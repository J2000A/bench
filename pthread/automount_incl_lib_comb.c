/* Generated by CIL v. 1.3.5 */
/* print_CIL_Input is true */

#line 214 "/usr/lib/gcc/i486-linux-gnu/4.1.3/include/stddef.h"
typedef unsigned int size_t;
#line 59 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 60 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 137 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 143 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 144 "/usr/include/bits/types.h"
typedef long __off_t;
#line 145 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 146 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 147 "/usr/include/bits/types.h"
struct __anonstruct___fsid_t_1 {
   int __val[2] ;
};
#line 147 "/usr/include/bits/types.h"
typedef struct __anonstruct___fsid_t_1 __fsid_t;
#line 149 "/usr/include/bits/types.h"
typedef unsigned long __rlim_t;
#line 152 "/usr/include/bits/types.h"
typedef long __time_t;
#line 167 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 172 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 176 "/usr/include/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 180 "/usr/include/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 183 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 35 "/usr/include/dirent.h"
typedef __ino_t ino_t;
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 62 "/usr/include/sys/types.h"
typedef __dev_t dev_t;
#line 67 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 72 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 82 "/usr/include/sys/types.h"
typedef __uid_t uid_t;
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 77 "/usr/include/time.h"
typedef __time_t time_t;
#line 29 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_3 {
   unsigned long __val[(int )(1024U / (8U * sizeof(unsigned long )))] ;
};
#line 29 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_3 __sigset_t;
#line 38 "/usr/include/sys/select.h"
typedef __sigset_t sigset_t;
#line 121 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 36 "/usr/include/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 39 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_attr_t_5 {
   char __size[36] ;
   long __align ;
};
#line 39 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_attr_t_5 pthread_attr_t;
#line 46 "/usr/include/bits/pthreadtypes.h"
struct __pthread_internal_slist {
   struct __pthread_internal_slist *__next ;
};
#line 46 "/usr/include/bits/pthreadtypes.h"
typedef struct __pthread_internal_slist __pthread_slist_t;
#line 54 "/usr/include/bits/pthreadtypes.h"
union __anonunion____missing_field_name_7 {
   int __spins ;
   __pthread_slist_t __list ;
};
#line 54 "/usr/include/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   int __kind ;
   unsigned int __nusers ;
   union __anonunion____missing_field_name_7 __annonCompField1 ;
};
#line 54 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_6 {
   struct __pthread_mutex_s __data ;
   char __size[24] ;
   long __align ;
};
#line 54 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_6 pthread_mutex_t;
#line 84 "/usr/include/bits/pthreadtypes.h"
struct __anonstruct___data_10 {
   int __lock ;
   unsigned int __futex ;
   unsigned long long __total_seq ;
   unsigned long long __wakeup_seq ;
   unsigned long long __woken_seq ;
   void *__mutex ;
   unsigned int __nwaiters ;
   unsigned int __broadcast_seq ;
};
#line 84 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_cond_t_9 {
   struct __anonstruct___data_10 __data ;
   char __size[48] ;
   long long __align ;
};
#line 84 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_cond_t_9 pthread_cond_t;
#line 109 "/usr/include/bits/pthreadtypes.h"
typedef unsigned int pthread_key_t;
#line 119 "/usr/include/bits/pthreadtypes.h"
struct __anonstruct___data_13 {
   int __lock ;
   unsigned int __nr_readers ;
   unsigned int __readers_wakeup ;
   unsigned int __writer_wakeup ;
   unsigned int __nr_readers_queued ;
   unsigned int __nr_writers_queued ;
   unsigned int __flags ;
   int __writer ;
};
#line 119 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_rwlock_t_12 {
   struct __anonstruct___data_13 __data ;
   char __size[32] ;
   long __align ;
};
#line 119 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_rwlock_t_12 pthread_rwlock_t;
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 106 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 177 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 183 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 268 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(int )((15U * sizeof(int ) - 4U * sizeof(void *)) - sizeof(size_t ))] ;
};
#line 33 "/usr/include/bits/resource.h"
enum __rlimit_resource {
    RLIMIT_CPU = 0,
    RLIMIT_FSIZE = 1,
    RLIMIT_DATA = 2,
    RLIMIT_STACK = 3,
    RLIMIT_CORE = 4,
    __RLIMIT_RSS = 5,
    RLIMIT_NOFILE = 7,
    __RLIMIT_OFILE = 7,
    RLIMIT_AS = 9,
    __RLIMIT_NPROC = 6,
    __RLIMIT_MEMLOCK = 8,
    __RLIMIT_LOCKS = 10,
    __RLIMIT_SIGPENDING = 11,
    __RLIMIT_MSGQUEUE = 12,
    __RLIMIT_NICE = 13,
    __RLIMIT_RTPRIO = 14,
    __RLIMIT_NLIMITS = 15,
    __RLIM_NLIMITS = 15
} ;
#line 127 "/usr/include/bits/resource.h"
typedef __rlim_t rlim_t;
#line 135 "/usr/include/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 39 "/usr/include/sys/resource.h"
typedef enum __rlimit_resource __rlimit_resource_t;
#line 37 "/usr/include/sys/poll.h"
typedef unsigned long nfds_t;
#line 40 "/usr/include/sys/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 25 "/usr/include/bits/statfs.h"
struct statfs {
   int f_type ;
   int f_bsize ;
   __fsblkcnt_t f_blocks ;
   __fsblkcnt_t f_bfree ;
   __fsblkcnt_t f_bavail ;
   __fsfilcnt_t f_files ;
   __fsfilcnt_t f_ffree ;
   __fsid_t f_fsid ;
   int f_namelen ;
   int f_frsize ;
   int f_spare[5] ;
};
#line 49 "/usr/include/sys/utsname.h"
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char domainname[65] ;
};
#line 20 "/usr/include/asm-i386/types.h"
typedef unsigned int __u32;
#line 24 "/usr/include/asm-i386/types.h"
typedef unsigned long long __u64;
#line 29 "/usr/include/bits/setjmp.h"
typedef int __jmp_buf[6];
#line 492 "/usr/include/pthread.h"
struct __anonstruct___cancel_jmp_buf_73 {
   __jmp_buf __cancel_jmp_buf ;
   int __mask_was_saved ;
};
#line 492 "/usr/include/pthread.h"
struct __anonstruct___pthread_unwind_buf_t_72 {
   struct __anonstruct___cancel_jmp_buf_73 __cancel_jmp_buf[1] ;
   void *__pad[4] ;
};
#line 492 "/usr/include/pthread.h"
typedef struct __anonstruct___pthread_unwind_buf_t_72  __attribute__((__aligned__)) __pthread_unwind_buf_t;
#line 709
struct __jmp_buf_tag;
#line 14 "../include/list.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 51 "../include/linux/auto_fs.h"
typedef unsigned long autofs_wqt_t;
#line 58 "../include/linux/auto_fs.h"
struct autofs_packet_hdr {
   int proto_version ;
   int type ;
};
#line 64 "../include/linux/auto_fs.h"
struct autofs_packet_missing {
   struct autofs_packet_hdr hdr ;
   autofs_wqt_t wait_queue_token ;
   int len ;
   char name[256] ;
};
#line 72 "../include/linux/auto_fs.h"
struct autofs_packet_expire {
   struct autofs_packet_hdr hdr ;
   int len ;
   char name[256] ;
};
#line 55 "../include/linux/auto_fs4.h"
struct autofs_packet_expire_multi {
   struct autofs_packet_hdr hdr ;
   autofs_wqt_t wait_queue_token ;
   int len ;
   char name[256] ;
};
#line 63 "../include/linux/auto_fs4.h"
struct autofs_v5_packet {
   struct autofs_packet_hdr hdr ;
   autofs_wqt_t wait_queue_token ;
   __u32 dev ;
   __u64 ino ;
   __u32 uid ;
   __u32 gid ;
   __u32 pid ;
   __u32 tgid ;
   __u32 len ;
   char name[256] ;
};
#line 76 "../include/linux/auto_fs4.h"
typedef struct autofs_v5_packet autofs_packet_missing_indirect_t;
#line 77 "../include/linux/auto_fs4.h"
typedef struct autofs_v5_packet autofs_packet_expire_indirect_t;
#line 78 "../include/linux/auto_fs4.h"
typedef struct autofs_v5_packet autofs_packet_missing_direct_t;
#line 79 "../include/linux/auto_fs4.h"
typedef struct autofs_v5_packet autofs_packet_expire_direct_t;
#line 81 "../include/linux/auto_fs4.h"
union autofs_packet_union {
   struct autofs_packet_hdr hdr ;
   struct autofs_packet_missing missing ;
   struct autofs_packet_expire expire ;
   struct autofs_packet_expire_multi expire_multi ;
   struct autofs_v5_packet v5_packet ;
};
#line 40 "../include/state.h"
enum states {
    ST_INVAL = -1,
    ST_INIT = 0,
    ST_READY = 1,
    ST_EXPIRE = 2,
    ST_PRUNE = 3,
    ST_READMAP = 4,
    ST_SHUTDOWN_PENDING = 5,
    ST_SHUTDOWN_FORCE = 6,
    ST_SHUTDOWN = 7
} ;
#line 52
struct autofs_point;
#line 27 "../include/master.h"
struct mapent_cache;
#line 27
struct lookup_mod;
#line 27 "../include/master.h"
struct map_source {
   char *type ;
   char *format ;
   time_t age ;
   unsigned int master_line ;
   struct mapent_cache *mc ;
   unsigned int stale ;
   unsigned int recurse ;
   unsigned int depth ;
   struct lookup_mod *lookup ;
   int argc ;
   char const   **argv ;
   struct map_source *instance ;
   struct map_source *next ;
};
#line 43
struct master;
#line 43 "../include/master.h"
struct master_mapent {
   char *path ;
   pthread_t thid ;
   time_t age ;
   struct master *master ;
   pthread_rwlock_t source_lock ;
   pthread_mutex_t current_mutex ;
   pthread_cond_t current_cond ;
   struct map_source *current ;
   struct map_source *maps ;
   struct autofs_point *ap ;
   struct list_head list ;
};
#line 57 "../include/master.h"
struct master {
   char *name ;
   unsigned int recurse ;
   unsigned int depth ;
   unsigned int reading ;
   unsigned int default_ghost ;
   unsigned int default_logging ;
   unsigned int default_timeout ;
   struct mapent_cache *nc ;
   struct list_head mounts ;
};
#line 21 "../include/parse_subs.h"
struct mapent;
#line 129 "../include/automount.h"
struct mapent_cache {
   pthread_rwlock_t rwlock ;
   unsigned int size ;
   pthread_mutex_t ino_index_mutex ;
   struct list_head *ino_index ;
   struct map_source *map ;
   struct mapent **hash ;
};
#line 138 "../include/automount.h"
struct mapent {
   struct mapent *next ;
   struct list_head ino_index ;
   pthread_mutex_t multi_mutex ;
   struct list_head multi_list ;
   struct mapent_cache *mc ;
   struct map_source *source ;
   struct mapent *multi ;
   struct mapent *parent ;
   char *key ;
   char *mapent ;
   time_t age ;
   time_t status ;
   int dir_created ;
   int ioctlfd ;
   dev_t dev ;
   ino_t ino ;
};
#line 249 "../include/automount.h"
struct lookup_mod {
   int (*lookup_init)(char const   * , int  , char const   * const  * , void ** ) ;
   int (*lookup_read_master)(struct master *master , time_t  , void * ) ;
   int (*lookup_read_map)(struct autofs_point * , time_t  , void * ) ;
   int (*lookup_mount)(struct autofs_point * , char const   * , int  , void * ) ;
   int (*lookup_done)(void * ) ;
   void *dlhandle ;
   void *context ;
};
#line 381 "../include/automount.h"
struct startup_cond {
   pthread_mutex_t mutex ;
   pthread_cond_t cond ;
   unsigned int done ;
   unsigned int status ;
};
#line 388 "../include/automount.h"
struct master_readmap_cond {
   pthread_mutex_t mutex ;
   pthread_cond_t cond ;
   pthread_t thid ;
   struct master *master ;
   time_t age ;
   enum states state ;
   unsigned int signaled ;
   unsigned int busy ;
};
#line 416 "../include/automount.h"
struct thread_stdenv_vars {
   uid_t uid ;
   gid_t gid ;
   char *user ;
   char *group ;
   char *home ;
};
#line 431 "../include/automount.h"
struct autofs_point {
   pthread_t thid ;
   char *path ;
   int pipefd ;
   int kpipefd ;
   int ioctlfd ;
   dev_t dev ;
   struct master_mapent *entry ;
   unsigned int type ;
   time_t exp_timeout ;
   time_t exp_runfreq ;
   unsigned int ghost ;
   unsigned int logopt ;
   pthread_t exp_thread ;
   pthread_t readmap_thread ;
   pthread_mutex_t state_mutex ;
   enum states state ;
   int state_pipe[2] ;
   unsigned int dir_created ;
   struct autofs_point *parent ;
   pthread_mutex_t mounts_mutex ;
   pthread_cond_t mounts_cond ;
   unsigned int mounts_signaled ;
   struct list_head mounts ;
   unsigned int submount ;
   unsigned int submnt_count ;
   struct list_head submounts ;
};
#line 329 "automount.c"
struct counter_args {
   unsigned int count ;
   dev_t dev ;
};
#line 101 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_condattr_t_11 {
   char __size[4] ;
   long __align ;
};
#line 101 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_condattr_t_11 pthread_condattr_t;
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 43 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 52 "../include/state.h"
struct expire_args {
   pthread_mutex_t mutex ;
   pthread_cond_t cond ;
   unsigned int signaled ;
   struct autofs_point *ap ;
   enum states state ;
   unsigned int when ;
   int status ;
};
#line 37 "../include/log.h"
typedef void logger(unsigned int logopt , char const   *msg  , ...);
#line 328 "../include/automount.h"
struct mnt_list {
   char *path ;
   char *fs_name ;
   char *fs_type ;
   char *opts ;
   pid_t owner ;
   struct mnt_list *next ;
   struct mnt_list *left ;
   struct mnt_list *right ;
   struct list_head self ;
   struct list_head list ;
   struct list_head entries ;
   struct list_head sublist ;
   struct list_head ordered ;
};
#line 399 "../include/automount.h"
struct pending_args {
   pthread_mutex_t mutex ;
   pthread_cond_t cond ;
   unsigned int signaled ;
   struct autofs_point *ap ;
   int status ;
   int type ;
   int ioctlfd ;
   struct mapent_cache *mc ;
   char name[255] ;
   dev_t dev ;
   unsigned int len ;
   uid_t uid ;
   gid_t gid ;
   unsigned long wait_queue_token ;
};
#line 113 "/usr/include/bits/pthreadtypes.h"
//typedef int pthread_once_t;
#line 45 "direct.c"
struct mnt_params {
   char *options ;
};
#line 148 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 33 "/usr/include/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 33 "/usr/include/bits/siginfo.h"
typedef union sigval sigval_t;
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__kill_17 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__timer_18 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__rt_19 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigchld_20 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigfault_21 {
   void *si_addr ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigpoll_22 {
   long si_band ;
   int si_fd ;
};
#line 51 "/usr/include/bits/siginfo.h"
union __anonunion__sifields_16 {
   int _pad[(int )(128U / sizeof(int ) - 3U)] ;
   struct __anonstruct__kill_17 _kill ;
   struct __anonstruct__timer_18 _timer ;
   struct __anonstruct__rt_19 _rt ;
   struct __anonstruct__sigchld_20 _sigchld ;
   struct __anonstruct__sigfault_21 _sigfault ;
   struct __anonstruct__sigpoll_22 _sigpoll ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_16 _sifields ;
};
#line 51 "/usr/include/bits/siginfo.h"
typedef struct siginfo siginfo_t;
#line 25 "/usr/include/bits/sigaction.h"
union __anonunion___sigaction_handler_34 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 25 "/usr/include/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_34 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 43 "/usr/lib/gcc/i486-linux-gnu/4.1.3/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 105 "/usr/lib/gcc/i486-linux-gnu/4.1.3/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 277 "../include/automount.h"
struct parse_mod {
   int (*parse_init)(int  , char const   * const  * , void ** ) ;
   int (*parse_mount)(struct autofs_point * , char const   * , int  , char const   * ,
                      void * ) ;
   int (*parse_done)(void * ) ;
   void *dlhandle ;
   void *context ;
};
#line 304 "../include/automount.h"
struct mount_mod {
   int (*mount_init)(void ** ) ;
   int (*mount_mount)(struct autofs_point * , char const   * , char const   * , int  ,
                      char const   * , char const   * , char const   * , void * ) ;
   int (*mount_done)(void * ) ;
   void *dlhandle ;
   void *context ;
};
#line 29 "../include/nsswitch.h"
enum nsswitch_status {
    NSS_STATUS_UNKNOWN = -1,
    NSS_STATUS_SUCCESS = 0,
    NSS_STATUS_NOTFOUND = 1,
    NSS_STATUS_UNAVAIL = 2,
    NSS_STATUS_TRYAGAIN = 3,
    NSS_STATUS_MAX = 4
} ;
#line 41
enum nsswitch_action {
    NSS_ACTION_UNKNOWN = 0,
    NSS_ACTION_CONTINUE = 1,
    NSS_ACTION_RETURN = 2
} ;
#line 47 "../include/nsswitch.h"
struct nss_action {
   enum nsswitch_action action ;
   int negated ;
};
#line 52 "../include/nsswitch.h"
struct nss_source {
   char *source ;
   struct nss_action action[4] ;
   struct list_head list ;
};
#line 75 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_7 {
   char __size[4] ;
   long __align ;
};
#line 75 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_7 pthread_mutexattr_t;
#line 76 "../include/state.h"
struct readmap_args {
   pthread_mutex_t mutex ;
   pthread_cond_t cond ;
   unsigned int signaled ;
   struct autofs_point *ap ;
   time_t now ;
};
#line 21 "state.c"
struct state_queue {
   pthread_t thid ;
   struct list_head list ;
   struct list_head pending ;
   struct autofs_point *ap ;
   enum states state ;
   unsigned int busy ;
   unsigned int done ;
   unsigned int cancel ;
};
#line 213
enum expire {
    EXP_ERROR = 0,
    EXP_STARTED = 1,
    EXP_PARTIAL = 2
} ;
#line 18 "alarm.c"
struct alarm {
   time_t time ;
   unsigned int cancel ;
   struct autofs_point *ap ;
   struct list_head list ;
};
#line 138 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_rwlockattr_t_28 {
   char __size[8] ;
   long __align ;
};
#line 138 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_rwlockattr_t_28 pthread_rwlockattr_t;
#line 182 "cache.c"
struct entry;
#line 21 "../include/macros.h"
struct substvar {
   char *def ;
   char *val ;
   unsigned int readonly ;
   struct substvar *next ;
};
#line 102 "master_parse.y"
union YYSTYPE {
   char strtype[2048] ;
   int inttype ;
   long longtype ;
};
#line 102 "master_parse.y"
typedef union YYSTYPE YYSTYPE;
#line 265 "master_parse.tab.c"
typedef unsigned char yytype_uint8;
#line 272 "master_parse.tab.c"
typedef signed char yytype_int8;
#line 286 "master_parse.tab.c"
typedef short yytype_int16;
#line 417 "master_parse.tab.c"
union yyalloc {
   yytype_int16 yyss ;
   YYSTYPE yyvs ;
};
#line 52 "master_tok.c"
typedef short flex_int16_t;
#line 53 "master_tok.c"
typedef int flex_int32_t;
#line 152
struct yy_buffer_state;
#line 152 "master_tok.c"
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#line 188 "master_tok.c"
typedef unsigned int yy_size_t;
#line 193 "master_tok.c"
struct yy_buffer_state {
   FILE *yy_input_file ;
   char *yy_ch_buf ;
   char *yy_buf_pos ;
   yy_size_t yy_buf_size ;
   int yy_n_chars ;
   int yy_is_our_buffer ;
   int yy_is_interactive ;
   int yy_at_bol ;
   int yy_bs_lineno ;
   int yy_bs_column ;
   int yy_fill_buffer ;
   int yy_buffer_status ;
};
#line 339 "master_tok.c"
typedef unsigned char YY_CHAR;
#line 343 "master_tok.c"
typedef int yy_state_type;
#line 34 "/usr/include/bits/types.h"
typedef unsigned char __u_char;
#line 36 "/usr/include/bits/types.h"
typedef unsigned int __u_int;
#line 37 "/usr/include/bits/types.h"
typedef unsigned long __u_long;
#line 154 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 189 "/usr/include/bits/types.h"
typedef char *__caddr_t;
#line 36 "/usr/include/rpc/types.h"
typedef int bool_t;
#line 37 "/usr/include/rpc/types.h"
typedef int enum_t;
#line 35 "/usr/include/sys/types.h"
typedef __u_char u_char;
#line 37 "/usr/include/sys/types.h"
typedef __u_int u_int;
#line 38 "/usr/include/sys/types.h"
typedef __u_long u_long;
#line 117 "/usr/include/sys/types.h"
typedef __caddr_t caddr_t;
#line 197 "/usr/include/sys/types.h"
typedef int int32_t;
#line 203 "/usr/include/sys/types.h"
typedef unsigned int u_int32_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 83 "/usr/include/rpc/xdr.h"
enum xdr_op {
    XDR_ENCODE = 0,
    XDR_DECODE = 1,
    XDR_FREE = 2
} ;
#line 111
struct XDR;
#line 111 "/usr/include/rpc/xdr.h"
typedef struct XDR XDR;
#line 112 "/usr/include/rpc/xdr.h"
struct xdr_ops {
   bool_t (*x_getlong)(XDR *__xdrs , long *__lp ) ;
   bool_t (*x_putlong)(XDR *__xdrs , long const   *__lp ) ;
   bool_t (*x_getbytes)(XDR *__xdrs , caddr_t __addr , u_int __len ) ;
   bool_t (*x_putbytes)(XDR *__xdrs , char const   *__addr , u_int __len ) ;
   u_int (*x_getpostn)(XDR const   *__xdrs ) ;
   bool_t (*x_setpostn)(XDR *__xdrs , u_int __pos ) ;
   int32_t *(*x_inline)(XDR *__xdrs , u_int __len ) ;
   void (*x_destroy)(XDR *__xdrs ) ;
   bool_t (*x_getint32)(XDR *__xdrs , int32_t *__ip ) ;
   bool_t (*x_putint32)(XDR *__xdrs , int32_t const   *__ip ) ;
};
#line 112 "/usr/include/rpc/xdr.h"
struct XDR {
   enum xdr_op x_op ;
   struct xdr_ops *x_ops ;
   caddr_t x_public ;
   caddr_t x_private ;
   caddr_t x_base ;
   u_int x_handy ;
};
#line 55 "/usr/include/rpc/auth.h"
enum auth_stat {
    AUTH_OK = 0,
    AUTH_BADCRED = 1,
    AUTH_REJECTEDCRED = 2,
    AUTH_BADVERF = 3,
    AUTH_REJECTEDVERF = 4,
    AUTH_TOOWEAK = 5,
    AUTH_INVALIDRESP = 6,
    AUTH_FAILED = 7
} ;
#line 72 "/usr/include/rpc/auth.h"
struct __anonstruct_key_39 {
   u_int32_t high ;
   u_int32_t low ;
};
#line 72 "/usr/include/rpc/auth.h"
union des_block {
   struct __anonstruct_key_39 key ;
   char c[8] ;
};
#line 85 "/usr/include/rpc/auth.h"
struct opaque_auth {
   enum_t oa_flavor ;
   caddr_t oa_base ;
   u_int oa_length ;
};
#line 94
struct AUTH;
#line 94 "/usr/include/rpc/auth.h"
typedef struct AUTH AUTH;
#line 95 "/usr/include/rpc/auth.h"
struct auth_ops {
   void (*ah_nextverf)(AUTH * ) ;
   int (*ah_marshal)(AUTH * , XDR * ) ;
   int (*ah_validate)(AUTH * , struct opaque_auth * ) ;
   int (*ah_refresh)(AUTH * ) ;
   void (*ah_destroy)(AUTH * ) ;
};
#line 95 "/usr/include/rpc/auth.h"
struct AUTH {
   struct opaque_auth ah_cred ;
   struct opaque_auth ah_verf ;
   union des_block ah_key ;
   struct auth_ops *ah_ops ;
   caddr_t ah_private ;
};
#line 53 "/usr/include/rpc/clnt.h"
enum clnt_stat {
    RPC_SUCCESS = 0,
    RPC_CANTENCODEARGS = 1,
    RPC_CANTDECODERES = 2,
    RPC_CANTSEND = 3,
    RPC_CANTRECV = 4,
    RPC_TIMEDOUT = 5,
    RPC_VERSMISMATCH = 6,
    RPC_AUTHERROR = 7,
    RPC_PROGUNAVAIL = 8,
    RPC_PROGVERSMISMATCH = 9,
    RPC_PROCUNAVAIL = 10,
    RPC_CANTDECODEARGS = 11,
    RPC_SYSTEMERROR = 12,
    RPC_NOBROADCAST = 21,
    RPC_UNKNOWNHOST = 13,
    RPC_UNKNOWNPROTO = 17,
    RPC_UNKNOWNADDR = 19,
    RPC_RPCBFAILURE = 14,
    RPC_PROGNOTREGISTERED = 15,
    RPC_N2AXLATEFAILURE = 22,
    RPC_FAILED = 16,
    RPC_INTR = 18,
    RPC_TLIERROR = 20,
    RPC_UDERROR = 23,
    RPC_INPROGRESS = 24,
    RPC_STALERACHANDLE = 25
} ;
#line 106 "/usr/include/rpc/clnt.h"
struct __anonstruct_RE_vers_41 {
   u_long low ;
   u_long high ;
};
#line 106 "/usr/include/rpc/clnt.h"
struct __anonstruct_RE_lb_42 {
   long s1 ;
   long s2 ;
};
#line 106 "/usr/include/rpc/clnt.h"
union __anonunion_ru_40 {
   int RE_errno ;
   enum auth_stat RE_why ;
   struct __anonstruct_RE_vers_41 RE_vers ;
   struct __anonstruct_RE_lb_42 RE_lb ;
};
#line 106 "/usr/include/rpc/clnt.h"
struct rpc_err {
   enum clnt_stat re_status ;
   union __anonunion_ru_40 ru ;
};
#line 132
struct CLIENT;
#line 132 "/usr/include/rpc/clnt.h"
typedef struct CLIENT CLIENT;
#line 133 "/usr/include/rpc/clnt.h"
struct clnt_ops {
   enum clnt_stat (*cl_call)(CLIENT * , u_long  , bool_t (*)(XDR * , void *  , ...) ,
                             caddr_t  , bool_t (*)(XDR * , void *  , ...) , caddr_t  ,
                             struct timeval  ) ;
   void (*cl_abort)(void) ;
   void (*cl_geterr)(CLIENT * , struct rpc_err * ) ;
   bool_t (*cl_freeres)(CLIENT * , bool_t (*)(XDR * , void *  , ...) , caddr_t  ) ;
   void (*cl_destroy)(CLIENT * ) ;
   bool_t (*cl_control)(CLIENT * , int  , char * ) ;
};
#line 133 "/usr/include/rpc/clnt.h"
struct CLIENT {
   AUTH *cl_auth ;
   struct clnt_ops *cl_ops ;
   caddr_t cl_private ;
};
#line 57 "mount.h"
typedef char fhandle[32];
#line 59 "mount.h"
union __anonunion_fhstatus_u_51 {
   fhandle fhs_fhandle ;
};
#line 59 "mount.h"
struct fhstatus {
   u_int fhs_status ;
   union __anonunion_fhstatus_u_51 fhstatus_u ;
};
#line 65 "mount.h"
typedef struct fhstatus fhstatus;
#line 67 "mount.h"
typedef char *dirpath;
#line 69 "mount.h"
typedef char *name;
#line 71
struct mountbody;
#line 71 "mount.h"
typedef struct mountbody *mountlist;
#line 73 "mount.h"
struct mountbody {
   name ml_hostname ;
   dirpath ml_directory ;
   mountlist ml_next ;
};
#line 80
struct groupnode;
#line 80 "mount.h"
typedef struct groupnode *groups;
#line 82 "mount.h"
struct groupnode {
   name gr_name ;
   groups gr_next ;
};
#line 88
struct exportnode;
#line 88 "mount.h"
typedef struct exportnode *exports;
#line 90 "mount.h"
struct exportnode {
   dirpath ex_dir ;
   groups ex_groups ;
   exports ex_next ;
};
#line 97 "mount.h"
struct ppathcnf {
   int pc_link_max ;
   short pc_max_canon ;
   short pc_max_input ;
   short pc_name_max ;
   short pc_path_max ;
   short pc_pipe_buf ;
   u_char pc_vdisable ;
   char pc_xxx ;
   short pc_mask[2] ;
};
#line 108 "mount.h"
typedef struct ppathcnf ppathcnf;
#line 111 "mount.h"
struct __anonstruct_fhandle3_52 {
   u_int fhandle3_len ;
   char *fhandle3_val ;
};
#line 111 "mount.h"
typedef struct __anonstruct_fhandle3_52 fhandle3;
#line 116
enum mountstat3 {
    MNT_OK = 0,
    MNT3ERR_PERM = 1,
    MNT3ERR_NOENT = 2,
    MNT3ERR_IO = 5,
    MNT3ERR_ACCES = 13,
    MNT3ERR_NOTDIR = 20,
    MNT3ERR_INVAL = 22,
    MNT3ERR_NAMETOOLONG = 63,
    MNT3ERR_NOTSUPP = 10004,
    MNT3ERR_SERVERFAULT = 10006
} ;
#line 128 "mount.h"
typedef enum mountstat3 mountstat3;
#line 130 "mount.h"
struct __anonstruct_auth_flavors_53 {
   u_int auth_flavors_len ;
   int *auth_flavors_val ;
};
#line 130 "mount.h"
struct mountres3_ok {
   fhandle3 fhandle ;
   struct __anonstruct_auth_flavors_53 auth_flavors ;
};
#line 137 "mount.h"
typedef struct mountres3_ok mountres3_ok;
#line 139 "mount.h"
union __anonunion_mountres3_u_54 {
   mountres3_ok mountinfo ;
};
#line 139 "mount.h"
struct mountres3 {
   mountstat3 fhs_status ;
   union __anonunion_mountres3_u_54 mountres3_u ;
};
#line 145 "mount.h"
typedef struct mountres3 mountres3;
#line 78 "mount.h"
typedef struct mountbody mountbody;
#line 86 "mount.h"
typedef struct groupnode groupnode;
#line 95 "mount.h"
typedef struct exportnode exportnode;
#line 54 "/usr/include/mntent.h"
struct mntent {
   char *mnt_fsname ;
   char *mnt_dir ;
   char *mnt_type ;
   char *mnt_opts ;
   int mnt_freq ;
   int mnt_passno ;
};
#line 426 "../include/automount.h"
struct kernel_mod_version {
   unsigned int major ;
   unsigned int minor ;
};
#line 68 "nss_parse.tab.h"
union YYSTYPE___0 {
   char strval[128] ;
};
#line 68 "nss_parse.tab.h"
typedef union YYSTYPE___0 YYSTYPE___0;
#line 359 "nss_parse.tab.c"
union yyalloc___0 {
   yytype_int16 yyss ;
   YYSTYPE___0 yyvs ;
};
#line 338 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 35 "/usr/include/bits/types.h"
typedef unsigned short __u_short;
#line 195 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 36 "/usr/include/sys/types.h"
typedef __u_short u_short;
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_9 {
   __fd_mask fds_bits[(int )(1024U / (8U * sizeof(__fd_mask )))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_9 fd_set;
#line 57 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 63 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 37 "/usr/include/bits/socket.h"
typedef __socklen_t socklen_t;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 146 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 315 "/usr/include/bits/socket.h"
struct linger {
   int l_onoff ;
   int l_linger ;
};
#line 87 "/usr/include/sys/socket.h"
struct sockaddr_in;
#line 87
struct sockaddr_in6;
#line 92 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 136 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 137 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 193 "/usr/include/netinet/in.h"
union __anonunion_in6_u_29 {
   uint8_t u6_addr8[16] ;
   uint16_t u6_addr16[8] ;
   uint32_t u6_addr32[4] ;
};
#line 193 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion_in6_u_29 in6_u ;
};
#line 219 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[(int )(((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr ))] ;
};
#line 233 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 90 "/usr/include/rpc/pmap_prot.h"
struct pmap {
   unsigned long pm_prog ;
   unsigned long pm_vers ;
   unsigned long pm_prot ;
   unsigned long pm_port ;
};
#line 27 "/usr/include/bits/netdb.h"
struct netent {
   char *n_name ;
   char **n_aliases ;
   int n_addrtype ;
   uint32_t n_net ;
};
#line 96 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 321 "/usr/include/netdb.h"
struct protoent {
   char *p_name ;
   char **p_aliases ;
   int p_proto ;
};
#line 538 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 112 "/usr/include/net/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 127 "/usr/include/net/if.h"
union __anonunion_ifr_ifrn_59 {
   char ifrn_name[16] ;
};
#line 127 "/usr/include/net/if.h"
union __anonunion_ifr_ifru_60 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
#line 127 "/usr/include/net/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_59 ifr_ifrn ;
   union __anonunion_ifr_ifru_60 ifr_ifru ;
};
#line 177 "/usr/include/net/if.h"
union __anonunion_ifc_ifcu_61 {
   __caddr_t ifcu_buf ;
   struct ifreq *ifcu_req ;
};
#line 177 "/usr/include/net/if.h"
struct ifconf {
   int ifc_len ;
   union __anonunion_ifc_ifcu_61 ifc_ifcu ;
};
#line 47 "../include/rpc_subs.h"
struct conn_info {
   char const   *host ;
   unsigned short port ;
   unsigned long program ;
   unsigned long version ;
   struct protoent *proto ;
   unsigned int send_sz ;
   unsigned int recv_sz ;
   struct timeval timeout ;
   unsigned int close_option ;
   CLIENT *client ;
};
#line 1 "cil-khBvcyWB.o"
#pragma merger(0,"/tmp/cil-DlBa1C3g.i","")
#line 1 "automount.o"
#pragma merger(0,"/tmp/cil-MnezGtJu.i","-O2,-Wall,-fPIE")
#line 135 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 150
extern int closedir(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
#line 184
extern int readdir_r(DIR * __restrict  __dirp , struct dirent * __restrict  __entry ,
                     struct dirent ** __restrict  __result )  __attribute__((__nonnull__(1,2,3))) ;
#line 250
extern int scandir(char const   * __restrict  __dir , struct dirent *** __restrict  __namelist ,
                   int (*__selector)(struct dirent  const  * ) , int (*__cmp)(void const   * ,
                                                                              void const   * ) )  __attribute__((__nonnull__(1,2))) ;
#line 280
extern  __attribute__((__nothrow__)) int alphasort(void const   *__e1 , void const   *__e2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 318 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int mkdir(char const   *__path , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 399
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
#line 401
extern  __attribute__((__nothrow__)) int __lxstat(int __ver , char const   *__filename ,
                                                  struct stat *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
#line 450
__inline static  __attribute__((__nothrow__)) int stat__extinline(char const   *__path ,
                                                                  struct stat *__statbuf ) ;
#line 450
__inline static  __attribute__((__nothrow__)) int stat__extinline(char const   *__path ,
                                                                  struct stat *__statbuf ) ;
#line 450 "/usr/include/sys/stat.h"
__inline static int stat__extinline(char const   *__path , struct stat *__statbuf ) 
{ int tmp ;

  {
#line 453
  tmp = __xstat(3, __path, __statbuf);
#line 453
  return (tmp);
}
}
#line 457
__inline static  __attribute__((__nothrow__)) int lstat__extinline(char const   *__path ,
                                                                   struct stat *__statbuf ) ;
#line 457
__inline static  __attribute__((__nothrow__)) int lstat__extinline(char const   *__path ,
                                                                   struct stat *__statbuf ) ;
#line 457 "/usr/include/sys/stat.h"
__inline static int lstat__extinline(char const   *__path , struct stat *__statbuf ) 
{ int tmp ;

  {
#line 460
  tmp = __lxstat(3, __path, __statbuf);
#line 460
  return (tmp);
}
}
#line 59 "/usr/include/getopt.h"
extern char *optarg ;
#line 73
extern int optind ;
#line 78
extern int opterr ;
#line 159
extern  __attribute__((__nothrow__)) int getopt_long(int ___argc , char * const  *___argv ,
                                                     char const   *__shortopts , struct option  const  *__longopts ,
                                                     int *__longind ) ;
#line 117 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 219
extern  __attribute__((__nothrow__)) int sigfillset(sigset_t *__set )  __attribute__((__nonnull__(1))) ;
#line 225
extern  __attribute__((__nothrow__)) int sigdelset(sigset_t *__set , int __signo )  __attribute__((__nonnull__(1))) ;
#line 249
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t const   * __restrict  __set ,
                                                     sigset_t * __restrict  __oset ) ;
#line 271
extern int sigwait(sigset_t const   * __restrict  __set , int * __restrict  __sig )  __attribute__((__nonnull__(1,2))) ;
#line 147 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 214
extern int fclose(FILE *__stream ) ;
#line 249
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 331
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 337
extern int printf(char const   * __restrict  __format  , ...) ;
#line 339
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 361
extern  __attribute__((__nothrow__)) int snprintf(char * __restrict  __s , size_t __maxlen ,
                                                  char const   * __restrict  __format 
                                                  , ...) ;
#line 445
extern int fgetc(FILE *__stream ) ;
#line 290 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   * __restrict  __nptr ,
                                                            char ** __restrict  __endptr ,
                                                            int __base , int __group )  __attribute__((__nonnull__(1))) ;
#line 297
extern  __attribute__((__nothrow__)) unsigned long __strtoul_internal(char const   * __restrict  __nptr ,
                                                                      char ** __restrict  __endptr ,
                                                                      int __base ,
                                                                      int __group )  __attribute__((__nonnull__(1))) ;
#line 332
__inline static  __attribute__((__nothrow__)) long strtol__extinline(char const   * __restrict  __nptr ,
                                                                     char ** __restrict  __endptr ,
                                                                     int __base ) ;
#line 332
__inline static  __attribute__((__nothrow__)) long strtol__extinline(char const   * __restrict  __nptr ,
                                                                     char ** __restrict  __endptr ,
                                                                     int __base ) ;
#line 332 "/usr/include/stdlib.h"
__inline static long strtol__extinline(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                       int __base ) 
{ long tmp ;

  {
#line 336
  tmp = __strtol_internal(__nptr, __endptr, __base, 0);
#line 336
  return (tmp);
}
}
#line 338
__inline static  __attribute__((__nothrow__)) unsigned long strtoul__extinline(char const   * __restrict  __nptr ,
                                                                               char ** __restrict  __endptr ,
                                                                               int __base ) ;
#line 338
__inline static  __attribute__((__nothrow__)) unsigned long strtoul__extinline(char const   * __restrict  __nptr ,
                                                                               char ** __restrict  __endptr ,
                                                                               int __base ) ;
#line 338 "/usr/include/stdlib.h"
__inline static unsigned long strtoul__extinline(char const   * __restrict  __nptr ,
                                                 char ** __restrict  __endptr , int __base ) 
{ unsigned long tmp ;

  {
#line 342
  tmp = __strtoul_internal(__nptr, __endptr, __base, 0);
#line 342
  return (tmp);
}
}
#line 401
__inline static  __attribute__((__nothrow__)) int atoi__extinline(char const   *__nptr ) ;
#line 401
__inline static  __attribute__((__nothrow__)) int atoi__extinline(char const   *__nptr ) ;
#line 401 "/usr/include/stdlib.h"
__inline static int atoi__extinline(char const   *__nptr ) 
{ int tmp ;

  {
#line 404
  tmp = (int )strtol__extinline((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                                10);
#line 404
  return (tmp);
}
}
#line 498
extern  __attribute__((__nothrow__)) int rand(void) ;
#line 603
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 628
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 646
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 38 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                                                  size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 59
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n )  __attribute__((__nonnull__(1))) ;
#line 84
extern  __attribute__((__nothrow__)) char *strcpy(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
#line 92
extern  __attribute__((__nothrow__)) char *strcat(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
#line 170
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 194
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 242
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 281
extern  __attribute__((__nothrow__)) char *strerror_r(int __errnum , char *__buf ,
                                                      size_t __buflen )  __attribute__((__nonnull__(2))) ;
#line 1304 "/usr/include/bits/string2.h"
extern  __attribute__((__nothrow__)) char *__strdup(char const   *__string )  __attribute__((__malloc__)) ;
#line 320 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 327
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 333
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 384
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 457
extern  __attribute__((__nothrow__)) int chdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 573
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 634
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 645
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 723
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 792
extern  __attribute__((__nothrow__)) int unlink(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 801
extern  __attribute__((__nothrow__)) int rmdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 51 "/usr/include/asm-generic/ioctl.h"
extern unsigned int __invalid_size_argument_for_IOC ;
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 81 "/usr/include/ctype.h"
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 70 "/usr/include/sys/resource.h"
extern  __attribute__((__nothrow__)) int setrlimit(__rlimit_resource_t __resource ,
                                                   struct rlimit  const  *__rlimits ) ;
#line 58 "/usr/include/sys/poll.h"
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
#line 32 "/usr/include/sys/statfs.h"
extern  __attribute__((__nothrow__)) int statfs(char const   *__file , struct statfs *__buf )  __attribute__((__nonnull__(1,2))) ;
#line 82 "/usr/include/sys/utsname.h"
extern  __attribute__((__nothrow__)) int uname(struct utsname *__name ) ;
#line 187 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 184 "../include/syslog.h"
extern void closelog(void) ;
#line 54 "/usr/include/sched.h"
extern  __attribute__((__nothrow__)) int sched_yield(void) ;
#line 222 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int pthread_create(pthread_t * __restrict  __newthread ,
                                                        pthread_attr_t const   * __restrict  __attr ,
                                                        void *(*__start_routine)(void * ) ,
                                                        void * __restrict  __arg )  __attribute__((__nonnull__(1,3))) ;
#line 231
extern  __attribute__((__noreturn__)) void pthread_exit(void *__retval ) ;
#line 275
extern  __attribute__((__nothrow__)) int pthread_attr_init(pthread_attr_t *__attr )  __attribute__((__nonnull__(1))) ;
#line 287
extern  __attribute__((__nothrow__)) int pthread_attr_setdetachstate(pthread_attr_t *__attr ,
                                                                     int __detachstate )  __attribute__((__nonnull__(1))) ;
#line 364
extern  __attribute__((__nothrow__)) int pthread_attr_setstacksize(pthread_attr_t *__attr ,
                                                                   size_t __stacksize )  __attribute__((__nonnull__(1))) ;
#line 475
extern int pthread_setcancelstate(int __state , int *__oldstate ) ;
#line 649
extern void ( __attribute__((__regparm__(1))) __pthread_register_cancel)(__pthread_unwind_buf_t *__buf ) ;
#line 660
extern void ( __attribute__((__regparm__(1))) __pthread_unregister_cancel)(__pthread_unwind_buf_t *__buf ) ;
#line 700
extern  __attribute__((__noreturn__)) void ( __attribute__((__regparm__(1))) __pthread_unwind_next)(__pthread_unwind_buf_t *__buf )  __attribute__((__weak__)) ;
#line 710
extern  __attribute__((__nothrow__)) int __sigsetjmp(struct __jmp_buf_tag *__env ,
                                                     int __savemask ) ;
#line 725
extern  __attribute__((__nothrow__)) int pthread_mutex_trylock(pthread_mutex_t *__mutex )  __attribute__((__nonnull__(1))) ;
#line 729
extern  __attribute__((__nothrow__)) int pthread_mutex_lock(pthread_mutex_t *__mutex )  __attribute__((__nonnull__(1))) ;
#line 740
extern  __attribute__((__nothrow__)) int pthread_mutex_unlock(pthread_mutex_t *__mutex )  __attribute__((__nonnull__(1))) ;
#line 932
extern  __attribute__((__nothrow__)) int pthread_cond_signal(pthread_cond_t *__cond )  __attribute__((__nonnull__(1))) ;
#line 944
extern int pthread_cond_wait(pthread_cond_t * __restrict  __cond , pthread_mutex_t * __restrict  __mutex )  __attribute__((__nonnull__(1,2))) ;
#line 1066
extern  __attribute__((__nothrow__)) int pthread_key_create(pthread_key_t *__key ,
                                                            void (*__destr_function)(void * ) )  __attribute__((__nonnull__(1))) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 40 "../include/defaults.h"
unsigned int defaults_read_config(void) ;
#line 42
unsigned int defaults_get_timeout(void) ;
#line 43
unsigned int defaults_get_browse_mode(void) ;
#line 44
unsigned int defaults_get_logging(void) ;
#line 86 "../include/state.h"
void nextstate(int statefd , enum states next ) ;
#line 88
int st_add_task(struct autofs_point *ap , enum states state ) ;
#line 89
void st_remove_tasks(struct autofs_point *ap ) ;
#line 90
int st_start_handler(void) ;
#line 91 "../include/master.h"
void master_source_readlock(struct master_mapent *entry ) ;
#line 93
void master_source_lock_cleanup(void *arg ) ;
#line 99
void master_remove_mapent(struct master_mapent *entry ) ;
#line 100
void master_free_mapent_sources(struct master_mapent *entry , unsigned int free_cache ) ;
#line 101
void master_free_mapent(struct master_mapent *entry ) ;
#line 102
struct master *master_new(char const   *name___0 , unsigned int timeout___1 , unsigned int ghost___1 ) ;
#line 103
int master_read_master(struct master *master , time_t age , int readall ) ;
#line 106
void master_signal_submount(struct autofs_point *ap , unsigned int join ) ;
#line 107
void master_notify_state_change(struct master *master , int sig ) ;
#line 109
int master_list_empty(struct master *master ) ;
#line 110
int master_kill(struct master *master ) ;
#line 31 "../include/macros.h"
int macro_parse_globalvar(char const   *define ) ;
#line 30 "../include/log.h"
void set_log_verbose(void) ;
#line 31
void set_log_debug(void) ;
#line 34
void log_to_syslog(void) ;
#line 35
void log_to_stderr(void) ;
#line 39
void (*log_info)(unsigned int logopt , char const   *msg  , ...) ;
#line 41
void (*log_warn)(unsigned int logopt , char const   *msg  , ...) ;
#line 42
void (*log_error)(unsigned int logopt , char const   *msg  , ...) ;
#line 43
void (*log_crit)(unsigned int logopt , char const   *msg  , ...) ;
#line 44
void (*log_debug)(unsigned int logopt , char const   *msg  , ...) ;
#line 30 "../include/parse_subs.h"
int umount_ent(struct autofs_point *ap , char const   *path___1 ) ;
#line 32
int umount_multi_triggers(struct autofs_point *ap , char *root , struct mapent *me ,
                          char const   *base ) ;
#line 162 "../include/automount.h"
void cache_lock_cleanup(void *arg ) ;
#line 163
void cache_readlock(struct mapent_cache *mc ) ;
#line 165
int cache_try_writelock(struct mapent_cache *mc ) ;
#line 166
void cache_unlock(struct mapent_cache *mc ) ;
#line 176
struct mapent *cache_lookup_distinct(struct mapent_cache *mc , char const   *key ) ;
#line 183
int cache_delete(struct mapent_cache *mc , char const   *key ) ;
#line 184
void cache_multi_lock(struct mapent *me ) ;
#line 185
void cache_multi_unlock(struct mapent *me ) ;
#line 199
void dump_core(void) ;
#line 211
int mkdir_path(char const   *path___0 , mode_t mode ) ;
#line 212
int rmdir_path(struct autofs_point *ap , char const   *path___0 , dev_t dev ) ;
#line 230
void lookup_close_lookup(struct autofs_point *ap ) ;
#line 233
struct mapent *lookup_source_mapent(struct autofs_point *ap , char const   *key ,
                                    unsigned int type___0 ) ;
#line 318
int cat_path(char *buf , size_t len , char const   *dir , char const   *base ) ;
#line 319
int ncat_path(char *buf , size_t len , char const   *dir , char const   *base , size_t blen ) ;
#line 355
unsigned int query_kproto_ver(void) ;
#line 356
unsigned int get_kver_major(void) ;
#line 357
unsigned int get_kver_minor(void) ;
#line 363
int contained_in_local_fs(char const   *path___1 ) ;
#line 364
int is_mounted(char const   *table , char const   *path___1 , unsigned int type___1 ) ;
#line 424 "../include/automount.h"
pthread_key_t key_thread_stdenv_vars  ;
#line 462
void *handle_mounts(void *arg ) ;
#line 463
int umount_multi(struct autofs_point *ap , char const   *path___0 , int incl ) ;
#line 464
int send_ready(int ioctlfd , unsigned int wait_queue_token ) ;
#line 465
int send_fail(int ioctlfd , unsigned int wait_queue_token ) ;
#line 466
int do_expire(struct autofs_point *ap , char const   *name , int namelen ) ;
#line 470
int mount_autofs_indirect(struct autofs_point *ap ) ;
#line 471
int mount_autofs_direct(struct autofs_point *ap ) ;
#line 474
int umount_autofs(struct autofs_point *ap , int force ) ;
#line 475
int umount_autofs_indirect(struct autofs_point *ap ) ;
#line 477
int umount_autofs_direct(struct autofs_point *ap ) ;
#line 479
int handle_packet_expire_indirect(struct autofs_point *ap , autofs_packet_expire_indirect_t *pkt ) ;
#line 480
int handle_packet_expire_direct(struct autofs_point *ap , autofs_packet_expire_direct_t *pkt ) ;
#line 481
int handle_packet_missing_indirect(struct autofs_point *ap , autofs_packet_missing_indirect_t *pkt ) ;
#line 482
int handle_packet_missing_direct(struct autofs_point *ap , autofs_packet_missing_direct_t *pkt ) ;
#line 483
void rm_unwanted(char const   *path___0 , int incl , dev_t dev ) ;
#line 484
int count_mounts(char const   *path___0 , dev_t dev ) ;
#line 515
int alarm_start_handler(void) ;
#line 516
int alarm_add(struct autofs_point *ap , time_t seconds ) ;
#line 517
void alarm_delete(struct autofs_point *ap ) ;
#line 44 "automount.c"
char const   *program  ;
#line 45 "automount.c"
char const   *version  =    "5.0.2";
#line 46 "automount.c"
char const   *libdir  =    "/usr/lib/autofs";
#line 47 "automount.c"
char const   *mapdir  =    "/etc";
#line 48 "automount.c"
char const   *confdir  =    "";
#line 50 "automount.c"
char const   *global_options  ;
#line 52 "automount.c"
static char *pid_file  =    (char *)((void *)0);
#line 53 "automount.c"
unsigned int random_selection  ;
#line 55 "automount.c"
static int start_pipefd[2]  ;
#line 56 "automount.c"
static int st_stat  =    0;
#line 57 "automount.c"
static int *pst_stat  =    & st_stat;
#line 60 "automount.c"
static size_t kpkt_len  ;
#line 63 "automount.c"
pthread_attr_t thread_attr  ;
#line 65 "automount.c"
struct master_readmap_cond mrc  = 
#line 65
     {{{0, 0U, 0, 0, 0U, {0}}}, {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}}, 0UL,
    (struct master *)((void *)0), 0L, (enum states )0, 0U, 0U};
#line 68 "automount.c"
struct startup_cond suc  =    {{{0, 0U, 0, 0, 0U, {0}}}, {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}}, 0U,
    0U};
#line 78
static int umount_all(struct autofs_point *ap , int force ) ;
#line 81
struct master *master_list ;
#line 83 "automount.c"
static int do_mkdir(char const   *parent , char const   *path___0 , mode_t mode ) 
{ int status ;
  struct stat st ;
  struct statfs fs ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 90
  status = stat__extinline(path___0, & st);
#line 91
  if (status == 0) {
#line 92
    if (! ((st.st_mode & 61440U) == 16384U)) {
#line 93
      tmp = __errno_location();
#line 93
      (*tmp) = 20;
    }
#line 94
    tmp___0 = __errno_location();
#line 94
    (*tmp___0) = 17;
#line 95
    return (0);
  }
#line 102
  status = -1;
#line 103
  if ((*parent)) {
#line 104
    status = statfs(parent, & fs);
  }
#line 105
  if (status != -1) {
#line 105
    if (fs.f_type == 391) {
      goto _L;
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
#line 105
    tmp___2 = contained_in_local_fs(path___0);
#line 105
    if (tmp___2) {
      _L: 
#line 107
      tmp___1 = mkdir(path___0, mode);
#line 107
      if (tmp___1 == -1) {
#line 108
        return (0);
      }
#line 109
      return (1);
    }
  }
#line 112
  return (0);
}
}
#line 115 "automount.c"
int mkdir_path(char const   *path___0 , mode_t mode ) 
{ char *buf ;
  size_t tmp ;
  char *tmp___0 ;
  char *parent ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char const   *cp ;
  char const   *lcp ;
  char *bp ;
  char *pp ;
  int tmp___3 ;
  char const   *tmp___4 ;

  {
#line 117
  tmp = strlen(path___0);
#line 117
  tmp___0 = (char *)__builtin_alloca(tmp + 1U);
#line 117
  buf = tmp___0;
#line 118
  tmp___1 = strlen(path___0);
#line 118
  tmp___2 = (char *)__builtin_alloca(tmp___1 + 1U);
#line 118
  parent = tmp___2;
#line 119
  cp = path___0;
#line 119
  lcp = path___0;
#line 120
  bp = buf;
#line 120
  pp = parent;
#line 122
  (*parent) = (char )'\000';
#line 124
  while (1) {
#line 125
    if ((unsigned int )cp != (unsigned int )path___0) {
#line 125
      if ((int const   )(*cp) == 47) {
        goto _L;
      } else {
#line 125
        if ((int const   )(*cp) == 0) {
          _L: 
#line 126
          memcpy((void * __restrict  )bp, (void const   * __restrict  )lcp, (unsigned int )(cp - lcp));
#line 127
          bp += cp - lcp;
#line 128
          (*bp) = (char )'\000';
#line 129
          tmp___3 = do_mkdir((char const   *)parent, (char const   *)buf, mode);
#line 129
          if (! tmp___3) {
#line 130
            if ((int const   )(*cp) != 0) {
#line 131
              memcpy((void * __restrict  )pp, (void const   * __restrict  )lcp, (unsigned int )(cp - lcp));
#line 132
              pp += cp - lcp;
#line 133
              (*pp) = (char )'\000';
#line 134
              lcp = cp;
              goto __Cont;
            }
#line 137
            return (-1);
          }
#line 139
          memcpy((void * __restrict  )pp, (void const   * __restrict  )lcp, (unsigned int )(cp - lcp));
#line 140
          pp += cp - lcp;
#line 141
          (*pp) = (char )'\000';
#line 142
          lcp = cp;
        }
      }
    }
    __Cont: 
#line 124
    tmp___4 = cp;
#line 124
    cp ++;
#line 124
    if (! ((int const   )(*tmp___4) != 0)) {
#line 124
      break;
    }
  }
#line 146
  return (0);
}
}
#line 150 "automount.c"
int rmdir_path(struct autofs_point *ap , char const   *path___0 , dev_t dev ) 
{ int len ;
  int tmp ;
  char *buf ;
  char *tmp___0 ;
  char *cp ;
  int first ;
  struct stat st ;
  struct statfs fs ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 152
  tmp = (int )strlen(path___0);
#line 152
  len = tmp;
#line 153
  tmp___0 = (char *)__builtin_alloca((unsigned int )(len + 1));
#line 153
  buf = tmp___0;
#line 155
  first = 1;
#line 159
  strcpy((char * __restrict  )buf, (char const   * __restrict  )path___0);
#line 160
  cp = buf + len;
#line 162
  while (1) {
#line 163
    (*cp) = (char )'\000';
#line 170
    memset((void *)(& st), 0, sizeof(st));
#line 171
    tmp___1 = lstat__extinline((char const   *)buf, & st);
#line 171
    if (tmp___1 != 0) {
#line 172
      while (1) {
#line 172
        ((*log_crit))(ap->logopt, "%s: lstat of %s failed.", "rmdir_path", buf);
#line 172
        break;
      }
#line 173
      return (-1);
    }
#line 177
    if (st.st_dev != dev) {
#line 178
      return (0);
    }
#line 180
    tmp___2 = statfs((char const   *)buf, & fs);
#line 180
    if (tmp___2 != 0) {
#line 181
      while (1) {
#line 181
        ((*log_error))(ap->logopt, "%s: could not stat fs of %s", "rmdir_path", buf);
#line 181
        break;
      }
#line 182
      return (-1);
    }
#line 185
    if (fs.f_type != 391) {
#line 186
      while (1) {
#line 186
        ((*log_crit))(ap->logopt, "%s: attempt to remove directory from a non-autofs filesystem!",
                      "rmdir_path");
#line 186
        break;
      }
#line 188
      while (1) {
#line 188
        ((*log_crit))(ap->logopt, "%s: requestor dev == %llu, \"%s\" owner dev == %llu",
                      "rmdir_path", dev, buf, st.st_dev);
#line 188
        break;
      }
#line 191
      return (-1);
    }
#line 199
    tmp___5 = rmdir((char const   *)buf);
#line 199
    if (tmp___5 == -1) {
#line 200
      if (first) {
#line 200
        tmp___4 = __errno_location();
#line 200
        if ((*tmp___4) == 20) {
#line 205
          if ((st.st_mode & 61440U) == 40960U) {
#line 206
            tmp___3 = unlink((char const   *)buf);
#line 206
            if (tmp___3 == -1) {
#line 207
              return (-1);
            }
          } else {
#line 209
            while (1) {
#line 209
              ((*log_crit))(ap->logopt, "%s: file \"%s\" is neither a directory nor a symbolic link. mode %d",
                            "rmdir_path", buf, st.st_mode);
#line 209
              break;
            }
#line 213
            return (-1);
          }
        }
      }
#line 221
      return (-1);
    }
#line 224
    first = 0;
#line 162
    cp = strrchr((char const   *)buf, '/');
#line 162
    if ((unsigned int )cp != (unsigned int )((void *)0)) {
#line 162
      if (! ((unsigned int )cp != (unsigned int )buf)) {
#line 162
        break;
      }
    } else {
#line 162
      break;
    }
  }
#line 227
  return (0);
}
}
#line 233 "automount.c"
static int walk_tree(char const   *base , int (*fn)(char const   *file , struct stat  const  *st ,
                                                    int  , void * ) , int incl , void *arg ) 
{ char buf[4097] ;
  struct stat st ;
  struct dirent **de ;
  int n ;
  int ret ;
  int size ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 240
  tmp___21 = lstat__extinline(base, & st);
#line 240
  if (tmp___21 != -1) {
#line 240
    tmp___22 = ((*fn))(base, (struct stat  const  *)(& st), 0, arg);
#line 240
    if (tmp___22) {
#line 241
      if ((st.st_mode & 61440U) == 16384U) {
#line 245
        n = scandir((char const   * __restrict  )base, (struct dirent *** __restrict  )(& de),
                    (int (*)(struct dirent  const  * ))0, & alphasort);
#line 246
        if (n < 0) {
#line 247
          return (-1);
        }
#line 249
        while (1) {
#line 249
          tmp___20 = n;
#line 249
          n --;
#line 249
          if (! tmp___20) {
#line 249
            break;
          }
#line 252
          if (0) {
#line 252
            __s1_len = strlen((char const   *)(((*(de + n)))->d_name));
#line 252
            __s2_len = strlen(".");
#line 252
            if (! ((unsigned int )((void const   *)(((*(de + n)))->d_name + 1)) - (unsigned int )((void const   *)(((*(de + n)))->d_name)) == 1U)) {
              goto _L___0;
            } else {
#line 252
              if (__s1_len >= 4U) {
                _L___0: 
#line 252
                if (! ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") == 1U)) {
#line 252
                  tmp___8 = 1;
                } else {
#line 252
                  if (__s2_len >= 4U) {
#line 252
                    tmp___8 = 1;
                  } else {
#line 252
                    tmp___8 = 0;
                  }
                }
              } else {
#line 252
                tmp___8 = 0;
              }
            }
#line 252
            if (tmp___8) {
#line 252
              tmp___4 = __builtin_strcmp((char const   *)(((*(de + n)))->d_name),
                                         ".");
            } else {
#line 252
              tmp___7 = __builtin_strcmp((char const   *)(((*(de + n)))->d_name),
                                         ".");
#line 252
              tmp___4 = tmp___7;
            }
          } else {
#line 252
            tmp___7 = __builtin_strcmp((char const   *)(((*(de + n)))->d_name), ".");
#line 252
            tmp___4 = tmp___7;
          }
#line 253
          if (tmp___4 == 0) {
#line 254
            free((void *)(*(de + n)));
#line 255
            continue;
          } else {
#line 253
            if (0) {
#line 253
              __s1_len___0 = strlen((char const   *)(((*(de + n)))->d_name));
#line 253
              __s2_len___0 = strlen("..");
#line 253
              if (! ((unsigned int )((void const   *)(((*(de + n)))->d_name + 1)) - (unsigned int )((void const   *)(((*(de + n)))->d_name)) == 1U)) {
                goto _L___2;
              } else {
#line 253
                if (__s1_len___0 >= 4U) {
                  _L___2: 
#line 253
                  if (! ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") == 1U)) {
#line 253
                    tmp___18 = 1;
                  } else {
#line 253
                    if (__s2_len___0 >= 4U) {
#line 253
                      tmp___18 = 1;
                    } else {
#line 253
                      tmp___18 = 0;
                    }
                  }
                } else {
#line 253
                  tmp___18 = 0;
                }
              }
#line 253
              if (tmp___18) {
#line 253
                tmp___14 = __builtin_strcmp((char const   *)(((*(de + n)))->d_name),
                                            "..");
              } else {
#line 253
                tmp___17 = __builtin_strcmp((char const   *)(((*(de + n)))->d_name),
                                            "..");
#line 253
                tmp___14 = tmp___17;
              }
            } else {
#line 253
              tmp___17 = __builtin_strcmp((char const   *)(((*(de + n)))->d_name),
                                          "..");
#line 253
              tmp___14 = tmp___17;
            }
#line 253
            if (tmp___14 == 0) {
#line 254
              free((void *)(*(de + n)));
#line 255
              continue;
            }
          }
#line 258
          size = (int )sizeof(buf);
#line 259
          ret = cat_path(buf, (unsigned int )size, base, (char const   *)(((*(de + n)))->d_name));
#line 260
          if (! ret) {
#line 261
            while (1) {
#line 262
              free((void *)(*(de + n)));
#line 261
              tmp___19 = n;
#line 261
              n --;
#line 261
              if (! tmp___19) {
#line 261
                break;
              }
            }
#line 264
            free((void *)de);
#line 265
            return (-1);
          }
#line 268
          walk_tree((char const   *)(buf), fn, 1, arg);
#line 269
          free((void *)(*(de + n)));
        }
#line 271
        free((void *)de);
      }
#line 273
      if (incl) {
#line 274
        ((*fn))(base, (struct stat  const  *)(& st), 1, arg);
      }
    }
  }
#line 276
  return (0);
}
}
#line 279 "automount.c"
static int rm_unwanted_fn(char const   *file , struct stat  const  *st , int when ,
                          void *arg ) 
{ dev_t dev ;
  char buf[128] ;
  struct stat newst ;
  int tmp ;
  char *estr ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 281
  dev = (*((dev_t *)arg));
#line 285
  if (when == 0) {
#line 286
    if (st->st_dev != (__dev_t const   )dev) {
#line 287
      return (0);
    }
#line 288
    return (1);
  }
#line 291
  tmp = lstat__extinline(file, & newst);
#line 291
  if (tmp) {
#line 292
    while (1) {
#line 292
      ((*log_crit))(3U, "%s: unable to stat file, possible race condition", "rm_unwanted_fn");
#line 292
      break;
    }
#line 294
    return (0);
  }
#line 297
  if (newst.st_dev != dev) {
#line 298
    while (1) {
#line 298
      ((*log_crit))(3U, "%s: file %s has the wrong device, possible race condition",
                    "rm_unwanted_fn", file);
#line 298
      break;
    }
#line 301
    return (0);
  }
#line 304
  if ((newst.st_mode & 61440U) == 16384U) {
#line 305
    while (1) {
#line 305
      ((*log_debug))(3U, "%s: removing directory %s", "rm_unwanted_fn", file);
#line 305
      break;
    }
#line 306
    tmp___2 = rmdir(file);
#line 306
    if (tmp___2) {
#line 307
      tmp___0 = __errno_location();
#line 307
      tmp___1 = strerror_r((*tmp___0), buf, 128U);
#line 307
      estr = tmp___1;
#line 308
      while (1) {
#line 308
        ((*log_warn))(3U, "%s: unable to remove directory %s: %s", "rm_unwanted_fn",
                      file, estr);
#line 308
        break;
      }
#line 310
      return (0);
    }
  } else {
#line 312
    if ((newst.st_mode & 61440U) == 32768U) {
#line 313
      while (1) {
#line 313
        ((*log_crit))(3U, "%s: attempting to remove files from a mounted directory. file %s",
                      "rm_unwanted_fn", file);
#line 313
        break;
      }
#line 316
      return (0);
    } else {
#line 317
      if ((newst.st_mode & 61440U) == 40960U) {
#line 318
        while (1) {
#line 318
          ((*log_debug))(3U, "%s: removing symlink %s", "rm_unwanted_fn", file);
#line 318
          break;
        }
#line 319
        unlink(file);
      }
    }
  }
#line 321
  return (1);
}
}
#line 324 "automount.c"
void rm_unwanted(char const   *path___0 , int incl , dev_t dev ) 
{ 

  {
#line 326
  walk_tree(path___0, & rm_unwanted_fn, incl, (void *)(& dev));
#line 327
  return;
}
}
#line 334 "automount.c"
static int counter_fn(char const   *file , struct stat  const  *st , int when , void *arg ) 
{ struct counter_args *counter ;

  {
#line 336
  counter = (struct counter_args *)arg;
#line 338
  if ((st->st_mode & 61440U) == 40960U) {
#line 340
    counter->count ++;
#line 341
    return (0);
  } else {
#line 338
    if ((st->st_mode & 61440U) == 16384U) {
#line 338
      if (st->st_dev != (__dev_t const   )counter->dev) {
#line 340
        counter->count ++;
#line 341
        return (0);
      }
    }
  }
#line 344
  return (1);
}
}
#line 348 "automount.c"
int count_mounts(char const   *path___0 , dev_t dev ) 
{ struct counter_args counter ;
  int tmp ;

  {
#line 352
  counter.count = 0U;
#line 353
  counter.dev = dev;
#line 355
  tmp = walk_tree(path___0, & counter_fn, 0, (void *)(& counter));
#line 355
  if (tmp == -1) {
#line 356
    return (-1);
  }
#line 358
  return ((int )counter.count);
}
}
#line 361 "automount.c"
static void check_rm_dirs(struct autofs_point *ap , char const   *path___0 , int incl ) 
{ 

  {
#line 363
  if (! ap->ghost) {
#line 367
    rm_unwanted(path___0, incl, ap->dev);
  } else {
#line 363
    if ((int )ap->state == 5) {
#line 367
      rm_unwanted(path___0, incl, ap->dev);
    } else {
#line 363
      if ((int )ap->state == 6) {
#line 367
        rm_unwanted(path___0, incl, ap->dev);
      } else {
#line 363
        if ((int )ap->state == 7) {
#line 367
          rm_unwanted(path___0, incl, ap->dev);
        } else {
#line 368
          if (ap->ghost) {
#line 368
            if (ap->type == 2U) {
#line 369
              rm_unwanted(path___0, 0, ap->dev);
            }
          }
        }
      }
    }
  }
#line 370
  return;
}
}
#line 373 "automount.c"
static void update_map_cache(struct autofs_point *ap , char const   *path___0 ) 
{ struct map_source *map ;
  struct mapent_cache *mc ;
  char const   *key ;
  char *tmp ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___0 ;
  long tmp___1 ;
  struct mapent *me ;
  int tmp___2 ;

  {
#line 379
  if (ap->type == 2U) {
#line 380
    tmp = strrchr(path___0, '/');
#line 380
    key = (char const   *)(tmp + 1);
  } else {
#line 382
    key = path___0;
  }
#line 384
  while (1) {
#line 384
    __cancel_routine = & master_source_lock_cleanup;
#line 384
    __cancel_arg = (void *)ap->entry;
#line 384
    tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
#line 384
    not_first_call = tmp___0;
#line 384
    tmp___1 = __builtin_expect((long )not_first_call, 0L);
#line 384
    if (tmp___1) {
#line 384
      ((*__cancel_routine))(__cancel_arg);
#line 384
      __pthread_unwind_next(& __cancel_buf);
    }
#line 384
    __pthread_register_cancel(& __cancel_buf);
#line 384
    while (1) {
#line 385
      master_source_readlock(ap->entry);
#line 386
      map = (ap->entry)->maps;
#line 387
      while (map) {
#line 388
        me = (struct mapent *)((void *)0);
#line 391
        if ((ap->entry)->age <= map->age) {
#line 392
          map = map->next;
#line 393
          continue;
        }
#line 396
        mc = map->mc;
#line 398
        tmp___2 = cache_try_writelock(mc);
#line 398
        if (tmp___2) {
#line 399
          me = cache_lookup_distinct(mc, key);
#line 400
          if (me) {
#line 400
            if (me->ioctlfd == -1) {
#line 401
              cache_delete(mc, key);
            }
          }
#line 402
          cache_unlock(mc);
        }
#line 405
        map = map->next;
      }
#line 384
      break;
    }
#line 407
    __pthread_unregister_cancel(& __cancel_buf);
#line 407
    ((*__cancel_routine))(__cancel_arg);
#line 384
    break;
  }
#line 409
  return;
}
}
#line 412 "automount.c"
static int umount_subtree_mounts(struct autofs_point *ap , char const   *path___0 ,
                                 unsigned int is_autofs_fs ) 
{ struct mapent_cache *mc ;
  struct mapent *me ;
  unsigned int is_mm_root ;
  int left ;
  char *ind_key ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp ;
  long tmp___0 ;
  char *root ;
  char *base ;
  size_t ap_len ;
  int cur_state ;
  size_t tmp___1 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 419
  me = lookup_source_mapent(ap, path___0, 8192U);
#line 420
  if (! me) {
#line 423
    ind_key = strrchr(path___0, '/');
#line 424
    if (ind_key) {
#line 425
      ind_key ++;
    }
#line 427
    me = lookup_source_mapent(ap, (char const   *)ind_key, 4096U);
#line 428
    if (! me) {
#line 429
      return (0);
    }
  }
#line 432
  mc = me->mc;
#line 433
  is_mm_root = (unsigned int )((unsigned int )me->multi == (unsigned int )me);
#line 435
  left = 0;
#line 437
  while (1) {
#line 437
    __cancel_routine = & cache_lock_cleanup;
#line 437
    __cancel_arg = (void *)mc;
#line 437
    tmp = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf), 0);
#line 437
    not_first_call = tmp;
#line 437
    tmp___0 = __builtin_expect((long )not_first_call, 0L);
#line 437
    if (tmp___0) {
#line 437
      ((*__cancel_routine))(__cancel_arg);
#line 437
      __pthread_unwind_next(& __cancel_buf);
    }
#line 437
    __pthread_register_cancel(& __cancel_buf);
#line 437
    while (1) {
#line 439
      if (me->multi) {
#line 444
        ap_len = strlen((char const   *)ap->path);
#line 446
        tmp___3 = __builtin_strchr((me->multi)->key, (char )'/');
#line 446
        if (tmp___3) {
#line 453
          root = (me->multi)->key;
        } else {
#line 448
          tmp___1 = strlen((char const   *)(me->multi)->key);
#line 448
          root = (char *)__builtin_alloca((ap_len + tmp___1) + 2U);
#line 449
          strcpy((char * __restrict  )root, (char const   * __restrict  )ap->path);
#line 450
          strcat((char * __restrict  )root, (char const   * __restrict  )"/");
#line 451
          strcat((char * __restrict  )root, (char const   * __restrict  )(me->multi)->key);
        }
#line 455
        if (is_mm_root) {
#line 456
          base = (char *)((void *)0);
        } else {
#line 458
          tmp___4 = strlen((char const   *)root);
#line 458
          base = me->key + tmp___4;
        }
#line 460
        pthread_setcancelstate(1, & cur_state);
#line 462
        cache_multi_lock(me->parent);
#line 463
        tmp___5 = umount_multi_triggers(ap, root, me, (char const   *)base);
#line 463
        if (tmp___5) {
#line 464
          while (1) {
#line 464
            ((*log_warn))(ap->logopt, "%s: could not umount some offsets under %s",
                          "umount_subtree_mounts", path___0);
#line 464
            break;
          }
#line 466
          left ++;
        }
#line 468
        cache_multi_unlock(me->parent);
#line 469
        pthread_setcancelstate(cur_state, (int *)((void *)0));
      }
#line 437
      break;
    }
#line 472
    __pthread_unregister_cancel(& __cancel_buf);
#line 472
    ((*__cancel_routine))(__cancel_arg);
#line 437
    break;
  }
#line 474
  if (left) {
#line 475
    return (left);
  } else {
#line 474
    if (is_autofs_fs) {
#line 475
      return (left);
    }
  }
#line 481
  if (! is_mm_root) {
#line 481
    tmp___7 = is_mounted("/etc/mtab", path___0, 2U);
#line 481
    if (tmp___7) {
#line 482
      while (1) {
#line 482
        ((*log_info))(0U, "unmounting dir = %s", path___0);
#line 482
        break;
      }
#line 483
      tmp___6 = umount_ent(ap, path___0);
#line 483
      if (tmp___6) {
#line 484
        while (1) {
#line 484
          ((*log_warn))(ap->logopt, "%s: could not umount dir %s", "umount_subtree_mounts",
                        path___0);
#line 484
          break;
        }
#line 485
        left ++;
      }
    }
  }
#line 489
  return (left);
}
}
#line 494 "automount.c"
int umount_multi(struct autofs_point *ap , char const   *path___0 , int incl ) 
{ struct mapent_cache *nc ;
  struct statfs fs ;
  int is_autofs_fs ;
  int ret ;
  int left ;
  struct mapent *tmp ;
  int tmp___0 ;

  {
#line 501
  while (1) {
#line 501
    ((*log_debug))(ap->logopt, "%s: path %s incl %d", "umount_multi", path___0, incl);
#line 501
    break;
  }
#line 503
  nc = ((ap->entry)->master)->nc;
#line 504
  cache_readlock(nc);
#line 505
  tmp = cache_lookup_distinct(nc, path___0);
#line 505
  if (tmp) {
#line 506
    cache_unlock(nc);
#line 507
    return (0);
  }
#line 509
  cache_unlock(nc);
#line 511
  ret = statfs(path___0, & fs);
#line 512
  if (ret == -1) {
#line 513
    while (1) {
#line 513
      ((*log_error))(ap->logopt, "%s: could not stat fs of %s", "umount_multi", path___0);
#line 513
      break;
    }
#line 514
    return (1);
  }
#line 517
  if (fs.f_type == 391) {
#line 517
    is_autofs_fs = 1;
  } else {
#line 517
    is_autofs_fs = 0;
  }
#line 519
  left = 0;
#line 528
  tmp___0 = umount_subtree_mounts(ap, path___0, (unsigned int )is_autofs_fs);
#line 528
  left += tmp___0;
#line 531
  if (left == 0) {
#line 531
    if ((int )ap->state != 4) {
#line 532
      update_map_cache(ap, path___0);
#line 533
      check_rm_dirs(ap, path___0, incl);
    }
  }
#line 536
  return (left);
}
}
#line 539 "automount.c"
static int umount_all(struct autofs_point *ap , int force ) 
{ int left ;

  {
#line 543
  left = umount_multi(ap, (char const   *)ap->path, 0);
#line 544
  if (force) {
#line 544
    if (left) {
#line 545
      while (1) {
#line 545
        ((*log_warn))(ap->logopt, "%s: could not unmount %d dirs under %s", "umount_all",
                      left, ap->path);
#line 545
        break;
      }
    }
  }
#line 548
  return (left);
}
}
#line 551 "automount.c"
int umount_autofs(struct autofs_point *ap , int force ) 
{ int ret ;
  int tmp ;

  {
#line 553
  ret = 0;
#line 555
  if ((int )ap->state == 0) {
#line 556
    return (-1);
  }
#line 563
  lookup_close_lookup(ap);
#line 565
  if (ap->type == 2U) {
#line 566
    tmp = umount_all(ap, force);
#line 566
    if (tmp) {
#line 566
      if (! force) {
#line 567
        return (-1);
      }
    }
#line 568
    ret = umount_autofs_indirect(ap);
  } else {
#line 570
    ret = umount_autofs_direct(ap);
  }
#line 572
  return (ret);
}
}
#line 575 "automount.c"
int send_ready(int ioctlfd , unsigned int wait_queue_token ) 
{ char buf[128] ;
  char *estr ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 579
  if (wait_queue_token == 0U) {
#line 580
    return (0);
  }
#line 582
  while (1) {
#line 582
    ((*log_debug))(0U, "%s: token = %d", "send_ready", wait_queue_token);
#line 582
    break;
  }
#line 584
  tmp___1 = ioctl(ioctlfd, 37728UL, wait_queue_token);
#line 584
  if (tmp___1 < 0) {
#line 585
    tmp = __errno_location();
#line 585
    tmp___0 = strerror_r((*tmp), buf, 128U);
#line 585
    estr = tmp___0;
#line 586
    while (1) {
#line 586
      ((*log_error))(3U, "%s: AUTOFS_IOC_READY: error %s", "send_ready", estr);
#line 586
      break;
    }
#line 587
    return (1);
  }
#line 589
  return (0);
}
}
#line 592 "automount.c"
int send_fail(int ioctlfd , unsigned int wait_queue_token ) 
{ char buf[128] ;
  char *estr ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 596
  if (wait_queue_token == 0U) {
#line 597
    return (0);
  }
#line 599
  while (1) {
#line 599
    ((*log_debug))(0U, "%s: token = %d", "send_fail", wait_queue_token);
#line 599
    break;
  }
#line 601
  tmp___1 = ioctl(ioctlfd, 37729UL, wait_queue_token);
#line 601
  if (tmp___1 < 0) {
#line 602
    tmp = __errno_location();
#line 602
    tmp___0 = strerror_r((*tmp), buf, 128U);
#line 602
    estr = tmp___0;
#line 603
    while (1) {
#line 603
      ((*log_error))(3U, "%s: AUTOFS_IOC_FAIL: error %s", "send_fail", estr);
#line 603
      break;
    }
#line 604
    return (1);
  }
#line 606
  return (0);
}
}
#line 609 "automount.c"
static size_t get_kpkt_len(void) 
{ size_t pkt_len ;
  struct utsname un___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;

  {
#line 611
  pkt_len = sizeof(struct autofs_v5_packet );
#line 614
  uname(& un___0);
#line 616
  if (pkt_len % 8U) {
#line 617
    if (0) {
#line 617
      __s1_len = strlen((char const   *)(un___0.machine));
#line 617
      __s2_len = strlen("alpha");
#line 617
      if (! ((unsigned int )((void const   *)(un___0.machine + 1)) - (unsigned int )((void const   *)(un___0.machine)) == 1U)) {
        goto _L___0;
      } else {
#line 617
        if (__s1_len >= 4U) {
          _L___0: 
#line 617
          if (! ((unsigned int )((void const   *)("alpha" + 1)) - (unsigned int )((void const   *)"alpha") == 1U)) {
#line 617
            tmp___8 = 1;
          } else {
#line 617
            if (__s2_len >= 4U) {
#line 617
              tmp___8 = 1;
            } else {
#line 617
              tmp___8 = 0;
            }
          }
        } else {
#line 617
          tmp___8 = 0;
        }
      }
#line 617
      if (tmp___8) {
#line 617
        tmp___4 = __builtin_strcmp((char const   *)(un___0.machine), "alpha");
      } else {
#line 617
        tmp___7 = __builtin_strcmp((char const   *)(un___0.machine), "alpha");
#line 617
        tmp___4 = tmp___7;
      }
    } else {
#line 617
      tmp___7 = __builtin_strcmp((char const   *)(un___0.machine), "alpha");
#line 617
      tmp___4 = tmp___7;
    }
#line 620
    if (tmp___4 == 0) {
#line 621
      pkt_len += 4U;
    } else {
#line 618
      if (0) {
#line 618
        __s1_len___0 = strlen((char const   *)(un___0.machine));
#line 618
        __s2_len___0 = strlen("ia64");
#line 618
        if (! ((unsigned int )((void const   *)(un___0.machine + 1)) - (unsigned int )((void const   *)(un___0.machine)) == 1U)) {
          goto _L___2;
        } else {
#line 618
          if (__s1_len___0 >= 4U) {
            _L___2: 
#line 618
            if (! ((unsigned int )((void const   *)("ia64" + 1)) - (unsigned int )((void const   *)"ia64") == 1U)) {
#line 618
              tmp___18 = 1;
            } else {
#line 618
              if (__s2_len___0 >= 4U) {
#line 618
                tmp___18 = 1;
              } else {
#line 618
                tmp___18 = 0;
              }
            }
          } else {
#line 618
            tmp___18 = 0;
          }
        }
#line 618
        if (tmp___18) {
#line 618
          tmp___14 = __builtin_strcmp((char const   *)(un___0.machine), "ia64");
        } else {
#line 618
          tmp___17 = __builtin_strcmp((char const   *)(un___0.machine), "ia64");
#line 618
          tmp___14 = tmp___17;
        }
      } else {
#line 618
        tmp___17 = __builtin_strcmp((char const   *)(un___0.machine), "ia64");
#line 618
        tmp___14 = tmp___17;
      }
#line 620
      if (tmp___14 == 0) {
#line 621
        pkt_len += 4U;
      } else {
#line 619
        if (0) {
#line 619
          __s1_len___1 = strlen((char const   *)(un___0.machine));
#line 619
          __s2_len___1 = strlen("x86_64");
#line 619
          if (! ((unsigned int )((void const   *)(un___0.machine + 1)) - (unsigned int )((void const   *)(un___0.machine)) == 1U)) {
            goto _L___4;
          } else {
#line 619
            if (__s1_len___1 >= 4U) {
              _L___4: 
#line 619
              if (! ((unsigned int )((void const   *)("x86_64" + 1)) - (unsigned int )((void const   *)"x86_64") == 1U)) {
#line 619
                tmp___28 = 1;
              } else {
#line 619
                if (__s2_len___1 >= 4U) {
#line 619
                  tmp___28 = 1;
                } else {
#line 619
                  tmp___28 = 0;
                }
              }
            } else {
#line 619
              tmp___28 = 0;
            }
          }
#line 619
          if (tmp___28) {
#line 619
            tmp___24 = __builtin_strcmp((char const   *)(un___0.machine), "x86_64");
          } else {
#line 619
            tmp___27 = __builtin_strcmp((char const   *)(un___0.machine), "x86_64");
#line 619
            tmp___24 = tmp___27;
          }
        } else {
#line 619
          tmp___27 = __builtin_strcmp((char const   *)(un___0.machine), "x86_64");
#line 619
          tmp___24 = tmp___27;
        }
#line 620
        if (tmp___24 == 0) {
#line 621
          pkt_len += 4U;
        } else {
#line 620
          if (0) {
#line 620
            __s1_len___2 = strlen((char const   *)(un___0.machine));
#line 620
            __s2_len___2 = strlen("ppc64");
#line 620
            if (! ((unsigned int )((void const   *)(un___0.machine + 1)) - (unsigned int )((void const   *)(un___0.machine)) == 1U)) {
              goto _L___6;
            } else {
#line 620
              if (__s1_len___2 >= 4U) {
                _L___6: 
#line 620
                if (! ((unsigned int )((void const   *)("ppc64" + 1)) - (unsigned int )((void const   *)"ppc64") == 1U)) {
#line 620
                  tmp___38 = 1;
                } else {
#line 620
                  if (__s2_len___2 >= 4U) {
#line 620
                    tmp___38 = 1;
                  } else {
#line 620
                    tmp___38 = 0;
                  }
                }
              } else {
#line 620
                tmp___38 = 0;
              }
            }
#line 620
            if (tmp___38) {
#line 620
              tmp___34 = __builtin_strcmp((char const   *)(un___0.machine), "ppc64");
            } else {
#line 620
              tmp___37 = __builtin_strcmp((char const   *)(un___0.machine), "ppc64");
#line 620
              tmp___34 = tmp___37;
            }
          } else {
#line 620
            tmp___37 = __builtin_strcmp((char const   *)(un___0.machine), "ppc64");
#line 620
            tmp___34 = tmp___37;
          }
#line 620
          if (tmp___34 == 0) {
#line 621
            pkt_len += 4U;
          }
        }
      }
    }
  }
#line 625
  return (pkt_len);
}
}
#line 628 "automount.c"
static int fullread(int fd , void *ptr , size_t len ) 
{ char *buf ;
  ssize_t r ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
#line 630
  buf = (char *)ptr;
#line 632
  while (len > 0U) {
#line 633
    tmp = read(fd, (void *)buf, len);
#line 633
    r = tmp;
#line 635
    if (r == -1) {
#line 636
      tmp___0 = __errno_location();
#line 636
      if ((*tmp___0) == 4) {
#line 637
        continue;
      }
#line 638
      break;
    }
#line 641
    buf += r;
#line 642
    len -= (unsigned int )r;
  }
#line 645
  return ((int )len);
}
}
#line 648 "automount.c"
static int get_pkt(struct autofs_point *ap , union autofs_packet_union *pkt ) 
{ struct pollfd fds[2] ;
  char buf[128] ;
  char *estr ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  enum states next_state ;
  enum states post_state ;
  size_t read_size ;
  int state_pipe ;
  int _st_lock ;
  int tmp___2 ;
  int _st_unlock ;
  int tmp___3 ;
  int tmp___4 ;
  int _st_unlock___0 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 653
  fds[0].fd = ap->pipefd;
#line 654
  fds[0].events = (short)1;
#line 655
  fds[1].fd = ap->state_pipe[0];
#line 656
  fds[1].events = (short)1;
#line 658
  while (1) {
#line 659
    tmp___1 = poll(fds, 2UL, -1);
#line 659
    if (tmp___1 == -1) {
#line 661
      tmp = __errno_location();
#line 661
      if ((*tmp) == 4) {
        goto __Cont;
      }
#line 663
      tmp___0 = __errno_location();
#line 663
      estr = strerror_r((*tmp___0), buf, 128U);
#line 664
      while (1) {
#line 664
        ((*log_error))(ap->logopt, "%s: poll failed: %s", "get_pkt", estr);
#line 664
        break;
      }
#line 665
      return (-1);
    }
#line 668
    if ((int )fds[1].revents & 1) {
#line 670
      read_size = sizeof(next_state);
#line 673
      post_state = (enum states )-1;
#line 673
      next_state = post_state;
#line 675
      while (1) {
#line 675
        tmp___2 = pthread_mutex_lock(& ap->state_mutex);
#line 675
        _st_lock = tmp___2;
#line 675
        if (_st_lock) {
#line 675
          while (1) {
#line 675
            if (_st_lock == 35) {
#line 675
              ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                            "get_pkt", 675, "automount.c");
#line 675
              dump_core();
            }
#line 675
            ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_lock,
                          675, "automount.c");
#line 675
            abort();
#line 675
            break;
          }
        }
#line 675
        break;
      }
#line 677
      state_pipe = ap->state_pipe[0];
#line 679
      tmp___4 = fullread(state_pipe, (void *)(& next_state), read_size);
#line 679
      if (tmp___4) {
#line 680
        while (1) {
#line 680
          tmp___3 = pthread_mutex_unlock(& ap->state_mutex);
#line 680
          _st_unlock = tmp___3;
#line 680
          if (_st_unlock) {
#line 680
            while (1) {
#line 680
              if (_st_unlock == 35) {
#line 680
                ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                              "get_pkt", 680, "automount.c");
#line 680
                dump_core();
              }
#line 680
              ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_unlock,
                            680, "automount.c");
#line 680
              abort();
#line 680
              break;
            }
          }
#line 680
          break;
        }
        goto __Cont;
      }
#line 684
      if ((int )next_state != -1) {
#line 684
        if ((int )next_state != (int )ap->state) {
#line 685
          if ((int )next_state != 7) {
#line 686
            post_state = next_state;
          } else {
#line 688
            ap->state = (enum states )7;
          }
        }
      }
#line 691
      while (1) {
#line 691
        tmp___5 = pthread_mutex_unlock(& ap->state_mutex);
#line 691
        _st_unlock___0 = tmp___5;
#line 691
        if (_st_unlock___0) {
#line 691
          while (1) {
#line 691
            if (_st_unlock___0 == 35) {
#line 691
              ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                            "get_pkt", 691, "automount.c");
#line 691
              dump_core();
            }
#line 691
            ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_unlock___0,
                          691, "automount.c");
#line 691
            abort();
#line 691
            break;
          }
        }
#line 691
        break;
      }
#line 693
      if ((int )post_state != -1) {
#line 694
        if ((int )post_state == 5) {
#line 696
          alarm_delete(ap);
#line 697
          st_remove_tasks(ap);
        } else {
#line 694
          if ((int )post_state == 6) {
#line 696
            alarm_delete(ap);
#line 697
            st_remove_tasks(ap);
          }
        }
#line 699
        st_add_task(ap, post_state);
      }
#line 702
      if ((int )next_state == 7) {
#line 703
        return (-1);
      }
    }
#line 706
    if ((int )fds[0].revents & 1) {
#line 707
      tmp___6 = fullread(ap->pipefd, (void *)pkt, kpkt_len);
#line 707
      return (tmp___6);
    }
    __Cont: ;
  }
}
}
#line 711 "automount.c"
int do_expire(struct autofs_point *ap , char const   *name , int namelen ) 
{ char buf[4097] ;
  int len ;
  int ret ;

  {
#line 716
  if ((int const   )(*name) != 47) {
#line 717
    len = ncat_path(buf, sizeof(buf), (char const   *)ap->path, name, (unsigned int )namelen);
  } else {
#line 719
    len = snprintf((char * __restrict  )(buf), 4096U, (char const   * __restrict  )"%s",
                   name);
#line 720
    if (len > 4096) {
#line 721
      len = 0;
    }
  }
#line 724
  if (! len) {
#line 725
    while (1) {
#line 725
      ((*log_crit))(ap->logopt, "%s: path to long for buffer", "do_expire");
#line 725
      break;
    }
#line 726
    return (1);
  }
#line 729
  while (1) {
#line 729
    ((*log_info))(0U, "expiring path %s", buf);
#line 729
    break;
  }
#line 731
  ret = umount_multi(ap, (char const   *)(buf), 1);
#line 732
  if (ret == 0) {
#line 733
    while (1) {
#line 733
      ((*log_info))(0U, "expired %s", buf);
#line 733
      break;
    }
  } else {
#line 735
    while (1) {
#line 735
      ((*log_warn))(ap->logopt, "%s: couldn\'t complete expire of %s", "do_expire",
                    buf);
#line 735
      break;
    }
  }
#line 737
  return (ret);
}
}
#line 740 "automount.c"
static int mount_autofs(struct autofs_point *ap ) 
{ int status ;

  {
#line 742
  status = 0;
#line 744
  if (ap->type == 4U) {
#line 745
    status = mount_autofs_direct(ap);
  } else {
#line 747
    status = mount_autofs_indirect(ap);
  }
#line 749
  if (status < 0) {
#line 750
    return (-1);
  }
#line 752
  ap->state = (enum states )1;
#line 754
  return (0);
}
}
#line 757 "automount.c"
static int handle_packet(struct autofs_point *ap ) 
{ union autofs_packet_union pkt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 761
  tmp = get_pkt(ap, & pkt);
#line 761
  if (tmp) {
#line 762
    return (-1);
  }
#line 764
  while (1) {
#line 764
    ((*log_debug))(ap->logopt, "%s: type = %d", "handle_packet", pkt.hdr.type);
#line 764
    break;
  }
#line 766
  switch (pkt.hdr.type) {
  case 3: 
#line 768
  tmp___0 = handle_packet_missing_indirect(ap, & pkt.v5_packet);
#line 768
  return (tmp___0);
  case 5: 
#line 771
  tmp___1 = handle_packet_missing_direct(ap, & pkt.v5_packet);
#line 771
  return (tmp___1);
  case 4: 
#line 774
  tmp___2 = handle_packet_expire_indirect(ap, & pkt.v5_packet);
#line 774
  return (tmp___2);
  case 6: 
#line 777
  tmp___3 = handle_packet_expire_direct(ap, & pkt.v5_packet);
#line 777
  return (tmp___3);
  }
#line 779
  while (1) {
#line 779
    ((*log_error))(ap->logopt, "%s: unknown packet type %d", "handle_packet", pkt.hdr.type);
#line 779
    break;
  }
#line 780
  return (-1);
}
}
#line 783 "automount.c"
static void become_daemon(unsigned int foreground ) 
{ FILE *pidfp ;
  char buf[128] ;
  unsigned int to_stderr___0 ;
  pid_t pid ;
  int tmp ;
  int tmp___0 ;
  int r ;
  char *estr ;
  int *tmp___1 ;
  char *tmp___2 ;
  __pid_t tmp___3 ;
  __pid_t tmp___4 ;
  char *estr___0 ;
  int *tmp___5 ;
  char *tmp___6 ;

  {
#line 787
  to_stderr___0 = 0U;
#line 791
  tmp = chdir("/");
#line 791
  if (tmp) {
#line 792
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: failed change working directory.\n",
            program);
#line 794
    exit(0);
  }
#line 797
  tmp___0 = pipe(start_pipefd);
#line 797
  if (tmp___0 < 0) {
#line 798
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: failed to create start_pipefd.\n",
            program);
#line 800
    exit(0);
  }
#line 804
  if (! foreground) {
#line 805
    pid = fork();
#line 806
    if (pid > 0) {
#line 808
      close(start_pipefd[1]);
#line 809
      r = read(start_pipefd[0], (void *)pst_stat, sizeof(pst_stat));
#line 810
      if (r < 0) {
#line 811
        exit(1);
      }
#line 812
      exit((*pst_stat));
    } else {
#line 813
      if (pid < 0) {
#line 814
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Could not detach process\n",
                program);
#line 816
        exit(1);
      }
    }
#line 818
    close(start_pipefd[0]);
#line 824
    tmp___3 = setsid();
#line 824
    if (tmp___3 == -1) {
#line 825
      tmp___1 = __errno_location();
#line 825
      tmp___2 = strerror_r((*tmp___1), buf, 128U);
#line 825
      estr = tmp___2;
#line 826
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"setsid: %s",
              estr);
#line 827
      exit(1);
    }
  }
#line 832
  if (to_stderr___0) {
#line 833
    log_to_stderr();
  } else {
#line 835
    log_to_syslog();
  }
#line 838
  if (pid_file) {
#line 839
    pidfp = fopen((char const   * __restrict  )pid_file, (char const   * __restrict  )"wt");
#line 839
    if (pidfp) {
#line 840
      tmp___4 = getpid();
#line 840
      fprintf((FILE * __restrict  )pidfp, (char const   * __restrict  )"%lu\n", (unsigned long )tmp___4);
#line 841
      fclose(pidfp);
    } else {
#line 843
      tmp___5 = __errno_location();
#line 843
      tmp___6 = strerror_r((*tmp___5), buf, 128U);
#line 843
      estr___0 = tmp___6;
#line 844
      while (1) {
#line 844
        ((*log_warn))(3U, "%s: failed to write pid file %s: %s", "become_daemon",
                      pid_file, estr___0);
#line 844
        break;
      }
#line 847
      pid_file = (char *)((void *)0);
    }
  }
#line 850
  return;
}
}
#line 852 "automount.c"
static unsigned long getnumopt(char *str , char option ) 
{ unsigned long val ;
  char *end ;

  {
#line 857
  val = strtoul__extinline((char const   * __restrict  )str, (char ** __restrict  )(& end),
                           0);
#line 858
  if (! (*str)) {
#line 859
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: option -%c requires a numeric argument, got %s\n",
            program, option, str);
#line 862
    exit(1);
  } else {
#line 858
    if ((*end)) {
#line 859
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: option -%c requires a numeric argument, got %s\n",
              program, option, str);
#line 862
      exit(1);
    }
  }
#line 864
  return (val);
}
}
#line 867 "automount.c"
static void do_master_cleanup_unlock(void *arg ) 
{ int status ;

  {
#line 871
  status = pthread_mutex_unlock(& mrc.mutex);
#line 872
  if (status) {
#line 873
    while (1) {
#line 873
      if (status == 35) {
#line 873
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "do_master_cleanup_unlock", 873, "automount.c");
#line 873
        dump_core();
      }
#line 873
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 873,
                    "automount.c");
#line 873
      abort();
#line 873
      break;
    }
  }
#line 875
  return;
}
}
#line 878 "automount.c"
static void *do_notify_state(void *arg ) 
{ struct master *master ;
  int sig ;
  int status ;

  {
#line 884
  sig = (*((int *)arg));
#line 886
  status = pthread_mutex_lock(& mrc.mutex);
#line 887
  if (status) {
#line 888
    while (1) {
#line 888
      if (status == 35) {
#line 888
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "do_notify_state", 888, "automount.c");
#line 888
        dump_core();
      }
#line 888
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 888,
                    "automount.c");
#line 888
      abort();
#line 888
      break;
    }
  }
#line 890
  master = mrc.master;
#line 892
  while (1) {
#line 892
    ((*log_debug))(master->default_logging, "%s: signal %d", "do_notify_state", sig);
#line 892
    break;
  }
#line 894
  mrc.signaled = 1U;
#line 895
  status = pthread_cond_signal(& mrc.cond);
#line 896
  if (status) {
#line 897
    while (1) {
#line 897
      ((*log_error))(master->default_logging, "%s: failed to signal state notify condition",
                     "do_notify_state");
#line 897
      break;
    }
#line 899
    status = pthread_mutex_unlock(& mrc.mutex);
#line 900
    if (status) {
#line 901
      while (1) {
#line 901
        if (status == 35) {
#line 901
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "do_notify_state", 901, "automount.c");
#line 901
          dump_core();
        }
#line 901
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 901,
                      "automount.c");
#line 901
        abort();
#line 901
        break;
      }
    }
#line 902
    pthread_exit((void *)0);
  }
#line 905
  status = pthread_mutex_unlock(& mrc.mutex);
#line 906
  if (status) {
#line 907
    while (1) {
#line 907
      if (status == 35) {
#line 907
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "do_notify_state", 907, "automount.c");
#line 907
        dump_core();
      }
#line 907
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 907,
                    "automount.c");
#line 907
      abort();
#line 907
      break;
    }
  }
#line 909
  master_notify_state_change(master, sig);
#line 911
  return ((void *)0);
}
}
#line 914 "automount.c"
static int do_signals(struct master *master , int sig ) 
{ pthread_t thid ;
  int r_sig ;
  int status ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp ;
  long tmp___0 ;

  {
#line 917
  r_sig = sig;
#line 920
  status = pthread_mutex_lock(& mrc.mutex);
#line 921
  if (status) {
#line 922
    while (1) {
#line 922
      if (status == 35) {
#line 922
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "do_signals", 922, "automount.c");
#line 922
        dump_core();
      }
#line 922
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 922,
                    "automount.c");
#line 922
      abort();
#line 922
      break;
    }
  }
#line 924
  status = pthread_create((pthread_t * __restrict  )(& thid), (pthread_attr_t const   * __restrict  )(& thread_attr),
                          & do_notify_state, (void * __restrict  )(& r_sig));
#line 925
  if (status) {
#line 926
    while (1) {
#line 926
      ((*log_error))(master->default_logging, "%s: mount state notify thread create failed",
                     "do_signals");
#line 926
      break;
    }
#line 928
    status = pthread_mutex_unlock(& mrc.mutex);
#line 929
    if (status) {
#line 930
      while (1) {
#line 930
        if (status == 35) {
#line 930
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "do_signals", 930, "automount.c");
#line 930
          dump_core();
        }
#line 930
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 930,
                      "automount.c");
#line 930
        abort();
#line 930
        break;
      }
    }
#line 931
    return (0);
  }
#line 934
  mrc.thid = thid;
#line 935
  mrc.master = master;
#line 937
  while (1) {
#line 937
    __cancel_routine = & do_master_cleanup_unlock;
#line 937
    __cancel_arg = (void *)0;
#line 937
    tmp = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf), 0);
#line 937
    not_first_call = tmp;
#line 937
    tmp___0 = __builtin_expect((long )not_first_call, 0L);
#line 937
    if (tmp___0) {
#line 937
      ((*__cancel_routine))(__cancel_arg);
#line 937
      __pthread_unwind_next(& __cancel_buf);
    }
#line 937
    __pthread_register_cancel(& __cancel_buf);
#line 937
    while (1) {
#line 939
      mrc.signaled = 0U;
#line 940
      while (! mrc.signaled) {
#line 941
        status = pthread_cond_wait((pthread_cond_t * __restrict  )(& mrc.cond), (pthread_mutex_t * __restrict  )(& mrc.mutex));
#line 942
        if (status) {
#line 943
          while (1) {
#line 943
            if (status == 35) {
#line 943
              ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                            "do_signals", 943, "automount.c");
#line 943
              dump_core();
            }
#line 943
            ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status,
                          943, "automount.c");
#line 943
            abort();
#line 943
            break;
          }
        }
      }
#line 937
      break;
    }
#line 946
    __pthread_unregister_cancel(& __cancel_buf);
#line 946
    ((*__cancel_routine))(__cancel_arg);
#line 937
    break;
  }
#line 948
  return (1);
}
}
#line 951 "automount.c"
static void *do_read_master(void *arg ) 
{ struct master *master ;
  time_t age ;
  int readall ;
  int status ;

  {
#line 955
  readall = 1;
#line 958
  status = pthread_mutex_lock(& mrc.mutex);
#line 959
  if (status) {
#line 960
    while (1) {
#line 960
      if (status == 35) {
#line 960
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "do_read_master", 960, "automount.c");
#line 960
        dump_core();
      }
#line 960
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 960,
                    "automount.c");
#line 960
      abort();
#line 960
      break;
    }
  }
#line 962
  master = mrc.master;
#line 963
  age = mrc.age;
#line 965
  mrc.signaled = 1U;
#line 966
  status = pthread_cond_signal(& mrc.cond);
#line 967
  if (status) {
#line 968
    while (1) {
#line 968
      ((*log_error))(master->default_logging, "%s: failed to signal master read map condition",
                     "do_read_master");
#line 968
      break;
    }
#line 970
    master->reading = 0U;
#line 971
    status = pthread_mutex_unlock(& mrc.mutex);
#line 972
    if (status) {
#line 973
      while (1) {
#line 973
        if (status == 35) {
#line 973
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "do_read_master", 973, "automount.c");
#line 973
          dump_core();
        }
#line 973
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 973,
                      "automount.c");
#line 973
        abort();
#line 973
        break;
      }
    }
#line 974
    pthread_exit((void *)0);
  }
#line 977
  status = pthread_mutex_unlock(& mrc.mutex);
#line 978
  if (status) {
#line 979
    while (1) {
#line 979
      if (status == 35) {
#line 979
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "do_read_master", 979, "automount.c");
#line 979
        dump_core();
      }
#line 979
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 979,
                    "automount.c");
#line 979
      abort();
#line 979
      break;
    }
  }
#line 981
  status = master_read_master(master, age, readall);
#line 983
  master->reading = 0U;
#line 985
  return ((void *)0);
}
}
#line 988 "automount.c"
static int do_hup_signal(struct master *master , time_t age ) 
{ pthread_t thid ;
  int status ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp ;
  long tmp___0 ;

  {
#line 993
  status = pthread_mutex_lock(& mrc.mutex);
#line 994
  if (status) {
#line 995
    while (1) {
#line 995
      if (status == 35) {
#line 995
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "do_hup_signal", 995, "automount.c");
#line 995
        dump_core();
      }
#line 995
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 995,
                    "automount.c");
#line 995
      abort();
#line 995
      break;
    }
  }
#line 997
  if (master->reading) {
#line 998
    status = pthread_mutex_unlock(& mrc.mutex);
#line 999
    if (status) {
#line 1000
      while (1) {
#line 1000
        if (status == 35) {
#line 1000
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "do_hup_signal", 1000, "automount.c");
#line 1000
          dump_core();
        }
#line 1000
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1000,
                      "automount.c");
#line 1000
        abort();
#line 1000
        break;
      }
    }
#line 1001
    return (1);
  }
#line 1004
  master->reading = 1U;
#line 1006
  status = pthread_create((pthread_t * __restrict  )(& thid), (pthread_attr_t const   * __restrict  )(& thread_attr),
                          & do_read_master, (void * __restrict  )((void *)0));
#line 1007
  if (status) {
#line 1008
    while (1) {
#line 1008
      ((*log_error))(master->default_logging, "%s: master read map thread create failed",
                     "do_hup_signal");
#line 1008
      break;
    }
#line 1010
    master->reading = 0U;
#line 1011
    status = pthread_mutex_unlock(& mrc.mutex);
#line 1012
    if (status) {
#line 1013
      while (1) {
#line 1013
        if (status == 35) {
#line 1013
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "do_hup_signal", 1013, "automount.c");
#line 1013
          dump_core();
        }
#line 1013
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1013,
                      "automount.c");
#line 1013
        abort();
#line 1013
        break;
      }
    }
#line 1014
    return (0);
  }
#line 1017
  mrc.thid = thid;
#line 1018
  mrc.master = master;
#line 1019
  mrc.age = age;
#line 1021
  while (1) {
#line 1021
    __cancel_routine = & do_master_cleanup_unlock;
#line 1021
    __cancel_arg = (void *)0;
#line 1021
    tmp = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf), 0);
#line 1021
    not_first_call = tmp;
#line 1021
    tmp___0 = __builtin_expect((long )not_first_call, 0L);
#line 1021
    if (tmp___0) {
#line 1021
      ((*__cancel_routine))(__cancel_arg);
#line 1021
      __pthread_unwind_next(& __cancel_buf);
    }
#line 1021
    __pthread_register_cancel(& __cancel_buf);
#line 1021
    while (1) {
#line 1023
      mrc.signaled = 0U;
#line 1024
      while (! mrc.signaled) {
#line 1025
        status = pthread_cond_wait((pthread_cond_t * __restrict  )(& mrc.cond), (pthread_mutex_t * __restrict  )(& mrc.mutex));
#line 1026
        if (status) {
#line 1027
          while (1) {
#line 1027
            if (status == 35) {
#line 1027
              ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                            "do_hup_signal", 1027, "automount.c");
#line 1027
              dump_core();
            }
#line 1027
            ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status,
                          1027, "automount.c");
#line 1027
            abort();
#line 1027
            break;
          }
        }
      }
#line 1021
      break;
    }
#line 1030
    __pthread_unregister_cancel(& __cancel_buf);
#line 1030
    ((*__cancel_routine))(__cancel_arg);
#line 1021
    break;
  }
#line 1032
  return (1);
}
}
#line 1036 "automount.c"
static void *statemachine(void *arg ) 
{ sigset_t signalset ;
  int sig ;
  int tmp ;
  time_t tmp___0 ;

  {
#line 1041
  sigfillset(& signalset);
#line 1042
  sigdelset(& signalset, 17);
#line 1043
  sigdelset(& signalset, 18);
#line 1045
  while (1) {
#line 1046
    sigwait((sigset_t const   * __restrict  )(& signalset), (int * __restrict  )(& sig));
#line 1049
    tmp = master_list_empty(master_list);
#line 1049
    if (tmp) {
#line 1050
      return ((void *)0);
    }
#line 1052
    switch (sig) {
    case 15: 
    case 12: 
    case 10: 
#line 1056
    do_signals(master_list, sig);
#line 1057
    break;
    case 1: 
#line 1060
    tmp___0 = time((time_t *)((void *)0));
#line 1060
    do_hup_signal(master_list, tmp___0);
#line 1061
    break;
    default: ;
#line 1064
    while (1) {
#line 1064
      ((*log_error))(master_list->default_logging, "%s: got unexpected signal %d!",
                     "statemachine", sig);
#line 1064
      break;
    }
#line 1066
    continue;
    }
  }
}
}
#line 1071 "automount.c"
static void return_start_status(void *arg ) 
{ struct startup_cond *sc ;
  int status ;

  {
#line 1076
  sc = (struct startup_cond *)arg;
#line 1078
  sc->done = 1U;
#line 1084
  status = pthread_cond_signal(& sc->cond);
#line 1085
  if (status) {
#line 1086
    while (1) {
#line 1086
      if (status == 35) {
#line 1086
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "return_start_status", 1086, "automount.c");
#line 1086
        dump_core();
      }
#line 1086
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1086,
                    "automount.c");
#line 1086
      abort();
#line 1086
      break;
    }
  }
#line 1088
  status = pthread_mutex_unlock(& sc->mutex);
#line 1089
  if (status) {
#line 1090
    while (1) {
#line 1090
      if (status == 35) {
#line 1090
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "return_start_status", 1090, "automount.c");
#line 1090
        dump_core();
      }
#line 1090
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1090,
                    "automount.c");
#line 1090
      abort();
#line 1090
      break;
    }
  }
#line 1091
  return;
}
}
#line 1093 "automount.c"
static void mutex_operation_wait(pthread_mutex_t *mutex___1 ) 
{ int status ;

  {
#line 1101
  status = pthread_mutex_trylock(mutex___1);
#line 1102
  if (status) {
#line 1103
    if (status == 16) {
#line 1105
      status = pthread_mutex_unlock(mutex___1);
#line 1106
      if (status) {
#line 1107
        if (status != 1) {
#line 1108
          while (1) {
#line 1108
            if (status == 35) {
#line 1108
              ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                            "mutex_operation_wait", 1108, "automount.c");
#line 1108
              dump_core();
            }
#line 1108
            ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status,
                          1108, "automount.c");
#line 1108
            abort();
#line 1108
            break;
          }
        }
      } else {
#line 1110
        return;
      }
#line 1112
      status = pthread_mutex_lock(mutex___1);
#line 1113
      if (status) {
#line 1114
        while (1) {
#line 1114
          if (status == 35) {
#line 1114
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "mutex_operation_wait", 1114, "automount.c");
#line 1114
            dump_core();
          }
#line 1114
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1114,
                        "automount.c");
#line 1114
          abort();
#line 1114
          break;
        }
      }
    } else {
#line 1116
      while (1) {
#line 1116
        if (status == 35) {
#line 1116
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "mutex_operation_wait", 1116, "automount.c");
#line 1116
          dump_core();
        }
#line 1116
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1116,
                      "automount.c");
#line 1116
        abort();
#line 1116
        break;
      }
    }
#line 1119
    status = pthread_mutex_unlock(mutex___1);
#line 1120
    if (status) {
#line 1121
      while (1) {
#line 1121
        if (status == 35) {
#line 1121
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "mutex_operation_wait", 1121, "automount.c");
#line 1121
          dump_core();
        }
#line 1121
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1121,
                      "automount.c");
#line 1121
        abort();
#line 1121
        break;
      }
    }
  } else {
#line 1123
    status = pthread_mutex_unlock(mutex___1);
#line 1124
    if (status) {
#line 1125
      while (1) {
#line 1125
        if (status == 35) {
#line 1125
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "mutex_operation_wait", 1125, "automount.c");
#line 1125
          dump_core();
        }
#line 1125
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1125,
                      "automount.c");
#line 1125
        abort();
#line 1125
        break;
      }
    }
  }
#line 1128
  return;
}
}
#line 1131 "automount.c"
static void handle_mounts_cleanup(void *arg ) 
{ struct autofs_point *ap ;
  char path___0[4097] ;
  char buf[128] ;
  unsigned int clean ;
  unsigned int submount ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char *estr ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  __pid_t tmp___12 ;
  int tmp___13 ;

  {
#line 1136
  clean = 0U;
#line 1138
  ap = (struct autofs_point *)arg;
#line 1140
  submount = ap->submount;
#line 1142
  strcpy((char * __restrict  )(path___0), (char const   * __restrict  )ap->path);
#line 1143
  if (! submount) {
#line 1143
    if (0) {
#line 1143
      __s1_len = strlen((char const   *)ap->path);
#line 1143
      __s2_len = strlen("/-");
#line 1143
      if (! ((unsigned int )((void const   *)(ap->path + 1)) - (unsigned int )((void const   *)ap->path) == 1U)) {
        goto _L___0;
      } else {
#line 1143
        if (__s1_len >= 4U) {
          _L___0: 
#line 1143
          if (! ((unsigned int )((void const   *)("/-" + 1)) - (unsigned int )((void const   *)"/-") == 1U)) {
#line 1143
            tmp___8 = 1;
          } else {
#line 1143
            if (__s2_len >= 4U) {
#line 1143
              tmp___8 = 1;
            } else {
#line 1143
              tmp___8 = 0;
            }
          }
        } else {
#line 1143
          tmp___8 = 0;
        }
      }
#line 1143
      if (tmp___8) {
#line 1143
        tmp___4 = __builtin_strcmp((char const   *)ap->path, "/-");
      } else {
#line 1143
        tmp___7 = __builtin_strcmp((char const   *)ap->path, "/-");
#line 1143
        tmp___4 = tmp___7;
      }
    } else {
#line 1143
      tmp___7 = __builtin_strcmp((char const   *)ap->path, "/-");
#line 1143
      tmp___4 = tmp___7;
    }
#line 1143
    if (tmp___4) {
#line 1143
      if (ap->dir_created) {
#line 1144
        clean = 1U;
      }
    }
  }
#line 1147
  mutex_operation_wait(& ap->state_mutex);
#line 1149
  alarm_delete(ap);
#line 1150
  st_remove_tasks(ap);
#line 1152
  umount_autofs(ap, 1);
#line 1154
  master_signal_submount(ap, 2U);
#line 1155
  master_remove_mapent(ap->entry);
#line 1156
  master_free_mapent_sources(ap->entry, 1U);
#line 1157
  master_free_mapent(ap->entry);
#line 1159
  sched_yield();
#line 1161
  if (clean) {
#line 1162
    tmp___11 = rmdir((char const   *)(path___0));
#line 1162
    if (tmp___11 == -1) {
#line 1163
      tmp___9 = __errno_location();
#line 1163
      tmp___10 = strerror_r((*tmp___9), buf, 128U);
#line 1163
      estr = tmp___10;
#line 1164
      while (1) {
#line 1164
        ((*log_warn))(0U, "%s: failed to remove dir %s: %s", "handle_mounts_cleanup",
                      path___0, estr);
#line 1164
        break;
      }
    }
  }
#line 1169
  while (1) {
#line 1169
    ((*log_info))(0U, "shut down path %s", path___0);
#line 1169
    break;
  }
#line 1172
  if (! submount) {
#line 1172
    tmp___13 = master_list_empty(master_list);
#line 1172
    if (tmp___13) {
#line 1173
      tmp___12 = getpid();
#line 1173
      kill(tmp___12, 15);
    }
  }
#line 1175
  return;
}
}
#line 1178 "automount.c"
void *handle_mounts(void *arg ) 
{ struct autofs_point *ap ;
  int cancel_state ;
  int status ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp ;
  long tmp___0 ;
  int _st_lock ;
  int tmp___1 ;
  int _st_unlock ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___0)(void * ) ;
  void *__cancel_arg___0 ;
  int not_first_call___0 ;
  int tmp___5 ;
  long tmp___6 ;
  int _st_unlock___0 ;
  int tmp___7 ;
  int ret ;
  int result ;
  int _st_lock___0 ;
  int tmp___8 ;
  int _st_unlock___1 ;
  int tmp___9 ;
  unsigned int tmp___10 ;
  int _st_unlock___2 ;
  int tmp___11 ;
  int _st_unlock___3 ;
  int tmp___12 ;
  int _st_unlock___4 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 1181
  status = 0;
#line 1183
  ap = (struct autofs_point *)arg;
#line 1185
  while (1) {
#line 1185
    __cancel_routine = & return_start_status;
#line 1185
    __cancel_arg = (void *)(& suc);
#line 1185
    tmp = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf), 0);
#line 1185
    not_first_call = tmp;
#line 1185
    tmp___0 = __builtin_expect((long )not_first_call, 0L);
#line 1185
    if (tmp___0) {
#line 1185
      ((*__cancel_routine))(__cancel_arg);
#line 1185
      __pthread_unwind_next(& __cancel_buf);
    }
#line 1185
    __pthread_register_cancel(& __cancel_buf);
#line 1185
    while (1) {
#line 1186
      pthread_setcancelstate(1, & cancel_state);
#line 1188
      while (1) {
#line 1188
        tmp___1 = pthread_mutex_lock(& ap->state_mutex);
#line 1188
        _st_lock = tmp___1;
#line 1188
        if (_st_lock) {
#line 1188
          while (1) {
#line 1188
            if (_st_lock == 35) {
#line 1188
              ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                            "handle_mounts", 1188, "automount.c");
#line 1188
              dump_core();
            }
#line 1188
            ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_lock,
                          1188, "automount.c");
#line 1188
            abort();
#line 1188
            break;
          }
        }
#line 1188
        break;
      }
#line 1190
      status = pthread_mutex_lock(& suc.mutex);
#line 1191
      if (status) {
#line 1192
        while (1) {
#line 1192
          ((*log_crit))(ap->logopt, "%s: failed to lock startup condition mutex!",
                        "handle_mounts");
#line 1192
          break;
        }
#line 1193
        while (1) {
#line 1193
          if (status == 35) {
#line 1193
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "handle_mounts", 1193, "automount.c");
#line 1193
            dump_core();
          }
#line 1193
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1193,
                        "automount.c");
#line 1193
          abort();
#line 1193
          break;
        }
      }
#line 1196
      tmp___3 = mount_autofs(ap);
#line 1196
      if (tmp___3 < 0) {
#line 1197
        while (1) {
#line 1197
          ((*log_crit))(ap->logopt, "%s: mount of %s failed!", "handle_mounts", ap->path);
#line 1197
          break;
        }
#line 1198
        suc.status = 1U;
#line 1199
        while (1) {
#line 1199
          tmp___2 = pthread_mutex_unlock(& ap->state_mutex);
#line 1199
          _st_unlock = tmp___2;
#line 1199
          if (_st_unlock) {
#line 1199
            while (1) {
#line 1199
              if (_st_unlock == 35) {
#line 1199
                ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                              "handle_mounts", 1199, "automount.c");
#line 1199
                dump_core();
              }
#line 1199
              ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_unlock,
                            1199, "automount.c");
#line 1199
              abort();
#line 1199
              break;
            }
          }
#line 1199
          break;
        }
#line 1200
        umount_autofs(ap, 1);
#line 1201
        pthread_setcancelstate(cancel_state, (int *)((void *)0));
#line 1202
        pthread_exit((void *)0);
      }
#line 1205
      if (ap->ghost) {
#line 1205
        if (ap->type != 4U) {
#line 1206
          while (1) {
#line 1206
            ((*log_info))(0U, "ghosting enabled");
#line 1206
            break;
          }
        }
      }
#line 1208
      suc.status = 0U;
#line 1185
      break;
    }
#line 1209
    __pthread_unregister_cancel(& __cancel_buf);
#line 1209
    ((*__cancel_routine))(__cancel_arg);
#line 1185
    break;
  }
#line 1213
  if (! ap->submount) {
#line 1213
    if (ap->exp_timeout) {
#line 1214
      tmp___4 = rand();
#line 1214
      alarm_add(ap, ap->exp_runfreq + (long )tmp___4 % ap->exp_runfreq);
    }
  }
#line 1216
  while (1) {
#line 1216
    __cancel_routine___0 = & handle_mounts_cleanup;
#line 1216
    __cancel_arg___0 = (void *)ap;
#line 1216
    tmp___5 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf),
                          0);
#line 1216
    not_first_call___0 = tmp___5;
#line 1216
    tmp___6 = __builtin_expect((long )not_first_call___0, 0L);
#line 1216
    if (tmp___6) {
#line 1216
      ((*__cancel_routine___0))(__cancel_arg___0);
#line 1216
      __pthread_unwind_next(& __cancel_buf___0);
    }
#line 1216
    __pthread_register_cancel(& __cancel_buf___0);
#line 1216
    while (1) {
#line 1217
      pthread_setcancelstate(cancel_state, (int *)((void *)0));
#line 1219
      while (1) {
#line 1219
        tmp___7 = pthread_mutex_unlock(& ap->state_mutex);
#line 1219
        _st_unlock___0 = tmp___7;
#line 1219
        if (_st_unlock___0) {
#line 1219
          while (1) {
#line 1219
            if (_st_unlock___0 == 35) {
#line 1219
              ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                            "handle_mounts", 1219, "automount.c");
#line 1219
              dump_core();
            }
#line 1219
            ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_unlock___0,
                          1219, "automount.c");
#line 1219
            abort();
#line 1219
            break;
          }
        }
#line 1219
        break;
      }
#line 1221
      while ((int )ap->state != 7) {
#line 1222
        tmp___14 = handle_packet(ap);
#line 1222
        if (tmp___14) {
#line 1225
          while (1) {
#line 1225
            tmp___8 = pthread_mutex_lock(& ap->state_mutex);
#line 1225
            _st_lock___0 = tmp___8;
#line 1225
            if (_st_lock___0) {
#line 1225
              while (1) {
#line 1225
                if (_st_lock___0 == 35) {
#line 1225
                  ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                                "handle_mounts", 1225, "automount.c");
#line 1225
                  dump_core();
                }
#line 1225
                ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_lock___0,
                              1225, "automount.c");
#line 1225
                abort();
#line 1225
                break;
              }
            }
#line 1225
            break;
          }
#line 1230
          if (ap->type == 4U) {
#line 1231
            status = 1;
#line 1232
            while (1) {
#line 1232
              tmp___9 = pthread_mutex_unlock(& ap->state_mutex);
#line 1232
              _st_unlock___1 = tmp___9;
#line 1232
              if (_st_unlock___1) {
#line 1232
                while (1) {
#line 1232
                  if (_st_unlock___1 == 35) {
#line 1232
                    ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                                  "handle_mounts", 1232, "automount.c");
#line 1232
                    dump_core();
                  }
#line 1232
                  ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_unlock___1,
                                1232, "automount.c");
#line 1232
                  abort();
#line 1232
                  break;
                }
              }
#line 1232
              break;
            }
#line 1233
            break;
          }
#line 1240
          if (sizeof(int ) == sizeof(int [1])) {
#line 1240
            if (sizeof(int ) < 16384U) {
#line 1240
              tmp___10 = sizeof(int );
            } else {
#line 1240
              tmp___10 = __invalid_size_argument_for_IOC;
            }
          } else {
#line 1240
            tmp___10 = __invalid_size_argument_for_IOC;
          }
#line 1240
          ret = ioctl(ap->ioctlfd, (unsigned long )(2147521392U | (tmp___10 << 16)),
                      & result);
#line 1241
          if (ret == -1) {
#line 1242
            while (1) {
#line 1242
              tmp___11 = pthread_mutex_unlock(& ap->state_mutex);
#line 1242
              _st_unlock___2 = tmp___11;
#line 1242
              if (_st_unlock___2) {
#line 1242
                while (1) {
#line 1242
                  if (_st_unlock___2 == 35) {
#line 1242
                    ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                                  "handle_mounts", 1242, "automount.c");
#line 1242
                    dump_core();
                  }
#line 1242
                  ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_unlock___2,
                                1242, "automount.c");
#line 1242
                  abort();
#line 1242
                  break;
                }
              }
#line 1242
              break;
            }
#line 1243
            break;
          }
#line 1247
          if ((int )ap->state == 7) {
            goto _L;
          } else {
#line 1247
            if (result) {
              _L: 
#line 1248
              while (1) {
#line 1248
                tmp___12 = pthread_mutex_unlock(& ap->state_mutex);
#line 1248
                _st_unlock___3 = tmp___12;
#line 1248
                if (_st_unlock___3) {
#line 1248
                  while (1) {
#line 1248
                    if (_st_unlock___3 == 35) {
#line 1248
                      ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                                    "handle_mounts", 1248, "automount.c");
#line 1248
                      dump_core();
                    }
#line 1248
                    ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s",
                                  _st_unlock___3, 1248, "automount.c");
#line 1248
                    abort();
#line 1248
                    break;
                  }
                }
#line 1248
                break;
              }
#line 1249
              break;
            }
          }
#line 1253
          while (1) {
#line 1253
            ((*log_warn))(ap->logopt, "%s: can\'t shutdown: filesystem %s still busy",
                          "handle_mounts", ap->path);
#line 1253
            break;
          }
#line 1256
          if (! ap->submount) {
#line 1257
            alarm_add(ap, ap->exp_runfreq);
          }
#line 1258
          nextstate(ap->state_pipe[1], (enum states )1);
#line 1260
          while (1) {
#line 1260
            tmp___13 = pthread_mutex_unlock(& ap->state_mutex);
#line 1260
            _st_unlock___4 = tmp___13;
#line 1260
            if (_st_unlock___4) {
#line 1260
              while (1) {
#line 1260
                if (_st_unlock___4 == 35) {
#line 1260
                  ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                                "handle_mounts", 1260, "automount.c");
#line 1260
                  dump_core();
                }
#line 1260
                ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_unlock___4,
                              1260, "automount.c");
#line 1260
                abort();
#line 1260
                break;
              }
            }
#line 1260
            break;
          }
        }
      }
#line 1216
      break;
    }
#line 1264
    __pthread_unregister_cancel(& __cancel_buf___0);
#line 1264
    ((*__cancel_routine___0))(__cancel_arg___0);
#line 1216
    break;
  }
#line 1281
  sched_yield();
#line 1283
  return ((void *)0);
}
}
#line 1286 "automount.c"
static void key_thread_stdenv_vars_destroy(void *arg ) 
{ struct thread_stdenv_vars *tsv ;

  {
#line 1290
  tsv = (struct thread_stdenv_vars *)arg;
#line 1291
  if (tsv->user) {
#line 1292
    free((void *)tsv->user);
  }
#line 1293
  if (tsv->group) {
#line 1294
    free((void *)tsv->group);
  }
#line 1295
  if (tsv->home) {
#line 1296
    free((void *)tsv->home);
  }
#line 1297
  free((void *)tsv);
#line 1298
  return;
}
}
#line 1301 "automount.c"
static int is_automount_running(void) 
{ FILE *fp ;
  DIR *dir ;
  struct dirent entry ;
  struct dirent *result ;
  char path___0[4097] ;
  char buf[4096] ;
  int path_len ;
  int pid ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned short const   **tmp___9 ;
  __pid_t tmp___10 ;
  int c ;
  int len ;
  int tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;

  {
#line 1309
  dir = opendir("/proc");
#line 1309
  if ((unsigned int )dir == (unsigned int )((void *)0)) {
#line 1310
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"cannot opendir(/proc)\n");
#line 1311
    exit(1);
  }
#line 1314
  while (1) {
#line 1314
    tmp___13 = readdir_r((DIR * __restrict  )dir, (struct dirent * __restrict  )(& entry),
                         (struct dirent ** __restrict  )(& result));
#line 1314
    if (! (tmp___13 == 0)) {
#line 1314
      break;
    }
#line 1315
    pid = 0;
#line 1317
    if (! result) {
#line 1318
      break;
    }
#line 1320
    if ((int )entry.d_name[0] == 46) {
#line 1321
      continue;
    }
#line 1323
    if (0) {
#line 1323
      __s1_len = strlen((char const   *)(entry.d_name));
#line 1323
      __s2_len = strlen("self");
#line 1323
      if (! ((unsigned int )((void const   *)(entry.d_name + 1)) - (unsigned int )((void const   *)(entry.d_name)) == 1U)) {
        goto _L___0;
      } else {
#line 1323
        if (__s1_len >= 4U) {
          _L___0: 
#line 1323
          if (! ((unsigned int )((void const   *)("self" + 1)) - (unsigned int )((void const   *)"self") == 1U)) {
#line 1323
            tmp___8 = 1;
          } else {
#line 1323
            if (__s2_len >= 4U) {
#line 1323
              tmp___8 = 1;
            } else {
#line 1323
              tmp___8 = 0;
            }
          }
        } else {
#line 1323
          tmp___8 = 0;
        }
      }
#line 1323
      if (tmp___8) {
#line 1323
        tmp___4 = __builtin_strcmp((char const   *)(entry.d_name), "self");
      } else {
#line 1323
        tmp___7 = __builtin_strcmp((char const   *)(entry.d_name), "self");
#line 1323
        tmp___4 = tmp___7;
      }
    } else {
#line 1323
      tmp___7 = __builtin_strcmp((char const   *)(entry.d_name), "self");
#line 1323
      tmp___4 = tmp___7;
    }
#line 1323
    if (! tmp___4) {
#line 1324
      continue;
    }
#line 1326
    tmp___9 = __ctype_b_loc();
#line 1326
    if (! ((int const   )(*((*tmp___9) + (int )entry.d_name[0])) & 2048)) {
#line 1327
      continue;
    }
#line 1329
    pid = atoi__extinline((char const   *)(entry.d_name));
#line 1330
    tmp___10 = getpid();
#line 1330
    if (pid == tmp___10) {
#line 1331
      continue;
    }
#line 1333
    path_len = sprintf((char * __restrict  )(path___0), (char const   * __restrict  )"/proc/%s/cmdline",
                       entry.d_name);
#line 1334
    if (path_len >= 4096) {
#line 1335
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"buffer to small for /proc path\n");
#line 1337
      return (-1);
    }
#line 1339
    path___0[path_len] = (char )'\000';
#line 1341
    fp = fopen((char const   * __restrict  )(path___0), (char const   * __restrict  )"r");
#line 1342
    if (fp) {
#line 1343
      len = 0;
#line 1345
      while (1) {
#line 1345
        if (len < 127) {
#line 1345
          c = fgetc(fp);
#line 1345
          if (c != -1) {
#line 1345
            if (! c) {
#line 1345
              break;
            }
          } else {
#line 1345
            break;
          }
        } else {
#line 1345
          break;
        }
#line 1346
        tmp___11 = len;
#line 1346
        len ++;
#line 1346
        buf[tmp___11] = (char )c;
      }
#line 1347
      buf[len] = (char )'\000';
#line 1349
      tmp___12 = strstr((char const   *)(buf), "automount");
#line 1349
      if (tmp___12) {
#line 1350
        return (pid);
      }
#line 1351
      fclose(fp);
    }
  }
#line 1354
  closedir(dir);
#line 1356
  return (0);
}
}
#line 1359 "automount.c"
static void usage(void) 
{ 

  {
#line 1361
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: %s [options] [master_map_name]\n\t-h --help\tthis text\n\t-p --pid-file f write process id to file f\n\t-t --timeout n\tauto-unmount in n seconds (0-disable)\n\t-v --verbose\tbe verbose\n\t-d --debug\tlog debuging info\n\t-D --define\tdefine global macro variable\n\t-r --random-replicated-selection\n\t\t\tuse ramdom replicated server selection\n\t-O --global-options\n\t\t\tspecify global mount options\n\t-V --version\tprint version, build config and exit\n",
          program);
#line 1376
  return;
}
}
#line 1378 "automount.c"
static void show_build_info(void) 
{ char buf[2048] ;
  int count ;

  {
#line 1381
  count = 0;
#line 1383
  printf((char const   * __restrict  )"\nLinux automount version %s\n", version);
#line 1385
  printf((char const   * __restrict  )"\nDirectories:\n");
#line 1386
  printf((char const   * __restrict  )"\tconfig dir:\t%s\n", confdir);
#line 1387
  printf((char const   * __restrict  )"\tmaps dir:\t%s\n", mapdir);
#line 1388
  printf((char const   * __restrict  )"\tmodules dir:\t%s\n", libdir);
#line 1390
  printf((char const   * __restrict  )"\nCompile options:\n  ");
#line 1392
  memset((void *)(buf), 0, 2048U);
#line 1450
  printf((char const   * __restrict  )"\n\n");
#line 1452
  return;
}
}
#line 1464
int main(int argc , char **argv ) ;
#line 1464 "automount.c"
static struct option  const  long_options[11]  = 
#line 1464
  {      {"help", 0, (int *)0, 'h'}, 
        {"pid-file", 1, (int *)0, 'p'}, 
        {"timeout", 1, (int *)0, 't'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"debug", 0, (int *)0, 'd'}, 
        {"define", 1, (int *)0, 'D'}, 
        {"foreground", 0, (int *)0, 'f'}, 
        {"random-selection", 0, (int *)0, 'r'}, 
        {"global-options", 1, (int *)0, 'O'}, 
        {"version", 0, (int *)0, 'V'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 1455 "automount.c"
int main(int argc , char **argv ) 
{ int res ;
  int opt ;
  int status ;
  unsigned int ghost___0 ;
  unsigned int logging ;
  unsigned int foreground ;
  unsigned int have_global_options ;
  time_t timeout___0 ;
  time_t age ;
  time_t tmp ;
  sigset_t allsigs ;
  struct rlimit rlim ;
  __uid_t tmp___10 ;
  int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  unsigned int tmp___17 ;
  unsigned int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 1461
  tmp = time((time_t *)((void *)0));
#line 1461
  age = tmp;
#line 1478
  sigfillset(& allsigs);
#line 1479
  sigprocmask(0, (sigset_t const   * __restrict  )(& allsigs), (sigset_t * __restrict  )((void *)0));
#line 1481
  program = (char const   *)(*(argv + 0));
#line 1483
  defaults_read_config();
#line 1485
  kpkt_len = get_kpkt_len();
#line 1486
  timeout___0 = (time_t )defaults_get_timeout();
#line 1487
  ghost___0 = defaults_get_browse_mode();
#line 1488
  logging = defaults_get_logging();
#line 1489
  random_selection = 0U;
#line 1490
  global_options = (char const   *)((void *)0);
#line 1491
  have_global_options = 0U;
#line 1492
  foreground = 0U;
#line 1494
  opterr = 0;
#line 1495
  while (1) {
#line 1495
    opt = getopt_long(argc, (char * const  *)argv, "+hp:t:vdD:fVrO:", long_options,
                      (int *)((void *)0));
#line 1495
    if (! (opt != -1)) {
#line 1495
      break;
    }
#line 1496
    switch (opt) {
    case 104: 
#line 1498
    usage();
#line 1499
    exit(0);
    case 112: 
#line 1502
    pid_file = optarg;
#line 1503
    break;
    case 116: 
#line 1506
    timeout___0 = (time_t )getnumopt(optarg, (char )opt);
#line 1507
    break;
    case 118: 
#line 1510
    logging |= 2U;
#line 1511
    break;
    case 100: 
#line 1514
    logging |= 1U;
#line 1515
    break;
    case 68: 
#line 1518
    macro_parse_globalvar((char const   *)optarg);
#line 1519
    break;
    case 102: 
#line 1522
    foreground = 1U;
#line 1523
    break;
    case 86: 
#line 1526
    show_build_info();
#line 1527
    exit(0);
    case 114: 
#line 1530
    random_selection = 1U;
#line 1531
    break;
    case 79: 
#line 1534
    if (! have_global_options) {
#line 1535
      global_options = (char const   *)__strdup((char const   *)optarg);
#line 1536
      have_global_options = 1U;
#line 1537
      break;
    }
#line 1539
    printf((char const   * __restrict  )"%s: global options already specified.\n",
           program);
#line 1541
    break;
    case 63: 
    case 58: 
#line 1545
    printf((char const   * __restrict  )"%s: Ambiguous or unknown options\n", program);
#line 1546
    exit(1);
    }
  }
#line 1550
  if (logging & 2U) {
#line 1551
    set_log_verbose();
  }
#line 1553
  if (logging & 1U) {
#line 1554
    set_log_debug();
  }
#line 1556
  tmp___10 = geteuid();
#line 1556
  if (tmp___10 != 0U) {
#line 1557
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: this program must be run by root.\n",
            program);
#line 1559
    exit(1);
  }
#line 1563
  argv += optind;
#line 1564
  argc -= optind;
#line 1566
  tmp___11 = is_automount_running();
#line 1566
  if (tmp___11 > 0) {
#line 1567
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: program is already running.\n",
            program);
#line 1569
    exit(1);
  }
#line 1579
  tmp___12 = query_kproto_ver();
#line 1579
  if (tmp___12) {
#line 1579
    tmp___13 = get_kver_major();
#line 1579
    if (tmp___13 < 5U) {
#line 1580
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: kernel protocol version 5.00 or above required.\n",
              program);
#line 1583
      exit(1);
    }
  } else {
#line 1580
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: kernel protocol version 5.00 or above required.\n",
            program);
#line 1583
    exit(1);
  }
#line 1586
  rlim.rlim_cur = 10240UL;
#line 1587
  rlim.rlim_max = 10240UL;
#line 1588
  res = setrlimit((enum __rlimit_resource )7, (struct rlimit  const  *)(& rlim));
#line 1589
  if (res) {
#line 1590
    while (1) {
#line 1590
      ((*log_warn))(0U, "%s: can\'t increase open file limit - continuing", "main");
#line 1590
      break;
    }
  }
#line 1594
  rlim.rlim_cur = ~ 0UL;
#line 1595
  rlim.rlim_max = ~ 0UL;
#line 1596
  res = setrlimit((enum __rlimit_resource )4, (struct rlimit  const  *)(& rlim));
#line 1597
  if (res) {
#line 1598
    while (1) {
#line 1598
      ((*log_warn))(0U, "%s: can\'t increase core file limit - continuing", "main");
#line 1598
      break;
    }
  }
#line 1602
  become_daemon(foreground);
#line 1604
  if (argc == 0) {
#line 1605
    master_list = master_new((char const   *)((void *)0), (unsigned int )timeout___0,
                             ghost___0);
  } else {
#line 1607
    master_list = master_new((char const   *)(*(argv + 0)), (unsigned int )timeout___0,
                             ghost___0);
  }
#line 1609
  if (! master_list) {
#line 1610
    while (1) {
#line 1610
      ((*log_crit))(3U, "%s: %s: can\'t create master map %s", "main", program, (*(argv + 0)));
#line 1610
      break;
    }
#line 1612
    close(start_pipefd[1]);
#line 1613
    exit(1);
  }
#line 1616
  tmp___14 = pthread_attr_init(& thread_attr);
#line 1616
  if (tmp___14) {
#line 1617
    while (1) {
#line 1617
      ((*log_crit))(3U, "%s: %s: failed to init thread attribute struct!", "main",
                    program);
#line 1617
      break;
    }
#line 1620
    close(start_pipefd[1]);
#line 1621
    exit(1);
  }
#line 1624
  tmp___15 = pthread_attr_setdetachstate(& thread_attr, 1);
#line 1624
  if (tmp___15) {
#line 1626
    while (1) {
#line 1626
      ((*log_crit))(3U, "%s: %s: failed to set detached thread attribute!", "main",
                    program);
#line 1626
      break;
    }
#line 1629
    close(start_pipefd[1]);
#line 1630
    exit(1);
  }
#line 1634
  tmp___16 = pthread_attr_setstacksize(& thread_attr, 1048576U);
#line 1634
  if (tmp___16) {
#line 1636
    while (1) {
#line 1636
      ((*log_crit))(3U, "%s: %s: failed to set stack size thread attribute!", "main",
                    program);
#line 1636
      break;
    }
#line 1639
    close(start_pipefd[1]);
#line 1640
    exit(1);
  }
#line 1644
  while (1) {
#line 1644
    ((*log_info))(0U, "Starting automounter version %s, master map %s", version, master_list->name);
#line 1644
    break;
  }
#line 1646
  while (1) {
#line 1646
    tmp___17 = get_kver_minor();
#line 1646
    tmp___18 = get_kver_major();
#line 1646
    ((*log_info))(0U, "using kernel protocol version %d.%02d", tmp___18, tmp___17);
#line 1646
    break;
  }
#line 1649
  status = pthread_key_create(& key_thread_stdenv_vars, & key_thread_stdenv_vars_destroy);
#line 1651
  if (status) {
#line 1652
    while (1) {
#line 1652
      ((*log_crit))(3U, "%s: failed to create thread data key for std env vars!",
                    "main");
#line 1652
      break;
    }
#line 1654
    master_kill(master_list);
#line 1655
    close(start_pipefd[1]);
#line 1656
    exit(1);
  }
#line 1659
  tmp___19 = alarm_start_handler();
#line 1659
  if (! tmp___19) {
#line 1660
    while (1) {
#line 1660
      ((*log_crit))(3U, "%s: failed to create alarm handler thread!", "main");
#line 1660
      break;
    }
#line 1661
    master_kill(master_list);
#line 1662
    close(start_pipefd[1]);
#line 1663
    exit(1);
  }
#line 1666
  tmp___20 = st_start_handler();
#line 1666
  if (! tmp___20) {
#line 1667
    while (1) {
#line 1667
      ((*log_crit))(3U, "%s: failed to create FSM handler thread!", "main");
#line 1667
      break;
    }
#line 1668
    master_kill(master_list);
#line 1669
    close(start_pipefd[1]);
#line 1670
    exit(1);
  }
#line 1672
  tmp___21 = master_read_master(master_list, age, 0);
#line 1672
  if (! tmp___21) {
#line 1673
    master_kill(master_list);
#line 1674
    (*pst_stat) = 3;
#line 1675
    res = write(start_pipefd[1], (void const   *)pst_stat, sizeof(pst_stat));
#line 1676
    close(start_pipefd[1]);
#line 1677
    exit(3);
  }
#line 1680
  res = write(start_pipefd[1], (void const   *)pst_stat, sizeof(pst_stat));
#line 1681
  close(start_pipefd[1]);
#line 1683
  statemachine((void *)0);
#line 1685
  master_kill(master_list);
#line 1687
  if (pid_file) {
#line 1688
    unlink((char const   *)pid_file);
#line 1689
    pid_file = (char *)((void *)0);
  }
#line 1691
  closelog();
#line 1693
  exit(0);
}
}
#line 1 "indirect.o"
#pragma merger(0,"/tmp/cil-13QBzBas.i","-O2,-Wall,-fPIE")
#line 397 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf )  __attribute__((__nonnull__(3))) ;
#line 464
__inline static  __attribute__((__nothrow__)) int fstat__extinline(int __fd , struct stat *__statbuf ) ;
#line 464
__inline static  __attribute__((__nothrow__)) int fstat__extinline(int __fd , struct stat *__statbuf ) ;
#line 464 "/usr/include/sys/stat.h"
__inline static int fstat__extinline(int __fd , struct stat *__statbuf ) 
{ int tmp ;

  {
#line 467
  tmp = __fxstat(3, __fd, __statbuf);
#line 467
  return (tmp);
}
}
#line 76 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 85
extern int open(char const   *__file , int __oflag  , ...)  __attribute__((__nonnull__(1))) ;
#line 589 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 564 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long sysconf(int __name ) ;
#line 581
extern  __attribute__((__nothrow__)) __pid_t getpgrp(void) ;
#line 107 "/usr/include/sys/mount.h"
extern  __attribute__((__nothrow__)) int mount(char const   *__special_file , char const   *__dir ,
                                               char const   *__fstype , unsigned long __rwflag ,
                                               void const   *__data ) ;
#line 112
extern  __attribute__((__nothrow__)) int umount(char const   *__special_file ) ;
#line 115
extern  __attribute__((__nothrow__)) int umount2(char const   *__special_file , int __flags ) ;
#line 145 "/usr/include/pwd.h"
extern int getpwuid_r(__uid_t __uid , struct passwd * __restrict  __resultbuf , char * __restrict  __buffer ,
                      size_t __buflen , struct passwd ** __restrict  __result ) ;
#line 142 "/usr/include/grp.h"
extern int getgrgid_r(__gid_t __gid , struct group * __restrict  __resultbuf , char * __restrict  __buffer ,
                      size_t __buflen , struct group ** __restrict  __result ) ;
#line 327 "/usr/include/time.h"
extern int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
#line 487 "/usr/include/pthread.h"
extern void pthread_testcancel(void) ;
#line 923
extern  __attribute__((__nothrow__)) int pthread_cond_init(pthread_cond_t * __restrict  __cond ,
                                                           pthread_condattr_t const   * __restrict  __cond_attr )  __attribute__((__nonnull__(1))) ;
#line 928
extern  __attribute__((__nothrow__)) int pthread_cond_destroy(pthread_cond_t *__cond )  __attribute__((__nonnull__(1))) ;
#line 1077
extern  __attribute__((__nothrow__)) int pthread_setspecific(pthread_key_t __key ,
                                                             void const   *__pointer ) ;
#line 84 "../include/state.h"
void expire_cleanup(void *arg ) ;
#line 105 "../include/master.h"
int master_notify_submount(struct autofs_point *ap , char const   *path___1 , enum states state ) ;
#line 206 "../include/automount.h"
int spawn_umount(logger *log  , ...) ;
#line 225
int lookup_nss_read_map(struct autofs_point *ap , struct map_source *source , time_t age ) ;
#line 228
int lookup_ghost(struct autofs_point *ap ) ;
#line 229
int lookup_nss_mount(struct autofs_point *ap , struct map_source *source , char const   *name ,
                     int name_len ) ;
#line 231
int lookup_prune_cache(struct autofs_point *ap , time_t age ) ;
#line 234
int lookup_source_close_ioctlfd(struct autofs_point *ap , char const   *key ) ;
#line 358
char *make_options_string(char *path___1 , int pipefd , char *extra ) ;
#line 360
struct mnt_list *get_mnt_list(char const   *table , char const   *path___1 , int include ) ;
#line 362
void free_mnt_list(struct mnt_list *list ) ;
#line 467
void *expire_proc_indirect(void *arg ) ;
#line 43 "indirect.c"
static union __anonunion_pthread_mutex_t_6 ma_mutex  =    {{0, 0U, 0, 0, 0U, {0}}};
#line 44 "indirect.c"
static union __anonunion_pthread_mutex_t_6 ea_mutex  =    {{0, 0U, 0, 0, 0U, {0}}};
#line 46 "indirect.c"
static int autofs_init_indirect(struct autofs_point *ap ) 
{ int pipefd[2] ;
  int cl_flags ;
  int tmp ;
  int tmp___0 ;

  {
#line 50
  if ((int )ap->state != 0) {
#line 52
    while (1) {
#line 52
      ((*log_error))(ap->logopt, "%s: bad state %d", "autofs_init_indirect", ap->state);
#line 52
      break;
    }
#line 53
    return (-1);
  }
#line 56
  ap->ioctlfd = -1;
#line 56
  ap->kpipefd = ap->ioctlfd;
#line 56
  ap->pipefd = ap->kpipefd;
#line 59
  tmp = pipe(pipefd);
#line 59
  if (tmp < 0) {
#line 60
    while (1) {
#line 60
      ((*log_crit))(ap->logopt, "%s: failed to create commumication pipe for autofs path %s",
                    "autofs_init_indirect", ap->path);
#line 60
      break;
    }
#line 63
    free((void *)ap->path);
#line 64
    return (-1);
  }
#line 67
  ap->pipefd = pipefd[0];
#line 68
  ap->kpipefd = pipefd[1];
#line 70
  cl_flags = fcntl(ap->pipefd, 1, 0);
#line 70
  if (cl_flags != -1) {
#line 71
    cl_flags |= 1;
#line 72
    fcntl(ap->pipefd, 2, cl_flags);
  }
#line 75
  cl_flags = fcntl(ap->kpipefd, 1, 0);
#line 75
  if (cl_flags != -1) {
#line 76
    cl_flags |= 1;
#line 77
    fcntl(ap->kpipefd, 2, cl_flags);
  }
#line 81
  tmp___0 = pipe(ap->state_pipe);
#line 81
  if (tmp___0 < 0) {
#line 82
    while (1) {
#line 82
      ((*log_crit))(ap->logopt, "%s: failed create state pipe for autofs path %s",
                    "autofs_init_indirect", ap->path);
#line 82
      break;
    }
#line 84
    close(ap->pipefd);
#line 85
    close(ap->kpipefd);
#line 86
    free((void *)ap->path);
#line 87
    return (-1);
  }
#line 90
  cl_flags = fcntl(ap->state_pipe[0], 1, 0);
#line 90
  if (cl_flags != -1) {
#line 91
    cl_flags |= 1;
#line 92
    fcntl(ap->state_pipe[0], 2, cl_flags);
  }
#line 95
  cl_flags = fcntl(ap->state_pipe[1], 1, 0);
#line 95
  if (cl_flags != -1) {
#line 96
    cl_flags |= 1;
#line 97
    fcntl(ap->state_pipe[1], 2, cl_flags);
  }
#line 100
  return (0);
}
}
#line 103 "indirect.c"
static int unlink_mount_tree(struct autofs_point *ap , struct mnt_list *mnts ) 
{ struct mnt_list *this ;
  int rv ;
  int ret ;
  pid_t pgrp ;
  pid_t tmp ;
  char spgrp[20] ;
  char *tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;

  {
#line 107
  tmp = getpgrp();
#line 107
  pgrp = tmp;
#line 110
  sprintf((char * __restrict  )(spgrp), (char const   * __restrict  )"pgrp=%d", pgrp);
#line 112
  ret = 1;
#line 113
  this = mnts;
#line 114
  while (this) {
#line 115
    tmp___0 = strstr((char const   *)this->opts, (char const   *)(spgrp));
#line 115
    if (tmp___0) {
#line 116
      this = this->next;
#line 117
      continue;
    }
#line 120
    if (0) {
#line 120
      __s1_len = strlen((char const   *)this->fs_type);
#line 120
      __s2_len = strlen("autofs");
#line 120
      if (! ((unsigned int )((void const   *)(this->fs_type + 1)) - (unsigned int )((void const   *)this->fs_type) == 1U)) {
        goto _L___0;
      } else {
#line 120
        if (__s1_len >= 4U) {
          _L___0: 
#line 120
          if (! ((unsigned int )((void const   *)("autofs" + 1)) - (unsigned int )((void const   *)"autofs") == 1U)) {
#line 120
            tmp___10 = 1;
          } else {
#line 120
            if (__s2_len >= 4U) {
#line 120
              tmp___10 = 1;
            } else {
#line 120
              tmp___10 = 0;
            }
          }
        } else {
#line 120
          tmp___10 = 0;
        }
      }
#line 120
      if (tmp___10) {
#line 120
        tmp___6 = __builtin_strcmp((char const   *)this->fs_type, "autofs");
      } else {
#line 120
        tmp___9 = __builtin_strcmp((char const   *)this->fs_type, "autofs");
#line 120
        tmp___6 = tmp___9;
      }
    } else {
#line 120
      tmp___9 = __builtin_strcmp((char const   *)this->fs_type, "autofs");
#line 120
      tmp___6 = tmp___9;
    }
#line 120
    if (tmp___6) {
#line 121
      rv = spawn_umount(log_debug, "-l", this->path, (void *)0);
    } else {
#line 123
      rv = umount2((char const   *)this->path, 2);
    }
#line 124
    if (rv == -1) {
#line 125
      ret = 0;
#line 126
      while (1) {
#line 126
        ((*log_debug))(ap->logopt, "%s: can\'t unlink %s from mount tree", "unlink_mount_tree",
                       this->path);
#line 126
        break;
      }
#line 129
      tmp___11 = __errno_location();
#line 129
      switch ((*tmp___11)) {
      case 22: 
#line 131
      while (1) {
#line 131
        ((*log_warn))(ap->logopt, "%s: bad superblock or not mounted", "unlink_mount_tree");
#line 131
        break;
      }
#line 133
      break;
      case 2: 
      case 14: 
#line 137
      while (1) {
#line 137
        ((*log_warn))(ap->logopt, "%s: bad path for mount", "unlink_mount_tree");
#line 137
        break;
      }
#line 138
      break;
      }
    }
#line 141
    this = this->next;
  }
#line 143
  return (ret);
}
}
#line 146 "indirect.c"
static int do_mount_autofs_indirect(struct autofs_point *ap ) 
{ time_t timeout___0 ;
  char *options ;
  char const   *type___0 ;
  char const   *map_name ;
  struct stat st ;
  struct mnt_list *mnts ;
  int cl_flags ;
  int ret ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___9 ;
  int tmp___12 ;
  int tmp___13 ;
  unsigned int tmp___14 ;

  {
#line 148
  timeout___0 = ap->exp_timeout;
#line 149
  options = (char *)((void *)0);
#line 150
  map_name = (char const   *)((void *)0);
#line 155
  mnts = get_mnt_list("/proc/mounts", (char const   *)ap->path, 1);
#line 156
  if (mnts) {
#line 157
    ret = unlink_mount_tree(ap, mnts);
#line 158
    free_mnt_list(mnts);
#line 159
    if (! ret) {
#line 160
      while (1) {
#line 160
        ((*log_debug))(ap->logopt, "%s: already mounted as other than autofs or failed to unlink entry in tree",
                       "do_mount_autofs_indirect");
#line 160
        break;
      }
      goto out_err;
    }
  }
#line 167
  options = make_options_string(ap->path, ap->kpipefd, (char *)((void *)0));
#line 168
  if (! options) {
    goto out_err;
  }
#line 172
  tmp___1 = mkdir_path((char const   *)ap->path, 365U);
#line 172
  if (tmp___1 < 0) {
#line 173
    tmp = __errno_location();
#line 173
    if ((*tmp) != 17) {
#line 173
      tmp___0 = __errno_location();
#line 173
      if ((*tmp___0) != 30) {
#line 174
        while (1) {
#line 174
          ((*log_crit))(ap->logopt, "%s: failed to create autofs directory %s", "do_mount_autofs_indirect",
                        ap->path);
#line 174
          break;
        }
        goto out_err;
      }
    }
#line 181
    ap->dir_created = 0U;
  } else {
#line 184
    ap->dir_created = 1U;
  }
#line 187
  type___0 = (char const   *)((ap->entry)->maps)->type;
#line 188
  if (type___0) {
#line 188
    if (0) {
#line 188
      __s1_len = strlen((char const   *)((ap->entry)->maps)->type);
#line 188
      __s2_len = strlen("hosts");
#line 188
      if (! ((unsigned int )((void const   *)(((ap->entry)->maps)->type + 1)) - (unsigned int )((void const   *)((ap->entry)->maps)->type) == 1U)) {
        goto _L___0;
      } else {
#line 188
        if (__s1_len >= 4U) {
          _L___0: 
#line 188
          if (! ((unsigned int )((void const   *)("hosts" + 1)) - (unsigned int )((void const   *)"hosts") == 1U)) {
#line 188
            tmp___13 = 1;
          } else {
#line 188
            if (__s2_len >= 4U) {
#line 188
              tmp___13 = 1;
            } else {
#line 188
              tmp___13 = 0;
            }
          }
        } else {
#line 188
          tmp___13 = 0;
        }
      }
#line 188
      if (tmp___13) {
#line 188
        tmp___9 = __builtin_strcmp((char const   *)((ap->entry)->maps)->type, "hosts");
      } else {
#line 188
        tmp___12 = __builtin_strcmp((char const   *)((ap->entry)->maps)->type, "hosts");
#line 188
        tmp___9 = tmp___12;
      }
    } else {
#line 188
      tmp___12 = __builtin_strcmp((char const   *)((ap->entry)->maps)->type, "hosts");
#line 188
      tmp___9 = tmp___12;
    }
#line 188
    if (tmp___9) {
#line 195
      map_name = (*(((ap->entry)->maps)->argv + 0));
    } else {
#line 189
      tmp___3 = (char *)__builtin_alloca(7U);
#line 189
      tmp___2 = tmp___3;
#line 190
      if (tmp___2) {
#line 191
        strcpy((char * __restrict  )tmp___2, (char const   * __restrict  )"-hosts");
#line 192
        map_name = (char const   *)tmp___2;
      }
    }
  } else {
#line 195
    map_name = (*(((ap->entry)->maps)->argv + 0));
  }
#line 197
  ret = mount(map_name, (char const   *)ap->path, "autofs", 3236757504UL, (void const   *)options);
#line 198
  if (ret) {
#line 199
    while (1) {
#line 199
      ((*log_crit))(ap->logopt, "%s: failed to mount autofs path %s", "do_mount_autofs_indirect",
                    ap->path);
#line 199
      break;
    }
    goto out_rmdir;
  }
#line 203
  free((void *)options);
#line 205
  options = (char *)((void *)0);
#line 208
  ap->ioctlfd = open((char const   *)ap->path, 0);
#line 209
  if (ap->ioctlfd < 0) {
#line 210
    while (1) {
#line 210
      ((*log_crit))(ap->logopt, "%s: failed to create ioctl fd for autofs path %s",
                    "do_mount_autofs_indirect", ap->path);
#line 210
      break;
    }
    goto out_umount;
  }
#line 215
  cl_flags = fcntl(ap->ioctlfd, 1, 0);
#line 215
  if (cl_flags != -1) {
#line 216
    cl_flags |= 1;
#line 217
    fcntl(ap->ioctlfd, 2, cl_flags);
  }
#line 220
  ap->exp_runfreq = ((timeout___0 + 4L) - 1L) / 4L;
#line 222
  if (sizeof(unsigned long ) == sizeof(unsigned long [1])) {
#line 222
    if (sizeof(unsigned long ) < 16384U) {
#line 222
      tmp___14 = sizeof(unsigned long );
    } else {
#line 222
      tmp___14 = __invalid_size_argument_for_IOC;
    }
  } else {
#line 222
    tmp___14 = __invalid_size_argument_for_IOC;
  }
#line 222
  ioctl(ap->ioctlfd, (unsigned long )(3221263204U | (tmp___14 << 16)), & timeout___0);
#line 224
  if (ap->exp_timeout) {
#line 225
    while (1) {
#line 225
      ((*log_info))(0U, "mounted indirect mount on %s with timeout %u, freq %u seconds",
                    ap->path, (unsigned int )ap->exp_timeout, (unsigned int )ap->exp_runfreq);
#line 225
      break;
    }
  } else {
#line 230
    while (1) {
#line 230
      ((*log_info))(0U, "mounted indirect mount on %s with timeouts disabled", ap->path);
#line 230
      break;
    }
  }
#line 233
  fstat__extinline(ap->ioctlfd, & st);
#line 234
  ap->dev = st.st_dev;
#line 236
  return (0);
  out_umount: 
#line 239
  umount((char const   *)ap->path);
  out_rmdir: 
#line 241
  if (ap->dir_created) {
#line 242
    rmdir_path(ap, (char const   *)ap->path, ap->dev);
  }
  out_err: 
#line 244
  if (options) {
#line 245
    free((void *)options);
  }
#line 246
  close(ap->state_pipe[0]);
#line 247
  close(ap->state_pipe[1]);
#line 248
  close(ap->pipefd);
#line 249
  close(ap->kpipefd);
#line 251
  return (-1);
}
}
#line 254 "indirect.c"
int mount_autofs_indirect(struct autofs_point *ap ) 
{ time_t now ;
  time_t tmp ;
  int status ;
  int map ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 256
  tmp = time((time_t *)((void *)0));
#line 256
  now = tmp;
#line 260
  tmp___0 = autofs_init_indirect(ap);
#line 260
  if (tmp___0) {
#line 261
    return (-1);
  }
#line 264
  tmp___1 = lookup_nss_read_map(ap, (struct map_source *)((void *)0), now);
#line 264
  if (tmp___1) {
#line 265
    lookup_prune_cache(ap, now);
  } else {
#line 267
    while (1) {
#line 267
      ((*log_error))(ap->logopt, "%s: failed to read map for %s", "mount_autofs_indirect",
                     ap->path);
#line 267
      break;
    }
#line 268
    return (-1);
  }
#line 271
  status = do_mount_autofs_indirect(ap);
#line 272
  if (status < 0) {
#line 273
    return (-1);
  }
#line 275
  map = lookup_ghost(ap);
#line 276
  if (map & 1) {
#line 277
    if (map & 4) {
#line 278
      while (1) {
#line 278
        ((*log_error))(ap->logopt, "%s: bad map format,found direct, expected indirect exiting",
                       "mount_autofs_indirect");
#line 278
        break;
      }
    } else {
#line 282
      while (1) {
#line 282
        ((*log_error))(ap->logopt, "%s: failed to load map, exiting", "mount_autofs_indirect");
#line 282
        break;
      }
    }
#line 285
    return (-1);
  }
#line 288
  if (map & 32768) {
#line 289
    ap->ghost = 0U;
  }
#line 291
  return (0);
}
}
#line 294 "indirect.c"
int umount_autofs_indirect(struct autofs_point *ap ) 
{ char buf[128] ;
  int ret ;
  int rv ;
  int retries ;
  unsigned int tmp ;
  char *estr ;
  int *tmp___0 ;
  char *tmp___1 ;
  struct timespec tm ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;

  {
#line 305
  if (ap->submount) {
#line 306
    lookup_source_close_ioctlfd(ap->parent, (char const   *)ap->path);
  }
#line 309
  if (sizeof(int ) == sizeof(int [1])) {
#line 309
    if (sizeof(int ) < 16384U) {
#line 309
      tmp = sizeof(int );
    } else {
#line 309
      tmp = __invalid_size_argument_for_IOC;
    }
  } else {
#line 309
    tmp = __invalid_size_argument_for_IOC;
  }
#line 309
  rv = ioctl(ap->ioctlfd, (unsigned long )(2147521392U | (tmp << 16)), & ret);
#line 310
  if (rv == -1) {
#line 311
    tmp___0 = __errno_location();
#line 311
    tmp___1 = strerror_r((*tmp___0), buf, 128U);
#line 311
    estr = tmp___1;
#line 312
    while (1) {
#line 312
      ((*log_error))(ap->logopt, "%s: ioctl failed: %s", "umount_autofs_indirect",
                     estr);
#line 312
      break;
    }
#line 313
    return (1);
  } else {
#line 314
    if (! ret) {
#line 315
      while (1) {
#line 315
        ((*log_error))(ap->logopt, "%s: ask umount returned busy %s", "umount_autofs_indirect",
                       ap->path);
#line 315
        break;
      }
#line 316
      return (1);
    }
  }
#line 319
  ioctl(ap->ioctlfd, 37730UL, 0);
#line 320
  close(ap->ioctlfd);
#line 321
  ap->ioctlfd = -1;
#line 322
  close(ap->state_pipe[0]);
#line 323
  close(ap->state_pipe[1]);
#line 324
  ap->state_pipe[0] = -1;
#line 325
  ap->state_pipe[1] = -1;
#line 327
  if (ap->pipefd >= 0) {
#line 328
    close(ap->pipefd);
  }
#line 330
  if (ap->kpipefd >= 0) {
#line 331
    close(ap->kpipefd);
  }
#line 333
  sched_yield();
#line 335
  retries = 8;
#line 336
  while (1) {
#line 336
    rv = umount((char const   *)ap->path);
#line 336
    if (rv == -1) {
#line 336
      tmp___3 = retries;
#line 336
      retries --;
#line 336
      if (! tmp___3) {
#line 336
        break;
      }
    } else {
#line 336
      break;
    }
#line 337
    tm.tv_sec = 0L;
#line 337
    tm.tv_nsec = 100000000L;
#line 338
    tmp___2 = __errno_location();
#line 338
    if ((*tmp___2) != 16) {
#line 339
      break;
    }
#line 340
    nanosleep((struct timespec  const  *)(& tm), (struct timespec *)((void *)0));
  }
#line 343
  if (rv == -1) {
#line 344
    tmp___4 = __errno_location();
#line 344
    switch ((*tmp___4)) {
    case 2: 
    case 22: 
#line 347
    while (1) {
#line 347
      ((*log_error))(ap->logopt, "%s: mount point %s does not exist", "umount_autofs_indirect",
                     ap->path);
#line 347
      break;
    }
#line 349
    return (0);
#line 350
    break;
    case 16: 
#line 352
    while (1) {
#line 352
      ((*log_error))(ap->logopt, "%s: mount point %s is in use", "umount_autofs_indirect",
                     ap->path);
#line 352
      break;
    }
#line 354
    if ((int )ap->state == 6) {
      goto force_umount;
    } else {
#line 357
      return (0);
    }
#line 358
    break;
    case 20: 
#line 360
    while (1) {
#line 360
      ((*log_error))(ap->logopt, "%s: mount point is not a directory", "umount_autofs_indirect");
#line 360
      break;
    }
#line 361
    return (0);
#line 362
    break;
    }
#line 364
    return (1);
  }
  force_umount: 
#line 368
  if (rv != 0) {
#line 369
    while (1) {
#line 369
      ((*log_warn))(ap->logopt, "%s: forcing umount of indirect mount %s", "umount_autofs_indirect",
                    ap->path);
#line 369
      break;
    }
#line 371
    rv = umount2((char const   *)ap->path, 2);
  } else {
#line 373
    while (1) {
#line 373
      ((*log_info))(0U, "umounted indirect mount %s", ap->path);
#line 373
      break;
    }
#line 374
    if (ap->submount) {
#line 375
      rm_unwanted((char const   *)ap->path, 1, ap->dev);
    }
  }
#line 378
  return (rv);
}
}
#line 381 "indirect.c"
static int expire_indirect(struct autofs_point *ap , int ioctlfd , char const   *path___0 ,
                           unsigned int when ) 
{ char buf[128] ;
  int ret ;
  int retries ;
  struct stat st ;
  char *estr ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct timespec tm ;
  unsigned int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  unsigned int tmp___8 ;
  int tmp___9 ;

  {
#line 387
  tmp___1 = fstat__extinline(ioctlfd, & st);
#line 387
  if (tmp___1 == -1) {
#line 388
    tmp = __errno_location();
#line 388
    tmp___0 = strerror_r((*tmp), buf, 128U);
#line 388
    estr = tmp___0;
#line 389
    while (1) {
#line 389
      ((*log_error))(ap->logopt, "%s: fstat failed: %s", "expire_indirect", estr);
#line 389
      break;
    }
#line 390
    return (0);
  }
#line 393
  tmp___2 = count_mounts(path___0, st.st_dev);
#line 393
  retries = (tmp___2 + 1) * 3;
#line 395
  while (1) {
#line 395
    tmp___7 = retries;
#line 395
    retries --;
#line 395
    if (! tmp___7) {
#line 395
      break;
    }
#line 396
    tm.tv_sec = 0L;
#line 396
    tm.tv_nsec = 100000000L;
#line 399
    if (sizeof(int ) == sizeof(int [1])) {
#line 399
      if (sizeof(int ) < 16384U) {
#line 399
        tmp___3 = sizeof(int );
      } else {
#line 399
        tmp___3 = __invalid_size_argument_for_IOC;
      }
    } else {
#line 399
      tmp___3 = __invalid_size_argument_for_IOC;
    }
#line 399
    ret = ioctl(ioctlfd, (unsigned long )(1073779558U | (tmp___3 << 16)), & when);
#line 400
    if (ret == -1) {
#line 402
      tmp___4 = __errno_location();
#line 402
      if ((*tmp___4) == 9) {
#line 403
        return (1);
      } else {
#line 402
        tmp___5 = __errno_location();
#line 402
        if ((*tmp___5) == 22) {
#line 403
          return (1);
        }
      }
#line 406
      tmp___6 = __errno_location();
#line 406
      if ((*tmp___6) != 11) {
#line 407
        return (0);
      }
    }
#line 410
    nanosleep((struct timespec  const  *)(& tm), (struct timespec *)((void *)0));
  }
#line 413
  if (sizeof(int ) == sizeof(int [1])) {
#line 413
    if (sizeof(int ) < 16384U) {
#line 413
      tmp___8 = sizeof(int );
    } else {
#line 413
      tmp___8 = __invalid_size_argument_for_IOC;
    }
  } else {
#line 413
    tmp___8 = __invalid_size_argument_for_IOC;
  }
#line 413
  tmp___9 = ioctl(ioctlfd, (unsigned long )(2147521392U | (tmp___8 << 16)), & ret);
#line 413
  if (! tmp___9) {
#line 414
    if (! ret) {
#line 415
      return (0);
    }
  }
#line 418
  return (1);
}
}
#line 421 "indirect.c"
static void mnts_cleanup(void *arg ) 
{ struct mnt_list *mnts ;

  {
#line 423
  mnts = (struct mnt_list *)arg;
#line 424
  free_mnt_list(mnts);
#line 425
  return;
}
}
#line 428 "indirect.c"
void *expire_proc_indirect(void *arg ) 
{ struct autofs_point *ap ;
  struct mapent *me ;
  struct mnt_list *mnts ;
  struct mnt_list *next ;
  struct expire_args *ea ;
  struct expire_args ec ;
  unsigned int now ;
  int offsets ;
  int submnts ;
  int count ;
  int ioctlfd ;
  int cur_state ;
  int status ;
  int ret ;
  int left ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp ;
  long tmp___0 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___0)(void * ) ;
  void *__cancel_arg___0 ;
  int not_first_call___0 ;
  int tmp___1 ;
  long tmp___2 ;
  char *ind_key ;
  int ret___0 ;
  char *tmp___3 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___9 ;
  int tmp___12 ;
  int tmp___13 ;
  __pthread_unwind_buf_t __cancel_buf___1 ;
  void (*__cancel_routine___1)(void * ) ;
  void *__cancel_arg___1 ;
  int not_first_call___1 ;
  int tmp___14 ;
  long tmp___15 ;
  char *tmp___16 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  unsigned int tmp___27 ;
  int tmp___28 ;

  {
#line 431
  me = (struct mapent *)((void *)0);
#line 432
  mnts = (struct mnt_list *)((void *)0);
#line 440
  ea = (struct expire_args *)arg;
#line 442
  status = pthread_mutex_lock(& ea->mutex);
#line 443
  if (status) {
#line 444
    while (1) {
#line 444
      if (status == 35) {
#line 444
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "expire_proc_indirect", 444, "indirect.c");
#line 444
        dump_core();
      }
#line 444
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 444,
                    "indirect.c");
#line 444
      abort();
#line 444
      break;
    }
  }
#line 446
  ec.ap = ea->ap;
#line 446
  ap = ec.ap;
#line 447
  now = ea->when;
#line 448
  ec.status = -1;
#line 450
  ea->signaled = 1U;
#line 451
  status = pthread_cond_signal(& ea->cond);
#line 452
  if (status) {
#line 453
    while (1) {
#line 453
      if (status == 35) {
#line 453
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "expire_proc_indirect", 453, "indirect.c");
#line 453
        dump_core();
      }
#line 453
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 453,
                    "indirect.c");
#line 453
      abort();
#line 453
      break;
    }
  }
#line 455
  status = pthread_mutex_unlock(& ea->mutex);
#line 456
  if (status) {
#line 457
    while (1) {
#line 457
      if (status == 35) {
#line 457
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "expire_proc_indirect", 457, "indirect.c");
#line 457
        dump_core();
      }
#line 457
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 457,
                    "indirect.c");
#line 457
      abort();
#line 457
      break;
    }
  }
#line 459
  while (1) {
#line 459
    __cancel_routine = & expire_cleanup;
#line 459
    __cancel_arg = (void *)(& ec);
#line 459
    tmp = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf), 0);
#line 459
    not_first_call = tmp;
#line 459
    tmp___0 = __builtin_expect((long )not_first_call, 0L);
#line 459
    if (tmp___0) {
#line 459
      ((*__cancel_routine))(__cancel_arg);
#line 459
      __pthread_unwind_next(& __cancel_buf);
    }
#line 459
    __pthread_register_cancel(& __cancel_buf);
#line 459
    while (1) {
#line 461
      left = 0;
#line 464
      mnts = get_mnt_list("/proc/mounts", (char const   *)ap->path, 0);
#line 465
      while (1) {
#line 465
        __cancel_routine___0 = & mnts_cleanup;
#line 465
        __cancel_arg___0 = (void *)mnts;
#line 465
        tmp___1 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf),
                              0);
#line 465
        not_first_call___0 = tmp___1;
#line 465
        tmp___2 = __builtin_expect((long )not_first_call___0, 0L);
#line 465
        if (tmp___2) {
#line 465
          ((*__cancel_routine___0))(__cancel_arg___0);
#line 465
          __pthread_unwind_next(& __cancel_buf___0);
        }
#line 465
        __pthread_register_cancel(& __cancel_buf___0);
#line 465
        while (1) {
#line 466
          next = mnts;
#line 466
          while (next) {
#line 470
            if (0) {
#line 470
              __s1_len = strlen((char const   *)next->fs_type);
#line 470
              __s2_len = strlen("autofs");
#line 470
              if (! ((unsigned int )((void const   *)(next->fs_type + 1)) - (unsigned int )((void const   *)next->fs_type) == 1U)) {
                goto _L___0;
              } else {
#line 470
                if (__s1_len >= 4U) {
                  _L___0: 
#line 470
                  if (! ((unsigned int )((void const   *)("autofs" + 1)) - (unsigned int )((void const   *)"autofs") == 1U)) {
#line 470
                    tmp___13 = 1;
                  } else {
#line 470
                    if (__s2_len >= 4U) {
#line 470
                      tmp___13 = 1;
                    } else {
#line 470
                      tmp___13 = 0;
                    }
                  }
                } else {
#line 470
                  tmp___13 = 0;
                }
              }
#line 470
              if (tmp___13) {
#line 470
                tmp___9 = __builtin_strcmp((char const   *)next->fs_type, "autofs");
              } else {
#line 470
                tmp___12 = __builtin_strcmp((char const   *)next->fs_type, "autofs");
#line 470
                tmp___9 = tmp___12;
              }
            } else {
#line 470
              tmp___12 = __builtin_strcmp((char const   *)next->fs_type, "autofs");
#line 470
              tmp___9 = tmp___12;
            }
#line 470
            if (! tmp___9) {
#line 475
              pthread_setcancelstate(1, & cur_state);
#line 476
              tmp___3 = strstr((char const   *)next->opts, "indirect");
#line 476
              if (tmp___3) {
#line 477
                master_notify_submount(ap, (char const   *)next->path, ap->state);
              }
#line 478
              pthread_setcancelstate(cur_state, (int *)((void *)0));
              goto __Cont;
            }
#line 483
            if ((int )ap->state == 2) {
#line 484
              pthread_testcancel();
            } else {
#line 483
              if ((int )ap->state == 3) {
#line 484
                pthread_testcancel();
              }
            }
#line 490
            ind_key = strrchr((char const   *)next->path, '/');
#line 491
            if (ind_key) {
#line 492
              ind_key ++;
            }
#line 501
            me = lookup_source_mapent(ap, (char const   *)next->path, 8192U);
#line 502
            if (! me) {
#line 502
              if (ind_key) {
#line 503
                me = lookup_source_mapent(ap, (char const   *)ind_key, 4096U);
              }
            }
#line 504
            if (! me) {
              goto __Cont;
            }
#line 507
            if ((int )(*(me->key)) == 47) {
#line 508
              ioctlfd = me->ioctlfd;
            } else {
#line 510
              ioctlfd = ap->ioctlfd;
            }
#line 512
            cache_unlock(me->mc);
#line 514
            while (1) {
#line 514
              ((*log_debug))(ap->logopt, "%s: expire %s", "expire_proc_indirect",
                             next->path);
#line 514
              break;
            }
#line 516
            pthread_setcancelstate(1, & cur_state);
#line 517
            ret___0 = expire_indirect(ap, ioctlfd, (char const   *)next->path, now);
#line 518
            if (! ret___0) {
#line 519
              left ++;
            }
#line 520
            pthread_setcancelstate(cur_state, (int *)((void *)0));
            __Cont: 
#line 466
            next = next->next;
          }
#line 465
          break;
        }
#line 522
        __pthread_unregister_cancel(& __cancel_buf___0);
#line 522
        ((*__cancel_routine___0))(__cancel_arg___0);
#line 465
        break;
      }
#line 529
      if (mnts) {
#line 530
        pthread_setcancelstate(1, & cur_state);
#line 531
        ret = expire_indirect(ap, ap->ioctlfd, (char const   *)ap->path, now);
#line 532
        if (! ret) {
#line 533
          left ++;
        }
#line 534
        pthread_setcancelstate(cur_state, (int *)((void *)0));
      }
#line 537
      submnts = 0;
#line 537
      offsets = submnts;
#line 537
      count = offsets;
#line 538
      mnts = get_mnt_list("/proc/mounts", (char const   *)ap->path, 0);
#line 539
      while (1) {
#line 539
        __cancel_routine___1 = & mnts_cleanup;
#line 539
        __cancel_arg___1 = (void *)mnts;
#line 539
        tmp___14 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___1.__cancel_jmp_buf),
                               0);
#line 539
        not_first_call___1 = tmp___14;
#line 539
        tmp___15 = __builtin_expect((long )not_first_call___1, 0L);
#line 539
        if (tmp___15) {
#line 539
          ((*__cancel_routine___1))(__cancel_arg___1);
#line 539
          __pthread_unwind_next(& __cancel_buf___1);
        }
#line 539
        __pthread_register_cancel(& __cancel_buf___1);
#line 539
        while (1) {
#line 541
          next = mnts;
#line 541
          while (next) {
#line 542
            if (0) {
#line 542
              __s1_len___0 = strlen((char const   *)next->fs_type);
#line 542
              __s2_len___0 = strlen("autofs");
#line 542
              if (! ((unsigned int )((void const   *)(next->fs_type + 1)) - (unsigned int )((void const   *)next->fs_type) == 1U)) {
                goto _L___2;
              } else {
#line 542
                if (__s1_len___0 >= 4U) {
                  _L___2: 
#line 542
                  if (! ((unsigned int )((void const   *)("autofs" + 1)) - (unsigned int )((void const   *)"autofs") == 1U)) {
#line 542
                    tmp___26 = 1;
                  } else {
#line 542
                    if (__s2_len___0 >= 4U) {
#line 542
                      tmp___26 = 1;
                    } else {
#line 542
                      tmp___26 = 0;
                    }
                  }
                } else {
#line 542
                  tmp___26 = 0;
                }
              }
#line 542
              if (tmp___26) {
#line 542
                tmp___22 = __builtin_strcmp((char const   *)next->fs_type, "autofs");
              } else {
#line 542
                tmp___25 = __builtin_strcmp((char const   *)next->fs_type, "autofs");
#line 542
                tmp___22 = tmp___25;
              }
            } else {
#line 542
              tmp___25 = __builtin_strcmp((char const   *)next->fs_type, "autofs");
#line 542
              tmp___22 = tmp___25;
            }
#line 542
            if (tmp___22) {
#line 543
              count ++;
            } else {
#line 545
              tmp___16 = strstr((char const   *)next->opts, "indirect");
#line 545
              if (tmp___16) {
#line 546
                submnts ++;
              } else {
#line 548
                offsets ++;
              }
            }
#line 541
            next = next->next;
          }
#line 539
          break;
        }
#line 551
        __pthread_unregister_cancel(& __cancel_buf___1);
#line 551
        ((*__cancel_routine___1))(__cancel_arg___1);
#line 539
        break;
      }
#line 553
      if (submnts) {
#line 554
        while (1) {
#line 554
          ((*log_debug))(ap->logopt, "%s: %d submounts remaining in %s", "expire_proc_indirect",
                         submnts, ap->path);
#line 554
          break;
        }
      }
#line 561
      if (count) {
#line 562
        while (1) {
#line 562
          ((*log_debug))(ap->logopt, "%s: %d remaining in %s", "expire_proc_indirect",
                         count, ap->path);
#line 562
          break;
        }
      }
#line 565
      if (sizeof(int ) == sizeof(int [1])) {
#line 565
        if (sizeof(int ) < 16384U) {
#line 565
          tmp___27 = sizeof(int );
        } else {
#line 565
          tmp___27 = __invalid_size_argument_for_IOC;
        }
      } else {
#line 565
        tmp___27 = __invalid_size_argument_for_IOC;
      }
#line 565
      tmp___28 = ioctl(ap->ioctlfd, (unsigned long )(2147521392U | (tmp___27 << 16)),
                       & ret);
#line 565
      if (! tmp___28) {
#line 566
        if (! ret) {
#line 567
          while (1) {
#line 567
            ((*log_info))(0U, "mount still busy %s", ap->path);
#line 567
            break;
          }
        }
      }
#line 570
      ec.status = left;
#line 572
      pthread_setcancelstate(1, & cur_state);
#line 459
      break;
    }
#line 573
    __pthread_unregister_cancel(& __cancel_buf);
#line 573
    ((*__cancel_routine))(__cancel_arg);
#line 459
    break;
  }
#line 574
  pthread_setcancelstate(cur_state, (int *)((void *)0));
#line 576
  return ((void *)0);
}
}
#line 579 "indirect.c"
static void pending_cond_destroy(void *arg ) 
{ struct pending_args *mt ;
  int status ;

  {
#line 584
  mt = (struct pending_args *)arg;
#line 585
  status = pthread_cond_destroy(& mt->cond);
#line 586
  if (status) {
#line 587
    while (1) {
#line 587
      if (status == 35) {
#line 587
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "pending_cond_destroy", 587, "indirect.c");
#line 587
        dump_core();
      }
#line 587
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 587,
                    "indirect.c");
#line 587
      abort();
#line 587
      break;
    }
  }
#line 588
  return;
}
}
#line 590 "indirect.c"
static void expire_send_fail(void *arg ) 
{ struct pending_args *mt ;

  {
#line 592
  mt = (struct pending_args *)arg;
#line 593
  send_fail((mt->ap)->ioctlfd, (unsigned int )mt->wait_queue_token);
#line 594
  return;
}
}
#line 596 "indirect.c"
static void free_pending_args(void *arg ) 
{ struct pending_args *mt ;

  {
#line 598
  mt = (struct pending_args *)arg;
#line 599
  free((void *)mt);
#line 600
  return;
}
}
#line 602 "indirect.c"
static void expire_mutex_unlock(void *arg ) 
{ int status ;
  int tmp ;

  {
#line 604
  tmp = pthread_mutex_unlock(& ea_mutex);
#line 604
  status = tmp;
#line 605
  if (status) {
#line 606
    while (1) {
#line 606
      if (status == 35) {
#line 606
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "expire_mutex_unlock", 606, "indirect.c");
#line 606
        dump_core();
      }
#line 606
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 606,
                    "indirect.c");
#line 606
      abort();
#line 606
      break;
    }
  }
#line 607
  return;
}
}
#line 609 "indirect.c"
static void *do_expire_indirect(void *arg ) 
{ struct pending_args *mt ;
  struct autofs_point *ap ;
  int status ;
  int state ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp ;
  long tmp___0 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___0)(void * ) ;
  void *__cancel_arg___0 ;
  int not_first_call___0 ;
  int tmp___1 ;
  long tmp___2 ;
  __pthread_unwind_buf_t __cancel_buf___1 ;
  void (*__cancel_routine___1)(void * ) ;
  void *__cancel_arg___1 ;
  int not_first_call___1 ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 615
  mt = (struct pending_args *)arg;
#line 617
  status = pthread_mutex_lock(& ea_mutex);
#line 618
  if (status) {
#line 619
    while (1) {
#line 619
      if (status == 35) {
#line 619
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "do_expire_indirect", 619, "indirect.c");
#line 619
        dump_core();
      }
#line 619
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 619,
                    "indirect.c");
#line 619
      abort();
#line 619
      break;
    }
  }
#line 621
  ap = mt->ap;
#line 623
  mt->signaled = 1U;
#line 624
  status = pthread_cond_signal(& mt->cond);
#line 625
  if (status) {
#line 626
    while (1) {
#line 626
      if (status == 35) {
#line 626
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "do_expire_indirect", 626, "indirect.c");
#line 626
        dump_core();
      }
#line 626
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 626,
                    "indirect.c");
#line 626
      abort();
#line 626
      break;
    }
  }
#line 628
  expire_mutex_unlock((void *)0);
#line 630
  while (1) {
#line 630
    __cancel_routine = & free_pending_args;
#line 630
    __cancel_arg = (void *)mt;
#line 630
    tmp = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf), 0);
#line 630
    not_first_call = tmp;
#line 630
    tmp___0 = __builtin_expect((long )not_first_call, 0L);
#line 630
    if (tmp___0) {
#line 630
      ((*__cancel_routine))(__cancel_arg);
#line 630
      __pthread_unwind_next(& __cancel_buf);
    }
#line 630
    __pthread_register_cancel(& __cancel_buf);
#line 630
    while (1) {
#line 631
      while (1) {
#line 631
        __cancel_routine___0 = & pending_cond_destroy;
#line 631
        __cancel_arg___0 = (void *)mt;
#line 631
        tmp___1 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf),
                              0);
#line 631
        not_first_call___0 = tmp___1;
#line 631
        tmp___2 = __builtin_expect((long )not_first_call___0, 0L);
#line 631
        if (tmp___2) {
#line 631
          ((*__cancel_routine___0))(__cancel_arg___0);
#line 631
          __pthread_unwind_next(& __cancel_buf___0);
        }
#line 631
        __pthread_register_cancel(& __cancel_buf___0);
#line 631
        while (1) {
#line 632
          while (1) {
#line 632
            __cancel_routine___1 = & expire_send_fail;
#line 632
            __cancel_arg___1 = (void *)mt;
#line 632
            tmp___3 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___1.__cancel_jmp_buf),
                                  0);
#line 632
            not_first_call___1 = tmp___3;
#line 632
            tmp___4 = __builtin_expect((long )not_first_call___1, 0L);
#line 632
            if (tmp___4) {
#line 632
              ((*__cancel_routine___1))(__cancel_arg___1);
#line 632
              __pthread_unwind_next(& __cancel_buf___1);
            }
#line 632
            __pthread_register_cancel(& __cancel_buf___1);
#line 632
            while (1) {
#line 634
              status = do_expire(mt->ap, (char const   *)(mt->name), (int )mt->len);
#line 635
              pthread_setcancelstate(1, & state);
#line 636
              if (status) {
#line 637
                send_fail(ap->ioctlfd, (unsigned int )mt->wait_queue_token);
              } else {
#line 639
                send_ready(ap->ioctlfd, (unsigned int )mt->wait_queue_token);
              }
#line 640
              pthread_setcancelstate(state, (int *)((void *)0));
#line 632
              break;
            }
#line 642
            __pthread_unregister_cancel(& __cancel_buf___1);
#line 632
            break;
          }
#line 631
          break;
        }
#line 643
        __pthread_unregister_cancel(& __cancel_buf___0);
#line 643
        ((*__cancel_routine___0))(__cancel_arg___0);
#line 631
        break;
      }
#line 630
      break;
    }
#line 644
    __pthread_unregister_cancel(& __cancel_buf);
#line 644
    ((*__cancel_routine))(__cancel_arg);
#line 630
    break;
  }
#line 646
  return ((void *)0);
}
}
#line 649 "indirect.c"
int handle_packet_expire_indirect(struct autofs_point *ap , autofs_packet_expire_indirect_t *pkt ) 
{ struct pending_args *mt ;
  char buf[128] ;
  pthread_t thid ;
  int status ;
  int state ;
  char *estr ;
  int *tmp ;
  char *tmp___0 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 656
  pthread_setcancelstate(1, & state);
#line 658
  while (1) {
#line 658
    ((*log_debug))(ap->logopt, "%s: token %ld, name %s", "handle_packet_expire_indirect",
                   pkt->wait_queue_token, pkt->name);
#line 658
    break;
  }
#line 661
  mt = (struct pending_args *)malloc(sizeof(struct pending_args ));
#line 662
  if (! mt) {
#line 663
    tmp = __errno_location();
#line 663
    tmp___0 = strerror_r((*tmp), buf, 128U);
#line 663
    estr = tmp___0;
#line 664
    while (1) {
#line 664
      ((*log_error))(ap->logopt, "%s: malloc: %s", "handle_packet_expire_indirect",
                     estr);
#line 664
      break;
    }
#line 665
    send_fail(ap->ioctlfd, (unsigned int )pkt->wait_queue_token);
#line 666
    pthread_setcancelstate(state, (int *)((void *)0));
#line 667
    return (1);
  }
#line 670
  status = pthread_cond_init((pthread_cond_t * __restrict  )(& mt->cond), (pthread_condattr_t const   * __restrict  )((void *)0));
#line 671
  if (status) {
#line 672
    while (1) {
#line 672
      if (status == 35) {
#line 672
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "handle_packet_expire_indirect", 672, "indirect.c");
#line 672
        dump_core();
      }
#line 672
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 672,
                    "indirect.c");
#line 672
      abort();
#line 672
      break;
    }
  }
#line 674
  status = pthread_mutex_lock(& ea_mutex);
#line 675
  if (status) {
#line 676
    while (1) {
#line 676
      if (status == 35) {
#line 676
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "handle_packet_expire_indirect", 676, "indirect.c");
#line 676
        dump_core();
      }
#line 676
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 676,
                    "indirect.c");
#line 676
      abort();
#line 676
      break;
    }
  }
#line 678
  mt->ap = ap;
#line 679
  __builtin_strncpy(mt->name, (char const   *)(pkt->name), pkt->len);
#line 680
  mt->name[pkt->len] = (char )'\000';
#line 681
  mt->len = pkt->len;
#line 682
  mt->wait_queue_token = pkt->wait_queue_token;
#line 684
  status = pthread_create((pthread_t * __restrict  )(& thid), (pthread_attr_t const   * __restrict  )(& thread_attr),
                          & do_expire_indirect, (void * __restrict  )mt);
#line 685
  if (status) {
#line 686
    while (1) {
#line 686
      ((*log_error))(ap->logopt, "%s: expire thread create failed", "handle_packet_expire_indirect");
#line 686
      break;
    }
#line 687
    send_fail(ap->ioctlfd, (unsigned int )pkt->wait_queue_token);
#line 688
    expire_mutex_unlock((void *)0);
#line 689
    pending_cond_destroy((void *)mt);
#line 690
    free_pending_args((void *)mt);
#line 691
    pthread_setcancelstate(state, (int *)((void *)0));
#line 692
    return (1);
  }
#line 695
  while (1) {
#line 695
    __cancel_routine = & expire_mutex_unlock;
#line 695
    __cancel_arg = (void *)0;
#line 695
    tmp___1 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
#line 695
    not_first_call = tmp___1;
#line 695
    tmp___2 = __builtin_expect((long )not_first_call, 0L);
#line 695
    if (tmp___2) {
#line 695
      ((*__cancel_routine))(__cancel_arg);
#line 695
      __pthread_unwind_next(& __cancel_buf);
    }
#line 695
    __pthread_register_cancel(& __cancel_buf);
#line 695
    while (1) {
#line 696
      pthread_setcancelstate(state, (int *)((void *)0));
#line 698
      mt->signaled = 0U;
#line 699
      while (! mt->signaled) {
#line 700
        status = pthread_cond_wait((pthread_cond_t * __restrict  )(& mt->cond), (pthread_mutex_t * __restrict  )(& ea_mutex));
#line 701
        if (status) {
#line 702
          while (1) {
#line 702
            if (status == 35) {
#line 702
              ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                            "handle_packet_expire_indirect", 702, "indirect.c");
#line 702
              dump_core();
            }
#line 702
            ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status,
                          702, "indirect.c");
#line 702
            abort();
#line 702
            break;
          }
        }
      }
#line 695
      break;
    }
#line 705
    __pthread_unregister_cancel(& __cancel_buf);
#line 705
    ((*__cancel_routine))(__cancel_arg);
#line 695
    break;
  }
#line 707
  return (0);
}
}
#line 710 "indirect.c"
static void mount_send_fail(void *arg ) 
{ struct pending_args *mt ;

  {
#line 712
  mt = (struct pending_args *)arg;
#line 713
  send_fail((mt->ap)->ioctlfd, (unsigned int )mt->wait_queue_token);
#line 714
  return;
}
}
#line 716 "indirect.c"
static void mount_mutex_unlock(void *arg ) 
{ int status ;
  int tmp ;

  {
#line 718
  tmp = pthread_mutex_unlock(& ma_mutex);
#line 718
  status = tmp;
#line 719
  if (status) {
#line 720
    while (1) {
#line 720
      if (status == 35) {
#line 720
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "mount_mutex_unlock", 720, "indirect.c");
#line 720
        dump_core();
      }
#line 720
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 720,
                    "indirect.c");
#line 720
      abort();
#line 720
      break;
    }
  }
#line 721
  return;
}
}
#line 723 "indirect.c"
static void *do_mount_indirect(void *arg ) 
{ struct pending_args *mt ;
  struct autofs_point *ap ;
  char buf[4097] ;
  struct stat st ;
  struct passwd pw ;
  struct passwd *ppw ;
  struct passwd **pppw ;
  struct group gr ;
  struct group *pgr ;
  struct group **ppgr ;
  char *pw_tmp ;
  char *gr_tmp ;
  struct thread_stdenv_vars *tsv ;
  int len ;
  int tmplen ;
  int status ;
  int state ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp ;
  long tmp___0 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___0)(void * ) ;
  void *__cancel_arg___0 ;
  int not_first_call___0 ;
  int tmp___1 ;
  long tmp___2 ;
  __pthread_unwind_buf_t __cancel_buf___1 ;
  void (*__cancel_routine___1)(void * ) ;
  void *__cancel_arg___1 ;
  int not_first_call___1 ;
  int tmp___3 ;
  long tmp___4 ;
  char *tmp___14 ;
  char *tmp___24 ;
  char *tmp___34 ;

  {
#line 730
  ppw = & pw;
#line 731
  pppw = & ppw;
#line 733
  pgr = & gr;
#line 734
  ppgr = & pgr;
#line 739
  mt = (struct pending_args *)arg;
#line 741
  status = pthread_mutex_lock(& ma_mutex);
#line 742
  if (status) {
#line 743
    while (1) {
#line 743
      if (status == 35) {
#line 743
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "do_mount_indirect", 743, "indirect.c");
#line 743
        dump_core();
      }
#line 743
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 743,
                    "indirect.c");
#line 743
      abort();
#line 743
      break;
    }
  }
#line 745
  ap = mt->ap;
#line 746
  mt->status = 0;
#line 748
  mt->signaled = 1U;
#line 749
  status = pthread_cond_signal(& mt->cond);
#line 750
  if (status) {
#line 751
    while (1) {
#line 751
      if (status == 35) {
#line 751
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "do_mount_indirect", 751, "indirect.c");
#line 751
        dump_core();
      }
#line 751
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 751,
                    "indirect.c");
#line 751
      abort();
#line 751
      break;
    }
  }
#line 753
  mount_mutex_unlock((void *)0);
#line 755
  while (1) {
#line 755
    __cancel_routine = & free_pending_args;
#line 755
    __cancel_arg = (void *)mt;
#line 755
    tmp = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf), 0);
#line 755
    not_first_call = tmp;
#line 755
    tmp___0 = __builtin_expect((long )not_first_call, 0L);
#line 755
    if (tmp___0) {
#line 755
      ((*__cancel_routine))(__cancel_arg);
#line 755
      __pthread_unwind_next(& __cancel_buf);
    }
#line 755
    __pthread_register_cancel(& __cancel_buf);
#line 755
    while (1) {
#line 756
      while (1) {
#line 756
        __cancel_routine___0 = & pending_cond_destroy;
#line 756
        __cancel_arg___0 = (void *)mt;
#line 756
        tmp___1 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf),
                              0);
#line 756
        not_first_call___0 = tmp___1;
#line 756
        tmp___2 = __builtin_expect((long )not_first_call___0, 0L);
#line 756
        if (tmp___2) {
#line 756
          ((*__cancel_routine___0))(__cancel_arg___0);
#line 756
          __pthread_unwind_next(& __cancel_buf___0);
        }
#line 756
        __pthread_register_cancel(& __cancel_buf___0);
#line 756
        while (1) {
#line 757
          while (1) {
#line 757
            __cancel_routine___1 = & mount_send_fail;
#line 757
            __cancel_arg___1 = (void *)mt;
#line 757
            tmp___3 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___1.__cancel_jmp_buf),
                                  0);
#line 757
            not_first_call___1 = tmp___3;
#line 757
            tmp___4 = __builtin_expect((long )not_first_call___1, 0L);
#line 757
            if (tmp___4) {
#line 757
              ((*__cancel_routine___1))(__cancel_arg___1);
#line 757
              __pthread_unwind_next(& __cancel_buf___1);
            }
#line 757
            __pthread_register_cancel(& __cancel_buf___1);
#line 757
            while (1) {
#line 759
              pthread_setcancelstate(1, & state);
#line 761
              len = ncat_path(buf, sizeof(buf), (char const   *)ap->path, (char const   *)(mt->name),
                              mt->len);
#line 762
              if (! len) {
#line 763
                while (1) {
#line 763
                  ((*log_crit))(ap->logopt, "%s: path to be mounted is to long", "do_mount_indirect");
#line 763
                  break;
                }
#line 764
                pthread_setcancelstate(state, (int *)((void *)0));
#line 765
                pthread_exit((void *)0);
              }
#line 768
              status = lstat__extinline((char const   *)(buf), & st);
#line 769
              if (status != -1) {
#line 769
                if ((st.st_mode & 61440U) == 16384U) {
#line 769
                  if (! (st.st_dev == mt->dev)) {
                    goto _L;
                  }
                } else {
                  _L: 
#line 770
                  while (1) {
#line 770
                    ((*log_error))(ap->logopt, "%s: indirect trigger not valid or already mounted %s",
                                   "do_mount_indirect", buf);
#line 770
                    break;
                  }
#line 772
                  pthread_setcancelstate(state, (int *)((void *)0));
#line 773
                  pthread_exit((void *)0);
                }
              }
#line 776
              pthread_setcancelstate(state, (int *)((void *)0));
#line 778
              while (1) {
#line 778
                ((*log_info))(0U, "attempting to mount entry %s", buf);
#line 778
                break;
              }
#line 786
              tsv = (struct thread_stdenv_vars *)malloc(sizeof(struct thread_stdenv_vars ));
#line 787
              if (! tsv) {
                goto cont;
              }
#line 790
              tsv->uid = mt->uid;
#line 791
              tsv->gid = mt->gid;
#line 795
              tmplen = (int )sysconf(70);
#line 796
              if (tmplen < 0) {
#line 797
                while (1) {
#line 797
                  ((*log_error))(ap->logopt, "%s: failed to get buffer size for getpwuid_r",
                                 "do_mount_indirect");
#line 797
                  break;
                }
#line 798
                free((void *)tsv);
                goto cont;
              }
#line 802
              pw_tmp = (char *)malloc((unsigned int )(tmplen + 1));
#line 803
              if (! pw_tmp) {
#line 804
                while (1) {
#line 804
                  ((*log_error))(ap->logopt, "%s: failed to malloc buffer for getpwuid_r",
                                 "do_mount_indirect");
#line 804
                  break;
                }
#line 805
                free((void *)tsv);
                goto cont;
              }
#line 809
              status = getpwuid_r(mt->uid, (struct passwd * __restrict  )ppw, (char * __restrict  )pw_tmp,
                                  (unsigned int )tmplen, (struct passwd ** __restrict  )pppw);
#line 810
              if (status) {
                goto _L___0;
              } else {
#line 810
                if (! ppw) {
                  _L___0: 
#line 811
                  while (1) {
#line 811
                    ((*log_error))(ap->logopt, "%s: failed to get passwd info from getpwuid_r",
                                   "do_mount_indirect");
#line 811
                    break;
                  }
#line 812
                  free((void *)tsv);
#line 813
                  free((void *)pw_tmp);
                  goto cont;
                }
              }
#line 817
              tmp___14 = __strdup((char const   *)pw.pw_name);
#line 817
              tsv->user = tmp___14;
#line 818
              if (! tsv->user) {
#line 819
                while (1) {
#line 819
                  ((*log_error))(ap->logopt, "%s: failed to malloc buffer for user",
                                 "do_mount_indirect");
#line 819
                  break;
                }
#line 820
                free((void *)tsv);
#line 821
                free((void *)pw_tmp);
                goto cont;
              }
#line 825
              tmp___24 = __strdup((char const   *)pw.pw_dir);
#line 825
              tsv->home = tmp___24;
#line 826
              if (! tsv->user) {
#line 827
                while (1) {
#line 827
                  ((*log_error))(ap->logopt, "%s: failed to malloc buffer for home",
                                 "do_mount_indirect");
#line 827
                  break;
                }
#line 828
                free((void *)pw_tmp);
#line 829
                free((void *)tsv->user);
#line 830
                free((void *)tsv);
                goto cont;
              }
#line 834
              free((void *)pw_tmp);
#line 838
              tmplen = (int )sysconf(69);
#line 839
              if (tmplen < 0) {
#line 840
                while (1) {
#line 840
                  ((*log_error))(ap->logopt, "%s: failed to get buffer size for getgrgid_r",
                                 "do_mount_indirect");
#line 840
                  break;
                }
#line 841
                free((void *)tsv->user);
#line 842
                free((void *)tsv->home);
#line 843
                free((void *)tsv);
                goto cont;
              }
#line 847
              gr_tmp = (char *)malloc((unsigned int )(tmplen + 1));
#line 848
              if (! gr_tmp) {
#line 849
                while (1) {
#line 849
                  ((*log_error))(ap->logopt, "%s: failed to malloc buffer for getgrgid_r",
                                 "do_mount_indirect");
#line 849
                  break;
                }
#line 850
                free((void *)tsv->user);
#line 851
                free((void *)tsv->home);
#line 852
                free((void *)tsv);
                goto cont;
              }
#line 856
              status = getgrgid_r(mt->gid, (struct group * __restrict  )pgr, (char * __restrict  )gr_tmp,
                                  (unsigned int )tmplen, (struct group ** __restrict  )ppgr);
#line 857
              if (status) {
                goto _L___1;
              } else {
#line 857
                if (! pgr) {
                  _L___1: 
#line 858
                  while (1) {
#line 858
                    ((*log_error))(ap->logopt, "%s: failed to get group info from getgrgid_r",
                                   "do_mount_indirect");
#line 858
                    break;
                  }
#line 859
                  free((void *)tsv->user);
#line 860
                  free((void *)tsv->home);
#line 861
                  free((void *)tsv);
#line 862
                  free((void *)gr_tmp);
                  goto cont;
                }
              }
#line 866
              tmp___34 = __strdup((char const   *)gr.gr_name);
#line 866
              tsv->group = tmp___34;
#line 867
              if (! tsv->group) {
#line 868
                while (1) {
#line 868
                  ((*log_error))(ap->logopt, "%s: failed to malloc buffer for group",
                                 "do_mount_indirect");
#line 868
                  break;
                }
#line 869
                free((void *)tsv->user);
#line 870
                free((void *)tsv->home);
#line 871
                free((void *)tsv);
#line 872
                free((void *)gr_tmp);
                goto cont;
              }
#line 876
              free((void *)gr_tmp);
#line 878
              status = pthread_setspecific(key_thread_stdenv_vars, (void const   *)tsv);
#line 879
              if (status) {
#line 880
                while (1) {
#line 880
                  ((*log_error))(ap->logopt, "%s: failed to set stdenv thread var",
                                 "do_mount_indirect");
#line 880
                  break;
                }
#line 881
                free((void *)tsv->group);
#line 882
                free((void *)tsv->user);
#line 883
                free((void *)tsv->home);
#line 884
                free((void *)tsv);
              }
              cont: 
#line 887
              status = lookup_nss_mount(ap, (struct map_source *)((void *)0), (char const   *)(mt->name),
                                        (int )mt->len);
#line 888
              pthread_setcancelstate(1, & state);
#line 889
              if (status) {
#line 890
                send_ready(ap->ioctlfd, (unsigned int )mt->wait_queue_token);
#line 891
                while (1) {
#line 891
                  ((*log_info))(0U, "mounted %s", buf);
#line 891
                  break;
                }
              } else {
#line 893
                send_fail(ap->ioctlfd, (unsigned int )mt->wait_queue_token);
#line 894
                while (1) {
#line 894
                  ((*log_info))(0U, "failed to mount %s", buf);
#line 894
                  break;
                }
              }
#line 896
              pthread_setcancelstate(state, (int *)((void *)0));
#line 757
              break;
            }
#line 898
            __pthread_unregister_cancel(& __cancel_buf___1);
#line 757
            break;
          }
#line 756
          break;
        }
#line 899
        __pthread_unregister_cancel(& __cancel_buf___0);
#line 899
        ((*__cancel_routine___0))(__cancel_arg___0);
#line 756
        break;
      }
#line 755
      break;
    }
#line 900
    __pthread_unregister_cancel(& __cancel_buf);
#line 900
    ((*__cancel_routine))(__cancel_arg);
#line 755
    break;
  }
#line 902
  return ((void *)0);
}
}
#line 905 "indirect.c"
int handle_packet_missing_indirect(struct autofs_point *ap , autofs_packet_missing_indirect_t *pkt ) 
{ pthread_t thid ;
  char buf[128] ;
  struct pending_args *mt ;
  int status ;
  int state ;
  char *estr ;
  int *tmp ;
  char *tmp___0 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 912
  pthread_setcancelstate(1, & state);
#line 914
  while (1) {
#line 914
    ((*log_debug))(ap->logopt, "%s: token %ld, name %s, request pid %u", "handle_packet_missing_indirect",
                   pkt->wait_queue_token, pkt->name, pkt->pid);
#line 914
    break;
  }
#line 918
  if ((int )ap->state == 5) {
#line 921
    send_fail(ap->ioctlfd, (unsigned int )pkt->wait_queue_token);
#line 922
    pthread_setcancelstate(state, (int *)((void *)0));
#line 923
    return (0);
  } else {
#line 918
    if ((int )ap->state == 6) {
#line 921
      send_fail(ap->ioctlfd, (unsigned int )pkt->wait_queue_token);
#line 922
      pthread_setcancelstate(state, (int *)((void *)0));
#line 923
      return (0);
    } else {
#line 918
      if ((int )ap->state == 7) {
#line 921
        send_fail(ap->ioctlfd, (unsigned int )pkt->wait_queue_token);
#line 922
        pthread_setcancelstate(state, (int *)((void *)0));
#line 923
        return (0);
      }
    }
  }
#line 926
  mt = (struct pending_args *)malloc(sizeof(struct pending_args ));
#line 927
  if (! mt) {
#line 928
    tmp = __errno_location();
#line 928
    tmp___0 = strerror_r((*tmp), buf, 128U);
#line 928
    estr = tmp___0;
#line 929
    while (1) {
#line 929
      ((*log_error))(ap->logopt, "%s: malloc: %s", "handle_packet_missing_indirect",
                     estr);
#line 929
      break;
    }
#line 930
    send_fail(ap->ioctlfd, (unsigned int )pkt->wait_queue_token);
#line 931
    pthread_setcancelstate(state, (int *)((void *)0));
#line 932
    return (1);
  }
#line 934
  memset((void *)mt, 0, sizeof(struct pending_args ));
#line 936
  status = pthread_cond_init((pthread_cond_t * __restrict  )(& mt->cond), (pthread_condattr_t const   * __restrict  )((void *)0));
#line 937
  if (status) {
#line 938
    while (1) {
#line 938
      if (status == 35) {
#line 938
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "handle_packet_missing_indirect", 938, "indirect.c");
#line 938
        dump_core();
      }
#line 938
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 938,
                    "indirect.c");
#line 938
      abort();
#line 938
      break;
    }
  }
#line 940
  status = pthread_mutex_lock(& ma_mutex);
#line 941
  if (status) {
#line 942
    while (1) {
#line 942
      if (status == 35) {
#line 942
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "handle_packet_missing_indirect", 942, "indirect.c");
#line 942
        dump_core();
      }
#line 942
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 942,
                    "indirect.c");
#line 942
      abort();
#line 942
      break;
    }
  }
#line 944
  mt->ap = ap;
#line 945
  __builtin_strncpy(mt->name, (char const   *)(pkt->name), pkt->len);
#line 946
  mt->name[pkt->len] = (char )'\000';
#line 947
  mt->len = pkt->len;
#line 948
  mt->dev = (unsigned long long )pkt->dev;
#line 949
  mt->uid = pkt->uid;
#line 950
  mt->gid = pkt->gid;
#line 951
  mt->wait_queue_token = pkt->wait_queue_token;
#line 953
  status = pthread_create((pthread_t * __restrict  )(& thid), (pthread_attr_t const   * __restrict  )(& thread_attr),
                          & do_mount_indirect, (void * __restrict  )mt);
#line 954
  if (status) {
#line 955
    while (1) {
#line 955
      ((*log_error))(ap->logopt, "%s: expire thread create failed", "handle_packet_missing_indirect");
#line 955
      break;
    }
#line 956
    send_fail(ap->ioctlfd, (unsigned int )pkt->wait_queue_token);
#line 957
    mount_mutex_unlock((void *)0);
#line 958
    pending_cond_destroy((void *)mt);
#line 959
    free_pending_args((void *)mt);
#line 960
    pthread_setcancelstate(state, (int *)((void *)0));
#line 961
    return (1);
  }
#line 964
  while (1) {
#line 964
    __cancel_routine = & mount_mutex_unlock;
#line 964
    __cancel_arg = (void *)0;
#line 964
    tmp___1 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
#line 964
    not_first_call = tmp___1;
#line 964
    tmp___2 = __builtin_expect((long )not_first_call, 0L);
#line 964
    if (tmp___2) {
#line 964
      ((*__cancel_routine))(__cancel_arg);
#line 964
      __pthread_unwind_next(& __cancel_buf);
    }
#line 964
    __pthread_register_cancel(& __cancel_buf);
#line 964
    while (1) {
#line 965
      pthread_setcancelstate(state, (int *)((void *)0));
#line 967
      mt->signaled = 0U;
#line 968
      while (! mt->signaled) {
#line 969
        status = pthread_cond_wait((pthread_cond_t * __restrict  )(& mt->cond), (pthread_mutex_t * __restrict  )(& ma_mutex));
#line 970
        if (status) {
#line 971
          while (1) {
#line 971
            if (status == 35) {
#line 971
              ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                            "handle_packet_missing_indirect", 971, "indirect.c");
#line 971
              dump_core();
            }
#line 971
            ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status,
                          971, "indirect.c");
#line 971
            abort();
#line 971
            break;
          }
        }
      }
#line 964
      break;
    }
#line 974
    __pthread_unregister_cancel(& __cancel_buf);
#line 974
    ((*__cancel_routine))(__cancel_arg);
#line 964
    break;
  }
#line 976
  return (0);
}
}
#line 1 "direct.o"
#pragma merger(0,"/tmp/cil-n2xqQPXz.i","-O2,-Wall,-fPIE")
#line 463 "/usr/include/pthread.h"
/*pthread_once_impl*/

typedef struct {
  pthread_mutex_t mut;
  int             val;
} my_pthread_once_t;

#define MY_PTHREAD_ONCE_INIT     {0,0}

int my_pthread_once(my_pthread_once_t *m , void (*func)(void) )  {

  pthread_mutex_lock(&m->mut);

  if (!(m->val)){
    m->val = 1;
    func();
  }

  pthread_mutex_unlock(&m->mut);

  return 0;
}

#define pthread_once_t    my_pthread_once_t
#define pthread_once      my_pthread_once
#define PTHREAD_ONCE_INIT MY_PTHREAD_ONCE_INIT

/*pthread_once_impl*/

//extern int pthread_once(pthread_once_t *__once_control , void (*__init_routine)(void) )  __attribute__((__nonnull__(1,2))) ;
#line 1074
extern  __attribute__((__nothrow__)) void *pthread_getspecific(pthread_key_t __key ) ;
#line 92 "../include/master.h"
void master_source_unlock(struct master_mapent *entry ) ;
#line 169 "../include/automount.h"
int cache_set_ino_index(struct mapent_cache *mc , char const   *key , dev_t dev ,
                        ino_t ino ) ;
#line 171
struct mapent *cache_lookup_ino(struct mapent_cache *mc , dev_t dev , ino_t ino ) ;
#line 178
struct mapent *cache_partial_match(struct mapent_cache *mc , char const   *prefix ) ;
#line 189
struct mapent *cache_enumerate(struct mapent_cache *mc , struct mapent *me ) ;
#line 317
size_t _strlen(char const   *str , size_t max ) ;
#line 370
void tree_free_mnt_tree(struct mnt_list *tree ) ;
#line 371
struct mnt_list *tree_make_mnt_tree(char const   *table , char const   *path___1 ) ;
#line 372
int tree_get_mnt_list(struct mnt_list *mnts , struct list_head *list , char const   *path___1 ,
                      int include ) ;
#line 375
int tree_is_mounted(struct mnt_list *mnts , char const   *path___1 , unsigned int type___1 ) ;
#line 468
void *expire_proc_direct(void *arg ) ;
#line 472
int mount_autofs_offset(struct autofs_point *ap , struct mapent *me , int is_autofs_fs ) ;
#line 476
int do_umount_autofs_direct(struct autofs_point *ap , struct mnt_list *mnts , struct mapent *me ) ;
#line 478
int umount_autofs_offset(struct autofs_point *ap , struct mapent *me ) ;
#line 49 "direct.c"
pthread_key_t key_mnt_direct_params  ;
#line 50 "direct.c"
pthread_key_t key_mnt_offset_params  ;
#line 51 "direct.c"
pthread_once_t key_mnt_params_once  =    PTHREAD_ONCE_INIT;
#line 53 "direct.c"
static union __anonunion_pthread_mutex_t_6 ma_mutex___0  =    {{0, 0U, 0, 0, 0U, {0}}};
#line 54 "direct.c"
static union __anonunion_pthread_mutex_t_6 ea_mutex___0  =    {{0, 0U, 0, 0, 0U, {0}}};
#line 56 "direct.c"
static void key_mnt_params_destroy(void *arg ) 
{ struct mnt_params *mp ;

  {
#line 60
  mp = (struct mnt_params *)arg;
#line 61
  if (mp->options) {
#line 62
    free((void *)mp->options);
  }
#line 63
  free((void *)mp);
#line 64
  return;
}
}
#line 67 "direct.c"
static void key_mnt_params_init(void) 
{ int status ;

  {
#line 71
  status = pthread_key_create(& key_mnt_direct_params, & key_mnt_params_destroy);
#line 72
  if (status) {
#line 73
    while (1) {
#line 73
      if (status == 35) {
#line 73
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "key_mnt_params_init", 73, "direct.c");
#line 73
        dump_core();
      }
#line 73
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 73, "direct.c");
#line 73
      abort();
#line 73
      break;
    }
  }
#line 75
  status = pthread_key_create(& key_mnt_offset_params, & key_mnt_params_destroy);
#line 76
  if (status) {
#line 77
    while (1) {
#line 77
      if (status == 35) {
#line 77
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "key_mnt_params_init", 77, "direct.c");
#line 77
        dump_core();
      }
#line 77
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 77, "direct.c");
#line 77
      abort();
#line 77
      break;
    }
  }
#line 79
  return;
}
}
#line 82 "direct.c"
static void mnts_cleanup___0(void *arg ) 
{ struct mnt_list *mnts ;

  {
#line 84
  mnts = (struct mnt_list *)arg;
#line 85
  tree_free_mnt_tree(mnts);
#line 86
  return;
}
}
#line 89 "direct.c"
static int autofs_init_direct(struct autofs_point *ap ) 
{ int pipefd[2] ;
  int cl_flags ;
  int tmp ;
  int tmp___0 ;

  {
#line 93
  if ((int )ap->state != 0) {
#line 95
    while (1) {
#line 95
      ((*log_error))(ap->logopt, "%s: bad state %d", "autofs_init_direct", ap->state);
#line 95
      break;
    }
#line 96
    return (-1);
  }
#line 99
  ap->ioctlfd = -1;
#line 99
  ap->kpipefd = ap->ioctlfd;
#line 99
  ap->pipefd = ap->kpipefd;
#line 102
  tmp = pipe(pipefd);
#line 102
  if (tmp < 0) {
#line 103
    while (1) {
#line 103
      ((*log_crit))(ap->logopt, "%s: failed to create commumication pipe for autofs path %s",
                    "autofs_init_direct", ap->path);
#line 103
      break;
    }
#line 106
    return (-1);
  }
#line 109
  ap->pipefd = pipefd[0];
#line 110
  ap->kpipefd = pipefd[1];
#line 112
  cl_flags = fcntl(ap->pipefd, 1, 0);
#line 112
  if (cl_flags != -1) {
#line 113
    cl_flags |= 1;
#line 114
    fcntl(ap->pipefd, 2, cl_flags);
  }
#line 117
  cl_flags = fcntl(ap->kpipefd, 1, 0);
#line 117
  if (cl_flags != -1) {
#line 118
    cl_flags |= 1;
#line 119
    fcntl(ap->kpipefd, 2, cl_flags);
  }
#line 123
  tmp___0 = pipe(ap->state_pipe);
#line 123
  if (tmp___0 < 0) {
#line 124
    while (1) {
#line 124
      ((*log_crit))(ap->logopt, "%s: failed create state pipe for autofs path %s",
                    "autofs_init_direct", ap->path);
#line 124
      break;
    }
#line 126
    close(ap->pipefd);
#line 127
    close(ap->kpipefd);
#line 128
    return (-1);
  }
#line 131
  cl_flags = fcntl(ap->state_pipe[0], 1, 0);
#line 131
  if (cl_flags != -1) {
#line 132
    cl_flags |= 1;
#line 133
    fcntl(ap->state_pipe[0], 2, cl_flags);
  }
#line 136
  cl_flags = fcntl(ap->state_pipe[1], 1, 0);
#line 136
  if (cl_flags != -1) {
#line 137
    cl_flags |= 1;
#line 138
    fcntl(ap->state_pipe[1], 2, cl_flags);
  }
#line 141
  return (0);
}
}
#line 144 "direct.c"
int do_umount_autofs_direct(struct autofs_point *ap , struct mnt_list *mnts , struct mapent *me ) 
{ char buf[128] ;
  int ioctlfd ;
  int rv ;
  int left ;
  int retries ;
  int tmp ;
  int cl_flags ;
  int status ;
  unsigned int tmp___0 ;
  char *estr ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *estr___0 ;
  int *tmp___3 ;
  char *tmp___4 ;
  struct timespec tm ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *estr___1 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;

  {
#line 149
  left = umount_multi(ap, (char const   *)me->key, 0);
#line 150
  if (left) {
#line 151
    while (1) {
#line 151
      ((*log_warn))(ap->logopt, "%s: could not unmount %d dirs under %s", "do_umount_autofs_direct",
                    left, me->key);
#line 151
      break;
    }
#line 153
    return (1);
  }
#line 156
  if (me->ioctlfd != -1) {
#line 157
    tmp = tree_is_mounted(mnts, (char const   *)me->key, 2U);
#line 157
    if (tmp) {
#line 158
      while (1) {
#line 158
        ((*log_error))(ap->logopt, "%s: attempt to umount busy direct mount %s", "do_umount_autofs_direct",
                       me->key);
#line 158
        break;
      }
#line 161
      return (1);
    }
#line 163
    ioctlfd = me->ioctlfd;
  } else {
#line 167
    ioctlfd = open((char const   *)me->key, 0);
#line 168
    if (ioctlfd != -1) {
#line 169
      cl_flags = fcntl(ioctlfd, 1, 0);
#line 169
      if (cl_flags != -1) {
#line 170
        cl_flags |= 1;
#line 171
        fcntl(ioctlfd, 2, cl_flags);
      }
    }
  }
#line 177
  if (ioctlfd >= 0) {
#line 178
    status = 1;
#line 180
    if (sizeof(int ) == sizeof(int [1])) {
#line 180
      if (sizeof(int ) < 16384U) {
#line 180
        tmp___0 = sizeof(int );
      } else {
#line 180
        tmp___0 = __invalid_size_argument_for_IOC;
      }
    } else {
#line 180
      tmp___0 = __invalid_size_argument_for_IOC;
    }
#line 180
    rv = ioctl(ioctlfd, (unsigned long )(2147521392U | (tmp___0 << 16)), & status);
#line 181
    if (rv) {
#line 182
      tmp___1 = __errno_location();
#line 182
      tmp___2 = strerror_r((*tmp___1), buf, 128U);
#line 182
      estr = tmp___2;
#line 183
      while (1) {
#line 183
        ((*log_error))(ap->logopt, "%s: ioctl failed: %s", "do_umount_autofs_direct",
                       estr);
#line 183
        break;
      }
#line 184
      return (1);
    } else {
#line 185
      if (! status) {
#line 186
        if ((int )ap->state != 6) {
#line 187
          while (1) {
#line 187
            ((*log_error))(ap->logopt, "%s: ask umount returned busy for %s", "do_umount_autofs_direct",
                           me->key);
#line 187
            break;
          }
#line 190
          return (1);
        } else {
#line 192
          me->ioctlfd = -1;
#line 193
          ioctl(ioctlfd, 37730UL, 0);
#line 194
          close(ioctlfd);
          goto force_umount;
        }
      }
    }
#line 198
    me->ioctlfd = -1;
#line 199
    ioctl(ioctlfd, 37730UL, 0);
#line 200
    close(ioctlfd);
  } else {
#line 202
    tmp___3 = __errno_location();
#line 202
    tmp___4 = strerror_r((*tmp___3), buf, 128U);
#line 202
    estr___0 = tmp___4;
#line 203
    while (1) {
#line 203
      ((*log_error))(ap->logopt, "%s: couldn\'t get ioctl fd for direct mount %s",
                     "do_umount_autofs_direct", me->key);
#line 203
      break;
    }
#line 205
    while (1) {
#line 205
      ((*log_debug))(ap->logopt, "%s: open: %s", "do_umount_autofs_direct", estr___0);
#line 205
      break;
    }
#line 206
    return (1);
  }
#line 209
  sched_yield();
#line 211
  retries = 8;
#line 212
  while (1) {
#line 212
    rv = umount((char const   *)me->key);
#line 212
    if (rv == -1) {
#line 212
      tmp___6 = retries;
#line 212
      retries --;
#line 212
      if (! tmp___6) {
#line 212
        break;
      }
    } else {
#line 212
      break;
    }
#line 213
    tm.tv_sec = 0L;
#line 213
    tm.tv_nsec = 100000000L;
#line 214
    tmp___5 = __errno_location();
#line 214
    if ((*tmp___5) != 16) {
#line 215
      break;
    }
#line 216
    nanosleep((struct timespec  const  *)(& tm), (struct timespec *)((void *)0));
  }
#line 219
  if (rv == -1) {
#line 220
    tmp___7 = __errno_location();
#line 220
    switch ((*tmp___7)) {
    case 2: 
    case 22: 
#line 223
    while (1) {
#line 223
      ((*log_warn))(ap->logopt, "%s: mount point %s does not exist", "do_umount_autofs_direct",
                    me->key);
#line 223
      break;
    }
#line 225
    return (0);
#line 226
    break;
    case 16: 
#line 228
    while (1) {
#line 228
      ((*log_warn))(ap->logopt, "%s: mount point %s is in use", "do_umount_autofs_direct",
                    me->key);
#line 228
      break;
    }
#line 229
    if ((int )ap->state == 6) {
      goto force_umount;
    } else {
#line 232
      return (0);
    }
#line 233
    break;
    case 20: 
#line 235
    while (1) {
#line 235
      ((*log_error))(ap->logopt, "%s: mount point is not a directory", "do_umount_autofs_direct");
#line 235
      break;
    }
#line 236
    return (0);
#line 237
    break;
    }
#line 239
    return (1);
  }
  force_umount: 
#line 243
  if (rv != 0) {
#line 244
    while (1) {
#line 244
      ((*log_info))(0U, "forcing umount of direct mount %s", me->key);
#line 244
      break;
    }
#line 245
    rv = umount2((char const   *)me->key, 2);
  } else {
#line 247
    while (1) {
#line 247
      ((*log_info))(0U, "umounted direct mount %s", me->key);
#line 247
      break;
    }
  }
#line 249
  if (! rv) {
#line 249
    if (me->dir_created) {
#line 250
      tmp___10 = rmdir((char const   *)me->key);
#line 250
      if (tmp___10 == -1) {
#line 251
        tmp___8 = __errno_location();
#line 251
        tmp___9 = strerror_r((*tmp___8), buf, 128U);
#line 251
        estr___1 = tmp___9;
#line 252
        while (1) {
#line 252
          ((*log_warn))(ap->logopt, "%s: failed to remove dir %s: %s", "do_umount_autofs_direct",
                        me->key, estr___1);
#line 252
          break;
        }
      }
    }
  }
#line 256
  return (rv);
}
}
#line 259 "direct.c"
int umount_autofs_direct(struct autofs_point *ap ) 
{ struct map_source *map ;
  struct mapent_cache *nc ;
  struct mapent_cache *mc ;
  struct mnt_list *mnts ;
  struct mapent *me ;
  struct mapent *ne ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp ;
  long tmp___0 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___0)(void * ) ;
  void *__cancel_arg___0 ;
  int not_first_call___0 ;
  int tmp___1 ;
  long tmp___2 ;
  __pthread_unwind_buf_t __cancel_buf___1 ;
  void (*__cancel_routine___1)(void * ) ;
  void *__cancel_arg___1 ;
  int not_first_call___1 ;
  int tmp___3 ;
  long tmp___4 ;
  __pthread_unwind_buf_t __cancel_buf___2 ;
  void (*__cancel_routine___2)(void * ) ;
  void *__cancel_arg___2 ;
  int not_first_call___2 ;
  int tmp___5 ;
  long tmp___6 ;

  {
#line 266
  close(ap->state_pipe[0]);
#line 267
  close(ap->state_pipe[1]);
#line 268
  if (ap->pipefd >= 0) {
#line 269
    close(ap->pipefd);
  }
#line 270
  if (ap->kpipefd >= 0) {
#line 271
    close(ap->kpipefd);
#line 272
    ap->kpipefd = -1;
  }
#line 275
  mnts = tree_make_mnt_tree("/proc/mounts", "/");
#line 276
  while (1) {
#line 276
    __cancel_routine = & mnts_cleanup___0;
#line 276
    __cancel_arg = (void *)mnts;
#line 276
    tmp = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf), 0);
#line 276
    not_first_call = tmp;
#line 276
    tmp___0 = __builtin_expect((long )not_first_call, 0L);
#line 276
    if (tmp___0) {
#line 276
      ((*__cancel_routine))(__cancel_arg);
#line 276
      __pthread_unwind_next(& __cancel_buf);
    }
#line 276
    __pthread_register_cancel(& __cancel_buf);
#line 276
    while (1) {
#line 277
      while (1) {
#line 277
        __cancel_routine___0 = & master_source_lock_cleanup;
#line 277
        __cancel_arg___0 = (void *)ap->entry;
#line 277
        tmp___1 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf),
                              0);
#line 277
        not_first_call___0 = tmp___1;
#line 277
        tmp___2 = __builtin_expect((long )not_first_call___0, 0L);
#line 277
        if (tmp___2) {
#line 277
          ((*__cancel_routine___0))(__cancel_arg___0);
#line 277
          __pthread_unwind_next(& __cancel_buf___0);
        }
#line 277
        __pthread_register_cancel(& __cancel_buf___0);
#line 277
        while (1) {
#line 278
          master_source_readlock(ap->entry);
#line 279
          nc = ((ap->entry)->master)->nc;
#line 280
          cache_readlock(nc);
#line 281
          while (1) {
#line 281
            __cancel_routine___1 = & cache_lock_cleanup;
#line 281
            __cancel_arg___1 = (void *)nc;
#line 281
            tmp___3 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___1.__cancel_jmp_buf),
                                  0);
#line 281
            not_first_call___1 = tmp___3;
#line 281
            tmp___4 = __builtin_expect((long )not_first_call___1, 0L);
#line 281
            if (tmp___4) {
#line 281
              ((*__cancel_routine___1))(__cancel_arg___1);
#line 281
              __pthread_unwind_next(& __cancel_buf___1);
            }
#line 281
            __pthread_register_cancel(& __cancel_buf___1);
#line 281
            while (1) {
#line 282
              map = (ap->entry)->maps;
#line 283
              while (map) {
#line 284
                mc = map->mc;
#line 285
                while (1) {
#line 285
                  __cancel_routine___2 = & cache_lock_cleanup;
#line 285
                  __cancel_arg___2 = (void *)mc;
#line 285
                  tmp___5 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___2.__cancel_jmp_buf),
                                        0);
#line 285
                  not_first_call___2 = tmp___5;
#line 285
                  tmp___6 = __builtin_expect((long )not_first_call___2, 0L);
#line 285
                  if (tmp___6) {
#line 285
                    ((*__cancel_routine___2))(__cancel_arg___2);
#line 285
                    __pthread_unwind_next(& __cancel_buf___2);
                  }
#line 285
                  __pthread_register_cancel(& __cancel_buf___2);
#line 285
                  while (1) {
#line 286
                    cache_readlock(mc);
#line 287
                    me = cache_enumerate(mc, (struct mapent *)((void *)0));
#line 288
                    while (me) {
#line 289
                      ne = cache_lookup_distinct(nc, (char const   *)me->key);
#line 290
                      if (ne) {
#line 290
                        if ((unsigned long )map->master_line > (unsigned long )ne->age) {
#line 291
                          me = cache_enumerate(mc, me);
#line 292
                          continue;
                        }
                      }
#line 296
                      do_umount_autofs_direct(ap, mnts, me);
#line 298
                      me = cache_enumerate(mc, me);
                    }
#line 285
                    break;
                  }
#line 300
                  __pthread_unregister_cancel(& __cancel_buf___2);
#line 300
                  ((*__cancel_routine___2))(__cancel_arg___2);
#line 285
                  break;
                }
#line 301
                map = map->next;
              }
#line 281
              break;
            }
#line 303
            __pthread_unregister_cancel(& __cancel_buf___1);
#line 303
            ((*__cancel_routine___1))(__cancel_arg___1);
#line 281
            break;
          }
#line 277
          break;
        }
#line 304
        __pthread_unregister_cancel(& __cancel_buf___0);
#line 304
        ((*__cancel_routine___0))(__cancel_arg___0);
#line 277
        break;
      }
#line 276
      break;
    }
#line 305
    __pthread_unregister_cancel(& __cancel_buf);
#line 305
    ((*__cancel_routine))(__cancel_arg);
#line 276
    break;
  }
#line 307
  return (0);
}
}
#line 310 "direct.c"
static int unlink_mount_tree___0(struct autofs_point *ap , struct list_head *list ) 
{ struct list_head *p ;
  int rv ;
  int ret ;
  pid_t pgrp ;
  pid_t tmp ;
  char spgrp[20] ;
  struct mnt_list *mnt ;
  char *tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;

  {
#line 314
  tmp = getpgrp();
#line 314
  pgrp = tmp;
#line 317
  sprintf((char * __restrict  )(spgrp), (char const   * __restrict  )"pgrp=%d", pgrp);
#line 319
  ret = 1;
#line 320
  p = list->next;
#line 320
  while ((unsigned int )p != (unsigned int )list) {
#line 323
    mnt = (struct mnt_list *)((char *)p - (unsigned long )(& ((struct mnt_list *)0)->list));
#line 325
    tmp___0 = strstr((char const   *)mnt->opts, (char const   *)(spgrp));
#line 325
    if (tmp___0) {
      goto __Cont;
    }
#line 328
    if (0) {
#line 328
      __s1_len = strlen((char const   *)mnt->fs_type);
#line 328
      __s2_len = strlen("autofs");
#line 328
      if (! ((unsigned int )((void const   *)(mnt->fs_type + 1)) - (unsigned int )((void const   *)mnt->fs_type) == 1U)) {
        goto _L___0;
      } else {
#line 328
        if (__s1_len >= 4U) {
          _L___0: 
#line 328
          if (! ((unsigned int )((void const   *)("autofs" + 1)) - (unsigned int )((void const   *)"autofs") == 1U)) {
#line 328
            tmp___10 = 1;
          } else {
#line 328
            if (__s2_len >= 4U) {
#line 328
              tmp___10 = 1;
            } else {
#line 328
              tmp___10 = 0;
            }
          }
        } else {
#line 328
          tmp___10 = 0;
        }
      }
#line 328
      if (tmp___10) {
#line 328
        tmp___6 = __builtin_strcmp((char const   *)mnt->fs_type, "autofs");
      } else {
#line 328
        tmp___9 = __builtin_strcmp((char const   *)mnt->fs_type, "autofs");
#line 328
        tmp___6 = tmp___9;
      }
    } else {
#line 328
      tmp___9 = __builtin_strcmp((char const   *)mnt->fs_type, "autofs");
#line 328
      tmp___6 = tmp___9;
    }
#line 328
    if (tmp___6) {
#line 329
      rv = spawn_umount(log_debug, "-l", mnt->path, (void *)0);
    } else {
#line 331
      rv = umount2((char const   *)mnt->path, 2);
    }
#line 332
    if (rv == -1) {
#line 333
      ret = 0;
#line 334
      while (1) {
#line 334
        ((*log_debug))(ap->logopt, "%s: can\'t unlink %s from mount tree", "unlink_mount_tree",
                       mnt->path);
#line 334
        break;
      }
#line 337
      tmp___11 = __errno_location();
#line 337
      switch ((*tmp___11)) {
      case 22: 
#line 339
      while (1) {
#line 339
        ((*log_warn))(ap->logopt, "%s: bad superblock or not mounted", "unlink_mount_tree");
#line 339
        break;
      }
#line 341
      break;
      case 2: 
      case 14: 
#line 345
      while (1) {
#line 345
        ((*log_warn))(ap->logopt, "%s: bad path for mount", "unlink_mount_tree");
#line 345
        break;
      }
#line 346
      break;
      }
    }
    __Cont: 
#line 320
    p = p->next;
  }
#line 350
  return (ret);
}
}
#line 353 "direct.c"
int do_mount_autofs_direct(struct autofs_point *ap , struct mnt_list *mnts , struct mapent *me ) 
{ struct mnt_params *mp ;
  time_t timeout___0 ;
  struct stat st ;
  int status ;
  int ret ;
  int ioctlfd ;
  int cl_flags ;
  struct list_head list ;
  char const   *map_name ;
  time_t tout ;
  int save_ioctlfd ;
  int ioctlfd___0 ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;

  {
#line 356
  timeout___0 = ap->exp_timeout;
#line 362
  while (1) {
#line 362
    list.next = & list;
#line 362
    list.prev = & list;
#line 362
    break;
  }
#line 364
  tmp___1 = tree_get_mnt_list(mnts, & list, (char const   *)me->key, 1);
#line 364
  if (tmp___1) {
#line 365
    if ((int )ap->state == 4) {
#line 366
      tout = ap->exp_timeout;
#line 369
      ioctlfd___0 = me->ioctlfd;
#line 369
      save_ioctlfd = ioctlfd___0;
#line 371
      if (ioctlfd___0 == -1) {
#line 372
        ioctlfd___0 = open((char const   *)me->key, 0);
#line 373
        if (ioctlfd___0 != -1) {
#line 374
          cl_flags = fcntl(ioctlfd___0, 1, 0);
#line 375
          if (cl_flags != -1) {
#line 376
            cl_flags |= 1;
#line 377
            fcntl(ioctlfd___0, 2, cl_flags);
          }
        }
      }
#line 382
      if (ioctlfd___0 < 0) {
#line 383
        while (1) {
#line 383
          ((*log_error))(ap->logopt, "%s: failed to create ioctl fd for %s", "do_mount_autofs_direct",
                         me->key);
#line 383
          break;
        }
#line 386
        return (0);
      }
#line 389
      if (sizeof(unsigned long ) == sizeof(unsigned long [1])) {
#line 389
        if (sizeof(unsigned long ) < 16384U) {
#line 389
          tmp = sizeof(unsigned long );
        } else {
#line 389
          tmp = __invalid_size_argument_for_IOC;
        }
      } else {
#line 389
        tmp = __invalid_size_argument_for_IOC;
      }
#line 389
      ioctl(ioctlfd___0, (unsigned long )(3221263204U | (tmp << 16)), & tout);
#line 391
      if (save_ioctlfd == -1) {
#line 392
        close(ioctlfd___0);
      }
#line 394
      return (0);
    }
#line 396
    tmp___0 = unlink_mount_tree___0(ap, & list);
#line 396
    if (! tmp___0) {
#line 397
      while (1) {
#line 397
        ((*log_debug))(ap->logopt, "%s: already mounted as other than autofs or failed to unlink entry in tree",
                       "do_mount_autofs_direct");
#line 397
        break;
      }
#line 400
      return (-1);
    }
  }
#line 404
  if (me->ioctlfd != -1) {
#line 405
    while (1) {
#line 405
      ((*log_error))(ap->logopt, "%s: active direct mount %s", "do_mount_autofs_direct",
                     me->key);
#line 405
      break;
    }
#line 406
    return (-1);
  }
#line 409
  status = pthread_once(& key_mnt_params_once, & key_mnt_params_init);
#line 410
  if (status) {
#line 411
    while (1) {
#line 411
      if (status == 35) {
#line 411
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "do_mount_autofs_direct", 411, "direct.c");
#line 411
        dump_core();
      }
#line 411
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 411,
                    "direct.c");
#line 411
      abort();
#line 411
      break;
    }
  }
#line 413
  mp = (struct mnt_params *)pthread_getspecific(key_mnt_direct_params);
#line 414
  if (! mp) {
#line 415
    mp = (struct mnt_params *)malloc(sizeof(struct mnt_params ));
#line 416
    if (! mp) {
#line 417
      while (1) {
#line 417
        ((*log_crit))(ap->logopt, "%s: mnt_params value create failed for direct mount %s",
                      "do_mount_autofs_direct", ap->path);
#line 417
        break;
      }
#line 420
      return (0);
    }
#line 422
    mp->options = (char *)((void *)0);
#line 424
    status = pthread_setspecific(key_mnt_direct_params, (void const   *)mp);
#line 425
    if (status) {
#line 426
      free((void *)mp);
#line 427
      while (1) {
#line 427
        if (status == 35) {
#line 427
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "do_mount_autofs_direct", 427, "direct.c");
#line 427
          dump_core();
        }
#line 427
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 427,
                      "direct.c");
#line 427
        abort();
#line 427
        break;
      }
    }
  }
#line 431
  if (! mp->options) {
#line 432
    mp->options = make_options_string(ap->path, ap->kpipefd, (char *)"direct");
#line 433
    if (! mp->options) {
#line 434
      return (0);
    }
  }
#line 438
  tmp___5 = mkdir_path((char const   *)me->key, 365U);
#line 438
  if (tmp___5 < 0) {
#line 439
    tmp___3 = __errno_location();
#line 439
    if ((*tmp___3) != 17) {
#line 439
      tmp___4 = __errno_location();
#line 439
      if ((*tmp___4) != 30) {
#line 440
        while (1) {
#line 440
          ((*log_crit))(ap->logopt, "%s: failed to create mount directory %s", "do_mount_autofs_direct",
                        me->key);
#line 440
          break;
        }
#line 442
        return (-1);
      }
    }
#line 446
    me->dir_created = 0;
  } else {
#line 449
    me->dir_created = 1;
  }
#line 452
  map_name = (*(((me->mc)->map)->argv + 0));
#line 454
  ret = mount(map_name, (char const   *)me->key, "autofs", 3236757504UL, (void const   *)mp->options);
#line 455
  if (ret) {
#line 456
    while (1) {
#line 456
      ((*log_crit))(ap->logopt, "%s: failed to mount autofs path %s", "do_mount_autofs_direct",
                    me->key);
#line 456
      break;
    }
    goto out_err;
  }
#line 461
  ioctlfd = open((char const   *)me->key, 0);
#line 462
  if (ioctlfd < 0) {
#line 463
    while (1) {
#line 463
      ((*log_crit))(ap->logopt, "%s: failed to create ioctl fd for %s", "do_mount_autofs_direct",
                    me->key);
#line 463
      break;
    }
    goto out_umount;
  }
#line 467
  cl_flags = fcntl(ioctlfd, 1, 0);
#line 467
  if (cl_flags != -1) {
#line 468
    cl_flags |= 1;
#line 469
    fcntl(ioctlfd, 2, cl_flags);
  }
#line 473
  ap->exp_runfreq = ((timeout___0 + 4L) - 1L) / 4L;
#line 475
  if (sizeof(unsigned long ) == sizeof(unsigned long [1])) {
#line 475
    if (sizeof(unsigned long ) < 16384U) {
#line 475
      tmp___6 = sizeof(unsigned long );
    } else {
#line 475
      tmp___6 = __invalid_size_argument_for_IOC;
    }
  } else {
#line 475
    tmp___6 = __invalid_size_argument_for_IOC;
  }
#line 475
  ioctl(ioctlfd, (unsigned long )(3221263204U | (tmp___6 << 16)), & timeout___0);
#line 477
  if (ap->exp_timeout) {
#line 478
    while (1) {
#line 478
      ((*log_info))(0U, "mounted direct mount on %s with timeout %u, freq %u seconds",
                    me->key, (unsigned int )ap->exp_timeout, (unsigned int )ap->exp_runfreq);
#line 478
      break;
    }
  } else {
#line 483
    while (1) {
#line 483
      ((*log_info))(0U, "mounted direct mount on %s with timeouts disabled", me->key);
#line 483
      break;
    }
  }
#line 486
  ret = fstat__extinline(ioctlfd, & st);
#line 487
  if (ret == -1) {
#line 488
    while (1) {
#line 488
      ((*log_error))(ap->logopt, "%s: failed to stat direct mount trigger %s", "do_mount_autofs_direct",
                     me->key);
#line 488
      break;
    }
    goto out_close;
  }
#line 492
  cache_set_ino_index(me->mc, (char const   *)me->key, st.st_dev, st.st_ino);
#line 494
  close(ioctlfd);
#line 496
  while (1) {
#line 496
    ((*log_debug))(ap->logopt, "%s: mounted trigger %s", "do_mount_autofs_direct",
                   me->key);
#line 496
    break;
  }
#line 498
  return (0);
  out_close: 
#line 501
  close(ioctlfd);
  out_umount: 
#line 504
  umount((char const   *)me->key);
  out_err: 
#line 506
  if (me->dir_created) {
#line 507
    rmdir((char const   *)me->key);
  }
#line 509
  return (-1);
}
}
#line 512 "direct.c"
int mount_autofs_direct(struct autofs_point *ap ) 
{ struct map_source *map ;
  struct mapent_cache *nc ;
  struct mapent_cache *mc ;
  struct mapent *me ;
  struct mapent *ne ;
  struct mapent *nested ;
  struct mnt_list *mnts ;
  time_t now ;
  time_t tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___12 ;
  long tmp___13 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___0)(void * ) ;
  void *__cancel_arg___0 ;
  int not_first_call___0 ;
  int tmp___14 ;
  long tmp___15 ;
  __pthread_unwind_buf_t __cancel_buf___1 ;
  void (*__cancel_routine___1)(void * ) ;
  void *__cancel_arg___1 ;
  int not_first_call___1 ;
  int tmp___16 ;
  long tmp___17 ;
  __pthread_unwind_buf_t __cancel_buf___2 ;
  void (*__cancel_routine___2)(void * ) ;
  void *__cancel_arg___2 ;
  int not_first_call___2 ;
  int tmp___18 ;
  long tmp___19 ;

  {
#line 518
  tmp = time((time_t *)((void *)0));
#line 518
  now = tmp;
#line 520
  if (0) {
#line 520
    __s1_len = strlen((char const   *)ap->path);
#line 520
    __s2_len = strlen("/-");
#line 520
    if (! ((unsigned int )((void const   *)(ap->path + 1)) - (unsigned int )((void const   *)ap->path) == 1U)) {
      goto _L___0;
    } else {
#line 520
      if (__s1_len >= 4U) {
        _L___0: 
#line 520
        if (! ((unsigned int )((void const   *)("/-" + 1)) - (unsigned int )((void const   *)"/-") == 1U)) {
#line 520
          tmp___9 = 1;
        } else {
#line 520
          if (__s2_len >= 4U) {
#line 520
            tmp___9 = 1;
          } else {
#line 520
            tmp___9 = 0;
          }
        }
      } else {
#line 520
        tmp___9 = 0;
      }
    }
#line 520
    if (tmp___9) {
#line 520
      tmp___5 = __builtin_strcmp((char const   *)ap->path, "/-");
    } else {
#line 520
      tmp___8 = __builtin_strcmp((char const   *)ap->path, "/-");
#line 520
      tmp___5 = tmp___8;
    }
  } else {
#line 520
    tmp___8 = __builtin_strcmp((char const   *)ap->path, "/-");
#line 520
    tmp___5 = tmp___8;
  }
#line 520
  if (tmp___5) {
#line 521
    while (1) {
#line 521
      ((*log_error))(ap->logopt, "%s: expected direct map, exiting", "mount_autofs_direct");
#line 521
      break;
    }
#line 522
    return (-1);
  }
#line 525
  tmp___10 = autofs_init_direct(ap);
#line 525
  if (tmp___10) {
#line 526
    return (-1);
  }
#line 529
  tmp___11 = lookup_nss_read_map(ap, (struct map_source *)((void *)0), now);
#line 529
  if (tmp___11) {
#line 530
    lookup_prune_cache(ap, now);
  } else {
#line 532
    while (1) {
#line 532
      ((*log_error))(ap->logopt, "%s: failed to read direct map", "mount_autofs_direct");
#line 532
      break;
    }
#line 533
    return (-1);
  }
#line 536
  mnts = tree_make_mnt_tree("/proc/mounts", "/");
#line 537
  while (1) {
#line 537
    __cancel_routine = & mnts_cleanup___0;
#line 537
    __cancel_arg = (void *)mnts;
#line 537
    tmp___12 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                           0);
#line 537
    not_first_call = tmp___12;
#line 537
    tmp___13 = __builtin_expect((long )not_first_call, 0L);
#line 537
    if (tmp___13) {
#line 537
      ((*__cancel_routine))(__cancel_arg);
#line 537
      __pthread_unwind_next(& __cancel_buf);
    }
#line 537
    __pthread_register_cancel(& __cancel_buf);
#line 537
    while (1) {
#line 538
      while (1) {
#line 538
        __cancel_routine___0 = & master_source_lock_cleanup;
#line 538
        __cancel_arg___0 = (void *)ap->entry;
#line 538
        tmp___14 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf),
                               0);
#line 538
        not_first_call___0 = tmp___14;
#line 538
        tmp___15 = __builtin_expect((long )not_first_call___0, 0L);
#line 538
        if (tmp___15) {
#line 538
          ((*__cancel_routine___0))(__cancel_arg___0);
#line 538
          __pthread_unwind_next(& __cancel_buf___0);
        }
#line 538
        __pthread_register_cancel(& __cancel_buf___0);
#line 538
        while (1) {
#line 539
          master_source_readlock(ap->entry);
#line 540
          nc = ((ap->entry)->master)->nc;
#line 541
          cache_readlock(nc);
#line 542
          while (1) {
#line 542
            __cancel_routine___1 = & cache_lock_cleanup;
#line 542
            __cancel_arg___1 = (void *)nc;
#line 542
            tmp___16 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___1.__cancel_jmp_buf),
                                   0);
#line 542
            not_first_call___1 = tmp___16;
#line 542
            tmp___17 = __builtin_expect((long )not_first_call___1, 0L);
#line 542
            if (tmp___17) {
#line 542
              ((*__cancel_routine___1))(__cancel_arg___1);
#line 542
              __pthread_unwind_next(& __cancel_buf___1);
            }
#line 542
            __pthread_register_cancel(& __cancel_buf___1);
#line 542
            while (1) {
#line 543
              map = (ap->entry)->maps;
#line 544
              while (map) {
#line 549
                if ((ap->entry)->age > map->age) {
#line 550
                  map = map->next;
#line 551
                  continue;
                }
#line 554
                mc = map->mc;
#line 555
                while (1) {
#line 555
                  __cancel_routine___2 = & cache_lock_cleanup;
#line 555
                  __cancel_arg___2 = (void *)mc;
#line 555
                  tmp___18 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___2.__cancel_jmp_buf),
                                         0);
#line 555
                  not_first_call___2 = tmp___18;
#line 555
                  tmp___19 = __builtin_expect((long )not_first_call___2, 0L);
#line 555
                  if (tmp___19) {
#line 555
                    ((*__cancel_routine___2))(__cancel_arg___2);
#line 555
                    __pthread_unwind_next(& __cancel_buf___2);
                  }
#line 555
                  __pthread_register_cancel(& __cancel_buf___2);
#line 555
                  while (1) {
#line 556
                    cache_readlock(mc);
#line 557
                    me = cache_enumerate(mc, (struct mapent *)((void *)0));
#line 558
                    while (me) {
#line 559
                      ne = cache_lookup_distinct(nc, (char const   *)me->key);
#line 560
                      if (ne) {
#line 561
                        if ((unsigned long )map->master_line < (unsigned long )ne->age) {
#line 563
                          do_mount_autofs_direct(ap, mnts, me);
                        }
#line 565
                        me = cache_enumerate(mc, me);
#line 566
                        continue;
                      }
#line 569
                      nested = cache_partial_match(nc, (char const   *)me->key);
#line 570
                      if (nested) {
#line 571
                        while (1) {
#line 571
                          ((*log_error))(ap->logopt, "%s: removing invalid nested null entry %s",
                                         "mount_autofs_direct", nested->key);
#line 571
                          break;
                        }
#line 574
                        nested = cache_partial_match(nc, (char const   *)me->key);
#line 575
                        if (nested) {
#line 576
                          cache_delete(nc, (char const   *)nested->key);
                        }
                      }
#line 580
                      do_mount_autofs_direct(ap, mnts, me);
#line 582
                      me = cache_enumerate(mc, me);
                    }
#line 555
                    break;
                  }
#line 584
                  __pthread_unregister_cancel(& __cancel_buf___2);
#line 584
                  ((*__cancel_routine___2))(__cancel_arg___2);
#line 555
                  break;
                }
#line 585
                map = map->next;
              }
#line 542
              break;
            }
#line 587
            __pthread_unregister_cancel(& __cancel_buf___1);
#line 587
            ((*__cancel_routine___1))(__cancel_arg___1);
#line 542
            break;
          }
#line 538
          break;
        }
#line 588
        __pthread_unregister_cancel(& __cancel_buf___0);
#line 588
        ((*__cancel_routine___0))(__cancel_arg___0);
#line 538
        break;
      }
#line 537
      break;
    }
#line 589
    __pthread_unregister_cancel(& __cancel_buf);
#line 589
    ((*__cancel_routine))(__cancel_arg);
#line 537
    break;
  }
#line 591
  return (0);
}
}
#line 594 "direct.c"
int umount_autofs_offset(struct autofs_point *ap , struct mapent *me ) 
{ char buf[128] ;
  int ioctlfd ;
  int cl_flags ;
  int rv ;
  int retries ;
  int tmp ;
  int status ;
  unsigned int tmp___0 ;
  char *estr ;
  int *tmp___1 ;
  char *tmp___2 ;
  struct stat st ;
  char *estr___0 ;
  int save_errno ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  struct timespec tm ;
  int *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;

  {
#line 597
  rv = 1;
#line 599
  if (me->ioctlfd != -1) {
#line 600
    tmp = is_mounted("/etc/mtab", (char const   *)me->key, 2U);
#line 600
    if (tmp) {
#line 601
      while (1) {
#line 601
        ((*log_error))(ap->logopt, "%s: attempt to umount busy offset %s", "umount_autofs_offset",
                       me->key);
#line 601
        break;
      }
#line 603
      return (1);
    }
#line 605
    ioctlfd = me->ioctlfd;
  } else {
#line 607
    ioctlfd = open((char const   *)me->key, 0);
#line 608
    if (ioctlfd != -1) {
#line 609
      cl_flags = fcntl(ioctlfd, 1, 0);
#line 609
      if (cl_flags != -1) {
#line 610
        cl_flags |= 1;
#line 611
        fcntl(ioctlfd, 2, cl_flags);
      }
    }
  }
#line 616
  if (ioctlfd >= 0) {
#line 617
    status = 1;
#line 619
    if (sizeof(int ) == sizeof(int [1])) {
#line 619
      if (sizeof(int ) < 16384U) {
#line 619
        tmp___0 = sizeof(int );
      } else {
#line 619
        tmp___0 = __invalid_size_argument_for_IOC;
      }
    } else {
#line 619
      tmp___0 = __invalid_size_argument_for_IOC;
    }
#line 619
    rv = ioctl(ioctlfd, (unsigned long )(2147521392U | (tmp___0 << 16)), & status);
#line 620
    if (rv) {
#line 621
      tmp___1 = __errno_location();
#line 621
      tmp___2 = strerror_r((*tmp___1), buf, 128U);
#line 621
      estr = tmp___2;
#line 622
      while (1) {
#line 622
        ((*log_error))(ap->logopt, "%s: ioctl failed: %s", "umount_autofs_offset",
                       estr);
#line 622
        break;
      }
#line 623
      return (1);
    } else {
#line 624
      if (! status) {
#line 625
        if ((int )ap->state != 6) {
#line 626
          while (1) {
#line 626
            ((*log_error))(ap->logopt, "%s: ask umount returned busy for %s", "umount_autofs_offset",
                           me->key);
#line 626
            break;
          }
#line 629
          return (1);
        } else {
#line 631
          me->ioctlfd = -1;
#line 632
          ioctl(ioctlfd, 37730UL, 0);
#line 633
          close(ioctlfd);
          goto force_umount;
        }
      }
    }
#line 637
    me->ioctlfd = -1;
#line 638
    ioctl(ioctlfd, 37730UL, 0);
#line 639
    close(ioctlfd);
  } else {
#line 643
    tmp___3 = __errno_location();
#line 643
    save_errno = (*tmp___3);
#line 646
    tmp___4 = stat__extinline((char const   *)me->key, & st);
#line 646
    if (tmp___4 == -1) {
#line 646
      tmp___5 = __errno_location();
#line 646
      if ((*tmp___5) == 2) {
#line 647
        return (0);
      }
    }
#line 649
    estr___0 = strerror_r(save_errno, buf, 128U);
#line 650
    while (1) {
#line 650
      ((*log_error))(ap->logopt, "%s: couldn\'t get ioctl fd for offset %s: %s", "umount_autofs_offset",
                     me->key, estr___0);
#line 650
      break;
    }
    goto force_umount;
  }
#line 656
  sched_yield();
#line 658
  retries = 8;
#line 659
  while (1) {
#line 659
    rv = umount((char const   *)me->key);
#line 659
    if (rv == -1) {
#line 659
      tmp___7 = retries;
#line 659
      retries --;
#line 659
      if (! tmp___7) {
#line 659
        break;
      }
    } else {
#line 659
      break;
    }
#line 660
    tm.tv_sec = 0L;
#line 660
    tm.tv_nsec = 100000000L;
#line 661
    tmp___6 = __errno_location();
#line 661
    if ((*tmp___6) != 16) {
#line 662
      break;
    }
#line 663
    nanosleep((struct timespec  const  *)(& tm), (struct timespec *)((void *)0));
  }
#line 666
  if (rv == -1) {
#line 667
    tmp___8 = __errno_location();
#line 667
    switch ((*tmp___8)) {
    case 2: 
#line 669
    while (1) {
#line 669
      ((*log_warn))(ap->logopt, "%s: mount point does not exist", "umount_autofs_offset");
#line 669
      break;
    }
#line 670
    return (0);
#line 671
    break;
    case 16: 
#line 673
    while (1) {
#line 673
      ((*log_error))(ap->logopt, "%s: mount point %s is in use", "umount_autofs_offset",
                     me->key);
#line 673
      break;
    }
#line 674
    if ((int )ap->state != 6) {
#line 675
      return (1);
    }
#line 676
    break;
    case 20: 
#line 678
    while (1) {
#line 678
      ((*log_error))(ap->logopt, "%s: mount point is not a directory", "umount_autofs_offset");
#line 678
      break;
    }
#line 679
    return (0);
#line 680
    break;
    }
    goto force_umount;
  }
  force_umount: 
#line 686
  if (rv != 0) {
#line 687
    while (1) {
#line 687
      ((*log_info))(0U, "forcing umount of offset mount %s", me->key);
#line 687
      break;
    }
#line 688
    rv = umount2((char const   *)me->key, 2);
  } else {
#line 690
    while (1) {
#line 690
      ((*log_info))(0U, "umounted offset mount %s", me->key);
#line 690
      break;
    }
  }
#line 692
  return (rv);
}
}
#line 695 "direct.c"
int mount_autofs_offset(struct autofs_point *ap , struct mapent *me , int is_autofs_fs ) 
{ struct mnt_params *mp ;
  time_t timeout___0 ;
  struct stat st ;
  int ioctlfd ;
  int cl_flags ;
  int status ;
  int ret ;
  char const   *type___0 ;
  char const   *map_name ;
  int tmp ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___13 ;
  int tmp___16 ;
  int tmp___17 ;
  unsigned int tmp___18 ;
  int tmp___19 ;

  {
#line 698
  timeout___0 = ap->exp_timeout;
#line 701
  map_name = (char const   *)((void *)0);
#line 703
  tmp = is_mounted("/proc/mounts", (char const   *)me->key, 4U);
#line 703
  if (tmp) {
#line 704
    if ((int )ap->state != 4) {
#line 705
      while (1) {
#line 705
        ((*log_warn))(ap->logopt, "%s: trigger %s already mounted", "mount_autofs_offset",
                      me->key);
#line 705
        break;
      }
    }
#line 707
    return (0);
  }
#line 710
  if (me->ioctlfd != -1) {
#line 711
    while (1) {
#line 711
      ((*log_error))(ap->logopt, "%s: active offset mount %s", "mount_autofs_offset",
                     me->key);
#line 711
      break;
    }
#line 712
    return (-1);
  }
#line 715
  status = pthread_once(& key_mnt_params_once, & key_mnt_params_init);
#line 716
  if (status) {
#line 717
    while (1) {
#line 717
      if (status == 35) {
#line 717
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "mount_autofs_offset", 717, "direct.c");
#line 717
        dump_core();
      }
#line 717
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 717,
                    "direct.c");
#line 717
      abort();
#line 717
      break;
    }
  }
#line 719
  mp = (struct mnt_params *)pthread_getspecific(key_mnt_offset_params);
#line 720
  if (! mp) {
#line 721
    mp = (struct mnt_params *)malloc(sizeof(struct mnt_params ));
#line 722
    if (! mp) {
#line 723
      while (1) {
#line 723
        ((*log_crit))(ap->logopt, "%s: mnt_params value create failed for offset mount %s",
                      "mount_autofs_offset", me->key);
#line 723
        break;
      }
#line 726
      return (0);
    }
#line 728
    mp->options = (char *)((void *)0);
#line 730
    status = pthread_setspecific(key_mnt_offset_params, (void const   *)mp);
#line 731
    if (status) {
#line 732
      free((void *)mp);
#line 733
      while (1) {
#line 733
        if (status == 35) {
#line 733
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "mount_autofs_offset", 733, "direct.c");
#line 733
          dump_core();
        }
#line 733
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 733,
                      "direct.c");
#line 733
        abort();
#line 733
        break;
      }
    }
  }
#line 737
  if (! mp->options) {
#line 738
    mp->options = make_options_string(ap->path, ap->kpipefd, (char *)"offset");
#line 739
    if (! mp->options) {
#line 740
      return (0);
    }
  }
#line 743
  if (is_autofs_fs) {
#line 745
    tmp___3 = mkdir_path((char const   *)me->key, 365U);
#line 745
    if (tmp___3 < 0) {
#line 746
      tmp___2 = __errno_location();
#line 746
      if ((*tmp___2) != 17) {
#line 747
        while (1) {
#line 747
          tmp___1 = __errno_location();
#line 747
          ((*log_crit))(ap->logopt, "%s: failed to create mount directory %s %d",
                        "mount_autofs_offset", me->key, (*tmp___1));
#line 747
          break;
        }
#line 750
        return (-1);
      }
#line 756
      me->dir_created = 0;
    } else {
#line 759
      me->dir_created = 1;
    }
  } else {
#line 762
    me->dir_created = 0;
#line 771
    tmp___4 = stat__extinline((char const   *)me->key, & st);
#line 771
    if (tmp___4 == -1) {
#line 771
      tmp___5 = __errno_location();
#line 771
      if ((*tmp___5) == 2) {
#line 772
        return (0);
      }
    }
  }
#line 775
  while (1) {
#line 775
    ((*log_debug))(ap->logopt, "%s: calling mount -t autofs -s  -o %s automount %s",
                   "mount_autofs_offset", mp->options, me->key);
#line 775
    break;
  }
#line 779
  type___0 = (char const   *)((ap->entry)->maps)->type;
#line 780
  if (type___0) {
#line 780
    if (0) {
#line 780
      __s1_len = strlen((char const   *)((ap->entry)->maps)->type);
#line 780
      __s2_len = strlen("hosts");
#line 780
      if (! ((unsigned int )((void const   *)(((ap->entry)->maps)->type + 1)) - (unsigned int )((void const   *)((ap->entry)->maps)->type) == 1U)) {
        goto _L___0;
      } else {
#line 780
        if (__s1_len >= 4U) {
          _L___0: 
#line 780
          if (! ((unsigned int )((void const   *)("hosts" + 1)) - (unsigned int )((void const   *)"hosts") == 1U)) {
#line 780
            tmp___17 = 1;
          } else {
#line 780
            if (__s2_len >= 4U) {
#line 780
              tmp___17 = 1;
            } else {
#line 780
              tmp___17 = 0;
            }
          }
        } else {
#line 780
          tmp___17 = 0;
        }
      }
#line 780
      if (tmp___17) {
#line 780
        tmp___13 = __builtin_strcmp((char const   *)((ap->entry)->maps)->type, "hosts");
      } else {
#line 780
        tmp___16 = __builtin_strcmp((char const   *)((ap->entry)->maps)->type, "hosts");
#line 780
        tmp___13 = tmp___16;
      }
    } else {
#line 780
      tmp___16 = __builtin_strcmp((char const   *)((ap->entry)->maps)->type, "hosts");
#line 780
      tmp___13 = tmp___16;
    }
#line 780
    if (tmp___13) {
#line 787
      map_name = (*(((me->mc)->map)->argv + 0));
    } else {
#line 781
      tmp___7 = (char *)__builtin_alloca(7U);
#line 781
      tmp___6 = tmp___7;
#line 782
      if (tmp___6) {
#line 783
        strcpy((char * __restrict  )tmp___6, (char const   * __restrict  )"-hosts");
#line 784
        map_name = (char const   *)tmp___6;
      }
    }
  } else {
#line 787
    map_name = (*(((me->mc)->map)->argv + 0));
  }
#line 789
  ret = mount(map_name, (char const   *)me->key, "autofs", 3236757504UL, (void const   *)mp->options);
#line 790
  if (ret) {
#line 791
    while (1) {
#line 791
      ((*log_crit))(ap->logopt, "%s: failed to mount autofs path %s", "mount_autofs_offset",
                    me->key);
#line 791
      break;
    }
    goto out_err;
  }
#line 795
  if (ret != 0) {
#line 796
    while (1) {
#line 796
      ((*log_crit))(ap->logopt, "%s: failed to mount autofs offset trigger %s", "mount_autofs_offset",
                    me->key);
#line 796
      break;
    }
    goto out_err;
  }
#line 802
  ioctlfd = open((char const   *)me->key, 0);
#line 803
  if (ioctlfd < 0) {
#line 804
    while (1) {
#line 804
      ((*log_crit))(ap->logopt, "%s: failed to create ioctl fd for %s", "mount_autofs_offset",
                    me->key);
#line 804
      break;
    }
    goto out_umount;
  }
#line 808
  cl_flags = fcntl(ioctlfd, 1, 0);
#line 808
  if (cl_flags != -1) {
#line 809
    cl_flags |= 1;
#line 810
    fcntl(ioctlfd, 2, cl_flags);
  }
#line 813
  if (sizeof(unsigned long ) == sizeof(unsigned long [1])) {
#line 813
    if (sizeof(unsigned long ) < 16384U) {
#line 813
      tmp___18 = sizeof(unsigned long );
    } else {
#line 813
      tmp___18 = __invalid_size_argument_for_IOC;
    }
  } else {
#line 813
    tmp___18 = __invalid_size_argument_for_IOC;
  }
#line 813
  ioctl(ioctlfd, (unsigned long )(3221263204U | (tmp___18 << 16)), & timeout___0);
#line 815
  ret = fstat__extinline(ioctlfd, & st);
#line 816
  if (ret == -1) {
#line 817
    while (1) {
#line 817
      ((*log_error))(ap->logopt, "%s: failed to stat direct mount trigger %s", "mount_autofs_offset",
                     me->key);
#line 817
      break;
    }
    goto out_close;
  }
#line 822
  cache_set_ino_index(me->mc, (char const   *)me->key, st.st_dev, st.st_ino);
#line 824
  close(ioctlfd);
#line 826
  while (1) {
#line 826
    ((*log_debug))(ap->logopt, "%s: mounted trigger %s", "mount_autofs_offset", me->key);
#line 826
    break;
  }
#line 828
  return (0);
  out_close: 
#line 831
  close(ioctlfd);
  out_umount: 
#line 833
  umount((char const   *)me->key);
  out_err: 
#line 835
  if (is_autofs_fs) {
#line 836
    tmp___19 = stat__extinline((char const   *)me->key, & st);
#line 836
    if (tmp___19 == 0) {
#line 836
      if (me->dir_created) {
#line 837
        rmdir_path(ap, (char const   *)me->key, st.st_dev);
      }
    }
  }
#line 840
  return (-1);
}
}
#line 843 "direct.c"
static int expire_direct(int ioctlfd , char const   *path___0 , unsigned int when ,
                         unsigned int logopt ) 
{ char buf[128] ;
  int ret ;
  int retries ;
  struct stat st ;
  char *estr ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct timespec tm ;
  unsigned int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  unsigned int tmp___8 ;
  int tmp___9 ;

  {
#line 849
  tmp___1 = fstat__extinline(ioctlfd, & st);
#line 849
  if (tmp___1 == -1) {
#line 850
    tmp = __errno_location();
#line 850
    tmp___0 = strerror_r((*tmp), buf, 128U);
#line 850
    estr = tmp___0;
#line 851
    while (1) {
#line 851
      ((*log_error))(logopt, "%s: fstat failed: %s", "expire_direct", estr);
#line 851
      break;
    }
#line 852
    return (0);
  }
#line 855
  tmp___2 = count_mounts(path___0, st.st_dev);
#line 855
  retries = (tmp___2 + 1) * 3;
#line 857
  while (1) {
#line 857
    tmp___7 = retries;
#line 857
    retries --;
#line 857
    if (! tmp___7) {
#line 857
      break;
    }
#line 858
    tm.tv_sec = 0L;
#line 858
    tm.tv_nsec = 100000000L;
#line 861
    if (sizeof(int ) == sizeof(int [1])) {
#line 861
      if (sizeof(int ) < 16384U) {
#line 861
        tmp___3 = sizeof(int );
      } else {
#line 861
        tmp___3 = __invalid_size_argument_for_IOC;
      }
    } else {
#line 861
      tmp___3 = __invalid_size_argument_for_IOC;
    }
#line 861
    ret = ioctl(ioctlfd, (unsigned long )(1073779558U | (tmp___3 << 16)), & when);
#line 862
    if (ret == -1) {
#line 864
      tmp___4 = __errno_location();
#line 864
      if ((*tmp___4) == 9) {
#line 865
        return (1);
      } else {
#line 864
        tmp___5 = __errno_location();
#line 864
        if ((*tmp___5) == 22) {
#line 865
          return (1);
        }
      }
#line 868
      tmp___6 = __errno_location();
#line 868
      if ((*tmp___6) != 11) {
#line 869
        return (0);
      }
    }
#line 872
    nanosleep((struct timespec  const  *)(& tm), (struct timespec *)((void *)0));
  }
#line 875
  if (sizeof(int ) == sizeof(int [1])) {
#line 875
    if (sizeof(int ) < 16384U) {
#line 875
      tmp___8 = sizeof(int );
    } else {
#line 875
      tmp___8 = __invalid_size_argument_for_IOC;
    }
  } else {
#line 875
    tmp___8 = __invalid_size_argument_for_IOC;
  }
#line 875
  tmp___9 = ioctl(ioctlfd, (unsigned long )(2147521392U | (tmp___8 << 16)), & ret);
#line 875
  if (! tmp___9) {
#line 876
    if (! ret) {
#line 877
      return (0);
    }
  }
#line 880
  return (1);
}
}
#line 883 "direct.c"
void *expire_proc_direct(void *arg ) 
{ struct mnt_list *mnts ;
  struct mnt_list *next ;
  struct list_head list ;
  struct list_head *p ;
  struct expire_args *ea ;
  struct expire_args ec ;
  struct autofs_point *ap ;
  struct mapent *me ;
  unsigned int now ;
  int ioctlfd ;
  int cur_state ;
  int status ;
  int ret ;
  int left ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___0)(void * ) ;
  void *__cancel_arg___0 ;
  int not_first_call___0 ;
  int tmp___2 ;
  long tmp___3 ;
  struct stat st ;
  struct statfs fs ;
  int ioctlfd___0 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 885
  mnts = (struct mnt_list *)((void *)0);
#line 890
  me = (struct mapent *)((void *)0);
#line 895
  ea = (struct expire_args *)arg;
#line 897
  status = pthread_mutex_lock(& ea->mutex);
#line 898
  if (status) {
#line 899
    while (1) {
#line 899
      if (status == 35) {
#line 899
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "expire_proc_direct", 899, "direct.c");
#line 899
        dump_core();
      }
#line 899
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 899,
                    "direct.c");
#line 899
      abort();
#line 899
      break;
    }
  }
#line 901
  ec.ap = ea->ap;
#line 901
  ap = ec.ap;
#line 902
  now = ea->when;
#line 903
  ec.status = -1;
#line 905
  ea->signaled = 1U;
#line 906
  status = pthread_cond_signal(& ea->cond);
#line 907
  if (status) {
#line 908
    while (1) {
#line 908
      if (status == 35) {
#line 908
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "expire_proc_direct", 908, "direct.c");
#line 908
        dump_core();
      }
#line 908
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 908,
                    "direct.c");
#line 908
      abort();
#line 908
      break;
    }
  }
#line 910
  status = pthread_mutex_unlock(& ea->mutex);
#line 911
  if (status) {
#line 912
    while (1) {
#line 912
      if (status == 35) {
#line 912
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "expire_proc_direct", 912, "direct.c");
#line 912
        dump_core();
      }
#line 912
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 912,
                    "direct.c");
#line 912
      abort();
#line 912
      break;
    }
  }
#line 914
  while (1) {
#line 914
    __cancel_routine = & expire_cleanup;
#line 914
    __cancel_arg = (void *)(& ec);
#line 914
    tmp = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf), 0);
#line 914
    not_first_call = tmp;
#line 914
    tmp___0 = __builtin_expect((long )not_first_call, 0L);
#line 914
    if (tmp___0) {
#line 914
      ((*__cancel_routine))(__cancel_arg);
#line 914
      __pthread_unwind_next(& __cancel_buf);
    }
#line 914
    __pthread_register_cancel(& __cancel_buf);
#line 914
    while (1) {
#line 916
      left = 0;
#line 918
      mnts = tree_make_mnt_tree("/proc/mounts", "/");
#line 921
      while (1) {
#line 921
        list.next = & list;
#line 921
        list.prev = & list;
#line 921
        break;
      }
#line 922
      tmp___1 = tree_get_mnt_list(mnts, & list, "/", 0);
#line 922
      if (! tmp___1) {
#line 923
        ec.status = 0;
#line 924
        return ((void *)0);
      }
#line 926
      while (1) {
#line 926
        __cancel_routine___0 = & mnts_cleanup___0;
#line 926
        __cancel_arg___0 = (void *)mnts;
#line 926
        tmp___2 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf),
                              0);
#line 926
        not_first_call___0 = tmp___2;
#line 926
        tmp___3 = __builtin_expect((long )not_first_call___0, 0L);
#line 926
        if (tmp___3) {
#line 926
          ((*__cancel_routine___0))(__cancel_arg___0);
#line 926
          __pthread_unwind_next(& __cancel_buf___0);
        }
#line 926
        __pthread_register_cancel(& __cancel_buf___0);
#line 926
        while (1) {
#line 928
          p = list.next;
#line 928
          while ((unsigned int )p != (unsigned int )(& list)) {
#line 929
            next = (struct mnt_list *)((char *)p - (unsigned long )(& ((struct mnt_list *)0)->list));
#line 935
            me = lookup_source_mapent(ap, (char const   *)next->path, 8192U);
#line 936
            if (! me) {
              goto __Cont;
            }
#line 939
            if (0) {
#line 939
              __s1_len = strlen((char const   *)next->fs_type);
#line 939
              __s2_len = strlen("autofs");
#line 939
              if (! ((unsigned int )((void const   *)(next->fs_type + 1)) - (unsigned int )((void const   *)next->fs_type) == 1U)) {
                goto _L___0;
              } else {
#line 939
                if (__s1_len >= 4U) {
                  _L___0: 
#line 939
                  if (! ((unsigned int )((void const   *)("autofs" + 1)) - (unsigned int )((void const   *)"autofs") == 1U)) {
#line 939
                    tmp___18 = 1;
                  } else {
#line 939
                    if (__s2_len >= 4U) {
#line 939
                      tmp___18 = 1;
                    } else {
#line 939
                      tmp___18 = 0;
                    }
                  }
                } else {
#line 939
                  tmp___18 = 0;
                }
              }
#line 939
              if (tmp___18) {
#line 939
                tmp___14 = __builtin_strcmp((char const   *)next->fs_type, "autofs");
              } else {
#line 939
                tmp___17 = __builtin_strcmp((char const   *)next->fs_type, "autofs");
#line 939
                tmp___14 = tmp___17;
              }
            } else {
#line 939
              tmp___17 = __builtin_strcmp((char const   *)next->fs_type, "autofs");
#line 939
              tmp___14 = tmp___17;
            }
#line 939
            if (! tmp___14) {
#line 944
              cache_unlock(me->mc);
#line 950
              pthread_setcancelstate(1, & cur_state);
#line 951
              tmp___4 = strstr((char const   *)next->opts, "indirect");
#line 951
              if (tmp___4) {
#line 952
                master_notify_submount(ap, (char const   *)next->path, ap->state);
#line 953
                pthread_setcancelstate(cur_state, (int *)((void *)0));
                goto __Cont;
              }
#line 957
              if (me->ioctlfd == -1) {
#line 958
                pthread_setcancelstate(cur_state, (int *)((void *)0));
                goto __Cont;
              }
#line 962
              tmp___5 = statfs((char const   *)next->path, & fs);
#line 962
              if (tmp___5 == -1) {
#line 963
                pthread_setcancelstate(cur_state, (int *)((void *)0));
#line 964
                while (1) {
#line 964
                  ((*log_warn))(ap->logopt, "%s: fstatfs failed for %s", "expire_proc_direct",
                                next->path);
#line 964
                  break;
                }
                goto __Cont;
              }
#line 969
              if (fs.f_type != 391) {
#line 970
                pthread_setcancelstate(cur_state, (int *)((void *)0));
                goto __Cont;
              }
#line 987
              tmp___6 = strstr((char const   *)next->opts, "offset");
#line 987
              if (tmp___6) {
#line 988
                close(me->ioctlfd);
#line 989
                me->ioctlfd = -1;
#line 990
                pthread_setcancelstate(cur_state, (int *)((void *)0));
                goto __Cont;
              }
#line 994
              ioctlfd___0 = me->ioctlfd;
#line 996
              ret = expire_direct(ioctlfd___0, (char const   *)next->path, now, ap->logopt);
#line 997
              if (! ret) {
#line 998
                left ++;
#line 999
                pthread_setcancelstate(cur_state, (int *)((void *)0));
                goto __Cont;
              }
#line 1003
              if (me->ioctlfd != -1) {
#line 1003
                tmp___7 = fstat__extinline(ioctlfd___0, & st);
#line 1003
                if (tmp___7 != -1) {
#line 1003
                  tmp___8 = count_mounts((char const   *)next->path, st.st_dev);
#line 1003
                  if (! tmp___8) {
#line 1006
                    close(ioctlfd___0);
#line 1007
                    me->ioctlfd = -1;
                  }
                }
              }
#line 1010
              pthread_setcancelstate(cur_state, (int *)((void *)0));
              goto __Cont;
            }
#line 1014
            if (me->ioctlfd >= 0) {
#line 1016
              ioctlfd = me->ioctlfd;
#line 1017
              cache_unlock(me->mc);
            } else {
#line 1019
              cache_unlock(me->mc);
              goto __Cont;
            }
#line 1023
            if ((int )ap->state == 2) {
#line 1024
              pthread_testcancel();
            } else {
#line 1023
              if ((int )ap->state == 3) {
#line 1024
                pthread_testcancel();
              }
            }
#line 1026
            while (1) {
#line 1026
              ((*log_debug))(ap->logopt, "%s: send expire to trigger %s", "expire_proc_direct",
                             next->path);
#line 1026
              break;
            }
#line 1028
            pthread_setcancelstate(1, & cur_state);
#line 1029
            ret = expire_direct(ioctlfd, (char const   *)next->path, now, ap->logopt);
#line 1030
            if (! ret) {
#line 1031
              left ++;
            }
#line 1032
            pthread_setcancelstate(cur_state, (int *)((void *)0));
            __Cont: 
#line 928
            p = p->next;
          }
#line 926
          break;
        }
#line 1034
        __pthread_unregister_cancel(& __cancel_buf___0);
#line 1034
        ((*__cancel_routine___0))(__cancel_arg___0);
#line 926
        break;
      }
#line 1036
      ec.status = left;
#line 1038
      pthread_setcancelstate(1, & cur_state);
#line 914
      break;
    }
#line 1039
    __pthread_unregister_cancel(& __cancel_buf);
#line 1039
    ((*__cancel_routine))(__cancel_arg);
#line 914
    break;
  }
#line 1040
  pthread_setcancelstate(cur_state, (int *)((void *)0));
#line 1042
  return ((void *)0);
}
}
#line 1045 "direct.c"
static void pending_cond_destroy___0(void *arg ) 
{ struct pending_args *mt ;
  int status ;

  {
#line 1050
  mt = (struct pending_args *)arg;
#line 1051
  status = pthread_cond_destroy(& mt->cond);
#line 1052
  if (status) {
#line 1053
    while (1) {
#line 1053
      if (status == 35) {
#line 1053
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "pending_cond_destroy", 1053, "direct.c");
#line 1053
        dump_core();
      }
#line 1053
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1053,
                    "direct.c");
#line 1053
      abort();
#line 1053
      break;
    }
  }
#line 1054
  return;
}
}
#line 1056 "direct.c"
static void expire_send_fail___0(void *arg ) 
{ struct pending_args *mt ;

  {
#line 1058
  mt = (struct pending_args *)arg;
#line 1059
  send_fail(mt->ioctlfd, (unsigned int )mt->wait_queue_token);
#line 1060
  return;
}
}
#line 1062 "direct.c"
static void free_pending_args___0(void *arg ) 
{ struct pending_args *mt ;

  {
#line 1064
  mt = (struct pending_args *)arg;
#line 1065
  free((void *)mt);
#line 1066
  return;
}
}
#line 1068 "direct.c"
static void expire_mutex_unlock___0(void *arg ) 
{ int status ;
  int tmp ;

  {
#line 1070
  tmp = pthread_mutex_unlock(& ea_mutex___0);
#line 1070
  status = tmp;
#line 1071
  if (status) {
#line 1072
    while (1) {
#line 1072
      if (status == 35) {
#line 1072
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "expire_mutex_unlock", 1072, "direct.c");
#line 1072
        dump_core();
      }
#line 1072
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1072,
                    "direct.c");
#line 1072
      abort();
#line 1072
      break;
    }
  }
#line 1073
  return;
}
}
#line 1075 "direct.c"
static void *do_expire_direct(void *arg ) 
{ struct pending_args *mt ;
  struct autofs_point *ap ;
  size_t len ;
  int status ;
  int state ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp ;
  long tmp___0 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___0)(void * ) ;
  void *__cancel_arg___0 ;
  int not_first_call___0 ;
  int tmp___1 ;
  long tmp___2 ;
  __pthread_unwind_buf_t __cancel_buf___1 ;
  void (*__cancel_routine___1)(void * ) ;
  void *__cancel_arg___1 ;
  int not_first_call___1 ;
  int tmp___3 ;
  long tmp___4 ;
  struct mapent *me ;

  {
#line 1082
  mt = (struct pending_args *)arg;
#line 1084
  status = pthread_mutex_lock(& ea_mutex___0);
#line 1085
  if (status) {
#line 1086
    while (1) {
#line 1086
      if (status == 35) {
#line 1086
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "do_expire_direct", 1086, "direct.c");
#line 1086
        dump_core();
      }
#line 1086
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1086,
                    "direct.c");
#line 1086
      abort();
#line 1086
      break;
    }
  }
#line 1088
  ap = mt->ap;
#line 1090
  mt->signaled = 1U;
#line 1091
  status = pthread_cond_signal(& mt->cond);
#line 1092
  if (status) {
#line 1093
    while (1) {
#line 1093
      if (status == 35) {
#line 1093
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "do_expire_direct", 1093, "direct.c");
#line 1093
        dump_core();
      }
#line 1093
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1093,
                    "direct.c");
#line 1093
      abort();
#line 1093
      break;
    }
  }
#line 1095
  expire_mutex_unlock___0((void *)0);
#line 1097
  while (1) {
#line 1097
    __cancel_routine = & free_pending_args___0;
#line 1097
    __cancel_arg = (void *)mt;
#line 1097
    tmp = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf), 0);
#line 1097
    not_first_call = tmp;
#line 1097
    tmp___0 = __builtin_expect((long )not_first_call, 0L);
#line 1097
    if (tmp___0) {
#line 1097
      ((*__cancel_routine))(__cancel_arg);
#line 1097
      __pthread_unwind_next(& __cancel_buf);
    }
#line 1097
    __pthread_register_cancel(& __cancel_buf);
#line 1097
    while (1) {
#line 1098
      while (1) {
#line 1098
        __cancel_routine___0 = & pending_cond_destroy___0;
#line 1098
        __cancel_arg___0 = (void *)mt;
#line 1098
        tmp___1 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf),
                              0);
#line 1098
        not_first_call___0 = tmp___1;
#line 1098
        tmp___2 = __builtin_expect((long )not_first_call___0, 0L);
#line 1098
        if (tmp___2) {
#line 1098
          ((*__cancel_routine___0))(__cancel_arg___0);
#line 1098
          __pthread_unwind_next(& __cancel_buf___0);
        }
#line 1098
        __pthread_register_cancel(& __cancel_buf___0);
#line 1098
        while (1) {
#line 1099
          while (1) {
#line 1099
            __cancel_routine___1 = & expire_send_fail___0;
#line 1099
            __cancel_arg___1 = (void *)mt;
#line 1099
            tmp___3 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___1.__cancel_jmp_buf),
                                  0);
#line 1099
            not_first_call___1 = tmp___3;
#line 1099
            tmp___4 = __builtin_expect((long )not_first_call___1, 0L);
#line 1099
            if (tmp___4) {
#line 1099
              ((*__cancel_routine___1))(__cancel_arg___1);
#line 1099
              __pthread_unwind_next(& __cancel_buf___1);
            }
#line 1099
            __pthread_register_cancel(& __cancel_buf___1);
#line 1099
            while (1) {
#line 1101
              len = _strlen((char const   *)(mt->name), 255U);
#line 1102
              if (! len) {
#line 1103
                while (1) {
#line 1103
                  ((*log_warn))(ap->logopt, "%s: direct key path too long %s", "do_expire_direct",
                                mt->name);
#line 1103
                  break;
                }
#line 1105
                pthread_exit((void *)0);
              }
#line 1108
              status = do_expire(ap, (char const   *)(mt->name), (int )len);
#line 1109
              pthread_setcancelstate(1, & state);
#line 1110
              if (status) {
#line 1111
                send_fail(mt->ioctlfd, (unsigned int )mt->wait_queue_token);
              } else {
#line 1114
                cache_readlock(mt->mc);
#line 1115
                me = cache_lookup_distinct(mt->mc, (char const   *)(mt->name));
#line 1116
                me->ioctlfd = -1;
#line 1117
                cache_unlock(mt->mc);
#line 1118
                send_ready(mt->ioctlfd, (unsigned int )mt->wait_queue_token);
#line 1119
                close(mt->ioctlfd);
              }
#line 1121
              pthread_setcancelstate(state, (int *)((void *)0));
#line 1099
              break;
            }
#line 1123
            __pthread_unregister_cancel(& __cancel_buf___1);
#line 1099
            break;
          }
#line 1098
          break;
        }
#line 1124
        __pthread_unregister_cancel(& __cancel_buf___0);
#line 1124
        ((*__cancel_routine___0))(__cancel_arg___0);
#line 1098
        break;
      }
#line 1097
      break;
    }
#line 1125
    __pthread_unregister_cancel(& __cancel_buf);
#line 1125
    ((*__cancel_routine))(__cancel_arg);
#line 1097
    break;
  }
#line 1127
  return ((void *)0);
}
}
#line 1130 "direct.c"
int handle_packet_expire_direct(struct autofs_point *ap , autofs_packet_expire_direct_t *pkt ) 
{ struct map_source *map ;
  struct mapent_cache *mc ;
  struct mapent *me ;
  struct pending_args *mt ;
  char buf[128] ;
  pthread_t thid ;
  int status ;
  int state ;
  char *estr ;
  int *tmp ;
  char *tmp___0 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 1133
  mc = (struct mapent_cache *)((void *)0);
#line 1134
  me = (struct mapent *)((void *)0);
#line 1140
  pthread_setcancelstate(1, & state);
#line 1152
  master_source_readlock(ap->entry);
#line 1153
  map = (ap->entry)->maps;
#line 1154
  while (map) {
#line 1155
    mc = map->mc;
#line 1156
    cache_readlock(mc);
#line 1157
    me = cache_lookup_ino(mc, (unsigned long long )pkt->dev, (unsigned long )pkt->ino);
#line 1158
    if (me) {
#line 1159
      break;
    }
#line 1160
    cache_unlock(mc);
#line 1161
    map = map->next;
  }
#line 1163
  master_source_unlock(ap->entry);
#line 1165
  if (! me) {
#line 1170
    while (1) {
#line 1170
      ((*log_crit))(ap->logopt, "%s: can\'t find map entry for (%lu,%lu)", "handle_packet_expire_direct",
                    (unsigned long )pkt->dev, (unsigned long )pkt->ino);
#line 1170
      break;
    }
#line 1172
    pthread_setcancelstate(state, (int *)((void *)0));
#line 1173
    return (1);
  }
#line 1177
  mt = (struct pending_args *)malloc(sizeof(struct pending_args ));
#line 1178
  if (! mt) {
#line 1179
    tmp = __errno_location();
#line 1179
    tmp___0 = strerror_r((*tmp), buf, 128U);
#line 1179
    estr = tmp___0;
#line 1180
    while (1) {
#line 1180
      ((*log_error))(ap->logopt, "%s: malloc: %s", "handle_packet_expire_direct",
                     estr);
#line 1180
      break;
    }
#line 1181
    send_fail(me->ioctlfd, (unsigned int )pkt->wait_queue_token);
#line 1182
    cache_unlock(mc);
#line 1183
    pthread_setcancelstate(state, (int *)((void *)0));
#line 1184
    return (1);
  }
#line 1187
  status = pthread_cond_init((pthread_cond_t * __restrict  )(& mt->cond), (pthread_condattr_t const   * __restrict  )((void *)0));
#line 1188
  if (status) {
#line 1189
    while (1) {
#line 1189
      if (status == 35) {
#line 1189
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "handle_packet_expire_direct", 1189, "direct.c");
#line 1189
        dump_core();
      }
#line 1189
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1189,
                    "direct.c");
#line 1189
      abort();
#line 1189
      break;
    }
  }
#line 1191
  status = pthread_mutex_lock(& ea_mutex___0);
#line 1192
  if (status) {
#line 1193
    while (1) {
#line 1193
      if (status == 35) {
#line 1193
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "handle_packet_expire_direct", 1193, "direct.c");
#line 1193
        dump_core();
      }
#line 1193
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1193,
                    "direct.c");
#line 1193
      abort();
#line 1193
      break;
    }
  }
#line 1195
  mt->ap = ap;
#line 1196
  mt->ioctlfd = me->ioctlfd;
#line 1197
  mt->mc = mc;
#line 1199
  strcpy((char * __restrict  )(mt->name), (char const   * __restrict  )me->key);
#line 1200
  mt->dev = me->dev;
#line 1201
  mt->type = 2;
#line 1202
  mt->wait_queue_token = pkt->wait_queue_token;
#line 1204
  while (1) {
#line 1204
    ((*log_debug))(ap->logopt, "%s: token %ld, name %s", "handle_packet_expire_direct",
                   pkt->wait_queue_token, mt->name);
#line 1204
    break;
  }
#line 1207
  status = pthread_create((pthread_t * __restrict  )(& thid), (pthread_attr_t const   * __restrict  )(& thread_attr),
                          & do_expire_direct, (void * __restrict  )mt);
#line 1208
  if (status) {
#line 1209
    while (1) {
#line 1209
      ((*log_error))(ap->logopt, "%s: expire thread create failed", "handle_packet_expire_direct");
#line 1209
      break;
    }
#line 1210
    send_fail(mt->ioctlfd, (unsigned int )pkt->wait_queue_token);
#line 1211
    cache_unlock(mc);
#line 1212
    expire_mutex_unlock___0((void *)0);
#line 1213
    pending_cond_destroy___0((void *)mt);
#line 1214
    free_pending_args___0((void *)mt);
#line 1215
    pthread_setcancelstate(state, (int *)((void *)0));
#line 1216
    return (1);
  }
#line 1219
  cache_unlock(mc);
#line 1221
  while (1) {
#line 1221
    __cancel_routine = & expire_mutex_unlock___0;
#line 1221
    __cancel_arg = (void *)0;
#line 1221
    tmp___1 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
#line 1221
    not_first_call = tmp___1;
#line 1221
    tmp___2 = __builtin_expect((long )not_first_call, 0L);
#line 1221
    if (tmp___2) {
#line 1221
      ((*__cancel_routine))(__cancel_arg);
#line 1221
      __pthread_unwind_next(& __cancel_buf);
    }
#line 1221
    __pthread_register_cancel(& __cancel_buf);
#line 1221
    while (1) {
#line 1222
      pthread_setcancelstate(state, (int *)((void *)0));
#line 1224
      mt->signaled = 0U;
#line 1225
      while (! mt->signaled) {
#line 1226
        status = pthread_cond_wait((pthread_cond_t * __restrict  )(& mt->cond), (pthread_mutex_t * __restrict  )(& ea_mutex___0));
#line 1227
        if (status) {
#line 1228
          while (1) {
#line 1228
            if (status == 35) {
#line 1228
              ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                            "handle_packet_expire_direct", 1228, "direct.c");
#line 1228
              dump_core();
            }
#line 1228
            ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status,
                          1228, "direct.c");
#line 1228
            abort();
#line 1228
            break;
          }
        }
      }
#line 1221
      break;
    }
#line 1231
    __pthread_unregister_cancel(& __cancel_buf);
#line 1231
    ((*__cancel_routine))(__cancel_arg);
#line 1221
    break;
  }
#line 1233
  return (0);
}
}
#line 1236 "direct.c"
static void mount_send_fail___0(void *arg ) 
{ struct pending_args *mt ;

  {
#line 1238
  mt = (struct pending_args *)arg;
#line 1239
  send_fail(mt->ioctlfd, (unsigned int )mt->wait_queue_token);
#line 1240
  close(mt->ioctlfd);
#line 1241
  return;
}
}
#line 1243 "direct.c"
static void mount_mutex_unlock___0(void *arg ) 
{ int status ;
  int tmp ;

  {
#line 1245
  tmp = pthread_mutex_unlock(& ma_mutex___0);
#line 1245
  status = tmp;
#line 1246
  if (status) {
#line 1247
    while (1) {
#line 1247
      if (status == 35) {
#line 1247
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "mount_mutex_unlock", 1247, "direct.c");
#line 1247
        dump_core();
      }
#line 1247
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1247,
                    "direct.c");
#line 1247
      abort();
#line 1247
      break;
    }
  }
#line 1248
  return;
}
}
#line 1250 "direct.c"
static void *do_mount_direct(void *arg ) 
{ struct pending_args *mt ;
  struct autofs_point *ap ;
  struct passwd pw ;
  struct passwd *ppw ;
  struct passwd **pppw ;
  struct group gr ;
  struct group *pgr ;
  struct group **ppgr ;
  char *pw_tmp ;
  char *gr_tmp ;
  struct thread_stdenv_vars *tsv ;
  int tmplen ;
  struct stat st ;
  int status ;
  int state ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp ;
  long tmp___0 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___0)(void * ) ;
  void *__cancel_arg___0 ;
  int not_first_call___0 ;
  int tmp___1 ;
  long tmp___2 ;
  __pthread_unwind_buf_t __cancel_buf___1 ;
  void (*__cancel_routine___1)(void * ) ;
  void *__cancel_arg___1 ;
  int not_first_call___1 ;
  int tmp___3 ;
  long tmp___4 ;
  char *tmp___14 ;
  char *tmp___24 ;
  char *tmp___34 ;
  size_t tmp___35 ;
  struct mapent *me ;
  int real_mount ;
  int set_fd ;
  int tmp___36 ;

  {
#line 1255
  ppw = & pw;
#line 1256
  pppw = & ppw;
#line 1258
  pgr = & gr;
#line 1259
  ppgr = & pgr;
#line 1266
  mt = (struct pending_args *)arg;
#line 1268
  status = pthread_mutex_lock(& ma_mutex___0);
#line 1269
  if (status) {
#line 1270
    while (1) {
#line 1270
      if (status == 35) {
#line 1270
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "do_mount_direct", 1270, "direct.c");
#line 1270
        dump_core();
      }
#line 1270
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1270,
                    "direct.c");
#line 1270
      abort();
#line 1270
      break;
    }
  }
#line 1272
  ap = mt->ap;
#line 1274
  mt->signaled = 1U;
#line 1275
  status = pthread_cond_signal(& mt->cond);
#line 1276
  if (status) {
#line 1277
    while (1) {
#line 1277
      if (status == 35) {
#line 1277
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "do_mount_direct", 1277, "direct.c");
#line 1277
        dump_core();
      }
#line 1277
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1277,
                    "direct.c");
#line 1277
      abort();
#line 1277
      break;
    }
  }
#line 1279
  mount_mutex_unlock___0((void *)0);
#line 1281
  while (1) {
#line 1281
    __cancel_routine = & free_pending_args___0;
#line 1281
    __cancel_arg = (void *)mt;
#line 1281
    tmp = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf), 0);
#line 1281
    not_first_call = tmp;
#line 1281
    tmp___0 = __builtin_expect((long )not_first_call, 0L);
#line 1281
    if (tmp___0) {
#line 1281
      ((*__cancel_routine))(__cancel_arg);
#line 1281
      __pthread_unwind_next(& __cancel_buf);
    }
#line 1281
    __pthread_register_cancel(& __cancel_buf);
#line 1281
    while (1) {
#line 1282
      while (1) {
#line 1282
        __cancel_routine___0 = & pending_cond_destroy___0;
#line 1282
        __cancel_arg___0 = (void *)mt;
#line 1282
        tmp___1 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf),
                              0);
#line 1282
        not_first_call___0 = tmp___1;
#line 1282
        tmp___2 = __builtin_expect((long )not_first_call___0, 0L);
#line 1282
        if (tmp___2) {
#line 1282
          ((*__cancel_routine___0))(__cancel_arg___0);
#line 1282
          __pthread_unwind_next(& __cancel_buf___0);
        }
#line 1282
        __pthread_register_cancel(& __cancel_buf___0);
#line 1282
        while (1) {
#line 1283
          while (1) {
#line 1283
            __cancel_routine___1 = & mount_send_fail___0;
#line 1283
            __cancel_arg___1 = (void *)mt;
#line 1283
            tmp___3 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___1.__cancel_jmp_buf),
                                  0);
#line 1283
            not_first_call___1 = tmp___3;
#line 1283
            tmp___4 = __builtin_expect((long )not_first_call___1, 0L);
#line 1283
            if (tmp___4) {
#line 1283
              ((*__cancel_routine___1))(__cancel_arg___1);
#line 1283
              __pthread_unwind_next(& __cancel_buf___1);
            }
#line 1283
            __pthread_register_cancel(& __cancel_buf___1);
#line 1283
            while (1) {
#line 1285
              pthread_setcancelstate(1, & state);
#line 1287
              status = fstat__extinline(mt->ioctlfd, & st);
#line 1288
              if (status == -1) {
#line 1289
                while (1) {
#line 1289
                  ((*log_error))(ap->logopt, "%s: can\'t stat direct mount trigger %s",
                                 "do_mount_direct", mt->name);
#line 1289
                  break;
                }
#line 1291
                pthread_setcancelstate(state, (int *)((void *)0));
#line 1292
                pthread_exit((void *)0);
              }
#line 1295
              status = stat__extinline((char const   *)(mt->name), & st);
#line 1296
              if (! ((st.st_mode & 61440U) == 16384U)) {
                goto _L;
              } else {
#line 1296
                if (st.st_dev != mt->dev) {
                  _L: 
#line 1297
                  while (1) {
#line 1297
                    ((*log_error))(ap->logopt, "%s: direct trigger not valid or already mounted %s",
                                   "do_mount_direct", mt->name);
#line 1297
                    break;
                  }
#line 1300
                  pthread_setcancelstate(state, (int *)((void *)0));
#line 1301
                  pthread_exit((void *)0);
                }
              }
#line 1304
              pthread_setcancelstate(state, (int *)((void *)0));
#line 1306
              while (1) {
#line 1306
                ((*log_info))(0U, "attempting to mount entry %s", mt->name);
#line 1306
                break;
              }
#line 1314
              tsv = (struct thread_stdenv_vars *)malloc(sizeof(struct thread_stdenv_vars ));
#line 1315
              if (! tsv) {
                goto cont;
              }
#line 1318
              tsv->uid = mt->uid;
#line 1319
              tsv->gid = mt->gid;
#line 1323
              tmplen = (int )sysconf(70);
#line 1324
              if (tmplen < 0) {
#line 1325
                while (1) {
#line 1325
                  ((*log_error))(ap->logopt, "%s: failed to get buffer size for getpwuid_r",
                                 "do_mount_direct");
#line 1325
                  break;
                }
#line 1326
                free((void *)tsv);
                goto cont;
              }
#line 1330
              pw_tmp = (char *)malloc((unsigned int )(tmplen + 1));
#line 1331
              if (! pw_tmp) {
#line 1332
                while (1) {
#line 1332
                  ((*log_error))(ap->logopt, "%s: failed to malloc buffer for getpwuid_r",
                                 "do_mount_direct");
#line 1332
                  break;
                }
#line 1333
                free((void *)tsv);
                goto cont;
              }
#line 1337
              status = getpwuid_r(mt->uid, (struct passwd * __restrict  )ppw, (char * __restrict  )pw_tmp,
                                  (unsigned int )tmplen, (struct passwd ** __restrict  )pppw);
#line 1338
              if (status) {
                goto _L___0;
              } else {
#line 1338
                if (! ppw) {
                  _L___0: 
#line 1339
                  while (1) {
#line 1339
                    ((*log_error))(ap->logopt, "%s: failed to get passwd info from getpwuid_r",
                                   "do_mount_direct");
#line 1339
                    break;
                  }
#line 1340
                  free((void *)tsv);
#line 1341
                  free((void *)pw_tmp);
                  goto cont;
                }
              }
#line 1345
              tmp___14 = __strdup((char const   *)pw.pw_name);
#line 1345
              tsv->user = tmp___14;
#line 1346
              if (! tsv->user) {
#line 1347
                while (1) {
#line 1347
                  ((*log_error))(ap->logopt, "%s: failed to malloc buffer for user",
                                 "do_mount_direct");
#line 1347
                  break;
                }
#line 1348
                free((void *)tsv);
#line 1349
                free((void *)pw_tmp);
                goto cont;
              }
#line 1353
              tmp___24 = __strdup((char const   *)pw.pw_dir);
#line 1353
              tsv->home = tmp___24;
#line 1354
              if (! tsv->user) {
#line 1355
                while (1) {
#line 1355
                  ((*log_error))(ap->logopt, "%s: failed to malloc buffer for home",
                                 "do_mount_direct");
#line 1355
                  break;
                }
#line 1356
                free((void *)pw_tmp);
#line 1357
                free((void *)tsv->user);
#line 1358
                free((void *)tsv);
                goto cont;
              }
#line 1362
              free((void *)pw_tmp);
#line 1366
              tmplen = (int )sysconf(69);
#line 1367
              if (tmplen < 0) {
#line 1368
                while (1) {
#line 1368
                  ((*log_error))(ap->logopt, "%s: failed to get buffer size for getgrgid_r",
                                 "do_mount_direct");
#line 1368
                  break;
                }
#line 1369
                free((void *)tsv->user);
#line 1370
                free((void *)tsv->home);
#line 1371
                free((void *)tsv);
                goto cont;
              }
#line 1375
              gr_tmp = (char *)malloc((unsigned int )(tmplen + 1));
#line 1376
              if (! gr_tmp) {
#line 1377
                while (1) {
#line 1377
                  ((*log_error))(ap->logopt, "%s: failed to malloc buffer for getgrgid_r",
                                 "do_mount_direct");
#line 1377
                  break;
                }
#line 1378
                free((void *)tsv->user);
#line 1379
                free((void *)tsv->home);
#line 1380
                free((void *)tsv);
                goto cont;
              }
#line 1384
              status = getgrgid_r(mt->gid, (struct group * __restrict  )pgr, (char * __restrict  )gr_tmp,
                                  (unsigned int )tmplen, (struct group ** __restrict  )ppgr);
#line 1385
              if (status) {
                goto _L___1;
              } else {
#line 1385
                if (! pgr) {
                  _L___1: 
#line 1386
                  while (1) {
#line 1386
                    ((*log_error))(ap->logopt, "%s: failed to get group info from getgrgid_r",
                                   "do_mount_direct");
#line 1386
                    break;
                  }
#line 1387
                  free((void *)tsv->user);
#line 1388
                  free((void *)tsv->home);
#line 1389
                  free((void *)tsv);
#line 1390
                  free((void *)gr_tmp);
                  goto cont;
                }
              }
#line 1394
              tmp___34 = __strdup((char const   *)gr.gr_name);
#line 1394
              tsv->group = tmp___34;
#line 1395
              if (! tsv->group) {
#line 1396
                while (1) {
#line 1396
                  ((*log_error))(ap->logopt, "%s: failed to malloc buffer for group",
                                 "do_mount_direct");
#line 1396
                  break;
                }
#line 1397
                free((void *)tsv->user);
#line 1398
                free((void *)tsv->home);
#line 1399
                free((void *)tsv);
#line 1400
                free((void *)gr_tmp);
                goto cont;
              }
#line 1404
              free((void *)gr_tmp);
#line 1406
              status = pthread_setspecific(key_thread_stdenv_vars, (void const   *)tsv);
#line 1407
              if (status) {
#line 1408
                while (1) {
#line 1408
                  ((*log_error))(ap->logopt, "%s: failed to set stdenv thread var",
                                 "do_mount_direct");
#line 1408
                  break;
                }
#line 1409
                free((void *)tsv->group);
#line 1410
                free((void *)tsv->user);
#line 1411
                free((void *)tsv->home);
#line 1412
                free((void *)tsv);
              }
              cont: 
#line 1416
              tmp___35 = strlen((char const   *)(mt->name));
#line 1416
              status = lookup_nss_mount(ap, (struct map_source *)((void *)0), (char const   *)(mt->name),
                                        (int )tmp___35);
#line 1421
              pthread_setcancelstate(1, & state);
#line 1422
              if (status) {
#line 1425
                cache_readlock(mt->mc);
#line 1426
                me = cache_lookup_distinct(mt->mc, (char const   *)(mt->name));
#line 1427
                real_mount = is_mounted("/etc/mtab", (char const   *)me->key, 2U);
#line 1428
                if (real_mount) {
#line 1428
                  tmp___36 = 1;
                } else {
#line 1428
                  if ((unsigned int )me->multi == (unsigned int )me) {
#line 1428
                    tmp___36 = 1;
                  } else {
#line 1428
                    tmp___36 = 0;
                  }
                }
#line 1428
                set_fd = tmp___36;
#line 1429
                cache_unlock(mt->mc);
#line 1430
                if (set_fd) {
#line 1431
                  me->ioctlfd = mt->ioctlfd;
#line 1432
                  send_ready(mt->ioctlfd, (unsigned int )mt->wait_queue_token);
                } else {
#line 1434
                  send_ready(mt->ioctlfd, (unsigned int )mt->wait_queue_token);
#line 1435
                  close(mt->ioctlfd);
                }
#line 1437
                while (1) {
#line 1437
                  ((*log_info))(0U, "mounted %s", mt->name);
#line 1437
                  break;
                }
              } else {
#line 1439
                send_fail(mt->ioctlfd, (unsigned int )mt->wait_queue_token);
#line 1440
                close(mt->ioctlfd);
#line 1441
                while (1) {
#line 1441
                  ((*log_info))(0U, "failed to mount %s", mt->name);
#line 1441
                  break;
                }
              }
#line 1443
              pthread_setcancelstate(state, (int *)((void *)0));
#line 1283
              break;
            }
#line 1445
            __pthread_unregister_cancel(& __cancel_buf___1);
#line 1283
            break;
          }
#line 1282
          break;
        }
#line 1446
        __pthread_unregister_cancel(& __cancel_buf___0);
#line 1446
        ((*__cancel_routine___0))(__cancel_arg___0);
#line 1282
        break;
      }
#line 1281
      break;
    }
#line 1447
    __pthread_unregister_cancel(& __cancel_buf);
#line 1447
    ((*__cancel_routine))(__cancel_arg);
#line 1281
    break;
  }
#line 1449
  return ((void *)0);
}
}
#line 1452 "direct.c"
int handle_packet_missing_direct(struct autofs_point *ap , autofs_packet_missing_direct_t *pkt ) 
{ struct map_source *map ;
  struct mapent_cache *mc ;
  struct mapent *me ;
  pthread_t thid ;
  struct pending_args *mt ;
  char buf[128] ;
  int status ;
  int ioctlfd ;
  int cl_flags ;
  int state ;
  char *estr ;
  int *tmp ;
  char *tmp___0 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 1455
  mc = (struct mapent_cache *)((void *)0);
#line 1456
  me = (struct mapent *)((void *)0);
#line 1460
  status = 0;
#line 1463
  pthread_setcancelstate(1, & state);
#line 1465
  master_source_readlock(ap->entry);
#line 1466
  map = (ap->entry)->maps;
#line 1467
  while (map) {
#line 1472
    if ((ap->entry)->age > map->age) {
#line 1473
      map = map->next;
#line 1474
      continue;
    }
#line 1477
    mc = map->mc;
#line 1478
    cache_readlock(mc);
#line 1479
    me = cache_lookup_ino(mc, (unsigned long long )pkt->dev, (unsigned long )pkt->ino);
#line 1480
    if (me) {
#line 1481
      break;
    }
#line 1482
    cache_unlock(mc);
#line 1483
    map = map->next;
  }
#line 1485
  master_source_unlock(ap->entry);
#line 1487
  if (! me) {
#line 1492
    while (1) {
#line 1492
      ((*log_crit))(ap->logopt, "%s: can\'t find map entry for (%lu,%lu)", "handle_packet_missing_direct",
                    (unsigned long )pkt->dev, (unsigned long )pkt->ino);
#line 1492
      break;
    }
#line 1494
    pthread_setcancelstate(state, (int *)((void *)0));
#line 1495
    return (1);
  }
#line 1498
  if (me->ioctlfd != -1) {
#line 1500
    ioctlfd = me->ioctlfd;
#line 1501
    me->ioctlfd = -1;
  } else {
#line 1503
    ioctlfd = open((char const   *)me->key, 0);
  }
#line 1505
  if (ioctlfd == -1) {
#line 1506
    cache_unlock(mc);
#line 1507
    pthread_setcancelstate(state, (int *)((void *)0));
#line 1508
    while (1) {
#line 1508
      ((*log_crit))(ap->logopt, "%s: failed to create ioctl fd for %s", "handle_packet_missing_direct",
                    me->key);
#line 1508
      break;
    }
#line 1510
    return (1);
  }
#line 1513
  cl_flags = fcntl(ioctlfd, 1, 0);
#line 1513
  if (cl_flags != -1) {
#line 1514
    cl_flags |= 1;
#line 1515
    fcntl(ioctlfd, 2, cl_flags);
  }
#line 1518
  while (1) {
#line 1518
    ((*log_debug))(ap->logopt, "%s: token %ld, name %s, request pid %u", "handle_packet_missing_direct",
                   pkt->wait_queue_token, me->key, pkt->pid);
#line 1518
    break;
  }
#line 1522
  if ((int )ap->state == 5) {
#line 1525
    send_fail(ioctlfd, (unsigned int )pkt->wait_queue_token);
#line 1526
    close(ioctlfd);
#line 1527
    cache_unlock(mc);
#line 1528
    pthread_setcancelstate(state, (int *)((void *)0));
#line 1529
    return (1);
  } else {
#line 1522
    if ((int )ap->state == 6) {
#line 1525
      send_fail(ioctlfd, (unsigned int )pkt->wait_queue_token);
#line 1526
      close(ioctlfd);
#line 1527
      cache_unlock(mc);
#line 1528
      pthread_setcancelstate(state, (int *)((void *)0));
#line 1529
      return (1);
    } else {
#line 1522
      if ((int )ap->state == 7) {
#line 1525
        send_fail(ioctlfd, (unsigned int )pkt->wait_queue_token);
#line 1526
        close(ioctlfd);
#line 1527
        cache_unlock(mc);
#line 1528
        pthread_setcancelstate(state, (int *)((void *)0));
#line 1529
        return (1);
      }
    }
  }
#line 1532
  mt = (struct pending_args *)malloc(sizeof(struct pending_args ));
#line 1533
  if (! mt) {
#line 1534
    tmp = __errno_location();
#line 1534
    tmp___0 = strerror_r((*tmp), buf, 128U);
#line 1534
    estr = tmp___0;
#line 1535
    while (1) {
#line 1535
      ((*log_error))(ap->logopt, "%s: malloc: %s", "handle_packet_missing_direct",
                     estr);
#line 1535
      break;
    }
#line 1536
    send_fail(ioctlfd, (unsigned int )pkt->wait_queue_token);
#line 1537
    close(ioctlfd);
#line 1538
    cache_unlock(mc);
#line 1539
    pthread_setcancelstate(state, (int *)((void *)0));
#line 1540
    return (1);
  }
#line 1542
  memset((void *)mt, 0, sizeof(struct pending_args ));
#line 1544
  status = pthread_cond_init((pthread_cond_t * __restrict  )(& mt->cond), (pthread_condattr_t const   * __restrict  )((void *)0));
#line 1545
  if (status) {
#line 1546
    while (1) {
#line 1546
      if (status == 35) {
#line 1546
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "handle_packet_missing_direct", 1546, "direct.c");
#line 1546
        dump_core();
      }
#line 1546
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1546,
                    "direct.c");
#line 1546
      abort();
#line 1546
      break;
    }
  }
#line 1548
  status = pthread_mutex_lock(& ma_mutex___0);
#line 1549
  if (status) {
#line 1550
    while (1) {
#line 1550
      if (status == 35) {
#line 1550
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "handle_packet_missing_direct", 1550, "direct.c");
#line 1550
        dump_core();
      }
#line 1550
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1550,
                    "direct.c");
#line 1550
      abort();
#line 1550
      break;
    }
  }
#line 1552
  mt->ap = ap;
#line 1553
  mt->ioctlfd = ioctlfd;
#line 1554
  mt->mc = mc;
#line 1555
  strcpy((char * __restrict  )(mt->name), (char const   * __restrict  )me->key);
#line 1556
  mt->dev = me->dev;
#line 1557
  mt->type = 1;
#line 1558
  mt->uid = pkt->uid;
#line 1559
  mt->gid = pkt->gid;
#line 1560
  mt->wait_queue_token = pkt->wait_queue_token;
#line 1562
  status = pthread_create((pthread_t * __restrict  )(& thid), (pthread_attr_t const   * __restrict  )(& thread_attr),
                          & do_mount_direct, (void * __restrict  )mt);
#line 1563
  if (status) {
#line 1564
    while (1) {
#line 1564
      ((*log_error))(ap->logopt, "%s: missing mount thread create failed", "handle_packet_missing_direct");
#line 1564
      break;
    }
#line 1565
    send_fail(ioctlfd, (unsigned int )pkt->wait_queue_token);
#line 1566
    close(ioctlfd);
#line 1567
    cache_unlock(mc);
#line 1568
    mount_mutex_unlock___0((void *)0);
#line 1569
    pending_cond_destroy___0((void *)mt);
#line 1570
    free_pending_args___0((void *)mt);
#line 1571
    pthread_setcancelstate(state, (int *)((void *)0));
#line 1572
    return (1);
  }
#line 1575
  cache_unlock(mc);
#line 1576
  while (1) {
#line 1576
    __cancel_routine = & mount_mutex_unlock___0;
#line 1576
    __cancel_arg = (void *)0;
#line 1576
    tmp___1 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
#line 1576
    not_first_call = tmp___1;
#line 1576
    tmp___2 = __builtin_expect((long )not_first_call, 0L);
#line 1576
    if (tmp___2) {
#line 1576
      ((*__cancel_routine))(__cancel_arg);
#line 1576
      __pthread_unwind_next(& __cancel_buf);
    }
#line 1576
    __pthread_register_cancel(& __cancel_buf);
#line 1576
    while (1) {
#line 1577
      pthread_setcancelstate(state, (int *)((void *)0));
#line 1579
      mt->signaled = 0U;
#line 1580
      while (! mt->signaled) {
#line 1581
        status = pthread_cond_wait((pthread_cond_t * __restrict  )(& mt->cond), (pthread_mutex_t * __restrict  )(& ma_mutex___0));
#line 1582
        if (status) {
#line 1583
          while (1) {
#line 1583
            if (status == 35) {
#line 1583
              ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                            "handle_packet_missing_direct", 1583, "direct.c");
#line 1583
              dump_core();
            }
#line 1583
            ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status,
                          1583, "direct.c");
#line 1583
            abort();
#line 1583
            break;
          }
        }
      }
#line 1576
      break;
    }
#line 1586
    __pthread_unregister_cancel(& __cancel_buf);
#line 1586
    ((*__cancel_routine))(__cancel_arg);
#line 1576
    break;
  }
#line 1588
  return (0);
}
}
#line 1 "spawn.o"
#pragma merger(0,"/tmp/cil-kdUas04X.i","-O2,-Wall,-fPIE")
#line 129 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int raise(int __sig ) ;
#line 216
extern  __attribute__((__nothrow__)) int sigemptyset(sigset_t *__set )  __attribute__((__nonnull__(1))) ;
#line 222
extern  __attribute__((__nothrow__)) int sigaddset(sigset_t *__set , int __signo )  __attribute__((__nonnull__(1))) ;
#line 260
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
#line 31 "/usr/include/bits/sigthread.h"
extern  __attribute__((__nothrow__)) int pthread_sigmask(int __how , __sigset_t const   * __restrict  __newmask ,
                                                         __sigset_t * __restrict  __oldmask ) ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 66
extern  __attribute__((__nothrow__)) void *memchr(void const   *__s , int __c , size_t __n )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 258 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int access(char const   *__name , int __type )  __attribute__((__nonnull__(1))) ;
#line 493
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 516
extern  __attribute__((__nothrow__)) int execv(char const   *__path , char * const  *__argv )  __attribute__((__nonnull__(1))) ;
#line 548
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 600
extern  __attribute__((__nothrow__)) int setpgid(__pid_t __pid , __pid_t __pgid ) ;
#line 617
extern  __attribute__((__nothrow__)) int setpgrp(void) ;
#line 677
extern  __attribute__((__nothrow__)) int seteuid(__uid_t __uid ) ;
#line 694
extern  __attribute__((__nothrow__)) int setegid(__gid_t __gid ) ;
#line 139 "/usr/include/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 202 "../include/automount.h"
int spawnl(logger *log , char const   *prog  , ...) ;
#line 203
int spawnv(logger *log , char const   *prog , char const   * const  *argv ) ;
#line 204
int spawn_mount(logger *log  , ...) ;
#line 205
int spawn_bind_mount(logger *log  , ...) ;
#line 207
void reset_signals(void) ;
#line 31 "spawn.c"
static union __anonunion_pthread_mutex_t_6 spawn_mutex  =    {{0, 0U, 0, 0, 0U, {0}}};
#line 39 "spawn.c"
void dump_core(void) 
{ sigset_t segv ;

  {
#line 43
  sigemptyset(& segv);
#line 44
  sigaddset(& segv, 11);
#line 45
  pthread_sigmask(1, (__sigset_t const   * __restrict  )(& segv), (__sigset_t * __restrict  )((void *)0));
#line 46
  sigprocmask(1, (sigset_t const   * __restrict  )(& segv), (sigset_t * __restrict  )((void *)0));
#line 48
  raise(11);
#line 49
  return;
}
}
#line 55 "spawn.c"
void reset_signals(void) 
{ struct sigaction sa ;
  sigset_t allsignals ;
  int i ;

  {
#line 61
  sigfillset(& allsignals);
#line 62
  sigprocmask(0, (sigset_t const   * __restrict  )(& allsignals), (sigset_t * __restrict  )((void *)0));
#line 65
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 66
  sigemptyset(& sa.sa_mask);
#line 67
  sa.sa_flags = 0;
#line 69
  i = 1;
#line 69
  while (i < 65) {
#line 70
    if (i != 9) {
#line 70
      if (i != 19) {
#line 71
        sigaction(i, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
      }
    }
#line 69
    i ++;
  }
#line 73
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))0;
#line 75
  i = 1;
#line 75
  while (i < 65) {
#line 76
    if (i != 9) {
#line 76
      if (i != 19) {
#line 77
        sigaction(i, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
      }
    }
#line 75
    i ++;
  }
#line 81
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 82
  sa.sa_flags = 268435456;
#line 83
  sigaction(10, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
#line 84
  sigaction(12, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
#line 86
  sigprocmask(1, (sigset_t const   * __restrict  )(& allsignals), (sigset_t * __restrict  )((void *)0));
#line 87
  return;
}
}
#line 91 "spawn.c"
static int do_spawn(logger *log , unsigned int options , char const   *prog , char const   * const  *argv ) 
{ pid_t f ;
  int ret ;
  int status ;
  int pipefd[2] ;
  char errbuf[2048] ;
  char *p ;
  char *sp ;
  int errp ;
  int errn ;
  int cancel_state ;
  unsigned int use_lock ;
  unsigned int use_access ;
  sigset_t allsigs ;
  sigset_t tmpsig ;
  sigset_t oldsig ;
  struct thread_stdenv_vars *tsv ;
  pid_t euid ;
  gid_t egid ;
  int tmp ;
  char **pargv ;
  int argc ;
  pid_t pgrp ;
  pid_t tmp___0 ;
  char **tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  __pid_t tmp___6 ;

  {
#line 98
  use_lock = options & 1U;
#line 99
  use_access = options & 2U;
#line 102
  euid = 0;
#line 103
  egid = 0U;
#line 105
  tmp = pipe(pipefd);
#line 105
  if (tmp) {
#line 106
    return (-1);
  }
#line 108
  pthread_setcancelstate(1, & cancel_state);
#line 110
  sigfillset(& allsigs);
#line 111
  pthread_sigmask(0, (__sigset_t const   * __restrict  )(& allsigs), (__sigset_t * __restrict  )(& oldsig));
#line 113
  if (use_lock) {
#line 114
    status = pthread_mutex_lock(& spawn_mutex);
#line 115
    if (status) {
#line 116
      while (1) {
#line 116
        if (status == 35) {
#line 116
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "do_spawn", 116, "spawn.c");
#line 116
          dump_core();
        }
#line 116
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 116,
                      "spawn.c");
#line 116
        abort();
#line 116
        break;
      }
    }
  }
#line 119
  tsv = (struct thread_stdenv_vars *)pthread_getspecific(key_thread_stdenv_vars);
#line 120
  if (tsv) {
#line 121
    euid = (int )tsv->uid;
#line 122
    egid = tsv->gid;
  }
#line 125
  f = fork();
#line 126
  if (f == 0) {
#line 127
    reset_signals();
#line 128
    close(pipefd[0]);
#line 129
    dup2(pipefd[1], 1);
#line 130
    dup2(pipefd[1], 2);
#line 131
    close(pipefd[1]);
#line 134
    if (use_access) {
#line 135
      pargv = (char **)argv;
#line 136
      argc = 0;
#line 137
      tmp___0 = getpgrp();
#line 137
      pgrp = tmp___0;
#line 140
      while (1) {
#line 140
        tmp___1 = pargv;
#line 140
        pargv ++;
#line 140
        if (! (*tmp___1)) {
#line 140
          break;
        }
#line 141
        argc ++;
      }
#line 142
      argc -= 2;
#line 148
      if (euid) {
#line 149
        seteuid((unsigned int )euid);
#line 150
        setegid(egid);
      }
#line 152
      setpgrp();
#line 155
      tmp___3 = access((char const   *)(*(argv + argc)), 0);
#line 155
      if (tmp___3 == -1) {
#line 156
        tmp___2 = __errno_location();
#line 156
        _exit((*tmp___2));
      }
#line 158
      seteuid(0U);
#line 159
      setegid(0U);
#line 160
      setpgid(0, pgrp);
    }
#line 163
    execv(prog, (char * const  *)argv);
#line 164
    _exit(255);
  } else {
#line 166
    tmpsig = oldsig;
#line 168
    sigaddset(& tmpsig, 17);
#line 169
    pthread_sigmask(2, (__sigset_t const   * __restrict  )(& tmpsig), (__sigset_t * __restrict  )((void *)0));
#line 171
    close(pipefd[1]);
#line 173
    if (f < 0) {
#line 174
      close(pipefd[0]);
#line 175
      if (use_lock) {
#line 176
        status = pthread_mutex_unlock(& spawn_mutex);
#line 177
        if (status) {
#line 178
          while (1) {
#line 178
            if (status == 35) {
#line 178
              ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                            "do_spawn", 178, "spawn.c");
#line 178
              dump_core();
            }
#line 178
            ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status,
                          178, "spawn.c");
#line 178
            abort();
#line 178
            break;
          }
        }
      }
#line 180
      pthread_sigmask(2, (__sigset_t const   * __restrict  )(& oldsig), (__sigset_t * __restrict  )((void *)0));
#line 181
      pthread_setcancelstate(cancel_state, (int *)((void *)0));
#line 182
      return (-1);
    }
#line 185
    errp = 0;
#line 186
    while (1) {
#line 187
      while (1) {
#line 187
        errn = read(pipefd[0], (void *)(errbuf + errp), (unsigned int )(2047 - errp));
#line 187
        if (errn == -1) {
#line 187
          tmp___4 = __errno_location();
#line 187
          if (! ((*tmp___4) == 4)) {
#line 187
            break;
          }
        } else {
#line 187
          break;
        }
      }
#line 191
      if (errn > 0) {
#line 192
        errp += errn;
#line 194
        sp = errbuf;
#line 195
        while (1) {
#line 195
          if (errp) {
#line 195
            p = (char *)memchr((void const   *)sp, '\n', (unsigned int )errp);
#line 195
            if (! p) {
#line 195
              break;
            }
          } else {
#line 195
            break;
          }
#line 196
          tmp___5 = p;
#line 196
          p ++;
#line 196
          (*tmp___5) = (char )'\000';
#line 197
          if ((*(sp + 0))) {
#line 198
            ((*log))(3U, ">> %s", sp);
          }
#line 199
          errp -= p - sp;
#line 200
          sp = p;
        }
#line 203
        if (errp) {
#line 203
          if ((unsigned int )sp != (unsigned int )(errbuf)) {
#line 204
            memmove((void *)(errbuf), (void const   *)sp, (unsigned int )errp);
          }
        }
#line 206
        if (errp >= 2047) {
#line 208
          errbuf[errp] = (char )'\000';
#line 209
          ((*log))(3U, ">> %s", errbuf);
#line 210
          errp = 0;
        }
      }
#line 186
      if (! (errn > 0)) {
#line 186
        break;
      }
    }
#line 215
    close(pipefd[0]);
#line 217
    if (errp > 0) {
#line 219
      errbuf[errp] = (char )'\000';
#line 220
      ((*log))(3U, ">> %s", errbuf);
    }
#line 223
    tmp___6 = waitpid(f, & ret, 0);
#line 223
    if (tmp___6 != f) {
#line 224
      ret = -1;
    }
#line 226
    if (use_lock) {
#line 227
      status = pthread_mutex_unlock(& spawn_mutex);
#line 228
      if (status) {
#line 229
        while (1) {
#line 229
          if (status == 35) {
#line 229
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "do_spawn", 229, "spawn.c");
#line 229
            dump_core();
          }
#line 229
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 229,
                        "spawn.c");
#line 229
          abort();
#line 229
          break;
        }
      }
    }
#line 231
    pthread_sigmask(2, (__sigset_t const   * __restrict  )(& oldsig), (__sigset_t * __restrict  )((void *)0));
#line 232
    pthread_setcancelstate(cancel_state, (int *)((void *)0));
#line 234
    return (ret);
  }
}
}
#line 238 "spawn.c"
int spawnv(logger *log , char const   *prog , char const   * const  *argv ) 
{ int tmp ;

  {
#line 240
  tmp = do_spawn(log, 0U, prog, argv);
#line 240
  return (tmp);
}
}
#line 243 "spawn.c"
int spawnl(logger *log , char const   *prog  , ...) 
{ va_list arg ;
  int argc ;
  char **argv ;
  char **p ;
  char *tmp ;
  char **tmp___0 ;
  int tmp___1 ;

  {
#line 249
  __builtin_va_start(arg, prog);
#line 250
  argc = 1;
#line 250
  while (1) {
#line 250
    tmp = __builtin_va_arg(arg, char *);
#line 250
    if (! tmp) {
#line 250
      break;
    }
#line 250
    argc ++;
  }
#line 251
  __builtin_va_end(arg);
#line 253
  argv = (char **)__builtin_alloca(sizeof(char *) * (unsigned int )argc);
#line 253
  if (! argv) {
#line 254
    return (-1);
  }
#line 256
  __builtin_va_start(arg, prog);
#line 257
  p = argv;
#line 258
  while (1) {
#line 258
    tmp___0 = p;
#line 258
    p ++;
#line 258
    (*tmp___0) = __builtin_va_arg(arg, char *);
#line 258
    if (! (*tmp___0)) {
#line 258
      break;
    }
  }
#line 259
  __builtin_va_end(arg);
#line 261
  tmp___1 = do_spawn(log, 0U, prog, (char const   * const  *)((char const   **)argv));
#line 261
  return (tmp___1);
}
}
#line 264 "spawn.c"
int spawn_mount(logger *log  , ...) 
{ va_list arg ;
  int argc ;
  char **argv ;
  char **p ;
  char prog[11] ;
  char arg0[11] ;
  unsigned int options ;
  unsigned int retries ;
  int ret ;
  char *tmp ;
  char **tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 269
  prog[0] = (char )'/';
#line 269
  prog[1] = (char )'b';
#line 269
  prog[2] = (char )'i';
#line 269
  prog[3] = (char )'n';
#line 269
  prog[4] = (char )'/';
#line 269
  prog[5] = (char )'m';
#line 269
  prog[6] = (char )'o';
#line 269
  prog[7] = (char )'u';
#line 269
  prog[8] = (char )'n';
#line 269
  prog[9] = (char )'t';
#line 269
  prog[10] = (char )'\000';
#line 270
  arg0[0] = (char )'/';
#line 270
  arg0[1] = (char )'b';
#line 270
  arg0[2] = (char )'i';
#line 270
  arg0[3] = (char )'n';
#line 270
  arg0[4] = (char )'/';
#line 270
  arg0[5] = (char )'m';
#line 270
  arg0[6] = (char )'o';
#line 270
  arg0[7] = (char )'u';
#line 270
  arg0[8] = (char )'n';
#line 270
  arg0[9] = (char )'t';
#line 270
  arg0[10] = (char )'\000';
#line 272
  retries = 3U;
#line 277
  options = 1U;
#line 282
  __builtin_va_start(arg, log);
#line 283
  argc = 1;
#line 283
  while (1) {
#line 283
    tmp = __builtin_va_arg(arg, char *);
#line 283
    if (! tmp) {
#line 283
      break;
    }
#line 283
    argc ++;
  }
#line 284
  __builtin_va_end(arg);
#line 286
  argv = (char **)__builtin_alloca(sizeof(char *) * (unsigned int )argc + 1U);
#line 286
  if (! argv) {
#line 287
    return (-1);
  }
#line 289
  (*(argv + 0)) = arg0;
#line 291
  __builtin_va_start(arg, log);
#line 292
  p = argv + 1;
#line 293
  while (1) {
#line 293
    tmp___0 = p;
#line 293
    p ++;
#line 293
    (*tmp___0) = __builtin_va_arg(arg, char *);
#line 293
    if (! (*tmp___0)) {
#line 293
      break;
    }
  }
#line 294
  __builtin_va_end(arg);
#line 296
  while (1) {
#line 296
    tmp___1 = retries;
#line 296
    retries --;
#line 296
    if (! tmp___1) {
#line 296
      break;
    }
#line 297
    ret = do_spawn(log, options, (char const   *)(prog), (char const   * const  *)((char const   **)argv));
#line 298
    if (ret & 4096) {
#line 299
      continue;
    }
#line 300
    break;
  }
#line 303
  return (ret);
}
}
#line 314 "spawn.c"
int spawn_bind_mount(logger *log  , ...) 
{ va_list arg ;
  int argc ;
  char **argv ;
  char **p ;
  char prog[11] ;
  char arg0[11] ;
  char bind___0[7] ;
  unsigned int options ;
  unsigned int retries ;
  int ret ;
  char *tmp ;
  char **tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 319
  prog[0] = (char )'/';
#line 319
  prog[1] = (char )'b';
#line 319
  prog[2] = (char )'i';
#line 319
  prog[3] = (char )'n';
#line 319
  prog[4] = (char )'/';
#line 319
  prog[5] = (char )'m';
#line 319
  prog[6] = (char )'o';
#line 319
  prog[7] = (char )'u';
#line 319
  prog[8] = (char )'n';
#line 319
  prog[9] = (char )'t';
#line 319
  prog[10] = (char )'\000';
#line 320
  arg0[0] = (char )'/';
#line 320
  arg0[1] = (char )'b';
#line 320
  arg0[2] = (char )'i';
#line 320
  arg0[3] = (char )'n';
#line 320
  arg0[4] = (char )'/';
#line 320
  arg0[5] = (char )'m';
#line 320
  arg0[6] = (char )'o';
#line 320
  arg0[7] = (char )'u';
#line 320
  arg0[8] = (char )'n';
#line 320
  arg0[9] = (char )'t';
#line 320
  arg0[10] = (char )'\000';
#line 321
  bind___0[0] = (char )'-';
#line 321
  bind___0[1] = (char )'-';
#line 321
  bind___0[2] = (char )'b';
#line 321
  bind___0[3] = (char )'i';
#line 321
  bind___0[4] = (char )'n';
#line 321
  bind___0[5] = (char )'d';
#line 321
  bind___0[6] = (char )'\000';
#line 323
  retries = 3U;
#line 328
  options = 1U;
#line 333
  __builtin_va_start(arg, log);
#line 334
  argc = 1;
#line 334
  while (1) {
#line 334
    tmp = __builtin_va_arg(arg, char *);
#line 334
    if (! tmp) {
#line 334
      break;
    }
#line 334
    argc ++;
  }
#line 335
  __builtin_va_end(arg);
#line 337
  argv = (char **)__builtin_alloca(sizeof(char *) * (unsigned int )argc + 2U);
#line 337
  if (! argv) {
#line 338
    return (-1);
  }
#line 340
  (*(argv + 0)) = arg0;
#line 341
  (*(argv + 1)) = bind___0;
#line 343
  __builtin_va_start(arg, log);
#line 344
  p = argv + 2;
#line 345
  while (1) {
#line 345
    tmp___0 = p;
#line 345
    p ++;
#line 345
    (*tmp___0) = __builtin_va_arg(arg, char *);
#line 345
    if (! (*tmp___0)) {
#line 345
      break;
    }
  }
#line 346
  __builtin_va_end(arg);
#line 348
  while (1) {
#line 348
    tmp___1 = retries;
#line 348
    retries --;
#line 348
    if (! tmp___1) {
#line 348
      break;
    }
#line 349
    ret = do_spawn(log, options, (char const   *)(prog), (char const   * const  *)((char const   **)argv));
#line 350
    if (ret & 4096) {
#line 351
      continue;
    }
#line 352
    break;
  }
#line 355
  return (ret);
}
}
#line 358 "spawn.c"
int spawn_umount(logger *log  , ...) 
{ va_list arg ;
  int argc ;
  char **argv ;
  char **p ;
  char prog[12] ;
  char arg0[12] ;
  unsigned int options ;
  unsigned int retries ;
  int ret ;
  char *tmp ;
  char **tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 363
  prog[0] = (char )'/';
#line 363
  prog[1] = (char )'b';
#line 363
  prog[2] = (char )'i';
#line 363
  prog[3] = (char )'n';
#line 363
  prog[4] = (char )'/';
#line 363
  prog[5] = (char )'u';
#line 363
  prog[6] = (char )'m';
#line 363
  prog[7] = (char )'o';
#line 363
  prog[8] = (char )'u';
#line 363
  prog[9] = (char )'n';
#line 363
  prog[10] = (char )'t';
#line 363
  prog[11] = (char )'\000';
#line 364
  arg0[0] = (char )'/';
#line 364
  arg0[1] = (char )'b';
#line 364
  arg0[2] = (char )'i';
#line 364
  arg0[3] = (char )'n';
#line 364
  arg0[4] = (char )'/';
#line 364
  arg0[5] = (char )'u';
#line 364
  arg0[6] = (char )'m';
#line 364
  arg0[7] = (char )'o';
#line 364
  arg0[8] = (char )'u';
#line 364
  arg0[9] = (char )'n';
#line 364
  arg0[10] = (char )'t';
#line 364
  arg0[11] = (char )'\000';
#line 366
  retries = 3U;
#line 370
  options = 1U;
#line 375
  __builtin_va_start(arg, log);
#line 376
  argc = 1;
#line 376
  while (1) {
#line 376
    tmp = __builtin_va_arg(arg, char *);
#line 376
    if (! tmp) {
#line 376
      break;
    }
#line 376
    argc ++;
  }
#line 377
  __builtin_va_end(arg);
#line 379
  argv = (char **)__builtin_alloca(sizeof(char *) * (unsigned int )argc + 1U);
#line 379
  if (! argv) {
#line 380
    return (-1);
  }
#line 382
  (*(argv + 0)) = arg0;
#line 384
  __builtin_va_start(arg, log);
#line 385
  p = argv + 1;
#line 386
  while (1) {
#line 386
    tmp___0 = p;
#line 386
    p ++;
#line 386
    (*tmp___0) = __builtin_va_arg(arg, char *);
#line 386
    if (! (*tmp___0)) {
#line 386
      break;
    }
  }
#line 387
  __builtin_va_end(arg);
#line 389
  while (1) {
#line 389
    tmp___1 = retries;
#line 389
    retries --;
#line 389
    if (! tmp___1) {
#line 389
      break;
    }
#line 390
    ret = do_spawn(log, options, (char const   *)(prog), (char const   * const  *)((char const   **)argv));
#line 391
    if (ret & 4096) {
#line 392
      continue;
    }
#line 393
    break;
  }
#line 396
  return (ret);
}
}
#line 1 "module.o"
#pragma merger(0,"/tmp/cil-enPVUdB3.i","-O2,-Wall,-fPIE")
#line 536 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 58 "/usr/include/dlfcn.h"
extern  __attribute__((__nothrow__)) void *dlopen(char const   *__file , int __mode ) ;
#line 62
extern  __attribute__((__nothrow__)) int dlclose(void *__handle )  __attribute__((__nonnull__(1))) ;
#line 66
extern  __attribute__((__nothrow__)) void *dlsym(void * __restrict  __handle , char const   * __restrict  __name )  __attribute__((__nonnull__(2))) ;
#line 84
extern  __attribute__((__nothrow__)) char *dlerror(void) ;
#line 57 "../include/automount.h"
int load_autofs4_module(void) ;
#line 259
struct lookup_mod *open_lookup(char const   *name , char const   *err_prefix , char const   *mapfmt ,
                               int argc , char const   * const  *argv ) ;
#line 261
int close_lookup(struct lookup_mod *mod ) ;
#line 285
struct parse_mod *open_parse(char const   *name , char const   *err_prefix , int argc ,
                             char const   * const  *argv ) ;
#line 287
int close_parse(struct parse_mod *mod ) ;
#line 312
struct mount_mod *open_mount(char const   *name , char const   *err_prefix ) ;
#line 313
int close_mount(struct mount_mod *mod ) ;
#line 21 "module.c"
int load_autofs4_module(void) 
{ FILE *fp ;
  char buf[4096] ;
  int ret ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 34
  fp = fopen((char const   * __restrict  )"/proc/filesystems", (char const   * __restrict  )"r");
#line 35
  if (! fp) {
#line 36
    while (1) {
#line 36
      ((*log_error))(3U, "%s: cannot open /proc/filesystems\n", "load_autofs4_module");
#line 36
      break;
    }
#line 37
    return (0);
  }
#line 40
  while (1) {
#line 40
    tmp___0 = fgets((char * __restrict  )(buf), 4095, (FILE * __restrict  )fp);
#line 40
    if (! tmp___0) {
#line 40
      break;
    }
#line 41
    tmp = strstr((char const   *)(buf), "autofs");
#line 41
    if (tmp) {
#line 42
      fclose(fp);
#line 43
      return (1);
    }
  }
#line 46
  fclose(fp);
#line 48
  ret = spawnl(log_debug, "/sbin/modprobe", "/sbin/modprobe", "-q", "autofs4", (void *)0);
#line 50
  if (ret) {
#line 51
    return (0);
  }
#line 53
  return (1);
}
}
#line 56 "module.c"
struct lookup_mod *open_lookup(char const   *name , char const   *err_prefix , char const   *mapfmt ,
                               int argc , char const   * const  *argv ) 
{ struct lookup_mod *mod ;
  char buf[128] ;
  char *fnbuf ;
  size_t size_name ;
  size_t size_fnbuf ;
  void *dh ;
  int *ver ;
  char *estr ;
  int *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *estr___0 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___11 ;

  {
#line 67
  size_name = _strlen(name, 4097U);
#line 68
  if (! size_name) {
#line 69
    return ((struct lookup_mod *)((void *)0));
  }
#line 71
  mod = (struct lookup_mod *)malloc(sizeof(struct lookup_mod ));
#line 72
  if (! mod) {
#line 73
    if (err_prefix) {
#line 74
      tmp = __errno_location();
#line 74
      tmp___0 = strerror_r((*tmp), buf, 128U);
#line 74
      estr = tmp___0;
#line 75
      while (1) {
#line 75
        ((*log_crit))(3U, "%s: %s%s", "open_lookup", err_prefix, estr);
#line 75
        break;
      }
    }
#line 77
    return ((struct lookup_mod *)((void *)0));
  }
#line 80
  tmp___1 = strlen("/usr/lib/autofs");
#line 80
  size_fnbuf = (size_name + tmp___1) + 13U;
#line 81
  fnbuf = (char *)__builtin_alloca(size_fnbuf);
#line 82
  if (! fnbuf) {
#line 83
    free((void *)mod);
#line 84
    if (err_prefix) {
#line 85
      tmp___2 = __errno_location();
#line 85
      tmp___3 = strerror_r((*tmp___2), buf, 128U);
#line 85
      estr___0 = tmp___3;
#line 86
      while (1) {
#line 86
        ((*log_crit))(3U, "%s: %s%s", "open_lookup", err_prefix, estr___0);
#line 86
        break;
      }
    }
#line 88
    return ((struct lookup_mod *)((void *)0));
  }
#line 90
  snprintf((char * __restrict  )fnbuf, size_fnbuf, (char const   * __restrict  )"%s/lookup_%s.so",
           "/usr/lib/autofs", name);
#line 92
  dh = dlopen((char const   *)fnbuf, 2);
#line 92
  if (! dh) {
#line 93
    if (err_prefix) {
#line 94
      while (1) {
#line 94
        tmp___4 = dlerror();
#line 94
        ((*log_crit))(3U, "%s: %scannot open lookup module %s (%s)", "open_lookup",
                      err_prefix, name, tmp___4);
#line 94
        break;
      }
    }
#line 96
    free((void *)mod);
#line 97
    return ((struct lookup_mod *)((void *)0));
  }
#line 100
  ver = (int *)dlsym((void * __restrict  )dh, (char const   * __restrict  )"lookup_version");
#line 100
  if (ver) {
#line 100
    if ((*ver) != 5) {
      _L: 
#line 102
      if (err_prefix) {
#line 103
        while (1) {
#line 103
          ((*log_crit))(3U, "%s: %slookup module %s version mismatch", "open_lookup",
                        err_prefix, name);
#line 103
          break;
        }
      }
#line 106
      dlclose(dh);
#line 107
      free((void *)mod);
#line 108
      return ((struct lookup_mod *)((void *)0));
    }
  } else {
    goto _L;
  }
#line 111
  mod->lookup_init = (int (*)(char const   * , int  , char const   * const  * , void ** ))dlsym((void * __restrict  )dh,
                                                                                                (char const   * __restrict  )"lookup_init");
#line 111
  if (mod->lookup_init) {
#line 111
    mod->lookup_read_master = (int (*)(struct master *master , time_t  , void * ))dlsym((void * __restrict  )dh,
                                                                                        (char const   * __restrict  )"lookup_read_master");
#line 111
    if (mod->lookup_read_master) {
#line 111
      mod->lookup_read_map = (int (*)(struct autofs_point * , time_t  , void * ))dlsym((void * __restrict  )dh,
                                                                                       (char const   * __restrict  )"lookup_read_map");
#line 111
      if (mod->lookup_read_map) {
#line 111
        mod->lookup_mount = (int (*)(struct autofs_point * , char const   * , int  ,
                                     void * ))dlsym((void * __restrict  )dh, (char const   * __restrict  )"lookup_mount");
#line 111
        if (mod->lookup_mount) {
#line 111
          mod->lookup_done = (int (*)(void * ))dlsym((void * __restrict  )dh, (char const   * __restrict  )"lookup_done");
#line 111
          if (! mod->lookup_done) {
            _L___0: 
#line 116
            if (err_prefix) {
#line 117
              while (1) {
#line 117
                ((*log_crit))(3U, "%s: %slookup module %s corrupt", "open_lookup",
                              err_prefix, name);
#line 117
                break;
              }
            }
#line 118
            dlclose(dh);
#line 119
            free((void *)mod);
#line 120
            return ((struct lookup_mod *)((void *)0));
          }
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    goto _L___0;
  }
#line 123
  tmp___11 = ((*(mod->lookup_init)))(mapfmt, argc, argv, & mod->context);
#line 123
  if (tmp___11) {
#line 124
    dlclose(dh);
#line 125
    free((void *)mod);
#line 126
    return ((struct lookup_mod *)((void *)0));
  }
#line 128
  mod->dlhandle = dh;
#line 129
  return (mod);
}
}
#line 132 "module.c"
int close_lookup(struct lookup_mod *mod ) 
{ int rv ;
  int tmp ;

  {
#line 134
  tmp = ((*(mod->lookup_done)))(mod->context);
#line 134
  rv = tmp;
#line 135
  dlclose(mod->dlhandle);
#line 136
  free((void *)mod);
#line 137
  return (rv);
}
}
#line 140 "module.c"
struct parse_mod *open_parse(char const   *name , char const   *err_prefix , int argc ,
                             char const   * const  *argv ) 
{ struct parse_mod *mod ;
  char buf[128] ;
  char *fnbuf ;
  size_t size_name ;
  size_t size_fnbuf ;
  void *dh ;
  int *ver ;
  char *estr ;
  int *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *estr___0 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___9 ;

  {
#line 151
  size_name = _strlen(name, 4097U);
#line 152
  if (! size_name) {
#line 153
    return ((struct parse_mod *)((void *)0));
  }
#line 155
  mod = (struct parse_mod *)malloc(sizeof(struct parse_mod ));
#line 156
  if (! mod) {
#line 157
    if (err_prefix) {
#line 158
      tmp = __errno_location();
#line 158
      tmp___0 = strerror_r((*tmp), buf, 128U);
#line 158
      estr = tmp___0;
#line 159
      while (1) {
#line 159
        ((*log_crit))(3U, "%s: %s%s", "open_parse", err_prefix, estr);
#line 159
        break;
      }
    }
#line 161
    return ((struct parse_mod *)((void *)0));
  }
#line 164
  tmp___1 = strlen("/usr/lib/autofs");
#line 164
  size_fnbuf = (size_name + tmp___1) + 13U;
#line 165
  fnbuf = (char *)__builtin_alloca(size_fnbuf);
#line 166
  if (! fnbuf) {
#line 167
    free((void *)mod);
#line 168
    if (err_prefix) {
#line 169
      tmp___2 = __errno_location();
#line 169
      tmp___3 = strerror_r((*tmp___2), buf, 128U);
#line 169
      estr___0 = tmp___3;
#line 170
      while (1) {
#line 170
        ((*log_crit))(3U, "%s: %s%s", "open_parse", err_prefix, estr___0);
#line 170
        break;
      }
    }
#line 172
    return ((struct parse_mod *)((void *)0));
  }
#line 174
  snprintf((char * __restrict  )fnbuf, size_fnbuf, (char const   * __restrict  )"%s/parse_%s.so",
           "/usr/lib/autofs", name);
#line 176
  dh = dlopen((char const   *)fnbuf, 2);
#line 176
  if (! dh) {
#line 177
    if (err_prefix) {
#line 178
      while (1) {
#line 178
        tmp___4 = dlerror();
#line 178
        ((*log_crit))(3U, "%s: %scannot open parse module %s (%s)", "open_parse",
                      err_prefix, name, tmp___4);
#line 178
        break;
      }
    }
#line 181
    free((void *)mod);
#line 182
    return ((struct parse_mod *)((void *)0));
  }
#line 185
  ver = (int *)dlsym((void * __restrict  )dh, (char const   * __restrict  )"parse_version");
#line 185
  if (ver) {
#line 185
    if ((*ver) != 5) {
      _L: 
#line 187
      if (err_prefix) {
#line 188
        while (1) {
#line 188
          ((*log_crit))(3U, "%s: %sparse module %s version mismatch", "open_parse",
                        err_prefix, name);
#line 188
          break;
        }
      }
#line 191
      dlclose(dh);
#line 192
      free((void *)mod);
#line 193
      return ((struct parse_mod *)((void *)0));
    }
  } else {
    goto _L;
  }
#line 196
  mod->parse_init = (int (*)(int  , char const   * const  * , void ** ))dlsym((void * __restrict  )dh,
                                                                              (char const   * __restrict  )"parse_init");
#line 196
  if (mod->parse_init) {
#line 196
    mod->parse_mount = (int (*)(struct autofs_point * , char const   * , int  , char const   * ,
                                void * ))dlsym((void * __restrict  )dh, (char const   * __restrict  )"parse_mount");
#line 196
    if (mod->parse_mount) {
#line 196
      mod->parse_done = (int (*)(void * ))dlsym((void * __restrict  )dh, (char const   * __restrict  )"parse_done");
#line 196
      if (! mod->parse_done) {
        _L___0: 
#line 199
        if (err_prefix) {
#line 200
          while (1) {
#line 200
            ((*log_crit))(3U, "%s: %sparse module %s corrupt", "open_parse", err_prefix,
                          name);
#line 200
            break;
          }
        }
#line 203
        dlclose(dh);
#line 204
        free((void *)mod);
#line 205
        return ((struct parse_mod *)((void *)0));
      }
    } else {
      goto _L___0;
    }
  } else {
    goto _L___0;
  }
#line 208
  tmp___9 = ((*(mod->parse_init)))(argc, argv, & mod->context);
#line 208
  if (tmp___9) {
#line 209
    dlclose(dh);
#line 210
    free((void *)mod);
#line 211
    return ((struct parse_mod *)((void *)0));
  }
#line 213
  mod->dlhandle = dh;
#line 214
  return (mod);
}
}
#line 217 "module.c"
int close_parse(struct parse_mod *mod ) 
{ int rv ;
  int tmp ;

  {
#line 219
  tmp = ((*(mod->parse_done)))(mod->context);
#line 219
  rv = tmp;
#line 220
  dlclose(mod->dlhandle);
#line 221
  free((void *)mod);
#line 222
  return (rv);
}
}
#line 225 "module.c"
struct mount_mod *open_mount(char const   *name , char const   *err_prefix ) 
{ struct mount_mod *mod ;
  char buf[128] ;
  char *fnbuf ;
  size_t size_name ;
  size_t size_fnbuf ;
  void *dh ;
  int *ver ;
  char *estr ;
  int *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *estr___0 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___9 ;

  {
#line 235
  size_name = _strlen(name, 4097U);
#line 236
  if (! size_name) {
#line 237
    return ((struct mount_mod *)((void *)0));
  }
#line 239
  mod = (struct mount_mod *)malloc(sizeof(struct mount_mod ));
#line 240
  if (! mod) {
#line 241
    if (err_prefix) {
#line 242
      tmp = __errno_location();
#line 242
      tmp___0 = strerror_r((*tmp), buf, 128U);
#line 242
      estr = tmp___0;
#line 243
      while (1) {
#line 243
        ((*log_crit))(3U, "%s: %s%s", "open_mount", err_prefix, estr);
#line 243
        break;
      }
    }
#line 245
    return ((struct mount_mod *)((void *)0));
  }
#line 248
  tmp___1 = strlen("/usr/lib/autofs");
#line 248
  size_fnbuf = (size_name + tmp___1) + 13U;
#line 249
  fnbuf = (char *)__builtin_alloca(size_fnbuf);
#line 250
  if (! fnbuf) {
#line 251
    free((void *)mod);
#line 252
    if (err_prefix) {
#line 253
      tmp___2 = __errno_location();
#line 253
      tmp___3 = strerror_r((*tmp___2), buf, 128U);
#line 253
      estr___0 = tmp___3;
#line 254
      while (1) {
#line 254
        ((*log_crit))(3U, "%s: %s%s", "open_mount", err_prefix, estr___0);
#line 254
        break;
      }
    }
#line 256
    return ((struct mount_mod *)((void *)0));
  }
#line 258
  snprintf((char * __restrict  )fnbuf, size_fnbuf, (char const   * __restrict  )"%s/mount_%s.so",
           "/usr/lib/autofs", name);
#line 260
  dh = dlopen((char const   *)fnbuf, 2);
#line 260
  if (! dh) {
#line 261
    if (err_prefix) {
#line 262
      while (1) {
#line 262
        tmp___4 = dlerror();
#line 262
        ((*log_crit))(3U, "%s: %scannot open mount module %s (%s)", "open_mount",
                      err_prefix, name, tmp___4);
#line 262
        break;
      }
    }
#line 265
    free((void *)mod);
#line 266
    return ((struct mount_mod *)((void *)0));
  }
#line 269
  ver = (int *)dlsym((void * __restrict  )dh, (char const   * __restrict  )"mount_version");
#line 269
  if (ver) {
#line 269
    if ((*ver) != 4) {
      _L: 
#line 271
      if (err_prefix) {
#line 272
        while (1) {
#line 272
          ((*log_crit))(3U, "%s: %smount module %s version mismatch", "open_mount",
                        err_prefix, name);
#line 272
          break;
        }
      }
#line 275
      dlclose(dh);
#line 276
      free((void *)mod);
#line 277
      return ((struct mount_mod *)((void *)0));
    }
  } else {
    goto _L;
  }
#line 280
  mod->mount_init = (int (*)(void ** ))dlsym((void * __restrict  )dh, (char const   * __restrict  )"mount_init");
#line 280
  if (mod->mount_init) {
#line 280
    mod->mount_mount = (int (*)(struct autofs_point * , char const   * , char const   * ,
                                int  , char const   * , char const   * , char const   * ,
                                void * ))dlsym((void * __restrict  )dh, (char const   * __restrict  )"mount_mount");
#line 280
    if (mod->mount_mount) {
#line 280
      mod->mount_done = (int (*)(void * ))dlsym((void * __restrict  )dh, (char const   * __restrict  )"mount_done");
#line 280
      if (! mod->mount_done) {
        _L___0: 
#line 283
        if (err_prefix) {
#line 284
          while (1) {
#line 284
            ((*log_crit))(3U, "%s: %smount module %s corrupt", "open_mount", err_prefix,
                          name);
#line 284
            break;
          }
        }
#line 287
        dlclose(dh);
#line 288
        free((void *)mod);
#line 289
        return ((struct mount_mod *)((void *)0));
      }
    } else {
      goto _L___0;
    }
  } else {
    goto _L___0;
  }
#line 292
  tmp___9 = ((*(mod->mount_init)))(& mod->context);
#line 292
  if (tmp___9) {
#line 293
    dlclose(dh);
#line 294
    free((void *)mod);
#line 295
    return ((struct mount_mod *)((void *)0));
  }
#line 297
  mod->dlhandle = dh;
#line 298
  return (mod);
}
}
#line 301 "module.c"
int close_mount(struct mount_mod *mod ) 
{ int rv ;
  int tmp ;

  {
#line 303
  tmp = ((*(mod->mount_done)))(mod->context);
#line 303
  rv = tmp;
#line 304
  dlclose(mod->dlhandle);
#line 305
  free((void *)mod);
#line 306
  return (rv);
}
}
#line 1 "mount.o"
#pragma merger(0,"/tmp/cil-r86XTcFO.i","-O2,-Wall,-fPIE")
#line 208 "../include/automount.h"
int do_mount(struct autofs_point *ap , char const   *root , char const   *name , int name_len ,
             char const   *what , char const   *fstype , char const   *options ) ;
#line 29 "mount.c"
static char *not_generic[7]  = {      (char *)"nfs",      (char *)"userfs",      (char *)"afs",      (char *)"autofs", 
        (char *)"changer",      (char *)"bind",      (char *)((void *)0)};
#line 33 "mount.c"
int do_mount(struct autofs_point *ap , char const   *root , char const   *name , int name_len ,
             char const   *what , char const   *fstype , char const   *options ) 
{ struct mount_mod *mod ;
  char const   *modstr ;
  char **ngp ;
  int rv ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 41
  modstr = fstype;
#line 41
  mod = open_mount(modstr, "(mount):");
#line 42
  if (! mod) {
#line 43
    ngp = not_generic;
#line 43
    while ((*ngp)) {
#line 44
      if (0) {
#line 44
        __s1_len = strlen(fstype);
#line 44
        __s2_len = strlen((char const   *)(*ngp));
#line 44
        if (! ((unsigned int )((void const   *)(fstype + 1)) - (unsigned int )((void const   *)fstype) == 1U)) {
          goto _L___0;
        } else {
#line 44
          if (__s1_len >= 4U) {
            _L___0: 
#line 44
            if (! ((unsigned int )((void const   *)((*ngp) + 1)) - (unsigned int )((void const   *)(*ngp)) == 1U)) {
#line 44
              tmp___8 = 1;
            } else {
#line 44
              if (__s2_len >= 4U) {
#line 44
                tmp___8 = 1;
              } else {
#line 44
                tmp___8 = 0;
              }
            }
          } else {
#line 44
            tmp___8 = 0;
          }
        }
#line 44
        if (tmp___8) {
#line 44
          tmp___4 = __builtin_strcmp(fstype, (char const   *)(*ngp));
        } else {
#line 44
          tmp___7 = __builtin_strcmp(fstype, (char const   *)(*ngp));
#line 44
          tmp___4 = tmp___7;
        }
      } else {
#line 44
        tmp___7 = __builtin_strcmp(fstype, (char const   *)(*ngp));
#line 44
        tmp___4 = tmp___7;
      }
#line 44
      if (! tmp___4) {
#line 45
        break;
      }
#line 43
      ngp ++;
    }
#line 47
    if (! (*ngp)) {
#line 48
      modstr = "generic";
#line 48
      mod = open_mount(modstr, "(mount):");
    }
#line 49
    if (! mod) {
#line 50
      while (1) {
#line 50
        ((*log_error))(ap->logopt, "%s: cannot find mount method for filesystem %s",
                       "do_mount", fstype);
#line 50
        break;
      }
#line 53
      return (-1);
    }
  }
#line 57
  if (ap->type == 4U) {
#line 58
    while (1) {
#line 58
      ((*log_debug))(ap->logopt, "%s: %s %s type %s options %s using module %s", "do_mount",
                     what, name, fstype, options, modstr);
#line 58
      break;
    }
  } else {
#line 62
    while (1) {
#line 62
      ((*log_debug))(ap->logopt, "%s: %s %s/%s type %s options %s using module %s",
                     "do_mount", what, root, name, fstype, options, modstr);
#line 62
      break;
    }
  }
#line 66
  rv = ((*(mod->mount_mount)))(ap, root, name, name_len, what, fstype, options, mod->context);
#line 67
  close_mount(mod);
#line 69
  return (rv);
}
}
#line 1 "lookup.o"
#pragma merger(0,"/tmp/cil-jfSX7yip.i","-O2,-Wall,-fPIE")
#line 102 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 331
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 107 "../include/list.h"
__inline static int list_empty(struct list_head *head ) 
{ 

  {
#line 109
  return ((unsigned int )head->next == (unsigned int )head);
}
}
#line 85 "../include/master.h"
struct map_source *master_find_source_instance(struct map_source *source , char const   *type___1 ,
                                               char const   *format___1 , int argc ,
                                               char const   **argv ) ;
#line 87
struct map_source *master_add_source_instance(struct map_source *source , char const   *type___1 ,
                                              char const   *format___1 , time_t age ,
                                              int argc , char const   **argv ) ;
#line 89
void send_map_update_request(struct autofs_point *ap ) ;
#line 94
void master_source_current_wait(struct master_mapent *entry ) ;
#line 164 "../include/automount.h"
void cache_writelock(struct mapent_cache *mc ) ;
#line 175
struct mapent *cache_lookup(struct mapent_cache *mc , char const   *key ) ;
#line 195
char const   **copy_argv(int argc , char const   **argv ) ;
#line 197
int free_argv(int argc , char const   **argv ) ;
#line 224
int lookup_nss_read_master(struct master *master , time_t age ) ;
#line 232
struct mapent *lookup_source_valid_mapent(struct autofs_point *ap , char const   *key ,
                                          unsigned int type___0 ) ;
#line 60 "../include/nsswitch.h"
int free_sources(struct list_head *list ) ;
#line 62
int nsswitch_parse(struct list_head *list ) ;
#line 29 "lookup.c"
static int check_nss_result(struct nss_source *this , enum nsswitch_status result ) 
{ enum nsswitch_status status ;
  struct nss_action a ;

  {
#line 35
  status = (enum nsswitch_status )0;
#line 35
  while ((int )status < 4) {
#line 36
    a = this->action[status];
#line 37
    if ((int )a.action == 0) {
      goto __Cont;
    }
#line 40
    if (a.negated) {
#line 40
      if ((int )result != (int )status) {
#line 41
        if ((int )a.action == 2) {
#line 42
          if ((int )result == 0) {
#line 43
            return (1);
          } else {
#line 45
            return (0);
          }
        }
      }
    }
    __Cont: 
#line 35
    status = (enum nsswitch_status )((int )status + 1);
  }
#line 50
  a = this->action[result];
#line 53
  switch ((int )result) {
  case 0: 
#line 55
  if ((int )a.action == 1) {
#line 56
    break;
  }
#line 57
  return (1);
  case 1: 
  case 2: 
  case 3: 
#line 62
  if ((int )a.action == 2) {
#line 63
    return (0);
  }
#line 65
  break;
  default: ;
#line 68
  break;
  }
#line 71
  return (-1);
}
}
#line 74 "lookup.c"
static void nsslist_cleanup(void *arg ) 
{ struct list_head *nsslist ;
  int tmp ;

  {
#line 76
  nsslist = (struct list_head *)arg;
#line 77
  tmp = list_empty(nsslist);
#line 77
  if (! tmp) {
#line 78
    free_sources(nsslist);
  }
#line 79
  return;
}
}
#line 82 "lookup.c"
static int do_read_master___0(struct master *master , char *type___0 , time_t age ) 
{ struct lookup_mod *lookup ;
  char const   *argv[2] ;
  int argc ;
  int status ;

  {
#line 89
  argc = 1;
#line 90
  argv[0] = (char const   *)master->name;
#line 91
  argv[1] = (char const   *)((void *)0);
#line 93
  lookup = open_lookup((char const   *)type___0, "", (char const   *)((void *)0),
                       argc, (char const   * const  *)(argv));
#line 94
  if (! lookup) {
#line 95
    return (2);
  }
#line 97
  status = ((*(lookup->lookup_read_master)))(master, age, lookup->context);
#line 99
  close_lookup(lookup);
#line 101
  return (status);
}
}
#line 104 "lookup.c"
static int read_master_map(struct master *master , char *type___0 , time_t age ) 
{ char *path___0 ;
  char *save_name ;
  int result ;
  int tmp ;
  int tmp___0 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
#line 109
  tmp___0 = strcasecmp((char const   *)type___0, "files");
#line 109
  if (tmp___0) {
#line 110
    tmp = do_read_master___0(master, type___0, age);
#line 110
    return (tmp);
  }
#line 119
  tmp___2 = __builtin_strchr(master->name, (char )'/');
#line 119
  if (tmp___2) {
#line 120
    while (1) {
#line 120
      ((*log_error))(3U, "%s: relative path invalid in files map name", "read_master_map");
#line 120
      break;
    }
#line 121
    return (1);
  }
#line 124
  tmp___3 = strlen("/etc");
#line 124
  tmp___4 = strlen((char const   *)master->name);
#line 124
  path___0 = (char *)malloc((tmp___3 + tmp___4) + 2U);
#line 125
  if (! path___0) {
#line 126
    return (-1);
  }
#line 128
  strcpy((char * __restrict  )path___0, (char const   * __restrict  )"/etc");
#line 129
  strcat((char * __restrict  )path___0, (char const   * __restrict  )"/");
#line 130
  strcat((char * __restrict  )path___0, (char const   * __restrict  )master->name);
#line 132
  save_name = master->name;
#line 133
  master->name = path___0;
#line 135
  result = do_read_master___0(master, type___0, age);
#line 137
  master->name = save_name;
#line 138
  free((void *)path___0);
#line 140
  return (result);
}
}
#line 143 "lookup.c"
int lookup_nss_read_master(struct master *master , time_t age ) 
{ struct list_head nsslist ;
  struct list_head *head ;
  struct list_head *p ;
  int result ;
  char *name ;
  char *tmp ;
  char *tmp___1 ;
  char source[10] ;
  int tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___41 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___47 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___67 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___73 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___93 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___99 ;
  int tmp___102 ;
  int tmp___103 ;
  int tmp___119 ;
  size_t __s1_len___8 ;
  size_t __s2_len___8 ;
  int tmp___125 ;
  int tmp___128 ;
  int tmp___129 ;
  int tmp___145 ;
  size_t __s1_len___10 ;
  size_t __s2_len___10 ;
  int tmp___151 ;
  int tmp___154 ;
  int tmp___155 ;
  int tmp___171 ;
  size_t __s1_len___12 ;
  size_t __s2_len___12 ;
  int tmp___177 ;
  int tmp___180 ;
  int tmp___181 ;
  int tmp___184 ;
  struct nss_source *this ;
  int status ;
  int tmp___185 ;

  {
#line 147
  result = -1;
#line 150
  if ((int )(*(master->name)) == 47) {
#line 151
    if ((int )(*(master->name + 1)) == 47) {
#line 152
      while (1) {
#line 152
        ((*log_debug))(0U, "%s: reading master ldap %s", "lookup_nss_read_master",
                       master->name);
#line 152
        break;
      }
#line 154
      result = do_read_master___0(master, (char *)"ldap", age);
    } else {
#line 156
      while (1) {
#line 156
        ((*log_debug))(0U, "%s: reading master file %s", "lookup_nss_read_master",
                       master->name);
#line 156
        break;
      }
#line 158
      result = do_read_master___0(master, (char *)"file", age);
    }
#line 161
    return (! result);
  } else {
#line 163
    name = master->name;
#line 167
    tmp___1 = __builtin_strchr(name, (char )':');
#line 167
    tmp = tmp___1;
#line 168
    if (tmp) {
#line 171
      memset((void *)(source), 0, 10U);
#line 172
      if (0) {
#line 172
        if (0) {
#line 172
          __s1_len___2 = strlen((char const   *)name);
#line 172
          __s2_len___2 = strlen("file:");
#line 172
          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
            goto _L___6;
          } else {
#line 172
            if (__s1_len___2 >= 4U) {
              _L___6: 
#line 172
              if (! ((unsigned int )((void const   *)("file:" + 1)) - (unsigned int )((void const   *)"file:") == 1U)) {
#line 172
                tmp___51 = 1;
              } else {
#line 172
                if (__s2_len___2 >= 4U) {
#line 172
                  tmp___51 = 1;
                } else {
#line 172
                  tmp___51 = 0;
                }
              }
            } else {
#line 172
              tmp___51 = 0;
            }
          }
#line 172
          if (tmp___51) {
#line 172
            tmp___47 = __builtin_strcmp((char const   *)name, "file:");
          } else {
#line 172
            tmp___50 = __builtin_strcmp((char const   *)name, "file:");
#line 172
            tmp___47 = tmp___50;
          }
        } else {
#line 172
          tmp___50 = __builtin_strcmp((char const   *)name, "file:");
#line 172
          tmp___47 = tmp___50;
        }
#line 172
        tmp___41 = tmp___47;
      } else {
#line 172
        tmp___41 = strncmp((char const   *)name, "file:", 5U);
      }
#line 177
      if (tmp___41) {
#line 173
        if (0) {
#line 173
          if (0) {
#line 173
            __s1_len___4 = strlen((char const   *)name);
#line 173
            __s2_len___4 = strlen("yp:");
#line 173
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
              goto _L___10;
            } else {
#line 173
              if (__s1_len___4 >= 4U) {
                _L___10: 
#line 173
                if (! ((unsigned int )((void const   *)("yp:" + 1)) - (unsigned int )((void const   *)"yp:") == 1U)) {
#line 173
                  tmp___77 = 1;
                } else {
#line 173
                  if (__s2_len___4 >= 4U) {
#line 173
                    tmp___77 = 1;
                  } else {
#line 173
                    tmp___77 = 0;
                  }
                }
              } else {
#line 173
                tmp___77 = 0;
              }
            }
#line 173
            if (tmp___77) {
#line 173
              tmp___73 = __builtin_strcmp((char const   *)name, "yp:");
            } else {
#line 173
              tmp___76 = __builtin_strcmp((char const   *)name, "yp:");
#line 173
              tmp___73 = tmp___76;
            }
          } else {
#line 173
            tmp___76 = __builtin_strcmp((char const   *)name, "yp:");
#line 173
            tmp___73 = tmp___76;
          }
#line 173
          tmp___67 = tmp___73;
        } else {
#line 173
          tmp___67 = strncmp((char const   *)name, "yp:", 3U);
        }
#line 177
        if (tmp___67) {
#line 174
          if (0) {
#line 174
            if (0) {
#line 174
              __s1_len___6 = strlen((char const   *)name);
#line 174
              __s2_len___6 = strlen("nis:");
#line 174
              if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                goto _L___14;
              } else {
#line 174
                if (__s1_len___6 >= 4U) {
                  _L___14: 
#line 174
                  if (! ((unsigned int )((void const   *)("nis:" + 1)) - (unsigned int )((void const   *)"nis:") == 1U)) {
#line 174
                    tmp___103 = 1;
                  } else {
#line 174
                    if (__s2_len___6 >= 4U) {
#line 174
                      tmp___103 = 1;
                    } else {
#line 174
                      tmp___103 = 0;
                    }
                  }
                } else {
#line 174
                  tmp___103 = 0;
                }
              }
#line 174
              if (tmp___103) {
#line 174
                tmp___99 = __builtin_strcmp((char const   *)name, "nis:");
              } else {
#line 174
                tmp___102 = __builtin_strcmp((char const   *)name, "nis:");
#line 174
                tmp___99 = tmp___102;
              }
            } else {
#line 174
              tmp___102 = __builtin_strcmp((char const   *)name, "nis:");
#line 174
              tmp___99 = tmp___102;
            }
#line 174
            tmp___93 = tmp___99;
          } else {
#line 174
            tmp___93 = strncmp((char const   *)name, "nis:", 4U);
          }
#line 177
          if (tmp___93) {
#line 175
            if (0) {
#line 175
              if (0) {
#line 175
                __s1_len___8 = strlen((char const   *)name);
#line 175
                __s2_len___8 = strlen("nisplus:");
#line 175
                if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                  goto _L___18;
                } else {
#line 175
                  if (__s1_len___8 >= 4U) {
                    _L___18: 
#line 175
                    if (! ((unsigned int )((void const   *)("nisplus:" + 1)) - (unsigned int )((void const   *)"nisplus:") == 1U)) {
#line 175
                      tmp___129 = 1;
                    } else {
#line 175
                      if (__s2_len___8 >= 4U) {
#line 175
                        tmp___129 = 1;
                      } else {
#line 175
                        tmp___129 = 0;
                      }
                    }
                  } else {
#line 175
                    tmp___129 = 0;
                  }
                }
#line 175
                if (tmp___129) {
#line 175
                  tmp___125 = __builtin_strcmp((char const   *)name, "nisplus:");
                } else {
#line 175
                  tmp___128 = __builtin_strcmp((char const   *)name, "nisplus:");
#line 175
                  tmp___125 = tmp___128;
                }
              } else {
#line 175
                tmp___128 = __builtin_strcmp((char const   *)name, "nisplus:");
#line 175
                tmp___125 = tmp___128;
              }
#line 175
              tmp___119 = tmp___125;
            } else {
#line 175
              tmp___119 = strncmp((char const   *)name, "nisplus:", 8U);
            }
#line 177
            if (tmp___119) {
#line 176
              if (0) {
#line 176
                if (0) {
#line 176
                  __s1_len___10 = strlen((char const   *)name);
#line 176
                  __s2_len___10 = strlen("ldap:");
#line 176
                  if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                    goto _L___22;
                  } else {
#line 176
                    if (__s1_len___10 >= 4U) {
                      _L___22: 
#line 176
                      if (! ((unsigned int )((void const   *)("ldap:" + 1)) - (unsigned int )((void const   *)"ldap:") == 1U)) {
#line 176
                        tmp___155 = 1;
                      } else {
#line 176
                        if (__s2_len___10 >= 4U) {
#line 176
                          tmp___155 = 1;
                        } else {
#line 176
                          tmp___155 = 0;
                        }
                      }
                    } else {
#line 176
                      tmp___155 = 0;
                    }
                  }
#line 176
                  if (tmp___155) {
#line 176
                    tmp___151 = __builtin_strcmp((char const   *)name, "ldap:");
                  } else {
#line 176
                    tmp___154 = __builtin_strcmp((char const   *)name, "ldap:");
#line 176
                    tmp___151 = tmp___154;
                  }
                } else {
#line 176
                  tmp___154 = __builtin_strcmp((char const   *)name, "ldap:");
#line 176
                  tmp___151 = tmp___154;
                }
#line 176
                tmp___145 = tmp___151;
              } else {
#line 176
                tmp___145 = strncmp((char const   *)name, "ldap:", 5U);
              }
#line 177
              if (tmp___145) {
#line 177
                if (0) {
#line 177
                  if (0) {
#line 177
                    __s1_len___12 = strlen((char const   *)name);
#line 177
                    __s2_len___12 = strlen("ldaps:");
#line 177
                    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                      goto _L___26;
                    } else {
#line 177
                      if (__s1_len___12 >= 4U) {
                        _L___26: 
#line 177
                        if (! ((unsigned int )((void const   *)("ldaps:" + 1)) - (unsigned int )((void const   *)"ldaps:") == 1U)) {
#line 177
                          tmp___181 = 1;
                        } else {
#line 177
                          if (__s2_len___12 >= 4U) {
#line 177
                            tmp___181 = 1;
                          } else {
#line 177
                            tmp___181 = 0;
                          }
                        }
                      } else {
#line 177
                        tmp___181 = 0;
                      }
                    }
#line 177
                    if (tmp___181) {
#line 177
                      tmp___177 = __builtin_strcmp((char const   *)name, "ldaps:");
                    } else {
#line 177
                      tmp___180 = __builtin_strcmp((char const   *)name, "ldaps:");
#line 177
                      tmp___177 = tmp___180;
                    }
                  } else {
#line 177
                    tmp___180 = __builtin_strcmp((char const   *)name, "ldaps:");
#line 177
                    tmp___177 = tmp___180;
                  }
#line 177
                  tmp___171 = tmp___177;
                } else {
#line 177
                  tmp___171 = strncmp((char const   *)name, "ldaps:", 6U);
                }
#line 177
                if (! tmp___171) {
                  _L___27: 
#line 178
                  __builtin_strncpy(source, (char const   *)name, (unsigned int )(tmp - name));
#line 185
                  if (0) {
#line 185
                    if (0) {
#line 185
                      __s1_len___0 = strlen((char const   *)name);
#line 185
                      __s2_len___0 = strlen("ldap");
#line 185
                      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                        goto _L___2;
                      } else {
#line 185
                        if (__s1_len___0 >= 4U) {
                          _L___2: 
#line 185
                          if (! ((unsigned int )((void const   *)("ldap" + 1)) - (unsigned int )((void const   *)"ldap") == 1U)) {
#line 185
                            tmp___25 = 1;
                          } else {
#line 185
                            if (__s2_len___0 >= 4U) {
#line 185
                              tmp___25 = 1;
                            } else {
#line 185
                              tmp___25 = 0;
                            }
                          }
                        } else {
#line 185
                          tmp___25 = 0;
                        }
                      }
#line 185
                      if (tmp___25) {
#line 185
                        tmp___21 = __builtin_strcmp((char const   *)name, "ldap");
                      } else {
#line 185
                        tmp___24 = __builtin_strcmp((char const   *)name, "ldap");
#line 185
                        tmp___21 = tmp___24;
                      }
                    } else {
#line 185
                      tmp___24 = __builtin_strcmp((char const   *)name, "ldap");
#line 185
                      tmp___21 = tmp___24;
                    }
#line 185
                    tmp___15 = tmp___21;
                  } else {
#line 185
                    tmp___15 = strncmp((char const   *)name, "ldap", 4U);
                  }
#line 185
                  if (tmp___15) {
#line 186
                    master->name = tmp + 1;
#line 187
                    while (1) {
#line 187
                      ((*log_debug))(0U, "%s: reading master %s %s", "lookup_nss_read_master",
                                     source, master->name);
#line 187
                      break;
                    }
                  } else {
#line 191
                    master->name = name;
#line 192
                    while (1) {
#line 192
                      ((*log_debug))(0U, "%s: reading master %s %s", "lookup_nss_read_master",
                                     source, tmp + 1);
#line 192
                      break;
                    }
                  }
#line 197
                  result = do_read_master___0(master, source, age);
#line 198
                  master->name = name;
#line 200
                  return (! result);
                }
              } else {
                goto _L___27;
              }
            } else {
              goto _L___27;
            }
          } else {
            goto _L___27;
          }
        } else {
          goto _L___27;
        }
      } else {
        goto _L___27;
      }
    }
  }
#line 205
  while (1) {
#line 205
    nsslist.next = & nsslist;
#line 205
    nsslist.prev = & nsslist;
#line 205
    break;
  }
#line 207
  result = nsswitch_parse(& nsslist);
#line 208
  if (result) {
#line 209
    tmp___184 = list_empty(& nsslist);
#line 209
    if (! tmp___184) {
#line 210
      free_sources(& nsslist);
    }
#line 211
    while (1) {
#line 211
      ((*log_error))(3U, "%s: can\'t to read name service switch config.", "lookup_nss_read_master");
#line 211
      break;
    }
#line 212
    return (0);
  }
#line 216
  head = & nsslist;
#line 217
  p = head->next;
#line 217
  while ((unsigned int )p != (unsigned int )head) {
#line 221
    this = (struct nss_source *)((char *)p - (unsigned long )(& ((struct nss_source *)0)->list));
#line 223
    while (1) {
#line 223
      ((*log_debug))(0U, "%s: reading master %s %s", "lookup_nss_read_master", this->source,
                     master->name);
#line 223
      break;
    }
#line 226
    result = read_master_map(master, this->source, age);
#line 227
    if (result == -1) {
#line 228
      while (1) {
#line 228
        ((*log_debug))(0U, "%s: no map - continuing to next source", "lookup_nss_read_master");
#line 228
        break;
      }
      goto __Cont;
    }
#line 233
    status = check_nss_result(this, (enum nsswitch_status )result);
#line 234
    if (status >= 0) {
#line 235
      free_sources(& nsslist);
#line 236
      return (status);
    }
    __Cont: 
#line 217
    p = p->next;
  }
#line 240
  tmp___185 = list_empty(& nsslist);
#line 240
  if (! tmp___185) {
#line 241
    free_sources(& nsslist);
  }
#line 243
  return (! result);
}
}
#line 246 "lookup.c"
static int do_read_map(struct autofs_point *ap , struct map_source *map , time_t age ) 
{ struct lookup_mod *lookup ;
  int status ;

  {
#line 251
  if (! map->lookup) {
#line 252
    lookup = open_lookup((char const   *)map->type, "", (char const   *)map->format,
                         map->argc, (char const   * const  *)map->argv);
#line 254
    if (! lookup) {
#line 255
      while (1) {
#line 255
        ((*log_debug))(ap->logopt, "%s: lookup module %s failed", "do_read_map", map->type);
#line 255
        break;
      }
#line 256
      return (2);
    }
#line 258
    map->lookup = lookup;
  }
#line 261
  lookup = map->lookup;
#line 271
  if (! ap->ghost) {
#line 271
    if (ap->type != 4U) {
#line 272
      return (0);
    }
  }
#line 274
  if (! map->stale) {
#line 275
    return (0);
  }
#line 277
  master_source_current_wait(ap->entry);
#line 278
  (ap->entry)->current = map;
#line 280
  status = ((*(lookup->lookup_read_map)))(ap, age, lookup->context);
#line 282
  map->stale = 0U;
#line 289
  if (status == -1) {
#line 290
    return (0);
  }
#line 292
  return (status);
}
}
#line 295 "lookup.c"
static int read_file_source_instance(struct autofs_point *ap , struct map_source *map ,
                                     time_t age ) 
{ struct map_source *instance ;
  char src_file[5] ;
  char src_prog[8] ;
  struct stat st ;
  char *type___0 ;
  char *format___0 ;
  int tmp ;
  int argc ;
  char const   **argv ;
  int tmp___0 ;

  {
#line 298
  src_file[0] = (char )'f';
#line 298
  src_file[1] = (char )'i';
#line 298
  src_file[2] = (char )'l';
#line 298
  src_file[3] = (char )'e';
#line 298
  src_file[4] = (char )'\000';
#line 299
  src_prog[0] = (char )'p';
#line 299
  src_prog[1] = (char )'r';
#line 299
  src_prog[2] = (char )'o';
#line 299
  src_prog[3] = (char )'g';
#line 299
  src_prog[4] = (char )'r';
#line 299
  src_prog[5] = (char )'a';
#line 299
  src_prog[6] = (char )'m';
#line 299
  src_prog[7] = (char )'\000';
#line 303
  tmp = stat__extinline((*(map->argv + 0)), & st);
#line 303
  if (tmp == -1) {
#line 304
    while (1) {
#line 304
      ((*log_warn))(ap->logopt, "%s: file map %s not found", "read_file_source_instance",
                    (*(map->argv + 0)));
#line 304
      break;
    }
#line 305
    return (1);
  }
#line 308
  if (! ((st.st_mode & 61440U) == 32768U)) {
#line 309
    return (1);
  }
#line 311
  if (st.st_mode & 64U) {
#line 312
    type___0 = src_prog;
  } else {
#line 314
    type___0 = src_file;
  }
#line 316
  format___0 = map->format;
#line 318
  instance = master_find_source_instance(map, (char const   *)type___0, (char const   *)format___0,
                                         0, (char const   **)((void *)0));
#line 319
  if (! instance) {
#line 320
    argc = map->argc;
#line 321
    argv = map->argv;
#line 322
    instance = master_add_source_instance(map, (char const   *)type___0, (char const   *)format___0,
                                          age, argc, argv);
#line 323
    if (! instance) {
#line 324
      return (2);
    }
#line 325
    instance->recurse = map->recurse;
#line 326
    instance->depth = map->depth;
  }
#line 329
  tmp___0 = do_read_map(ap, instance, age);
#line 329
  return (tmp___0);
}
}
#line 332 "lookup.c"
static int read_source_instance(struct autofs_point *ap , struct map_source *map ,
                                char const   *type___0 , time_t age ) 
{ struct map_source *instance ;
  char const   *format___0 ;
  int argc ;
  char const   **argv ;
  int tmp ;

  {
#line 337
  format___0 = (char const   *)map->format;
#line 339
  instance = master_find_source_instance(map, type___0, format___0, 0, (char const   **)((void *)0));
#line 340
  if (! instance) {
#line 341
    argc = map->argc;
#line 342
    argv = map->argv;
#line 343
    instance = master_add_source_instance(map, type___0, format___0, age, argc, argv);
#line 344
    if (! instance) {
#line 345
      return (2);
    }
#line 346
    instance->recurse = map->recurse;
#line 347
    instance->depth = map->depth;
  }
#line 350
  tmp = do_read_map(ap, instance, age);
#line 350
  return (tmp);
}
}
#line 353 "lookup.c"
static void argv_cleanup(void *arg ) 
{ struct map_source *tmap ;

  {
#line 355
  tmap = (struct map_source *)arg;
#line 357
  free_argv(tmap->argc, tmap->argv);
#line 358
  return;
}
}
#line 361 "lookup.c"
static enum nsswitch_status read_map_source(struct nss_source *this , struct autofs_point *ap ,
                                            struct map_source *map , time_t age ) 
{ enum nsswitch_status result ;
  struct map_source tmap ;
  char *path___0 ;
  enum nsswitch_status tmp ;
  int tmp___0 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___5 ;
  long tmp___6 ;

  {
#line 368
  tmp___0 = strcasecmp((char const   *)this->source, "files");
#line 368
  if (tmp___0) {
#line 369
    tmp = (enum nsswitch_status )read_source_instance(ap, map, (char const   *)this->source,
                                                      age);
#line 369
    return (tmp);
  }
#line 379
  tmp___2 = __builtin_strchr((char *)(*(map->argv + 0)), (char )'/');
#line 379
  if (tmp___2) {
#line 380
    while (1) {
#line 380
      ((*log_error))(ap->logopt, "%s: relative path invalid in files map name", "read_map_source");
#line 380
      break;
    }
#line 381
    return ((enum nsswitch_status )1);
  }
#line 384
  (*(this->source + 4)) = (char )'\000';
#line 385
  tmap.type = this->source;
#line 386
  tmap.format = map->format;
#line 387
  tmap.lookup = map->lookup;
#line 388
  tmap.mc = map->mc;
#line 389
  tmap.instance = map->instance;
#line 390
  tmap.recurse = map->recurse;
#line 391
  tmap.depth = map->depth;
#line 392
  tmap.argc = 0;
#line 393
  tmap.argv = (char const   **)((void *)0);
#line 395
  tmp___3 = strlen("/etc");
#line 395
  tmp___4 = strlen((*(map->argv + 0)));
#line 395
  path___0 = (char *)malloc((tmp___3 + tmp___4) + 2U);
#line 396
  if (! path___0) {
#line 397
    return ((enum nsswitch_status )-1);
  }
#line 399
  strcpy((char * __restrict  )path___0, (char const   * __restrict  )"/etc");
#line 400
  strcat((char * __restrict  )path___0, (char const   * __restrict  )"/");
#line 401
  strcat((char * __restrict  )path___0, (char const   * __restrict  )(*(map->argv + 0)));
#line 403
  if (map->argc >= 1) {
#line 404
    tmap.argc = map->argc;
#line 405
    tmap.argv = copy_argv(map->argc, map->argv);
#line 406
    if (! tmap.argv) {
#line 407
      while (1) {
#line 407
        ((*log_error))(ap->logopt, "%s: failed to copy args", "read_map_source");
#line 407
        break;
      }
#line 408
      free((void *)path___0);
#line 409
      return ((enum nsswitch_status )-1);
    }
#line 411
    if ((*(tmap.argv + 0))) {
#line 412
      free((void *)((char *)(*(tmap.argv + 0))));
    }
#line 413
    (*(tmap.argv + 0)) = (char const   *)path___0;
  } else {
#line 415
    while (1) {
#line 415
      ((*log_error))(ap->logopt, "%s: invalid arguments for autofs_point", "read_map_source");
#line 415
      break;
    }
#line 416
    free((void *)path___0);
#line 417
    return ((enum nsswitch_status )-1);
  }
#line 420
  while (1) {
#line 420
    __cancel_routine = & argv_cleanup;
#line 420
    __cancel_arg = (void *)(& tmap);
#line 420
    tmp___5 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
#line 420
    not_first_call = tmp___5;
#line 420
    tmp___6 = __builtin_expect((long )not_first_call, 0L);
#line 420
    if (tmp___6) {
#line 420
      ((*__cancel_routine))(__cancel_arg);
#line 420
      __pthread_unwind_next(& __cancel_buf);
    }
#line 420
    __pthread_register_cancel(& __cancel_buf);
#line 420
    while (1) {
#line 421
      result = (enum nsswitch_status )read_file_source_instance(ap, & tmap, age);
#line 420
      break;
    }
#line 422
    __pthread_unregister_cancel(& __cancel_buf);
#line 422
    ((*__cancel_routine))(__cancel_arg);
#line 420
    break;
  }
#line 424
  map->instance = tmap.instance;
#line 426
  return (result);
}
}
#line 429 "lookup.c"
int lookup_nss_read_map(struct autofs_point *ap , struct map_source *source , time_t age ) 
{ struct master_mapent *entry ;
  struct list_head nsslist ;
  struct list_head *head ;
  struct list_head *p ;
  struct nss_source *this ;
  struct map_source *map ;
  enum nsswitch_status status ;
  unsigned int at_least_one ;
  int result ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp ;
  long tmp___0 ;
  char *tmp___1 ;
  char *tmp___11 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___0)(void * ) ;
  void *__cancel_arg___0 ;
  int not_first_call___0 ;
  int tmp___12 ;
  long tmp___13 ;
  __pthread_unwind_buf_t __cancel_buf___1 ;
  void (*__cancel_routine___1)(void * ) ;
  void *__cancel_arg___1 ;
  int not_first_call___1 ;
  int tmp___14 ;
  long tmp___15 ;

  {
#line 431
  entry = ap->entry;
#line 437
  at_least_one = 0U;
#line 438
  result = 0;
#line 445
  while (1) {
#line 445
    __cancel_routine = & master_source_lock_cleanup;
#line 445
    __cancel_arg = (void *)entry;
#line 445
    tmp = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf), 0);
#line 445
    not_first_call = tmp;
#line 445
    tmp___0 = __builtin_expect((long )not_first_call, 0L);
#line 445
    if (tmp___0) {
#line 445
      ((*__cancel_routine))(__cancel_arg);
#line 445
      __pthread_unwind_next(& __cancel_buf);
    }
#line 445
    __pthread_register_cancel(& __cancel_buf);
#line 445
    while (1) {
#line 446
      master_source_readlock(entry);
#line 447
      if (source) {
#line 448
        map = source;
      } else {
#line 450
        map = entry->maps;
      }
#line 451
      while (map) {
#line 453
        if (! map->stale) {
#line 454
          map = map->next;
#line 455
          continue;
        } else {
#line 453
          if (entry->age > map->age) {
#line 454
            map = map->next;
#line 455
            continue;
          }
        }
#line 458
        if (map->type) {
#line 459
          while (1) {
#line 459
            ((*log_debug))(ap->logopt, "%s: reading map %s %s", "lookup_nss_read_map",
                           map->type, (*(map->argv + 0)));
#line 459
            break;
          }
#line 461
          result = do_read_map(ap, map, age);
#line 462
          map = map->next;
#line 463
          continue;
        }
#line 467
        if (map->argv) {
#line 467
          if ((int const   )(*((*(map->argv + 0)))) == 47) {
#line 468
            if ((int const   )(*((*(map->argv + 0)) + 1)) == 47) {
#line 469
              tmp___11 = __strdup("ldap");
#line 469
              tmp___1 = tmp___11;
#line 470
              if (! tmp___1) {
#line 471
                map = map->next;
#line 472
                continue;
              }
#line 474
              map->type = tmp___1;
#line 475
              while (1) {
#line 475
                ((*log_debug))(ap->logopt, "%s: reading map %s %s", "lookup_nss_read_map",
                               tmp___1, (*(map->argv + 0)));
#line 475
                break;
              }
#line 477
              result = do_read_map(ap, map, age);
            } else {
#line 479
              while (1) {
#line 479
                ((*log_debug))(ap->logopt, "%s: reading map file %s", "lookup_nss_read_map",
                               (*(map->argv + 0)));
#line 479
                break;
              }
#line 481
              result = read_file_source_instance(ap, map, age);
            }
#line 483
            map = map->next;
#line 484
            continue;
          }
        }
#line 487
        while (1) {
#line 487
          nsslist.next = & nsslist;
#line 487
          nsslist.prev = & nsslist;
#line 487
          break;
        }
#line 489
        while (1) {
#line 489
          __cancel_routine___0 = & nsslist_cleanup;
#line 489
          __cancel_arg___0 = (void *)(& nsslist);
#line 489
          tmp___12 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf),
                                 0);
#line 489
          not_first_call___0 = tmp___12;
#line 489
          tmp___13 = __builtin_expect((long )not_first_call___0, 0L);
#line 489
          if (tmp___13) {
#line 489
            ((*__cancel_routine___0))(__cancel_arg___0);
#line 489
            __pthread_unwind_next(& __cancel_buf___0);
          }
#line 489
          __pthread_register_cancel(& __cancel_buf___0);
#line 489
          while (1) {
#line 490
            status = (enum nsswitch_status )nsswitch_parse(& nsslist);
#line 489
            break;
          }
#line 491
          __pthread_unregister_cancel(& __cancel_buf___0);
#line 489
          break;
        }
#line 492
        if (status) {
#line 493
          while (1) {
#line 493
            ((*log_error))(ap->logopt, "%s: can\'t to read name service switch config.",
                           "lookup_nss_read_map");
#line 493
            break;
          }
#line 495
          result = 1;
#line 496
          break;
        }
#line 499
        while (1) {
#line 499
          __cancel_routine___1 = & nsslist_cleanup;
#line 499
          __cancel_arg___1 = (void *)(& nsslist);
#line 499
          tmp___14 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___1.__cancel_jmp_buf),
                                 0);
#line 499
          not_first_call___1 = tmp___14;
#line 499
          tmp___15 = __builtin_expect((long )not_first_call___1, 0L);
#line 499
          if (tmp___15) {
#line 499
            ((*__cancel_routine___1))(__cancel_arg___1);
#line 499
            __pthread_unwind_next(& __cancel_buf___1);
          }
#line 499
          __pthread_register_cancel(& __cancel_buf___1);
#line 499
          while (1) {
#line 500
            head = & nsslist;
#line 501
            p = head->next;
#line 501
            while ((unsigned int )p != (unsigned int )head) {
#line 502
              this = (struct nss_source *)((char *)p - (unsigned long )(& ((struct nss_source *)0)->list));
#line 504
              while (1) {
#line 504
                ((*log_debug))(ap->logopt, "%s: reading map %s %s", "lookup_nss_read_map",
                               this->source, (*(map->argv + 0)));
#line 504
                break;
              }
#line 507
              result = (int )read_map_source(this, ap, map, age);
#line 508
              if (result == -1) {
                goto __Cont;
              }
#line 511
              if (result == 0) {
#line 512
                at_least_one = 1U;
#line 513
                result = 3;
              }
#line 516
              status = (enum nsswitch_status )check_nss_result(this, (enum nsswitch_status )result);
#line 517
              if ((int )status >= 0) {
#line 518
                map = (struct map_source *)((void *)0);
#line 519
                break;
              }
              __Cont: 
#line 501
              p = p->next;
            }
#line 499
            break;
          }
#line 522
          __pthread_unregister_cancel(& __cancel_buf___1);
#line 522
          ((*__cancel_routine___1))(__cancel_arg___1);
#line 499
          break;
        }
#line 524
        if (! map) {
#line 525
          break;
        }
#line 527
        map = map->next;
      }
#line 445
      break;
    }
#line 529
    __pthread_unregister_cancel(& __cancel_buf);
#line 529
    ((*__cancel_routine))(__cancel_arg);
#line 445
    break;
  }
#line 531
  if (! result) {
#line 532
    return (1);
  } else {
#line 531
    if (at_least_one) {
#line 532
      return (1);
    }
  }
#line 534
  return (0);
}
}
#line 537 "lookup.c"
int lookup_ghost(struct autofs_point *ap ) 
{ struct master_mapent *entry ;
  struct map_source *map ;
  struct mapent_cache *mc ;
  struct mapent *me ;
  char buf[128] ;
  struct stat st ;
  char *fullpath ;
  int ret ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___9 ;
  long tmp___10 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___0)(void * ) ;
  void *__cancel_arg___0 ;
  int not_first_call___0 ;
  int tmp___11 ;
  long tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  char *estr ;
  int *tmp___16 ;
  char *tmp___17 ;
  int *tmp___18 ;
  char *estr___0 ;
  int *tmp___19 ;
  char *tmp___20 ;
  int *tmp___21 ;
  int tmp___22 ;

  {
#line 539
  entry = ap->entry;
#line 548
  if (0) {
#line 548
    __s1_len = strlen((char const   *)ap->path);
#line 548
    __s2_len = strlen("/-");
#line 548
    if (! ((unsigned int )((void const   *)(ap->path + 1)) - (unsigned int )((void const   *)ap->path) == 1U)) {
      goto _L___0;
    } else {
#line 548
      if (__s1_len >= 4U) {
        _L___0: 
#line 548
        if (! ((unsigned int )((void const   *)("/-" + 1)) - (unsigned int )((void const   *)"/-") == 1U)) {
#line 548
          tmp___8 = 1;
        } else {
#line 548
          if (__s2_len >= 4U) {
#line 548
            tmp___8 = 1;
          } else {
#line 548
            tmp___8 = 0;
          }
        }
      } else {
#line 548
        tmp___8 = 0;
      }
    }
#line 548
    if (tmp___8) {
#line 548
      tmp___4 = __builtin_strcmp((char const   *)ap->path, "/-");
    } else {
#line 548
      tmp___7 = __builtin_strcmp((char const   *)ap->path, "/-");
#line 548
      tmp___4 = tmp___7;
    }
  } else {
#line 548
    tmp___7 = __builtin_strcmp((char const   *)ap->path, "/-");
#line 548
    tmp___4 = tmp___7;
  }
#line 548
  if (! tmp___4) {
#line 549
    return (5);
  }
#line 551
  if (! ap->ghost) {
#line 552
    return (2);
  }
#line 554
  while (1) {
#line 554
    __cancel_routine = & master_source_lock_cleanup;
#line 554
    __cancel_arg = (void *)entry;
#line 554
    tmp___9 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
#line 554
    not_first_call = tmp___9;
#line 554
    tmp___10 = __builtin_expect((long )not_first_call, 0L);
#line 554
    if (tmp___10) {
#line 554
      ((*__cancel_routine))(__cancel_arg);
#line 554
      __pthread_unwind_next(& __cancel_buf);
    }
#line 554
    __pthread_register_cancel(& __cancel_buf);
#line 554
    while (1) {
#line 555
      master_source_readlock(entry);
#line 556
      map = entry->maps;
#line 557
      while (map) {
#line 562
        if (entry->age > map->age) {
#line 563
          map = map->next;
#line 564
          continue;
        }
#line 567
        mc = map->mc;
#line 568
        while (1) {
#line 568
          __cancel_routine___0 = & cache_lock_cleanup;
#line 568
          __cancel_arg___0 = (void *)mc;
#line 568
          tmp___11 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf),
                                 0);
#line 568
          not_first_call___0 = tmp___11;
#line 568
          tmp___12 = __builtin_expect((long )not_first_call___0, 0L);
#line 568
          if (tmp___12) {
#line 568
            ((*__cancel_routine___0))(__cancel_arg___0);
#line 568
            __pthread_unwind_next(& __cancel_buf___0);
          }
#line 568
          __pthread_register_cancel(& __cancel_buf___0);
#line 568
          while (1) {
#line 569
            cache_readlock(mc);
#line 570
            me = cache_enumerate(mc, (struct mapent *)((void *)0));
#line 571
            while (me) {
#line 572
              if ((int )(*(me->key)) == 42) {
                goto next;
              }
#line 575
              if ((int )(*(me->key)) == 47) {
#line 577
                tmp___13 = list_empty(& me->multi_list);
#line 577
                if (tmp___13) {
#line 578
                  while (1) {
#line 578
                    ((*log_error))(ap->logopt, "%s: invalid key %s", "lookup_ghost",
                                   me->key);
#line 578
                    break;
                  }
                }
                goto next;
              }
#line 583
              tmp___14 = strlen((char const   *)me->key);
#line 583
              tmp___15 = strlen((char const   *)ap->path);
#line 583
              fullpath = (char *)__builtin_alloca((tmp___14 + tmp___15) + 3U);
#line 584
              if (! fullpath) {
#line 585
                while (1) {
#line 585
                  ((*log_warn))(ap->logopt, "%s: failed to allocate full path", "lookup_ghost");
#line 585
                  break;
                }
                goto next;
              }
#line 588
              sprintf((char * __restrict  )fullpath, (char const   * __restrict  )"%s/%s",
                      ap->path, me->key);
#line 590
              ret = stat__extinline((char const   *)fullpath, & st);
#line 591
              if (ret == -1) {
#line 591
                tmp___18 = __errno_location();
#line 591
                if ((*tmp___18) != 2) {
#line 592
                  tmp___16 = __errno_location();
#line 592
                  tmp___17 = strerror_r((*tmp___16), buf, 128U);
#line 592
                  estr = tmp___17;
#line 593
                  while (1) {
#line 593
                    ((*log_warn))(ap->logopt, "%s: stat error %s", "lookup_ghost",
                                  estr);
#line 593
                    break;
                  }
                  goto next;
                }
              }
#line 597
              ret = mkdir_path((char const   *)fullpath, 365U);
#line 598
              if (ret < 0) {
#line 598
                tmp___21 = __errno_location();
#line 598
                if ((*tmp___21) != 17) {
#line 599
                  tmp___19 = __errno_location();
#line 599
                  tmp___20 = strerror_r((*tmp___19), buf, 128U);
#line 599
                  estr___0 = tmp___20;
#line 600
                  while (1) {
#line 600
                    ((*log_warn))(ap->logopt, "%s: mkdir_path %s failed: %s", "lookup_ghost",
                                  fullpath, estr___0);
#line 600
                    break;
                  }
                  goto next;
                }
              }
#line 605
              tmp___22 = stat__extinline((char const   *)fullpath, & st);
#line 605
              if (tmp___22 != -1) {
#line 606
                me->dev = st.st_dev;
#line 607
                me->ino = st.st_ino;
              }
              next: 
#line 610
              me = cache_enumerate(mc, me);
            }
#line 568
            break;
          }
#line 612
          __pthread_unregister_cancel(& __cancel_buf___0);
#line 612
          ((*__cancel_routine___0))(__cancel_arg___0);
#line 568
          break;
        }
#line 613
        map = map->next;
      }
#line 554
      break;
    }
#line 615
    __pthread_unregister_cancel(& __cancel_buf);
#line 615
    ((*__cancel_routine))(__cancel_arg);
#line 554
    break;
  }
#line 617
  return (2);
}
}
#line 620 "lookup.c"
int do_lookup_mount(struct autofs_point *ap , struct map_source *map , char const   *name ,
                    int name_len ) 
{ struct lookup_mod *lookup ;
  int status ;

  {
#line 625
  if (! map->lookup) {
#line 626
    lookup = open_lookup((char const   *)map->type, "", (char const   *)map->format,
                         map->argc, (char const   * const  *)map->argv);
#line 628
    if (! lookup) {
#line 629
      while (1) {
#line 629
        ((*log_debug))(ap->logopt, "%s: lookup module %s failed", "do_lookup_mount",
                       map->type);
#line 629
        break;
      }
#line 631
      return (2);
    }
#line 633
    map->lookup = lookup;
  }
#line 636
  lookup = map->lookup;
#line 638
  master_source_current_wait(ap->entry);
#line 639
  (ap->entry)->current = map;
#line 641
  status = ((*(lookup->lookup_mount)))(ap, name, name_len, lookup->context);
#line 643
  return (status);
}
}
#line 646 "lookup.c"
static int lookup_name_file_source_instance(struct autofs_point *ap , struct map_source *map ,
                                            char const   *name , int name_len ) 
{ struct map_source *instance ;
  char src_file[5] ;
  char src_prog[8] ;
  time_t age ;
  time_t tmp ;
  struct stat st ;
  char *type___0 ;
  char *format___0 ;
  int tmp___0 ;
  int argc ;
  char const   **argv ;
  int tmp___1 ;

  {
#line 649
  src_file[0] = (char )'f';
#line 649
  src_file[1] = (char )'i';
#line 649
  src_file[2] = (char )'l';
#line 649
  src_file[3] = (char )'e';
#line 649
  src_file[4] = (char )'\000';
#line 650
  src_prog[0] = (char )'p';
#line 650
  src_prog[1] = (char )'r';
#line 650
  src_prog[2] = (char )'o';
#line 650
  src_prog[3] = (char )'g';
#line 650
  src_prog[4] = (char )'r';
#line 650
  src_prog[5] = (char )'a';
#line 650
  src_prog[6] = (char )'m';
#line 650
  src_prog[7] = (char )'\000';
#line 651
  tmp = time((time_t *)((void *)0));
#line 651
  age = tmp;
#line 655
  tmp___0 = stat__extinline((*(map->argv + 0)), & st);
#line 655
  if (tmp___0 == -1) {
#line 656
    while (1) {
#line 656
      ((*log_warn))(ap->logopt, "%s: file map not found", "lookup_name_file_source_instance");
#line 656
      break;
    }
#line 657
    return (1);
  }
#line 660
  if (! ((st.st_mode & 61440U) == 32768U)) {
#line 661
    return (1);
  }
#line 663
  if (st.st_mode & 64U) {
#line 664
    type___0 = src_prog;
  } else {
#line 666
    type___0 = src_file;
  }
#line 668
  format___0 = map->format;
#line 670
  instance = master_find_source_instance(map, (char const   *)type___0, (char const   *)format___0,
                                         0, (char const   **)((void *)0));
#line 671
  if (! instance) {
#line 672
    argc = map->argc;
#line 673
    argv = map->argv;
#line 674
    instance = master_add_source_instance(map, (char const   *)type___0, (char const   *)format___0,
                                          age, argc, argv);
#line 675
    if (! instance) {
#line 676
      return (1);
    }
#line 677
    instance->recurse = map->recurse;
#line 678
    instance->depth = map->depth;
  }
#line 681
  tmp___1 = do_lookup_mount(ap, instance, name, name_len);
#line 681
  return (tmp___1);
}
}
#line 684 "lookup.c"
static int lookup_name_source_instance(struct autofs_point *ap , struct map_source *map ,
                                       char const   *type___0 , char const   *name ,
                                       int name_len ) 
{ struct map_source *instance ;
  char const   *format___0 ;
  time_t age ;
  time_t tmp ;
  int argc ;
  char const   **argv ;
  int tmp___0 ;

  {
#line 688
  tmp = time((time_t *)((void *)0));
#line 688
  age = tmp;
#line 690
  format___0 = (char const   *)map->format;
#line 692
  instance = master_find_source_instance(map, type___0, format___0, 0, (char const   **)((void *)0));
#line 693
  if (! instance) {
#line 694
    argc = map->argc;
#line 695
    argv = map->argv;
#line 696
    instance = master_add_source_instance(map, type___0, format___0, age, argc, argv);
#line 697
    if (! instance) {
#line 698
      return (1);
    }
#line 699
    instance->recurse = map->recurse;
#line 700
    instance->depth = map->depth;
  }
#line 703
  tmp___0 = do_lookup_mount(ap, instance, name, name_len);
#line 703
  return (tmp___0);
}
}
#line 706 "lookup.c"
static enum nsswitch_status lookup_map_name(struct nss_source *this , struct autofs_point *ap ,
                                            struct map_source *map , char const   *name ,
                                            int name_len ) 
{ enum nsswitch_status result ;
  struct map_source tmap ;
  char *path___0 ;
  enum nsswitch_status tmp ;
  int tmp___0 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
#line 714
  tmp___0 = strcasecmp((char const   *)this->source, "files");
#line 714
  if (tmp___0) {
#line 715
    tmp = (enum nsswitch_status )lookup_name_source_instance(ap, map, (char const   *)this->source,
                                                             name, name_len);
#line 715
    return (tmp);
  }
#line 725
  tmp___2 = __builtin_strchr((char *)(*(map->argv + 0)), (char )'/');
#line 725
  if (tmp___2) {
#line 726
    while (1) {
#line 726
      ((*log_error))(ap->logopt, "%s: relative path invalid in files map name", "lookup_map_name");
#line 726
      break;
    }
#line 727
    return ((enum nsswitch_status )1);
  }
#line 730
  (*(this->source + 4)) = (char )'\000';
#line 731
  tmap.type = this->source;
#line 732
  tmap.format = map->format;
#line 733
  tmap.mc = map->mc;
#line 734
  tmap.instance = map->instance;
#line 735
  tmap.recurse = map->recurse;
#line 736
  tmap.depth = map->depth;
#line 737
  tmap.argc = 0;
#line 738
  tmap.argv = (char const   **)((void *)0);
#line 740
  tmp___3 = strlen("/etc");
#line 740
  tmp___4 = strlen((*(map->argv + 0)));
#line 740
  path___0 = (char *)malloc((tmp___3 + tmp___4) + 2U);
#line 741
  if (! path___0) {
#line 742
    return ((enum nsswitch_status )-1);
  }
#line 744
  strcpy((char * __restrict  )path___0, (char const   * __restrict  )"/etc");
#line 745
  strcat((char * __restrict  )path___0, (char const   * __restrict  )"/");
#line 746
  strcat((char * __restrict  )path___0, (char const   * __restrict  )(*(map->argv + 0)));
#line 748
  if (map->argc >= 1) {
#line 749
    tmap.argc = map->argc;
#line 750
    tmap.argv = copy_argv(map->argc, map->argv);
#line 751
    if (! tmap.argv) {
#line 752
      while (1) {
#line 752
        ((*log_error))(ap->logopt, "%s: failed to copy args", "lookup_map_name");
#line 752
        break;
      }
#line 753
      free((void *)path___0);
#line 754
      return ((enum nsswitch_status )-1);
    }
#line 756
    if ((*(tmap.argv + 0))) {
#line 757
      free((void *)((char *)(*(tmap.argv + 0))));
    }
#line 758
    (*(tmap.argv + 0)) = (char const   *)path___0;
  } else {
#line 760
    while (1) {
#line 760
      ((*log_error))(ap->logopt, "%s: invalid arguments for autofs_point", "lookup_map_name");
#line 760
      break;
    }
#line 761
    free((void *)path___0);
#line 762
    return ((enum nsswitch_status )-1);
  }
#line 765
  result = (enum nsswitch_status )lookup_name_file_source_instance(ap, & tmap, name,
                                                                   name_len);
#line 767
  map->instance = tmap.instance;
#line 770
  free_argv(tmap.argc, tmap.argv);
#line 772
  return (result);
}
}
#line 775 "lookup.c"
int lookup_nss_mount(struct autofs_point *ap , struct map_source *source , char const   *name ,
                     int name_len ) 
{ struct master_mapent *entry ;
  struct list_head nsslist ;
  struct list_head *head ;
  struct list_head *p ;
  struct nss_source *this ;
  struct map_source *map ;
  enum nsswitch_status status ;
  int result ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp ;
  long tmp___0 ;
  char *tmp___1 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
#line 777
  entry = ap->entry;
#line 783
  result = 0;
#line 790
  while (1) {
#line 790
    __cancel_routine = & master_source_lock_cleanup;
#line 790
    __cancel_arg = (void *)entry;
#line 790
    tmp = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf), 0);
#line 790
    not_first_call = tmp;
#line 790
    tmp___0 = __builtin_expect((long )not_first_call, 0L);
#line 790
    if (tmp___0) {
#line 790
      ((*__cancel_routine))(__cancel_arg);
#line 790
      __pthread_unwind_next(& __cancel_buf);
    }
#line 790
    __pthread_register_cancel(& __cancel_buf);
#line 790
    while (1) {
#line 791
      master_source_readlock(entry);
#line 792
      if (source) {
#line 793
        map = source;
      } else {
#line 795
        map = entry->maps;
      }
#line 796
      while (map) {
#line 801
        if (entry->age > map->age) {
#line 802
          map = map->next;
#line 803
          continue;
        }
#line 806
        sched_yield();
#line 808
        if (map->type) {
#line 809
          result = do_lookup_mount(ap, map, name, name_len);
#line 811
          if (result == 0) {
#line 812
            break;
          }
#line 814
          map = map->next;
#line 815
          continue;
        }
#line 819
        if ((int const   )(*((*(map->argv + 0)))) == 47) {
#line 820
          if ((int const   )(*((*(map->argv + 0)) + 1)) == 47) {
#line 821
            tmp___11 = __strdup("ldap");
#line 821
            tmp___1 = tmp___11;
#line 822
            if (! tmp___1) {
#line 823
              map = map->next;
#line 824
              continue;
            }
#line 826
            map->type = tmp___1;
#line 827
            result = do_lookup_mount(ap, map, name, name_len);
          } else {
#line 829
            result = lookup_name_file_source_instance(ap, map, name, name_len);
          }
#line 831
          if (result == 0) {
#line 832
            break;
          }
#line 834
          map = map->next;
#line 835
          continue;
        }
#line 838
        while (1) {
#line 838
          nsslist.next = & nsslist;
#line 838
          nsslist.prev = & nsslist;
#line 838
          break;
        }
#line 840
        status = (enum nsswitch_status )nsswitch_parse(& nsslist);
#line 841
        if (status) {
#line 842
          while (1) {
#line 842
            ((*log_error))(ap->logopt, "%s: can\'t to read name service switch config.",
                           "lookup_nss_mount");
#line 842
            break;
          }
#line 844
          result = 1;
#line 845
          break;
        }
#line 848
        head = & nsslist;
#line 849
        p = head->next;
#line 849
        while ((unsigned int )p != (unsigned int )head) {
#line 850
          this = (struct nss_source *)((char *)p - (unsigned long )(& ((struct nss_source *)0)->list));
#line 852
          result = (int )lookup_map_name(this, ap, map, name, name_len);
#line 854
          if (result == -1) {
#line 855
            map = map->next;
            goto __Cont;
          }
#line 859
          status = (enum nsswitch_status )check_nss_result(this, (enum nsswitch_status )result);
#line 860
          if ((int )status >= 0) {
#line 861
            map = (struct map_source *)((void *)0);
#line 862
            break;
          }
          __Cont: 
#line 849
          p = p->next;
        }
#line 866
        tmp___12 = list_empty(& nsslist);
#line 866
        if (! tmp___12) {
#line 867
          free_sources(& nsslist);
        }
#line 869
        if (! map) {
#line 870
          break;
        }
#line 872
        map = map->next;
      }
#line 874
      send_map_update_request(ap);
#line 790
      break;
    }
#line 875
    __pthread_unregister_cancel(& __cancel_buf);
#line 875
    ((*__cancel_routine))(__cancel_arg);
#line 790
    break;
  }
#line 877
  return (! result);
}
}
#line 880 "lookup.c"
static void lookup_close_lookup_instances(struct map_source *map ) 
{ struct map_source *instance ;

  {
#line 884
  instance = map->instance;
#line 885
  while (instance) {
#line 886
    lookup_close_lookup_instances(instance);
#line 887
    instance = instance->next;
  }
#line 890
  if (map->lookup) {
#line 891
    close_lookup(map->lookup);
#line 892
    map->lookup = (struct lookup_mod *)((void *)0);
  }
#line 894
  return;
}
}
#line 896 "lookup.c"
void lookup_close_lookup(struct autofs_point *ap ) 
{ struct map_source *map ;

  {
#line 900
  map = (ap->entry)->maps;
#line 901
  if (! map) {
#line 902
    return;
  }
#line 904
  while (map) {
#line 905
    lookup_close_lookup_instances(map);
#line 906
    map = map->next;
  }
#line 908
  return;
}
}
#line 911 "lookup.c"
static char *make_fullpath(char const   *root , char const   *key ) 
{ int l ;
  char *path___0 ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 916
  if ((int const   )(*key) == 47) {
#line 917
    tmp = strlen(key);
#line 917
    l = (int )(tmp + 1U);
#line 918
    if (l > 255) {
#line 919
      return ((char *)((void *)0));
    }
#line 920
    path___0 = (char *)malloc((unsigned int )l);
#line 921
    strcpy((char * __restrict  )path___0, (char const   * __restrict  )key);
  } else {
#line 923
    tmp___0 = strlen(key);
#line 923
    tmp___1 = strlen(root);
#line 923
    l = (int )(((tmp___0 + 1U) + tmp___1) + 1U);
#line 924
    if (l > 255) {
#line 925
      return ((char *)((void *)0));
    }
#line 926
    path___0 = (char *)malloc((unsigned int )l);
#line 927
    sprintf((char * __restrict  )path___0, (char const   * __restrict  )"%s/%s", root,
            key);
  }
#line 929
  return (path___0);
}
}
#line 932 "lookup.c"
int lookup_prune_cache(struct autofs_point *ap , time_t age ) 
{ struct master_mapent *entry ;
  struct map_source *map ;
  struct mapent_cache *mc ;
  struct mapent *me ;
  struct mapent *this ;
  char *path___0 ;
  int status ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp ;
  long tmp___0 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___0)(void * ) ;
  void *__cancel_arg___0 ;
  int not_first_call___0 ;
  int tmp___1 ;
  long tmp___2 ;
  char *key ;
  char *next_key ;
  char *tmp___12 ;
  int tmp___13 ;
  char *tmp___23 ;
  int tmp___24 ;

  {
#line 934
  entry = ap->entry;
#line 939
  status = 0;
#line 941
  while (1) {
#line 941
    __cancel_routine = & master_source_lock_cleanup;
#line 941
    __cancel_arg = (void *)entry;
#line 941
    tmp = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf), 0);
#line 941
    not_first_call = tmp;
#line 941
    tmp___0 = __builtin_expect((long )not_first_call, 0L);
#line 941
    if (tmp___0) {
#line 941
      ((*__cancel_routine))(__cancel_arg);
#line 941
      __pthread_unwind_next(& __cancel_buf);
    }
#line 941
    __pthread_register_cancel(& __cancel_buf);
#line 941
    while (1) {
#line 942
      master_source_readlock(entry);
#line 944
      map = entry->maps;
#line 945
      while (map) {
#line 947
        if (! map->stale) {
#line 948
          map = map->next;
#line 949
          continue;
        }
#line 951
        mc = map->mc;
#line 952
        while (1) {
#line 952
          __cancel_routine___0 = & cache_lock_cleanup;
#line 952
          __cancel_arg___0 = (void *)mc;
#line 952
          tmp___1 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf),
                                0);
#line 952
          not_first_call___0 = tmp___1;
#line 952
          tmp___2 = __builtin_expect((long )not_first_call___0, 0L);
#line 952
          if (tmp___2) {
#line 952
            ((*__cancel_routine___0))(__cancel_arg___0);
#line 952
            __pthread_unwind_next(& __cancel_buf___0);
          }
#line 952
          __pthread_register_cancel(& __cancel_buf___0);
#line 952
          while (1) {
#line 953
            cache_readlock(mc);
#line 954
            me = cache_enumerate(mc, (struct mapent *)((void *)0));
#line 955
            while (me) {
#line 956
              key = (char *)((void *)0);
#line 956
              next_key = (char *)((void *)0);
#line 958
              if (me->age >= age) {
#line 959
                me = cache_enumerate(mc, me);
#line 960
                continue;
              }
#line 963
              tmp___12 = __strdup((char const   *)me->key);
#line 963
              key = tmp___12;
#line 964
              me = cache_enumerate(mc, me);
#line 965
              if (! key) {
#line 966
                continue;
              } else {
#line 965
                if ((int )(*key) == 42) {
#line 966
                  continue;
                }
              }
#line 968
              path___0 = make_fullpath((char const   *)ap->path, (char const   *)key);
#line 969
              if (! path___0) {
#line 970
                while (1) {
#line 970
                  ((*log_warn))(ap->logopt, "%s: can\'t malloc storage for path",
                                "lookup_prune_cache");
#line 970
                  break;
                }
#line 972
                free((void *)key);
#line 973
                continue;
              }
#line 976
              tmp___13 = is_mounted("/etc/mtab", (char const   *)path___0, 2U);
#line 976
              if (tmp___13) {
#line 977
                while (1) {
#line 977
                  ((*log_debug))(ap->logopt, "%s: prune check posponed, %s mounted",
                                 "lookup_prune_cache", path___0);
#line 977
                  break;
                }
#line 979
                free((void *)key);
#line 980
                free((void *)path___0);
#line 981
                continue;
              }
#line 984
              if (me) {
#line 985
                tmp___23 = __strdup((char const   *)me->key);
#line 985
                next_key = tmp___23;
              }
#line 987
              cache_unlock(mc);
#line 989
              cache_writelock(mc);
#line 990
              this = cache_lookup_distinct(mc, (char const   *)key);
#line 991
              if (! this) {
#line 992
                cache_unlock(mc);
#line 993
                free((void *)key);
#line 994
                if (next_key) {
#line 995
                  free((void *)next_key);
                }
#line 996
                free((void *)path___0);
                goto next;
              }
#line 1000
              tmp___24 = is_mounted("/proc/mounts", (char const   *)path___0, 4U);
#line 1000
              if (! tmp___24) {
#line 1001
                status = 0;
#line 1002
                if (this->ioctlfd == -1) {
#line 1003
                  status = cache_delete(mc, (char const   *)key);
                }
#line 1004
                if (status != 0) {
#line 1005
                  if (ap->type == 2U) {
#line 1006
                    rmdir_path(ap, (char const   *)path___0, ap->dev);
                  } else {
#line 1008
                    rmdir_path(ap, (char const   *)path___0, this->dev);
                  }
                }
              }
#line 1011
              cache_unlock(mc);
#line 1013
              if (! next_key) {
#line 1014
                free((void *)key);
#line 1015
                free((void *)path___0);
#line 1016
                cache_readlock(mc);
#line 1017
                continue;
              }
              next: 
#line 1020
              cache_readlock(mc);
#line 1021
              me = cache_lookup_distinct(mc, (char const   *)next_key);
#line 1022
              free((void *)key);
#line 1023
              free((void *)path___0);
#line 1024
              free((void *)next_key);
            }
#line 952
            break;
          }
#line 1026
          __pthread_unregister_cancel(& __cancel_buf___0);
#line 1026
          ((*__cancel_routine___0))(__cancel_arg___0);
#line 952
          break;
        }
#line 1027
        map->stale = 0U;
#line 1028
        map = map->next;
      }
#line 941
      break;
    }
#line 1031
    __pthread_unregister_cancel(& __cancel_buf);
#line 1031
    ((*__cancel_routine))(__cancel_arg);
#line 941
    break;
  }
#line 1033
  return (1);
}
}
#line 1037 "lookup.c"
struct mapent *lookup_source_valid_mapent(struct autofs_point *ap , char const   *key ,
                                          unsigned int type___0 ) 
{ struct master_mapent *entry ;
  struct map_source *map ;
  struct mapent_cache *mc ;
  struct mapent *me ;

  {
#line 1039
  entry = ap->entry;
#line 1042
  me = (struct mapent *)((void *)0);
#line 1044
  master_source_readlock(entry);
#line 1045
  map = entry->maps;
#line 1046
  while (map) {
#line 1051
    if ((ap->entry)->age > map->age) {
#line 1052
      map = map->next;
#line 1053
      continue;
    }
#line 1056
    mc = map->mc;
#line 1057
    cache_readlock(mc);
#line 1058
    if (type___0 == 8192U) {
#line 1059
      me = cache_lookup_distinct(mc, key);
    } else {
#line 1061
      me = cache_lookup(mc, key);
    }
#line 1062
    if (me) {
#line 1063
      break;
    }
#line 1064
    cache_unlock(mc);
#line 1065
    map = map->next;
  }
#line 1067
  master_source_unlock(entry);
#line 1069
  return (me);
}
}
#line 1073 "lookup.c"
struct mapent *lookup_source_mapent(struct autofs_point *ap , char const   *key ,
                                    unsigned int type___0 ) 
{ struct master_mapent *entry ;
  struct map_source *map ;
  struct mapent_cache *mc ;
  struct mapent *me ;

  {
#line 1075
  entry = ap->entry;
#line 1078
  me = (struct mapent *)((void *)0);
#line 1080
  master_source_readlock(entry);
#line 1081
  map = entry->maps;
#line 1082
  while (map) {
#line 1083
    mc = map->mc;
#line 1084
    cache_readlock(mc);
#line 1085
    if (type___0 == 8192U) {
#line 1086
      me = cache_lookup_distinct(mc, key);
    } else {
#line 1088
      me = cache_lookup(mc, key);
    }
#line 1089
    if (me) {
#line 1090
      break;
    }
#line 1091
    cache_unlock(mc);
#line 1092
    map = map->next;
  }
#line 1094
  master_source_unlock(entry);
#line 1096
  return (me);
}
}
#line 1099 "lookup.c"
int lookup_source_close_ioctlfd(struct autofs_point *ap , char const   *key ) 
{ struct master_mapent *entry ;
  struct map_source *map ;
  struct mapent_cache *mc ;
  struct mapent *me ;
  int ret ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp ;
  long tmp___0 ;

  {
#line 1101
  entry = ap->entry;
#line 1105
  ret = 0;
#line 1107
  while (1) {
#line 1107
    __cancel_routine = & master_source_lock_cleanup;
#line 1107
    __cancel_arg = (void *)entry;
#line 1107
    tmp = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf), 0);
#line 1107
    not_first_call = tmp;
#line 1107
    tmp___0 = __builtin_expect((long )not_first_call, 0L);
#line 1107
    if (tmp___0) {
#line 1107
      ((*__cancel_routine))(__cancel_arg);
#line 1107
      __pthread_unwind_next(& __cancel_buf);
    }
#line 1107
    __pthread_register_cancel(& __cancel_buf);
#line 1107
    while (1) {
#line 1108
      master_source_readlock(entry);
#line 1109
      map = entry->maps;
#line 1110
      while (map) {
#line 1111
        mc = map->mc;
#line 1112
        cache_readlock(mc);
#line 1113
        me = cache_lookup_distinct(mc, key);
#line 1114
        if (me) {
#line 1115
          if (me->ioctlfd != -1) {
#line 1116
            close(me->ioctlfd);
#line 1117
            me->ioctlfd = -1;
          }
#line 1119
          cache_unlock(mc);
#line 1120
          ret = 1;
#line 1121
          break;
        }
#line 1123
        cache_unlock(mc);
#line 1124
        map = map->next;
      }
#line 1107
      break;
    }
#line 1126
    __pthread_unregister_cancel(& __cancel_buf);
#line 1126
    ((*__cancel_routine))(__cancel_arg);
#line 1107
    break;
  }
#line 1128
  return (ret);
}
}
#line 1 "state.o"
#pragma merger(0,"/tmp/cil-ivnIXVPw.i","-O2,-Wall,-fPIE")
#line 264 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) pthread_t pthread_self(void)  __attribute__((__const__)) ;
#line 482
extern int pthread_cancel(pthread_t __th ) ;
#line 716
extern  __attribute__((__nothrow__)) int pthread_mutex_init(pthread_mutex_t *__mutex ,
                                                            pthread_mutexattr_t const   *__mutexattr )  __attribute__((__nonnull__(1))) ;
#line 721
extern  __attribute__((__nothrow__)) int pthread_mutex_destroy(pthread_mutex_t *__mutex )  __attribute__((__nonnull__(1))) ;
#line 955
extern int pthread_cond_timedwait(pthread_cond_t * __restrict  __cond , pthread_mutex_t * __restrict  __mutex ,
                                  struct timespec  const  * __restrict  __abstime )  __attribute__((__nonnull__(1,2,3))) ;
#line 33 "../include/list.h"
__inline static void __list_add(struct list_head *new , struct list_head *prev , struct list_head *next ) 
{ 

  {
#line 37
  next->prev = new;
#line 38
  new->next = next;
#line 39
  new->prev = prev;
#line 40
  prev->next = new;
#line 41
  return;
}
}
#line 51 "../include/list.h"
__inline static void list_add(struct list_head *new , struct list_head *head ) 
{ 

  {
#line 53
  __list_add(new, head, head->next);
#line 54
  return;
}
}
#line 64 "../include/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 

  {
#line 66
  __list_add(new, head->prev, head);
#line 67
  return;
}
}
#line 76 "../include/list.h"
__inline static void __list_del(struct list_head *prev , struct list_head *next ) 
{ 

  {
#line 79
  next->prev = prev;
#line 80
  prev->next = next;
#line 81
  return;
}
}
#line 88 "../include/list.h"
__inline static void list_del(struct list_head *entry ) 
{ 

  {
#line 90
  __list_del(entry->prev, entry->next);
#line 91
  return;
}
}
#line 97 "../include/list.h"
__inline static void list_del_init(struct list_head *entry ) 
{ 

  {
#line 99
  __list_del(entry->prev, entry->next);
#line 100
  while (1) {
#line 100
    entry->next = entry;
#line 100
    entry->prev = entry;
#line 100
    break;
  }
#line 101
  return;
}
}
#line 85 "../include/state.h"
void expire_proc_cleanup(void *arg ) ;
#line 32 "state.c"
static union __anonunion_pthread_mutex_t_6 mutex  =    {{0, 0U, 0, 0, 0U, {0}}};
#line 33 "state.c"
static union __anonunion_pthread_cond_t_9 cond  =    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}};
#line 34 "state.c"
static unsigned int signaled  =    0U;
#line 35 "state.c"
static struct list_head state_queue  =    {& state_queue, & state_queue};
#line 37
static void st_set_thid(struct autofs_point *ap , pthread_t thid ) ;
#line 38
static void st_set_done(struct autofs_point *ap ) ;
#line 56 "state.c"
void dump_state_queue(void) 
{ struct list_head *head ;
  struct list_head *p ;
  struct list_head *q ;
  struct state_queue *entry ;
  struct state_queue *this ;

  {
#line 58
  head = & state_queue;
#line 61
  while (1) {
#line 61
    ((*log_debug))(3U, "%s: dumping queue", "dump_state_queue");
#line 61
    break;
  }
#line 63
  p = head->next;
#line 63
  while ((unsigned int )p != (unsigned int )head) {
#line 66
    entry = (struct state_queue *)((char *)p - (unsigned long )(& ((struct state_queue *)0)->list));
#line 67
    while (1) {
#line 67
      ((*log_debug))(3U, "%s: queue list head path %s state %d busy %d", "dump_state_queue",
                     (entry->ap)->path, entry->state, entry->busy);
#line 67
      break;
    }
#line 71
    q = entry->pending.next;
#line 71
    while ((unsigned int )q != (unsigned int )(& entry->pending)) {
#line 74
      this = (struct state_queue *)((char *)q - (unsigned long )(& ((struct state_queue *)0)->pending));
#line 75
      while (1) {
#line 75
        ((*log_debug))(3U, "%s: queue list entry path %s state %d busy %d", "dump_state_queue",
                       (this->ap)->path, this->state, this->busy);
#line 75
        break;
      }
#line 71
      q = q->next;
    }
#line 63
    p = p->next;
  }
#line 80
  return;
}
}
#line 82 "state.c"
void nextstate(int statefd , enum states next ) 
{ char buf[128] ;
  char *estr ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 86
  tmp___1 = write(statefd, (void const   *)(& next), sizeof(next));
#line 86
  if ((unsigned int )tmp___1 != sizeof(next)) {
#line 87
    tmp = __errno_location();
#line 87
    tmp___0 = strerror_r((*tmp), buf, 128U);
#line 87
    estr = tmp___0;
#line 88
    while (1) {
#line 88
      ((*log_error))(3U, "%s: write failed %s", "nextstate", estr);
#line 88
      break;
    }
  }
#line 90
  return;
}
}
#line 96 "state.c"
void expire_cleanup(void *arg ) 
{ pthread_t thid ;
  pthread_t tmp ;
  struct expire_args *ec ;
  struct autofs_point *ap ;
  int statefd ;
  int success ;
  enum states next ;
  int _st_lock ;
  int tmp___0 ;
  int rv ;
  int idle ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int _st_unlock ;
  int tmp___3 ;

  {
#line 98
  tmp = pthread_self();
#line 98
  thid = tmp;
#line 102
  next = (enum states )-1;
#line 104
  ec = (struct expire_args *)arg;
#line 105
  ap = ec->ap;
#line 106
  success = ec->status;
#line 108
  while (1) {
#line 108
    tmp___0 = pthread_mutex_lock(& ap->state_mutex);
#line 108
    _st_lock = tmp___0;
#line 108
    if (_st_lock) {
#line 108
      while (1) {
#line 108
        if (_st_lock == 35) {
#line 108
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "expire_cleanup", 108, "state.c");
#line 108
          dump_core();
        }
#line 108
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_lock, 108,
                      "state.c");
#line 108
        abort();
#line 108
        break;
      }
    }
#line 108
    break;
  }
#line 110
  while (1) {
#line 110
    ((*log_debug))(ap->logopt, "%s: got thid %lu path %s stat %d", "expire_cleanup",
                   thid, ap->path, success);
#line 110
    break;
  }
#line 114
  statefd = ap->state_pipe[1];
#line 117
  if (thid == ap->exp_thread) {
#line 118
    ap->exp_thread = 0UL;
#line 120
    switch ((int )ap->state) {
    case 2: 
    case 3: 
#line 137
    if (ap->submount) {
#line 137
      if (! success) {
#line 140
        if (sizeof(int ) == sizeof(int [1])) {
#line 140
          if (sizeof(int ) < 16384U) {
#line 140
            tmp___1 = sizeof(int );
          } else {
#line 140
            tmp___1 = __invalid_size_argument_for_IOC;
          }
        } else {
#line 140
          tmp___1 = __invalid_size_argument_for_IOC;
        }
#line 140
        rv = ioctl(ap->ioctlfd, (unsigned long )(2147521392U | (tmp___1 << 16)), & idle);
#line 141
        if (! rv) {
#line 141
          if (idle) {
#line 141
            if (ap->submount > 1U) {
#line 142
              next = (enum states )5;
#line 143
              break;
            }
          }
        }
#line 146
        tmp___2 = ap->submount;
#line 146
        ap->submount ++;
#line 146
        if (tmp___2 == 0U) {
#line 147
          ap->submount = 2U;
        }
      }
    }
#line 150
    if (! ap->submount) {
#line 151
      alarm_add(ap, ap->exp_runfreq);
    }
    case 1: 
#line 156
    next = (enum states )1;
#line 157
    break;
    case 5: 
#line 160
    next = (enum states )7;
#line 164
    if (success == 0) {
#line 165
      break;
    }
#line 168
    while (1) {
#line 168
      ((*log_warn))(ap->logopt, "%s: filesystem %s still busy", "expire_cleanup",
                    ap->path);
#line 168
      break;
    }
#line 169
    if (! ap->submount) {
#line 170
      alarm_add(ap, ap->exp_runfreq);
    }
#line 171
    next = (enum states )1;
#line 172
    break;
    case 6: 
#line 176
    next = (enum states )7;
#line 177
    break;
    default: ;
#line 180
    while (1) {
#line 180
      ((*log_error))(ap->logopt, "%s: bad state %d", "expire_cleanup", ap->state);
#line 180
      break;
    }
    }
#line 183
    if ((int )next != -1) {
#line 184
      while (1) {
#line 184
        ((*log_debug))(ap->logopt, "%s: sigchld: exp %lu finished, switching from %d to %d",
                       "expire_cleanup", thid, ap->state, next);
#line 184
        break;
      }
    }
  }
#line 190
  if ((int )next != -1) {
#line 191
    nextstate(statefd, next);
  }
#line 193
  st_set_done(ap);
#line 195
  while (1) {
#line 195
    tmp___3 = pthread_mutex_unlock(& ap->state_mutex);
#line 195
    _st_unlock = tmp___3;
#line 195
    if (_st_unlock) {
#line 195
      while (1) {
#line 195
        if (_st_unlock == 35) {
#line 195
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "expire_cleanup", 195, "state.c");
#line 195
          dump_core();
        }
#line 195
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_unlock,
                      195, "state.c");
#line 195
        abort();
#line 195
        break;
      }
    }
#line 195
    break;
  }
#line 197
  return;
}
}
#line 200 "state.c"
static unsigned int st_ready(struct autofs_point *ap ) 
{ 

  {
#line 202
  while (1) {
#line 202
    ((*log_debug))(ap->logopt, "%s: st_ready(): state = %d path %s", "st_ready", ap->state,
                   ap->path);
#line 202
    break;
  }
#line 205
  ap->state = (enum states )1;
#line 207
  if (ap->submount) {
#line 208
    master_signal_submount(ap, 1U);
  }
#line 210
  return (1U);
}
}
#line 228 "state.c"
void expire_proc_cleanup(void *arg ) 
{ struct expire_args *ea ;
  int status ;

  {
#line 233
  ea = (struct expire_args *)arg;
#line 235
  status = pthread_mutex_unlock(& ea->mutex);
#line 236
  if (status) {
#line 237
    while (1) {
#line 237
      if (status == 35) {
#line 237
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "expire_proc_cleanup", 237, "state.c");
#line 237
        dump_core();
      }
#line 237
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 237,
                    "state.c");
#line 237
      abort();
#line 237
      break;
    }
  }
#line 239
  status = pthread_cond_destroy(& ea->cond);
#line 240
  if (status) {
#line 241
    while (1) {
#line 241
      if (status == 35) {
#line 241
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "expire_proc_cleanup", 241, "state.c");
#line 241
        dump_core();
      }
#line 241
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 241,
                    "state.c");
#line 241
      abort();
#line 241
      break;
    }
  }
#line 243
  status = pthread_mutex_destroy(& ea->mutex);
#line 244
  if (status) {
#line 245
    while (1) {
#line 245
      if (status == 35) {
#line 245
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "expire_proc_cleanup", 245, "state.c");
#line 245
        dump_core();
      }
#line 245
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 245,
                    "state.c");
#line 245
      abort();
#line 245
      break;
    }
  }
#line 247
  free((void *)ea);
#line 249
  return;
}
}
#line 252 "state.c"
static enum expire expire_proc(struct autofs_point *ap , int now ) 
{ pthread_t thid ;
  struct expire_args *ea ;
  void *(*expire)(void * ) ;
  int status ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp ;
  long tmp___0 ;

  {
#line 259
  while (1) {
#line 259
    if (! (ap->exp_thread == 0UL)) {
#line 259
      ((*log_crit))(3U, "state.c:%d: assertion failed: ap->exp_thread == 0", 259);
    }
#line 259
    break;
  }
#line 261
  ea = (struct expire_args *)malloc(sizeof(struct expire_args ));
#line 262
  if (! ea) {
#line 263
    while (1) {
#line 263
      ((*log_error))(ap->logopt, "%s: failed to malloc expire cond struct", "expire_proc");
#line 263
      break;
    }
#line 264
    return ((enum expire )0);
  }
#line 267
  status = pthread_mutex_init(& ea->mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 268
  if (status) {
#line 269
    while (1) {
#line 269
      if (status == 35) {
#line 269
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "expire_proc", 269, "state.c");
#line 269
        dump_core();
      }
#line 269
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 269,
                    "state.c");
#line 269
      abort();
#line 269
      break;
    }
  }
#line 271
  status = pthread_cond_init((pthread_cond_t * __restrict  )(& ea->cond), (pthread_condattr_t const   * __restrict  )((void *)0));
#line 272
  if (status) {
#line 273
    while (1) {
#line 273
      if (status == 35) {
#line 273
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "expire_proc", 273, "state.c");
#line 273
        dump_core();
      }
#line 273
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 273,
                    "state.c");
#line 273
      abort();
#line 273
      break;
    }
  }
#line 275
  status = pthread_mutex_lock(& ea->mutex);
#line 276
  if (status) {
#line 277
    while (1) {
#line 277
      if (status == 35) {
#line 277
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "expire_proc", 277, "state.c");
#line 277
        dump_core();
      }
#line 277
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 277,
                    "state.c");
#line 277
      abort();
#line 277
      break;
    }
  }
#line 279
  ea->ap = ap;
#line 280
  ea->when = (unsigned int )now;
#line 281
  ea->status = 1;
#line 283
  if (ap->type == 2U) {
#line 284
    expire = & expire_proc_indirect;
  } else {
#line 286
    expire = & expire_proc_direct;
  }
#line 288
  status = pthread_create((pthread_t * __restrict  )(& thid), (pthread_attr_t const   * __restrict  )(& thread_attr),
                          expire, (void * __restrict  )ea);
#line 289
  if (status) {
#line 290
    while (1) {
#line 290
      ((*log_error))(ap->logopt, "%s: expire thread create for %s failed", "expire_proc",
                     ap->path);
#line 290
      break;
    }
#line 292
    expire_proc_cleanup((void *)ea);
#line 293
    free((void *)ea);
#line 294
    return ((enum expire )0);
  }
#line 296
  ap->exp_thread = thid;
#line 297
  st_set_thid(ap, thid);
#line 299
  while (1) {
#line 299
    __cancel_routine = & expire_proc_cleanup;
#line 299
    __cancel_arg = (void *)ea;
#line 299
    tmp = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf), 0);
#line 299
    not_first_call = tmp;
#line 299
    tmp___0 = __builtin_expect((long )not_first_call, 0L);
#line 299
    if (tmp___0) {
#line 299
      ((*__cancel_routine))(__cancel_arg);
#line 299
      __pthread_unwind_next(& __cancel_buf);
    }
#line 299
    __pthread_register_cancel(& __cancel_buf);
#line 299
    while (1) {
#line 301
      while (1) {
#line 301
        ((*log_debug))(ap->logopt, "%s: exp_proc = %lu path %s", "expire_proc", ap->exp_thread,
                       ap->path);
#line 301
        break;
      }
#line 304
      ea->signaled = 0U;
#line 305
      while (! ea->signaled) {
#line 306
        status = pthread_cond_wait((pthread_cond_t * __restrict  )(& ea->cond), (pthread_mutex_t * __restrict  )(& ea->mutex));
#line 307
        if (status) {
#line 308
          while (1) {
#line 308
            if (status == 35) {
#line 308
              ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                            "expire_proc", 308, "state.c");
#line 308
              dump_core();
            }
#line 308
            ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status,
                          308, "state.c");
#line 308
            abort();
#line 308
            break;
          }
        }
      }
#line 299
      break;
    }
#line 311
    __pthread_unregister_cancel(& __cancel_buf);
#line 311
    ((*__cancel_routine))(__cancel_arg);
#line 299
    break;
  }
#line 313
  return ((enum expire )1);
}
}
#line 316 "state.c"
static void do_readmap_cleanup(void *arg ) 
{ struct readmap_args *ra ;
  struct autofs_point *ap ;
  int _st_lock ;
  int tmp ;
  int _st_unlock ;
  int tmp___0 ;

  {
#line 321
  ra = (struct readmap_args *)arg;
#line 323
  ap = ra->ap;
#line 324
  ap->readmap_thread = 0UL;
#line 326
  while (1) {
#line 326
    tmp = pthread_mutex_lock(& ap->state_mutex);
#line 326
    _st_lock = tmp;
#line 326
    if (_st_lock) {
#line 326
      while (1) {
#line 326
        if (_st_lock == 35) {
#line 326
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "do_readmap_cleanup", 326, "state.c");
#line 326
          dump_core();
        }
#line 326
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_lock, 326,
                      "state.c");
#line 326
        abort();
#line 326
        break;
      }
    }
#line 326
    break;
  }
#line 328
  nextstate(ap->state_pipe[1], (enum states )1);
#line 329
  st_set_done(ap);
#line 331
  while (1) {
#line 331
    tmp___0 = pthread_mutex_unlock(& ap->state_mutex);
#line 331
    _st_unlock = tmp___0;
#line 331
    if (_st_unlock) {
#line 331
      while (1) {
#line 331
        if (_st_unlock == 35) {
#line 331
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "do_readmap_cleanup", 331, "state.c");
#line 331
          dump_core();
        }
#line 331
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_unlock,
                      331, "state.c");
#line 331
        abort();
#line 331
        break;
      }
    }
#line 331
    break;
  }
#line 333
  if (! ap->submount) {
#line 334
    alarm_add(ap, ap->exp_runfreq);
  }
#line 336
  free((void *)ra);
#line 338
  return;
}
}
#line 341 "state.c"
static void tree_mnts_cleanup(void *arg ) 
{ struct mnt_list *mnts ;

  {
#line 343
  mnts = (struct mnt_list *)arg;
#line 344
  tree_free_mnt_tree(mnts);
#line 345
  return;
}
}
#line 348 "state.c"
static void *do_readmap(void *arg ) 
{ struct autofs_point *ap ;
  struct map_source *map ;
  struct mapent_cache *nc ;
  struct mapent_cache *mc ;
  struct readmap_args *ra ;
  struct mnt_list *mnts ;
  int status ;
  time_t now ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp ;
  long tmp___0 ;
  struct mapent *me ;
  struct mapent *ne ;
  struct mapent *nested ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___0)(void * ) ;
  void *__cancel_arg___0 ;
  int not_first_call___0 ;
  int tmp___1 ;
  long tmp___2 ;
  __pthread_unwind_buf_t __cancel_buf___1 ;
  void (*__cancel_routine___1)(void * ) ;
  void *__cancel_arg___1 ;
  int not_first_call___1 ;
  int tmp___3 ;
  long tmp___4 ;
  __pthread_unwind_buf_t __cancel_buf___2 ;
  void (*__cancel_routine___2)(void * ) ;
  void *__cancel_arg___2 ;
  int not_first_call___2 ;
  int tmp___5 ;
  long tmp___6 ;
  __pthread_unwind_buf_t __cancel_buf___3 ;
  void (*__cancel_routine___3)(void * ) ;
  void *__cancel_arg___3 ;
  int not_first_call___3 ;
  int tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;

  {
#line 358
  ra = (struct readmap_args *)arg;
#line 360
  status = pthread_mutex_lock(& ra->mutex);
#line 361
  if (status) {
#line 362
    while (1) {
#line 362
      if (status == 35) {
#line 362
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "do_readmap", 362, "state.c");
#line 362
        dump_core();
      }
#line 362
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 362,
                    "state.c");
#line 362
      abort();
#line 362
      break;
    }
  }
#line 364
  ap = ra->ap;
#line 365
  now = ra->now;
#line 367
  ra->signaled = 1U;
#line 368
  status = pthread_cond_signal(& ra->cond);
#line 369
  if (status) {
#line 370
    while (1) {
#line 370
      ((*log_error))(ap->logopt, "%s: failed to signal expire condition", "do_readmap");
#line 370
      break;
    }
#line 371
    pthread_mutex_unlock(& ra->mutex);
#line 372
    while (1) {
#line 372
      if (status == 35) {
#line 372
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "do_readmap", 372, "state.c");
#line 372
        dump_core();
      }
#line 372
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 372,
                    "state.c");
#line 372
      abort();
#line 372
      break;
    }
  }
#line 375
  status = pthread_mutex_unlock(& ra->mutex);
#line 376
  if (status) {
#line 377
    while (1) {
#line 377
      if (status == 35) {
#line 377
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "do_readmap", 377, "state.c");
#line 377
        dump_core();
      }
#line 377
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 377,
                    "state.c");
#line 377
      abort();
#line 377
      break;
    }
  }
#line 379
  while (1) {
#line 379
    __cancel_routine = & do_readmap_cleanup;
#line 379
    __cancel_arg = (void *)ra;
#line 379
    tmp = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf), 0);
#line 379
    not_first_call = tmp;
#line 379
    tmp___0 = __builtin_expect((long )not_first_call, 0L);
#line 379
    if (tmp___0) {
#line 379
      ((*__cancel_routine))(__cancel_arg);
#line 379
      __pthread_unwind_next(& __cancel_buf);
    }
#line 379
    __pthread_register_cancel(& __cancel_buf);
#line 379
    while (1) {
#line 381
      status = lookup_nss_read_map(ap, (struct map_source *)((void *)0), now);
#line 382
      if (! status) {
#line 383
        pthread_exit((void *)0);
      }
#line 385
      if (ap->type == 2U) {
#line 386
        lookup_prune_cache(ap, now);
#line 387
        status = lookup_ghost(ap);
      } else {
#line 390
        mnts = tree_make_mnt_tree("/proc/mounts", "/");
#line 391
        while (1) {
#line 391
          __cancel_routine___0 = & tree_mnts_cleanup;
#line 391
          __cancel_arg___0 = (void *)mnts;
#line 391
          tmp___1 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf),
                                0);
#line 391
          not_first_call___0 = tmp___1;
#line 391
          tmp___2 = __builtin_expect((long )not_first_call___0, 0L);
#line 391
          if (tmp___2) {
#line 391
            ((*__cancel_routine___0))(__cancel_arg___0);
#line 391
            __pthread_unwind_next(& __cancel_buf___0);
          }
#line 391
          __pthread_register_cancel(& __cancel_buf___0);
#line 391
          while (1) {
#line 392
            while (1) {
#line 392
              __cancel_routine___1 = & master_source_lock_cleanup;
#line 392
              __cancel_arg___1 = (void *)ap->entry;
#line 392
              tmp___3 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___1.__cancel_jmp_buf),
                                    0);
#line 392
              not_first_call___1 = tmp___3;
#line 392
              tmp___4 = __builtin_expect((long )not_first_call___1, 0L);
#line 392
              if (tmp___4) {
#line 392
                ((*__cancel_routine___1))(__cancel_arg___1);
#line 392
                __pthread_unwind_next(& __cancel_buf___1);
              }
#line 392
              __pthread_register_cancel(& __cancel_buf___1);
#line 392
              while (1) {
#line 393
                master_source_readlock(ap->entry);
#line 394
                nc = ((ap->entry)->master)->nc;
#line 395
                cache_readlock(nc);
#line 396
                while (1) {
#line 396
                  __cancel_routine___2 = & cache_lock_cleanup;
#line 396
                  __cancel_arg___2 = (void *)nc;
#line 396
                  tmp___5 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___2.__cancel_jmp_buf),
                                        0);
#line 396
                  not_first_call___2 = tmp___5;
#line 396
                  tmp___6 = __builtin_expect((long )not_first_call___2, 0L);
#line 396
                  if (tmp___6) {
#line 396
                    ((*__cancel_routine___2))(__cancel_arg___2);
#line 396
                    __pthread_unwind_next(& __cancel_buf___2);
                  }
#line 396
                  __pthread_register_cancel(& __cancel_buf___2);
#line 396
                  while (1) {
#line 397
                    map = (ap->entry)->maps;
#line 398
                    while (map) {
#line 400
                      if (! map->stale) {
#line 401
                        map = map->next;
#line 402
                        continue;
                      }
#line 404
                      mc = map->mc;
#line 405
                      while (1) {
#line 405
                        __cancel_routine___3 = & cache_lock_cleanup;
#line 405
                        __cancel_arg___3 = (void *)mc;
#line 405
                        tmp___7 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___3.__cancel_jmp_buf),
                                              0);
#line 405
                        not_first_call___3 = tmp___7;
#line 405
                        tmp___8 = __builtin_expect((long )not_first_call___3, 0L);
#line 405
                        if (tmp___8) {
#line 405
                          ((*__cancel_routine___3))(__cancel_arg___3);
#line 405
                          __pthread_unwind_next(& __cancel_buf___3);
                        }
#line 405
                        __pthread_register_cancel(& __cancel_buf___3);
#line 405
                        while (1) {
#line 406
                          cache_readlock(mc);
#line 407
                          me = cache_enumerate(mc, (struct mapent *)((void *)0));
#line 408
                          while (me) {
#line 409
                            ne = cache_lookup_distinct(nc, (char const   *)me->key);
#line 410
                            if (! ne) {
#line 411
                              nested = cache_partial_match(nc, (char const   *)me->key);
#line 412
                              if (nested) {
#line 413
                                while (1) {
#line 413
                                  ((*log_error))(ap->logopt, "%s: removing invalid nested null entry %s",
                                                 "do_readmap", nested->key);
#line 413
                                  break;
                                }
#line 416
                                nested = cache_partial_match(nc, (char const   *)me->key);
#line 417
                                if (nested) {
#line 418
                                  cache_delete(nc, (char const   *)nested->key);
                                }
                              }
                            }
#line 423
                            if (me->age < now) {
                              goto _L;
                            } else {
#line 423
                              if (ne) {
#line 423
                                if ((unsigned long )map->master_line > (unsigned long )ne->age) {
                                  _L: 
#line 424
                                  tmp___9 = tree_is_mounted(mnts, (char const   *)me->key,
                                                            2U);
#line 424
                                  if (tmp___9) {
#line 427
                                    while (1) {
#line 427
                                      ((*log_debug))(ap->logopt, "%s: %s is mounted",
                                                     "do_readmap", me->key);
#line 427
                                      break;
                                    }
                                  } else {
#line 425
                                    do_umount_autofs_direct(ap, mnts, me);
                                  }
                                } else {
#line 430
                                  do_mount_autofs_direct(ap, mnts, me);
                                }
                              } else {
#line 430
                                do_mount_autofs_direct(ap, mnts, me);
                              }
                            }
#line 432
                            me = cache_enumerate(mc, me);
                          }
#line 405
                          break;
                        }
#line 434
                        __pthread_unregister_cancel(& __cancel_buf___3);
#line 434
                        ((*__cancel_routine___3))(__cancel_arg___3);
#line 405
                        break;
                      }
#line 435
                      map = map->next;
                    }
#line 396
                    break;
                  }
#line 437
                  __pthread_unregister_cancel(& __cancel_buf___2);
#line 437
                  ((*__cancel_routine___2))(__cancel_arg___2);
#line 396
                  break;
                }
#line 392
                break;
              }
#line 438
              __pthread_unregister_cancel(& __cancel_buf___1);
#line 438
              ((*__cancel_routine___1))(__cancel_arg___1);
#line 392
              break;
            }
#line 391
            break;
          }
#line 439
          __pthread_unregister_cancel(& __cancel_buf___0);
#line 439
          ((*__cancel_routine___0))(__cancel_arg___0);
#line 391
          break;
        }
#line 440
        lookup_prune_cache(ap, now);
      }
#line 379
      break;
    }
#line 443
    __pthread_unregister_cancel(& __cancel_buf);
#line 443
    ((*__cancel_routine))(__cancel_arg);
#line 379
    break;
  }
#line 445
  return ((void *)0);
}
}
#line 448 "state.c"
static void st_readmap_cleanup(void *arg ) 
{ struct readmap_args *ra ;
  int status ;

  {
#line 453
  ra = (struct readmap_args *)arg;
#line 455
  status = pthread_mutex_unlock(& ra->mutex);
#line 456
  if (status) {
#line 457
    while (1) {
#line 457
      if (status == 35) {
#line 457
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "st_readmap_cleanup", 457, "state.c");
#line 457
        dump_core();
      }
#line 457
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 457,
                    "state.c");
#line 457
      abort();
#line 457
      break;
    }
  }
#line 459
  status = pthread_cond_destroy(& ra->cond);
#line 460
  if (status) {
#line 461
    while (1) {
#line 461
      if (status == 35) {
#line 461
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "st_readmap_cleanup", 461, "state.c");
#line 461
        dump_core();
      }
#line 461
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 461,
                    "state.c");
#line 461
      abort();
#line 461
      break;
    }
  }
#line 463
  status = pthread_mutex_destroy(& ra->mutex);
#line 464
  if (status) {
#line 465
    while (1) {
#line 465
      if (status == 35) {
#line 465
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "st_readmap_cleanup", 465, "state.c");
#line 465
        dump_core();
      }
#line 465
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 465,
                    "state.c");
#line 465
      abort();
#line 465
      break;
    }
  }
#line 467
  return;
}
}
#line 470 "state.c"
static unsigned int st_readmap(struct autofs_point *ap ) 
{ pthread_t thid ;
  struct readmap_args *ra ;
  int status ;
  int now ;
  int tmp ;
  int _st_lock ;
  int tmp___0 ;
  int _st_unlock ;
  int tmp___1 ;
  int _st_lock___0 ;
  int tmp___2 ;
  int _st_unlock___0 ;
  int tmp___3 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___4 ;
  long tmp___5 ;

  {
#line 475
  tmp = (int )time((time_t *)((void *)0));
#line 475
  now = tmp;
#line 477
  while (1) {
#line 477
    ((*log_debug))(ap->logopt, "%s: state %d path %s", "st_readmap", ap->state, ap->path);
#line 477
    break;
  }
#line 479
  while (1) {
#line 479
    if (! ((int )ap->state == 1)) {
#line 479
      ((*log_crit))(3U, "state.c:%d: assertion failed: ap->state == ST_READY", 479);
    }
#line 479
    break;
  }
#line 480
  while (1) {
#line 480
    if (! (ap->readmap_thread == 0UL)) {
#line 480
      ((*log_crit))(3U, "state.c:%d: assertion failed: ap->readmap_thread == 0", 480);
    }
#line 480
    break;
  }
#line 482
  ap->state = (enum states )4;
#line 484
  ra = (struct readmap_args *)malloc(sizeof(struct readmap_args ));
#line 485
  if (! ra) {
#line 486
    while (1) {
#line 486
      ((*log_error))(ap->logopt, "%s: failed to malloc reamap cond struct", "st_readmap");
#line 486
      break;
    }
#line 487
    while (1) {
#line 487
      tmp___0 = pthread_mutex_lock(& ap->state_mutex);
#line 487
      _st_lock = tmp___0;
#line 487
      if (_st_lock) {
#line 487
        while (1) {
#line 487
          if (_st_lock == 35) {
#line 487
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "st_readmap", 487, "state.c");
#line 487
            dump_core();
          }
#line 487
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_lock,
                        487, "state.c");
#line 487
          abort();
#line 487
          break;
        }
      }
#line 487
      break;
    }
#line 488
    nextstate(ap->state_pipe[1], (enum states )1);
#line 489
    while (1) {
#line 489
      tmp___1 = pthread_mutex_unlock(& ap->state_mutex);
#line 489
      _st_unlock = tmp___1;
#line 489
      if (_st_unlock) {
#line 489
        while (1) {
#line 489
          if (_st_unlock == 35) {
#line 489
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "st_readmap", 489, "state.c");
#line 489
            dump_core();
          }
#line 489
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_unlock,
                        489, "state.c");
#line 489
          abort();
#line 489
          break;
        }
      }
#line 489
      break;
    }
#line 491
    if (! ap->submount) {
#line 492
      alarm_add(ap, ap->exp_runfreq);
    }
#line 493
    return (0U);
  }
#line 496
  status = pthread_mutex_init(& ra->mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 497
  if (status) {
#line 498
    while (1) {
#line 498
      if (status == 35) {
#line 498
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "st_readmap", 498, "state.c");
#line 498
        dump_core();
      }
#line 498
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 498,
                    "state.c");
#line 498
      abort();
#line 498
      break;
    }
  }
#line 500
  status = pthread_cond_init((pthread_cond_t * __restrict  )(& ra->cond), (pthread_condattr_t const   * __restrict  )((void *)0));
#line 501
  if (status) {
#line 502
    while (1) {
#line 502
      if (status == 35) {
#line 502
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "st_readmap", 502, "state.c");
#line 502
        dump_core();
      }
#line 502
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 502,
                    "state.c");
#line 502
      abort();
#line 502
      break;
    }
  }
#line 504
  status = pthread_mutex_lock(& ra->mutex);
#line 505
  if (status) {
#line 506
    while (1) {
#line 506
      if (status == 35) {
#line 506
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "st_readmap", 506, "state.c");
#line 506
        dump_core();
      }
#line 506
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 506,
                    "state.c");
#line 506
      abort();
#line 506
      break;
    }
  }
#line 508
  ra->ap = ap;
#line 509
  ra->now = (long )now;
#line 511
  status = pthread_create((pthread_t * __restrict  )(& thid), (pthread_attr_t const   * __restrict  )(& thread_attr),
                          & do_readmap, (void * __restrict  )ra);
#line 512
  if (status) {
#line 513
    while (1) {
#line 513
      ((*log_error))(ap->logopt, "%s: read map thread create failed", "st_readmap");
#line 513
      break;
    }
#line 514
    st_readmap_cleanup((void *)ra);
#line 515
    free((void *)ra);
#line 516
    while (1) {
#line 516
      tmp___2 = pthread_mutex_lock(& ap->state_mutex);
#line 516
      _st_lock___0 = tmp___2;
#line 516
      if (_st_lock___0) {
#line 516
        while (1) {
#line 516
          if (_st_lock___0 == 35) {
#line 516
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "st_readmap", 516, "state.c");
#line 516
            dump_core();
          }
#line 516
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_lock___0,
                        516, "state.c");
#line 516
          abort();
#line 516
          break;
        }
      }
#line 516
      break;
    }
#line 517
    nextstate(ap->state_pipe[1], (enum states )1);
#line 518
    while (1) {
#line 518
      tmp___3 = pthread_mutex_unlock(& ap->state_mutex);
#line 518
      _st_unlock___0 = tmp___3;
#line 518
      if (_st_unlock___0) {
#line 518
        while (1) {
#line 518
          if (_st_unlock___0 == 35) {
#line 518
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "st_readmap", 518, "state.c");
#line 518
            dump_core();
          }
#line 518
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_unlock___0,
                        518, "state.c");
#line 518
          abort();
#line 518
          break;
        }
      }
#line 518
      break;
    }
#line 520
    if (! ap->submount) {
#line 521
      alarm_add(ap, ap->exp_runfreq);
    }
#line 522
    return (0U);
  }
#line 524
  ap->readmap_thread = thid;
#line 525
  st_set_thid(ap, thid);
#line 527
  while (1) {
#line 527
    __cancel_routine = & st_readmap_cleanup;
#line 527
    __cancel_arg = (void *)ra;
#line 527
    tmp___4 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
#line 527
    not_first_call = tmp___4;
#line 527
    tmp___5 = __builtin_expect((long )not_first_call, 0L);
#line 527
    if (tmp___5) {
#line 527
      ((*__cancel_routine))(__cancel_arg);
#line 527
      __pthread_unwind_next(& __cancel_buf);
    }
#line 527
    __pthread_register_cancel(& __cancel_buf);
#line 527
    while (1) {
#line 529
      ra->signaled = 0U;
#line 530
      while (! ra->signaled) {
#line 531
        status = pthread_cond_wait((pthread_cond_t * __restrict  )(& ra->cond), (pthread_mutex_t * __restrict  )(& ra->mutex));
#line 532
        if (status) {
#line 533
          while (1) {
#line 533
            if (status == 35) {
#line 533
              ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                            "st_readmap", 533, "state.c");
#line 533
              dump_core();
            }
#line 533
            ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status,
                          533, "state.c");
#line 533
            abort();
#line 533
            break;
          }
        }
      }
#line 527
      break;
    }
#line 536
    __pthread_unregister_cancel(& __cancel_buf);
#line 536
    ((*__cancel_routine))(__cancel_arg);
#line 527
    break;
  }
#line 538
  return (1U);
}
}
#line 541 "state.c"
static unsigned int st_prepare_shutdown(struct autofs_point *ap ) 
{ int exp ;

  {
#line 545
  while (1) {
#line 545
    ((*log_debug))(ap->logopt, "%s: state %d path %s", "st_prepare_shutdown", ap->state,
                   ap->path);
#line 545
    break;
  }
#line 547
  while (1) {
#line 547
    if (! ((int )ap->state == 1)) {
#line 547
      if (! ((int )ap->state == 2)) {
#line 547
        ((*log_crit))(3U, "state.c:%d: assertion failed: ap->state == ST_READY || ap->state == ST_EXPIRE",
                      547);
      }
    }
#line 547
    break;
  }
#line 548
  ap->state = (enum states )5;
#line 551
  exp = (int )expire_proc(ap, 1);
#line 552
  switch (exp) {
  case 0: 
  case 2: 
#line 556
  if (! ap->submount) {
#line 557
    alarm_add(ap, ap->exp_runfreq);
  }
#line 558
  nextstate(ap->state_pipe[1], (enum states )1);
#line 559
  return (0U);
  case 1: 
#line 562
  return (1U);
  }
#line 564
  return (0U);
}
}
#line 567 "state.c"
static unsigned int st_force_shutdown(struct autofs_point *ap ) 
{ int exp ;

  {
#line 571
  while (1) {
#line 571
    ((*log_debug))(ap->logopt, "%s: state %d path %s", "st_force_shutdown", ap->state,
                   ap->path);
#line 571
    break;
  }
#line 573
  while (1) {
#line 573
    if (! ((int )ap->state == 1)) {
#line 573
      if (! ((int )ap->state == 2)) {
#line 573
        ((*log_crit))(3U, "state.c:%d: assertion failed: ap->state == ST_READY || ap->state == ST_EXPIRE",
                      573);
      }
    }
#line 573
    break;
  }
#line 574
  ap->state = (enum states )6;
#line 577
  exp = (int )expire_proc(ap, 1);
#line 578
  switch (exp) {
  case 0: 
  case 2: 
#line 582
  if (! ap->submount) {
#line 583
    alarm_add(ap, ap->exp_runfreq);
  }
#line 584
  nextstate(ap->state_pipe[1], (enum states )1);
#line 585
  return (0U);
  case 1: 
#line 588
  return (1U);
  }
#line 590
  return (0U);
}
}
#line 593 "state.c"
static unsigned int st_prune(struct autofs_point *ap ) 
{ int tmp ;

  {
#line 595
  while (1) {
#line 595
    ((*log_debug))(ap->logopt, "%s: state %d path %s", "st_prune", ap->state, ap->path);
#line 595
    break;
  }
#line 597
  while (1) {
#line 597
    if (! ((int )ap->state == 1)) {
#line 597
      ((*log_crit))(3U, "state.c:%d: assertion failed: ap->state == ST_READY", 597);
    }
#line 597
    break;
  }
#line 598
  ap->state = (enum states )3;
#line 600
  tmp = (int )expire_proc(ap, 1);
#line 600
  switch (tmp) {
  case 0: 
  case 2: 
#line 603
  if (! ap->submount) {
#line 604
    alarm_add(ap, ap->exp_runfreq);
  }
#line 605
  nextstate(ap->state_pipe[1], (enum states )1);
#line 606
  return (0U);
  case 1: 
#line 609
  return (1U);
  }
#line 611
  return (0U);
}
}
#line 614 "state.c"
static unsigned int st_expire(struct autofs_point *ap ) 
{ int tmp ;

  {
#line 616
  while (1) {
#line 616
    ((*log_debug))(ap->logopt, "%s: state %d path %s", "st_expire", ap->state, ap->path);
#line 616
    break;
  }
#line 618
  while (1) {
#line 618
    if (! ((int )ap->state == 1)) {
#line 618
      ((*log_crit))(3U, "state.c:%d: assertion failed: ap->state == ST_READY", 618);
    }
#line 618
    break;
  }
#line 619
  ap->state = (enum states )2;
#line 621
  tmp = (int )expire_proc(ap, 0);
#line 621
  switch (tmp) {
  case 0: 
  case 2: 
#line 624
  if (! ap->submount) {
#line 625
    alarm_add(ap, ap->exp_runfreq);
  }
#line 626
  nextstate(ap->state_pipe[1], (enum states )1);
#line 627
  return (0U);
  case 1: 
#line 630
  return (1U);
  }
#line 632
  return (0U);
}
}
#line 635 "state.c"
static struct state_queue *st_alloc_task(struct autofs_point *ap , enum states state ) 
{ struct state_queue *task ;

  {
#line 639
  task = (struct state_queue *)malloc(sizeof(struct state_queue ));
#line 640
  if (! task) {
#line 641
    return ((struct state_queue *)((void *)0));
  }
#line 642
  memset((void *)task, 0, sizeof(struct state_queue ));
#line 644
  task->ap = ap;
#line 645
  task->state = state;
#line 647
  while (1) {
#line 647
    task->list.next = & task->list;
#line 647
    task->list.prev = & task->list;
#line 647
    break;
  }
#line 648
  while (1) {
#line 648
    task->pending.next = & task->pending;
#line 648
    task->pending.prev = & task->pending;
#line 648
    break;
  }
#line 650
  return (task);
}
}
#line 654 "state.c"
int st_add_task(struct autofs_point *ap , enum states state ) 
{ struct list_head *head ;
  struct list_head *p ;
  struct list_head *q ;
  struct state_queue *new ;
  enum states ap_state ;
  unsigned int empty ;
  int status ;
  int _st_lock ;
  int tmp ;
  int _st_unlock ;
  int tmp___0 ;
  int status___0 ;
  int tmp___1 ;
  int status___1 ;
  int tmp___2 ;
  int _st_lock___0 ;
  int tmp___3 ;
  int _st_unlock___0 ;
  int tmp___4 ;
  int _st_unlock___1 ;
  int tmp___5 ;
  int status___2 ;
  int tmp___6 ;
  struct state_queue *task ;
  int tmp___7 ;
  struct state_queue *p_task ;
  int status___3 ;
  int tmp___8 ;

  {
#line 660
  empty = 1U;
#line 664
  if ((int )state == 1) {
#line 665
    while (1) {
#line 665
      tmp = pthread_mutex_lock(& ap->state_mutex);
#line 665
      _st_lock = tmp;
#line 665
      if (_st_lock) {
#line 665
        while (1) {
#line 665
          if (_st_lock == 35) {
#line 665
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "st_add_task", 665, "state.c");
#line 665
            dump_core();
          }
#line 665
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_lock,
                        665, "state.c");
#line 665
          abort();
#line 665
          break;
        }
      }
#line 665
      break;
    }
#line 666
    st_ready(ap);
#line 667
    while (1) {
#line 667
      tmp___0 = pthread_mutex_unlock(& ap->state_mutex);
#line 667
      _st_unlock = tmp___0;
#line 667
      if (_st_unlock) {
#line 667
        while (1) {
#line 667
          if (_st_unlock == 35) {
#line 667
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "st_add_task", 667, "state.c");
#line 667
            dump_core();
          }
#line 667
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_unlock,
                        667, "state.c");
#line 667
          abort();
#line 667
          break;
        }
      }
#line 667
      break;
    }
#line 669
    while (1) {
#line 669
      tmp___1 = pthread_mutex_lock(& mutex);
#line 669
      status___0 = tmp___1;
#line 669
      if (status___0) {
#line 669
        while (1) {
#line 669
          if (status___0 == 35) {
#line 669
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "st_add_task", 669, "state.c");
#line 669
            dump_core();
          }
#line 669
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status___0,
                        669, "state.c");
#line 669
          abort();
#line 669
          break;
        }
      }
#line 669
      break;
    }
#line 671
    signaled = 1U;
#line 672
    status = pthread_cond_signal(& cond);
#line 673
    if (status) {
#line 674
      while (1) {
#line 674
        if (status == 35) {
#line 674
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "st_add_task", 674, "state.c");
#line 674
          dump_core();
        }
#line 674
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 674,
                      "state.c");
#line 674
        abort();
#line 674
        break;
      }
    }
#line 676
    while (1) {
#line 676
      tmp___2 = pthread_mutex_unlock(& mutex);
#line 676
      status___1 = tmp___2;
#line 676
      if (status___1) {
#line 676
        while (1) {
#line 676
          if (status___1 == 35) {
#line 676
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "st_add_task", 676, "state.c");
#line 676
            dump_core();
          }
#line 676
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status___1,
                        676, "state.c");
#line 676
          abort();
#line 676
          break;
        }
      }
#line 676
      break;
    }
#line 678
    return (1);
  }
#line 681
  while (1) {
#line 681
    tmp___3 = pthread_mutex_lock(& ap->state_mutex);
#line 681
    _st_lock___0 = tmp___3;
#line 681
    if (_st_lock___0) {
#line 681
      while (1) {
#line 681
        if (_st_lock___0 == 35) {
#line 681
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "st_add_task", 681, "state.c");
#line 681
          dump_core();
        }
#line 681
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_lock___0,
                      681, "state.c");
#line 681
        abort();
#line 681
        break;
      }
    }
#line 681
    break;
  }
#line 682
  ap_state = ap->state;
#line 683
  if ((int )ap_state == 7) {
#line 684
    while (1) {
#line 684
      tmp___4 = pthread_mutex_unlock(& ap->state_mutex);
#line 684
      _st_unlock___0 = tmp___4;
#line 684
      if (_st_unlock___0) {
#line 684
        while (1) {
#line 684
          if (_st_unlock___0 == 35) {
#line 684
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "st_add_task", 684, "state.c");
#line 684
            dump_core();
          }
#line 684
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_unlock___0,
                        684, "state.c");
#line 684
          abort();
#line 684
          break;
        }
      }
#line 684
      break;
    }
#line 685
    return (1);
  }
#line 687
  while (1) {
#line 687
    tmp___5 = pthread_mutex_unlock(& ap->state_mutex);
#line 687
    _st_unlock___1 = tmp___5;
#line 687
    if (_st_unlock___1) {
#line 687
      while (1) {
#line 687
        if (_st_unlock___1 == 35) {
#line 687
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "st_add_task", 687, "state.c");
#line 687
          dump_core();
        }
#line 687
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_unlock___1,
                      687, "state.c");
#line 687
        abort();
#line 687
        break;
      }
    }
#line 687
    break;
  }
#line 689
  while (1) {
#line 689
    tmp___6 = pthread_mutex_lock(& mutex);
#line 689
    status___2 = tmp___6;
#line 689
    if (status___2) {
#line 689
      while (1) {
#line 689
        if (status___2 == 35) {
#line 689
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "st_add_task", 689, "state.c");
#line 689
          dump_core();
        }
#line 689
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status___2,
                      689, "state.c");
#line 689
        abort();
#line 689
        break;
      }
    }
#line 689
    break;
  }
#line 691
  head = & state_queue;
#line 694
  p = head->next;
#line 694
  while ((unsigned int )p != (unsigned int )head) {
#line 697
    task = (struct state_queue *)((char *)p - (unsigned long )(& ((struct state_queue *)0)->list));
#line 699
    if ((unsigned int )task->ap != (unsigned int )ap) {
      goto __Cont;
    }
#line 702
    empty = 0U;
#line 705
    if ((int )task->state == (int )state) {
#line 705
      if (! task->done) {
#line 708
        break;
      } else {
        goto _L;
      }
    } else {
      _L: 
#line 705
      if ((int )ap_state == 5) {
#line 708
        break;
      } else {
#line 705
        if ((int )ap_state == 6) {
#line 708
          break;
        }
      }
    }
#line 711
    tmp___7 = list_empty(& task->pending);
#line 711
    if (tmp___7) {
#line 712
      new = st_alloc_task(ap, state);
#line 713
      if (new) {
#line 714
        list_add_tail(& new->pending, & task->pending);
      }
      goto done;
    }
#line 718
    q = task->pending.next;
#line 718
    while ((unsigned int )q != (unsigned int )(& task->pending)) {
#line 721
      p_task = (struct state_queue *)((char *)q - (unsigned long )(& ((struct state_queue *)0)->pending));
#line 723
      if ((int )p_task->state == (int )state) {
        goto done;
      } else {
#line 723
        if ((int )ap_state == 5) {
          goto done;
        } else {
#line 723
          if ((int )ap_state == 6) {
            goto done;
          }
        }
      }
#line 718
      q = q->next;
    }
#line 729
    new = st_alloc_task(ap, state);
#line 730
    if (new) {
#line 731
      list_add_tail(& new->pending, & task->pending);
    }
    done: 
#line 733
    break;
    __Cont: 
#line 694
    p = p->next;
  }
#line 736
  if (empty) {
#line 737
    new = st_alloc_task(ap, state);
#line 738
    if (new) {
#line 739
      list_add(& new->list, head);
    }
  }
#line 743
  signaled = 1U;
#line 744
  status = pthread_cond_signal(& cond);
#line 745
  if (status) {
#line 746
    while (1) {
#line 746
      if (status == 35) {
#line 746
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "st_add_task", 746, "state.c");
#line 746
        dump_core();
      }
#line 746
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 746,
                    "state.c");
#line 746
      abort();
#line 746
      break;
    }
  }
#line 748
  while (1) {
#line 748
    tmp___8 = pthread_mutex_unlock(& mutex);
#line 748
    status___3 = tmp___8;
#line 748
    if (status___3) {
#line 748
      while (1) {
#line 748
        if (status___3 == 35) {
#line 748
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "st_add_task", 748, "state.c");
#line 748
          dump_core();
        }
#line 748
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status___3,
                      748, "state.c");
#line 748
        abort();
#line 748
        break;
      }
    }
#line 748
    break;
  }
#line 750
  return (1);
}
}
#line 753 "state.c"
void st_remove_tasks(struct autofs_point *ap ) 
{ struct list_head *head ;
  struct list_head *p ;
  struct list_head *q ;
  struct state_queue *task ;
  struct state_queue *waiting ;
  int status ;
  int status___0 ;
  int tmp ;
  int status___1 ;
  int tmp___0 ;
  int tmp___1 ;
  int status___2 ;
  int tmp___2 ;

  {
#line 760
  while (1) {
#line 760
    tmp = pthread_mutex_lock(& mutex);
#line 760
    status___0 = tmp;
#line 760
    if (status___0) {
#line 760
      while (1) {
#line 760
        if (status___0 == 35) {
#line 760
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "st_remove_tasks", 760, "state.c");
#line 760
          dump_core();
        }
#line 760
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status___0,
                      760, "state.c");
#line 760
        abort();
#line 760
        break;
      }
    }
#line 760
    break;
  }
#line 762
  head = & state_queue;
#line 764
  tmp___1 = list_empty(head);
#line 764
  if (tmp___1) {
#line 765
    while (1) {
#line 765
      tmp___0 = pthread_mutex_unlock(& mutex);
#line 765
      status___1 = tmp___0;
#line 765
      if (status___1) {
#line 765
        while (1) {
#line 765
          if (status___1 == 35) {
#line 765
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "st_remove_tasks", 765, "state.c");
#line 765
            dump_core();
          }
#line 765
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status___1,
                        765, "state.c");
#line 765
          abort();
#line 765
          break;
        }
      }
#line 765
      break;
    }
#line 766
    return;
  }
#line 769
  p = head->next;
#line 770
  while ((unsigned int )p != (unsigned int )head) {
#line 771
    task = (struct state_queue *)((char *)p - (unsigned long )(& ((struct state_queue *)0)->list));
#line 772
    p = p->next;
#line 774
    if ((unsigned int )task->ap != (unsigned int )ap) {
#line 775
      continue;
    }
#line 777
    if (task->busy) {
#line 779
      if ((int )task->state == 2) {
#line 782
        task->cancel = 1U;
      } else {
#line 779
        if ((int )task->state == 3) {
#line 782
          task->cancel = 1U;
        } else {
#line 779
          if ((int )task->state == 4) {
#line 782
            task->cancel = 1U;
          }
        }
      }
    }
#line 785
    q = task->pending.next;
#line 786
    while ((unsigned int )q != (unsigned int )(& task->pending)) {
#line 787
      waiting = (struct state_queue *)((char *)q - (unsigned long )(& ((struct state_queue *)0)->pending));
#line 788
      q = q->next;
#line 791
      if ((int )waiting->state != 5) {
#line 791
        if ((int )waiting->state != 6) {
#line 793
          list_del(& waiting->pending);
#line 794
          free((void *)waiting);
        }
      }
    }
  }
#line 799
  signaled = 1U;
#line 800
  status = pthread_cond_signal(& cond);
#line 801
  if (status) {
#line 802
    while (1) {
#line 802
      if (status == 35) {
#line 802
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "st_remove_tasks", 802, "state.c");
#line 802
        dump_core();
      }
#line 802
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 802,
                    "state.c");
#line 802
      abort();
#line 802
      break;
    }
  }
#line 804
  while (1) {
#line 804
    tmp___2 = pthread_mutex_unlock(& mutex);
#line 804
    status___2 = tmp___2;
#line 804
    if (status___2) {
#line 804
      while (1) {
#line 804
        if (status___2 == 35) {
#line 804
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "st_remove_tasks", 804, "state.c");
#line 804
          dump_core();
        }
#line 804
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status___2,
                      804, "state.c");
#line 804
        abort();
#line 804
        break;
      }
    }
#line 804
    break;
  }
#line 806
  return;
}
}
#line 810 "state.c"
static int run_state_task(struct state_queue *task ) 
{ struct autofs_point *ap ;
  enum states next_state ;
  enum states state ;
  unsigned long ret ;
  int _st_lock ;
  int tmp ;
  int _st_unlock ;
  int tmp___0 ;

  {
#line 814
  ret = 0UL;
#line 816
  ap = task->ap;
#line 817
  next_state = task->state;
#line 819
  while (1) {
#line 819
    tmp = pthread_mutex_lock(& ap->state_mutex);
#line 819
    _st_lock = tmp;
#line 819
    if (_st_lock) {
#line 819
      while (1) {
#line 819
        if (_st_lock == 35) {
#line 819
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "run_state_task", 819, "state.c");
#line 819
          dump_core();
        }
#line 819
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_lock, 819,
                      "state.c");
#line 819
        abort();
#line 819
        break;
      }
    }
#line 819
    break;
  }
#line 821
  state = ap->state;
#line 823
  if ((int )next_state != (int )state) {
#line 824
    switch ((int )next_state) {
    case 3: 
#line 826
    ret = (unsigned long )st_prune(ap);
#line 827
    break;
    case 2: 
#line 830
    ret = (unsigned long )st_expire(ap);
#line 831
    break;
    case 4: 
#line 834
    ret = (unsigned long )st_readmap(ap);
#line 835
    break;
    case 5: 
#line 838
    ret = (unsigned long )st_prepare_shutdown(ap);
#line 839
    break;
    case 6: 
#line 842
    ret = (unsigned long )st_force_shutdown(ap);
#line 843
    break;
    default: ;
#line 846
    while (1) {
#line 846
      ((*log_error))(ap->logopt, "%s: bad next state %d", "run_state_task", next_state);
#line 846
      break;
    }
    }
  }
#line 850
  while (1) {
#line 850
    tmp___0 = pthread_mutex_unlock(& ap->state_mutex);
#line 850
    _st_unlock = tmp___0;
#line 850
    if (_st_unlock) {
#line 850
      while (1) {
#line 850
        if (_st_unlock == 35) {
#line 850
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "run_state_task", 850, "state.c");
#line 850
          dump_core();
        }
#line 850
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_unlock,
                      850, "state.c");
#line 850
        abort();
#line 850
        break;
      }
    }
#line 850
    break;
  }
#line 852
  return ((int )ret);
}
}
#line 855 "state.c"
static void st_set_thid(struct autofs_point *ap , pthread_t thid ) 
{ struct list_head *p ;
  struct list_head *head ;
  struct state_queue *task ;

  {
#line 857
  head = & state_queue;
#line 860
  p = head->next;
#line 860
  while ((unsigned int )p != (unsigned int )head) {
#line 861
    task = (struct state_queue *)((char *)p - (unsigned long )(& ((struct state_queue *)0)->list));
#line 862
    if ((unsigned int )task->ap == (unsigned int )ap) {
#line 863
      task->thid = thid;
#line 864
      break;
    }
#line 860
    p = p->next;
  }
#line 867
  return;
}
}
#line 871 "state.c"
static void st_set_done(struct autofs_point *ap ) 
{ struct list_head *p ;
  struct list_head *head ;
  struct state_queue *task ;
  int status ;
  int tmp ;
  int status___0 ;
  int tmp___0 ;

  {
#line 876
  while (1) {
#line 876
    tmp = pthread_mutex_lock(& mutex);
#line 876
    status = tmp;
#line 876
    if (status) {
#line 876
      while (1) {
#line 876
        if (status == 35) {
#line 876
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "st_set_done", 876, "state.c");
#line 876
          dump_core();
        }
#line 876
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 876,
                      "state.c");
#line 876
        abort();
#line 876
        break;
      }
    }
#line 876
    break;
  }
#line 878
  head = & state_queue;
#line 879
  p = head->next;
#line 879
  while ((unsigned int )p != (unsigned int )head) {
#line 880
    task = (struct state_queue *)((char *)p - (unsigned long )(& ((struct state_queue *)0)->list));
#line 881
    if ((unsigned int )task->ap == (unsigned int )ap) {
#line 882
      task->done = 1U;
#line 883
      break;
    }
#line 879
    p = p->next;
  }
#line 887
  while (1) {
#line 887
    tmp___0 = pthread_mutex_unlock(& mutex);
#line 887
    status___0 = tmp___0;
#line 887
    if (status___0) {
#line 887
      while (1) {
#line 887
        if (status___0 == 35) {
#line 887
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "st_set_done", 887, "state.c");
#line 887
          dump_core();
        }
#line 887
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status___0,
                      887, "state.c");
#line 887
        abort();
#line 887
        break;
      }
    }
#line 887
    break;
  }
#line 889
  return;
}
}
#line 892 "state.c"
static void *st_queue_handler(void *arg ) 
{ struct list_head *head ;
  struct list_head *p ;
  struct timespec wait ;
  int status ;
  int ret ;
  int status___0 ;
  int tmp ;
  time_t tmp___0 ;
  int tmp___1 ;
  struct state_queue *task ;
  time_t tmp___2 ;
  struct state_queue *task___0 ;
  struct state_queue *next ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 899
  while (1) {
#line 899
    tmp = pthread_mutex_lock(& mutex);
#line 899
    status___0 = tmp;
#line 899
    if (status___0) {
#line 899
      while (1) {
#line 899
        if (status___0 == 35) {
#line 899
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "st_queue_handler", 899, "state.c");
#line 899
          dump_core();
        }
#line 899
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status___0,
                      899, "state.c");
#line 899
        abort();
#line 899
        break;
      }
    }
#line 899
    break;
  }
#line 901
  while (1) {
#line 906
    head = & state_queue;
#line 907
    tmp___0 = time((time_t *)((void *)0));
#line 907
    wait.tv_sec = tmp___0 + 1L;
#line 908
    wait.tv_nsec = 0L;
#line 910
    while (1) {
#line 910
      tmp___1 = list_empty(head);
#line 910
      if (! tmp___1) {
#line 910
        break;
      }
#line 911
      status = pthread_cond_timedwait((pthread_cond_t * __restrict  )(& cond), (pthread_mutex_t * __restrict  )(& mutex),
                                      (struct timespec  const  * __restrict  )(& wait));
#line 912
      if (status) {
#line 913
        if (status == 110) {
#line 914
          break;
        }
#line 915
        while (1) {
#line 915
          if (status == 35) {
#line 915
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "st_queue_handler", 915, "state.c");
#line 915
            dump_core();
          }
#line 915
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 915,
                        "state.c");
#line 915
          abort();
#line 915
          break;
        }
      }
    }
#line 919
    p = head->next;
#line 920
    while ((unsigned int )p != (unsigned int )head) {
#line 923
      task = (struct state_queue *)((char *)p - (unsigned long )(& ((struct state_queue *)0)->list));
#line 924
      p = p->next;
#line 926
      if (task->cancel) {
#line 927
        list_del(& task->list);
#line 928
        free((void *)task);
#line 929
        continue;
      }
#line 932
      task->busy = 1U;
#line 934
      ret = run_state_task(task);
#line 935
      if (! ret) {
#line 936
        list_del(& task->list);
#line 937
        free((void *)task);
      }
    }
#line 941
    while (1) {
#line 942
      tmp___2 = time((time_t *)((void *)0));
#line 942
      wait.tv_sec = tmp___2 + 1L;
#line 943
      wait.tv_nsec = 0L;
#line 945
      signaled = 0U;
#line 946
      while (! signaled) {
#line 947
        status = pthread_cond_timedwait((pthread_cond_t * __restrict  )(& cond), (pthread_mutex_t * __restrict  )(& mutex),
                                        (struct timespec  const  * __restrict  )(& wait));
#line 948
        if (status) {
#line 949
          if (status == 110) {
#line 950
            break;
          }
#line 951
          while (1) {
#line 951
            if (status == 35) {
#line 951
              ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                            "st_queue_handler", 951, "state.c");
#line 951
              dump_core();
            }
#line 951
            ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status,
                          951, "state.c");
#line 951
            abort();
#line 951
            break;
          }
        }
      }
#line 955
      head = & state_queue;
#line 956
      p = head->next;
#line 957
      while ((unsigned int )p != (unsigned int )head) {
#line 960
        task___0 = (struct state_queue *)((char *)p - (unsigned long )(& ((struct state_queue *)0)->list));
#line 961
        p = p->next;
#line 963
        if (! task___0->busy) {
#line 965
          task___0->busy = 1U;
#line 967
          ret = run_state_task(task___0);
#line 968
          if (! ret) {
            goto remove;
          }
#line 970
          continue;
        }
#line 974
        if (! task___0->thid) {
#line 975
          continue;
        }
#line 977
        if (task___0->cancel) {
#line 978
          pthread_cancel(task___0->thid);
#line 979
          task___0->cancel = 0U;
#line 980
          continue;
        }
#line 984
        if (! task___0->done) {
#line 985
          continue;
        }
        remove: 
#line 989
        tmp___3 = list_empty(& task___0->pending);
#line 989
        if (tmp___3) {
#line 990
          list_del(& task___0->list);
#line 991
          free((void *)task___0);
#line 992
          continue;
        }
#line 996
        next = (struct state_queue *)((char *)task___0->pending.next - (unsigned long )(& ((struct state_queue *)0)->pending));
#line 999
        list_del_init(& next->pending);
#line 1000
        list_add_tail(& next->list, p);
#line 1002
        list_del(& task___0->list);
#line 1003
        free((void *)task___0);
      }
#line 1006
      tmp___4 = list_empty(head);
#line 1006
      if (tmp___4) {
#line 1007
        break;
      }
    }
  }
}
}
#line 1012 "state.c"
int st_start_handler(void) 
{ pthread_t thid ;
  pthread_attr_t attrs ;
  pthread_attr_t *pattrs ;
  int status ;

  {
#line 1016
  pattrs = & attrs;
#line 1019
  status = pthread_attr_init(pattrs);
#line 1020
  if (status) {
#line 1021
    pattrs = (pthread_attr_t *)((void *)0);
  } else {
#line 1023
    pthread_attr_setdetachstate(pattrs, 1);
#line 1025
    pthread_attr_setstacksize(pattrs, 65536U);
  }
#line 1029
  status = pthread_create((pthread_t * __restrict  )(& thid), (pthread_attr_t const   * __restrict  )pattrs,
                          & st_queue_handler, (void * __restrict  )((void *)0));
#line 1030
  if (status) {
#line 1031
    return (0);
  }
#line 1033
  return (1);
}
}
#line 1 "cil-Ggw2XuA3.o"
#pragma merger(0,"/tmp/cil-GOF0sC5N.i","")
#line 1 "alarm.o"
#pragma merger(0,"/tmp/cil-z9Gx37lJ.i","-O2,-Wall,-fPIC")
#line 25 "alarm.c"
static union __anonunion_pthread_mutex_t_6 mutex___0  =    {{0, 0U, 0, 0, 0U, {0}}};
#line 26 "alarm.c"
static union __anonunion_pthread_cond_t_9 cond___0  =    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}};
#line 27 "alarm.c"
static struct list_head alarms  =    {& alarms, & alarms};
#line 43 "alarm.c"
void dump_alarms(void) 
{ struct list_head *head ;
  struct list_head *p ;
  struct alarm *this ;

  {
#line 48
  pthread_mutex_lock(& mutex___0);
#line 49
  head = & alarms;
#line 50
  p = head->next;
#line 50
  while ((unsigned int )p != (unsigned int )head) {
#line 53
    this = (struct alarm *)((char *)p - (unsigned long )(& ((struct alarm *)0)->list));
#line 54
    while (1) {
#line 54
      ((*log_info))(0U, "alarm time = %d", this->time);
#line 54
      break;
    }
#line 50
    p = p->next;
  }
#line 56
  pthread_mutex_unlock(& mutex___0);
#line 57
  return;
}
}
#line 60 "alarm.c"
int alarm_add(struct autofs_point *ap , time_t seconds ) 
{ struct list_head *head ;
  struct list_head *p ;
  struct alarm *new ;
  time_t now ;
  time_t tmp ;
  time_t next_alarm ;
  unsigned int empty ;
  int status ;
  int _alm_lock ;
  int tmp___0 ;
  struct alarm *current ;
  int tmp___1 ;
  struct alarm *this ;
  int _alm_unlock ;
  int tmp___2 ;

  {
#line 65
  tmp = time((time_t *)((void *)0));
#line 65
  now = tmp;
#line 66
  next_alarm = 0L;
#line 67
  empty = 1U;
#line 70
  new = (struct alarm *)malloc(sizeof(struct alarm ));
#line 71
  if (! new) {
#line 72
    return (0);
  }
#line 74
  new->ap = ap;
#line 75
  new->cancel = 0U;
#line 76
  new->time = now + seconds;
#line 78
  while (1) {
#line 78
    tmp___0 = pthread_mutex_lock(& mutex___0);
#line 78
    _alm_lock = tmp___0;
#line 78
    if (_alm_lock) {
#line 78
      while (1) {
#line 78
        if (_alm_lock == 35) {
#line 78
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "alarm_add", 78, "alarm.c");
#line 78
          dump_core();
        }
#line 78
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _alm_lock,
                      78, "alarm.c");
#line 78
        abort();
#line 78
        break;
      }
    }
#line 78
    break;
  }
#line 80
  head = & alarms;
#line 83
  tmp___1 = list_empty(head);
#line 83
  if (! tmp___1) {
#line 85
    current = (struct alarm *)((char *)head->next - (unsigned long )(& ((struct alarm *)0)->list));
#line 86
    next_alarm = current->time;
#line 87
    empty = 0U;
  }
#line 90
  p = head->next;
#line 90
  while ((unsigned int )p != (unsigned int )head) {
#line 93
    this = (struct alarm *)((char *)p - (unsigned long )(& ((struct alarm *)0)->list));
#line 94
    if (this->time >= new->time) {
#line 95
      list_add_tail(& new->list, p);
#line 96
      break;
    }
#line 90
    p = p->next;
  }
#line 99
  if ((unsigned int )p == (unsigned int )head) {
#line 100
    list_add_tail(& new->list, p);
  }
#line 107
  if (empty) {
    goto _L;
  } else {
#line 107
    if (new->time < next_alarm) {
      _L: 
#line 108
      status = pthread_cond_signal(& cond___0);
#line 109
      if (status) {
#line 110
        while (1) {
#line 110
          if (status == 35) {
#line 110
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "alarm_add", 110, "alarm.c");
#line 110
            dump_core();
          }
#line 110
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 110,
                        "alarm.c");
#line 110
          abort();
#line 110
          break;
        }
      }
    }
  }
#line 113
  while (1) {
#line 113
    tmp___2 = pthread_mutex_unlock(& mutex___0);
#line 113
    _alm_unlock = tmp___2;
#line 113
    if (_alm_unlock) {
#line 113
      while (1) {
#line 113
        if (_alm_unlock == 35) {
#line 113
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "alarm_add", 113, "alarm.c");
#line 113
          dump_core();
        }
#line 113
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _alm_unlock,
                      113, "alarm.c");
#line 113
        abort();
#line 113
        break;
      }
    }
#line 113
    break;
  }
#line 115
  return (1);
}
}
#line 118 "alarm.c"
void alarm_delete(struct autofs_point *ap ) 
{ struct list_head *head ;
  struct list_head *p ;
  struct alarm *current ;
  unsigned int signal_cancel ;
  int status ;
  int _alm_lock ;
  int tmp ;
  int _alm_unlock ;
  int tmp___0 ;
  int tmp___1 ;
  struct alarm *this ;
  int _alm_unlock___0 ;
  int tmp___2 ;

  {
#line 123
  signal_cancel = 0U;
#line 126
  while (1) {
#line 126
    tmp = pthread_mutex_lock(& mutex___0);
#line 126
    _alm_lock = tmp;
#line 126
    if (_alm_lock) {
#line 126
      while (1) {
#line 126
        if (_alm_lock == 35) {
#line 126
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "alarm_delete", 126, "alarm.c");
#line 126
          dump_core();
        }
#line 126
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _alm_lock,
                      126, "alarm.c");
#line 126
        abort();
#line 126
        break;
      }
    }
#line 126
    break;
  }
#line 128
  head = & alarms;
#line 130
  tmp___1 = list_empty(head);
#line 130
  if (tmp___1) {
#line 131
    while (1) {
#line 131
      tmp___0 = pthread_mutex_unlock(& mutex___0);
#line 131
      _alm_unlock = tmp___0;
#line 131
      if (_alm_unlock) {
#line 131
        while (1) {
#line 131
          if (_alm_unlock == 35) {
#line 131
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "alarm_delete", 131, "alarm.c");
#line 131
            dump_core();
          }
#line 131
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _alm_unlock,
                        131, "alarm.c");
#line 131
          abort();
#line 131
          break;
        }
      }
#line 131
      break;
    }
#line 132
    return;
  }
#line 135
  current = (struct alarm *)((char *)head->next - (unsigned long )(& ((struct alarm *)0)->list));
#line 137
  p = head->next;
#line 138
  while ((unsigned int )p != (unsigned int )head) {
#line 141
    this = (struct alarm *)((char *)p - (unsigned long )(& ((struct alarm *)0)->list));
#line 142
    p = p->next;
#line 144
    if ((unsigned int )ap == (unsigned int )this->ap) {
#line 145
      if ((unsigned int )current != (unsigned int )this) {
#line 146
        list_del_init(& this->list);
#line 147
        free((void *)this);
#line 148
        continue;
      }
#line 151
      this->cancel = 1U;
#line 152
      this->time = 0L;
#line 153
      signal_cancel = 1U;
    }
  }
#line 157
  if (signal_cancel) {
#line 158
    status = pthread_cond_signal(& cond___0);
#line 159
    if (status) {
#line 160
      while (1) {
#line 160
        if (status == 35) {
#line 160
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "alarm_delete", 160, "alarm.c");
#line 160
          dump_core();
        }
#line 160
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 160,
                      "alarm.c");
#line 160
        abort();
#line 160
        break;
      }
    }
  }
#line 163
  while (1) {
#line 163
    tmp___2 = pthread_mutex_unlock(& mutex___0);
#line 163
    _alm_unlock___0 = tmp___2;
#line 163
    if (_alm_unlock___0) {
#line 163
      while (1) {
#line 163
        if (_alm_unlock___0 == 35) {
#line 163
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "alarm_delete", 163, "alarm.c");
#line 163
          dump_core();
        }
#line 163
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _alm_unlock___0,
                      163, "alarm.c");
#line 163
        abort();
#line 163
        break;
      }
    }
#line 163
    break;
  }
#line 165
  return;
}
}
#line 168 "alarm.c"
static void *alarm_handler(void *arg ) 
{ struct list_head *head ;
  struct timespec expire ;
  struct alarm *first ;
  time_t now ;
  int status ;
  int _alm_lock ;
  int tmp ;
  int tmp___0 ;
  struct autofs_point *ap ;
  int _alm_unlock ;
  int tmp___1 ;
  int _st_lock ;
  int tmp___2 ;
  int _st_unlock ;
  int tmp___3 ;
  int _alm_lock___0 ;
  int tmp___4 ;

  {
#line 176
  while (1) {
#line 176
    tmp = pthread_mutex_lock(& mutex___0);
#line 176
    _alm_lock = tmp;
#line 176
    if (_alm_lock) {
#line 176
      while (1) {
#line 176
        if (_alm_lock == 35) {
#line 176
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "alarm_handler", 176, "alarm.c");
#line 176
          dump_core();
        }
#line 176
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _alm_lock,
                      176, "alarm.c");
#line 176
        abort();
#line 176
        break;
      }
    }
#line 176
    break;
  }
#line 178
  head = & alarms;
#line 180
  while (1) {
#line 182
    tmp___0 = list_empty(head);
#line 182
    if (tmp___0) {
#line 184
      status = pthread_cond_wait((pthread_cond_t * __restrict  )(& cond___0), (pthread_mutex_t * __restrict  )(& mutex___0));
#line 185
      if (status) {
#line 186
        while (1) {
#line 186
          if (status == 35) {
#line 186
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "alarm_handler", 186, "alarm.c");
#line 186
            dump_core();
          }
#line 186
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 186,
                        "alarm.c");
#line 186
          abort();
#line 186
          break;
        }
      }
#line 187
      continue;
    }
#line 190
    first = (struct alarm *)((char *)head->next - (unsigned long )(& ((struct alarm *)0)->list));
#line 192
    now = time((time_t *)((void *)0));
#line 194
    if (first->time > now) {
#line 199
      expire.tv_sec = first->time;
#line 200
      expire.tv_nsec = 0L;
#line 202
      status = pthread_cond_timedwait((pthread_cond_t * __restrict  )(& cond___0),
                                      (pthread_mutex_t * __restrict  )(& mutex___0),
                                      (struct timespec  const  * __restrict  )(& expire));
#line 203
      if (status) {
#line 203
        if (status != 110) {
#line 204
          while (1) {
#line 204
            if (status == 35) {
#line 204
              ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                            "alarm_handler", 204, "alarm.c");
#line 204
              dump_core();
            }
#line 204
            ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status,
                          204, "alarm.c");
#line 204
            abort();
#line 204
            break;
          }
        }
      }
    } else {
#line 208
      list_del(& first->list);
#line 210
      if (! first->cancel) {
#line 211
        ap = first->ap;
#line 219
        while (1) {
#line 219
          tmp___1 = pthread_mutex_unlock(& mutex___0);
#line 219
          _alm_unlock = tmp___1;
#line 219
          if (_alm_unlock) {
#line 219
            while (1) {
#line 219
              if (_alm_unlock == 35) {
#line 219
                ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                              "alarm_handler", 219, "alarm.c");
#line 219
                dump_core();
              }
#line 219
              ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _alm_unlock,
                            219, "alarm.c");
#line 219
              abort();
#line 219
              break;
            }
          }
#line 219
          break;
        }
#line 221
        while (1) {
#line 221
          tmp___2 = pthread_mutex_lock(& ap->state_mutex);
#line 221
          _st_lock = tmp___2;
#line 221
          if (_st_lock) {
#line 221
            while (1) {
#line 221
              if (_st_lock == 35) {
#line 221
                ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                              "alarm_handler", 221, "alarm.c");
#line 221
                dump_core();
              }
#line 221
              ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_lock,
                            221, "alarm.c");
#line 221
              abort();
#line 221
              break;
            }
          }
#line 221
          break;
        }
#line 222
        nextstate(ap->state_pipe[1], (enum states )2);
#line 223
        while (1) {
#line 223
          tmp___3 = pthread_mutex_unlock(& ap->state_mutex);
#line 223
          _st_unlock = tmp___3;
#line 223
          if (_st_unlock) {
#line 223
            while (1) {
#line 223
              if (_st_unlock == 35) {
#line 223
                ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                              "alarm_handler", 223, "alarm.c");
#line 223
                dump_core();
              }
#line 223
              ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_unlock,
                            223, "alarm.c");
#line 223
              abort();
#line 223
              break;
            }
          }
#line 223
          break;
        }
#line 225
        while (1) {
#line 225
          tmp___4 = pthread_mutex_lock(& mutex___0);
#line 225
          _alm_lock___0 = tmp___4;
#line 225
          if (_alm_lock___0) {
#line 225
            while (1) {
#line 225
              if (_alm_lock___0 == 35) {
#line 225
                ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                              "alarm_handler", 225, "alarm.c");
#line 225
                dump_core();
              }
#line 225
              ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _alm_lock___0,
                            225, "alarm.c");
#line 225
              abort();
#line 225
              break;
            }
          }
#line 225
          break;
        }
      }
#line 227
      free((void *)first);
    }
  }
}
}
#line 233 "alarm.c"
int alarm_start_handler(void) 
{ pthread_t thid ;
  pthread_attr_t attrs ;
  pthread_attr_t *pattrs ;
  int status ;

  {
#line 237
  pattrs = & attrs;
#line 240
  status = pthread_attr_init(pattrs);
#line 241
  if (status) {
#line 242
    pattrs = (pthread_attr_t *)((void *)0);
  } else {
#line 244
    pthread_attr_setdetachstate(pattrs, 1);
#line 246
    pthread_attr_setstacksize(pattrs, 65536U);
  }
#line 250
  status = pthread_create((pthread_t * __restrict  )(& thid), (pthread_attr_t const   * __restrict  )pattrs,
                          & alarm_handler, (void * __restrict  )((void *)0));
#line 251
  if (status) {
#line 252
    return (0);
  }
#line 254
  return (1);
}
}
#line 1 "args.o"
#pragma merger(0,"/tmp/cil-1FndAHCZ.i","-O2,-Wall,-fPIC")
#line 194 "../include/automount.h"
char **add_argv(int argc , char **argv , char *str ) ;
#line 196
int compare_argv(int argc1 , char const   **argv1 , int argc2 , char const   **argv2 ) ;
#line 25 "args.c"
char **add_argv(int argc , char **argv , char *str ) 
{ char **vector ;
  size_t vector_size ;
  int i ;
  char *tmp___9 ;
  char *tmp___19 ;

  {
#line 31
  vector_size = (unsigned int )(argc + 1) * sizeof(char *);
#line 32
  vector = (char **)malloc(vector_size);
#line 33
  if (! vector) {
#line 34
    return ((char **)((void *)0));
  }
#line 36
  i = 0;
#line 36
  while (i < argc - 1) {
#line 37
    if ((*(argv + i))) {
#line 38
      tmp___9 = __strdup((char const   *)(*(argv + i)));
#line 38
      (*(vector + i)) = tmp___9;
#line 39
      if (! (*(vector + i))) {
#line 40
        while (1) {
#line 40
          ((*log_error))(3U, "%s: failed to strdup arg", "add_argv");
#line 40
          break;
        }
#line 41
        break;
      }
    } else {
#line 44
      (*(vector + i)) = (char *)((void *)0);
    }
#line 36
    i ++;
  }
#line 47
  if (i < argc - 1) {
#line 48
    free_argv(argc - 1, (char const   **)vector);
#line 49
    return ((char **)((void *)0));
  }
#line 52
  tmp___19 = __strdup((char const   *)str);
#line 52
  (*(vector + (argc - 1))) = tmp___19;
#line 53
  if (! (*(vector + (argc - 1)))) {
#line 54
    free_argv(argc - 1, (char const   **)vector);
#line 55
    return ((char **)((void *)0));
  }
#line 58
  (*(vector + argc)) = (char *)((void *)0);
#line 60
  free_argv(argc - 1, (char const   **)argv);
#line 62
  return (vector);
}
}
#line 65 "args.c"
char const   **copy_argv(int argc , char const   **argv ) 
{ char **vector ;
  size_t vector_size ;
  int i ;
  char *tmp___9 ;

  {
#line 71
  vector_size = (unsigned int )(argc + 1) * sizeof(char *);
#line 72
  vector = (char **)malloc(vector_size);
#line 73
  if (! vector) {
#line 74
    return ((char const   **)((void *)0));
  }
#line 76
  i = 0;
#line 76
  while (i < argc) {
#line 77
    if ((*(argv + i))) {
#line 78
      tmp___9 = __strdup((*(argv + i)));
#line 78
      (*(vector + i)) = tmp___9;
#line 79
      if (! (*(vector + i))) {
#line 80
        while (1) {
#line 80
          ((*log_error))(3U, "%s: failed to strdup arg", "copy_argv");
#line 80
          break;
        }
#line 81
        break;
      }
    } else {
#line 84
      (*(vector + i)) = (char *)((void *)0);
    }
#line 76
    i ++;
  }
#line 87
  if (i < argc) {
#line 88
    free_argv(argc, (char const   **)vector);
#line 89
    return ((char const   **)((void *)0));
  }
#line 92
  (*(vector + argc)) = (char *)((void *)0);
#line 94
  return ((char const   **)vector);
}
}
#line 98 "args.c"
static int compare(char const   *s1 , char const   *s2 ) 
{ int res ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 100
  res = 0;
#line 102
  if (s1) {
#line 103
    if (! s2) {
      goto done;
    }
#line 106
    if (0) {
#line 106
      __s1_len = strlen(s1);
#line 106
      __s2_len = strlen(s2);
#line 106
      if (! ((unsigned int )((void const   *)(s1 + 1)) - (unsigned int )((void const   *)s1) == 1U)) {
        goto _L___0;
      } else {
#line 106
        if (__s1_len >= 4U) {
          _L___0: 
#line 106
          if (! ((unsigned int )((void const   *)(s2 + 1)) - (unsigned int )((void const   *)s2) == 1U)) {
#line 106
            tmp___8 = 1;
          } else {
#line 106
            if (__s2_len >= 4U) {
#line 106
              tmp___8 = 1;
            } else {
#line 106
              tmp___8 = 0;
            }
          }
        } else {
#line 106
          tmp___8 = 0;
        }
      }
#line 106
      if (tmp___8) {
#line 106
        tmp___4 = __builtin_strcmp(s1, s2);
      } else {
#line 106
        tmp___7 = __builtin_strcmp(s1, s2);
#line 106
        tmp___4 = tmp___7;
      }
    } else {
#line 106
      tmp___7 = __builtin_strcmp(s1, s2);
#line 106
      tmp___4 = tmp___7;
    }
#line 106
    if (tmp___4) {
      goto done;
    }
  } else {
#line 108
    if (s2) {
      goto done;
    }
  }
#line 111
  res = 1;
  done: 
#line 113
  return (res);
}
}
#line 116 "args.c"
int compare_argv(int argc1 , char const   **argv1 , int argc2 , char const   **argv2 ) 
{ int res ;
  int i ;
  int val ;

  {
#line 118
  res = 1;
#line 121
  if (argc1 != argc2) {
#line 122
    return (0);
  }
#line 124
  i = 0;
#line 125
  while (i < argc1) {
#line 126
    val = compare((*(argv1 + i)), (*(argv2 + i)));
#line 127
    if (! val) {
#line 128
      res = 0;
#line 129
      break;
    }
#line 131
    i ++;
  }
#line 133
  return (res);
}
}
#line 136 "args.c"
int free_argv(int argc , char const   **argv ) 
{ char **vector ;
  int i ;

  {
#line 138
  vector = (char **)argv;
#line 141
  if (! argc) {
#line 142
    if (vector) {
#line 143
      free((void *)vector);
    }
#line 144
    return (1);
  }
#line 147
  i = 0;
#line 147
  while (i < argc) {
#line 148
    if ((*(vector + i))) {
#line 149
      free((void *)(*(vector + i)));
    }
#line 147
    i ++;
  }
#line 151
  free((void *)vector);
#line 153
  return (1);
}
}
#line 1 "cache.o"
#pragma merger(0,"/tmp/cil-gmj5pfh8.i","-O2,-Wall,-fPIC")
#line 843 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int pthread_rwlock_init(pthread_rwlock_t * __restrict  __rwlock ,
                                                             pthread_rwlockattr_t const   * __restrict  __attr )  __attribute__((__nonnull__(1))) ;
#line 848
extern  __attribute__((__nothrow__)) int pthread_rwlock_destroy(pthread_rwlock_t *__rwlock )  __attribute__((__nonnull__(1))) ;
#line 852
extern  __attribute__((__nothrow__)) int pthread_rwlock_rdlock(pthread_rwlock_t *__rwlock )  __attribute__((__nonnull__(1))) ;
#line 867
extern  __attribute__((__nothrow__)) int pthread_rwlock_wrlock(pthread_rwlock_t *__rwlock )  __attribute__((__nonnull__(1))) ;
#line 871
extern  __attribute__((__nothrow__)) int pthread_rwlock_trywrlock(pthread_rwlock_t *__rwlock )  __attribute__((__nonnull__(1))) ;
#line 882
extern  __attribute__((__nothrow__)) int pthread_rwlock_unlock(pthread_rwlock_t *__rwlock )  __attribute__((__nonnull__(1))) ;
#line 167 "../include/automount.h"
struct mapent_cache *cache_init(struct map_source *map ) ;
#line 168
struct mapent_cache *cache_init_null_cache(struct master *master ) ;
#line 172
struct mapent *cache_lookup_first(struct mapent_cache *mc ) ;
#line 173
struct mapent *cache_lookup_next(struct mapent_cache *mc , struct mapent *me ) ;
#line 174
struct mapent *cache_lookup_key_next(struct mapent *me ) ;
#line 177
struct mapent *cache_lookup_offset(char const   *prefix , char const   *offset , int start ,
                                   struct list_head *head ) ;
#line 179
int cache_add(struct mapent_cache *mc , struct map_source *ms , char const   *key ,
              char const   *mapent , time_t age ) ;
#line 180
int cache_add_offset(struct mapent_cache *mc , char const   *mkey , char const   *key ,
                     char const   *mapent , time_t age ) ;
#line 181
int cache_set_parents(struct mapent *mm ) ;
#line 182
int cache_update(struct mapent_cache *mc , struct map_source *ms , char const   *key ,
                 char const   *mapent , time_t age ) ;
#line 186
int cache_delete_offset_list(struct mapent_cache *mc , char const   *key ) ;
#line 187
void cache_release(struct map_source *map ) ;
#line 188
void cache_release_null_cache(struct master *master ) ;
#line 190
char *cache_get_offset(char const   *prefix , char *offset , int start , struct list_head *head ,
                       struct list_head **pos ) ;
#line 30 "cache.c"
void cache_dump_multi(struct list_head *list ) 
{ struct list_head *p ;
  struct mapent *me ;

  {
#line 35
  p = list->next;
#line 35
  while ((unsigned int )p != (unsigned int )list) {
#line 36
    me = (struct mapent *)((char *)p - (unsigned long )(& ((struct mapent *)0)->multi_list));
#line 37
    while (1) {
#line 37
      ((*log_info))(0U, "key=%s", me->key);
#line 37
      break;
    }
#line 35
    p = p->next;
  }
#line 39
  return;
}
}
#line 41 "cache.c"
void cache_dump_cache(struct mapent_cache *mc ) 
{ struct mapent *me ;
  unsigned int i ;

  {
#line 46
  i = 0U;
#line 46
  while (i < mc->size) {
#line 47
    me = (*(mc->hash + i));
#line 48
    if ((unsigned int )me == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 50
    while (me) {
#line 51
      while (1) {
#line 51
        ((*log_info))(0U, "me->key=%s me->multi=%p dev=%ld ino=%ld", me->key, me->multi,
                      me->dev, me->ino);
#line 51
        break;
      }
#line 53
      me = me->next;
    }
    __Cont: 
#line 46
    i ++;
  }
#line 56
  return;
}
}
#line 58 "cache.c"
void cache_readlock(struct mapent_cache *mc ) 
{ int status ;

  {
#line 62
  status = pthread_rwlock_rdlock(& mc->rwlock);
#line 63
  if (status) {
#line 64
    while (1) {
#line 64
      ((*log_error))(3U, "%s: mapent cache rwlock lock failed", "cache_readlock");
#line 64
      break;
    }
#line 65
    while (1) {
#line 65
      if (status == 35) {
#line 65
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "cache_readlock", 65, "cache.c");
#line 65
        dump_core();
      }
#line 65
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 65, "cache.c");
#line 65
      abort();
#line 65
      break;
    }
  }
#line 67
  return;
}
}
#line 70 "cache.c"
void cache_writelock(struct mapent_cache *mc ) 
{ int status ;

  {
#line 74
  status = pthread_rwlock_wrlock(& mc->rwlock);
#line 75
  if (status) {
#line 76
    while (1) {
#line 76
      ((*log_error))(3U, "%s: mapent cache rwlock lock failed", "cache_writelock");
#line 76
      break;
    }
#line 77
    while (1) {
#line 77
      if (status == 35) {
#line 77
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "cache_writelock", 77, "cache.c");
#line 77
        dump_core();
      }
#line 77
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 77, "cache.c");
#line 77
      abort();
#line 77
      break;
    }
  }
#line 79
  return;
}
}
#line 82 "cache.c"
int cache_try_writelock(struct mapent_cache *mc ) 
{ int status ;

  {
#line 86
  status = pthread_rwlock_trywrlock(& mc->rwlock);
#line 87
  if (status) {
#line 88
    while (1) {
#line 88
      ((*log_debug))(3U, "%s: mapent cache rwlock busy", "cache_try_writelock");
#line 88
      break;
    }
#line 89
    return (0);
  }
#line 91
  return (1);
}
}
#line 94 "cache.c"
void cache_unlock(struct mapent_cache *mc ) 
{ int status ;

  {
#line 98
  status = pthread_rwlock_unlock(& mc->rwlock);
#line 99
  if (status) {
#line 100
    while (1) {
#line 100
      ((*log_error))(3U, "%s: mapent cache rwlock unlock failed", "cache_unlock");
#line 100
      break;
    }
#line 101
    while (1) {
#line 101
      if (status == 35) {
#line 101
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "cache_unlock", 101, "cache.c");
#line 101
        dump_core();
      }
#line 101
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 101,
                    "cache.c");
#line 101
      abort();
#line 101
      break;
    }
  }
#line 103
  return;
}
}
#line 106 "cache.c"
void cache_lock_cleanup(void *arg ) 
{ struct mapent_cache *mc ;

  {
#line 108
  mc = (struct mapent_cache *)arg;
#line 110
  cache_unlock(mc);
#line 111
  return;
}
}
#line 114 "cache.c"
void cache_multi_lock(struct mapent *me ) 
{ int status ;

  {
#line 118
  if (! me) {
#line 119
    return;
  }
#line 121
  status = pthread_mutex_lock(& me->multi_mutex);
#line 122
  if (status) {
#line 123
    while (1) {
#line 123
      ((*log_error))(3U, "%s: mapent cache multi mutex lock failed", "cache_multi_lock");
#line 123
      break;
    }
#line 124
    while (1) {
#line 124
      if (status == 35) {
#line 124
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "cache_multi_lock", 124, "cache.c");
#line 124
        dump_core();
      }
#line 124
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 124,
                    "cache.c");
#line 124
      abort();
#line 124
      break;
    }
  }
#line 126
  return;
}
}
#line 129 "cache.c"
void cache_multi_unlock(struct mapent *me ) 
{ int status ;

  {
#line 133
  if (! me) {
#line 134
    return;
  }
#line 136
  status = pthread_mutex_unlock(& me->multi_mutex);
#line 137
  if (status) {
#line 138
    while (1) {
#line 138
      ((*log_error))(3U, "%s: mapent cache multi mutex unlock failed", "cache_multi_unlock");
#line 138
      break;
    }
#line 139
    while (1) {
#line 139
      if (status == 35) {
#line 139
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "cache_multi_unlock", 139, "cache.c");
#line 139
        dump_core();
      }
#line 139
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 139,
                    "cache.c");
#line 139
      abort();
#line 139
      break;
    }
  }
#line 141
  return;
}
}
#line 144 "cache.c"
void cache_multi_lock_cleanup(void *arg ) 
{ struct mapent *me ;

  {
#line 146
  me = (struct mapent *)arg;
#line 147
  cache_multi_unlock(me);
#line 148
  return;
}
}
#line 151 "cache.c"
__inline static void ino_index_lock(struct mapent_cache *mc ) 
{ int status ;
  int tmp ;

  {
#line 153
  tmp = pthread_mutex_lock(& mc->ino_index_mutex);
#line 153
  status = tmp;
#line 154
  if (status) {
#line 155
    while (1) {
#line 155
      if (status == 35) {
#line 155
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "ino_index_lock", 155, "cache.c");
#line 155
        dump_core();
      }
#line 155
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 155,
                    "cache.c");
#line 155
      abort();
#line 155
      break;
    }
  }
#line 156
  return;
}
}
#line 159 "cache.c"
__inline static void ino_index_unlock(struct mapent_cache *mc ) 
{ int status ;
  int tmp ;

  {
#line 161
  tmp = pthread_mutex_unlock(& mc->ino_index_mutex);
#line 161
  status = tmp;
#line 162
  if (status) {
#line 163
    while (1) {
#line 163
      if (status == 35) {
#line 163
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "ino_index_unlock", 163, "cache.c");
#line 163
        dump_core();
      }
#line 163
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 163,
                    "cache.c");
#line 163
      abort();
#line 163
      break;
    }
  }
#line 164
  return;
}
}
#line 167 "cache.c"
struct mapent_cache *cache_init(struct map_source *map ) 
{ struct mapent_cache *mc ;
  unsigned int i ;
  int status ;

  {
#line 173
  if (map->mc) {
#line 174
    cache_release(map);
  }
#line 176
  mc = (struct mapent_cache *)malloc(sizeof(struct mapent_cache ));
#line 177
  if (! mc) {
#line 178
    return ((struct mapent_cache *)((void *)0));
  }
#line 180
  mc->size = 77U;
#line 182
  mc->hash = (struct mapent **)malloc(mc->size * sizeof(struct entry *));
#line 183
  if (! mc->hash) {
#line 184
    free((void *)mc);
#line 185
    return ((struct mapent_cache *)((void *)0));
  }
#line 188
  mc->ino_index = (struct list_head *)malloc(mc->size * sizeof(struct list_head ));
#line 189
  if (! mc->ino_index) {
#line 190
    free((void *)mc->hash);
#line 191
    free((void *)mc);
#line 192
    return ((struct mapent_cache *)((void *)0));
  }
#line 195
  status = pthread_mutex_init(& mc->ino_index_mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 196
  if (status) {
#line 197
    while (1) {
#line 197
      if (status == 35) {
#line 197
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "cache_init", 197, "cache.c");
#line 197
        dump_core();
      }
#line 197
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 197,
                    "cache.c");
#line 197
      abort();
#line 197
      break;
    }
  }
#line 199
  status = pthread_rwlock_init((pthread_rwlock_t * __restrict  )(& mc->rwlock), (pthread_rwlockattr_t const   * __restrict  )((void *)0));
#line 200
  if (status) {
#line 201
    while (1) {
#line 201
      if (status == 35) {
#line 201
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "cache_init", 201, "cache.c");
#line 201
        dump_core();
      }
#line 201
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 201,
                    "cache.c");
#line 201
      abort();
#line 201
      break;
    }
  }
#line 203
  cache_writelock(mc);
#line 205
  i = 0U;
#line 205
  while (i < mc->size) {
#line 206
    (*(mc->hash + i)) = (struct mapent *)((void *)0);
#line 207
    while (1) {
#line 207
      (mc->ino_index + i)->next = mc->ino_index + i;
#line 207
      (mc->ino_index + i)->prev = mc->ino_index + i;
#line 207
      break;
    }
#line 205
    i ++;
  }
#line 210
  mc->map = map;
#line 212
  cache_unlock(mc);
#line 214
  return (mc);
}
}
#line 217 "cache.c"
struct mapent_cache *cache_init_null_cache(struct master *master ) 
{ struct mapent_cache *mc ;
  unsigned int i ;
  int status ;

  {
#line 223
  if (master->nc) {
#line 224
    cache_release_null_cache(master);
  }
#line 226
  mc = (struct mapent_cache *)malloc(sizeof(struct mapent_cache ));
#line 227
  if (! mc) {
#line 228
    return ((struct mapent_cache *)((void *)0));
  }
#line 230
  mc->size = 77U;
#line 232
  mc->hash = (struct mapent **)malloc(mc->size * sizeof(struct entry *));
#line 233
  if (! mc->hash) {
#line 234
    free((void *)mc);
#line 235
    return ((struct mapent_cache *)((void *)0));
  }
#line 238
  mc->ino_index = (struct list_head *)malloc(mc->size * sizeof(struct list_head ));
#line 239
  if (! mc->ino_index) {
#line 240
    free((void *)mc->hash);
#line 241
    free((void *)mc);
#line 242
    return ((struct mapent_cache *)((void *)0));
  }
#line 245
  status = pthread_mutex_init(& mc->ino_index_mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 246
  if (status) {
#line 247
    while (1) {
#line 247
      if (status == 35) {
#line 247
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "cache_init_null_cache", 247, "cache.c");
#line 247
        dump_core();
      }
#line 247
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 247,
                    "cache.c");
#line 247
      abort();
#line 247
      break;
    }
  }
#line 249
  status = pthread_rwlock_init((pthread_rwlock_t * __restrict  )(& mc->rwlock), (pthread_rwlockattr_t const   * __restrict  )((void *)0));
#line 250
  if (status) {
#line 251
    while (1) {
#line 251
      if (status == 35) {
#line 251
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "cache_init_null_cache", 251, "cache.c");
#line 251
        dump_core();
      }
#line 251
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 251,
                    "cache.c");
#line 251
      abort();
#line 251
      break;
    }
  }
#line 253
  cache_writelock(mc);
#line 255
  i = 0U;
#line 255
  while (i < mc->size) {
#line 256
    (*(mc->hash + i)) = (struct mapent *)((void *)0);
#line 257
    while (1) {
#line 257
      (mc->ino_index + i)->next = mc->ino_index + i;
#line 257
      (mc->ino_index + i)->prev = mc->ino_index + i;
#line 257
      break;
    }
#line 255
    i ++;
  }
#line 260
  cache_unlock(mc);
#line 262
  return (mc);
}
}
#line 265 "cache.c"
static unsigned int hash(char const   *key ) 
{ unsigned long hashval ;
  char *s ;
  char *tmp ;

  {
#line 268
  s = (char *)key;
#line 270
  hashval = 0UL;
#line 270
  while ((int )(*s) != 0) {
#line 271
    tmp = s;
#line 271
    s ++;
#line 271
    hashval += (unsigned long )(*tmp);
  }
#line 273
  return ((unsigned int )(hashval % 77UL));
}
}
#line 276 "cache.c"
static unsigned int ino_hash(dev_t dev , ino_t ino ) 
{ unsigned long hashval ;

  {
#line 280
  hashval = (unsigned long )(dev + (unsigned long long )ino);
#line 282
  return ((unsigned int )(hashval % 77UL));
}
}
#line 285 "cache.c"
int cache_set_ino_index(struct mapent_cache *mc , char const   *key , dev_t dev ,
                        ino_t ino ) 
{ unsigned int ino_index ;
  unsigned int tmp ;
  struct mapent *me ;

  {
#line 287
  tmp = ino_hash(dev, ino);
#line 287
  ino_index = tmp;
#line 290
  me = cache_lookup_distinct(mc, key);
#line 291
  if (! me) {
#line 292
    return (0);
  }
#line 294
  ino_index_lock(mc);
#line 295
  list_del_init(& me->ino_index);
#line 296
  list_add(& me->ino_index, mc->ino_index + ino_index);
#line 297
  me->dev = dev;
#line 298
  me->ino = ino;
#line 299
  ino_index_unlock(mc);
#line 301
  return (1);
}
}
#line 305 "cache.c"
struct mapent *cache_lookup_ino(struct mapent_cache *mc , dev_t dev , ino_t ino ) 
{ struct mapent *me ;
  struct list_head *head ;
  struct list_head *p ;
  unsigned int ino_index ;

  {
#line 307
  me = (struct mapent *)((void *)0);
#line 311
  ino_index_lock(mc);
#line 312
  ino_index = ino_hash(dev, ino);
#line 313
  head = mc->ino_index + ino_index;
#line 315
  p = head->next;
#line 315
  while ((unsigned int )p != (unsigned int )head) {
#line 316
    me = (struct mapent *)((char *)p - (unsigned long )(& ((struct mapent *)0)->ino_index));
#line 318
    if (me->dev != dev) {
      goto __Cont;
    } else {
#line 318
      if (me->ino != ino) {
        goto __Cont;
      }
    }
#line 321
    ino_index_unlock(mc);
#line 322
    return (me);
    __Cont: 
#line 315
    p = p->next;
  }
#line 324
  ino_index_unlock(mc);
#line 325
  return ((struct mapent *)((void *)0));
}
}
#line 329 "cache.c"
struct mapent *cache_lookup_first(struct mapent_cache *mc ) 
{ struct mapent *me ;
  unsigned int i ;

  {
#line 331
  me = (struct mapent *)((void *)0);
#line 334
  i = 0U;
#line 334
  while (i < mc->size) {
#line 335
    me = (*(mc->hash + i));
#line 336
    if (! me) {
      goto __Cont;
    }
#line 339
    while (me) {
#line 341
      if (me->multi) {
#line 341
        if ((unsigned int )me->multi != (unsigned int )me) {
#line 342
          me = me->next;
#line 343
          continue;
        }
      }
#line 345
      return (me);
    }
    __Cont: 
#line 334
    i ++;
  }
#line 348
  return ((struct mapent *)((void *)0));
}
}
#line 352 "cache.c"
struct mapent *cache_lookup_next(struct mapent_cache *mc , struct mapent *me ) 
{ struct mapent *this ;
  unsigned long hashval ;
  unsigned int i ;
  unsigned int tmp ;

  {
#line 358
  if (! me) {
#line 359
    return ((struct mapent *)((void *)0));
  }
#line 361
  this = me->next;
#line 362
  while (this) {
#line 364
    if (this->multi) {
#line 364
      if ((unsigned int )this->multi != (unsigned int )this) {
#line 365
        this = this->next;
#line 366
        continue;
      }
    }
#line 368
    return (this);
  }
#line 371
  tmp = hash((char const   *)me->key);
#line 371
  hashval = (unsigned long )(tmp + 1U);
#line 372
  if (hashval < (unsigned long )mc->size) {
#line 373
    i = (unsigned int )hashval;
#line 373
    while (i < mc->size) {
#line 374
      this = (*(mc->hash + i));
#line 375
      if (! this) {
        goto __Cont;
      }
#line 378
      while (this) {
#line 380
        if (this->multi) {
#line 380
          if ((unsigned int )this->multi != (unsigned int )this) {
#line 381
            this = this->next;
#line 382
            continue;
          }
        }
#line 384
        return (this);
      }
      __Cont: 
#line 373
      i ++;
    }
  }
#line 388
  return ((struct mapent *)((void *)0));
}
}
#line 392 "cache.c"
struct mapent *cache_lookup_key_next(struct mapent *me ) 
{ struct mapent *next ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 396
  if (! me) {
#line 397
    return ((struct mapent *)((void *)0));
  }
#line 399
  next = me->next;
#line 400
  while (next) {
#line 402
    if (me->multi) {
#line 402
      if ((unsigned int )me->multi != (unsigned int )me) {
#line 403
        continue;
      }
    }
#line 404
    if (0) {
#line 404
      __s1_len = strlen((char const   *)me->key);
#line 404
      __s2_len = strlen((char const   *)next->key);
#line 404
      if (! ((unsigned int )((void const   *)(me->key + 1)) - (unsigned int )((void const   *)me->key) == 1U)) {
        goto _L___0;
      } else {
#line 404
        if (__s1_len >= 4U) {
          _L___0: 
#line 404
          if (! ((unsigned int )((void const   *)(next->key + 1)) - (unsigned int )((void const   *)next->key) == 1U)) {
#line 404
            tmp___8 = 1;
          } else {
#line 404
            if (__s2_len >= 4U) {
#line 404
              tmp___8 = 1;
            } else {
#line 404
              tmp___8 = 0;
            }
          }
        } else {
#line 404
          tmp___8 = 0;
        }
      }
#line 404
      if (tmp___8) {
#line 404
        tmp___4 = __builtin_strcmp((char const   *)me->key, (char const   *)next->key);
      } else {
#line 404
        tmp___7 = __builtin_strcmp((char const   *)me->key, (char const   *)next->key);
#line 404
        tmp___4 = tmp___7;
      }
    } else {
#line 404
      tmp___7 = __builtin_strcmp((char const   *)me->key, (char const   *)next->key);
#line 404
      tmp___4 = tmp___7;
    }
#line 404
    if (! tmp___4) {
#line 405
      return (next);
    }
#line 406
    next = next->next;
  }
#line 408
  return ((struct mapent *)((void *)0));
}
}
#line 412 "cache.c"
struct mapent *cache_lookup(struct mapent_cache *mc , char const   *key ) 
{ struct mapent *me ;
  unsigned int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  unsigned int tmp___10 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___16 ;
  int tmp___19 ;
  int tmp___20 ;

  {
#line 414
  me = (struct mapent *)((void *)0);
#line 416
  if (! key) {
#line 417
    return ((struct mapent *)((void *)0));
  }
#line 419
  tmp = hash(key);
#line 419
  me = (*(mc->hash + tmp));
#line 419
  while ((unsigned int )me != (unsigned int )((void *)0)) {
#line 420
    if (0) {
#line 420
      __s1_len = strlen(key);
#line 420
      __s2_len = strlen((char const   *)me->key);
#line 420
      if (! ((unsigned int )((void const   *)(key + 1)) - (unsigned int )((void const   *)key) == 1U)) {
        goto _L___0;
      } else {
#line 420
        if (__s1_len >= 4U) {
          _L___0: 
#line 420
          if (! ((unsigned int )((void const   *)(me->key + 1)) - (unsigned int )((void const   *)me->key) == 1U)) {
#line 420
            tmp___9 = 1;
          } else {
#line 420
            if (__s2_len >= 4U) {
#line 420
              tmp___9 = 1;
            } else {
#line 420
              tmp___9 = 0;
            }
          }
        } else {
#line 420
          tmp___9 = 0;
        }
      }
#line 420
      if (tmp___9) {
#line 420
        tmp___5 = __builtin_strcmp(key, (char const   *)me->key);
      } else {
#line 420
        tmp___8 = __builtin_strcmp(key, (char const   *)me->key);
#line 420
        tmp___5 = tmp___8;
      }
    } else {
#line 420
      tmp___8 = __builtin_strcmp(key, (char const   *)me->key);
#line 420
      tmp___5 = tmp___8;
    }
#line 420
    if (tmp___5 == 0) {
      goto done;
    }
#line 419
    me = me->next;
  }
#line 424
  me = cache_lookup_first(mc);
#line 425
  if ((unsigned int )me != (unsigned int )((void *)0)) {
#line 427
    if ((int )(*(me->key)) == 47) {
#line 428
      me = (struct mapent *)((void *)0);
      goto done;
    }
#line 432
    tmp___10 = hash("*");
#line 432
    me = (*(mc->hash + tmp___10));
#line 432
    while ((unsigned int )me != (unsigned int )((void *)0)) {
#line 433
      if (0) {
#line 433
        __s1_len___0 = strlen("*");
#line 433
        __s2_len___0 = strlen((char const   *)me->key);
#line 433
        if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") == 1U)) {
          goto _L___2;
        } else {
#line 433
          if (__s1_len___0 >= 4U) {
            _L___2: 
#line 433
            if (! ((unsigned int )((void const   *)(me->key + 1)) - (unsigned int )((void const   *)me->key) == 1U)) {
#line 433
              tmp___20 = 1;
            } else {
#line 433
              if (__s2_len___0 >= 4U) {
#line 433
                tmp___20 = 1;
              } else {
#line 433
                tmp___20 = 0;
              }
            }
          } else {
#line 433
            tmp___20 = 0;
          }
        }
#line 433
        if (tmp___20) {
#line 433
          tmp___16 = __builtin_strcmp("*", (char const   *)me->key);
        } else {
#line 433
          tmp___19 = __builtin_strcmp("*", (char const   *)me->key);
#line 433
          tmp___16 = tmp___19;
        }
      } else {
#line 433
        tmp___19 = __builtin_strcmp("*", (char const   *)me->key);
#line 433
        tmp___16 = tmp___19;
      }
#line 433
      if (tmp___16 == 0) {
        goto done;
      }
#line 432
      me = me->next;
    }
  }
  done: 
#line 437
  return (me);
}
}
#line 441 "cache.c"
struct mapent *cache_lookup_distinct(struct mapent_cache *mc , char const   *key ) 
{ struct mapent *me ;
  unsigned int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 445
  if (! key) {
#line 446
    return ((struct mapent *)((void *)0));
  }
#line 448
  tmp = hash(key);
#line 448
  me = (*(mc->hash + tmp));
#line 448
  while ((unsigned int )me != (unsigned int )((void *)0)) {
#line 449
    if (0) {
#line 449
      __s1_len = strlen(key);
#line 449
      __s2_len = strlen((char const   *)me->key);
#line 449
      if (! ((unsigned int )((void const   *)(key + 1)) - (unsigned int )((void const   *)key) == 1U)) {
        goto _L___0;
      } else {
#line 449
        if (__s1_len >= 4U) {
          _L___0: 
#line 449
          if (! ((unsigned int )((void const   *)(me->key + 1)) - (unsigned int )((void const   *)me->key) == 1U)) {
#line 449
            tmp___9 = 1;
          } else {
#line 449
            if (__s2_len >= 4U) {
#line 449
              tmp___9 = 1;
            } else {
#line 449
              tmp___9 = 0;
            }
          }
        } else {
#line 449
          tmp___9 = 0;
        }
      }
#line 449
      if (tmp___9) {
#line 449
        tmp___5 = __builtin_strcmp(key, (char const   *)me->key);
      } else {
#line 449
        tmp___8 = __builtin_strcmp(key, (char const   *)me->key);
#line 449
        tmp___5 = tmp___8;
      }
    } else {
#line 449
      tmp___8 = __builtin_strcmp(key, (char const   *)me->key);
#line 449
      tmp___5 = tmp___8;
    }
#line 449
    if (tmp___5 == 0) {
#line 450
      return (me);
    }
#line 448
    me = me->next;
  }
#line 453
  return ((struct mapent *)((void *)0));
}
}
#line 457 "cache.c"
struct mapent *cache_lookup_offset(char const   *prefix , char const   *offset , int start ,
                                   struct list_head *head ) 
{ struct list_head *p ;
  struct mapent *this ;
  int plen ;
  int tmp ;
  char *o_key ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 461
  tmp = (int )strlen(prefix);
#line 461
  plen = tmp;
#line 465
  if (plen > 1) {
#line 466
    tmp___0 = strlen(offset);
#line 466
    o_key = (char *)__builtin_alloca(((unsigned int )plen + tmp___0) + 1U);
#line 467
    strcpy((char * __restrict  )o_key, (char const   * __restrict  )prefix);
#line 468
    strcat((char * __restrict  )o_key, (char const   * __restrict  )offset);
  } else {
#line 470
    tmp___1 = strlen(offset);
#line 470
    o_key = (char *)__builtin_alloca(tmp___1 + 1U);
#line 471
    strcpy((char * __restrict  )o_key, (char const   * __restrict  )offset);
  }
#line 474
  p = head->next;
#line 474
  while ((unsigned int )p != (unsigned int )head) {
#line 475
    this = (struct mapent *)((char *)p - (unsigned long )(& ((struct mapent *)0)->multi_list));
#line 476
    if (0) {
#line 476
      __s1_len = strlen((char const   *)(this->key + start));
#line 476
      __s2_len = strlen((char const   *)o_key);
#line 476
      if (! ((unsigned int )((void const   *)((this->key + start) + 1)) - (unsigned int )((void const   *)(this->key + start)) == 1U)) {
        goto _L___0;
      } else {
#line 476
        if (__s1_len >= 4U) {
          _L___0: 
#line 476
          if (! ((unsigned int )((void const   *)(o_key + 1)) - (unsigned int )((void const   *)o_key) == 1U)) {
#line 476
            tmp___11 = 1;
          } else {
#line 476
            if (__s2_len >= 4U) {
#line 476
              tmp___11 = 1;
            } else {
#line 476
              tmp___11 = 0;
            }
          }
        } else {
#line 476
          tmp___11 = 0;
        }
      }
#line 476
      if (tmp___11) {
#line 476
        tmp___7 = __builtin_strcmp((char const   *)(this->key + start), (char const   *)o_key);
      } else {
#line 476
        tmp___10 = __builtin_strcmp((char const   *)(this->key + start), (char const   *)o_key);
#line 476
        tmp___7 = tmp___10;
      }
    } else {
#line 476
      tmp___10 = __builtin_strcmp((char const   *)(this->key + start), (char const   *)o_key);
#line 476
      tmp___7 = tmp___10;
    }
#line 476
    if (! tmp___7) {
      goto done;
    }
#line 474
    p = p->next;
  }
#line 479
  this = (struct mapent *)((void *)0);
  done: 
#line 481
  return (this);
}
}
#line 485 "cache.c"
struct mapent *cache_partial_match(struct mapent_cache *mc , char const   *prefix ) 
{ struct mapent *me ;
  size_t len ;
  size_t tmp ;
  unsigned int i ;
  size_t tmp___0 ;
  int tmp___14 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;
  size_t tmp___27 ;
  int tmp___41 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___47 ;
  int tmp___50 ;
  int tmp___51 ;

  {
#line 487
  me = (struct mapent *)((void *)0);
#line 488
  tmp = strlen(prefix);
#line 488
  len = tmp;
#line 491
  i = 0U;
#line 491
  while (i < mc->size) {
#line 492
    me = (*(mc->hash + i));
#line 493
    if ((unsigned int )me == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 496
    tmp___0 = strlen((char const   *)me->key);
#line 497
    if (len < tmp___0) {
#line 497
      if (0) {
#line 497
        if (0) {
#line 497
          __s1_len___0 = strlen(prefix);
#line 497
          __s2_len___0 = strlen((char const   *)me->key);
#line 497
          if (! ((unsigned int )((void const   *)(prefix + 1)) - (unsigned int )((void const   *)prefix) == 1U)) {
            goto _L___2;
          } else {
#line 497
            if (__s1_len___0 >= 4U) {
              _L___2: 
#line 497
              if (! ((unsigned int )((void const   *)(me->key + 1)) - (unsigned int )((void const   *)me->key) == 1U)) {
#line 497
                tmp___24 = 1;
              } else {
#line 497
                if (__s2_len___0 >= 4U) {
#line 497
                  tmp___24 = 1;
                } else {
#line 497
                  tmp___24 = 0;
                }
              }
            } else {
#line 497
              tmp___24 = 0;
            }
          }
#line 497
          if (tmp___24) {
#line 497
            tmp___20 = __builtin_strcmp(prefix, (char const   *)me->key);
          } else {
#line 497
            tmp___23 = __builtin_strcmp(prefix, (char const   *)me->key);
#line 497
            tmp___20 = tmp___23;
          }
        } else {
#line 497
          tmp___23 = __builtin_strcmp(prefix, (char const   *)me->key);
#line 497
          tmp___20 = tmp___23;
        }
#line 497
        tmp___14 = tmp___20;
      } else {
#line 497
        tmp___14 = strncmp(prefix, (char const   *)me->key, len);
      }
#line 497
      if (tmp___14 == 0) {
#line 497
        if ((int )(*(me->key + len)) == 47) {
#line 498
          return (me);
        }
      }
    }
#line 500
    me = me->next;
#line 501
    while ((unsigned int )me != (unsigned int )((void *)0)) {
#line 502
      tmp___27 = strlen((char const   *)me->key);
#line 503
      if (len < tmp___27) {
#line 503
        if (0) {
#line 503
          if (0) {
#line 503
            __s1_len___2 = strlen(prefix);
#line 503
            __s2_len___2 = strlen((char const   *)me->key);
#line 503
            if (! ((unsigned int )((void const   *)(prefix + 1)) - (unsigned int )((void const   *)prefix) == 1U)) {
              goto _L___6;
            } else {
#line 503
              if (__s1_len___2 >= 4U) {
                _L___6: 
#line 503
                if (! ((unsigned int )((void const   *)(me->key + 1)) - (unsigned int )((void const   *)me->key) == 1U)) {
#line 503
                  tmp___51 = 1;
                } else {
#line 503
                  if (__s2_len___2 >= 4U) {
#line 503
                    tmp___51 = 1;
                  } else {
#line 503
                    tmp___51 = 0;
                  }
                }
              } else {
#line 503
                tmp___51 = 0;
              }
            }
#line 503
            if (tmp___51) {
#line 503
              tmp___47 = __builtin_strcmp(prefix, (char const   *)me->key);
            } else {
#line 503
              tmp___50 = __builtin_strcmp(prefix, (char const   *)me->key);
#line 503
              tmp___47 = tmp___50;
            }
          } else {
#line 503
            tmp___50 = __builtin_strcmp(prefix, (char const   *)me->key);
#line 503
            tmp___47 = tmp___50;
          }
#line 503
          tmp___41 = tmp___47;
        } else {
#line 503
          tmp___41 = strncmp(prefix, (char const   *)me->key, len);
        }
#line 503
        if (tmp___41 == 0) {
#line 503
          if ((int )(*(me->key + len)) == 47) {
#line 504
            return (me);
          }
        }
      }
#line 505
      me = me->next;
    }
    __Cont: 
#line 491
    i ++;
  }
#line 508
  return ((struct mapent *)((void *)0));
}
}
#line 512 "cache.c"
int cache_add(struct mapent_cache *mc , struct map_source *ms , char const   *key ,
              char const   *mapent , time_t age ) 
{ struct mapent *me ;
  struct mapent *existing ;
  char *pkey ;
  char *pent ;
  unsigned int hashval ;
  unsigned int tmp ;
  int status ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  struct mapent *next ;

  {
#line 514
  existing = (struct mapent *)((void *)0);
#line 516
  tmp = hash(key);
#line 516
  hashval = tmp;
#line 519
  me = (struct mapent *)malloc(sizeof(struct mapent ));
#line 520
  if (! me) {
#line 521
    return (0);
  }
#line 523
  tmp___1 = strlen(key);
#line 523
  pkey = (char *)malloc(tmp___1 + 1U);
#line 524
  if (! pkey) {
#line 525
    free((void *)me);
#line 526
    return (0);
  }
#line 528
  me->key = strcpy((char * __restrict  )pkey, (char const   * __restrict  )key);
#line 530
  if (mapent) {
#line 531
    tmp___2 = strlen(mapent);
#line 531
    pent = (char *)malloc(tmp___2 + 1U);
#line 532
    if (! pent) {
#line 533
      free((void *)me);
#line 534
      free((void *)pkey);
#line 535
      return (0);
    }
#line 537
    me->mapent = strcpy((char * __restrict  )pent, (char const   * __restrict  )mapent);
  } else {
#line 539
    me->mapent = (char *)((void *)0);
  }
#line 541
  me->age = age;
#line 542
  me->status = 0L;
#line 543
  me->mc = mc;
#line 544
  me->source = ms;
#line 545
  while (1) {
#line 545
    me->ino_index.next = & me->ino_index;
#line 545
    me->ino_index.prev = & me->ino_index;
#line 545
    break;
  }
#line 546
  while (1) {
#line 546
    me->multi_list.next = & me->multi_list;
#line 546
    me->multi_list.prev = & me->multi_list;
#line 546
    break;
  }
#line 547
  me->multi = (struct mapent *)((void *)0);
#line 548
  me->parent = (struct mapent *)((void *)0);
#line 549
  me->ioctlfd = -1;
#line 550
  me->dev = 0xffffffffffffffffULL;
#line 551
  me->ino = 4294967295UL;
#line 553
  status = pthread_mutex_init(& me->multi_mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 554
  if (status) {
#line 555
    while (1) {
#line 555
      if (status == 35) {
#line 555
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "cache_add", 555, "cache.c");
#line 555
        dump_core();
      }
#line 555
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 555,
                    "cache.c");
#line 555
      abort();
#line 555
      break;
    }
  }
#line 561
  existing = cache_lookup_distinct(mc, key);
#line 562
  if (! existing) {
#line 563
    me->next = (*(mc->hash + hashval));
#line 564
    (*(mc->hash + hashval)) = me;
  } else {
#line 566
    while (1) {
#line 569
      next = cache_lookup_key_next(existing);
#line 570
      if (! next) {
#line 571
        break;
      }
#line 573
      existing = next;
    }
#line 575
    me->next = existing->next;
#line 576
    existing->next = me;
  }
#line 578
  return (1);
}
}
#line 582 "cache.c"
static void cache_add_ordered_offset(struct mapent *me , struct list_head *head ) 
{ struct list_head *p ;
  struct mapent *this ;
  size_t tlen ;
  int eq ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___17 ;
  int tmp___20 ;
  int tmp___21 ;
  size_t tmp___24 ;

  {
#line 587
  p = head->next;
#line 587
  while ((unsigned int )p != (unsigned int )head) {
#line 591
    this = (struct mapent *)((char *)p - (unsigned long )(& ((struct mapent *)0)->multi_list));
#line 592
    tlen = strlen((char const   *)this->key);
#line 594
    if (0) {
#line 594
      if (0) {
#line 594
        __s1_len___0 = strlen((char const   *)this->key);
#line 594
        __s2_len___0 = strlen((char const   *)me->key);
#line 594
        if (! ((unsigned int )((void const   *)(this->key + 1)) - (unsigned int )((void const   *)this->key) == 1U)) {
          goto _L___2;
        } else {
#line 594
          if (__s1_len___0 >= 4U) {
            _L___2: 
#line 594
            if (! ((unsigned int )((void const   *)(me->key + 1)) - (unsigned int )((void const   *)me->key) == 1U)) {
#line 594
              tmp___21 = 1;
            } else {
#line 594
              if (__s2_len___0 >= 4U) {
#line 594
                tmp___21 = 1;
              } else {
#line 594
                tmp___21 = 0;
              }
            }
          } else {
#line 594
            tmp___21 = 0;
          }
        }
#line 594
        if (tmp___21) {
#line 594
          tmp___17 = __builtin_strcmp((char const   *)this->key, (char const   *)me->key);
        } else {
#line 594
          tmp___20 = __builtin_strcmp((char const   *)this->key, (char const   *)me->key);
#line 594
          tmp___17 = tmp___20;
        }
      } else {
#line 594
        tmp___20 = __builtin_strcmp((char const   *)this->key, (char const   *)me->key);
#line 594
        tmp___17 = tmp___20;
      }
#line 594
      eq = tmp___17;
    } else {
#line 594
      eq = strncmp((char const   *)this->key, (char const   *)me->key, tlen);
    }
#line 595
    if (! eq) {
#line 595
      tmp___24 = strlen((char const   *)me->key);
#line 595
      if (tlen == tmp___24) {
#line 596
        return;
      }
    }
#line 598
    if (eq > 0) {
#line 599
      list_add_tail(& me->multi_list, p);
#line 600
      return;
    }
#line 587
    p = p->next;
  }
#line 603
  list_add_tail(& me->multi_list, p);
#line 605
  return;
}
}
#line 609 "cache.c"
int cache_add_offset(struct mapent_cache *mc , char const   *mkey , char const   *key ,
                     char const   *mapent , time_t age ) 
{ struct mapent *me ;
  struct mapent *owner ;
  int ret ;

  {
#line 612
  ret = 1;
#line 614
  owner = cache_lookup_distinct(mc, mkey);
#line 615
  if (! owner) {
#line 616
    return (0);
  }
#line 618
  me = cache_lookup_distinct(mc, key);
#line 619
  if (me) {
#line 619
    if ((unsigned int )me != (unsigned int )owner) {
#line 620
      return (32);
    }
  }
#line 622
  ret = cache_add(mc, owner->source, key, mapent, age);
#line 623
  if (ret == 0) {
#line 624
    while (1) {
#line 624
      ((*log_warn))(3U, "%s: failed to add key %s to cache", "cache_add_offset", key);
#line 624
      break;
    }
#line 625
    return (0);
  }
#line 628
  me = cache_lookup_distinct(mc, key);
#line 629
  if (me) {
#line 630
    cache_add_ordered_offset(me, & owner->multi_list);
#line 631
    me->multi = owner;
    goto done;
  }
#line 634
  ret = 0;
  done: 
#line 636
  return (ret);
}
}
#line 639 "cache.c"
static struct mapent *get_parent(char const   *key , struct list_head *head , struct list_head **pos ) 
{ struct list_head *next ;
  struct mapent *this ;
  struct mapent *last ;
  int eq ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___31 ;
  int tmp___34 ;
  int tmp___35 ;
  size_t tmp___36 ;

  {
#line 645
  last = (struct mapent *)((void *)0);
#line 646
  if ((*pos)) {
#line 646
    next = ((*pos))->next;
  } else {
#line 646
    next = head->next;
  }
#line 648
  next = head->next;
#line 648
  while ((unsigned int )next != (unsigned int )head) {
#line 649
    this = (struct mapent *)((char *)next - (unsigned long )(& ((struct mapent *)0)->multi_list));
#line 651
    if (0) {
#line 651
      __s1_len = strlen((char const   *)this->key);
#line 651
      __s2_len = strlen(key);
#line 651
      if (! ((unsigned int )((void const   *)(this->key + 1)) - (unsigned int )((void const   *)this->key) == 1U)) {
        goto _L___0;
      } else {
#line 651
        if (__s1_len >= 4U) {
          _L___0: 
#line 651
          if (! ((unsigned int )((void const   *)(key + 1)) - (unsigned int )((void const   *)key) == 1U)) {
#line 651
            tmp___8 = 1;
          } else {
#line 651
            if (__s2_len >= 4U) {
#line 651
              tmp___8 = 1;
            } else {
#line 651
              tmp___8 = 0;
            }
          }
        } else {
#line 651
          tmp___8 = 0;
        }
      }
#line 651
      if (tmp___8) {
#line 651
        tmp___4 = __builtin_strcmp((char const   *)this->key, key);
      } else {
#line 651
        tmp___7 = __builtin_strcmp((char const   *)this->key, key);
#line 651
        tmp___4 = tmp___7;
      }
    } else {
#line 651
      tmp___7 = __builtin_strcmp((char const   *)this->key, key);
#line 651
      tmp___4 = tmp___7;
    }
#line 651
    if (! tmp___4) {
#line 652
      break;
    }
#line 654
    if (0) {
#line 654
      if (0) {
#line 654
        __s1_len___1 = strlen((char const   *)this->key);
#line 654
        __s2_len___1 = strlen(key);
#line 654
        if (! ((unsigned int )((void const   *)(this->key + 1)) - (unsigned int )((void const   *)this->key) == 1U)) {
          goto _L___4;
        } else {
#line 654
          if (__s1_len___1 >= 4U) {
            _L___4: 
#line 654
            if (! ((unsigned int )((void const   *)(key + 1)) - (unsigned int )((void const   *)key) == 1U)) {
#line 654
              tmp___35 = 1;
            } else {
#line 654
              if (__s2_len___1 >= 4U) {
#line 654
                tmp___35 = 1;
              } else {
#line 654
                tmp___35 = 0;
              }
            }
          } else {
#line 654
            tmp___35 = 0;
          }
        }
#line 654
        if (tmp___35) {
#line 654
          tmp___31 = __builtin_strcmp((char const   *)this->key, key);
        } else {
#line 654
          tmp___34 = __builtin_strcmp((char const   *)this->key, key);
#line 654
          tmp___31 = tmp___34;
        }
      } else {
#line 654
        tmp___34 = __builtin_strcmp((char const   *)this->key, key);
#line 654
        tmp___31 = tmp___34;
      }
#line 654
      eq = tmp___31;
    } else {
#line 654
      tmp___36 = strlen((char const   *)this->key);
#line 654
      eq = strncmp((char const   *)this->key, key, tmp___36);
    }
#line 655
    if (eq == 0) {
#line 656
      (*pos) = next;
#line 657
      last = this;
      goto __Cont;
    }
    __Cont: 
#line 648
    next = next->next;
  }
#line 662
  return (last);
}
}
#line 665 "cache.c"
int cache_set_parents(struct mapent *mm ) 
{ struct list_head *multi_head ;
  struct list_head *p ;
  struct list_head *pos ;
  struct mapent *this ;
  struct mapent *parent ;

  {
#line 670
  if (! mm->multi) {
#line 671
    return (0);
  }
#line 673
  pos = (struct list_head *)((void *)0);
#line 674
  multi_head = & (mm->multi)->multi_list;
#line 676
  p = multi_head->next;
#line 676
  while ((unsigned int )p != (unsigned int )multi_head) {
#line 678
    this = (struct mapent *)((char *)p - (unsigned long )(& ((struct mapent *)0)->multi_list));
#line 679
    parent = get_parent((char const   *)this->key, multi_head, & pos);
#line 680
    if (parent) {
#line 681
      this->parent = parent;
    } else {
#line 683
      this->parent = mm->multi;
    }
#line 676
    p = p->next;
  }
#line 686
  return (1);
}
}
#line 690 "cache.c"
int cache_update(struct mapent_cache *mc , struct map_source *ms , char const   *key ,
                 char const   *mapent , time_t age ) 
{ struct mapent *me ;
  char *pent ;
  int ret ;
  size_t tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 692
  me = (struct mapent *)((void *)0);
#line 694
  ret = 1;
#line 696
  me = cache_lookup(mc, key);
#line 697
  if (! me) {
    goto _L___2;
  } else {
#line 697
    if ((int )(*(me->key)) == 42) {
#line 697
      if ((int const   )(*key) != 42) {
        _L___2: 
#line 698
        ret = cache_add(mc, ms, key, mapent, age);
#line 699
        if (! ret) {
#line 700
          while (1) {
#line 700
            ((*log_debug))(0U, "%s: failed for %s", "cache_update", key);
#line 700
            break;
          }
#line 701
          return (0);
        }
#line 703
        ret = 2;
      } else {
        goto _L___3;
      }
    } else {
      _L___3: 
#line 706
      if (me->age == age) {
#line 707
        return (1);
      }
#line 709
      if (! mapent) {
#line 710
        if (me->mapent) {
#line 711
          free((void *)me->mapent);
        }
#line 712
        me->mapent = (char *)((void *)0);
      } else {
#line 713
        if (! me->mapent) {
          goto _L___1;
        } else {
#line 713
          if (0) {
#line 713
            __s1_len = strlen((char const   *)me->mapent);
#line 713
            __s2_len = strlen(mapent);
#line 713
            if (! ((unsigned int )((void const   *)(me->mapent + 1)) - (unsigned int )((void const   *)me->mapent) == 1U)) {
              goto _L___0;
            } else {
#line 713
              if (__s1_len >= 4U) {
                _L___0: 
#line 713
                if (! ((unsigned int )((void const   *)(mapent + 1)) - (unsigned int )((void const   *)mapent) == 1U)) {
#line 713
                  tmp___9 = 1;
                } else {
#line 713
                  if (__s2_len >= 4U) {
#line 713
                    tmp___9 = 1;
                  } else {
#line 713
                    tmp___9 = 0;
                  }
                }
              } else {
#line 713
                tmp___9 = 0;
              }
            }
#line 713
            if (tmp___9) {
#line 713
              tmp___5 = __builtin_strcmp((char const   *)me->mapent, mapent);
            } else {
#line 713
              tmp___8 = __builtin_strcmp((char const   *)me->mapent, mapent);
#line 713
              tmp___5 = tmp___8;
            }
          } else {
#line 713
            tmp___8 = __builtin_strcmp((char const   *)me->mapent, mapent);
#line 713
            tmp___5 = tmp___8;
          }
#line 713
          if (tmp___5 != 0) {
            _L___1: 
#line 714
            tmp = strlen(mapent);
#line 714
            pent = (char *)malloc(tmp + 1U);
#line 715
            if ((unsigned int )pent == (unsigned int )((void *)0)) {
#line 716
              return (0);
            }
#line 717
            if (me->mapent) {
#line 718
              free((void *)me->mapent);
            }
#line 719
            me->mapent = strcpy((char * __restrict  )pent, (char const   * __restrict  )mapent);
#line 720
            ret = 2;
          }
        }
      }
#line 722
      me->age = age;
    }
  }
#line 724
  return (ret);
}
}
#line 728 "cache.c"
int cache_delete(struct mapent_cache *mc , char const   *key ) 
{ struct mapent *me ;
  struct mapent *pred ;
  unsigned int hashval ;
  unsigned int tmp ;
  int status ;
  int ret ;
  char *this ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 730
  me = (struct mapent *)((void *)0);
#line 731
  tmp = hash(key);
#line 731
  hashval = tmp;
#line 732
  ret = 1;
#line 735
  tmp___0 = strlen(key);
#line 735
  this = (char *)__builtin_alloca(tmp___0 + 1U);
#line 736
  if (! this) {
#line 737
    ret = 0;
    goto done;
  }
#line 740
  strcpy((char * __restrict  )this, (char const   * __restrict  )key);
#line 742
  me = (*(mc->hash + hashval));
#line 743
  if (! me) {
#line 744
    ret = 0;
    goto done;
  }
#line 748
  while ((unsigned int )me->next != (unsigned int )((void *)0)) {
#line 749
    pred = me;
#line 750
    me = me->next;
#line 751
    if (0) {
#line 751
      __s1_len = strlen((char const   *)this);
#line 751
      __s2_len = strlen((char const   *)me->key);
#line 751
      if (! ((unsigned int )((void const   *)(this + 1)) - (unsigned int )((void const   *)this) == 1U)) {
        goto _L___0;
      } else {
#line 751
        if (__s1_len >= 4U) {
          _L___0: 
#line 751
          if (! ((unsigned int )((void const   *)(me->key + 1)) - (unsigned int )((void const   *)me->key) == 1U)) {
#line 751
            tmp___11 = 1;
          } else {
#line 751
            if (__s2_len >= 4U) {
#line 751
              tmp___11 = 1;
            } else {
#line 751
              tmp___11 = 0;
            }
          }
        } else {
#line 751
          tmp___11 = 0;
        }
      }
#line 751
      if (tmp___11) {
#line 751
        tmp___7 = __builtin_strcmp((char const   *)this, (char const   *)me->key);
      } else {
#line 751
        tmp___10 = __builtin_strcmp((char const   *)this, (char const   *)me->key);
#line 751
        tmp___7 = tmp___10;
      }
    } else {
#line 751
      tmp___10 = __builtin_strcmp((char const   *)this, (char const   *)me->key);
#line 751
      tmp___7 = tmp___10;
    }
#line 751
    if (tmp___7 == 0) {
#line 752
      if (me->multi) {
#line 752
        tmp___1 = list_empty(& me->multi_list);
#line 752
        if (! tmp___1) {
#line 753
          ret = 0;
          goto done;
        }
      }
#line 756
      pred->next = me->next;
#line 757
      status = pthread_mutex_destroy(& me->multi_mutex);
#line 758
      if (status) {
#line 759
        while (1) {
#line 759
          if (status == 35) {
#line 759
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "cache_delete", 759, "cache.c");
#line 759
            dump_core();
          }
#line 759
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 759,
                        "cache.c");
#line 759
          abort();
#line 759
          break;
        }
      }
#line 760
      ino_index_lock(mc);
#line 761
      list_del(& me->ino_index);
#line 762
      ino_index_unlock(mc);
#line 763
      free((void *)me->key);
#line 764
      if (me->mapent) {
#line 765
        free((void *)me->mapent);
      }
#line 766
      free((void *)me);
#line 767
      me = pred;
    }
  }
#line 771
  me = (*(mc->hash + hashval));
#line 772
  if (! me) {
    goto done;
  }
#line 775
  if (0) {
#line 775
    __s1_len___0 = strlen((char const   *)this);
#line 775
    __s2_len___0 = strlen((char const   *)me->key);
#line 775
    if (! ((unsigned int )((void const   *)(this + 1)) - (unsigned int )((void const   *)this) == 1U)) {
      goto _L___2;
    } else {
#line 775
      if (__s1_len___0 >= 4U) {
        _L___2: 
#line 775
        if (! ((unsigned int )((void const   *)(me->key + 1)) - (unsigned int )((void const   *)me->key) == 1U)) {
#line 775
          tmp___22 = 1;
        } else {
#line 775
          if (__s2_len___0 >= 4U) {
#line 775
            tmp___22 = 1;
          } else {
#line 775
            tmp___22 = 0;
          }
        }
      } else {
#line 775
        tmp___22 = 0;
      }
    }
#line 775
    if (tmp___22) {
#line 775
      tmp___18 = __builtin_strcmp((char const   *)this, (char const   *)me->key);
    } else {
#line 775
      tmp___21 = __builtin_strcmp((char const   *)this, (char const   *)me->key);
#line 775
      tmp___18 = tmp___21;
    }
  } else {
#line 775
    tmp___21 = __builtin_strcmp((char const   *)this, (char const   *)me->key);
#line 775
    tmp___18 = tmp___21;
  }
#line 775
  if (tmp___18 == 0) {
#line 776
    if (me->multi) {
#line 776
      tmp___12 = list_empty(& me->multi_list);
#line 776
      if (! tmp___12) {
#line 777
        ret = 0;
        goto done;
      }
    }
#line 780
    (*(mc->hash + hashval)) = me->next;
#line 781
    status = pthread_mutex_destroy(& me->multi_mutex);
#line 782
    if (status) {
#line 783
      while (1) {
#line 783
        if (status == 35) {
#line 783
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "cache_delete", 783, "cache.c");
#line 783
          dump_core();
        }
#line 783
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 783,
                      "cache.c");
#line 783
        abort();
#line 783
        break;
      }
    }
#line 784
    ino_index_lock(mc);
#line 785
    list_del(& me->ino_index);
#line 786
    ino_index_unlock(mc);
#line 787
    free((void *)me->key);
#line 788
    if (me->mapent) {
#line 789
      free((void *)me->mapent);
    }
#line 790
    free((void *)me);
  }
  done: 
#line 793
  return (ret);
}
}
#line 797 "cache.c"
int cache_delete_offset_list(struct mapent_cache *mc , char const   *key ) 
{ struct mapent *me ;
  struct mapent *this ;
  struct list_head *head ;
  struct list_head *next ;
  int remain ;
  int status ;

  {
#line 802
  remain = 0;
#line 805
  me = cache_lookup_distinct(mc, key);
#line 806
  if (! me) {
#line 807
    return (0);
  }
#line 810
  if ((unsigned int )me->multi != (unsigned int )me) {
#line 811
    return (0);
  }
#line 813
  head = & me->multi_list;
#line 814
  next = head->next;
#line 815
  while ((unsigned int )next != (unsigned int )head) {
#line 816
    this = (struct mapent *)((char *)next - (unsigned long )(& ((struct mapent *)0)->multi_list));
#line 817
    next = next->next;
#line 818
    if (this->ioctlfd != -1) {
#line 819
      while (1) {
#line 819
        ((*log_error))(3U, "%s: active offset mount key %s", "cache_delete_offset_list",
                       this->key);
#line 819
        break;
      }
#line 821
      return (0);
    }
  }
#line 825
  head = & me->multi_list;
#line 826
  next = head->next;
#line 827
  while ((unsigned int )next != (unsigned int )head) {
#line 828
    this = (struct mapent *)((char *)next - (unsigned long )(& ((struct mapent *)0)->multi_list));
#line 829
    next = next->next;
#line 830
    list_del_init(& this->multi_list);
#line 831
    this->multi = (struct mapent *)((void *)0);
#line 832
    while (1) {
#line 832
      ((*log_debug))(0U, "%s: deleting offset key %s", "cache_delete_offset_list",
                     this->key);
#line 832
      break;
    }
#line 833
    status = cache_delete(mc, (char const   *)this->key);
#line 834
    if (status == 0) {
#line 835
      while (1) {
#line 835
        ((*log_warn))(3U, "%s: failed to delete offset %s", "cache_delete_offset_list",
                      this->key);
#line 835
        break;
      }
#line 837
      this->multi = me;
#line 839
      remain ++;
    }
  }
#line 843
  if (! remain) {
#line 844
    list_del_init(& me->multi_list);
#line 845
    me->multi = (struct mapent *)((void *)0);
  }
#line 848
  if (remain) {
#line 849
    return (0);
  }
#line 851
  return (1);
}
}
#line 854 "cache.c"
void cache_release(struct map_source *map ) 
{ struct mapent_cache *mc ;
  struct mapent *me ;
  struct mapent *next ;
  int status ;
  unsigned int i ;

  {
#line 861
  mc = map->mc;
#line 863
  cache_writelock(mc);
#line 865
  i = 0U;
#line 865
  while (i < mc->size) {
#line 866
    me = (*(mc->hash + i));
#line 867
    if ((unsigned int )me == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 869
    next = me->next;
#line 870
    free((void *)me->key);
#line 871
    if (me->mapent) {
#line 872
      free((void *)me->mapent);
    }
#line 873
    free((void *)me);
#line 875
    while ((unsigned int )next != (unsigned int )((void *)0)) {
#line 876
      me = next;
#line 877
      next = me->next;
#line 878
      free((void *)me->key);
#line 879
      if (me->mapent) {
#line 880
        free((void *)me->mapent);
      }
#line 881
      free((void *)me);
    }
    __Cont: 
#line 865
    i ++;
  }
#line 885
  map->mc = (struct mapent_cache *)((void *)0);
#line 887
  cache_unlock(mc);
#line 889
  status = pthread_mutex_destroy(& mc->ino_index_mutex);
#line 890
  if (status) {
#line 891
    while (1) {
#line 891
      if (status == 35) {
#line 891
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "cache_release", 891, "cache.c");
#line 891
        dump_core();
      }
#line 891
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 891,
                    "cache.c");
#line 891
      abort();
#line 891
      break;
    }
  }
#line 893
  status = pthread_rwlock_destroy(& mc->rwlock);
#line 894
  if (status) {
#line 895
    while (1) {
#line 895
      if (status == 35) {
#line 895
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "cache_release", 895, "cache.c");
#line 895
        dump_core();
      }
#line 895
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 895,
                    "cache.c");
#line 895
      abort();
#line 895
      break;
    }
  }
#line 897
  free((void *)mc->hash);
#line 898
  free((void *)mc->ino_index);
#line 899
  free((void *)mc);
#line 900
  return;
}
}
#line 902 "cache.c"
void cache_release_null_cache(struct master *master ) 
{ struct mapent_cache *mc ;
  struct mapent *me ;
  struct mapent *next ;
  int status ;
  unsigned int i ;

  {
#line 909
  mc = master->nc;
#line 911
  cache_writelock(mc);
#line 913
  i = 0U;
#line 913
  while (i < mc->size) {
#line 914
    me = (*(mc->hash + i));
#line 915
    if ((unsigned int )me == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 917
    next = me->next;
#line 918
    free((void *)me->key);
#line 919
    if (me->mapent) {
#line 920
      free((void *)me->mapent);
    }
#line 921
    free((void *)me);
#line 923
    while ((unsigned int )next != (unsigned int )((void *)0)) {
#line 924
      me = next;
#line 925
      next = me->next;
#line 926
      free((void *)me->key);
#line 927
      free((void *)me);
    }
    __Cont: 
#line 913
    i ++;
  }
#line 931
  master->nc = (struct mapent_cache *)((void *)0);
#line 933
  cache_unlock(mc);
#line 935
  status = pthread_mutex_destroy(& mc->ino_index_mutex);
#line 936
  if (status) {
#line 937
    while (1) {
#line 937
      if (status == 35) {
#line 937
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "cache_release_null_cache", 937, "cache.c");
#line 937
        dump_core();
      }
#line 937
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 937,
                    "cache.c");
#line 937
      abort();
#line 937
      break;
    }
  }
#line 939
  status = pthread_rwlock_destroy(& mc->rwlock);
#line 940
  if (status) {
#line 941
    while (1) {
#line 941
      if (status == 35) {
#line 941
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "cache_release_null_cache", 941, "cache.c");
#line 941
        dump_core();
      }
#line 941
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 941,
                    "cache.c");
#line 941
      abort();
#line 941
      break;
    }
  }
#line 943
  free((void *)mc->hash);
#line 944
  free((void *)mc->ino_index);
#line 945
  free((void *)mc);
#line 946
  return;
}
}
#line 951 "cache.c"
struct mapent *cache_enumerate(struct mapent_cache *mc , struct mapent *me ) 
{ struct mapent *tmp ;
  struct mapent *tmp___0 ;

  {
#line 953
  if (! me) {
#line 954
    tmp = cache_lookup_first(mc);
#line 954
    return (tmp);
  }
#line 956
  tmp___0 = cache_lookup_next(mc, me);
#line 956
  return (tmp___0);
}
}
#line 966 "cache.c"
char *cache_get_offset(char const   *prefix , char *offset , int start , struct list_head *head ,
                       struct list_head **pos ) 
{ struct list_head *next ;
  struct mapent *this ;
  size_t plen ;
  size_t tmp ;
  size_t len ;
  char *offset_start ;
  char *pstart ;
  char *pend ;
  size_t tmp___0 ;
  char *tmp___1 ;
  int tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  char *offset_start___0 ;
  char *pstart___0 ;
  size_t tmp___28 ;
  int tmp___42 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___48 ;
  int tmp___51 ;
  int tmp___52 ;
  char *tmp___55 ;

  {
#line 971
  tmp = strlen(prefix);
#line 971
  plen = tmp;
#line 972
  len = 0U;
#line 974
  if ((unsigned int )(*pos) == (unsigned int )head) {
#line 975
    return ((char *)((void *)0));
  }
#line 978
  (*offset) = (char )'\000';
#line 979
  if ((*pos)) {
#line 979
    next = ((*pos))->next;
  } else {
#line 979
    next = head->next;
  }
#line 980
  while ((unsigned int )next != (unsigned int )head) {
#line 983
    this = (struct mapent *)((char *)next - (unsigned long )(& ((struct mapent *)0)->multi_list));
#line 984
    (*pos) = next;
#line 985
    next = next->next;
#line 987
    offset_start = this->key + start;
#line 988
    tmp___0 = strlen((char const   *)offset_start);
#line 988
    if (tmp___0 <= plen) {
#line 989
      continue;
    }
#line 991
    if (0) {
#line 991
      if (0) {
#line 991
        __s1_len___0 = strlen(prefix);
#line 991
        __s2_len___0 = strlen((char const   *)offset_start);
#line 991
        if (! ((unsigned int )((void const   *)(prefix + 1)) - (unsigned int )((void const   *)prefix) == 1U)) {
          goto _L___2;
        } else {
#line 991
          if (__s1_len___0 >= 4U) {
            _L___2: 
#line 991
            if (! ((unsigned int )((void const   *)(offset_start + 1)) - (unsigned int )((void const   *)offset_start) == 1U)) {
#line 991
              tmp___25 = 1;
            } else {
#line 991
              if (__s2_len___0 >= 4U) {
#line 991
                tmp___25 = 1;
              } else {
#line 991
                tmp___25 = 0;
              }
            }
          } else {
#line 991
            tmp___25 = 0;
          }
        }
#line 991
        if (tmp___25) {
#line 991
          tmp___21 = __builtin_strcmp(prefix, (char const   *)offset_start);
        } else {
#line 991
          tmp___24 = __builtin_strcmp(prefix, (char const   *)offset_start);
#line 991
          tmp___21 = tmp___24;
        }
      } else {
#line 991
        tmp___24 = __builtin_strcmp(prefix, (char const   *)offset_start);
#line 991
        tmp___21 = tmp___24;
      }
#line 991
      tmp___15 = tmp___21;
    } else {
#line 991
      tmp___15 = strncmp(prefix, (char const   *)offset_start, plen);
    }
#line 991
    if (! tmp___15) {
#line 993
      if (plen == 1U) {
#line 994
        pstart = offset_start + (plen - 1U);
      } else {
#line 996
        pstart = offset_start + plen;
      }
#line 999
      if ((int )(*pstart) != 47) {
#line 1000
        continue;
      }
#line 1003
      pend = pstart;
#line 1004
      while (1) {
#line 1004
        tmp___1 = pend;
#line 1004
        pend ++;
#line 1004
        if (! (*tmp___1)) {
#line 1004
          break;
        }
      }
#line 1005
      len = (unsigned int )((pend - pstart) - 1);
#line 1006
      __builtin_strncpy(offset, (char const   *)pstart, len);
#line 1007
      (*(offset + len)) = (char )'\000';
#line 1008
      break;
    }
  }
#line 1013
  while ((unsigned int )next != (unsigned int )head) {
#line 1016
    this = (struct mapent *)((char *)next - (unsigned long )(& ((struct mapent *)0)->multi_list));
#line 1018
    offset_start___0 = this->key + start;
#line 1019
    tmp___28 = strlen((char const   *)offset_start___0);
#line 1019
    if (tmp___28 <= plen + len) {
#line 1020
      break;
    }
#line 1023
    if (plen == 1U) {
#line 1024
      pstart___0 = offset_start___0 + (plen - 1U);
    } else {
#line 1026
      pstart___0 = offset_start___0 + plen;
    }
#line 1029
    if ((int )(*pstart___0) != 47) {
#line 1030
      break;
    }
#line 1033
    if (! (*((pstart___0 + len) + 1))) {
#line 1034
      break;
    }
#line 1037
    if ((int )(*(pstart___0 + len)) != 47) {
#line 1038
      break;
    } else {
#line 1037
      if (0) {
#line 1037
        if (0) {
#line 1037
          __s1_len___2 = strlen((char const   *)offset);
#line 1037
          __s2_len___2 = strlen((char const   *)pstart___0);
#line 1037
          if (! ((unsigned int )((void const   *)(offset + 1)) - (unsigned int )((void const   *)offset) == 1U)) {
            goto _L___6;
          } else {
#line 1037
            if (__s1_len___2 >= 4U) {
              _L___6: 
#line 1037
              if (! ((unsigned int )((void const   *)(pstart___0 + 1)) - (unsigned int )((void const   *)pstart___0) == 1U)) {
#line 1037
                tmp___52 = 1;
              } else {
#line 1037
                if (__s2_len___2 >= 4U) {
#line 1037
                  tmp___52 = 1;
                } else {
#line 1037
                  tmp___52 = 0;
                }
              }
            } else {
#line 1037
              tmp___52 = 0;
            }
          }
#line 1037
          if (tmp___52) {
#line 1037
            tmp___48 = __builtin_strcmp((char const   *)offset, (char const   *)pstart___0);
          } else {
#line 1037
            tmp___51 = __builtin_strcmp((char const   *)offset, (char const   *)pstart___0);
#line 1037
            tmp___48 = tmp___51;
          }
        } else {
#line 1037
          tmp___51 = __builtin_strcmp((char const   *)offset, (char const   *)pstart___0);
#line 1037
          tmp___48 = tmp___51;
        }
#line 1037
        tmp___42 = tmp___48;
      } else {
#line 1037
        tmp___42 = strncmp((char const   *)offset, (char const   *)pstart___0, len);
      }
#line 1037
      if (tmp___42) {
#line 1038
        break;
      }
    }
#line 1040
    (*pos) = next;
#line 1041
    next = next->next;
  }
#line 1044
  if ((*offset)) {
#line 1044
    tmp___55 = offset;
  } else {
#line 1044
    tmp___55 = (char *)((void *)0);
  }
#line 1044
  return (tmp___55);
}
}
#line 1 "cat_path.o"
#pragma merger(0,"/tmp/cil-s6q7zIsb.i","-O2,-Wall,-fPIC")
#line 24 "cat_path.c"
int cat_path(char *buf , size_t len , char const   *dir , char const   *base ) 
{ char *d ;
  char *b ;
  char *s ;
  size_t left ;
  size_t tmp ;
  char *tmp___0 ;

  {
#line 26
  d = (char *)dir;
#line 27
  b = (char *)base;
#line 28
  s = buf;
#line 29
  left = len;
#line 31
  (*s) = (*d);
#line 31
  if ((*s)) {
#line 32
    while (1) {
#line 32
      s ++;
#line 32
      d ++;
#line 32
      (*s) = (*d);
#line 32
      if ((*s)) {
#line 32
        left --;
#line 32
        if (! left) {
#line 32
          break;
        }
      } else {
#line 32
        break;
      }
    }
  }
#line 34
  if (! left) {
#line 35
    (*s) = (char )'\000';
#line 36
    return (0);
  }
#line 41
  while (1) {
#line 41
    s --;
#line 41
    if ((int )(*s) == 47) {
#line 41
      tmp = left;
#line 41
      left ++;
#line 41
      if (! (tmp < len)) {
#line 41
        break;
      }
    } else {
#line 41
      break;
    }
#line 42
    (*s) = (char )'\000';
  }
#line 44
  s ++;
#line 44
  (*s) = (char )'/';
#line 45
  left --;
#line 47
  if ((int )(*b) == 47) {
#line 48
    while (1) {
#line 48
      b ++;
#line 48
      if (! ((int )(*b) == 47)) {
#line 48
        break;
      }
    }
  }
#line 50
  while (1) {
#line 50
    left --;
#line 50
    if (left) {
#line 50
      s ++;
#line 50
      tmp___0 = b;
#line 50
      b ++;
#line 50
      (*s) = (*tmp___0);
#line 50
      if (! (*s)) {
#line 50
        break;
      }
    } else {
#line 50
      break;
    }
  }
#line 52
  if (! left) {
#line 53
    (*s) = (char )'\000';
#line 54
    return (0);
  }
#line 57
  return (1);
}
}
#line 60 "cat_path.c"
size_t _strlen(char const   *str , size_t max ) 
{ char const   *s ;
  size_t len ;
  char const   *tmp ;

  {
#line 62
  s = str;
#line 63
  len = 0U;
#line 65
  while (1) {
#line 65
    tmp = s;
#line 65
    s ++;
#line 65
    if ((*tmp)) {
#line 65
      if (! (len < max)) {
#line 65
        break;
      }
    } else {
#line 65
      break;
    }
#line 66
    len ++;
  }
#line 68
  return (len);
}
}
#line 76 "cat_path.c"
int ncat_path(char *buf , size_t len , char const   *dir , char const   *base , size_t blen ) 
{ char name___0[4097] ;
  size_t alen ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 80
  tmp = _strlen(base, blen);
#line 80
  alen = tmp;
#line 82
  if (blen > 4096U) {
#line 83
    return (0);
  } else {
#line 82
    if (! alen) {
#line 83
      return (0);
    }
  }
#line 85
  __builtin_strncpy(name___0, base, alen);
#line 86
  name___0[alen] = (char )'\000';
#line 88
  tmp___0 = cat_path(buf, len, dir, (char const   *)(name___0));
#line 88
  return (tmp___0);
}
}
#line 1 "defaults.o"
#pragma merger(0,"/tmp/cil-cUKdJ7Qb.i","-O2,-Wall,-fPIC")
#line 332 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) long strtol__extinline(char const   * __restrict  __nptr ,
                                                                     char ** __restrict  __endptr ,
                                                                     int __base ) ;
#line 401
__inline static  __attribute__((__nothrow__)) int atoi__extinline(char const   *__nptr ) ;
#line 406
__inline static  __attribute__((__nothrow__)) long atol__extinline(char const   *__nptr ) ;
#line 406
__inline static  __attribute__((__nothrow__)) long atol__extinline(char const   *__nptr ) ;
#line 406 "/usr/include/stdlib.h"
__inline static long atol__extinline(char const   *__nptr ) 
{ long tmp ;

  {
#line 409
  tmp = strtol__extinline((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                          10);
#line 409
  return (tmp);
}
}
#line 660
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 678
extern  __attribute__((__nothrow__)) int setenv(char const   *__name , char const   *__value ,
                                                int __replace )  __attribute__((__nonnull__(2))) ;
#line 733 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 735
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 41 "../include/defaults.h"
char const   *defaults_get_master_map(void) ;
#line 45
char const   *defaults_get_ldap_server(void) ;
#line 46
char const   *defaults_get_map_obj_class(void) ;
#line 47
char const   *defaults_get_entry_obj_class(void) ;
#line 48
char const   *defaults_get_map_attr(void) ;
#line 49
char const   *defaults_get_entry_attr(void) ;
#line 50
char const   *defaults_get_value_attr(void) ;
#line 51
unsigned int defaults_get_append_options(void) ;
#line 52
char const   *defaults_get_auth_conf_file(void) ;
#line 43 "defaults.c"
static char const   *default_master_map_name  =    "auto.master";
#line 45 "defaults.c"
static char const   *default_ldap_server  =    (char const   *)((void *)0);
#line 47 "defaults.c"
static char const   *default_map_obj_class  =    "nisMap";
#line 48 "defaults.c"
static char const   *default_entry_obj_class  =    "nisObject";
#line 49 "defaults.c"
static char const   *default_map_attr  =    "nisMapName";
#line 50 "defaults.c"
static char const   *default_entry_attr  =    "cn";
#line 51 "defaults.c"
static char const   *default_value_attr  =    "nisMapEntry";
#line 53 "defaults.c"
static char const   *default_auth_conf_file  =    "/etc/autofs_ldap_auth.conf";
#line 55 "defaults.c"
static char *get_env_string(char const   *name___0 ) 
{ char *val ;
  char *res ;
  char *tmp___8 ;

  {
#line 59
  val = getenv(name___0);
#line 60
  if (! val) {
#line 61
    return ((char *)((void *)0));
  }
#line 63
  tmp___8 = __strdup((char const   *)val);
#line 63
  res = tmp___8;
#line 64
  if (! val) {
#line 65
    return ((char *)((void *)0));
  }
#line 67
  return (res);
}
}
#line 70 "defaults.c"
static long get_env_number(char const   *name___0 ) 
{ char *val ;
  long res ;
  unsigned short const   **tmp ;

  {
#line 73
  res = -1L;
#line 75
  val = getenv(name___0);
#line 76
  if (! val) {
#line 77
    return (-1L);
  }
#line 79
  tmp = __ctype_b_loc();
#line 79
  if ((int const   )(*((*tmp) + (int )(*val))) & 2048) {
#line 80
    res = atol__extinline((char const   *)val);
  }
#line 82
  if (res < 0L) {
#line 83
    return (-1L);
  }
#line 85
  return (res);
}
}
#line 88 "defaults.c"
static int get_env_yesno(char const   *name___0 ) 
{ char const   *val ;
  int res ;
  int tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 91
  res = -1;
#line 93
  val = (char const   *)getenv(name___0);
#line 94
  if (! val) {
#line 95
    return (-1);
  }
#line 97
  tmp___1 = __ctype_b_loc();
#line 97
  if ((int const   )(*((*tmp___1) + (int )(*val))) & 2048) {
#line 98
    res = atoi__extinline(val);
  } else {
#line 99
    tmp___0 = strcasecmp(val, "yes");
#line 99
    if (tmp___0) {
#line 101
      tmp = strcasecmp(val, "no");
#line 101
      if (! tmp) {
#line 102
        return (0);
      }
    } else {
#line 100
      return (1);
    }
  }
#line 104
  return (res);
}
}
#line 111 "defaults.c"
static int check_set_config_value(char const   *res , char const   *name___0 , char const   *value ) 
{ char *old_name ;
  int ret ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 116
  tmp = strcasecmp(res, name___0);
#line 116
  if (! tmp) {
#line 117
    ret = setenv(name___0, value, 0);
#line 118
    if (ret) {
#line 119
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"can\'t set config value for %s, error %d",
              name___0, ret);
    }
#line 122
    return (1);
  }
#line 125
  tmp___0 = strlen(name___0);
#line 125
  old_name = (char *)__builtin_alloca(tmp___0 + 9U);
#line 126
  strcpy((char * __restrict  )old_name, (char const   * __restrict  )"DEFAULT_");
#line 127
  strcat((char * __restrict  )old_name, (char const   * __restrict  )name___0);
#line 129
  tmp___1 = strcasecmp(res, (char const   *)old_name);
#line 129
  if (! tmp___1) {
#line 130
    ret = setenv(name___0, value, 0);
#line 131
    if (ret) {
#line 132
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"can\'t set config value for %s, error %d",
              name___0, ret);
    }
#line 135
    return (1);
  }
#line 137
  return (0);
}
}
#line 147 "defaults.c"
unsigned int defaults_read_config(void) 
{ FILE *f ;
  char buf[256] ;
  char *res ;
  char *value ;
  char *trailer ;
  int len ;
  unsigned short const   **tmp ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *tmp___5 ;
  char *tmp___6 ;
  unsigned short const   **tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 153
  f = fopen((char const   * __restrict  )"/autofs", (char const   * __restrict  )"r");
#line 154
  if (! f) {
#line 155
    return (0U);
  }
#line 157
  while (1) {
#line 157
    res = fgets((char * __restrict  )(buf), 256, (FILE * __restrict  )f);
#line 157
    if (! res) {
#line 157
      break;
    }
#line 161
    if ((int )(*res) == 35) {
#line 162
      continue;
    } else {
#line 161
      tmp = __ctype_b_loc();
#line 161
      if (! ((int const   )(*((*tmp) + (int )(*res))) & 1024)) {
#line 162
        continue;
      }
    }
#line 164
    while (1) {
#line 164
      if ((*res)) {
#line 164
        if (! ((int )(*res) == 32)) {
#line 164
          break;
        }
      } else {
#line 164
        break;
      }
#line 165
      res ++;
    }
#line 167
    if (! res) {
#line 168
      continue;
    }
#line 170
    tmp___1 = __builtin_strchr(res, (char )'=');
#line 170
    value = tmp___1;
#line 170
    if (! value) {
#line 171
      continue;
    }
#line 173
    tmp___2 = value;
#line 173
    value ++;
#line 173
    (*tmp___2) = (char )'\000';
#line 175
    while (1) {
#line 175
      if ((*value)) {
#line 175
        if (! ((int )(*value) == 34)) {
#line 175
          tmp___3 = __ctype_b_loc();
#line 175
          if (! ((int const   )(*((*tmp___3) + (int )(*value))) & 1)) {
#line 175
            break;
          }
        }
      } else {
#line 175
        break;
      }
#line 176
      value ++;
    }
#line 178
    len = (int )strlen((char const   *)value);
#line 180
    if ((int )(*(value + (len - 1))) == 10) {
#line 181
      (*(value + (len - 1))) = (char )'\000';
#line 182
      len --;
    }
#line 185
    tmp___5 = __builtin_strchr(value, (char )'#');
#line 185
    trailer = tmp___5;
#line 186
    if (! trailer) {
#line 187
      trailer = (value + len) - 1;
    } else {
#line 189
      trailer --;
    }
#line 191
    while (1) {
#line 191
      if ((*trailer)) {
#line 191
        if (! ((int )(*trailer) == 34)) {
#line 191
          tmp___7 = __ctype_b_loc();
#line 191
          if (! ((int const   )(*((*tmp___7) + (int )(*trailer))) & 1)) {
#line 191
            break;
          }
        }
      } else {
#line 191
        break;
      }
#line 192
      tmp___6 = trailer;
#line 192
      trailer --;
#line 192
      (*tmp___6) = (char )'\000';
    }
#line 194
    tmp___8 = check_set_config_value((char const   *)res, "MASTER_MAP_NAME", (char const   *)value);
#line 194
    if (! tmp___8) {
#line 194
      tmp___9 = check_set_config_value((char const   *)res, "TIMEOUT", (char const   *)value);
#line 194
      if (! tmp___9) {
#line 194
        tmp___10 = check_set_config_value((char const   *)res, "BROWSE_MODE", (char const   *)value);
#line 194
        if (! tmp___10) {
#line 194
          tmp___11 = check_set_config_value((char const   *)res, "LOGGING", (char const   *)value);
#line 194
          if (! tmp___11) {
#line 194
            tmp___12 = check_set_config_value((char const   *)res, "LDAP_SERVER",
                                              (char const   *)value);
#line 194
            if (! tmp___12) {
#line 194
              tmp___13 = check_set_config_value((char const   *)res, "MAP_OBJECT_CLASS",
                                                (char const   *)value);
#line 194
              if (! tmp___13) {
#line 194
                tmp___14 = check_set_config_value((char const   *)res, "ENTRY_OBJECT_CLASS",
                                                  (char const   *)value);
#line 194
                if (! tmp___14) {
#line 194
                  tmp___15 = check_set_config_value((char const   *)res, "MAP_ATTRIBUTE",
                                                    (char const   *)value);
#line 194
                  if (! tmp___15) {
#line 194
                    tmp___16 = check_set_config_value((char const   *)res, "ENTRY_ATTRIBUTE",
                                                      (char const   *)value);
#line 194
                    if (! tmp___16) {
#line 194
                      tmp___17 = check_set_config_value((char const   *)res, "VALUE_ATTRIBUTE",
                                                        (char const   *)value);
#line 194
                      if (! tmp___17) {
#line 194
                        tmp___18 = check_set_config_value((char const   *)res, "APPEND_OPTIONS",
                                                          (char const   *)value);
#line 194
                        if (! tmp___18) {
#line 194
                          tmp___19 = check_set_config_value((char const   *)res, "AUTH_CONF_FILE",
                                                            (char const   *)value);
#line 194
                          if (tmp___19) {

                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 209
  tmp___21 = feof(f);
#line 209
  if (! tmp___21) {
#line 210
    tmp___20 = ferror(f);
#line 210
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"fgets returned error %d while reading %s\n",
            tmp___20, "/autofs");
#line 212
    fclose(f);
#line 213
    return (0U);
  }
#line 216
  fclose(f);
#line 217
  return (1U);
}
}
#line 220 "defaults.c"
char const   *defaults_get_master_map(void) 
{ char *master ;
  char *tmp___8 ;

  {
#line 224
  master = get_env_string("MASTER_MAP_NAME");
#line 225
  if (! master) {
#line 226
    tmp___8 = __strdup(default_master_map_name);
#line 226
    return ((char const   *)tmp___8);
  }
#line 228
  return ((char const   *)master);
}
}
#line 231 "defaults.c"
unsigned int defaults_get_timeout(void) 
{ long timeout___1 ;

  {
#line 235
  timeout___1 = get_env_number("TIMEOUT");
#line 236
  if (timeout___1 < 0L) {
#line 237
    timeout___1 = 600L;
  }
#line 239
  return ((unsigned int )timeout___1);
}
}
#line 242 "defaults.c"
unsigned int defaults_get_browse_mode(void) 
{ int res ;

  {
#line 246
  res = get_env_yesno("BROWSE_MODE");
#line 247
  if (res < 0) {
#line 248
    res = 1;
  }
#line 250
  return ((unsigned int )res);
}
}
#line 253 "defaults.c"
unsigned int defaults_get_logging(void) 
{ char *res ;
  unsigned int logging ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 256
  logging = 0U;
#line 258
  res = get_env_string("LOGGING");
#line 259
  if (! res) {
#line 260
    return (logging);
  }
#line 262
  tmp___1 = strcasecmp((char const   *)res, "none");
#line 262
  if (tmp___1) {
#line 265
    tmp = strcasecmp((char const   *)res, "verbose");
#line 265
    if (! tmp) {
#line 266
      logging |= 2U;
    }
#line 268
    tmp___0 = strcasecmp((char const   *)res, "debug");
#line 268
    if (! tmp___0) {
#line 269
      logging |= 1U;
    }
  } else {
#line 263
    logging = 0U;
  }
#line 272
  free((void *)res);
#line 274
  return (logging);
}
}
#line 277 "defaults.c"
char const   *defaults_get_ldap_server(void) 
{ char *server ;

  {
#line 281
  server = get_env_string("LDAP_SERVER");
#line 282
  if (! server) {
#line 283
    return (default_ldap_server);
  }
#line 285
  return ((char const   *)server);
}
}
#line 288 "defaults.c"
char const   *defaults_get_map_obj_class(void) 
{ char *moc ;
  char *tmp___8 ;

  {
#line 292
  moc = get_env_string("MAP_OBJECT_CLASS");
#line 293
  if (! moc) {
#line 294
    tmp___8 = __strdup(default_map_obj_class);
#line 294
    return ((char const   *)tmp___8);
  }
#line 296
  return ((char const   *)moc);
}
}
#line 299 "defaults.c"
char const   *defaults_get_entry_obj_class(void) 
{ char *eoc ;
  char *tmp___8 ;

  {
#line 303
  eoc = get_env_string("ENTRY_OBJECT_CLASS");
#line 304
  if (! eoc) {
#line 305
    tmp___8 = __strdup(default_entry_obj_class);
#line 305
    return ((char const   *)tmp___8);
  }
#line 307
  return ((char const   *)eoc);
}
}
#line 310 "defaults.c"
char const   *defaults_get_map_attr(void) 
{ char *ma ;
  char *tmp___8 ;

  {
#line 314
  ma = get_env_string("MAP_ATTRIBUTE");
#line 315
  if (! ma) {
#line 316
    tmp___8 = __strdup(default_map_attr);
#line 316
    return ((char const   *)tmp___8);
  }
#line 318
  return ((char const   *)ma);
}
}
#line 321 "defaults.c"
char const   *defaults_get_entry_attr(void) 
{ char *ea ;
  char *tmp___8 ;

  {
#line 325
  ea = get_env_string("ENTRY_ATTRIBUTE");
#line 326
  if (! ea) {
#line 327
    tmp___8 = __strdup(default_entry_attr);
#line 327
    return ((char const   *)tmp___8);
  }
#line 329
  return ((char const   *)ea);
}
}
#line 332 "defaults.c"
char const   *defaults_get_value_attr(void) 
{ char *va ;
  char *tmp___8 ;

  {
#line 336
  va = get_env_string("VALUE_ATTRIBUTE");
#line 337
  if (! va) {
#line 338
    tmp___8 = __strdup(default_value_attr);
#line 338
    return ((char const   *)tmp___8);
  }
#line 340
  return ((char const   *)va);
}
}
#line 343 "defaults.c"
unsigned int defaults_get_append_options(void) 
{ int res ;

  {
#line 347
  res = get_env_yesno("APPEND_OPTIONS");
#line 348
  if (res < 0) {
#line 349
    res = 1;
  }
#line 351
  return ((unsigned int )res);
}
}
#line 354 "defaults.c"
char const   *defaults_get_auth_conf_file(void) 
{ char *cf ;
  char *tmp___8 ;

  {
#line 358
  cf = get_env_string("AUTH_CONF_FILE");
#line 359
  if (! cf) {
#line 360
    tmp___8 = __strdup(default_auth_conf_file);
#line 360
    return ((char const   *)tmp___8);
  }
#line 362
  return ((char const   *)cf);
}
}
#line 1 "log.o"
#pragma merger(0,"/tmp/cil-EeaGHvaJ.i","-O2,-Wall,-fPIC")
#line 346 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 487
extern int fputc(int __c , FILE *__stream ) ;
#line 185 "../include/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 189
extern void vsyslog(int __pri , char const   * , __gnuc_va_list __ap ) ;
#line 29 "../include/log.h"
void set_log_norm(void) ;
#line 32
void set_mnt_logging(struct autofs_point *ap ) ;
#line 40
void (*log_notice)(unsigned int logopt , char const   *msg  , ...) ;
#line 38 "log.c"
static unsigned int syslog_open  =    0U;
#line 39 "log.c"
static unsigned int logging_to_syslog  =    0U;
#line 42 "log.c"
static unsigned int do_verbose  =    0U;
#line 43 "log.c"
static unsigned int do_debug  =    0U;
#line 45 "log.c"
static void null(unsigned int logopt , char const   *msg  , ...) 
{ 

  {
#line 45
  return;
}
}
#line 47 "log.c"
void (*log_info)(unsigned int logopt , char const   *msg  , ...)  =    & null;
#line 48 "log.c"
void (*log_notice)(unsigned int logopt , char const   *msg  , ...)  =    & null;
#line 49 "log.c"
void (*log_warn)(unsigned int logopt , char const   *msg  , ...)  =    & null;
#line 50 "log.c"
void (*log_error)(unsigned int logopt , char const   *msg  , ...)  =    & null;
#line 51 "log.c"
void (*log_crit)(unsigned int logopt , char const   *msg  , ...)  =    & null;
#line 52 "log.c"
void (*log_debug)(unsigned int logopt , char const   *msg  , ...)  =    & null;
#line 54 "log.c"
void set_log_norm(void) 
{ 

  {
#line 56
  do_verbose = 0U;
#line 57
  do_debug = 0U;
#line 58
  return;
}
}
#line 60 "log.c"
void set_log_verbose(void) 
{ 

  {
#line 62
  do_verbose = 1U;
#line 63
  return;
}
}
#line 65 "log.c"
void set_log_debug(void) 
{ 

  {
#line 67
  do_debug = 1U;
#line 68
  return;
}
}
#line 70 "log.c"
static void syslog_info(unsigned int logopt , char const   *msg  , ...) 
{ unsigned int opt_log ;
  va_list ap ;

  {
#line 72
  opt_log = logopt & 3U;
#line 75
  if (! do_debug) {
#line 75
    if (! do_verbose) {
#line 75
      if (! opt_log) {
#line 76
        return;
      }
    }
  }
#line 78
  __builtin_va_start(ap, msg);
#line 79
  vsyslog(6, msg, ap);
#line 80
  __builtin_va_end(ap);
#line 81
  return;
}
}
#line 83 "log.c"
static void syslog_notice(unsigned int logopt , char const   *msg  , ...) 
{ unsigned int opt_log ;
  va_list ap ;

  {
#line 85
  opt_log = logopt & 3U;
#line 88
  if (! do_debug) {
#line 88
    if (! do_verbose) {
#line 88
      if (! opt_log) {
#line 89
        return;
      }
    }
  }
#line 91
  __builtin_va_start(ap, msg);
#line 92
  vsyslog(5, msg, ap);
#line 93
  __builtin_va_end(ap);
#line 94
  return;
}
}
#line 96 "log.c"
static void syslog_warn(unsigned int logopt , char const   *msg  , ...) 
{ unsigned int opt_log ;
  va_list ap ;

  {
#line 98
  opt_log = logopt & 3U;
#line 101
  if (! do_debug) {
#line 101
    if (! do_verbose) {
#line 101
      if (! opt_log) {
#line 102
        return;
      }
    }
  }
#line 104
  __builtin_va_start(ap, msg);
#line 105
  vsyslog(4, msg, ap);
#line 106
  __builtin_va_end(ap);
#line 107
  return;
}
}
#line 109 "log.c"
static void syslog_err(unsigned int logopt , char const   *msg  , ...) 
{ va_list ap ;

  {
#line 112
  __builtin_va_start(ap, msg);
#line 113
  vsyslog(3, msg, ap);
#line 114
  __builtin_va_end(ap);
#line 115
  return;
}
}
#line 117 "log.c"
static void syslog_crit(unsigned int logopt , char const   *msg  , ...) 
{ va_list ap ;

  {
#line 120
  __builtin_va_start(ap, msg);
#line 121
  vsyslog(2, msg, ap);
#line 122
  __builtin_va_end(ap);
#line 123
  return;
}
}
#line 125 "log.c"
static void syslog_debug(unsigned int logopt , char const   *msg  , ...) 
{ va_list ap ;

  {
#line 129
  if (! do_debug) {
#line 129
    if (! (logopt & 1U)) {
#line 130
      return;
    }
  }
#line 132
  __builtin_va_start(ap, msg);
#line 133
  vsyslog(7, msg, ap);
#line 134
  __builtin_va_end(ap);
#line 135
  return;
}
}
#line 137 "log.c"
void set_mnt_logging(struct autofs_point *ap ) 
{ unsigned int opt_verbose ;
  unsigned int opt_debug ;

  {
#line 139
  opt_verbose = ap->logopt & 2U;
#line 140
  opt_debug = ap->logopt & 1U;
#line 142
  if (opt_debug) {
#line 143
    log_debug = & syslog_debug;
  }
#line 145
  if (opt_verbose) {
#line 146
    log_info = & syslog_info;
#line 147
    log_notice = & syslog_notice;
#line 148
    log_warn = & syslog_warn;
  } else {
#line 145
    if (opt_debug) {
#line 146
      log_info = & syslog_info;
#line 147
      log_notice = & syslog_notice;
#line 148
      log_warn = & syslog_warn;
    }
  }
#line 150
  return;
}
}
#line 152 "log.c"
static void to_stderr(unsigned int logopt , char const   *msg  , ...) 
{ va_list ap ;

  {
#line 155
  __builtin_va_start(ap, msg);
#line 156
  vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )msg, ap);
#line 157
  fputc('\n', stderr);
#line 158
  __builtin_va_end(ap);
#line 159
  return;
}
}
#line 161 "log.c"
void log_to_syslog(void) 
{ char buf[128] ;
  int nullfd ;
  char *estr ;
  int *tmp ;
  char *tmp___0 ;
  char *estr___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 166
  if (! syslog_open) {
#line 167
    syslog_open = 1U;
#line 168
    openlog("automount", 1, 24);
  }
#line 171
  if (do_debug) {
#line 172
    log_debug = & syslog_debug;
  } else {
#line 174
    log_debug = & null;
  }
#line 176
  if (do_verbose) {
#line 177
    log_info = & syslog_info;
#line 178
    log_notice = & syslog_notice;
#line 179
    log_warn = & syslog_warn;
  } else {
#line 176
    if (do_debug) {
#line 177
      log_info = & syslog_info;
#line 178
      log_notice = & syslog_notice;
#line 179
      log_warn = & syslog_warn;
    } else {
#line 181
      log_info = & null;
#line 182
      log_notice = & null;
#line 183
      log_warn = & null;
    }
  }
#line 186
  log_error = & syslog_err;
#line 187
  log_crit = & syslog_crit;
#line 189
  logging_to_syslog = 1U;
#line 192
  nullfd = open("/dev/null", 2);
#line 193
  if (nullfd < 0) {
#line 194
    tmp = __errno_location();
#line 194
    tmp___0 = strerror_r((*tmp), buf, 128U);
#line 194
    estr = tmp___0;
#line 195
    syslog_crit(3U, "cannot open /dev/null: %s", estr);
#line 196
    exit(1);
  }
#line 199
  tmp___3 = dup2(nullfd, 0);
#line 199
  if (tmp___3 < 0) {
#line 202
    tmp___1 = __errno_location();
#line 202
    tmp___2 = strerror_r((*tmp___1), buf, 128U);
#line 202
    estr___0 = tmp___2;
#line 203
    syslog_crit(3U, "redirecting file descriptors failed: %s", estr___0);
#line 205
    exit(1);
  } else {
#line 199
    tmp___4 = dup2(nullfd, 1);
#line 199
    if (tmp___4 < 0) {
#line 202
      tmp___1 = __errno_location();
#line 202
      tmp___2 = strerror_r((*tmp___1), buf, 128U);
#line 202
      estr___0 = tmp___2;
#line 203
      syslog_crit(3U, "redirecting file descriptors failed: %s", estr___0);
#line 205
      exit(1);
    } else {
#line 199
      tmp___5 = dup2(nullfd, 2);
#line 199
      if (tmp___5 < 0) {
#line 202
        tmp___1 = __errno_location();
#line 202
        tmp___2 = strerror_r((*tmp___1), buf, 128U);
#line 202
        estr___0 = tmp___2;
#line 203
        syslog_crit(3U, "redirecting file descriptors failed: %s", estr___0);
#line 205
        exit(1);
      }
    }
  }
#line 208
  if (nullfd > 2) {
#line 209
    close(nullfd);
  }
#line 210
  return;
}
}
#line 212 "log.c"
void log_to_stderr(void) 
{ 

  {
#line 214
  if (syslog_open) {
#line 215
    syslog_open = 0U;
#line 216
    closelog();
  }
#line 219
  if (do_debug) {
#line 220
    log_debug = & to_stderr;
  } else {
#line 222
    log_debug = & null;
  }
#line 224
  if (do_verbose) {
#line 225
    log_info = & to_stderr;
#line 226
    log_notice = & to_stderr;
#line 227
    log_warn = & to_stderr;
  } else {
#line 224
    if (do_debug) {
#line 225
      log_info = & to_stderr;
#line 226
      log_notice = & to_stderr;
#line 227
      log_warn = & to_stderr;
    } else {
#line 229
      log_info = & null;
#line 230
      log_notice = & null;
#line 231
      log_warn = & null;
    }
  }
#line 234
  log_error = & to_stderr;
#line 235
  log_crit = & to_stderr;
#line 237
  logging_to_syslog = 0U;
#line 238
  return;
}
}
#line 1 "macros.o"
#pragma merger(0,"/tmp/cil-wD2AE0BU.i","-O2,-Wall,-fPIC")
#line 57 "/usr/include/malloc.h"
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size )  __attribute__((__warn_unused_result__,
__malloc__)) ;
#line 28 "../include/macros.h"
void macro_init(void) ;
#line 29
int macro_is_systemvar(char const   *str , int len ) ;
#line 30
int macro_global_addvar(char const   *str , int len , char const   *value ) ;
#line 32
void macro_lock(void) ;
#line 33
void macro_unlock(void) ;
#line 34
struct substvar *macro_addvar(struct substvar *table , char const   *str , int len ,
                              char const   *value ) ;
#line 36
void macro_global_removevar(char const   *str , int len ) ;
#line 37
struct substvar *macro_removevar(struct substvar *table , char const   *str , int len ) ;
#line 39
void macro_free_global_table(void) ;
#line 40
void macro_free_table(struct substvar *table ) ;
#line 41
struct substvar  const  *macro_findvar(struct substvar  const  *table , char const   *str ,
                                       int len ) ;
#line 25 "macros.c"
static struct utsname un  ;
#line 26 "macros.c"
static char processor[65]  ;
#line 29 "macros.c"
static struct substvar sv_arch  =    {(char *)"ARCH", un.machine, 1U, (struct substvar *)((void *)0)};
#line 29 "macros.c"
static struct substvar sv_cpu  =    {(char *)"CPU", processor, 1U, & sv_arch};
#line 29 "macros.c"
static struct substvar sv_host  =    {(char *)"HOST", un.nodename, 1U, & sv_cpu};
#line 29 "macros.c"
static struct substvar sv_osname  =    {(char *)"OSNAME", un.sysname, 1U, & sv_host};
#line 29 "macros.c"
static struct substvar sv_osrel  =    {(char *)"OSREL", un.release, 1U, & sv_osname};
#line 29 "macros.c"
static struct substvar sv_osvers  =    {(char *)"OSVERS", un.version, 1U, & sv_osrel};
#line 38 "macros.c"
static struct substvar *system_table  =    & sv_osvers;
#line 40 "macros.c"
static union __anonunion_pthread_mutex_t_6 table_mutex  =    {{0, 0U, 0, 0, 0U, {0}}};
#line 41 "macros.c"
static union __anonunion_pthread_mutex_t_6 macro_mutex  =    {{0, 0U, 0, 0, 0U, {0}}};
#line 43 "macros.c"
void dump_table(struct substvar *table ) 
{ struct substvar *lv ;
  int status ;

  {
#line 45
  lv = table;
#line 48
  status = pthread_mutex_lock(& table_mutex);
#line 49
  if (status) {
#line 50
    while (1) {
#line 50
      if (status == 35) {
#line 50
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "dump_table", 50, "macros.c");
#line 50
        dump_core();
      }
#line 50
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 50, "macros.c");
#line 50
      abort();
#line 50
      break;
    }
  }
#line 52
  while (lv) {
#line 53
    while (1) {
#line 53
      ((*log_debug))(0U, "%s: lv->def %s lv->val %s lv->next %p", "dump_table", lv->def,
                     lv->val, lv->next);
#line 53
      break;
    }
#line 56
    lv = lv->next;
  }
#line 59
  status = pthread_mutex_unlock(& table_mutex);
#line 60
  if (status) {
#line 61
    while (1) {
#line 61
      if (status == 35) {
#line 61
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "dump_table", 61, "macros.c");
#line 61
        dump_core();
      }
#line 61
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 61, "macros.c");
#line 61
      abort();
#line 61
      break;
    }
  }
#line 62
  return;
}
}
#line 65 "macros.c"
void macro_init(void) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 67
  uname(& un);
#line 72
  strcpy((char * __restrict  )(processor), (char const   * __restrict  )(un.machine));
#line 74
  if ((int )processor[0] == 105) {
#line 74
    if ((int )processor[1] >= 51) {
#line 74
      if (0) {
#line 74
        __s1_len = strlen((char const   *)(processor + 2));
#line 74
        __s2_len = strlen("86");
#line 74
        if (! ((unsigned int )((void const   *)((processor + 2) + 1)) - (unsigned int )((void const   *)(processor + 2)) == 1U)) {
          goto _L___0;
        } else {
#line 74
          if (__s1_len >= 4U) {
            _L___0: 
#line 74
            if (! ((unsigned int )((void const   *)("86" + 1)) - (unsigned int )((void const   *)"86") == 1U)) {
#line 74
              tmp___8 = 1;
            } else {
#line 74
              if (__s2_len >= 4U) {
#line 74
                tmp___8 = 1;
              } else {
#line 74
                tmp___8 = 0;
              }
            }
          } else {
#line 74
            tmp___8 = 0;
          }
        }
#line 74
        if (tmp___8) {
#line 74
          tmp___4 = __builtin_strcmp((char const   *)(processor + 2), "86");
        } else {
#line 74
          tmp___7 = __builtin_strcmp((char const   *)(processor + 2), "86");
#line 74
          tmp___4 = tmp___7;
        }
      } else {
#line 74
        tmp___7 = __builtin_strcmp((char const   *)(processor + 2), "86");
#line 74
        tmp___4 = tmp___7;
      }
#line 74
      if (! tmp___4) {
#line 75
        processor[1] = (char )'3';
      }
    }
  }
#line 76
  return;
}
}
#line 78 "macros.c"
int macro_is_systemvar(char const   *str , int len ) 
{ struct substvar *sv ;
  int found ;
  int status ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 81
  found = 0;
#line 84
  status = pthread_mutex_lock(& table_mutex);
#line 85
  if (status) {
#line 86
    while (1) {
#line 86
      if (status == 35) {
#line 86
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "macro_is_systemvar", 86, "macros.c");
#line 86
        dump_core();
      }
#line 86
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 86, "macros.c");
#line 86
      abort();
#line 86
      break;
    }
  }
#line 88
  sv = system_table;
#line 90
  while (sv) {
#line 91
    if (0) {
#line 91
      if (0) {
#line 91
        __s1_len___0 = strlen(str);
#line 91
        __s2_len___0 = strlen((char const   *)sv->def);
#line 91
        if (! ((unsigned int )((void const   *)(str + 1)) - (unsigned int )((void const   *)str) == 1U)) {
          goto _L___2;
        } else {
#line 91
          if (__s1_len___0 >= 4U) {
            _L___2: 
#line 91
            if (! ((unsigned int )((void const   *)(sv->def + 1)) - (unsigned int )((void const   *)sv->def) == 1U)) {
#line 91
              tmp___22 = 1;
            } else {
#line 91
              if (__s2_len___0 >= 4U) {
#line 91
                tmp___22 = 1;
              } else {
#line 91
                tmp___22 = 0;
              }
            }
          } else {
#line 91
            tmp___22 = 0;
          }
        }
#line 91
        if (tmp___22) {
#line 91
          tmp___18 = __builtin_strcmp(str, (char const   *)sv->def);
        } else {
#line 91
          tmp___21 = __builtin_strcmp(str, (char const   *)sv->def);
#line 91
          tmp___18 = tmp___21;
        }
      } else {
#line 91
        tmp___21 = __builtin_strcmp(str, (char const   *)sv->def);
#line 91
        tmp___18 = tmp___21;
      }
#line 91
      tmp___12 = tmp___18;
    } else {
#line 91
      tmp___12 = strncmp(str, (char const   *)sv->def, (unsigned int )len);
    }
#line 91
    if (! tmp___12) {
#line 91
      if ((int )(*(sv->def + len)) == 0) {
#line 92
        found = 1;
#line 93
        break;
      }
    }
#line 95
    sv = sv->next;
  }
#line 98
  status = pthread_mutex_unlock(& table_mutex);
#line 99
  if (status) {
#line 100
    while (1) {
#line 100
      if (status == 35) {
#line 100
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "macro_is_systemvar", 100, "macros.c");
#line 100
        dump_core();
      }
#line 100
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 100,
                    "macros.c");
#line 100
      abort();
#line 100
      break;
    }
  }
#line 102
  return (found);
}
}
#line 105 "macros.c"
int macro_global_addvar(char const   *str , int len , char const   *value ) 
{ struct substvar *sv ;
  int status ;
  int ret ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  char *this ;
  size_t tmp___25 ;
  char *tmp___26 ;
  struct substvar *new ;
  char *def ;
  char *val ;
  char *tmp___36 ;
  char *tmp___46 ;

  {
#line 108
  ret = 0;
#line 110
  status = pthread_mutex_lock(& table_mutex);
#line 111
  if (status) {
#line 112
    while (1) {
#line 112
      if (status == 35) {
#line 112
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "macro_global_addvar", 112, "macros.c");
#line 112
        dump_core();
      }
#line 112
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 112,
                    "macros.c");
#line 112
      abort();
#line 112
      break;
    }
  }
#line 114
  sv = system_table;
#line 116
  while (sv) {
#line 117
    if (0) {
#line 117
      if (0) {
#line 117
        __s1_len___0 = strlen(str);
#line 117
        __s2_len___0 = strlen((char const   *)sv->def);
#line 117
        if (! ((unsigned int )((void const   *)(str + 1)) - (unsigned int )((void const   *)str) == 1U)) {
          goto _L___2;
        } else {
#line 117
          if (__s1_len___0 >= 4U) {
            _L___2: 
#line 117
            if (! ((unsigned int )((void const   *)(sv->def + 1)) - (unsigned int )((void const   *)sv->def) == 1U)) {
#line 117
              tmp___22 = 1;
            } else {
#line 117
              if (__s2_len___0 >= 4U) {
#line 117
                tmp___22 = 1;
              } else {
#line 117
                tmp___22 = 0;
              }
            }
          } else {
#line 117
            tmp___22 = 0;
          }
        }
#line 117
        if (tmp___22) {
#line 117
          tmp___18 = __builtin_strcmp(str, (char const   *)sv->def);
        } else {
#line 117
          tmp___21 = __builtin_strcmp(str, (char const   *)sv->def);
#line 117
          tmp___18 = tmp___21;
        }
      } else {
#line 117
        tmp___21 = __builtin_strcmp(str, (char const   *)sv->def);
#line 117
        tmp___18 = tmp___21;
      }
#line 117
      tmp___12 = tmp___18;
    } else {
#line 117
      tmp___12 = strncmp(str, (char const   *)sv->def, (unsigned int )len);
    }
#line 117
    if (! tmp___12) {
#line 117
      if ((int )(*(sv->def + len)) == 0) {
#line 118
        break;
      }
    }
#line 119
    sv = sv->next;
  }
#line 122
  if (sv) {
#line 122
    if (! sv->readonly) {
#line 123
      tmp___25 = strlen(value);
#line 123
      tmp___26 = (char *)realloc((void *)sv->val, tmp___25 + 1U);
#line 123
      this = tmp___26;
#line 124
      if (! this) {
        goto done;
      }
#line 126
      strcat((char * __restrict  )this, (char const   * __restrict  )value);
#line 127
      sv->val = this;
#line 128
      ret = 1;
    } else {
      goto _L___3;
    }
  } else {
    _L___3: 
#line 133
    tmp___36 = __strdup(str);
#line 133
    def = tmp___36;
#line 134
    if (! def) {
      goto done;
    }
#line 136
    (*(def + len)) = (char )'\000';
#line 138
    tmp___46 = __strdup(value);
#line 138
    val = tmp___46;
#line 139
    if (! val) {
#line 140
      free((void *)def);
      goto done;
    }
#line 144
    new = (struct substvar *)malloc(sizeof(struct substvar ));
#line 145
    if (! new) {
#line 146
      free((void *)def);
#line 147
      free((void *)val);
      goto done;
    }
#line 150
    new->def = def;
#line 151
    new->val = val;
#line 152
    new->readonly = 0U;
#line 153
    new->next = system_table;
#line 154
    system_table = new;
#line 155
    ret = 1;
  }
  done: 
#line 158
  status = pthread_mutex_unlock(& table_mutex);
#line 159
  if (status) {
#line 160
    while (1) {
#line 160
      if (status == 35) {
#line 160
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "macro_global_addvar", 160, "macros.c");
#line 160
        dump_core();
      }
#line 160
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 160,
                    "macros.c");
#line 160
      abort();
#line 160
      break;
    }
  }
#line 162
  return (ret);
}
}
#line 165 "macros.c"
int macro_parse_globalvar(char const   *define ) 
{ char buf[128] ;
  char *pbuf ;
  char *value ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 170
  tmp = strlen(define);
#line 170
  if (tmp > 128U) {
#line 171
    return (0);
  }
#line 173
  strcpy((char * __restrict  )(buf), (char const   * __restrict  )define);
#line 175
  pbuf = buf;
#line 176
  while (pbuf) {
#line 177
    if ((int )(*pbuf) == 61) {
#line 178
      (*pbuf) = (char )'\000';
#line 179
      value = pbuf + 1;
#line 180
      break;
    }
#line 182
    pbuf ++;
  }
#line 186
  if (! pbuf) {
#line 187
    return (0);
  }
#line 189
  tmp___0 = strlen((char const   *)(buf));
#line 189
  tmp___1 = macro_global_addvar((char const   *)(buf), (int )tmp___0, (char const   *)value);
#line 189
  return (tmp___1);
}
}
#line 192 "macros.c"
void macro_lock(void) 
{ int status ;
  int tmp ;

  {
#line 194
  tmp = pthread_mutex_lock(& macro_mutex);
#line 194
  status = tmp;
#line 195
  if (status) {
#line 196
    while (1) {
#line 196
      if (status == 35) {
#line 196
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "macro_lock", 196, "macros.c");
#line 196
        dump_core();
      }
#line 196
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 196,
                    "macros.c");
#line 196
      abort();
#line 196
      break;
    }
  }
#line 197
  return;
}
}
#line 199 "macros.c"
void macro_unlock(void) 
{ int status ;
  int tmp ;

  {
#line 201
  tmp = pthread_mutex_unlock(& macro_mutex);
#line 201
  status = tmp;
#line 202
  if (status) {
#line 203
    while (1) {
#line 203
      if (status == 35) {
#line 203
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "macro_unlock", 203, "macros.c");
#line 203
        dump_core();
      }
#line 203
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 203,
                    "macros.c");
#line 203
      abort();
#line 203
      break;
    }
  }
#line 204
  return;
}
}
#line 206 "macros.c"
struct substvar *macro_addvar(struct substvar *table , char const   *str , int len ,
                              char const   *value ) 
{ struct substvar *lv ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  char *this ;
  size_t tmp___25 ;
  char *tmp___26 ;
  struct substvar *new ;
  char *def ;
  char *val ;
  char *tmp___36 ;
  char *tmp___46 ;

  {
#line 209
  lv = table;
#line 211
  while (lv) {
#line 212
    if (0) {
#line 212
      if (0) {
#line 212
        __s1_len___0 = strlen(str);
#line 212
        __s2_len___0 = strlen((char const   *)lv->def);
#line 212
        if (! ((unsigned int )((void const   *)(str + 1)) - (unsigned int )((void const   *)str) == 1U)) {
          goto _L___2;
        } else {
#line 212
          if (__s1_len___0 >= 4U) {
            _L___2: 
#line 212
            if (! ((unsigned int )((void const   *)(lv->def + 1)) - (unsigned int )((void const   *)lv->def) == 1U)) {
#line 212
              tmp___22 = 1;
            } else {
#line 212
              if (__s2_len___0 >= 4U) {
#line 212
                tmp___22 = 1;
              } else {
#line 212
                tmp___22 = 0;
              }
            }
          } else {
#line 212
            tmp___22 = 0;
          }
        }
#line 212
        if (tmp___22) {
#line 212
          tmp___18 = __builtin_strcmp(str, (char const   *)lv->def);
        } else {
#line 212
          tmp___21 = __builtin_strcmp(str, (char const   *)lv->def);
#line 212
          tmp___18 = tmp___21;
        }
      } else {
#line 212
        tmp___21 = __builtin_strcmp(str, (char const   *)lv->def);
#line 212
        tmp___18 = tmp___21;
      }
#line 212
      tmp___12 = tmp___18;
    } else {
#line 212
      tmp___12 = strncmp(str, (char const   *)lv->def, (unsigned int )len);
    }
#line 212
    if (! tmp___12) {
#line 212
      if ((int )(*(lv->def + len)) == 0) {
#line 213
        break;
      }
    }
#line 214
    lv = lv->next;
  }
#line 217
  if (lv) {
#line 218
    tmp___25 = strlen(value);
#line 218
    tmp___26 = (char *)realloc((void *)lv->val, tmp___25 + 1U);
#line 218
    this = tmp___26;
#line 219
    if (! this) {
#line 220
      lv = table;
      goto done;
    }
#line 223
    strcat((char * __restrict  )this, (char const   * __restrict  )value);
#line 224
    lv->val = this;
  } else {
#line 229
    tmp___36 = __strdup(str);
#line 229
    def = tmp___36;
#line 230
    if (! def) {
#line 231
      lv = table;
      goto done;
    }
#line 234
    (*(def + len)) = (char )'\000';
#line 236
    tmp___46 = __strdup(value);
#line 236
    val = tmp___46;
#line 237
    if (! val) {
#line 238
      lv = table;
#line 239
      free((void *)def);
      goto done;
    }
#line 243
    new = (struct substvar *)malloc(sizeof(struct substvar ));
#line 244
    if (! new) {
#line 245
      lv = table;
#line 246
      free((void *)def);
#line 247
      free((void *)val);
      goto done;
    }
#line 250
    new->def = def;
#line 251
    new->val = val;
#line 252
    new->readonly = 0U;
#line 253
    new->next = table;
#line 254
    lv = new;
  }
  done: 
#line 258
  return (lv);
}
}
#line 261 "macros.c"
void macro_global_removevar(char const   *str , int len ) 
{ struct substvar *sv ;
  struct substvar *last ;
  int status ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 264
  last = (struct substvar *)((void *)0);
#line 267
  status = pthread_mutex_lock(& table_mutex);
#line 268
  if (status) {
#line 269
    while (1) {
#line 269
      if (status == 35) {
#line 269
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "macro_global_removevar", 269, "macros.c");
#line 269
        dump_core();
      }
#line 269
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 269,
                    "macros.c");
#line 269
      abort();
#line 269
      break;
    }
  }
#line 271
  sv = system_table;
#line 273
  while (sv) {
#line 274
    if (0) {
#line 274
      if (0) {
#line 274
        __s1_len___0 = strlen(str);
#line 274
        __s2_len___0 = strlen((char const   *)sv->def);
#line 274
        if (! ((unsigned int )((void const   *)(str + 1)) - (unsigned int )((void const   *)str) == 1U)) {
          goto _L___2;
        } else {
#line 274
          if (__s1_len___0 >= 4U) {
            _L___2: 
#line 274
            if (! ((unsigned int )((void const   *)(sv->def + 1)) - (unsigned int )((void const   *)sv->def) == 1U)) {
#line 274
              tmp___22 = 1;
            } else {
#line 274
              if (__s2_len___0 >= 4U) {
#line 274
                tmp___22 = 1;
              } else {
#line 274
                tmp___22 = 0;
              }
            }
          } else {
#line 274
            tmp___22 = 0;
          }
        }
#line 274
        if (tmp___22) {
#line 274
          tmp___18 = __builtin_strcmp(str, (char const   *)sv->def);
        } else {
#line 274
          tmp___21 = __builtin_strcmp(str, (char const   *)sv->def);
#line 274
          tmp___18 = tmp___21;
        }
      } else {
#line 274
        tmp___21 = __builtin_strcmp(str, (char const   *)sv->def);
#line 274
        tmp___18 = tmp___21;
      }
#line 274
      tmp___12 = tmp___18;
    } else {
#line 274
      tmp___12 = strncmp(str, (char const   *)sv->def, (unsigned int )len);
    }
#line 274
    if (! tmp___12) {
#line 274
      if ((int )(*(sv->def + len)) == 0) {
#line 275
        break;
      }
    }
#line 276
    last = sv;
#line 277
    sv = sv->next;
  }
#line 280
  if (sv) {
#line 280
    if (! sv->readonly) {
#line 281
      if (last) {
#line 282
        last->next = sv->next;
      } else {
#line 284
        system_table = sv->next;
      }
#line 285
      if (sv->def) {
#line 286
        free((void *)sv->def);
      }
#line 287
      if (sv->val) {
#line 288
        free((void *)sv->val);
      }
#line 289
      free((void *)sv);
    }
  }
#line 292
  status = pthread_mutex_unlock(& table_mutex);
#line 293
  if (status) {
#line 294
    while (1) {
#line 294
      if (status == 35) {
#line 294
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "macro_global_removevar", 294, "macros.c");
#line 294
        dump_core();
      }
#line 294
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 294,
                    "macros.c");
#line 294
      abort();
#line 294
      break;
    }
  }
#line 296
  return;
}
}
#line 299 "macros.c"
struct substvar *macro_removevar(struct substvar *table , char const   *str , int len ) 
{ struct substvar *list ;
  struct substvar *lv ;
  struct substvar *last ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 303
  last = (struct substvar *)((void *)0);
#line 305
  list = table;
#line 305
  lv = list;
#line 307
  while (lv) {
#line 308
    if (0) {
#line 308
      if (0) {
#line 308
        __s1_len___0 = strlen(str);
#line 308
        __s2_len___0 = strlen((char const   *)lv->def);
#line 308
        if (! ((unsigned int )((void const   *)(str + 1)) - (unsigned int )((void const   *)str) == 1U)) {
          goto _L___2;
        } else {
#line 308
          if (__s1_len___0 >= 4U) {
            _L___2: 
#line 308
            if (! ((unsigned int )((void const   *)(lv->def + 1)) - (unsigned int )((void const   *)lv->def) == 1U)) {
#line 308
              tmp___22 = 1;
            } else {
#line 308
              if (__s2_len___0 >= 4U) {
#line 308
                tmp___22 = 1;
              } else {
#line 308
                tmp___22 = 0;
              }
            }
          } else {
#line 308
            tmp___22 = 0;
          }
        }
#line 308
        if (tmp___22) {
#line 308
          tmp___18 = __builtin_strcmp(str, (char const   *)lv->def);
        } else {
#line 308
          tmp___21 = __builtin_strcmp(str, (char const   *)lv->def);
#line 308
          tmp___18 = tmp___21;
        }
      } else {
#line 308
        tmp___21 = __builtin_strcmp(str, (char const   *)lv->def);
#line 308
        tmp___18 = tmp___21;
      }
#line 308
      tmp___12 = tmp___18;
    } else {
#line 308
      tmp___12 = strncmp(str, (char const   *)lv->def, (unsigned int )len);
    }
#line 308
    if (! tmp___12) {
#line 308
      if ((int )(*(lv->def + len)) == 0) {
#line 309
        break;
      }
    }
#line 310
    last = lv;
#line 311
    lv = lv->next;
  }
#line 314
  if (lv) {
#line 315
    if (last) {
#line 316
      last->next = lv->next;
    } else {
#line 318
      list = lv->next;
    }
#line 319
    if (lv->def) {
#line 320
      free((void *)lv->def);
    }
#line 321
    if (lv->val) {
#line 322
      free((void *)lv->val);
    }
#line 323
    free((void *)lv);
  }
#line 326
  return (list);
}
}
#line 329 "macros.c"
void macro_free_global_table(void) 
{ struct substvar *sv ;
  struct substvar *next ;
  int status ;

  {
#line 335
  status = pthread_mutex_lock(& table_mutex);
#line 336
  if (status) {
#line 337
    while (1) {
#line 337
      if (status == 35) {
#line 337
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "macro_free_global_table", 337, "macros.c");
#line 337
        dump_core();
      }
#line 337
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 337,
                    "macros.c");
#line 337
      abort();
#line 337
      break;
    }
  }
#line 339
  sv = system_table;
#line 341
  while (sv) {
#line 342
    if (sv->readonly) {
#line 343
      sv = sv->next;
#line 344
      continue;
    }
#line 346
    next = sv->next;
#line 347
    if (sv->def) {
#line 348
      free((void *)sv->def);
    }
#line 349
    if (sv->val) {
#line 350
      free((void *)sv->val);
    }
#line 351
    free((void *)sv);
#line 352
    sv = next;
  }
#line 355
  system_table = & sv_osvers;
#line 357
  status = pthread_mutex_unlock(& table_mutex);
#line 358
  if (status) {
#line 359
    while (1) {
#line 359
      if (status == 35) {
#line 359
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "macro_free_global_table", 359, "macros.c");
#line 359
        dump_core();
      }
#line 359
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 359,
                    "macros.c");
#line 359
      abort();
#line 359
      break;
    }
  }
#line 361
  return;
}
}
#line 364 "macros.c"
void macro_free_table(struct substvar *table ) 
{ struct substvar *lv ;
  struct substvar *next ;

  {
#line 366
  lv = table;
#line 369
  if (! lv) {
#line 370
    return;
  }
#line 372
  while (lv) {
#line 373
    next = lv->next;
#line 374
    if (lv->def) {
#line 375
      free((void *)lv->def);
    }
#line 376
    if (lv->val) {
#line 377
      free((void *)lv->val);
    }
#line 378
    free((void *)lv);
#line 379
    lv = next;
  }
#line 382
  return;
}
}
#line 386 "macros.c"
struct substvar  const  *macro_findvar(struct substvar  const  *table , char const   *str ,
                                       int len ) 
{ struct substvar  const  *sv ;
  struct substvar  const  *lv ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___38 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___44 ;
  int tmp___47 ;
  int tmp___48 ;

  {
#line 389
  sv = (struct substvar  const  *)system_table;
#line 390
  lv = table;
#line 399
  while (lv) {
#line 400
    if (0) {
#line 400
      if (0) {
#line 400
        __s1_len___0 = strlen(str);
#line 400
        __s2_len___0 = strlen((char const   *)lv->def);
#line 400
        if (! ((unsigned int )((void const   *)(str + 1)) - (unsigned int )((void const   *)str) == 1U)) {
          goto _L___2;
        } else {
#line 400
          if (__s1_len___0 >= 4U) {
            _L___2: 
#line 400
            if (! ((unsigned int )((void const   *)(lv->def + 1)) - (unsigned int )((void const   *)lv->def) == 1U)) {
#line 400
              tmp___22 = 1;
            } else {
#line 400
              if (__s2_len___0 >= 4U) {
#line 400
                tmp___22 = 1;
              } else {
#line 400
                tmp___22 = 0;
              }
            }
          } else {
#line 400
            tmp___22 = 0;
          }
        }
#line 400
        if (tmp___22) {
#line 400
          tmp___18 = __builtin_strcmp(str, (char const   *)lv->def);
        } else {
#line 400
          tmp___21 = __builtin_strcmp(str, (char const   *)lv->def);
#line 400
          tmp___18 = tmp___21;
        }
      } else {
#line 400
        tmp___21 = __builtin_strcmp(str, (char const   *)lv->def);
#line 400
        tmp___18 = tmp___21;
      }
#line 400
      tmp___12 = tmp___18;
    } else {
#line 400
      tmp___12 = strncmp(str, (char const   *)lv->def, (unsigned int )len);
    }
#line 400
    if (! tmp___12) {
#line 400
      if ((int )(*(lv->def + len)) == 0) {
#line 401
        return (lv);
      }
    }
#line 402
    lv = (struct substvar  const  *)lv->next;
  }
#line 406
  while (sv) {
#line 407
    if (0) {
#line 407
      if (0) {
#line 407
        __s1_len___2 = strlen(str);
#line 407
        __s2_len___2 = strlen((char const   *)sv->def);
#line 407
        if (! ((unsigned int )((void const   *)(str + 1)) - (unsigned int )((void const   *)str) == 1U)) {
          goto _L___6;
        } else {
#line 407
          if (__s1_len___2 >= 4U) {
            _L___6: 
#line 407
            if (! ((unsigned int )((void const   *)(sv->def + 1)) - (unsigned int )((void const   *)sv->def) == 1U)) {
#line 407
              tmp___48 = 1;
            } else {
#line 407
              if (__s2_len___2 >= 4U) {
#line 407
                tmp___48 = 1;
              } else {
#line 407
                tmp___48 = 0;
              }
            }
          } else {
#line 407
            tmp___48 = 0;
          }
        }
#line 407
        if (tmp___48) {
#line 407
          tmp___44 = __builtin_strcmp(str, (char const   *)sv->def);
        } else {
#line 407
          tmp___47 = __builtin_strcmp(str, (char const   *)sv->def);
#line 407
          tmp___44 = tmp___47;
        }
      } else {
#line 407
        tmp___47 = __builtin_strcmp(str, (char const   *)sv->def);
#line 407
        tmp___44 = tmp___47;
      }
#line 407
      tmp___38 = tmp___44;
    } else {
#line 407
      tmp___38 = strncmp(str, (char const   *)sv->def, (unsigned int )len);
    }
#line 407
    if (! tmp___38) {
#line 407
      if ((int )(*(sv->def + len)) == 0) {
#line 408
        return (sv);
      }
    }
#line 409
    sv = (struct substvar  const  *)sv->next;
  }
#line 423
  return ((struct substvar  const  *)((void *)0));
}
}
#line 1 "master.o"
#pragma merger(0,"/tmp/cil-n9cablPX.i","-O2,-Wall,-fPIC")
#line 464 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int fstat__extinline(int __fd , struct stat *__statbuf ) ;
#line 239 "/usr/include/pthread.h"
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 71 "../include/master.h"
void master_init_scan(void) ;
#line 78
int master_add_autofs_point(struct master_mapent *entry , time_t timeout___1 , unsigned int logopt ,
                            unsigned int ghost___1 , int submount ) ;
#line 79
void master_free_autofs_point(struct autofs_point *ap ) ;
#line 80
struct map_source *master_add_map_source(struct master_mapent *entry , char *type___1 ,
                                         char *format___1 , time_t age , int argc ,
                                         char const   **argv ) ;
#line 82
struct map_source *master_find_map_source(struct master_mapent *entry , char const   *type___1 ,
                                          char const   *format___1 , int argc , char const   **argv ) ;
#line 84
void master_free_map_source(struct map_source *source , unsigned int free_cache ) ;
#line 90
void master_source_writelock(struct master_mapent *entry ) ;
#line 95
void master_source_current_signal(struct master_mapent *entry ) ;
#line 96
struct master_mapent *master_find_mapent(struct master *master , char const   *path___1 ) ;
#line 97
struct master_mapent *master_new_mapent(struct master *master , char const   *path___1 ,
                                        time_t age ) ;
#line 98
void master_add_mapent(struct master *master , struct master_mapent *entry ) ;
#line 104
int master_submount_list_empty(struct autofs_point *ap ) ;
#line 108
int master_mount_mounts(struct master *master , time_t age , int readall ) ;
#line 31 "master.c"
struct master *master_list  =    (struct master *)((void *)0);
#line 38
static struct map_source *__master_find_map_source(struct master_mapent *entry , char const   *type___1 ,
                                                   char const   *format___1 , int argc ,
                                                   char const   **argv ) ;
#line 42 "master.c"
union __anonunion_pthread_mutex_t_6 master_mutex  =    {{0, 0U, 0, 0, 0U, {0}}};
#line 43 "master.c"
union __anonunion_pthread_mutex_t_6 instance_mutex  =    {{0, 0U, 0, 0, 0U, {0}}};
#line 45 "master.c"
int master_add_autofs_point(struct master_mapent *entry , time_t timeout___1 , unsigned int logopt ,
                            unsigned int ghost___1 , int submount ) 
{ struct autofs_point *ap ;
  int status ;
  char *tmp___8 ;

  {
#line 51
  ap = (struct autofs_point *)malloc(sizeof(struct autofs_point ));
#line 52
  if (! ap) {
#line 53
    return (0);
  }
#line 55
  ap->state = (enum states )0;
#line 57
  ap->state_pipe[0] = -1;
#line 58
  ap->state_pipe[1] = -1;
#line 60
  tmp___8 = __strdup((char const   *)entry->path);
#line 60
  ap->path = tmp___8;
#line 61
  if (! ap->path) {
#line 62
    free((void *)ap);
#line 63
    return (0);
  }
#line 66
  ap->entry = entry;
#line 67
  ap->exp_thread = 0UL;
#line 68
  ap->readmap_thread = 0UL;
#line 69
  ap->exp_timeout = timeout___1;
#line 70
  ap->exp_runfreq = ((timeout___1 + 4L) - 1L) / 4L;
#line 71
  ap->ghost = ghost___1;
#line 73
  if ((int )(*(ap->path + 1)) == 45) {
#line 74
    ap->type = 4U;
  } else {
#line 76
    ap->type = 2U;
  }
#line 78
  ap->dir_created = 0U;
#line 79
  ap->logopt = logopt;
#line 81
  ap->parent = (struct autofs_point *)((void *)0);
#line 82
  ap->submnt_count = 0U;
#line 83
  ap->submount = (unsigned int )submount;
#line 84
  while (1) {
#line 84
    ap->mounts.next = & ap->mounts;
#line 84
    ap->mounts.prev = & ap->mounts;
#line 84
    break;
  }
#line 85
  while (1) {
#line 85
    ap->submounts.next = & ap->submounts;
#line 85
    ap->submounts.prev = & ap->submounts;
#line 85
    break;
  }
#line 87
  status = pthread_mutex_init(& ap->state_mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 88
  if (status) {
#line 89
    free((void *)ap->path);
#line 90
    free((void *)ap);
#line 91
    return (0);
  }
#line 94
  status = pthread_mutex_init(& ap->mounts_mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 95
  if (status) {
#line 96
    status = pthread_mutex_destroy(& ap->state_mutex);
#line 97
    if (status) {
#line 98
      while (1) {
#line 98
        if (status == 35) {
#line 98
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "master_add_autofs_point", 98, "master.c");
#line 98
          dump_core();
        }
#line 98
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 98,
                      "master.c");
#line 98
        abort();
#line 98
        break;
      }
    }
#line 99
    free((void *)ap->path);
#line 100
    free((void *)ap);
#line 101
    return (0);
  }
#line 104
  status = pthread_cond_init((pthread_cond_t * __restrict  )(& ap->mounts_cond), (pthread_condattr_t const   * __restrict  )((void *)0));
#line 105
  if (status) {
#line 106
    status = pthread_mutex_destroy(& ap->mounts_mutex);
#line 107
    if (status) {
#line 108
      while (1) {
#line 108
        if (status == 35) {
#line 108
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "master_add_autofs_point", 108, "master.c");
#line 108
          dump_core();
        }
#line 108
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 108,
                      "master.c");
#line 108
        abort();
#line 108
        break;
      }
    }
#line 109
    status = pthread_mutex_destroy(& ap->state_mutex);
#line 110
    if (status) {
#line 111
      while (1) {
#line 111
        if (status == 35) {
#line 111
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "master_add_autofs_point", 111, "master.c");
#line 111
          dump_core();
        }
#line 111
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 111,
                      "master.c");
#line 111
        abort();
#line 111
        break;
      }
    }
#line 112
    free((void *)ap->path);
#line 113
    free((void *)ap);
#line 114
    return (0);
  }
#line 116
  entry->ap = ap;
#line 118
  return (1);
}
}
#line 121 "master.c"
void master_free_autofs_point(struct autofs_point *ap ) 
{ int status ;

  {
#line 125
  if (! ap) {
#line 126
    return;
  }
#line 128
  status = pthread_mutex_destroy(& ap->state_mutex);
#line 129
  if (status) {
#line 130
    while (1) {
#line 130
      if (status == 35) {
#line 130
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "master_free_autofs_point", 130, "master.c");
#line 130
        dump_core();
      }
#line 130
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 130,
                    "master.c");
#line 130
      abort();
#line 130
      break;
    }
  }
#line 132
  status = pthread_mutex_destroy(& ap->mounts_mutex);
#line 133
  if (status) {
#line 134
    while (1) {
#line 134
      if (status == 35) {
#line 134
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "master_free_autofs_point", 134, "master.c");
#line 134
        dump_core();
      }
#line 134
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 134,
                    "master.c");
#line 134
      abort();
#line 134
      break;
    }
  }
#line 136
  status = pthread_cond_destroy(& ap->mounts_cond);
#line 137
  if (status) {
#line 138
    while (1) {
#line 138
      if (status == 35) {
#line 138
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "master_free_autofs_point", 138, "master.c");
#line 138
        dump_core();
      }
#line 138
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 138,
                    "master.c");
#line 138
      abort();
#line 138
      break;
    }
  }
#line 140
  free((void *)ap->path);
#line 141
  free((void *)ap);
#line 142
  return;
}
}
#line 144 "master.c"
struct map_source *master_add_map_source(struct master_mapent *entry , char *type___1 ,
                                         char *format___1 , time_t age , int argc ,
                                         char const   **argv ) 
{ struct map_source *source ;
  char *ntype ;
  char *nformat ;
  char const   **tmpargv ;
  char const   *name___0 ;
  char *tmp___8 ;
  char *tmp___18 ;
  struct map_source *this ;
  struct map_source *last ;
  struct map_source *next ;

  {
#line 151
  name___0 = (char const   *)((void *)0);
#line 153
  source = (struct map_source *)malloc(sizeof(struct map_source ));
#line 154
  if (! source) {
#line 155
    return ((struct map_source *)((void *)0));
  }
#line 156
  memset((void *)source, 0, sizeof(struct map_source ));
#line 158
  if (type___1) {
#line 159
    tmp___8 = __strdup((char const   *)type___1);
#line 159
    ntype = tmp___8;
#line 160
    if (! ntype) {
#line 161
      master_free_map_source(source, 0U);
#line 162
      return ((struct map_source *)((void *)0));
    }
#line 164
    source->type = ntype;
  }
#line 167
  if (format___1) {
#line 168
    tmp___18 = __strdup((char const   *)format___1);
#line 168
    nformat = tmp___18;
#line 169
    if (! nformat) {
#line 170
      master_free_map_source(source, 0U);
#line 171
      return ((struct map_source *)((void *)0));
    }
#line 173
    source->format = nformat;
  }
#line 176
  source->age = age;
#line 177
  source->stale = 1U;
#line 179
  tmpargv = copy_argv(argc, argv);
#line 180
  if (! tmpargv) {
#line 181
    master_free_map_source(source, 0U);
#line 182
    return ((struct map_source *)((void *)0));
  }
#line 184
  source->argc = argc;
#line 185
  source->argv = tmpargv;
#line 188
  if (argv) {
#line 189
    name___0 = (*(argv + 0));
  }
#line 191
  master_source_writelock(entry);
#line 193
  if (! entry->maps) {
#line 194
    entry->maps = source;
  } else {
#line 200
    this = __master_find_map_source(entry, (char const   *)type___1, (char const   *)format___1,
                                    argc, tmpargv);
#line 201
    if (this) {
#line 202
      this->age = age;
#line 203
      master_free_map_source(source, 0U);
#line 204
      master_source_unlock(entry);
#line 205
      return (this);
    }
#line 208
    last = (struct map_source *)((void *)0);
#line 209
    next = entry->maps;
#line 210
    while (next) {
#line 211
      last = next;
#line 212
      next = next->next;
    }
#line 214
    if (last) {
#line 215
      last->next = source;
    } else {
#line 217
      entry->maps = source;
    }
  }
#line 220
  master_source_unlock(entry);
#line 222
  return (source);
}
}
#line 225 "master.c"
static int compare_source_type_and_format(struct map_source *map , char const   *type___1 ,
                                          char const   *format___1 ) 
{ int res ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 227
  res = 0;
#line 229
  if (type___1) {
#line 230
    if (! map->type) {
      goto done;
    }
#line 233
    if (0) {
#line 233
      __s1_len = strlen((char const   *)map->type);
#line 233
      __s2_len = strlen(type___1);
#line 233
      if (! ((unsigned int )((void const   *)(map->type + 1)) - (unsigned int )((void const   *)map->type) == 1U)) {
        goto _L___0;
      } else {
#line 233
        if (__s1_len >= 4U) {
          _L___0: 
#line 233
          if (! ((unsigned int )((void const   *)(type___1 + 1)) - (unsigned int )((void const   *)type___1) == 1U)) {
#line 233
            tmp___8 = 1;
          } else {
#line 233
            if (__s2_len >= 4U) {
#line 233
              tmp___8 = 1;
            } else {
#line 233
              tmp___8 = 0;
            }
          }
        } else {
#line 233
          tmp___8 = 0;
        }
      }
#line 233
      if (tmp___8) {
#line 233
        tmp___4 = __builtin_strcmp((char const   *)map->type, type___1);
      } else {
#line 233
        tmp___7 = __builtin_strcmp((char const   *)map->type, type___1);
#line 233
        tmp___4 = tmp___7;
      }
    } else {
#line 233
      tmp___7 = __builtin_strcmp((char const   *)map->type, type___1);
#line 233
      tmp___4 = tmp___7;
    }
#line 233
    if (tmp___4) {
      goto done;
    }
  } else {
#line 235
    if (map->type) {
      goto done;
    }
  }
#line 238
  if (format___1) {
#line 239
    if (! map->format) {
      goto done;
    }
#line 242
    if (0) {
#line 242
      __s1_len___0 = strlen((char const   *)map->format);
#line 242
      __s2_len___0 = strlen(format___1);
#line 242
      if (! ((unsigned int )((void const   *)(map->format + 1)) - (unsigned int )((void const   *)map->format) == 1U)) {
        goto _L___2;
      } else {
#line 242
        if (__s1_len___0 >= 4U) {
          _L___2: 
#line 242
          if (! ((unsigned int )((void const   *)(format___1 + 1)) - (unsigned int )((void const   *)format___1) == 1U)) {
#line 242
            tmp___18 = 1;
          } else {
#line 242
            if (__s2_len___0 >= 4U) {
#line 242
              tmp___18 = 1;
            } else {
#line 242
              tmp___18 = 0;
            }
          }
        } else {
#line 242
          tmp___18 = 0;
        }
      }
#line 242
      if (tmp___18) {
#line 242
        tmp___14 = __builtin_strcmp((char const   *)map->format, format___1);
      } else {
#line 242
        tmp___17 = __builtin_strcmp((char const   *)map->format, format___1);
#line 242
        tmp___14 = tmp___17;
      }
    } else {
#line 242
      tmp___17 = __builtin_strcmp((char const   *)map->format, format___1);
#line 242
      tmp___14 = tmp___17;
    }
#line 242
    if (tmp___14) {
      goto done;
    }
  } else {
#line 244
    if (map->format) {
      goto done;
    }
  }
#line 247
  res = 1;
  done: 
#line 249
  return (res);
}
}
#line 252 "master.c"
static struct map_source *__master_find_map_source(struct master_mapent *entry , char const   *type___1 ,
                                                   char const   *format___1 , int argc ,
                                                   char const   **argv ) 
{ struct map_source *map ;
  struct map_source *source ;
  int res ;

  {
#line 258
  source = (struct map_source *)((void *)0);
#line 261
  map = entry->maps;
#line 262
  while (map) {
#line 263
    res = compare_source_type_and_format(map, type___1, format___1);
#line 264
    if (! res) {
      goto next;
    }
#line 267
    res = compare_argv(map->argc, map->argv, argc, argv);
#line 268
    if (! res) {
      goto next;
    }
#line 271
    source = map;
#line 272
    break;
    next: 
#line 274
    map = map->next;
  }
#line 277
  return (source);
}
}
#line 280 "master.c"
struct map_source *master_find_map_source(struct master_mapent *entry , char const   *type___1 ,
                                          char const   *format___1 , int argc , char const   **argv ) 
{ struct map_source *source ;
  int status ;
  int tmp ;
  int status___0 ;
  int tmp___0 ;

  {
#line 284
  source = (struct map_source *)((void *)0);
#line 286
  while (1) {
#line 286
    tmp = pthread_mutex_lock(& master_mutex);
#line 286
    status = tmp;
#line 286
    if (status) {
#line 286
      while (1) {
#line 286
        if (status == 35) {
#line 286
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "master_find_map_source", 286, "master.c");
#line 286
          dump_core();
        }
#line 286
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 286,
                      "master.c");
#line 286
        abort();
#line 286
        break;
      }
    }
#line 286
    break;
  }
#line 288
  source = __master_find_map_source(entry, type___1, format___1, argc, argv);
#line 290
  while (1) {
#line 290
    tmp___0 = pthread_mutex_unlock(& master_mutex);
#line 290
    status___0 = tmp___0;
#line 290
    if (status___0) {
#line 290
      while (1) {
#line 290
        if (status___0 == 35) {
#line 290
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "master_find_map_source", 290, "master.c");
#line 290
          dump_core();
        }
#line 290
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status___0,
                      290, "master.c");
#line 290
        abort();
#line 290
        break;
      }
    }
#line 290
    break;
  }
#line 292
  return (source);
}
}
#line 295 "master.c"
static void __master_free_map_source(struct map_source *source , unsigned int free_cache ) 
{ struct map_source *instance ;
  struct map_source *instance___0 ;
  struct map_source *next ;

  {
#line 297
  if (source->type) {
#line 298
    free((void *)source->type);
  }
#line 299
  if (source->format) {
#line 300
    free((void *)source->format);
  }
#line 301
  if (free_cache) {
#line 301
    if (source->mc) {
#line 302
      cache_release(source);
    }
  }
#line 303
  if (source->lookup) {
#line 306
    instance = source->instance;
#line 307
    while (instance) {
#line 308
      if (instance->lookup) {
#line 309
        close_lookup(instance->lookup);
      }
#line 310
      instance = instance->next;
    }
#line 312
    close_lookup(source->lookup);
  }
#line 314
  if (source->argv) {
#line 315
    free_argv(source->argc, source->argv);
  }
#line 316
  if (source->instance) {
#line 319
    instance___0 = source->instance;
#line 320
    while (instance___0) {
#line 321
      next = instance___0->next;
#line 322
      __master_free_map_source(instance___0, 0U);
#line 323
      instance___0 = next;
    }
  }
#line 327
  free((void *)source);
#line 329
  return;
}
}
#line 332 "master.c"
void master_free_map_source(struct map_source *source , unsigned int free_cache ) 
{ int status ;

  {
#line 336
  status = pthread_mutex_lock(& instance_mutex);
#line 337
  if (status) {
#line 338
    while (1) {
#line 338
      if (status == 35) {
#line 338
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "master_free_map_source", 338, "master.c");
#line 338
        dump_core();
      }
#line 338
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 338,
                    "master.c");
#line 338
      abort();
#line 338
      break;
    }
  }
#line 340
  __master_free_map_source(source, free_cache);
#line 342
  status = pthread_mutex_unlock(& instance_mutex);
#line 343
  if (status) {
#line 344
    while (1) {
#line 344
      if (status == 35) {
#line 344
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "master_free_map_source", 344, "master.c");
#line 344
        dump_core();
      }
#line 344
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 344,
                    "master.c");
#line 344
      abort();
#line 344
      break;
    }
  }
#line 345
  return;
}
}
#line 347 "master.c"
struct map_source *master_find_source_instance(struct map_source *source , char const   *type___1 ,
                                               char const   *format___1 , int argc ,
                                               char const   **argv ) 
{ struct map_source *map ;
  struct map_source *instance ;
  int status ;
  int res ;

  {
#line 350
  instance = (struct map_source *)((void *)0);
#line 353
  status = pthread_mutex_lock(& instance_mutex);
#line 354
  if (status) {
#line 355
    while (1) {
#line 355
      if (status == 35) {
#line 355
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "master_find_source_instance", 355, "master.c");
#line 355
        dump_core();
      }
#line 355
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 355,
                    "master.c");
#line 355
      abort();
#line 355
      break;
    }
  }
#line 357
  map = source->instance;
#line 358
  while (map) {
#line 359
    res = compare_source_type_and_format(map, type___1, format___1);
#line 360
    if (! res) {
      goto next;
    }
#line 363
    if (! argv) {
#line 364
      instance = map;
#line 365
      break;
    }
#line 368
    res = compare_argv(map->argc, map->argv, argc, argv);
#line 369
    if (! res) {
      goto next;
    }
#line 372
    instance = map;
#line 373
    break;
    next: 
#line 375
    map = map->next;
  }
#line 378
  status = pthread_mutex_unlock(& instance_mutex);
#line 379
  if (status) {
#line 380
    while (1) {
#line 380
      if (status == 35) {
#line 380
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "master_find_source_instance", 380, "master.c");
#line 380
        dump_core();
      }
#line 380
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 380,
                    "master.c");
#line 380
      abort();
#line 380
      break;
    }
  }
#line 382
  return (instance);
}
}
#line 385 "master.c"
struct map_source *master_add_source_instance(struct map_source *source , char const   *type___1 ,
                                              char const   *format___1 , time_t age ,
                                              int argc , char const   **argv ) 
{ struct map_source *instance ;
  struct map_source *new ;
  char *ntype ;
  char *nformat ;
  char const   **tmpargv ;
  int status ;
  char *tmp___8 ;
  char *tmp___18 ;

  {
#line 394
  instance = master_find_source_instance(source, type___1, format___1, argc, argv);
#line 395
  if (instance) {
#line 396
    return (instance);
  }
#line 398
  new = (struct map_source *)malloc(sizeof(struct map_source ));
#line 399
  if (! new) {
#line 400
    return ((struct map_source *)((void *)0));
  }
#line 401
  memset((void *)new, 0, sizeof(struct map_source ));
#line 403
  if (type___1) {
#line 404
    tmp___8 = __strdup(type___1);
#line 404
    ntype = tmp___8;
#line 405
    if (! ntype) {
#line 406
      master_free_map_source(new, 0U);
#line 407
      return ((struct map_source *)((void *)0));
    }
#line 409
    new->type = ntype;
  }
#line 412
  if (format___1) {
#line 413
    tmp___18 = __strdup(format___1);
#line 413
    nformat = tmp___18;
#line 414
    if (! nformat) {
#line 415
      master_free_map_source(new, 0U);
#line 416
      return ((struct map_source *)((void *)0));
    }
#line 418
    new->format = nformat;
  }
#line 421
  new->age = age;
#line 422
  new->master_line = 0U;
#line 423
  new->mc = source->mc;
#line 424
  new->stale = 1U;
#line 426
  tmpargv = copy_argv(argc, argv);
#line 427
  if (! tmpargv) {
#line 428
    master_free_map_source(new, 0U);
#line 429
    return ((struct map_source *)((void *)0));
  }
#line 431
  new->argc = argc;
#line 432
  new->argv = tmpargv;
#line 434
  status = pthread_mutex_lock(& instance_mutex);
#line 435
  if (status) {
#line 436
    while (1) {
#line 436
      if (status == 35) {
#line 436
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "master_add_source_instance", 436, "master.c");
#line 436
        dump_core();
      }
#line 436
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 436,
                    "master.c");
#line 436
      abort();
#line 436
      break;
    }
  }
#line 438
  if (! source->instance) {
#line 439
    source->instance = new;
  } else {
#line 445
    new->next = source->instance;
#line 446
    source->instance = new;
  }
#line 449
  status = pthread_mutex_unlock(& instance_mutex);
#line 450
  if (status) {
#line 451
    while (1) {
#line 451
      if (status == 35) {
#line 451
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "master_add_source_instance", 451, "master.c");
#line 451
        dump_core();
      }
#line 451
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 451,
                    "master.c");
#line 451
      abort();
#line 451
      break;
    }
  }
#line 453
  return (new);
}
}
#line 456 "master.c"
static void check_stale_instances(struct map_source *source ) 
{ struct map_source *map ;

  {
#line 460
  if (! source) {
#line 461
    return;
  }
#line 463
  map = source->instance;
#line 464
  while (map) {
#line 465
    if (map->stale) {
#line 466
      source->stale = 1U;
#line 467
      break;
    }
#line 469
    check_stale_instances(map->instance);
#line 470
    map = map->next;
  }
#line 473
  return;
}
}
#line 476 "master.c"
void send_map_update_request(struct autofs_point *ap ) 
{ struct map_source *map ;
  int status ;
  int need_update ;

  {
#line 479
  need_update = 0;
#line 481
  if (! ap->ghost) {
#line 482
    return;
  }
#line 484
  status = pthread_mutex_lock(& instance_mutex);
#line 485
  if (status) {
#line 486
    while (1) {
#line 486
      if (status == 35) {
#line 486
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "send_map_update_request", 486, "master.c");
#line 486
        dump_core();
      }
#line 486
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 486,
                    "master.c");
#line 486
      abort();
#line 486
      break;
    }
  }
#line 488
  map = (ap->entry)->maps;
#line 489
  while (map) {
#line 490
    check_stale_instances(map);
#line 491
    map = map->next;
  }
#line 494
  map = (ap->entry)->maps;
#line 495
  while (map) {
#line 496
    if (map->stale) {
#line 497
      need_update = 1;
#line 498
      break;
    }
#line 500
    map = map->next;
  }
#line 503
  status = pthread_mutex_unlock(& instance_mutex);
#line 504
  if (status) {
#line 505
    while (1) {
#line 505
      if (status == 35) {
#line 505
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "send_map_update_request", 505, "master.c");
#line 505
        dump_core();
      }
#line 505
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 505,
                    "master.c");
#line 505
      abort();
#line 505
      break;
    }
  }
#line 507
  if (! need_update) {
#line 508
    return;
  }
#line 510
  status = pthread_mutex_lock(& ap->state_mutex);
#line 511
  if (status) {
#line 512
    while (1) {
#line 512
      if (status == 35) {
#line 512
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "send_map_update_request", 512, "master.c");
#line 512
        dump_core();
      }
#line 512
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 512,
                    "master.c");
#line 512
      abort();
#line 512
      break;
    }
  }
#line 513
  nextstate(ap->state_pipe[1], (enum states )4);
#line 514
  status = pthread_mutex_unlock(& ap->state_mutex);
#line 515
  if (status) {
#line 516
    while (1) {
#line 516
      if (status == 35) {
#line 516
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "send_map_update_request", 516, "master.c");
#line 516
        dump_core();
      }
#line 516
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 516,
                    "master.c");
#line 516
      abort();
#line 516
      break;
    }
  }
#line 518
  return;
}
}
#line 521 "master.c"
void master_source_writelock(struct master_mapent *entry ) 
{ int status ;

  {
#line 525
  status = pthread_rwlock_wrlock(& entry->source_lock);
#line 526
  if (status) {
#line 527
    while (1) {
#line 527
      ((*log_error))(3U, "%s: master_mapent source write lock failed", "master_source_writelock");
#line 527
      break;
    }
#line 529
    while (1) {
#line 529
      if (status == 35) {
#line 529
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "master_source_writelock", 529, "master.c");
#line 529
        dump_core();
      }
#line 529
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 529,
                    "master.c");
#line 529
      abort();
#line 529
      break;
    }
  }
#line 531
  return;
}
}
#line 534 "master.c"
void master_source_readlock(struct master_mapent *entry ) 
{ int status ;

  {
#line 538
  status = pthread_rwlock_rdlock(& entry->source_lock);
#line 539
  if (status) {
#line 540
    while (1) {
#line 540
      ((*log_error))(3U, "%s: master_mapent source read lock failed", "master_source_readlock");
#line 540
      break;
    }
#line 542
    while (1) {
#line 542
      if (status == 35) {
#line 542
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "master_source_readlock", 542, "master.c");
#line 542
        dump_core();
      }
#line 542
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 542,
                    "master.c");
#line 542
      abort();
#line 542
      break;
    }
  }
#line 544
  return;
}
}
#line 547 "master.c"
void master_source_unlock(struct master_mapent *entry ) 
{ int status ;

  {
#line 551
  status = pthread_rwlock_unlock(& entry->source_lock);
#line 552
  if (status) {
#line 553
    while (1) {
#line 553
      ((*log_error))(3U, "%s: master_mapent source unlock failed", "master_source_unlock");
#line 553
      break;
    }
#line 555
    while (1) {
#line 555
      if (status == 35) {
#line 555
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "master_source_unlock", 555, "master.c");
#line 555
        dump_core();
      }
#line 555
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 555,
                    "master.c");
#line 555
      abort();
#line 555
      break;
    }
  }
#line 557
  return;
}
}
#line 560 "master.c"
void master_source_lock_cleanup(void *arg ) 
{ struct master_mapent *entry ;

  {
#line 562
  entry = (struct master_mapent *)arg;
#line 564
  master_source_unlock(entry);
#line 566
  return;
}
}
#line 569 "master.c"
void master_source_current_wait(struct master_mapent *entry ) 
{ int status ;

  {
#line 573
  status = pthread_mutex_lock(& entry->current_mutex);
#line 574
  if (status) {
#line 575
    while (1) {
#line 575
      ((*log_error))(3U, "%s: entry current source lock failed", "master_source_current_wait");
#line 575
      break;
    }
#line 576
    while (1) {
#line 576
      if (status == 35) {
#line 576
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "master_source_current_wait", 576, "master.c");
#line 576
        dump_core();
      }
#line 576
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 576,
                    "master.c");
#line 576
      abort();
#line 576
      break;
    }
  }
#line 579
  while ((unsigned int )entry->current != (unsigned int )((void *)0)) {
#line 580
    status = pthread_cond_wait((pthread_cond_t * __restrict  )(& entry->current_cond),
                               (pthread_mutex_t * __restrict  )(& entry->current_mutex));
#line 582
    if (status) {
#line 583
      while (1) {
#line 583
        ((*log_error))(3U, "%s: entry current source condition wait failed", "master_source_current_wait");
#line 583
        break;
      }
#line 585
      while (1) {
#line 585
        if (status == 35) {
#line 585
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "master_source_current_wait", 585, "master.c");
#line 585
          dump_core();
        }
#line 585
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 585,
                      "master.c");
#line 585
        abort();
#line 585
        break;
      }
    }
  }
#line 589
  return;
}
}
#line 592 "master.c"
void master_source_current_signal(struct master_mapent *entry ) 
{ int status ;

  {
#line 596
  status = pthread_cond_signal(& entry->current_cond);
#line 597
  if (status) {
#line 598
    while (1) {
#line 598
      ((*log_error))(3U, "%s: entry current source condition signal failed", "master_source_current_signal");
#line 598
      break;
    }
#line 600
    while (1) {
#line 600
      if (status == 35) {
#line 600
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "master_source_current_signal", 600, "master.c");
#line 600
        dump_core();
      }
#line 600
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 600,
                    "master.c");
#line 600
      abort();
#line 600
      break;
    }
  }
#line 603
  status = pthread_mutex_unlock(& entry->current_mutex);
#line 604
  if (status) {
#line 605
    while (1) {
#line 605
      ((*log_error))(3U, "%s: entry current source unlock failed", "master_source_current_signal");
#line 605
      break;
    }
#line 606
    while (1) {
#line 606
      if (status == 35) {
#line 606
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "master_source_current_signal", 606, "master.c");
#line 606
        dump_core();
      }
#line 606
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 606,
                    "master.c");
#line 606
      abort();
#line 606
      break;
    }
  }
#line 609
  return;
}
}
#line 612 "master.c"
struct master_mapent *master_find_mapent(struct master *master , char const   *path___1 ) 
{ struct list_head *head ;
  struct list_head *p ;
  int status ;
  int tmp ;
  struct master_mapent *entry ;
  int status___0 ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  int status___1 ;
  int tmp___11 ;

  {
#line 616
  while (1) {
#line 616
    tmp = pthread_mutex_lock(& master_mutex);
#line 616
    status = tmp;
#line 616
    if (status) {
#line 616
      while (1) {
#line 616
        if (status == 35) {
#line 616
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "master_find_mapent", 616, "master.c");
#line 616
          dump_core();
        }
#line 616
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 616,
                      "master.c");
#line 616
        abort();
#line 616
        break;
      }
    }
#line 616
    break;
  }
#line 618
  head = & master->mounts;
#line 619
  p = head->next;
#line 619
  while ((unsigned int )p != (unsigned int )head) {
#line 622
    entry = (struct master_mapent *)((char *)p - (unsigned long )(& ((struct master_mapent *)0)->list));
#line 624
    if (0) {
#line 624
      __s1_len = strlen((char const   *)entry->path);
#line 624
      __s2_len = strlen(path___1);
#line 624
      if (! ((unsigned int )((void const   *)(entry->path + 1)) - (unsigned int )((void const   *)entry->path) == 1U)) {
        goto _L___0;
      } else {
#line 624
        if (__s1_len >= 4U) {
          _L___0: 
#line 624
          if (! ((unsigned int )((void const   *)(path___1 + 1)) - (unsigned int )((void const   *)path___1) == 1U)) {
#line 624
            tmp___10 = 1;
          } else {
#line 624
            if (__s2_len >= 4U) {
#line 624
              tmp___10 = 1;
            } else {
#line 624
              tmp___10 = 0;
            }
          }
        } else {
#line 624
          tmp___10 = 0;
        }
      }
#line 624
      if (tmp___10) {
#line 624
        tmp___6 = __builtin_strcmp((char const   *)entry->path, path___1);
      } else {
#line 624
        tmp___9 = __builtin_strcmp((char const   *)entry->path, path___1);
#line 624
        tmp___6 = tmp___9;
      }
    } else {
#line 624
      tmp___9 = __builtin_strcmp((char const   *)entry->path, path___1);
#line 624
      tmp___6 = tmp___9;
    }
#line 624
    if (! tmp___6) {
#line 625
      while (1) {
#line 625
        tmp___0 = pthread_mutex_unlock(& master_mutex);
#line 625
        status___0 = tmp___0;
#line 625
        if (status___0) {
#line 625
          while (1) {
#line 625
            if (status___0 == 35) {
#line 625
              ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                            "master_find_mapent", 625, "master.c");
#line 625
              dump_core();
            }
#line 625
            ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status___0,
                          625, "master.c");
#line 625
            abort();
#line 625
            break;
          }
        }
#line 625
        break;
      }
#line 626
      return (entry);
    }
#line 619
    p = p->next;
  }
#line 630
  while (1) {
#line 630
    tmp___11 = pthread_mutex_unlock(& master_mutex);
#line 630
    status___1 = tmp___11;
#line 630
    if (status___1) {
#line 630
      while (1) {
#line 630
        if (status___1 == 35) {
#line 630
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "master_find_mapent", 630, "master.c");
#line 630
          dump_core();
        }
#line 630
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status___1,
                      630, "master.c");
#line 630
        abort();
#line 630
        break;
      }
    }
#line 630
    break;
  }
#line 632
  return ((struct master_mapent *)((void *)0));
}
}
#line 635 "master.c"
struct master_mapent *master_new_mapent(struct master *master , char const   *path___1 ,
                                        time_t age ) 
{ struct master_mapent *entry ;
  int status ;
  char *tmp ;
  char *tmp___9 ;

  {
#line 641
  entry = (struct master_mapent *)malloc(sizeof(struct master_mapent ));
#line 642
  if (! entry) {
#line 643
    return ((struct master_mapent *)((void *)0));
  }
#line 645
  memset((void *)entry, 0, sizeof(struct master_mapent ));
#line 647
  tmp___9 = __strdup(path___1);
#line 647
  tmp = tmp___9;
#line 648
  if (! tmp) {
#line 649
    free((void *)entry);
#line 650
    return ((struct master_mapent *)((void *)0));
  }
#line 652
  entry->path = tmp;
#line 654
  entry->thid = 0UL;
#line 655
  entry->age = age;
#line 656
  entry->master = master;
#line 657
  entry->current = (struct map_source *)((void *)0);
#line 658
  entry->maps = (struct map_source *)((void *)0);
#line 659
  entry->ap = (struct autofs_point *)((void *)0);
#line 661
  status = pthread_rwlock_init((pthread_rwlock_t * __restrict  )(& entry->source_lock),
                               (pthread_rwlockattr_t const   * __restrict  )((void *)0));
#line 662
  if (status) {
#line 663
    while (1) {
#line 663
      if (status == 35) {
#line 663
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "master_new_mapent", 663, "master.c");
#line 663
        dump_core();
      }
#line 663
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 663,
                    "master.c");
#line 663
      abort();
#line 663
      break;
    }
  }
#line 665
  status = pthread_mutex_init(& entry->current_mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 666
  if (status) {
#line 667
    while (1) {
#line 667
      if (status == 35) {
#line 667
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "master_new_mapent", 667, "master.c");
#line 667
        dump_core();
      }
#line 667
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 667,
                    "master.c");
#line 667
      abort();
#line 667
      break;
    }
  }
#line 669
  status = pthread_cond_init((pthread_cond_t * __restrict  )(& entry->current_cond),
                             (pthread_condattr_t const   * __restrict  )((void *)0));
#line 670
  if (status) {
#line 671
    while (1) {
#line 671
      if (status == 35) {
#line 671
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "master_new_mapent", 671, "master.c");
#line 671
        dump_core();
      }
#line 671
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 671,
                    "master.c");
#line 671
      abort();
#line 671
      break;
    }
  }
#line 673
  while (1) {
#line 673
    entry->list.next = & entry->list;
#line 673
    entry->list.prev = & entry->list;
#line 673
    break;
  }
#line 675
  return (entry);
}
}
#line 678 "master.c"
void master_add_mapent(struct master *master , struct master_mapent *entry ) 
{ int status ;
  int tmp ;
  int status___0 ;
  int tmp___0 ;

  {
#line 680
  while (1) {
#line 680
    tmp = pthread_mutex_lock(& master_mutex);
#line 680
    status = tmp;
#line 680
    if (status) {
#line 680
      while (1) {
#line 680
        if (status == 35) {
#line 680
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "master_add_mapent", 680, "master.c");
#line 680
          dump_core();
        }
#line 680
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 680,
                      "master.c");
#line 680
        abort();
#line 680
        break;
      }
    }
#line 680
    break;
  }
#line 681
  list_add_tail(& entry->list, & master->mounts);
#line 682
  while (1) {
#line 682
    tmp___0 = pthread_mutex_unlock(& master_mutex);
#line 682
    status___0 = tmp___0;
#line 682
    if (status___0) {
#line 682
      while (1) {
#line 682
        if (status___0 == 35) {
#line 682
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "master_add_mapent", 682, "master.c");
#line 682
          dump_core();
        }
#line 682
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status___0,
                      682, "master.c");
#line 682
        abort();
#line 682
        break;
      }
    }
#line 682
    break;
  }
#line 683
  return;
}
}
#line 686 "master.c"
void master_remove_mapent(struct master_mapent *entry ) 
{ int status ;
  int tmp ;
  int tmp___0 ;
  int status___0 ;
  int tmp___1 ;

  {
#line 688
  if ((entry->ap)->submount) {
#line 689
    return;
  }
#line 691
  while (1) {
#line 691
    tmp = pthread_mutex_lock(& master_mutex);
#line 691
    status = tmp;
#line 691
    if (status) {
#line 691
      while (1) {
#line 691
        if (status == 35) {
#line 691
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "master_remove_mapent", 691, "master.c");
#line 691
          dump_core();
        }
#line 691
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 691,
                      "master.c");
#line 691
        abort();
#line 691
        break;
      }
    }
#line 691
    break;
  }
#line 692
  tmp___0 = list_empty(& entry->list);
#line 692
  if (! tmp___0) {
#line 693
    list_del_init(& entry->list);
  }
#line 694
  while (1) {
#line 694
    tmp___1 = pthread_mutex_unlock(& master_mutex);
#line 694
    status___0 = tmp___1;
#line 694
    if (status___0) {
#line 694
      while (1) {
#line 694
        if (status___0 == 35) {
#line 694
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "master_remove_mapent", 694, "master.c");
#line 694
          dump_core();
        }
#line 694
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status___0,
                      694, "master.c");
#line 694
        abort();
#line 694
        break;
      }
    }
#line 694
    break;
  }
#line 695
  return;
}
}
#line 698 "master.c"
void master_free_mapent_sources(struct master_mapent *entry , unsigned int free_cache ) 
{ struct map_source *m ;
  struct map_source *n ;

  {
#line 700
  master_source_writelock(entry);
#line 702
  if (entry->maps) {
#line 705
    m = entry->maps;
#line 706
    while (m) {
#line 707
      n = m->next;
#line 708
      master_free_map_source(m, free_cache);
#line 709
      m = n;
    }
#line 711
    entry->maps = (struct map_source *)((void *)0);
  }
#line 714
  master_source_unlock(entry);
#line 716
  return;
}
}
#line 719 "master.c"
void master_free_mapent(struct master_mapent *entry ) 
{ int status ;

  {
#line 723
  if (entry->path) {
#line 724
    free((void *)entry->path);
  }
#line 726
  master_free_autofs_point(entry->ap);
#line 728
  status = pthread_rwlock_destroy(& entry->source_lock);
#line 729
  if (status) {
#line 730
    while (1) {
#line 730
      if (status == 35) {
#line 730
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "master_free_mapent", 730, "master.c");
#line 730
        dump_core();
      }
#line 730
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 730,
                    "master.c");
#line 730
      abort();
#line 730
      break;
    }
  }
#line 732
  status = pthread_mutex_destroy(& entry->current_mutex);
#line 733
  if (status) {
#line 734
    while (1) {
#line 734
      if (status == 35) {
#line 734
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "master_free_mapent", 734, "master.c");
#line 734
        dump_core();
      }
#line 734
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 734,
                    "master.c");
#line 734
      abort();
#line 734
      break;
    }
  }
#line 736
  status = pthread_cond_destroy(& entry->current_cond);
#line 737
  if (status) {
#line 738
    while (1) {
#line 738
      if (status == 35) {
#line 738
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "master_free_mapent", 738, "master.c");
#line 738
        dump_core();
      }
#line 738
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 738,
                    "master.c");
#line 738
      abort();
#line 738
      break;
    }
  }
#line 740
  free((void *)entry);
#line 742
  return;
}
}
#line 745 "master.c"
struct master *master_new(char const   *name___0 , unsigned int timeout___1 , unsigned int ghost___1 ) 
{ struct master *master ;
  char *tmp ;
  char *tmp___10 ;

  {
#line 750
  master = (struct master *)malloc(sizeof(struct master ));
#line 751
  if (! master) {
#line 752
    return ((struct master *)((void *)0));
  }
#line 754
  if (! name___0) {
#line 755
    tmp = (char *)defaults_get_master_map();
  } else {
#line 757
    tmp___10 = __strdup(name___0);
#line 757
    tmp = tmp___10;
  }
#line 759
  if (! tmp) {
#line 760
    free((void *)master);
#line 761
    return ((struct master *)((void *)0));
  }
#line 764
  master->name = tmp;
#line 765
  master->nc = (struct mapent_cache *)((void *)0);
#line 767
  master->recurse = 0U;
#line 768
  master->depth = 0U;
#line 769
  master->reading = 0U;
#line 770
  master->default_ghost = ghost___1;
#line 771
  master->default_timeout = timeout___1;
#line 772
  master->default_logging = defaults_get_logging();
#line 774
  while (1) {
#line 774
    master->mounts.next = & master->mounts;
#line 774
    master->mounts.prev = & master->mounts;
#line 774
    break;
  }
#line 776
  return (master);
}
}
#line 779 "master.c"
int master_read_master(struct master *master , time_t age , int readall ) 
{ struct mapent_cache *nc ;
  int tmp ;
  int status ;
  int tmp___0 ;
  int status___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int status___1 ;
  int tmp___3 ;

  {
#line 783
  nc = cache_init_null_cache(master);
#line 784
  if (! nc) {
#line 785
    while (1) {
#line 785
      ((*log_error))(3U, "%s: failed to init null map cache for %s", "master_read_master",
                     master->name);
#line 785
      break;
    }
#line 787
    return (0);
  }
#line 789
  master->nc = nc;
#line 791
  master_init_scan();
#line 793
  tmp = lookup_nss_read_master(master, age);
#line 793
  if (! tmp) {
#line 794
    while (1) {
#line 794
      ((*log_error))(3U, "%s: can\'t read master map %s", "master_read_master", master->name);
#line 794
      break;
    }
#line 796
    return (0);
  }
#line 799
  master_mount_mounts(master, age, readall);
#line 801
  while (1) {
#line 801
    tmp___0 = pthread_mutex_lock(& master_mutex);
#line 801
    status = tmp___0;
#line 801
    if (status) {
#line 801
      while (1) {
#line 801
        if (status == 35) {
#line 801
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "master_read_master", 801, "master.c");
#line 801
          dump_core();
        }
#line 801
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 801,
                      "master.c");
#line 801
        abort();
#line 801
        break;
      }
    }
#line 801
    break;
  }
#line 803
  tmp___2 = list_empty(& master->mounts);
#line 803
  if (tmp___2) {
#line 804
    while (1) {
#line 804
      tmp___1 = pthread_mutex_unlock(& master_mutex);
#line 804
      status___0 = tmp___1;
#line 804
      if (status___0) {
#line 804
        while (1) {
#line 804
          if (status___0 == 35) {
#line 804
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "master_read_master", 804, "master.c");
#line 804
            dump_core();
          }
#line 804
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status___0,
                        804, "master.c");
#line 804
          abort();
#line 804
          break;
        }
      }
#line 804
      break;
    }
#line 805
    while (1) {
#line 805
      ((*log_error))(3U, "%s: no mounts in table", "master_read_master");
#line 805
      break;
    }
#line 806
    return (0);
  }
#line 809
  while (1) {
#line 809
    tmp___3 = pthread_mutex_unlock(& master_mutex);
#line 809
    status___1 = tmp___3;
#line 809
    if (status___1) {
#line 809
      while (1) {
#line 809
        if (status___1 == 35) {
#line 809
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "master_read_master", 809, "master.c");
#line 809
          dump_core();
        }
#line 809
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status___1,
                      809, "master.c");
#line 809
        abort();
#line 809
        break;
      }
    }
#line 809
    break;
  }
#line 811
  return (1);
}
}
#line 814 "master.c"
int master_submount_list_empty(struct autofs_point *ap ) 
{ int res ;
  int _m_lock ;
  int tmp ;
  int tmp___0 ;
  int _m_unlock ;
  int tmp___1 ;

  {
#line 816
  res = 0;
#line 818
  while (1) {
#line 818
    tmp = pthread_mutex_lock(& ap->mounts_mutex);
#line 818
    _m_lock = tmp;
#line 818
    if (_m_lock) {
#line 818
      while (1) {
#line 818
        if (_m_lock == 35) {
#line 818
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "master_submount_list_empty", 818, "master.c");
#line 818
          dump_core();
        }
#line 818
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _m_lock, 818,
                      "master.c");
#line 818
        abort();
#line 818
        break;
      }
    }
#line 818
    break;
  }
#line 819
  tmp___0 = list_empty(& ap->submounts);
#line 819
  if (tmp___0) {
#line 820
    res = 1;
  }
#line 821
  while (1) {
#line 821
    tmp___1 = pthread_mutex_unlock(& ap->mounts_mutex);
#line 821
    _m_unlock = tmp___1;
#line 821
    if (_m_unlock) {
#line 821
      while (1) {
#line 821
        if (_m_unlock == 35) {
#line 821
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "master_submount_list_empty", 821, "master.c");
#line 821
          dump_core();
        }
#line 821
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _m_unlock,
                      821, "master.c");
#line 821
        abort();
#line 821
        break;
      }
    }
#line 821
    break;
  }
#line 823
  return (res);
}
}
#line 826 "master.c"
int master_notify_submount(struct autofs_point *ap , char const   *path___1 , enum states state ) 
{ struct list_head *head ;
  struct list_head *p ;
  struct autofs_point *this ;
  pthread_t thid ;
  size_t plen ;
  size_t tmp ;
  int status ;
  int ret ;
  int _m_lock ;
  int tmp___0 ;
  size_t len ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___16 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  int _st_lock ;
  int tmp___29 ;
  int _st_unlock ;
  int tmp___30 ;
  int _st_unlock___0 ;
  int tmp___31 ;
  int _m_unlock ;
  int tmp___32 ;

  {
#line 831
  tmp = strlen(path___1);
#line 831
  plen = tmp;
#line 832
  ret = 1;
#line 834
  while (1) {
#line 834
    tmp___0 = pthread_mutex_lock(& ap->mounts_mutex);
#line 834
    _m_lock = tmp___0;
#line 834
    if (_m_lock) {
#line 834
      while (1) {
#line 834
        if (_m_lock == 35) {
#line 834
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "master_notify_submount", 834, "master.c");
#line 834
          dump_core();
        }
#line 834
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _m_lock, 834,
                      "master.c");
#line 834
        abort();
#line 834
        break;
      }
    }
#line 834
    break;
  }
#line 836
  head = & ap->submounts;
#line 837
  p = head->prev;
#line 838
  while ((unsigned int )p != (unsigned int )head) {
#line 841
    this = (struct autofs_point *)((char *)p - (unsigned long )(& ((struct autofs_point *)0)->mounts));
#line 842
    p = p->prev;
#line 844
    tmp___2 = master_submount_list_empty(this);
#line 844
    if (! tmp___2) {
#line 845
      tmp___1 = master_notify_submount(this, path___1, state);
#line 845
      if (! tmp___1) {
#line 846
        ret = 0;
#line 847
        break;
      }
    }
#line 851
    len = strlen((char const   *)this->path);
#line 854
    if (0) {
#line 854
      if (0) {
#line 854
        __s1_len___0 = strlen((char const   *)this->path);
#line 854
        __s2_len___0 = strlen(path___1);
#line 854
        if (! ((unsigned int )((void const   *)(this->path + 1)) - (unsigned int )((void const   *)this->path) == 1U)) {
          goto _L___2;
        } else {
#line 854
          if (__s1_len___0 >= 4U) {
            _L___2: 
#line 854
            if (! ((unsigned int )((void const   *)(path___1 + 1)) - (unsigned int )((void const   *)path___1) == 1U)) {
#line 854
              tmp___26 = 1;
            } else {
#line 854
              if (__s2_len___0 >= 4U) {
#line 854
                tmp___26 = 1;
              } else {
#line 854
                tmp___26 = 0;
              }
            }
          } else {
#line 854
            tmp___26 = 0;
          }
        }
#line 854
        if (tmp___26) {
#line 854
          tmp___22 = __builtin_strcmp((char const   *)this->path, path___1);
        } else {
#line 854
          tmp___25 = __builtin_strcmp((char const   *)this->path, path___1);
#line 854
          tmp___22 = tmp___25;
        }
      } else {
#line 854
        tmp___25 = __builtin_strcmp((char const   *)this->path, path___1);
#line 854
        tmp___22 = tmp___25;
      }
#line 854
      tmp___16 = tmp___22;
    } else {
#line 854
      tmp___16 = strncmp((char const   *)this->path, path___1, len);
    }
#line 854
    if (tmp___16) {
#line 855
      continue;
    }
#line 862
    if (plen > len) {
#line 864
      if ((int const   )(*(path___1 + len)) != 47) {
#line 865
        continue;
      }
#line 866
      break;
    }
#line 871
    while (1) {
#line 871
      tmp___29 = pthread_mutex_lock(& this->state_mutex);
#line 871
      _st_lock = tmp___29;
#line 871
      if (_st_lock) {
#line 871
        while (1) {
#line 871
          if (_st_lock == 35) {
#line 871
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "master_notify_submount", 871, "master.c");
#line 871
            dump_core();
          }
#line 871
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_lock,
                        871, "master.c");
#line 871
          abort();
#line 871
          break;
        }
      }
#line 871
      break;
    }
#line 873
    if ((int )this->state == 7) {
#line 874
      while (1) {
#line 874
        tmp___30 = pthread_mutex_unlock(& this->state_mutex);
#line 874
        _st_unlock = tmp___30;
#line 874
        if (_st_unlock) {
#line 874
          while (1) {
#line 874
            if (_st_unlock == 35) {
#line 874
              ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                            "master_notify_submount", 874, "master.c");
#line 874
              dump_core();
            }
#line 874
            ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_unlock,
                          874, "master.c");
#line 874
            abort();
#line 874
            break;
          }
        }
#line 874
        break;
      }
#line 875
      break;
    }
#line 878
    nextstate(this->state_pipe[1], state);
#line 880
    while (1) {
#line 880
      tmp___31 = pthread_mutex_unlock(& this->state_mutex);
#line 880
      _st_unlock___0 = tmp___31;
#line 880
      if (_st_unlock___0) {
#line 880
        while (1) {
#line 880
          if (_st_unlock___0 == 35) {
#line 880
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "master_notify_submount", 880, "master.c");
#line 880
            dump_core();
          }
#line 880
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_unlock___0,
                        880, "master.c");
#line 880
          abort();
#line 880
          break;
        }
      }
#line 880
      break;
    }
#line 882
    thid = this->thid;
#line 883
    ap->mounts_signaled = 0U;
#line 884
    while (ap->mounts_signaled == 0U) {
#line 885
      status = pthread_cond_wait((pthread_cond_t * __restrict  )(& ap->mounts_cond),
                                 (pthread_mutex_t * __restrict  )(& ap->mounts_mutex));
#line 886
      if (status) {
#line 887
        while (1) {
#line 887
          if (status == 35) {
#line 887
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "master_notify_submount", 887, "master.c");
#line 887
            dump_core();
          }
#line 887
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 887,
                        "master.c");
#line 887
          abort();
#line 887
          break;
        }
      }
    }
#line 890
    if (ap->mounts_signaled == 2U) {
#line 891
      status = pthread_join(thid, (void **)((void *)0));
#line 892
      if (status) {
#line 893
        while (1) {
#line 893
          if (status == 35) {
#line 893
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "master_notify_submount", 893, "master.c");
#line 893
            dump_core();
          }
#line 893
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 893,
                        "master.c");
#line 893
          abort();
#line 893
          break;
        }
      }
    } else {
#line 895
      ret = 0;
    }
#line 897
    break;
  }
#line 900
  while (1) {
#line 900
    tmp___32 = pthread_mutex_unlock(& ap->mounts_mutex);
#line 900
    _m_unlock = tmp___32;
#line 900
    if (_m_unlock) {
#line 900
      while (1) {
#line 900
        if (_m_unlock == 35) {
#line 900
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "master_notify_submount", 900, "master.c");
#line 900
          dump_core();
        }
#line 900
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _m_unlock,
                      900, "master.c");
#line 900
        abort();
#line 900
        break;
      }
    }
#line 900
    break;
  }
#line 902
  return (ret);
}
}
#line 905 "master.c"
void master_signal_submount(struct autofs_point *ap , unsigned int join ) 
{ int status ;
  int _m_lock ;
  int tmp ;
  int _m_unlock ;
  int tmp___0 ;

  {
#line 909
  if (! ap->parent) {
#line 910
    return;
  } else {
#line 909
    if (! ap->submount) {
#line 910
      return;
    }
  }
#line 912
  while (1) {
#line 912
    tmp = pthread_mutex_lock(& (ap->parent)->mounts_mutex);
#line 912
    _m_lock = tmp;
#line 912
    if (_m_lock) {
#line 912
      while (1) {
#line 912
        if (_m_lock == 35) {
#line 912
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "master_signal_submount", 912, "master.c");
#line 912
          dump_core();
        }
#line 912
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _m_lock, 912,
                      "master.c");
#line 912
        abort();
#line 912
        break;
      }
    }
#line 912
    break;
  }
#line 914
  (ap->parent)->mounts_signaled = join;
#line 916
  if (join == 2U) {
#line 918
    (ap->parent)->submnt_count --;
#line 919
    list_del(& ap->mounts);
  }
#line 922
  status = pthread_cond_signal(& (ap->parent)->mounts_cond);
#line 923
  if (status) {
#line 924
    while (1) {
#line 924
      if (status == 35) {
#line 924
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "master_signal_submount", 924, "master.c");
#line 924
        dump_core();
      }
#line 924
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 924,
                    "master.c");
#line 924
      abort();
#line 924
      break;
    }
  }
#line 926
  while (1) {
#line 926
    tmp___0 = pthread_mutex_unlock(& (ap->parent)->mounts_mutex);
#line 926
    _m_unlock = tmp___0;
#line 926
    if (_m_unlock) {
#line 926
      while (1) {
#line 926
        if (_m_unlock == 35) {
#line 926
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "master_signal_submount", 926, "master.c");
#line 926
          dump_core();
        }
#line 926
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _m_unlock,
                      926, "master.c");
#line 926
        abort();
#line 926
        break;
      }
    }
#line 926
    break;
  }
#line 928
  return;
}
}
#line 931 "master.c"
void master_notify_state_change(struct master *master , int sig ) 
{ struct master_mapent *entry ;
  struct autofs_point *ap ;
  struct list_head *p ;
  int state_pipe ;
  int cur_state ;
  int status ;
  int tmp ;
  enum states next ;
  int _st_lock ;
  int tmp___0 ;
  int _st_unlock ;
  int tmp___1 ;
  int status___0 ;
  int tmp___2 ;

  {
#line 938
  pthread_setcancelstate(1, & cur_state);
#line 939
  while (1) {
#line 939
    tmp = pthread_mutex_lock(& master_mutex);
#line 939
    status = tmp;
#line 939
    if (status) {
#line 939
      while (1) {
#line 939
        if (status == 35) {
#line 939
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "master_notify_state_change", 939, "master.c");
#line 939
          dump_core();
        }
#line 939
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 939,
                      "master.c");
#line 939
        abort();
#line 939
        break;
      }
    }
#line 939
    break;
  }
#line 941
  p = master->mounts.next;
#line 941
  while ((unsigned int )p != (unsigned int )(& master->mounts)) {
#line 942
    next = (enum states )-1;
#line 944
    entry = (struct master_mapent *)((char *)p - (unsigned long )(& ((struct master_mapent *)0)->list));
#line 946
    ap = entry->ap;
#line 948
    while (1) {
#line 948
      tmp___0 = pthread_mutex_lock(& ap->state_mutex);
#line 948
      _st_lock = tmp___0;
#line 948
      if (_st_lock) {
#line 948
        while (1) {
#line 948
          if (_st_lock == 35) {
#line 948
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "master_notify_state_change", 948, "master.c");
#line 948
            dump_core();
          }
#line 948
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_lock,
                        948, "master.c");
#line 948
          abort();
#line 948
          break;
        }
      }
#line 948
      break;
    }
#line 950
    if ((int )ap->state == 7) {
      goto next;
    }
#line 953
    state_pipe = ap->state_pipe[1];
#line 955
    switch (sig) {
    case 15: 
#line 957
    if ((int )ap->state != 5) {
#line 957
      if ((int )ap->state != 6) {
#line 959
        next = (enum states )5;
#line 960
        nextstate(state_pipe, next);
      }
    }
#line 962
    break;
    case 10: 
#line 973
    while (1) {
#line 973
      if (! ((int )ap->state == 1)) {
#line 973
        ((*log_crit))(3U, "master.c:%d: assertion failed: ap->state == ST_READY",
                      973);
      }
#line 973
      break;
    }
#line 974
    next = (enum states )3;
#line 975
    nextstate(state_pipe, next);
#line 976
    break;
    }
    next: 
#line 979
    if ((int )next != -1) {
#line 980
      while (1) {
#line 980
        ((*log_debug))(ap->logopt, "%s: sig %d switching %s from %d to %d", "master_notify_state_change",
                       sig, ap->path, ap->state, next);
#line 980
        break;
      }
    }
#line 984
    while (1) {
#line 984
      tmp___1 = pthread_mutex_unlock(& ap->state_mutex);
#line 984
      _st_unlock = tmp___1;
#line 984
      if (_st_unlock) {
#line 984
        while (1) {
#line 984
          if (_st_unlock == 35) {
#line 984
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "master_notify_state_change", 984, "master.c");
#line 984
            dump_core();
          }
#line 984
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_unlock,
                        984, "master.c");
#line 984
          abort();
#line 984
          break;
        }
      }
#line 984
      break;
    }
#line 941
    p = p->next;
  }
#line 987
  while (1) {
#line 987
    tmp___2 = pthread_mutex_unlock(& master_mutex);
#line 987
    status___0 = tmp___2;
#line 987
    if (status___0) {
#line 987
      while (1) {
#line 987
        if (status___0 == 35) {
#line 987
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "master_notify_state_change", 987, "master.c");
#line 987
          dump_core();
        }
#line 987
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status___0,
                      987, "master.c");
#line 987
        abort();
#line 987
        break;
      }
    }
#line 987
    break;
  }
#line 988
  pthread_setcancelstate(cur_state, (int *)((void *)0));
#line 990
  return;
}
}
#line 993 "master.c"
static int master_do_mount(struct master_mapent *entry ) 
{ struct autofs_point *ap ;
  pthread_t thid ;
  int status ;
  int tmp ;

  {
#line 999
  status = pthread_mutex_lock(& suc.mutex);
#line 1000
  if (status) {
#line 1001
    while (1) {
#line 1001
      if (status == 35) {
#line 1001
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "master_do_mount", 1001, "master.c");
#line 1001
        dump_core();
      }
#line 1001
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1001,
                    "master.c");
#line 1001
      abort();
#line 1001
      break;
    }
  }
#line 1003
  suc.done = 0U;
#line 1004
  suc.status = 0U;
#line 1006
  ap = entry->ap;
#line 1008
  while (1) {
#line 1008
    ((*log_debug))(ap->logopt, "%s: mounting %s", "master_do_mount", entry->path);
#line 1008
    break;
  }
#line 1010
  tmp = pthread_create((pthread_t * __restrict  )(& thid), (pthread_attr_t const   * __restrict  )(& thread_attr),
                       & handle_mounts, (void * __restrict  )ap);
#line 1010
  if (tmp) {
#line 1011
    while (1) {
#line 1011
      ((*log_crit))(ap->logopt, "%s: failed to create mount handler thread for %s",
                    "master_do_mount", entry->path);
#line 1011
      break;
    }
#line 1014
    status = pthread_mutex_unlock(& suc.mutex);
#line 1015
    if (status) {
#line 1016
      while (1) {
#line 1016
        if (status == 35) {
#line 1016
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "master_do_mount", 1016, "master.c");
#line 1016
          dump_core();
        }
#line 1016
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1016,
                      "master.c");
#line 1016
        abort();
#line 1016
        break;
      }
    }
#line 1017
    return (0);
  }
#line 1019
  entry->thid = thid;
#line 1021
  while (! suc.done) {
#line 1022
    status = pthread_cond_wait((pthread_cond_t * __restrict  )(& suc.cond), (pthread_mutex_t * __restrict  )(& suc.mutex));
#line 1023
    if (status) {
#line 1024
      while (1) {
#line 1024
        if (status == 35) {
#line 1024
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "master_do_mount", 1024, "master.c");
#line 1024
          dump_core();
        }
#line 1024
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1024,
                      "master.c");
#line 1024
        abort();
#line 1024
        break;
      }
    }
  }
#line 1027
  if (suc.status) {
#line 1028
    while (1) {
#line 1028
      ((*log_error))(ap->logopt, "%s: failed to startup mount", "master_do_mount");
#line 1028
      break;
    }
#line 1029
    status = pthread_mutex_unlock(& suc.mutex);
#line 1030
    if (status) {
#line 1031
      while (1) {
#line 1031
        if (status == 35) {
#line 1031
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "master_do_mount", 1031, "master.c");
#line 1031
          dump_core();
        }
#line 1031
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1031,
                      "master.c");
#line 1031
        abort();
#line 1031
        break;
      }
    }
#line 1032
    return (0);
  }
#line 1035
  status = pthread_mutex_unlock(& suc.mutex);
#line 1036
  if (status) {
#line 1037
    while (1) {
#line 1037
      if (status == 35) {
#line 1037
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "master_do_mount", 1037, "master.c");
#line 1037
        dump_core();
      }
#line 1037
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1037,
                    "master.c");
#line 1037
      abort();
#line 1037
      break;
    }
  }
#line 1039
  return (1);
}
}
#line 1042 "master.c"
static void shutdown_entry(struct master_mapent *entry ) 
{ int state_pipe ;
  struct autofs_point *ap ;
  struct stat st ;
  int ret ;
  int _st_lock ;
  int tmp ;
  int _st_unlock ;
  int tmp___0 ;

  {
#line 1049
  ap = entry->ap;
#line 1051
  while (1) {
#line 1051
    ((*log_debug))(ap->logopt, "%s: %s", "shutdown_entry", entry->path);
#line 1051
    break;
  }
#line 1053
  while (1) {
#line 1053
    tmp = pthread_mutex_lock(& ap->state_mutex);
#line 1053
    _st_lock = tmp;
#line 1053
    if (_st_lock) {
#line 1053
      while (1) {
#line 1053
        if (_st_lock == 35) {
#line 1053
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "shutdown_entry", 1053, "master.c");
#line 1053
          dump_core();
        }
#line 1053
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_lock, 1053,
                      "master.c");
#line 1053
        abort();
#line 1053
        break;
      }
    }
#line 1053
    break;
  }
#line 1055
  state_pipe = ap->state_pipe[1];
#line 1057
  ret = fstat__extinline(state_pipe, & st);
#line 1058
  if (ret == -1) {
    goto next;
  }
#line 1061
  nextstate(state_pipe, (enum states )5);
  next: 
#line 1063
  while (1) {
#line 1063
    tmp___0 = pthread_mutex_unlock(& ap->state_mutex);
#line 1063
    _st_unlock = tmp___0;
#line 1063
    if (_st_unlock) {
#line 1063
      while (1) {
#line 1063
        if (_st_unlock == 35) {
#line 1063
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "shutdown_entry", 1063, "master.c");
#line 1063
          dump_core();
        }
#line 1063
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_unlock,
                      1063, "master.c");
#line 1063
        abort();
#line 1063
        break;
      }
    }
#line 1063
    break;
  }
#line 1065
  return;
}
}
#line 1068 "master.c"
static void check_update_map_sources(struct master_mapent *entry , int readall ) 
{ struct map_source *source ;
  struct map_source *last ;
  int state_pipe ;
  int map_stale ;
  struct autofs_point *ap ;
  struct stat st ;
  int ret ;
  struct mapent *me ;
  struct map_source *next ;
  int _st_lock ;
  int tmp ;
  int _st_unlock ;
  int tmp___0 ;

  {
#line 1071
  map_stale = 0;
#line 1076
  if (readall) {
#line 1077
    map_stale = 1;
  }
#line 1079
  ap = entry->ap;
#line 1081
  master_source_writelock(entry);
#line 1083
  last = (struct map_source *)((void *)0);
#line 1084
  source = entry->maps;
#line 1085
  while (source) {
#line 1086
    if (readall) {
#line 1087
      source->stale = 1U;
    }
#line 1093
    if (entry->age > source->age) {
#line 1095
      cache_readlock(source->mc);
#line 1096
      me = cache_lookup_first(source->mc);
#line 1097
      if (! me) {
#line 1098
        next = source->next;
#line 1100
        cache_unlock(source->mc);
#line 1102
        if (! last) {
#line 1103
          entry->maps = next;
        } else {
#line 1105
          last->next = next;
        }
#line 1107
        if ((unsigned int )entry->maps == (unsigned int )source) {
#line 1108
          entry->maps = next;
        }
#line 1110
        master_free_map_source(source, 1U);
#line 1112
        source = next;
#line 1113
        continue;
      } else {
#line 1115
        source->stale = 1U;
#line 1116
        map_stale = 1;
      }
#line 1118
      cache_unlock(source->mc);
    }
#line 1120
    last = source;
#line 1121
    source = source->next;
  }
#line 1124
  master_source_unlock(entry);
#line 1127
  if (map_stale) {
#line 1128
    while (1) {
#line 1128
      tmp = pthread_mutex_lock(& ap->state_mutex);
#line 1128
      _st_lock = tmp;
#line 1128
      if (_st_lock) {
#line 1128
        while (1) {
#line 1128
          if (_st_lock == 35) {
#line 1128
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "check_update_map_sources", 1128, "master.c");
#line 1128
            dump_core();
          }
#line 1128
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_lock,
                        1128, "master.c");
#line 1128
          abort();
#line 1128
          break;
        }
      }
#line 1128
      break;
    }
#line 1130
    state_pipe = (entry->ap)->state_pipe[1];
#line 1132
    ret = fstat__extinline(state_pipe, & st);
#line 1133
    if (ret != -1) {
#line 1134
      nextstate(state_pipe, (enum states )4);
    }
#line 1136
    while (1) {
#line 1136
      tmp___0 = pthread_mutex_unlock(& ap->state_mutex);
#line 1136
      _st_unlock = tmp___0;
#line 1136
      if (_st_unlock) {
#line 1136
        while (1) {
#line 1136
          if (_st_unlock == 35) {
#line 1136
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "check_update_map_sources", 1136, "master.c");
#line 1136
            dump_core();
          }
#line 1136
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_unlock,
                        1136, "master.c");
#line 1136
          abort();
#line 1136
          break;
        }
      }
#line 1136
      break;
    }
  }
#line 1139
  return;
}
}
#line 1142 "master.c"
int master_mount_mounts(struct master *master , time_t age , int readall ) 
{ struct mapent_cache *nc ;
  struct list_head *p ;
  struct list_head *head ;
  int cur_state ;
  int status ;
  int tmp ;
  struct master_mapent *this ;
  struct autofs_point *ap ;
  struct mapent *ne ;
  struct mapent *nested ;
  struct stat st ;
  int state_pipe ;
  int save_errno ;
  int ret ;
  int _st_lock ;
  int tmp___0 ;
  int *tmp___1 ;
  int _st_unlock ;
  int tmp___2 ;
  int tmp___3 ;
  int status___0 ;
  int tmp___4 ;

  {
#line 1144
  nc = master->nc;
#line 1148
  pthread_setcancelstate(1, & cur_state);
#line 1149
  while (1) {
#line 1149
    tmp = pthread_mutex_lock(& master_mutex);
#line 1149
    status = tmp;
#line 1149
    if (status) {
#line 1149
      while (1) {
#line 1149
        if (status == 35) {
#line 1149
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "master_mount_mounts", 1149, "master.c");
#line 1149
          dump_core();
        }
#line 1149
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1149,
                      "master.c");
#line 1149
        abort();
#line 1149
        break;
      }
    }
#line 1149
    break;
  }
#line 1151
  head = & master->mounts;
#line 1152
  p = head->next;
#line 1153
  while ((unsigned int )p != (unsigned int )head) {
#line 1161
    this = (struct master_mapent *)((char *)p - (unsigned long )(& ((struct master_mapent *)0)->list));
#line 1162
    p = p->next;
#line 1164
    ap = this->ap;
#line 1167
    if (this->age < age) {
#line 1168
      shutdown_entry(this);
#line 1169
      continue;
    }
#line 1172
    cache_readlock(nc);
#line 1173
    ne = cache_lookup_distinct(nc, (char const   *)this->path);
#line 1174
    if (ne) {
#line 1174
      if (this->age > ne->age) {
#line 1175
        cache_unlock(nc);
#line 1176
        shutdown_entry(this);
#line 1177
        continue;
      }
    }
#line 1179
    nested = cache_partial_match(nc, (char const   *)this->path);
#line 1180
    if (nested) {
#line 1181
      while (1) {
#line 1181
        ((*log_error))(ap->logopt, "%s: removing invalid nested null entry %s", "master_mount_mounts",
                       nested->key);
#line 1181
        break;
      }
#line 1184
      nested = cache_partial_match(nc, (char const   *)this->path);
#line 1185
      if (nested) {
#line 1186
        cache_delete(nc, (char const   *)nested->key);
      }
    }
#line 1188
    cache_unlock(nc);
#line 1190
    check_update_map_sources(this, readall);
#line 1192
    while (1) {
#line 1192
      tmp___0 = pthread_mutex_lock(& ap->state_mutex);
#line 1192
      _st_lock = tmp___0;
#line 1192
      if (_st_lock) {
#line 1192
        while (1) {
#line 1192
          if (_st_lock == 35) {
#line 1192
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "master_mount_mounts", 1192, "master.c");
#line 1192
            dump_core();
          }
#line 1192
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_lock,
                        1192, "master.c");
#line 1192
          abort();
#line 1192
          break;
        }
      }
#line 1192
      break;
    }
#line 1194
    state_pipe = (this->ap)->state_pipe[1];
#line 1197
    ret = fstat__extinline(state_pipe, & st);
#line 1198
    tmp___1 = __errno_location();
#line 1198
    save_errno = (*tmp___1);
#line 1200
    while (1) {
#line 1200
      tmp___2 = pthread_mutex_unlock(& ap->state_mutex);
#line 1200
      _st_unlock = tmp___2;
#line 1200
      if (_st_unlock) {
#line 1200
        while (1) {
#line 1200
          if (_st_unlock == 35) {
#line 1200
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "master_mount_mounts", 1200, "master.c");
#line 1200
            dump_core();
          }
#line 1200
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_unlock,
                        1200, "master.c");
#line 1200
          abort();
#line 1200
          break;
        }
      }
#line 1200
      break;
    }
#line 1202
    if (ret == -1) {
#line 1202
      if (save_errno == 9) {
#line 1203
        tmp___3 = master_do_mount(this);
#line 1203
        if (! tmp___3) {
#line 1204
          list_del_init(& this->list);
#line 1205
          master_free_mapent_sources(ap->entry, 1U);
#line 1206
          master_free_mapent(ap->entry);
        }
      }
    }
  }
#line 1210
  while (1) {
#line 1210
    tmp___4 = pthread_mutex_unlock(& master_mutex);
#line 1210
    status___0 = tmp___4;
#line 1210
    if (status___0) {
#line 1210
      while (1) {
#line 1210
        if (status___0 == 35) {
#line 1210
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "master_mount_mounts", 1210, "master.c");
#line 1210
          dump_core();
        }
#line 1210
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status___0,
                      1210, "master.c");
#line 1210
        abort();
#line 1210
        break;
      }
    }
#line 1210
    break;
  }
#line 1211
  pthread_setcancelstate(cur_state, (int *)((void *)0));
#line 1213
  return (1);
}
}
#line 1216 "master.c"
int master_list_empty(struct master *master ) 
{ int res ;
  int status ;
  int tmp ;
  int tmp___0 ;
  int status___0 ;
  int tmp___1 ;

  {
#line 1218
  res = 0;
#line 1220
  while (1) {
#line 1220
    tmp = pthread_mutex_lock(& master_mutex);
#line 1220
    status = tmp;
#line 1220
    if (status) {
#line 1220
      while (1) {
#line 1220
        if (status == 35) {
#line 1220
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "master_list_empty", 1220, "master.c");
#line 1220
          dump_core();
        }
#line 1220
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1220,
                      "master.c");
#line 1220
        abort();
#line 1220
        break;
      }
    }
#line 1220
    break;
  }
#line 1221
  tmp___0 = list_empty(& master->mounts);
#line 1221
  if (tmp___0) {
#line 1222
    res = 1;
  }
#line 1223
  while (1) {
#line 1223
    tmp___1 = pthread_mutex_unlock(& master_mutex);
#line 1223
    status___0 = tmp___1;
#line 1223
    if (status___0) {
#line 1223
      while (1) {
#line 1223
        if (status___0 == 35) {
#line 1223
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "master_list_empty", 1223, "master.c");
#line 1223
          dump_core();
        }
#line 1223
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status___0,
                      1223, "master.c");
#line 1223
        abort();
#line 1223
        break;
      }
    }
#line 1223
    break;
  }
#line 1225
  return (res);
}
}
#line 1228 "master.c"
int master_kill(struct master *master ) 
{ int tmp ;

  {
#line 1230
  tmp = list_empty(& master->mounts);
#line 1230
  if (! tmp) {
#line 1231
    return (0);
  }
#line 1233
  if (master->name) {
#line 1234
    free((void *)master->name);
  }
#line 1236
  cache_release_null_cache(master);
#line 1237
  free((void *)master);
#line 1239
  return (1);
}
}
#line 1242 "master.c"
void dump_master(struct master *master ) 
{ struct list_head *p ;
  struct list_head *head ;
  struct master_mapent *this ;

  {
#line 1246
  head = & master->mounts;
#line 1247
  p = head->next;
#line 1247
  while ((unsigned int )p != (unsigned int )head) {
#line 1248
    this = (struct master_mapent *)((char *)p - (unsigned long )(& ((struct master_mapent *)0)->list));
#line 1249
    while (1) {
#line 1249
      ((*log_debug))(3U, "%s: path %s", "dump_master", this->path);
#line 1249
      break;
    }
#line 1247
    p = p->next;
  }
#line 1251
  return;
}
}
#line 1 "master_parse.tab.o"
#pragma merger(0,"/tmp/cil-4tcCqPvC.i","-O2,-Wall,-fPIC")
#line 72 "../include/master.h"
int master_parse_entry(char const   *buffer , unsigned int default_timeout , unsigned int logging ,
                       time_t age ) ;
#line 40 "master_parse.y"
int master_lex(void) ;
#line 41
int master_lineno ;
#line 42
void master_set_scan_buffer(char const   *buffer ) ;
#line 44
static char *master_strdup(char *str ) ;
#line 45
static void local_init_vars(void) ;
#line 46
static void local_free_vars(void) ;
#line 48
static int master_error(char const   *s ) ;
#line 49
static int master_notify(char const   *s ) ;
#line 51 "master_parse.y"
static char *path  ;
#line 52 "master_parse.y"
static char *type  ;
#line 53 "master_parse.y"
static char *format  ;
#line 54 "master_parse.y"
static long timeout  ;
#line 55 "master_parse.y"
static unsigned int ghost  ;
#line 56 "master_parse.y"
static char **local_argv  ;
#line 57 "master_parse.y"
static int local_argc  ;
#line 59 "master_parse.y"
static char errstr[512]  ;
#line 61 "master_parse.y"
static unsigned int verbose  ;
#line 62 "master_parse.y"
static unsigned int debug  ;
#line 64 "master_parse.y"
static int lineno  ;
#line 490 "master_parse.tab.c"
static yytype_uint8 const   yytranslate[282]  = 
#line 490 "master_parse.tab.c"
  {      (yytype_uint8 const   )(unsigned char)0,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)1,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)3,      (yytype_uint8 const   )(unsigned char)4, 
        (yytype_uint8 const   )(unsigned char)5,      (yytype_uint8 const   )(unsigned char)6,      (yytype_uint8 const   )(unsigned char)7,      (yytype_uint8 const   )(unsigned char)8, 
        (yytype_uint8 const   )(unsigned char)9,      (yytype_uint8 const   )(unsigned char)10,      (yytype_uint8 const   )(unsigned char)11,      (yytype_uint8 const   )(unsigned char)12, 
        (yytype_uint8 const   )(unsigned char)13,      (yytype_uint8 const   )(unsigned char)14,      (yytype_uint8 const   )(unsigned char)15,      (yytype_uint8 const   )(unsigned char)16, 
        (yytype_uint8 const   )(unsigned char)17,      (yytype_uint8 const   )(unsigned char)18,      (yytype_uint8 const   )(unsigned char)19,      (yytype_uint8 const   )(unsigned char)20, 
        (yytype_uint8 const   )(unsigned char)21,      (yytype_uint8 const   )(unsigned char)22,      (yytype_uint8 const   )(unsigned char)23,      (yytype_uint8 const   )(unsigned char)24, 
        (yytype_uint8 const   )(unsigned char)25,      (yytype_uint8 const   )(unsigned char)26};
#line 594 "master_parse.tab.c"
static yytype_uint8 const   yyr1[53]  = 
#line 594
  {      (yytype_uint8 const   )(unsigned char)0,      (yytype_uint8 const   )(unsigned char)27,      (yytype_uint8 const   )(unsigned char)29,      (yytype_uint8 const   )(unsigned char)28, 
        (yytype_uint8 const   )(unsigned char)30,      (yytype_uint8 const   )(unsigned char)30,      (yytype_uint8 const   )(unsigned char)30,      (yytype_uint8 const   )(unsigned char)30, 
        (yytype_uint8 const   )(unsigned char)30,      (yytype_uint8 const   )(unsigned char)30,      (yytype_uint8 const   )(unsigned char)30,      (yytype_uint8 const   )(unsigned char)30, 
        (yytype_uint8 const   )(unsigned char)30,      (yytype_uint8 const   )(unsigned char)30,      (yytype_uint8 const   )(unsigned char)30,      (yytype_uint8 const   )(unsigned char)30, 
        (yytype_uint8 const   )(unsigned char)30,      (yytype_uint8 const   )(unsigned char)30,      (yytype_uint8 const   )(unsigned char)30,      (yytype_uint8 const   )(unsigned char)30, 
        (yytype_uint8 const   )(unsigned char)31,      (yytype_uint8 const   )(unsigned char)31,      (yytype_uint8 const   )(unsigned char)31,      (yytype_uint8 const   )(unsigned char)31, 
        (yytype_uint8 const   )(unsigned char)31,      (yytype_uint8 const   )(unsigned char)31,      (yytype_uint8 const   )(unsigned char)31,      (yytype_uint8 const   )(unsigned char)31, 
        (yytype_uint8 const   )(unsigned char)32,      (yytype_uint8 const   )(unsigned char)32,      (yytype_uint8 const   )(unsigned char)32,      (yytype_uint8 const   )(unsigned char)33, 
        (yytype_uint8 const   )(unsigned char)33,      (yytype_uint8 const   )(unsigned char)33,      (yytype_uint8 const   )(unsigned char)33,      (yytype_uint8 const   )(unsigned char)34, 
        (yytype_uint8 const   )(unsigned char)34,      (yytype_uint8 const   )(unsigned char)34,      (yytype_uint8 const   )(unsigned char)34,      (yytype_uint8 const   )(unsigned char)35, 
        (yytype_uint8 const   )(unsigned char)35,      (yytype_uint8 const   )(unsigned char)35,      (yytype_uint8 const   )(unsigned char)35,      (yytype_uint8 const   )(unsigned char)35, 
        (yytype_uint8 const   )(unsigned char)36,      (yytype_uint8 const   )(unsigned char)36,      (yytype_uint8 const   )(unsigned char)36,      (yytype_uint8 const   )(unsigned char)37, 
        (yytype_uint8 const   )(unsigned char)37,      (yytype_uint8 const   )(unsigned char)37,      (yytype_uint8 const   )(unsigned char)37,      (yytype_uint8 const   )(unsigned char)37, 
        (yytype_uint8 const   )(unsigned char)38};
#line 605 "master_parse.tab.c"
static yytype_uint8 const   yyr2[53]  = 
#line 605
  {      (yytype_uint8 const   )(unsigned char)0,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)0,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)0,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)3,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)1, 
        (yytype_uint8 const   )(unsigned char)1,      (yytype_uint8 const   )(unsigned char)1,      (yytype_uint8 const   )(unsigned char)1,      (yytype_uint8 const   )(unsigned char)1, 
        (yytype_uint8 const   )(unsigned char)1,      (yytype_uint8 const   )(unsigned char)1,      (yytype_uint8 const   )(unsigned char)1,      (yytype_uint8 const   )(unsigned char)1, 
        (yytype_uint8 const   )(unsigned char)1,      (yytype_uint8 const   )(unsigned char)3,      (yytype_uint8 const   )(unsigned char)3,      (yytype_uint8 const   )(unsigned char)3, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)1,      (yytype_uint8 const   )(unsigned char)0,      (yytype_uint8 const   )(unsigned char)3, 
        (yytype_uint8 const   )(unsigned char)5,      (yytype_uint8 const   )(unsigned char)1,      (yytype_uint8 const   )(unsigned char)1,      (yytype_uint8 const   )(unsigned char)3, 
        (yytype_uint8 const   )(unsigned char)5,      (yytype_uint8 const   )(unsigned char)1,      (yytype_uint8 const   )(unsigned char)1,      (yytype_uint8 const   )(unsigned char)1, 
        (yytype_uint8 const   )(unsigned char)3,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)4,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)1,      (yytype_uint8 const   )(unsigned char)1,      (yytype_uint8 const   )(unsigned char)1,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)1,      (yytype_uint8 const   )(unsigned char)1,      (yytype_uint8 const   )(unsigned char)1,      (yytype_uint8 const   )(unsigned char)1, 
        (yytype_uint8 const   )(unsigned char)1};
#line 618 "master_parse.tab.c"
static yytype_uint8 const   yydefact[62]  = 
#line 618
  {      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)0,      (yytype_uint8 const   )(unsigned char)4,      (yytype_uint8 const   )(unsigned char)1, 
        (yytype_uint8 const   )(unsigned char)19,      (yytype_uint8 const   )(unsigned char)15,      (yytype_uint8 const   )(unsigned char)16,      (yytype_uint8 const   )(unsigned char)18, 
        (yytype_uint8 const   )(unsigned char)17,      (yytype_uint8 const   )(unsigned char)3,      (yytype_uint8 const   )(unsigned char)11,      (yytype_uint8 const   )(unsigned char)13, 
        (yytype_uint8 const   )(unsigned char)12,      (yytype_uint8 const   )(unsigned char)14,      (yytype_uint8 const   )(unsigned char)10,      (yytype_uint8 const   )(unsigned char)7, 
        (yytype_uint8 const   )(unsigned char)20,      (yytype_uint8 const   )(unsigned char)9,      (yytype_uint8 const   )(unsigned char)0,      (yytype_uint8 const   )(unsigned char)34, 
        (yytype_uint8 const   )(unsigned char)33,      (yytype_uint8 const   )(unsigned char)22,      (yytype_uint8 const   )(unsigned char)23,      (yytype_uint8 const   )(unsigned char)21, 
        (yytype_uint8 const   )(unsigned char)8,      (yytype_uint8 const   )(unsigned char)0,      (yytype_uint8 const   )(unsigned char)24,      (yytype_uint8 const   )(unsigned char)30, 
        (yytype_uint8 const   )(unsigned char)0,      (yytype_uint8 const   )(unsigned char)46,      (yytype_uint8 const   )(unsigned char)0,      (yytype_uint8 const   )(unsigned char)48, 
        (yytype_uint8 const   )(unsigned char)49,      (yytype_uint8 const   )(unsigned char)50,      (yytype_uint8 const   )(unsigned char)51,      (yytype_uint8 const   )(unsigned char)52, 
        (yytype_uint8 const   )(unsigned char)0,      (yytype_uint8 const   )(unsigned char)39,      (yytype_uint8 const   )(unsigned char)44,      (yytype_uint8 const   )(unsigned char)45, 
        (yytype_uint8 const   )(unsigned char)25,      (yytype_uint8 const   )(unsigned char)0,      (yytype_uint8 const   )(unsigned char)26,      (yytype_uint8 const   )(unsigned char)27, 
        (yytype_uint8 const   )(unsigned char)29,      (yytype_uint8 const   )(unsigned char)31,      (yytype_uint8 const   )(unsigned char)47,      (yytype_uint8 const   )(unsigned char)0, 
        (yytype_uint8 const   )(unsigned char)43,      (yytype_uint8 const   )(unsigned char)41,      (yytype_uint8 const   )(unsigned char)28,      (yytype_uint8 const   )(unsigned char)0, 
        (yytype_uint8 const   )(unsigned char)0,      (yytype_uint8 const   )(unsigned char)40,      (yytype_uint8 const   )(unsigned char)37,      (yytype_uint8 const   )(unsigned char)38, 
        (yytype_uint8 const   )(unsigned char)32,      (yytype_uint8 const   )(unsigned char)42,      (yytype_uint8 const   )(unsigned char)0,      (yytype_uint8 const   )(unsigned char)35, 
        (yytype_uint8 const   )(unsigned char)0,      (yytype_uint8 const   )(unsigned char)36};
#line 630 "master_parse.tab.c"
static yytype_int8 const   yydefgoto[12]  = 
#line 630
  {      (yytype_int8 const   )(signed char)-1,      (yytype_int8 const   )(signed char)1,      (yytype_int8 const   )(signed char)2,      (yytype_int8 const   )(signed char)9, 
        (yytype_int8 const   )(signed char)25,      (yytype_int8 const   )(signed char)43,      (yytype_int8 const   )(signed char)26,      (yytype_int8 const   )(signed char)56, 
        (yytype_int8 const   )(signed char)36,      (yytype_int8 const   )(signed char)37,      (yytype_int8 const   )(signed char)38,      (yytype_int8 const   )(signed char)39};
#line 639 "master_parse.tab.c"
static yytype_int8 const   yypact[62]  = 
#line 639
  {      (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)10,      (yytype_int8 const   )(signed char)32,      (yytype_int8 const   )(signed char)-26, 
        (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)44,      (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)-26, 
        (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)-26, 
        (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)-26, 
        (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)2,      (yytype_int8 const   )(signed char)-2, 
        (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)-26, 
        (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)13,      (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)59, 
        (yytype_int8 const   )(signed char)11,      (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)9,      (yytype_int8 const   )(signed char)-26, 
        (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)-26, 
        (yytype_int8 const   )(signed char)0,      (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)-26, 
        (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)-17,      (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)-26, 
        (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)26,      (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)22, 
        (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)4, 
        (yytype_int8 const   )(signed char)35,      (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)21,      (yytype_int8 const   )(signed char)-26, 
        (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)34,      (yytype_int8 const   )(signed char)45, 
        (yytype_int8 const   )(signed char)4,      (yytype_int8 const   )(signed char)-26};
#line 651 "master_parse.tab.c"
static yytype_int8 const   yypgoto[12]  = 
#line 651
  {      (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)-26, 
        (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)-25,      (yytype_int8 const   )(signed char)3, 
        (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)24,      (yytype_int8 const   )(signed char)-26,      (yytype_int8 const   )(signed char)-26};
#line 662 "master_parse.tab.c"
static yytype_int8 const   yytable[84]  = 
#line 662
  {      (yytype_int8 const   )(signed char)-6,      (yytype_int8 const   )(signed char)29,      (yytype_int8 const   )(signed char)44,      (yytype_int8 const   )(signed char)19, 
        (yytype_int8 const   )(signed char)20,      (yytype_int8 const   )(signed char)30,      (yytype_int8 const   )(signed char)31,      (yytype_int8 const   )(signed char)32, 
        (yytype_int8 const   )(signed char)33,      (yytype_int8 const   )(signed char)34,      (yytype_int8 const   )(signed char)3,      (yytype_int8 const   )(signed char)47, 
        (yytype_int8 const   )(signed char)27,      (yytype_int8 const   )(signed char)-5,      (yytype_int8 const   )(signed char)29,      (yytype_int8 const   )(signed char)28, 
        (yytype_int8 const   )(signed char)50,      (yytype_int8 const   )(signed char)48,      (yytype_int8 const   )(signed char)30,      (yytype_int8 const   )(signed char)31, 
        (yytype_int8 const   )(signed char)32,      (yytype_int8 const   )(signed char)33,      (yytype_int8 const   )(signed char)34,      (yytype_int8 const   )(signed char)29, 
        (yytype_int8 const   )(signed char)54,      (yytype_int8 const   )(signed char)55,      (yytype_int8 const   )(signed char)35,      (yytype_int8 const   )(signed char)30, 
        (yytype_int8 const   )(signed char)31,      (yytype_int8 const   )(signed char)32,      (yytype_int8 const   )(signed char)33,      (yytype_int8 const   )(signed char)34, 
        (yytype_int8 const   )(signed char)45,      (yytype_int8 const   )(signed char)52,      (yytype_int8 const   )(signed char)46,      (yytype_int8 const   )(signed char)4, 
        (yytype_int8 const   )(signed char)29,      (yytype_int8 const   )(signed char)51,      (yytype_int8 const   )(signed char)58,      (yytype_int8 const   )(signed char)35, 
        (yytype_int8 const   )(signed char)30,      (yytype_int8 const   )(signed char)31,      (yytype_int8 const   )(signed char)32,      (yytype_int8 const   )(signed char)33, 
        (yytype_int8 const   )(signed char)34,      (yytype_int8 const   )(signed char)5,      (yytype_int8 const   )(signed char)6,      (yytype_int8 const   )(signed char)7, 
        (yytype_int8 const   )(signed char)35,      (yytype_int8 const   )(signed char)10,      (yytype_int8 const   )(signed char)11,      (yytype_int8 const   )(signed char)12, 
        (yytype_int8 const   )(signed char)13,      (yytype_int8 const   )(signed char)14,      (yytype_int8 const   )(signed char)15,      (yytype_int8 const   )(signed char)59, 
        (yytype_int8 const   )(signed char)60,      (yytype_int8 const   )(signed char)16,      (yytype_int8 const   )(signed char)8,      (yytype_int8 const   )(signed char)17, 
        (yytype_int8 const   )(signed char)49,      (yytype_int8 const   )(signed char)35,      (yytype_int8 const   )(signed char)18,      (yytype_int8 const   )(signed char)61, 
        (yytype_int8 const   )(signed char)19,      (yytype_int8 const   )(signed char)20,      (yytype_int8 const   )(signed char)21,      (yytype_int8 const   )(signed char)22, 
        (yytype_int8 const   )(signed char)23,      (yytype_int8 const   )(signed char)0,      (yytype_int8 const   )(signed char)24,      (yytype_int8 const   )(signed char)53, 
        (yytype_int8 const   )(signed char)40,      (yytype_int8 const   )(signed char)0,      (yytype_int8 const   )(signed char)0,      (yytype_int8 const   )(signed char)0, 
        (yytype_int8 const   )(signed char)57,      (yytype_int8 const   )(signed char)0,      (yytype_int8 const   )(signed char)41,      (yytype_int8 const   )(signed char)19, 
        (yytype_int8 const   )(signed char)20,      (yytype_int8 const   )(signed char)0,      (yytype_int8 const   )(signed char)0,      (yytype_int8 const   )(signed char)42};
#line 675 "master_parse.tab.c"
static yytype_int8 const   yycheck[84]  = 
#line 675
  {      (yytype_int8 const   )(signed char)0,      (yytype_int8 const   )(signed char)1,      (yytype_int8 const   )(signed char)27,      (yytype_int8 const   )(signed char)20, 
        (yytype_int8 const   )(signed char)21,      (yytype_int8 const   )(signed char)5,      (yytype_int8 const   )(signed char)6,      (yytype_int8 const   )(signed char)7, 
        (yytype_int8 const   )(signed char)8,      (yytype_int8 const   )(signed char)9,      (yytype_int8 const   )(signed char)0,      (yytype_int8 const   )(signed char)11, 
        (yytype_int8 const   )(signed char)10,      (yytype_int8 const   )(signed char)0,      (yytype_int8 const   )(signed char)1,      (yytype_int8 const   )(signed char)17, 
        (yytype_int8 const   )(signed char)41,      (yytype_int8 const   )(signed char)17,      (yytype_int8 const   )(signed char)5,      (yytype_int8 const   )(signed char)6, 
        (yytype_int8 const   )(signed char)7,      (yytype_int8 const   )(signed char)8,      (yytype_int8 const   )(signed char)9,      (yytype_int8 const   )(signed char)1, 
        (yytype_int8 const   )(signed char)20,      (yytype_int8 const   )(signed char)21,      (yytype_int8 const   )(signed char)26,      (yytype_int8 const   )(signed char)5, 
        (yytype_int8 const   )(signed char)6,      (yytype_int8 const   )(signed char)7,      (yytype_int8 const   )(signed char)8,      (yytype_int8 const   )(signed char)9, 
        (yytype_int8 const   )(signed char)21,      (yytype_int8 const   )(signed char)11,      (yytype_int8 const   )(signed char)25,      (yytype_int8 const   )(signed char)3, 
        (yytype_int8 const   )(signed char)1,      (yytype_int8 const   )(signed char)11,      (yytype_int8 const   )(signed char)17,      (yytype_int8 const   )(signed char)26, 
        (yytype_int8 const   )(signed char)5,      (yytype_int8 const   )(signed char)6,      (yytype_int8 const   )(signed char)7,      (yytype_int8 const   )(signed char)8, 
        (yytype_int8 const   )(signed char)9,      (yytype_int8 const   )(signed char)13,      (yytype_int8 const   )(signed char)14,      (yytype_int8 const   )(signed char)15, 
        (yytype_int8 const   )(signed char)26,      (yytype_int8 const   )(signed char)5,      (yytype_int8 const   )(signed char)6,      (yytype_int8 const   )(signed char)7, 
        (yytype_int8 const   )(signed char)8,      (yytype_int8 const   )(signed char)9,      (yytype_int8 const   )(signed char)10,      (yytype_int8 const   )(signed char)21, 
        (yytype_int8 const   )(signed char)11,      (yytype_int8 const   )(signed char)13,      (yytype_int8 const   )(signed char)26,      (yytype_int8 const   )(signed char)15, 
        (yytype_int8 const   )(signed char)36,      (yytype_int8 const   )(signed char)26,      (yytype_int8 const   )(signed char)18,      (yytype_int8 const   )(signed char)60, 
        (yytype_int8 const   )(signed char)20,      (yytype_int8 const   )(signed char)21,      (yytype_int8 const   )(signed char)22,      (yytype_int8 const   )(signed char)23, 
        (yytype_int8 const   )(signed char)24,      (yytype_int8 const   )(signed char)-1,      (yytype_int8 const   )(signed char)26,      (yytype_int8 const   )(signed char)47, 
        (yytype_int8 const   )(signed char)13,      (yytype_int8 const   )(signed char)-1,      (yytype_int8 const   )(signed char)-1,      (yytype_int8 const   )(signed char)-1, 
        (yytype_int8 const   )(signed char)52,      (yytype_int8 const   )(signed char)-1,      (yytype_int8 const   )(signed char)19,      (yytype_int8 const   )(signed char)20, 
        (yytype_int8 const   )(signed char)21,      (yytype_int8 const   )(signed char)-1,      (yytype_int8 const   )(signed char)-1,      (yytype_int8 const   )(signed char)24};
#line 690 "master_parse.tab.c"
static yytype_uint8 const   yystos[62]  = 
#line 690
  {      (yytype_uint8 const   )(unsigned char)0,      (yytype_uint8 const   )(unsigned char)28,      (yytype_uint8 const   )(unsigned char)29,      (yytype_uint8 const   )(unsigned char)0, 
        (yytype_uint8 const   )(unsigned char)3,      (yytype_uint8 const   )(unsigned char)13,      (yytype_uint8 const   )(unsigned char)14,      (yytype_uint8 const   )(unsigned char)15, 
        (yytype_uint8 const   )(unsigned char)26,      (yytype_uint8 const   )(unsigned char)30,      (yytype_uint8 const   )(unsigned char)5,      (yytype_uint8 const   )(unsigned char)6, 
        (yytype_uint8 const   )(unsigned char)7,      (yytype_uint8 const   )(unsigned char)8,      (yytype_uint8 const   )(unsigned char)9,      (yytype_uint8 const   )(unsigned char)10, 
        (yytype_uint8 const   )(unsigned char)13,      (yytype_uint8 const   )(unsigned char)15,      (yytype_uint8 const   )(unsigned char)18,      (yytype_uint8 const   )(unsigned char)20, 
        (yytype_uint8 const   )(unsigned char)21,      (yytype_uint8 const   )(unsigned char)22,      (yytype_uint8 const   )(unsigned char)23,      (yytype_uint8 const   )(unsigned char)24, 
        (yytype_uint8 const   )(unsigned char)26,      (yytype_uint8 const   )(unsigned char)31,      (yytype_uint8 const   )(unsigned char)33,      (yytype_uint8 const   )(unsigned char)10, 
        (yytype_uint8 const   )(unsigned char)17,      (yytype_uint8 const   )(unsigned char)1,      (yytype_uint8 const   )(unsigned char)5,      (yytype_uint8 const   )(unsigned char)6, 
        (yytype_uint8 const   )(unsigned char)7,      (yytype_uint8 const   )(unsigned char)8,      (yytype_uint8 const   )(unsigned char)9,      (yytype_uint8 const   )(unsigned char)26, 
        (yytype_uint8 const   )(unsigned char)35,      (yytype_uint8 const   )(unsigned char)36,      (yytype_uint8 const   )(unsigned char)37,      (yytype_uint8 const   )(unsigned char)38, 
        (yytype_uint8 const   )(unsigned char)13,      (yytype_uint8 const   )(unsigned char)19,      (yytype_uint8 const   )(unsigned char)24,      (yytype_uint8 const   )(unsigned char)32, 
        (yytype_uint8 const   )(unsigned char)33,      (yytype_uint8 const   )(unsigned char)21,      (yytype_uint8 const   )(unsigned char)25,      (yytype_uint8 const   )(unsigned char)11, 
        (yytype_uint8 const   )(unsigned char)17,      (yytype_uint8 const   )(unsigned char)36,      (yytype_uint8 const   )(unsigned char)33,      (yytype_uint8 const   )(unsigned char)11, 
        (yytype_uint8 const   )(unsigned char)11,      (yytype_uint8 const   )(unsigned char)36,      (yytype_uint8 const   )(unsigned char)20,      (yytype_uint8 const   )(unsigned char)21, 
        (yytype_uint8 const   )(unsigned char)34,      (yytype_uint8 const   )(unsigned char)36,      (yytype_uint8 const   )(unsigned char)17,      (yytype_uint8 const   )(unsigned char)21, 
        (yytype_uint8 const   )(unsigned char)11,      (yytype_uint8 const   )(unsigned char)34};
#line 1188 "master_parse.tab.c"
static void yydestruct(char const   *yymsg , int yytype , YYSTYPE *yyvaluep ) 
{ 

  {
#line 1200
  if (! yymsg) {
#line 1201
    yymsg = "Deleting";
  }
#line 1204
  switch (yytype) {
  default: ;
#line 1208
  break;
  }
#line 1210
  return;
}
}
#line 1223
int master_parse(void) ;
#line 1232 "master_parse.tab.c"
int master_char  ;
#line 1235 "master_parse.tab.c"
YYSTYPE master_lval  ;
#line 1238 "master_parse.tab.c"
int master_nerrs  ;
#line 1259 "master_parse.tab.c"
int master_parse(void) 
{ int yystate ;
  int yyn ;
  int yyresult ;
  int yyerrstatus ;
  int yytoken ;
  yytype_int16 yyssa[200] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE yyvsa[200] ;
  YYSTYPE *yyvs ;
  YYSTYPE *yyvsp ;
  unsigned int yystacksize ;
  YYSTYPE yyval ;
  int yylen ;
  unsigned int yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc *yyptr ;
  union yyalloc *tmp ;
  unsigned int yynewbytes ;
  unsigned int yynewbytes___0 ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;

  {
#line 1275
  yytoken = 0;
#line 1293
  yyss = yyssa;
#line 1298
  yyvs = yyvsa;
#line 1305
  yystacksize = 200U;
#line 1314
  yylen = 0;
#line 1318
  yystate = 0;
#line 1319
  yyerrstatus = 0;
#line 1320
  master_nerrs = 0;
#line 1321
  master_char = -2;
#line 1328
  yyssp = yyss;
#line 1329
  yyvsp = yyvs;
  goto yysetstate;
  yynewstate: 
#line 1339
  yyssp ++;
  yysetstate: 
#line 1342
  (*yyssp) = (short )yystate;
#line 1344
  if ((unsigned int )((yyss + yystacksize) - 1) <= (unsigned int )yyssp) {
#line 1347
    yysize = (unsigned int )((yyssp - yyss) + 1);
#line 1376
    if (10000U <= yystacksize) {
      goto yyexhaustedlab;
    }
#line 1378
    yystacksize *= 2U;
#line 1379
    if (10000U < yystacksize) {
#line 1380
      yystacksize = 10000U;
    }
#line 1383
    yyss1 = yyss;
#line 1384
    tmp = (union yyalloc *)malloc(yystacksize * (sizeof(yytype_int16 ) + sizeof(YYSTYPE )) + (sizeof(union yyalloc ) - 1U));
#line 1384
    yyptr = tmp;
#line 1386
    if (! yyptr) {
      goto yyexhaustedlab;
    }
#line 1388
    while (1) {
#line 1388
      __builtin_memcpy((void *)(& yyptr->yyss), (void const   *)yyss, yysize * sizeof((*yyss)));
#line 1388
      yyss = & yyptr->yyss;
#line 1388
      yynewbytes = yystacksize * sizeof((*yyss)) + (sizeof(union yyalloc ) - 1U);
#line 1388
      yyptr += yynewbytes / sizeof((*yyptr));
#line 1388
      break;
    }
#line 1389
    while (1) {
#line 1389
      __builtin_memcpy((void *)(& yyptr->yyvs), (void const   *)yyvs, yysize * sizeof((*yyvs)));
#line 1389
      yyvs = & yyptr->yyvs;
#line 1389
      yynewbytes___0 = yystacksize * sizeof((*yyvs)) + (sizeof(union yyalloc ) - 1U);
#line 1389
      yyptr += yynewbytes___0 / sizeof((*yyptr));
#line 1389
      break;
    }
#line 1392
    if ((unsigned int )yyss1 != (unsigned int )(yyssa)) {
#line 1393
      free((void *)yyss1);
    }
#line 1398
    yyssp = (yyss + yysize) - 1;
#line 1399
    yyvsp = (yyvs + yysize) - 1;
#line 1405
    if ((unsigned int )((yyss + yystacksize) - 1) <= (unsigned int )yyssp) {
      goto yyabortlab;
    }
  }
  goto yybackup;
  yybackup: 
#line 1422
  yyn = (int )yypact[yystate];
#line 1423
  if (yyn == -26) {
    goto yydefault;
  }
#line 1429
  if (master_char == -2) {
#line 1432
    master_char = master_lex();
  }
#line 1435
  if (master_char <= 0) {
#line 1437
    yytoken = 0;
#line 1437
    master_char = yytoken;
  } else {
#line 1442
    if ((unsigned int )master_char <= 281U) {
#line 1442
      yytoken = (int )yytranslate[master_char];
    } else {
#line 1442
      yytoken = 2;
    }
  }
#line 1448
  yyn += yytoken;
#line 1449
  if (yyn < 0) {
    goto yydefault;
  } else {
#line 1449
    if (83 < yyn) {
      goto yydefault;
    } else {
#line 1449
      if ((int const   )yycheck[yyn] != (int const   )yytoken) {
        goto yydefault;
      }
    }
  }
#line 1451
  yyn = (int )yytable[yyn];
#line 1452
  if (yyn <= 0) {
#line 1454
    if (yyn == 0) {
      goto yyerrlab;
    } else {
#line 1454
      if (yyn == -7) {
        goto yyerrlab;
      }
    }
#line 1456
    yyn = - yyn;
    goto yyreduce;
  }
#line 1460
  if (yyn == 3) {
    goto yyacceptlab;
  }
#line 1465
  if (yyerrstatus) {
#line 1466
    yyerrstatus --;
  }
#line 1472
  if (master_char != 0) {
#line 1473
    master_char = -2;
  }
#line 1475
  yystate = yyn;
#line 1476
  yyvsp ++;
#line 1476
  (*yyvsp) = master_lval;
  goto yynewstate;
  yydefault: 
#line 1485
  yyn = (int )yydefact[yystate];
#line 1486
  if (yyn == 0) {
    goto yyerrlab;
  }
  goto yyreduce;
  yyreduce: 
#line 1496
  yylen = (int )yyr2[yyn];
#line 1506
  yyval = (*(yyvsp + (1 - yylen)));
#line 1510
  switch (yyn) {
  case 2: 
#line 121 "master_parse.y"
  master_lineno = 0;
#line 126
  break;
  case 5: 
#line 131
  path = master_strdup((yyvsp + -1)->strtype);
#line 132
  if (! path) {
#line 133
    local_free_vars();
    goto yyabortlab;
  }
#line 137
  break;
  case 6: 
#line 139
  path = master_strdup((yyvsp + -2)->strtype);
#line 140
  if (! path) {
#line 141
    local_free_vars();
    goto yyabortlab;
  }
#line 145
  break;
  case 7: 
#line 145
  master_notify((char const   *)((yyvsp + -1)->strtype));
  goto yyabortlab;
#line 146
  break;
  case 8: 
#line 146
  master_notify((char const   *)((yyvsp + 0)->strtype));
  goto yyabortlab;
#line 147
  break;
  case 9: 
#line 147
  master_notify((char const   *)((yyvsp + 0)->strtype));
  goto yyabortlab;
#line 148
  break;
  case 10: 
#line 148
  master_notify((char const   *)((yyvsp + -1)->strtype));
  goto yyabortlab;
#line 149
  break;
  case 11: 
#line 149
  master_notify((char const   *)((yyvsp + -1)->strtype));
  goto yyabortlab;
#line 150
  break;
  case 12: 
#line 150
  master_notify((char const   *)((yyvsp + -1)->strtype));
  goto yyabortlab;
#line 151
  break;
  case 13: 
#line 151
  master_notify((char const   *)((yyvsp + -1)->strtype));
  goto yyabortlab;
#line 152
  break;
  case 14: 
#line 152
  master_notify((char const   *)((yyvsp + -1)->strtype));
  goto yyabortlab;
#line 153
  break;
  case 15: 
#line 153
  master_notify((char const   *)((yyvsp + 0)->strtype));
  goto yyabortlab;
#line 154
  break;
  case 16: 
#line 154
  master_notify((char const   *)((yyvsp + 0)->strtype));
  goto yyabortlab;
#line 155
  break;
  case 17: 
#line 155
  master_notify((char const   *)((yyvsp + 0)->strtype));
  goto yyabortlab;
#line 156
  break;
  case 18: 
#line 156
  master_notify((char const   *)((yyvsp + 0)->strtype));
  goto yyabortlab;
#line 157
  break;
  case 19: 
  goto yyabortlab;
#line 158
  break;
  case 20: 
#line 162
  local_argc ++;
#line 163
  local_argv = add_argv(local_argc, local_argv, (yyvsp + 0)->strtype);
#line 164
  if (! local_argv) {
#line 165
    master_error("memory allocation error");
#line 166
    local_free_vars();
    goto yyabortlab;
  }
#line 170
  break;
  case 21: 
#line 172
  local_argc ++;
#line 173
  local_argv = add_argv(local_argc, local_argv, (yyvsp + 0)->strtype);
#line 174
  if (! local_argv) {
#line 175
    master_error("memory allocation error");
#line 176
    local_free_vars();
    goto yyabortlab;
  }
#line 180
  break;
  case 22: 
#line 182
  type = master_strdup((yyvsp + 0)->strtype + 1);
#line 183
  if (! type) {
#line 184
    local_free_vars();
    goto yyabortlab;
  }
#line 188
  break;
  case 23: 
#line 190
  type = master_strdup((yyvsp + 0)->strtype + 1);
#line 191
  if (! type) {
#line 192
    local_free_vars();
    goto yyabortlab;
  }
#line 196
  break;
  case 24: 
#line 198
  type = master_strdup((char *)"ldap");
#line 199
  if (! type) {
#line 200
    local_free_vars();
    goto yyabortlab;
  }
#line 203
  local_argc ++;
#line 204
  local_argv = add_argv(local_argc, local_argv, (yyvsp + 0)->strtype);
#line 205
  if (! local_argv) {
#line 206
    master_error("memory allocation error");
#line 207
    local_free_vars();
    goto yyabortlab;
  }
#line 211
  break;
  case 25: 
#line 213
  tmp___0 = (char *)((void *)0);
#line 215
  tmp___3 = __builtin_strchr((yyvsp + -2)->strtype, (char )',');
#line 215
  tmp___0 = tmp___3;
#line 215
  if (tmp___0) {
#line 216
    tmp___1 = tmp___0;
#line 216
    tmp___0 ++;
#line 216
    (*tmp___1) = (char )'\000';
  }
#line 218
  type = master_strdup((yyvsp + -2)->strtype);
#line 219
  if (! type) {
#line 220
    local_free_vars();
    goto yyabortlab;
  }
#line 223
  if (tmp___0) {
#line 224
    format = master_strdup(tmp___0);
#line 225
    if (! format) {
#line 226
      local_free_vars();
      goto yyabortlab;
    }
  }
#line 230
  local_argc ++;
#line 231
  local_argv = add_argv(local_argc, local_argv, (yyvsp + 0)->strtype);
#line 232
  if (! local_argv) {
#line 233
    master_error("memory allocation error");
#line 234
    local_free_vars();
    goto yyabortlab;
  }
#line 238
  break;
  case 26: 
#line 240
  tmp___4 = (char *)((void *)0);
#line 242
  tmp___7 = __builtin_strchr((yyvsp + -2)->strtype, (char )',');
#line 242
  tmp___4 = tmp___7;
#line 242
  if (tmp___4) {
#line 243
    tmp___5 = tmp___4;
#line 243
    tmp___4 ++;
#line 243
    (*tmp___5) = (char )'\000';
  }
#line 245
  type = master_strdup((yyvsp + -2)->strtype);
#line 246
  if (! type) {
#line 247
    local_free_vars();
    goto yyabortlab;
  }
#line 250
  if (tmp___4) {
#line 251
    format = master_strdup(tmp___4);
#line 252
    if (! format) {
#line 253
      local_free_vars();
      goto yyabortlab;
    }
  }
#line 257
  local_argc ++;
#line 258
  local_argv = add_argv(local_argc, local_argv, (yyvsp + 0)->strtype);
#line 259
  if (! local_argv) {
#line 260
    master_error("memory allocation error");
#line 261
    local_free_vars();
    goto yyabortlab;
  }
#line 265
  break;
  case 27: 
#line 267
  tmp___8 = (char *)((void *)0);
#line 269
  tmp___11 = __builtin_strchr((yyvsp + -2)->strtype, (char )',');
#line 269
  tmp___8 = tmp___11;
#line 269
  if (tmp___8) {
#line 270
    tmp___9 = tmp___8;
#line 270
    tmp___8 ++;
#line 270
    (*tmp___9) = (char )'\000';
  }
#line 272
  type = master_strdup((yyvsp + -2)->strtype);
#line 273
  if (! type) {
#line 274
    local_free_vars();
    goto yyabortlab;
  }
#line 277
  if (tmp___8) {
#line 278
    format = master_strdup(tmp___8);
#line 279
    if (! format) {
#line 280
      local_free_vars();
      goto yyabortlab;
    }
  }
#line 284
  local_argc ++;
#line 285
  local_argv = add_argv(local_argc, local_argv, (yyvsp + 0)->strtype);
#line 286
  if (! local_argv) {
#line 287
    master_error("memory allocation error");
#line 288
    local_free_vars();
    goto yyabortlab;
  }
#line 292
  if ((*((*(local_argv + 0))))) {
#line 293
    tmp___12 = strlen((char const   *)type);
#line 293
    tmp___13 = strlen((char const   *)(*(local_argv + 0)));
#line 293
    tmp___8 = (char *)malloc((tmp___12 + tmp___13) + 2U);
#line 294
    if (! tmp___8) {
#line 295
      local_free_vars();
      goto yyabortlab;
    }
#line 298
    strcpy((char * __restrict  )tmp___8, (char const   * __restrict  )type);
#line 299
    strcat((char * __restrict  )tmp___8, (char const   * __restrict  )":");
#line 300
    strcat((char * __restrict  )tmp___8, (char const   * __restrict  )(*(local_argv + 0)));
#line 301
    free((void *)(*(local_argv + 0)));
#line 302
    (*(local_argv + 0)) = tmp___8;
  }
#line 305
  break;
  case 28: 
#line 309
  strcpy((char * __restrict  )(yyval.strtype), (char const   * __restrict  )((yyvsp + -1)->strtype));
#line 310
  strcat((char * __restrict  )(yyval.strtype), (char const   * __restrict  )((yyvsp + 0)->strtype));
#line 312
  break;
  case 29: 
#line 314
  strcpy((char * __restrict  )(yyval.strtype), (char const   * __restrict  )((yyvsp + 0)->strtype));
#line 316
  break;
  case 30: 
#line 318
  master_notify("syntax error in dn");
  goto yyabortlab;
#line 321
  break;
  case 31: 
#line 325
  tmp___14 = strcasecmp((char const   *)((yyvsp + -2)->strtype), "cn");
#line 325
  if (tmp___14) {
#line 325
    tmp___15 = strcasecmp((char const   *)((yyvsp + -2)->strtype), "ou");
#line 325
    if (tmp___15) {
#line 325
      tmp___16 = strcasecmp((char const   *)((yyvsp + -2)->strtype), "automountMapName");
#line 325
      if (tmp___16) {
#line 325
        tmp___17 = strcasecmp((char const   *)((yyvsp + -2)->strtype), "nisMapName");
#line 325
        if (tmp___17) {
#line 329
          strcpy((char * __restrict  )(errstr), (char const   * __restrict  )((yyvsp + -2)->strtype));
#line 330
          strcat((char * __restrict  )(errstr), (char const   * __restrict  )"=");
#line 331
          strcat((char * __restrict  )(errstr), (char const   * __restrict  )((yyvsp + 0)->strtype));
#line 332
          master_notify((char const   *)(errstr));
          goto yyabortlab;
        }
      }
    }
  }
#line 335
  strcpy((char * __restrict  )(yyval.strtype), (char const   * __restrict  )((yyvsp + -2)->strtype));
#line 336
  strcat((char * __restrict  )(yyval.strtype), (char const   * __restrict  )"=");
#line 337
  strcat((char * __restrict  )(yyval.strtype), (char const   * __restrict  )((yyvsp + 0)->strtype));
#line 339
  break;
  case 32: 
#line 341
  tmp___18 = strcasecmp((char const   *)((yyvsp + -4)->strtype), "cn");
#line 341
  if (tmp___18) {
#line 341
    tmp___19 = strcasecmp((char const   *)((yyvsp + -4)->strtype), "ou");
#line 341
    if (tmp___19) {
#line 341
      tmp___20 = strcasecmp((char const   *)((yyvsp + -4)->strtype), "automountMapName");
#line 341
      if (tmp___20) {
#line 341
        tmp___21 = strcasecmp((char const   *)((yyvsp + -4)->strtype), "nisMapName");
#line 341
        if (tmp___21) {
#line 345
          strcpy((char * __restrict  )(errstr), (char const   * __restrict  )((yyvsp + -4)->strtype));
#line 346
          strcat((char * __restrict  )(errstr), (char const   * __restrict  )"=");
#line 347
          strcat((char * __restrict  )(errstr), (char const   * __restrict  )((yyvsp + -2)->strtype));
#line 348
          master_notify((char const   *)(errstr));
          goto yyabortlab;
        }
      }
    }
  }
#line 351
  strcpy((char * __restrict  )(yyval.strtype), (char const   * __restrict  )((yyvsp + -4)->strtype));
#line 352
  strcat((char * __restrict  )(yyval.strtype), (char const   * __restrict  )"=");
#line 353
  strcat((char * __restrict  )(yyval.strtype), (char const   * __restrict  )((yyvsp + -2)->strtype));
#line 354
  strcat((char * __restrict  )(yyval.strtype), (char const   * __restrict  )",");
#line 355
  strcat((char * __restrict  )(yyval.strtype), (char const   * __restrict  )((yyvsp + 0)->strtype));
#line 357
  break;
  case 33: 
#line 360
  strcpy((char * __restrict  )(yyval.strtype), (char const   * __restrict  )((yyvsp + 0)->strtype));
#line 362
  break;
  case 34: 
#line 364
  master_notify((char const   *)((yyvsp + 0)->strtype));
  goto yyabortlab;
#line 367
  break;
  case 35: 
#line 371
  tmp___22 = strcasecmp((char const   *)((yyvsp + -2)->strtype), "automountMapName");
#line 371
  if (tmp___22) {
#line 371
    tmp___23 = strcasecmp((char const   *)((yyvsp + -2)->strtype), "nisMapName");
#line 371
    if (! tmp___23) {
#line 373
      strcpy((char * __restrict  )(errstr), (char const   * __restrict  )((yyvsp + -2)->strtype));
#line 374
      strcat((char * __restrict  )(errstr), (char const   * __restrict  )"=");
#line 375
      strcat((char * __restrict  )(errstr), (char const   * __restrict  )((yyvsp + 0)->strtype));
#line 376
      master_notify((char const   *)(errstr));
      goto yyabortlab;
    }
  } else {
#line 373
    strcpy((char * __restrict  )(errstr), (char const   * __restrict  )((yyvsp + -2)->strtype));
#line 374
    strcat((char * __restrict  )(errstr), (char const   * __restrict  )"=");
#line 375
    strcat((char * __restrict  )(errstr), (char const   * __restrict  )((yyvsp + 0)->strtype));
#line 376
    master_notify((char const   *)(errstr));
    goto yyabortlab;
  }
#line 379
  strcpy((char * __restrict  )(yyval.strtype), (char const   * __restrict  )((yyvsp + -2)->strtype));
#line 380
  strcat((char * __restrict  )(yyval.strtype), (char const   * __restrict  )"=");
#line 381
  strcat((char * __restrict  )(yyval.strtype), (char const   * __restrict  )((yyvsp + 0)->strtype));
#line 383
  break;
  case 36: 
#line 385
  tmp___24 = strcasecmp((char const   *)((yyvsp + -4)->strtype), "automountMapName");
#line 385
  if (tmp___24) {
#line 385
    tmp___25 = strcasecmp((char const   *)((yyvsp + -4)->strtype), "nisMapName");
#line 385
    if (! tmp___25) {
#line 387
      strcpy((char * __restrict  )(errstr), (char const   * __restrict  )((yyvsp + -4)->strtype));
#line 388
      strcat((char * __restrict  )(errstr), (char const   * __restrict  )"=");
#line 389
      strcat((char * __restrict  )(errstr), (char const   * __restrict  )((yyvsp + -2)->strtype));
#line 390
      master_notify((char const   *)(errstr));
      goto yyabortlab;
    }
  } else {
#line 387
    strcpy((char * __restrict  )(errstr), (char const   * __restrict  )((yyvsp + -4)->strtype));
#line 388
    strcat((char * __restrict  )(errstr), (char const   * __restrict  )"=");
#line 389
    strcat((char * __restrict  )(errstr), (char const   * __restrict  )((yyvsp + -2)->strtype));
#line 390
    master_notify((char const   *)(errstr));
    goto yyabortlab;
  }
#line 393
  strcpy((char * __restrict  )(yyval.strtype), (char const   * __restrict  )((yyvsp + -4)->strtype));
#line 394
  strcat((char * __restrict  )(yyval.strtype), (char const   * __restrict  )"=");
#line 395
  strcat((char * __restrict  )(yyval.strtype), (char const   * __restrict  )((yyvsp + -2)->strtype));
#line 396
  strcat((char * __restrict  )(yyval.strtype), (char const   * __restrict  )",");
#line 397
  strcat((char * __restrict  )(yyval.strtype), (char const   * __restrict  )((yyvsp + 0)->strtype));
#line 399
  break;
  case 37: 
#line 401
  master_notify((char const   *)((yyvsp + 0)->strtype));
  goto yyabortlab;
#line 404
  break;
  case 38: 
#line 406
  master_notify((char const   *)((yyvsp + 0)->strtype));
  goto yyabortlab;
#line 409
  break;
  case 39: ;
#line 412
  break;
  case 40: ;
#line 413
  break;
  case 41: ;
#line 414
  break;
  case 42: 
#line 416
  master_notify((char const   *)((yyvsp + -3)->strtype));
  goto yyabortlab;
#line 419
  break;
  case 43: 
#line 421
  master_notify((char const   *)((yyvsp + -1)->strtype));
  goto yyabortlab;
#line 424
  break;
  case 45: ;
#line 428
  break;
  case 46: 
#line 430
  master_notify("bogus option");
  goto yyabortlab;
#line 433
  break;
  case 47: 
#line 435
  timeout = (long )(yyvsp + 0)->inttype;
#line 436
  break;
  case 48: 
#line 436
  ghost = 0U;
#line 437
  break;
  case 49: 
#line 437
  ghost = 1U;
#line 438
  break;
  case 50: 
#line 438
  verbose = 1U;
#line 439
  break;
  case 51: 
#line 439
  debug = 1U;
#line 440
  break;
  case 52: 
#line 444
  local_argc ++;
#line 445
  local_argv = add_argv(local_argc, local_argv, (yyvsp + 0)->strtype);
#line 446
  if (! local_argv) {
#line 447
    master_error("memory allocation error");
#line 448
    local_free_vars();
    goto yyabortlab;
  }
#line 452
  break;
  default: ;
#line 1994 "master_parse.tab.c"
  break;
  }
#line 1998
  yyvsp -= yylen;
#line 1998
  yyssp -= yylen;
#line 1999
  yylen = 0;
#line 2002
  yyvsp ++;
#line 2002
  (*yyvsp) = yyval;
#line 2009
  yyn = (int )yyr1[yyn];
#line 2011
  yystate = (int )((int const   )yypgoto[yyn - 27] + (int const   )(*yyssp));
#line 2012
  if (0 <= yystate) {
#line 2012
    if (yystate <= 83) {
#line 2012
      if ((int const   )yycheck[yystate] == (int const   )(*yyssp)) {
#line 2013
        yystate = (int )yytable[yystate];
      } else {
#line 2015
        yystate = (int )yydefgoto[yyn - 27];
      }
    } else {
#line 2015
      yystate = (int )yydefgoto[yyn - 27];
    }
  } else {
#line 2015
    yystate = (int )yydefgoto[yyn - 27];
  }
  goto yynewstate;
  yyerrlab: 
#line 2025
  if (! yyerrstatus) {
#line 2027
    master_nerrs ++;
#line 2029
    master_error("syntax error");
  }
#line 2067
  if (yyerrstatus == 3) {
#line 2072
    if (master_char <= 0) {
#line 2075
      if (master_char == 0) {
        goto yyabortlab;
      }
    } else {
#line 2080
      yydestruct("Error: discarding", yytoken, & master_lval);
#line 2082
      master_char = -2;
    }
  }
  goto yyerrlab1;
#line 2104
  yyvsp -= yylen;
#line 2104
  yyssp -= yylen;
#line 2105
  yylen = 0;
#line 2107
  yystate = (int )(*yyssp);
  goto yyerrlab1;
  yyerrlab1: 
#line 2115
  yyerrstatus = 3;
#line 2117
  while (1) {
#line 2119
    yyn = (int )yypact[yystate];
#line 2120
    if (yyn != -26) {
#line 2122
      yyn ++;
#line 2123
      if (0 <= yyn) {
#line 2123
        if (yyn <= 83) {
#line 2123
          if ((int const   )yycheck[yyn] == 1) {
#line 2125
            yyn = (int )yytable[yyn];
#line 2126
            if (0 < yyn) {
#line 2127
              break;
            }
          }
        }
      }
    }
#line 2132
    if ((unsigned int )yyssp == (unsigned int )yyss) {
      goto yyabortlab;
    }
#line 2136
    yydestruct("Error: popping", (int )yystos[yystate], yyvsp);
#line 2138
    yyvsp --;
#line 2138
    yyssp --;
#line 2139
    yystate = (int )(*yyssp);
  }
#line 2143
  if (yyn == 3) {
    goto yyacceptlab;
  }
#line 2146
  yyvsp ++;
#line 2146
  (*yyvsp) = master_lval;
#line 2152
  yystate = yyn;
  goto yynewstate;
  yyacceptlab: 
#line 2160
  yyresult = 0;
  goto yyreturn;
  yyabortlab: 
#line 2167
  yyresult = 1;
  goto yyreturn;
  yyexhaustedlab: 
#line 2175
  master_error("memory exhausted");
#line 2176
  yyresult = 2;
  yyreturn: 
#line 2181
  if (master_char != 0) {
#line 2181
    if (master_char != -2) {
#line 2182
      yydestruct("Cleanup: discarding lookahead", yytoken, & master_lval);
    }
  }
#line 2186
  yyvsp -= yylen;
#line 2186
  yyssp -= yylen;
#line 2188
  while ((unsigned int )yyssp != (unsigned int )yyss) {
#line 2190
    yydestruct("Cleanup: popping", (int )yystos[(*yyssp)], yyvsp);
#line 2192
    yyvsp --;
#line 2192
    yyssp --;
  }
#line 2195
  if ((unsigned int )yyss != (unsigned int )(yyssa)) {
#line 2196
    free((void *)yyss);
  }
#line 2203
  return (yyresult);
}
}
#line 466 "master_parse.y"
static char *master_strdup(char *str ) 
{ char *tmp ;
  char *tmp___9 ;

  {
#line 470
  tmp___9 = __strdup((char const   *)str);
#line 470
  tmp = tmp___9;
#line 471
  if (! tmp) {
#line 472
    master_error("memory allocation error");
  }
#line 473
  return (tmp);
}
}
#line 476 "master_parse.y"
static int master_error(char const   *s ) 
{ 

  {
#line 478
  while (1) {
#line 478
    ((*log_error))(3U, "%s: %s while parsing map.", "master_error", s);
#line 478
    break;
  }
#line 479
  return (0);
}
}
#line 482 "master_parse.y"
static int master_notify(char const   *s ) 
{ 

  {
#line 484
  while (1) {
#line 484
    ((*log_warn))(3U, "%s: syntax error in map near [ %s ]", "master_notify", s);
#line 484
    break;
  }
#line 485
  return (0);
}
}
#line 488 "master_parse.y"
static void local_init_vars(void) 
{ 

  {
#line 490
  path = (char *)((void *)0);
#line 491
  type = (char *)((void *)0);
#line 492
  format = (char *)((void *)0);
#line 493
  verbose = 0U;
#line 494
  debug = 0U;
#line 495
  timeout = -1L;
#line 496
  ghost = defaults_get_browse_mode();
#line 497
  local_argv = (char **)((void *)0);
#line 498
  local_argc = 0;
#line 499
  return;
}
}
#line 501 "master_parse.y"
static void local_free_vars(void) 
{ 

  {
#line 503
  if (path) {
#line 504
    free((void *)path);
  }
#line 506
  if (type) {
#line 507
    free((void *)type);
  }
#line 509
  if (format) {
#line 510
    free((void *)format);
  }
#line 512
  if (local_argv) {
#line 513
    free_argv(local_argc, (char const   **)local_argv);
  }
#line 514
  return;
}
}
#line 516 "master_parse.y"
void master_init_scan(void) 
{ 

  {
#line 518
  lineno = 0;
#line 519
  return;
}
}
#line 521 "master_parse.y"
int master_parse_entry(char const   *buffer , unsigned int default_timeout , unsigned int logging ,
                       time_t age ) 
{ struct master *master ;
  struct mapent_cache *nc ;
  struct master_mapent *entry ;
  struct master_mapent *new ;
  struct map_source *source ;
  unsigned int logopt ;
  int ret ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  struct mapent *tmp___9 ;
  int tmp___10 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___16 ;
  int tmp___19 ;
  int tmp___20 ;
  struct autofs_point *ap ;
  time_t tout ;
  unsigned int tmp___21 ;

  {
#line 523
  master = master_list;
#line 527
  logopt = logging;
#line 530
  local_init_vars();
#line 532
  lineno ++;
#line 534
  master_set_scan_buffer(buffer);
#line 536
  ret = master_parse();
#line 537
  if (ret != 0) {
#line 538
    local_free_vars();
#line 539
    return (0);
  }
#line 542
  nc = master->nc;
#line 545
  if (type) {
#line 545
    if (0) {
#line 545
      __s1_len = strlen((char const   *)type);
#line 545
      __s2_len = strlen("null");
#line 545
      if (! ((unsigned int )((void const   *)(type + 1)) - (unsigned int )((void const   *)type) == 1U)) {
        goto _L___0;
      } else {
#line 545
        if (__s1_len >= 4U) {
          _L___0: 
#line 545
          if (! ((unsigned int )((void const   *)("null" + 1)) - (unsigned int )((void const   *)"null") == 1U)) {
#line 545
            tmp___8 = 1;
          } else {
#line 545
            if (__s2_len >= 4U) {
#line 545
              tmp___8 = 1;
            } else {
#line 545
              tmp___8 = 0;
            }
          }
        } else {
#line 545
          tmp___8 = 0;
        }
      }
#line 545
      if (tmp___8) {
#line 545
        tmp___4 = __builtin_strcmp((char const   *)type, "null");
      } else {
#line 545
        tmp___7 = __builtin_strcmp((char const   *)type, "null");
#line 545
        tmp___4 = tmp___7;
      }
    } else {
#line 545
      tmp___7 = __builtin_strcmp((char const   *)type, "null");
#line 545
      tmp___4 = tmp___7;
    }
#line 545
    if (! tmp___4) {
#line 546
      cache_writelock(nc);
#line 547
      cache_update(nc, (struct map_source *)((void *)0), (char const   *)path, (char const   *)((void *)0),
                   (long )lineno);
#line 548
      cache_unlock(nc);
#line 549
      local_free_vars();
#line 550
      return (1);
    }
  }
#line 554
  cache_readlock(nc);
#line 555
  tmp___9 = cache_lookup_distinct(nc, (char const   *)path);
#line 555
  if (tmp___9) {
#line 556
    cache_unlock(nc);
#line 557
    local_free_vars();
#line 558
    return (1);
  }
#line 560
  cache_unlock(nc);
#line 562
  if (debug) {
    goto _L___1;
  } else {
#line 562
    if (verbose) {
      _L___1: 
#line 563
      if (debug) {
#line 563
        logopt = 1U;
      } else {
#line 563
        logopt = 0U;
      }
#line 564
      if (verbose) {
#line 564
        tmp___10 = 2;
      } else {
#line 564
        tmp___10 = 0;
      }
#line 564
      logopt |= (unsigned int )tmp___10;
    }
  }
#line 567
  if (timeout < 0L) {
#line 568
    timeout = (long )default_timeout;
  }
#line 570
  new = (struct master_mapent *)((void *)0);
#line 571
  entry = master_find_mapent(master, (char const   *)path);
#line 572
  if (! entry) {
#line 573
    new = master_new_mapent(master, (char const   *)path, age);
#line 574
    if (! new) {
#line 575
      local_free_vars();
#line 576
      return (0);
    }
#line 578
    entry = new;
  } else {
#line 580
    if (entry->age) {
#line 580
      if (entry->age == age) {
#line 581
        if (0) {
#line 581
          __s1_len___0 = strlen((char const   *)path);
#line 581
          __s2_len___0 = strlen("/-");
#line 581
          if (! ((unsigned int )((void const   *)(path + 1)) - (unsigned int )((void const   *)path) == 1U)) {
            goto _L___3;
          } else {
#line 581
            if (__s1_len___0 >= 4U) {
              _L___3: 
#line 581
              if (! ((unsigned int )((void const   *)("/-" + 1)) - (unsigned int )((void const   *)"/-") == 1U)) {
#line 581
                tmp___20 = 1;
              } else {
#line 581
                if (__s2_len___0 >= 4U) {
#line 581
                  tmp___20 = 1;
                } else {
#line 581
                  tmp___20 = 0;
                }
              }
            } else {
#line 581
              tmp___20 = 0;
            }
          }
#line 581
          if (tmp___20) {
#line 581
            tmp___16 = __builtin_strcmp((char const   *)path, "/-");
          } else {
#line 581
            tmp___19 = __builtin_strcmp((char const   *)path, "/-");
#line 581
            tmp___16 = tmp___19;
          }
        } else {
#line 581
          tmp___19 = __builtin_strcmp((char const   *)path, "/-");
#line 581
          tmp___16 = tmp___19;
        }
#line 581
        if (tmp___16) {
#line 582
          while (1) {
#line 582
            ((*log_warn))(2U, "%s: ignoring duplicate indirect mount %s", "master_parse_entry",
                          path);
#line 582
            break;
          }
#line 585
          local_free_vars();
#line 586
          return (0);
        }
      }
    }
  }
#line 591
  if (! entry->ap) {
#line 592
    ret = master_add_autofs_point(entry, timeout, logopt, ghost, 0);
#line 593
    if (! ret) {
#line 594
      while (1) {
#line 594
        ((*log_error))(3U, "%s: failed to add autofs_point", "master_parse_entry");
#line 594
        break;
      }
#line 595
      if (new) {
#line 596
        master_free_mapent(new);
      }
#line 597
      local_free_vars();
#line 598
      return (0);
    }
#line 600
    set_mnt_logging(entry->ap);
  } else {
#line 602
    ap = entry->ap;
#line 603
    tout = timeout;
#line 609
    if (entry->age < age) {
#line 610
      ap->ghost = ghost;
#line 611
      ap->logopt = logopt;
#line 612
      ap->exp_timeout = timeout;
#line 613
      ap->exp_runfreq = ((ap->exp_timeout + 4L) - 1L) / 4L;
#line 614
      if (ap->ioctlfd != -1) {
#line 614
        if (ap->type == 2U) {
#line 615
          if (sizeof(unsigned long ) == sizeof(unsigned long [1])) {
#line 615
            if (sizeof(unsigned long ) < 16384U) {
#line 615
              tmp___21 = sizeof(unsigned long );
            } else {
#line 615
              tmp___21 = __invalid_size_argument_for_IOC;
            }
          } else {
#line 615
            tmp___21 = __invalid_size_argument_for_IOC;
          }
#line 615
          ioctl(ap->ioctlfd, (unsigned long )(3221263204U | (tmp___21 << 16)), & tout);
        }
      }
    }
#line 617
    set_mnt_logging(ap);
  }
#line 629
  source = master_add_map_source(entry, type, format, age, local_argc, (char const   **)local_argv);
#line 631
  if (! source) {
#line 632
    while (1) {
#line 632
      ((*log_error))(3U, "%s: failed to add source", "master_parse_entry");
#line 632
      break;
    }
#line 633
    if (new) {
#line 634
      master_free_mapent(new);
    }
#line 635
    local_free_vars();
#line 636
    return (0);
  }
#line 639
  if (! source->mc) {
#line 640
    source->mc = cache_init(source);
#line 641
    if (! source->mc) {
#line 642
      while (1) {
#line 642
        ((*log_error))(3U, "%s: failed to init source cache", "master_parse_entry");
#line 642
        break;
      }
#line 643
      if (new) {
#line 644
        master_free_mapent(new);
      }
#line 645
      local_free_vars();
#line 646
      return (0);
    }
  }
#line 649
  source->master_line = (unsigned int )lineno;
#line 651
  entry->age = age;
#line 652
  entry->current = (struct map_source *)((void *)0);
#line 654
  if (new) {
#line 655
    master_add_mapent(master, entry);
  }
#line 657
  local_free_vars();
#line 659
  return (1);
}
}
#line 1 "master_tok.o"
#pragma merger(0,"/tmp/cil-vIV2a8v5.i","-O2,-Wall,-fPIC")
#line 145 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 146
extern struct _IO_FILE *stdout ;
#line 763
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 155 "master_tok.c"
int master_leng  ;
#line 157
FILE *master_in ;
#line 157
FILE *master_out ;
#line 257 "master_tok.c"
static unsigned int yy_buffer_stack_top  =    0U;
#line 258 "master_tok.c"
static unsigned int yy_buffer_stack_max  =    0U;
#line 259 "master_tok.c"
static YY_BUFFER_STATE *yy_buffer_stack  =    (YY_BUFFER_STATE *)0;
#line 277 "master_tok.c"
static char yy_hold_char  ;
#line 278 "master_tok.c"
static int yy_n_chars  ;
#line 282 "master_tok.c"
static char *yy_c_buf_p  =    (char *)0;
#line 283 "master_tok.c"
static int yy_init  =    0;
#line 284 "master_tok.c"
static int yy_start  =    0;
#line 289 "master_tok.c"
static int yy_did_buffer_switch_on_eof  ;
#line 291
void master_restart(FILE *input_file ) ;
#line 292
void master__switch_to_buffer(YY_BUFFER_STATE new_buffer ) ;
#line 293
YY_BUFFER_STATE master__create_buffer(FILE *file , int size ) ;
#line 294
void master__delete_buffer(YY_BUFFER_STATE b ) ;
#line 295
void master__flush_buffer(YY_BUFFER_STATE b ) ;
#line 296
void master_push_buffer_state(YY_BUFFER_STATE new_buffer ) ;
#line 297
void master_pop_buffer_state(void) ;
#line 299
static void master_ensure_buffer_stack(void) ;
#line 300
static void master__load_buffer_state(void) ;
#line 301
static void master__init_buffer(YY_BUFFER_STATE b , FILE *file ) ;
#line 305
YY_BUFFER_STATE master__scan_buffer(char *base , yy_size_t size ) ;
#line 306
YY_BUFFER_STATE master__scan_string(char const   *yystr ) ;
#line 307
YY_BUFFER_STATE master__scan_bytes(char const   *yybytes , int _yybytes_len ) ;
#line 309
void *master_alloc(yy_size_t size ) ;
#line 310
void *master_realloc(void *ptr , yy_size_t size ) ;
#line 311
void master_free(void *ptr ) ;
#line 341 "master_tok.c"
FILE *master_in  =    (FILE *)0;
#line 341 "master_tok.c"
FILE *master_out  =    (FILE *)0;
#line 347 "master_tok.c"
int master_lineno  =    1;
#line 349 "master_tok.c"
char *master_text  ;
#line 352
static yy_state_type yy_get_previous_state(void) ;
#line 353
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) ;
#line 354
static int yy_get_next_buffer(void) ;
#line 355
static void yy_fatal_error(char const   *msg ) ;
#line 376 "master_tok.c"
static flex_int16_t const   yy_acclist[282]  = 
#line 376
  {      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)16404,      (flex_int16_t const   )(short)16404,      (flex_int16_t const   )(short)45, 
        (flex_int16_t const   )(short)45,      (flex_int16_t const   )(short)54,      (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)53, 
        (flex_int16_t const   )(short)1,      (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)53, 
        (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)4, 
        (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)2,      (flex_int16_t const   )(short)5, 
        (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)9, 
        (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)10,      (flex_int16_t const   )(short)53, 
        (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)8,      (flex_int16_t const   )(short)11, 
        (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)6, 
        (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)25,      (flex_int16_t const   )(short)53, 
        (flex_int16_t const   )(short)22,      (flex_int16_t const   )(short)25,      (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)16404, 
        (flex_int16_t const   )(short)8212,      (flex_int16_t const   )(short)23,      (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)25, 
        (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)25,      (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)25, 
        (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)25,      (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)14, 
        (flex_int16_t const   )(short)25,      (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)25,      (flex_int16_t const   )(short)53, 
        (flex_int16_t const   )(short)25,      (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)25,      (flex_int16_t const   )(short)53, 
        (flex_int16_t const   )(short)25,      (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)25,      (flex_int16_t const   )(short)53, 
        (flex_int16_t const   )(short)25,      (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)25,      (flex_int16_t const   )(short)53, 
        (flex_int16_t const   )(short)25,      (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)25,      (flex_int16_t const   )(short)53, 
        (flex_int16_t const   )(short)25,      (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)25,      (flex_int16_t const   )(short)53, 
        (flex_int16_t const   )(short)25,      (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)25,      (flex_int16_t const   )(short)53, 
        (flex_int16_t const   )(short)25,      (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)24,      (flex_int16_t const   )(short)25, 
        (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)34,      (flex_int16_t const   )(short)53, 
        (flex_int16_t const   )(short)35,      (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)31, 
        (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)30,      (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)53, 
        (flex_int16_t const   )(short)30,      (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)29,      (flex_int16_t const   )(short)53, 
        (flex_int16_t const   )(short)30,      (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)30,      (flex_int16_t const   )(short)53, 
        (flex_int16_t const   )(short)28,      (flex_int16_t const   )(short)30,      (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)30, 
        (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)30,      (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)28, 
        (flex_int16_t const   )(short)30,      (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)36, 
        (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)45,      (flex_int16_t const   )(short)50,      (flex_int16_t const   )(short)53, 
        (flex_int16_t const   )(short)51,      (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)44, 
        (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)39,      (flex_int16_t const   )(short)53, 
        (flex_int16_t const   )(short)49,      (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)53, 
        (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)48, 
        (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)52,      (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)1, 
        (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)9,      (flex_int16_t const   )(short)10,      (flex_int16_t const   )(short)7, 
        (flex_int16_t const   )(short)22,      (flex_int16_t const   )(short)16404,      (flex_int16_t const   )(short)8212,      (flex_int16_t const   )(short)8212, 
        (flex_int16_t const   )(short)23,      (flex_int16_t const   )(short)17,      (flex_int16_t const   )(short)18,      (flex_int16_t const   )(short)19, 
        (flex_int16_t const   )(short)21,      (flex_int16_t const   )(short)12,      (flex_int16_t const   )(short)34,      (flex_int16_t const   )(short)31, 
        (flex_int16_t const   )(short)32,      (flex_int16_t const   )(short)35,      (flex_int16_t const   )(short)31,      (flex_int16_t const   )(short)30, 
        (flex_int16_t const   )(short)30,      (flex_int16_t const   )(short)30,      (flex_int16_t const   )(short)33,      (flex_int16_t const   )(short)30, 
        (flex_int16_t const   )(short)27,      (flex_int16_t const   )(short)30,      (flex_int16_t const   )(short)28,      (flex_int16_t const   )(short)30, 
        (flex_int16_t const   )(short)28,      (flex_int16_t const   )(short)30,      (flex_int16_t const   )(short)26,      (flex_int16_t const   )(short)45, 
        (flex_int16_t const   )(short)50,      (flex_int16_t const   )(short)44,      (flex_int16_t const   )(short)51,      (flex_int16_t const   )(short)44, 
        (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)43, 
        (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)41,      (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)48, 
        (flex_int16_t const   )(short)38,      (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)42,      (flex_int16_t const   )(short)48, 
        (flex_int16_t const   )(short)39,      (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)37, 
        (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)12,      (flex_int16_t const   )(short)13, 
        (flex_int16_t const   )(short)18,      (flex_int16_t const   )(short)30,      (flex_int16_t const   )(short)30,      (flex_int16_t const   )(short)30, 
        (flex_int16_t const   )(short)30,      (flex_int16_t const   )(short)26,      (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)38, 
        (flex_int16_t const   )(short)38,      (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)37,      (flex_int16_t const   )(short)48, 
        (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)18,      (flex_int16_t const   )(short)27,      (flex_int16_t const   )(short)30, 
        (flex_int16_t const   )(short)30,      (flex_int16_t const   )(short)30,      (flex_int16_t const   )(short)30,      (flex_int16_t const   )(short)48, 
        (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)38,      (flex_int16_t const   )(short)38,      (flex_int16_t const   )(short)48, 
        (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)16,      (flex_int16_t const   )(short)30, 
        (flex_int16_t const   )(short)30,      (flex_int16_t const   )(short)30,      (flex_int16_t const   )(short)30,      (flex_int16_t const   )(short)47, 
        (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)47,      (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)48, 
        (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)15,      (flex_int16_t const   )(short)30, 
        (flex_int16_t const   )(short)30,      (flex_int16_t const   )(short)30,      (flex_int16_t const   )(short)30,      (flex_int16_t const   )(short)47, 
        (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)41,      (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)48, 
        (flex_int16_t const   )(short)13,      (flex_int16_t const   )(short)30,      (flex_int16_t const   )(short)30,      (flex_int16_t const   )(short)30, 
        (flex_int16_t const   )(short)30,      (flex_int16_t const   )(short)43,      (flex_int16_t const   )(short)41,      (flex_int16_t const   )(short)47, 
        (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)47,      (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)48, 
        (flex_int16_t const   )(short)18,      (flex_int16_t const   )(short)30,      (flex_int16_t const   )(short)27,      (flex_int16_t const   )(short)30, 
        (flex_int16_t const   )(short)30,      (flex_int16_t const   )(short)40,      (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)30, 
        (flex_int16_t const   )(short)30,      (flex_int16_t const   )(short)30,      (flex_int16_t const   )(short)38,      (flex_int16_t const   )(short)42, 
        (flex_int16_t const   )(short)30,      (flex_int16_t const   )(short)38,      (flex_int16_t const   )(short)38,      (flex_int16_t const   )(short)30, 
        (flex_int16_t const   )(short)38,      (flex_int16_t const   )(short)30,      (flex_int16_t const   )(short)30,      (flex_int16_t const   )(short)30, 
        (flex_int16_t const   )(short)30,      (flex_int16_t const   )(short)46};
#line 411 "master_tok.c"
static flex_int16_t const   yy_accept[378]  = 
#line 411
  {      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)1,      (flex_int16_t const   )(short)1,      (flex_int16_t const   )(short)1, 
        (flex_int16_t const   )(short)1,      (flex_int16_t const   )(short)1,      (flex_int16_t const   )(short)2,      (flex_int16_t const   )(short)3, 
        (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)4,      (flex_int16_t const   )(short)5, 
        (flex_int16_t const   )(short)6,      (flex_int16_t const   )(short)8,      (flex_int16_t const   )(short)10,      (flex_int16_t const   )(short)12, 
        (flex_int16_t const   )(short)15,      (flex_int16_t const   )(short)18,      (flex_int16_t const   )(short)21,      (flex_int16_t const   )(short)23, 
        (flex_int16_t const   )(short)26,      (flex_int16_t const   )(short)28,      (flex_int16_t const   )(short)30,      (flex_int16_t const   )(short)33, 
        (flex_int16_t const   )(short)35,      (flex_int16_t const   )(short)38,      (flex_int16_t const   )(short)40,      (flex_int16_t const   )(short)44, 
        (flex_int16_t const   )(short)47,      (flex_int16_t const   )(short)49,      (flex_int16_t const   )(short)51,      (flex_int16_t const   )(short)53, 
        (flex_int16_t const   )(short)55,      (flex_int16_t const   )(short)58,      (flex_int16_t const   )(short)60,      (flex_int16_t const   )(short)62, 
        (flex_int16_t const   )(short)64,      (flex_int16_t const   )(short)66,      (flex_int16_t const   )(short)68,      (flex_int16_t const   )(short)70, 
        (flex_int16_t const   )(short)72,      (flex_int16_t const   )(short)74,      (flex_int16_t const   )(short)76,      (flex_int16_t const   )(short)78, 
        (flex_int16_t const   )(short)80,      (flex_int16_t const   )(short)82,      (flex_int16_t const   )(short)84,      (flex_int16_t const   )(short)86, 
        (flex_int16_t const   )(short)89,      (flex_int16_t const   )(short)90,      (flex_int16_t const   )(short)92,      (flex_int16_t const   )(short)94, 
        (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)97,      (flex_int16_t const   )(short)99,      (flex_int16_t const   )(short)100, 
        (flex_int16_t const   )(short)102,      (flex_int16_t const   )(short)104,      (flex_int16_t const   )(short)106,      (flex_int16_t const   )(short)108, 
        (flex_int16_t const   )(short)111,      (flex_int16_t const   )(short)113,      (flex_int16_t const   )(short)115,      (flex_int16_t const   )(short)118, 
        (flex_int16_t const   )(short)119,      (flex_int16_t const   )(short)121,      (flex_int16_t const   )(short)124,      (flex_int16_t const   )(short)126, 
        (flex_int16_t const   )(short)127,      (flex_int16_t const   )(short)129,      (flex_int16_t const   )(short)130,      (flex_int16_t const   )(short)132, 
        (flex_int16_t const   )(short)134,      (flex_int16_t const   )(short)136,      (flex_int16_t const   )(short)137,      (flex_int16_t const   )(short)139, 
        (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)143,      (flex_int16_t const   )(short)144,      (flex_int16_t const   )(short)145, 
        (flex_int16_t const   )(short)146,      (flex_int16_t const   )(short)147,      (flex_int16_t const   )(short)148,      (flex_int16_t const   )(short)150, 
        (flex_int16_t const   )(short)151,      (flex_int16_t const   )(short)151,      (flex_int16_t const   )(short)151,      (flex_int16_t const   )(short)153, 
        (flex_int16_t const   )(short)153,      (flex_int16_t const   )(short)153,      (flex_int16_t const   )(short)154,      (flex_int16_t const   )(short)154, 
        (flex_int16_t const   )(short)154,      (flex_int16_t const   )(short)154,      (flex_int16_t const   )(short)155,      (flex_int16_t const   )(short)155, 
        (flex_int16_t const   )(short)156,      (flex_int16_t const   )(short)156,      (flex_int16_t const   )(short)156,      (flex_int16_t const   )(short)156, 
        (flex_int16_t const   )(short)157,      (flex_int16_t const   )(short)158,      (flex_int16_t const   )(short)158,      (flex_int16_t const   )(short)158, 
        (flex_int16_t const   )(short)158,      (flex_int16_t const   )(short)158,      (flex_int16_t const   )(short)158,      (flex_int16_t const   )(short)158, 
        (flex_int16_t const   )(short)158,      (flex_int16_t const   )(short)159,      (flex_int16_t const   )(short)160,      (flex_int16_t const   )(short)161, 
        (flex_int16_t const   )(short)161,      (flex_int16_t const   )(short)162,      (flex_int16_t const   )(short)163,      (flex_int16_t const   )(short)164, 
        (flex_int16_t const   )(short)164,      (flex_int16_t const   )(short)165,      (flex_int16_t const   )(short)166,      (flex_int16_t const   )(short)167, 
        (flex_int16_t const   )(short)168,      (flex_int16_t const   )(short)169,      (flex_int16_t const   )(short)170,      (flex_int16_t const   )(short)172, 
        (flex_int16_t const   )(short)173,      (flex_int16_t const   )(short)174,      (flex_int16_t const   )(short)175,      (flex_int16_t const   )(short)177, 
        (flex_int16_t const   )(short)178,      (flex_int16_t const   )(short)178,      (flex_int16_t const   )(short)179,      (flex_int16_t const   )(short)180, 
        (flex_int16_t const   )(short)180,      (flex_int16_t const   )(short)181,      (flex_int16_t const   )(short)182,      (flex_int16_t const   )(short)183, 
        (flex_int16_t const   )(short)185,      (flex_int16_t const   )(short)187,      (flex_int16_t const   )(short)188,      (flex_int16_t const   )(short)190, 
        (flex_int16_t const   )(short)192,      (flex_int16_t const   )(short)193,      (flex_int16_t const   )(short)194,      (flex_int16_t const   )(short)194, 
        (flex_int16_t const   )(short)195,      (flex_int16_t const   )(short)196,      (flex_int16_t const   )(short)197,      (flex_int16_t const   )(short)198, 
        (flex_int16_t const   )(short)198,      (flex_int16_t const   )(short)198,      (flex_int16_t const   )(short)198,      (flex_int16_t const   )(short)198, 
        (flex_int16_t const   )(short)198,      (flex_int16_t const   )(short)198,      (flex_int16_t const   )(short)198,      (flex_int16_t const   )(short)198, 
        (flex_int16_t const   )(short)198,      (flex_int16_t const   )(short)199,      (flex_int16_t const   )(short)199,      (flex_int16_t const   )(short)199, 
        (flex_int16_t const   )(short)199,      (flex_int16_t const   )(short)199,      (flex_int16_t const   )(short)199,      (flex_int16_t const   )(short)199, 
        (flex_int16_t const   )(short)199,      (flex_int16_t const   )(short)201,      (flex_int16_t const   )(short)201,      (flex_int16_t const   )(short)201, 
        (flex_int16_t const   )(short)202,      (flex_int16_t const   )(short)203,      (flex_int16_t const   )(short)203,      (flex_int16_t const   )(short)204, 
        (flex_int16_t const   )(short)205,      (flex_int16_t const   )(short)206,      (flex_int16_t const   )(short)206,      (flex_int16_t const   )(short)206, 
        (flex_int16_t const   )(short)206,      (flex_int16_t const   )(short)206,      (flex_int16_t const   )(short)206,      (flex_int16_t const   )(short)206, 
        (flex_int16_t const   )(short)206,      (flex_int16_t const   )(short)207,      (flex_int16_t const   )(short)208,      (flex_int16_t const   )(short)209, 
        (flex_int16_t const   )(short)210,      (flex_int16_t const   )(short)211,      (flex_int16_t const   )(short)212,      (flex_int16_t const   )(short)213, 
        (flex_int16_t const   )(short)213,      (flex_int16_t const   )(short)213,      (flex_int16_t const   )(short)213,      (flex_int16_t const   )(short)213, 
        (flex_int16_t const   )(short)213,      (flex_int16_t const   )(short)214,      (flex_int16_t const   )(short)214,      (flex_int16_t const   )(short)214, 
        (flex_int16_t const   )(short)214,      (flex_int16_t const   )(short)214,      (flex_int16_t const   )(short)214,      (flex_int16_t const   )(short)214, 
        (flex_int16_t const   )(short)214,      (flex_int16_t const   )(short)214,      (flex_int16_t const   )(short)214,      (flex_int16_t const   )(short)214, 
        (flex_int16_t const   )(short)214,      (flex_int16_t const   )(short)214,      (flex_int16_t const   )(short)214,      (flex_int16_t const   )(short)214, 
        (flex_int16_t const   )(short)214,      (flex_int16_t const   )(short)215,      (flex_int16_t const   )(short)215,      (flex_int16_t const   )(short)216, 
        (flex_int16_t const   )(short)217,      (flex_int16_t const   )(short)218,      (flex_int16_t const   )(short)219,      (flex_int16_t const   )(short)219, 
        (flex_int16_t const   )(short)219,      (flex_int16_t const   )(short)219,      (flex_int16_t const   )(short)219,      (flex_int16_t const   )(short)219, 
        (flex_int16_t const   )(short)219,      (flex_int16_t const   )(short)219,      (flex_int16_t const   )(short)220,      (flex_int16_t const   )(short)220, 
        (flex_int16_t const   )(short)220,      (flex_int16_t const   )(short)221,      (flex_int16_t const   )(short)222,      (flex_int16_t const   )(short)223, 
        (flex_int16_t const   )(short)224,      (flex_int16_t const   )(short)225,      (flex_int16_t const   )(short)226,      (flex_int16_t const   )(short)226, 
        (flex_int16_t const   )(short)227,      (flex_int16_t const   )(short)227,      (flex_int16_t const   )(short)227,      (flex_int16_t const   )(short)227, 
        (flex_int16_t const   )(short)227,      (flex_int16_t const   )(short)227,      (flex_int16_t const   )(short)227,      (flex_int16_t const   )(short)227, 
        (flex_int16_t const   )(short)227,      (flex_int16_t const   )(short)227,      (flex_int16_t const   )(short)227,      (flex_int16_t const   )(short)227, 
        (flex_int16_t const   )(short)227,      (flex_int16_t const   )(short)227,      (flex_int16_t const   )(short)227,      (flex_int16_t const   )(short)227, 
        (flex_int16_t const   )(short)227,      (flex_int16_t const   )(short)228,      (flex_int16_t const   )(short)229,      (flex_int16_t const   )(short)230, 
        (flex_int16_t const   )(short)231,      (flex_int16_t const   )(short)231,      (flex_int16_t const   )(short)231,      (flex_int16_t const   )(short)231, 
        (flex_int16_t const   )(short)231,      (flex_int16_t const   )(short)231,      (flex_int16_t const   )(short)231,      (flex_int16_t const   )(short)231, 
        (flex_int16_t const   )(short)233,      (flex_int16_t const   )(short)234,      (flex_int16_t const   )(short)235,      (flex_int16_t const   )(short)236, 
        (flex_int16_t const   )(short)237,      (flex_int16_t const   )(short)238,      (flex_int16_t const   )(short)239,      (flex_int16_t const   )(short)239, 
        (flex_int16_t const   )(short)239,      (flex_int16_t const   )(short)239,      (flex_int16_t const   )(short)239,      (flex_int16_t const   )(short)239, 
        (flex_int16_t const   )(short)239,      (flex_int16_t const   )(short)239,      (flex_int16_t const   )(short)239,      (flex_int16_t const   )(short)239, 
        (flex_int16_t const   )(short)239,      (flex_int16_t const   )(short)239,      (flex_int16_t const   )(short)239,      (flex_int16_t const   )(short)239, 
        (flex_int16_t const   )(short)240,      (flex_int16_t const   )(short)241,      (flex_int16_t const   )(short)242,      (flex_int16_t const   )(short)243, 
        (flex_int16_t const   )(short)243,      (flex_int16_t const   )(short)243,      (flex_int16_t const   )(short)243,      (flex_int16_t const   )(short)243, 
        (flex_int16_t const   )(short)243,      (flex_int16_t const   )(short)245,      (flex_int16_t const   )(short)247,      (flex_int16_t const   )(short)248, 
        (flex_int16_t const   )(short)248,      (flex_int16_t const   )(short)248,      (flex_int16_t const   )(short)248,      (flex_int16_t const   )(short)248, 
        (flex_int16_t const   )(short)248,      (flex_int16_t const   )(short)248,      (flex_int16_t const   )(short)248,      (flex_int16_t const   )(short)249, 
        (flex_int16_t const   )(short)249,      (flex_int16_t const   )(short)249,      (flex_int16_t const   )(short)250,      (flex_int16_t const   )(short)251, 
        (flex_int16_t const   )(short)252,      (flex_int16_t const   )(short)253,      (flex_int16_t const   )(short)254,      (flex_int16_t const   )(short)255, 
        (flex_int16_t const   )(short)255,      (flex_int16_t const   )(short)255,      (flex_int16_t const   )(short)255,      (flex_int16_t const   )(short)257, 
        (flex_int16_t const   )(short)259,      (flex_int16_t const   )(short)260,      (flex_int16_t const   )(short)260,      (flex_int16_t const   )(short)260, 
        (flex_int16_t const   )(short)260,      (flex_int16_t const   )(short)261,      (flex_int16_t const   )(short)261,      (flex_int16_t const   )(short)261, 
        (flex_int16_t const   )(short)261,      (flex_int16_t const   )(short)261,      (flex_int16_t const   )(short)261,      (flex_int16_t const   )(short)262, 
        (flex_int16_t const   )(short)263,      (flex_int16_t const   )(short)264,      (flex_int16_t const   )(short)265,      (flex_int16_t const   )(short)265, 
        (flex_int16_t const   )(short)265,      (flex_int16_t const   )(short)265,      (flex_int16_t const   )(short)267,      (flex_int16_t const   )(short)267, 
        (flex_int16_t const   )(short)267,      (flex_int16_t const   )(short)267,      (flex_int16_t const   )(short)267,      (flex_int16_t const   )(short)267, 
        (flex_int16_t const   )(short)267,      (flex_int16_t const   )(short)267,      (flex_int16_t const   )(short)267,      (flex_int16_t const   )(short)268, 
        (flex_int16_t const   )(short)268,      (flex_int16_t const   )(short)269,      (flex_int16_t const   )(short)270,      (flex_int16_t const   )(short)270, 
        (flex_int16_t const   )(short)271,      (flex_int16_t const   )(short)272,      (flex_int16_t const   )(short)272,      (flex_int16_t const   )(short)272, 
        (flex_int16_t const   )(short)272,      (flex_int16_t const   )(short)272,      (flex_int16_t const   )(short)272,      (flex_int16_t const   )(short)273, 
        (flex_int16_t const   )(short)273,      (flex_int16_t const   )(short)274,      (flex_int16_t const   )(short)275,      (flex_int16_t const   )(short)275, 
        (flex_int16_t const   )(short)275,      (flex_int16_t const   )(short)275,      (flex_int16_t const   )(short)275,      (flex_int16_t const   )(short)275, 
        (flex_int16_t const   )(short)276,      (flex_int16_t const   )(short)276,      (flex_int16_t const   )(short)277,      (flex_int16_t const   )(short)277, 
        (flex_int16_t const   )(short)278,      (flex_int16_t const   )(short)278,      (flex_int16_t const   )(short)278,      (flex_int16_t const   )(short)279, 
        (flex_int16_t const   )(short)279,      (flex_int16_t const   )(short)279,      (flex_int16_t const   )(short)280,      (flex_int16_t const   )(short)280, 
        (flex_int16_t const   )(short)280,      (flex_int16_t const   )(short)281,      (flex_int16_t const   )(short)281,      (flex_int16_t const   )(short)281, 
        (flex_int16_t const   )(short)282,      (flex_int16_t const   )(short)282};
#line 456 "master_tok.c"
static flex_int32_t const   yy_ec[256]  = 
#line 456
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )4,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )5,      (flex_int32_t const   )6, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )7,      (flex_int32_t const   )8,      (flex_int32_t const   )9,      (flex_int32_t const   )10, 
        (flex_int32_t const   )11,      (flex_int32_t const   )11,      (flex_int32_t const   )11,      (flex_int32_t const   )11, 
        (flex_int32_t const   )11,      (flex_int32_t const   )11,      (flex_int32_t const   )11,      (flex_int32_t const   )11, 
        (flex_int32_t const   )11,      (flex_int32_t const   )11,      (flex_int32_t const   )12,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )13,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )14,      (flex_int32_t const   )15,      (flex_int32_t const   )16, 
        (flex_int32_t const   )17,      (flex_int32_t const   )18,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )15,      (flex_int32_t const   )19,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )15,      (flex_int32_t const   )20,      (flex_int32_t const   )21,      (flex_int32_t const   )22, 
        (flex_int32_t const   )23,      (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )24, 
        (flex_int32_t const   )25,      (flex_int32_t const   )26,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )27, 
        (flex_int32_t const   )28,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )29, 
        (flex_int32_t const   )1,      (flex_int32_t const   )30,      (flex_int32_t const   )31,      (flex_int32_t const   )32, 
        (flex_int32_t const   )33,      (flex_int32_t const   )34,      (flex_int32_t const   )35,      (flex_int32_t const   )36, 
        (flex_int32_t const   )37,      (flex_int32_t const   )38,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )39,      (flex_int32_t const   )40,      (flex_int32_t const   )41,      (flex_int32_t const   )42, 
        (flex_int32_t const   )43,      (flex_int32_t const   )15,      (flex_int32_t const   )44,      (flex_int32_t const   )45, 
        (flex_int32_t const   )46,      (flex_int32_t const   )47,      (flex_int32_t const   )48,      (flex_int32_t const   )49, 
        (flex_int32_t const   )15,      (flex_int32_t const   )50,      (flex_int32_t const   )15,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 488 "master_tok.c"
static flex_int32_t const   yy_meta[52]  = 
#line 488
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )4,      (flex_int32_t const   )5,      (flex_int32_t const   )6,      (flex_int32_t const   )7, 
        (flex_int32_t const   )8,      (flex_int32_t const   )9,      (flex_int32_t const   )10,      (flex_int32_t const   )10, 
        (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10, 
        (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10, 
        (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )11,      (flex_int32_t const   )10,      (flex_int32_t const   )10, 
        (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10, 
        (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10, 
        (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10, 
        (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10, 
        (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )1};
#line 498 "master_tok.c"
static flex_int16_t const   yy_base[403]  = 
#line 498
  {      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)14, 
        (flex_int16_t const   )(short)18,      (flex_int16_t const   )(short)69,      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)120, 
        (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)171,      (flex_int16_t const   )(short)222,      (flex_int16_t const   )(short)1008, 
        (flex_int16_t const   )(short)1009,      (flex_int16_t const   )(short)1009,      (flex_int16_t const   )(short)1004,      (flex_int16_t const   )(short)0, 
        (flex_int16_t const   )(short)1009,      (flex_int16_t const   )(short)1009,      (flex_int16_t const   )(short)1009,      (flex_int16_t const   )(short)1004, 
        (flex_int16_t const   )(short)1009,      (flex_int16_t const   )(short)1002,      (flex_int16_t const   )(short)1009,      (flex_int16_t const   )(short)0, 
        (flex_int16_t const   )(short)1009,      (flex_int16_t const   )(short)1009,      (flex_int16_t const   )(short)10,      (flex_int16_t const   )(short)1009, 
        (flex_int16_t const   )(short)1001,      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)993,      (flex_int16_t const   )(short)15, 
        (flex_int16_t const   )(short)1009,      (flex_int16_t const   )(short)13,      (flex_int16_t const   )(short)990,      (flex_int16_t const   )(short)22, 
        (flex_int16_t const   )(short)20,      (flex_int16_t const   )(short)21,      (flex_int16_t const   )(short)174,      (flex_int16_t const   )(short)998, 
        (flex_int16_t const   )(short)15,      (flex_int16_t const   )(short)16,      (flex_int16_t const   )(short)33,      (flex_int16_t const   )(short)173, 
        (flex_int16_t const   )(short)17,      (flex_int16_t const   )(short)19,      (flex_int16_t const   )(short)176,      (flex_int16_t const   )(short)1009, 
        (flex_int16_t const   )(short)1009,      (flex_int16_t const   )(short)234,      (flex_int16_t const   )(short)1009,      (flex_int16_t const   )(short)997, 
        (flex_int16_t const   )(short)997,      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)988,      (flex_int16_t const   )(short)46, 
        (flex_int16_t const   )(short)995,      (flex_int16_t const   )(short)191,      (flex_int16_t const   )(short)177,      (flex_int16_t const   )(short)225, 
        (flex_int16_t const   )(short)178,      (flex_int16_t const   )(short)232,      (flex_int16_t const   )(short)230,      (flex_int16_t const   )(short)993, 
        (flex_int16_t const   )(short)1009,      (flex_int16_t const   )(short)211,      (flex_int16_t const   )(short)1009,      (flex_int16_t const   )(short)992, 
        (flex_int16_t const   )(short)992,      (flex_int16_t const   )(short)270,      (flex_int16_t const   )(short)982,      (flex_int16_t const   )(short)1009, 
        (flex_int16_t const   )(short)232,      (flex_int16_t const   )(short)989,      (flex_int16_t const   )(short)247,      (flex_int16_t const   )(short)256, 
        (flex_int16_t const   )(short)1009,      (flex_int16_t const   )(short)1009,      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)989, 
        (flex_int16_t const   )(short)1009,      (flex_int16_t const   )(short)1009,      (flex_int16_t const   )(short)272,      (flex_int16_t const   )(short)1009, 
        (flex_int16_t const   )(short)987,      (flex_int16_t const   )(short)986,      (flex_int16_t const   )(short)1009,      (flex_int16_t const   )(short)946, 
        (flex_int16_t const   )(short)940,      (flex_int16_t const   )(short)975,      (flex_int16_t const   )(short)974,      (flex_int16_t const   )(short)182, 
        (flex_int16_t const   )(short)972,      (flex_int16_t const   )(short)972,      (flex_int16_t const   )(short)256,      (flex_int16_t const   )(short)1009, 
        (flex_int16_t const   )(short)55,      (flex_int16_t const   )(short)969,      (flex_int16_t const   )(short)259,      (flex_int16_t const   )(short)1009, 
        (flex_int16_t const   )(short)979,      (flex_int16_t const   )(short)253,      (flex_int16_t const   )(short)203,      (flex_int16_t const   )(short)18, 
        (flex_int16_t const   )(short)260,      (flex_int16_t const   )(short)267,      (flex_int16_t const   )(short)273,      (flex_int16_t const   )(short)197, 
        (flex_int16_t const   )(short)286,      (flex_int16_t const   )(short)978,      (flex_int16_t const   )(short)1009,      (flex_int16_t const   )(short)976, 
        (flex_int16_t const   )(short)1009,      (flex_int16_t const   )(short)976,      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)966, 
        (flex_int16_t const   )(short)965,      (flex_int16_t const   )(short)186,      (flex_int16_t const   )(short)973,      (flex_int16_t const   )(short)268, 
        (flex_int16_t const   )(short)963,      (flex_int16_t const   )(short)283,      (flex_int16_t const   )(short)284,      (flex_int16_t const   )(short)1009, 
        (flex_int16_t const   )(short)298,      (flex_int16_t const   )(short)968,      (flex_int16_t const   )(short)287,      (flex_int16_t const   )(short)966, 
        (flex_int16_t const   )(short)959,      (flex_int16_t const   )(short)1009,      (flex_int16_t const   )(short)958,      (flex_int16_t const   )(short)287, 
        (flex_int16_t const   )(short)313,      (flex_int16_t const   )(short)323,      (flex_int16_t const   )(short)329,      (flex_int16_t const   )(short)333, 
        (flex_int16_t const   )(short)337,      (flex_int16_t const   )(short)341,      (flex_int16_t const   )(short)345,      (flex_int16_t const   )(short)349, 
        (flex_int16_t const   )(short)944,      (flex_int16_t const   )(short)353,      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)357, 
        (flex_int16_t const   )(short)952,      (flex_int16_t const   )(short)361,      (flex_int16_t const   )(short)367,      (flex_int16_t const   )(short)907, 
        (flex_int16_t const   )(short)907,      (flex_int16_t const   )(short)205,      (flex_int16_t const   )(short)307,      (flex_int16_t const   )(short)368, 
        (flex_int16_t const   )(short)935,      (flex_int16_t const   )(short)327,      (flex_int16_t const   )(short)359,      (flex_int16_t const   )(short)347, 
        (flex_int16_t const   )(short)941,      (flex_int16_t const   )(short)351,      (flex_int16_t const   )(short)364,      (flex_int16_t const   )(short)339, 
        (flex_int16_t const   )(short)377,      (flex_int16_t const   )(short)374,      (flex_int16_t const   )(short)378,      (flex_int16_t const   )(short)17, 
        (flex_int16_t const   )(short)928,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)395, 
        (flex_int16_t const   )(short)929,      (flex_int16_t const   )(short)384,      (flex_int16_t const   )(short)387,      (flex_int16_t const   )(short)395, 
        (flex_int16_t const   )(short)934,      (flex_int16_t const   )(short)896,      (flex_int16_t const   )(short)891,      (flex_int16_t const   )(short)880, 
        (flex_int16_t const   )(short)881,      (flex_int16_t const   )(short)881,      (flex_int16_t const   )(short)880,      (flex_int16_t const   )(short)910, 
        (flex_int16_t const   )(short)410,      (flex_int16_t const   )(short)398,      (flex_int16_t const   )(short)905,      (flex_int16_t const   )(short)417, 
        (flex_int16_t const   )(short)904,      (flex_int16_t const   )(short)423,      (flex_int16_t const   )(short)429,      (flex_int16_t const   )(short)859, 
        (flex_int16_t const   )(short)865,      (flex_int16_t const   )(short)892,      (flex_int16_t const   )(short)403,      (flex_int16_t const   )(short)429, 
        (flex_int16_t const   )(short)1009,      (flex_int16_t const   )(short)891,      (flex_int16_t const   )(short)890,      (flex_int16_t const   )(short)434, 
        (flex_int16_t const   )(short)393,      (flex_int16_t const   )(short)432,      (flex_int16_t const   )(short)396,      (flex_int16_t const   )(short)420, 
        (flex_int16_t const   )(short)414,      (flex_int16_t const   )(short)435,      (flex_int16_t const   )(short)436,      (flex_int16_t const   )(short)864, 
        (flex_int16_t const   )(short)844,      (flex_int16_t const   )(short)872,      (flex_int16_t const   )(short)440,      (flex_int16_t const   )(short)440, 
        (flex_int16_t const   )(short)1009,      (flex_int16_t const   )(short)871,      (flex_int16_t const   )(short)869,      (flex_int16_t const   )(short)445, 
        (flex_int16_t const   )(short)446,      (flex_int16_t const   )(short)447,      (flex_int16_t const   )(short)848,      (flex_int16_t const   )(short)832, 
        (flex_int16_t const   )(short)864,      (flex_int16_t const   )(short)841,      (flex_int16_t const   )(short)829,      (flex_int16_t const   )(short)822, 
        (flex_int16_t const   )(short)852,      (flex_int16_t const   )(short)472,      (flex_int16_t const   )(short)849,      (flex_int16_t const   )(short)852, 
        (flex_int16_t const   )(short)479,      (flex_int16_t const   )(short)854,      (flex_int16_t const   )(short)852,      (flex_int16_t const   )(short)483, 
        (flex_int16_t const   )(short)487,      (flex_int16_t const   )(short)491,      (flex_int16_t const   )(short)808,      (flex_int16_t const   )(short)1009, 
        (flex_int16_t const   )(short)446,      (flex_int16_t const   )(short)840,      (flex_int16_t const   )(short)453,      (flex_int16_t const   )(short)459, 
        (flex_int16_t const   )(short)839,      (flex_int16_t const   )(short)481,      (flex_int16_t const   )(short)466,      (flex_int16_t const   )(short)472, 
        (flex_int16_t const   )(short)459,      (flex_int16_t const   )(short)485,      (flex_int16_t const   )(short)470,      (flex_int16_t const   )(short)802, 
        (flex_int16_t const   )(short)805,      (flex_int16_t const   )(short)501,      (flex_int16_t const   )(short)836,      (flex_int16_t const   )(short)503, 
        (flex_int16_t const   )(short)507,      (flex_int16_t const   )(short)832,      (flex_int16_t const   )(short)495,      (flex_int16_t const   )(short)499, 
        (flex_int16_t const   )(short)791,      (flex_int16_t const   )(short)788,      (flex_int16_t const   )(short)787,      (flex_int16_t const   )(short)785, 
        (flex_int16_t const   )(short)781,      (flex_int16_t const   )(short)781,      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)518, 
        (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)527,      (flex_int16_t const   )(short)528,      (flex_int16_t const   )(short)535, 
        (flex_int16_t const   )(short)536,      (flex_int16_t const   )(short)1009,      (flex_int16_t const   )(short)790,      (flex_int16_t const   )(short)510, 
        (flex_int16_t const   )(short)779,      (flex_int16_t const   )(short)541,      (flex_int16_t const   )(short)508,      (flex_int16_t const   )(short)533, 
        (flex_int16_t const   )(short)343,      (flex_int16_t const   )(short)513,      (flex_int16_t const   )(short)518,      (flex_int16_t const   )(short)715, 
        (flex_int16_t const   )(short)740,      (flex_int16_t const   )(short)740,      (flex_int16_t const   )(short)547,      (flex_int16_t const   )(short)739, 
        (flex_int16_t const   )(short)548,      (flex_int16_t const   )(short)539,      (flex_int16_t const   )(short)549,      (flex_int16_t const   )(short)712, 
        (flex_int16_t const   )(short)701,      (flex_int16_t const   )(short)709,      (flex_int16_t const   )(short)701,      (flex_int16_t const   )(short)700, 
        (flex_int16_t const   )(short)564,      (flex_int16_t const   )(short)568,      (flex_int16_t const   )(short)576,      (flex_int16_t const   )(short)555, 
        (flex_int16_t const   )(short)732,      (flex_int16_t const   )(short)571,      (flex_int16_t const   )(short)731,      (flex_int16_t const   )(short)559, 
        (flex_int16_t const   )(short)579,      (flex_int16_t const   )(short)697,      (flex_int16_t const   )(short)1009,      (flex_int16_t const   )(short)583, 
        (flex_int16_t const   )(short)728,      (flex_int16_t const   )(short)584,      (flex_int16_t const   )(short)726,      (flex_int16_t const   )(short)576, 
        (flex_int16_t const   )(short)589,      (flex_int16_t const   )(short)1009,      (flex_int16_t const   )(short)1009,      (flex_int16_t const   )(short)695, 
        (flex_int16_t const   )(short)680,      (flex_int16_t const   )(short)675,      (flex_int16_t const   )(short)599,      (flex_int16_t const   )(short)614, 
        (flex_int16_t const   )(short)603,      (flex_int16_t const   )(short)707,      (flex_int16_t const   )(short)593,      (flex_int16_t const   )(short)587, 
        (flex_int16_t const   )(short)704,      (flex_int16_t const   )(short)601,      (flex_int16_t const   )(short)608,      (flex_int16_t const   )(short)680, 
        (flex_int16_t const   )(short)698,      (flex_int16_t const   )(short)620,      (flex_int16_t const   )(short)621,      (flex_int16_t const   )(short)692, 
        (flex_int16_t const   )(short)624,      (flex_int16_t const   )(short)622,      (flex_int16_t const   )(short)638,      (flex_int16_t const   )(short)619, 
        (flex_int16_t const   )(short)605,      (flex_int16_t const   )(short)627,      (flex_int16_t const   )(short)633,      (flex_int16_t const   )(short)606, 
        (flex_int16_t const   )(short)594,      (flex_int16_t const   )(short)643,      (flex_int16_t const   )(short)638,      (flex_int16_t const   )(short)612, 
        (flex_int16_t const   )(short)649,      (flex_int16_t const   )(short)558,      (flex_int16_t const   )(short)551,      (flex_int16_t const   )(short)645, 
        (flex_int16_t const   )(short)651,      (flex_int16_t const   )(short)654,      (flex_int16_t const   )(short)510,      (flex_int16_t const   )(short)639, 
        (flex_int16_t const   )(short)1009,      (flex_int16_t const   )(short)657,      (flex_int16_t const   )(short)490,      (flex_int16_t const   )(short)662, 
        (flex_int16_t const   )(short)674,      (flex_int16_t const   )(short)463,      (flex_int16_t const   )(short)665,      (flex_int16_t const   )(short)459, 
        (flex_int16_t const   )(short)662,      (flex_int16_t const   )(short)458,      (flex_int16_t const   )(short)677,      (flex_int16_t const   )(short)671, 
        (flex_int16_t const   )(short)678,      (flex_int16_t const   )(short)686,      (flex_int16_t const   )(short)689,      (flex_int16_t const   )(short)681, 
        (flex_int16_t const   )(short)298,      (flex_int16_t const   )(short)288,      (flex_int16_t const   )(short)685,      (flex_int16_t const   )(short)690, 
        (flex_int16_t const   )(short)244,      (flex_int16_t const   )(short)693,      (flex_int16_t const   )(short)700,      (flex_int16_t const   )(short)243, 
        (flex_int16_t const   )(short)696,      (flex_int16_t const   )(short)705,      (flex_int16_t const   )(short)166,      (flex_int16_t const   )(short)710, 
        (flex_int16_t const   )(short)720,      (flex_int16_t const   )(short)155,      (flex_int16_t const   )(short)13,      (flex_int16_t const   )(short)1009, 
        (flex_int16_t const   )(short)1009,      (flex_int16_t const   )(short)754,      (flex_int16_t const   )(short)765,      (flex_int16_t const   )(short)776, 
        (flex_int16_t const   )(short)787,      (flex_int16_t const   )(short)798,      (flex_int16_t const   )(short)806,      (flex_int16_t const   )(short)816, 
        (flex_int16_t const   )(short)824,      (flex_int16_t const   )(short)832,      (flex_int16_t const   )(short)840,      (flex_int16_t const   )(short)848, 
        (flex_int16_t const   )(short)853,      (flex_int16_t const   )(short)857,      (flex_int16_t const   )(short)866,      (flex_int16_t const   )(short)874, 
        (flex_int16_t const   )(short)882,      (flex_int16_t const   )(short)889,      (flex_int16_t const   )(short)898,      (flex_int16_t const   )(short)906, 
        (flex_int16_t const   )(short)914,      (flex_int16_t const   )(short)922,      (flex_int16_t const   )(short)930,      (flex_int16_t const   )(short)938, 
        (flex_int16_t const   )(short)946,      (flex_int16_t const   )(short)954,      (flex_int16_t const   )(short)962};
#line 547 "master_tok.c"
static flex_int16_t const   yy_def[403]  = 
#line 547
  {      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)377,      (flex_int16_t const   )(short)377,      (flex_int16_t const   )(short)378, 
        (flex_int16_t const   )(short)378,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)379,      (flex_int16_t const   )(short)379,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)380, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)381, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)382, 
        (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)383, 
        (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)382, 
        (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)384,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)384, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)385,      (flex_int16_t const   )(short)385,      (flex_int16_t const   )(short)385, 
        (flex_int16_t const   )(short)385,      (flex_int16_t const   )(short)385,      (flex_int16_t const   )(short)385,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)386,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)387,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)387,      (flex_int16_t const   )(short)387, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)380,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)388,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)382, 
        (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)382, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)384,      (flex_int16_t const   )(short)389, 
        (flex_int16_t const   )(short)384,      (flex_int16_t const   )(short)384,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)385, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)385,      (flex_int16_t const   )(short)385,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)385,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)387,      (flex_int16_t const   )(short)390,      (flex_int16_t const   )(short)387,      (flex_int16_t const   )(short)387, 
        (flex_int16_t const   )(short)387,      (flex_int16_t const   )(short)387,      (flex_int16_t const   )(short)387,      (flex_int16_t const   )(short)387, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)387,      (flex_int16_t const   )(short)391,      (flex_int16_t const   )(short)387, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)387,      (flex_int16_t const   )(short)387,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)392,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)382, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)382, 
        (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)393,      (flex_int16_t const   )(short)384, 
        (flex_int16_t const   )(short)384,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)385,      (flex_int16_t const   )(short)385, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)394, 
        (flex_int16_t const   )(short)395,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)391,      (flex_int16_t const   )(short)396, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)387,      (flex_int16_t const   )(short)387,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)392, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)382, 
        (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)393, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)384,      (flex_int16_t const   )(short)384, 
        (flex_int16_t const   )(short)385,      (flex_int16_t const   )(short)385,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)397,      (flex_int16_t const   )(short)395,      (flex_int16_t const   )(short)397,      (flex_int16_t const   )(short)398, 
        (flex_int16_t const   )(short)395,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)399, 
        (flex_int16_t const   )(short)387,      (flex_int16_t const   )(short)387,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)382, 
        (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)384,      (flex_int16_t const   )(short)384,      (flex_int16_t const   )(short)385,      (flex_int16_t const   )(short)385, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)400,      (flex_int16_t const   )(short)401, 
        (flex_int16_t const   )(short)400,      (flex_int16_t const   )(short)399,      (flex_int16_t const   )(short)399,      (flex_int16_t const   )(short)387, 
        (flex_int16_t const   )(short)387,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)382, 
        (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)384, 
        (flex_int16_t const   )(short)384,      (flex_int16_t const   )(short)385,      (flex_int16_t const   )(short)385,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)402,      (flex_int16_t const   )(short)387,      (flex_int16_t const   )(short)387,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)382, 
        (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)384,      (flex_int16_t const   )(short)384,      (flex_int16_t const   )(short)385, 
        (flex_int16_t const   )(short)385,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)402,      (flex_int16_t const   )(short)402, 
        (flex_int16_t const   )(short)387,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)384,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)385,      (flex_int16_t const   )(short)385,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)387,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)382, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)384,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)385,      (flex_int16_t const   )(short)385,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)382, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)385,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)385, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)385, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)385,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)385,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)382, 
        (flex_int16_t const   )(short)385,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376};
#line 596 "master_tok.c"
static flex_int16_t const   yy_nxt[1061]  = 
#line 596
  {      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)13, 
        (flex_int16_t const   )(short)14,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)15,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)13,      (flex_int16_t const   )(short)14,      (flex_int16_t const   )(short)16,      (flex_int16_t const   )(short)15, 
        (flex_int16_t const   )(short)82,      (flex_int16_t const   )(short)83,      (flex_int16_t const   )(short)84,      (flex_int16_t const   )(short)16, 
        (flex_int16_t const   )(short)19,      (flex_int16_t const   )(short)20,      (flex_int16_t const   )(short)21,      (flex_int16_t const   )(short)22, 
        (flex_int16_t const   )(short)19,      (flex_int16_t const   )(short)20,      (flex_int16_t const   )(short)21,      (flex_int16_t const   )(short)22, 
        (flex_int16_t const   )(short)90,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)91,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)95, 
        (flex_int16_t const   )(short)96,      (flex_int16_t const   )(short)87,      (flex_int16_t const   )(short)85,      (flex_int16_t const   )(short)94, 
        (flex_int16_t const   )(short)98,      (flex_int16_t const   )(short)88,      (flex_int16_t const   )(short)23,      (flex_int16_t const   )(short)96, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)23,      (flex_int16_t const   )(short)97, 
        (flex_int16_t const   )(short)159,      (flex_int16_t const   )(short)97,      (flex_int16_t const   )(short)102,      (flex_int16_t const   )(short)17, 
        (flex_int16_t const   )(short)96,      (flex_int16_t const   )(short)101,      (flex_int16_t const   )(short)203,      (flex_int16_t const   )(short)116, 
        (flex_int16_t const   )(short)17,      (flex_int16_t const   )(short)117,      (flex_int16_t const   )(short)375,      (flex_int16_t const   )(short)98, 
        (flex_int16_t const   )(short)94,      (flex_int16_t const   )(short)105,      (flex_int16_t const   )(short)204,      (flex_int16_t const   )(short)96, 
        (flex_int16_t const   )(short)106,      (flex_int16_t const   )(short)24,      (flex_int16_t const   )(short)103,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)24,      (flex_int16_t const   )(short)25,      (flex_int16_t const   )(short)26, 
        (flex_int16_t const   )(short)27,      (flex_int16_t const   )(short)28,      (flex_int16_t const   )(short)25,      (flex_int16_t const   )(short)25, 
        (flex_int16_t const   )(short)25,      (flex_int16_t const   )(short)29,      (flex_int16_t const   )(short)25,      (flex_int16_t const   )(short)30, 
        (flex_int16_t const   )(short)31,      (flex_int16_t const   )(short)32,      (flex_int16_t const   )(short)25,      (flex_int16_t const   )(short)33, 
        (flex_int16_t const   )(short)34,      (flex_int16_t const   )(short)35,      (flex_int16_t const   )(short)36,      (flex_int16_t const   )(short)34, 
        (flex_int16_t const   )(short)34,      (flex_int16_t const   )(short)34,      (flex_int16_t const   )(short)37,      (flex_int16_t const   )(short)38, 
        (flex_int16_t const   )(short)34,      (flex_int16_t const   )(short)34,      (flex_int16_t const   )(short)34,      (flex_int16_t const   )(short)34, 
        (flex_int16_t const   )(short)25,      (flex_int16_t const   )(short)39,      (flex_int16_t const   )(short)25,      (flex_int16_t const   )(short)33, 
        (flex_int16_t const   )(short)34,      (flex_int16_t const   )(short)35,      (flex_int16_t const   )(short)36,      (flex_int16_t const   )(short)34, 
        (flex_int16_t const   )(short)40,      (flex_int16_t const   )(short)34,      (flex_int16_t const   )(short)41,      (flex_int16_t const   )(short)34, 
        (flex_int16_t const   )(short)42,      (flex_int16_t const   )(short)34,      (flex_int16_t const   )(short)43,      (flex_int16_t const   )(short)38, 
        (flex_int16_t const   )(short)44,      (flex_int16_t const   )(short)34,      (flex_int16_t const   )(short)34,      (flex_int16_t const   )(short)34, 
        (flex_int16_t const   )(short)45,      (flex_int16_t const   )(short)34,      (flex_int16_t const   )(short)34,      (flex_int16_t const   )(short)46, 
        (flex_int16_t const   )(short)47,      (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)49,      (flex_int16_t const   )(short)50, 
        (flex_int16_t const   )(short)51,      (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)52, 
        (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)54,      (flex_int16_t const   )(short)55, 
        (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)56,      (flex_int16_t const   )(short)57,      (flex_int16_t const   )(short)58, 
        (flex_int16_t const   )(short)59,      (flex_int16_t const   )(short)60,      (flex_int16_t const   )(short)58,      (flex_int16_t const   )(short)58, 
        (flex_int16_t const   )(short)58,      (flex_int16_t const   )(short)61,      (flex_int16_t const   )(short)62,      (flex_int16_t const   )(short)58, 
        (flex_int16_t const   )(short)58,      (flex_int16_t const   )(short)58,      (flex_int16_t const   )(short)58,      (flex_int16_t const   )(short)48, 
        (flex_int16_t const   )(short)63,      (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)57,      (flex_int16_t const   )(short)58, 
        (flex_int16_t const   )(short)59,      (flex_int16_t const   )(short)60,      (flex_int16_t const   )(short)58,      (flex_int16_t const   )(short)58, 
        (flex_int16_t const   )(short)58,      (flex_int16_t const   )(short)58,      (flex_int16_t const   )(short)58,      (flex_int16_t const   )(short)58, 
        (flex_int16_t const   )(short)58,      (flex_int16_t const   )(short)61,      (flex_int16_t const   )(short)62,      (flex_int16_t const   )(short)58, 
        (flex_int16_t const   )(short)58,      (flex_int16_t const   )(short)58,      (flex_int16_t const   )(short)58,      (flex_int16_t const   )(short)58, 
        (flex_int16_t const   )(short)58,      (flex_int16_t const   )(short)58,      (flex_int16_t const   )(short)58,      (flex_int16_t const   )(short)64, 
        (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)65,      (flex_int16_t const   )(short)66,      (flex_int16_t const   )(short)67, 
        (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)68,      (flex_int16_t const   )(short)69, 
        (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)70,      (flex_int16_t const   )(short)48, 
        (flex_int16_t const   )(short)71,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)95, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)120,      (flex_int16_t const   )(short)120,      (flex_int16_t const   )(short)90, 
        (flex_int16_t const   )(short)98,      (flex_int16_t const   )(short)152,      (flex_int16_t const   )(short)122,      (flex_int16_t const   )(short)116, 
        (flex_int16_t const   )(short)374,      (flex_int16_t const   )(short)168,      (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)73, 
        (flex_int16_t const   )(short)96,      (flex_int16_t const   )(short)97,      (flex_int16_t const   )(short)74,      (flex_int16_t const   )(short)120, 
        (flex_int16_t const   )(short)163,      (flex_int16_t const   )(short)123,      (flex_int16_t const   )(short)114,      (flex_int16_t const   )(short)114, 
        (flex_int16_t const   )(short)373,      (flex_int16_t const   )(short)164,      (flex_int16_t const   )(short)122,      (flex_int16_t const   )(short)104, 
        (flex_int16_t const   )(short)75,      (flex_int16_t const   )(short)126,      (flex_int16_t const   )(short)189,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)190,      (flex_int16_t const   )(short)121,      (flex_int16_t const   )(short)127,      (flex_int16_t const   )(short)107, 
        (flex_int16_t const   )(short)114,      (flex_int16_t const   )(short)96,      (flex_int16_t const   )(short)76,      (flex_int16_t const   )(short)48, 
        (flex_int16_t const   )(short)65,      (flex_int16_t const   )(short)66,      (flex_int16_t const   )(short)67,      (flex_int16_t const   )(short)48, 
        (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)68,      (flex_int16_t const   )(short)69,      (flex_int16_t const   )(short)48, 
        (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)70,      (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)71, 
        (flex_int16_t const   )(short)108,      (flex_int16_t const   )(short)120,      (flex_int16_t const   )(short)121,      (flex_int16_t const   )(short)128, 
        (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)109,      (flex_int16_t const   )(short)120,      (flex_int16_t const   )(short)141, 
        (flex_int16_t const   )(short)120,      (flex_int16_t const   )(short)142,      (flex_int16_t const   )(short)122,      (flex_int16_t const   )(short)110, 
        (flex_int16_t const   )(short)158,      (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)73,      (flex_int16_t const   )(short)124, 
        (flex_int16_t const   )(short)123,      (flex_int16_t const   )(short)74,      (flex_int16_t const   )(short)114,      (flex_int16_t const   )(short)141, 
        (flex_int16_t const   )(short)122,      (flex_int16_t const   )(short)123,      (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)114, 
        (flex_int16_t const   )(short)142,      (flex_int16_t const   )(short)114,      (flex_int16_t const   )(short)111,      (flex_int16_t const   )(short)75, 
        (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)122,      (flex_int16_t const   )(short)141, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)142,      (flex_int16_t const   )(short)124,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)76,      (flex_int16_t const   )(short)82,      (flex_int16_t const   )(short)83, 
        (flex_int16_t const   )(short)84,      (flex_int16_t const   )(short)122,      (flex_int16_t const   )(short)131,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)120,      (flex_int16_t const   )(short)154,      (flex_int16_t const   )(short)370,      (flex_int16_t const   )(short)155, 
        (flex_int16_t const   )(short)155,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)367,      (flex_int16_t const   )(short)133, 
        (flex_int16_t const   )(short)108,      (flex_int16_t const   )(short)126,      (flex_int16_t const   )(short)361,      (flex_int16_t const   )(short)145, 
        (flex_int16_t const   )(short)157,      (flex_int16_t const   )(short)109,      (flex_int16_t const   )(short)127,      (flex_int16_t const   )(short)120, 
        (flex_int16_t const   )(short)120,      (flex_int16_t const   )(short)114,      (flex_int16_t const   )(short)146,      (flex_int16_t const   )(short)110, 
        (flex_int16_t const   )(short)85,      (flex_int16_t const   )(short)134,      (flex_int16_t const   )(short)154,      (flex_int16_t const   )(short)135, 
        (flex_int16_t const   )(short)155,      (flex_int16_t const   )(short)160,      (flex_int16_t const   )(short)136,      (flex_int16_t const   )(short)162, 
        (flex_int16_t const   )(short)170,      (flex_int16_t const   )(short)161,      (flex_int16_t const   )(short)120,      (flex_int16_t const   )(short)137, 
        (flex_int16_t const   )(short)114,      (flex_int16_t const   )(short)114,      (flex_int16_t const   )(short)111,      (flex_int16_t const   )(short)128, 
        (flex_int16_t const   )(short)138,      (flex_int16_t const   )(short)192,      (flex_int16_t const   )(short)139,      (flex_int16_t const   )(short)193, 
        (flex_int16_t const   )(short)173,      (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)171,      (flex_int16_t const   )(short)174, 
        (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)179,      (flex_int16_t const   )(short)142,      (flex_int16_t const   )(short)114, 
        (flex_int16_t const   )(short)175,      (flex_int16_t const   )(short)170,      (flex_int16_t const   )(short)364,      (flex_int16_t const   )(short)141, 
        (flex_int16_t const   )(short)176,      (flex_int16_t const   )(short)177,      (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)178, 
        (flex_int16_t const   )(short)142,      (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)153,      (flex_int16_t const   )(short)192, 
        (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)142,      (flex_int16_t const   )(short)171, 
        (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)142,      (flex_int16_t const   )(short)181, 
        (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)142,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)142,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)182,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)142,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)142,      (flex_int16_t const   )(short)197, 
        (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)142,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)145,      (flex_int16_t const   )(short)142,      (flex_int16_t const   )(short)141, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)194,      (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)195, 
        (flex_int16_t const   )(short)142,      (flex_int16_t const   )(short)196,      (flex_int16_t const   )(short)199,      (flex_int16_t const   )(short)146, 
        (flex_int16_t const   )(short)163,      (flex_int16_t const   )(short)107,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)197, 
        (flex_int16_t const   )(short)107,      (flex_int16_t const   )(short)164,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)205, 
        (flex_int16_t const   )(short)208,      (flex_int16_t const   )(short)206,      (flex_int16_t const   )(short)209,      (flex_int16_t const   )(short)169, 
        (flex_int16_t const   )(short)208,      (flex_int16_t const   )(short)197,      (flex_int16_t const   )(short)186,      (flex_int16_t const   )(short)120, 
        (flex_int16_t const   )(short)181,      (flex_int16_t const   )(short)196,      (flex_int16_t const   )(short)198,      (flex_int16_t const   )(short)185, 
        (flex_int16_t const   )(short)210,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)211,      (flex_int16_t const   )(short)120, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)212,      (flex_int16_t const   )(short)201,      (flex_int16_t const   )(short)225, 
        (flex_int16_t const   )(short)189,      (flex_int16_t const   )(short)237,      (flex_int16_t const   )(short)233,      (flex_int16_t const   )(short)213, 
        (flex_int16_t const   )(short)114,      (flex_int16_t const   )(short)197,      (flex_int16_t const   )(short)221,      (flex_int16_t const   )(short)222, 
        (flex_int16_t const   )(short)200,      (flex_int16_t const   )(short)221,      (flex_int16_t const   )(short)202,      (flex_int16_t const   )(short)223, 
        (flex_int16_t const   )(short)114,      (flex_int16_t const   )(short)183,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)163, 
        (flex_int16_t const   )(short)183,      (flex_int16_t const   )(short)212,      (flex_int16_t const   )(short)142,      (flex_int16_t const   )(short)141, 
        (flex_int16_t const   )(short)164,      (flex_int16_t const   )(short)237,      (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)213, 
        (flex_int16_t const   )(short)142,      (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)239,      (flex_int16_t const   )(short)192, 
        (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)193,      (flex_int16_t const   )(short)142,      (flex_int16_t const   )(short)194, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)236,      (flex_int16_t const   )(short)238,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)205,      (flex_int16_t const   )(short)208,      (flex_int16_t const   )(short)246, 
        (flex_int16_t const   )(short)209,      (flex_int16_t const   )(short)240,      (flex_int16_t const   )(short)210,      (flex_int16_t const   )(short)266, 
        (flex_int16_t const   )(short)249,      (flex_int16_t const   )(short)267,      (flex_int16_t const   )(short)120,      (flex_int16_t const   )(short)120, 
        (flex_int16_t const   )(short)361,      (flex_int16_t const   )(short)251,      (flex_int16_t const   )(short)238,      (flex_int16_t const   )(short)192, 
        (flex_int16_t const   )(short)234,      (flex_int16_t const   )(short)107,      (flex_int16_t const   )(short)250,      (flex_int16_t const   )(short)360, 
        (flex_int16_t const   )(short)268,      (flex_int16_t const   )(short)242,      (flex_int16_t const   )(short)269,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)228,      (flex_int16_t const   )(short)229,      (flex_int16_t const   )(short)358,      (flex_int16_t const   )(short)114, 
        (flex_int16_t const   )(short)114,      (flex_int16_t const   )(short)251,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)241, 
        (flex_int16_t const   )(short)221,      (flex_int16_t const   )(short)222,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)221, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)223,      (flex_int16_t const   )(short)250,      (flex_int16_t const   )(short)221, 
        (flex_int16_t const   )(short)222,      (flex_int16_t const   )(short)271,      (flex_int16_t const   )(short)221,      (flex_int16_t const   )(short)261, 
        (flex_int16_t const   )(short)223,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)261,      (flex_int16_t const   )(short)141, 
        (flex_int16_t const   )(short)142,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)141, 
        (flex_int16_t const   )(short)142,      (flex_int16_t const   )(short)355,      (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)270, 
        (flex_int16_t const   )(short)142,      (flex_int16_t const   )(short)107,      (flex_int16_t const   )(short)272,      (flex_int16_t const   )(short)120, 
        (flex_int16_t const   )(short)274,      (flex_int16_t const   )(short)271,      (flex_int16_t const   )(short)277,      (flex_int16_t const   )(short)120, 
        (flex_int16_t const   )(short)278,      (flex_int16_t const   )(short)208,      (flex_int16_t const   )(short)247,      (flex_int16_t const   )(short)273, 
        (flex_int16_t const   )(short)279,      (flex_int16_t const   )(short)281,      (flex_int16_t const   )(short)280,      (flex_int16_t const   )(short)266, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)292,      (flex_int16_t const   )(short)282,      (flex_int16_t const   )(short)270, 
        (flex_int16_t const   )(short)114,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)259,      (flex_int16_t const   )(short)260, 
        (flex_int16_t const   )(short)114,      (flex_int16_t const   )(short)259,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)142, 
        (flex_int16_t const   )(short)263,      (flex_int16_t const   )(short)264,      (flex_int16_t const   )(short)295,      (flex_int16_t const   )(short)261, 
        (flex_int16_t const   )(short)261,      (flex_int16_t const   )(short)281,      (flex_int16_t const   )(short)261,      (flex_int16_t const   )(short)261, 
        (flex_int16_t const   )(short)142,      (flex_int16_t const   )(short)142,      (flex_int16_t const   )(short)282,      (flex_int16_t const   )(short)141, 
        (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)141, 
        (flex_int16_t const   )(short)142,      (flex_int16_t const   )(short)142,      (flex_int16_t const   )(short)268,      (flex_int16_t const   )(short)120, 
        (flex_int16_t const   )(short)294,      (flex_int16_t const   )(short)107,      (flex_int16_t const   )(short)296,      (flex_int16_t const   )(short)295, 
        (flex_int16_t const   )(short)277,      (flex_int16_t const   )(short)279,      (flex_int16_t const   )(short)300,      (flex_int16_t const   )(short)302, 
        (flex_int16_t const   )(short)351,      (flex_int16_t const   )(short)120,      (flex_int16_t const   )(short)107,      (flex_int16_t const   )(short)323, 
        (flex_int16_t const   )(short)313,      (flex_int16_t const   )(short)303,      (flex_int16_t const   )(short)314,      (flex_int16_t const   )(short)320, 
        (flex_int16_t const   )(short)114,      (flex_int16_t const   )(short)289,      (flex_int16_t const   )(short)304,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)310,      (flex_int16_t const   )(short)260,      (flex_int16_t const   )(short)296,      (flex_int16_t const   )(short)310, 
        (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)142,      (flex_int16_t const   )(short)114,      (flex_int16_t const   )(short)141, 
        (flex_int16_t const   )(short)317,      (flex_int16_t const   )(short)142,      (flex_int16_t const   )(short)315,      (flex_int16_t const   )(short)316, 
        (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)290,      (flex_int16_t const   )(short)303,      (flex_int16_t const   )(short)141, 
        (flex_int16_t const   )(short)120,      (flex_int16_t const   )(short)142,      (flex_int16_t const   )(short)304,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)320,      (flex_int16_t const   )(short)318,      (flex_int16_t const   )(short)321,      (flex_int16_t const   )(short)322, 
        (flex_int16_t const   )(short)323,      (flex_int16_t const   )(short)324,      (flex_int16_t const   )(short)332,      (flex_int16_t const   )(short)316, 
        (flex_int16_t const   )(short)317,      (flex_int16_t const   )(short)120,      (flex_int16_t const   )(short)313,      (flex_int16_t const   )(short)325, 
        (flex_int16_t const   )(short)331,      (flex_int16_t const   )(short)114,      (flex_int16_t const   )(short)316,      (flex_int16_t const   )(short)310, 
        (flex_int16_t const   )(short)260,      (flex_int16_t const   )(short)318,      (flex_int16_t const   )(short)310,      (flex_int16_t const   )(short)141, 
        (flex_int16_t const   )(short)142,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)313, 
        (flex_int16_t const   )(short)142,      (flex_int16_t const   )(short)324,      (flex_int16_t const   )(short)114,      (flex_int16_t const   )(short)325, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)312,      (flex_int16_t const   )(short)310,      (flex_int16_t const   )(short)260, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)310,      (flex_int16_t const   )(short)334,      (flex_int16_t const   )(short)142, 
        (flex_int16_t const   )(short)335,      (flex_int16_t const   )(short)320,      (flex_int16_t const   )(short)96,      (flex_int16_t const   )(short)337, 
        (flex_int16_t const   )(short)338,      (flex_int16_t const   )(short)323,      (flex_int16_t const   )(short)120,      (flex_int16_t const   )(short)141, 
        (flex_int16_t const   )(short)120,      (flex_int16_t const   )(short)329,      (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)344, 
        (flex_int16_t const   )(short)142,      (flex_int16_t const   )(short)352,      (flex_int16_t const   )(short)341,      (flex_int16_t const   )(short)192, 
        (flex_int16_t const   )(short)345,      (flex_int16_t const   )(short)346,      (flex_int16_t const   )(short)96,      (flex_int16_t const   )(short)334, 
        (flex_int16_t const   )(short)335,      (flex_int16_t const   )(short)340,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)114, 
        (flex_int16_t const   )(short)353,      (flex_int16_t const   )(short)114,      (flex_int16_t const   )(short)333,      (flex_int16_t const   )(short)192, 
        (flex_int16_t const   )(short)339,      (flex_int16_t const   )(short)208,      (flex_int16_t const   )(short)347,      (flex_int16_t const   )(short)208, 
        (flex_int16_t const   )(short)348,      (flex_int16_t const   )(short)349,      (flex_int16_t const   )(short)341,      (flex_int16_t const   )(short)120, 
        (flex_int16_t const   )(short)352,      (flex_int16_t const   )(short)343,      (flex_int16_t const   )(short)120,      (flex_int16_t const   )(short)192, 
        (flex_int16_t const   )(short)354,      (flex_int16_t const   )(short)346,      (flex_int16_t const   )(short)340,      (flex_int16_t const   )(short)350, 
        (flex_int16_t const   )(short)122,      (flex_int16_t const   )(short)342,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)353, 
        (flex_int16_t const   )(short)356,      (flex_int16_t const   )(short)120,      (flex_int16_t const   )(short)347,      (flex_int16_t const   )(short)359, 
        (flex_int16_t const   )(short)114,      (flex_int16_t const   )(short)192,      (flex_int16_t const   )(short)355,      (flex_int16_t const   )(short)114, 
        (flex_int16_t const   )(short)208,      (flex_int16_t const   )(short)357,      (flex_int16_t const   )(short)349,      (flex_int16_t const   )(short)192, 
        (flex_int16_t const   )(short)122,      (flex_int16_t const   )(short)346,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)350, 
        (flex_int16_t const   )(short)356,      (flex_int16_t const   )(short)120,      (flex_int16_t const   )(short)114,      (flex_int16_t const   )(short)359, 
        (flex_int16_t const   )(short)208,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)349,      (flex_int16_t const   )(short)208, 
        (flex_int16_t const   )(short)358,      (flex_int16_t const   )(short)362,      (flex_int16_t const   )(short)120,      (flex_int16_t const   )(short)339, 
        (flex_int16_t const   )(short)363,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)365,      (flex_int16_t const   )(short)368, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)336,      (flex_int16_t const   )(short)114,      (flex_int16_t const   )(short)366, 
        (flex_int16_t const   )(short)120,      (flex_int16_t const   )(short)276,      (flex_int16_t const   )(short)369,      (flex_int16_t const   )(short)333, 
        (flex_int16_t const   )(short)371,      (flex_int16_t const   )(short)120,      (flex_int16_t const   )(short)330,      (flex_int16_t const   )(short)114, 
        (flex_int16_t const   )(short)328,      (flex_int16_t const   )(short)362,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)368, 
        (flex_int16_t const   )(short)363,      (flex_int16_t const   )(short)372,      (flex_int16_t const   )(short)365,      (flex_int16_t const   )(short)327, 
        (flex_int16_t const   )(short)96,      (flex_int16_t const   )(short)114,      (flex_int16_t const   )(short)369,      (flex_int16_t const   )(short)366, 
        (flex_int16_t const   )(short)120,      (flex_int16_t const   )(short)326,      (flex_int16_t const   )(short)114,      (flex_int16_t const   )(short)279, 
        (flex_int16_t const   )(short)371,      (flex_int16_t const   )(short)277,      (flex_int16_t const   )(short)122,      (flex_int16_t const   )(short)319, 
        (flex_int16_t const   )(short)268,      (flex_int16_t const   )(short)266,      (flex_int16_t const   )(short)309,      (flex_int16_t const   )(short)308, 
        (flex_int16_t const   )(short)96,      (flex_int16_t const   )(short)372,      (flex_int16_t const   )(short)307,      (flex_int16_t const   )(short)306, 
        (flex_int16_t const   )(short)305,      (flex_int16_t const   )(short)114,      (flex_int16_t const   )(short)301,      (flex_int16_t const   )(short)299, 
        (flex_int16_t const   )(short)298,      (flex_int16_t const   )(short)297,      (flex_int16_t const   )(short)122,      (flex_int16_t const   )(short)12, 
        (flex_int16_t const   )(short)12,      (flex_int16_t const   )(short)12,      (flex_int16_t const   )(short)12,      (flex_int16_t const   )(short)12, 
        (flex_int16_t const   )(short)12,      (flex_int16_t const   )(short)12,      (flex_int16_t const   )(short)12,      (flex_int16_t const   )(short)12, 
        (flex_int16_t const   )(short)12,      (flex_int16_t const   )(short)12,      (flex_int16_t const   )(short)18,      (flex_int16_t const   )(short)18, 
        (flex_int16_t const   )(short)18,      (flex_int16_t const   )(short)18,      (flex_int16_t const   )(short)18,      (flex_int16_t const   )(short)18, 
        (flex_int16_t const   )(short)18,      (flex_int16_t const   )(short)18,      (flex_int16_t const   )(short)18,      (flex_int16_t const   )(short)18, 
        (flex_int16_t const   )(short)18,      (flex_int16_t const   )(short)72,      (flex_int16_t const   )(short)72,      (flex_int16_t const   )(short)72, 
        (flex_int16_t const   )(short)72,      (flex_int16_t const   )(short)72,      (flex_int16_t const   )(short)72,      (flex_int16_t const   )(short)72, 
        (flex_int16_t const   )(short)72,      (flex_int16_t const   )(short)72,      (flex_int16_t const   )(short)72,      (flex_int16_t const   )(short)72, 
        (flex_int16_t const   )(short)78,      (flex_int16_t const   )(short)78,      (flex_int16_t const   )(short)293,      (flex_int16_t const   )(short)78, 
        (flex_int16_t const   )(short)78,      (flex_int16_t const   )(short)78,      (flex_int16_t const   )(short)78,      (flex_int16_t const   )(short)78, 
        (flex_int16_t const   )(short)78,      (flex_int16_t const   )(short)78,      (flex_int16_t const   )(short)78,      (flex_int16_t const   )(short)81, 
        (flex_int16_t const   )(short)81,      (flex_int16_t const   )(short)291,      (flex_int16_t const   )(short)81,      (flex_int16_t const   )(short)81, 
        (flex_int16_t const   )(short)81,      (flex_int16_t const   )(short)81,      (flex_int16_t const   )(short)81,      (flex_int16_t const   )(short)81, 
        (flex_int16_t const   )(short)81,      (flex_int16_t const   )(short)81,      (flex_int16_t const   )(short)92,      (flex_int16_t const   )(short)92, 
        (flex_int16_t const   )(short)287,      (flex_int16_t const   )(short)92,      (flex_int16_t const   )(short)92,      (flex_int16_t const   )(short)286, 
        (flex_int16_t const   )(short)92,      (flex_int16_t const   )(short)99,      (flex_int16_t const   )(short)99,      (flex_int16_t const   )(short)99, 
        (flex_int16_t const   )(short)99,      (flex_int16_t const   )(short)99,      (flex_int16_t const   )(short)99,      (flex_int16_t const   )(short)99, 
        (flex_int16_t const   )(short)99,      (flex_int16_t const   )(short)99,      (flex_int16_t const   )(short)99,      (flex_int16_t const   )(short)99, 
        (flex_int16_t const   )(short)114,      (flex_int16_t const   )(short)114,      (flex_int16_t const   )(short)285,      (flex_int16_t const   )(short)114, 
        (flex_int16_t const   )(short)176,      (flex_int16_t const   )(short)284,      (flex_int16_t const   )(short)114,      (flex_int16_t const   )(short)114, 
        (flex_int16_t const   )(short)119,      (flex_int16_t const   )(short)119,      (flex_int16_t const   )(short)283,      (flex_int16_t const   )(short)119, 
        (flex_int16_t const   )(short)119,      (flex_int16_t const   )(short)210,      (flex_int16_t const   )(short)119,      (flex_int16_t const   )(short)119, 
        (flex_int16_t const   )(short)132,      (flex_int16_t const   )(short)205,      (flex_int16_t const   )(short)276,      (flex_int16_t const   )(short)275, 
        (flex_int16_t const   )(short)194,      (flex_int16_t const   )(short)189,      (flex_int16_t const   )(short)132,      (flex_int16_t const   )(short)132, 
        (flex_int16_t const   )(short)143,      (flex_int16_t const   )(short)265,      (flex_int16_t const   )(short)226,      (flex_int16_t const   )(short)143, 
        (flex_int16_t const   )(short)226,      (flex_int16_t const   )(short)143,      (flex_int16_t const   )(short)143,      (flex_int16_t const   )(short)143, 
        (flex_int16_t const   )(short)150,      (flex_int16_t const   )(short)260,      (flex_int16_t const   )(short)258,      (flex_int16_t const   )(short)150, 
        (flex_int16_t const   )(short)166,      (flex_int16_t const   )(short)258,      (flex_int16_t const   )(short)257,      (flex_int16_t const   )(short)166, 
        (flex_int16_t const   )(short)180,      (flex_int16_t const   )(short)256,      (flex_int16_t const   )(short)180,      (flex_int16_t const   )(short)255, 
        (flex_int16_t const   )(short)254,      (flex_int16_t const   )(short)180,      (flex_int16_t const   )(short)253,      (flex_int16_t const   )(short)180, 
        (flex_int16_t const   )(short)180,      (flex_int16_t const   )(short)180,      (flex_int16_t const   )(short)183,      (flex_int16_t const   )(short)252, 
        (flex_int16_t const   )(short)248,      (flex_int16_t const   )(short)183,      (flex_int16_t const   )(short)247,      (flex_int16_t const   )(short)245, 
        (flex_int16_t const   )(short)183,      (flex_int16_t const   )(short)183,      (flex_int16_t const   )(short)191,      (flex_int16_t const   )(short)191, 
        (flex_int16_t const   )(short)191,      (flex_int16_t const   )(short)191,      (flex_int16_t const   )(short)191,      (flex_int16_t const   )(short)244, 
        (flex_int16_t const   )(short)191,      (flex_int16_t const   )(short)207,      (flex_int16_t const   )(short)207,      (flex_int16_t const   )(short)207, 
        (flex_int16_t const   )(short)207,      (flex_int16_t const   )(short)207,      (flex_int16_t const   )(short)243,      (flex_int16_t const   )(short)207, 
        (flex_int16_t const   )(short)220,      (flex_int16_t const   )(short)235,      (flex_int16_t const   )(short)234,      (flex_int16_t const   )(short)232, 
        (flex_int16_t const   )(short)231,      (flex_int16_t const   )(short)230,      (flex_int16_t const   )(short)184,      (flex_int16_t const   )(short)226, 
        (flex_int16_t const   )(short)220,      (flex_int16_t const   )(short)220,      (flex_int16_t const   )(short)224,      (flex_int16_t const   )(short)224, 
        (flex_int16_t const   )(short)179,      (flex_int16_t const   )(short)224,      (flex_int16_t const   )(short)219,      (flex_int16_t const   )(short)224, 
        (flex_int16_t const   )(short)224,      (flex_int16_t const   )(short)224,      (flex_int16_t const   )(short)227,      (flex_int16_t const   )(short)218, 
        (flex_int16_t const   )(short)217,      (flex_int16_t const   )(short)227,      (flex_int16_t const   )(short)216,      (flex_int16_t const   )(short)227, 
        (flex_int16_t const   )(short)227,      (flex_int16_t const   )(short)227,      (flex_int16_t const   )(short)222,      (flex_int16_t const   )(short)222, 
        (flex_int16_t const   )(short)215,      (flex_int16_t const   )(short)222,      (flex_int16_t const   )(short)214,      (flex_int16_t const   )(short)222, 
        (flex_int16_t const   )(short)222,      (flex_int16_t const   )(short)222,      (flex_int16_t const   )(short)259,      (flex_int16_t const   )(short)259, 
        (flex_int16_t const   )(short)172,      (flex_int16_t const   )(short)259,      (flex_int16_t const   )(short)116,      (flex_int16_t const   )(short)153, 
        (flex_int16_t const   )(short)259,      (flex_int16_t const   )(short)259,      (flex_int16_t const   )(short)262,      (flex_int16_t const   )(short)156, 
        (flex_int16_t const   )(short)90,      (flex_int16_t const   )(short)262,      (flex_int16_t const   )(short)188,      (flex_int16_t const   )(short)262, 
        (flex_int16_t const   )(short)262,      (flex_int16_t const   )(short)262,      (flex_int16_t const   )(short)260,      (flex_int16_t const   )(short)260, 
        (flex_int16_t const   )(short)187,      (flex_int16_t const   )(short)260,      (flex_int16_t const   )(short)184,      (flex_int16_t const   )(short)140, 
        (flex_int16_t const   )(short)260,      (flex_int16_t const   )(short)260,      (flex_int16_t const   )(short)288,      (flex_int16_t const   )(short)288, 
        (flex_int16_t const   )(short)130,      (flex_int16_t const   )(short)288,      (flex_int16_t const   )(short)144,      (flex_int16_t const   )(short)288, 
        (flex_int16_t const   )(short)288,      (flex_int16_t const   )(short)288,      (flex_int16_t const   )(short)311,      (flex_int16_t const   )(short)311, 
        (flex_int16_t const   )(short)130,      (flex_int16_t const   )(short)311,      (flex_int16_t const   )(short)172,      (flex_int16_t const   )(short)311, 
        (flex_int16_t const   )(short)311,      (flex_int16_t const   )(short)311,      (flex_int16_t const   )(short)169,      (flex_int16_t const   )(short)118, 
        (flex_int16_t const   )(short)167,      (flex_int16_t const   )(short)165,      (flex_int16_t const   )(short)113,      (flex_int16_t const   )(short)125, 
        (flex_int16_t const   )(short)113,      (flex_int16_t const   )(short)156,      (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)153, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)151,      (flex_int16_t const   )(short)149,      (flex_int16_t const   )(short)148, 
        (flex_int16_t const   )(short)147,      (flex_int16_t const   )(short)100,      (flex_int16_t const   )(short)83,      (flex_int16_t const   )(short)79, 
        (flex_int16_t const   )(short)144,      (flex_int16_t const   )(short)140,      (flex_int16_t const   )(short)130,      (flex_int16_t const   )(short)129, 
        (flex_int16_t const   )(short)125,      (flex_int16_t const   )(short)118,      (flex_int16_t const   )(short)115,      (flex_int16_t const   )(short)113, 
        (flex_int16_t const   )(short)112,      (flex_int16_t const   )(short)100,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)89, 
        (flex_int16_t const   )(short)86,      (flex_int16_t const   )(short)80,      (flex_int16_t const   )(short)79,      (flex_int16_t const   )(short)77, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376};
#line 716 "master_tok.c"
static flex_int16_t const   yy_chk[1061]  = 
#line 716
  {      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)1, 
        (flex_int16_t const   )(short)1,      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)1,      (flex_int16_t const   )(short)0, 
        (flex_int16_t const   )(short)2,      (flex_int16_t const   )(short)2,      (flex_int16_t const   )(short)1,      (flex_int16_t const   )(short)2, 
        (flex_int16_t const   )(short)26,      (flex_int16_t const   )(short)26,      (flex_int16_t const   )(short)26,      (flex_int16_t const   )(short)2, 
        (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)3, 
        (flex_int16_t const   )(short)4,      (flex_int16_t const   )(short)4,      (flex_int16_t const   )(short)4,      (flex_int16_t const   )(short)4, 
        (flex_int16_t const   )(short)31,      (flex_int16_t const   )(short)33,      (flex_int16_t const   )(short)31,      (flex_int16_t const   )(short)40, 
        (flex_int16_t const   )(short)41,      (flex_int16_t const   )(short)44,      (flex_int16_t const   )(short)103,      (flex_int16_t const   )(short)45, 
        (flex_int16_t const   )(short)36,      (flex_int16_t const   )(short)37,      (flex_int16_t const   )(short)35,      (flex_int16_t const   )(short)35, 
        (flex_int16_t const   )(short)36,      (flex_int16_t const   )(short)29,      (flex_int16_t const   )(short)26,      (flex_int16_t const   )(short)33, 
        (flex_int16_t const   )(short)37,      (flex_int16_t const   )(short)29,      (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)35, 
        (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)42,      (flex_int16_t const   )(short)4,      (flex_int16_t const   )(short)36, 
        (flex_int16_t const   )(short)103,      (flex_int16_t const   )(short)35,      (flex_int16_t const   )(short)41,      (flex_int16_t const   )(short)1, 
        (flex_int16_t const   )(short)36,      (flex_int16_t const   )(short)40,      (flex_int16_t const   )(short)163,      (flex_int16_t const   )(short)55, 
        (flex_int16_t const   )(short)2,      (flex_int16_t const   )(short)55,      (flex_int16_t const   )(short)374,      (flex_int16_t const   )(short)37, 
        (flex_int16_t const   )(short)33,      (flex_int16_t const   )(short)44,      (flex_int16_t const   )(short)163,      (flex_int16_t const   )(short)35, 
        (flex_int16_t const   )(short)45,      (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)42,      (flex_int16_t const   )(short)96, 
        (flex_int16_t const   )(short)96,      (flex_int16_t const   )(short)4,      (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)5, 
        (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)5, 
        (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)5, 
        (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)5, 
        (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)5, 
        (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)5, 
        (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)5, 
        (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)5, 
        (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)5, 
        (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)5, 
        (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)5, 
        (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)5, 
        (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)5, 
        (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)7, 
        (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)7, 
        (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)7, 
        (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)7, 
        (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)7, 
        (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)7, 
        (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)7, 
        (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)7, 
        (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)7, 
        (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)7, 
        (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)7, 
        (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)7, 
        (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)7, 
        (flex_int16_t const   )(short)9,      (flex_int16_t const   )(short)9,      (flex_int16_t const   )(short)9,      (flex_int16_t const   )(short)9, 
        (flex_int16_t const   )(short)9,      (flex_int16_t const   )(short)9,      (flex_int16_t const   )(short)9,      (flex_int16_t const   )(short)9, 
        (flex_int16_t const   )(short)9,      (flex_int16_t const   )(short)9,      (flex_int16_t const   )(short)9,      (flex_int16_t const   )(short)9, 
        (flex_int16_t const   )(short)9,      (flex_int16_t const   )(short)43,      (flex_int16_t const   )(short)38,      (flex_int16_t const   )(short)38, 
        (flex_int16_t const   )(short)46,      (flex_int16_t const   )(short)58,      (flex_int16_t const   )(short)60,      (flex_int16_t const   )(short)91, 
        (flex_int16_t const   )(short)43,      (flex_int16_t const   )(short)91,      (flex_int16_t const   )(short)60,      (flex_int16_t const   )(short)117, 
        (flex_int16_t const   )(short)373,      (flex_int16_t const   )(short)117,      (flex_int16_t const   )(short)9,      (flex_int16_t const   )(short)9, 
        (flex_int16_t const   )(short)38,      (flex_int16_t const   )(short)38,      (flex_int16_t const   )(short)9,      (flex_int16_t const   )(short)57, 
        (flex_int16_t const   )(short)107,      (flex_int16_t const   )(short)60,      (flex_int16_t const   )(short)58,      (flex_int16_t const   )(short)60, 
        (flex_int16_t const   )(short)370,      (flex_int16_t const   )(short)107,      (flex_int16_t const   )(short)60,      (flex_int16_t const   )(short)43, 
        (flex_int16_t const   )(short)9,      (flex_int16_t const   )(short)65,      (flex_int16_t const   )(short)149,      (flex_int16_t const   )(short)102, 
        (flex_int16_t const   )(short)149,      (flex_int16_t const   )(short)57,      (flex_int16_t const   )(short)65,      (flex_int16_t const   )(short)46, 
        (flex_int16_t const   )(short)57,      (flex_int16_t const   )(short)38,      (flex_int16_t const   )(short)9,      (flex_int16_t const   )(short)10, 
        (flex_int16_t const   )(short)10,      (flex_int16_t const   )(short)10,      (flex_int16_t const   )(short)10,      (flex_int16_t const   )(short)10, 
        (flex_int16_t const   )(short)10,      (flex_int16_t const   )(short)10,      (flex_int16_t const   )(short)10,      (flex_int16_t const   )(short)10, 
        (flex_int16_t const   )(short)10,      (flex_int16_t const   )(short)10,      (flex_int16_t const   )(short)10,      (flex_int16_t const   )(short)10, 
        (flex_int16_t const   )(short)49,      (flex_int16_t const   )(short)59,      (flex_int16_t const   )(short)57,      (flex_int16_t const   )(short)65, 
        (flex_int16_t const   )(short)72,      (flex_int16_t const   )(short)49,      (flex_int16_t const   )(short)62,      (flex_int16_t const   )(short)72, 
        (flex_int16_t const   )(short)61,      (flex_int16_t const   )(short)72,      (flex_int16_t const   )(short)59,      (flex_int16_t const   )(short)49, 
        (flex_int16_t const   )(short)102,      (flex_int16_t const   )(short)10,      (flex_int16_t const   )(short)10,      (flex_int16_t const   )(short)61, 
        (flex_int16_t const   )(short)59,      (flex_int16_t const   )(short)10,      (flex_int16_t const   )(short)59,      (flex_int16_t const   )(short)74, 
        (flex_int16_t const   )(short)62,      (flex_int16_t const   )(short)62,      (flex_int16_t const   )(short)74,      (flex_int16_t const   )(short)62, 
        (flex_int16_t const   )(short)74,      (flex_int16_t const   )(short)61,      (flex_int16_t const   )(short)49,      (flex_int16_t const   )(short)10, 
        (flex_int16_t const   )(short)75,      (flex_int16_t const   )(short)101,      (flex_int16_t const   )(short)59,      (flex_int16_t const   )(short)75, 
        (flex_int16_t const   )(short)94,      (flex_int16_t const   )(short)75,      (flex_int16_t const   )(short)61,      (flex_int16_t const   )(short)98, 
        (flex_int16_t const   )(short)104,      (flex_int16_t const   )(short)10,      (flex_int16_t const   )(short)82,      (flex_int16_t const   )(short)82, 
        (flex_int16_t const   )(short)82,      (flex_int16_t const   )(short)62,      (flex_int16_t const   )(short)69,      (flex_int16_t const   )(short)105, 
        (flex_int16_t const   )(short)119,      (flex_int16_t const   )(short)94,      (flex_int16_t const   )(short)367,      (flex_int16_t const   )(short)98, 
        (flex_int16_t const   )(short)104,      (flex_int16_t const   )(short)106,      (flex_int16_t const   )(short)364,      (flex_int16_t const   )(short)69, 
        (flex_int16_t const   )(short)108,      (flex_int16_t const   )(short)126,      (flex_int16_t const   )(short)361,      (flex_int16_t const   )(short)74, 
        (flex_int16_t const   )(short)101,      (flex_int16_t const   )(short)108,      (flex_int16_t const   )(short)126,      (flex_int16_t const   )(short)121, 
        (flex_int16_t const   )(short)122,      (flex_int16_t const   )(short)119,      (flex_int16_t const   )(short)75,      (flex_int16_t const   )(short)108, 
        (flex_int16_t const   )(short)82,      (flex_int16_t const   )(short)69,      (flex_int16_t const   )(short)94,      (flex_int16_t const   )(short)69, 
        (flex_int16_t const   )(short)98,      (flex_int16_t const   )(short)104,      (flex_int16_t const   )(short)69,      (flex_int16_t const   )(short)106, 
        (flex_int16_t const   )(short)121,      (flex_int16_t const   )(short)105,      (flex_int16_t const   )(short)124,      (flex_int16_t const   )(short)69, 
        (flex_int16_t const   )(short)121,      (flex_int16_t const   )(short)122,      (flex_int16_t const   )(short)108,      (flex_int16_t const   )(short)126, 
        (flex_int16_t const   )(short)69,      (flex_int16_t const   )(short)150,      (flex_int16_t const   )(short)69,      (flex_int16_t const   )(short)150, 
        (flex_int16_t const   )(short)131,      (flex_int16_t const   )(short)132,      (flex_int16_t const   )(short)124,      (flex_int16_t const   )(short)131, 
        (flex_int16_t const   )(short)132,      (flex_int16_t const   )(short)133,      (flex_int16_t const   )(short)132,      (flex_int16_t const   )(short)124, 
        (flex_int16_t const   )(short)131,      (flex_int16_t const   )(short)121,      (flex_int16_t const   )(short)360,      (flex_int16_t const   )(short)133, 
        (flex_int16_t const   )(short)131,      (flex_int16_t const   )(short)131,      (flex_int16_t const   )(short)133,      (flex_int16_t const   )(short)131, 
        (flex_int16_t const   )(short)133,      (flex_int16_t const   )(short)134,      (flex_int16_t const   )(short)153,      (flex_int16_t const   )(short)153, 
        (flex_int16_t const   )(short)134,      (flex_int16_t const   )(short)135,      (flex_int16_t const   )(short)134,      (flex_int16_t const   )(short)124, 
        (flex_int16_t const   )(short)135,      (flex_int16_t const   )(short)136,      (flex_int16_t const   )(short)135,      (flex_int16_t const   )(short)138, 
        (flex_int16_t const   )(short)136,      (flex_int16_t const   )(short)137,      (flex_int16_t const   )(short)136,      (flex_int16_t const   )(short)159, 
        (flex_int16_t const   )(short)137,      (flex_int16_t const   )(short)138,      (flex_int16_t const   )(short)137,      (flex_int16_t const   )(short)272, 
        (flex_int16_t const   )(short)138,      (flex_int16_t const   )(short)139,      (flex_int16_t const   )(short)138,      (flex_int16_t const   )(short)155, 
        (flex_int16_t const   )(short)139,      (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)139,      (flex_int16_t const   )(short)157, 
        (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)143,      (flex_int16_t const   )(short)141,      (flex_int16_t const   )(short)155, 
        (flex_int16_t const   )(short)143,      (flex_int16_t const   )(short)145,      (flex_int16_t const   )(short)143,      (flex_int16_t const   )(short)154, 
        (flex_int16_t const   )(short)145,      (flex_int16_t const   )(short)134,      (flex_int16_t const   )(short)145,      (flex_int16_t const   )(short)146, 
        (flex_int16_t const   )(short)158,      (flex_int16_t const   )(short)151,      (flex_int16_t const   )(short)146,      (flex_int16_t const   )(short)151, 
        (flex_int16_t const   )(short)146,      (flex_int16_t const   )(short)154,      (flex_int16_t const   )(short)159,      (flex_int16_t const   )(short)137, 
        (flex_int16_t const   )(short)160,      (flex_int16_t const   )(short)157,      (flex_int16_t const   )(short)161,      (flex_int16_t const   )(short)155, 
        (flex_int16_t const   )(short)272,      (flex_int16_t const   )(short)160,      (flex_int16_t const   )(short)162,      (flex_int16_t const   )(short)165, 
        (flex_int16_t const   )(short)166,      (flex_int16_t const   )(short)165,      (flex_int16_t const   )(short)166,      (flex_int16_t const   )(short)169, 
        (flex_int16_t const   )(short)169,      (flex_int16_t const   )(short)160,      (flex_int16_t const   )(short)146,      (flex_int16_t const   )(short)170, 
        (flex_int16_t const   )(short)181,      (flex_int16_t const   )(short)154,      (flex_int16_t const   )(short)158,      (flex_int16_t const   )(short)145, 
        (flex_int16_t const   )(short)167,      (flex_int16_t const   )(short)196,      (flex_int16_t const   )(short)167,      (flex_int16_t const   )(short)171, 
        (flex_int16_t const   )(short)198,      (flex_int16_t const   )(short)170,      (flex_int16_t const   )(short)161,      (flex_int16_t const   )(short)181, 
        (flex_int16_t const   )(short)190,      (flex_int16_t const   )(short)196,      (flex_int16_t const   )(short)190,      (flex_int16_t const   )(short)171, 
        (flex_int16_t const   )(short)170,      (flex_int16_t const   )(short)160,      (flex_int16_t const   )(short)180,      (flex_int16_t const   )(short)180, 
        (flex_int16_t const   )(short)160,      (flex_int16_t const   )(short)180,      (flex_int16_t const   )(short)162,      (flex_int16_t const   )(short)180, 
        (flex_int16_t const   )(short)171,      (flex_int16_t const   )(short)183,      (flex_int16_t const   )(short)200,      (flex_int16_t const   )(short)199, 
        (flex_int16_t const   )(short)183,      (flex_int16_t const   )(short)170,      (flex_int16_t const   )(short)183,      (flex_int16_t const   )(short)185, 
        (flex_int16_t const   )(short)199,      (flex_int16_t const   )(short)196,      (flex_int16_t const   )(short)185,      (flex_int16_t const   )(short)171, 
        (flex_int16_t const   )(short)185,      (flex_int16_t const   )(short)186,      (flex_int16_t const   )(short)198,      (flex_int16_t const   )(short)191, 
        (flex_int16_t const   )(short)186,      (flex_int16_t const   )(short)191,      (flex_int16_t const   )(short)186,      (flex_int16_t const   )(short)195, 
        (flex_int16_t const   )(short)197,      (flex_int16_t const   )(short)195,      (flex_int16_t const   )(short)197,      (flex_int16_t const   )(short)201, 
        (flex_int16_t const   )(short)202,      (flex_int16_t const   )(short)206,      (flex_int16_t const   )(short)207,      (flex_int16_t const   )(short)206, 
        (flex_int16_t const   )(short)207,      (flex_int16_t const   )(short)200,      (flex_int16_t const   )(short)211,      (flex_int16_t const   )(short)232, 
        (flex_int16_t const   )(short)211,      (flex_int16_t const   )(short)232,      (flex_int16_t const   )(short)212,      (flex_int16_t const   )(short)213, 
        (flex_int16_t const   )(short)353,      (flex_int16_t const   )(short)213,      (flex_int16_t const   )(short)197,      (flex_int16_t const   )(short)234, 
        (flex_int16_t const   )(short)234,      (flex_int16_t const   )(short)199,      (flex_int16_t const   )(short)212,      (flex_int16_t const   )(short)351, 
        (flex_int16_t const   )(short)235,      (flex_int16_t const   )(short)202,      (flex_int16_t const   )(short)235,      (flex_int16_t const   )(short)240, 
        (flex_int16_t const   )(short)185,      (flex_int16_t const   )(short)186,      (flex_int16_t const   )(short)349,      (flex_int16_t const   )(short)212, 
        (flex_int16_t const   )(short)213,      (flex_int16_t const   )(short)213,      (flex_int16_t const   )(short)238,      (flex_int16_t const   )(short)201, 
        (flex_int16_t const   )(short)221,      (flex_int16_t const   )(short)221,      (flex_int16_t const   )(short)242,      (flex_int16_t const   )(short)221, 
        (flex_int16_t const   )(short)239,      (flex_int16_t const   )(short)221,      (flex_int16_t const   )(short)212,      (flex_int16_t const   )(short)224, 
        (flex_int16_t const   )(short)224,      (flex_int16_t const   )(short)238,      (flex_int16_t const   )(short)224,      (flex_int16_t const   )(short)227, 
        (flex_int16_t const   )(short)224,      (flex_int16_t const   )(short)237,      (flex_int16_t const   )(short)227,      (flex_int16_t const   )(short)228, 
        (flex_int16_t const   )(short)227,      (flex_int16_t const   )(short)241,      (flex_int16_t const   )(short)228,      (flex_int16_t const   )(short)229, 
        (flex_int16_t const   )(short)228,      (flex_int16_t const   )(short)346,      (flex_int16_t const   )(short)229,      (flex_int16_t const   )(short)237, 
        (flex_int16_t const   )(short)229,      (flex_int16_t const   )(short)239,      (flex_int16_t const   )(short)240,      (flex_int16_t const   )(short)250, 
        (flex_int16_t const   )(short)242,      (flex_int16_t const   )(short)238,      (flex_int16_t const   )(short)245,      (flex_int16_t const   )(short)251, 
        (flex_int16_t const   )(short)245,      (flex_int16_t const   )(short)247,      (flex_int16_t const   )(short)247,      (flex_int16_t const   )(short)241, 
        (flex_int16_t const   )(short)248,      (flex_int16_t const   )(short)250,      (flex_int16_t const   )(short)248,      (flex_int16_t const   )(short)267, 
        (flex_int16_t const   )(short)270,      (flex_int16_t const   )(short)267,      (flex_int16_t const   )(short)251,      (flex_int16_t const   )(short)237, 
        (flex_int16_t const   )(short)250,      (flex_int16_t const   )(short)273,      (flex_int16_t const   )(short)259,      (flex_int16_t const   )(short)259, 
        (flex_int16_t const   )(short)251,      (flex_int16_t const   )(short)259,      (flex_int16_t const   )(short)274,      (flex_int16_t const   )(short)259, 
        (flex_int16_t const   )(short)228,      (flex_int16_t const   )(short)229,      (flex_int16_t const   )(short)270,      (flex_int16_t const   )(short)261, 
        (flex_int16_t const   )(short)262,      (flex_int16_t const   )(short)250,      (flex_int16_t const   )(short)261,      (flex_int16_t const   )(short)262, 
        (flex_int16_t const   )(short)261,      (flex_int16_t const   )(short)262,      (flex_int16_t const   )(short)251,      (flex_int16_t const   )(short)263, 
        (flex_int16_t const   )(short)264,      (flex_int16_t const   )(short)271,      (flex_int16_t const   )(short)263,      (flex_int16_t const   )(short)264, 
        (flex_int16_t const   )(short)263,      (flex_int16_t const   )(short)264,      (flex_int16_t const   )(short)269,      (flex_int16_t const   )(short)281, 
        (flex_int16_t const   )(short)269,      (flex_int16_t const   )(short)273,      (flex_int16_t const   )(short)271,      (flex_int16_t const   )(short)270, 
        (flex_int16_t const   )(short)278,      (flex_int16_t const   )(short)280,      (flex_int16_t const   )(short)278,      (flex_int16_t const   )(short)280, 
        (flex_int16_t const   )(short)342,      (flex_int16_t const   )(short)282,      (flex_int16_t const   )(short)274,      (flex_int16_t const   )(short)338, 
        (flex_int16_t const   )(short)291,      (flex_int16_t const   )(short)281,      (flex_int16_t const   )(short)291,      (flex_int16_t const   )(short)337, 
        (flex_int16_t const   )(short)281,      (flex_int16_t const   )(short)263,      (flex_int16_t const   )(short)282,      (flex_int16_t const   )(short)295, 
        (flex_int16_t const   )(short)288,      (flex_int16_t const   )(short)288,      (flex_int16_t const   )(short)271,      (flex_int16_t const   )(short)288, 
        (flex_int16_t const   )(short)289,      (flex_int16_t const   )(short)288,      (flex_int16_t const   )(short)282,      (flex_int16_t const   )(short)289, 
        (flex_int16_t const   )(short)295,      (flex_int16_t const   )(short)289,      (flex_int16_t const   )(short)293,      (flex_int16_t const   )(short)293, 
        (flex_int16_t const   )(short)290,      (flex_int16_t const   )(short)264,      (flex_int16_t const   )(short)281,      (flex_int16_t const   )(short)290, 
        (flex_int16_t const   )(short)303,      (flex_int16_t const   )(short)290,      (flex_int16_t const   )(short)282,      (flex_int16_t const   )(short)296, 
        (flex_int16_t const   )(short)299,      (flex_int16_t const   )(short)296,      (flex_int16_t const   )(short)299,      (flex_int16_t const   )(short)301, 
        (flex_int16_t const   )(short)301,      (flex_int16_t const   )(short)303,      (flex_int16_t const   )(short)315,      (flex_int16_t const   )(short)315, 
        (flex_int16_t const   )(short)295,      (flex_int16_t const   )(short)304,      (flex_int16_t const   )(short)314,      (flex_int16_t const   )(short)304, 
        (flex_int16_t const   )(short)314,      (flex_int16_t const   )(short)303,      (flex_int16_t const   )(short)332,      (flex_int16_t const   )(short)310, 
        (flex_int16_t const   )(short)310,      (flex_int16_t const   )(short)296,      (flex_int16_t const   )(short)310,      (flex_int16_t const   )(short)312, 
        (flex_int16_t const   )(short)310,      (flex_int16_t const   )(short)317,      (flex_int16_t const   )(short)312,      (flex_int16_t const   )(short)331, 
        (flex_int16_t const   )(short)312,      (flex_int16_t const   )(short)303,      (flex_int16_t const   )(short)304,      (flex_int16_t const   )(short)304, 
        (flex_int16_t const   )(short)318,      (flex_int16_t const   )(short)290,      (flex_int16_t const   )(short)311,      (flex_int16_t const   )(short)311, 
        (flex_int16_t const   )(short)335,      (flex_int16_t const   )(short)311,      (flex_int16_t const   )(short)317,      (flex_int16_t const   )(short)311, 
        (flex_int16_t const   )(short)318,      (flex_int16_t const   )(short)321,      (flex_int16_t const   )(short)335,      (flex_int16_t const   )(short)321, 
        (flex_int16_t const   )(short)322,      (flex_int16_t const   )(short)322,      (flex_int16_t const   )(short)325,      (flex_int16_t const   )(short)329, 
        (flex_int16_t const   )(short)324,      (flex_int16_t const   )(short)312,      (flex_int16_t const   )(short)329,      (flex_int16_t const   )(short)328, 
        (flex_int16_t const   )(short)329,      (flex_int16_t const   )(short)343,      (flex_int16_t const   )(short)325,      (flex_int16_t const   )(short)330, 
        (flex_int16_t const   )(short)330,      (flex_int16_t const   )(short)330,      (flex_int16_t const   )(short)335,      (flex_int16_t const   )(short)317, 
        (flex_int16_t const   )(short)318,      (flex_int16_t const   )(short)324,      (flex_int16_t const   )(short)334,      (flex_int16_t const   )(short)325, 
        (flex_int16_t const   )(short)343,      (flex_int16_t const   )(short)324,      (flex_int16_t const   )(short)333,      (flex_int16_t const   )(short)333, 
        (flex_int16_t const   )(short)339,      (flex_int16_t const   )(short)339,      (flex_int16_t const   )(short)334,      (flex_int16_t const   )(short)336, 
        (flex_int16_t const   )(short)336,      (flex_int16_t const   )(short)336,      (flex_int16_t const   )(short)325,      (flex_int16_t const   )(short)340, 
        (flex_int16_t const   )(short)352,      (flex_int16_t const   )(short)327,      (flex_int16_t const   )(short)341,      (flex_int16_t const   )(short)345, 
        (flex_int16_t const   )(short)345,      (flex_int16_t const   )(short)345,      (flex_int16_t const   )(short)324,      (flex_int16_t const   )(short)340, 
        (flex_int16_t const   )(short)341,      (flex_int16_t const   )(short)326,      (flex_int16_t const   )(short)347,      (flex_int16_t const   )(short)352, 
        (flex_int16_t const   )(short)347,      (flex_int16_t const   )(short)350,      (flex_int16_t const   )(short)334,      (flex_int16_t const   )(short)350, 
        (flex_int16_t const   )(short)340,      (flex_int16_t const   )(short)355,      (flex_int16_t const   )(short)355,      (flex_int16_t const   )(short)341, 
        (flex_int16_t const   )(short)348,      (flex_int16_t const   )(short)348,      (flex_int16_t const   )(short)348,      (flex_int16_t const   )(short)354, 
        (flex_int16_t const   )(short)341,      (flex_int16_t const   )(short)354,      (flex_int16_t const   )(short)356,      (flex_int16_t const   )(short)340, 
        (flex_int16_t const   )(short)347,      (flex_int16_t const   )(short)359,      (flex_int16_t const   )(short)350,      (flex_int16_t const   )(short)350, 
        (flex_int16_t const   )(short)357,      (flex_int16_t const   )(short)362,      (flex_int16_t const   )(short)357,      (flex_int16_t const   )(short)358, 
        (flex_int16_t const   )(short)358,      (flex_int16_t const   )(short)356,      (flex_int16_t const   )(short)363,      (flex_int16_t const   )(short)323, 
        (flex_int16_t const   )(short)359,      (flex_int16_t const   )(short)365,      (flex_int16_t const   )(short)362,      (flex_int16_t const   )(short)365, 
        (flex_int16_t const   )(short)368,      (flex_int16_t const   )(short)320,      (flex_int16_t const   )(short)359,      (flex_int16_t const   )(short)363, 
        (flex_int16_t const   )(short)366,      (flex_int16_t const   )(short)319,      (flex_int16_t const   )(short)366,      (flex_int16_t const   )(short)316, 
        (flex_int16_t const   )(short)368,      (flex_int16_t const   )(short)369,      (flex_int16_t const   )(short)313,      (flex_int16_t const   )(short)363, 
        (flex_int16_t const   )(short)309,      (flex_int16_t const   )(short)356,      (flex_int16_t const   )(short)371,      (flex_int16_t const   )(short)365, 
        (flex_int16_t const   )(short)359,      (flex_int16_t const   )(short)369,      (flex_int16_t const   )(short)362,      (flex_int16_t const   )(short)308, 
        (flex_int16_t const   )(short)371,      (flex_int16_t const   )(short)366,      (flex_int16_t const   )(short)366,      (flex_int16_t const   )(short)363, 
        (flex_int16_t const   )(short)372,      (flex_int16_t const   )(short)307,      (flex_int16_t const   )(short)369,      (flex_int16_t const   )(short)302, 
        (flex_int16_t const   )(short)368,      (flex_int16_t const   )(short)300,      (flex_int16_t const   )(short)372,      (flex_int16_t const   )(short)297, 
        (flex_int16_t const   )(short)294,      (flex_int16_t const   )(short)292,      (flex_int16_t const   )(short)287,      (flex_int16_t const   )(short)286, 
        (flex_int16_t const   )(short)371,      (flex_int16_t const   )(short)369,      (flex_int16_t const   )(short)285,      (flex_int16_t const   )(short)284, 
        (flex_int16_t const   )(short)283,      (flex_int16_t const   )(short)372,      (flex_int16_t const   )(short)279,      (flex_int16_t const   )(short)277, 
        (flex_int16_t const   )(short)276,      (flex_int16_t const   )(short)275,      (flex_int16_t const   )(short)372,      (flex_int16_t const   )(short)377, 
        (flex_int16_t const   )(short)377,      (flex_int16_t const   )(short)377,      (flex_int16_t const   )(short)377,      (flex_int16_t const   )(short)377, 
        (flex_int16_t const   )(short)377,      (flex_int16_t const   )(short)377,      (flex_int16_t const   )(short)377,      (flex_int16_t const   )(short)377, 
        (flex_int16_t const   )(short)377,      (flex_int16_t const   )(short)377,      (flex_int16_t const   )(short)378,      (flex_int16_t const   )(short)378, 
        (flex_int16_t const   )(short)378,      (flex_int16_t const   )(short)378,      (flex_int16_t const   )(short)378,      (flex_int16_t const   )(short)378, 
        (flex_int16_t const   )(short)378,      (flex_int16_t const   )(short)378,      (flex_int16_t const   )(short)378,      (flex_int16_t const   )(short)378, 
        (flex_int16_t const   )(short)378,      (flex_int16_t const   )(short)379,      (flex_int16_t const   )(short)379,      (flex_int16_t const   )(short)379, 
        (flex_int16_t const   )(short)379,      (flex_int16_t const   )(short)379,      (flex_int16_t const   )(short)379,      (flex_int16_t const   )(short)379, 
        (flex_int16_t const   )(short)379,      (flex_int16_t const   )(short)379,      (flex_int16_t const   )(short)379,      (flex_int16_t const   )(short)379, 
        (flex_int16_t const   )(short)380,      (flex_int16_t const   )(short)380,      (flex_int16_t const   )(short)268,      (flex_int16_t const   )(short)380, 
        (flex_int16_t const   )(short)380,      (flex_int16_t const   )(short)380,      (flex_int16_t const   )(short)380,      (flex_int16_t const   )(short)380, 
        (flex_int16_t const   )(short)380,      (flex_int16_t const   )(short)380,      (flex_int16_t const   )(short)380,      (flex_int16_t const   )(short)381, 
        (flex_int16_t const   )(short)381,      (flex_int16_t const   )(short)266,      (flex_int16_t const   )(short)381,      (flex_int16_t const   )(short)381, 
        (flex_int16_t const   )(short)381,      (flex_int16_t const   )(short)381,      (flex_int16_t const   )(short)381,      (flex_int16_t const   )(short)381, 
        (flex_int16_t const   )(short)381,      (flex_int16_t const   )(short)381,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)382, 
        (flex_int16_t const   )(short)257,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)256, 
        (flex_int16_t const   )(short)382,      (flex_int16_t const   )(short)383,      (flex_int16_t const   )(short)383,      (flex_int16_t const   )(short)383, 
        (flex_int16_t const   )(short)383,      (flex_int16_t const   )(short)383,      (flex_int16_t const   )(short)383,      (flex_int16_t const   )(short)383, 
        (flex_int16_t const   )(short)383,      (flex_int16_t const   )(short)383,      (flex_int16_t const   )(short)383,      (flex_int16_t const   )(short)383, 
        (flex_int16_t const   )(short)384,      (flex_int16_t const   )(short)384,      (flex_int16_t const   )(short)255,      (flex_int16_t const   )(short)384, 
        (flex_int16_t const   )(short)254,      (flex_int16_t const   )(short)253,      (flex_int16_t const   )(short)384,      (flex_int16_t const   )(short)384, 
        (flex_int16_t const   )(short)385,      (flex_int16_t const   )(short)385,      (flex_int16_t const   )(short)252,      (flex_int16_t const   )(short)385, 
        (flex_int16_t const   )(short)385,      (flex_int16_t const   )(short)249,      (flex_int16_t const   )(short)385,      (flex_int16_t const   )(short)385, 
        (flex_int16_t const   )(short)386,      (flex_int16_t const   )(short)246,      (flex_int16_t const   )(short)244,      (flex_int16_t const   )(short)243, 
        (flex_int16_t const   )(short)236,      (flex_int16_t const   )(short)233,      (flex_int16_t const   )(short)386,      (flex_int16_t const   )(short)386, 
        (flex_int16_t const   )(short)387,      (flex_int16_t const   )(short)230,      (flex_int16_t const   )(short)226,      (flex_int16_t const   )(short)387, 
        (flex_int16_t const   )(short)225,      (flex_int16_t const   )(short)387,      (flex_int16_t const   )(short)387,      (flex_int16_t const   )(short)387, 
        (flex_int16_t const   )(short)388,      (flex_int16_t const   )(short)223,      (flex_int16_t const   )(short)222,      (flex_int16_t const   )(short)388, 
        (flex_int16_t const   )(short)389,      (flex_int16_t const   )(short)220,      (flex_int16_t const   )(short)219,      (flex_int16_t const   )(short)389, 
        (flex_int16_t const   )(short)390,      (flex_int16_t const   )(short)218,      (flex_int16_t const   )(short)390,      (flex_int16_t const   )(short)217, 
        (flex_int16_t const   )(short)216,      (flex_int16_t const   )(short)390,      (flex_int16_t const   )(short)215,      (flex_int16_t const   )(short)390, 
        (flex_int16_t const   )(short)390,      (flex_int16_t const   )(short)390,      (flex_int16_t const   )(short)391,      (flex_int16_t const   )(short)214, 
        (flex_int16_t const   )(short)210,      (flex_int16_t const   )(short)391,      (flex_int16_t const   )(short)209,      (flex_int16_t const   )(short)205, 
        (flex_int16_t const   )(short)391,      (flex_int16_t const   )(short)391,      (flex_int16_t const   )(short)392,      (flex_int16_t const   )(short)392, 
        (flex_int16_t const   )(short)392,      (flex_int16_t const   )(short)392,      (flex_int16_t const   )(short)392,      (flex_int16_t const   )(short)204, 
        (flex_int16_t const   )(short)392,      (flex_int16_t const   )(short)393,      (flex_int16_t const   )(short)393,      (flex_int16_t const   )(short)393, 
        (flex_int16_t const   )(short)393,      (flex_int16_t const   )(short)393,      (flex_int16_t const   )(short)203,      (flex_int16_t const   )(short)393, 
        (flex_int16_t const   )(short)394,      (flex_int16_t const   )(short)194,      (flex_int16_t const   )(short)193,      (flex_int16_t const   )(short)189, 
        (flex_int16_t const   )(short)188,      (flex_int16_t const   )(short)187,      (flex_int16_t const   )(short)184,      (flex_int16_t const   )(short)182, 
        (flex_int16_t const   )(short)394,      (flex_int16_t const   )(short)394,      (flex_int16_t const   )(short)395,      (flex_int16_t const   )(short)395, 
        (flex_int16_t const   )(short)179,      (flex_int16_t const   )(short)395,      (flex_int16_t const   )(short)178,      (flex_int16_t const   )(short)395, 
        (flex_int16_t const   )(short)395,      (flex_int16_t const   )(short)395,      (flex_int16_t const   )(short)396,      (flex_int16_t const   )(short)177, 
        (flex_int16_t const   )(short)176,      (flex_int16_t const   )(short)396,      (flex_int16_t const   )(short)175,      (flex_int16_t const   )(short)396, 
        (flex_int16_t const   )(short)396,      (flex_int16_t const   )(short)396,      (flex_int16_t const   )(short)397,      (flex_int16_t const   )(short)397, 
        (flex_int16_t const   )(short)174,      (flex_int16_t const   )(short)397,      (flex_int16_t const   )(short)173,      (flex_int16_t const   )(short)397, 
        (flex_int16_t const   )(short)397,      (flex_int16_t const   )(short)397,      (flex_int16_t const   )(short)398,      (flex_int16_t const   )(short)398, 
        (flex_int16_t const   )(short)172,      (flex_int16_t const   )(short)398,      (flex_int16_t const   )(short)168,      (flex_int16_t const   )(short)164, 
        (flex_int16_t const   )(short)398,      (flex_int16_t const   )(short)398,      (flex_int16_t const   )(short)399,      (flex_int16_t const   )(short)156, 
        (flex_int16_t const   )(short)152,      (flex_int16_t const   )(short)399,      (flex_int16_t const   )(short)148,      (flex_int16_t const   )(short)399, 
        (flex_int16_t const   )(short)399,      (flex_int16_t const   )(short)399,      (flex_int16_t const   )(short)400,      (flex_int16_t const   )(short)400, 
        (flex_int16_t const   )(short)147,      (flex_int16_t const   )(short)400,      (flex_int16_t const   )(short)144,      (flex_int16_t const   )(short)140, 
        (flex_int16_t const   )(short)400,      (flex_int16_t const   )(short)400,      (flex_int16_t const   )(short)401,      (flex_int16_t const   )(short)401, 
        (flex_int16_t const   )(short)130,      (flex_int16_t const   )(short)401,      (flex_int16_t const   )(short)128,      (flex_int16_t const   )(short)401, 
        (flex_int16_t const   )(short)401,      (flex_int16_t const   )(short)401,      (flex_int16_t const   )(short)402,      (flex_int16_t const   )(short)402, 
        (flex_int16_t const   )(short)127,      (flex_int16_t const   )(short)402,      (flex_int16_t const   )(short)125,      (flex_int16_t const   )(short)402, 
        (flex_int16_t const   )(short)402,      (flex_int16_t const   )(short)402,      (flex_int16_t const   )(short)120,      (flex_int16_t const   )(short)118, 
        (flex_int16_t const   )(short)116,      (flex_int16_t const   )(short)115,      (flex_int16_t const   )(short)113,      (flex_int16_t const   )(short)111, 
        (flex_int16_t const   )(short)109,      (flex_int16_t const   )(short)100,      (flex_int16_t const   )(short)97,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)92,      (flex_int16_t const   )(short)90,      (flex_int16_t const   )(short)89,      (flex_int16_t const   )(short)88, 
        (flex_int16_t const   )(short)87,      (flex_int16_t const   )(short)85,      (flex_int16_t const   )(short)84,      (flex_int16_t const   )(short)79, 
        (flex_int16_t const   )(short)73,      (flex_int16_t const   )(short)70,      (flex_int16_t const   )(short)68,      (flex_int16_t const   )(short)67, 
        (flex_int16_t const   )(short)63,      (flex_int16_t const   )(short)56,      (flex_int16_t const   )(short)54,      (flex_int16_t const   )(short)52, 
        (flex_int16_t const   )(short)51,      (flex_int16_t const   )(short)39,      (flex_int16_t const   )(short)34,      (flex_int16_t const   )(short)30, 
        (flex_int16_t const   )(short)28,      (flex_int16_t const   )(short)21,      (flex_int16_t const   )(short)19,      (flex_int16_t const   )(short)14, 
        (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376,      (flex_int16_t const   )(short)376, 
        (flex_int16_t const   )(short)376};
#line 836
int master__flex_debug ;
#line 837 "master_tok.c"
int master__flex_debug  =    0;
#line 839 "master_tok.c"
static yy_state_type *yy_state_buf  =    (yy_state_type *)0;
#line 839 "master_tok.c"
static yy_state_type *yy_state_ptr  =    (yy_state_type *)0;
#line 840 "master_tok.c"
static char *yy_full_match  ;
#line 841 "master_tok.c"
static int yy_lp  ;
#line 842 "master_tok.c"
static int yy_looking_for_trail_begin  =    0;
#line 843 "master_tok.c"
static int yy_full_lp  ;
#line 844 "master_tok.c"
static int *yy_full_state  ;
#line 24 "master_tok.l"
static void master_echo(void) ;
#line 41
int master_wrap(void) ;
#line 60 "master_tok.l"
char const   *line  =    (char const   *)((void *)0);
#line 63 "master_tok.l"
char const   *line_pos  =    (char const   *)((void *)0);
#line 64 "master_tok.l"
char const   *line_lim  =    (char const   *)((void *)0);
#line 65
int my_yyinput(char *buffer , int max_size ) ;
#line 76 "master_tok.l"
char buff[1024]  ;
#line 77 "master_tok.l"
char *bptr  ;
#line 78 "master_tok.l"
char *optr  =    buff;
#line 745 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 963 "master_tok.c"
static int yy_init_globals(void) ;
#line 1092 "master_tok.c"
int master_lex(void) 
{ register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  YY_BUFFER_STATE tmp___0 ;
  yy_state_type *tmp___1 ;
  register YY_CHAR yy_c ;
  yy_state_type *tmp___2 ;
  int yyless_macro_arg ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int yyless_macro_arg___0 ;
  int yyless_macro_arg___1 ;
  int yyless_macro_arg___2 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 1103
  if (! yy_init) {
#line 1105
    yy_init = 1;
#line 1112
    if (! yy_state_buf) {
#line 1113
      yy_state_buf = (yy_state_type *)master_alloc(16386U * sizeof(yy_state_type ));
    }
#line 1115
    if (! yy_start) {
#line 1116
      yy_start = 1;
    }
#line 1118
    if (! master_in) {
#line 1119
      master_in = stdin;
    }
#line 1121
    if (! master_out) {
#line 1122
      master_out = stdout;
    }
#line 1124
    if (yy_buffer_stack) {
#line 1124
      tmp___0 = (*(yy_buffer_stack + yy_buffer_stack_top));
    } else {
#line 1124
      tmp___0 = (struct yy_buffer_state *)((void *)0);
    }
#line 1124
    if (! tmp___0) {
#line 1125
      master_ensure_buffer_stack();
#line 1126
      (*(yy_buffer_stack + yy_buffer_stack_top)) = master__create_buffer(master_in,
                                                                         16384);
    }
#line 1130
    master__load_buffer_state();
  }
#line 1133
  while (1) {
#line 1135
    yy_cp = yy_c_buf_p;
#line 1138
    (*yy_cp) = yy_hold_char;
#line 1143
    yy_bp = yy_cp;
#line 1145
    yy_current_state = yy_start;
#line 1147
    yy_state_ptr = yy_state_buf;
#line 1148
    tmp___1 = yy_state_ptr;
#line 1148
    yy_state_ptr ++;
#line 1148
    (*tmp___1) = yy_current_state;
    yy_match: 
#line 1151
    while (1) {
#line 1153
      yy_c = (unsigned char )yy_ec[(unsigned int )((unsigned char )(*yy_cp))];
#line 1154
      while ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state) {
#line 1156
        yy_current_state = (int )yy_def[yy_current_state];
#line 1157
        if (yy_current_state >= 377) {
#line 1158
          yy_c = (unsigned char )yy_meta[(unsigned int )yy_c];
        }
      }
#line 1160
      yy_current_state = (int )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1161
      tmp___2 = yy_state_ptr;
#line 1161
      yy_state_ptr ++;
#line 1161
      (*tmp___2) = yy_current_state;
#line 1162
      yy_cp ++;
#line 1151
      if (! ((int const   )yy_base[yy_current_state] != 1009)) {
#line 1151
        break;
      }
    }
    yy_find_action: 
#line 1167
    yy_state_ptr --;
#line 1167
    yy_current_state = (*yy_state_ptr);
#line 1168
    yy_lp = (int )yy_accept[yy_current_state];
    find_rule: 
#line 1170
    while (1) {
#line 1172
      if (yy_lp) {
#line 1172
        if (yy_lp < (int )yy_accept[yy_current_state + 1]) {
#line 1174
          yy_act = (int )yy_acclist[yy_lp];
#line 1175
          if (yy_act & 16384) {
            goto _L;
          } else {
#line 1175
            if (yy_looking_for_trail_begin) {
              _L: 
#line 1178
              if (yy_act == yy_looking_for_trail_begin) {
#line 1180
                yy_looking_for_trail_begin = 0;
#line 1181
                yy_act &= -16385;
#line 1182
                break;
              }
            } else {
#line 1185
              if (yy_act & 8192) {
#line 1187
                yy_looking_for_trail_begin = yy_act & -8193;
#line 1188
                yy_looking_for_trail_begin |= 16384;
              } else {
#line 1192
                yy_full_match = yy_cp;
#line 1193
                yy_full_state = yy_state_ptr;
#line 1194
                yy_full_lp = yy_lp;
#line 1195
                break;
              }
            }
          }
#line 1197
          yy_lp ++;
          goto find_rule;
        }
      }
#line 1200
      yy_cp --;
#line 1201
      yy_state_ptr --;
#line 1201
      yy_current_state = (*yy_state_ptr);
#line 1202
      yy_lp = (int )yy_accept[yy_current_state];
    }
#line 1205
    master_text = yy_bp;
#line 1205
    master_leng = (int )((unsigned int )(yy_cp - yy_bp));
#line 1205
    yy_hold_char = (*yy_cp);
#line 1205
    (*yy_cp) = (char )'\000';
#line 1205
    yy_c_buf_p = yy_cp;
    do_action: 
#line 1209
    switch (yy_act) {
    case 1: 
    case 2: 
#line 123 "master_tok.c"
    if ((unsigned int )optr != (unsigned int )(buff)) {
#line 124 "master_tok.l"
      (*optr) = (char )'\000';
#line 125
      optr = buff;
#line 126
      strcpy((char * __restrict  )(master_lval.strtype), (char const   * __restrict  )(buff));
#line 127
      return (270);
    }
#line 130 "master_tok.l"
    break;
    case 3: 
#line 131
    return (258);
#line 132
    break;
    case 4: 
#line 134
    yy_start = 3;
#line 135
    bptr = buff;
#line 136
    while (1) {
#line 136
      yyless_macro_arg = 0;
#line 136
      (*yy_cp) = yy_hold_char;
#line 136
      yy_cp = (yy_bp + yyless_macro_arg) - 0;
#line 136
      yy_c_buf_p = yy_cp;
#line 136
      master_text = yy_bp;
#line 136
      master_leng = (int )((unsigned int )(yy_cp - yy_bp));
#line 136
      yy_hold_char = (*yy_cp);
#line 136
      (*yy_cp) = (char )'\000';
#line 136
      yy_c_buf_p = yy_cp;
#line 136
      break;
    }
#line 138
    break;
    case 5: 
#line 139
    tmp___3 = optr;
#line 139
    optr ++;
#line 139
    (*tmp___3) = (*master_text);
#line 140
    break;
    case 6: 
#line 144
    yy_start = 1;
#line 145
    tmp___4 = bptr;
#line 145
    bptr ++;
#line 145
    (*tmp___4) = (*master_text);
#line 146
    strcpy((char * __restrict  )(master_lval.strtype), (char const   * __restrict  )(buff));
#line 147
    return (270);
#line 149
    break;
    case 7: 
#line 150
    tmp___5 = bptr;
#line 150
    bptr ++;
#line 150
    (*tmp___5) = (*(master_text + 1));
#line 151
    break;
    case 8: 
#line 152
    yy_start = 1;
#line 153
    tmp___6 = bptr;
#line 153
    bptr ++;
#line 153
    (*tmp___6) = (*master_text);
#line 154
    (*bptr) = (char )'\000';
#line 155
    strcpy((char * __restrict  )(master_lval.strtype), (char const   * __restrict  )(buff));
#line 156
    return (269);
#line 158
    break;
    case 9: 
#line 160
    yy_start = 5;
#line 161
    (*bptr) = (char )'\000';
#line 162
    strcpy((char * __restrict  )(master_lval.strtype), (char const   * __restrict  )(buff));
#line 163
    bptr = buff;
#line 164
    return (268);
#line 166
    break;
    case 56: 
#line 168
    yy_start = 1;
#line 169
    (*bptr) = (char )'\000';
#line 170
    strcpy((char * __restrict  )(master_lval.strtype), (char const   * __restrict  )(buff));
#line 171
    return (268);
#line 173
    break;
    case 10: 
#line 175
    yy_start = 1;
#line 176
    (*bptr) = (char )'\000';
#line 177
    strcpy((char * __restrict  )(master_lval.strtype), (char const   * __restrict  )(buff));
#line 178
    return (268);
#line 180
    break;
    case 11: 
#line 181
    tmp___7 = bptr;
#line 181
    bptr ++;
#line 181
    (*tmp___7) = (*master_text);
#line 182
    break;
    case 12: ;
#line 186
    break;
    case 13: 
#line 188
    (*yy_cp) = yy_hold_char;
#line 189
    yy_cp --;
#line 189
    yy_c_buf_p = yy_cp;
#line 190
    master_text = yy_bp;
#line 190
    master_leng = (int )((unsigned int )(yy_cp - yy_bp));
#line 190
    yy_hold_char = (*yy_cp);
#line 190
    (*yy_cp) = (char )'\000';
#line 190
    yy_c_buf_p = yy_cp;
#line 188
    strcpy((char * __restrict  )(master_lval.strtype), (char const   * __restrict  )master_text);
#line 189
    return (273);
#line 191
    break;
    case 14: 
#line 192
    return (265);
#line 193
    break;
    case 15: 
#line 195
    yy_start = 9;
#line 196
    strcpy((char * __restrict  )(master_lval.strtype), (char const   * __restrict  )master_text);
#line 197
    return (277);
#line 199
    break;
    case 16: 
#line 201
    yy_start = 9;
#line 202
    strcpy((char * __restrict  )(master_lval.strtype), (char const   * __restrict  )master_text);
#line 203
    return (278);
#line 205
    break;
    case 17: 
#line 207
    yy_start = 7;
#line 208
    while (1) {
#line 208
      yyless_macro_arg___0 = 0;
#line 208
      (*yy_cp) = yy_hold_char;
#line 208
      yy_cp = (yy_bp + yyless_macro_arg___0) - 0;
#line 208
      yy_c_buf_p = yy_cp;
#line 208
      master_text = yy_bp;
#line 208
      master_leng = (int )((unsigned int )(yy_cp - yy_bp));
#line 208
      yy_hold_char = (*yy_cp);
#line 208
      (*yy_cp) = (char )'\000';
#line 208
      yy_c_buf_p = yy_cp;
#line 208
      break;
    }
#line 210
    break;
    case 18: 
#line 212
    yy_start = 7;
#line 213
    while (1) {
#line 213
      yyless_macro_arg___1 = 0;
#line 213
      (*yy_cp) = yy_hold_char;
#line 213
      yy_cp = (yy_bp + yyless_macro_arg___1) - 0;
#line 213
      yy_c_buf_p = yy_cp;
#line 213
      master_text = yy_bp;
#line 213
      master_leng = (int )((unsigned int )(yy_cp - yy_bp));
#line 213
      yy_hold_char = (*yy_cp);
#line 213
      (*yy_cp) = (char )'\000';
#line 213
      yy_c_buf_p = yy_cp;
#line 213
      break;
    }
#line 215
    break;
    case 19: 
#line 217
    yy_start = 7;
#line 218
    while (1) {
#line 218
      yyless_macro_arg___2 = 0;
#line 218
      (*yy_cp) = yy_hold_char;
#line 218
      yy_cp = (yy_bp + yyless_macro_arg___2) - 0;
#line 218
      yy_c_buf_p = yy_cp;
#line 218
      master_text = yy_bp;
#line 218
      master_leng = (int )((unsigned int )(yy_cp - yy_bp));
#line 218
      yy_hold_char = (*yy_cp);
#line 218
      (*yy_cp) = (char )'\000';
#line 218
      yy_c_buf_p = yy_cp;
#line 218
      break;
    }
#line 220
    break;
    case 20: 
#line 222
    yy_start = 1;
#line 223
    (*bptr) = (char )'\000';
#line 224
    strcpy((char * __restrict  )(master_lval.strtype), (char const   * __restrict  )(buff));
#line 225
    bptr = buff;
#line 226
    return (279);
#line 228
    break;
    case 21: 
#line 229
    tmp___8 = bptr;
#line 229
    bptr ++;
#line 229
    (*tmp___8) = (*(master_text + 1));
#line 230
    break;
    case 22: 
#line 232
    yy_start = 9;
#line 233
    (*bptr) = (char )'\000';
#line 234
    strcpy((char * __restrict  )(master_lval.strtype), (char const   * __restrict  )(buff));
#line 235
    bptr = buff;
#line 236
    return (279);
#line 238
    break;
    case 23: 
    case 24: 
#line 241
    yy_start = 1;
#line 242
    (*bptr) = (char )'\000';
#line 243
    strcpy((char * __restrict  )(master_lval.strtype), (char const   * __restrict  )(buff));
#line 244
    return (279);
#line 246
    break;
    case 57: 
#line 248
    yy_start = 1;
#line 249
    (*bptr) = (char )'\000';
#line 250
    strcpy((char * __restrict  )(master_lval.strtype), (char const   * __restrict  )(buff));
#line 251
    return (279);
#line 253
    break;
    case 25: 
#line 254
    tmp___9 = bptr;
#line 254
    bptr ++;
#line 254
    (*tmp___9) = (*master_text);
#line 255
    break;
    case 26: ;
#line 259
    break;
    case 27: 
#line 261
    strcpy((char * __restrict  )(master_lval.strtype), (char const   * __restrict  )master_text);
#line 262
    return (274);
#line 264
    break;
    case 28: 
#line 266
    strcpy((char * __restrict  )(master_lval.strtype), (char const   * __restrict  )master_text);
#line 267
    return (275);
#line 269
    break;
    case 29: 
#line 271
    return (272);
#line 273
    break;
    case 30: 
#line 275
    strcpy((char * __restrict  )(master_lval.strtype), (char const   * __restrict  )master_text);
#line 276
    return (276);
#line 278
    break;
    case 31: 
#line 280
    return (266);
#line 282
    break;
    case 32: 
    case 33: 
#line 285
    yy_start = 1;
#line 286
    strcpy((char * __restrict  )(master_lval.strtype), (char const   * __restrict  )master_text);
#line 287
    return (271);
#line 289
    break;
    case 34: 
#line 290
    yy_start = 9;
#line 291
    break;
    case 35: 
    case 36: 
#line 293
    yy_start = 1;
#line 294
    break;
    case 58: 
#line 295
    yy_start = 1;
#line 296
    break;
    case 37: ;
#line 300
    break;
    case 38: 
#line 301
    return (260);
#line 302
    break;
    case 39: 
#line 304
    master_lval.longtype = atol__extinline((char const   *)master_text);
#line 305
    return (280);
#line 307
    break;
    case 40: 
#line 308
    return (261);
#line 309
    break;
    case 41: 
#line 309
    return (262);
#line 310
    break;
    case 42: 
#line 310
    return (263);
#line 311
    break;
    case 43: 
#line 311
    return (264);
#line 312
    break;
    case 44: 
#line 313
    return (266);
#line 314
    break;
    case 45: ;
#line 316
    break;
    case 46: 
#line 318
    strcpy((char * __restrict  )(master_lval.strtype), (char const   * __restrict  )master_text);
#line 319
    return (281);
#line 321
    break;
    case 47: 
#line 323
    strcpy((char * __restrict  )(master_lval.strtype), (char const   * __restrict  )master_text);
#line 324
    return (281);
#line 326
    break;
    case 48: 
#line 328
    strcpy((char * __restrict  )(master_lval.strtype), (char const   * __restrict  )master_text);
#line 329
    return (281);
#line 331
    break;
    case 49: 
#line 333
    strcpy((char * __restrict  )(master_lval.strtype), (char const   * __restrict  )master_text);
#line 334
    return (272);
#line 336
    break;
    case 50: ;
#line 338
    break;
    case 51: 
    case 52: 
#line 339
    yy_start = 1;
#line 340
    break;
    case 59: 
#line 341
    yy_start = 1;
#line 342
    break;
    case 53: 
#line 344
    master_echo();
#line 345
    break;
    case 55: 
#line 1617 "master_tok.c"
    return (0);
    case 54: 
#line 1622
    yy_amount_of_matched_text = (yy_cp - master_text) - 1;
#line 1625
    (*yy_cp) = yy_hold_char;
#line 1628
    if (((*(yy_buffer_stack + yy_buffer_stack_top)))->yy_buffer_status == 0) {
#line 1639
      yy_n_chars = ((*(yy_buffer_stack + yy_buffer_stack_top)))->yy_n_chars;
#line 1640
      ((*(yy_buffer_stack + yy_buffer_stack_top)))->yy_input_file = master_in;
#line 1641
      ((*(yy_buffer_stack + yy_buffer_stack_top)))->yy_buffer_status = 1;
    }
#line 1651
    if ((unsigned int )yy_c_buf_p <= (unsigned int )(((*(yy_buffer_stack + yy_buffer_stack_top)))->yy_ch_buf + yy_n_chars)) {
#line 1655
      yy_c_buf_p = master_text + yy_amount_of_matched_text;
#line 1657
      yy_current_state = yy_get_previous_state();
#line 1668
      yy_next_state = yy_try_NUL_trans(yy_current_state);
#line 1670
      yy_bp = master_text + 0;
#line 1672
      if (yy_next_state) {
#line 1675
        yy_c_buf_p ++;
#line 1675
        yy_cp = yy_c_buf_p;
#line 1676
        yy_current_state = yy_next_state;
        goto yy_match;
      } else {
#line 1682
        yy_cp = yy_c_buf_p;
        goto yy_find_action;
      }
    } else {
#line 1687
      tmp___10 = yy_get_next_buffer();
#line 1687
      switch (tmp___10) {
      case 1: 
#line 1691
      yy_did_buffer_switch_on_eof = 0;
#line 1693
      tmp___11 = master_wrap();
#line 1693
      if (tmp___11) {
#line 1704
        yy_c_buf_p = master_text + 0;
#line 1706
        yy_act = (54 + (yy_start - 1) / 2) + 1;
        goto do_action;
      } else {
#line 1712
        if (! yy_did_buffer_switch_on_eof) {
#line 1713
          master_restart(master_in);
        }
      }
#line 1715
      break;
      case 0: 
#line 1719
      yy_c_buf_p = master_text + yy_amount_of_matched_text;
#line 1722
      yy_current_state = yy_get_previous_state();
#line 1724
      yy_cp = yy_c_buf_p;
#line 1725
      yy_bp = master_text + 0;
      goto yy_match;
      case 2: 
#line 1729
      yy_c_buf_p = ((*(yy_buffer_stack + yy_buffer_stack_top)))->yy_ch_buf + yy_n_chars;
#line 1732
      yy_current_state = yy_get_previous_state();
#line 1734
      yy_cp = yy_c_buf_p;
#line 1735
      yy_bp = master_text + 0;
      goto yy_find_action;
      }
    }
#line 1738
    break;
    default: 
#line 1742
    yy_fatal_error("fatal flex scanner internal error--no action found");
    }
  }
}
}
#line 1755 "master_tok.c"
static int yy_get_next_buffer(void) 
{ register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int num_to_read ;

  {
#line 1757
  dest = ((*(yy_buffer_stack + yy_buffer_stack_top)))->yy_ch_buf;
#line 1758
  source = master_text;
#line 1762
  if ((unsigned int )yy_c_buf_p > (unsigned int )(((*(yy_buffer_stack + yy_buffer_stack_top)))->yy_ch_buf + (yy_n_chars + 1))) {
#line 1763
    yy_fatal_error("fatal flex scanner internal error--end of buffer missed");
  }
#line 1766
  if (((*(yy_buffer_stack + yy_buffer_stack_top)))->yy_fill_buffer == 0) {
#line 1768
    if ((yy_c_buf_p - master_text) - 0 == 1) {
#line 1773
      return (1);
    } else {
#line 1781
      return (2);
    }
  }
#line 1788
  number_to_move = (yy_c_buf_p - master_text) - 1;
#line 1790
  i = 0;
#line 1790
  while (i < number_to_move) {
#line 1791
    tmp = dest;
#line 1791
    dest ++;
#line 1791
    tmp___0 = source;
#line 1791
    source ++;
#line 1791
    (*tmp) = (*tmp___0);
#line 1790
    i ++;
  }
#line 1793
  if (((*(yy_buffer_stack + yy_buffer_stack_top)))->yy_buffer_status == 2) {
#line 1797
    yy_n_chars = 0;
#line 1797
    ((*(yy_buffer_stack + yy_buffer_stack_top)))->yy_n_chars = yy_n_chars;
  } else {
#line 1801
    num_to_read = (int )((((*(yy_buffer_stack + yy_buffer_stack_top)))->yy_buf_size - (unsigned int )number_to_move) - 1U);
#line 1804
    while (num_to_read <= 0) {
#line 1807
      yy_fatal_error("input buffer overflow, can\'t enlarge buffer because scanner uses REJECT");
    }
#line 1812
    if (num_to_read > 8192) {
#line 1813
      num_to_read = 8192;
    }
#line 1816
    yy_n_chars = my_yyinput(((*(yy_buffer_stack + yy_buffer_stack_top)))->yy_ch_buf + number_to_move,
                            (int )((unsigned int )num_to_read));
#line 1819
    ((*(yy_buffer_stack + yy_buffer_stack_top)))->yy_n_chars = yy_n_chars;
  }
#line 1822
  if (yy_n_chars == 0) {
#line 1824
    if (number_to_move == 0) {
#line 1826
      ret_val = 1;
#line 1827
      master_restart(master_in);
    } else {
#line 1832
      ret_val = 2;
#line 1833
      ((*(yy_buffer_stack + yy_buffer_stack_top)))->yy_buffer_status = 2;
    }
  } else {
#line 1839
    ret_val = 0;
  }
#line 1841
  yy_n_chars += number_to_move;
#line 1842
  (*(((*(yy_buffer_stack + yy_buffer_stack_top)))->yy_ch_buf + yy_n_chars)) = (char)0;
#line 1843
  (*(((*(yy_buffer_stack + yy_buffer_stack_top)))->yy_ch_buf + (yy_n_chars + 1))) = (char)0;
#line 1845
  master_text = ((*(yy_buffer_stack + yy_buffer_stack_top)))->yy_ch_buf + 0;
#line 1847
  return (ret_val);
}
}
#line 1852 "master_tok.c"
static yy_state_type yy_get_previous_state(void) 
{ register yy_state_type yy_current_state ;
  register char *yy_cp ;
  yy_state_type *tmp ;
  register YY_CHAR yy_c ;
  flex_int32_t tmp___0 ;
  yy_state_type *tmp___1 ;

  {
#line 1857
  yy_current_state = yy_start;
#line 1859
  yy_state_ptr = yy_state_buf;
#line 1860
  tmp = yy_state_ptr;
#line 1860
  yy_state_ptr ++;
#line 1860
  (*tmp) = yy_current_state;
#line 1862
  yy_cp = master_text + 0;
#line 1862
  while ((unsigned int )yy_cp < (unsigned int )yy_c_buf_p) {
#line 1864
    if ((*yy_cp)) {
#line 1864
      tmp___0 = yy_ec[(unsigned int )((unsigned char )(*yy_cp))];
    } else {
#line 1864
      tmp___0 = 51;
    }
#line 1864
    yy_c = (unsigned char )tmp___0;
#line 1865
    while ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state) {
#line 1867
      yy_current_state = (int )yy_def[yy_current_state];
#line 1868
      if (yy_current_state >= 377) {
#line 1869
        yy_c = (unsigned char )yy_meta[(unsigned int )yy_c];
      }
    }
#line 1871
    yy_current_state = (int )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1872
    tmp___1 = yy_state_ptr;
#line 1872
    yy_state_ptr ++;
#line 1872
    (*tmp___1) = yy_current_state;
#line 1862
    yy_cp ++;
  }
#line 1875
  return (yy_current_state);
}
}
#line 1883 "master_tok.c"
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) 
{ register int yy_is_jam ;
  register YY_CHAR yy_c ;
  yy_state_type *tmp ;
  int tmp___0 ;

  {
#line 1887
  yy_c = (unsigned char)51;
#line 1888
  while ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state) {
#line 1890
    yy_current_state = (int )yy_def[yy_current_state];
#line 1891
    if (yy_current_state >= 377) {
#line 1892
      yy_c = (unsigned char )yy_meta[(unsigned int )yy_c];
    }
  }
#line 1894
  yy_current_state = (int )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1895
  yy_is_jam = yy_current_state == 376;
#line 1896
  if (! yy_is_jam) {
#line 1897
    tmp = yy_state_ptr;
#line 1897
    yy_state_ptr ++;
#line 1897
    (*tmp) = yy_current_state;
  }
#line 1899
  if (yy_is_jam) {
#line 1899
    tmp___0 = 0;
  } else {
#line 1899
    tmp___0 = yy_current_state;
  }
#line 1899
  return (tmp___0);
}
}
#line 1981 "master_tok.c"
void master_restart(FILE *input_file ) 
{ YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1984
  if (yy_buffer_stack) {
#line 1984
    tmp = (*(yy_buffer_stack + yy_buffer_stack_top));
  } else {
#line 1984
    tmp = (struct yy_buffer_state *)((void *)0);
  }
#line 1984
  if (! tmp) {
#line 1985
    master_ensure_buffer_stack();
#line 1986
    (*(yy_buffer_stack + yy_buffer_stack_top)) = master__create_buffer(master_in,
                                                                       16384);
  }
#line 1990
  if (yy_buffer_stack) {
#line 1990
    tmp___0 = (*(yy_buffer_stack + yy_buffer_stack_top));
  } else {
#line 1990
    tmp___0 = (struct yy_buffer_state *)((void *)0);
  }
#line 1990
  master__init_buffer(tmp___0, input_file);
#line 1991
  master__load_buffer_state();
#line 1992
  return;
}
}
#line 1998 "master_tok.c"
void master__switch_to_buffer(YY_BUFFER_STATE new_buffer ) 
{ YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 2006
  master_ensure_buffer_stack();
#line 2007
  if (yy_buffer_stack) {
#line 2007
    tmp = (*(yy_buffer_stack + yy_buffer_stack_top));
  } else {
#line 2007
    tmp = (struct yy_buffer_state *)((void *)0);
  }
#line 2007
  if ((unsigned int )tmp == (unsigned int )new_buffer) {
#line 2008
    return;
  }
#line 2010
  if (yy_buffer_stack) {
#line 2010
    tmp___0 = (*(yy_buffer_stack + yy_buffer_stack_top));
  } else {
#line 2010
    tmp___0 = (struct yy_buffer_state *)((void *)0);
  }
#line 2010
  if (tmp___0) {
#line 2013
    (*yy_c_buf_p) = yy_hold_char;
#line 2014
    ((*(yy_buffer_stack + yy_buffer_stack_top)))->yy_buf_pos = yy_c_buf_p;
#line 2015
    ((*(yy_buffer_stack + yy_buffer_stack_top)))->yy_n_chars = yy_n_chars;
  }
#line 2018
  (*(yy_buffer_stack + yy_buffer_stack_top)) = new_buffer;
#line 2019
  master__load_buffer_state();
#line 2026
  yy_did_buffer_switch_on_eof = 1;
#line 2027
  return;
}
}
#line 2029 "master_tok.c"
static void master__load_buffer_state(void) 
{ 

  {
#line 2031
  yy_n_chars = ((*(yy_buffer_stack + yy_buffer_stack_top)))->yy_n_chars;
#line 2032
  yy_c_buf_p = ((*(yy_buffer_stack + yy_buffer_stack_top)))->yy_buf_pos;
#line 2032
  master_text = yy_c_buf_p;
#line 2033
  master_in = ((*(yy_buffer_stack + yy_buffer_stack_top)))->yy_input_file;
#line 2034
  yy_hold_char = (*yy_c_buf_p);
#line 2035
  return;
}
}
#line 2043 "master_tok.c"
YY_BUFFER_STATE master__create_buffer(FILE *file , int size ) 
{ YY_BUFFER_STATE b ;

  {
#line 2047
  b = (YY_BUFFER_STATE )master_alloc(sizeof(struct yy_buffer_state ));
#line 2048
  if (! b) {
#line 2049
    yy_fatal_error("out of dynamic memory in master__create_buffer()");
  }
#line 2051
  b->yy_buf_size = (unsigned int )size;
#line 2056
  b->yy_ch_buf = (char *)master_alloc(b->yy_buf_size + 2U);
#line 2057
  if (! b->yy_ch_buf) {
#line 2058
    yy_fatal_error("out of dynamic memory in master__create_buffer()");
  }
#line 2060
  b->yy_is_our_buffer = 1;
#line 2062
  master__init_buffer(b, file);
#line 2064
  return (b);
}
}
#line 2071 "master_tok.c"
void master__delete_buffer(YY_BUFFER_STATE b ) 
{ YY_BUFFER_STATE tmp ;

  {
#line 2074
  if (! b) {
#line 2075
    return;
  }
#line 2077
  if (yy_buffer_stack) {
#line 2077
    tmp = (*(yy_buffer_stack + yy_buffer_stack_top));
  } else {
#line 2077
    tmp = (struct yy_buffer_state *)((void *)0);
  }
#line 2077
  if ((unsigned int )b == (unsigned int )tmp) {
#line 2078
    (*(yy_buffer_stack + yy_buffer_stack_top)) = (struct yy_buffer_state *)0;
  }
#line 2080
  if (b->yy_is_our_buffer) {
#line 2081
    master_free((void *)b->yy_ch_buf);
  }
#line 2083
  master_free((void *)b);
#line 2084
  return;
}
}
#line 2094 "master_tok.c"
static void master__init_buffer(YY_BUFFER_STATE b , FILE *file ) 
{ int oerrno ;
  int *tmp ;
  YY_BUFFER_STATE tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;

  {
#line 2097
  tmp = __errno_location();
#line 2097
  oerrno = (*tmp);
#line 2099
  master__flush_buffer(b);
#line 2101
  b->yy_input_file = file;
#line 2102
  b->yy_fill_buffer = 1;
#line 2108
  if (yy_buffer_stack) {
#line 2108
    tmp___0 = (*(yy_buffer_stack + yy_buffer_stack_top));
  } else {
#line 2108
    tmp___0 = (struct yy_buffer_state *)((void *)0);
  }
#line 2108
  if ((unsigned int )b != (unsigned int )tmp___0) {
#line 2109
    b->yy_bs_lineno = 1;
#line 2110
    b->yy_bs_column = 0;
  }
#line 2113
  if (file) {
#line 2113
    tmp___3 = fileno(file);
#line 2113
    tmp___4 = isatty(tmp___3);
#line 2113
    b->yy_is_interactive = tmp___4 > 0;
  } else {
#line 2113
    b->yy_is_interactive = 0;
  }
#line 2115
  tmp___5 = __errno_location();
#line 2115
  (*tmp___5) = oerrno;
#line 2116
  return;
}
}
#line 2122 "master_tok.c"
void master__flush_buffer(YY_BUFFER_STATE b ) 
{ YY_BUFFER_STATE tmp ;

  {
#line 2124
  if (! b) {
#line 2125
    return;
  }
#line 2127
  b->yy_n_chars = 0;
#line 2133
  (*(b->yy_ch_buf + 0)) = (char)0;
#line 2134
  (*(b->yy_ch_buf + 1)) = (char)0;
#line 2136
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 2138
  b->yy_at_bol = 1;
#line 2139
  b->yy_buffer_status = 0;
#line 2141
  if (yy_buffer_stack) {
#line 2141
    tmp = (*(yy_buffer_stack + yy_buffer_stack_top));
  } else {
#line 2141
    tmp = (struct yy_buffer_state *)((void *)0);
  }
#line 2141
  if ((unsigned int )b == (unsigned int )tmp) {
#line 2142
    master__load_buffer_state();
  }
#line 2143
  return;
}
}
#line 2151 "master_tok.c"
void master_push_buffer_state(YY_BUFFER_STATE new_buffer ) 
{ YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 2153
  if ((unsigned int )new_buffer == (unsigned int )((void *)0)) {
#line 2154
    return;
  }
#line 2156
  master_ensure_buffer_stack();
#line 2159
  if (yy_buffer_stack) {
#line 2159
    tmp = (*(yy_buffer_stack + yy_buffer_stack_top));
  } else {
#line 2159
    tmp = (struct yy_buffer_state *)((void *)0);
  }
#line 2159
  if (tmp) {
#line 2162
    (*yy_c_buf_p) = yy_hold_char;
#line 2163
    ((*(yy_buffer_stack + yy_buffer_stack_top)))->yy_buf_pos = yy_c_buf_p;
#line 2164
    ((*(yy_buffer_stack + yy_buffer_stack_top)))->yy_n_chars = yy_n_chars;
  }
#line 2168
  if (yy_buffer_stack) {
#line 2168
    tmp___0 = (*(yy_buffer_stack + yy_buffer_stack_top));
  } else {
#line 2168
    tmp___0 = (struct yy_buffer_state *)((void *)0);
  }
#line 2168
  if (tmp___0) {
#line 2169
    yy_buffer_stack_top ++;
  }
#line 2170
  (*(yy_buffer_stack + yy_buffer_stack_top)) = new_buffer;
#line 2173
  master__load_buffer_state();
#line 2174
  yy_did_buffer_switch_on_eof = 1;
#line 2175
  return;
}
}
#line 2181 "master_tok.c"
void master_pop_buffer_state(void) 
{ YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 2183
  if (yy_buffer_stack) {
#line 2183
    tmp = (*(yy_buffer_stack + yy_buffer_stack_top));
  } else {
#line 2183
    tmp = (struct yy_buffer_state *)((void *)0);
  }
#line 2183
  if (! tmp) {
#line 2184
    return;
  }
#line 2186
  if (yy_buffer_stack) {
#line 2186
    tmp___0 = (*(yy_buffer_stack + yy_buffer_stack_top));
  } else {
#line 2186
    tmp___0 = (struct yy_buffer_state *)((void *)0);
  }
#line 2186
  master__delete_buffer(tmp___0);
#line 2187
  (*(yy_buffer_stack + yy_buffer_stack_top)) = (struct yy_buffer_state *)((void *)0);
#line 2188
  if (yy_buffer_stack_top > 0U) {
#line 2189
    yy_buffer_stack_top --;
  }
#line 2191
  if (yy_buffer_stack) {
#line 2191
    tmp___1 = (*(yy_buffer_stack + yy_buffer_stack_top));
  } else {
#line 2191
    tmp___1 = (struct yy_buffer_state *)((void *)0);
  }
#line 2191
  if (tmp___1) {
#line 2192
    master__load_buffer_state();
#line 2193
    yy_did_buffer_switch_on_eof = 1;
  }
#line 2195
  return;
}
}
#line 2200 "master_tok.c"
static void master_ensure_buffer_stack(void) 
{ int num_to_alloc ;
  int grow_size ;

  {
#line 2204
  if (! yy_buffer_stack) {
#line 2210
    num_to_alloc = 1;
#line 2211
    yy_buffer_stack = (YY_BUFFER_STATE *)master_alloc((unsigned int )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 2215
    memset((void *)yy_buffer_stack, 0, (unsigned int )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 2217
    yy_buffer_stack_max = (unsigned int )num_to_alloc;
#line 2218
    yy_buffer_stack_top = 0U;
#line 2219
    return;
  }
#line 2222
  if (yy_buffer_stack_top >= yy_buffer_stack_max - 1U) {
#line 2225
    grow_size = 8;
#line 2227
    num_to_alloc = (int )(yy_buffer_stack_max + (unsigned int )grow_size);
#line 2228
    yy_buffer_stack = (YY_BUFFER_STATE *)master_realloc((void *)yy_buffer_stack, (unsigned int )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 2234
    memset((void *)(yy_buffer_stack + yy_buffer_stack_max), 0, (unsigned int )grow_size * sizeof(struct yy_buffer_state *));
#line 2235
    yy_buffer_stack_max = (unsigned int )num_to_alloc;
  }
#line 2237
  return;
}
}
#line 2245 "master_tok.c"
YY_BUFFER_STATE master__scan_buffer(char *base , yy_size_t size ) 
{ YY_BUFFER_STATE b ;

  {
#line 2249
  if (size < 2U) {
#line 2253
    return ((struct yy_buffer_state *)0);
  } else {
#line 2249
    if ((int )(*(base + (size - 2U))) != 0) {
#line 2253
      return ((struct yy_buffer_state *)0);
    } else {
#line 2249
      if ((int )(*(base + (size - 1U))) != 0) {
#line 2253
        return ((struct yy_buffer_state *)0);
      }
    }
  }
#line 2255
  b = (YY_BUFFER_STATE )master_alloc(sizeof(struct yy_buffer_state ));
#line 2256
  if (! b) {
#line 2257
    yy_fatal_error("out of dynamic memory in master__scan_buffer()");
  }
#line 2259
  b->yy_buf_size = size - 2U;
#line 2260
  b->yy_ch_buf = base;
#line 2260
  b->yy_buf_pos = b->yy_ch_buf;
#line 2261
  b->yy_is_our_buffer = 0;
#line 2262
  b->yy_input_file = (FILE *)0;
#line 2263
  b->yy_n_chars = (int )b->yy_buf_size;
#line 2264
  b->yy_is_interactive = 0;
#line 2265
  b->yy_at_bol = 1;
#line 2266
  b->yy_fill_buffer = 0;
#line 2267
  b->yy_buffer_status = 0;
#line 2269
  master__switch_to_buffer(b);
#line 2271
  return (b);
}
}
#line 2282 "master_tok.c"
YY_BUFFER_STATE master__scan_string(char const   *yystr ) 
{ size_t tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 2285
  tmp = strlen(yystr);
#line 2285
  tmp___0 = master__scan_bytes(yystr, (int )tmp);
#line 2285
  return (tmp___0);
}
}
#line 2295 "master_tok.c"
YY_BUFFER_STATE master__scan_bytes(char const   *yybytes , int _yybytes_len ) 
{ YY_BUFFER_STATE b ;
  char *buf ;
  yy_size_t n ;
  int i ;

  {
#line 2303
  n = (unsigned int )(_yybytes_len + 2);
#line 2304
  buf = (char *)master_alloc(n);
#line 2305
  if (! buf) {
#line 2306
    yy_fatal_error("out of dynamic memory in master__scan_bytes()");
  }
#line 2308
  i = 0;
#line 2308
  while (i < _yybytes_len) {
#line 2309
    (*(buf + i)) = (char )(*(yybytes + i));
#line 2308
    i ++;
  }
#line 2311
  (*(buf + (_yybytes_len + 1))) = (char)0;
#line 2311
  (*(buf + _yybytes_len)) = (*(buf + (_yybytes_len + 1)));
#line 2313
  b = master__scan_buffer(buf, n);
#line 2314
  if (! b) {
#line 2315
    yy_fatal_error("bad buffer in master__scan_bytes()");
  }
#line 2320
  b->yy_is_our_buffer = 1;
#line 2322
  return (b);
}
}
#line 2329 "master_tok.c"
static void yy_fatal_error(char const   *msg ) 
{ 

  {
#line 2331
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s\n", msg);
#line 2332
  exit(2);
}
}
#line 2357 "master_tok.c"
int master_get_lineno(void) 
{ 

  {
#line 2360
  return (master_lineno);
}
}
#line 2366 "master_tok.c"
FILE *master_get_in(void) 
{ 

  {
#line 2368
  return (master_in);
}
}
#line 2374 "master_tok.c"
FILE *master_get_out(void) 
{ 

  {
#line 2376
  return (master_out);
}
}
#line 2382 "master_tok.c"
int master_get_leng(void) 
{ 

  {
#line 2384
  return (master_leng);
}
}
#line 2391 "master_tok.c"
char *master_get_text(void) 
{ 

  {
#line 2393
  return (master_text);
}
}
#line 2400 "master_tok.c"
void master_set_lineno(int line_number ) 
{ 

  {
#line 2403
  master_lineno = line_number;
#line 2404
  return;
}
}
#line 2412 "master_tok.c"
void master_set_in(FILE *in_str ) 
{ 

  {
#line 2414
  master_in = in_str;
#line 2415
  return;
}
}
#line 2417 "master_tok.c"
void master_set_out(FILE *out_str ) 
{ 

  {
#line 2419
  master_out = out_str;
#line 2420
  return;
}
}
#line 2422 "master_tok.c"
int master_get_debug(void) 
{ 

  {
#line 2424
  return (master__flex_debug);
}
}
#line 2427 "master_tok.c"
void master_set_debug(int bdebug ) 
{ 

  {
#line 2429
  master__flex_debug = bdebug;
#line 2430
  return;
}
}
#line 2432 "master_tok.c"
static int yy_init_globals(void) 
{ 

  {
#line 2438
  yy_buffer_stack = (YY_BUFFER_STATE *)0;
#line 2439
  yy_buffer_stack_top = 0U;
#line 2440
  yy_buffer_stack_max = 0U;
#line 2441
  yy_c_buf_p = (char *)0;
#line 2442
  yy_init = 0;
#line 2443
  yy_start = 0;
#line 2445
  yy_state_buf = (yy_state_type *)0;
#line 2446
  yy_state_ptr = (yy_state_type *)0;
#line 2447
  yy_full_match = (char *)0;
#line 2448
  yy_lp = 0;
#line 2455
  master_in = (FILE *)0;
#line 2456
  master_out = (FILE *)0;
#line 2462
  return (0);
}
}
#line 2466 "master_tok.c"
int master_lex_destroy(void) 
{ YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 2470
  while (1) {
#line 2470
    if (yy_buffer_stack) {
#line 2470
      tmp___0 = (*(yy_buffer_stack + yy_buffer_stack_top));
    } else {
#line 2470
      tmp___0 = (struct yy_buffer_state *)((void *)0);
    }
#line 2470
    if (! tmp___0) {
#line 2470
      break;
    }
#line 2471
    if (yy_buffer_stack) {
#line 2471
      tmp = (*(yy_buffer_stack + yy_buffer_stack_top));
    } else {
#line 2471
      tmp = (struct yy_buffer_state *)((void *)0);
    }
#line 2471
    master__delete_buffer(tmp);
#line 2472
    (*(yy_buffer_stack + yy_buffer_stack_top)) = (struct yy_buffer_state *)((void *)0);
#line 2473
    master_pop_buffer_state();
  }
#line 2477
  master_free((void *)yy_buffer_stack);
#line 2478
  yy_buffer_stack = (YY_BUFFER_STATE *)((void *)0);
#line 2480
  master_free((void *)yy_state_buf);
#line 2481
  yy_state_buf = (yy_state_type *)((void *)0);
#line 2485
  yy_init_globals();
#line 2487
  return (0);
}
}
#line 2514 "master_tok.c"
void *master_alloc(yy_size_t size ) 
{ void *tmp ;

  {
#line 2516
  tmp = malloc(size);
#line 2516
  return (tmp);
}
}
#line 2519 "master_tok.c"
void *master_realloc(void *ptr , yy_size_t size ) 
{ void *tmp ;

  {
#line 2528
  tmp = realloc((void *)((char *)ptr), size);
#line 2528
  return (tmp);
}
}
#line 2531 "master_tok.c"
void master_free(void *ptr ) 
{ 

  {
#line 2533
  free((void *)((char *)ptr));
#line 2534
  return;
}
}
#line 349 "master_tok.l"
int master_wrap(void) 
{ 

  {
#line 351
  return (1);
}
}
#line 354 "master_tok.l"
static void master_echo(void) 
{ 

  {
#line 356
  while (1) {
#line 356
    ((*log_debug))(0U, "%s: %s", "master_echo", master_text);
#line 356
    break;
  }
#line 357
  return;
}
}
#line 362 "master_tok.l"
void master_set_scan_buffer(char const   *buffer ) 
{ size_t tmp ;

  {
#line 364
  line = buffer;
#line 365
  line_pos = line + 0;
#line 366
  tmp = strlen(buffer);
#line 366
  line_lim = line + tmp;
#line 367
  return;
}
}
#line 371 "master_tok.l"
int my_yyinput(char *buffer , int max_size ) 
{ int n ;
  int tmp ;

  {
#line 373
  if (max_size < line_lim - line_pos) {
#line 373
    tmp = max_size;
  } else {
#line 373
    tmp = line_lim - line_pos;
  }
#line 373
  n = tmp;
#line 375
  if (n > 0) {
#line 376
    memcpy((void * __restrict  )buffer, (void const   * __restrict  )line_pos, (unsigned int )n);
#line 377
    line_pos += n;
  }
#line 379
  return (n);
}
}
#line 1 "mount_clnt.o"
#pragma merger(0,"/tmp/cil-mjhAlRUi.i","-O2,-Wall,-fPIC")
#line 287 "/usr/include/rpc/xdr.h"
extern  __attribute__((__nothrow__)) bool_t xdr_void(void) ;
#line 153 "mount.h"
void *mountproc_null_1(void *argp , CLIENT *clnt ) ;
#line 156
fhstatus *mountproc_mnt_1(dirpath *argp , CLIENT *clnt ) ;
#line 159
mountlist *mountproc_dump_1(void *argp , CLIENT *clnt ) ;
#line 162
void *mountproc_umnt_1(dirpath *argp , CLIENT *clnt ) ;
#line 165
void *mountproc_umntall_1(void *argp , CLIENT *clnt ) ;
#line 168
exports *mountproc_export_1(void *argp , CLIENT *clnt ) ;
#line 171
exports *mountproc_exportall_1(void *argp , CLIENT *clnt ) ;
#line 202
void *mountproc_null_2(void *argp , CLIENT *clnt ) ;
#line 204
fhstatus *mountproc_mnt_2(dirpath *argp , CLIENT *clnt ) ;
#line 206
mountlist *mountproc_dump_2(void *argp , CLIENT *clnt ) ;
#line 208
void *mountproc_umnt_2(dirpath *argp , CLIENT *clnt ) ;
#line 210
void *mountproc_umntall_2(void *argp , CLIENT *clnt ) ;
#line 212
exports *mountproc_export_2(void *argp , CLIENT *clnt ) ;
#line 214
exports *mountproc_exportall_2(void *argp , CLIENT *clnt ) ;
#line 217
ppathcnf *mountproc_pathconf_2(dirpath *argp , CLIENT *clnt ) ;
#line 245
void *mountproc3_null_3(void *argp , CLIENT *clnt ) ;
#line 248
mountres3 *mountproc3_mnt_3(dirpath *argp , CLIENT *clnt ) ;
#line 251
mountlist *mountproc3_dump_3(void *argp , CLIENT *clnt ) ;
#line 254
void *mountproc3_umnt_3(dirpath *argp , CLIENT *clnt ) ;
#line 257
void *mountproc3_umntall_3(void *argp , CLIENT *clnt ) ;
#line 260
exports *mountproc3_export_3(void *argp , CLIENT *clnt ) ;
#line 290
bool_t xdr_fhstatus(XDR *xdrs , fhstatus *objp ) ;
#line 291
bool_t xdr_dirpath(XDR *xdrs , dirpath *objp ) ;
#line 293
bool_t xdr_mountlist(XDR *xdrs , mountlist *objp ) ;
#line 297
bool_t xdr_exports(XDR *xdrs , exports *objp ) ;
#line 299
bool_t xdr_ppathcnf(XDR *xdrs , ppathcnf *objp ) ;
#line 303
bool_t xdr_mountres3(XDR *xdrs , mountres3 *objp ) ;
#line 44 "mount_clnt.c"
static struct timeval TIMEOUT  =    {25L, 0L};
#line 49 "mount_clnt.c"
static char clnt_res  ;
#line 46 "mount_clnt.c"
void *mountproc_null_1(void *argp , CLIENT *clnt ) 
{ enum clnt_stat tmp ;

  {
#line 51
  memset((void *)(& clnt_res), 0, sizeof(clnt_res));
#line 52
  tmp = ((*((clnt->cl_ops)->cl_call)))(clnt, 0UL, (bool_t (*)(XDR * , void *  , ...))(& xdr_void),
                                       (char *)argp, (bool_t (*)(XDR * , void *  , ...))(& xdr_void),
                                       & clnt_res, TIMEOUT);
#line 52
  if ((int )tmp != 0) {
#line 56
    return ((void *)0);
  }
#line 58
  return ((void *)(& clnt_res));
}
}
#line 64 "mount_clnt.c"
static fhstatus clnt_res___0  ;
#line 61 "mount_clnt.c"
fhstatus *mountproc_mnt_1(dirpath *argp , CLIENT *clnt ) 
{ enum clnt_stat tmp ;

  {
#line 66
  memset((void *)((char *)(& clnt_res___0)), 0, sizeof(clnt_res___0));
#line 67
  tmp = ((*((clnt->cl_ops)->cl_call)))(clnt, 1UL, (bool_t (*)(XDR * , void *  , ...))(& xdr_dirpath),
                                       (char *)argp, (bool_t (*)(XDR * , void *  , ...))(& xdr_fhstatus),
                                       (char *)(& clnt_res___0), TIMEOUT);
#line 67
  if ((int )tmp != 0) {
#line 71
    return ((fhstatus *)((void *)0));
  }
#line 73
  return (& clnt_res___0);
}
}
#line 79 "mount_clnt.c"
static mountlist clnt_res___1  ;
#line 76 "mount_clnt.c"
mountlist *mountproc_dump_1(void *argp , CLIENT *clnt ) 
{ enum clnt_stat tmp ;

  {
#line 81
  memset((void *)((char *)(& clnt_res___1)), 0, sizeof(clnt_res___1));
#line 82
  tmp = ((*((clnt->cl_ops)->cl_call)))(clnt, 2UL, (bool_t (*)(XDR * , void *  , ...))(& xdr_void),
                                       (char *)argp, (bool_t (*)(XDR * , void *  , ...))(& xdr_mountlist),
                                       (char *)(& clnt_res___1), TIMEOUT);
#line 82
  if ((int )tmp != 0) {
#line 86
    return ((mountlist *)((void *)0));
  }
#line 88
  return (& clnt_res___1);
}
}
#line 94 "mount_clnt.c"
static char clnt_res___2  ;
#line 91 "mount_clnt.c"
void *mountproc_umnt_1(dirpath *argp , CLIENT *clnt ) 
{ enum clnt_stat tmp ;

  {
#line 96
  memset((void *)(& clnt_res___2), 0, sizeof(clnt_res___2));
#line 97
  tmp = ((*((clnt->cl_ops)->cl_call)))(clnt, 3UL, (bool_t (*)(XDR * , void *  , ...))(& xdr_dirpath),
                                       (char *)argp, (bool_t (*)(XDR * , void *  , ...))(& xdr_void),
                                       & clnt_res___2, TIMEOUT);
#line 97
  if ((int )tmp != 0) {
#line 101
    return ((void *)0);
  }
#line 103
  return ((void *)(& clnt_res___2));
}
}
#line 109 "mount_clnt.c"
static char clnt_res___3  ;
#line 106 "mount_clnt.c"
void *mountproc_umntall_1(void *argp , CLIENT *clnt ) 
{ enum clnt_stat tmp ;

  {
#line 111
  memset((void *)(& clnt_res___3), 0, sizeof(clnt_res___3));
#line 112
  tmp = ((*((clnt->cl_ops)->cl_call)))(clnt, 4UL, (bool_t (*)(XDR * , void *  , ...))(& xdr_void),
                                       (char *)argp, (bool_t (*)(XDR * , void *  , ...))(& xdr_void),
                                       & clnt_res___3, TIMEOUT);
#line 112
  if ((int )tmp != 0) {
#line 116
    return ((void *)0);
  }
#line 118
  return ((void *)(& clnt_res___3));
}
}
#line 124 "mount_clnt.c"
static exports clnt_res___4  ;
#line 121 "mount_clnt.c"
exports *mountproc_export_1(void *argp , CLIENT *clnt ) 
{ enum clnt_stat tmp ;

  {
#line 126
  memset((void *)((char *)(& clnt_res___4)), 0, sizeof(clnt_res___4));
#line 127
  tmp = ((*((clnt->cl_ops)->cl_call)))(clnt, 5UL, (bool_t (*)(XDR * , void *  , ...))(& xdr_void),
                                       (char *)argp, (bool_t (*)(XDR * , void *  , ...))(& xdr_exports),
                                       (char *)(& clnt_res___4), TIMEOUT);
#line 127
  if ((int )tmp != 0) {
#line 131
    return ((exports *)((void *)0));
  }
#line 133
  return (& clnt_res___4);
}
}
#line 139 "mount_clnt.c"
static exports clnt_res___5  ;
#line 136 "mount_clnt.c"
exports *mountproc_exportall_1(void *argp , CLIENT *clnt ) 
{ enum clnt_stat tmp ;

  {
#line 141
  memset((void *)((char *)(& clnt_res___5)), 0, sizeof(clnt_res___5));
#line 142
  tmp = ((*((clnt->cl_ops)->cl_call)))(clnt, 6UL, (bool_t (*)(XDR * , void *  , ...))(& xdr_void),
                                       (char *)argp, (bool_t (*)(XDR * , void *  , ...))(& xdr_exports),
                                       (char *)(& clnt_res___5), TIMEOUT);
#line 142
  if ((int )tmp != 0) {
#line 146
    return ((exports *)((void *)0));
  }
#line 148
  return (& clnt_res___5);
}
}
#line 154 "mount_clnt.c"
static char clnt_res___6  ;
#line 151 "mount_clnt.c"
void *mountproc_null_2(void *argp , CLIENT *clnt ) 
{ enum clnt_stat tmp ;

  {
#line 156
  memset((void *)(& clnt_res___6), 0, sizeof(clnt_res___6));
#line 157
  tmp = ((*((clnt->cl_ops)->cl_call)))(clnt, 0UL, (bool_t (*)(XDR * , void *  , ...))(& xdr_void),
                                       (char *)argp, (bool_t (*)(XDR * , void *  , ...))(& xdr_void),
                                       & clnt_res___6, TIMEOUT);
#line 157
  if ((int )tmp != 0) {
#line 161
    return ((void *)0);
  }
#line 163
  return ((void *)(& clnt_res___6));
}
}
#line 169 "mount_clnt.c"
static fhstatus clnt_res___7  ;
#line 166 "mount_clnt.c"
fhstatus *mountproc_mnt_2(dirpath *argp , CLIENT *clnt ) 
{ enum clnt_stat tmp ;

  {
#line 171
  memset((void *)((char *)(& clnt_res___7)), 0, sizeof(clnt_res___7));
#line 172
  tmp = ((*((clnt->cl_ops)->cl_call)))(clnt, 1UL, (bool_t (*)(XDR * , void *  , ...))(& xdr_dirpath),
                                       (char *)argp, (bool_t (*)(XDR * , void *  , ...))(& xdr_fhstatus),
                                       (char *)(& clnt_res___7), TIMEOUT);
#line 172
  if ((int )tmp != 0) {
#line 176
    return ((fhstatus *)((void *)0));
  }
#line 178
  return (& clnt_res___7);
}
}
#line 184 "mount_clnt.c"
static mountlist clnt_res___8  ;
#line 181 "mount_clnt.c"
mountlist *mountproc_dump_2(void *argp , CLIENT *clnt ) 
{ enum clnt_stat tmp ;

  {
#line 186
  memset((void *)((char *)(& clnt_res___8)), 0, sizeof(clnt_res___8));
#line 187
  tmp = ((*((clnt->cl_ops)->cl_call)))(clnt, 2UL, (bool_t (*)(XDR * , void *  , ...))(& xdr_void),
                                       (char *)argp, (bool_t (*)(XDR * , void *  , ...))(& xdr_mountlist),
                                       (char *)(& clnt_res___8), TIMEOUT);
#line 187
  if ((int )tmp != 0) {
#line 191
    return ((mountlist *)((void *)0));
  }
#line 193
  return (& clnt_res___8);
}
}
#line 199 "mount_clnt.c"
static char clnt_res___9  ;
#line 196 "mount_clnt.c"
void *mountproc_umnt_2(dirpath *argp , CLIENT *clnt ) 
{ enum clnt_stat tmp ;

  {
#line 201
  memset((void *)(& clnt_res___9), 0, sizeof(clnt_res___9));
#line 202
  tmp = ((*((clnt->cl_ops)->cl_call)))(clnt, 3UL, (bool_t (*)(XDR * , void *  , ...))(& xdr_dirpath),
                                       (char *)argp, (bool_t (*)(XDR * , void *  , ...))(& xdr_void),
                                       & clnt_res___9, TIMEOUT);
#line 202
  if ((int )tmp != 0) {
#line 206
    return ((void *)0);
  }
#line 208
  return ((void *)(& clnt_res___9));
}
}
#line 214 "mount_clnt.c"
static char clnt_res___10  ;
#line 211 "mount_clnt.c"
void *mountproc_umntall_2(void *argp , CLIENT *clnt ) 
{ enum clnt_stat tmp ;

  {
#line 216
  memset((void *)(& clnt_res___10), 0, sizeof(clnt_res___10));
#line 217
  tmp = ((*((clnt->cl_ops)->cl_call)))(clnt, 4UL, (bool_t (*)(XDR * , void *  , ...))(& xdr_void),
                                       (char *)argp, (bool_t (*)(XDR * , void *  , ...))(& xdr_void),
                                       & clnt_res___10, TIMEOUT);
#line 217
  if ((int )tmp != 0) {
#line 221
    return ((void *)0);
  }
#line 223
  return ((void *)(& clnt_res___10));
}
}
#line 229 "mount_clnt.c"
static exports clnt_res___11  ;
#line 226 "mount_clnt.c"
exports *mountproc_export_2(void *argp , CLIENT *clnt ) 
{ enum clnt_stat tmp ;

  {
#line 231
  memset((void *)((char *)(& clnt_res___11)), 0, sizeof(clnt_res___11));
#line 232
  tmp = ((*((clnt->cl_ops)->cl_call)))(clnt, 5UL, (bool_t (*)(XDR * , void *  , ...))(& xdr_void),
                                       (char *)argp, (bool_t (*)(XDR * , void *  , ...))(& xdr_exports),
                                       (char *)(& clnt_res___11), TIMEOUT);
#line 232
  if ((int )tmp != 0) {
#line 236
    return ((exports *)((void *)0));
  }
#line 238
  return (& clnt_res___11);
}
}
#line 244 "mount_clnt.c"
static exports clnt_res___12  ;
#line 241 "mount_clnt.c"
exports *mountproc_exportall_2(void *argp , CLIENT *clnt ) 
{ enum clnt_stat tmp ;

  {
#line 246
  memset((void *)((char *)(& clnt_res___12)), 0, sizeof(clnt_res___12));
#line 247
  tmp = ((*((clnt->cl_ops)->cl_call)))(clnt, 6UL, (bool_t (*)(XDR * , void *  , ...))(& xdr_void),
                                       (char *)argp, (bool_t (*)(XDR * , void *  , ...))(& xdr_exports),
                                       (char *)(& clnt_res___12), TIMEOUT);
#line 247
  if ((int )tmp != 0) {
#line 251
    return ((exports *)((void *)0));
  }
#line 253
  return (& clnt_res___12);
}
}
#line 259 "mount_clnt.c"
static ppathcnf clnt_res___13  ;
#line 256 "mount_clnt.c"
ppathcnf *mountproc_pathconf_2(dirpath *argp , CLIENT *clnt ) 
{ enum clnt_stat tmp ;

  {
#line 261
  memset((void *)((char *)(& clnt_res___13)), 0, sizeof(clnt_res___13));
#line 262
  tmp = ((*((clnt->cl_ops)->cl_call)))(clnt, 7UL, (bool_t (*)(XDR * , void *  , ...))(& xdr_dirpath),
                                       (char *)argp, (bool_t (*)(XDR * , void *  , ...))(& xdr_ppathcnf),
                                       (char *)(& clnt_res___13), TIMEOUT);
#line 262
  if ((int )tmp != 0) {
#line 266
    return ((ppathcnf *)((void *)0));
  }
#line 268
  return (& clnt_res___13);
}
}
#line 274 "mount_clnt.c"
static char clnt_res___14  ;
#line 271 "mount_clnt.c"
void *mountproc3_null_3(void *argp , CLIENT *clnt ) 
{ enum clnt_stat tmp ;

  {
#line 276
  memset((void *)(& clnt_res___14), 0, sizeof(clnt_res___14));
#line 277
  tmp = ((*((clnt->cl_ops)->cl_call)))(clnt, 0UL, (bool_t (*)(XDR * , void *  , ...))(& xdr_void),
                                       (char *)argp, (bool_t (*)(XDR * , void *  , ...))(& xdr_void),
                                       & clnt_res___14, TIMEOUT);
#line 277
  if ((int )tmp != 0) {
#line 281
    return ((void *)0);
  }
#line 283
  return ((void *)(& clnt_res___14));
}
}
#line 289 "mount_clnt.c"
static mountres3 clnt_res___15  ;
#line 286 "mount_clnt.c"
mountres3 *mountproc3_mnt_3(dirpath *argp , CLIENT *clnt ) 
{ enum clnt_stat tmp ;

  {
#line 291
  memset((void *)((char *)(& clnt_res___15)), 0, sizeof(clnt_res___15));
#line 292
  tmp = ((*((clnt->cl_ops)->cl_call)))(clnt, 1UL, (bool_t (*)(XDR * , void *  , ...))(& xdr_dirpath),
                                       (char *)argp, (bool_t (*)(XDR * , void *  , ...))(& xdr_mountres3),
                                       (char *)(& clnt_res___15), TIMEOUT);
#line 292
  if ((int )tmp != 0) {
#line 296
    return ((mountres3 *)((void *)0));
  }
#line 298
  return (& clnt_res___15);
}
}
#line 304 "mount_clnt.c"
static mountlist clnt_res___16  ;
#line 301 "mount_clnt.c"
mountlist *mountproc3_dump_3(void *argp , CLIENT *clnt ) 
{ enum clnt_stat tmp ;

  {
#line 306
  memset((void *)((char *)(& clnt_res___16)), 0, sizeof(clnt_res___16));
#line 307
  tmp = ((*((clnt->cl_ops)->cl_call)))(clnt, 2UL, (bool_t (*)(XDR * , void *  , ...))(& xdr_void),
                                       (char *)argp, (bool_t (*)(XDR * , void *  , ...))(& xdr_mountlist),
                                       (char *)(& clnt_res___16), TIMEOUT);
#line 307
  if ((int )tmp != 0) {
#line 311
    return ((mountlist *)((void *)0));
  }
#line 313
  return (& clnt_res___16);
}
}
#line 319 "mount_clnt.c"
static char clnt_res___17  ;
#line 316 "mount_clnt.c"
void *mountproc3_umnt_3(dirpath *argp , CLIENT *clnt ) 
{ enum clnt_stat tmp ;

  {
#line 321
  memset((void *)(& clnt_res___17), 0, sizeof(clnt_res___17));
#line 322
  tmp = ((*((clnt->cl_ops)->cl_call)))(clnt, 3UL, (bool_t (*)(XDR * , void *  , ...))(& xdr_dirpath),
                                       (char *)argp, (bool_t (*)(XDR * , void *  , ...))(& xdr_void),
                                       & clnt_res___17, TIMEOUT);
#line 322
  if ((int )tmp != 0) {
#line 326
    return ((void *)0);
  }
#line 328
  return ((void *)(& clnt_res___17));
}
}
#line 334 "mount_clnt.c"
static char clnt_res___18  ;
#line 331 "mount_clnt.c"
void *mountproc3_umntall_3(void *argp , CLIENT *clnt ) 
{ enum clnt_stat tmp ;

  {
#line 336
  memset((void *)(& clnt_res___18), 0, sizeof(clnt_res___18));
#line 337
  tmp = ((*((clnt->cl_ops)->cl_call)))(clnt, 4UL, (bool_t (*)(XDR * , void *  , ...))(& xdr_void),
                                       (char *)argp, (bool_t (*)(XDR * , void *  , ...))(& xdr_void),
                                       & clnt_res___18, TIMEOUT);
#line 337
  if ((int )tmp != 0) {
#line 341
    return ((void *)0);
  }
#line 343
  return ((void *)(& clnt_res___18));
}
}
#line 349 "mount_clnt.c"
static exports clnt_res___19  ;
#line 346 "mount_clnt.c"
exports *mountproc3_export_3(void *argp , CLIENT *clnt ) 
{ enum clnt_stat tmp ;

  {
#line 351
  memset((void *)((char *)(& clnt_res___19)), 0, sizeof(clnt_res___19));
#line 352
  tmp = ((*((clnt->cl_ops)->cl_call)))(clnt, 5UL, (bool_t (*)(XDR * , void *  , ...))(& xdr_void),
                                       (char *)argp, (bool_t (*)(XDR * , void *  , ...))(& xdr_exports),
                                       (char *)(& clnt_res___19), TIMEOUT);
#line 352
  if ((int )tmp != 0) {
#line 356
    return ((exports *)((void *)0));
  }
#line 358
  return (& clnt_res___19);
}
}
#line 1 "mount_xdr.o"
#pragma merger(0,"/tmp/cil-ibgSRb1p.i","-O2,-Wall,-fPIC,-Wno-unused-variable")
#line 288 "/usr/include/rpc/xdr.h"
extern  __attribute__((__nothrow__)) bool_t xdr_short(XDR *__xdrs , short *__sp ) ;
#line 290
extern  __attribute__((__nothrow__)) bool_t xdr_int(XDR *__xdrs , int *__ip ) ;
#line 291
extern  __attribute__((__nothrow__)) bool_t xdr_u_int(XDR *__xdrs , u_int *__up ) ;
#line 309
extern  __attribute__((__nothrow__)) bool_t xdr_enum(XDR *__xdrs , enum_t *__ep ) ;
#line 310
extern  __attribute__((__nothrow__)) bool_t xdr_array(XDR *_xdrs , caddr_t *__addrp ,
                                                      u_int *__sizep , u_int __maxsize ,
                                                      u_int __elsize , bool_t (*__elproc)(XDR * ,
                                                                                          void * 
                                                                                          , ...) ) ;
#line 313
extern  __attribute__((__nothrow__)) bool_t xdr_bytes(XDR *__xdrs , char **__cpp ,
                                                      u_int *__sizep , u_int __maxsize ) ;
#line 315
extern  __attribute__((__nothrow__)) bool_t xdr_opaque(XDR *__xdrs , caddr_t __cp ,
                                                       u_int __cnt ) ;
#line 316
extern  __attribute__((__nothrow__)) bool_t xdr_string(XDR *__xdrs , char **__cpp ,
                                                       u_int __maxsize ) ;
#line 320
extern  __attribute__((__nothrow__)) bool_t xdr_char(XDR *__xdrs , char *__cp ) ;
#line 321
extern  __attribute__((__nothrow__)) bool_t xdr_u_char(XDR *__xdrs , u_char *__cp ) ;
#line 322
extern  __attribute__((__nothrow__)) bool_t xdr_vector(XDR *__xdrs , char *__basep ,
                                                       u_int __nelem , u_int __elemsize ,
                                                       bool_t (*__xdr_elem)(XDR * ,
                                                                            void * 
                                                                            , ...) ) ;
#line 328
extern  __attribute__((__nothrow__)) bool_t xdr_pointer(XDR *__xdrs , char **__objpp ,
                                                        u_int __obj_size , bool_t (*__xdr_obj)(XDR * ,
                                                                                               void * 
                                                                                               , ...) ) ;
#line 289 "mount.h"
bool_t xdr_fhandle(XDR *xdrs , char *objp ) ;
#line 292
bool_t xdr_name(XDR *xdrs , name *objp ) ;
#line 294
bool_t xdr_mountbody(XDR *xdrs , mountbody *objp ) ;
#line 295
bool_t xdr_groups(XDR *xdrs , groups *objp ) ;
#line 296
bool_t xdr_groupnode(XDR *xdrs , groupnode *objp ) ;
#line 298
bool_t xdr_exportnode(XDR *xdrs , exportnode *objp ) ;
#line 300
bool_t xdr_fhandle3(XDR *xdrs , fhandle3 *objp ) ;
#line 301
bool_t xdr_mountstat3(XDR *xdrs , mountstat3 *objp ) ;
#line 302
bool_t xdr_mountres3_ok(XDR *xdrs , mountres3_ok *objp ) ;
#line 42 "mount_xdr.c"
bool_t xdr_fhandle(XDR *xdrs , char *objp ) 
{ bool_t tmp ;

  {
#line 47
  tmp = xdr_opaque(xdrs, objp, 32U);
#line 47
  if (! tmp) {
#line 48
    return (0);
  }
#line 49
  return (1);
}
}
#line 52 "mount_xdr.c"
bool_t xdr_fhstatus(XDR *xdrs , fhstatus *objp ) 
{ bool_t tmp ;
  bool_t tmp___0 ;

  {
#line 57
  tmp = xdr_u_int(xdrs, & objp->fhs_status);
#line 57
  if (! tmp) {
#line 58
    return (0);
  }
#line 59
  switch ((int )objp->fhs_status) {
  case 0: 
#line 61
  tmp___0 = xdr_fhandle(xdrs, objp->fhstatus_u.fhs_fhandle);
#line 61
  if (! tmp___0) {
#line 62
    return (0);
  }
#line 63
  break;
  default: ;
#line 65
  break;
  }
#line 67
  return (1);
}
}
#line 70 "mount_xdr.c"
bool_t xdr_dirpath(XDR *xdrs , dirpath *objp ) 
{ bool_t tmp ;

  {
#line 75
  tmp = xdr_string(xdrs, objp, 1024U);
#line 75
  if (! tmp) {
#line 76
    return (0);
  }
#line 77
  return (1);
}
}
#line 80 "mount_xdr.c"
bool_t xdr_name(XDR *xdrs , name *objp ) 
{ bool_t tmp ;

  {
#line 85
  tmp = xdr_string(xdrs, objp, 255U);
#line 85
  if (! tmp) {
#line 86
    return (0);
  }
#line 87
  return (1);
}
}
#line 90 "mount_xdr.c"
bool_t xdr_mountlist(XDR *xdrs , mountlist *objp ) 
{ bool_t tmp ;

  {
#line 95
  tmp = xdr_pointer(xdrs, (char **)objp, sizeof(struct mountbody ), (bool_t (*)(XDR * ,
                                                                                void * 
                                                                                , ...))(& xdr_mountbody));
#line 95
  if (! tmp) {
#line 96
    return (0);
  }
#line 97
  return (1);
}
}
#line 100 "mount_xdr.c"
bool_t xdr_mountbody(XDR *xdrs , mountbody *objp ) 
{ bool_t tmp ;
  bool_t tmp___0 ;
  bool_t tmp___1 ;

  {
#line 105
  tmp = xdr_name(xdrs, & objp->ml_hostname);
#line 105
  if (! tmp) {
#line 106
    return (0);
  }
#line 107
  tmp___0 = xdr_dirpath(xdrs, & objp->ml_directory);
#line 107
  if (! tmp___0) {
#line 108
    return (0);
  }
#line 109
  tmp___1 = xdr_mountlist(xdrs, & objp->ml_next);
#line 109
  if (! tmp___1) {
#line 110
    return (0);
  }
#line 111
  return (1);
}
}
#line 114 "mount_xdr.c"
bool_t xdr_groups(XDR *xdrs , groups *objp ) 
{ bool_t tmp ;

  {
#line 119
  tmp = xdr_pointer(xdrs, (char **)objp, sizeof(struct groupnode ), (bool_t (*)(XDR * ,
                                                                                void * 
                                                                                , ...))(& xdr_groupnode));
#line 119
  if (! tmp) {
#line 120
    return (0);
  }
#line 121
  return (1);
}
}
#line 124 "mount_xdr.c"
bool_t xdr_groupnode(XDR *xdrs , groupnode *objp ) 
{ bool_t tmp ;
  bool_t tmp___0 ;

  {
#line 129
  tmp = xdr_name(xdrs, & objp->gr_name);
#line 129
  if (! tmp) {
#line 130
    return (0);
  }
#line 131
  tmp___0 = xdr_groups(xdrs, & objp->gr_next);
#line 131
  if (! tmp___0) {
#line 132
    return (0);
  }
#line 133
  return (1);
}
}
#line 136 "mount_xdr.c"
bool_t xdr_exports(XDR *xdrs , exports *objp ) 
{ bool_t tmp ;

  {
#line 141
  tmp = xdr_pointer(xdrs, (char **)objp, sizeof(struct exportnode ), (bool_t (*)(XDR * ,
                                                                                 void * 
                                                                                 , ...))(& xdr_exportnode));
#line 141
  if (! tmp) {
#line 142
    return (0);
  }
#line 143
  return (1);
}
}
#line 146 "mount_xdr.c"
bool_t xdr_exportnode(XDR *xdrs , exportnode *objp ) 
{ bool_t tmp ;
  bool_t tmp___0 ;
  bool_t tmp___1 ;

  {
#line 151
  tmp = xdr_dirpath(xdrs, & objp->ex_dir);
#line 151
  if (! tmp) {
#line 152
    return (0);
  }
#line 153
  tmp___0 = xdr_groups(xdrs, & objp->ex_groups);
#line 153
  if (! tmp___0) {
#line 154
    return (0);
  }
#line 155
  tmp___1 = xdr_exports(xdrs, & objp->ex_next);
#line 155
  if (! tmp___1) {
#line 156
    return (0);
  }
#line 157
  return (1);
}
}
#line 160 "mount_xdr.c"
bool_t xdr_ppathcnf(XDR *xdrs , ppathcnf *objp ) 
{ register int32_t *buf ;
  int i ;
  bool_t tmp ;
  bool_t tmp___0 ;
  bool_t tmp___1 ;
  bool_t tmp___2 ;
  bool_t tmp___3 ;
  bool_t tmp___4 ;
  int32_t *tmp___5 ;
  register unsigned int __v ;
  register unsigned int __x ;
  int32_t *tmp___6 ;
  register unsigned int __v___0 ;
  register unsigned int __x___0 ;
  int32_t *tmp___7 ;
  register unsigned int __v___1 ;
  register unsigned int __x___1 ;
  int32_t *tmp___8 ;
  register unsigned int __v___2 ;
  register unsigned int __x___2 ;
  int32_t *tmp___9 ;
  register unsigned int __v___3 ;
  register unsigned int __x___3 ;
  int32_t *tmp___10 ;
  register unsigned int __v___4 ;
  register unsigned int __x___4 ;
  bool_t tmp___11 ;
  bool_t tmp___12 ;
  bool_t tmp___13 ;
  register short *genp ;
  int32_t *tmp___14 ;
  register unsigned int __v___5 ;
  register unsigned int __x___5 ;
  short *tmp___15 ;
  bool_t tmp___16 ;
  bool_t tmp___17 ;
  bool_t tmp___18 ;
  bool_t tmp___19 ;
  bool_t tmp___20 ;
  bool_t tmp___21 ;
  register unsigned int __v___6 ;
  register unsigned int __x___6 ;
  int32_t *tmp___22 ;
  register unsigned int __v___7 ;
  register unsigned int __x___7 ;
  int32_t *tmp___23 ;
  register unsigned int __v___8 ;
  register unsigned int __x___8 ;
  int32_t *tmp___24 ;
  register unsigned int __v___9 ;
  register unsigned int __x___9 ;
  int32_t *tmp___25 ;
  register unsigned int __v___10 ;
  register unsigned int __x___10 ;
  int32_t *tmp___26 ;
  register unsigned int __v___11 ;
  register unsigned int __x___11 ;
  int32_t *tmp___27 ;
  bool_t tmp___28 ;
  bool_t tmp___29 ;
  bool_t tmp___30 ;
  register short *genp___0 ;
  short *tmp___31 ;
  register unsigned int __v___12 ;
  register unsigned int __x___12 ;
  int32_t *tmp___32 ;
  bool_t tmp___33 ;
  bool_t tmp___34 ;
  bool_t tmp___35 ;
  bool_t tmp___36 ;
  bool_t tmp___37 ;
  bool_t tmp___38 ;
  bool_t tmp___39 ;
  bool_t tmp___40 ;
  bool_t tmp___41 ;

  {
#line 167
  if ((int )xdrs->x_op == 0) {
#line 168
    buf = ((*((xdrs->x_ops)->x_inline)))(xdrs, 24U);
#line 169
    if ((unsigned int )buf == (unsigned int )((void *)0)) {
#line 170
      tmp = xdr_int(xdrs, & objp->pc_link_max);
#line 170
      if (! tmp) {
#line 171
        return (0);
      }
#line 172
      tmp___0 = xdr_short(xdrs, & objp->pc_max_canon);
#line 172
      if (! tmp___0) {
#line 173
        return (0);
      }
#line 174
      tmp___1 = xdr_short(xdrs, & objp->pc_max_input);
#line 174
      if (! tmp___1) {
#line 175
        return (0);
      }
#line 176
      tmp___2 = xdr_short(xdrs, & objp->pc_name_max);
#line 176
      if (! tmp___2) {
#line 177
        return (0);
      }
#line 178
      tmp___3 = xdr_short(xdrs, & objp->pc_path_max);
#line 178
      if (! tmp___3) {
#line 179
        return (0);
      }
#line 180
      tmp___4 = xdr_short(xdrs, & objp->pc_pipe_buf);
#line 180
      if (! tmp___4) {
#line 181
        return (0);
      }
    } else {
#line 184
      tmp___5 = buf;
#line 184
      buf ++;
#line 184
      __x = (unsigned int )((long )objp->pc_link_max);
#line 184
      __asm__  ("bswap %0": "=r" (__v): "0" (__x));
#line 184
      (*tmp___5) = (int )__v;
#line 185
      tmp___6 = buf;
#line 185
      buf ++;
#line 185
      __x___0 = (unsigned int )((long )objp->pc_max_canon);
#line 185
      __asm__  ("bswap %0": "=r" (__v___0): "0" (__x___0));
#line 185
      (*tmp___6) = (int )__v___0;
#line 186
      tmp___7 = buf;
#line 186
      buf ++;
#line 186
      __x___1 = (unsigned int )((long )objp->pc_max_input);
#line 186
      __asm__  ("bswap %0": "=r" (__v___1): "0" (__x___1));
#line 186
      (*tmp___7) = (int )__v___1;
#line 187
      tmp___8 = buf;
#line 187
      buf ++;
#line 187
      __x___2 = (unsigned int )((long )objp->pc_name_max);
#line 187
      __asm__  ("bswap %0": "=r" (__v___2): "0" (__x___2));
#line 187
      (*tmp___8) = (int )__v___2;
#line 188
      tmp___9 = buf;
#line 188
      buf ++;
#line 188
      __x___3 = (unsigned int )((long )objp->pc_path_max);
#line 188
      __asm__  ("bswap %0": "=r" (__v___3): "0" (__x___3));
#line 188
      (*tmp___9) = (int )__v___3;
#line 189
      tmp___10 = buf;
#line 189
      buf ++;
#line 189
      __x___4 = (unsigned int )((long )objp->pc_pipe_buf);
#line 189
      __asm__  ("bswap %0": "=r" (__v___4): "0" (__x___4));
#line 189
      (*tmp___10) = (int )__v___4;
    }
#line 191
    tmp___11 = xdr_u_char(xdrs, & objp->pc_vdisable);
#line 191
    if (! tmp___11) {
#line 192
      return (0);
    }
#line 193
    tmp___12 = xdr_char(xdrs, & objp->pc_xxx);
#line 193
    if (! tmp___12) {
#line 194
      return (0);
    }
#line 195
    buf = ((*((xdrs->x_ops)->x_inline)))(xdrs, 8U);
#line 196
    if ((unsigned int )buf == (unsigned int )((void *)0)) {
#line 197
      tmp___13 = xdr_vector(xdrs, (char *)(objp->pc_mask), 2U, sizeof(short ), (bool_t (*)(XDR * ,
                                                                                           void * 
                                                                                           , ...))(& xdr_short));
#line 197
      if (! tmp___13) {
#line 199
        return (0);
      }
    } else {
#line 204
      i = 0;
#line 204
      genp = objp->pc_mask;
#line 204
      while (i < 2) {
#line 206
        tmp___14 = buf;
#line 206
        buf ++;
#line 206
        tmp___15 = genp;
#line 206
        genp ++;
#line 206
        __x___5 = (unsigned int )((long )(*tmp___15));
#line 206
        __asm__  ("bswap %0": "=r" (__v___5): "0" (__x___5));
#line 206
        (*tmp___14) = (int )__v___5;
#line 204
        i ++;
      }
    }
#line 210
    return (1);
  } else {
#line 211
    if ((int )xdrs->x_op == 1) {
#line 212
      buf = ((*((xdrs->x_ops)->x_inline)))(xdrs, 24U);
#line 213
      if ((unsigned int )buf == (unsigned int )((void *)0)) {
#line 214
        tmp___16 = xdr_int(xdrs, & objp->pc_link_max);
#line 214
        if (! tmp___16) {
#line 215
          return (0);
        }
#line 216
        tmp___17 = xdr_short(xdrs, & objp->pc_max_canon);
#line 216
        if (! tmp___17) {
#line 217
          return (0);
        }
#line 218
        tmp___18 = xdr_short(xdrs, & objp->pc_max_input);
#line 218
        if (! tmp___18) {
#line 219
          return (0);
        }
#line 220
        tmp___19 = xdr_short(xdrs, & objp->pc_name_max);
#line 220
        if (! tmp___19) {
#line 221
          return (0);
        }
#line 222
        tmp___20 = xdr_short(xdrs, & objp->pc_path_max);
#line 222
        if (! tmp___20) {
#line 223
          return (0);
        }
#line 224
        tmp___21 = xdr_short(xdrs, & objp->pc_pipe_buf);
#line 224
        if (! tmp___21) {
#line 225
          return (0);
        }
      } else {
#line 228
        tmp___22 = buf;
#line 228
        buf ++;
#line 228
        __x___6 = (unsigned int )(*tmp___22);
#line 228
        __asm__  ("bswap %0": "=r" (__v___6): "0" (__x___6));
#line 228
        objp->pc_link_max = (int )((long )((unsigned int )((int )__v___6)));
#line 229
        tmp___23 = buf;
#line 229
        buf ++;
#line 229
        __x___7 = (unsigned int )(*tmp___23);
#line 229
        __asm__  ("bswap %0": "=r" (__v___7): "0" (__x___7));
#line 229
        objp->pc_max_canon = (short )((long )((unsigned int )((int )__v___7)));
#line 230
        tmp___24 = buf;
#line 230
        buf ++;
#line 230
        __x___8 = (unsigned int )(*tmp___24);
#line 230
        __asm__  ("bswap %0": "=r" (__v___8): "0" (__x___8));
#line 230
        objp->pc_max_input = (short )((long )((unsigned int )((int )__v___8)));
#line 231
        tmp___25 = buf;
#line 231
        buf ++;
#line 231
        __x___9 = (unsigned int )(*tmp___25);
#line 231
        __asm__  ("bswap %0": "=r" (__v___9): "0" (__x___9));
#line 231
        objp->pc_name_max = (short )((long )((unsigned int )((int )__v___9)));
#line 232
        tmp___26 = buf;
#line 232
        buf ++;
#line 232
        __x___10 = (unsigned int )(*tmp___26);
#line 232
        __asm__  ("bswap %0": "=r" (__v___10): "0" (__x___10));
#line 232
        objp->pc_path_max = (short )((long )((unsigned int )((int )__v___10)));
#line 233
        tmp___27 = buf;
#line 233
        buf ++;
#line 233
        __x___11 = (unsigned int )(*tmp___27);
#line 233
        __asm__  ("bswap %0": "=r" (__v___11): "0" (__x___11));
#line 233
        objp->pc_pipe_buf = (short )((long )((unsigned int )((int )__v___11)));
      }
#line 235
      tmp___28 = xdr_u_char(xdrs, & objp->pc_vdisable);
#line 235
      if (! tmp___28) {
#line 236
        return (0);
      }
#line 237
      tmp___29 = xdr_char(xdrs, & objp->pc_xxx);
#line 237
      if (! tmp___29) {
#line 238
        return (0);
      }
#line 239
      buf = ((*((xdrs->x_ops)->x_inline)))(xdrs, 8U);
#line 240
      if ((unsigned int )buf == (unsigned int )((void *)0)) {
#line 241
        tmp___30 = xdr_vector(xdrs, (char *)(objp->pc_mask), 2U, sizeof(short ), (bool_t (*)(XDR * ,
                                                                                             void * 
                                                                                             , ...))(& xdr_short));
#line 241
        if (! tmp___30) {
#line 243
          return (0);
        }
      } else {
#line 248
        i = 0;
#line 248
        genp___0 = objp->pc_mask;
#line 248
        while (i < 2) {
#line 250
          tmp___31 = genp___0;
#line 250
          genp___0 ++;
#line 250
          tmp___32 = buf;
#line 250
          buf ++;
#line 250
          __x___12 = (unsigned int )(*tmp___32);
#line 250
          __asm__  ("bswap %0": "=r" (__v___12): "0" (__x___12));
#line 250
          (*tmp___31) = (short )((long )((unsigned int )((int )__v___12)));
#line 248
          i ++;
        }
      }
#line 254
      return (1);
    }
  }
#line 257
  tmp___33 = xdr_int(xdrs, & objp->pc_link_max);
#line 257
  if (! tmp___33) {
#line 258
    return (0);
  }
#line 259
  tmp___34 = xdr_short(xdrs, & objp->pc_max_canon);
#line 259
  if (! tmp___34) {
#line 260
    return (0);
  }
#line 261
  tmp___35 = xdr_short(xdrs, & objp->pc_max_input);
#line 261
  if (! tmp___35) {
#line 262
    return (0);
  }
#line 263
  tmp___36 = xdr_short(xdrs, & objp->pc_name_max);
#line 263
  if (! tmp___36) {
#line 264
    return (0);
  }
#line 265
  tmp___37 = xdr_short(xdrs, & objp->pc_path_max);
#line 265
  if (! tmp___37) {
#line 266
    return (0);
  }
#line 267
  tmp___38 = xdr_short(xdrs, & objp->pc_pipe_buf);
#line 267
  if (! tmp___38) {
#line 268
    return (0);
  }
#line 269
  tmp___39 = xdr_u_char(xdrs, & objp->pc_vdisable);
#line 269
  if (! tmp___39) {
#line 270
    return (0);
  }
#line 271
  tmp___40 = xdr_char(xdrs, & objp->pc_xxx);
#line 271
  if (! tmp___40) {
#line 272
    return (0);
  }
#line 273
  tmp___41 = xdr_vector(xdrs, (char *)(objp->pc_mask), 2U, sizeof(short ), (bool_t (*)(XDR * ,
                                                                                       void * 
                                                                                       , ...))(& xdr_short));
#line 273
  if (! tmp___41) {
#line 275
    return (0);
  }
#line 276
  return (1);
}
}
#line 279 "mount_xdr.c"
bool_t xdr_fhandle3(XDR *xdrs , fhandle3 *objp ) 
{ bool_t tmp ;

  {
#line 284
  tmp = xdr_bytes(xdrs, & objp->fhandle3_val, & objp->fhandle3_len, 64U);
#line 284
  if (! tmp) {
#line 285
    return (0);
  }
#line 286
  return (1);
}
}
#line 289 "mount_xdr.c"
bool_t xdr_mountstat3(XDR *xdrs , mountstat3 *objp ) 
{ bool_t tmp ;

  {
#line 294
  tmp = xdr_enum(xdrs, (enum_t *)objp);
#line 294
  if (! tmp) {
#line 295
    return (0);
  }
#line 296
  return (1);
}
}
#line 299 "mount_xdr.c"
bool_t xdr_mountres3_ok(XDR *xdrs , mountres3_ok *objp ) 
{ bool_t tmp ;
  bool_t tmp___0 ;

  {
#line 304
  tmp = xdr_fhandle3(xdrs, & objp->fhandle);
#line 304
  if (! tmp) {
#line 305
    return (0);
  }
#line 306
  tmp___0 = xdr_array(xdrs, (char **)(& objp->auth_flavors.auth_flavors_val), & objp->auth_flavors.auth_flavors_len,
                      (unsigned int )(~ 0), sizeof(int ), (bool_t (*)(XDR * , void * 
                                                                      , ...))(& xdr_int));
#line 306
  if (! tmp___0) {
#line 308
    return (0);
  }
#line 309
  return (1);
}
}
#line 312 "mount_xdr.c"
bool_t xdr_mountres3(XDR *xdrs , mountres3 *objp ) 
{ bool_t tmp ;
  bool_t tmp___0 ;

  {
#line 317
  tmp = xdr_mountstat3(xdrs, & objp->fhs_status);
#line 317
  if (! tmp) {
#line 318
    return (0);
  }
#line 319
  switch ((int )objp->fhs_status) {
  case 0: 
#line 321
  tmp___0 = xdr_mountres3_ok(xdrs, & objp->mountres3_u.mountinfo);
#line 321
  if (! tmp___0) {
#line 322
    return (0);
  }
#line 323
  break;
  default: ;
#line 325
  break;
  }
#line 327
  return (1);
}
}
#line 1 "mounts.o"
#pragma merger(0,"/tmp/cil-9Rg6ts2G.i","-O2,-Wall,-fPIC")
#line 729 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *mkdtemp(char *__template )  __attribute__((__nonnull__(1))) ;
#line 67 "/usr/include/mntent.h"
extern  __attribute__((__nothrow__)) FILE *setmntent(char const   *__file , char const   *__mode ) ;
#line 76
extern  __attribute__((__nothrow__)) struct mntent *getmntent_r(FILE * __restrict  __stream ,
                                                                struct mntent * __restrict  __result ,
                                                                char * __restrict  __buffer ,
                                                                int __bufsize ) ;
#line 88
extern  __attribute__((__nothrow__)) int endmntent(FILE *__stream ) ;
#line 92
extern  __attribute__((__nothrow__)) char *hasmntopt(struct mntent  const  *__mnt ,
                                                     char const   *__opt ) ;
#line 411 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...) ;
#line 359 "../include/automount.h"
char *make_mnt_name_string(char *path___1 ) ;
#line 361
struct mnt_list *reverse_mnt_list(struct mnt_list *list ) ;
#line 365
int has_fstab_option(char const   *opt ) ;
#line 366
char *find_mnt_ino(char const   *table , dev_t dev , ino_t ino ) ;
#line 367
char *get_offset(char const   *prefix , char *offset , struct list_head *head , struct list_head **pos ) ;
#line 369
void add_ordered_list(struct mnt_list *ent , struct list_head *head ) ;
#line 373
int tree_get_mnt_sublist(struct mnt_list *mnts , struct list_head *list , char const   *path___1 ,
                         int include ) ;
#line 374
int tree_find_mnt_ents(struct mnt_list *mnts , struct list_head *list , char const   *path___1 ) ;
#line 32 "mounts.c"
static char const   options_template[37]  = 
#line 32 "mounts.c"
  {      (char const   )'f',      (char const   )'d',      (char const   )'=',      (char const   )'%', 
        (char const   )'d',      (char const   )',',      (char const   )'p',      (char const   )'g', 
        (char const   )'r',      (char const   )'p',      (char const   )'=',      (char const   )'%', 
        (char const   )'u',      (char const   )',',      (char const   )'m',      (char const   )'i', 
        (char const   )'n',      (char const   )'p',      (char const   )'r',      (char const   )'o', 
        (char const   )'t',      (char const   )'o',      (char const   )'=',      (char const   )'5', 
        (char const   )',',      (char const   )'m',      (char const   )'a',      (char const   )'x', 
        (char const   )'p',      (char const   )'r',      (char const   )'o',      (char const   )'t', 
        (char const   )'o',      (char const   )'=',      (char const   )'%',      (char const   )'d', 
        (char const   )'\000'};
#line 33 "mounts.c"
static char const   options_template_extra[40]  = 
#line 33
  {      (char const   )'f',      (char const   )'d',      (char const   )'=',      (char const   )'%', 
        (char const   )'d',      (char const   )',',      (char const   )'p',      (char const   )'g', 
        (char const   )'r',      (char const   )'p',      (char const   )'=',      (char const   )'%', 
        (char const   )'u',      (char const   )',',      (char const   )'m',      (char const   )'i', 
        (char const   )'n',      (char const   )'p',      (char const   )'r',      (char const   )'o', 
        (char const   )'t',      (char const   )'o',      (char const   )'=',      (char const   )'5', 
        (char const   )',',      (char const   )'m',      (char const   )'a',      (char const   )'x', 
        (char const   )'p',      (char const   )'r',      (char const   )'o',      (char const   )'t', 
        (char const   )'o',      (char const   )'=',      (char const   )'%',      (char const   )'d', 
        (char const   )',',      (char const   )'%',      (char const   )'s',      (char const   )'\000'};
#line 34 "mounts.c"
static char const   mnt_name_template[17]  = 
#line 34
  {      (char const   )'a',      (char const   )'u',      (char const   )'t',      (char const   )'o', 
        (char const   )'m',      (char const   )'o',      (char const   )'u',      (char const   )'n', 
        (char const   )'t',      (char const   )'(',      (char const   )'p',      (char const   )'i', 
        (char const   )'d',      (char const   )'%',      (char const   )'u',      (char const   )')', 
        (char const   )'\000'};
#line 36 "mounts.c"
static struct kernel_mod_version kver  =    {0U, 0U};
#line 37 "mounts.c"
static char const   kver_options_template[36]  = 
#line 37
  {      (char const   )'f',      (char const   )'d',      (char const   )'=',      (char const   )'%', 
        (char const   )'d',      (char const   )',',      (char const   )'p',      (char const   )'g', 
        (char const   )'r',      (char const   )'p',      (char const   )'=',      (char const   )'%', 
        (char const   )'u',      (char const   )',',      (char const   )'m',      (char const   )'i', 
        (char const   )'n',      (char const   )'p',      (char const   )'r',      (char const   )'o', 
        (char const   )'t',      (char const   )'o',      (char const   )'=',      (char const   )'3', 
        (char const   )',',      (char const   )'m',      (char const   )'a',      (char const   )'x', 
        (char const   )'p',      (char const   )'r',      (char const   )'o',      (char const   )'t', 
        (char const   )'o',      (char const   )'=',      (char const   )'5',      (char const   )'\000'};
#line 39 "mounts.c"
unsigned int query_kproto_ver(void) 
{ char dir[16] ;
  char *t_dir ;
  char options[81] ;
  pid_t pgrp ;
  pid_t tmp ;
  int pipefd[2] ;
  int ioctlfd ;
  int len ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;

  {
#line 41
  dir[0] = (char )'/';
#line 41
  dir[1] = (char )'t';
#line 41
  dir[2] = (char )'m';
#line 41
  dir[3] = (char )'p';
#line 41
  dir[4] = (char )'/';
#line 41
  dir[5] = (char )'a';
#line 41
  dir[6] = (char )'u';
#line 41
  dir[7] = (char )'t';
#line 41
  dir[8] = (char )'o';
#line 41
  dir[9] = (char )'X';
#line 41
  dir[10] = (char )'X';
#line 41
  dir[11] = (char )'X';
#line 41
  dir[12] = (char )'X';
#line 41
  dir[13] = (char )'X';
#line 41
  dir[14] = (char )'X';
#line 41
  dir[15] = (char )'\000';
#line 43
  tmp = getpgrp();
#line 43
  pgrp = tmp;
#line 46
  t_dir = mkdtemp(dir);
#line 47
  if (! t_dir) {
#line 48
    return (0U);
  }
#line 50
  tmp___0 = pipe(pipefd);
#line 50
  if (tmp___0 == -1) {
#line 51
    rmdir((char const   *)t_dir);
#line 52
    return (0U);
  }
#line 55
  len = snprintf((char * __restrict  )(options), 80U, (char const   * __restrict  )(kver_options_template),
                 pipefd[1], (unsigned int )pgrp);
#line 57
  if (len < 0) {
#line 58
    close(pipefd[0]);
#line 59
    close(pipefd[1]);
#line 60
    rmdir((char const   *)t_dir);
#line 61
    return (0U);
  }
#line 64
  tmp___1 = mount("automount", (char const   *)t_dir, "autofs", 3236757504UL, (void const   *)(options));
#line 64
  if (tmp___1) {
#line 65
    close(pipefd[0]);
#line 66
    close(pipefd[1]);
#line 67
    rmdir((char const   *)t_dir);
#line 68
    return (0U);
  }
#line 71
  close(pipefd[1]);
#line 73
  ioctlfd = open((char const   *)t_dir, 0);
#line 74
  if (ioctlfd == -1) {
#line 75
    umount((char const   *)t_dir);
#line 76
    close(pipefd[0]);
#line 77
    rmdir((char const   *)t_dir);
#line 78
    return (0U);
  }
#line 81
  ioctl(ioctlfd, 37730UL, 0);
#line 84
  if (sizeof(int ) == sizeof(int [1])) {
#line 84
    if (sizeof(int ) < 16384U) {
#line 84
      tmp___2 = sizeof(int );
    } else {
#line 84
      tmp___2 = __invalid_size_argument_for_IOC;
    }
  } else {
#line 84
    tmp___2 = __invalid_size_argument_for_IOC;
  }
#line 84
  tmp___3 = ioctl(ioctlfd, (unsigned long )(2147521379U | (tmp___2 << 16)), & kver.major);
#line 84
  if (tmp___3 == -1) {
#line 85
    close(ioctlfd);
#line 86
    umount((char const   *)t_dir);
#line 87
    close(pipefd[0]);
#line 88
    rmdir((char const   *)t_dir);
#line 89
    return (0U);
  }
#line 93
  if (sizeof(int ) == sizeof(int [1])) {
#line 93
    if (sizeof(int ) < 16384U) {
#line 93
      tmp___4 = sizeof(int );
    } else {
#line 93
      tmp___4 = __invalid_size_argument_for_IOC;
    }
  } else {
#line 93
    tmp___4 = __invalid_size_argument_for_IOC;
  }
#line 93
  tmp___5 = ioctl(ioctlfd, (unsigned long )(2147521383U | (tmp___4 << 16)), & kver.minor);
#line 93
  if (tmp___5 == -1) {
#line 94
    close(ioctlfd);
#line 95
    umount((char const   *)t_dir);
#line 96
    close(pipefd[0]);
#line 97
    rmdir((char const   *)t_dir);
#line 98
    return (0U);
  }
#line 101
  close(ioctlfd);
#line 102
  umount((char const   *)t_dir);
#line 103
  close(pipefd[0]);
#line 104
  rmdir((char const   *)t_dir);
#line 106
  return (1U);
}
}
#line 109 "mounts.c"
unsigned int get_kver_major(void) 
{ 

  {
#line 111
  return (kver.major);
}
}
#line 114 "mounts.c"
unsigned int get_kver_minor(void) 
{ 

  {
#line 116
  return (kver.minor);
}
}
#line 122 "mounts.c"
char *make_options_string(char *path___1 , int pipefd , char *extra ) 
{ char *options ;
  int len ;
  __pid_t tmp ;
  __pid_t tmp___0 ;

  {
#line 127
  options = (char *)malloc(81U);
#line 128
  if (! options) {
#line 129
    while (1) {
#line 129
      ((*log_crit))(3U, "%s: can\'t malloc options string", "make_options_string");
#line 129
      break;
    }
#line 130
    return ((char *)((void *)0));
  }
#line 133
  if (extra) {
#line 134
    tmp = getpgrp();
#line 134
    len = snprintf((char * __restrict  )options, 80U, (char const   * __restrict  )(options_template_extra),
                   pipefd, (unsigned int )tmp, 5, extra);
  } else {
#line 139
    tmp___0 = getpgrp();
#line 139
    len = snprintf((char * __restrict  )options, 80U, (char const   * __restrict  )(options_template),
                   pipefd, (unsigned int )tmp___0, 5);
  }
#line 143
  if (len >= 80) {
#line 144
    while (1) {
#line 144
      ((*log_crit))(3U, "%s: buffer to small for options - truncated", "make_options_string");
#line 144
      break;
    }
#line 145
    len = 79;
  }
#line 148
  if (len < 0) {
#line 149
    while (1) {
#line 149
      ((*log_crit))(3U, "%s: failed to malloc autofs mount options for %s", "make_options_string",
                    path___1);
#line 149
      break;
    }
#line 151
    free((void *)options);
#line 152
    return ((char *)((void *)0));
  }
#line 154
  (*(options + len)) = (char )'\000';
#line 156
  return (options);
}
}
#line 159 "mounts.c"
char *make_mnt_name_string(char *path___1 ) 
{ char *mnt_name ;
  int len ;
  __pid_t tmp ;

  {
#line 164
  mnt_name = (char *)malloc(31U);
#line 165
  if (! mnt_name) {
#line 166
    while (1) {
#line 166
      ((*log_crit))(3U, "%s: can\'t malloc mnt_name string", "make_mnt_name_string");
#line 166
      break;
    }
#line 167
    return ((char *)((void *)0));
  }
#line 170
  tmp = getpid();
#line 170
  len = snprintf((char * __restrict  )mnt_name, 30U, (char const   * __restrict  )(mnt_name_template),
                 (unsigned int )tmp);
#line 173
  if (len >= 30) {
#line 174
    while (1) {
#line 174
      ((*log_crit))(3U, "%s: buffer to small for mnt_name - truncated", "make_mnt_name_string");
#line 174
      break;
    }
#line 175
    len = 29;
  }
#line 178
  if (len < 0) {
#line 179
    while (1) {
#line 179
      ((*log_crit))(3U, "%s: failed setting up mnt_name for autofs path %s", "make_mnt_name_string",
                    path___1);
#line 179
      break;
    }
#line 181
    free((void *)mnt_name);
#line 182
    return ((char *)((void *)0));
  }
#line 184
  (*(mnt_name + len)) = (char )'\000';
#line 186
  return (mnt_name);
}
}
#line 192 "mounts.c"
struct mnt_list *get_mnt_list(char const   *table , char const   *path___1 , int include ) 
{ FILE *tab ;
  size_t pathlen ;
  size_t tmp ;
  struct mntent mnt_wrk ;
  char buf[12288] ;
  struct mntent *mnt ;
  struct mnt_list *ent ;
  struct mnt_list *mptr ;
  struct mnt_list *last ;
  struct mnt_list *list ;
  char *pgrp ;
  size_t len ;
  char *estr ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  size_t tmp___28 ;
  size_t tmp___29 ;
  size_t tmp___30 ;
  size_t tmp___31 ;
  char *end ;
  char *tmp___33 ;

  {
#line 195
  tmp = strlen(path___1);
#line 195
  pathlen = tmp;
#line 200
  list = (struct mnt_list *)((void *)0);
#line 204
  if (! path___1) {
#line 205
    return ((struct mnt_list *)((void *)0));
  } else {
#line 204
    if (! pathlen) {
#line 205
      return ((struct mnt_list *)((void *)0));
    } else {
#line 204
      if (pathlen > 4096U) {
#line 205
        return ((struct mnt_list *)((void *)0));
      }
    }
  }
#line 207
  tab = setmntent(table, "r");
#line 208
  if (! tab) {
#line 209
    tmp___0 = __errno_location();
#line 209
    tmp___1 = strerror_r((*tmp___0), buf, 4095U);
#line 209
    estr = tmp___1;
#line 210
    while (1) {
#line 210
      ((*log_error))(3U, "%s: setmntent: %s", "get_mnt_list", estr);
#line 210
      break;
    }
#line 211
    return ((struct mnt_list *)((void *)0));
  }
#line 214
  while (1) {
#line 214
    mnt = getmntent_r((FILE * __restrict  )tab, (struct mntent * __restrict  )(& mnt_wrk),
                      (char * __restrict  )(buf), 12288);
#line 214
    if (! mnt) {
#line 214
      break;
    }
#line 215
    len = strlen((char const   *)mnt->mnt_dir);
#line 218
    if (! include) {
#line 218
      if (len <= pathlen) {
#line 219
        continue;
      } else {
        goto _L___3;
      }
    } else {
      _L___3: 
#line 218
      if (0) {
#line 218
        if (0) {
#line 218
          __s1_len___0 = strlen((char const   *)mnt->mnt_dir);
#line 218
          __s2_len___0 = strlen(path___1);
#line 218
          if (! ((unsigned int )((void const   *)(mnt->mnt_dir + 1)) - (unsigned int )((void const   *)mnt->mnt_dir) == 1U)) {
            goto _L___2;
          } else {
#line 218
            if (__s1_len___0 >= 4U) {
              _L___2: 
#line 218
              if (! ((unsigned int )((void const   *)(path___1 + 1)) - (unsigned int )((void const   *)path___1) == 1U)) {
#line 218
                tmp___25 = 1;
              } else {
#line 218
                if (__s2_len___0 >= 4U) {
#line 218
                  tmp___25 = 1;
                } else {
#line 218
                  tmp___25 = 0;
                }
              }
            } else {
#line 218
              tmp___25 = 0;
            }
          }
#line 218
          if (tmp___25) {
#line 218
            tmp___21 = __builtin_strcmp((char const   *)mnt->mnt_dir, path___1);
          } else {
#line 218
            tmp___24 = __builtin_strcmp((char const   *)mnt->mnt_dir, path___1);
#line 218
            tmp___21 = tmp___24;
          }
        } else {
#line 218
          tmp___24 = __builtin_strcmp((char const   *)mnt->mnt_dir, path___1);
#line 218
          tmp___21 = tmp___24;
        }
#line 218
        tmp___15 = tmp___21;
      } else {
#line 218
        tmp___15 = strncmp((char const   *)mnt->mnt_dir, path___1, pathlen);
      }
#line 218
      if (tmp___15 != 0) {
#line 219
        continue;
      }
    }
#line 223
    if (pathlen > 1U) {
#line 223
      if (len > pathlen) {
#line 223
        if ((int )(*(mnt->mnt_dir + pathlen)) != 47) {
#line 225
          continue;
        }
      }
    }
#line 227
    ent = (struct mnt_list *)malloc(sizeof((*ent)));
#line 228
    if (! ent) {
#line 229
      endmntent(tab);
#line 230
      free_mnt_list(list);
#line 231
      return ((struct mnt_list *)((void *)0));
    }
#line 233
    memset((void *)ent, 0, sizeof((*ent)));
#line 235
    mptr = list;
#line 236
    last = (struct mnt_list *)((void *)0);
#line 237
    while (mptr) {
#line 238
      tmp___28 = strlen((char const   *)mptr->path);
#line 238
      if (len >= tmp___28) {
#line 239
        break;
      }
#line 240
      last = mptr;
#line 241
      mptr = mptr->next;
    }
#line 244
    if ((unsigned int )mptr == (unsigned int )list) {
#line 245
      list = ent;
    }
#line 247
    ent->next = mptr;
#line 248
    if (last) {
#line 249
      last->next = ent;
    }
#line 251
    ent->path = (char *)malloc(len + 1U);
#line 252
    if (! ent->path) {
#line 253
      endmntent(tab);
#line 254
      free_mnt_list(list);
#line 255
      return ((struct mnt_list *)((void *)0));
    }
#line 257
    strcpy((char * __restrict  )ent->path, (char const   * __restrict  )mnt->mnt_dir);
#line 259
    tmp___29 = strlen((char const   *)mnt->mnt_fsname);
#line 259
    ent->fs_name = (char *)malloc(tmp___29 + 1U);
#line 260
    if (! ent->fs_name) {
#line 261
      endmntent(tab);
#line 262
      free_mnt_list(list);
#line 263
      return ((struct mnt_list *)((void *)0));
    }
#line 265
    strcpy((char * __restrict  )ent->fs_name, (char const   * __restrict  )mnt->mnt_fsname);
#line 267
    tmp___30 = strlen((char const   *)mnt->mnt_type);
#line 267
    ent->fs_type = (char *)malloc(tmp___30 + 1U);
#line 268
    if (! ent->fs_type) {
#line 269
      endmntent(tab);
#line 270
      free_mnt_list(list);
#line 271
      return ((struct mnt_list *)((void *)0));
    }
#line 273
    strcpy((char * __restrict  )ent->fs_type, (char const   * __restrict  )mnt->mnt_type);
#line 275
    tmp___31 = strlen((char const   *)mnt->mnt_opts);
#line 275
    ent->opts = (char *)malloc(tmp___31 + 1U);
#line 276
    if (! ent->opts) {
#line 277
      endmntent(tab);
#line 278
      free_mnt_list(list);
#line 279
      return ((struct mnt_list *)((void *)0));
    }
#line 281
    strcpy((char * __restrict  )ent->opts, (char const   * __restrict  )mnt->mnt_opts);
#line 283
    ent->owner = 0;
#line 284
    pgrp = strstr((char const   *)mnt->mnt_opts, "pgrp=");
#line 285
    if (pgrp) {
#line 286
      tmp___33 = __builtin_strchr(pgrp, (char )',');
#line 286
      end = tmp___33;
#line 287
      if (end) {
#line 288
        (*end) = (char )'\000';
      }
#line 289
      sscanf((char const   * __restrict  )pgrp, (char const   * __restrict  )"pgrp=%d",
             & ent->owner);
    }
  }
#line 292
  endmntent(tab);
#line 294
  return (list);
}
}
#line 300 "mounts.c"
struct mnt_list *reverse_mnt_list(struct mnt_list *list ) 
{ struct mnt_list *next ;
  struct mnt_list *last ;
  struct mnt_list *this ;

  {
#line 304
  if (! list) {
#line 305
    return ((struct mnt_list *)((void *)0));
  }
#line 307
  next = list;
#line 308
  last = (struct mnt_list *)((void *)0);
#line 309
  while (next) {
#line 310
    this = next;
#line 311
    next = this->next;
#line 312
    this->next = last;
#line 313
    last = this;
  }
#line 315
  return (last);
}
}
#line 318 "mounts.c"
void free_mnt_list(struct mnt_list *list ) 
{ struct mnt_list *next ;
  struct mnt_list *this ;

  {
#line 322
  if (! list) {
#line 323
    return;
  }
#line 325
  next = list;
#line 326
  while (next) {
#line 327
    this = next;
#line 329
    next = this->next;
#line 331
    if (this->path) {
#line 332
      free((void *)this->path);
    }
#line 334
    if (this->fs_name) {
#line 335
      free((void *)this->fs_name);
    }
#line 337
    if (this->fs_type) {
#line 338
      free((void *)this->fs_type);
    }
#line 340
    if (this->opts) {
#line 341
      free((void *)this->opts);
    }
#line 343
    free((void *)this);
  }
#line 345
  return;
}
}
#line 347 "mounts.c"
int contained_in_local_fs(char const   *path___1 ) 
{ struct mnt_list *mnts ;
  struct mnt_list *this ;
  size_t pathlen ;
  size_t tmp ;
  int ret ;
  size_t len ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___41 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___47 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___67 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___73 ;
  int tmp___76 ;
  int tmp___77 ;

  {
#line 350
  tmp = strlen(path___1);
#line 350
  pathlen = tmp;
#line 353
  if (! path___1) {
#line 354
    return (0);
  } else {
#line 353
    if (! pathlen) {
#line 354
      return (0);
    } else {
#line 353
      if (pathlen > 4096U) {
#line 354
        return (0);
      }
    }
  }
#line 356
  mnts = get_mnt_list("/etc/mtab", "/", 1);
#line 357
  if (! mnts) {
#line 358
    return (0);
  }
#line 360
  ret = 0;
#line 362
  this = mnts;
#line 362
  while ((unsigned int )this != (unsigned int )((void *)0)) {
#line 363
    tmp___0 = strlen((char const   *)this->path);
#line 363
    len = tmp___0;
#line 365
    if (0) {
#line 365
      if (0) {
#line 365
        __s1_len___4 = strlen(path___1);
#line 365
        __s2_len___4 = strlen((char const   *)this->path);
#line 365
        if (! ((unsigned int )((void const   *)(path___1 + 1)) - (unsigned int )((void const   *)path___1) == 1U)) {
          goto _L___12;
        } else {
#line 365
          if (__s1_len___4 >= 4U) {
            _L___12: 
#line 365
            if (! ((unsigned int )((void const   *)(this->path + 1)) - (unsigned int )((void const   *)this->path) == 1U)) {
#line 365
              tmp___77 = 1;
            } else {
#line 365
              if (__s2_len___4 >= 4U) {
#line 365
                tmp___77 = 1;
              } else {
#line 365
                tmp___77 = 0;
              }
            }
          } else {
#line 365
            tmp___77 = 0;
          }
        }
#line 365
        if (tmp___77) {
#line 365
          tmp___73 = __builtin_strcmp(path___1, (char const   *)this->path);
        } else {
#line 365
          tmp___76 = __builtin_strcmp(path___1, (char const   *)this->path);
#line 365
          tmp___73 = tmp___76;
        }
      } else {
#line 365
        tmp___76 = __builtin_strcmp(path___1, (char const   *)this->path);
#line 365
        tmp___73 = tmp___76;
      }
#line 365
      tmp___67 = tmp___73;
    } else {
#line 365
      tmp___67 = strncmp(path___1, (char const   *)this->path, len);
    }
#line 365
    if (! tmp___67) {
#line 366
      if (len > 1U) {
#line 366
        if (pathlen > len) {
#line 366
          if ((int const   )(*(path___1 + len)) != 47) {
            goto __Cont;
          } else {
            goto _L___8;
          }
        } else {
          goto _L___8;
        }
      } else {
        _L___8: 
#line 368
        if ((int )(*(this->fs_name + 0)) == 47) {
#line 369
          tmp___1 = strlen((char const   *)this->fs_name);
#line 369
          if (tmp___1 > 1U) {
#line 370
            if ((int )(*(this->fs_name + 1)) != 47) {
#line 371
              ret = 1;
            }
          } else {
#line 373
            ret = 1;
          }
        } else {
#line 374
          if (0) {
#line 374
            if (0) {
#line 374
              __s1_len___0 = strlen("LABEL=");
#line 374
              __s2_len___0 = strlen((char const   *)this->fs_name);
#line 374
              if (! ((unsigned int )((void const   *)("LABEL=" + 1)) - (unsigned int )((void const   *)"LABEL=") == 1U)) {
                goto _L___2;
              } else {
#line 374
                if (__s1_len___0 >= 4U) {
                  _L___2: 
#line 374
                  if (! ((unsigned int )((void const   *)(this->fs_name + 1)) - (unsigned int )((void const   *)this->fs_name) == 1U)) {
#line 374
                    tmp___25 = 1;
                  } else {
#line 374
                    if (__s2_len___0 >= 4U) {
#line 374
                      tmp___25 = 1;
                    } else {
#line 374
                      tmp___25 = 0;
                    }
                  }
                } else {
#line 374
                  tmp___25 = 0;
                }
              }
#line 374
              if (tmp___25) {
#line 374
                tmp___21 = __builtin_strcmp("LABEL=", (char const   *)this->fs_name);
              } else {
#line 374
                tmp___24 = __builtin_strcmp("LABEL=", (char const   *)this->fs_name);
#line 374
                tmp___21 = tmp___24;
              }
            } else {
#line 374
              tmp___24 = __builtin_strcmp("LABEL=", (char const   *)this->fs_name);
#line 374
              tmp___21 = tmp___24;
            }
#line 374
            tmp___15 = tmp___21;
          } else {
#line 374
            tmp___15 = strncmp("LABEL=", (char const   *)this->fs_name, 6U);
          }
#line 375
          if (tmp___15) {
#line 375
            if (0) {
#line 375
              if (0) {
#line 375
                __s1_len___2 = strlen("UUID=");
#line 375
                __s2_len___2 = strlen((char const   *)this->fs_name);
#line 375
                if (! ((unsigned int )((void const   *)("UUID=" + 1)) - (unsigned int )((void const   *)"UUID=") == 1U)) {
                  goto _L___6;
                } else {
#line 375
                  if (__s1_len___2 >= 4U) {
                    _L___6: 
#line 375
                    if (! ((unsigned int )((void const   *)(this->fs_name + 1)) - (unsigned int )((void const   *)this->fs_name) == 1U)) {
#line 375
                      tmp___51 = 1;
                    } else {
#line 375
                      if (__s2_len___2 >= 4U) {
#line 375
                        tmp___51 = 1;
                      } else {
#line 375
                        tmp___51 = 0;
                      }
                    }
                  } else {
#line 375
                    tmp___51 = 0;
                  }
                }
#line 375
                if (tmp___51) {
#line 375
                  tmp___47 = __builtin_strcmp("UUID=", (char const   *)this->fs_name);
                } else {
#line 375
                  tmp___50 = __builtin_strcmp("UUID=", (char const   *)this->fs_name);
#line 375
                  tmp___47 = tmp___50;
                }
              } else {
#line 375
                tmp___50 = __builtin_strcmp("UUID=", (char const   *)this->fs_name);
#line 375
                tmp___47 = tmp___50;
              }
#line 375
              tmp___41 = tmp___47;
            } else {
#line 375
              tmp___41 = strncmp("UUID=", (char const   *)this->fs_name, 5U);
            }
#line 375
            if (! tmp___41) {
#line 376
              ret = 1;
            }
          } else {
#line 376
            ret = 1;
          }
        }
      }
#line 377
      break;
    }
    __Cont: 
#line 362
    this = this->next;
  }
#line 381
  free_mnt_list(mnts);
#line 383
  return (ret);
}
}
#line 386 "mounts.c"
int is_mounted(char const   *table , char const   *path___1 , unsigned int type___1 ) 
{ struct mntent *mnt ;
  struct mntent mnt_wrk ;
  char buf[12288] ;
  size_t pathlen ;
  size_t tmp ;
  FILE *tab ;
  int ret ;
  char *estr ;
  int *tmp___0 ;
  char *tmp___1 ;
  size_t len ;
  size_t tmp___2 ;
  unsigned int autofs_fs ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___27 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___33 ;
  int tmp___36 ;
  int tmp___37 ;

  {
#line 391
  tmp = strlen(path___1);
#line 391
  pathlen = tmp;
#line 393
  ret = 0;
#line 395
  if (! path___1) {
#line 396
    return (0);
  } else {
#line 395
    if (! pathlen) {
#line 396
      return (0);
    } else {
#line 395
      if (pathlen >= 4096U) {
#line 396
        return (0);
      }
    }
  }
#line 398
  tab = setmntent(table, "r");
#line 399
  if (! tab) {
#line 400
    tmp___0 = __errno_location();
#line 400
    tmp___1 = strerror_r((*tmp___0), buf, 4095U);
#line 400
    estr = tmp___1;
#line 401
    while (1) {
#line 401
      ((*log_error))(3U, "%s: setmntent: %s", "is_mounted", estr);
#line 401
      break;
    }
#line 402
    return (0);
  }
#line 405
  while (1) {
#line 405
    mnt = getmntent_r((FILE * __restrict  )tab, (struct mntent * __restrict  )(& mnt_wrk),
                      (char * __restrict  )(buf), 12288);
#line 405
    if (! mnt) {
#line 405
      break;
    }
#line 406
    tmp___2 = strlen((char const   *)mnt->mnt_dir);
#line 406
    len = tmp___2;
#line 408
    if (type___1) {
#line 411
      if (0) {
#line 411
        __s1_len = strlen((char const   *)mnt->mnt_type);
#line 411
        __s2_len = strlen("autofs");
#line 411
        if (! ((unsigned int )((void const   *)(mnt->mnt_type + 1)) - (unsigned int )((void const   *)mnt->mnt_type) == 1U)) {
          goto _L___0;
        } else {
#line 411
          if (__s1_len >= 4U) {
            _L___0: 
#line 411
            if (! ((unsigned int )((void const   *)("autofs" + 1)) - (unsigned int )((void const   *)"autofs") == 1U)) {
#line 411
              tmp___12 = 1;
            } else {
#line 411
              if (__s2_len >= 4U) {
#line 411
                tmp___12 = 1;
              } else {
#line 411
                tmp___12 = 0;
              }
            }
          } else {
#line 411
            tmp___12 = 0;
          }
        }
#line 411
        if (tmp___12) {
#line 411
          tmp___8 = __builtin_strcmp((char const   *)mnt->mnt_type, "autofs");
        } else {
#line 411
          tmp___11 = __builtin_strcmp((char const   *)mnt->mnt_type, "autofs");
#line 411
          tmp___8 = tmp___11;
        }
      } else {
#line 411
        tmp___11 = __builtin_strcmp((char const   *)mnt->mnt_type, "autofs");
#line 411
        tmp___8 = tmp___11;
      }
#line 411
      if (tmp___8) {
#line 411
        tmp___13 = 0;
      } else {
#line 411
        tmp___13 = 1;
      }
#line 411
      autofs_fs = (unsigned int )tmp___13;
#line 413
      if (type___1 & 2U) {
#line 414
        if (autofs_fs) {
#line 415
          continue;
        }
      }
#line 417
      if (type___1 & 4U) {
#line 418
        if (! autofs_fs) {
#line 419
          continue;
        }
      }
    }
#line 422
    if (pathlen == len) {
#line 422
      if (0) {
#line 422
        if (0) {
#line 422
          __s1_len___1 = strlen(path___1);
#line 422
          __s2_len___1 = strlen((char const   *)mnt->mnt_dir);
#line 422
          if (! ((unsigned int )((void const   *)(path___1 + 1)) - (unsigned int )((void const   *)path___1) == 1U)) {
            goto _L___4;
          } else {
#line 422
            if (__s1_len___1 >= 4U) {
              _L___4: 
#line 422
              if (! ((unsigned int )((void const   *)(mnt->mnt_dir + 1)) - (unsigned int )((void const   *)mnt->mnt_dir) == 1U)) {
#line 422
                tmp___37 = 1;
              } else {
#line 422
                if (__s2_len___1 >= 4U) {
#line 422
                  tmp___37 = 1;
                } else {
#line 422
                  tmp___37 = 0;
                }
              }
            } else {
#line 422
              tmp___37 = 0;
            }
          }
#line 422
          if (tmp___37) {
#line 422
            tmp___33 = __builtin_strcmp(path___1, (char const   *)mnt->mnt_dir);
          } else {
#line 422
            tmp___36 = __builtin_strcmp(path___1, (char const   *)mnt->mnt_dir);
#line 422
            tmp___33 = tmp___36;
          }
        } else {
#line 422
          tmp___36 = __builtin_strcmp(path___1, (char const   *)mnt->mnt_dir);
#line 422
          tmp___33 = tmp___36;
        }
#line 422
        tmp___27 = tmp___33;
      } else {
#line 422
        tmp___27 = strncmp(path___1, (char const   *)mnt->mnt_dir, pathlen);
      }
#line 422
      if (! tmp___27) {
#line 423
        ret = 1;
#line 424
        break;
      }
    }
  }
#line 427
  endmntent(tab);
#line 429
  return (ret);
}
}
#line 432 "mounts.c"
int has_fstab_option(char const   *opt ) 
{ struct mntent *mnt ;
  struct mntent mnt_wrk ;
  char buf[12288] ;
  FILE *tab ;
  int ret ;
  char *estr ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 438
  ret = 0;
#line 440
  if (! opt) {
#line 441
    return (0);
  }
#line 443
  tab = setmntent("/etc/fstab", "r");
#line 444
  if (! tab) {
#line 445
    tmp = __errno_location();
#line 445
    tmp___0 = strerror_r((*tmp), buf, 4095U);
#line 445
    estr = tmp___0;
#line 446
    while (1) {
#line 446
      ((*log_error))(3U, "%s: setmntent: %s", "has_fstab_option", estr);
#line 446
      break;
    }
#line 447
    return (0);
  }
#line 450
  while (1) {
#line 450
    mnt = getmntent_r((FILE * __restrict  )tab, (struct mntent * __restrict  )(& mnt_wrk),
                      (char * __restrict  )(buf), 12288);
#line 450
    if (! mnt) {
#line 450
      break;
    }
#line 451
    tmp___1 = hasmntopt((struct mntent  const  *)mnt, opt);
#line 451
    if (tmp___1) {
#line 452
      ret = 1;
#line 453
      break;
    }
  }
#line 456
  endmntent(tab);
#line 458
  return (ret);
}
}
#line 461 "mounts.c"
char *find_mnt_ino(char const   *table , dev_t dev , ino_t ino ) 
{ struct mntent mnt_wrk ;
  struct mntent *mnt ;
  char buf[12288] ;
  char *path___1 ;
  unsigned long l_dev ;
  unsigned long l_ino ;
  FILE *tab ;
  char *estr ;
  int *tmp ;
  char *tmp___0 ;
  char *p_dev ;
  char *p_ino ;
  unsigned long m_dev ;
  unsigned long m_ino ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___20 ;

  {
#line 466
  path___1 = (char *)((void *)0);
#line 467
  l_dev = (unsigned long )dev;
#line 468
  l_ino = ino;
#line 471
  tab = setmntent(table, "r");
#line 472
  if (! tab) {
#line 473
    tmp = __errno_location();
#line 473
    tmp___0 = strerror_r((*tmp), buf, 4095U);
#line 473
    estr = tmp___0;
#line 474
    while (1) {
#line 474
      ((*log_error))(3U, "%s: setmntent: %s", "find_mnt_ino", estr);
#line 474
      break;
    }
#line 475
    return ((char *)0);
  }
#line 478
  while (1) {
#line 478
    mnt = getmntent_r((FILE * __restrict  )tab, (struct mntent * __restrict  )(& mnt_wrk),
                      (char * __restrict  )(buf), 12288);
#line 478
    if (! mnt) {
#line 478
      break;
    }
#line 482
    if (0) {
#line 482
      __s1_len = strlen((char const   *)mnt->mnt_type);
#line 482
      __s2_len = strlen("autofs");
#line 482
      if (! ((unsigned int )((void const   *)(mnt->mnt_type + 1)) - (unsigned int )((void const   *)mnt->mnt_type) == 1U)) {
        goto _L___0;
      } else {
#line 482
        if (__s1_len >= 4U) {
          _L___0: 
#line 482
          if (! ((unsigned int )((void const   *)("autofs" + 1)) - (unsigned int )((void const   *)"autofs") == 1U)) {
#line 482
            tmp___10 = 1;
          } else {
#line 482
            if (__s2_len >= 4U) {
#line 482
              tmp___10 = 1;
            } else {
#line 482
              tmp___10 = 0;
            }
          }
        } else {
#line 482
          tmp___10 = 0;
        }
      }
#line 482
      if (tmp___10) {
#line 482
        tmp___6 = __builtin_strcmp((char const   *)mnt->mnt_type, "autofs");
      } else {
#line 482
        tmp___9 = __builtin_strcmp((char const   *)mnt->mnt_type, "autofs");
#line 482
        tmp___6 = tmp___9;
      }
    } else {
#line 482
      tmp___9 = __builtin_strcmp((char const   *)mnt->mnt_type, "autofs");
#line 482
      tmp___6 = tmp___9;
    }
#line 482
    if (tmp___6) {
#line 483
      continue;
    }
#line 485
    p_dev = strstr((char const   *)mnt->mnt_opts, "dev=");
#line 486
    if (! p_dev) {
#line 487
      continue;
    }
#line 488
    sscanf((char const   * __restrict  )p_dev, (char const   * __restrict  )"dev=%lu",
           & m_dev);
#line 489
    if (m_dev != l_dev) {
#line 490
      continue;
    }
#line 492
    p_ino = strstr((char const   *)mnt->mnt_opts, "ino=");
#line 493
    if (! p_ino) {
#line 494
      continue;
    }
#line 495
    sscanf((char const   * __restrict  )p_ino, (char const   * __restrict  )"ino=%lu",
           & m_ino);
#line 496
    if (m_ino == l_ino) {
#line 497
      tmp___20 = __strdup((char const   *)mnt->mnt_dir);
#line 497
      path___1 = tmp___20;
#line 498
      break;
    }
  }
#line 501
  endmntent(tab);
#line 503
  return (path___1);
}
}
#line 506 "mounts.c"
char *get_offset(char const   *prefix , char *offset , struct list_head *head , struct list_head **pos ) 
{ struct list_head *next ;
  struct mnt_list *this ;
  size_t plen ;
  size_t tmp ;
  size_t len ;
  char *pstart ;
  char *pend ;
  size_t tmp___0 ;
  char *tmp___1 ;
  int tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  char *pstart___0 ;
  size_t tmp___28 ;
  int tmp___42 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___48 ;
  int tmp___51 ;
  int tmp___52 ;
  char *tmp___55 ;

  {
#line 511
  tmp = strlen(prefix);
#line 511
  plen = tmp;
#line 512
  len = 0U;
#line 514
  (*offset) = (char )'\000';
#line 515
  if ((*pos)) {
#line 515
    next = ((*pos))->next;
  } else {
#line 515
    next = head->next;
  }
#line 516
  while ((unsigned int )next != (unsigned int )head) {
#line 519
    this = (struct mnt_list *)((char *)next - (unsigned long )(& ((struct mnt_list *)0)->ordered));
#line 520
    (*pos) = next;
#line 521
    next = next->next;
#line 523
    tmp___0 = strlen((char const   *)this->path);
#line 523
    if (tmp___0 <= plen) {
#line 524
      continue;
    }
#line 526
    if (0) {
#line 526
      if (0) {
#line 526
        __s1_len___0 = strlen(prefix);
#line 526
        __s2_len___0 = strlen((char const   *)this->path);
#line 526
        if (! ((unsigned int )((void const   *)(prefix + 1)) - (unsigned int )((void const   *)prefix) == 1U)) {
          goto _L___2;
        } else {
#line 526
          if (__s1_len___0 >= 4U) {
            _L___2: 
#line 526
            if (! ((unsigned int )((void const   *)(this->path + 1)) - (unsigned int )((void const   *)this->path) == 1U)) {
#line 526
              tmp___25 = 1;
            } else {
#line 526
              if (__s2_len___0 >= 4U) {
#line 526
                tmp___25 = 1;
              } else {
#line 526
                tmp___25 = 0;
              }
            }
          } else {
#line 526
            tmp___25 = 0;
          }
        }
#line 526
        if (tmp___25) {
#line 526
          tmp___21 = __builtin_strcmp(prefix, (char const   *)this->path);
        } else {
#line 526
          tmp___24 = __builtin_strcmp(prefix, (char const   *)this->path);
#line 526
          tmp___21 = tmp___24;
        }
      } else {
#line 526
        tmp___24 = __builtin_strcmp(prefix, (char const   *)this->path);
#line 526
        tmp___21 = tmp___24;
      }
#line 526
      tmp___15 = tmp___21;
    } else {
#line 526
      tmp___15 = strncmp(prefix, (char const   *)this->path, plen);
    }
#line 526
    if (! tmp___15) {
#line 527
      pstart = this->path + plen;
#line 530
      if ((int )(*pstart) != 47) {
#line 531
        continue;
      }
#line 534
      pend = pstart;
#line 535
      while (1) {
#line 535
        tmp___1 = pend;
#line 535
        pend ++;
#line 535
        if (! (*tmp___1)) {
#line 535
          break;
        }
      }
#line 536
      len = (unsigned int )((pend - pstart) - 1);
#line 537
      __builtin_strncpy(offset, (char const   *)pstart, len);
#line 538
      (*(offset + len)) = (char )'\000';
#line 539
      break;
    }
  }
#line 543
  while ((unsigned int )next != (unsigned int )head) {
#line 546
    this = (struct mnt_list *)((char *)next - (unsigned long )(& ((struct mnt_list *)0)->ordered));
#line 548
    tmp___28 = strlen((char const   *)this->path);
#line 548
    if (tmp___28 <= plen + len) {
#line 549
      break;
    }
#line 551
    pstart___0 = this->path + plen;
#line 554
    if ((int )(*pstart___0) != 47) {
#line 555
      break;
    }
#line 558
    if (! (*((pstart___0 + len) + 1))) {
#line 559
      break;
    }
#line 562
    if ((int )(*(pstart___0 + len)) != 47) {
#line 563
      break;
    } else {
#line 562
      if (0) {
#line 562
        if (0) {
#line 562
          __s1_len___2 = strlen((char const   *)offset);
#line 562
          __s2_len___2 = strlen((char const   *)pstart___0);
#line 562
          if (! ((unsigned int )((void const   *)(offset + 1)) - (unsigned int )((void const   *)offset) == 1U)) {
            goto _L___6;
          } else {
#line 562
            if (__s1_len___2 >= 4U) {
              _L___6: 
#line 562
              if (! ((unsigned int )((void const   *)(pstart___0 + 1)) - (unsigned int )((void const   *)pstart___0) == 1U)) {
#line 562
                tmp___52 = 1;
              } else {
#line 562
                if (__s2_len___2 >= 4U) {
#line 562
                  tmp___52 = 1;
                } else {
#line 562
                  tmp___52 = 0;
                }
              }
            } else {
#line 562
              tmp___52 = 0;
            }
          }
#line 562
          if (tmp___52) {
#line 562
            tmp___48 = __builtin_strcmp((char const   *)offset, (char const   *)pstart___0);
          } else {
#line 562
            tmp___51 = __builtin_strcmp((char const   *)offset, (char const   *)pstart___0);
#line 562
            tmp___48 = tmp___51;
          }
        } else {
#line 562
          tmp___51 = __builtin_strcmp((char const   *)offset, (char const   *)pstart___0);
#line 562
          tmp___48 = tmp___51;
        }
#line 562
        tmp___42 = tmp___48;
      } else {
#line 562
        tmp___42 = strncmp((char const   *)offset, (char const   *)pstart___0, len);
      }
#line 562
      if (tmp___42) {
#line 563
        break;
      }
    }
#line 565
    (*pos) = next;
#line 566
    next = next->next;
  }
#line 569
  if ((*offset)) {
#line 569
    tmp___55 = offset;
  } else {
#line 569
    tmp___55 = (char *)((void *)0);
  }
#line 569
  return (tmp___55);
}
}
#line 572 "mounts.c"
void add_ordered_list(struct mnt_list *ent , struct list_head *head ) 
{ struct list_head *p ;
  struct mnt_list *this ;
  size_t tlen ;
  int eq ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___17 ;
  int tmp___20 ;
  int tmp___21 ;
  size_t tmp___24 ;

  {
#line 577
  p = head->next;
#line 577
  while ((unsigned int )p != (unsigned int )head) {
#line 581
    this = (struct mnt_list *)((char *)p - (unsigned long )(& ((struct mnt_list *)0)->ordered));
#line 582
    tlen = strlen((char const   *)this->path);
#line 584
    if (0) {
#line 584
      if (0) {
#line 584
        __s1_len___0 = strlen((char const   *)this->path);
#line 584
        __s2_len___0 = strlen((char const   *)ent->path);
#line 584
        if (! ((unsigned int )((void const   *)(this->path + 1)) - (unsigned int )((void const   *)this->path) == 1U)) {
          goto _L___2;
        } else {
#line 584
          if (__s1_len___0 >= 4U) {
            _L___2: 
#line 584
            if (! ((unsigned int )((void const   *)(ent->path + 1)) - (unsigned int )((void const   *)ent->path) == 1U)) {
#line 584
              tmp___21 = 1;
            } else {
#line 584
              if (__s2_len___0 >= 4U) {
#line 584
                tmp___21 = 1;
              } else {
#line 584
                tmp___21 = 0;
              }
            }
          } else {
#line 584
            tmp___21 = 0;
          }
        }
#line 584
        if (tmp___21) {
#line 584
          tmp___17 = __builtin_strcmp((char const   *)this->path, (char const   *)ent->path);
        } else {
#line 584
          tmp___20 = __builtin_strcmp((char const   *)this->path, (char const   *)ent->path);
#line 584
          tmp___17 = tmp___20;
        }
      } else {
#line 584
        tmp___20 = __builtin_strcmp((char const   *)this->path, (char const   *)ent->path);
#line 584
        tmp___17 = tmp___20;
      }
#line 584
      eq = tmp___17;
    } else {
#line 584
      eq = strncmp((char const   *)this->path, (char const   *)ent->path, tlen);
    }
#line 585
    if (! eq) {
#line 585
      tmp___24 = strlen((char const   *)ent->path);
#line 585
      if (tlen == tmp___24) {
#line 586
        return;
      }
    }
#line 588
    if (eq > 0) {
#line 589
      while (1) {
#line 589
        ent->ordered.next = & ent->ordered;
#line 589
        ent->ordered.prev = & ent->ordered;
#line 589
        break;
      }
#line 590
      list_add_tail(& ent->ordered, p);
#line 591
      return;
    }
#line 577
    p = p->next;
  }
#line 594
  while (1) {
#line 594
    ent->ordered.next = & ent->ordered;
#line 594
    ent->ordered.prev = & ent->ordered;
#line 594
    break;
  }
#line 595
  list_add_tail(& ent->ordered, p);
#line 597
  return;
}
}
#line 611 "mounts.c"
void tree_free_mnt_tree(struct mnt_list *tree ) 
{ struct list_head *head ;
  struct list_head *p ;
  struct mnt_list *this ;

  {
#line 615
  if (! tree) {
#line 616
    return;
  }
#line 618
  tree_free_mnt_tree(tree->left);
#line 619
  tree_free_mnt_tree(tree->right);
#line 621
  head = & tree->self;
#line 622
  p = head->next;
#line 623
  while ((unsigned int )p != (unsigned int )head) {
#line 626
    this = (struct mnt_list *)((char *)p - (unsigned long )(& ((struct mnt_list *)0)->self));
#line 628
    p = p->next;
#line 630
    list_del(& this->self);
#line 632
    free((void *)this->path);
#line 633
    free((void *)this->fs_name);
#line 634
    free((void *)this->fs_type);
#line 636
    if (this->opts) {
#line 637
      free((void *)this->opts);
    }
#line 639
    free((void *)this);
  }
#line 642
  free((void *)tree->path);
#line 643
  free((void *)tree->fs_name);
#line 644
  free((void *)tree->fs_type);
#line 646
  if (tree->opts) {
#line 647
    free((void *)tree->opts);
  }
#line 649
  free((void *)tree);
#line 650
  return;
}
}
#line 655 "mounts.c"
struct mnt_list *tree_make_mnt_tree(char const   *table , char const   *path___1 ) 
{ FILE *tab ;
  struct mntent mnt_wrk ;
  char buf[12288] ;
  struct mntent *mnt ;
  struct mnt_list *ent ;
  struct mnt_list *mptr ;
  struct mnt_list *tree ;
  char *pgrp ;
  size_t plen ;
  int eq ;
  char *estr ;
  int *tmp ;
  char *tmp___0 ;
  size_t len ;
  size_t tmp___1 ;
  int tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  size_t tmp___28 ;
  size_t tmp___29 ;
  size_t tmp___30 ;
  char *end ;
  char *tmp___32 ;
  int elen ;
  int tmp___33 ;
  int mlen ;
  int tmp___34 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___40 ;
  int tmp___43 ;
  int tmp___44 ;

  {
#line 662
  tree = (struct mnt_list *)((void *)0);
#line 667
  tab = setmntent(table, "r");
#line 668
  if (! tab) {
#line 669
    tmp = __errno_location();
#line 669
    tmp___0 = strerror_r((*tmp), buf, 4095U);
#line 669
    estr = tmp___0;
#line 670
    while (1) {
#line 670
      ((*log_error))(3U, "%s: setmntent: %s", "tree_make_mnt_tree", estr);
#line 670
      break;
    }
#line 671
    return ((struct mnt_list *)((void *)0));
  }
#line 674
  plen = strlen(path___1);
#line 676
  while (1) {
#line 676
    mnt = getmntent_r((FILE * __restrict  )tab, (struct mntent * __restrict  )(& mnt_wrk),
                      (char * __restrict  )(buf), 12288);
#line 676
    if (! mnt) {
#line 676
      break;
    }
#line 677
    tmp___1 = strlen((char const   *)mnt->mnt_dir);
#line 677
    len = tmp___1;
#line 680
    if (0) {
#line 680
      if (0) {
#line 680
        __s1_len___0 = strlen((char const   *)mnt->mnt_dir);
#line 680
        __s2_len___0 = strlen(path___1);
#line 680
        if (! ((unsigned int )((void const   *)(mnt->mnt_dir + 1)) - (unsigned int )((void const   *)mnt->mnt_dir) == 1U)) {
          goto _L___2;
        } else {
#line 680
          if (__s1_len___0 >= 4U) {
            _L___2: 
#line 680
            if (! ((unsigned int )((void const   *)(path___1 + 1)) - (unsigned int )((void const   *)path___1) == 1U)) {
#line 680
              tmp___25 = 1;
            } else {
#line 680
              if (__s2_len___0 >= 4U) {
#line 680
                tmp___25 = 1;
              } else {
#line 680
                tmp___25 = 0;
              }
            }
          } else {
#line 680
            tmp___25 = 0;
          }
        }
#line 680
        if (tmp___25) {
#line 680
          tmp___21 = __builtin_strcmp((char const   *)mnt->mnt_dir, path___1);
        } else {
#line 680
          tmp___24 = __builtin_strcmp((char const   *)mnt->mnt_dir, path___1);
#line 680
          tmp___21 = tmp___24;
        }
      } else {
#line 680
        tmp___24 = __builtin_strcmp((char const   *)mnt->mnt_dir, path___1);
#line 680
        tmp___21 = tmp___24;
      }
#line 680
      tmp___15 = tmp___21;
    } else {
#line 680
      tmp___15 = strncmp((char const   *)mnt->mnt_dir, path___1, plen);
    }
#line 680
    if (tmp___15) {
#line 681
      continue;
    }
#line 684
    if (plen > 1U) {
#line 684
      if (len > plen) {
#line 684
        if ((int )(*(mnt->mnt_dir + plen)) != 47) {
#line 685
          continue;
        }
      }
    }
#line 687
    ent = (struct mnt_list *)malloc(sizeof((*ent)));
#line 688
    if (! ent) {
#line 689
      endmntent(tab);
#line 690
      tree_free_mnt_tree(tree);
#line 691
      return ((struct mnt_list *)((void *)0));
    }
#line 693
    memset((void *)ent, 0, sizeof((*ent)));
#line 695
    while (1) {
#line 695
      ent->self.next = & ent->self;
#line 695
      ent->self.prev = & ent->self;
#line 695
      break;
    }
#line 696
    while (1) {
#line 696
      ent->list.next = & ent->list;
#line 696
      ent->list.prev = & ent->list;
#line 696
      break;
    }
#line 697
    while (1) {
#line 697
      ent->entries.next = & ent->entries;
#line 697
      ent->entries.prev = & ent->entries;
#line 697
      break;
    }
#line 698
    while (1) {
#line 698
      ent->sublist.next = & ent->sublist;
#line 698
      ent->sublist.prev = & ent->sublist;
#line 698
      break;
    }
#line 699
    while (1) {
#line 699
      ent->ordered.next = & ent->ordered;
#line 699
      ent->ordered.prev = & ent->ordered;
#line 699
      break;
    }
#line 701
    ent->path = (char *)malloc(len + 1U);
#line 702
    if (! ent->path) {
#line 703
      endmntent(tab);
#line 704
      tree_free_mnt_tree(tree);
#line 705
      return ((struct mnt_list *)((void *)0));
    }
#line 707
    strcpy((char * __restrict  )ent->path, (char const   * __restrict  )mnt->mnt_dir);
#line 709
    tmp___28 = strlen((char const   *)mnt->mnt_fsname);
#line 709
    ent->fs_name = (char *)malloc(tmp___28 + 1U);
#line 710
    if (! ent->fs_name) {
#line 711
      free((void *)ent->path);
#line 712
      free((void *)ent);
#line 713
      endmntent(tab);
#line 714
      tree_free_mnt_tree(tree);
#line 715
      return ((struct mnt_list *)((void *)0));
    }
#line 717
    strcpy((char * __restrict  )ent->fs_name, (char const   * __restrict  )mnt->mnt_fsname);
#line 719
    tmp___29 = strlen((char const   *)mnt->mnt_type);
#line 719
    ent->fs_type = (char *)malloc(tmp___29 + 1U);
#line 720
    if (! ent->fs_type) {
#line 721
      free((void *)ent->fs_name);
#line 722
      free((void *)ent->path);
#line 723
      free((void *)ent);
#line 724
      endmntent(tab);
#line 725
      tree_free_mnt_tree(tree);
#line 726
      return ((struct mnt_list *)((void *)0));
    }
#line 728
    strcpy((char * __restrict  )ent->fs_type, (char const   * __restrict  )mnt->mnt_type);
#line 730
    tmp___30 = strlen((char const   *)mnt->mnt_opts);
#line 730
    ent->opts = (char *)malloc(tmp___30 + 1U);
#line 731
    if (! ent->opts) {
#line 732
      free((void *)ent->fs_type);
#line 733
      free((void *)ent->fs_name);
#line 734
      free((void *)ent->path);
#line 735
      free((void *)ent);
#line 736
      endmntent(tab);
#line 737
      tree_free_mnt_tree(tree);
#line 738
      return ((struct mnt_list *)((void *)0));
    }
#line 740
    strcpy((char * __restrict  )ent->opts, (char const   * __restrict  )mnt->mnt_opts);
#line 742
    ent->owner = 0;
#line 743
    pgrp = strstr((char const   *)mnt->mnt_opts, "pgrp=");
#line 744
    if (pgrp) {
#line 745
      tmp___32 = __builtin_strchr(pgrp, (char )',');
#line 745
      end = tmp___32;
#line 746
      if (end) {
#line 747
        (*end) = (char )'\000';
      }
#line 748
      sscanf((char const   * __restrict  )pgrp, (char const   * __restrict  )"pgrp=%d",
             & ent->owner);
    }
#line 751
    mptr = tree;
#line 752
    while (mptr) {
#line 753
      tmp___33 = (int )strlen((char const   *)ent->path);
#line 753
      elen = tmp___33;
#line 754
      tmp___34 = (int )strlen((char const   *)mptr->path);
#line 754
      mlen = tmp___34;
#line 756
      if (elen < mlen) {
#line 757
        if (mptr->left) {
#line 758
          mptr = mptr->left;
#line 759
          continue;
        } else {
#line 761
          mptr->left = ent;
#line 762
          break;
        }
      } else {
#line 764
        if (elen > mlen) {
#line 765
          if (mptr->right) {
#line 766
            mptr = mptr->right;
#line 767
            continue;
          } else {
#line 769
            mptr->right = ent;
#line 770
            break;
          }
        }
      }
#line 774
      if (0) {
#line 774
        __s1_len___1 = strlen((char const   *)ent->path);
#line 774
        __s2_len___1 = strlen((char const   *)mptr->path);
#line 774
        if (! ((unsigned int )((void const   *)(ent->path + 1)) - (unsigned int )((void const   *)ent->path) == 1U)) {
          goto _L___4;
        } else {
#line 774
          if (__s1_len___1 >= 4U) {
            _L___4: 
#line 774
            if (! ((unsigned int )((void const   *)(mptr->path + 1)) - (unsigned int )((void const   *)mptr->path) == 1U)) {
#line 774
              tmp___44 = 1;
            } else {
#line 774
              if (__s2_len___1 >= 4U) {
#line 774
                tmp___44 = 1;
              } else {
#line 774
                tmp___44 = 0;
              }
            }
          } else {
#line 774
            tmp___44 = 0;
          }
        }
#line 774
        if (tmp___44) {
#line 774
          tmp___40 = __builtin_strcmp((char const   *)ent->path, (char const   *)mptr->path);
        } else {
#line 774
          tmp___43 = __builtin_strcmp((char const   *)ent->path, (char const   *)mptr->path);
#line 774
          tmp___40 = tmp___43;
        }
      } else {
#line 774
        tmp___43 = __builtin_strcmp((char const   *)ent->path, (char const   *)mptr->path);
#line 774
        tmp___40 = tmp___43;
      }
#line 774
      eq = tmp___40;
#line 775
      if (eq < 0) {
#line 776
        if (mptr->left) {
#line 777
          mptr = mptr->left;
        } else {
#line 779
          mptr->left = ent;
#line 780
          break;
        }
      } else {
#line 782
        if (eq > 0) {
#line 783
          if (mptr->right) {
#line 784
            mptr = mptr->right;
          } else {
#line 786
            mptr->right = ent;
#line 787
            break;
          }
        } else {
#line 790
          list_add_tail(& ent->self, & mptr->self);
#line 791
          break;
        }
      }
    }
#line 795
    if (! tree) {
#line 796
      tree = ent;
    }
  }
#line 798
  endmntent(tab);
#line 800
  return (tree);
}
}
#line 806 "mounts.c"
int tree_get_mnt_list(struct mnt_list *mnts , struct list_head *list , char const   *path___1 ,
                      int include ) 
{ size_t mlen ;
  size_t plen ;
  int tmp ;
  struct list_head *self ;
  struct list_head *p ;
  int tmp___13 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___19 ;
  int tmp___22 ;
  int tmp___23 ;
  struct mnt_list *this ;
  int tmp___26 ;

  {
#line 810
  if (! mnts) {
#line 811
    return (0);
  }
#line 813
  plen = strlen(path___1);
#line 814
  mlen = strlen((char const   *)mnts->path);
#line 815
  if (mlen < plen) {
#line 816
    tmp = tree_get_mnt_list(mnts->right, list, path___1, include);
#line 816
    return (tmp);
  } else {
#line 820
    tree_get_mnt_list(mnts->left, list, path___1, include);
#line 823
    if (! include) {
#line 823
      if (mlen <= plen) {
        goto skip;
      } else {
        goto _L___3;
      }
    } else {
      _L___3: 
#line 823
      if (0) {
#line 823
        if (0) {
#line 823
          __s1_len___0 = strlen((char const   *)mnts->path);
#line 823
          __s2_len___0 = strlen(path___1);
#line 823
          if (! ((unsigned int )((void const   *)(mnts->path + 1)) - (unsigned int )((void const   *)mnts->path) == 1U)) {
            goto _L___2;
          } else {
#line 823
            if (__s1_len___0 >= 4U) {
              _L___2: 
#line 823
              if (! ((unsigned int )((void const   *)(path___1 + 1)) - (unsigned int )((void const   *)path___1) == 1U)) {
#line 823
                tmp___23 = 1;
              } else {
#line 823
                if (__s2_len___0 >= 4U) {
#line 823
                  tmp___23 = 1;
                } else {
#line 823
                  tmp___23 = 0;
                }
              }
            } else {
#line 823
              tmp___23 = 0;
            }
          }
#line 823
          if (tmp___23) {
#line 823
            tmp___19 = __builtin_strcmp((char const   *)mnts->path, path___1);
          } else {
#line 823
            tmp___22 = __builtin_strcmp((char const   *)mnts->path, path___1);
#line 823
            tmp___19 = tmp___22;
          }
        } else {
#line 823
          tmp___22 = __builtin_strcmp((char const   *)mnts->path, path___1);
#line 823
          tmp___19 = tmp___22;
        }
#line 823
        tmp___13 = tmp___19;
      } else {
#line 823
        tmp___13 = strncmp((char const   *)mnts->path, path___1, plen);
      }
#line 823
      if (tmp___13) {
        goto skip;
      }
    }
#line 826
    if (plen > 1U) {
#line 826
      if (mlen > plen) {
#line 826
        if ((int )(*(mnts->path + plen)) != 47) {
          goto skip;
        }
      }
    }
#line 829
    while (1) {
#line 829
      mnts->list.next = & mnts->list;
#line 829
      mnts->list.prev = & mnts->list;
#line 829
      break;
    }
#line 830
    list_add(& mnts->list, list);
#line 832
    self = & mnts->self;
#line 833
    p = self->next;
#line 833
    while ((unsigned int )p != (unsigned int )self) {
#line 836
      this = (struct mnt_list *)((char *)p - (unsigned long )(& ((struct mnt_list *)0)->self));
#line 837
      while (1) {
#line 837
        this->list.next = & this->list;
#line 837
        this->list.prev = & this->list;
#line 837
        break;
      }
#line 838
      list_add(& this->list, list);
#line 833
      p = p->next;
    }
    skip: 
#line 841
    tree_get_mnt_list(mnts->right, list, path___1, include);
  }
#line 844
  tmp___26 = list_empty(list);
#line 844
  if (tmp___26) {
#line 845
    return (0);
  }
#line 847
  return (1);
}
}
#line 853 "mounts.c"
int tree_get_mnt_sublist(struct mnt_list *mnts , struct list_head *list , char const   *path___1 ,
                         int include ) 
{ size_t mlen ;
  size_t plen ;
  int tmp ;
  struct list_head *self ;
  struct list_head *p ;
  int tmp___13 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___19 ;
  int tmp___22 ;
  int tmp___23 ;
  struct mnt_list *this ;
  int tmp___26 ;

  {
#line 857
  if (! mnts) {
#line 858
    return (0);
  }
#line 860
  plen = strlen(path___1);
#line 861
  mlen = strlen((char const   *)mnts->path);
#line 862
  if (mlen < plen) {
#line 863
    tmp = tree_get_mnt_sublist(mnts->right, list, path___1, include);
#line 863
    return (tmp);
  } else {
#line 867
    tree_get_mnt_sublist(mnts->left, list, path___1, include);
#line 870
    if (! include) {
#line 870
      if (mlen <= plen) {
        goto skip;
      } else {
        goto _L___3;
      }
    } else {
      _L___3: 
#line 870
      if (0) {
#line 870
        if (0) {
#line 870
          __s1_len___0 = strlen((char const   *)mnts->path);
#line 870
          __s2_len___0 = strlen(path___1);
#line 870
          if (! ((unsigned int )((void const   *)(mnts->path + 1)) - (unsigned int )((void const   *)mnts->path) == 1U)) {
            goto _L___2;
          } else {
#line 870
            if (__s1_len___0 >= 4U) {
              _L___2: 
#line 870
              if (! ((unsigned int )((void const   *)(path___1 + 1)) - (unsigned int )((void const   *)path___1) == 1U)) {
#line 870
                tmp___23 = 1;
              } else {
#line 870
                if (__s2_len___0 >= 4U) {
#line 870
                  tmp___23 = 1;
                } else {
#line 870
                  tmp___23 = 0;
                }
              }
            } else {
#line 870
              tmp___23 = 0;
            }
          }
#line 870
          if (tmp___23) {
#line 870
            tmp___19 = __builtin_strcmp((char const   *)mnts->path, path___1);
          } else {
#line 870
            tmp___22 = __builtin_strcmp((char const   *)mnts->path, path___1);
#line 870
            tmp___19 = tmp___22;
          }
        } else {
#line 870
          tmp___22 = __builtin_strcmp((char const   *)mnts->path, path___1);
#line 870
          tmp___19 = tmp___22;
        }
#line 870
        tmp___13 = tmp___19;
      } else {
#line 870
        tmp___13 = strncmp((char const   *)mnts->path, path___1, plen);
      }
#line 870
      if (tmp___13) {
        goto skip;
      }
    }
#line 873
    if (plen > 1U) {
#line 873
      if (mlen > plen) {
#line 873
        if ((int )(*(mnts->path + plen)) != 47) {
          goto skip;
        }
      }
    }
#line 876
    while (1) {
#line 876
      mnts->sublist.next = & mnts->sublist;
#line 876
      mnts->sublist.prev = & mnts->sublist;
#line 876
      break;
    }
#line 877
    list_add(& mnts->sublist, list);
#line 879
    self = & mnts->self;
#line 880
    p = self->next;
#line 880
    while ((unsigned int )p != (unsigned int )self) {
#line 883
      this = (struct mnt_list *)((char *)p - (unsigned long )(& ((struct mnt_list *)0)->self));
#line 884
      while (1) {
#line 884
        this->sublist.next = & this->sublist;
#line 884
        this->sublist.prev = & this->sublist;
#line 884
        break;
      }
#line 885
      list_add(& this->sublist, list);
#line 880
      p = p->next;
    }
    skip: 
#line 888
    tree_get_mnt_sublist(mnts->right, list, path___1, include);
  }
#line 891
  tmp___26 = list_empty(list);
#line 891
  if (tmp___26) {
#line 892
    return (0);
  }
#line 894
  return (1);
}
}
#line 897 "mounts.c"
int tree_find_mnt_ents(struct mnt_list *mnts , struct list_head *list , char const   *path___1 ) 
{ int mlen ;
  int plen ;
  int tmp ;
  int tmp___0 ;
  struct list_head *self ;
  struct list_head *p ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  struct mnt_list *this ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___16 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 901
  if (! mnts) {
#line 902
    return (0);
  }
#line 904
  plen = (int )strlen(path___1);
#line 905
  mlen = (int )strlen((char const   *)mnts->path);
#line 906
  if (mlen < plen) {
#line 907
    tmp = tree_find_mnt_ents(mnts->right, list, path___1);
#line 907
    return (tmp);
  } else {
#line 908
    if (mlen > plen) {
#line 909
      tmp___0 = tree_find_mnt_ents(mnts->left, list, path___1);
#line 909
      return (tmp___0);
    } else {
#line 913
      tree_find_mnt_ents(mnts->left, list, path___1);
#line 915
      if (0) {
#line 915
        __s1_len = strlen((char const   *)mnts->path);
#line 915
        __s2_len = strlen(path___1);
#line 915
        if (! ((unsigned int )((void const   *)(mnts->path + 1)) - (unsigned int )((void const   *)mnts->path) == 1U)) {
          goto _L___0;
        } else {
#line 915
          if (__s1_len >= 4U) {
            _L___0: 
#line 915
            if (! ((unsigned int )((void const   *)(path___1 + 1)) - (unsigned int )((void const   *)path___1) == 1U)) {
#line 915
              tmp___10 = 1;
            } else {
#line 915
              if (__s2_len >= 4U) {
#line 915
                tmp___10 = 1;
              } else {
#line 915
                tmp___10 = 0;
              }
            }
          } else {
#line 915
            tmp___10 = 0;
          }
        }
#line 915
        if (tmp___10) {
#line 915
          tmp___6 = __builtin_strcmp((char const   *)mnts->path, path___1);
        } else {
#line 915
          tmp___9 = __builtin_strcmp((char const   *)mnts->path, path___1);
#line 915
          tmp___6 = tmp___9;
        }
      } else {
#line 915
        tmp___9 = __builtin_strcmp((char const   *)mnts->path, path___1);
#line 915
        tmp___6 = tmp___9;
      }
#line 915
      if (! tmp___6) {
#line 916
        while (1) {
#line 916
          mnts->entries.next = & mnts->entries;
#line 916
          mnts->entries.prev = & mnts->entries;
#line 916
          break;
        }
#line 917
        list_add(& mnts->entries, list);
      }
#line 920
      self = & mnts->self;
#line 921
      p = self->next;
#line 921
      while ((unsigned int )p != (unsigned int )self) {
#line 924
        this = (struct mnt_list *)((char *)p - (unsigned long )(& ((struct mnt_list *)0)->self));
#line 926
        if (0) {
#line 926
          __s1_len___0 = strlen((char const   *)this->path);
#line 926
          __s2_len___0 = strlen(path___1);
#line 926
          if (! ((unsigned int )((void const   *)(this->path + 1)) - (unsigned int )((void const   *)this->path) == 1U)) {
            goto _L___2;
          } else {
#line 926
            if (__s1_len___0 >= 4U) {
              _L___2: 
#line 926
              if (! ((unsigned int )((void const   *)(path___1 + 1)) - (unsigned int )((void const   *)path___1) == 1U)) {
#line 926
                tmp___20 = 1;
              } else {
#line 926
                if (__s2_len___0 >= 4U) {
#line 926
                  tmp___20 = 1;
                } else {
#line 926
                  tmp___20 = 0;
                }
              }
            } else {
#line 926
              tmp___20 = 0;
            }
          }
#line 926
          if (tmp___20) {
#line 926
            tmp___16 = __builtin_strcmp((char const   *)this->path, path___1);
          } else {
#line 926
            tmp___19 = __builtin_strcmp((char const   *)this->path, path___1);
#line 926
            tmp___16 = tmp___19;
          }
        } else {
#line 926
          tmp___19 = __builtin_strcmp((char const   *)this->path, path___1);
#line 926
          tmp___16 = tmp___19;
        }
#line 926
        if (! tmp___16) {
#line 927
          while (1) {
#line 927
            this->entries.next = & this->entries;
#line 927
            this->entries.prev = & this->entries;
#line 927
            break;
          }
#line 928
          list_add(& this->entries, list);
        }
#line 921
        p = p->next;
      }
#line 932
      tree_find_mnt_ents(mnts->right, list, path___1);
#line 934
      tmp___21 = list_empty(list);
#line 934
      if (! tmp___21) {
#line 935
        return (1);
      }
    }
  }
#line 938
  return (0);
}
}
#line 941 "mounts.c"
int tree_is_mounted(struct mnt_list *mnts , char const   *path___1 , unsigned int type___1 ) 
{ struct list_head *p ;
  struct list_head list ;
  int mounted ;
  int tmp ;
  struct mnt_list *mptr ;
  unsigned int autofs_fs ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 945
  mounted = 0;
#line 947
  while (1) {
#line 947
    list.next = & list;
#line 947
    list.prev = & list;
#line 947
    break;
  }
#line 949
  tmp = tree_find_mnt_ents(mnts, & list, path___1);
#line 949
  if (! tmp) {
#line 950
    return (0);
  }
#line 952
  p = list.next;
#line 952
  while ((unsigned int )p != (unsigned int )(& list)) {
#line 955
    mptr = (struct mnt_list *)((char *)p - (unsigned long )(& ((struct mnt_list *)0)->entries));
#line 957
    if (type___1) {
#line 960
      if (0) {
#line 960
        __s1_len = strlen((char const   *)mptr->fs_type);
#line 960
        __s2_len = strlen("autofs");
#line 960
        if (! ((unsigned int )((void const   *)(mptr->fs_type + 1)) - (unsigned int )((void const   *)mptr->fs_type) == 1U)) {
          goto _L___0;
        } else {
#line 960
          if (__s1_len >= 4U) {
            _L___0: 
#line 960
            if (! ((unsigned int )((void const   *)("autofs" + 1)) - (unsigned int )((void const   *)"autofs") == 1U)) {
#line 960
              tmp___9 = 1;
            } else {
#line 960
              if (__s2_len >= 4U) {
#line 960
                tmp___9 = 1;
              } else {
#line 960
                tmp___9 = 0;
              }
            }
          } else {
#line 960
            tmp___9 = 0;
          }
        }
#line 960
        if (tmp___9) {
#line 960
          tmp___5 = __builtin_strcmp((char const   *)mptr->fs_type, "autofs");
        } else {
#line 960
          tmp___8 = __builtin_strcmp((char const   *)mptr->fs_type, "autofs");
#line 960
          tmp___5 = tmp___8;
        }
      } else {
#line 960
        tmp___8 = __builtin_strcmp((char const   *)mptr->fs_type, "autofs");
#line 960
        tmp___5 = tmp___8;
      }
#line 960
      if (tmp___5) {
#line 960
        tmp___10 = 0;
      } else {
#line 960
        tmp___10 = 1;
      }
#line 960
      autofs_fs = (unsigned int )tmp___10;
#line 962
      if (type___1 & 2U) {
#line 963
        if (! autofs_fs) {
#line 964
          mounted = 1;
#line 965
          break;
        }
      } else {
#line 967
        if (type___1 & 4U) {
#line 968
          if (autofs_fs) {
#line 969
            mounted = 1;
#line 970
            break;
          }
        } else {
#line 973
          mounted = 1;
#line 974
          break;
        }
      }
    }
#line 952
    p = p->next;
  }
#line 978
  return (mounted);
}
}
#line 1 "nss_parse.tab.o"
#pragma merger(0,"/tmp/cil-f74uvPUX.i","-O2,-Wall,-fPIC")
#line 58 "../include/nsswitch.h"
int set_action(struct nss_action *act___0 , char *status , char *action , int negated ) ;
#line 59
struct nss_source *add_source(struct list_head *head , char *source ) ;
#line 81 "nss_parse.tab.h"
YYSTYPE___0 nss_lval  ;
#line 33 "nss_parse.y"
static union __anonunion_pthread_mutex_t_6 parse_mutex  =    {{0, 0U, 0, 0, 0U, {0}}};
#line 35 "nss_parse.y"
static struct list_head *nss_list  ;
#line 36 "nss_parse.y"
static struct nss_source *src  ;
#line 37 "nss_parse.y"
struct nss_action act[4]  ;
#line 49
int nss_lex(void) ;
#line 50
FILE *nss_in ;
#line 52
static int nss_ignore(char const   *s ) ;
#line 53
static int nss_error(char const   *s ) ;
#line 432 "nss_parse.tab.c"
static yytype_uint8 const   yytranslate___0[267]  = 
#line 432 "nss_parse.tab.c"
  {      (yytype_uint8 const   )(unsigned char)0,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)1,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)3,      (yytype_uint8 const   )(unsigned char)4, 
        (yytype_uint8 const   )(unsigned char)5,      (yytype_uint8 const   )(unsigned char)6,      (yytype_uint8 const   )(unsigned char)7,      (yytype_uint8 const   )(unsigned char)8, 
        (yytype_uint8 const   )(unsigned char)9,      (yytype_uint8 const   )(unsigned char)10,      (yytype_uint8 const   )(unsigned char)11};
#line 517 "nss_parse.tab.c"
static yytype_uint8 const   yyr1___0[23]  = 
#line 517
  {      (yytype_uint8 const   )(unsigned char)0,      (yytype_uint8 const   )(unsigned char)12,      (yytype_uint8 const   )(unsigned char)14,      (yytype_uint8 const   )(unsigned char)13, 
        (yytype_uint8 const   )(unsigned char)15,      (yytype_uint8 const   )(unsigned char)15,      (yytype_uint8 const   )(unsigned char)16,      (yytype_uint8 const   )(unsigned char)16, 
        (yytype_uint8 const   )(unsigned char)16,      (yytype_uint8 const   )(unsigned char)16,      (yytype_uint8 const   )(unsigned char)16,      (yytype_uint8 const   )(unsigned char)16, 
        (yytype_uint8 const   )(unsigned char)16,      (yytype_uint8 const   )(unsigned char)16,      (yytype_uint8 const   )(unsigned char)17,      (yytype_uint8 const   )(unsigned char)17, 
        (yytype_uint8 const   )(unsigned char)18,      (yytype_uint8 const   )(unsigned char)18,      (yytype_uint8 const   )(unsigned char)18,      (yytype_uint8 const   )(unsigned char)18, 
        (yytype_uint8 const   )(unsigned char)18,      (yytype_uint8 const   )(unsigned char)18,      (yytype_uint8 const   )(unsigned char)18};
#line 525 "nss_parse.tab.c"
static yytype_uint8 const   yyr2___0[23]  = 
#line 525
  {      (yytype_uint8 const   )(unsigned char)0,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)0,      (yytype_uint8 const   )(unsigned char)3, 
        (yytype_uint8 const   )(unsigned char)1,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)1,      (yytype_uint8 const   )(unsigned char)4, 
        (yytype_uint8 const   )(unsigned char)4,      (yytype_uint8 const   )(unsigned char)4,      (yytype_uint8 const   )(unsigned char)4,      (yytype_uint8 const   )(unsigned char)3, 
        (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)1,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)3,      (yytype_uint8 const   )(unsigned char)4,      (yytype_uint8 const   )(unsigned char)3,      (yytype_uint8 const   )(unsigned char)2, 
        (yytype_uint8 const   )(unsigned char)4,      (yytype_uint8 const   )(unsigned char)3,      (yytype_uint8 const   )(unsigned char)2};
#line 535 "nss_parse.tab.c"
static yytype_uint8 const   yydefact___0[33]  = 
#line 535
  {      (yytype_uint8 const   )(unsigned char)2,      (yytype_uint8 const   )(unsigned char)0,      (yytype_uint8 const   )(unsigned char)0,      (yytype_uint8 const   )(unsigned char)1, 
        (yytype_uint8 const   )(unsigned char)0,      (yytype_uint8 const   )(unsigned char)6,      (yytype_uint8 const   )(unsigned char)0,      (yytype_uint8 const   )(unsigned char)0, 
        (yytype_uint8 const   )(unsigned char)13,      (yytype_uint8 const   )(unsigned char)0,      (yytype_uint8 const   )(unsigned char)12,      (yytype_uint8 const   )(unsigned char)3, 
        (yytype_uint8 const   )(unsigned char)5,      (yytype_uint8 const   )(unsigned char)0,      (yytype_uint8 const   )(unsigned char)0,      (yytype_uint8 const   )(unsigned char)11, 
        (yytype_uint8 const   )(unsigned char)0,      (yytype_uint8 const   )(unsigned char)14,      (yytype_uint8 const   )(unsigned char)0,      (yytype_uint8 const   )(unsigned char)22, 
        (yytype_uint8 const   )(unsigned char)0,      (yytype_uint8 const   )(unsigned char)19,      (yytype_uint8 const   )(unsigned char)7,      (yytype_uint8 const   )(unsigned char)10, 
        (yytype_uint8 const   )(unsigned char)8,      (yytype_uint8 const   )(unsigned char)9,      (yytype_uint8 const   )(unsigned char)15,      (yytype_uint8 const   )(unsigned char)0, 
        (yytype_uint8 const   )(unsigned char)21,      (yytype_uint8 const   )(unsigned char)16,      (yytype_uint8 const   )(unsigned char)18,      (yytype_uint8 const   )(unsigned char)17, 
        (yytype_uint8 const   )(unsigned char)20};
#line 544 "nss_parse.tab.c"
static yytype_int8 const   yydefgoto___0[7]  = {      (yytype_int8 const   )(signed char)-1,      (yytype_int8 const   )(signed char)1,      (yytype_int8 const   )(signed char)2,      (yytype_int8 const   )(signed char)6, 
        (yytype_int8 const   )(signed char)7,      (yytype_int8 const   )(signed char)16,      (yytype_int8 const   )(signed char)17};
#line 552 "nss_parse.tab.c"
static yytype_int8 const   yypact___0[33]  = 
#line 552
  {      (yytype_int8 const   )(signed char)-9,      (yytype_int8 const   )(signed char)23,      (yytype_int8 const   )(signed char)6,      (yytype_int8 const   )(signed char)-9, 
        (yytype_int8 const   )(signed char)14,      (yytype_int8 const   )(signed char)-3,      (yytype_int8 const   )(signed char)21,      (yytype_int8 const   )(signed char)3, 
        (yytype_int8 const   )(signed char)-9,      (yytype_int8 const   )(signed char)11,      (yytype_int8 const   )(signed char)-9,      (yytype_int8 const   )(signed char)-9, 
        (yytype_int8 const   )(signed char)-9,      (yytype_int8 const   )(signed char)-8,      (yytype_int8 const   )(signed char)7,      (yytype_int8 const   )(signed char)-9, 
        (yytype_int8 const   )(signed char)-2,      (yytype_int8 const   )(signed char)15,      (yytype_int8 const   )(signed char)8,      (yytype_int8 const   )(signed char)-9, 
        (yytype_int8 const   )(signed char)5,      (yytype_int8 const   )(signed char)-9,      (yytype_int8 const   )(signed char)-9,      (yytype_int8 const   )(signed char)-9, 
        (yytype_int8 const   )(signed char)-9,      (yytype_int8 const   )(signed char)-9,      (yytype_int8 const   )(signed char)-9,      (yytype_int8 const   )(signed char)16, 
        (yytype_int8 const   )(signed char)-9,      (yytype_int8 const   )(signed char)-9,      (yytype_int8 const   )(signed char)-9,      (yytype_int8 const   )(signed char)-9, 
        (yytype_int8 const   )(signed char)-9};
#line 561 "nss_parse.tab.c"
static yytype_int8 const   yypgoto___0[7]  = {      (yytype_int8 const   )(signed char)-9,      (yytype_int8 const   )(signed char)-9,      (yytype_int8 const   )(signed char)-9,      (yytype_int8 const   )(signed char)22, 
        (yytype_int8 const   )(signed char)-9,      (yytype_int8 const   )(signed char)13,      (yytype_int8 const   )(signed char)-9};
#line 571 "nss_parse.tab.c"
static yytype_int8 const   yytable___0[31]  = 
#line 571
  {      (yytype_int8 const   )(signed char)9,      (yytype_int8 const   )(signed char)18,      (yytype_int8 const   )(signed char)22,      (yytype_int8 const   )(signed char)19, 
        (yytype_int8 const   )(signed char)4,      (yytype_int8 const   )(signed char)23,      (yytype_int8 const   )(signed char)24,      (yytype_int8 const   )(signed char)4, 
        (yytype_int8 const   )(signed char)10,      (yytype_int8 const   )(signed char)25,      (yytype_int8 const   )(signed char)-4,      (yytype_int8 const   )(signed char)5, 
        (yytype_int8 const   )(signed char)20,      (yytype_int8 const   )(signed char)27,      (yytype_int8 const   )(signed char)5,      (yytype_int8 const   )(signed char)29, 
        (yytype_int8 const   )(signed char)30,      (yytype_int8 const   )(signed char)13,      (yytype_int8 const   )(signed char)21,      (yytype_int8 const   )(signed char)28, 
        (yytype_int8 const   )(signed char)14,      (yytype_int8 const   )(signed char)13,      (yytype_int8 const   )(signed char)15,      (yytype_int8 const   )(signed char)3, 
        (yytype_int8 const   )(signed char)14,      (yytype_int8 const   )(signed char)8,      (yytype_int8 const   )(signed char)31,      (yytype_int8 const   )(signed char)32, 
        (yytype_int8 const   )(signed char)11,      (yytype_int8 const   )(signed char)12,      (yytype_int8 const   )(signed char)26};
#line 579 "nss_parse.tab.c"
static yytype_uint8 const   yycheck___0[31]  = 
#line 579
  {      (yytype_uint8 const   )(unsigned char)3,      (yytype_uint8 const   )(unsigned char)9,      (yytype_uint8 const   )(unsigned char)4,      (yytype_uint8 const   )(unsigned char)11, 
        (yytype_uint8 const   )(unsigned char)1,      (yytype_uint8 const   )(unsigned char)7,      (yytype_uint8 const   )(unsigned char)8,      (yytype_uint8 const   )(unsigned char)1, 
        (yytype_uint8 const   )(unsigned char)11,      (yytype_uint8 const   )(unsigned char)11,      (yytype_uint8 const   )(unsigned char)7,      (yytype_uint8 const   )(unsigned char)8, 
        (yytype_uint8 const   )(unsigned char)5,      (yytype_uint8 const   )(unsigned char)5,      (yytype_uint8 const   )(unsigned char)8,      (yytype_uint8 const   )(unsigned char)10, 
        (yytype_uint8 const   )(unsigned char)11,      (yytype_uint8 const   )(unsigned char)6,      (yytype_uint8 const   )(unsigned char)11,      (yytype_uint8 const   )(unsigned char)11, 
        (yytype_uint8 const   )(unsigned char)9,      (yytype_uint8 const   )(unsigned char)6,      (yytype_uint8 const   )(unsigned char)11,      (yytype_uint8 const   )(unsigned char)0, 
        (yytype_uint8 const   )(unsigned char)9,      (yytype_uint8 const   )(unsigned char)11,      (yytype_uint8 const   )(unsigned char)10,      (yytype_uint8 const   )(unsigned char)11, 
        (yytype_uint8 const   )(unsigned char)7,      (yytype_uint8 const   )(unsigned char)7,      (yytype_uint8 const   )(unsigned char)17};
#line 589 "nss_parse.tab.c"
static yytype_uint8 const   yystos___0[33]  = 
#line 589
  {      (yytype_uint8 const   )(unsigned char)0,      (yytype_uint8 const   )(unsigned char)13,      (yytype_uint8 const   )(unsigned char)14,      (yytype_uint8 const   )(unsigned char)0, 
        (yytype_uint8 const   )(unsigned char)1,      (yytype_uint8 const   )(unsigned char)8,      (yytype_uint8 const   )(unsigned char)15,      (yytype_uint8 const   )(unsigned char)16, 
        (yytype_uint8 const   )(unsigned char)11,      (yytype_uint8 const   )(unsigned char)3,      (yytype_uint8 const   )(unsigned char)11,      (yytype_uint8 const   )(unsigned char)7, 
        (yytype_uint8 const   )(unsigned char)15,      (yytype_uint8 const   )(unsigned char)6,      (yytype_uint8 const   )(unsigned char)9,      (yytype_uint8 const   )(unsigned char)11, 
        (yytype_uint8 const   )(unsigned char)17,      (yytype_uint8 const   )(unsigned char)18,      (yytype_uint8 const   )(unsigned char)9,      (yytype_uint8 const   )(unsigned char)11, 
        (yytype_uint8 const   )(unsigned char)5,      (yytype_uint8 const   )(unsigned char)11,      (yytype_uint8 const   )(unsigned char)4,      (yytype_uint8 const   )(unsigned char)7, 
        (yytype_uint8 const   )(unsigned char)8,      (yytype_uint8 const   )(unsigned char)11,      (yytype_uint8 const   )(unsigned char)17,      (yytype_uint8 const   )(unsigned char)5, 
        (yytype_uint8 const   )(unsigned char)11,      (yytype_uint8 const   )(unsigned char)10,      (yytype_uint8 const   )(unsigned char)11,      (yytype_uint8 const   )(unsigned char)10, 
        (yytype_uint8 const   )(unsigned char)11};
#line 1084 "nss_parse.tab.c"
static void yydestruct___0(char const   *yymsg , int yytype , YYSTYPE___0 *yyvaluep ) 
{ 

  {
#line 1096
  if (! yymsg) {
#line 1097
    yymsg = "Deleting";
  }
#line 1100
  switch (yytype) {
  default: ;
#line 1104
  break;
  }
#line 1106
  return;
}
}
#line 1119
int nss_parse(void) ;
#line 1128 "nss_parse.tab.c"
int nss_char  ;
#line 1134 "nss_parse.tab.c"
int nss_nerrs  ;
#line 1155 "nss_parse.tab.c"
int nss_parse(void) 
{ int yystate ;
  int yyn ;
  int yyresult ;
  int yyerrstatus ;
  int yytoken ;
  yytype_int16 yyssa[200] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE___0 yyvsa[200] ;
  YYSTYPE___0 *yyvs ;
  YYSTYPE___0 *yyvsp ;
  unsigned int yystacksize ;
  YYSTYPE___0 yyval ;
  int yylen ;
  unsigned int yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc___0 *yyptr ;
  union yyalloc___0 *tmp ;
  unsigned int yynewbytes ;
  unsigned int yynewbytes___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  enum nsswitch_status a ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;

  {
#line 1171
  yytoken = 0;
#line 1189
  yyss = yyssa;
#line 1194
  yyvs = yyvsa;
#line 1201
  yystacksize = 200U;
#line 1210
  yylen = 0;
#line 1214
  yystate = 0;
#line 1215
  yyerrstatus = 0;
#line 1216
  nss_nerrs = 0;
#line 1217
  nss_char = -2;
#line 1224
  yyssp = yyss;
#line 1225
  yyvsp = yyvs;
  goto yysetstate;
  yynewstate: 
#line 1235
  yyssp ++;
  yysetstate: 
#line 1238
  (*yyssp) = (short )yystate;
#line 1240
  if ((unsigned int )((yyss + yystacksize) - 1) <= (unsigned int )yyssp) {
#line 1243
    yysize = (unsigned int )((yyssp - yyss) + 1);
#line 1272
    if (10000U <= yystacksize) {
      goto yyexhaustedlab;
    }
#line 1274
    yystacksize *= 2U;
#line 1275
    if (10000U < yystacksize) {
#line 1276
      yystacksize = 10000U;
    }
#line 1279
    yyss1 = yyss;
#line 1280
    tmp = (union yyalloc___0 *)malloc(yystacksize * (sizeof(yytype_int16 ) + sizeof(YYSTYPE___0 )) + (sizeof(union yyalloc___0 ) - 1U));
#line 1280
    yyptr = tmp;
#line 1282
    if (! yyptr) {
      goto yyexhaustedlab;
    }
#line 1284
    while (1) {
#line 1284
      __builtin_memcpy((void *)(& yyptr->yyss), (void const   *)yyss, yysize * sizeof((*yyss)));
#line 1284
      yyss = & yyptr->yyss;
#line 1284
      yynewbytes = yystacksize * sizeof((*yyss)) + (sizeof(union yyalloc___0 ) - 1U);
#line 1284
      yyptr += yynewbytes / sizeof((*yyptr));
#line 1284
      break;
    }
#line 1285
    while (1) {
#line 1285
      __builtin_memcpy((void *)(& yyptr->yyvs), (void const   *)yyvs, yysize * sizeof((*yyvs)));
#line 1285
      yyvs = & yyptr->yyvs;
#line 1285
      yynewbytes___0 = yystacksize * sizeof((*yyvs)) + (sizeof(union yyalloc___0 ) - 1U);
#line 1285
      yyptr += yynewbytes___0 / sizeof((*yyptr));
#line 1285
      break;
    }
#line 1288
    if ((unsigned int )yyss1 != (unsigned int )(yyssa)) {
#line 1289
      free((void *)yyss1);
    }
#line 1294
    yyssp = (yyss + yysize) - 1;
#line 1295
    yyvsp = (yyvs + yysize) - 1;
#line 1301
    if ((unsigned int )((yyss + yystacksize) - 1) <= (unsigned int )yyssp) {
      goto yyabortlab;
    }
  }
  goto yybackup;
  yybackup: 
#line 1318
  yyn = (int )yypact___0[yystate];
#line 1319
  if (yyn == -9) {
    goto yydefault;
  }
#line 1325
  if (nss_char == -2) {
#line 1328
    nss_char = nss_lex();
  }
#line 1331
  if (nss_char <= 0) {
#line 1333
    yytoken = 0;
#line 1333
    nss_char = yytoken;
  } else {
#line 1338
    if ((unsigned int )nss_char <= 266U) {
#line 1338
      yytoken = (int )yytranslate___0[nss_char];
    } else {
#line 1338
      yytoken = 2;
    }
  }
#line 1344
  yyn += yytoken;
#line 1345
  if (yyn < 0) {
    goto yydefault;
  } else {
#line 1345
    if (30 < yyn) {
      goto yydefault;
    } else {
#line 1345
      if ((int const   )yycheck___0[yyn] != (int const   )yytoken) {
        goto yydefault;
      }
    }
  }
#line 1347
  yyn = (int )yytable___0[yyn];
#line 1348
  if (yyn <= 0) {
#line 1350
    if (yyn == 0) {
      goto yyerrlab;
    } else {
#line 1350
      if (yyn == -5) {
        goto yyerrlab;
      }
    }
#line 1352
    yyn = - yyn;
    goto yyreduce;
  }
#line 1356
  if (yyn == 3) {
    goto yyacceptlab;
  }
#line 1361
  if (yyerrstatus) {
#line 1362
    yyerrstatus --;
  }
#line 1368
  if (nss_char != 0) {
#line 1369
    nss_char = -2;
  }
#line 1371
  yystate = yyn;
#line 1372
  yyvsp ++;
#line 1372
  (*yyvsp) = nss_lval;
  goto yynewstate;
  yydefault: 
#line 1381
  yyn = (int )yydefact___0[yystate];
#line 1382
  if (yyn == 0) {
    goto yyerrlab;
  }
  goto yyreduce;
  yyreduce: 
#line 1392
  yylen = (int )yyr2___0[yyn];
#line 1402
  yyval = (*(yyvsp + (1 - yylen)));
#line 1406
  switch (yyn) {
  case 2: ;
#line 76 "nss_parse.y"
  break;
  case 6: 
#line 84
  if (0) {
#line 84
    __s1_len = strlen((char const   *)((yyvsp + 0)->strval));
#line 84
    __s2_len = strlen("winbind");
#line 84
    if (! ((unsigned int )((void const   *)((yyvsp + 0)->strval + 1)) - (unsigned int )((void const   *)((yyvsp + 0)->strval)) == 1U)) {
      goto _L___0;
    } else {
#line 84
      if (__s1_len >= 4U) {
        _L___0: 
#line 84
        if (! ((unsigned int )((void const   *)("winbind" + 1)) - (unsigned int )((void const   *)"winbind") == 1U)) {
#line 84
          tmp___9 = 1;
        } else {
#line 84
          if (__s2_len >= 4U) {
#line 84
            tmp___9 = 1;
          } else {
#line 84
            tmp___9 = 0;
          }
        }
      } else {
#line 84
        tmp___9 = 0;
      }
    }
#line 84
    if (tmp___9) {
#line 84
      tmp___5 = __builtin_strcmp((char const   *)((yyvsp + 0)->strval), "winbind");
    } else {
#line 84
      tmp___8 = __builtin_strcmp((char const   *)((yyvsp + 0)->strval), "winbind");
#line 84
      tmp___5 = tmp___8;
    }
  } else {
#line 84
    tmp___8 = __builtin_strcmp((char const   *)((yyvsp + 0)->strval), "winbind");
#line 84
    tmp___5 = tmp___8;
  }
#line 84
  if (tmp___5) {
#line 85
    src = add_source(nss_list, (yyvsp + 0)->strval);
  } else {
#line 87
    nss_ignore((char const   *)((yyvsp + 0)->strval));
  }
#line 89
  break;
  case 7: 
#line 92
  if (0) {
#line 92
    __s1_len___0 = strlen((char const   *)((yyvsp + -3)->strval));
#line 92
    __s2_len___0 = strlen("winbind");
#line 92
    if (! ((unsigned int )((void const   *)((yyvsp + -3)->strval + 1)) - (unsigned int )((void const   *)((yyvsp + -3)->strval)) == 1U)) {
      goto _L___2;
    } else {
#line 92
      if (__s1_len___0 >= 4U) {
        _L___2: 
#line 92
        if (! ((unsigned int )((void const   *)("winbind" + 1)) - (unsigned int )((void const   *)"winbind") == 1U)) {
#line 92
          tmp___19 = 1;
        } else {
#line 92
          if (__s2_len___0 >= 4U) {
#line 92
            tmp___19 = 1;
          } else {
#line 92
            tmp___19 = 0;
          }
        }
      } else {
#line 92
        tmp___19 = 0;
      }
    }
#line 92
    if (tmp___19) {
#line 92
      tmp___15 = __builtin_strcmp((char const   *)((yyvsp + -3)->strval), "winbind");
    } else {
#line 92
      tmp___18 = __builtin_strcmp((char const   *)((yyvsp + -3)->strval), "winbind");
#line 92
      tmp___15 = tmp___18;
    }
  } else {
#line 92
    tmp___18 = __builtin_strcmp((char const   *)((yyvsp + -3)->strval), "winbind");
#line 92
    tmp___15 = tmp___18;
  }
#line 92
  if (tmp___15) {
#line 93
    src = add_source(nss_list, (yyvsp + -3)->strval);
#line 94
    a = (enum nsswitch_status )0;
#line 94
    while ((int )a < 4) {
#line 95
      if ((int )act[a].action != 0) {
#line 96
        src->action[a].action = act[a].action;
#line 97
        src->action[a].negated = act[a].negated;
      }
#line 94
      a = (enum nsswitch_status )((int )a + 1);
    }
  } else {
#line 101
    nss_ignore((char const   *)((yyvsp + -3)->strval));
  }
#line 103
  break;
  case 8: 
#line 102
  nss_error((char const   *)((yyvsp + 0)->strval));
  goto yyabortlab;
#line 103
  break;
  case 9: 
#line 103
  nss_error((char const   *)((yyvsp + 0)->strval));
  goto yyabortlab;
#line 104
  break;
  case 10: 
#line 104
  nss_error("no closing bracket");
  goto yyabortlab;
#line 105
  break;
  case 11: 
#line 105
  nss_error((char const   *)((yyvsp + 0)->strval));
  goto yyabortlab;
#line 106
  break;
  case 12: 
#line 106
  nss_error("no opening bracket");
  goto yyabortlab;
#line 107
  break;
  case 13: 
#line 107
  nss_error((char const   *)((yyvsp + 0)->strval));
  goto yyabortlab;
#line 108
  break;
  case 16: 
#line 114
  set_action(act, (yyvsp + -2)->strval, (yyvsp + 0)->strval, 0);
#line 116
  break;
  case 17: 
#line 117
  set_action(act, (yyvsp + -2)->strval, (yyvsp + 0)->strval, 1);
#line 119
  break;
  case 18: 
#line 118
  nss_error((char const   *)((yyvsp + 0)->strval));
  goto yyabortlab;
#line 119
  break;
  case 19: 
#line 119
  nss_error((char const   *)((yyvsp + 0)->strval));
  goto yyabortlab;
#line 120
  break;
  case 20: 
#line 120
  nss_error((char const   *)((yyvsp + 0)->strval));
  goto yyabortlab;
#line 121
  break;
  case 21: 
#line 121
  nss_error((char const   *)((yyvsp + 0)->strval));
  goto yyabortlab;
#line 122
  break;
  case 22: 
#line 122
  nss_error((char const   *)((yyvsp + 0)->strval));
  goto yyabortlab;
#line 123
  break;
  default: ;
#line 1517 "nss_parse.tab.c"
  break;
  }
#line 1521
  yyvsp -= yylen;
#line 1521
  yyssp -= yylen;
#line 1522
  yylen = 0;
#line 1525
  yyvsp ++;
#line 1525
  (*yyvsp) = yyval;
#line 1532
  yyn = (int )yyr1___0[yyn];
#line 1534
  yystate = (int )((int const   )yypgoto___0[yyn - 12] + (int const   )(*yyssp));
#line 1535
  if (0 <= yystate) {
#line 1535
    if (yystate <= 30) {
#line 1535
      if ((int const   )yycheck___0[yystate] == (int const   )(*yyssp)) {
#line 1536
        yystate = (int )yytable___0[yystate];
      } else {
#line 1538
        yystate = (int )yydefgoto___0[yyn - 12];
      }
    } else {
#line 1538
      yystate = (int )yydefgoto___0[yyn - 12];
    }
  } else {
#line 1538
    yystate = (int )yydefgoto___0[yyn - 12];
  }
  goto yynewstate;
  yyerrlab: 
#line 1548
  if (! yyerrstatus) {
#line 1550
    nss_nerrs ++;
#line 1552
    nss_error("syntax error");
  }
#line 1590
  if (yyerrstatus == 3) {
#line 1595
    if (nss_char <= 0) {
#line 1598
      if (nss_char == 0) {
        goto yyabortlab;
      }
    } else {
#line 1603
      yydestruct___0("Error: discarding", yytoken, & nss_lval);
#line 1605
      nss_char = -2;
    }
  }
  goto yyerrlab1;
#line 1627
  yyvsp -= yylen;
#line 1627
  yyssp -= yylen;
#line 1628
  yylen = 0;
#line 1630
  yystate = (int )(*yyssp);
  goto yyerrlab1;
  yyerrlab1: 
#line 1638
  yyerrstatus = 3;
#line 1640
  while (1) {
#line 1642
    yyn = (int )yypact___0[yystate];
#line 1643
    if (yyn != -9) {
#line 1645
      yyn ++;
#line 1646
      if (0 <= yyn) {
#line 1646
        if (yyn <= 30) {
#line 1646
          if ((int const   )yycheck___0[yyn] == 1) {
#line 1648
            yyn = (int )yytable___0[yyn];
#line 1649
            if (0 < yyn) {
#line 1650
              break;
            }
          }
        }
      }
    }
#line 1655
    if ((unsigned int )yyssp == (unsigned int )yyss) {
      goto yyabortlab;
    }
#line 1659
    yydestruct___0("Error: popping", (int )yystos___0[yystate], yyvsp);
#line 1661
    yyvsp --;
#line 1661
    yyssp --;
#line 1662
    yystate = (int )(*yyssp);
  }
#line 1666
  if (yyn == 3) {
    goto yyacceptlab;
  }
#line 1669
  yyvsp ++;
#line 1669
  (*yyvsp) = nss_lval;
#line 1675
  yystate = yyn;
  goto yynewstate;
  yyacceptlab: 
#line 1683
  yyresult = 0;
  goto yyreturn;
  yyabortlab: 
#line 1690
  yyresult = 1;
  goto yyreturn;
  yyexhaustedlab: 
#line 1698
  nss_error("memory exhausted");
#line 1699
  yyresult = 2;
  yyreturn: 
#line 1704
  if (nss_char != 0) {
#line 1704
    if (nss_char != -2) {
#line 1705
      yydestruct___0("Cleanup: discarding lookahead", yytoken, & nss_lval);
    }
  }
#line 1709
  yyvsp -= yylen;
#line 1709
  yyssp -= yylen;
#line 1711
  while ((unsigned int )yyssp != (unsigned int )yyss) {
#line 1713
    yydestruct___0("Cleanup: popping", (int )yystos___0[(*yyssp)], yyvsp);
#line 1715
    yyvsp --;
#line 1715
    yyssp --;
  }
#line 1718
  if ((unsigned int )yyss != (unsigned int )(yyssa)) {
#line 1719
    free((void *)yyss);
  }
#line 1726
  return (yyresult);
}
}
#line 126 "nss_parse.y"
static int nss_ignore(char const   *s ) 
{ 

  {
#line 128
  while (1) {
#line 128
    ((*log_info))(0U, "ignored invalid nsswitch config near [ %s ]", s);
#line 128
    break;
  }
#line 129
  return (0);
}
}
#line 132 "nss_parse.y"
static int nss_error(char const   *s ) 
{ 

  {
#line 134
  while (1) {
#line 134
    ((*log_info))(0U, "syntax error in nsswitch config near [ %s ]\n", s);
#line 134
    break;
  }
#line 135
  return (0);
}
}
#line 138 "nss_parse.y"
static void parse_mutex_lock(void) 
{ int status ;
  int tmp ;

  {
#line 140
  tmp = pthread_mutex_lock(& parse_mutex);
#line 140
  status = tmp;
#line 141
  if (status) {
#line 142
    while (1) {
#line 142
      if (status == 35) {
#line 142
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "parse_mutex_lock", 142, "nss_parse.y");
#line 142
        dump_core();
      }
#line 142
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 142,
                    "nss_parse.y");
#line 142
      abort();
#line 142
      break;
    }
  }
#line 143
  return;
}
}
#line 146 "nss_parse.y"
static void parse_mutex_unlock(void *arg ) 
{ int status ;
  int tmp ;

  {
#line 148
  tmp = pthread_mutex_unlock(& parse_mutex);
#line 148
  status = tmp;
#line 149
  if (status) {
#line 150
    while (1) {
#line 150
      if (status == 35) {
#line 150
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "parse_mutex_unlock", 150, "nss_parse.y");
#line 150
        dump_core();
      }
#line 150
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 150,
                    "nss_parse.y");
#line 150
      abort();
#line 150
      break;
    }
  }
#line 151
  return;
}
}
#line 154 "nss_parse.y"
static void parse_close_nsswitch(void *arg ) 
{ FILE *nsswitch ;

  {
#line 156
  nsswitch = (FILE *)arg;
#line 157
  fclose(nsswitch);
#line 158
  return;
}
}
#line 161 "nss_parse.y"
int nsswitch_parse(struct list_head *list ) 
{ FILE *nsswitch ;
  int fd ;
  int cl_flags ;
  int status ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp ;
  long tmp___0 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___0)(void * ) ;
  void *__cancel_arg___0 ;
  int not_first_call___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 166
  nsswitch = fopen((char const   * __restrict  )"/etc/nsswitch.conf", (char const   * __restrict  )"r");
#line 167
  if (! nsswitch) {
#line 168
    while (1) {
#line 168
      ((*log_error))(3U, "%s: couldn\'t open %s\n", "nsswitch_parse", "/etc/nsswitch.conf");
#line 168
      break;
    }
#line 169
    return (1);
  }
#line 172
  while (1) {
#line 172
    __cancel_routine = & parse_close_nsswitch;
#line 172
    __cancel_arg = (void *)nsswitch;
#line 172
    tmp = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf), 0);
#line 172
    not_first_call = tmp;
#line 172
    tmp___0 = __builtin_expect((long )not_first_call, 0L);
#line 172
    if (tmp___0) {
#line 172
      ((*__cancel_routine))(__cancel_arg);
#line 172
      __pthread_unwind_next(& __cancel_buf);
    }
#line 172
    __pthread_register_cancel(& __cancel_buf);
#line 172
    while (1) {
#line 174
      fd = fileno(nsswitch);
#line 176
      cl_flags = fcntl(fd, 1, 0);
#line 176
      if (cl_flags != -1) {
#line 177
        cl_flags |= 1;
#line 178
        fcntl(fd, 2, cl_flags);
      }
#line 181
      parse_mutex_lock();
#line 182
      while (1) {
#line 182
        __cancel_routine___0 = & parse_mutex_unlock;
#line 182
        __cancel_arg___0 = (void *)0;
#line 182
        tmp___1 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf),
                              0);
#line 182
        not_first_call___0 = tmp___1;
#line 182
        tmp___2 = __builtin_expect((long )not_first_call___0, 0L);
#line 182
        if (tmp___2) {
#line 182
          ((*__cancel_routine___0))(__cancel_arg___0);
#line 182
          __pthread_unwind_next(& __cancel_buf___0);
        }
#line 182
        __pthread_register_cancel(& __cancel_buf___0);
#line 182
        while (1) {
#line 184
          nss_in = nsswitch;
#line 186
          nss_list = list;
#line 187
          status = nss_parse();
#line 188
          nss_list = (struct list_head *)((void *)0);
#line 182
          break;
        }
#line 190
        __pthread_unregister_cancel(& __cancel_buf___0);
#line 190
        ((*__cancel_routine___0))(__cancel_arg___0);
#line 182
        break;
      }
#line 172
      break;
    }
#line 191
    __pthread_unregister_cancel(& __cancel_buf);
#line 191
    ((*__cancel_routine))(__cancel_arg);
#line 172
    break;
  }
#line 193
  if (status) {
#line 194
    return (1);
  }
#line 196
  return (0);
}
}
#line 1 "nss_tok.o"
#pragma merger(0,"/tmp/cil-wIosJoid.i","-O2,-Wall,-fPIC")
#line 451 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 614 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 731
extern  __attribute__((__nothrow__)) void clearerr(FILE *__stream ) ;
#line 155 "nss_tok.c"
int nss_leng  ;
#line 157
FILE *nss_out ;
#line 257 "nss_tok.c"
static unsigned int yy_buffer_stack_top___0  =    0U;
#line 258 "nss_tok.c"
static unsigned int yy_buffer_stack_max___0  =    0U;
#line 259 "nss_tok.c"
static YY_BUFFER_STATE *yy_buffer_stack___0  =    (YY_BUFFER_STATE *)0;
#line 277 "nss_tok.c"
static char yy_hold_char___0  ;
#line 278 "nss_tok.c"
static int yy_n_chars___0  ;
#line 282 "nss_tok.c"
static char *yy_c_buf_p___0  =    (char *)0;
#line 283 "nss_tok.c"
static int yy_init___0  =    0;
#line 284 "nss_tok.c"
static int yy_start___0  =    0;
#line 289 "nss_tok.c"
static int yy_did_buffer_switch_on_eof___0  ;
#line 291
void nss_restart(FILE *input_file ) ;
#line 292
void nss__switch_to_buffer(YY_BUFFER_STATE new_buffer ) ;
#line 293
YY_BUFFER_STATE nss__create_buffer(FILE *file , int size ) ;
#line 294
void nss__delete_buffer(YY_BUFFER_STATE b ) ;
#line 295
void nss__flush_buffer(YY_BUFFER_STATE b ) ;
#line 296
void nss_push_buffer_state(YY_BUFFER_STATE new_buffer ) ;
#line 297
void nss_pop_buffer_state(void) ;
#line 299
static void nss_ensure_buffer_stack(void) ;
#line 300
static void nss__load_buffer_state(void) ;
#line 301
static void nss__init_buffer(YY_BUFFER_STATE b , FILE *file ) ;
#line 305
YY_BUFFER_STATE nss__scan_buffer(char *base , yy_size_t size ) ;
#line 306
YY_BUFFER_STATE nss__scan_string(char const   *yystr ) ;
#line 307
YY_BUFFER_STATE nss__scan_bytes(char const   *yybytes , int _yybytes_len ) ;
#line 309
void *nss_alloc(yy_size_t size ) ;
#line 310
void *nss_realloc(void *ptr , yy_size_t size ) ;
#line 311
void nss_free(void *ptr ) ;
#line 341 "nss_tok.c"
FILE *nss_in  =    (FILE *)0;
#line 341 "nss_tok.c"
FILE *nss_out  =    (FILE *)0;
#line 345
int nss_lineno ;
#line 347 "nss_tok.c"
int nss_lineno  =    1;
#line 349 "nss_tok.c"
char *nss_text  ;
#line 352
static yy_state_type yy_get_previous_state___0(void) ;
#line 353
static yy_state_type yy_try_NUL_trans___0(yy_state_type yy_current_state ) ;
#line 354
static int yy_get_next_buffer___0(void) ;
#line 355
static void yy_fatal_error___0(char const   *msg ) ;
#line 376 "nss_tok.c"
static flex_int16_t const   yy_accept___0[94]  = 
#line 376
  {      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)0, 
        (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)14,      (flex_int16_t const   )(short)2,      (flex_int16_t const   )(short)2, 
        (flex_int16_t const   )(short)13,      (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)12,      (flex_int16_t const   )(short)10, 
        (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)9,      (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11, 
        (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11, 
        (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)8,      (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11, 
        (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11, 
        (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11, 
        (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11, 
        (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11, 
        (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)4,      (flex_int16_t const   )(short)0, 
        (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11, 
        (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11, 
        (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)4,      (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)0, 
        (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11, 
        (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11, 
        (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)11, 
        (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11, 
        (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11, 
        (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)6, 
        (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11, 
        (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)11, 
        (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)11,      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)0, 
        (flex_int16_t const   )(short)1,      (flex_int16_t const   )(short)0};
#line 391 "nss_tok.c"
static flex_int32_t const   yy_ec___0[256]  = 
#line 391
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )4,      (flex_int32_t const   )5,      (flex_int32_t const   )1, 
        (flex_int32_t const   )5,      (flex_int32_t const   )5,      (flex_int32_t const   )5,      (flex_int32_t const   )5, 
        (flex_int32_t const   )5,      (flex_int32_t const   )5,      (flex_int32_t const   )5,      (flex_int32_t const   )5, 
        (flex_int32_t const   )5,      (flex_int32_t const   )1,      (flex_int32_t const   )5,      (flex_int32_t const   )5, 
        (flex_int32_t const   )5,      (flex_int32_t const   )5,      (flex_int32_t const   )5,      (flex_int32_t const   )5, 
        (flex_int32_t const   )5,      (flex_int32_t const   )5,      (flex_int32_t const   )5,      (flex_int32_t const   )5, 
        (flex_int32_t const   )5,      (flex_int32_t const   )5,      (flex_int32_t const   )6,      (flex_int32_t const   )5, 
        (flex_int32_t const   )5,      (flex_int32_t const   )7,      (flex_int32_t const   )5,      (flex_int32_t const   )5, 
        (flex_int32_t const   )5,      (flex_int32_t const   )8,      (flex_int32_t const   )5,      (flex_int32_t const   )9, 
        (flex_int32_t const   )10,      (flex_int32_t const   )11,      (flex_int32_t const   )12,      (flex_int32_t const   )13, 
        (flex_int32_t const   )5,      (flex_int32_t const   )14,      (flex_int32_t const   )5,      (flex_int32_t const   )5, 
        (flex_int32_t const   )15,      (flex_int32_t const   )16,      (flex_int32_t const   )17,      (flex_int32_t const   )18, 
        (flex_int32_t const   )5,      (flex_int32_t const   )5,      (flex_int32_t const   )19,      (flex_int32_t const   )20, 
        (flex_int32_t const   )21,      (flex_int32_t const   )22,      (flex_int32_t const   )23,      (flex_int32_t const   )5, 
        (flex_int32_t const   )5,      (flex_int32_t const   )24,      (flex_int32_t const   )5,      (flex_int32_t const   )25, 
        (flex_int32_t const   )1,      (flex_int32_t const   )26,      (flex_int32_t const   )5,      (flex_int32_t const   )5, 
        (flex_int32_t const   )5,      (flex_int32_t const   )27,      (flex_int32_t const   )28,      (flex_int32_t const   )9, 
        (flex_int32_t const   )29,      (flex_int32_t const   )30,      (flex_int32_t const   )31,      (flex_int32_t const   )13, 
        (flex_int32_t const   )32,      (flex_int32_t const   )33,      (flex_int32_t const   )5,      (flex_int32_t const   )5, 
        (flex_int32_t const   )34,      (flex_int32_t const   )16,      (flex_int32_t const   )35,      (flex_int32_t const   )36, 
        (flex_int32_t const   )37,      (flex_int32_t const   )5,      (flex_int32_t const   )19,      (flex_int32_t const   )38, 
        (flex_int32_t const   )21,      (flex_int32_t const   )39,      (flex_int32_t const   )23,      (flex_int32_t const   )40, 
        (flex_int32_t const   )5,      (flex_int32_t const   )41,      (flex_int32_t const   )5,      (flex_int32_t const   )5, 
        (flex_int32_t const   )1,      (flex_int32_t const   )5,      (flex_int32_t const   )5,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 423 "nss_tok.c"
static flex_int32_t const   yy_meta___0[42]  = 
#line 423
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )2, 
        (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )2, 
        (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )2, 
        (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )2, 
        (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )2, 
        (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )2, 
        (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )2, 
        (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )2, 
        (flex_int32_t const   )2,      (flex_int32_t const   )2};
#line 432 "nss_tok.c"
static flex_int16_t const   yy_base___0[96]  = 
#line 432
  {      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)27, 
        (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)179,      (flex_int16_t const   )(short)180,      (flex_int16_t const   )(short)47, 
        (flex_int16_t const   )(short)180,      (flex_int16_t const   )(short)176,      (flex_int16_t const   )(short)180,      (flex_int16_t const   )(short)180, 
        (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)180,      (flex_int16_t const   )(short)52,      (flex_int16_t const   )(short)53, 
        (flex_int16_t const   )(short)61,      (flex_int16_t const   )(short)51,      (flex_int16_t const   )(short)158,      (flex_int16_t const   )(short)57, 
        (flex_int16_t const   )(short)180,      (flex_int16_t const   )(short)180,      (flex_int16_t const   )(short)143,      (flex_int16_t const   )(short)145, 
        (flex_int16_t const   )(short)145,      (flex_int16_t const   )(short)60,      (flex_int16_t const   )(short)140,      (flex_int16_t const   )(short)135, 
        (flex_int16_t const   )(short)150,      (flex_int16_t const   )(short)168,      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)59, 
        (flex_int16_t const   )(short)148,      (flex_int16_t const   )(short)147,      (flex_int16_t const   )(short)158,      (flex_int16_t const   )(short)56, 
        (flex_int16_t const   )(short)71,      (flex_int16_t const   )(short)132,      (flex_int16_t const   )(short)127,      (flex_int16_t const   )(short)137, 
        (flex_int16_t const   )(short)125,      (flex_int16_t const   )(short)127,      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)59, 
        (flex_int16_t const   )(short)140,      (flex_int16_t const   )(short)69,      (flex_int16_t const   )(short)60,      (flex_int16_t const   )(short)151, 
        (flex_int16_t const   )(short)75,      (flex_int16_t const   )(short)136,      (flex_int16_t const   )(short)128,      (flex_int16_t const   )(short)124, 
        (flex_int16_t const   )(short)116,      (flex_int16_t const   )(short)115,      (flex_int16_t const   )(short)123,      (flex_int16_t const   )(short)134, 
        (flex_int16_t const   )(short)70,      (flex_int16_t const   )(short)69,      (flex_int16_t const   )(short)130,      (flex_int16_t const   )(short)74, 
        (flex_int16_t const   )(short)135,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)109,      (flex_int16_t const   )(short)110, 
        (flex_int16_t const   )(short)111,      (flex_int16_t const   )(short)111,      (flex_int16_t const   )(short)88,      (flex_int16_t const   )(short)90, 
        (flex_int16_t const   )(short)87,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)91,      (flex_int16_t const   )(short)100, 
        (flex_int16_t const   )(short)98,      (flex_int16_t const   )(short)114,      (flex_int16_t const   )(short)103,      (flex_int16_t const   )(short)105, 
        (flex_int16_t const   )(short)91,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)99,      (flex_int16_t const   )(short)0, 
        (flex_int16_t const   )(short)97,      (flex_int16_t const   )(short)100,      (flex_int16_t const   )(short)103,      (flex_int16_t const   )(short)85, 
        (flex_int16_t const   )(short)46,      (flex_int16_t const   )(short)104,      (flex_int16_t const   )(short)108,      (flex_int16_t const   )(short)112, 
        (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)119,      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)0, 
        (flex_int16_t const   )(short)180,      (flex_int16_t const   )(short)180,      (flex_int16_t const   )(short)154,      (flex_int16_t const   )(short)0};
#line 447 "nss_tok.c"
static flex_int16_t const   yy_def___0[96]  = 
#line 447
  {      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)94,      (flex_int16_t const   )(short)94,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95, 
        (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95, 
        (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95, 
        (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95, 
        (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95, 
        (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95, 
        (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95, 
        (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95, 
        (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95, 
        (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)95, 
        (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95, 
        (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95, 
        (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95, 
        (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95, 
        (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93};
#line 462 "nss_tok.c"
static flex_int16_t const   yy_nxt___0[222]  = 
#line 462
  {      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)30,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)92,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)91,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)7, 
        (flex_int16_t const   )(short)8,      (flex_int16_t const   )(short)9,      (flex_int16_t const   )(short)10,      (flex_int16_t const   )(short)11, 
        (flex_int16_t const   )(short)12,      (flex_int16_t const   )(short)12,      (flex_int16_t const   )(short)13,      (flex_int16_t const   )(short)12, 
        (flex_int16_t const   )(short)14,      (flex_int16_t const   )(short)12,      (flex_int16_t const   )(short)12,      (flex_int16_t const   )(short)12, 
        (flex_int16_t const   )(short)12,      (flex_int16_t const   )(short)12,      (flex_int16_t const   )(short)12,      (flex_int16_t const   )(short)12, 
        (flex_int16_t const   )(short)15,      (flex_int16_t const   )(short)12,      (flex_int16_t const   )(short)16,      (flex_int16_t const   )(short)17, 
        (flex_int16_t const   )(short)18,      (flex_int16_t const   )(short)19,      (flex_int16_t const   )(short)12,      (flex_int16_t const   )(short)12, 
        (flex_int16_t const   )(short)20,      (flex_int16_t const   )(short)21,      (flex_int16_t const   )(short)12,      (flex_int16_t const   )(short)12, 
        (flex_int16_t const   )(short)12,      (flex_int16_t const   )(short)12,      (flex_int16_t const   )(short)22,      (flex_int16_t const   )(short)23, 
        (flex_int16_t const   )(short)12,      (flex_int16_t const   )(short)24,      (flex_int16_t const   )(short)25,      (flex_int16_t const   )(short)12, 
        (flex_int16_t const   )(short)12,      (flex_int16_t const   )(short)17,      (flex_int16_t const   )(short)19,      (flex_int16_t const   )(short)26, 
        (flex_int16_t const   )(short)27,      (flex_int16_t const   )(short)28,      (flex_int16_t const   )(short)31,      (flex_int16_t const   )(short)32, 
        (flex_int16_t const   )(short)33,      (flex_int16_t const   )(short)34,      (flex_int16_t const   )(short)36,      (flex_int16_t const   )(short)42, 
        (flex_int16_t const   )(short)44,      (flex_int16_t const   )(short)55,      (flex_int16_t const   )(short)32,      (flex_int16_t const   )(short)49, 
        (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)57,      (flex_int16_t const   )(short)58,      (flex_int16_t const   )(short)60, 
        (flex_int16_t const   )(short)67,      (flex_int16_t const   )(short)70,      (flex_int16_t const   )(short)28,      (flex_int16_t const   )(short)68, 
        (flex_int16_t const   )(short)31,      (flex_int16_t const   )(short)32,      (flex_int16_t const   )(short)34,      (flex_int16_t const   )(short)33, 
        (flex_int16_t const   )(short)36,      (flex_int16_t const   )(short)40,      (flex_int16_t const   )(short)44,      (flex_int16_t const   )(short)55, 
        (flex_int16_t const   )(short)32,      (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)49,      (flex_int16_t const   )(short)58, 
        (flex_int16_t const   )(short)57,      (flex_int16_t const   )(short)72,      (flex_int16_t const   )(short)60,      (flex_int16_t const   )(short)67, 
        (flex_int16_t const   )(short)70,      (flex_int16_t const   )(short)68,      (flex_int16_t const   )(short)76,      (flex_int16_t const   )(short)77, 
        (flex_int16_t const   )(short)81,      (flex_int16_t const   )(short)78,      (flex_int16_t const   )(short)79,      (flex_int16_t const   )(short)80, 
        (flex_int16_t const   )(short)82,      (flex_int16_t const   )(short)85,      (flex_int16_t const   )(short)89,      (flex_int16_t const   )(short)86, 
        (flex_int16_t const   )(short)87,      (flex_int16_t const   )(short)88,      (flex_int16_t const   )(short)88,      (flex_int16_t const   )(short)79, 
        (flex_int16_t const   )(short)72,      (flex_int16_t const   )(short)90,      (flex_int16_t const   )(short)88,      (flex_int16_t const   )(short)42, 
        (flex_int16_t const   )(short)76,      (flex_int16_t const   )(short)77,      (flex_int16_t const   )(short)78,      (flex_int16_t const   )(short)81, 
        (flex_int16_t const   )(short)79,      (flex_int16_t const   )(short)80,      (flex_int16_t const   )(short)85,      (flex_int16_t const   )(short)82, 
        (flex_int16_t const   )(short)86,      (flex_int16_t const   )(short)89,      (flex_int16_t const   )(short)87,      (flex_int16_t const   )(short)88, 
        (flex_int16_t const   )(short)88,      (flex_int16_t const   )(short)88,      (flex_int16_t const   )(short)79,      (flex_int16_t const   )(short)90, 
        (flex_int16_t const   )(short)84,      (flex_int16_t const   )(short)88,      (flex_int16_t const   )(short)83,      (flex_int16_t const   )(short)42, 
        (flex_int16_t const   )(short)75,      (flex_int16_t const   )(short)74,      (flex_int16_t const   )(short)73,      (flex_int16_t const   )(short)42, 
        (flex_int16_t const   )(short)71,      (flex_int16_t const   )(short)69,      (flex_int16_t const   )(short)66,      (flex_int16_t const   )(short)65, 
        (flex_int16_t const   )(short)64,      (flex_int16_t const   )(short)42,      (flex_int16_t const   )(short)88,      (flex_int16_t const   )(short)6, 
        (flex_int16_t const   )(short)6,      (flex_int16_t const   )(short)63,      (flex_int16_t const   )(short)62,      (flex_int16_t const   )(short)61, 
        (flex_int16_t const   )(short)59,      (flex_int16_t const   )(short)56,      (flex_int16_t const   )(short)54,      (flex_int16_t const   )(short)53, 
        (flex_int16_t const   )(short)52,      (flex_int16_t const   )(short)51,      (flex_int16_t const   )(short)50,      (flex_int16_t const   )(short)47, 
        (flex_int16_t const   )(short)46,      (flex_int16_t const   )(short)45,      (flex_int16_t const   )(short)29,      (flex_int16_t const   )(short)43, 
        (flex_int16_t const   )(short)42,      (flex_int16_t const   )(short)41,      (flex_int16_t const   )(short)39,      (flex_int16_t const   )(short)38, 
        (flex_int16_t const   )(short)37,      (flex_int16_t const   )(short)35,      (flex_int16_t const   )(short)29,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)5,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93};
#line 491 "nss_tok.c"
static flex_int16_t const   yy_chk___0[222]  = 
#line 491
  {      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)95,      (flex_int16_t const   )(short)0, 
        (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)91,      (flex_int16_t const   )(short)0, 
        (flex_int16_t const   )(short)2,      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)0, 
        (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)0, 
        (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)0, 
        (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)90,      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)0, 
        (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)0,      (flex_int16_t const   )(short)2, 
        (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)3, 
        (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)3, 
        (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)3, 
        (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)3, 
        (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)3, 
        (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)3, 
        (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)3, 
        (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)3, 
        (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)3, 
        (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)3, 
        (flex_int16_t const   )(short)3,      (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)14,      (flex_int16_t const   )(short)15, 
        (flex_int16_t const   )(short)16,      (flex_int16_t const   )(short)17,      (flex_int16_t const   )(short)19,      (flex_int16_t const   )(short)84, 
        (flex_int16_t const   )(short)31,      (flex_int16_t const   )(short)43,      (flex_int16_t const   )(short)25,      (flex_int16_t const   )(short)36, 
        (flex_int16_t const   )(short)35,      (flex_int16_t const   )(short)45,      (flex_int16_t const   )(short)46,      (flex_int16_t const   )(short)48, 
        (flex_int16_t const   )(short)56,      (flex_int16_t const   )(short)59,      (flex_int16_t const   )(short)7,      (flex_int16_t const   )(short)57, 
        (flex_int16_t const   )(short)14,      (flex_int16_t const   )(short)15,      (flex_int16_t const   )(short)17,      (flex_int16_t const   )(short)16, 
        (flex_int16_t const   )(short)19,      (flex_int16_t const   )(short)25,      (flex_int16_t const   )(short)31,      (flex_int16_t const   )(short)43, 
        (flex_int16_t const   )(short)25,      (flex_int16_t const   )(short)35,      (flex_int16_t const   )(short)36,      (flex_int16_t const   )(short)46, 
        (flex_int16_t const   )(short)45,      (flex_int16_t const   )(short)61,      (flex_int16_t const   )(short)48,      (flex_int16_t const   )(short)56, 
        (flex_int16_t const   )(short)59,      (flex_int16_t const   )(short)57,      (flex_int16_t const   )(short)66,      (flex_int16_t const   )(short)67, 
        (flex_int16_t const   )(short)71,      (flex_int16_t const   )(short)68,      (flex_int16_t const   )(short)69,      (flex_int16_t const   )(short)70, 
        (flex_int16_t const   )(short)72,      (flex_int16_t const   )(short)76,      (flex_int16_t const   )(short)81,      (flex_int16_t const   )(short)77, 
        (flex_int16_t const   )(short)78,      (flex_int16_t const   )(short)80,      (flex_int16_t const   )(short)82,      (flex_int16_t const   )(short)86, 
        (flex_int16_t const   )(short)61,      (flex_int16_t const   )(short)85,      (flex_int16_t const   )(short)87,      (flex_int16_t const   )(short)83, 
        (flex_int16_t const   )(short)66,      (flex_int16_t const   )(short)67,      (flex_int16_t const   )(short)68,      (flex_int16_t const   )(short)71, 
        (flex_int16_t const   )(short)69,      (flex_int16_t const   )(short)70,      (flex_int16_t const   )(short)76,      (flex_int16_t const   )(short)72, 
        (flex_int16_t const   )(short)77,      (flex_int16_t const   )(short)81,      (flex_int16_t const   )(short)78,      (flex_int16_t const   )(short)80, 
        (flex_int16_t const   )(short)89,      (flex_int16_t const   )(short)82,      (flex_int16_t const   )(short)86,      (flex_int16_t const   )(short)85, 
        (flex_int16_t const   )(short)75,      (flex_int16_t const   )(short)87,      (flex_int16_t const   )(short)74,      (flex_int16_t const   )(short)73, 
        (flex_int16_t const   )(short)65,      (flex_int16_t const   )(short)64,      (flex_int16_t const   )(short)63,      (flex_int16_t const   )(short)62, 
        (flex_int16_t const   )(short)60,      (flex_int16_t const   )(short)58,      (flex_int16_t const   )(short)55,      (flex_int16_t const   )(short)54, 
        (flex_int16_t const   )(short)53,      (flex_int16_t const   )(short)52,      (flex_int16_t const   )(short)89,      (flex_int16_t const   )(short)94, 
        (flex_int16_t const   )(short)94,      (flex_int16_t const   )(short)51,      (flex_int16_t const   )(short)50,      (flex_int16_t const   )(short)49, 
        (flex_int16_t const   )(short)47,      (flex_int16_t const   )(short)44,      (flex_int16_t const   )(short)41,      (flex_int16_t const   )(short)40, 
        (flex_int16_t const   )(short)39,      (flex_int16_t const   )(short)38,      (flex_int16_t const   )(short)37,      (flex_int16_t const   )(short)34, 
        (flex_int16_t const   )(short)33,      (flex_int16_t const   )(short)32,      (flex_int16_t const   )(short)29,      (flex_int16_t const   )(short)28, 
        (flex_int16_t const   )(short)27,      (flex_int16_t const   )(short)26,      (flex_int16_t const   )(short)24,      (flex_int16_t const   )(short)23, 
        (flex_int16_t const   )(short)22,      (flex_int16_t const   )(short)18,      (flex_int16_t const   )(short)9,      (flex_int16_t const   )(short)5, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93, 
        (flex_int16_t const   )(short)93,      (flex_int16_t const   )(short)93};
#line 520 "nss_tok.c"
static yy_state_type yy_last_accepting_state  ;
#line 521 "nss_tok.c"
static char *yy_last_accepting_cpos  ;
#line 523
int nss__flex_debug ;
#line 524 "nss_tok.c"
int nss__flex_debug  =    0;
#line 24 "nss_tok.l"
static void nss_echo(void) ;
#line 42
int nss_wrap(void) ;
#line 611 "nss_tok.c"
static int yy_init_globals___0(void) ;
#line 743 "nss_tok.c"
int nss_lex(void) 
{ register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  YY_BUFFER_STATE tmp ;
  register YY_CHAR yy_c ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 754
  if (! yy_init___0) {
#line 756
    yy_init___0 = 1;
#line 762
    if (! yy_start___0) {
#line 763
      yy_start___0 = 1;
    }
#line 765
    if (! nss_in) {
#line 766
      nss_in = stdin;
    }
#line 768
    if (! nss_out) {
#line 769
      nss_out = stdout;
    }
#line 771
    if (yy_buffer_stack___0) {
#line 771
      tmp = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0));
    } else {
#line 771
      tmp = (struct yy_buffer_state *)((void *)0);
    }
#line 771
    if (! tmp) {
#line 772
      nss_ensure_buffer_stack();
#line 773
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0)) = nss__create_buffer(nss_in,
                                                                              16384);
    }
#line 777
    nss__load_buffer_state();
  }
#line 780
  while (1) {
#line 782
    yy_cp = yy_c_buf_p___0;
#line 785
    (*yy_cp) = yy_hold_char___0;
#line 790
    yy_bp = yy_cp;
#line 792
    yy_current_state = yy_start___0;
#line 793
    yy_current_state += ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_at_bol;
    yy_match: 
#line 795
    while (1) {
#line 797
      yy_c = (unsigned char )yy_ec___0[(unsigned int )((unsigned char )(*yy_cp))];
#line 798
      if (yy_accept___0[yy_current_state]) {
#line 800
        yy_last_accepting_state = yy_current_state;
#line 801
        yy_last_accepting_cpos = yy_cp;
      }
#line 803
      while ((int const   )yy_chk___0[(int const   )yy_base___0[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state) {
#line 805
        yy_current_state = (int )yy_def___0[yy_current_state];
#line 806
        if (yy_current_state >= 94) {
#line 807
          yy_c = (unsigned char )yy_meta___0[(unsigned int )yy_c];
        }
      }
#line 809
      yy_current_state = (int )yy_nxt___0[(unsigned int )yy_base___0[yy_current_state] + (unsigned int )yy_c];
#line 810
      yy_cp ++;
#line 795
      if (! ((int const   )yy_base___0[yy_current_state] != 180)) {
#line 795
        break;
      }
    }
    yy_find_action: 
#line 815
    yy_act = (int )yy_accept___0[yy_current_state];
#line 816
    if (yy_act == 0) {
#line 818
      yy_cp = yy_last_accepting_cpos;
#line 819
      yy_current_state = yy_last_accepting_state;
#line 820
      yy_act = (int )yy_accept___0[yy_current_state];
    }
#line 823
    nss_text = yy_bp;
#line 823
    nss_leng = (int )((unsigned int )(yy_cp - yy_bp));
#line 823
    yy_hold_char___0 = (*yy_cp);
#line 823
    (*yy_cp) = (char )'\000';
#line 823
    yy_c_buf_p___0 = yy_cp;
    do_action: 
#line 827
    switch (yy_act) {
    case 0: 
#line 831
    (*yy_cp) = yy_hold_char___0;
#line 832
    yy_cp = yy_last_accepting_cpos;
#line 833
    yy_current_state = yy_last_accepting_state;
    goto yy_find_action;
    case 1: 
#line 837
    if (nss_leng > 0) {
#line 837
      ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_at_bol = (int )(*(nss_text + (nss_leng - 1))) == 10;
    }
#line 88 "nss_tok.l"
    yy_start___0 = 3;
#line 90
    break;
    case 2: 
#line 93
    if (nss_leng > 0) {
#line 93
      ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_at_bol = (int )(*(nss_text + (nss_leng - 1))) == 10;
    }
#line 92
    break;
    case 3: 
#line 95
    if (nss_leng > 0) {
#line 95
      ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_at_bol = (int )(*(nss_text + (nss_leng - 1))) == 10;
    }
#line 95
    break;
    case 4: 
#line 97
    if (nss_leng > 0) {
#line 97
      ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_at_bol = (int )(*(nss_text + (nss_leng - 1))) == 10;
    }
#line 97
    strcpy((char * __restrict  )(nss_lval.strval), (char const   * __restrict  )nss_text);
#line 98
    return (263);
#line 100
    break;
    case 5: 
#line 102
    if (nss_leng > 0) {
#line 102
      ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_at_bol = (int )(*(nss_text + (nss_leng - 1))) == 10;
    }
#line 102
    strcpy((char * __restrict  )(nss_lval.strval), (char const   * __restrict  )nss_text);
#line 103
    return (264);
#line 105
    break;
    case 6: 
#line 107
    if (nss_leng > 0) {
#line 107
      ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_at_bol = (int )(*(nss_text + (nss_leng - 1))) == 10;
    }
#line 107
    strcpy((char * __restrict  )(nss_lval.strval), (char const   * __restrict  )nss_text);
#line 108
    return (265);
#line 110
    break;
    case 7: 
#line 112
    if (nss_leng > 0) {
#line 112
      ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_at_bol = (int )(*(nss_text + (nss_leng - 1))) == 10;
    }
#line 111
    return (258);
#line 112
    break;
    case 8: 
#line 114
    if (nss_leng > 0) {
#line 114
      ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_at_bol = (int )(*(nss_text + (nss_leng - 1))) == 10;
    }
#line 112
    return (259);
#line 113
    break;
    case 9: 
#line 115
    if (nss_leng > 0) {
#line 115
      ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_at_bol = (int )(*(nss_text + (nss_leng - 1))) == 10;
    }
#line 113
    return (260);
#line 114
    break;
    case 10: 
#line 116
    if (nss_leng > 0) {
#line 116
      ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_at_bol = (int )(*(nss_text + (nss_leng - 1))) == 10;
    }
#line 114
    return (261);
#line 115
    break;
    case 11: 
#line 117
    if (nss_leng > 0) {
#line 117
      ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_at_bol = (int )(*(nss_text + (nss_leng - 1))) == 10;
    }
#line 117
    strcpy((char * __restrict  )(nss_lval.strval), (char const   * __restrict  )nss_text);
#line 118
    return (266);
#line 120
    break;
    case 12: 
#line 123
    if (nss_leng > 0) {
#line 123
      ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_at_bol = (int )(*(nss_text + (nss_leng - 1))) == 10;
    }
#line 121
    yy_start___0 = 1;
#line 121
    return (262);
#line 122
    break;
    case 13: 
#line 125
    if (nss_leng > 0) {
#line 125
      ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_at_bol = (int )(*(nss_text + (nss_leng - 1))) == 10;
    }
#line 124
    nss_echo();
#line 125
    break;
    case 15: 
    case 16: 
#line 922 "nss_tok.c"
    return (0);
    case 14: 
#line 927
    yy_amount_of_matched_text = (yy_cp - nss_text) - 1;
#line 930
    (*yy_cp) = yy_hold_char___0;
#line 933
    if (((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_buffer_status == 0) {
#line 944
      yy_n_chars___0 = ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_n_chars;
#line 945
      ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_input_file = nss_in;
#line 946
      ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_buffer_status = 1;
    }
#line 956
    if ((unsigned int )yy_c_buf_p___0 <= (unsigned int )(((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_ch_buf + yy_n_chars___0)) {
#line 960
      yy_c_buf_p___0 = nss_text + yy_amount_of_matched_text;
#line 962
      yy_current_state = yy_get_previous_state___0();
#line 973
      yy_next_state = yy_try_NUL_trans___0(yy_current_state);
#line 975
      yy_bp = nss_text + 0;
#line 977
      if (yy_next_state) {
#line 980
        yy_c_buf_p___0 ++;
#line 980
        yy_cp = yy_c_buf_p___0;
#line 981
        yy_current_state = yy_next_state;
        goto yy_match;
      } else {
#line 987
        yy_cp = yy_c_buf_p___0;
        goto yy_find_action;
      }
    } else {
#line 992
      tmp___0 = yy_get_next_buffer___0();
#line 992
      switch (tmp___0) {
      case 1: 
#line 996
      yy_did_buffer_switch_on_eof___0 = 0;
#line 998
      tmp___1 = nss_wrap();
#line 998
      if (tmp___1) {
#line 1009
        yy_c_buf_p___0 = nss_text + 0;
#line 1011
        yy_act = (14 + (yy_start___0 - 1) / 2) + 1;
        goto do_action;
      } else {
#line 1017
        if (! yy_did_buffer_switch_on_eof___0) {
#line 1018
          nss_restart(nss_in);
        }
      }
#line 1020
      break;
      case 0: 
#line 1024
      yy_c_buf_p___0 = nss_text + yy_amount_of_matched_text;
#line 1027
      yy_current_state = yy_get_previous_state___0();
#line 1029
      yy_cp = yy_c_buf_p___0;
#line 1030
      yy_bp = nss_text + 0;
      goto yy_match;
      case 2: 
#line 1034
      yy_c_buf_p___0 = ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_ch_buf + yy_n_chars___0;
#line 1037
      yy_current_state = yy_get_previous_state___0();
#line 1039
      yy_cp = yy_c_buf_p___0;
#line 1040
      yy_bp = nss_text + 0;
      goto yy_find_action;
      }
    }
#line 1043
    break;
    default: 
#line 1047
    yy_fatal_error___0("fatal flex scanner internal error--no action found");
    }
  }
}
}
#line 1060 "nss_tok.c"
static int yy_get_next_buffer___0(void) 
{ register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int num_to_read ;
  YY_BUFFER_STATE b ;
  YY_BUFFER_STATE tmp___1 ;
  int yy_c_buf_p_offset ;
  int new_size ;
  int c ;
  size_t n ;
  size_t tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;

  {
#line 1062
  dest = ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_ch_buf;
#line 1063
  source = nss_text;
#line 1067
  if ((unsigned int )yy_c_buf_p___0 > (unsigned int )(((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_ch_buf + (yy_n_chars___0 + 1))) {
#line 1068
    yy_fatal_error___0("fatal flex scanner internal error--end of buffer missed");
  }
#line 1071
  if (((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_fill_buffer == 0) {
#line 1073
    if ((yy_c_buf_p___0 - nss_text) - 0 == 1) {
#line 1078
      return (1);
    } else {
#line 1086
      return (2);
    }
  }
#line 1093
  number_to_move = (yy_c_buf_p___0 - nss_text) - 1;
#line 1095
  i = 0;
#line 1095
  while (i < number_to_move) {
#line 1096
    tmp = dest;
#line 1096
    dest ++;
#line 1096
    tmp___0 = source;
#line 1096
    source ++;
#line 1096
    (*tmp) = (*tmp___0);
#line 1095
    i ++;
  }
#line 1098
  if (((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_buffer_status == 2) {
#line 1102
    yy_n_chars___0 = 0;
#line 1102
    ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_n_chars = yy_n_chars___0;
  } else {
#line 1106
    num_to_read = (int )((((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_buf_size - (unsigned int )number_to_move) - 1U);
#line 1109
    while (num_to_read <= 0) {
#line 1113
      if (yy_buffer_stack___0) {
#line 1113
        tmp___1 = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0));
      } else {
#line 1113
        tmp___1 = (struct yy_buffer_state *)((void *)0);
      }
#line 1113
      b = tmp___1;
#line 1115
      yy_c_buf_p_offset = yy_c_buf_p___0 - b->yy_ch_buf;
#line 1118
      if (b->yy_is_our_buffer) {
#line 1120
        new_size = (int )(b->yy_buf_size * 2U);
#line 1122
        if (new_size <= 0) {
#line 1123
          b->yy_buf_size += b->yy_buf_size / 8U;
        } else {
#line 1125
          b->yy_buf_size *= 2U;
        }
#line 1127
        b->yy_ch_buf = (char *)nss_realloc((void *)b->yy_ch_buf, b->yy_buf_size + 2U);
      } else {
#line 1133
        b->yy_ch_buf = (char *)0;
      }
#line 1135
      if (! b->yy_ch_buf) {
#line 1136
        yy_fatal_error___0("fatal error - scanner input buffer overflow");
      }
#line 1139
      yy_c_buf_p___0 = b->yy_ch_buf + yy_c_buf_p_offset;
#line 1141
      num_to_read = (int )((((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_buf_size - (unsigned int )number_to_move) - 1U);
    }
#line 1146
    if (num_to_read > 8192) {
#line 1147
      num_to_read = 8192;
    }
#line 1150
    if (((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_is_interactive) {
#line 1150
      c = '*';
#line 1150
      n = 0U;
#line 1150
      while (1) {
#line 1150
        if (n < (unsigned int )num_to_read) {
#line 1150
          c = _IO_getc(nss_in);
#line 1150
          if (c != -1) {
#line 1150
            if (! (c != 10)) {
#line 1150
              break;
            }
          } else {
#line 1150
            break;
          }
        } else {
#line 1150
          break;
        }
#line 1150
        (*((((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_ch_buf + number_to_move) + n)) = (char )c;
#line 1150
        n ++;
      }
#line 1150
      if (c == 10) {
#line 1150
        tmp___3 = n;
#line 1150
        n ++;
#line 1150
        (*((((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_ch_buf + number_to_move) + tmp___3)) = (char )c;
      }
#line 1150
      if (c == -1) {
#line 1150
        tmp___4 = ferror(nss_in);
#line 1150
        if (tmp___4) {
#line 1150
          yy_fatal_error___0("input in flex scanner failed");
        }
      }
#line 1150
      yy_n_chars___0 = (int )n;
    } else {
#line 1150
      tmp___5 = __errno_location();
#line 1150
      (*tmp___5) = 0;
#line 1150
      while (1) {
#line 1150
        yy_n_chars___0 = (int )fread((void * __restrict  )(((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_ch_buf + number_to_move),
                                     1U, (unsigned int )num_to_read, (FILE * __restrict  )nss_in);
#line 1150
        if (yy_n_chars___0 == 0) {
#line 1150
          tmp___8 = ferror(nss_in);
#line 1150
          if (! tmp___8) {
#line 1150
            break;
          }
        } else {
#line 1150
          break;
        }
#line 1150
        tmp___6 = __errno_location();
#line 1150
        if ((*tmp___6) != 4) {
#line 1150
          yy_fatal_error___0("input in flex scanner failed");
#line 1150
          break;
        }
#line 1150
        tmp___7 = __errno_location();
#line 1150
        (*tmp___7) = 0;
#line 1150
        clearerr(nss_in);
      }
    }
#line 1153
    ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_n_chars = yy_n_chars___0;
  }
#line 1156
  if (yy_n_chars___0 == 0) {
#line 1158
    if (number_to_move == 0) {
#line 1160
      ret_val = 1;
#line 1161
      nss_restart(nss_in);
    } else {
#line 1166
      ret_val = 2;
#line 1167
      ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_buffer_status = 2;
    }
  } else {
#line 1173
    ret_val = 0;
  }
#line 1175
  yy_n_chars___0 += number_to_move;
#line 1176
  (*(((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_ch_buf + yy_n_chars___0)) = (char)0;
#line 1177
  (*(((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_ch_buf + (yy_n_chars___0 + 1))) = (char)0;
#line 1179
  nss_text = ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_ch_buf + 0;
#line 1181
  return (ret_val);
}
}
#line 1186 "nss_tok.c"
static yy_state_type yy_get_previous_state___0(void) 
{ register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  flex_int32_t tmp ;

  {
#line 1191
  yy_current_state = yy_start___0;
#line 1192
  yy_current_state += ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_at_bol;
#line 1194
  yy_cp = nss_text + 0;
#line 1194
  while ((unsigned int )yy_cp < (unsigned int )yy_c_buf_p___0) {
#line 1196
    if ((*yy_cp)) {
#line 1196
      tmp = yy_ec___0[(unsigned int )((unsigned char )(*yy_cp))];
    } else {
#line 1196
      tmp = 1;
    }
#line 1196
    yy_c = (unsigned char )tmp;
#line 1197
    if (yy_accept___0[yy_current_state]) {
#line 1199
      yy_last_accepting_state = yy_current_state;
#line 1200
      yy_last_accepting_cpos = yy_cp;
    }
#line 1202
    while ((int const   )yy_chk___0[(int const   )yy_base___0[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state) {
#line 1204
      yy_current_state = (int )yy_def___0[yy_current_state];
#line 1205
      if (yy_current_state >= 94) {
#line 1206
        yy_c = (unsigned char )yy_meta___0[(unsigned int )yy_c];
      }
    }
#line 1208
    yy_current_state = (int )yy_nxt___0[(unsigned int )yy_base___0[yy_current_state] + (unsigned int )yy_c];
#line 1194
    yy_cp ++;
  }
#line 1211
  return (yy_current_state);
}
}
#line 1219 "nss_tok.c"
static yy_state_type yy_try_NUL_trans___0(yy_state_type yy_current_state ) 
{ register int yy_is_jam ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  int tmp ;

  {
#line 1222
  yy_cp = yy_c_buf_p___0;
#line 1224
  yy_c = (unsigned char)1;
#line 1225
  if (yy_accept___0[yy_current_state]) {
#line 1227
    yy_last_accepting_state = yy_current_state;
#line 1228
    yy_last_accepting_cpos = yy_cp;
  }
#line 1230
  while ((int const   )yy_chk___0[(int const   )yy_base___0[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state) {
#line 1232
    yy_current_state = (int )yy_def___0[yy_current_state];
#line 1233
    if (yy_current_state >= 94) {
#line 1234
      yy_c = (unsigned char )yy_meta___0[(unsigned int )yy_c];
    }
  }
#line 1236
  yy_current_state = (int )yy_nxt___0[(unsigned int )yy_base___0[yy_current_state] + (unsigned int )yy_c];
#line 1237
  yy_is_jam = yy_current_state == 93;
#line 1239
  if (yy_is_jam) {
#line 1239
    tmp = 0;
  } else {
#line 1239
    tmp = yy_current_state;
  }
#line 1239
  return (tmp);
}
}
#line 1323 "nss_tok.c"
void nss_restart(FILE *input_file ) 
{ YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1326
  if (yy_buffer_stack___0) {
#line 1326
    tmp = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0));
  } else {
#line 1326
    tmp = (struct yy_buffer_state *)((void *)0);
  }
#line 1326
  if (! tmp) {
#line 1327
    nss_ensure_buffer_stack();
#line 1328
    (*(yy_buffer_stack___0 + yy_buffer_stack_top___0)) = nss__create_buffer(nss_in,
                                                                            16384);
  }
#line 1332
  if (yy_buffer_stack___0) {
#line 1332
    tmp___0 = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0));
  } else {
#line 1332
    tmp___0 = (struct yy_buffer_state *)((void *)0);
  }
#line 1332
  nss__init_buffer(tmp___0, input_file);
#line 1333
  nss__load_buffer_state();
#line 1334
  return;
}
}
#line 1340 "nss_tok.c"
void nss__switch_to_buffer(YY_BUFFER_STATE new_buffer ) 
{ YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1348
  nss_ensure_buffer_stack();
#line 1349
  if (yy_buffer_stack___0) {
#line 1349
    tmp = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0));
  } else {
#line 1349
    tmp = (struct yy_buffer_state *)((void *)0);
  }
#line 1349
  if ((unsigned int )tmp == (unsigned int )new_buffer) {
#line 1350
    return;
  }
#line 1352
  if (yy_buffer_stack___0) {
#line 1352
    tmp___0 = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0));
  } else {
#line 1352
    tmp___0 = (struct yy_buffer_state *)((void *)0);
  }
#line 1352
  if (tmp___0) {
#line 1355
    (*yy_c_buf_p___0) = yy_hold_char___0;
#line 1356
    ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_buf_pos = yy_c_buf_p___0;
#line 1357
    ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_n_chars = yy_n_chars___0;
  }
#line 1360
  (*(yy_buffer_stack___0 + yy_buffer_stack_top___0)) = new_buffer;
#line 1361
  nss__load_buffer_state();
#line 1368
  yy_did_buffer_switch_on_eof___0 = 1;
#line 1369
  return;
}
}
#line 1371 "nss_tok.c"
static void nss__load_buffer_state(void) 
{ 

  {
#line 1373
  yy_n_chars___0 = ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_n_chars;
#line 1374
  yy_c_buf_p___0 = ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_buf_pos;
#line 1374
  nss_text = yy_c_buf_p___0;
#line 1375
  nss_in = ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_input_file;
#line 1376
  yy_hold_char___0 = (*yy_c_buf_p___0);
#line 1377
  return;
}
}
#line 1385 "nss_tok.c"
YY_BUFFER_STATE nss__create_buffer(FILE *file , int size ) 
{ YY_BUFFER_STATE b ;

  {
#line 1389
  b = (YY_BUFFER_STATE )nss_alloc(sizeof(struct yy_buffer_state ));
#line 1390
  if (! b) {
#line 1391
    yy_fatal_error___0("out of dynamic memory in nss__create_buffer()");
  }
#line 1393
  b->yy_buf_size = (unsigned int )size;
#line 1398
  b->yy_ch_buf = (char *)nss_alloc(b->yy_buf_size + 2U);
#line 1399
  if (! b->yy_ch_buf) {
#line 1400
    yy_fatal_error___0("out of dynamic memory in nss__create_buffer()");
  }
#line 1402
  b->yy_is_our_buffer = 1;
#line 1404
  nss__init_buffer(b, file);
#line 1406
  return (b);
}
}
#line 1413 "nss_tok.c"
void nss__delete_buffer(YY_BUFFER_STATE b ) 
{ YY_BUFFER_STATE tmp ;

  {
#line 1416
  if (! b) {
#line 1417
    return;
  }
#line 1419
  if (yy_buffer_stack___0) {
#line 1419
    tmp = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0));
  } else {
#line 1419
    tmp = (struct yy_buffer_state *)((void *)0);
  }
#line 1419
  if ((unsigned int )b == (unsigned int )tmp) {
#line 1420
    (*(yy_buffer_stack___0 + yy_buffer_stack_top___0)) = (struct yy_buffer_state *)0;
  }
#line 1422
  if (b->yy_is_our_buffer) {
#line 1423
    nss_free((void *)b->yy_ch_buf);
  }
#line 1425
  nss_free((void *)b);
#line 1426
  return;
}
}
#line 1436 "nss_tok.c"
static void nss__init_buffer(YY_BUFFER_STATE b , FILE *file ) 
{ int oerrno ;
  int *tmp ;
  YY_BUFFER_STATE tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;

  {
#line 1439
  tmp = __errno_location();
#line 1439
  oerrno = (*tmp);
#line 1441
  nss__flush_buffer(b);
#line 1443
  b->yy_input_file = file;
#line 1444
  b->yy_fill_buffer = 1;
#line 1450
  if (yy_buffer_stack___0) {
#line 1450
    tmp___0 = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0));
  } else {
#line 1450
    tmp___0 = (struct yy_buffer_state *)((void *)0);
  }
#line 1450
  if ((unsigned int )b != (unsigned int )tmp___0) {
#line 1451
    b->yy_bs_lineno = 1;
#line 1452
    b->yy_bs_column = 0;
  }
#line 1455
  if (file) {
#line 1455
    tmp___3 = fileno(file);
#line 1455
    tmp___4 = isatty(tmp___3);
#line 1455
    b->yy_is_interactive = tmp___4 > 0;
  } else {
#line 1455
    b->yy_is_interactive = 0;
  }
#line 1457
  tmp___5 = __errno_location();
#line 1457
  (*tmp___5) = oerrno;
#line 1458
  return;
}
}
#line 1464 "nss_tok.c"
void nss__flush_buffer(YY_BUFFER_STATE b ) 
{ YY_BUFFER_STATE tmp ;

  {
#line 1466
  if (! b) {
#line 1467
    return;
  }
#line 1469
  b->yy_n_chars = 0;
#line 1475
  (*(b->yy_ch_buf + 0)) = (char)0;
#line 1476
  (*(b->yy_ch_buf + 1)) = (char)0;
#line 1478
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 1480
  b->yy_at_bol = 1;
#line 1481
  b->yy_buffer_status = 0;
#line 1483
  if (yy_buffer_stack___0) {
#line 1483
    tmp = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0));
  } else {
#line 1483
    tmp = (struct yy_buffer_state *)((void *)0);
  }
#line 1483
  if ((unsigned int )b == (unsigned int )tmp) {
#line 1484
    nss__load_buffer_state();
  }
#line 1485
  return;
}
}
#line 1493 "nss_tok.c"
void nss_push_buffer_state(YY_BUFFER_STATE new_buffer ) 
{ YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1495
  if ((unsigned int )new_buffer == (unsigned int )((void *)0)) {
#line 1496
    return;
  }
#line 1498
  nss_ensure_buffer_stack();
#line 1501
  if (yy_buffer_stack___0) {
#line 1501
    tmp = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0));
  } else {
#line 1501
    tmp = (struct yy_buffer_state *)((void *)0);
  }
#line 1501
  if (tmp) {
#line 1504
    (*yy_c_buf_p___0) = yy_hold_char___0;
#line 1505
    ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_buf_pos = yy_c_buf_p___0;
#line 1506
    ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0)))->yy_n_chars = yy_n_chars___0;
  }
#line 1510
  if (yy_buffer_stack___0) {
#line 1510
    tmp___0 = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0));
  } else {
#line 1510
    tmp___0 = (struct yy_buffer_state *)((void *)0);
  }
#line 1510
  if (tmp___0) {
#line 1511
    yy_buffer_stack_top___0 ++;
  }
#line 1512
  (*(yy_buffer_stack___0 + yy_buffer_stack_top___0)) = new_buffer;
#line 1515
  nss__load_buffer_state();
#line 1516
  yy_did_buffer_switch_on_eof___0 = 1;
#line 1517
  return;
}
}
#line 1523 "nss_tok.c"
void nss_pop_buffer_state(void) 
{ YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 1525
  if (yy_buffer_stack___0) {
#line 1525
    tmp = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0));
  } else {
#line 1525
    tmp = (struct yy_buffer_state *)((void *)0);
  }
#line 1525
  if (! tmp) {
#line 1526
    return;
  }
#line 1528
  if (yy_buffer_stack___0) {
#line 1528
    tmp___0 = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0));
  } else {
#line 1528
    tmp___0 = (struct yy_buffer_state *)((void *)0);
  }
#line 1528
  nss__delete_buffer(tmp___0);
#line 1529
  (*(yy_buffer_stack___0 + yy_buffer_stack_top___0)) = (struct yy_buffer_state *)((void *)0);
#line 1530
  if (yy_buffer_stack_top___0 > 0U) {
#line 1531
    yy_buffer_stack_top___0 --;
  }
#line 1533
  if (yy_buffer_stack___0) {
#line 1533
    tmp___1 = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0));
  } else {
#line 1533
    tmp___1 = (struct yy_buffer_state *)((void *)0);
  }
#line 1533
  if (tmp___1) {
#line 1534
    nss__load_buffer_state();
#line 1535
    yy_did_buffer_switch_on_eof___0 = 1;
  }
#line 1537
  return;
}
}
#line 1542 "nss_tok.c"
static void nss_ensure_buffer_stack(void) 
{ int num_to_alloc ;
  int grow_size ;

  {
#line 1546
  if (! yy_buffer_stack___0) {
#line 1552
    num_to_alloc = 1;
#line 1553
    yy_buffer_stack___0 = (YY_BUFFER_STATE *)nss_alloc((unsigned int )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 1557
    memset((void *)yy_buffer_stack___0, 0, (unsigned int )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 1559
    yy_buffer_stack_max___0 = (unsigned int )num_to_alloc;
#line 1560
    yy_buffer_stack_top___0 = 0U;
#line 1561
    return;
  }
#line 1564
  if (yy_buffer_stack_top___0 >= yy_buffer_stack_max___0 - 1U) {
#line 1567
    grow_size = 8;
#line 1569
    num_to_alloc = (int )(yy_buffer_stack_max___0 + (unsigned int )grow_size);
#line 1570
    yy_buffer_stack___0 = (YY_BUFFER_STATE *)nss_realloc((void *)yy_buffer_stack___0,
                                                         (unsigned int )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 1576
    memset((void *)(yy_buffer_stack___0 + yy_buffer_stack_max___0), 0, (unsigned int )grow_size * sizeof(struct yy_buffer_state *));
#line 1577
    yy_buffer_stack_max___0 = (unsigned int )num_to_alloc;
  }
#line 1579
  return;
}
}
#line 1587 "nss_tok.c"
YY_BUFFER_STATE nss__scan_buffer(char *base , yy_size_t size ) 
{ YY_BUFFER_STATE b ;

  {
#line 1591
  if (size < 2U) {
#line 1595
    return ((struct yy_buffer_state *)0);
  } else {
#line 1591
    if ((int )(*(base + (size - 2U))) != 0) {
#line 1595
      return ((struct yy_buffer_state *)0);
    } else {
#line 1591
      if ((int )(*(base + (size - 1U))) != 0) {
#line 1595
        return ((struct yy_buffer_state *)0);
      }
    }
  }
#line 1597
  b = (YY_BUFFER_STATE )nss_alloc(sizeof(struct yy_buffer_state ));
#line 1598
  if (! b) {
#line 1599
    yy_fatal_error___0("out of dynamic memory in nss__scan_buffer()");
  }
#line 1601
  b->yy_buf_size = size - 2U;
#line 1602
  b->yy_ch_buf = base;
#line 1602
  b->yy_buf_pos = b->yy_ch_buf;
#line 1603
  b->yy_is_our_buffer = 0;
#line 1604
  b->yy_input_file = (FILE *)0;
#line 1605
  b->yy_n_chars = (int )b->yy_buf_size;
#line 1606
  b->yy_is_interactive = 0;
#line 1607
  b->yy_at_bol = 1;
#line 1608
  b->yy_fill_buffer = 0;
#line 1609
  b->yy_buffer_status = 0;
#line 1611
  nss__switch_to_buffer(b);
#line 1613
  return (b);
}
}
#line 1624 "nss_tok.c"
YY_BUFFER_STATE nss__scan_string(char const   *yystr ) 
{ size_t tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1627
  tmp = strlen(yystr);
#line 1627
  tmp___0 = nss__scan_bytes(yystr, (int )tmp);
#line 1627
  return (tmp___0);
}
}
#line 1637 "nss_tok.c"
YY_BUFFER_STATE nss__scan_bytes(char const   *yybytes , int _yybytes_len ) 
{ YY_BUFFER_STATE b ;
  char *buf ;
  yy_size_t n ;
  int i ;

  {
#line 1645
  n = (unsigned int )(_yybytes_len + 2);
#line 1646
  buf = (char *)nss_alloc(n);
#line 1647
  if (! buf) {
#line 1648
    yy_fatal_error___0("out of dynamic memory in nss__scan_bytes()");
  }
#line 1650
  i = 0;
#line 1650
  while (i < _yybytes_len) {
#line 1651
    (*(buf + i)) = (char )(*(yybytes + i));
#line 1650
    i ++;
  }
#line 1653
  (*(buf + (_yybytes_len + 1))) = (char)0;
#line 1653
  (*(buf + _yybytes_len)) = (*(buf + (_yybytes_len + 1)));
#line 1655
  b = nss__scan_buffer(buf, n);
#line 1656
  if (! b) {
#line 1657
    yy_fatal_error___0("bad buffer in nss__scan_bytes()");
  }
#line 1662
  b->yy_is_our_buffer = 1;
#line 1664
  return (b);
}
}
#line 1671 "nss_tok.c"
static void yy_fatal_error___0(char const   *msg ) 
{ 

  {
#line 1673
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s\n", msg);
#line 1674
  exit(2);
}
}
#line 1699 "nss_tok.c"
int nss_get_lineno(void) 
{ 

  {
#line 1702
  return (nss_lineno);
}
}
#line 1708 "nss_tok.c"
FILE *nss_get_in(void) 
{ 

  {
#line 1710
  return (nss_in);
}
}
#line 1716 "nss_tok.c"
FILE *nss_get_out(void) 
{ 

  {
#line 1718
  return (nss_out);
}
}
#line 1724 "nss_tok.c"
int nss_get_leng(void) 
{ 

  {
#line 1726
  return (nss_leng);
}
}
#line 1733 "nss_tok.c"
char *nss_get_text(void) 
{ 

  {
#line 1735
  return (nss_text);
}
}
#line 1742 "nss_tok.c"
void nss_set_lineno(int line_number ) 
{ 

  {
#line 1745
  nss_lineno = line_number;
#line 1746
  return;
}
}
#line 1754 "nss_tok.c"
void nss_set_in(FILE *in_str ) 
{ 

  {
#line 1756
  nss_in = in_str;
#line 1757
  return;
}
}
#line 1759 "nss_tok.c"
void nss_set_out(FILE *out_str ) 
{ 

  {
#line 1761
  nss_out = out_str;
#line 1762
  return;
}
}
#line 1764 "nss_tok.c"
int nss_get_debug(void) 
{ 

  {
#line 1766
  return (nss__flex_debug);
}
}
#line 1769 "nss_tok.c"
void nss_set_debug(int bdebug ) 
{ 

  {
#line 1771
  nss__flex_debug = bdebug;
#line 1772
  return;
}
}
#line 1774 "nss_tok.c"
static int yy_init_globals___0(void) 
{ 

  {
#line 1780
  yy_buffer_stack___0 = (YY_BUFFER_STATE *)0;
#line 1781
  yy_buffer_stack_top___0 = 0U;
#line 1782
  yy_buffer_stack_max___0 = 0U;
#line 1783
  yy_c_buf_p___0 = (char *)0;
#line 1784
  yy_init___0 = 0;
#line 1785
  yy_start___0 = 0;
#line 1792
  nss_in = (FILE *)0;
#line 1793
  nss_out = (FILE *)0;
#line 1799
  return (0);
}
}
#line 1803 "nss_tok.c"
int nss_lex_destroy(void) 
{ YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1807
  while (1) {
#line 1807
    if (yy_buffer_stack___0) {
#line 1807
      tmp___0 = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0));
    } else {
#line 1807
      tmp___0 = (struct yy_buffer_state *)((void *)0);
    }
#line 1807
    if (! tmp___0) {
#line 1807
      break;
    }
#line 1808
    if (yy_buffer_stack___0) {
#line 1808
      tmp = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0));
    } else {
#line 1808
      tmp = (struct yy_buffer_state *)((void *)0);
    }
#line 1808
    nss__delete_buffer(tmp);
#line 1809
    (*(yy_buffer_stack___0 + yy_buffer_stack_top___0)) = (struct yy_buffer_state *)((void *)0);
#line 1810
    nss_pop_buffer_state();
  }
#line 1814
  nss_free((void *)yy_buffer_stack___0);
#line 1815
  yy_buffer_stack___0 = (YY_BUFFER_STATE *)((void *)0);
#line 1819
  yy_init_globals___0();
#line 1821
  return (0);
}
}
#line 1848 "nss_tok.c"
void *nss_alloc(yy_size_t size ) 
{ void *tmp ;

  {
#line 1850
  tmp = malloc(size);
#line 1850
  return (tmp);
}
}
#line 1853 "nss_tok.c"
void *nss_realloc(void *ptr , yy_size_t size ) 
{ void *tmp ;

  {
#line 1862
  tmp = realloc((void *)((char *)ptr), size);
#line 1862
  return (tmp);
}
}
#line 1865 "nss_tok.c"
void nss_free(void *ptr ) 
{ 

  {
#line 1867
  free((void *)((char *)ptr));
#line 1868
  return;
}
}
#line 129 "nss_tok.l"
int nss_wrap(void) 
{ 

  {
#line 131
  return (1);
}
}
#line 134 "nss_tok.l"
static void nss_echo(void) 
{ 

  {
#line 136
  while (1) {
#line 136
    ((*log_info))(0U, "%s", nss_text);
#line 136
    break;
  }
#line 137
  return;
}
}
#line 1 "nsswitch.o"
#pragma merger(0,"/tmp/cil-MKK6P0oB.i","-O2,-Wall,-fPIC")
#line 29 "nsswitch.c"
int set_action(struct nss_action *act___0 , char *status , char *action , int negated ) 
{ enum nsswitch_action a ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 33
  tmp___0 = strcasecmp((char const   *)action, "continue");
#line 33
  if (tmp___0) {
#line 35
    tmp = strcasecmp((char const   *)action, "return");
#line 35
    if (tmp) {
#line 38
      return (0);
    } else {
#line 36
      a = (enum nsswitch_action )2;
    }
  } else {
#line 34
    a = (enum nsswitch_action )1;
  }
#line 40
  tmp___4 = strcasecmp((char const   *)status, "SUCCESS");
#line 40
  if (tmp___4) {
#line 43
    tmp___3 = strcasecmp((char const   *)status, "NOTFOUND");
#line 43
    if (tmp___3) {
#line 46
      tmp___2 = strcasecmp((char const   *)status, "UNAVAIL");
#line 46
      if (tmp___2) {
#line 49
        tmp___1 = strcasecmp((char const   *)status, "TRYAGAIN");
#line 49
        if (tmp___1) {
#line 53
          return (0);
        } else {
#line 50
          (act___0 + 3)->action = a;
#line 51
          (act___0 + 3)->negated = negated;
        }
      } else {
#line 47
        (act___0 + 2)->action = a;
#line 48
        (act___0 + 2)->negated = negated;
      }
    } else {
#line 44
      (act___0 + 1)->action = a;
#line 45
      (act___0 + 1)->negated = negated;
    }
  } else {
#line 41
    (act___0 + 0)->action = a;
#line 42
    (act___0 + 0)->negated = negated;
  }
#line 55
  return (1);
}
}
#line 58 "nsswitch.c"
struct nss_source *add_source(struct list_head *head , char *source ) 
{ struct nss_source *s ;
  char *tmp ;
  enum nsswitch_status status ;
  char *tmp___9 ;

  {
#line 64
  s = (struct nss_source *)malloc(sizeof(struct nss_source ));
#line 65
  if (! s) {
#line 66
    return ((struct nss_source *)((void *)0));
  }
#line 68
  memset((void *)s, 0, sizeof(struct nss_source ));
#line 69
  while (1) {
#line 69
    s->list.next = & s->list;
#line 69
    s->list.prev = & s->list;
#line 69
    break;
  }
#line 71
  tmp___9 = __strdup((char const   *)source);
#line 71
  tmp = tmp___9;
#line 72
  if (! tmp) {
#line 73
    free((void *)s);
#line 74
    return ((struct nss_source *)((void *)0));
  }
#line 76
  s->source = tmp;
#line 78
  status = (enum nsswitch_status )0;
#line 78
  while ((int )status < 4) {
#line 79
    s->action[status].action = (enum nsswitch_action )0;
#line 78
    status = (enum nsswitch_status )((int )status + 1);
  }
#line 81
  list_add_tail(& s->list, head);
#line 83
  return (s);
}
}
#line 86 "nsswitch.c"
int free_sources(struct list_head *list ) 
{ struct nss_source *this ;
  struct list_head *head ;
  struct list_head *next ;
  int tmp ;

  {
#line 91
  tmp = list_empty(list);
#line 91
  if (tmp) {
#line 92
    return (0);
  }
#line 94
  head = list;
#line 95
  next = list->next;
#line 96
  while ((unsigned int )next != (unsigned int )head) {
#line 97
    this = (struct nss_source *)((char *)next - (unsigned long )(& ((struct nss_source *)0)->list));
#line 98
    next = next->next;
#line 100
    list_del(& this->list);
#line 101
    if (this->source) {
#line 102
      free((void *)this->source);
    }
#line 103
    free((void *)this);
  }
#line 105
  return (1);
}
}
#line 1 "parse_subs.o"
#pragma merger(0,"/tmp/cil-JfJlyyLC.i","-O2,-Wall,-fPIC")
#line 450 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat__extinline(char const   *__path ,
                                                                  struct stat *__statbuf ) ;
#line 457
__inline static  __attribute__((__nothrow__)) int lstat__extinline(char const   *__path ,
                                                                   struct stat *__statbuf ) ;
#line 23 "../include/parse_subs.h"
char const   *skipspace(char const   *whence ) ;
#line 24
int check_colon(char const   *str ) ;
#line 25
int chunklen(char const   *whence , int expect_colon ) ;
#line 26
int strmcmp(char const   *str , char const   *pat , int mchr ) ;
#line 27
char *dequote(char const   *str , int origlen , unsigned int logopt ) ;
#line 28
int span_space(char const   *str , unsigned int maxlen ) ;
#line 29
char *sanitize_path(char const   *path___1 , int origlen , unsigned int type___1 ,
                    unsigned int logopt ) ;
#line 31
int mount_multi_triggers(struct autofs_point *ap , char *root , struct mapent *me ,
                         char const   *base ) ;
#line 31 "parse_subs.c"
char const   *skipspace(char const   *whence ) 
{ 

  {
#line 33
  while (1) {
#line 34
    switch ((int )(*whence)) {
    case 32: 
    case 8: 
    case 9: 
    case 10: 
    case 11: 
    case 12: 
    case 13: 
#line 42
    whence ++;
#line 43
    break;
    case 35: 
#line 45
    while ((int const   )(*whence) != 0) {
#line 46
      whence ++;
    }
    default: ;
#line 50
    return (whence);
    }
  }
}
}
#line 58 "parse_subs.c"
int check_colon(char const   *str ) 
{ char *ptr ;

  {
#line 60
  ptr = (char *)str;
#line 63
  if ((int )(*ptr) == 58) {
#line 64
    return (1);
  }
#line 66
  while (1) {
#line 66
    if ((*ptr)) {
#line 66
      if ((int )(*ptr) != 58) {
#line 66
        if (! ((int )(*ptr) != 47)) {
#line 66
          break;
        }
      } else {
#line 66
        break;
      }
    } else {
#line 66
      break;
    }
#line 67
    ptr ++;
  }
#line 70
  if (! (*ptr)) {
#line 71
    return (0);
  } else {
#line 70
    if ((int )(*ptr) == 47) {
#line 71
      return (0);
    }
  }
#line 73
  return (1);
}
}
#line 77 "parse_subs.c"
int chunklen(char const   *whence , int expect_colon ) 
{ char *str ;
  int n ;
  int quote ;

  {
#line 79
  str = (char *)whence;
#line 80
  n = 0;
#line 81
  quote = 0;
#line 83
  while ((*str)) {
#line 84
    switch ((int )(*str)) {
    case 92: 
#line 86
    if (quote) {
#line 87
      break;
    } else {
#line 89
      quote = 1;
      goto __Cont;
    }
    case 34: 
#line 93
    if (quote) {
#line 94
      break;
    }
#line 95
    while ((*str)) {
#line 96
      str ++;
#line 97
      n ++;
#line 98
      if ((int )(*str) == 34) {
#line 99
        break;
      }
#line 100
      if ((int )(*str) == 58) {
#line 101
        expect_colon = 0;
      }
    }
#line 103
    break;
    case 58: 
#line 105
    if (expect_colon) {
#line 106
      expect_colon = 0;
    }
    goto __Cont;
    case 32: 
    case 9: 
#line 111
    if (expect_colon) {
      goto __Cont;
    }
    case 8: 
    case 10: 
    case 11: 
    case 12: 
    case 13: 
    case 0: 
#line 119
    if (! quote) {
#line 120
      return (n);
    }
    default: ;
#line 123
    break;
    }
#line 125
    quote = 0;
    __Cont: 
#line 83
    str ++;
#line 83
    n ++;
  }
#line 128
  return (n);
}
}
#line 135 "parse_subs.c"
int strmcmp(char const   *str , char const   *pat , int mchr ) 
{ int nchr ;

  {
#line 137
  nchr = 0;
#line 139
  while ((int const   )(*str) == (int const   )(*pat)) {
#line 140
    if (! (*str)) {
#line 141
      return (0);
    }
#line 142
    str ++;
#line 143
    pat ++;
#line 144
    nchr ++;
  }
#line 147
  if (! (*str)) {
#line 147
    if (nchr > mchr) {
#line 148
      return (0);
    }
  }
#line 150
  return ((int )((int const   )(*pat) - (int const   )(*str)));
}
}
#line 153 "parse_subs.c"
char *dequote(char const   *str , int origlen , unsigned int logopt ) 
{ char *ret ;
  char *tmp ;
  char *cp ;
  char const   *scp ;
  int len ;
  int quote ;
  int dquote ;
  int i ;
  int j ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;

  {
#line 155
  tmp = (char *)malloc((unsigned int )(origlen + 1));
#line 155
  ret = tmp;
#line 156
  cp = ret;
#line 158
  len = origlen;
#line 159
  quote = 0;
#line 159
  dquote = 0;
#line 162
  if ((unsigned int )ret == (unsigned int )((void *)0)) {
#line 163
    return ((char *)((void *)0));
  }
#line 166
  i = len - 1;
#line 167
  while (1) {
#line 167
    tmp___0 = __ctype_b_loc();
#line 167
    if (! ((int const   )(*((*tmp___0) + (int )(*(str + i)))) & 8192)) {
#line 167
      break;
    }
#line 169
    j = i - 1;
#line 170
    if (j > 0) {
#line 170
      if ((int const   )(*(str + j)) == 92) {
#line 171
        break;
      } else {
#line 170
        if ((int const   )(*(str + j)) == 34) {
#line 171
          break;
        }
      }
    }
#line 172
    i --;
#line 173
    len --;
  }
#line 176
  scp = str;
#line 176
  while (1) {
#line 176
    if (len > 0) {
#line 176
      if (! (*scp)) {
#line 176
        break;
      }
    } else {
#line 176
      break;
    }
#line 177
    if (! quote) {
#line 178
      if ((int const   )(*scp) == 34) {
#line 179
        if (dquote) {
#line 180
          dquote = 0;
        } else {
#line 182
          dquote = 1;
        }
        goto __Cont;
      }
#line 186
      if (! dquote) {
#line 187
        if ((int const   )(*scp) == 92) {
#line 188
          quote = 1;
          goto __Cont;
        }
      }
    }
#line 193
    quote = 0;
#line 194
    tmp___1 = cp;
#line 194
    cp ++;
#line 194
    (*tmp___1) = (char )(*scp);
    __Cont: 
#line 176
    scp ++;
#line 176
    len --;
  }
#line 196
  (*cp) = (char )'\000';
#line 198
  if (dquote) {
#line 199
    while (1) {
#line 199
      ((*log_debug))(logopt, "%s: unmatched quote in %.*s", "dequote", origlen, str);
#line 199
      break;
    }
#line 200
    free((void *)ret);
#line 201
    return ((char *)((void *)0));
  }
#line 204
  return (ret);
}
}
#line 207 "parse_subs.c"
int span_space(char const   *str , unsigned int maxlen ) 
{ char const   *p ;
  unsigned int len ;
  char const   *tmp ;
  unsigned int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 209
  p = str;
#line 210
  len = 0U;
#line 212
  while (1) {
#line 212
    if ((*p)) {
#line 212
      tmp___1 = __ctype_b_loc();
#line 212
      if ((int const   )(*((*tmp___1) + (int )(*p))) & 1) {
#line 212
        break;
      } else {
#line 212
        if (! (len < maxlen)) {
#line 212
          break;
        }
      }
    } else {
#line 212
      break;
    }
#line 213
    if ((int const   )(*p) == 34) {
#line 214
      while (1) {
#line 214
        tmp = p;
#line 214
        p ++;
#line 214
        if ((*tmp)) {
#line 214
          tmp___0 = len;
#line 214
          len ++;
#line 214
          if (! (tmp___0 < maxlen)) {
#line 214
            break;
          }
        } else {
#line 214
          break;
        }
#line 215
        if ((int const   )(*p) == 34) {
#line 216
          break;
        }
      }
    } else {
#line 218
      if ((int const   )(*p) == 92) {
#line 219
        p += 2;
#line 220
        len += 2U;
#line 221
        continue;
      }
    }
#line 223
    p ++;
#line 224
    len ++;
  }
#line 226
  return ((int )len);
}
}
#line 229 "parse_subs.c"
char *sanitize_path(char const   *path___1 , int origlen , unsigned int type___1 ,
                    unsigned int logopt ) 
{ char *slash ;
  char *cp ;
  char *s_path ;
  char const   *scp ;
  int len ;
  unsigned int seen_slash ;
  unsigned int quote ;
  unsigned int dquote ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 233
  len = origlen;
#line 234
  seen_slash = 0U;
#line 234
  quote = 0U;
#line 234
  dquote = 0U;
#line 236
  if (type___1 & 6U) {
#line 237
    tmp___0 = __builtin_strchr((char *)path___1, (char )'/');
#line 237
    slash = tmp___0;
#line 238
    if (slash) {
#line 239
      if (type___1 == 2U) {
#line 240
        return ((char *)((void *)0));
      }
#line 241
      if ((int const   )(*path___1) != 47) {
#line 242
        return ((char *)((void *)0));
      }
    } else {
#line 244
      if (type___1 == 4U) {
#line 245
        return ((char *)((void *)0));
      }
    }
  }
#line 249
  s_path = (char *)malloc((unsigned int )(origlen + 1));
#line 250
  if (! s_path) {
#line 251
    return ((char *)((void *)0));
  }
#line 253
  cp = s_path;
#line 253
  scp = path___1;
#line 253
  while (len > 0) {
#line 254
    if (! quote) {
#line 255
      if ((int const   )(*scp) == 34) {
#line 256
        if (dquote) {
#line 257
          dquote = 0U;
        } else {
#line 259
          dquote = 1U;
        }
        goto __Cont;
      }
#line 263
      if (! dquote) {
#line 265
        if ((int const   )(*scp) < 32) {
#line 266
          free((void *)s_path);
#line 267
          return ((char *)((void *)0));
        }
#line 270
        if ((int const   )(*scp) == 92) {
#line 271
          quote = 1U;
          goto __Cont;
        }
      }
#line 282
      if ((int const   )(*scp) == 47) {
#line 283
        if (seen_slash) {
          goto __Cont;
        }
#line 285
        seen_slash = 1U;
      } else {
#line 287
        seen_slash = 0U;
      }
    }
#line 289
    quote = 0U;
#line 290
    tmp___1 = cp;
#line 290
    cp ++;
#line 290
    (*tmp___1) = (char )(*scp);
    __Cont: 
#line 253
    scp ++;
#line 253
    len --;
  }
#line 292
  (*cp) = (char )'\000';
#line 294
  if (dquote) {
#line 295
    while (1) {
#line 295
      ((*log_debug))(logopt, "%s: unmatched quote in %.*s", "sanitize_path", origlen,
                     path___1);
#line 295
      break;
    }
#line 296
    free((void *)s_path);
#line 297
    return ((char *)((void *)0));
  }
#line 300
  if (origlen > 1) {
#line 300
    if ((int )(*(cp - 1)) == 47) {
#line 301
      (*(cp - 1)) = (char )'\000';
    }
  }
#line 303
  return (s_path);
}
}
#line 306 "parse_subs.c"
int umount_ent(struct autofs_point *ap , char const   *path___1 ) 
{ struct stat st ;
  struct statfs fs ;
  int sav_errno ;
  int status ;
  int is_smbfs ;
  int ret ;
  int rv ;
  int cifsfs ;
  int smbfs ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 311
  is_smbfs = 0;
#line 312
  rv = 1;
#line 314
  ret = statfs(path___1, & fs);
#line 315
  if (ret == -1) {
#line 316
    while (1) {
#line 316
      ((*log_warn))(ap->logopt, "%s: could not stat fs of %s", "umount_ent", path___1);
#line 316
      break;
    }
#line 317
    is_smbfs = 0;
  } else {
#line 319
    cifsfs = fs.f_type == -11317950;
#line 320
    smbfs = fs.f_type == 20859;
#line 321
    if (cifsfs | smbfs) {
#line 321
      is_smbfs = 1;
    } else {
#line 321
      is_smbfs = 0;
    }
  }
#line 324
  status = lstat__extinline(path___1, & st);
#line 325
  tmp = __errno_location();
#line 325
  sav_errno = (*tmp);
#line 327
  if (status < 0) {
#line 328
    while (1) {
#line 328
      ((*log_warn))(ap->logopt, "%s: lstat of %s failed with %d", "umount_ent", path___1,
                    status);
#line 328
      break;
    }
  }
#line 338
  if (! status) {
#line 338
    if ((st.st_mode & 61440U) == 16384U) {
#line 338
      if (st.st_dev != ap->dev) {
#line 339
        rv = spawn_umount(log_debug, path___1, (void *)0);
      } else {
        goto _L;
      }
    } else {
      goto _L;
    }
  } else {
    _L: 
#line 340
    if (is_smbfs) {
#line 340
      if (sav_errno == 5) {
#line 341
        rv = spawn_umount(log_debug, path___1, (void *)0);
      } else {
#line 340
        if (sav_errno == 57) {
#line 341
          rv = spawn_umount(log_debug, path___1, (void *)0);
        }
      }
    }
  }
#line 345
  if (rv) {
#line 345
    if ((int )ap->state == 6) {
      goto _L___0;
    } else {
#line 345
      if ((int )ap->state == 7) {
        _L___0: 
#line 346
        ret = stat__extinline(path___1, & st);
#line 347
        if (ret == -1) {
#line 347
          tmp___0 = __errno_location();
#line 347
          if ((*tmp___0) == 2) {
#line 348
            while (1) {
#line 348
              ((*log_warn))(ap->logopt, "%s: mount point does not exist", "umount_ent");
#line 348
              break;
            }
#line 349
            return (0);
          }
        }
#line 352
        if (ret == 0) {
#line 352
          if (! ((st.st_mode & 61440U) == 16384U)) {
#line 353
            while (1) {
#line 353
              ((*log_warn))(ap->logopt, "%s: mount point is not a directory", "umount_ent");
#line 353
              break;
            }
#line 354
            return (0);
          }
        }
#line 357
        if ((int )ap->state == 6) {
#line 358
          while (1) {
#line 358
            ((*log_info))(0U, "forcing umount of %s", path___1);
#line 358
            break;
          }
#line 359
          rv = spawn_umount(log_debug, "-l", path___1, (void *)0);
        }
#line 372
        if (! rv) {
#line 372
          tmp___1 = is_mounted("/etc/mtab", path___1, 2U);
#line 372
          if (tmp___1) {
#line 373
            while (1) {
#line 373
              ((*log_crit))(ap->logopt, "%s: the umount binary reported that %s was unmounted, but there is still something mounted on this path.",
                            "umount_ent", path___1);
#line 373
              break;
            }
#line 377
            rv = -1;
          }
        }
      }
    }
  }
#line 381
  return (rv);
}
}
#line 384 "parse_subs.c"
int mount_multi_triggers(struct autofs_point *ap , char *root , struct mapent *me ,
                         char const   *base ) 
{ char path___1[4097] ;
  char *offset ;
  struct mapent *oe ;
  struct list_head *pos ;
  unsigned int fs_path_len ;
  struct statfs fs ;
  struct stat st ;
  unsigned int mounted ;
  unsigned int is_autofs_fs ;
  int ret ;
  int start ;
  size_t tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;
  int plen ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
#line 387
  offset = path___1;
#line 389
  pos = (struct list_head *)((void *)0);
#line 396
  tmp = strlen((char const   *)root);
#line 396
  tmp___0 = strlen(base);
#line 396
  fs_path_len = tmp + tmp___0;
#line 397
  if (fs_path_len > 4096U) {
#line 398
    return (-1);
  }
#line 400
  strcpy((char * __restrict  )(path___1), (char const   * __restrict  )root);
#line 401
  strcat((char * __restrict  )(path___1), (char const   * __restrict  )base);
#line 402
  ret = statfs((char const   *)(path___1), & fs);
#line 403
  if (ret == -1) {
#line 405
    tmp___1 = __errno_location();
#line 405
    if ((*tmp___1) == 2) {
#line 406
      is_autofs_fs = 1U;
    } else {
#line 408
      return (-1);
    }
  } else {
#line 410
    if (fs.f_type == 391) {
#line 410
      is_autofs_fs = 1U;
    } else {
#line 410
      is_autofs_fs = 0U;
    }
  }
#line 412
  mounted = 0U;
#line 413
  start = (int )strlen((char const   *)root);
#line 414
  offset = cache_get_offset(base, offset, start, & me->multi_list, & pos);
#line 415
  while (offset) {
#line 416
    tmp___2 = strlen((char const   *)offset);
#line 416
    plen = (int )(fs_path_len + tmp___2);
#line 418
    if (plen > 4096) {
#line 419
      while (1) {
#line 419
        ((*log_warn))(ap->logopt, "%s: path loo long", "mount_multi_triggers");
#line 419
        break;
      }
      goto cont;
    }
#line 423
    oe = cache_lookup_offset(base, (char const   *)offset, start, & me->multi_list);
#line 424
    if (! oe) {
      goto cont;
    }
#line 432
    if (! is_autofs_fs) {
#line 433
      ret = stat__extinline((char const   *)oe->key, & st);
#line 434
      if (ret == -1) {
        goto cont;
      }
    }
#line 438
    while (1) {
#line 438
      ((*log_debug))(ap->logopt, "%s: mount offset %s", "mount_multi_triggers", oe->key);
#line 438
      break;
    }
#line 440
    tmp___3 = mount_autofs_offset(ap, oe, (int )is_autofs_fs);
#line 440
    if (tmp___3 < 0) {
#line 441
      while (1) {
#line 441
        ((*log_warn))(ap->logopt, "%s: failed to mount offset", "mount_multi_triggers");
#line 441
        break;
      }
    } else {
#line 443
      mounted ++;
    }
    cont: 
#line 445
    offset = cache_get_offset(base, offset, start, & me->multi_list, & pos);
  }
#line 449
  return ((int )mounted);
}
}
#line 452 "parse_subs.c"
int umount_multi_triggers(struct autofs_point *ap , char *root , struct mapent *me ,
                          char const   *base ) 
{ char path___1[4097] ;
  char *offset ;
  struct mapent *oe ;
  struct list_head *mm_root ;
  struct list_head *pos ;
  char o_root[2] ;
  char const   *mm_base ;
  int left ;
  int start ;
  char *oe_base ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  struct mapent_cache *mc ;
  int status ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 458
  o_root[0] = (char )'/';
#line 458
  o_root[1] = (char )'\000';
#line 462
  left = 0;
#line 463
  start = (int )strlen((char const   *)root);
#line 465
  mm_root = & (me->multi)->multi_list;
#line 467
  if (! base) {
#line 468
    mm_base = (char const   *)(o_root);
  } else {
#line 470
    mm_base = base;
  }
#line 472
  pos = (struct list_head *)((void *)0);
#line 473
  offset = path___1;
#line 476
  while (1) {
#line 476
    offset = cache_get_offset(mm_base, offset, start, mm_root, & pos);
#line 476
    if (! offset) {
#line 476
      break;
    }
#line 479
    oe = cache_lookup_offset(mm_base, (char const   *)offset, start, & me->multi_list);
#line 481
    if (! oe) {
#line 482
      continue;
    } else {
#line 481
      tmp = strlen((char const   *)oe->key);
#line 481
      if (tmp - (unsigned int )start == 1U) {
#line 482
        continue;
      }
    }
#line 488
    tmp___0 = strlen((char const   *)root);
#line 488
    oe_base = oe->key + tmp___0;
#line 489
    tmp___1 = umount_multi_triggers(ap, root, oe, (char const   *)oe_base);
#line 489
    left += tmp___1;
#line 491
    if (oe->ioctlfd != -1) {
#line 492
      left ++;
    }
  }
#line 495
  if (left) {
#line 496
    return (left);
  }
#line 498
  pos = (struct list_head *)((void *)0);
#line 499
  offset = path___1;
#line 502
  while (1) {
#line 502
    offset = cache_get_offset(mm_base, offset, start, mm_root, & pos);
#line 502
    if (! offset) {
#line 502
      break;
    }
#line 503
    oe = cache_lookup_offset(mm_base, (char const   *)offset, start, & me->multi_list);
#line 505
    if (! oe) {
#line 506
      continue;
    } else {
#line 505
      tmp___2 = strlen((char const   *)oe->key);
#line 505
      if (tmp___2 - (unsigned int )start == 1U) {
#line 506
        continue;
      }
    }
#line 508
    while (1) {
#line 508
      ((*log_debug))(ap->logopt, "%s: umount offset %s", "umount_multi_triggers",
                     oe->key);
#line 508
      break;
    }
#line 510
    tmp___3 = umount_autofs_offset(ap, oe);
#line 510
    if (tmp___3) {
#line 511
      while (1) {
#line 511
        ((*log_warn))(ap->logopt, "%s: failed to umount offset", "umount_multi_triggers");
#line 511
        break;
      }
#line 512
      left ++;
    }
  }
#line 516
  if (! left) {
#line 516
    if ((unsigned int )me->multi == (unsigned int )me) {
#line 517
      mc = me->mc;
#line 526
      tmp___7 = is_mounted("/etc/mtab", (char const   *)root, 2U);
#line 526
      if (tmp___7) {
#line 527
        while (1) {
#line 527
          ((*log_info))(0U, "unmounting dir = %s", root);
#line 527
          break;
        }
#line 528
        tmp___6 = umount_ent(ap, (char const   *)root);
#line 528
        if (tmp___6) {
#line 529
          tmp___4 = mount_multi_triggers(ap, root, me, "/");
#line 529
          if (! tmp___4) {
#line 530
            while (1) {
#line 530
              ((*log_warn))(ap->logopt, "%s: failed to remount offset triggers", "umount_multi_triggers");
#line 530
              break;
            }
          }
#line 532
          tmp___5 = left;
#line 532
          left ++;
#line 532
          return (tmp___5);
        }
      }
#line 537
      status = cache_delete_offset_list(mc, (char const   *)me->key);
#line 538
      if (status != 1) {
#line 539
        while (1) {
#line 539
          ((*log_warn))(ap->logopt, "%s: couldn\'t delete offset list", "umount_multi_triggers");
#line 539
          break;
        }
      }
    }
  }
#line 542
  return (left);
}
}
#line 1 "rpc_subs.o"
#pragma merger(0,"/tmp/cil-dU7Ufpcu.i","-O2,-Wall,-fPIC")
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 73 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval * __restrict  __tv ,
                                                      __timezone_ptr_t __tz )  __attribute__((__nonnull__(1))) ;
#line 100 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 110
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  * __restrict  __addr ,
                                              socklen_t __len ) ;
#line 124
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
#line 185
extern  __attribute__((__nothrow__)) int getsockopt(int __fd , int __level , int __optname ,
                                                    void * __restrict  __optval ,
                                                    socklen_t * __restrict  __optlen ) ;
#line 192
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 289 "/usr/include/rpc/xdr.h"
extern  __attribute__((__nothrow__)) bool_t xdr_u_short(XDR *__xdrs , u_short *__usp ) ;
#line 163 "/usr/include/rpc/auth.h"
extern AUTH *authunix_create_default(void) ;
#line 62 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 310 "/usr/include/rpc/clnt.h"
extern  __attribute__((__nothrow__)) CLIENT *clnttcp_create(struct sockaddr_in *__raddr ,
                                                            u_long __prog , u_long __version ,
                                                            int *__sockp , u_int __sendsz ,
                                                            u_int __recvsz ) ;
#line 338
extern  __attribute__((__nothrow__)) CLIENT *clntudp_bufcreate(struct sockaddr_in *__raddr ,
                                                               u_long __program ,
                                                               u_long __version ,
                                                               struct timeval __wait_resend ,
                                                               int *__sockp , u_int __sendsz ,
                                                               u_int __recvsz ) ;
#line 97 "/usr/include/rpc/pmap_prot.h"
extern  __attribute__((__nothrow__)) bool_t xdr_pmap(XDR *__xdrs , struct pmap *__regs ) ;
#line 845 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int gethostname(char *__name , size_t __len )  __attribute__((__nonnull__(1))) ;
#line 173 "/usr/include/netdb.h"
extern int gethostbyname_r(char const   * __restrict  __name , struct hostent * __restrict  __result_buf ,
                           char * __restrict  __buf , size_t __buflen , struct hostent ** __restrict  __result ,
                           int * __restrict  __h_errnop ) ;
#line 218
extern struct netent *getnetbyname(char const   *__name ) ;
#line 352
extern struct protoent *getprotobyname(char const   *__name ) ;
#line 418
extern int innetgr(char const   *__netgroup , char const   *__host , char const   *__user ,
                   char const   *domain ) ;
#line 631
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 637
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
#line 640
extern  __attribute__((__nothrow__)) char const   *gai_strerror(int __ecode ) ;
#line 646
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , unsigned int __flags ) ;
#line 59 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) int inet_pton(int __af , char const   * __restrict  __cp ,
                                                   void * __restrict  __buf ) ;
#line 65
extern  __attribute__((__nothrow__)) char const   *inet_ntop(int __af , void const   * __restrict  __cp ,
                                                             char * __restrict  __buf ,
                                                             socklen_t __len ) ;
#line 74
extern  __attribute__((__nothrow__)) int inet_aton(char const   *__cp , struct in_addr *__inp ) ;
#line 64 "/usr/include/rpcsvc/ypclnt.h"
extern  __attribute__((__nothrow__)) int yp_get_default_domain(char ** ) ;
#line 60 "../include/rpc_subs.h"
int rpc_udp_getclient(struct conn_info *info , unsigned int program___0 , unsigned int version___0 ) ;
#line 61
void rpc_destroy_udp_client(struct conn_info *info ) ;
#line 62
int rpc_tcp_getclient(struct conn_info *info , unsigned int program___0 , unsigned int version___0 ) ;
#line 63
void rpc_destroy_tcp_client(struct conn_info *info ) ;
#line 64
int rpc_portmap_getclient(struct conn_info *info , char const   *host , char const   *proto ,
                          unsigned int option ) ;
#line 65
unsigned short rpc_portmap_getport(struct conn_info *info , struct pmap *parms ) ;
#line 66
int rpc_ping_proto(struct conn_info *info ) ;
#line 67
int rpc_ping(char const   *host , long seconds , long micros , unsigned int option ) ;
#line 68
double elapsed(struct timeval start , struct timeval end ) ;
#line 69
int rpc_time(char const   *host , unsigned int ping_vers , unsigned int ping_proto ,
             long seconds , long micros , unsigned int option , double *result ) ;
#line 55 "rpc_subs.c"
static char *domain  =    (char *)((void *)0);
#line 58 "rpc_subs.c"
static union __anonunion_pthread_mutex_t_6 networks_mutex  =    {{0, 0U, 0, 0, 0U, {0}}};
#line 63 "rpc_subs.c"
static CLIENT *create_udp_client(struct conn_info *info ) 
{ int fd ;
  int cl_flags ;
  int ret ;
  int ghn_errno ;
  CLIENT *client ;
  struct sockaddr_in laddr ;
  struct sockaddr_in raddr ;
  struct hostent hp ;
  struct hostent *php ;
  struct hostent *result ;
  char buf[2048] ;
  size_t len ;
  bool_t tmp ;
  int tmp___0 ;
  int err ;
  int tmp___2 ;
  int *tmp___3 ;
  char *estr ;
  char *tmp___4 ;
  register unsigned short __v ;
  register unsigned short __x ;
  register unsigned int __v___0 ;
  register unsigned int __x___0 ;
  int tmp___5 ;
  bool_t tmp___6 ;

  {
#line 69
  php = & hp;
#line 74
  if ((info->proto)->p_proto != 17) {
#line 75
    return ((CLIENT *)((void *)0));
  }
#line 77
  if (info->client) {
#line 78
    tmp = ((*(((info->client)->cl_ops)->cl_control)))(info->client, 6, (char *)(& fd));
#line 78
    if (tmp) {
#line 83
      ((*(((info->client)->cl_ops)->cl_control)))(info->client, 9, (char *)((void *)0));
#line 84
      ((*(((info->client)->cl_ops)->cl_destroy)))(info->client);
    } else {
#line 79
      fd = -1;
#line 80
      ((*(((info->client)->cl_ops)->cl_destroy)))(info->client);
#line 81
      info->client = (CLIENT *)((void *)0);
    }
  }
#line 88
  memset((void *)(& laddr), 0, sizeof(laddr));
#line 89
  memset((void *)(& raddr), 0, sizeof(raddr));
#line 91
  raddr.sin_family = (unsigned short)2;
#line 92
  tmp___0 = inet_aton(info->host, & raddr.sin_addr);
#line 92
  if (tmp___0) {
    goto got_addr;
  }
#line 95
  memset((void *)(& hp), 0, sizeof(struct hostent ));
#line 97
  ret = gethostbyname_r((char const   * __restrict  )info->host, (struct hostent * __restrict  )php,
                        (char * __restrict  )(buf), 2048U, (struct hostent ** __restrict  )(& result),
                        (int * __restrict  )(& ghn_errno));
#line 99
  if (ret) {
    goto _L;
  } else {
#line 99
    if (! result) {
      _L: 
#line 100
      if (ghn_errno == -1) {
#line 100
        tmp___3 = __errno_location();
#line 100
        tmp___2 = (*tmp___3);
      } else {
#line 100
        tmp___2 = ghn_errno;
      }
#line 100
      err = tmp___2;
#line 101
      tmp___4 = strerror_r(err, buf, 2048U);
#line 101
      estr = tmp___4;
#line 102
      while (1) {
#line 102
        ((*log_error))(3U, "%s: hostname lookup failed: %s", "create_udp_client",
                       estr);
#line 102
        break;
      }
      goto out_close;
    }
  }
#line 105
  memcpy((void * __restrict  )(& raddr.sin_addr.s_addr), (void const   * __restrict  )(*(php->h_addr_list + 0)),
         (unsigned int )php->h_length);
  got_addr: 
#line 108
  __x = info->port;
#line 108
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 108
  raddr.sin_port = __v;
#line 110
  if (! info->client) {
#line 116
    fd = socket(2, 2, 17);
#line 117
    if (fd < 0) {
#line 118
      return ((CLIENT *)((void *)0));
    }
#line 120
    cl_flags = fcntl(fd, 1, 0);
#line 120
    if (cl_flags != -1) {
#line 121
      cl_flags |= 1;
#line 122
      fcntl(fd, 2, cl_flags);
    }
#line 125
    laddr.sin_family = (unsigned short)2;
#line 126
    laddr.sin_port = (unsigned short)0;
#line 127
    __x___0 = 0U;
#line 127
    __asm__  ("bswap %0": "=r" (__v___0): "0" (__x___0));
#line 127
    laddr.sin_addr.s_addr = __v___0;
#line 129
    len = sizeof(struct sockaddr_in );
#line 130
    tmp___5 = bind(fd, (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& laddr)),
                   len);
#line 130
    if (tmp___5 < 0) {
#line 131
      close(fd);
#line 132
      fd = -1;
    }
  }
#line 137
  client = clntudp_bufcreate(& raddr, info->program, info->version, info->timeout,
                             & fd, info->send_sz, info->recv_sz);
#line 142
  if (! client) {
#line 143
    info->client = (CLIENT *)((void *)0);
    goto out_close;
  }
#line 148
  tmp___6 = ((*((client->cl_ops)->cl_control)))(client, 8, (char *)((void *)0));
#line 148
  if (! tmp___6) {
#line 149
    ((*((client->cl_ops)->cl_destroy)))(client);
#line 150
    info->client = (CLIENT *)((void *)0);
    goto out_close;
  }
#line 154
  return (client);
  out_close: 
#line 157
  if (fd != -1) {
#line 158
    close(fd);
  }
#line 159
  return ((CLIENT *)((void *)0));
}
}
#line 162 "rpc_subs.c"
int rpc_udp_getclient(struct conn_info *info , unsigned int program___0 , unsigned int version___0 ) 
{ struct protoent *pe_proto ;
  CLIENT *client ;

  {
#line 168
  if (! info->client) {
#line 169
    pe_proto = getprotobyname("udp");
#line 170
    if (! pe_proto) {
#line 171
      return (0);
    }
#line 173
    info->proto = pe_proto;
#line 174
    info->send_sz = 8800U;
#line 175
    info->recv_sz = 8800U;
  }
#line 178
  info->program = (unsigned long )program___0;
#line 179
  info->version = (unsigned long )version___0;
#line 181
  client = create_udp_client(info);
#line 183
  if (! client) {
#line 184
    return (0);
  }
#line 186
  info->client = client;
#line 188
  return (1);
}
}
#line 191 "rpc_subs.c"
void rpc_destroy_udp_client(struct conn_info *info ) 
{ 

  {
#line 193
  if (! info->client) {
#line 194
    return;
  }
#line 196
  ((*(((info->client)->cl_ops)->cl_destroy)))(info->client);
#line 197
  info->client = (CLIENT *)((void *)0);
#line 198
  return;
}
}
#line 207 "rpc_subs.c"
static int connect_nb(int fd , struct sockaddr_in *addr , struct timeval *tout ) 
{ int flags ;
  int ret ;
  socklen_t len ;
  fd_set wset ;
  fd_set rset ;
  int *tmp ;
  int *tmp___0 ;
  int __d0 ;
  int __d1 ;
  int *tmp___1 ;
  int status ;
  int *tmp___2 ;
  register char __result ;
  register char __result___0 ;

  {
#line 213
  flags = fcntl(fd, 3, 0);
#line 214
  if (flags < 0) {
#line 215
    return (-1);
  }
#line 217
  ret = fcntl(fd, 4, flags | 2048);
#line 218
  if (ret < 0) {
#line 219
    return (-1);
  }
#line 226
  len = sizeof(struct sockaddr );
#line 227
  ret = connect(fd, (struct sockaddr  const  * __restrict  )((struct sockaddr *)addr),
                len);
#line 228
  if (ret < 0) {
#line 228
    tmp___0 = __errno_location();
#line 228
    if ((*tmp___0) != 115) {
#line 229
      tmp = __errno_location();
#line 229
      ret = - (*tmp);
      goto done;
    }
  }
#line 233
  if (ret == 0) {
    goto done;
  }
#line 237
  while (1) {
#line 237
    __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& rset.fds_bits[0]): "memory");
#line 237
    break;
  }
#line 238
  __asm__  volatile   ("btsl %1,%0": "=m" (rset.fds_bits[(unsigned int )fd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fd % (8U * sizeof(__fd_mask ))): "cc",
                       "memory");
#line 239
  wset = rset;
#line 241
  ret = select(fd + 1, (fd_set * __restrict  )(& rset), (fd_set * __restrict  )(& wset),
               (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )tout);
#line 242
  if (ret <= 0) {
#line 243
    if (ret == 0) {
#line 244
      ret = -110;
    } else {
#line 246
      tmp___1 = __errno_location();
#line 246
      ret = - (*tmp___1);
    }
    goto done;
  }
#line 250
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )fd % (8U * sizeof(__fd_mask ))),
                       "m" (rset.fds_bits[(unsigned int )fd / (8U * sizeof(__fd_mask ))]): "cc");
#line 250
  if (__result) {
    goto _L;
  } else {
#line 250
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )fd % (8U * sizeof(__fd_mask ))),
                         "m" (wset.fds_bits[(unsigned int )fd / (8U * sizeof(__fd_mask ))]): "cc");
#line 250
    if (__result___0) {
      _L: 
#line 253
      len = sizeof(ret);
#line 254
      status = getsockopt(fd, 1, 4, (void * __restrict  )(& ret), (socklen_t * __restrict  )(& len));
#line 255
      if (status < 0) {
#line 256
        tmp___2 = __errno_location();
#line 256
        ret = - (*tmp___2);
        goto done;
      }
#line 261
      if (ret) {
#line 262
        ret = - ret;
      }
    }
  }
  done: 
#line 266
  fcntl(fd, 4, flags);
#line 267
  return (ret);
}
}
#line 273 "rpc_subs.c"
static CLIENT *create_tcp_client(struct conn_info *info ) 
{ int fd ;
  int cl_flags ;
  int ghn_errno ;
  CLIENT *client ;
  struct sockaddr_in addr ;
  struct hostent hp ;
  struct hostent *php ;
  struct hostent *result ;
  char buf[2048] ;
  int ret ;
  bool_t tmp ;
  int tmp___0 ;
  int err ;
  int tmp___2 ;
  int *tmp___3 ;
  char *estr ;
  char *tmp___4 ;
  register unsigned short __v ;
  register unsigned short __x ;
  bool_t tmp___5 ;

  {
#line 279
  php = & hp;
#line 284
  if ((info->proto)->p_proto != 6) {
#line 285
    return ((CLIENT *)((void *)0));
  }
#line 287
  if (info->client) {
#line 288
    tmp = ((*(((info->client)->cl_ops)->cl_control)))(info->client, 6, (char *)(& fd));
#line 288
    if (tmp) {
#line 293
      ((*(((info->client)->cl_ops)->cl_control)))(info->client, 9, (char *)((void *)0));
#line 294
      ((*(((info->client)->cl_ops)->cl_destroy)))(info->client);
    } else {
#line 289
      fd = -1;
#line 290
      ((*(((info->client)->cl_ops)->cl_destroy)))(info->client);
#line 291
      info->client = (CLIENT *)((void *)0);
    }
  }
#line 298
  memset((void *)(& addr), 0, sizeof(addr));
#line 300
  addr.sin_family = (unsigned short)2;
#line 301
  tmp___0 = inet_aton(info->host, & addr.sin_addr);
#line 301
  if (tmp___0) {
    goto got_addr;
  }
#line 304
  memset((void *)(& hp), 0, sizeof(struct hostent ));
#line 306
  ret = gethostbyname_r((char const   * __restrict  )info->host, (struct hostent * __restrict  )php,
                        (char * __restrict  )(buf), 2048U, (struct hostent ** __restrict  )(& result),
                        (int * __restrict  )(& ghn_errno));
#line 308
  if (ret) {
    goto _L;
  } else {
#line 308
    if (! result) {
      _L: 
#line 309
      if (ghn_errno == -1) {
#line 309
        tmp___3 = __errno_location();
#line 309
        tmp___2 = (*tmp___3);
      } else {
#line 309
        tmp___2 = ghn_errno;
      }
#line 309
      err = tmp___2;
#line 310
      tmp___4 = strerror_r(err, buf, 2048U);
#line 310
      estr = tmp___4;
#line 311
      while (1) {
#line 311
        ((*log_error))(3U, "%s: hostname lookup failed: %s", "create_tcp_client",
                       estr);
#line 311
        break;
      }
      goto out_close;
    }
  }
#line 314
  memcpy((void * __restrict  )(& addr.sin_addr.s_addr), (void const   * __restrict  )(*(php->h_addr_list + 0)),
         (unsigned int )php->h_length);
  got_addr: 
#line 317
  __x = info->port;
#line 317
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 317
  addr.sin_port = __v;
#line 319
  if (! info->client) {
#line 320
    fd = socket(2, 1, (info->proto)->p_proto);
#line 321
    if (fd < 0) {
#line 322
      return ((CLIENT *)((void *)0));
    }
#line 324
    cl_flags = fcntl(fd, 1, 0);
#line 324
    if (cl_flags != -1) {
#line 325
      cl_flags |= 1;
#line 326
      fcntl(fd, 2, cl_flags);
    }
#line 329
    ret = connect_nb(fd, & addr, & info->timeout);
#line 330
    if (ret < 0) {
      goto out_close;
    }
  }
#line 334
  client = clnttcp_create(& addr, info->program, info->version, & fd, info->send_sz,
                          info->recv_sz);
#line 338
  if (! client) {
#line 339
    info->client = (CLIENT *)((void *)0);
    goto out_close;
  }
#line 344
  tmp___5 = ((*((client->cl_ops)->cl_control)))(client, 8, (char *)((void *)0));
#line 344
  if (! tmp___5) {
#line 345
    ((*((client->cl_ops)->cl_destroy)))(client);
#line 346
    info->client = (CLIENT *)((void *)0);
    goto out_close;
  }
#line 350
  return (client);
  out_close: 
#line 353
  if (fd != -1) {
#line 354
    close(fd);
  }
#line 355
  return ((CLIENT *)((void *)0));
}
}
#line 358 "rpc_subs.c"
int rpc_tcp_getclient(struct conn_info *info , unsigned int program___0 , unsigned int version___0 ) 
{ struct protoent *pe_proto ;
  CLIENT *client ;

  {
#line 364
  if (! info->client) {
#line 365
    pe_proto = getprotobyname("tcp");
#line 366
    if (! pe_proto) {
#line 367
      return (0);
    }
#line 369
    info->proto = pe_proto;
#line 370
    info->send_sz = 0U;
#line 371
    info->recv_sz = 0U;
  }
#line 374
  info->program = (unsigned long )program___0;
#line 375
  info->version = (unsigned long )version___0;
#line 377
  client = create_tcp_client(info);
#line 379
  if (! client) {
#line 380
    return (0);
  }
#line 382
  info->client = client;
#line 384
  return (1);
}
}
#line 387 "rpc_subs.c"
void rpc_destroy_tcp_client(struct conn_info *info ) 
{ struct linger lin ;
  socklen_t lin_len ;
  int fd ;
  bool_t tmp ;

  {
#line 389
  lin.l_onoff = 1;
#line 389
  lin.l_linger = 0;
#line 390
  lin_len = sizeof(struct linger );
#line 393
  if (! info->client) {
#line 394
    return;
  }
#line 396
  tmp = ((*(((info->client)->cl_ops)->cl_control)))(info->client, 6, (char *)(& fd));
#line 396
  if (! tmp) {
#line 397
    fd = -1;
  }
#line 399
  switch ((int )info->close_option) {
  case 1: 
#line 401
  if (fd >= 0) {
#line 402
    setsockopt(fd, 1, 13, (void const   *)(& lin), lin_len);
  }
#line 403
  break;
  }
#line 406
  ((*(((info->client)->cl_ops)->cl_destroy)))(info->client);
#line 407
  info->client = (CLIENT *)((void *)0);
#line 409
  return;
}
}
#line 412 "rpc_subs.c"
int rpc_portmap_getclient(struct conn_info *info , char const   *host , char const   *proto ,
                          unsigned int option ) 
{ struct protoent *pe_proto ;
  CLIENT *client ;

  {
#line 419
  pe_proto = getprotobyname(proto);
#line 420
  if (! pe_proto) {
#line 421
    return (0);
  }
#line 423
  info->host = host;
#line 424
  info->program = 100000UL;
#line 425
  info->port = (unsigned short)111;
#line 426
  info->version = 2UL;
#line 427
  info->proto = pe_proto;
#line 428
  info->send_sz = 400U;
#line 429
  info->recv_sz = 400U;
#line 430
  info->timeout.tv_sec = 3L;
#line 431
  info->timeout.tv_usec = 0L;
#line 432
  info->close_option = option;
#line 433
  info->client = (CLIENT *)((void *)0);
#line 435
  if (pe_proto->p_proto == 6) {
#line 436
    info->timeout.tv_sec = 5L;
#line 437
    client = create_tcp_client(info);
  } else {
#line 439
    client = create_udp_client(info);
  }
#line 441
  if (! client) {
#line 442
    return (0);
  }
#line 444
  info->client = client;
#line 446
  return (1);
}
}
#line 449 "rpc_subs.c"
unsigned short rpc_portmap_getport(struct conn_info *info , struct pmap *parms ) 
{ struct conn_info pmap_info ;
  unsigned short port ;
  CLIENT *client ;
  enum clnt_stat status ;
  int proto ;
  struct linger lin ;
  socklen_t lin_len ;
  int fd ;
  bool_t tmp ;

  {
#line 452
  port = (unsigned short)0;
#line 455
  proto = (info->proto)->p_proto;
#line 457
  memset((void *)(& pmap_info), 0, sizeof(struct conn_info ));
#line 459
  if (proto == 6) {
#line 460
    pmap_info.timeout.tv_sec = 5L;
  } else {
#line 462
    pmap_info.timeout.tv_sec = 3L;
  }
#line 464
  if (info->client) {
#line 465
    client = info->client;
  } else {
#line 467
    pmap_info.host = info->host;
#line 468
    pmap_info.port = (unsigned short)111;
#line 469
    pmap_info.program = 100000UL;
#line 470
    pmap_info.version = 2UL;
#line 471
    pmap_info.proto = info->proto;
#line 472
    pmap_info.send_sz = 400U;
#line 473
    pmap_info.recv_sz = 400U;
#line 475
    if (proto == 6) {
#line 476
      client = create_tcp_client(& pmap_info);
    } else {
#line 478
      client = create_udp_client(& pmap_info);
    }
#line 480
    if (! client) {
#line 481
      return ((unsigned short)0);
    }
  }
#line 488
  status = ((*((client->cl_ops)->cl_call)))(client, 0UL, (bool_t (*)(XDR * , void * 
                                                                     , ...))(& xdr_void),
                                            (char *)0, (bool_t (*)(XDR * , void * 
                                                                   , ...))(& xdr_void),
                                            (char *)0, pmap_info.timeout);
#line 492
  if ((int )status == 0) {
#line 493
    status = ((*((client->cl_ops)->cl_call)))(client, 3UL, (bool_t (*)(XDR * , void * 
                                                                       , ...))(& xdr_pmap),
                                              (char *)parms, (bool_t (*)(XDR * , void * 
                                                                         , ...))(& xdr_u_short),
                                              (char *)(& port), pmap_info.timeout);
  }
#line 499
  if (! info->client) {
#line 504
    if (proto == 6) {
#line 504
      if ((int )status == 0) {
#line 505
        lin.l_onoff = 1;
#line 505
        lin.l_linger = 0;
#line 506
        lin_len = sizeof(struct linger );
#line 509
        tmp = ((*((client->cl_ops)->cl_control)))(client, 6, (char *)(& fd));
#line 509
        if (! tmp) {
#line 510
          fd = -1;
        }
#line 512
        switch ((int )info->close_option) {
        case 1: 
#line 514
        if (fd >= 0) {
#line 515
          setsockopt(fd, 1, 13, (void const   *)(& lin), lin_len);
        }
#line 516
        break;
        }
      }
    }
#line 519
    ((*((client->cl_ops)->cl_destroy)))(client);
  }
#line 522
  if ((int )status != 0) {
#line 523
    return ((unsigned short)0);
  }
#line 525
  return (port);
}
}
#line 528 "rpc_subs.c"
int rpc_ping_proto(struct conn_info *info ) 
{ CLIENT *client ;
  enum clnt_stat status ;
  int proto ;
  struct linger lin ;
  socklen_t lin_len ;
  int fd ;
  bool_t tmp ;

  {
#line 532
  proto = (info->proto)->p_proto;
#line 534
  if (info->client) {
#line 535
    client = info->client;
  } else {
#line 537
    if ((info->proto)->p_proto == 17) {
#line 538
      info->send_sz = 8800U;
#line 539
      info->recv_sz = 8800U;
#line 540
      client = create_udp_client(info);
    } else {
#line 542
      client = create_tcp_client(info);
    }
#line 544
    if (! client) {
#line 545
      return (0);
    }
  }
#line 548
  ((*((client->cl_ops)->cl_control)))(client, 1, (char *)(& info->timeout));
#line 549
  ((*((client->cl_ops)->cl_control)))(client, 4, (char *)(& info->timeout));
#line 551
  status = ((*((client->cl_ops)->cl_call)))(client, 0UL, (bool_t (*)(XDR * , void * 
                                                                     , ...))(& xdr_void),
                                            (char *)0, (bool_t (*)(XDR * , void * 
                                                                   , ...))(& xdr_void),
                                            (char *)0, info->timeout);
#line 555
  if (! info->client) {
#line 560
    if (proto == 6) {
#line 560
      if ((int )status == 0) {
#line 561
        lin.l_onoff = 1;
#line 561
        lin.l_linger = 0;
#line 562
        lin_len = sizeof(struct linger );
#line 565
        tmp = ((*((client->cl_ops)->cl_control)))(client, 6, (char *)(& fd));
#line 565
        if (! tmp) {
#line 566
          fd = -1;
        }
#line 568
        switch ((int )info->close_option) {
        case 1: 
#line 570
        if (fd >= 0) {
#line 571
          setsockopt(fd, 1, 13, (void const   *)(& lin), lin_len);
        }
#line 572
        break;
        }
      }
    }
#line 575
    ((*((client->cl_ops)->cl_destroy)))(client);
  }
#line 578
  if ((int )status != 0) {
#line 579
    return (0);
  }
#line 581
  return (1);
}
}
#line 584 "rpc_subs.c"
static unsigned int __rpc_ping(char const   *host , unsigned long version___0 , char *proto ,
                               long seconds , long micros , unsigned int option ) 
{ unsigned int status ;
  struct conn_info info ;
  struct pmap parms ;

  {
#line 594
  info.host = host;
#line 595
  info.program = 100003UL;
#line 596
  info.version = version___0;
#line 597
  info.send_sz = 0U;
#line 598
  info.recv_sz = 0U;
#line 599
  info.timeout.tv_sec = seconds;
#line 600
  info.timeout.tv_usec = micros;
#line 601
  info.close_option = option;
#line 602
  info.client = (CLIENT *)((void *)0);
#line 604
  status = 0U;
#line 606
  info.proto = getprotobyname((char const   *)proto);
#line 607
  if (! info.proto) {
#line 608
    return (status);
  }
#line 610
  parms.pm_prog = 100003UL;
#line 611
  parms.pm_vers = version___0;
#line 612
  parms.pm_prot = (unsigned long )(info.proto)->p_proto;
#line 613
  parms.pm_port = 0UL;
#line 615
  info.port = rpc_portmap_getport(& info, & parms);
#line 616
  if (! info.port) {
#line 617
    return (status);
  }
#line 619
  status = (unsigned int )rpc_ping_proto(& info);
#line 621
  return (status);
}
}
#line 624 "rpc_subs.c"
int rpc_ping(char const   *host , long seconds , long micros , unsigned int option ) 
{ unsigned long vers3 ;
  unsigned long vers2 ;
  unsigned int status ;

  {
#line 626
  vers3 = 3UL;
#line 627
  vers2 = 2UL;
#line 630
  status = __rpc_ping(host, vers2, (char *)"udp", seconds, micros, option);
#line 631
  if (status) {
#line 632
    return (258);
  }
#line 634
  status = __rpc_ping(host, vers3, (char *)"udp", seconds, micros, option);
#line 635
  if (status) {
#line 636
    return (259);
  }
#line 638
  status = __rpc_ping(host, vers2, (char *)"tcp", seconds, micros, option);
#line 639
  if (status) {
#line 640
    return (514);
  }
#line 642
  status = __rpc_ping(host, vers3, (char *)"tcp", seconds, micros, option);
#line 643
  if (status) {
#line 644
    return (515);
  }
#line 646
  return ((int )status);
}
}
#line 649 "rpc_subs.c"
double elapsed(struct timeval start , struct timeval end ) 
{ double t1 ;
  double t2 ;

  {
#line 652
  t1 = (double )start.tv_sec + (double )start.tv_usec / (double )1000000;
#line 653
  t2 = (double )end.tv_sec + (double )end.tv_usec / (double )1000000;
#line 654
  return (t2 - t1);
}
}
#line 657 "rpc_subs.c"
int rpc_time(char const   *host , unsigned int ping_vers , unsigned int ping_proto ,
             long seconds , long micros , unsigned int option , double *result ) 
{ int status ;
  double taken ;
  struct timeval start ;
  struct timeval end ;
  struct timezone tz ;
  char *proto ;
  char const   *tmp ;
  unsigned long vers ;

  {
#line 665
  if (ping_proto & 256U) {
#line 665
    tmp = "udp";
  } else {
#line 665
    tmp = "tcp";
  }
#line 665
  proto = (char *)tmp;
#line 666
  vers = (unsigned long )ping_vers;
#line 668
  gettimeofday((struct timeval * __restrict  )(& start), (struct timezone * __restrict  )(& tz));
#line 669
  status = (int )__rpc_ping(host, vers, proto, seconds, micros, option);
#line 670
  gettimeofday((struct timeval * __restrict  )(& end), (struct timezone * __restrict  )(& tz));
#line 672
  if (! status) {
#line 673
    return (0);
  }
#line 676
  taken = elapsed(start, end);
#line 678
  if ((unsigned int )result != (unsigned int )((void *)0)) {
#line 679
    (*result) = taken;
  }
#line 681
  return (status);
}
}
#line 684 "rpc_subs.c"
static int rpc_get_exports_proto(struct conn_info *info , exports *exp ) 
{ CLIENT *client ;
  enum clnt_stat status ;
  int proto ;
  unsigned int option ;
  struct linger lin ;
  socklen_t lin_len ;
  int fd ;
  bool_t tmp ;

  {
#line 688
  proto = (info->proto)->p_proto;
#line 689
  option = info->close_option;
#line 691
  if ((info->proto)->p_proto == 17) {
#line 692
    info->send_sz = 8800U;
#line 693
    info->recv_sz = 8800U;
#line 694
    client = create_udp_client(info);
  } else {
#line 696
    client = create_tcp_client(info);
  }
#line 698
  if (! client) {
#line 699
    return (0);
  }
#line 701
  ((*((client->cl_ops)->cl_control)))(client, 1, (char *)(& info->timeout));
#line 702
  ((*((client->cl_ops)->cl_control)))(client, 4, (char *)(& info->timeout));
#line 704
  client->cl_auth = authunix_create_default();
#line 706
  status = ((*((client->cl_ops)->cl_call)))(client, 5UL, (bool_t (*)(XDR * , void * 
                                                                     , ...))(& xdr_void),
                                            (char *)((void *)0), (bool_t (*)(XDR * ,
                                                                             void * 
                                                                             , ...))(& xdr_exports),
                                            (char *)exp, info->timeout);
#line 712
  if (proto == 6) {
#line 712
    if ((int )status == 0) {
#line 713
      lin.l_onoff = 1;
#line 713
      lin.l_linger = 0;
#line 714
      lin_len = sizeof(struct linger );
#line 717
      tmp = ((*((client->cl_ops)->cl_control)))(client, 6, (char *)(& fd));
#line 717
      if (! tmp) {
#line 718
        fd = -1;
      }
#line 720
      switch ((int )option) {
      case 1: 
#line 722
      if (fd >= 0) {
#line 723
        setsockopt(fd, 1, 13, (void const   *)(& lin), lin_len);
      }
#line 724
      break;
      }
    }
  }
#line 727
  ((*(((client->cl_auth)->ah_ops)->ah_destroy)))(client->cl_auth);
#line 728
  ((*((client->cl_ops)->cl_destroy)))(client);
#line 730
  if ((int )status != 0) {
#line 731
    return (0);
  }
#line 733
  return (1);
}
}
#line 736 "rpc_subs.c"
static void rpc_export_free(exports item ) 
{ groups grp ;
  groups tmp ;

  {
#line 741
  if (item->ex_dir) {
#line 742
    free((void *)item->ex_dir);
  }
#line 744
  grp = item->ex_groups;
#line 745
  while (grp) {
#line 746
    if (grp->gr_name) {
#line 747
      free((void *)grp->gr_name);
    }
#line 748
    tmp = grp;
#line 749
    grp = grp->gr_next;
#line 750
    free((void *)tmp);
  }
#line 752
  free((void *)item);
#line 753
  return;
}
}
#line 755 "rpc_subs.c"
void rpc_exports_free(exports list ) 
{ exports tmp ;

  {
#line 759
  while (list) {
#line 760
    tmp = list;
#line 761
    list = list->ex_next;
#line 762
    rpc_export_free(tmp);
  }
#line 764
  return;
}
}
#line 767 "rpc_subs.c"
static int masked_match(char const   *addr , char const   *mask ) 
{ char buf[1024] ;
  char *ptr ;
  struct sockaddr_in saddr ;
  struct sockaddr_in6 saddr6 ;
  struct ifconf ifc ;
  struct ifreq *ifr ;
  int sock ;
  int cl_flags ;
  int ret ;
  int i ;
  int is_ipv4 ;
  int is_ipv6 ;
  unsigned int msize ;
  char *estr ;
  int *tmp ;
  char *tmp___0 ;
  char *estr___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  struct sockaddr_in maddr ;
  uint32_t ma ;
  int i___0 ;
  register unsigned int __v ;
  register unsigned int __x ;
  char *tmp___4 ;
  struct sockaddr_in *if_addr ;
  uint32_t m ;
  uint32_t ia ;
  uint32_t ha ;
  register unsigned int __v___0 ;
  register unsigned int __x___0 ;
  register unsigned int __v___1 ;
  register unsigned int __x___1 ;

  {
#line 777
  sock = socket(2, 2, 0);
#line 778
  if (sock < 0) {
#line 779
    tmp = __errno_location();
#line 779
    tmp___0 = strerror_r((*tmp), buf, 128U);
#line 779
    estr = tmp___0;
#line 780
    while (1) {
#line 780
      ((*log_error))(3U, "%s: socket creation failed: %s", "masked_match", estr);
#line 780
      break;
    }
#line 781
    return (0);
  }
#line 784
  cl_flags = fcntl(sock, 1, 0);
#line 784
  if (cl_flags != -1) {
#line 785
    cl_flags |= 1;
#line 786
    fcntl(sock, 2, cl_flags);
  }
#line 789
  ifc.ifc_len = (int )sizeof(buf);
#line 790
  ifc.ifc_ifcu.ifcu_req = (struct ifreq *)(buf);
#line 791
  ret = ioctl(sock, 35090UL, & ifc);
#line 792
  if (ret == -1) {
#line 793
    close(sock);
#line 794
    tmp___1 = __errno_location();
#line 794
    tmp___2 = strerror_r((*tmp___1), buf, 128U);
#line 794
    estr___0 = tmp___2;
#line 795
    while (1) {
#line 795
      ((*log_error))(3U, "%s: ioctl: %s", "masked_match", estr___0);
#line 795
      break;
    }
#line 796
    return (0);
  }
#line 799
  is_ipv6 = 0;
#line 799
  is_ipv4 = is_ipv6;
#line 800
  is_ipv4 = inet_pton(2, (char const   * __restrict  )addr, (void * __restrict  )(& saddr.sin_addr));
#line 801
  if (! is_ipv4) {
#line 802
    is_ipv6 = inet_pton(10, (char const   * __restrict  )addr, (void * __restrict  )(& saddr6.sin6_addr));
  }
#line 804
  tmp___4 = __builtin_strchr((char *)mask, (char )'.');
#line 804
  if (tmp___4) {
#line 807
    i___0 = 0;
#line 809
    ret = inet_aton(mask, & maddr.sin_addr);
#line 810
    if (! ret) {
#line 811
      close(sock);
#line 812
      return (0);
    }
#line 815
    __x = maddr.sin_addr.s_addr;
#line 815
    __asm__  ("bswap %0": "=r" (__v): "0" (__x));
#line 815
    ma = __v;
#line 816
    while (! (ma & 1U)) {
#line 817
      i___0 ++;
#line 818
      ma >>= 1;
    }
#line 821
    msize = (unsigned int )i___0;
  } else {
#line 823
    msize = (unsigned int )atoi__extinline(mask);
  }
#line 825
  i = 0;
#line 826
  ptr = ifc.ifc_ifcu.ifcu_buf + 0;
#line 828
  while ((unsigned int )ptr < (unsigned int )(buf + ifc.ifc_len)) {
#line 829
    ifr = (struct ifreq *)ptr;
#line 831
    switch ((int )ifr->ifr_ifru.ifru_addr.sa_family) {
    case 2: 
#line 837
    if (! is_ipv4) {
#line 838
      break;
    } else {
#line 837
      if (msize > 32U) {
#line 838
        break;
      }
    }
#line 840
    m = 4294967295U;
#line 841
    m <<= 32U - msize;
#line 842
    __x___0 = saddr.sin_addr.s_addr;
#line 842
    __asm__  ("bswap %0": "=r" (__v___0): "0" (__x___0));
#line 842
    ha = __v___0;
#line 844
    if_addr = (struct sockaddr_in *)(& ifr->ifr_ifru.ifru_addr);
#line 845
    __x___1 = if_addr->sin_addr.s_addr;
#line 845
    __asm__  ("bswap %0": "=r" (__v___1): "0" (__x___1));
#line 845
    ia = __v___1;
#line 847
    if ((ia & m) == (ha & m)) {
#line 848
      close(sock);
#line 849
      return (1);
    }
#line 851
    break;
    case 10: 
#line 856
    break;
    default: ;
#line 859
    break;
    }
#line 862
    i ++;
#line 863
    ptr = (char *)(ifc.ifc_ifcu.ifcu_req + i);
  }
#line 866
  close(sock);
#line 867
  return (0);
}
}
#line 882 "rpc_subs.c"
static int pattern_match(char const   *s , char const   *pattern ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 884
  while (1) {
#line 886
    if (! (*pattern)) {
#line 887
      return (! (*s));
    }
#line 889
    if ((int const   )(*pattern) == 42) {
#line 891
      pattern ++;
#line 894
      if (! (*pattern)) {
#line 895
        return (1);
      }
#line 898
      if ((int const   )(*pattern) != 63) {
#line 898
        if ((int const   )(*pattern) != 42) {
#line 904
          while ((*s)) {
#line 905
            if ((int const   )(*s) == (int const   )(*pattern)) {
#line 905
              tmp = pattern_match(s + 1, pattern + 1);
#line 905
              if (tmp) {
#line 907
                return (1);
              }
            }
#line 904
            s ++;
          }
#line 910
          return (0);
        }
      }
#line 916
      while ((*s)) {
#line 917
        tmp___0 = pattern_match(s, pattern);
#line 917
        if (tmp___0) {
#line 918
          return (1);
        }
#line 916
        s ++;
      }
#line 920
      return (0);
    }
#line 926
    if (! (*s)) {
#line 927
      return (0);
    }
#line 930
    if ((int const   )(*pattern) != 63) {
#line 930
      if ((int const   )(*pattern) != (int const   )(*s)) {
#line 931
        return (0);
      }
    }
#line 934
    s ++;
#line 935
    pattern ++;
  }
}
}
#line 940 "rpc_subs.c"
static int name_match(char const   *name___0 , char const   *pattern ) 
{ int ret ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___3 ;
  char *tmp___5 ;

  {
#line 944
  tmp___3 = __builtin_strchr((char *)pattern, (char )'*');
#line 944
  if (tmp___3) {
#line 945
    ret = pattern_match(name___0, pattern);
  } else {
#line 944
    tmp___5 = __builtin_strchr((char *)pattern, (char )'?');
#line 944
    if (tmp___5) {
#line 945
      ret = pattern_match(name___0, pattern);
    } else {
#line 947
      tmp = strlen(pattern);
#line 947
      tmp___0 = memcmp((void const   *)name___0, (void const   *)pattern, tmp);
#line 947
      if (tmp___0) {
#line 947
        tmp___1 = 0;
      } else {
#line 947
        tmp___1 = 1;
      }
#line 947
      ret = tmp___1;
#line 949
      if (! ret) {
#line 950
        ret = innetgr(pattern, name___0, (char const   *)((void *)0), (char const   *)domain);
      }
    }
  }
#line 953
  return (ret);
}
}
#line 956 "rpc_subs.c"
static int fqdn_match(char const   *pattern ) 
{ char buf[1024] ;
  char *ptr ;
  struct ifconf ifc ;
  struct ifreq *ifr ;
  int sock ;
  int cl_flags ;
  int ret ;
  int i ;
  char fqdn[1026] ;
  char *estr ;
  int *tmp ;
  char *tmp___0 ;
  char *estr___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  socklen_t slen ;

  {
#line 964
  sock = socket(2, 2, 0);
#line 965
  if (sock < 0) {
#line 966
    tmp = __errno_location();
#line 966
    tmp___0 = strerror_r((*tmp), buf, 128U);
#line 966
    estr = tmp___0;
#line 967
    while (1) {
#line 967
      ((*log_error))(3U, "%s: socket creation failed: %s", "fqdn_match", estr);
#line 967
      break;
    }
#line 968
    return (0);
  }
#line 971
  cl_flags = fcntl(sock, 1, 0);
#line 971
  if (cl_flags != -1) {
#line 972
    cl_flags |= 1;
#line 973
    fcntl(sock, 2, cl_flags);
  }
#line 976
  ifc.ifc_len = (int )sizeof(buf);
#line 977
  ifc.ifc_ifcu.ifcu_req = (struct ifreq *)(buf);
#line 978
  ret = ioctl(sock, 35090UL, & ifc);
#line 979
  if (ret == -1) {
#line 980
    close(sock);
#line 981
    tmp___1 = __errno_location();
#line 981
    tmp___2 = strerror_r((*tmp___1), buf, 128U);
#line 981
    estr___0 = tmp___2;
#line 982
    while (1) {
#line 982
      ((*log_error))(3U, "%s: ioctl: %s", "fqdn_match", estr___0);
#line 982
      break;
    }
#line 983
    return (0);
  }
#line 986
  i = 0;
#line 987
  ptr = ifc.ifc_ifcu.ifcu_buf + 0;
#line 989
  while ((unsigned int )ptr < (unsigned int )(buf + ifc.ifc_len)) {
#line 990
    ifr = (struct ifreq *)ptr;
#line 992
    switch ((int )ifr->ifr_ifru.ifru_addr.sa_family) {
    case 2: 
#line 995
    slen = sizeof(struct sockaddr );
#line 997
    ret = getnameinfo((struct sockaddr  const  * __restrict  )(& ifr->ifr_ifru.ifru_addr),
                      slen, (char * __restrict  )(fqdn), 1025U, (char * __restrict  )((void *)0),
                      0U, 8U);
#line 999
    if (! ret) {
#line 1000
      ret = name_match((char const   *)(fqdn), pattern);
#line 1001
      if (ret) {
#line 1002
        close(sock);
#line 1003
        return (1);
      }
    }
#line 1006
    break;
    case 10: 
#line 1011
    break;
    default: ;
#line 1014
    break;
    }
#line 1017
    i ++;
#line 1018
    ptr = (char *)(ifc.ifc_ifcu.ifcu_req + i);
  }
#line 1021
  close(sock);
#line 1022
  return (0);
}
}
#line 1025 "rpc_subs.c"
static int string_match(char const   *myname , char const   *pattern ) 
{ struct addrinfo hints ;
  struct addrinfo *ni ;
  int ret ;
  char const   *tmp ;
  int tmp___0 ;

  {
#line 1031
  ret = name_match(myname, pattern);
#line 1032
  if (ret) {
    goto done;
  }
#line 1035
  memset((void *)(& hints), 0, sizeof(hints));
#line 1036
  hints.ai_flags = 2;
#line 1037
  hints.ai_family = 0;
#line 1038
  hints.ai_socktype = 0;
#line 1041
  tmp___0 = getaddrinfo((char const   * __restrict  )myname, (char const   * __restrict  )((void *)0),
                        (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& ni));
#line 1041
  if (tmp___0 == 0) {
#line 1042
    ret = name_match((char const   *)ni->ai_canonname, pattern);
#line 1043
    freeaddrinfo(ni);
  } else {
#line 1045
    while (1) {
#line 1045
      tmp = gai_strerror(ret);
#line 1045
      ((*log_warn))(3U, "%s: name lookup failed: %s", "string_match", tmp);
#line 1045
      break;
    }
  }
#line 1046
  if (ret) {
    goto done;
  }
#line 1050
  ret = fqdn_match(pattern);
  done: 
#line 1052
  return (ret);
}
}
#line 1055 "rpc_subs.c"
static unsigned int inet_get_net_len(uint32_t net ) 
{ int i ;

  {
#line 1059
  i = 0;
#line 1059
  while (i < 32) {
#line 1060
    if ((net >> (((i + 7) + 1) - 8)) & 255U) {
#line 1061
      break;
    }
#line 1059
    i += 8;
  }
#line 1064
  return (32U - (unsigned int )i);
}
}
#line 1067 "rpc_subs.c"
static char *inet_fill_net(char const   *net_num , char *net ) 
{ char *np ;
  unsigned int dots ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  unsigned int tmp___3 ;

  {
#line 1070
  dots = 3U;
#line 1072
  tmp = strlen(net_num);
#line 1072
  if (tmp > 16U) {
#line 1073
    return ((char *)((void *)0));
  }
#line 1075
  tmp___0 = __ctype_b_loc();
#line 1075
  if (! ((int const   )(*((*tmp___0) + (int )(*net_num))) & 2048)) {
#line 1076
    return ((char *)((void *)0));
  }
#line 1078
  (*net) = (char )'\000';
#line 1079
  strcpy((char * __restrict  )net, (char const   * __restrict  )net_num);
#line 1081
  np = net;
#line 1082
  while (1) {
#line 1082
    tmp___2 = np;
#line 1082
    np ++;
#line 1082
    if (! (*tmp___2)) {
#line 1082
      break;
    }
#line 1083
    if ((int )(*np) == 46) {
#line 1084
      np ++;
#line 1085
      dots --;
#line 1086
      if (! (*np)) {
#line 1086
        if (dots) {
#line 1087
          strcat((char * __restrict  )net, (char const   * __restrict  )"0");
        }
      }
#line 1088
      continue;
    }
#line 1091
    if ((*np)) {
#line 1091
      tmp___1 = __ctype_b_loc();
#line 1091
      if ((int const   )(*((*tmp___1) + (int )(*np))) & 2048) {
        goto _L;
      } else {
#line 1092
        (*net) = (char )'\000';
#line 1093
        return ((char *)((void *)0));
      }
    } else {
      _L: 
#line 1091
      if (dots < 0U) {
#line 1092
        (*net) = (char )'\000';
#line 1093
        return ((char *)((void *)0));
      }
    }
  }
#line 1097
  while (1) {
#line 1097
    tmp___3 = dots;
#line 1097
    dots --;
#line 1097
    if (! tmp___3) {
#line 1097
      break;
    }
#line 1098
    strcat((char * __restrict  )net, (char const   * __restrict  )".0");
  }
#line 1100
  return (net);
}
}
#line 1103 "rpc_subs.c"
static int match_network(char const   *network ) 
{ struct netent *pnent ;
  struct netent nent ;
  char const   *pcnet ;
  char *net ;
  char cnet[255] ;
  char mask[4] ;
  char *pmask ;
  unsigned int size ;
  size_t l_network ;
  size_t tmp ;
  int status ;
  char *tmp___0 ;
  char *tmp___2 ;
  uint32_t n_net ;
  register unsigned int __v ;
  register unsigned int __x ;
  int ret ;
  struct in_addr addr ;
  uint32_t nl_addr ;
  register unsigned int __v___0 ;
  register unsigned int __x___0 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1109
  tmp = strlen(network);
#line 1109
  l_network = tmp + 1U;
#line 1112
  if (l_network > 255U) {
#line 1113
    while (1) {
#line 1113
      ((*log_error))(3U, "%s: match string \"%s\" too long", "match_network", network);
#line 1113
      break;
    }
#line 1115
    return (0);
  }
#line 1118
  net = (char *)__builtin_alloca(l_network);
#line 1119
  if (! net) {
#line 1120
    return (0);
  }
#line 1121
  memset((void *)net, 0, l_network);
#line 1122
  strcpy((char * __restrict  )net, (char const   * __restrict  )network);
#line 1124
  tmp___2 = __builtin_strchr(net, (char )'/');
#line 1124
  pmask = tmp___2;
#line 1124
  if (pmask) {
#line 1125
    tmp___0 = pmask;
#line 1125
    pmask ++;
#line 1125
    (*tmp___0) = (char )'\000';
  }
#line 1127
  status = pthread_mutex_lock(& networks_mutex);
#line 1128
  if (status) {
#line 1129
    while (1) {
#line 1129
      if (status == 35) {
#line 1129
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "match_network", 1129, "rpc_subs.c");
#line 1129
        dump_core();
      }
#line 1129
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1129,
                    "rpc_subs.c");
#line 1129
      abort();
#line 1129
      break;
    }
  }
#line 1131
  pnent = getnetbyname((char const   *)net);
#line 1132
  if (pnent) {
#line 1133
    memcpy((void * __restrict  )(& nent), (void const   * __restrict  )pnent, sizeof(struct netent ));
  }
#line 1135
  status = pthread_mutex_unlock(& networks_mutex);
#line 1136
  if (status) {
#line 1137
    while (1) {
#line 1137
      if (status == 35) {
#line 1137
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "match_network", 1137, "rpc_subs.c");
#line 1137
        dump_core();
      }
#line 1137
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1137,
                    "rpc_subs.c");
#line 1137
      abort();
#line 1137
      break;
    }
  }
#line 1139
  if (pnent) {
#line 1142
    switch (nent.n_addrtype) {
    case 2: 
#line 1144
    __x = nent.n_net;
#line 1144
    __asm__  ("bswap %0": "=r" (__v): "0" (__x));
#line 1144
    n_net = __v;
#line 1145
    pcnet = inet_ntop(2, (void const   * __restrict  )(& n_net), (char * __restrict  )(cnet),
                      16U);
#line 1146
    if (! pcnet) {
#line 1147
      return (0);
    }
#line 1149
    if (! pmask) {
#line 1150
      size = inet_get_net_len(nent.n_net);
#line 1151
      if (! size) {
#line 1152
        return (0);
      }
    }
#line 1154
    break;
    case 10: 
#line 1157
    return (0);
    default: ;
#line 1160
    return (0);
    }
  } else {
#line 1165
    tmp___4 = __builtin_strchr(net, (char )':');
#line 1165
    if (tmp___4) {
#line 1166
      return (0);
    } else {
#line 1170
      pcnet = (char const   *)inet_fill_net((char const   *)net, cnet);
#line 1171
      if (! pcnet) {
#line 1172
        return (0);
      }
#line 1174
      ret = inet_pton(2, (char const   * __restrict  )pcnet, (void * __restrict  )(& addr));
#line 1175
      if (ret <= 0) {
#line 1176
        return (0);
      }
#line 1178
      if (! pmask) {
#line 1179
        __x___0 = addr.s_addr;
#line 1179
        __asm__  ("bswap %0": "=r" (__v___0): "0" (__x___0));
#line 1179
        nl_addr = __v___0;
#line 1180
        size = inet_get_net_len(nl_addr);
#line 1181
        if (! size) {
#line 1182
          return (0);
        }
      }
    }
  }
#line 1187
  if (! pmask) {
#line 1188
    tmp___5 = sprintf((char * __restrict  )(mask), (char const   * __restrict  )"%u",
                      size);
#line 1188
    if (tmp___5 <= 0) {
#line 1189
      return (0);
    }
#line 1190
    pmask = mask;
  }
#line 1193
  while (1) {
#line 1193
    ((*log_debug))(3U, "%s: pcnet %s pmask %s", "match_network", pcnet, pmask);
#line 1193
    break;
  }
#line 1195
  tmp___6 = masked_match(pcnet, (char const   *)pmask);
#line 1195
  return (tmp___6);
}
}
#line 1221 "rpc_subs.c"
static int host_match(char *pattern ) 
{ unsigned int negate ;
  char const   *m_pattern ;
  char *tmp ;
  char myname[65] ;
  int ret ;
  int tmp___0 ;
  int tmp___1 ;
  size_t m_len ;
  size_t tmp___2 ;
  char *has_dot ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  char *w_pattern ;
  char *tmp___8 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 1223
  negate = (unsigned int )((int )(*pattern) == 45);
#line 1224
  if (negate) {
#line 1224
    tmp = pattern + 1;
  } else {
#line 1224
    tmp = pattern;
  }
#line 1224
  m_pattern = (char const   *)tmp;
#line 1225
  myname[0] = (char )'\000';
#line 1225
  myname[1] = (char )'\000';
#line 1226
  ret = 0;
#line 1228
  tmp___0 = gethostname(myname, 64U);
#line 1228
  if (tmp___0) {
#line 1229
    return (0);
  }
#line 1231
  tmp___1 = yp_get_default_domain(& domain);
#line 1231
  if (tmp___1) {
#line 1232
    domain = (char *)((void *)0);
  }
#line 1234
  if ((int const   )(*m_pattern) == 64) {
#line 1239
    ret = match_network(m_pattern + 1);
#line 1240
    if (! ret) {
#line 1241
      ret = innetgr(m_pattern + 1, (char const   *)(myname), (char const   *)((void *)0),
                    (char const   *)domain);
    }
  } else {
#line 1242
    if ((int const   )(*m_pattern) == 46) {
#line 1243
      tmp___2 = strlen(m_pattern);
#line 1243
      m_len = tmp___2;
#line 1244
      tmp___4 = __builtin_strchr(myname, (char )'.');
#line 1244
      has_dot = tmp___4;
#line 1255
      if (has_dot) {
#line 1256
        tmp___7 = strlen((char const   *)has_dot);
#line 1256
        if (tmp___7 == m_len) {
#line 1257
          tmp___5 = memcmp((void const   *)has_dot, (void const   *)m_pattern, m_len);
#line 1257
          if (tmp___5) {
#line 1257
            tmp___6 = 0;
          } else {
#line 1257
            tmp___6 = 1;
          }
#line 1257
          ret = tmp___6;
        }
      } else {
#line 1259
        tmp___8 = (char *)__builtin_alloca(m_len + 2U);
#line 1259
        w_pattern = tmp___8;
#line 1260
        if (w_pattern) {
#line 1261
          strcpy((char * __restrict  )w_pattern, (char const   * __restrict  )"*");
#line 1262
          strcat((char * __restrict  )w_pattern, (char const   * __restrict  )m_pattern);
#line 1263
          ret = fqdn_match((char const   *)w_pattern);
        }
      }
    } else {
#line 1266
      if (0) {
#line 1266
        __s1_len = strlen(m_pattern);
#line 1266
        __s2_len = strlen("gss/krb5");
#line 1266
        if (! ((unsigned int )((void const   *)(m_pattern + 1)) - (unsigned int )((void const   *)m_pattern) == 1U)) {
          goto _L___0;
        } else {
#line 1266
          if (__s1_len >= 4U) {
            _L___0: 
#line 1266
            if (! ((unsigned int )((void const   *)("gss/krb5" + 1)) - (unsigned int )((void const   *)"gss/krb5") == 1U)) {
#line 1266
              tmp___18 = 1;
            } else {
#line 1266
              if (__s2_len >= 4U) {
#line 1266
                tmp___18 = 1;
              } else {
#line 1266
                tmp___18 = 0;
              }
            }
          } else {
#line 1266
            tmp___18 = 0;
          }
        }
#line 1266
        if (tmp___18) {
#line 1266
          tmp___14 = __builtin_strcmp(m_pattern, "gss/krb5");
        } else {
#line 1266
          tmp___17 = __builtin_strcmp(m_pattern, "gss/krb5");
#line 1266
          tmp___14 = tmp___17;
        }
      } else {
#line 1266
        tmp___17 = __builtin_strcmp(m_pattern, "gss/krb5");
#line 1266
        tmp___14 = tmp___17;
      }
#line 1266
      if (tmp___14) {
#line 1273
        ret = match_network(m_pattern);
#line 1274
        if (! ret) {
#line 1276
          ret = string_match((char const   *)(myname), m_pattern);
        }
      } else {
#line 1268
        return (1);
      }
    }
  }
#line 1279
  if (negate) {
#line 1279
    if (ret) {
#line 1280
      ret = -1;
    }
  }
#line 1282
  return (ret);
}
}
#line 1285 "rpc_subs.c"
static int rpc_export_allowed(groups grouplist ) 
{ groups grp ;
  int allowed ;
  int tmp ;

  {
#line 1287
  grp = grouplist;
#line 1290
  if (! grp) {
#line 1291
    return (1);
  }
#line 1293
  while (grp) {
#line 1294
    tmp = host_match(grp->gr_name);
#line 1294
    allowed = tmp;
#line 1296
    if (allowed == -1) {
#line 1297
      return (0);
    } else {
#line 1298
      if (allowed) {
#line 1299
        return (1);
      }
    }
#line 1300
    grp = grp->gr_next;
  }
#line 1302
  return (0);
}
}
#line 1305 "rpc_subs.c"
exports rpc_exports_prune(exports list ) 
{ exports head ;
  exports exp ;
  exports last ;
  int res ;

  {
#line 1307
  head = list;
#line 1312
  exp = list;
#line 1313
  last = (struct exportnode *)((void *)0);
#line 1314
  while (exp) {
#line 1315
    res = rpc_export_allowed(exp->ex_groups);
#line 1316
    if (! res) {
#line 1317
      if ((unsigned int )last == (unsigned int )((void *)0)) {
#line 1318
        head = exp->ex_next;
#line 1319
        rpc_export_free(exp);
#line 1320
        exp = head;
      } else {
#line 1322
        last->ex_next = exp->ex_next;
#line 1323
        rpc_export_free(exp);
#line 1324
        exp = last->ex_next;
      }
#line 1326
      continue;
    }
#line 1328
    last = exp;
#line 1329
    exp = exp->ex_next;
  }
#line 1331
  return (head);
}
}
#line 1334 "rpc_subs.c"
exports rpc_get_exports(char const   *host , long seconds , long micros , unsigned int option ) 
{ struct conn_info info ;
  exports exportlist ;
  struct pmap parms ;
  int status ;

  {
#line 1341
  info.host = host;
#line 1342
  info.program = 100005UL;
#line 1343
  info.version = 1UL;
#line 1344
  info.send_sz = 0U;
#line 1345
  info.recv_sz = 0U;
#line 1346
  info.timeout.tv_sec = seconds;
#line 1347
  info.timeout.tv_usec = micros;
#line 1348
  info.close_option = option;
#line 1349
  info.client = (CLIENT *)((void *)0);
#line 1351
  parms.pm_prog = info.program;
#line 1352
  parms.pm_vers = info.version;
#line 1353
  parms.pm_port = 0UL;
#line 1356
  info.proto = getprotobyname("udp");
#line 1357
  if (! info.proto) {
    goto try_tcp;
  }
#line 1360
  parms.pm_prot = (unsigned long )(info.proto)->p_proto;
#line 1362
  info.port = rpc_portmap_getport(& info, & parms);
#line 1363
  if (! info.port) {
    goto try_tcp;
  }
#line 1366
  memset((void *)(& exportlist), '\000', sizeof(exportlist));
#line 1368
  status = rpc_get_exports_proto(& info, & exportlist);
#line 1369
  if (status) {
#line 1370
    return (exportlist);
  }
  try_tcp: 
#line 1373
  info.proto = getprotobyname("tcp");
#line 1374
  if (! info.proto) {
#line 1375
    return ((struct exportnode *)((void *)0));
  }
#line 1377
  parms.pm_prot = (unsigned long )(info.proto)->p_proto;
#line 1379
  info.port = rpc_portmap_getport(& info, & parms);
#line 1380
  if (! info.port) {
#line 1381
    return ((struct exportnode *)((void *)0));
  }
#line 1383
  memset((void *)(& exportlist), '\000', sizeof(exportlist));
#line 1385
  status = rpc_get_exports_proto(& info, & exportlist);
#line 1386
  if (! status) {
#line 1387
    return ((struct exportnode *)((void *)0));
  }
#line 1389
  return (exportlist);
}
}
#line 1 "alarm.o"
#pragma merger(0,"/tmp/cil-z9Gx37lJ.i","-O2,-Wall,-fPIC")
#line 1 "args.o"
#pragma merger(0,"/tmp/cil-1FndAHCZ.i","-O2,-Wall,-fPIC")
#line 1 "cache.o"
#pragma merger(0,"/tmp/cil-gmj5pfh8.i","-O2,-Wall,-fPIC")
#line 1 "cat_path.o"
#pragma merger(0,"/tmp/cil-s6q7zIsb.i","-O2,-Wall,-fPIC")
#line 1 "defaults.o"
#pragma merger(0,"/tmp/cil-cUKdJ7Qb.i","-O2,-Wall,-fPIC")
#line 1 "log.o"
#pragma merger(0,"/tmp/cil-EeaGHvaJ.i","-O2,-Wall,-fPIC")
#line 1 "macros.o"
#pragma merger(0,"/tmp/cil-wD2AE0BU.i","-O2,-Wall,-fPIC")
#line 1 "master.o"
#pragma merger(0,"/tmp/cil-n9cablPX.i","-O2,-Wall,-fPIC")
#line 1 "master_parse.tab.o"
#pragma merger(0,"/tmp/cil-4tcCqPvC.i","-O2,-Wall,-fPIC")
#line 1 "master_tok.o"
#pragma merger(0,"/tmp/cil-vIV2a8v5.i","-O2,-Wall,-fPIC")
#line 1 "mount_clnt.o"
#pragma merger(0,"/tmp/cil-mjhAlRUi.i","-O2,-Wall,-fPIC")
#line 1 "mount_xdr.o"
#pragma merger(0,"/tmp/cil-ibgSRb1p.i","-O2,-Wall,-fPIC,-Wno-unused-variable")
#line 1 "mounts.o"
#pragma merger(0,"/tmp/cil-9Rg6ts2G.i","-O2,-Wall,-fPIC")
#line 1 "nss_parse.tab.o"
#pragma merger(0,"/tmp/cil-f74uvPUX.i","-O2,-Wall,-fPIC")
#line 1 "nss_tok.o"
#pragma merger(0,"/tmp/cil-wIosJoid.i","-O2,-Wall,-fPIC")
#line 1 "nsswitch.o"
#pragma merger(0,"/tmp/cil-MKK6P0oB.i","-O2,-Wall,-fPIC")
#line 1 "parse_subs.o"
#pragma merger(0,"/tmp/cil-JfJlyyLC.i","-O2,-Wall,-fPIC")
#line 1 "rpc_subs.o"
#pragma merger(0,"/tmp/cil-dU7Ufpcu.i","-O2,-Wall,-fPIC")
