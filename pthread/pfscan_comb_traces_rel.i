/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

#line 4 "pfscan_comb.c"
typedef unsigned int size_t;
#line 5 "pfscan_comb.c"
typedef int __ssize_t;
#line 6 "pfscan_comb.c"
typedef __ssize_t ssize_t;
#line 7 "pfscan_comb.c"
struct __anonstruct_BM_30 {
   int *bmGs ;
   int bmBc[256] ;
   unsigned char *saved_x ;
   int saved_m ;
   int icase ;
};
#line 14 "pfscan_comb.c"
typedef struct __anonstruct_BM_30 BM;
#line 15 "pfscan_comb.c"
typedef long long __quad_t;
#line 16 "pfscan_comb.c"
typedef unsigned long long __u_quad_t;
#line 17 "pfscan_comb.c"
typedef __u_quad_t __dev_t;
#line 18 "pfscan_comb.c"
typedef unsigned int __uid_t;
#line 19 "pfscan_comb.c"
typedef unsigned int __gid_t;
#line 20 "pfscan_comb.c"
typedef unsigned long __ino_t;
#line 21 "pfscan_comb.c"
typedef unsigned int __mode_t;
#line 22 "pfscan_comb.c"
typedef unsigned int __nlink_t;
#line 23 "pfscan_comb.c"
typedef long __off_t;
#line 24 "pfscan_comb.c"
typedef __quad_t __off64_t;
#line 25 "pfscan_comb.c"
typedef unsigned long __rlim_t;
#line 26 "pfscan_comb.c"
typedef long __time_t;
#line 27 "pfscan_comb.c"
typedef long __blksize_t;
#line 28 "pfscan_comb.c"
typedef long __blkcnt_t;
#line 29
struct _IO_FILE ;
#line 30 "pfscan_comb.c"
typedef struct _IO_FILE FILE;
#line 31 "pfscan_comb.c"
typedef void _IO_lock_t;
#line 32 "pfscan_comb.c"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 37 "pfscan_comb.c"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 68 "pfscan_comb.c"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 72 "pfscan_comb.c"
typedef unsigned long pthread_t;
#line 73 "pfscan_comb.c"
union __anonunion_pthread_attr_t_14 {
   char __size[36] ;
   long __align ;
};
#line 77 "pfscan_comb.c"
typedef union __anonunion_pthread_attr_t_14 pthread_attr_t;
#line 78 "pfscan_comb.c"
struct __pthread_internal_slist {
   struct __pthread_internal_slist *__next ;
};
#line 81 "pfscan_comb.c"
typedef struct __pthread_internal_slist __pthread_slist_t;
#line 82 "pfscan_comb.c"
union __anonunion____missing_field_name_16 {
   int __spins ;
   __pthread_slist_t __list ;
};
#line 86 "pfscan_comb.c"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   int __kind ;
   unsigned int __nusers ;
   union __anonunion____missing_field_name_16 __annonCompField1 ;
};
#line 94 "pfscan_comb.c"
union __anonunion_pthread_mutex_t_15 {
   struct __pthread_mutex_s __data ;
   char __size[24] ;
   long __align ;
};
#line 99 "pfscan_comb.c"
typedef union __anonunion_pthread_mutex_t_15 pthread_mutex_t;
#line 100 "pfscan_comb.c"
union __anonunion_pthread_mutexattr_t_17 {
   char __size[4] ;
   long __align ;
};
#line 104 "pfscan_comb.c"
typedef union __anonunion_pthread_mutexattr_t_17 pthread_mutexattr_t;
#line 105 "pfscan_comb.c"
struct __anonstruct___data_19 {
   int __lock ;
   unsigned int __futex ;
   unsigned long long __total_seq ;
   unsigned long long __wakeup_seq ;
   unsigned long long __woken_seq ;
   void *__mutex ;
   unsigned int __nwaiters ;
   unsigned int __broadcast_seq ;
};
#line 115 "pfscan_comb.c"
union __anonunion_pthread_cond_t_18 {
   struct __anonstruct___data_19 __data ;
   char __size[48] ;
   long long __align ;
};
#line 120 "pfscan_comb.c"
typedef union __anonunion_pthread_cond_t_18 pthread_cond_t;
#line 121 "pfscan_comb.c"
typedef void (*__sighandler_t)(int  );
#line 122 "pfscan_comb.c"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 141 "pfscan_comb.c"
typedef __rlim_t rlim_t;
#line 142 "pfscan_comb.c"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 146 "pfscan_comb.c"
typedef int __rlimit_resource_t;
#line 147 "pfscan_comb.c"
struct __anonstruct_PQUEUE_63 {
   void **buf ;
   int qsize ;
   int occupied ;
   int nextin ;
   int nextout ;
   int closed ;
   pthread_mutex_t mtx ;
   pthread_cond_t more ;
   pthread_cond_t less ;
};
#line 158 "pfscan_comb.c"
typedef struct __anonstruct_PQUEUE_63 PQUEUE;
#line 159 "pfscan_comb.c"
union __anonunion_pthread_condattr_t_12 {
   char __size[4] ;
   long __align ;
};
#line 163 "pfscan_comb.c"
typedef union __anonunion_pthread_condattr_t_12 pthread_condattr_t;
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
/* compiler builtin: 
   void *__builtin_frob_return_address(void * ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_and_and_fetch(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_or(...) ;  */
/* compiler builtin: 
   int __builtin_popcountll(unsigned long long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_or_fetch(...) ;  */
/* compiler builtin: 
   float __builtin_atanf(float  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_addps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   unsigned long __builtin_strcspn(char const   * , char const   * ) ;  */
/* compiler builtin: 
   float __builtin_asinf(float  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_maxps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_unpckhps(float __attribute__((____vector_size____(16)))   ,
                                                                           float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   double __builtin_acos(double  ) ;  */
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_nand_fetch_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_and(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_xor_fetch_16(...) ;  */
/* compiler builtin: 
   double __builtin_cosh(double  ) ;  */
/* compiler builtin: 
   float __builtin_tanhf(float  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_nand_16(...) ;  */
/* compiler builtin: 
   void *__builtin_mempcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_sub_fetch_1(...) ;  */
/* compiler builtin: 
   long double __builtin_sqrtl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_parity(unsigned int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_or(...) ;  */
/* compiler builtin: 
   long double __builtin_coshl(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_cosl(long double  ) ;  */
/* compiler builtin: 
   float __builtin_cosf(float  ) ;  */
/* compiler builtin: 
   void __sync_synchronize(...) ;  */
/* compiler builtin: 
   long double __builtin_acosl(long double  ) ;  */
/* compiler builtin: 
   void *__builtin___mempcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_or_and_fetch(...) ;  */
/* compiler builtin: 
   int __builtin_clz(unsigned int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_nand_fetch_4(...) ;  */
/* compiler builtin: 
   double __builtin_log10(double  ) ;  */
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   float __builtin_modff(float  , float * ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_sub_fetch_4(...) ;  */
/* compiler builtin: 
   _Bool __atomic_compare_exchange_n(...) ;  */
/* compiler builtin: 
   double __builtin_sin(double  ) ;  */
/* compiler builtin: 
   double __builtin_frexp(double  , int * ) ;  */
/* compiler builtin: 
   float __builtin_acosf(float  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_add_and_fetch(...) ;  */
/* compiler builtin: 
   long double __builtin_sinhl(long double  ) ;  */
/* compiler builtin: 
   char *__builtin___stpcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void __atomic_signal_fence(int  ) ;  */
/* compiler builtin: 
   double __builtin_fabs(double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_nand_1(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_and_fetch_16(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_nand(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_xor_fetch_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_xor_fetch_2(...) ;  */
/* compiler builtin: 
   void __atomic_thread_fence(int  ) ;  */
/* compiler builtin: 
   void __atomic_store_16(...) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_and_8(...) ;  */
/* compiler builtin: 
   short __builtin_bswap16(short  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_and_fetch_2(...) ;  */
/* compiler builtin: 
   _Bool __atomic_test_and_set(void * , int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_add_8(...) ;  */
/* compiler builtin: 
   int __builtin_ctz(unsigned int  ) ;  */
/* compiler builtin: 
   char *__builtin_strpbrk(char const   * , char const   * ) ;  */
/* compiler builtin: 
   char *__builtin_strcpy(char * , char const   * ) ;  */
/* compiler builtin: 
   double __builtin_sqrt(double  ) ;  */
/* compiler builtin: 
   __builtin_va_list __builtin_next_arg(void) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_nand(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_exchange_16(...) ;  */
/* compiler builtin: 
   void __atomic_clear(_Bool * , int  ) ;  */
/* compiler builtin: 
   void __atomic_store(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_add_fetch_2(...) ;  */
/* compiler builtin: 
   float __builtin_log10f(float  ) ;  */
/* compiler builtin: 
   long double __builtin_fabsl(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_floorl(long double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_xor_1(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_and_fetch(...) ;  */
/* compiler builtin: 
   float __builtin_floorf(float  ) ;  */
/* compiler builtin: 
   _Bool __atomic_compare_exchange_4(...) ;  */
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_sub_and_fetch(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_nand_and_fetch(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_load_16(...) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_subps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   int __builtin_parityll(unsigned long long  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_bzero(void * , unsigned long  ) ;  */
/* compiler builtin: 
   _Bool __atomic_always_lock_free(unsigned long  , void * ) ;  */
/* compiler builtin: 
   int __builtin_strncmp(char const   * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_nand_fetch_16(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_xor_and_fetch(...) ;  */
/* compiler builtin: 
   int __builtin___vsprintf_chk(char * , int  , unsigned long  , char const   * ,
                                __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __builtin_sqrtf(float  ) ;  */
/* compiler builtin: 
   double __builtin_nans(char const   * ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_xor_8(...) ;  */
/* compiler builtin: 
   double __builtin_exp(double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_exchange_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_exchange_1(...) ;  */
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
/* compiler builtin: 
   float __builtin_ldexpf(float  , int  ) ;  */
/* compiler builtin: 
   float __builtin_powif(float  , int  ) ;  */
/* compiler builtin: 
   long double __builtin_log10l(long double  ) ;  */
/* compiler builtin: 
   void *__builtin___memmove_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_and(...) ;  */
/* compiler builtin: 
   void *__builtin_return_address(unsigned int  ) ;  */
/* compiler builtin: 
   void __atomic_feraiseexcept(int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_and_fetch_4(...) ;  */
/* compiler builtin: 
   float __builtin_fabsf(float  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_or_fetch_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_or_fetch_4(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_or_fetch_1(...) ;  */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack_len(void) ;  */
/* compiler builtin: 
   long double __builtin_tanl(long double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_and_2(...) ;  */
/* compiler builtin: 
   void __sync_lock_release(...) ;  */
/* compiler builtin: 
   long double __builtin_modfl(long double  , long double * ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_nand_8(...) ;  */
/* compiler builtin: 
   char *__builtin_stpcpy(char * , char const   * ) ;  */
/* compiler builtin: 
   long double __builtin_sinl(long double  ) ;  */
/* compiler builtin: 
   double __builtin_asin(double  ) ;  */
/* compiler builtin: 
   float __builtin_sinhf(float  ) ;  */
/* compiler builtin: 
   int __builtin_ctzl(unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_tanhl(long double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_add(...) ;  */
/* compiler builtin: 
   long __builtin_bswap64(long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_nand_fetch_1(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_nand_2(...) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_mulps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   double __builtin_tan(double  ) ;  */
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   float __builtin_inff(void) ;  */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_load_n(...) ;  */
/* compiler builtin: 
   double __builtin_huge_val(void) ;  */
/* compiler builtin: 
   int __builtin_clzl(unsigned long  ) ;  */
/* compiler builtin: 
   _Bool __atomic_compare_exchange_16(...) ;  */
/* compiler builtin: 
   float __builtin_frexpf(float  , int * ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_exchange_n(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_or_1(...) ;  */
/* compiler builtin: 
   long double __builtin_fmodl(long double  ) ;  */
/* compiler builtin: 
   double __builtin_atan(double  ) ;  */
/* compiler builtin: 
   int __builtin___fprintf_chk(void * , int  , char const   *  , ...) ;  */
/* compiler builtin: 
   float __builtin_ceilf(float  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_or_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_add_1(...) ;  */
/* compiler builtin: 
   void __builtin_return(void const   * ) ;  */
/* compiler builtin: 
   long double __builtin_asinl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_ffsll(unsigned long long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_sub_1(...) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_or_4(...) ;  */
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_powi(double  , int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_load_2(...) ;  */
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
/* compiler builtin: 
   char *__builtin___strncat_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   void __atomic_store_2(...) ;  */
/* compiler builtin: 
   long double __builtin_huge_vall(void) ;  */
/* compiler builtin: 
   int __builtin_ffsl(unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin___vprintf_chk(int  , char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_unpcklps(float __attribute__((____vector_size____(16)))   ,
                                                                           float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   char *__builtin_strncat(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin_ctzll(unsigned long long  ) ;  */
/* compiler builtin: 
   void __builtin_stdarg_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_exchange_4(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_xor(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_sub_4(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_and_4(...) ;  */
/* compiler builtin: 
   long double __builtin_frexpl(long double  , int * ) ;  */
/* compiler builtin: 
   _Bool __atomic_compare_exchange(...) ;  */
/* compiler builtin: 
   float __builtin_tanf(float  ) ;  */
/* compiler builtin: 
   long double __builtin_logl(long double  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_load_1(...) ;  */
/* compiler builtin: 
   _Bool __atomic_compare_exchange_1(...) ;  */
/* compiler builtin: 
   int __builtin___printf_chk(int  , char const   *  , ...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_xor_2(...) ;  */
/* compiler builtin: 
   int __builtin___vfprintf_chk(void * , int  , char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_prefetch(void const   *  , ...) ;  */
/* compiler builtin: 
   long double __builtin_nansl(char const   * ) ;  */
/* compiler builtin: 
   double __builtin_fmod(double  ) ;  */
/* compiler builtin: 
   void __atomic_load(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_or_fetch_16(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_add_fetch_16(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_val_compare_and_swap(...) ;  */
/* compiler builtin: 
   void __atomic_store_4(...) ;  */
/* compiler builtin: 
   double __builtin_tanh(double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_and_1(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_nand_4(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_add_16(...) ;  */
/* compiler builtin: 
   void __builtin_unreachable(void) ;  */
/* compiler builtin: 
   _Bool __atomic_compare_exchange_2(...) ;  */
/* compiler builtin: 
   long double __builtin_ldexpl(long double  , int  ) ;  */
/* compiler builtin: 
   void *__builtin_apply(void (*)() , void * , unsigned long  ) ;  */
/* compiler builtin: 
   float __builtin_sinf(float  ) ;  */
/* compiler builtin: 
   double __builtin_ceil(double  ) ;  */
/* compiler builtin: 
   void __atomic_exchange(...) ;  */
/* compiler builtin: 
   long double __builtin_powil(long double  , int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_sub_fetch_8(...) ;  */
/* compiler builtin: 
   long double __builtin_expl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_constant_p(int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_sub_16(...) ;  */
/* compiler builtin: 
   double __builtin_log(double  ) ;  */
/* compiler builtin: 
   float __builtin_expf(float  ) ;  */
/* compiler builtin: 
   int __builtin_types_compatible_p(unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_atan2l(long double  , long double  ) ;  */
/* compiler builtin: 
   void *__builtin_apply_args(void) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_exchange_2(...) ;  */
/* compiler builtin: 
   float __builtin_logf(float  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_sub_fetch_2(...) ;  */
/* compiler builtin: 
   unsigned long __builtin_strlen(char const   * ) ;  */
/* compiler builtin: 
   int __builtin_ffs(unsigned int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_xor_16(...) ;  */
/* compiler builtin: 
   double __builtin_inf(void) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_or_16(...) ;  */
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_load_4(...) ;  */
/* compiler builtin: 
   void __atomic_store_n(...) ;  */
/* compiler builtin: 
   void __builtin_trap(void) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_add_4(...) ;  */
/* compiler builtin: 
   int __builtin_parityl(unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_nand_fetch_2(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_lock_test_and_set(...) ;  */
/* compiler builtin: 
   unsigned long __builtin_strspn(char const   * , char const   * ) ;  */
/* compiler builtin: 
   void __builtin_varargs_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_sub_fetch(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_and_16(...) ;  */
/* compiler builtin: 
   _Bool __atomic_compare_exchange_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_nand_fetch(...) ;  */
/* compiler builtin: 
   double __builtin_nan(char const   * ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_load_8(...) ;  */
/* compiler builtin: 
   int __builtin___snprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                char const   *  , ...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_xor_fetch_4(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_sub_2(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_add_fetch(...) ;  */
/* compiler builtin: 
   long double __builtin_atanl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_clzll(unsigned long long  ) ;  */
/* compiler builtin: 
   float __builtin_huge_valf(void) ;  */
/* compiler builtin: 
   float __builtin_coshf(float  ) ;  */
/* compiler builtin: 
   float __builtin_nansf(char const   * ) ;  */
/* compiler builtin: 
   void __atomic_store_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_xor_fetch(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_add(...) ;  */
/* compiler builtin: 
   int __builtin___vsnprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                 char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __builtin_nanf(char const   * ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_or_fetch_2(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_add_fetch_1(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_xor(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_add_fetch_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_xor_4(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_sub_8(...) ;  */
/* compiler builtin: 
   _Bool __sync_bool_compare_and_swap(...) ;  */
/* compiler builtin: 
   double __builtin_atan2(double  , double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __builtin_tgmath(...) ;  */
/* compiler builtin: 
   int __builtin_popcountl(unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_and_fetch_1(...) ;  */
/* compiler builtin: 
   long double __builtin_ceill(long double  ) ;  */
/* compiler builtin: 
   void __atomic_store_1(...) ;  */
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_xor_fetch_1(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_or_2(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_sub_fetch_16(...) ;  */
/* compiler builtin: 
   double __builtin_floor(double  ) ;  */
/* compiler builtin: 
   double __builtin_cos(double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_sub(...) ;  */
/* compiler builtin: 
   void *__builtin_memset(void * , int  , int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_add_2(...) ;  */
/* compiler builtin: 
   long double __builtin_nanl(char const   * ) ;  */
/* compiler builtin: 
   float __builtin_atan2f(float  , float  ) ;  */
/* compiler builtin: 
   _Bool __atomic_is_lock_free(unsigned long  , void * ) ;  */
/* compiler builtin: 
   int __builtin_popcount(unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_sinh(double  ) ;  */
/* compiler builtin: 
   void __builtin_bcopy(void const   * , void * , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_and_fetch_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_sub(...) ;  */
/* compiler builtin: 
   void *__builtin_extract_return_addr(void * ) ;  */
/* compiler builtin: 
   int __builtin_bswap32(int  ) ;  */
/* compiler builtin: 
   double __builtin_ldexp(double  , int  ) ;  */
/* compiler builtin: 
   long double __builtin_infl(void) ;  */
/* compiler builtin: 
   float __builtin_fmodf(float  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_add_fetch_4(...) ;  */
/* compiler builtin: 
   void *__builtin_frame_address(unsigned int  ) ;  */
#line 164
#pragma merger(0,"/tmp/cil-2xopH8kW.i","")
#line 165
extern void *malloc(size_t __size )  __attribute__((__nothrow__, __malloc__)) ;
#line 166
extern void *calloc(size_t __nmemb , size_t __size )  __attribute__((__nothrow__,
__malloc__)) ;
#line 167
extern void free(void *__ptr )  __attribute__((__nothrow__)) ;
#line 168
extern int tolower(int __c )  __attribute__((__nothrow__)) ;
#line 169
extern void *( __attribute__((__nonnull__(1))) memset)(void *__s , int __c , size_t __n )  __attribute__((__nothrow__)) ;
#line 170
int bm_init(BM *bmp , unsigned char *x , int m , int icase ) ;
#line 171
int bm_search(BM *bmp , unsigned char *y , size_t n , int (*mfun)(unsigned char *buf ,
                                                                  size_t n , size_t pos ,
                                                                  void *misc ) , void *misc ) ;
#line 174
void bm_destroy(BM *bmp ) ;
#line 175
int debug ;
#line 176 "pfscan_comb.c"
static void preBmBc(unsigned char *x , int m , int *bmBc ) 
{ 
  int i ;

  {
  {
#line 180
  i = 0;
  }
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (! (i < 256)) {
#line 181
      goto while_break;
    }
    {
#line 182
    *(bmBc + i) = m;
#line 183
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 185
  i = 0;
  }
  {
#line 186
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 186
    if (! (i < m - 1)) {
#line 186
      goto while_break___0;
    }
    {
#line 187
    *(bmBc + (int )*(x + i)) = (m - i) - 1;
#line 188
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 190
  return;
}
}
#line 193 "pfscan_comb.c"
static void suffixes(unsigned char *x , int m , int *suff ) 
{ 
  int f ;
  int g ;
  int i ;

  {
  {
#line 199
  f = 0;
#line 200
  *(suff + (m - 1)) = m;
#line 201
  g = m - 1;
#line 202
  i = m - 2;
  }
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (! (i >= 0)) {
#line 203
      goto while_break;
    }
#line 204
    if (i > g) {
#line 205
      if (*(suff + (((i + m) - 1) - f)) < i - g) {
        {
#line 206
        *(suff + i) = *(suff + (((i + m) - 1) - f));
        }
      } else {
#line 208
        goto _L;
      }
    } else {
      _L: 
#line 212
      if (i < g) {
        {
#line 213
        g = i;
        }
      }
      {
#line 215
      f = i;
      }
      {
#line 216
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 217
        if (g >= 0) {
#line 218
          if (! ((int )*(x + g) == (int )*(x + (((g + m) - 1) - f)))) {
#line 219
            goto while_break___0;
          }
        } else {
#line 222
          goto while_break___0;
        }
        {
#line 224
        g --;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 226
      *(suff + i) = f - g;
      }
    }
    {
#line 228
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 230
  return;
}
}
#line 233 "pfscan_comb.c"
static int preBmGs(unsigned char *x , int m , int *bmGs ) 
{ 
  int *suff ;
  int i ;
  int j ;
  void *tmp ;

  {
  {
#line 240
  tmp = calloc((size_t )sizeof(int ), (unsigned int )m);
#line 241
  suff = (int *)tmp;
  }
#line 242
  if ((unsigned int )suff == (unsigned int )((void *)0)) {
#line 243
    return (-1);
  }
  {
#line 245
  suffixes(x, m, suff);
#line 246
  i = 0;
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! (i < m)) {
#line 247
      goto while_break;
    }
    {
#line 248
    *(bmGs + i) = m;
#line 249
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 251
  j = 0;
#line 252
  i = m - 1;
  }
  {
#line 253
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 253
    if (! (i >= -1)) {
#line 253
      goto while_break___0;
    }
#line 254
    if (i == -1) {
#line 255
      goto _L;
    } else
#line 257
    if (*(suff + i) == i + 1) {
      _L: 
      {
#line 259
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 259
        if (! (j < (m - 1) - i)) {
#line 259
          goto while_break___1;
        }
#line 260
        if (*(bmGs + j) == m) {
          {
#line 261
          *(bmGs + j) = (m - 1) - i;
          }
        }
        {
#line 263
        j ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 267
    i --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 269
  i = 0;
  }
  {
#line 270
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 270
    if (! (i <= m - 2)) {
#line 270
      goto while_break___2;
    }
    {
#line 271
    *(bmGs + ((m - 1) - *(suff + i))) = (m - 1) - i;
#line 272
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 274
  free((void *)suff);
  }
#line 275
  return (0);
}
}
#line 278 "pfscan_comb.c"
int bm_init(BM *bmp , unsigned char *x , int m , int icase ) 
{ 
  int i ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 286
  memset((void *)bmp, 0, (size_t )sizeof(bmp));
#line 287
  bmp->icase = icase;
#line 288
  tmp = calloc((size_t )sizeof(int ), (unsigned int )m);
#line 289
  bmp->bmGs = (int *)tmp;
  }
#line 290
  if ((unsigned int )bmp->bmGs == (unsigned int )((void *)0)) {
#line 291
    return (-1);
  }
  {
#line 293
  bmp->saved_m = m;
#line 294
  tmp___0 = malloc((unsigned int )m);
#line 295
  bmp->saved_x = (unsigned char *)tmp___0;
  }
#line 296
  if ((unsigned int )bmp->saved_x == (unsigned int )((void *)0)) {
#line 297
    return (-2);
  }
  {
#line 299
  i = 0;
  }
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 300
    if (! (i < m)) {
#line 300
      goto while_break;
    }
#line 301
    if (icase) {
      {
#line 302
      tmp___1 = tolower((int )*(x + i));
#line 303
      *(bmp->saved_x + i) = (unsigned char )tmp___1;
      }
    } else {
      {
#line 305
      *(bmp->saved_x + i) = *(x + i);
      }
    }
    {
#line 307
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 309
  tmp___2 = preBmGs(bmp->saved_x, m, bmp->bmGs);
  }
#line 310
  if (tmp___2 < 0) {
#line 311
    return (-3);
  }
  {
#line 313
  preBmBc(bmp->saved_x, m, bmp->bmBc);
  }
#line 314
  return (0);
}
}
#line 317 "pfscan_comb.c"
void bm_destroy(BM *bmp ) 
{ 


  {
#line 321
  if (bmp->bmGs) {
    {
#line 322
    free((void *)bmp->bmGs);
    }
  }
#line 324
  if (bmp->saved_x) {
    {
#line 325
    free((void *)bmp->saved_x);
    }
  }
#line 327
  return;
}
}
#line 330 "pfscan_comb.c"
int bm_search(BM *bmp , unsigned char *y , size_t n , int (*mfun)(unsigned char *buf ,
                                                                  size_t n , size_t pos ,
                                                                  void *misc ) , void *misc ) 
{ 
  ssize_t i ;
  ssize_t j ;
  int c ;
  int nm ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned char c___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 347
  nm = 0;
#line 348
  j = 0;
  }
  {
#line 349
  while (1) {
    while_continue: /* CIL Label */ ;
#line 349
    if (! ((size_t )j <= n - (size_t )bmp->saved_m)) {
#line 349
      goto while_break;
    }
    {
#line 350
    i = bmp->saved_m - 1;
    }
    {
#line 351
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 352
      if (i >= 0) {
#line 353
        if (bmp->icase) {
          {
#line 354
          tmp = tolower((int )*(y + (i + j)));
#line 355
          tmp___0 = tmp;
          }
        } else {
          {
#line 357
          tmp___0 = (int )*(y + (i + j));
          }
        }
#line 359
        if (! ((int )*(bmp->saved_x + i) == tmp___0)) {
#line 360
          goto while_break___0;
        }
      } else {
#line 363
        goto while_break___0;
      }
      {
#line 365
      i --;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 367
    if (i < 0) {
#line 368
      if (mfun) {
        {
#line 369
        nm ++;
#line 370
        c = (*mfun)(y, n, (unsigned int )j, misc);
        }
#line 371
        if (c) {
#line 372
          if (c < 0) {
            {
#line 373
            tmp___1 = c;
            }
          } else {
            {
#line 375
            tmp___1 = nm;
            }
          }
#line 377
          return (tmp___1);
        }
        {
#line 379
        j += *(bmp->bmGs + 0);
        }
      } else {
#line 381
        return (j);
      }
    } else {
#line 384
      if (bmp->icase) {
        {
#line 385
        tmp___2 = tolower((int )*(y + (i + j)));
#line 386
        tmp___3 = tmp___2;
        }
      } else {
        {
#line 388
        tmp___3 = (int )*(y + (i + j));
        }
      }
      {
#line 390
      c___0 = (unsigned char )tmp___3;
      }
#line 391
      if (*(bmp->bmGs + i) < ((bmp->bmBc[c___0] - bmp->saved_m) + 1) + i) {
        {
#line 392
        tmp___4 = ((bmp->bmBc[c___0] - bmp->saved_m) + 1) + i;
        }
      } else {
        {
#line 394
        tmp___4 = *(bmp->bmGs + i);
        }
      }
      {
#line 396
      j += tmp___4;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 399
  if ((unsigned int )mfun == (unsigned int )((void *)0)) {
    {
#line 400
    tmp___5 = -1;
    }
  } else {
    {
#line 402
    tmp___5 = nm;
    }
  }
#line 404
  return (tmp___5);
}
}
#line 407
#pragma merger(0,"/tmp/cil-bFpgwBOh.i","")
#line 408
extern struct _IO_FILE *stdout ;
#line 409
extern struct _IO_FILE *stderr ;
#line 410
extern int fflush(FILE *__stream ) ;
#line 411
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 413
extern int printf(char const   * __restrict  __format  , ...) ;
#line 414
extern int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                  , ...)  __attribute__((__nothrow__)) ;
#line 416
extern int putchar(int __c ) ;
#line 417
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 418
extern void exit(int __status )  __attribute__((__nothrow__, __noreturn__)) ;
#line 419
extern int *__errno_location(void)  __attribute__((__nothrow__, __const__)) ;
#line 420
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 421
extern int toupper(int __c )  __attribute__((__nothrow__)) ;
#line 422
extern char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__nothrow__,
__malloc__)) ;
#line 424
extern char *strerror(int __errnum )  __attribute__((__nothrow__)) ;
#line 425
extern __sighandler_t signal(int __sig , void (*__handler)(int  ) )  __attribute__((__nothrow__)) ;
#line 426
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 427
__inline static int ( __attribute__((__nonnull__(2))) fstat)(int __fd , struct stat *__statbuf )  __attribute__((__nothrow__)) ;
#line 428
extern int ( __attribute__((__nonnull__(3))) __fxstat)(int __ver , int __fildes ,
                                                       struct stat *__stat_buf )  __attribute__((__nothrow__)) ;
#line 430
__inline static int ( __attribute__((__nonnull__(2))) fstat)(int __fd , struct stat *__statbuf )  __attribute__((__nothrow__)) ;
#line 430 "pfscan_comb.c"
__inline static int ( __attribute__((__nonnull__(2))) fstat)(int __fd , struct stat *__statbuf ) 
{ 
  int tmp ;

  {
  {
#line 434
  tmp = __fxstat(3, __fd, __statbuf);
  }
#line 435
  return (tmp);
}
}
#line 438
int ( __attribute__((__nonnull__(1,2))) ftw)(char const   *dir , int (*fn)(char const   *file ,
                                                                           struct stat  const  *sb ,
                                                                           int flag ) ,
                                             int nopenfd ) ;
#line 440
extern char *setlocale(int __category , char const   *__locale )  __attribute__((__nothrow__)) ;
#line 441
extern void *mmap(void *__addr , size_t __len , int __prot , int __flags , int __fd ,
                  __off_t __offset )  __attribute__((__nothrow__)) ;
#line 443
extern int munmap(void *__addr , size_t __len )  __attribute__((__nothrow__)) ;
#line 444
extern int getrlimit(__rlimit_resource_t __resource , struct rlimit *__rlimits )  __attribute__((__nothrow__)) ;
#line 446
extern int setrlimit(__rlimit_resource_t __resource , struct rlimit  const  *__rlimits )  __attribute__((__nothrow__)) ;
#line 448
extern int close(int __fd ) ;
#line 449
extern int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                               pthread_attr_t const   * __restrict  __attr ,
                                                               void *(*__start_routine)(void * ) ,
                                                               void * __restrict  __arg )  __attribute__((__nothrow__)) ;
#line 453
extern int ( __attribute__((__nonnull__(1))) pthread_attr_init)(pthread_attr_t *__attr )  __attribute__((__nothrow__)) ;
#line 454
extern int ( __attribute__((__nonnull__(1))) pthread_attr_setscope)(pthread_attr_t *__attr ,
                                                                    int __scope )  __attribute__((__nothrow__)) ;
#line 456
extern int ( __attribute__((__nonnull__(1))) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                 pthread_mutexattr_t const   *__mutexattr )  __attribute__((__nothrow__)) ;
#line 458
extern int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex )  __attribute__((__nothrow__)) ;
#line 459
extern int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex )  __attribute__((__nothrow__)) ;
#line 460
extern int ( __attribute__((__nonnull__(1))) pthread_cond_signal)(pthread_cond_t *__cond )  __attribute__((__nothrow__)) ;
#line 461
extern int ( __attribute__((__nonnull__(1,2))) pthread_cond_wait)(pthread_cond_t * __restrict  __cond ,
                                                                  pthread_mutex_t * __restrict  __mutex ) ;
#line 462
int pqueue_init(PQUEUE *qp , int qsize ) ;
#line 463
int pqueue_put(PQUEUE *qp , void *item ) ;
#line 464
int pqueue_get(PQUEUE *qp , void **item ) ;
#line 465
void pqueue_close(PQUEUE *qp ) ;
#line 466
char version[4] ;
#line 467 "pfscan_comb.c"
char *argv0  =    "pfscan";
#line 468 "pfscan_comb.c"
int max_depth  =    64;
#line 469 "pfscan_comb.c"
unsigned char *rstr  =    (unsigned char *)((void *)0);
#line 470 "pfscan_comb.c"
int rlen  =    0;
#line 471 "pfscan_comb.c"
int debug  =    0;
#line 472 "pfscan_comb.c"
int verbose  =    0;
#line 473 "pfscan_comb.c"
int nworkers  =    0;
#line 474 "pfscan_comb.c"
int aworkers  =    0;
#line 475 "pfscan_comb.c"
pthread_mutex_t aworker_lock  ;
#line 476 "pfscan_comb.c"
pthread_cond_t aworker_cv  ;
#line 477 "pfscan_comb.c"
int line_f  =    0;
#line 478 "pfscan_comb.c"
int maxlen  =    64;
#line 479 "pfscan_comb.c"
int ignore_case  =    0;
#line 480 "pfscan_comb.c"
int n_matches  =    0;
#line 481 "pfscan_comb.c"
int n_files  =    0;
#line 482 "pfscan_comb.c"
size_t n_bytes  =    (size_t )0;
#line 483 "pfscan_comb.c"
pthread_mutex_t matches_lock  ;
#line 484 "pfscan_comb.c"
PQUEUE pqb  ;
#line 485 "pfscan_comb.c"
pthread_mutex_t print_lock  ;
#line 486 "pfscan_comb.c"
BM bmb  ;
#line 487 "pfscan_comb.c"
void print_version(FILE *fp ) 
{ 


  {
  {
#line 491
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"[PFScan, version %s - %s %s]\n",
          version, "Feb  1 2008", "15:56:16");
  }
#line 493
  return;
}
}
#line 496 "pfscan_comb.c"
int get_char_code(unsigned char **cp , int base ) 
{ 
  int val ;
  int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 509
  val = 0;
#line 510
  len = 0;
  }
  {
#line 511
  while (1) {
    while_continue: /* CIL Label */ ;
#line 512
    if (base == 16) {
      {
#line 513
      tmp___3 = 2;
      }
    } else {
      {
#line 515
      tmp___3 = 3;
      }
    }
#line 517
    if (len < tmp___3) {
#line 518
      if ((int )*(*cp) >= 48) {
#line 519
        if (base > 10) {
          {
#line 520
          tmp___4 = 10;
          }
        } else {
          {
#line 522
          tmp___4 = base;
          }
        }
#line 524
        if (! ((int )*(*cp) < 48 + tmp___4)) {
#line 525
          goto _L___0;
        }
      } else
      _L___0: 
#line 529
      if (base >= 10) {
        {
#line 530
        tmp___5 = toupper((int )*(*cp));
        }
#line 531
        if (tmp___5 >= 65) {
          {
#line 532
          tmp___6 = toupper((int )*(*cp));
          }
#line 533
          if (! (tmp___6 < (65 + base) - 10)) {
#line 534
            goto while_break;
          }
        } else {
#line 537
          goto while_break;
        }
      } else {
#line 540
        goto while_break;
      }
    } else {
#line 544
      goto while_break;
    }
    {
#line 546
    val *= base;
    }
#line 547
    if ((int )*(*cp) >= 48) {
#line 548
      if (base > 10) {
        {
#line 549
        tmp___2 = 10;
        }
      } else {
        {
#line 551
        tmp___2 = base;
        }
      }
#line 553
      if ((int )*(*cp) < 48 + tmp___2) {
        {
#line 554
        val += (int )*(*cp) - 48;
        }
      } else {
#line 556
        goto _L;
      }
    } else
    _L: 
#line 560
    if (base >= 10) {
      {
#line 561
      tmp___0 = toupper((int )*(*cp));
      }
#line 562
      if (tmp___0 >= 65) {
        {
#line 563
        tmp___1 = toupper((int )*(*cp));
        }
#line 564
        if (tmp___1 < (65 + base) - 10) {
          {
#line 565
          tmp = toupper((int )*(*cp));
#line 566
          val += (tmp - 65) + 10;
          }
        }
      }
    }
    {
#line 571
    (*cp) ++;
#line 572
    len ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 574
  return (val & 255);
}
}
#line 577 "pfscan_comb.c"
int dehex(unsigned char *str ) 
{ 
  unsigned char *wp ;
  unsigned char *rp ;
  int val ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned char *tmp___1 ;

  {
  {
#line 586
  wp = str;
#line 587
  rp = wp;
  }
  {
#line 588
  while (1) {
    while_continue: /* CIL Label */ ;
#line 588
    if (! *rp) {
#line 588
      goto while_break;
    }
    {
#line 589
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 590
      if (*rp) {
        {
#line 591
        tmp = __ctype_b_loc();
        }
#line 592
        if (! ((int const   )*(*tmp + (int )*rp) & 8192)) {
#line 593
          goto while_break___0;
        }
      } else {
#line 596
        goto while_break___0;
      }
      {
#line 598
      rp ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 600
    if ((int )*rp == 0) {
#line 601
      goto while_break;
    }
    {
#line 603
    tmp___0 = __ctype_b_loc();
    }
#line 604
    if (! ((int const   )*(*tmp___0 + (int )*rp) & 4096)) {
#line 605
      return (-1);
    }
    {
#line 607
    val = get_char_code(& rp, 16);
#line 608
    tmp___1 = wp;
#line 609
    wp ++;
#line 610
    *tmp___1 = (unsigned char )val;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 612
  *wp = (unsigned char )'\000';
  }
#line 613
  return ((int )(wp - str));
}
}
#line 616 "pfscan_comb.c"
int deslash(unsigned char *str ) 
{ 
  unsigned char *wp ;
  unsigned char *rp ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  int tmp___6 ;
  unsigned char *tmp___7 ;
  int tmp___8 ;
  unsigned char *tmp___9 ;
  int tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned char *tmp___12 ;

  {
  {
#line 635
  wp = str;
#line 636
  rp = wp;
  }
  {
#line 637
  while (1) {
    while_continue: /* CIL Label */ ;
#line 637
    if (! *rp) {
#line 637
      goto while_break;
    }
#line 638
    if ((int )*rp != 92) {
      {
#line 639
      tmp = wp;
#line 640
      wp ++;
#line 641
      tmp___0 = rp;
#line 642
      rp ++;
#line 643
      *tmp = *tmp___0;
      }
    } else {
      {
#line 645
      rp ++;
      }
      {
#line 647
      if ((int )*rp == 110) {
#line 647
        goto case_110;
      }
#line 653
      if ((int )*rp == 114) {
#line 653
        goto case_114;
      }
#line 659
      if ((int )*rp == 116) {
#line 659
        goto case_116;
      }
#line 665
      if ((int )*rp == 98) {
#line 665
        goto case_98;
      }
#line 671
      if ((int )*rp == 120) {
#line 671
        goto case_120;
      }
#line 678
      if ((int )*rp == 48) {
#line 678
        goto case_48;
      }
#line 692
      if ((int )*rp == 57) {
#line 692
        goto case_57;
      }
#line 692
      if ((int )*rp == 56) {
#line 692
        goto case_57;
      }
#line 692
      if ((int )*rp == 55) {
#line 692
        goto case_57;
      }
#line 692
      if ((int )*rp == 54) {
#line 692
        goto case_57;
      }
#line 692
      if ((int )*rp == 53) {
#line 692
        goto case_57;
      }
#line 692
      if ((int )*rp == 52) {
#line 692
        goto case_57;
      }
#line 692
      if ((int )*rp == 51) {
#line 692
        goto case_57;
      }
#line 692
      if ((int )*rp == 50) {
#line 692
        goto case_57;
      }
#line 692
      if ((int )*rp == 49) {
#line 692
        goto case_57;
      }
#line 698
      goto switch_default;
      case_110: /* CIL Label */ 
      {
#line 648
      tmp___1 = wp;
#line 649
      wp ++;
#line 650
      *tmp___1 = (unsigned char)10;
#line 651
      rp ++;
      }
#line 652
      goto switch_break;
      case_114: /* CIL Label */ 
      {
#line 654
      tmp___2 = wp;
#line 655
      wp ++;
#line 656
      *tmp___2 = (unsigned char)13;
#line 657
      rp ++;
      }
#line 658
      goto switch_break;
      case_116: /* CIL Label */ 
      {
#line 660
      tmp___3 = wp;
#line 661
      wp ++;
#line 662
      *tmp___3 = (unsigned char)9;
#line 663
      rp ++;
      }
#line 664
      goto switch_break;
      case_98: /* CIL Label */ 
      {
#line 666
      tmp___4 = wp;
#line 667
      wp ++;
#line 668
      *tmp___4 = (unsigned char)8;
#line 669
      rp ++;
      }
#line 670
      goto switch_break;
      case_120: /* CIL Label */ 
      {
#line 672
      rp ++;
#line 673
      tmp___5 = wp;
#line 674
      wp ++;
#line 675
      tmp___6 = get_char_code(& rp, 16);
#line 676
      *tmp___5 = (unsigned char )tmp___6;
      }
#line 677
      goto switch_break;
      case_48: /* CIL Label */ 
      {
#line 679
      tmp___7 = wp;
#line 680
      wp ++;
#line 681
      tmp___8 = get_char_code(& rp, 8);
#line 682
      *tmp___7 = (unsigned char )tmp___8;
      }
#line 683
      goto switch_break;
      case_57: /* CIL Label */ 
      case_56: /* CIL Label */ 
      case_55: /* CIL Label */ 
      case_54: /* CIL Label */ 
      case_53: /* CIL Label */ 
      case_52: /* CIL Label */ 
      case_51: /* CIL Label */ 
      case_50: /* CIL Label */ 
      case_49: /* CIL Label */ 
      {
#line 693
      tmp___9 = wp;
#line 694
      wp ++;
#line 695
      tmp___10 = get_char_code(& rp, 10);
#line 696
      *tmp___9 = (unsigned char )tmp___10;
      }
#line 697
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 699
      tmp___11 = wp;
#line 700
      wp ++;
#line 701
      tmp___12 = rp;
#line 702
      rp ++;
#line 703
      *tmp___11 = *tmp___12;
      }
#line 704
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 708
  *wp = (unsigned char )'\000';
  }
#line 709
  return ((int )(wp - str));
}
}
#line 712 "pfscan_comb.c"
int is_text(unsigned char *cp , int slen ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 716
  while (1) {
    while_continue: /* CIL Label */ ;
#line 717
    if (slen > 0) {
      {
#line 718
      tmp = __ctype_b_loc();
      }
#line 719
      if (! ((int const   )*(*tmp + (int )*cp) & 16384)) {
#line 720
        if (! ((int )*cp == 0)) {
#line 721
          if (! ((int )*cp == 9)) {
#line 722
            if (! ((int )*cp == 10)) {
#line 723
              if (! ((int )*cp == 13)) {
#line 724
                goto while_break;
              }
            }
          }
        }
      }
    } else {
#line 731
      goto while_break;
    }
    {
#line 733
    slen --;
#line 734
    cp ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 736
  return (slen == 0);
}
}
#line 739 "pfscan_comb.c"
size_t print_output(unsigned char *str , size_t slen ) 
{ 
  size_t len ;
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
  {
#line 745
  len = 0U;
  }
#line 746
  if ((unsigned int )str == (unsigned int )((void *)0)) {
    {
#line 747
    printf((char const   * __restrict  )"NULL");
    }
#line 748
    return (len);
  }
  {
#line 750
  tmp___0 = is_text(str, (int )slen);
  }
#line 751
  if (tmp___0) {
    {
#line 752
    printf((char const   * __restrict  )"TXT : ");
    }
    {
#line 753
    while (1) {
      while_continue: /* CIL Label */ ;
#line 754
      if (len < slen) {
#line 755
        if (! (len < (size_t )maxlen)) {
#line 756
          goto while_break;
        }
      } else {
#line 759
        goto while_break;
      }
      {
#line 761
      tmp = __ctype_b_loc();
      }
#line 762
      if ((int const   )*(*tmp + (int )*str) & 16384) {
        {
#line 763
        putchar((int )*str);
        }
      } else {
        {
#line 766
        if ((int )*str == 0) {
#line 766
          goto case_0;
        }
#line 769
        if ((int )*str == 10) {
#line 769
          goto case_10;
        }
#line 775
        if ((int )*str == 13) {
#line 775
          goto case_13;
        }
#line 781
        if ((int )*str == 9) {
#line 781
          goto case_9;
        }
#line 784
        goto switch_default;
        case_0: /* CIL Label */ 
        {
#line 767
        printf((char const   * __restrict  )"\\0");
        }
#line 768
        goto switch_break;
        case_10: /* CIL Label */ 
#line 770
        if (line_f) {
#line 771
          return (len);
        }
        {
#line 773
        printf((char const   * __restrict  )"\\n");
        }
#line 774
        goto switch_break;
        case_13: /* CIL Label */ 
#line 776
        if (line_f) {
#line 777
          return (len);
        }
        {
#line 779
        printf((char const   * __restrict  )"\\r");
        }
#line 780
        goto switch_break;
        case_9: /* CIL Label */ 
        {
#line 782
        printf((char const   * __restrict  )"\\t");
        }
#line 783
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 785
        printf((char const   * __restrict  )"\\x%02x", (int )*str);
        }
        switch_break: /* CIL Label */ ;
        }
      }
      {
#line 788
      len ++;
#line 789
      str ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 792
    printf((char const   * __restrict  )"HEX :");
    }
    {
#line 793
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 794
      if (len < slen) {
#line 795
        if (! (len < (size_t )maxlen)) {
#line 796
          goto while_break___0;
        }
      } else {
#line 799
        goto while_break___0;
      }
      {
#line 801
      printf((char const   * __restrict  )" %02x", (int )*str);
#line 802
      len ++;
#line 803
      str ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 806
  return (len);
}
}
#line 809 "pfscan_comb.c"
int matchfun(unsigned char *buf , size_t len , size_t pos , void *misc ) 
{ 
  char *pathname ;

  {
  {
#line 813
  pathname = (char *)misc;
#line 814
  pthread_mutex_lock(& matches_lock);
#line 815
  __VERIFIER_atomic_begin();
#line 815
  assert(-1LL + (long long )nworkers >= 0LL);
#line 815
  assert((-1LL + (long long )debug) + (long long )nworkers >= 0LL);
#line 815
  assert((-1LL + (long long )nworkers) + (long long )verbose >= 0LL);
#line 815
  assert((-1LL + (long long )line_f) + (long long )nworkers >= 0LL);
#line 815
  assert((-1LL + (long long )ignore_case) + (long long )nworkers >= 0LL);
#line 815
  assert((-1LL + (long long )n_matches) + (long long )nworkers >= 0LL);
#line 815
  assert((long long )debug + (long long )verbose >= 0LL);
#line 815
  assert((long long )debug + (long long )line_f >= 0LL);
#line 815
  assert((long long )debug + (long long )ignore_case >= 0LL);
#line 815
  assert((long long )debug + (long long )n_matches >= 0LL);
#line 815
  assert((long long )line_f + (long long )verbose >= 0LL);
#line 815
  assert((long long )line_f + (long long )n_matches >= 0LL);
#line 815
  assert((long long )ignore_case + (long long )verbose >= 0LL);
#line 815
  assert((long long )ignore_case + (long long )line_f >= 0LL);
#line 815
  assert((long long )ignore_case + (long long )n_matches >= 0LL);
#line 815
  assert((long long )n_matches + (long long )verbose >= 0LL);
#line 815
  assert((long long )debug >= 0LL);
#line 815
  assert((long long )verbose >= 0LL);
#line 815
  assert((long long )line_f >= 0LL);
#line 815
  assert((long long )ignore_case >= 0LL);
#line 815
  assert((long long )n_matches >= 0LL);
#line 815
  __VERIFIER_atomic_end();
#line 815
  n_matches ++;
#line 816
  pthread_mutex_unlock(& matches_lock);
  }
#line 817
  if (line_f) {
    {
#line 818
    while (1) {
      while_continue: /* CIL Label */ ;
#line 819
      if (pos > 0U) {
#line 820
        if ((int )*(buf + (pos - 1U)) == 10) {
#line 821
          goto while_break;
        } else
#line 823
        if ((int )*(buf + (pos - 1U)) == 13) {
#line 824
          goto while_break;
        }
      } else {
#line 828
        goto while_break;
      }
      {
#line 830
      pos --;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 833
  pthread_mutex_lock(& print_lock);
#line 834
  __VERIFIER_atomic_begin();
#line 834
  assert(-1LL + (long long )nworkers >= 0LL);
#line 834
  assert((-1LL + (long long )debug) + (long long )nworkers >= 0LL);
#line 834
  assert((-1LL + (long long )nworkers) + (long long )verbose >= 0LL);
#line 834
  assert((-1LL + (long long )line_f) + (long long )nworkers >= 0LL);
#line 834
  assert((-1LL + (long long )ignore_case) + (long long )nworkers >= 0LL);
#line 834
  assert((long long )debug + (long long )verbose >= 0LL);
#line 834
  assert((long long )debug + (long long )line_f >= 0LL);
#line 834
  assert((long long )debug + (long long )ignore_case >= 0LL);
#line 834
  assert((long long )line_f + (long long )verbose >= 0LL);
#line 834
  assert((long long )ignore_case + (long long )verbose >= 0LL);
#line 834
  assert((long long )ignore_case + (long long )line_f >= 0LL);
#line 834
  assert((long long )debug >= 0LL);
#line 834
  assert((long long )verbose >= 0LL);
#line 834
  assert((long long )line_f >= 0LL);
#line 834
  assert((long long )ignore_case >= 0LL);
#line 834
  __VERIFIER_atomic_end();
#line 834
  printf((char const   * __restrict  )"%s : %lu : ", pathname, (unsigned long )pos);
#line 835
  print_output(buf + pos, len - pos);
#line 836
  putchar('\n');
#line 837
  pthread_mutex_unlock(& print_lock);
  }
#line 838
  return (0);
}
}
#line 841 "pfscan_comb.c"
int scan_file(char *pathname ) 
{ 
  int fd ;
  size_t len ;
  unsigned char *buf ;
  struct stat sb ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int code ;

  {
  {
#line 857
  fd = open((char const   *)pathname, 0);
  }
#line 858
  if (fd < 0) {
#line 859
    if (verbose) {
      {
#line 860
      pthread_mutex_lock(& print_lock);
#line 861
      __VERIFIER_atomic_begin();
#line 861
      assert(-1LL + (long long )nworkers >= 0LL);
#line 861
      assert((-1LL + (long long )debug) + (long long )nworkers >= 0LL);
#line 861
      assert((-1LL + (long long )nworkers) + (long long )verbose >= 0LL);
#line 861
      assert((-1LL + (long long )line_f) + (long long )nworkers >= 0LL);
#line 861
      assert((-1LL + (long long )ignore_case) + (long long )nworkers >= 0LL);
#line 861
      assert((long long )debug + (long long )verbose >= 0LL);
#line 861
      assert((long long )debug + (long long )line_f >= 0LL);
#line 861
      assert((long long )debug + (long long )ignore_case >= 0LL);
#line 861
      assert((long long )line_f + (long long )verbose >= 0LL);
#line 861
      assert((long long )ignore_case + (long long )verbose >= 0LL);
#line 861
      assert((long long )ignore_case + (long long )line_f >= 0LL);
#line 861
      assert((long long )debug >= 0LL);
#line 861
      assert((long long )verbose >= 0LL);
#line 861
      assert((long long )line_f >= 0LL);
#line 861
      assert((long long )ignore_case >= 0LL);
#line 861
      __VERIFIER_atomic_end();
#line 861
      tmp = __errno_location();
#line 862
      tmp___0 = strerror(*tmp);
#line 863
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s : ERR : open() failed: %s\n",
              pathname, tmp___0);
#line 865
      pthread_mutex_unlock(& print_lock);
      }
    }
#line 867
    return (-1);
  }
  {
#line 869
  tmp___3 = fstat(fd, & sb);
  }
#line 870
  if (tmp___3 < 0) {
#line 871
    if (verbose) {
      {
#line 872
      pthread_mutex_lock(& print_lock);
#line 873
      __VERIFIER_atomic_begin();
#line 873
      assert(-1LL + (long long )nworkers >= 0LL);
#line 873
      assert((-1LL + (long long )debug) + (long long )nworkers >= 0LL);
#line 873
      assert((-1LL + (long long )nworkers) + (long long )verbose >= 0LL);
#line 873
      assert((-1LL + (long long )line_f) + (long long )nworkers >= 0LL);
#line 873
      assert((-1LL + (long long )ignore_case) + (long long )nworkers >= 0LL);
#line 873
      assert((long long )debug + (long long )verbose >= 0LL);
#line 873
      assert((long long )debug + (long long )line_f >= 0LL);
#line 873
      assert((long long )debug + (long long )ignore_case >= 0LL);
#line 873
      assert((long long )line_f + (long long )verbose >= 0LL);
#line 873
      assert((long long )ignore_case + (long long )verbose >= 0LL);
#line 873
      assert((long long )ignore_case + (long long )line_f >= 0LL);
#line 873
      assert((long long )debug >= 0LL);
#line 873
      assert((long long )verbose >= 0LL);
#line 873
      assert((long long )line_f >= 0LL);
#line 873
      assert((long long )ignore_case >= 0LL);
#line 873
      __VERIFIER_atomic_end();
#line 873
      tmp___1 = __errno_location();
#line 874
      tmp___2 = strerror(*tmp___1);
#line 875
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s : ERR : fstat() failed: %s\n",
              pathname, tmp___2);
#line 877
      pthread_mutex_unlock(& print_lock);
      }
    }
    {
#line 879
    close(fd);
    }
#line 880
    return (-1);
  }
  {
#line 882
  len = (unsigned int )sb.st_size;
  }
#line 883
  if (debug > 1) {
    {
#line 884
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"*** Scanning file %s (%u Mbytes)\n",
            pathname, len / 1000000U);
    }
  }
  {
#line 887
  tmp___4 = mmap((void *)0, len, 1, 16386, fd, 0L);
#line 888
  buf = (unsigned char *)tmp___4;
  }
#line 889
  if ((unsigned int )buf == (unsigned int )((void *)-1)) {
#line 890
    if (verbose) {
      {
#line 891
      pthread_mutex_lock(& print_lock);
#line 892
      __VERIFIER_atomic_begin();
#line 892
      assert(-1LL + (long long )nworkers >= 0LL);
#line 892
      assert((-1LL + (long long )debug) + (long long )nworkers >= 0LL);
#line 892
      assert((-1LL + (long long )nworkers) + (long long )verbose >= 0LL);
#line 892
      assert((-1LL + (long long )line_f) + (long long )nworkers >= 0LL);
#line 892
      assert((-1LL + (long long )ignore_case) + (long long )nworkers >= 0LL);
#line 892
      assert((long long )debug + (long long )verbose >= 0LL);
#line 892
      assert((long long )debug + (long long )line_f >= 0LL);
#line 892
      assert((long long )debug + (long long )ignore_case >= 0LL);
#line 892
      assert((long long )line_f + (long long )verbose >= 0LL);
#line 892
      assert((long long )ignore_case + (long long )verbose >= 0LL);
#line 892
      assert((long long )ignore_case + (long long )line_f >= 0LL);
#line 892
      assert((long long )debug >= 0LL);
#line 892
      assert((long long )verbose >= 0LL);
#line 892
      assert((long long )line_f >= 0LL);
#line 892
      assert((long long )ignore_case >= 0LL);
#line 892
      __VERIFIER_atomic_end();
#line 892
      tmp___5 = __errno_location();
#line 893
      tmp___6 = strerror(*tmp___5);
#line 894
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s : ERR : mmap() failed: %s\n",
              pathname, tmp___6);
#line 896
      pthread_mutex_unlock(& print_lock);
      }
    }
    {
#line 898
    close(fd);
    }
#line 899
    return (-1);
  }
#line 901
  if (rstr) {
    {
#line 902
    code = bm_search(& bmb, buf, len, & matchfun, (void *)pathname);
    }
  } else {
    {
#line 904
    pthread_mutex_lock(& print_lock);
#line 905
    __VERIFIER_atomic_begin();
#line 905
    assert(-1LL + (long long )nworkers >= 0LL);
#line 905
    assert((-1LL + (long long )debug) + (long long )nworkers >= 0LL);
#line 905
    assert((-1LL + (long long )nworkers) + (long long )verbose >= 0LL);
#line 905
    assert((-1LL + (long long )line_f) + (long long )nworkers >= 0LL);
#line 905
    assert((-1LL + (long long )ignore_case) + (long long )nworkers >= 0LL);
#line 905
    assert((long long )debug + (long long )verbose >= 0LL);
#line 905
    assert((long long )debug + (long long )line_f >= 0LL);
#line 905
    assert((long long )debug + (long long )ignore_case >= 0LL);
#line 905
    assert((long long )line_f + (long long )verbose >= 0LL);
#line 905
    assert((long long )ignore_case + (long long )verbose >= 0LL);
#line 905
    assert((long long )ignore_case + (long long )line_f >= 0LL);
#line 905
    assert((long long )debug >= 0LL);
#line 905
    assert((long long )verbose >= 0LL);
#line 905
    assert((long long )line_f >= 0LL);
#line 905
    assert((long long )ignore_case >= 0LL);
#line 905
    __VERIFIER_atomic_end();
#line 905
    printf((char const   * __restrict  )"%s : 0 : ", pathname);
#line 906
    print_output(buf, len);
#line 907
    putchar('\n');
#line 908
    pthread_mutex_unlock(& print_lock);
    }
  }
  {
#line 910
  munmap((void *)((char *)buf), len);
#line 911
  close(fd);
  }
#line 912
  return (1);
}
}
#line 915 "pfscan_comb.c"
int foreach_path(char const   *path , struct stat  const  *sp , int f ) 
{ 
  char *tmp ;

  {
  {
#line 919
  n_files ++;
#line 920
  n_bytes = (unsigned int )((unsigned long )n_bytes + (unsigned long )sp->st_size);
  }
  {
#line 922
  if (f == 0) {
#line 922
    goto case_0;
  }
#line 926
  if (f == 1) {
#line 926
    goto case_1;
  }
#line 928
  if (f == 2) {
#line 928
    goto case_2;
  }
#line 932
  if (f == 3) {
#line 932
    goto case_3;
  }
#line 936
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 923
  tmp = strdup(path);
#line 924
  pqueue_put(& pqb, (void *)tmp);
  }
#line 925
  return (0);
  case_1: /* CIL Label */ 
#line 927
  return (0);
  case_2: /* CIL Label */ 
  {
#line 929
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: Can\'t read directory.\n",
          argv0, path);
  }
#line 931
  return (1);
  case_3: /* CIL Label */ 
  {
#line 933
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: Can\'t stat object.\n",
          argv0, path);
  }
#line 935
  return (1);
  switch_default: /* CIL Label */ 
  {
#line 937
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: Internal error (invalid ftw code)\n",
          argv0, path);
  }
  switch_break: /* CIL Label */ ;
  }
#line 940
  return (1);
}
}
#line 943 "pfscan_comb.c"
int do_ftw(char *path ) 
{ 
  int code ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 950
  tmp = ftw((char const   *)path, & foreach_path, max_depth);
#line 951
  code = tmp;
  }
#line 952
  if (code < 0) {
    {
#line 953
    tmp___0 = __errno_location();
#line 954
    tmp___1 = strerror(*tmp___0);
#line 955
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: ftw: %s\n",
            argv0, tmp___1);
    }
#line 957
    return (1);
  }
#line 959
  return (code);
}
}
#line 962 "pfscan_comb.c"
void *worker(void *arg ) 
{ 
  char *path ;
  int tmp ;

  {
  {
#line 967
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 968
    tmp = pqueue_get(& pqb, (void **)(& path));
    }
#line 969
    if (! (tmp == 1)) {
#line 970
      goto while_break;
    }
    {
#line 972
    scan_file(path);
#line 973
    free((void *)path);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 975
  fflush(stdout);
#line 976
  pthread_mutex_lock(& aworker_lock);
#line 977
  __VERIFIER_atomic_begin();
#line 977
  assert(-1LL + (long long )nworkers >= 0LL);
#line 977
  assert((-1LL + (long long )debug) + (long long )nworkers >= 0LL);
#line 977
  assert((-1LL + (long long )nworkers) + (long long )verbose >= 0LL);
#line 977
  assert((-1LL + (long long )line_f) + (long long )nworkers >= 0LL);
#line 977
  assert((-1LL + (long long )ignore_case) + (long long )nworkers >= 0LL);
#line 977
  assert((0LL - (long long )aworkers) + (long long )nworkers >= 0LL);
#line 977
  assert((long long )debug + (long long )verbose >= 0LL);
#line 977
  assert((long long )debug + (long long )line_f >= 0LL);
#line 977
  assert((long long )debug + (long long )ignore_case >= 0LL);
#line 977
  assert((long long )line_f + (long long )verbose >= 0LL);
#line 977
  assert((long long )ignore_case + (long long )verbose >= 0LL);
#line 977
  assert((long long )ignore_case + (long long )line_f >= 0LL);
#line 977
  assert((long long )debug >= 0LL);
#line 977
  assert((long long )verbose >= 0LL);
#line 977
  assert((long long )line_f >= 0LL);
#line 977
  assert((long long )ignore_case >= 0LL);
#line 977
  __VERIFIER_atomic_end();
#line 977
  aworkers --;
#line 978
  pthread_mutex_unlock(& aworker_lock);
#line 979
  pthread_cond_signal(& aworker_cv);
  }
#line 980
  return ((void *)0);
}
}
#line 983 "pfscan_comb.c"
void usage(FILE *out ) 
{ 


  {
  {
#line 987
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"Usage: %s [<options>] <search-string> <pathname> [... <pathname-N>]\n",
          argv0);
#line 989
  fputs((char const   * __restrict  )"\nThis program implements a multithreaded file scanner.\nMore information may be found at:\n\thttp://www.lysator.liu.se/~pen/pfscan\n\nCommand line options:\n",
        (FILE * __restrict  )out);
#line 991
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\t-h             Display this information.\n");
#line 992
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\t-V             Print version.\n");
#line 993
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\t-v             Be verbose.\n");
#line 994
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\t-d             Print debugging info.\n");
#line 995
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\t-i             Ignore case when scanning.\n");
#line 996
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\t-l             Line oriented output.\n");
#line 997
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\t-n<workers>    Concurrent worker threads limit.\n");
#line 998
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\t-L<length>     Max length of bytes to print.\n");
  }
#line 999
  return;
}
}
#line 1002 "pfscan_comb.c"
int main(int argc , char **argv ) 
{ 
  int i ;
  int j ;
  struct rlimit rlb ;
  char *arg ;
  pthread_t tid ;
  pthread_attr_t pab ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 1021
  argv0 = *(argv + 0);
#line 1022
  setlocale(0, (char const   *)"");
#line 1023
  getrlimit(7, & rlb);
#line 1024
  rlb.rlim_cur = rlb.rlim_max;
#line 1025
  setrlimit(7, (struct rlimit  const  *)(& rlb));
#line 1026
  signal(13, (void (*)(int  ))1);
#line 1027
  nworkers = 2;
#line 1028
  pthread_mutex_init(& print_lock, (pthread_mutexattr_t const   *)((void *)0));
#line 1029
  pthread_mutex_init(& aworker_lock, (pthread_mutexattr_t const   *)((void *)0));
#line 1030
  pthread_mutex_init(& matches_lock, (pthread_mutexattr_t const   *)((void *)0));
#line 1031
  i = 1;
  }
  {
#line 1032
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1033
    if (i < argc) {
#line 1034
      if (! ((int )*(*(argv + i) + 0) == 45)) {
#line 1035
        goto while_break;
      }
    } else {
#line 1038
      goto while_break;
    }
    {
#line 1040
    j = 1;
    }
    {
#line 1041
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1042
      if (j > 0) {
#line 1043
        if (! *(*(argv + i) + j)) {
#line 1044
          goto while_break___0;
        }
      } else {
#line 1047
        goto while_break___0;
      }
      {
#line 1050
      if ((int )*(*(argv + i) + j) == 45) {
#line 1050
        goto case_45;
      }
#line 1053
      if ((int )*(*(argv + i) + j) == 86) {
#line 1053
        goto case_86;
      }
#line 1056
      if ((int )*(*(argv + i) + j) == 100) {
#line 1056
        goto case_100;
      }
#line 1059
      if ((int )*(*(argv + i) + j) == 105) {
#line 1059
        goto case_105;
      }
#line 1062
      if ((int )*(*(argv + i) + j) == 118) {
#line 1062
        goto case_118;
      }
#line 1065
      if ((int )*(*(argv + i) + j) == 104) {
#line 1065
        goto case_104;
      }
#line 1068
      if ((int )*(*(argv + i) + j) == 108) {
#line 1068
        goto case_108;
      }
#line 1071
      if ((int )*(*(argv + i) + j) == 76) {
#line 1071
        goto case_76;
      }
#line 1097
      if ((int )*(*(argv + i) + j) == 110) {
#line 1097
        goto case_110;
      }
#line 1123
      goto switch_default;
      case_45: /* CIL Label */ 
      {
#line 1051
      i ++;
      }
#line 1052
      goto EndOptions;
      case_86: /* CIL Label */ 
      {
#line 1054
      print_version(stdout);
      }
#line 1055
      goto switch_break;
      case_100: /* CIL Label */ 
      {
#line 1057
      debug ++;
      }
#line 1058
      goto switch_break;
      case_105: /* CIL Label */ 
      {
#line 1060
      ignore_case = 1;
      }
#line 1061
      goto switch_break;
      case_118: /* CIL Label */ 
      {
#line 1063
      verbose ++;
      }
#line 1064
      goto switch_break;
      case_104: /* CIL Label */ 
      {
#line 1066
      usage(stdout);
#line 1067
      exit(0);
      }
      case_108: /* CIL Label */ 
      {
#line 1069
      line_f ++;
      }
#line 1070
      goto switch_break;
      case_76: /* CIL Label */ 
#line 1072
      if (*(*(argv + i) + 2)) {
        {
#line 1073
        arg = *(argv + i) + 2;
        }
      } else {
        {
#line 1075
        i ++;
#line 1076
        arg = *(argv + i);
        }
      }
#line 1078
      if (! arg) {
#line 1079
        goto _L;
      } else {
        {
#line 1081
        tmp___0 = sscanf((char const   * __restrict  )arg, (char const   * __restrict  )"%u",
                         & maxlen);
        }
#line 1083
        if (tmp___0 != 1) {
          _L: 
#line 1085
          if (arg) {
            {
#line 1086
            tmp = (char const   *)arg;
            }
          } else {
            {
#line 1088
            tmp = (char const   *)"<null>";
            }
          }
          {
#line 1090
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Invalid length specification: %s\n",
                  *(argv + 0), tmp);
#line 1092
          exit(1);
          }
        }
      }
      {
#line 1095
      j = -2;
      }
#line 1096
      goto switch_break;
      case_110: /* CIL Label */ 
#line 1098
      if (*(*(argv + i) + 2)) {
        {
#line 1099
        arg = *(argv + i) + 2;
        }
      } else {
        {
#line 1101
        i ++;
#line 1102
        arg = *(argv + i);
        }
      }
#line 1104
      if (! arg) {
#line 1105
        goto _L___0;
      } else {
        {
#line 1107
        tmp___2 = sscanf((char const   * __restrict  )arg, (char const   * __restrict  )"%u",
                         & nworkers);
        }
#line 1109
        if (tmp___2 != 1) {
          _L___0: 
#line 1111
          if (arg) {
            {
#line 1112
            tmp___1 = (char const   *)arg;
            }
          } else {
            {
#line 1114
            tmp___1 = (char const   *)"<null>";
            }
          }
          {
#line 1116
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Invalid workers specification: %s\n",
                  *(argv + 0), tmp___1);
#line 1118
          exit(1);
          }
        }
      }
      {
#line 1121
      j = -2;
      }
#line 1122
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 1124
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: unknown command line switch: -%c\n",
              *(argv + 0), (int )*(*(argv + i) + j));
#line 1126
      exit(1);
      }
      switch_break: /* CIL Label */ ;
      }
      {
#line 1128
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1130
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  EndOptions: 
  {
#line 1133
  tmp___3 = i;
#line 1134
  i ++;
#line 1135
  tmp___4 = strdup((char const   *)*(argv + tmp___3));
#line 1136
  rstr = (unsigned char *)tmp___4;
#line 1137
  rlen = deslash(rstr);
#line 1138
  tmp___5 = bm_init(& bmb, rstr, rlen, ignore_case);
  }
#line 1139
  if (tmp___5 < 0) {
    {
#line 1140
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Failed search string setup: %s\n",
            *(argv + 0), rstr);
#line 1142
    exit(1);
    }
  }
  {
#line 1144
  max_depth = (int )((rlb.rlim_max - (rlim_t )nworkers) - 16UL);
  }
#line 1145
  if (debug) {
    {
#line 1146
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"max_depth = %d, nworkers = %d\n",
            max_depth, nworkers);
    }
  }
  {
#line 1149
  pqueue_init(& pqb, nworkers + 8);
#line 1150
  pthread_attr_init(& pab);
#line 1151
  pthread_attr_setscope(& pab, 0);
#line 1152
  aworkers = nworkers;
#line 1153
  j = 0;
  }
  {
#line 1154
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1154
    if (! (j < nworkers)) {
#line 1154
      goto while_break___1;
    }
    {
#line 1155
    tmp___6 = pthread_create((pthread_t * __restrict  )(& tid), (pthread_attr_t const   * __restrict  )(& pab),
                             & worker, (void * __restrict  )((void *)0));
    }
#line 1157
    if (tmp___6 != 0) {
      {
#line 1158
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: pthread_create: failed to create worker thread\n",
              *(argv + 0));
#line 1160
      exit(1);
      }
    }
    {
#line 1162
    j ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1164
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1165
    if (i < argc) {
      {
#line 1166
      tmp___7 = i;
#line 1167
      i ++;
#line 1168
      tmp___8 = do_ftw(*(argv + tmp___7));
      }
#line 1169
      if (! (tmp___8 == 0)) {
#line 1170
        goto while_break___2;
      }
    } else {
#line 1173
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1176
  pqueue_close(& pqb);
  }
#line 1177
  if (debug) {
    {
#line 1178
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Waiting for workers to finish...\n");
    }
  }
  {
#line 1180
  pthread_mutex_lock(& aworker_lock);
#line 1181
  __VERIFIER_atomic_begin();
#line 1181
  assert((0LL - (long long )aworkers) + (long long )nworkers >= 0LL);
#line 1181
  assert((long long )debug + (long long )verbose >= 0LL);
#line 1181
  assert((long long )debug + (long long )line_f >= 0LL);
#line 1181
  assert((long long )debug + (long long )ignore_case >= 0LL);
#line 1181
  assert((long long )line_f + (long long )verbose >= 0LL);
#line 1181
  assert((long long )ignore_case + (long long )verbose >= 0LL);
#line 1181
  assert((long long )ignore_case + (long long )line_f >= 0LL);
#line 1181
  assert((long long )debug >= 0LL);
#line 1181
  assert((long long )verbose >= 0LL);
#line 1181
  assert((long long )line_f >= 0LL);
#line 1181
  assert((long long )ignore_case >= 0LL);
#line 1181
  assert((((((((((((((((((((((((((((((((((((0LL - (long long )nworkers) + (long long )verbose >= 0LL && (0LL - (long long )aworkers) + (long long )debug >= 0LL) && (0LL - (long long )aworkers) + (long long )verbose >= 0LL) && (0LL - (long long )aworkers) + (long long )line_f >= 0LL) && (0LL - (long long )aworkers) + (long long )ignore_case >= 0LL) && (0LL - (long long )aworkers) + (long long )n_matches >= 0LL) && (0LL - (long long )aworkers) + (long long )n_files >= 0LL) && (0LL - (long long )n_matches) + (long long )verbose >= 0LL) && (long long )debug + (long long )n_matches >= 0LL) && (long long )debug + (long long )n_files >= 0LL) && (long long )line_f + (long long )n_matches >= 0LL) && (long long )line_f + (long long )n_files >= 0LL) && (long long )ignore_case + (long long )n_matches >= 0LL) && (long long )ignore_case + (long long )n_files >= 0LL) && (long long )n_matches + (long long )verbose >= 0LL) && (long long )n_files + (long long )verbose >= 0LL) && (long long )n_files + (long long )n_matches >= 0LL) && 0LL - (long long )nworkers >= 0LL) && 0LL - (long long )aworkers >= 0LL) && 0LL - (long long )n_matches >= 0LL) && (0LL - (long long )aworkers) - (long long )nworkers >= 0LL) && (0LL - (long long )aworkers) - (long long )n_matches >= 0LL) && (0LL - (long long )n_matches) - (long long )nworkers >= 0LL) && (long long )debug - (long long )nworkers >= 0LL) && (long long )debug - (long long )n_matches >= 0LL) && (long long )aworkers - (long long )nworkers >= 0LL) && (long long )line_f - (long long )nworkers >= 0LL) && (long long )line_f - (long long )n_matches >= 0LL) && (long long )ignore_case - (long long )nworkers >= 0LL) && (long long )ignore_case - (long long )n_matches >= 0LL) && (long long )n_matches - (long long )nworkers >= 0LL) && (long long )n_files - (long long )nworkers >= 0LL) && (long long )n_files - (long long )n_matches >= 0LL) && (long long )n_matches >= 0LL) && (long long )n_files >= 0LL) || ((((-1LL + (long long )nworkers >= 0LL && (-1LL + (long long )debug) + (long long )nworkers >= 0LL) && (-1LL + (long long )nworkers) + (long long )verbose >= 0LL) && (-1LL + (long long )line_f) + (long long )nworkers >= 0LL) && (-1LL + (long long )ignore_case) + (long long )nworkers >= 0LL));
#line 1181
  __VERIFIER_atomic_end();
  }
  {
#line 1181
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1181
    if (! (aworkers > 0)) {
#line 1181
      goto while_break___3;
    }
    {
#line 1182
    pthread_cond_wait((pthread_cond_t * __restrict  )(& aworker_cv), (pthread_mutex_t * __restrict  )(& aworker_lock));
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1184
  pthread_mutex_unlock(& aworker_lock);
  }
#line 1185
  if (debug) {
    {
#line 1186
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"n_files = %d, n_matches = %d, n_workers = %d, n_Mbytes = %d\n",
            n_files, n_matches, nworkers, (int )(n_bytes / 1000000U));
    }
  }
#line 1189
  return (n_matches);
}
}
#line 1192
#pragma merger(0,"/tmp/cil-fUHu0UpL.i","")
#line 1193
extern int ( __attribute__((__nonnull__(1))) pthread_mutex_destroy)(pthread_mutex_t *__mutex )  __attribute__((__nothrow__)) ;
#line 1194
extern int ( __attribute__((__nonnull__(1))) pthread_cond_init)(pthread_cond_t * __restrict  __cond ,
                                                                pthread_condattr_t const   * __restrict  __cond_attr )  __attribute__((__nothrow__)) ;
#line 1196
extern int ( __attribute__((__nonnull__(1))) pthread_cond_destroy)(pthread_cond_t *__cond )  __attribute__((__nothrow__)) ;
#line 1197
extern int ( __attribute__((__nonnull__(1))) pthread_cond_broadcast)(pthread_cond_t *__cond )  __attribute__((__nothrow__)) ;
#line 1198
void pqueue_destroy(PQUEUE *qp ) ;
#line 1199 "pfscan_comb.c"
int pqueue_init(PQUEUE *qp , int qsize ) 
{ 
  void *tmp ;

  {
  {
#line 1203
  tmp = calloc((size_t )sizeof(void *), (unsigned int )qsize);
#line 1204
  qp->buf = (void **)tmp;
  }
#line 1205
  if ((unsigned int )qp->buf == (unsigned int )((void *)0)) {
#line 1206
    return ((int )((void *)0));
  }
  {
#line 1208
  qp->qsize = qsize;
#line 1209
  qp->occupied = 0;
#line 1210
  qp->nextin = 0;
#line 1211
  qp->nextout = 0;
#line 1212
  qp->closed = 0;
#line 1213
  pthread_mutex_init(& qp->mtx, (pthread_mutexattr_t const   *)((void *)0));
#line 1214
  pthread_cond_init((pthread_cond_t * __restrict  )(& qp->more), (pthread_condattr_t const   * __restrict  )((void *)0));
#line 1215
  pthread_cond_init((pthread_cond_t * __restrict  )(& qp->less), (pthread_condattr_t const   * __restrict  )((void *)0));
  }
#line 1216
  return (0);
}
}
#line 1219 "pfscan_comb.c"
void pqueue_close(PQUEUE *qp ) 
{ 


  {
  {
#line 1223
  pthread_mutex_lock(& qp->mtx);
#line 1224
  __VERIFIER_atomic_begin();
#line 1224
  assert((long long )debug + (long long )verbose >= 0LL);
#line 1224
  assert((long long )debug + (long long )line_f >= 0LL);
#line 1224
  assert((long long )debug + (long long )ignore_case >= 0LL);
#line 1224
  assert((long long )line_f + (long long )verbose >= 0LL);
#line 1224
  assert((long long )ignore_case + (long long )verbose >= 0LL);
#line 1224
  assert((long long )ignore_case + (long long )line_f >= 0LL);
#line 1224
  assert((long long )debug >= 0LL);
#line 1224
  assert((long long )verbose >= 0LL);
#line 1224
  assert((long long )line_f >= 0LL);
#line 1224
  assert((long long )ignore_case >= 0LL);
#line 1224
  assert(((((((((((((((((((((((((((((((((((((0LL - (long long )nworkers) + (long long )verbose >= 0LL && (0LL - (long long )aworkers) + (long long )debug >= 0LL) && (0LL - (long long )aworkers) + (long long )verbose >= 0LL) && (0LL - (long long )aworkers) + (long long )nworkers >= 0LL) && (0LL - (long long )aworkers) + (long long )line_f >= 0LL) && (0LL - (long long )aworkers) + (long long )ignore_case >= 0LL) && (0LL - (long long )aworkers) + (long long )n_matches >= 0LL) && (0LL - (long long )aworkers) + (long long )n_files >= 0LL) && (0LL - (long long )n_matches) + (long long )verbose >= 0LL) && (long long )debug + (long long )n_matches >= 0LL) && (long long )debug + (long long )n_files >= 0LL) && (long long )line_f + (long long )n_matches >= 0LL) && (long long )line_f + (long long )n_files >= 0LL) && (long long )ignore_case + (long long )n_matches >= 0LL) && (long long )ignore_case + (long long )n_files >= 0LL) && (long long )n_matches + (long long )verbose >= 0LL) && (long long )n_files + (long long )verbose >= 0LL) && (long long )n_files + (long long )n_matches >= 0LL) && 0LL - (long long )nworkers >= 0LL) && 0LL - (long long )aworkers >= 0LL) && 0LL - (long long )n_matches >= 0LL) && (0LL - (long long )aworkers) - (long long )nworkers >= 0LL) && (0LL - (long long )aworkers) - (long long )n_matches >= 0LL) && (0LL - (long long )n_matches) - (long long )nworkers >= 0LL) && (long long )debug - (long long )nworkers >= 0LL) && (long long )debug - (long long )n_matches >= 0LL) && (long long )aworkers - (long long )nworkers >= 0LL) && (long long )line_f - (long long )nworkers >= 0LL) && (long long )line_f - (long long )n_matches >= 0LL) && (long long )ignore_case - (long long )nworkers >= 0LL) && (long long )ignore_case - (long long )n_matches >= 0LL) && (long long )n_matches - (long long )nworkers >= 0LL) && (long long )n_files - (long long )nworkers >= 0LL) && (long long )n_files - (long long )n_matches >= 0LL) && (long long )n_matches >= 0LL) && (long long )n_files >= 0LL) || ((((-1LL + (long long )nworkers >= 0LL && (-1LL + (long long )debug) + (long long )nworkers >= 0LL) && (-1LL + (long long )nworkers) + (long long )verbose >= 0LL) && (-1LL + (long long )line_f) + (long long )nworkers >= 0LL) && (-1LL + (long long )ignore_case) + (long long )nworkers >= 0LL));
#line 1224
  __VERIFIER_atomic_end();
#line 1224
  qp->closed = 1;
#line 1225
  pthread_mutex_unlock(& qp->mtx);
#line 1226
  pthread_cond_broadcast(& qp->more);
  }
#line 1227
  return;
}
}
#line 1230 "pfscan_comb.c"
int pqueue_put(PQUEUE *qp , void *item ) 
{ 
  int tmp ;

  {
  {
#line 1234
  pthread_mutex_lock(& qp->mtx);
#line 1235
  __VERIFIER_atomic_begin();
#line 1235
  assert((long long )debug + (long long )verbose >= 0LL);
#line 1235
  assert((long long )debug + (long long )line_f >= 0LL);
#line 1235
  assert((long long )debug + (long long )ignore_case >= 0LL);
#line 1235
  assert((long long )line_f + (long long )verbose >= 0LL);
#line 1235
  assert((long long )ignore_case + (long long )verbose >= 0LL);
#line 1235
  assert((long long )ignore_case + (long long )line_f >= 0LL);
#line 1235
  assert((long long )debug >= 0LL);
#line 1235
  assert((long long )verbose >= 0LL);
#line 1235
  assert((long long )line_f >= 0LL);
#line 1235
  assert((long long )ignore_case >= 0LL);
#line 1235
  assert((((((((((((((((((((((((((((((((((((-1LL + (long long )n_files >= 0LL && (-1LL + (long long )debug) + (long long )n_files >= 0LL) && (-1LL + (long long )line_f) + (long long )n_files >= 0LL) && (-1LL + (long long )ignore_case) + (long long )n_files >= 0LL) && (-1LL + (long long )n_files) + (long long )verbose >= 0LL) && (-1LL + (long long )n_files) + (long long )n_matches >= 0LL) && (-1LL - (long long )aworkers) + (long long )n_files >= 0LL) && (0LL - (long long )nworkers) + (long long )verbose >= 0LL) && (0LL - (long long )aworkers) + (long long )debug >= 0LL) && (0LL - (long long )aworkers) + (long long )verbose >= 0LL) && (0LL - (long long )aworkers) + (long long )nworkers >= 0LL) && (0LL - (long long )aworkers) + (long long )line_f >= 0LL) && (0LL - (long long )aworkers) + (long long )ignore_case >= 0LL) && (0LL - (long long )aworkers) + (long long )n_matches >= 0LL) && (0LL - (long long )n_matches) + (long long )verbose >= 0LL) && (long long )debug + (long long )n_matches >= 0LL) && (long long )line_f + (long long )n_matches >= 0LL) && (long long )ignore_case + (long long )n_matches >= 0LL) && (long long )n_matches + (long long )verbose >= 0LL) && 0LL - (long long )nworkers >= 0LL) && 0LL - (long long )aworkers >= 0LL) && 0LL - (long long )n_matches >= 0LL) && (-1LL + (long long )n_files) - (long long )nworkers >= 0LL) && (-1LL + (long long )n_files) - (long long )n_matches >= 0LL) && (0LL - (long long )aworkers) - (long long )nworkers >= 0LL) && (0LL - (long long )aworkers) - (long long )n_matches >= 0LL) && (0LL - (long long )n_matches) - (long long )nworkers >= 0LL) && (long long )debug - (long long )nworkers >= 0LL) && (long long )debug - (long long )n_matches >= 0LL) && (long long )aworkers - (long long )nworkers >= 0LL) && (long long )line_f - (long long )nworkers >= 0LL) && (long long )line_f - (long long )n_matches >= 0LL) && (long long )ignore_case - (long long )nworkers >= 0LL) && (long long )ignore_case - (long long )n_matches >= 0LL) && (long long )n_matches - (long long )nworkers >= 0LL) && (long long )n_matches >= 0LL) || ((((-1LL + (long long )nworkers >= 0LL && (-1LL + (long long )debug) + (long long )nworkers >= 0LL) && (-1LL + (long long )nworkers) + (long long )verbose >= 0LL) && (-1LL + (long long )line_f) + (long long )nworkers >= 0LL) && (-1LL + (long long )ignore_case) + (long long )nworkers >= 0LL));
#line 1235
  __VERIFIER_atomic_end();
  }
#line 1235
  if (qp->closed) {
#line 1236
    return (0);
  }
  {
#line 1238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1238
    if (! (qp->occupied >= qp->qsize)) {
#line 1238
      goto while_break;
    }
    {
#line 1239
    pthread_cond_wait((pthread_cond_t * __restrict  )(& qp->less), (pthread_mutex_t * __restrict  )(& qp->mtx));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1241
  tmp = qp->nextin;
#line 1242
  (qp->nextin) ++;
#line 1243
  *(qp->buf + tmp) = item;
#line 1244
  qp->nextin %= qp->qsize;
#line 1245
  (qp->occupied) ++;
#line 1246
  pthread_mutex_unlock(& qp->mtx);
#line 1247
  pthread_cond_signal(& qp->more);
  }
#line 1248
  return (1);
}
}
#line 1251 "pfscan_comb.c"
int pqueue_get(PQUEUE *qp , void **item ) 
{ 
  int got ;
  int tmp ;

  {
  {
#line 1256
  got = 0;
#line 1257
  pthread_mutex_lock(& qp->mtx);
  }
  {
#line 1258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1259
    if (qp->occupied <= 0) {
#line 1260
      if (! (! qp->closed)) {
#line 1261
        goto while_break;
      }
    } else {
#line 1264
      goto while_break;
    }
    {
#line 1266
    pthread_cond_wait((pthread_cond_t * __restrict  )(& qp->more), (pthread_mutex_t * __restrict  )(& qp->mtx));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1268
  if (qp->occupied > 0) {
    {
#line 1269
    tmp = qp->nextout;
#line 1270
    (qp->nextout) ++;
#line 1271
    *item = *(qp->buf + tmp);
#line 1272
    qp->nextout %= qp->qsize;
#line 1273
    (qp->occupied) --;
#line 1274
    got = 1;
#line 1275
    pthread_mutex_unlock(& qp->mtx);
#line 1276
    pthread_cond_signal(& qp->less);
    }
  } else {
    {
#line 1278
    pthread_mutex_unlock(& qp->mtx);
    }
  }
#line 1280
  return (got);
}
}
#line 1283 "pfscan_comb.c"
void pqueue_destroy(PQUEUE *qp ) 
{ 


  {
  {
#line 1287
  pthread_mutex_destroy(& qp->mtx);
#line 1288
  pthread_cond_destroy(& qp->more);
#line 1289
  pthread_cond_destroy(& qp->less);
#line 1290
  free((void *)qp->buf);
  }
#line 1291
  return;
}
}
#line 1294
#pragma merger(0,"/tmp/cil-imHGfsqR.i","")
#line 1295 "pfscan_comb.c"
char version[4]  = {      (char )'1',      (char )'.',      (char )'0',      (char )'\000'};
#line 3 "pfscan_ftw.c"
int ( __attribute__((__nonnull__(1,2))) ftw)(char const   *dir , int (*fn)(char const   *file ,
                                                                           struct stat  const  *sb ,
                                                                           int flag ) ,
                                             int nopenfd ) 
{ 


  {
  {
#line 4
  (*fn)((char const   *)"", (struct stat  const  *)0, 0);
  }
#line 5
  return (0);
}
}
