/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

#line 4 "aget_comb.c"
typedef unsigned int size_t;
#line 5 "aget_comb.c"
typedef long long __quad_t;
#line 6 "aget_comb.c"
typedef long __off_t;
#line 7 "aget_comb.c"
typedef __quad_t __off64_t;
#line 8 "aget_comb.c"
typedef long __time_t;
#line 9 "aget_comb.c"
typedef __time_t time_t;
#line 10 "aget_comb.c"
struct __anonstruct___sigset_t_7 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 13 "aget_comb.c"
typedef struct __anonstruct___sigset_t_7 __sigset_t;
#line 14 "aget_comb.c"
typedef __sigset_t sigset_t;
#line 15 "aget_comb.c"
typedef unsigned long pthread_t;
#line 16 "aget_comb.c"
union __anonunion_pthread_attr_t_9 {
   char __size[36] ;
   long __align ;
};
#line 20 "aget_comb.c"
typedef union __anonunion_pthread_attr_t_9 pthread_attr_t;
#line 21
struct _IO_FILE ;
#line 22 "aget_comb.c"
typedef struct _IO_FILE FILE;
#line 23 "aget_comb.c"
typedef void _IO_lock_t;
#line 24 "aget_comb.c"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 29 "aget_comb.c"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 60 "aget_comb.c"
typedef unsigned short uint16_t;
#line 61 "aget_comb.c"
typedef unsigned int uint32_t;
#line 62 "aget_comb.c"
typedef unsigned short sa_family_t;
#line 63 "aget_comb.c"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 67 "aget_comb.c"
typedef uint16_t in_port_t;
#line 68 "aget_comb.c"
typedef uint32_t in_addr_t;
#line 69 "aget_comb.c"
struct in_addr {
   in_addr_t s_addr ;
};
#line 72 "aget_comb.c"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 78 "aget_comb.c"
struct request {
   char host[1024] ;
   char url[1024] ;
   char file[512] ;
   char lfile[512] ;
   char ip[16] ;
   char username[512] ;
   char password[512] ;
   int port ;
   int clength ;
   unsigned char proto ;
};
#line 90 "aget_comb.c"
struct thread_data {
   struct sockaddr_in sin ;
   char getstr[256] ;
   long soffset ;
   long foffset ;
   long offset ;
   long clength ;
   int fd ;
   pthread_t tid ;
   unsigned char status ;
};
#line 101 "aget_comb.c"
struct hist_data {
   struct request req ;
   int nthreads ;
   int bwritten ;
   struct thread_data wthread[25] ;
};
#line 107 "aget_comb.c"
typedef int __ssize_t;
#line 108 "aget_comb.c"
typedef __ssize_t ssize_t;
#line 109 "aget_comb.c"
typedef __builtin_va_list __gnuc_va_list;
#line 110 "aget_comb.c"
typedef __gnuc_va_list va_list;
#line 111 "aget_comb.c"
typedef unsigned int __socklen_t;
#line 112 "aget_comb.c"
typedef __socklen_t socklen_t;
#line 113 "aget_comb.c"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 120 "aget_comb.c"
struct __pthread_internal_slist {
   struct __pthread_internal_slist *__next ;
};
#line 123 "aget_comb.c"
typedef struct __pthread_internal_slist __pthread_slist_t;
#line 124 "aget_comb.c"
union __anonunion____missing_field_name_19 {
   int __spins ;
   __pthread_slist_t __list ;
};
#line 128 "aget_comb.c"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   int __kind ;
   unsigned int __nusers ;
   union __anonunion____missing_field_name_19 __annonCompField1 ;
};
#line 136 "aget_comb.c"
union __anonunion_pthread_mutex_t_18 {
   struct __pthread_mutex_s __data ;
   char __size[24] ;
   long __align ;
};
#line 141 "aget_comb.c"
typedef union __anonunion_pthread_mutex_t_18 pthread_mutex_t;
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
/* compiler builtin: 
   void *__builtin_frob_return_address(void * ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_and_and_fetch(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_or(...) ;  */
/* compiler builtin: 
   int __builtin_popcountll(unsigned long long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_or_fetch(...) ;  */
/* compiler builtin: 
   float __builtin_atanf(float  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_addps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   unsigned long __builtin_strcspn(char const   * , char const   * ) ;  */
/* compiler builtin: 
   float __builtin_asinf(float  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_maxps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_unpckhps(float __attribute__((____vector_size____(16)))   ,
                                                                           float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   double __builtin_acos(double  ) ;  */
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_nand_fetch_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_and(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_xor_fetch_16(...) ;  */
/* compiler builtin: 
   double __builtin_cosh(double  ) ;  */
/* compiler builtin: 
   float __builtin_tanhf(float  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_nand_16(...) ;  */
/* compiler builtin: 
   void *__builtin_mempcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_sub_fetch_1(...) ;  */
/* compiler builtin: 
   long double __builtin_sqrtl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_parity(unsigned int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_or(...) ;  */
/* compiler builtin: 
   long double __builtin_coshl(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_cosl(long double  ) ;  */
/* compiler builtin: 
   float __builtin_cosf(float  ) ;  */
/* compiler builtin: 
   void __sync_synchronize(...) ;  */
/* compiler builtin: 
   long double __builtin_acosl(long double  ) ;  */
/* compiler builtin: 
   void *__builtin___mempcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_or_and_fetch(...) ;  */
/* compiler builtin: 
   int __builtin_clz(unsigned int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_nand_fetch_4(...) ;  */
/* compiler builtin: 
   double __builtin_log10(double  ) ;  */
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   float __builtin_modff(float  , float * ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_sub_fetch_4(...) ;  */
/* compiler builtin: 
   _Bool __atomic_compare_exchange_n(...) ;  */
/* compiler builtin: 
   double __builtin_sin(double  ) ;  */
/* compiler builtin: 
   double __builtin_frexp(double  , int * ) ;  */
/* compiler builtin: 
   float __builtin_acosf(float  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_add_and_fetch(...) ;  */
/* compiler builtin: 
   long double __builtin_sinhl(long double  ) ;  */
/* compiler builtin: 
   char *__builtin___stpcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void __atomic_signal_fence(int  ) ;  */
/* compiler builtin: 
   double __builtin_fabs(double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_nand_1(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_and_fetch_16(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_nand(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_xor_fetch_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_xor_fetch_2(...) ;  */
/* compiler builtin: 
   void __atomic_thread_fence(int  ) ;  */
/* compiler builtin: 
   void __atomic_store_16(...) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_and_8(...) ;  */
/* compiler builtin: 
   short __builtin_bswap16(short  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_and_fetch_2(...) ;  */
/* compiler builtin: 
   _Bool __atomic_test_and_set(void * , int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_add_8(...) ;  */
/* compiler builtin: 
   int __builtin_ctz(unsigned int  ) ;  */
/* compiler builtin: 
   char *__builtin_strpbrk(char const   * , char const   * ) ;  */
/* compiler builtin: 
   char *__builtin_strcpy(char * , char const   * ) ;  */
/* compiler builtin: 
   double __builtin_sqrt(double  ) ;  */
/* compiler builtin: 
   __builtin_va_list __builtin_next_arg(void) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_nand(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_exchange_16(...) ;  */
/* compiler builtin: 
   void __atomic_clear(_Bool * , int  ) ;  */
/* compiler builtin: 
   void __atomic_store(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_add_fetch_2(...) ;  */
/* compiler builtin: 
   float __builtin_log10f(float  ) ;  */
/* compiler builtin: 
   long double __builtin_fabsl(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_floorl(long double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_xor_1(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_and_fetch(...) ;  */
/* compiler builtin: 
   float __builtin_floorf(float  ) ;  */
/* compiler builtin: 
   _Bool __atomic_compare_exchange_4(...) ;  */
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_sub_and_fetch(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_nand_and_fetch(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_load_16(...) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_subps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   int __builtin_parityll(unsigned long long  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_bzero(void * , unsigned long  ) ;  */
/* compiler builtin: 
   _Bool __atomic_always_lock_free(unsigned long  , void * ) ;  */
/* compiler builtin: 
   int __builtin_strncmp(char const   * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_nand_fetch_16(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_xor_and_fetch(...) ;  */
/* compiler builtin: 
   int __builtin___vsprintf_chk(char * , int  , unsigned long  , char const   * ,
                                __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __builtin_sqrtf(float  ) ;  */
/* compiler builtin: 
   double __builtin_nans(char const   * ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_xor_8(...) ;  */
/* compiler builtin: 
   double __builtin_exp(double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_exchange_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_exchange_1(...) ;  */
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
/* compiler builtin: 
   float __builtin_ldexpf(float  , int  ) ;  */
/* compiler builtin: 
   float __builtin_powif(float  , int  ) ;  */
/* compiler builtin: 
   long double __builtin_log10l(long double  ) ;  */
/* compiler builtin: 
   void *__builtin___memmove_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_and(...) ;  */
/* compiler builtin: 
   void *__builtin_return_address(unsigned int  ) ;  */
/* compiler builtin: 
   void __atomic_feraiseexcept(int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_and_fetch_4(...) ;  */
/* compiler builtin: 
   float __builtin_fabsf(float  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_or_fetch_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_or_fetch_4(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_or_fetch_1(...) ;  */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack_len(void) ;  */
/* compiler builtin: 
   long double __builtin_tanl(long double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_and_2(...) ;  */
/* compiler builtin: 
   void __sync_lock_release(...) ;  */
/* compiler builtin: 
   long double __builtin_modfl(long double  , long double * ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_nand_8(...) ;  */
/* compiler builtin: 
   char *__builtin_stpcpy(char * , char const   * ) ;  */
/* compiler builtin: 
   long double __builtin_sinl(long double  ) ;  */
/* compiler builtin: 
   double __builtin_asin(double  ) ;  */
/* compiler builtin: 
   float __builtin_sinhf(float  ) ;  */
/* compiler builtin: 
   int __builtin_ctzl(unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_tanhl(long double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_add(...) ;  */
/* compiler builtin: 
   long __builtin_bswap64(long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_nand_fetch_1(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_nand_2(...) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_mulps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   double __builtin_tan(double  ) ;  */
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   float __builtin_inff(void) ;  */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_load_n(...) ;  */
/* compiler builtin: 
   double __builtin_huge_val(void) ;  */
/* compiler builtin: 
   int __builtin_clzl(unsigned long  ) ;  */
/* compiler builtin: 
   _Bool __atomic_compare_exchange_16(...) ;  */
/* compiler builtin: 
   float __builtin_frexpf(float  , int * ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_exchange_n(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_or_1(...) ;  */
/* compiler builtin: 
   long double __builtin_fmodl(long double  ) ;  */
/* compiler builtin: 
   double __builtin_atan(double  ) ;  */
/* compiler builtin: 
   int __builtin___fprintf_chk(void * , int  , char const   *  , ...) ;  */
/* compiler builtin: 
   float __builtin_ceilf(float  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_or_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_add_1(...) ;  */
/* compiler builtin: 
   void __builtin_return(void const   * ) ;  */
/* compiler builtin: 
   long double __builtin_asinl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_ffsll(unsigned long long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_sub_1(...) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_or_4(...) ;  */
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_powi(double  , int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_load_2(...) ;  */
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
/* compiler builtin: 
   char *__builtin___strncat_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   void __atomic_store_2(...) ;  */
/* compiler builtin: 
   long double __builtin_huge_vall(void) ;  */
/* compiler builtin: 
   int __builtin_ffsl(unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin___vprintf_chk(int  , char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_unpcklps(float __attribute__((____vector_size____(16)))   ,
                                                                           float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   char *__builtin_strncat(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin_ctzll(unsigned long long  ) ;  */
/* compiler builtin: 
   void __builtin_stdarg_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_exchange_4(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_xor(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_sub_4(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_and_4(...) ;  */
/* compiler builtin: 
   long double __builtin_frexpl(long double  , int * ) ;  */
/* compiler builtin: 
   _Bool __atomic_compare_exchange(...) ;  */
/* compiler builtin: 
   float __builtin_tanf(float  ) ;  */
/* compiler builtin: 
   long double __builtin_logl(long double  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_load_1(...) ;  */
/* compiler builtin: 
   _Bool __atomic_compare_exchange_1(...) ;  */
/* compiler builtin: 
   int __builtin___printf_chk(int  , char const   *  , ...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_xor_2(...) ;  */
/* compiler builtin: 
   int __builtin___vfprintf_chk(void * , int  , char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_prefetch(void const   *  , ...) ;  */
/* compiler builtin: 
   long double __builtin_nansl(char const   * ) ;  */
/* compiler builtin: 
   double __builtin_fmod(double  ) ;  */
/* compiler builtin: 
   void __atomic_load(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_or_fetch_16(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_add_fetch_16(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_val_compare_and_swap(...) ;  */
/* compiler builtin: 
   void __atomic_store_4(...) ;  */
/* compiler builtin: 
   double __builtin_tanh(double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_and_1(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_nand_4(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_add_16(...) ;  */
/* compiler builtin: 
   void __builtin_unreachable(void) ;  */
/* compiler builtin: 
   _Bool __atomic_compare_exchange_2(...) ;  */
/* compiler builtin: 
   long double __builtin_ldexpl(long double  , int  ) ;  */
/* compiler builtin: 
   void *__builtin_apply(void (*)() , void * , unsigned long  ) ;  */
/* compiler builtin: 
   float __builtin_sinf(float  ) ;  */
/* compiler builtin: 
   double __builtin_ceil(double  ) ;  */
/* compiler builtin: 
   void __atomic_exchange(...) ;  */
/* compiler builtin: 
   long double __builtin_powil(long double  , int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_sub_fetch_8(...) ;  */
/* compiler builtin: 
   long double __builtin_expl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_constant_p(int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_sub_16(...) ;  */
/* compiler builtin: 
   double __builtin_log(double  ) ;  */
/* compiler builtin: 
   float __builtin_expf(float  ) ;  */
/* compiler builtin: 
   int __builtin_types_compatible_p(unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_atan2l(long double  , long double  ) ;  */
/* compiler builtin: 
   void *__builtin_apply_args(void) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_exchange_2(...) ;  */
/* compiler builtin: 
   float __builtin_logf(float  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_sub_fetch_2(...) ;  */
/* compiler builtin: 
   unsigned long __builtin_strlen(char const   * ) ;  */
/* compiler builtin: 
   int __builtin_ffs(unsigned int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_xor_16(...) ;  */
/* compiler builtin: 
   double __builtin_inf(void) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_or_16(...) ;  */
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_load_4(...) ;  */
/* compiler builtin: 
   void __atomic_store_n(...) ;  */
/* compiler builtin: 
   void __builtin_trap(void) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_add_4(...) ;  */
/* compiler builtin: 
   int __builtin_parityl(unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_nand_fetch_2(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_lock_test_and_set(...) ;  */
/* compiler builtin: 
   unsigned long __builtin_strspn(char const   * , char const   * ) ;  */
/* compiler builtin: 
   void __builtin_varargs_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_sub_fetch(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_and_16(...) ;  */
/* compiler builtin: 
   _Bool __atomic_compare_exchange_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_nand_fetch(...) ;  */
/* compiler builtin: 
   double __builtin_nan(char const   * ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_load_8(...) ;  */
/* compiler builtin: 
   int __builtin___snprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                char const   *  , ...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_xor_fetch_4(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_sub_2(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_add_fetch(...) ;  */
/* compiler builtin: 
   long double __builtin_atanl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_clzll(unsigned long long  ) ;  */
/* compiler builtin: 
   float __builtin_huge_valf(void) ;  */
/* compiler builtin: 
   float __builtin_coshf(float  ) ;  */
/* compiler builtin: 
   float __builtin_nansf(char const   * ) ;  */
/* compiler builtin: 
   void __atomic_store_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_xor_fetch(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_add(...) ;  */
/* compiler builtin: 
   int __builtin___vsnprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                 char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __builtin_nanf(char const   * ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_or_fetch_2(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_add_fetch_1(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_xor(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_add_fetch_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_xor_4(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_sub_8(...) ;  */
/* compiler builtin: 
   _Bool __sync_bool_compare_and_swap(...) ;  */
/* compiler builtin: 
   double __builtin_atan2(double  , double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __builtin_tgmath(...) ;  */
/* compiler builtin: 
   int __builtin_popcountl(unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_and_fetch_1(...) ;  */
/* compiler builtin: 
   long double __builtin_ceill(long double  ) ;  */
/* compiler builtin: 
   void __atomic_store_1(...) ;  */
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_xor_fetch_1(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_or_2(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_sub_fetch_16(...) ;  */
/* compiler builtin: 
   double __builtin_floor(double  ) ;  */
/* compiler builtin: 
   double __builtin_cos(double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_sub(...) ;  */
/* compiler builtin: 
   void *__builtin_memset(void * , int  , int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_add_2(...) ;  */
/* compiler builtin: 
   long double __builtin_nanl(char const   * ) ;  */
/* compiler builtin: 
   float __builtin_atan2f(float  , float  ) ;  */
/* compiler builtin: 
   _Bool __atomic_is_lock_free(unsigned long  , void * ) ;  */
/* compiler builtin: 
   int __builtin_popcount(unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_sinh(double  ) ;  */
/* compiler builtin: 
   void __builtin_bcopy(void const   * , void * , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_and_fetch_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_sub(...) ;  */
/* compiler builtin: 
   void *__builtin_extract_return_addr(void * ) ;  */
/* compiler builtin: 
   int __builtin_bswap32(int  ) ;  */
/* compiler builtin: 
   double __builtin_ldexp(double  , int  ) ;  */
/* compiler builtin: 
   long double __builtin_infl(void) ;  */
/* compiler builtin: 
   float __builtin_fmodf(float  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_add_fetch_4(...) ;  */
/* compiler builtin: 
   void *__builtin_frame_address(unsigned int  ) ;  */
#line 142
#pragma merger(0,"/tmp/cil-96Ono5Br.i","-g,-Wall,-W,-pedantic")
#line 143
extern int *__errno_location(void)  __attribute__((__nothrow__, __const__)) ;
#line 144
extern char *optarg ;
#line 145
extern int optind ;
#line 146
extern int getopt(int ___argc , char **___argv , char const   *__shortopts )  __attribute__((__nothrow__)) ;
#line 148
extern int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__,
__nothrow__)) ;
#line 150
extern void *calloc(size_t __nmemb , size_t __size )  __attribute__((__nothrow__,
__malloc__)) ;
#line 151
extern void exit(int __status )  __attribute__((__nothrow__, __noreturn__)) ;
#line 152
extern struct _IO_FILE *stderr ;
#line 153
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 155
extern int printf(char const   * __restrict  __format  , ...) ;
#line 156
extern char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                          char const   * __restrict  __src ,
                                                          size_t __n )  __attribute__((__nothrow__)) ;
#line 158
extern char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__nothrow__,
__malloc__)) ;
#line 160
extern char *strerror(int __errnum )  __attribute__((__nothrow__)) ;
#line 161
extern int ( __attribute__((__nonnull__(1))) sigemptyset)(sigset_t *__set )  __attribute__((__nothrow__)) ;
#line 162
extern int ( __attribute__((__nonnull__(1))) sigaddset)(sigset_t *__set , int __signo )  __attribute__((__nothrow__)) ;
#line 163
extern int pthread_sigmask(int __how , __sigset_t const   * __restrict  __newmask ,
                           __sigset_t * __restrict  __oldmask )  __attribute__((__nothrow__)) ;
#line 165
extern int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                               pthread_attr_t const   * __restrict  __attr ,
                                                               void *(*__start_routine)(void * ) ,
                                                               void * __restrict  __arg )  __attribute__((__nothrow__)) ;
#line 169
void parse_url(char *url , struct request *req___0 ) ;
#line 170
void usage(void) ;
#line 171
void Log(char *fmt  , ...) ;
#line 172 "aget_comb.c"
time_t t_start  ;
#line 173 "aget_comb.c"
time_t t_finish  ;
#line 174
int read_log(struct hist_data *h ) ;
#line 175
void get(struct request *req___0 ) ;
#line 176
void resume_get(struct hist_data *h ) ;
#line 177 "aget_comb.c"
sigset_t signal_set  ;
#line 178
void *signal_waiter(void *arg ) ;
#line 179 "aget_comb.c"
char *fullurl  ;
#line 180 "aget_comb.c"
int nthreads  ;
#line 181 "aget_comb.c"
int fsuggested  =    0;
#line 182 "aget_comb.c"
struct request *req  ;
#line 183 "aget_comb.c"
pthread_t hthread  ;
#line 184 "aget_comb.c"
struct thread_data *wthread  ;
#line 185 "aget_comb.c"
int main(int argc , char **argv ) 
{ 
  int c ;
  int error ;
  int ret ;
  struct hist_data h ;
  int retlog ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 196
  error = 0;
#line 197
  tmp = calloc(1U, (size_t )sizeof(struct request ));
#line 198
  req = (struct request *)tmp;
#line 199
  sigemptyset(& signal_set);
#line 200
  sigaddset(& signal_set, 2);
#line 201
  sigaddset(& signal_set, 14);
#line 202
  pthread_sigmask(0, (__sigset_t const   * __restrict  )(& signal_set), (__sigset_t * __restrict  )((void *)0));
#line 203
  ret = pthread_create((pthread_t * __restrict  )(& hthread), (pthread_attr_t const   * __restrict  )((void *)0),
                       & signal_waiter, (void * __restrict  )((void *)0));
  }
#line 205
  if (ret != 0) {
    {
#line 206
    tmp___0 = __errno_location();
#line 207
    tmp___1 = strerror(*tmp___0);
#line 208
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"main: cannot create signal_waiter thread: %s, exiting...\n",
            tmp___1);
#line 210
    exit(-1);
    }
  }
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 213
    if (! error) {
      {
#line 214
      c = getopt(argc, (char **)argv, (char const   *)"p:l:n:hfv");
      }
#line 215
      if (! (c != -1)) {
#line 216
        goto while_break;
      }
    } else {
#line 219
      goto while_break;
    }
    {
#line 222
    if (c == 112) {
#line 222
      goto case_112;
    }
#line 225
    if (c == 102) {
#line 225
      goto case_102;
    }
#line 228
    if (c == 108) {
#line 228
      goto case_108;
    }
#line 232
    if (c == 110) {
#line 232
      goto case_110;
    }
#line 239
    if (c == 104) {
#line 239
      goto case_104;
    }
#line 244
    if (c == 118) {
#line 244
      goto case_118;
    }
#line 249
    goto switch_default;
    case_112: /* CIL Label */ 
    {
#line 223
    req->port = atoi((char const   *)optarg);
    }
#line 224
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 226
    fsuggested = 1;
    }
#line 227
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 229
    strncpy((char * __restrict  )(req->lfile), (char const   * __restrict  )optarg,
            512U);
    }
#line 231
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 233
    nthreads = atoi((char const   *)optarg);
    }
#line 234
    if (nthreads > 25) {
      {
#line 235
      Log("Error: Maximum # of threads allowed is %d\n", 25);
#line 236
      nthreads = 0;
      }
    }
#line 238
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 240
    printf((char const   * __restrict  )"%s\n", "EnderUNIX Aget v0.4");
#line 241
    usage();
#line 242
    exit(0);
    }
#line 243
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 245
    printf((char const   * __restrict  )"%s\nby Murat BALABAN <murat@enderunix.org>\n",
           "EnderUNIX Aget v0.4");
#line 247
    exit(0);
    }
#line 248
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 250
    error = 1;
#line 251
    usage();
#line 252
    exit(1);
    }
#line 253
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 256
  if (error) {
    {
#line 257
    usage();
#line 258
    exit(1);
    }
  }
#line 260
  if (fsuggested == 1) {
#line 261
    if (nthreads == 0) {
      {
#line 262
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\nERROR: -f and -n should be used together!, exiting...\n\n");
#line 263
      usage();
#line 264
      exit(1);
      }
    }
  }
#line 267
  if (argc == 2) {
    {
#line 268
    fullurl = strdup((char const   *)*(argv + 1));
    }
  } else
#line 270
  if (optind < argc) {
#line 271
    if (argc > 2) {
      {
#line 272
      fullurl = strdup((char const   *)*(argv + optind));
      }
    } else {
      {
#line 274
      usage();
#line 275
      exit(1);
      }
    }
  } else
#line 278
  if (optind == argc) {
    {
#line 279
    usage();
#line 280
    exit(1);
    }
  }
  {
#line 284
  parse_url(fullurl, req);
#line 285
  retlog = read_log(& h);
  }
#line 286
  if (retlog != -1) {
    {
#line 287
    resume_get(& h);
    }
  } else {
    {
#line 289
    get(req);
    }
  }
#line 291
  return (0);
}
}
#line 294
#pragma merger(0,"/tmp/cil-vCwIYZEB.i","-g,-Wall,-W,-pedantic")
#line 295
extern int snprintf(char * __restrict  __s , size_t __maxlen , char const   * __restrict  __format 
                    , ...)  __attribute__((__nothrow__)) ;
#line 299
extern void *malloc(size_t __size )  __attribute__((__nothrow__, __malloc__)) ;
#line 300
extern void free(void *__ptr )  __attribute__((__nothrow__)) ;
#line 301
extern void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                         void const   * __restrict  __src ,
                                                         size_t __n )  __attribute__((__nothrow__)) ;
#line 303
extern size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__,
__nothrow__)) ;
#line 305
extern time_t time(time_t *__timer )  __attribute__((__nothrow__)) ;
#line 306
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 307
extern int pthread_cancel(pthread_t __th ) ;
#line 308
extern __off_t lseek(int __fd , __off_t __offset , int __whence )  __attribute__((__nothrow__)) ;
#line 309
extern int close(int __fd ) ;
#line 310
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 311
extern int dup(int __fd )  __attribute__((__nothrow__)) ;
#line 312
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 313
extern uint16_t htons(uint16_t __hostshort )  __attribute__((__nothrow__, __const__)) ;
#line 314
extern in_addr_t inet_addr(char const   *__cp )  __attribute__((__nothrow__)) ;
#line 315
void http_head_req(struct request *req___0 ) ;
#line 316
int calc_offset(int total , int part , int nthreads___0 ) ;
#line 317
int numofthreads(int size ) ;
#line 318
void *http_get(void *arg ) ;
#line 319 "aget_comb.c"
void get(struct request *req___0 ) 
{ 
  int i ;
  int ret ;
  int fd ;
  int diff_sec ;
  int nok ;
  long soffset ;
  long foffset ;
  char *fmt ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  __off_t tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  ssize_t tmp___10 ;
  void *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
#line 345
  nok = 0;
  }
#line 346
  if ((int )req___0->proto == 255) {
    {
#line 347
    http_head_req(req___0);
    }
  }
  {
#line 349
  ret = numofthreads(req___0->clength);
  }
#line 350
  if (fsuggested == 0) {
#line 351
    if (ret == 0) {
      {
#line 352
      nthreads = 1;
      }
    } else {
      {
#line 354
      nthreads = ret;
      }
    }
  }
  {
#line 357
  tmp = malloc((size_t )((unsigned long )((unsigned int )nthreads) * sizeof(struct thread_data )));
#line 358
  wthread = (struct thread_data *)tmp;
#line 359
  Log("Downloading %s (%d bytes) from site %s(%s:%d). Number of Threads: %d", req___0->url,
      req___0->clength, req___0->host, req___0->ip, req___0->port, nthreads);
#line 361
  tmp___4 = strlen((char const   *)(req___0->lfile));
  }
#line 362
  if (tmp___4 != 0U) {
    {
#line 363
    fd = open((char const   *)(req___0->lfile), 66, 448);
    }
#line 364
    if (fd == -1) {
      {
#line 365
      tmp___0 = __errno_location();
#line 366
      tmp___1 = strerror(*tmp___0);
#line 367
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"get: cannot open file %s for writing: %s\n",
              req___0->lfile, tmp___1);
#line 369
      exit(1);
      }
    }
  } else {
    {
#line 372
    fd = open((char const   *)(req___0->file), 66, 448);
    }
#line 373
    if (fd == -1) {
      {
#line 374
      tmp___2 = __errno_location();
#line 375
      tmp___3 = strerror(*tmp___2);
#line 376
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"get: cannot open file %s for writing: %s\n",
              req___0->lfile, tmp___3);
#line 378
      exit(1);
      }
    }
  }
  {
#line 381
  tmp___7 = lseek(fd, (long )(req___0->clength - 1), 0);
  }
#line 382
  if (tmp___7 == -1L) {
    {
#line 383
    tmp___5 = __errno_location();
#line 384
    tmp___6 = strerror(*tmp___5);
#line 385
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"get: couldn\'t lseek:  %s\n",
            tmp___6);
#line 387
    exit(1);
    }
  }
  {
#line 389
  tmp___10 = write(fd, (void const   *)"0", 1U);
  }
#line 390
  if (tmp___10 == -1) {
    {
#line 391
    tmp___8 = __errno_location();
#line 392
    tmp___9 = strerror(*tmp___8);
#line 393
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"get: couldn\'t allocate space for download file: %s\n",
            tmp___9);
#line 395
    exit(1);
    }
  }
  {
#line 397
  tmp___11 = calloc(254U, (size_t )sizeof(char ));
#line 398
  fmt = (char *)tmp___11;
#line 399
  time(& t_start);
#line 400
  i = 0;
  }
  {
#line 401
  while (1) {
    while_continue: /* CIL Label */ ;
#line 401
    if (! (i < nthreads)) {
#line 401
      goto while_break;
    }
    {
#line 402
    tmp___12 = calc_offset(req___0->clength, i, nthreads);
#line 403
    soffset = (long )tmp___12;
#line 404
    tmp___13 = calc_offset(req___0->clength, i + 1, nthreads);
#line 405
    foffset = (long )tmp___13;
#line 406
    (wthread + i)->soffset = soffset;
    }
#line 407
    if (i == nthreads - 1) {
      {
#line 408
      (wthread + i)->foffset = (long )req___0->clength;
      }
    } else {
      {
#line 410
      (wthread + i)->foffset = foffset;
      }
    }
    {
#line 412
    (wthread + i)->sin.sin_family = (unsigned short)2;
#line 413
    (wthread + i)->sin.sin_addr.s_addr = inet_addr((char const   *)(req___0->ip));
#line 414
    (wthread + i)->sin.sin_port = htons((unsigned short )req___0->port);
#line 415
    (wthread + i)->fd = dup(fd);
#line 416
    (wthread + i)->clength = (long )req___0->clength;
#line 417
    snprintf((char * __restrict  )fmt, 256U, (char const   * __restrict  )"GET %s HTTP/1.1\r\nHost: %s\r\nUser-Agent: %s\r\nRange: bytes=%ld-\r\nConnection: close\r\n\r\n",
             req___0->url, req___0->host, "EnderUNIX Aget v0.4", soffset);
#line 419
    strncpy((char * __restrict  )((wthread + i)->getstr), (char const   * __restrict  )fmt,
            256U);
#line 421
    pthread_create((pthread_t * __restrict  )(& (wthread + i)->tid), (pthread_attr_t const   * __restrict  )((void *)0),
                   & http_get, (void * __restrict  )(wthread + i));
#line 423
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 425
  free((void *)fmt);
#line 426
  i = 0;
  }
  {
#line 427
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 427
    if (! (i < nthreads)) {
#line 427
      goto while_break___0;
    }
    {
#line 428
    pthread_join((wthread + i)->tid, (void **)((void *)0));
    }
#line 429
    if ((int )(wthread + i)->status == 255) {
      {
#line 430
      nok ++;
      }
    }
    {
#line 432
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 434
  if (nok == nthreads) {
    {
#line 435
    pthread_cancel(hthread);
    }
  } else {
    {
#line 437
    pthread_join(hthread, (void **)((void *)0));
    }
  }
  {
#line 439
  time(& t_finish);
#line 440
  diff_sec = (int )(t_finish - t_start);
  }
#line 441
  if (diff_sec == 0) {
    {
#line 442
    diff_sec = 1;
    }
  }
  {
#line 444
  Log("Download completed, job completed in %d seconds. (%d Kb/sec)", diff_sec, (req___0->clength / diff_sec) / 1024);
#line 446
  Log("Shutting down...");
#line 447
  close(fd);
  }
#line 448
  return;
}
}
#line 451 "aget_comb.c"
void resume_get(struct hist_data *h ) 
{ 
  int i ;
  int fd ;
  int diff_sec ;
  int nok ;
  char *fmt ;
  void *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;

  {
  {
#line 466
  nok = 0;
#line 467
  nthreads = h->nthreads;
#line 468
  tmp = calloc(254U, (size_t )sizeof(char ));
#line 469
  fmt = (char *)tmp;
#line 470
  tmp___0 = malloc((size_t )((unsigned long )((unsigned int )nthreads) * sizeof(struct thread_data )));
#line 471
  wthread = (struct thread_data *)tmp___0;
#line 472
  memcpy((void * __restrict  )req, (void const   * __restrict  )(& h->req), (size_t )sizeof(struct request ));
#line 473
  memcpy((void * __restrict  )wthread, (void const   * __restrict  )(h->wthread),
         (size_t )(sizeof(struct thread_data ) * (unsigned long )((unsigned int )nthreads)));
#line 475
  Log("Resuming download %s (%d bytes) from site %s(%s:%d). Number of Threads: %d",
      req->url, req->clength, req->host, req->ip, req->port, nthreads);
#line 477
  tmp___5 = strlen((char const   *)(req->lfile));
  }
#line 478
  if (tmp___5 != 0U) {
    {
#line 479
    fd = open((char const   *)(req->lfile), 2, 448);
    }
#line 480
    if (fd == -1) {
      {
#line 481
      tmp___1 = __errno_location();
#line 482
      tmp___2 = strerror(*tmp___1);
#line 483
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"get: cannot open file %s for writing: %s\n",
              req->lfile, tmp___2);
#line 485
      exit(1);
      }
    }
  } else {
    {
#line 488
    fd = open((char const   *)(req->file), 2, 448);
    }
#line 489
    if (fd == -1) {
      {
#line 490
      tmp___3 = __errno_location();
#line 491
      tmp___4 = strerror(*tmp___3);
#line 492
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"get: cannot open file %s for writing: %s\n",
              req->lfile, tmp___4);
#line 494
      exit(1);
      }
    }
  }
  {
#line 497
  time(& t_start);
#line 498
  i = 0;
  }
  {
#line 499
  while (1) {
    while_continue: /* CIL Label */ ;
#line 499
    if (! (i < nthreads)) {
#line 499
      goto while_break;
    }
    {
#line 500
    (wthread + i)->soffset = (wthread + i)->offset;
#line 501
    (wthread + i)->fd = dup(fd);
#line 502
    snprintf((char * __restrict  )fmt, 256U, (char const   * __restrict  )"GET %s HTTP/1.1\r\nHost: %s\r\nUser-Agent: %s\r\nRange: bytes=%ld-\r\nConnection: close\r\n\r\n",
             req->url, req->host, "EnderUNIX Aget v0.4", (wthread + i)->offset);
#line 504
    strncpy((char * __restrict  )((wthread + i)->getstr), (char const   * __restrict  )fmt,
            256U);
#line 506
    pthread_create((pthread_t * __restrict  )(& (wthread + i)->tid), (pthread_attr_t const   * __restrict  )((void *)0),
                   & http_get, (void * __restrict  )(wthread + i));
#line 508
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 510
  i = 0;
  }
  {
#line 511
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 511
    if (! (i < nthreads)) {
#line 511
      goto while_break___0;
    }
    {
#line 512
    pthread_join((wthread + i)->tid, (void **)((void *)0));
#line 513
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 515
  i = 0;
  }
  {
#line 516
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 516
    if (! (i < nthreads)) {
#line 516
      goto while_break___1;
    }
    {
#line 517
    pthread_join((wthread + i)->tid, (void **)((void *)0));
    }
#line 518
    if ((int )(wthread + i)->status == 255) {
      {
#line 519
      nok ++;
      }
    }
    {
#line 521
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 523
  if (nok == nthreads) {
    {
#line 524
    pthread_cancel(hthread);
    }
  } else {
    {
#line 526
    pthread_join(hthread, (void **)((void *)0));
    }
  }
  {
#line 528
  time(& t_finish);
#line 529
  diff_sec = (int )(t_finish - t_start);
  }
#line 530
  if (diff_sec == 0) {
    {
#line 531
    diff_sec = 1;
    }
  }
  {
#line 533
  Log("Download completed, job completed in %d seconds. (%d Kb/sec)", diff_sec, ((req->clength - h->bwritten) / diff_sec) / 1024);
#line 535
  Log("Shutting down...");
#line 536
  close(fd);
  }
#line 537
  return;
}
}
#line 544
#pragma merger(0,"/tmp/cil-rsiEkcjk.i","-g,-Wall,-W,-pedantic")
#line 545
extern struct _IO_FILE *stdout ;
#line 546
extern int fflush(FILE *__stream ) ;
#line 547
extern int sprintf(char * __restrict  __s , char const   * __restrict  __format  , ...)  __attribute__((__nothrow__)) ;
#line 549
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 551
extern int putchar(int __c ) ;
#line 552
extern void *( __attribute__((__nonnull__(1))) memset)(void *__s , int __c , size_t __n )  __attribute__((__nothrow__)) ;
#line 553
extern int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 , char const   *__s2 ,
                                                        size_t __n )  __attribute__((__pure__,
__nothrow__)) ;
#line 556
extern char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                         char const   *__needle )  __attribute__((__pure__,
__nothrow__)) ;
#line 558
void revstr(char *str ) ;
#line 559
void updateProgressBar(float cur , float tot ) ;
#line 560
void handleHttpRetcode(char *rbuf ) ;
#line 561 "aget_comb.c"
void parse_url(char *url , struct request *req___0 ) 
{ 
  char *s ;
  int i ;
  int j ;
  int k ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 572
  k = 0;
#line 573
  j = k;
#line 574
  i = j;
#line 575
  s = url;
#line 576
  tmp___0 = strncmp((char const   *)url, (char const   *)"ftp://", 6U);
  }
#line 577
  if (tmp___0 == 0) {
    {
#line 578
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: Currently Aget doesn\'t support FTP requests...\n");
#line 579
    exit(1);
    }
  } else {
    {
#line 581
    tmp = strncmp((char const   *)url, (char const   *)"http://", 7U);
    }
#line 582
    if (tmp != 0) {
      {
#line 583
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: URL should be of the form http://...\n");
#line 584
      exit(1);
      }
    }
  }
#line 587
  if (req___0->port == 0) {
    {
#line 588
    req___0->port = 80;
#line 589
    req___0->proto = (unsigned char)255;
    }
  }
  {
#line 591
  s = url + 7;
#line 592
  i = 0;
  }
  {
#line 593
  while (1) {
    while_continue: /* CIL Label */ ;
#line 593
    if (! ((int )*s != 47)) {
#line 593
      goto while_break;
    }
#line 594
    if (i > 1024) {
      {
#line 595
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: Cannot get hostname from URL...\n");
#line 596
      exit(1);
      }
    }
#line 598
    if ((int )*s == 58) {
      {
#line 599
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 599
        if (! ((int )*s != 47)) {
#line 599
          goto while_break___0;
        }
        {
#line 600
        tmp___1 = j;
#line 601
        j ++;
#line 602
        s --;
#line 603
        req___0->username[tmp___1] = *s;
#line 604
        i --;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 606
      j --;
#line 607
      req___0->username[j] = (char )'\000';
#line 608
      revstr(req___0->username);
      }
      {
#line 609
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 610
        if ((int )*s == 58) {
          {
#line 611
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 611
            if (! ((int )*s != 64)) {
#line 611
              goto while_break___2;
            }
#line 612
            if (k > 512) {
              {
#line 613
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: Cannot get password from URL...\n");
#line 614
              exit(1);
              }
            }
            {
#line 616
            tmp___2 = k;
#line 617
            k ++;
#line 618
            s ++;
#line 619
            req___0->password[tmp___2] = *s;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
#line 621
          goto while_break___1;
        }
        {
#line 623
        s ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 625
      k --;
#line 626
      req___0->password[k] = (char )'\000';
      }
    }
    {
#line 628
    req___0->host[i] = *s;
#line 629
    i ++;
#line 630
    s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 632
  req___0->host[i] = (char )'\000';
#line 633
  i = 0;
  }
  {
#line 634
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 634
    if (! ((int )*s != 0)) {
#line 634
      goto while_break___3;
    }
#line 635
    if (i > 1024) {
      {
#line 636
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: Cannot get remote file name from URL...\n");
#line 637
      exit(1);
      }
    }
    {
#line 639
    req___0->url[i] = *s;
#line 640
    i ++;
#line 641
    s ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 643
  req___0->url[i] = (char )'\000';
#line 644
  s --;
#line 645
  i = 0;
  }
  {
#line 646
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 646
    if (! ((int )*s != 47)) {
#line 646
      goto while_break___4;
    }
#line 647
    if (i > 512) {
      {
#line 648
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: Cannot get local file name from URL...\n");
#line 649
      exit(1);
      }
    }
    {
#line 651
    req___0->file[i] = *s;
#line 652
    i ++;
#line 653
    s --;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 655
  req___0->file[i] = (char )'\000';
#line 656
  revstr(req___0->file);
  }
#line 657
  return;
}
}
#line 660 "aget_comb.c"
int numofthreads(int size ) 
{ 


  {
#line 664
  if (size == 0) {
#line 665
    return (0);
  } else
#line 667
  if (size < 16384) {
#line 668
    return (1);
  } else
#line 670
  if (size >= 16384) {
#line 671
    if (size < 32768) {
#line 672
      return (2);
    } else {
#line 674
      goto _L___5;
    }
  } else
  _L___5: 
#line 678
  if (size >= 32768) {
#line 679
    if (size < 65536) {
#line 680
      return (3);
    } else {
#line 682
      goto _L___4;
    }
  } else
  _L___4: 
#line 686
  if (size >= 65536) {
#line 687
    if (size < 131072) {
#line 688
      return (4);
    } else {
#line 690
      goto _L___3;
    }
  } else
  _L___3: 
#line 694
  if (size >= 131072) {
#line 695
    if (size < 262144) {
#line 696
      return (5);
    } else {
#line 698
      goto _L___2;
    }
  } else
  _L___2: 
#line 702
  if (size >= 262144) {
#line 703
    if (size < 524288) {
#line 704
      return (6);
    } else {
#line 706
      goto _L___1;
    }
  } else
  _L___1: 
#line 710
  if (size >= 524288) {
#line 711
    if (size < 1048576) {
#line 712
      return (7);
    } else {
#line 714
      goto _L___0;
    }
  } else
  _L___0: 
#line 718
  if (size >= 1048576) {
#line 719
    if (size < 2097152) {
#line 720
      return (8);
    } else {
#line 722
      goto _L;
    }
  } else
  _L: 
#line 726
  if (size >= 2097152) {
#line 727
    if (size < 4194304) {
#line 728
      return (9);
    } else {
#line 730
      return (10);
    }
  } else {
#line 733
    return (10);
  }
}
}
#line 746 "aget_comb.c"
int calc_offset(int total , int part , int nthreads___0 ) 
{ 


  {
#line 750
  return (part * (total / nthreads___0));
}
}
#line 753 "aget_comb.c"
void usage(void) 
{ 


  {
  {
#line 757
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"usage: aget [options] url\n");
#line 758
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\toptions:\n");
#line 759
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\t\t-p port number\n");
#line 760
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\t\t-l local file name\n");
#line 761
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\t\t-n suggested number of threads\n");
#line 762
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\t\t-f force using suggested number of threads\n");
#line 763
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\t\t-h this screen\n");
#line 764
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\t\t-v version info\n");
#line 765
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 766
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"http//www.enderunix.org/aget/\n");
  }
#line 767
  return;
}
}
#line 770 "aget_comb.c"
void revstr(char *str ) 
{ 
  char *p ;
  char *s ;
  int i ;
  int size ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 779
  tmp = strlen((char const   *)str);
#line 780
  size = (int )tmp;
  }
#line 781
  if (size == 0) {
#line 782
    return;
  }
  {
#line 784
  tmp___0 = calloc((unsigned int )size, (size_t )sizeof(char ));
#line 785
  p = (char *)tmp___0;
#line 786
  s = p;
#line 787
  i = size;
  }
  {
#line 788
  while (1) {
    while_continue: /* CIL Label */ ;
#line 788
    if (! (i >= 0)) {
#line 788
      goto while_break;
    }
    {
#line 789
    *s = *((str + i) - 1);
#line 790
    i --;
#line 791
    s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 793
  *s = (char )'\000';
#line 794
  memset((void *)str, 0, (unsigned int )size);
#line 795
  strncpy((char * __restrict  )str, (char const   * __restrict  )p, (unsigned int )size);
#line 796
  free((void *)p);
  }
#line 797
  return;
}
}
#line 800 "aget_comb.c"
void Log(char *fmt  , ...) 
{ 
  va_list ap ;
  char *lfmt ;
  size_t tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 810
  tmp = strlen((char const   *)fmt);
#line 811
  tmp___0 = calloc(7U + tmp, (size_t )sizeof(char ));
#line 812
  lfmt = (char *)tmp___0;
#line 813
  sprintf((char * __restrict  )lfmt, (char const   * __restrict  )"<LOG> %s", fmt);
#line 814
  fflush(stdout);
#line 815
  __builtin_va_start(ap, fmt);
#line 816
  vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )lfmt, ap);
#line 817
  __builtin_va_end(ap);
  }
#line 818
  if ((int )*(fmt + 0) != 0) {
    {
#line 819
    tmp___3 = strlen((char const   *)fmt);
    }
#line 820
    if ((int )*(fmt + (tmp___3 - 1U)) == 58) {
      {
#line 821
      tmp___1 = __errno_location();
#line 822
      tmp___2 = strerror(*tmp___1);
#line 823
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" %s", tmp___2);
      }
    }
  }
  {
#line 826
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 827
  free((void *)lfmt);
  }
#line 828
  return;
}
}
#line 831 "aget_comb.c"
static float prev  =    (float )-1;
#line 832 "aget_comb.c"
void updateProgressBar(float cur , float tot ) 
{ 
  float rat ;
  int ndot ;
  int i ;

  {
  {
#line 838
  rat = cur / tot;
#line 839
  ndot = (int )(rat * (float )100);
  }
#line 840
  if ((float )ndot < prev + (float )5) {
#line 841
    if (ndot != 100) {
#line 842
      return;
    }
  }
  {
#line 845
  i = 0;
  }
  {
#line 846
  while (1) {
    while_continue: /* CIL Label */ ;
#line 846
    if (! (i < ndot)) {
#line 846
      goto while_break;
    }
    {
#line 847
    putchar('.');
#line 848
    i += 2;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 850
  i = ndot - 1;
  }
  {
#line 851
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 851
    if (! (i < 100)) {
#line 851
      goto while_break___0;
    }
    {
#line 852
    putchar(' ');
#line 853
    i += 2;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 855
  printf((char const   * __restrict  )"[%d%% completed]\n", ndot);
#line 856
  prev = (float )ndot;
  }
#line 857
  return;
}
}
#line 860 "aget_comb.c"
void handleHttpRetcode(char *rbuf ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 866
  tmp___1 = strstr((char const   *)rbuf, (char const   *)"HTTP/1.1 416");
  }
#line 867
  if ((unsigned int )tmp___1 != (unsigned int )((void *)0)) {
    {
#line 868
    Log("Server returned HTTP/1.1 416 - Requested Range Not Satisfiable\n");
#line 869
    exit(1);
    }
  } else {
    {
#line 871
    tmp___0 = strstr((char const   *)rbuf, (char const   *)"HTTP/1.1 403");
    }
#line 872
    if ((unsigned int )tmp___0 != (unsigned int )((void *)0)) {
      {
#line 873
      Log("<Server returned HTTP/1.1 403 - Permission Denied\n");
#line 874
      exit(1);
      }
    } else {
      {
#line 876
      tmp = strstr((char const   *)rbuf, (char const   *)"HTTP/1.1 404");
      }
#line 877
      if ((unsigned int )tmp != (unsigned int )((void *)0)) {
        {
#line 878
        Log("<Server returned HTTP/1.1 404 - File Not Found\n");
#line 879
        exit(1);
        }
      }
    }
  }
#line 883
  return;
}
}
#line 886
#pragma merger(0,"/tmp/cil-vVPZxX0H.i","-g,-Wall,-W,-pedantic")
#line 887
extern char *( __attribute__((__nonnull__(2))) strtok)(char * __restrict  __s , char const   * __restrict  __delim )  __attribute__((__nothrow__)) ;
#line 888
extern void ( __attribute__((__nonnull__(1))) bzero)(void *__s , size_t __n )  __attribute__((__nothrow__)) ;
#line 889
extern int socket(int __domain , int __type , int __protocol )  __attribute__((__nothrow__)) ;
#line 890
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 891
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 892
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 893
extern int *__h_errno_location(void)  __attribute__((__nothrow__, __const__)) ;
#line 894
extern char const   *hstrerror(int __err_num )  __attribute__((__nothrow__)) ;
#line 895
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 896
extern char *inet_ntoa(struct in_addr __in )  __attribute__((__nothrow__)) ;
#line 897 "aget_comb.c"
void http_head_req(struct request *req___0 ) 
{ 
  struct sockaddr_in sin ;
  struct hostent *he ;
  int sd ;
  char *sbuf ;
  char *rbuf ;
  char *tok ;
  char *s ;
  int clength ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  size_t tmp___12 ;
  ssize_t tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  ssize_t tmp___16 ;
  size_t tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;

  {
  {
#line 929
  tmp = strlen((char const   *)(req___0->url));
#line 930
  tmp___0 = calloc(512U + tmp, (size_t )sizeof(char ));
#line 931
  sbuf = (char *)tmp___0;
#line 932
  tmp___1 = calloc(512U, (size_t )sizeof(char ));
#line 933
  rbuf = (char *)tmp___1;
#line 934
  he = gethostbyname((char const   *)(req___0->host));
  }
#line 935
  if ((unsigned int )he == (unsigned int )((void *)0)) {
    {
#line 936
    tmp___2 = __h_errno_location();
#line 937
    tmp___3 = hstrerror(*tmp___2);
#line 938
    Log("Error: Cannot resolve hostname for %s: %s", req___0->host, tmp___3);
#line 939
    exit(1);
    }
  }
  {
#line 941
  tmp___4 = inet_ntoa(*((struct in_addr *)*(he->h_addr_list + 0)));
#line 942
  strncpy((char * __restrict  )(req___0->ip), (char const   * __restrict  )tmp___4,
          16U);
#line 944
  time(& t_start);
#line 945
  bzero((void *)(& sin), (size_t )sizeof(sin));
#line 946
  sin.sin_family = (unsigned short)2;
#line 947
  sin.sin_addr.s_addr = inet_addr((char const   *)(req___0->ip));
#line 948
  sin.sin_port = htons((unsigned short )req___0->port);
#line 949
  sd = socket(2, 1, 0);
  }
#line 950
  if (sd == -1) {
    {
#line 951
    tmp___5 = __errno_location();
#line 952
    tmp___6 = strerror(*tmp___5);
#line 953
    Log("Socket creation failed for Head Request: %s", tmp___6);
#line 954
    exit(1);
    }
  }
  {
#line 956
  tmp___9 = connect(sd, (struct sockaddr  const  *)(& sin), (socklen_t )sizeof(sin));
  }
#line 957
  if (tmp___9 == -1) {
    {
#line 958
    tmp___7 = __errno_location();
#line 959
    tmp___8 = strerror(*tmp___7);
#line 960
    Log("Connection failed for Head Request: %s", tmp___8);
#line 961
    exit(1);
    }
  }
  {
#line 963
  Log("Head-Request Connection established");
#line 964
  sprintf((char * __restrict  )sbuf, (char const   * __restrict  )"HEAD %s HTTP/1.1\r\nHost: %s\r\nUser-Agent: %s\r\n\r\n",
          req___0->url, req___0->host, "EnderUNIX Aget v0.4");
#line 966
  tmp___12 = strlen((char const   *)sbuf);
#line 967
  tmp___13 = send(sd, (void const   *)sbuf, tmp___12, 0);
  }
#line 968
  if (tmp___13 == -1) {
    {
#line 969
    tmp___10 = __errno_location();
#line 970
    tmp___11 = strerror(*tmp___10);
#line 971
    Log("send failed for Head Request: %s", tmp___11);
#line 972
    exit(1);
    }
  }
  {
#line 974
  tmp___16 = recv(sd, (void *)rbuf, 512U, 0);
  }
#line 975
  if (tmp___16 == -1) {
    {
#line 976
    tmp___14 = __errno_location();
#line 977
    tmp___15 = strerror(*tmp___14);
#line 978
    Log("recv failed for Head Request: %s", tmp___15);
#line 979
    exit(1);
    }
  }
  {
#line 981
  handleHttpRetcode(rbuf);
#line 982
  tok = strtok((char * __restrict  )rbuf, (char const   * __restrict  )"\r\n");
#line 983
  tmp___19 = strstr((char const   *)tok, (char const   *)"HTTP/1.1 200");
  }
#line 984
  if ((unsigned int )tmp___19 != (unsigned int )((void *)0)) {
    {
#line 985
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 986
      tok = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )"\r\n");
      }
#line 987
      if (! ((unsigned int )tok != (unsigned int )((void *)0))) {
#line 988
        goto while_break;
      }
      {
#line 990
      tmp___18 = strstr((char const   *)tok, (char const   *)"Content-Length");
      }
#line 991
      if ((unsigned int )tmp___18 != (unsigned int )((void *)0)) {
        {
#line 992
        tmp___17 = strlen((char const   *)"Content-Length: ");
#line 993
        s = tok + tmp___17;
#line 994
        clength = atoi((char const   *)s);
#line 995
        req___0->clength = clength;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 999
  free((void *)sbuf);
#line 1000
  free((void *)rbuf);
  }
#line 1001
  return;
}
}
#line 1004
#pragma merger(0,"/tmp/cil-R4CIbMeC.i","-g,-Wall,-W,-pedantic")
#line 1005
extern int ( __attribute__((__nonnull__(1,2))) sigwait)(sigset_t const   * __restrict  __set ,
                                                        int * __restrict  __sig ) ;
#line 1006
extern unsigned int alarm(unsigned int __seconds )  __attribute__((__nothrow__)) ;
#line 1007
void sigint_handler(void) ;
#line 1008
void sigalrm_handler(void) ;
#line 1009
void save_log(void) ;
#line 1010
unsigned int bwritten ;
#line 1011 "aget_comb.c"
void *signal_waiter(void *arg ) 
{ 
  int signal___0 ;

  {
  {
#line 1015
  arg = (void *)0;
#line 1016
  pthread_sigmask(1, (__sigset_t const   * __restrict  )(& signal_set), (__sigset_t * __restrict  )((void *)0));
  }
  {
#line 1017
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1018
    sigwait((sigset_t const   * __restrict  )(& signal_set), (int * __restrict  )(& signal___0));
    }
    {
#line 1020
    if (signal___0 == 2) {
#line 1020
      goto case_2;
    }
#line 1023
    if (signal___0 == 14) {
#line 1023
      goto case_14;
    }
#line 1019
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1021
    sigint_handler();
    }
#line 1022
    goto switch_break;
    case_14: /* CIL Label */ 
    {
#line 1024
    sigalrm_handler();
    }
#line 1025
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1030 "aget_comb.c"
void sigint_handler(void) 
{ 
  int i ;

  {
  {
#line 1034
  printf((char const   * __restrict  )"^C caught, saving download job...\n");
#line 1035
  i = 0;
  }
  {
#line 1036
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1036
    if (! (i < nthreads)) {
#line 1036
      goto while_break;
    }
    {
#line 1037
    pthread_cancel((wthread + i)->tid);
#line 1038
    (wthread + i)->status = (unsigned char )((int )(wthread + i)->status & 15);
#line 1039
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1041
  save_log();
#line 1042
  exit(0);
  }
}
}
#line 1045 "aget_comb.c"
void sigalrm_handler(void) 
{ 


  {
  {
#line 1049
  printf((char const   * __restrict  )"Signal Alarm came\n");
#line 1050
  updateProgressBar((float )bwritten, (float )req->clength);
#line 1051
  alarm(1U);
  }
#line 1052
  return;
}
}
#line 1055
#pragma merger(0,"/tmp/cil-msdqRXZR.i","-g,-Wall,-W,-pedantic")
#line 1056
extern void pthread_exit(void *__retval )  __attribute__((__noreturn__)) ;
#line 1057
extern pthread_t pthread_self(void)  __attribute__((__nothrow__, __const__)) ;
#line 1058
extern int pthread_setcanceltype(int __type , int *__oldtype ) ;
#line 1059
extern int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex )  __attribute__((__nothrow__)) ;
#line 1060
extern int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex )  __attribute__((__nothrow__)) ;
#line 1061 "aget_comb.c"
unsigned int bwritten  =    0U;
#line 1062 "aget_comb.c"
pthread_mutex_t bwritten_mutex  =    {{0, 0U, 0, 0, 0U, {0}}};
#line 1063
extern int pwrite() ;
#line 1064 "aget_comb.c"
void *http_get(void *arg ) 
{ 
  struct thread_data *td ;
  int sd ;
  char *rbuf ;
  char *s ;
  int dr ;
  int dw ;
  int i ;
  long foffset ;
  pthread_t tid ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  ssize_t tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
  {
#line 1089
  tid = pthread_self();
#line 1090
  pthread_sigmask(0, (__sigset_t const   * __restrict  )(& signal_set), (__sigset_t * __restrict  )((void *)0));
#line 1091
  pthread_setcanceltype(1, (int *)((void *)0));
#line 1092
  td = (struct thread_data *)arg;
#line 1093
  foffset = td->foffset;
#line 1094
  tmp = calloc(8192U, (size_t )sizeof(char ));
#line 1095
  rbuf = (char *)tmp;
#line 1096
  sd = socket(2, 1, 0);
  }
#line 1097
  if (sd == -1) {
    {
#line 1098
    tmp___0 = __errno_location();
#line 1099
    tmp___1 = strerror(*tmp___0);
#line 1100
    Log("<THREAD #%ld> socket creation failed: %s", tid, tmp___1);
#line 1101
    pthread_exit((void *)1);
    }
  }
  {
#line 1103
  tmp___4 = connect(sd, (struct sockaddr  const  *)(& td->sin), (socklen_t )sizeof(struct sockaddr ));
  }
#line 1104
  if (tmp___4 == -1) {
    {
#line 1105
    tmp___2 = __errno_location();
#line 1106
    tmp___3 = strerror(*tmp___2);
#line 1107
    Log("<THREAD #%ld> connection failed: %s", tid, tmp___3);
#line 1108
    pthread_exit((void *)1);
    }
  }
  {
#line 1110
  tmp___7 = strlen((char const   *)(td->getstr));
#line 1111
  tmp___8 = send(sd, (void const   *)(td->getstr), tmp___7, 0);
  }
#line 1112
  if (tmp___8 == -1) {
    {
#line 1113
    tmp___5 = __errno_location();
#line 1114
    tmp___6 = strerror(*tmp___5);
#line 1115
    Log("<THREAD #%ld> send failed: %s", tid, tmp___6);
#line 1116
    pthread_exit((void *)1);
    }
  }
  {
#line 1118
  dr = recv(sd, (void *)rbuf, 8192U, 0);
  }
#line 1119
  if (dr == -1) {
    {
#line 1120
    tmp___9 = __errno_location();
#line 1121
    tmp___10 = strerror(*tmp___9);
#line 1122
    Log("<THREAD #%ld> recv failed: %s", tid, tmp___10);
#line 1123
    pthread_exit((void *)1);
    }
  }
  {
#line 1125
  handleHttpRetcode(rbuf);
#line 1126
  tmp___11 = strstr((char const   *)rbuf, (char const   *)"HTTP/1.1 206");
  }
#line 1127
  if ((unsigned int )tmp___11 == (unsigned int )((void *)0)) {
    {
#line 1128
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Something unhandled happened, shutting down...\n");
#line 1129
    exit(1);
    }
  }
  {
#line 1131
  s = rbuf;
#line 1132
  i = 0;
  }
  {
#line 1133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1134
    if ((int )*s == 10) {
#line 1135
      if ((int )*(s - 1) == 13) {
#line 1136
        if ((int )*(s - 2) == 10) {
#line 1137
          if ((int )*(s - 3) == 13) {
            {
#line 1138
            s ++;
#line 1139
            i ++;
            }
#line 1140
            goto while_break;
          }
        }
      }
    }
    {
#line 1145
    s ++;
#line 1146
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1148
  td->offset = td->soffset;
  }
#line 1149
  if ((long )(dr - i) > foffset) {
    {
#line 1150
    dw = pwrite(td->fd, s, foffset - (long )i, td->soffset);
    }
  } else {
    {
#line 1152
    dw = pwrite(td->fd, s, dr - i, td->soffset);
    }
  }
  {
#line 1154
  td->offset = td->soffset + (long )dw;
#line 1155
  pthread_mutex_lock(& bwritten_mutex);
#line 1156
  bwritten += (unsigned int )dw;
#line 1157
  pthread_mutex_unlock(& bwritten_mutex);
  }
  {
#line 1158
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1158
    if (! (td->offset < foffset)) {
#line 1158
      goto while_break___0;
    }
    {
#line 1159
    memset((void *)rbuf, 8192, 0U);
#line 1160
    dr = recv(sd, (void *)rbuf, 8192U, 0);
    }
#line 1161
    if (td->offset + (long )dr > foffset) {
      {
#line 1162
      dw = pwrite(td->fd, rbuf, foffset - td->offset, td->offset);
      }
    } else {
      {
#line 1164
      dw = pwrite(td->fd, rbuf, dr, td->offset);
      }
    }
    {
#line 1166
    td->offset += (long )dw;
#line 1167
    pthread_mutex_lock(& bwritten_mutex);
#line 1168
    bwritten += (unsigned int )dw;
#line 1169
    pthread_mutex_unlock(& bwritten_mutex);
#line 1170
    updateProgressBar((float )bwritten, (float )td->clength);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1172
  if (td->offset == td->foffset) {
    {
#line 1173
    td->status = (unsigned char)255;
    }
  }
  {
#line 1175
  close(sd);
#line 1176
  pthread_exit((void *)0);
  }
#line 1177
  return ((void *)0);
}
}
#line 1180
#pragma merger(0,"/tmp/cil-qIg3LbHM.i","-g,-Wall,-W,-pedantic")
#line 1181
extern int fclose(FILE *__stream ) ;
#line 1182
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 1183
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 1184
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 1186
extern int ( __attribute__((__nonnull__(1))) unlink)(char const   *__name )  __attribute__((__nothrow__)) ;
#line 1187 "aget_comb.c"
void save_log(void) 
{ 
  char *logfile ;
  struct hist_data h ;
  FILE *fp ;
  void *tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1197
  tmp = calloc(255U, (size_t )sizeof(char ));
#line 1198
  logfile = (char *)tmp;
#line 1199
  tmp___0 = strlen((char const   *)((req + 0)->lfile));
  }
#line 1200
  if (tmp___0 == 0U) {
    {
#line 1201
    snprintf((char * __restrict  )logfile, 255U, (char const   * __restrict  )"aget-%s.log",
             (req + 0)->file);
    }
  } else {
    {
#line 1204
    snprintf((char * __restrict  )logfile, 255U, (char const   * __restrict  )"aget-%s.log",
             (req + 0)->lfile);
    }
  }
  {
#line 1207
  fp = fopen((char const   * __restrict  )logfile, (char const   * __restrict  )"w");
  }
#line 1208
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
    {
#line 1209
    tmp___1 = __errno_location();
#line 1210
    tmp___2 = strerror(*tmp___1);
#line 1211
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"cannot open log file %s for writing: %s\n",
            logfile, tmp___2);
#line 1213
    exit(1);
    }
  }
  {
#line 1215
  memcpy((void * __restrict  )(& h.req), (void const   * __restrict  )req, (size_t )sizeof(struct request ));
#line 1216
  memcpy((void * __restrict  )(& h.wthread), (void const   * __restrict  )wthread,
         (size_t )(sizeof(struct thread_data ) * (unsigned long )((unsigned int )nthreads)));
#line 1218
  h.nthreads = nthreads;
#line 1219
  h.bwritten = (int )bwritten;
#line 1220
  printf((char const   * __restrict  )"--> Logfile is: %s, so far %d bytes have been transferred\n",
         logfile, h.bwritten);
#line 1222
  fwrite((void const   * __restrict  )(& h), (size_t )sizeof(struct hist_data ), 1U,
         (FILE * __restrict  )fp);
#line 1223
  fclose(fp);
#line 1224
  free((void *)logfile);
  }
#line 1225
  return;
}
}
#line 1228 "aget_comb.c"
int read_log(struct hist_data *h ) 
{ 
  char *logfile ;
  FILE *fp ;
  void *tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 1241
  tmp = calloc(255U, (size_t )sizeof(char ));
#line 1242
  logfile = (char *)tmp;
#line 1243
  tmp___0 = strlen((char const   *)((req + 0)->lfile));
  }
#line 1244
  if (tmp___0 == 0U) {
    {
#line 1245
    snprintf((char * __restrict  )logfile, 255U, (char const   * __restrict  )"aget-%s.log",
             (req + 0)->file);
    }
  } else {
    {
#line 1248
    snprintf((char * __restrict  )logfile, 255U, (char const   * __restrict  )"aget-%s.log",
             (req + 0)->lfile);
    }
  }
  {
#line 1251
  Log("Attempting to read log file %s for resuming download job...", logfile);
#line 1252
  fp = fopen((char const   * __restrict  )logfile, (char const   * __restrict  )"r");
  }
#line 1253
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
    {
#line 1254
    tmp___3 = __errno_location();
    }
#line 1255
    if (*tmp___3 == 2) {
      {
#line 1256
      Log("Couldn\'t find log file for this download, starting a clean job...");
      }
#line 1257
      return (-1);
    } else {
      {
#line 1259
      tmp___1 = __errno_location();
#line 1260
      tmp___2 = strerror(*tmp___1);
#line 1261
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"cannot open log file %s for reading: %s\n",
              logfile, tmp___2);
#line 1263
      exit(1);
      }
    }
  }
  {
#line 1266
  fread((void * __restrict  )h, (size_t )sizeof(struct hist_data ), 1U, (FILE * __restrict  )fp);
#line 1267
  bwritten = (unsigned int )h->bwritten;
#line 1268
  fclose(fp);
#line 1269
  Log("%d bytes already transferred", bwritten);
#line 1270
  tmp___6 = unlink((char const   *)logfile);
  }
#line 1271
  if (tmp___6 == -1) {
    {
#line 1272
    tmp___4 = __errno_location();
#line 1273
    tmp___5 = strerror(*tmp___4);
#line 1274
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"read_log: cannot remove stale log file %s: %s\n",
            logfile, tmp___5);
    }
  }
  {
#line 1277
  free((void *)logfile);
  }
#line 1278
  return (0);
}
}
