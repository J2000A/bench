/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

#line 4 "knot_comb.c"
typedef unsigned int size_t;
#line 5 "knot_comb.c"
typedef long long __quad_t;
#line 6 "knot_comb.c"
typedef unsigned long long __u_quad_t;
#line 7 "knot_comb.c"
typedef __u_quad_t __dev_t;
#line 8 "knot_comb.c"
typedef unsigned int __uid_t;
#line 9 "knot_comb.c"
typedef unsigned int __gid_t;
#line 10 "knot_comb.c"
typedef unsigned long __ino_t;
#line 11 "knot_comb.c"
typedef unsigned int __mode_t;
#line 12 "knot_comb.c"
typedef unsigned int __nlink_t;
#line 13 "knot_comb.c"
typedef long __off_t;
#line 14 "knot_comb.c"
typedef __quad_t __off64_t;
#line 15 "knot_comb.c"
typedef long __time_t;
#line 16 "knot_comb.c"
typedef long __blksize_t;
#line 17 "knot_comb.c"
typedef long __blkcnt_t;
#line 18 "knot_comb.c"
typedef int __ssize_t;
#line 19 "knot_comb.c"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 23 "knot_comb.c"
struct __pthread_internal_slist {
   struct __pthread_internal_slist *__next ;
};
#line 26 "knot_comb.c"
typedef struct __pthread_internal_slist __pthread_slist_t;
#line 27 "knot_comb.c"
union __anonunion____missing_field_name_6 {
   int __spins ;
   __pthread_slist_t __list ;
};
#line 31 "knot_comb.c"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   int __kind ;
   unsigned int __nusers ;
   union __anonunion____missing_field_name_6 __annonCompField1 ;
};
#line 39 "knot_comb.c"
union __anonunion_pthread_mutex_t_5 {
   struct __pthread_mutex_s __data ;
   char __size[24] ;
   long __align ;
};
#line 44 "knot_comb.c"
typedef union __anonunion_pthread_mutex_t_5 pthread_mutex_t;
#line 45 "knot_comb.c"
union __anonunion_pthread_mutexattr_t_7 {
   char __size[4] ;
   long __align ;
};
#line 49 "knot_comb.c"
typedef union __anonunion_pthread_mutexattr_t_7 pthread_mutexattr_t;
#line 50 "knot_comb.c"
typedef __ssize_t ssize_t;
#line 51
struct _IO_FILE ;
#line 52 "knot_comb.c"
typedef struct _IO_FILE FILE;
#line 53 "knot_comb.c"
typedef void _IO_lock_t;
#line 54 "knot_comb.c"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 59 "knot_comb.c"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 90 "knot_comb.c"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 109
struct cache_entry ;
#line 110 "knot_comb.c"
typedef struct cache_entry cache_entry;
#line 111 "knot_comb.c"
struct cache_entry {
   char *filename ;
   char *data ;
   ssize_t total ;
   int refs ;
   pthread_mutex_t refs_mutex ;
   cache_entry *next ;
   cache_entry *prev ;
};
#line 120 "knot_comb.c"
typedef unsigned int PRUint32;
#line 121 "knot_comb.c"
typedef unsigned int PRUintn;
#line 122 "knot_comb.c"
typedef int PRIntn;
#line 123 "knot_comb.c"
typedef ssize_t PRSize;
#line 124 "knot_comb.c"
typedef int PRBool;
#line 125
struct PLHashEntry ;
#line 126 "knot_comb.c"
typedef struct PLHashEntry PLHashEntry;
#line 127
struct PLHashTable ;
#line 128 "knot_comb.c"
typedef struct PLHashTable PLHashTable;
#line 129 "knot_comb.c"
typedef PRUint32 PLHashNumber;
#line 130 "knot_comb.c"
struct PLHashAllocOps {
   void *(*allocTable)(void *pool , PRSize size ) ;
   void (*freeTable)(void *pool , void *item ) ;
   PLHashEntry *(*allocEntry)(void *pool , void const   *key ) ;
   void (*freeEntry)(void *pool , PLHashEntry *he , PRUintn flag ) ;
};
#line 136 "knot_comb.c"
typedef struct PLHashAllocOps PLHashAllocOps;
#line 137 "knot_comb.c"
struct PLHashEntry {
   PLHashEntry *next ;
   PLHashNumber keyHash ;
   void const   *key ;
   void *value ;
};
#line 143 "knot_comb.c"
struct PLHashTable {
   PLHashEntry **buckets ;
   PRUint32 nentries ;
   PRUint32 shift ;
   PLHashNumber (*keyHash)(void const   *key ) ;
   PRIntn (*keyCompare)(void const   *v1 , void const   *v2 ) ;
   PRIntn (*valueCompare)(void const   *v1 , void const   *v2 ) ;
   PLHashAllocOps const   *allocOps ;
   void *allocPriv ;
};
#line 153
struct input_state ;
#line 154 "knot_comb.c"
typedef struct input_state input_state;
#line 155 "knot_comb.c"
struct input_state {
   char buf[512] ;
   int used ;
   int valid ;
   int socket ;
};
#line 161
enum http_version ;
#line 162 "knot_comb.c"
typedef enum http_version http_version;
#line 163
enum http_version {
    HTTP_VERSION_1_0 = 0,
    HTTP_VERSION_1_1 = 1
} ;
#line 167
struct http_request ;
#line 168 "knot_comb.c"
typedef struct http_request http_request;
#line 169 "knot_comb.c"
struct http_request {
   char url[80] ;
   http_version version ;
   int socket ;
   int closed ;
};
#line 175 "knot_comb.c"
typedef unsigned int __socklen_t;
#line 176 "knot_comb.c"
typedef unsigned long pthread_t;
#line 177 "knot_comb.c"
union __anonunion_pthread_attr_t_4 {
   char __size[36] ;
   long __align ;
};
#line 181 "knot_comb.c"
typedef union __anonunion_pthread_attr_t_4 pthread_attr_t;
#line 182 "knot_comb.c"
typedef unsigned short uint16_t;
#line 183 "knot_comb.c"
typedef unsigned int uint32_t;
#line 184 "knot_comb.c"
typedef __socklen_t socklen_t;
#line 185 "knot_comb.c"
typedef unsigned short sa_family_t;
#line 186 "knot_comb.c"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 190 "knot_comb.c"
typedef uint16_t in_port_t;
#line 191 "knot_comb.c"
typedef uint32_t in_addr_t;
#line 192 "knot_comb.c"
struct in_addr {
   in_addr_t s_addr ;
};
#line 195 "knot_comb.c"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 202 "knot_comb.c"
typedef long long cpu_tick_t;
#line 203
struct thread_args ;
#line 204 "knot_comb.c"
typedef struct thread_args thread_args;
#line 205 "knot_comb.c"
struct thread_args {
   int id ;
   int s ;
};
#line 209 "knot_comb.c"
typedef __builtin_va_list __gnuc_va_list;
#line 210 "knot_comb.c"
typedef __gnuc_va_list va_list;
#line 211 "knot_comb.c"
typedef long __suseconds_t;
#line 212 "knot_comb.c"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 216 "knot_comb.c"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 220 "knot_comb.c"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 221 "knot_comb.c"
typedef unsigned char PRUint8;
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
/* compiler builtin: 
   void *__builtin_frob_return_address(void * ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_and_and_fetch(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_or(...) ;  */
/* compiler builtin: 
   int __builtin_popcountll(unsigned long long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_or_fetch(...) ;  */
/* compiler builtin: 
   float __builtin_atanf(float  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_addps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   unsigned long __builtin_strcspn(char const   * , char const   * ) ;  */
/* compiler builtin: 
   float __builtin_asinf(float  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_maxps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_unpckhps(float __attribute__((____vector_size____(16)))   ,
                                                                           float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   double __builtin_acos(double  ) ;  */
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_nand_fetch_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_and(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_xor_fetch_16(...) ;  */
/* compiler builtin: 
   double __builtin_cosh(double  ) ;  */
/* compiler builtin: 
   float __builtin_tanhf(float  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_nand_16(...) ;  */
/* compiler builtin: 
   void *__builtin_mempcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_sub_fetch_1(...) ;  */
/* compiler builtin: 
   long double __builtin_sqrtl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_parity(unsigned int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_or(...) ;  */
/* compiler builtin: 
   long double __builtin_coshl(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_cosl(long double  ) ;  */
/* compiler builtin: 
   float __builtin_cosf(float  ) ;  */
/* compiler builtin: 
   void __sync_synchronize(...) ;  */
/* compiler builtin: 
   long double __builtin_acosl(long double  ) ;  */
/* compiler builtin: 
   void *__builtin___mempcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_or_and_fetch(...) ;  */
/* compiler builtin: 
   int __builtin_clz(unsigned int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_nand_fetch_4(...) ;  */
/* compiler builtin: 
   double __builtin_log10(double  ) ;  */
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   float __builtin_modff(float  , float * ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_sub_fetch_4(...) ;  */
/* compiler builtin: 
   _Bool __atomic_compare_exchange_n(...) ;  */
/* compiler builtin: 
   double __builtin_sin(double  ) ;  */
/* compiler builtin: 
   double __builtin_frexp(double  , int * ) ;  */
/* compiler builtin: 
   float __builtin_acosf(float  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_add_and_fetch(...) ;  */
/* compiler builtin: 
   long double __builtin_sinhl(long double  ) ;  */
/* compiler builtin: 
   char *__builtin___stpcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void __atomic_signal_fence(int  ) ;  */
/* compiler builtin: 
   double __builtin_fabs(double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_nand_1(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_and_fetch_16(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_nand(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_xor_fetch_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_xor_fetch_2(...) ;  */
/* compiler builtin: 
   void __atomic_thread_fence(int  ) ;  */
/* compiler builtin: 
   void __atomic_store_16(...) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_and_8(...) ;  */
/* compiler builtin: 
   short __builtin_bswap16(short  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_and_fetch_2(...) ;  */
/* compiler builtin: 
   _Bool __atomic_test_and_set(void * , int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_add_8(...) ;  */
/* compiler builtin: 
   int __builtin_ctz(unsigned int  ) ;  */
/* compiler builtin: 
   char *__builtin_strpbrk(char const   * , char const   * ) ;  */
/* compiler builtin: 
   char *__builtin_strcpy(char * , char const   * ) ;  */
/* compiler builtin: 
   double __builtin_sqrt(double  ) ;  */
/* compiler builtin: 
   __builtin_va_list __builtin_next_arg(void) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_nand(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_exchange_16(...) ;  */
/* compiler builtin: 
   void __atomic_clear(_Bool * , int  ) ;  */
/* compiler builtin: 
   void __atomic_store(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_add_fetch_2(...) ;  */
/* compiler builtin: 
   float __builtin_log10f(float  ) ;  */
/* compiler builtin: 
   long double __builtin_fabsl(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_floorl(long double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_xor_1(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_and_fetch(...) ;  */
/* compiler builtin: 
   float __builtin_floorf(float  ) ;  */
/* compiler builtin: 
   _Bool __atomic_compare_exchange_4(...) ;  */
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_sub_and_fetch(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_nand_and_fetch(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_load_16(...) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_subps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   int __builtin_parityll(unsigned long long  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_bzero(void * , unsigned long  ) ;  */
/* compiler builtin: 
   _Bool __atomic_always_lock_free(unsigned long  , void * ) ;  */
/* compiler builtin: 
   int __builtin_strncmp(char const   * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_nand_fetch_16(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_xor_and_fetch(...) ;  */
/* compiler builtin: 
   int __builtin___vsprintf_chk(char * , int  , unsigned long  , char const   * ,
                                __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __builtin_sqrtf(float  ) ;  */
/* compiler builtin: 
   double __builtin_nans(char const   * ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_xor_8(...) ;  */
/* compiler builtin: 
   double __builtin_exp(double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_exchange_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_exchange_1(...) ;  */
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
/* compiler builtin: 
   float __builtin_ldexpf(float  , int  ) ;  */
/* compiler builtin: 
   float __builtin_powif(float  , int  ) ;  */
/* compiler builtin: 
   long double __builtin_log10l(long double  ) ;  */
/* compiler builtin: 
   void *__builtin___memmove_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_and(...) ;  */
/* compiler builtin: 
   void *__builtin_return_address(unsigned int  ) ;  */
/* compiler builtin: 
   void __atomic_feraiseexcept(int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_and_fetch_4(...) ;  */
/* compiler builtin: 
   float __builtin_fabsf(float  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_or_fetch_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_or_fetch_4(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_or_fetch_1(...) ;  */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack_len(void) ;  */
/* compiler builtin: 
   long double __builtin_tanl(long double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_and_2(...) ;  */
/* compiler builtin: 
   void __sync_lock_release(...) ;  */
/* compiler builtin: 
   long double __builtin_modfl(long double  , long double * ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_nand_8(...) ;  */
/* compiler builtin: 
   char *__builtin_stpcpy(char * , char const   * ) ;  */
/* compiler builtin: 
   long double __builtin_sinl(long double  ) ;  */
/* compiler builtin: 
   double __builtin_asin(double  ) ;  */
/* compiler builtin: 
   float __builtin_sinhf(float  ) ;  */
/* compiler builtin: 
   int __builtin_ctzl(unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_tanhl(long double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_add(...) ;  */
/* compiler builtin: 
   long __builtin_bswap64(long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_nand_fetch_1(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_nand_2(...) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_mulps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   double __builtin_tan(double  ) ;  */
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   float __builtin_inff(void) ;  */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_load_n(...) ;  */
/* compiler builtin: 
   double __builtin_huge_val(void) ;  */
/* compiler builtin: 
   int __builtin_clzl(unsigned long  ) ;  */
/* compiler builtin: 
   _Bool __atomic_compare_exchange_16(...) ;  */
/* compiler builtin: 
   float __builtin_frexpf(float  , int * ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_exchange_n(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_or_1(...) ;  */
/* compiler builtin: 
   long double __builtin_fmodl(long double  ) ;  */
/* compiler builtin: 
   double __builtin_atan(double  ) ;  */
/* compiler builtin: 
   int __builtin___fprintf_chk(void * , int  , char const   *  , ...) ;  */
/* compiler builtin: 
   float __builtin_ceilf(float  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_or_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_add_1(...) ;  */
/* compiler builtin: 
   void __builtin_return(void const   * ) ;  */
/* compiler builtin: 
   long double __builtin_asinl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_ffsll(unsigned long long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_sub_1(...) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_or_4(...) ;  */
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_powi(double  , int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_load_2(...) ;  */
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
/* compiler builtin: 
   char *__builtin___strncat_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   void __atomic_store_2(...) ;  */
/* compiler builtin: 
   long double __builtin_huge_vall(void) ;  */
/* compiler builtin: 
   int __builtin_ffsl(unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin___vprintf_chk(int  , char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_unpcklps(float __attribute__((____vector_size____(16)))   ,
                                                                           float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   char *__builtin_strncat(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin_ctzll(unsigned long long  ) ;  */
/* compiler builtin: 
   void __builtin_stdarg_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_exchange_4(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_xor(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_sub_4(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_and_4(...) ;  */
/* compiler builtin: 
   long double __builtin_frexpl(long double  , int * ) ;  */
/* compiler builtin: 
   _Bool __atomic_compare_exchange(...) ;  */
/* compiler builtin: 
   float __builtin_tanf(float  ) ;  */
/* compiler builtin: 
   long double __builtin_logl(long double  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_load_1(...) ;  */
/* compiler builtin: 
   _Bool __atomic_compare_exchange_1(...) ;  */
/* compiler builtin: 
   int __builtin___printf_chk(int  , char const   *  , ...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_xor_2(...) ;  */
/* compiler builtin: 
   int __builtin___vfprintf_chk(void * , int  , char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_prefetch(void const   *  , ...) ;  */
/* compiler builtin: 
   long double __builtin_nansl(char const   * ) ;  */
/* compiler builtin: 
   double __builtin_fmod(double  ) ;  */
/* compiler builtin: 
   void __atomic_load(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_or_fetch_16(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_add_fetch_16(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_val_compare_and_swap(...) ;  */
/* compiler builtin: 
   void __atomic_store_4(...) ;  */
/* compiler builtin: 
   double __builtin_tanh(double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_and_1(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_nand_4(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_add_16(...) ;  */
/* compiler builtin: 
   void __builtin_unreachable(void) ;  */
/* compiler builtin: 
   _Bool __atomic_compare_exchange_2(...) ;  */
/* compiler builtin: 
   long double __builtin_ldexpl(long double  , int  ) ;  */
/* compiler builtin: 
   void *__builtin_apply(void (*)() , void * , unsigned long  ) ;  */
/* compiler builtin: 
   float __builtin_sinf(float  ) ;  */
/* compiler builtin: 
   double __builtin_ceil(double  ) ;  */
/* compiler builtin: 
   void __atomic_exchange(...) ;  */
/* compiler builtin: 
   long double __builtin_powil(long double  , int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_sub_fetch_8(...) ;  */
/* compiler builtin: 
   long double __builtin_expl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_constant_p(int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_sub_16(...) ;  */
/* compiler builtin: 
   double __builtin_log(double  ) ;  */
/* compiler builtin: 
   float __builtin_expf(float  ) ;  */
/* compiler builtin: 
   int __builtin_types_compatible_p(unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_atan2l(long double  , long double  ) ;  */
/* compiler builtin: 
   void *__builtin_apply_args(void) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_exchange_2(...) ;  */
/* compiler builtin: 
   float __builtin_logf(float  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_sub_fetch_2(...) ;  */
/* compiler builtin: 
   unsigned long __builtin_strlen(char const   * ) ;  */
/* compiler builtin: 
   int __builtin_ffs(unsigned int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_xor_16(...) ;  */
/* compiler builtin: 
   double __builtin_inf(void) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_or_16(...) ;  */
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_load_4(...) ;  */
/* compiler builtin: 
   void __atomic_store_n(...) ;  */
/* compiler builtin: 
   void __builtin_trap(void) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_add_4(...) ;  */
/* compiler builtin: 
   int __builtin_parityl(unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_nand_fetch_2(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_lock_test_and_set(...) ;  */
/* compiler builtin: 
   unsigned long __builtin_strspn(char const   * , char const   * ) ;  */
/* compiler builtin: 
   void __builtin_varargs_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_sub_fetch(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_and_16(...) ;  */
/* compiler builtin: 
   _Bool __atomic_compare_exchange_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_nand_fetch(...) ;  */
/* compiler builtin: 
   double __builtin_nan(char const   * ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_load_8(...) ;  */
/* compiler builtin: 
   int __builtin___snprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                char const   *  , ...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_xor_fetch_4(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_sub_2(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_add_fetch(...) ;  */
/* compiler builtin: 
   long double __builtin_atanl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_clzll(unsigned long long  ) ;  */
/* compiler builtin: 
   float __builtin_huge_valf(void) ;  */
/* compiler builtin: 
   float __builtin_coshf(float  ) ;  */
/* compiler builtin: 
   float __builtin_nansf(char const   * ) ;  */
/* compiler builtin: 
   void __atomic_store_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_xor_fetch(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_add(...) ;  */
/* compiler builtin: 
   int __builtin___vsnprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                 char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __builtin_nanf(char const   * ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_or_fetch_2(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_add_fetch_1(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_xor(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_add_fetch_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_xor_4(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_sub_8(...) ;  */
/* compiler builtin: 
   _Bool __sync_bool_compare_and_swap(...) ;  */
/* compiler builtin: 
   double __builtin_atan2(double  , double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __builtin_tgmath(...) ;  */
/* compiler builtin: 
   int __builtin_popcountl(unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_and_fetch_1(...) ;  */
/* compiler builtin: 
   long double __builtin_ceill(long double  ) ;  */
/* compiler builtin: 
   void __atomic_store_1(...) ;  */
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_xor_fetch_1(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_or_2(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_sub_fetch_16(...) ;  */
/* compiler builtin: 
   double __builtin_floor(double  ) ;  */
/* compiler builtin: 
   double __builtin_cos(double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_sub(...) ;  */
/* compiler builtin: 
   void *__builtin_memset(void * , int  , int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_add_2(...) ;  */
/* compiler builtin: 
   long double __builtin_nanl(char const   * ) ;  */
/* compiler builtin: 
   float __builtin_atan2f(float  , float  ) ;  */
/* compiler builtin: 
   _Bool __atomic_is_lock_free(unsigned long  , void * ) ;  */
/* compiler builtin: 
   int __builtin_popcount(unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_sinh(double  ) ;  */
/* compiler builtin: 
   void __builtin_bcopy(void const   * , void * , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_and_fetch_8(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_fetch_sub(...) ;  */
/* compiler builtin: 
   void *__builtin_extract_return_addr(void * ) ;  */
/* compiler builtin: 
   int __builtin_bswap32(int  ) ;  */
/* compiler builtin: 
   double __builtin_ldexp(double  , int  ) ;  */
/* compiler builtin: 
   long double __builtin_infl(void) ;  */
/* compiler builtin: 
   float __builtin_fmodf(float  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_add_fetch_4(...) ;  */
/* compiler builtin: 
   void *__builtin_frame_address(unsigned int  ) ;  */
#line 222
#pragma merger(0,"/tmp/cil-oSwcmw7z.i","")
#line 223
extern int ( __attribute__((__nonnull__(1))) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                 pthread_mutexattr_t const   *__mutexattr )  __attribute__((__nothrow__)) ;
#line 225
extern int ( __attribute__((__nonnull__(1))) pthread_mutex_destroy)(pthread_mutex_t *__mutex )  __attribute__((__nothrow__)) ;
#line 226
extern int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex )  __attribute__((__nothrow__)) ;
#line 227
extern int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex )  __attribute__((__nothrow__)) ;
#line 228
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 229
extern void *malloc(size_t __size )  __attribute__((__nothrow__, __malloc__)) ;
#line 230
extern void free(void *__ptr )  __attribute__((__nothrow__)) ;
#line 231
extern void exit(int __status )  __attribute__((__nothrow__, __noreturn__)) ;
#line 232
extern struct _IO_FILE *stderr ;
#line 233
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 235
extern int snprintf(char * __restrict  __s , size_t __maxlen , char const   * __restrict  __format 
                    , ...)  __attribute__((__nothrow__)) ;
#line 239
extern void perror(char const   *__s ) ;
#line 240
extern char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__nothrow__,
__malloc__)) ;
#line 242
__inline static int ( __attribute__((__nonnull__(2))) fstat)(int __fd , struct stat *__statbuf )  __attribute__((__nothrow__)) ;
#line 243
extern int ( __attribute__((__nonnull__(3))) __fxstat)(int __ver , int __fildes ,
                                                       struct stat *__stat_buf )  __attribute__((__nothrow__)) ;
#line 245
__inline static int ( __attribute__((__nonnull__(2))) fstat)(int __fd , struct stat *__statbuf )  __attribute__((__nothrow__)) ;
#line 245 "knot_comb.c"
__inline static int ( __attribute__((__nonnull__(2))) fstat)(int __fd , struct stat *__statbuf ) 
{ 
  int tmp ;

  {
  {
#line 249
  tmp = __fxstat(3, __fd, __statbuf);
  }
#line 250
  return (tmp);
}
}
#line 253
extern int close(int __fd ) ;
#line 254
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 255
void cache_init(void) ;
#line 256
cache_entry *cache_get(char *filename ) ;
#line 257
void cache_entry_addref(cache_entry *entry ) ;
#line 258
void cache_entry_release(cache_entry *entry ) ;
#line 259
PLHashTable *PL_NewHashTable(PRUint32 n , PLHashNumber (*keyHash)(void const   *key ) ,
                             PRIntn (*keyCompare)(void const   *v1 , void const   *v2 ) ,
                             PRIntn (*valueCompare)(void const   *v1 , void const   *v2 ) ,
                             PLHashAllocOps const   *allocOps , void *allocPriv ) ;
#line 263
PLHashEntry *PL_HashTableAdd(PLHashTable *ht , void const   *key , void *value ) ;
#line 264
PRBool PL_HashTableRemove(PLHashTable *ht , void const   *key ) ;
#line 265
void *PL_HashTableLookup(PLHashTable *ht , void const   *key ) ;
#line 266
PLHashNumber PL_HashString(void const   *key ) ;
#line 267
int PL_CompareStrings(void const   *v1 , void const   *v2 ) ;
#line 268
int PL_CompareValues(void const   *v1 , void const   *v2 ) ;
#line 269
void assert_failed(char *file , unsigned int line , char const   *func , char *expr ) ;
#line 270 "knot_comb.c"
pthread_mutex_t g_cache_mutex  ;
#line 271
int g_cache_hits ;
#line 272
int g_cache_misses ;
#line 273 "knot_comb.c"
static PLHashTable *g_hash  =    (PLHashTable *)((void *)0);
#line 274 "knot_comb.c"
static cache_entry *g_cache  =    (cache_entry *)((void *)0);
#line 275 "knot_comb.c"
static cache_entry *g_cache_tail  =    (cache_entry *)((void *)0);
#line 276 "knot_comb.c"
static ssize_t g_cache_max  =    536870912;
#line 277 "knot_comb.c"
static ssize_t g_cache_cur  =    0;
#line 278 "knot_comb.c"
static cache_entry *cache_new(char *filename ) 
{ 
  cache_entry *result ;
  int fd ;
  int tmp ;
  int ret ;
  struct stat fd_stat ;
  char *data ;
  size_t length ;
  int hdrlen ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 292
  result = (cache_entry *)((void *)0);
#line 293
  tmp = open((char const   *)filename, 0);
#line 294
  fd = tmp;
  }
#line 295
  if (fd >= 0) {
    {
#line 296
    data = (char *)((void *)0);
#line 297
    length = (size_t )0;
#line 298
    hdrlen = 0;
#line 299
    tmp___0 = fstat(fd, & fd_stat);
    }
#line 300
    if (tmp___0 < 0) {
      {
#line 301
      perror((char const   *)"fstat");
#line 302
      exit(1);
      }
    }
#line 304
    if (! ((fd_stat.st_mode & 61440U) == 32768U)) {
#line 305
      return ((cache_entry *)((void *)0));
    }
    {
#line 307
    length = (unsigned int )fd_stat.st_size;
#line 308
    tmp___1 = malloc(length + 128U);
#line 309
    data = (char *)tmp___1;
    }
#line 310
    if (! ((unsigned int )data != (unsigned int )((void *)0))) {
      {
#line 311
      assert_failed("cache.c", 69U, (char const   *)"cache_new", "data != ((void *)0)");
      }
    }
    {
#line 313
    hdrlen = snprintf((char * __restrict  )data, 128U, (char const   * __restrict  )"HTTP/1.1 200 OK\r\nContent-Type: %s\r\nContent-Length: %d\r\n\r\n",
                      "text/html", length);
    }
#line 315
    if (hdrlen < 0) {
      {
#line 316
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"header buffer exceeded\n");
#line 317
      exit(1);
      }
    } else
#line 319
    if (hdrlen >= 128) {
      {
#line 320
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"header buffer exceeded\n");
#line 321
      exit(1);
      }
    }
    {
#line 324
    ret = read(fd, (void *)(data + hdrlen), length);
    }
#line 325
    if ((unsigned int )ret != length) {
      {
#line 326
      perror((char const   *)"read");
#line 327
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"read failed - expected %d, but got %d\n",
              length, ret);
#line 329
      close(fd);
      }
#line 330
      return ((cache_entry *)((void *)0));
    }
    {
#line 332
    tmp___2 = malloc((size_t )sizeof(*result));
#line 333
    result = (cache_entry *)tmp___2;
    }
#line 334
    if (! ((unsigned int )result != (unsigned int )((void *)0))) {
      {
#line 335
      assert_failed("cache.c", 90U, (char const   *)"cache_new", "result != ((void *)0)");
      }
    }
    {
#line 337
    result->filename = strdup((char const   *)filename);
    }
#line 338
    if (! ((unsigned int )result->filename != (unsigned int )((void *)0))) {
      {
#line 339
      assert_failed("cache.c", 93U, (char const   *)"cache_new", "result->filename != ((void *)0)");
      }
    }
    {
#line 341
    result->data = data;
#line 342
    result->total = (int )(length + (size_t )hdrlen);
#line 343
    result->refs = 1;
#line 344
    pthread_mutex_init(& result->refs_mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 345
    result->next = (cache_entry *)((void *)0);
#line 346
    result->prev = (cache_entry *)((void *)0);
#line 347
    close(fd);
    }
  }
#line 349
  return (result);
}
}
#line 352 "knot_comb.c"
static void cache_add(cache_entry *entry ) 
{ 


  {
#line 356
  if (! ((unsigned int )entry != (unsigned int )((void *)0))) {
    {
#line 357
    assert_failed("cache.c", 114U, (char const   *)"cache_add", "entry != ((void *)0)");
    }
  }
#line 359
  if ((unsigned int )g_cache != (unsigned int )((void *)0)) {
#line 360
    if (! ((unsigned int )entry->next == (unsigned int )((void *)0))) {
      {
#line 361
      assert_failed("cache.c", 118U, (char const   *)"cache_add", "entry->next == ((void *)0)");
      }
    }
#line 363
    if (! ((unsigned int )entry->prev == (unsigned int )((void *)0))) {
      {
#line 364
      assert_failed("cache.c", 119U, (char const   *)"cache_add", "entry->prev == ((void *)0)");
      }
    }
#line 366
    if (! ((unsigned int )g_cache->prev == (unsigned int )((void *)0))) {
      {
#line 367
      assert_failed("cache.c", 120U, (char const   *)"cache_add", "g_cache->prev == ((void *)0)");
      }
    }
    {
#line 369
    entry->next = g_cache;
#line 370
    entry->prev = (cache_entry *)((void *)0);
#line 371
    g_cache->prev = entry;
    }
  }
#line 373
  if ((unsigned int )g_cache_tail == (unsigned int )((void *)0)) {
    {
#line 374
    g_cache_tail = entry;
    }
  }
  {
#line 376
  g_cache = entry;
#line 377
  g_cache_cur += entry->total;
#line 378
  PL_HashTableAdd(g_hash, (void const   *)entry->filename, (void *)entry);
  }
#line 379
  return;
}
}
#line 382 "knot_comb.c"
static void cache_remove(cache_entry *entry ) 
{ 


  {
#line 386
  if (! ((unsigned int )entry != (unsigned int )((void *)0))) {
    {
#line 387
    assert_failed("cache.c", 145U, (char const   *)"cache_remove", "entry != ((void *)0)");
    }
  }
#line 389
  if ((unsigned int )g_cache == (unsigned int )entry) {
    {
#line 390
    g_cache_cur -= entry->total;
    }
  } else
#line 392
  if ((unsigned int )entry->prev != (unsigned int )((void *)0)) {
    {
#line 393
    g_cache_cur -= entry->total;
    }
  }
#line 396
  if ((unsigned int )g_cache == (unsigned int )entry) {
#line 397
    if (! ((unsigned int )g_cache->prev == (unsigned int )((void *)0))) {
      {
#line 398
      assert_failed("cache.c", 155U, (char const   *)"cache_remove", "g_cache->prev == ((void *)0)");
      }
    }
    {
#line 400
    g_cache = g_cache->next;
    }
  }
#line 402
  if ((unsigned int )g_cache_tail == (unsigned int )entry) {
#line 403
    if (! ((unsigned int )g_cache_tail->next == (unsigned int )((void *)0))) {
      {
#line 404
      assert_failed("cache.c", 161U, (char const   *)"cache_remove", "g_cache_tail->next == ((void *)0)");
      }
    }
    {
#line 406
    g_cache_tail = g_cache_tail->prev;
    }
  }
#line 408
  if ((unsigned int )entry->prev != (unsigned int )((void *)0)) {
    {
#line 409
    (entry->prev)->next = entry->next;
    }
  }
#line 411
  if ((unsigned int )entry->next != (unsigned int )((void *)0)) {
    {
#line 412
    (entry->next)->prev = entry->prev;
    }
  }
  {
#line 414
  entry->prev = (cache_entry *)((void *)0);
#line 415
  entry->next = (cache_entry *)((void *)0);
#line 416
  PL_HashTableRemove(g_hash, (void const   *)entry->filename);
  }
#line 417
  return;
}
}
#line 420 "knot_comb.c"
static void cache_evict(void) 
{ 
  cache_entry *remove___0 ;

  {
  {
#line 424
  while (1) {
    while_continue: /* CIL Label */ ;
#line 424
    if (! (g_cache_cur > g_cache_max)) {
#line 424
      goto while_break;
    }
    {
#line 425
    remove___0 = g_cache_tail;
    }
#line 426
    if (! ((unsigned int )remove___0 != (unsigned int )((void *)0))) {
      {
#line 427
      assert_failed("cache.c", 189U, (char const   *)"cache_evict", "remove != ((void *)0)");
      }
    }
    {
#line 429
    cache_remove(remove___0);
#line 430
    cache_entry_release(remove___0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 432
  return;
}
}
#line 435 "knot_comb.c"
static cache_entry *cache_find(char *filename ) 
{ 
  void *tmp ;

  {
  {
#line 439
  tmp = PL_HashTableLookup(g_hash, (void const   *)filename);
  }
#line 440
  return ((cache_entry *)tmp);
}
}
#line 443 "knot_comb.c"
static void cache_use(cache_entry *entry ) 
{ 


  {
#line 447
  if ((unsigned int )g_cache != (unsigned int )entry) {
    {
#line 448
    cache_remove(entry);
#line 449
    cache_add(entry);
    }
  }
#line 451
  return;
}
}
#line 454 "knot_comb.c"
static void cache_finish_get(cache_entry *entry ) 
{ 


  {
  {
#line 458
  cache_use(entry);
#line 459
  cache_entry_addref(entry);
#line 460
  cache_evict();
  }
#line 461
  return;
}
}
#line 464 "knot_comb.c"
void cache_init(void) 
{ 


  {
  {
#line 468
  g_hash = PL_NewHashTable(100U, & PL_HashString, & PL_CompareStrings, & PL_CompareValues,
                           (PLHashAllocOps const   *)((void *)0), (void *)0);
  }
#line 470
  if (! ((unsigned int )g_hash != (unsigned int )((void *)0))) {
    {
#line 471
    assert_failed("cache.c", 230U, (char const   *)"cache_init", "g_hash != ((void *)0)");
    }
  }
#line 473
  return;
}
}
#line 476 "knot_comb.c"
cache_entry *cache_get(char *filename ) 
{ 
  cache_entry *result ;

  {
  {
#line 480
  result = (cache_entry *)((void *)0);
#line 481
  pthread_mutex_lock(& g_cache_mutex);
#line 482
  result = cache_find(filename);
  }
#line 483
  if ((unsigned int )result != (unsigned int )((void *)0)) {
    {
#line 484
    g_cache_hits ++;
#line 485
    cache_finish_get(result);
    }
  } else {
    {
#line 487
    g_cache_misses ++;
    }
  }
  {
#line 489
  pthread_mutex_unlock(& g_cache_mutex);
  }
#line 490
  if ((unsigned int )result == (unsigned int )((void *)0)) {
    {
#line 491
    result = cache_new(filename);
    }
#line 492
    if ((unsigned int )result != (unsigned int )((void *)0)) {
      {
#line 493
      pthread_mutex_lock(& g_cache_mutex);
#line 494
      cache_add(result);
#line 495
      cache_finish_get(result);
#line 496
      pthread_mutex_unlock(& g_cache_mutex);
      }
    }
  }
#line 499
  return (result);
}
}
#line 502 "knot_comb.c"
void cache_entry_addref(cache_entry *entry ) 
{ 


  {
#line 506
  if ((unsigned int )entry != (unsigned int )((void *)0)) {
    {
#line 507
    pthread_mutex_lock(& entry->refs_mutex);
#line 508
    (entry->refs) ++;
#line 509
    pthread_mutex_unlock(& entry->refs_mutex);
    }
  }
#line 511
  return;
}
}
#line 514 "knot_comb.c"
void cache_entry_release(cache_entry *entry ) 
{ 
  int refs ;

  {
  {
#line 518
  refs = 0;
  }
#line 519
  if ((unsigned int )entry != (unsigned int )((void *)0)) {
    {
#line 520
    pthread_mutex_lock(& entry->refs_mutex);
#line 521
    (entry->refs) --;
#line 522
    refs = entry->refs;
#line 523
    pthread_mutex_unlock(& entry->refs_mutex);
    }
#line 524
    if (refs == 0) {
      {
#line 525
      pthread_mutex_destroy(& entry->refs_mutex);
#line 526
      free((void *)entry->filename);
#line 527
      free((void *)entry->data);
#line 528
      free((void *)entry);
#line 529
      entry = (cache_entry *)((void *)0);
      }
    }
  }
#line 532
  return;
}
}
#line 535
#pragma merger(0,"/tmp/cil-OrJKQtWj.i","")
#line 536
extern void __assert_fail(char const   *__assertion , char const   *__file , unsigned int __line ,
                          char const   *__function )  __attribute__((__nothrow__,
__noreturn__)) ;
#line 540
extern char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                         char const   * __restrict  __src )  __attribute__((__nothrow__)) ;
#line 541
extern int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nothrow__)) ;
#line 543
extern char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s , int __c )  __attribute__((__pure__,
__nothrow__)) ;
#line 545
extern size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__,
__nothrow__)) ;
#line 547
void input_init(input_state *state , int socket___0 ) ;
#line 548
char *input_get_line(input_state *state ) ;
#line 549
void http_init(http_request *request , int socket___0 ) ;
#line 550
int http_parse(http_request *request ) ;
#line 551 "knot_comb.c"
void http_init(http_request *request , int socket___0 ) 
{ 


  {
  {
#line 555
  request->url[0] = (char)0;
#line 556
  request->version = (http_version )0;
#line 557
  request->closed = 0;
#line 558
  request->socket = socket___0;
  }
#line 559
  return;
}
}
#line 562 "knot_comb.c"
int http_parse(http_request *request ) 
{ 
  int result ;
  int done ;
  input_state state ;
  char *line ;
  char *tmp ;
  char *method ;
  char *url ;
  char *protocol ;
  http_version version ;
  int valid ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;

  {
  {
#line 581
  result = 0;
#line 582
  done = 0;
#line 583
  input_init(& state, request->socket);
#line 584
  request->url[0] = (char)0;
#line 585
  request->version = (http_version )0;
  }
  {
#line 586
  while (1) {
    while_continue: /* CIL Label */ ;
#line 586
    if (! (! done)) {
#line 586
      goto while_break;
    }
    {
#line 587
    tmp = input_get_line(& state);
#line 588
    line = tmp;
    }
#line 589
    if ((unsigned int )line == (unsigned int )((void *)0)) {
      {
#line 590
      request->closed = 1;
#line 591
      result = 0;
#line 592
      done = 1;
      }
    } else
#line 594
    if ((int )*(line + 0) == 0) {
      {
#line 595
      result = (int )request->url[0] != 0;
#line 596
      done = 1;
      }
    } else
#line 598
    if ((int )request->url[0] == 0) {
      {
#line 599
      version = (http_version )0;
#line 600
      valid = 0;
#line 601
      method = line;
#line 602
      url = strchr((char const   *)line, ' ');
      }
#line 603
      if ((unsigned int )url != (unsigned int )((void *)0)) {
        {
#line 604
        tmp___0 = url;
#line 605
        url ++;
#line 606
        *tmp___0 = (char)0;
#line 607
        protocol = strchr((char const   *)url, ' ');
        }
#line 608
        if ((unsigned int )protocol != (unsigned int )((void *)0)) {
          {
#line 609
          tmp___1 = protocol;
#line 610
          protocol ++;
#line 611
          *tmp___1 = (char)0;
#line 612
          tmp___4 = strcmp((char const   *)method, (char const   *)"GET");
          }
#line 613
          if (tmp___4 == 0) {
            {
#line 614
            tmp___3 = strcmp((char const   *)protocol, (char const   *)"HTTP/1.1");
            }
#line 615
            if (tmp___3 == 0) {
              {
#line 616
              version = (http_version )1;
#line 617
              valid = 1;
              }
            } else {
              {
#line 619
              tmp___2 = strcmp((char const   *)protocol, (char const   *)"HTTP/1.0");
              }
#line 620
              if (tmp___2 == 0) {
                {
#line 621
                version = (http_version )0;
#line 622
                valid = 1;
                }
              }
            }
          }
        }
      }
#line 628
      if (valid) {
        {
#line 629
        url --;
        }
#line 630
        if (! ((unsigned int )line <= (unsigned int )url)) {
          {
#line 631
          __assert_fail((char const   *)"line <= url", (char const   *)"http.c", 95U,
                        (char const   *)"http_parse");
          }
        }
        {
#line 633
        *(url + 0) = (char )'.';
#line 634
        tmp___5 = strlen((char const   *)url);
        }
#line 635
        if (! ((unsigned long )tmp___5 < sizeof(request->url))) {
          {
#line 636
          __assert_fail((char const   *)"strlen(url) < sizeof(request->url)", (char const   *)"http.c",
                        101U, (char const   *)"http_parse");
          }
        }
        {
#line 639
        strcpy((char * __restrict  )(request->url), (char const   * __restrict  )url);
        }
#line 640
        if (! ((int )request->url[0] == 46)) {
          {
#line 641
          __assert_fail((char const   *)"request->url[0] == \'.\'", (char const   *)"http.c",
                        103U, (char const   *)"http_parse");
          }
        }
        {
#line 643
        request->version = version;
        }
      } else {
        {
#line 645
        result = 0;
#line 646
        done = 1;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 652
  return (result);
}
}
#line 655
#pragma merger(0,"/tmp/cil-Ms76eN5O.i","")
#line 656
extern void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest , void const   *__src ,
                                                          size_t __n )  __attribute__((__nothrow__)) ;
#line 658
extern char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                         char const   *__needle )  __attribute__((__pure__,
__nothrow__)) ;
#line 660 "knot_comb.c"
void input_init(input_state *state , int socket___0 ) 
{ 


  {
#line 664
  if (! ((unsigned int )state != (unsigned int )((void *)0))) {
    {
#line 665
    __assert_fail((char const   *)"state != ((void *)0)", (char const   *)"input.c",
                  18U, (char const   *)"input_init");
    }
  }
  {
#line 667
  state->used = 0;
#line 668
  state->valid = 0;
#line 669
  state->socket = socket___0;
  }
#line 670
  return;
}
}
#line 673 "knot_comb.c"
char *input_get_line(input_state *state ) 
{ 
  char *result ;
  int done ;
  char *start ;
  char *newline ;
  char *empty ;
  int n ;
  ssize_t tmp ;

  {
  {
#line 683
  result = (char *)((void *)0);
#line 684
  done = 0;
  }
  {
#line 685
  while (1) {
    while_continue: /* CIL Label */ ;
#line 685
    if (! (! done)) {
#line 685
      goto while_break;
    }
#line 686
    if (! (0 <= state->used)) {
      {
#line 687
      __assert_fail((char const   *)"0 <= state->used", (char const   *)"input.c",
                    38U, (char const   *)"input_get_line");
      }
    }
#line 689
    if (! (state->used <= state->valid)) {
      {
#line 690
      __assert_fail((char const   *)"state->used <= state->valid", (char const   *)"input.c",
                    39U, (char const   *)"input_get_line");
      }
    }
#line 692
    if (! (state->valid <= 511)) {
      {
#line 693
      __assert_fail((char const   *)"state->valid <= 511", (char const   *)"input.c",
                    40U, (char const   *)"input_get_line");
      }
    }
    {
#line 695
    state->buf[state->valid] = (char)0;
#line 696
    start = & state->buf[state->used];
#line 697
    newline = strstr((char const   *)start, (char const   *)"\r\n");
    }
#line 698
    if ((unsigned int )newline != (unsigned int )((void *)0)) {
      {
#line 699
      *newline = (char)0;
#line 700
      result = start;
#line 701
      done = 1;
#line 702
      state->used = (int )((newline - state->buf) + 2L);
      }
#line 703
      if (state->used == state->valid) {
        {
#line 704
        state->used = 0;
#line 705
        state->valid = 0;
        }
      }
    } else
#line 708
    if (state->valid < 511) {
      {
#line 709
      empty = & state->buf[state->valid];
#line 710
      tmp = read(state->socket, (void *)empty, (unsigned int )(511 - state->valid));
#line 711
      n = tmp;
      }
#line 712
      if (n <= 0) {
        {
#line 713
        result = (char *)((void *)0);
#line 714
        done = 1;
        }
      } else {
        {
#line 716
        state->valid += n;
        }
      }
    } else
#line 719
    if (state->used > 0) {
      {
#line 720
      memmove((void *)(& state->buf[0]), (void const   *)(& state->buf[state->used]),
              (unsigned int )(state->valid - state->used));
#line 722
      state->valid -= state->used;
#line 723
      state->used = 0;
      }
    } else {
      {
#line 725
      result = (char *)((void *)0);
#line 726
      done = 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 731
  return (result);
}
}
#line 734
#pragma merger(0,"/tmp/cil-yY6bFgIx.i","")
#line 735
extern int sched_yield(void)  __attribute__((__nothrow__)) ;
#line 736
extern int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                               pthread_attr_t const   * __restrict  __attr ,
                                                               void *(*__start_routine)(void * ) ,
                                                               void * __restrict  __arg )  __attribute__((__nothrow__)) ;
#line 740
extern void pthread_exit(void *__retval )  __attribute__((__noreturn__)) ;
#line 741
extern int ( __attribute__((__nonnull__(1))) pthread_attr_init)(pthread_attr_t *__attr )  __attribute__((__nothrow__)) ;
#line 742
extern int ( __attribute__((__nonnull__(1))) pthread_attr_setdetachstate)(pthread_attr_t *__attr ,
                                                                          int __detachstate )  __attribute__((__nothrow__)) ;
#line 744
extern int socket(int __domain , int __type , int __protocol )  __attribute__((__nothrow__)) ;
#line 745
extern int bind(int __fd , struct sockaddr  const  *__addr , socklen_t __len )  __attribute__((__nothrow__)) ;
#line 747
extern int setsockopt(int __fd , int __level , int __optname , void const   *__optval ,
                      socklen_t __optlen )  __attribute__((__nothrow__)) ;
#line 749
extern int listen(int __fd , int __n )  __attribute__((__nothrow__)) ;
#line 750
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 751
extern uint16_t htons(uint16_t __hostshort )  __attribute__((__nothrow__, __const__)) ;
#line 752
extern int printf(char const   * __restrict  __format  , ...) ;
#line 753
extern int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__,
__nothrow__)) ;
#line 755
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 756
extern unsigned int sleep(unsigned int __seconds ) ;
#line 757
extern int ( __attribute__((__nonnull__(1))) chdir)(char const   *__path )  __attribute__((__nothrow__)) ;
#line 758
extern int *__errno_location(void)  __attribute__((__nothrow__, __const__)) ;
#line 759
cpu_tick_t ticks_per_microsecond ;
#line 760 "knot_comb.c"
__inline static long long current_usecs(void) 
{ 
  register cpu_tick_t ret ;

  {
  {
#line 764
  __asm__  volatile   ("rdtsc": "=A" (ret));
  }
#line 765
  return (ret / ticks_per_microsecond);
}
}
#line 768 "knot_comb.c"
int g_use_timer  =    1;
#line 769 "knot_comb.c"
int g_spawn_on_demand  =    0;
#line 770 "knot_comb.c"
static int g_use_cache  =    0;
#line 771 "knot_comb.c"
static int g_force_thrashing  =    0;
#line 773 "knot_comb.c"
static int g_conn_open  =    0;
#line 774 "knot_comb.c"
static int g_conn_fail  =    0;
#line 775 "knot_comb.c"
static int g_conn_succeed  =    0;
#line 776 "knot_comb.c"
static int g_conn_active  =    0;
#line 777 "knot_comb.c"
int g_cache_hits  =    0;
#line 778 "knot_comb.c"
int g_cache_misses  =    0;
#line 779 "knot_comb.c"
long long g_bytes_sent  =    0LL;
#line 780 "knot_comb.c"
static unsigned int g_timer_interval  =    5U;
#line 781 "knot_comb.c"
int allow_file(char *file ) 
{ 
  char *p ;
  int allow ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 788
  p = file;
#line 789
  allow = 1;
  }
#line 790
  if ((int )*(file + 0) != 47) {
    {
#line 791
    allow = 0;
    }
  }
  {
#line 793
  while (1) {
    while_continue: /* CIL Label */ ;
#line 794
    if (allow) {
#line 795
      if (! ((int )*p != 0)) {
#line 796
        goto while_break;
      }
    } else {
#line 799
      goto while_break;
    }
#line 801
    if (97 <= (int )*p) {
#line 802
      if (! ((int )*p <= 122)) {
#line 803
        goto _L___1;
      }
    } else
    _L___1: 
#line 807
    if (65 <= (int )*p) {
#line 808
      if (! ((int )*p <= 90)) {
#line 809
        goto _L___0;
      }
    } else
    _L___0: 
#line 813
    if (48 <= (int )*p) {
#line 814
      if (! ((int )*p <= 57)) {
#line 815
        goto _L;
      }
    } else {
      _L: 
      {
#line 819
      tmp = strchr((char const   *)"/._", (int )*p);
      }
#line 820
      if (! ((unsigned int )tmp != (unsigned int )((void *)0))) {
        {
#line 821
        allow = 0;
        }
      }
    }
    {
#line 826
    p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 828
  if (allow) {
    {
#line 829
    tmp___0 = strstr((char const   *)file, (char const   *)"/.");
    }
#line 830
    if ((unsigned int )tmp___0 != (unsigned int )((void *)0)) {
      {
#line 831
      allow = 0;
      }
    }
  }
#line 834
  return (allow);
}
}
#line 837 "knot_comb.c"
char *get_request_filename(http_request *request ) 
{ 
  char *result ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 843
  result = (char *)((void *)0);
#line 844
  tmp___0 = http_parse(request);
  }
#line 845
  if (tmp___0) {
#line 846
    if (! request->closed) {
#line 847
      if (! ((int )request->url[0] == 46)) {
        {
#line 848
        assert_failed("knot.c", 131U, (char const   *)"get_request_filename", "request->url[0] == \'.\'");
        }
      }
      {
#line 850
      tmp = allow_file(request->url + 1);
      }
#line 851
      if (tmp) {
        {
#line 852
        result = request->url;
        }
      }
    }
  }
#line 856
  return (result);
}
}
#line 859 "knot_comb.c"
int get_request_fd(http_request *request ) 
{ 
  char *filename ;
  char *tmp ;
  int fd ;

  {
  {
#line 865
  tmp = get_request_filename(request);
#line 866
  filename = tmp;
#line 867
  fd = -1;
  }
#line 868
  if ((unsigned int )filename != (unsigned int )((void *)0)) {
    {
#line 869
    fd = open((char const   *)filename, 0);
    }
  }
#line 871
  return (fd);
}
}
#line 874 "knot_comb.c"
int process_client_nocache(http_request *request , int client ) 
{ 
  int fd ;
  int tmp ;
  int success ;
  char buf[8192] ;
  char *pos ;
  int n ;
  int ret ;
  int written ;

  {
  {
#line 885
  tmp = get_request_fd(request);
#line 886
  fd = tmp;
#line 887
  success = 1;
  }
#line 888
  if (fd >= 0) {
    {
#line 889
    n = 1;
#line 890
    written = 0;
    }
    {
#line 891
    while (1) {
      while_continue: /* CIL Label */ ;
#line 891
      if (! (n > 0)) {
#line 891
        goto while_break;
      }
      {
#line 892
      n = read(fd, (void *)(buf), (size_t )sizeof(buf));
      }
#line 893
      if (n < 0) {
        {
#line 894
        perror((char const   *)"read");
#line 895
        success = 0;
        }
#line 896
        goto while_break;
      }
      {
#line 898
      pos = buf;
      }
      {
#line 899
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 899
        if (! (n > 0)) {
#line 899
          goto while_break___0;
        }
        {
#line 900
        ret = write(client, (void const   *)pos, (unsigned int )n);
        }
#line 901
        if (ret < 0) {
          {
#line 902
          perror((char const   *)"write");
#line 903
          success = 0;
          }
#line 904
          goto while_break___0;
        } else
#line 906
        if (ret == 0) {
          {
#line 907
          n = 0;
          }
#line 908
          goto while_break___0;
        } else {
          {
#line 910
          written += ret;
#line 911
          pos += ret;
#line 912
          n -= ret;
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 917
    if (g_use_timer) {
      {
#line 918
      g_bytes_sent += (long long )written;
      }
    }
    {
#line 920
    close(fd);
    }
  }
#line 922
  return (success);
}
}
#line 925 "knot_comb.c"
cache_entry *get_request_entry(http_request *request ) 
{ 
  char *filename ;
  char *tmp ;
  cache_entry *tmp___0 ;

  {
  {
#line 931
  tmp = get_request_filename(request);
#line 932
  filename = tmp;
  }
#line 933
  if ((unsigned int )filename == (unsigned int )((void *)0)) {
#line 934
    return ((cache_entry *)((void *)0));
  }
  {
#line 936
  tmp___0 = cache_get(filename);
  }
#line 937
  return (tmp___0);
}
}
#line 940 "knot_comb.c"
int process_client_cache(http_request *request , int client ) 
{ 
  int success ;
  cache_entry *entry ;
  ssize_t written ;
  int n ;
  char *p ;
  char *bigstuff ;
  void *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 952
  success = 0;
#line 953
  entry = get_request_entry(request);
  }
#line 954
  if ((unsigned int )entry != (unsigned int )((void *)0)) {
    {
#line 955
    written = 0;
#line 956
    n = 0;
#line 957
    bigstuff = (char *)((void *)0);
    }
#line 958
    if (g_force_thrashing) {
      {
#line 959
      tmp = malloc(734003200U);
#line 960
      bigstuff = (char *)tmp;
      }
#line 961
      if (! bigstuff) {
#line 962
        return (0);
      }
      {
#line 964
      p = (bigstuff + 734003200) - 3;
      }
      {
#line 965
      while (1) {
        while_continue: /* CIL Label */ ;
#line 965
        if (! ((unsigned int )p > (unsigned int )bigstuff)) {
#line 965
          goto while_break;
        }
        {
#line 966
        *p = (char)10;
#line 967
        p -= 4096;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 969
      sched_yield();
#line 970
      free((void *)bigstuff);
#line 971
      bigstuff = (char *)((void *)0);
      }
    }
    {
#line 973
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 974
      n = write(client, (void const   *)(entry->data + written), (unsigned int )(entry->total - written));
      }
#line 975
      if (n > 0) {
        {
#line 976
        written += n;
#line 977
        g_bytes_sent += (long long )n;
        }
      }
#line 979
      if (n > 0) {
#line 980
        if (! (written < entry->total)) {
#line 981
          goto while_break___0;
        }
      } else {
#line 984
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 987
    if (n < 0) {
      {
#line 988
      tmp___0 = __errno_location();
      }
#line 989
      if (*tmp___0 != 32) {
        {
#line 990
        tmp___1 = __errno_location();
        }
#line 991
        if (*tmp___1 != 104) {
          {
#line 992
          perror((char const   *)"warning: write");
          }
        }
      }
    }
#line 996
    if (g_force_thrashing) {
#line 997
      if (bigstuff) {
        {
#line 998
        free((void *)bigstuff);
        }
      }
    }
    {
#line 1001
    success = 1;
    }
  }
  {
#line 1003
  cache_entry_release(entry);
  }
#line 1004
  return (success);
}
}
#line 1007 "knot_comb.c"
void process_client(int client ) 
{ 
  http_request request ;
  int done ;
  int numrequests ;
  int success ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int len ;
  size_t tmp___2 ;
  ssize_t tmp___3 ;

  {
  {
#line 1020
  done = 0;
#line 1021
  numrequests = 0;
#line 1022
  http_init(& request, client);
  }
  {
#line 1023
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1023
    if (! (! done)) {
#line 1023
      goto while_break;
    }
#line 1024
    if (g_use_cache) {
      {
#line 1025
      tmp = process_client_cache(& request, client);
#line 1026
      tmp___1 = tmp;
      }
    } else {
      {
#line 1028
      tmp___0 = process_client_nocache(& request, client);
#line 1029
      tmp___1 = tmp___0;
      }
    }
    {
#line 1031
    success = tmp___1;
    }
#line 1032
    if (success) {
      {
#line 1033
      g_conn_succeed ++;
      }
    } else {
      {
#line 1035
      g_conn_fail ++;
      }
    }
    {
#line 1037
    numrequests ++;
    }
#line 1038
    if (! success) {
#line 1039
      if (! request.closed) {
        {
#line 1040
        tmp___2 = strlen((char const   *)"HTTP/1.1 404 Not Found\r\nConnection: close\r\n");
#line 1041
        len = (int )tmp___2;
#line 1042
        tmp___3 = write(client, (void const   *)"HTTP/1.1 404 Not Found\r\nConnection: close\r\n",
                        (unsigned int )len);
        }
#line 1044
        if (! (tmp___3 != len)) {
          {
#line 1045
          g_bytes_sent += (long long )len;
          }
        }
      }
    }
#line 1049
    if (! success) {
      {
#line 1050
      done = 1;
      }
    } else
#line 1052
    if ((int )request.version == 0) {
      {
#line 1053
      done = 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1057
  if (numrequests > 1) {
    {
#line 1058
    g_conn_fail --;
    }
  }
#line 1060
  return;
}
}
#line 1063 "knot_comb.c"
void *thread_process_client(void *arg ) 
{ 
  int c ;

  {
  {
#line 1067
  c = (int )arg;
#line 1068
  process_client(c);
#line 1069
  g_conn_active --;
#line 1070
  close(c);
  }
#line 1071
  return ((void *)0);
}
}
#line 1074
void accept_loop(int id , int s ) ;
#line 1075 "knot_comb.c"
static int attr_init_done  =    0;
#line 1076 "knot_comb.c"
static pthread_attr_t attr  ;
#line 1077 "knot_comb.c"
static pthread_t thread  ;
#line 1078 "knot_comb.c"
void accept_loop(int id , int s ) 
{ 
  struct sockaddr_in caddr ;
  int len ;
  int c ;
  int optval ;
  int tmp ;
  int rv ;
  int tmp___0 ;

  {
  {
#line 1088
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1089
    len = (int )sizeof(caddr);
#line 1090
    c = 0;
#line 1091
    c = accept(s, (struct sockaddr * __restrict  )((struct sockaddr *)(& caddr)),
               (socklen_t * __restrict  )(& len));
    }
#line 1093
    if (c < 0) {
      {
#line 1094
      perror((char const   *)"accept");
      }
#line 1095
      goto while_continue;
    }
    {
#line 1097
    g_conn_open ++;
#line 1098
    g_conn_active ++;
#line 1099
    optval = 1;
#line 1100
    tmp = setsockopt(c, 6, 1, (void const   *)(& optval), (socklen_t )sizeof(optval));
    }
#line 1101
    if (tmp < 0) {
      {
#line 1102
      perror((char const   *)"setsockopt");
      }
#line 1103
      goto while_continue;
    }
#line 1105
    if (g_spawn_on_demand) {
#line 1106
      if (! attr_init_done) {
        {
#line 1107
        pthread_attr_init(& attr);
#line 1108
        rv = pthread_attr_setdetachstate(& attr, 1);
        }
#line 1109
        if (! (rv == 0)) {
          {
#line 1110
          assert_failed("knot.c", 472U, (char const   *)"accept_loop", "rv == 0");
          }
        }
        {
#line 1112
        attr_init_done = 1;
        }
      }
      {
#line 1114
      tmp___0 = pthread_create((pthread_t * __restrict  )(& thread), (pthread_attr_t const   * __restrict  )(& attr),
                               & thread_process_client, (void * __restrict  )((void *)c));
      }
#line 1116
      if (tmp___0 < 0) {
        {
#line 1117
        g_conn_fail ++;
#line 1118
        g_conn_active --;
#line 1119
        close(c);
        }
      }
    } else {
      {
#line 1122
      process_client(c);
#line 1123
      close(c);
#line 1124
      g_conn_active --;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1129 "knot_comb.c"
void *thread_main_autospawn(void *arg ) 
{ 
  int s ;

  {
  {
#line 1133
  s = (int )arg;
#line 1134
  accept_loop(-1, s);
  }
#line 1135
  return ((void *)0);
}
}
#line 1138
void *thread_main(void *arg ) ;
#line 1139 "knot_comb.c"
void *thread_main(void *arg ) 
{ 
  thread_args *targs ;
  int id ;
  int s ;

  {
  {
#line 1145
  targs = (thread_args *)arg;
#line 1146
  id = targs->id;
#line 1147
  s = targs->s;
#line 1148
  free((void *)targs);
#line 1149
  accept_loop(id, s);
  }
#line 1150
  return ((void *)0);
}
}
#line 1153 "knot_comb.c"
int main(int argc , char **argv ) 
{ 
  struct sockaddr_in saddr ;
  int s ;
  int nthreads ;
  int i ;
  int val ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  pthread_t thread___0 ;
  int tmp___5 ;
  thread_args *targs ;
  pthread_t thread___1 ;
  void *tmp___6 ;
  int tmp___7 ;
  unsigned long long start ;
  unsigned long long now ;
  long long tmp___8 ;
  long long bytes_sent ;
  int conn_open ;
  int conn_succeed ;
  int conn_fail ;
  int conn_active ;
  int cache_hits ;
  int cache_misses ;
  long long tmp___9 ;

  {
  {
#line 1184
  read_config();
  }
  {
#line 1184
  init_cycle_clock();
  }
  {
#line 1184
  init_debug();
  }
  {
#line 1184
  s = 0;
#line 1185
  nthreads = 0;
#line 1186
  i = 0;
#line 1187
  val = 1;
  }
#line 1188
  if (argc != 3) {
#line 1189
    if (argc != 4) {
      {
#line 1190
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"usage: %s port threads [root]\n",
              *(argv + 0));
#line 1192
      exit(1);
      }
    }
  }
#line 1195
  if (argc == 4) {
    {
#line 1196
    printf((char const   * __restrict  )"setting root directory to [%s]\n", *(argv + 3));
#line 1197
    tmp = chdir((char const   *)*(argv + 3));
    }
#line 1198
    if (tmp < 0) {
      {
#line 1199
      perror((char const   *)"chdir");
#line 1200
      exit(1);
      }
    }
  }
  {
#line 1203
  pthread_mutex_init(& g_cache_mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 1204
  cache_init();
#line 1205
  tmp___0 = strcmp((char const   *)*(argv + 2), (char const   *)"auto");
  }
#line 1206
  if (tmp___0) {
    {
#line 1207
    nthreads = atoi((char const   *)*(argv + 2));
    }
#line 1208
    if (nthreads <= 0) {
      {
#line 1209
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"nthreads should be > 0 or \'auto\'\n");
#line 1210
      exit(1);
      }
    }
  } else {
    {
#line 1213
    g_spawn_on_demand = 1;
    }
  }
  {
#line 1215
  s = socket(2, 1, 0);
  }
#line 1216
  if (s < 0) {
    {
#line 1217
    perror((char const   *)"socket");
#line 1218
    exit(1);
    }
  }
  {
#line 1220
  val = 1;
#line 1221
  tmp___1 = setsockopt(s, 1, 2, (void const   *)(& val), (socklen_t )sizeof(val));
  }
#line 1222
  if (tmp___1 < 0) {
    {
#line 1223
    perror((char const   *)"setsockopt");
#line 1224
    exit(1);
    }
  }
  {
#line 1226
  saddr.sin_family = (unsigned short)2;
#line 1227
  tmp___2 = atoi((char const   *)*(argv + 1));
#line 1228
  saddr.sin_port = htons((unsigned short )tmp___2);
#line 1229
  saddr.sin_addr.s_addr = 0U;
#line 1230
  tmp___3 = bind(s, (struct sockaddr  const  *)((struct sockaddr *)(& saddr)), (socklen_t )sizeof(saddr));
  }
#line 1231
  if (tmp___3 < 0) {
    {
#line 1232
    perror((char const   *)"bind");
#line 1233
    exit(1);
    }
  }
  {
#line 1235
  tmp___4 = listen(s, 50000);
  }
#line 1236
  if (tmp___4 < 0) {
    {
#line 1237
    perror((char const   *)"listen");
#line 1238
    exit(1);
    }
  }
#line 1240
  if (g_spawn_on_demand) {
    {
#line 1241
    tmp___5 = pthread_create((pthread_t * __restrict  )(& thread___0), (pthread_attr_t const   * __restrict  )((void *)0),
                             & thread_main_autospawn, (void * __restrict  )((void *)s));
    }
#line 1243
    if (tmp___5 < 0) {
      {
#line 1244
      perror((char const   *)"pthread_create");
      }
    }
  } else {
    {
#line 1247
    printf((char const   * __restrict  )"Spawning %d threads....\n", nthreads);
#line 1248
    i = 0;
    }
    {
#line 1249
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1249
      if (! (i < nthreads)) {
#line 1249
        goto while_break;
      }
      {
#line 1250
      targs = (thread_args *)((void *)0);
#line 1251
      tmp___6 = malloc((size_t )sizeof(*targs));
#line 1252
      targs = (thread_args *)tmp___6;
      }
#line 1253
      if (! ((unsigned int )targs != (unsigned int )((void *)0))) {
        {
#line 1254
        assert_failed("knot.c", 623U, (char const   *)"main", "targs != ((void *)0)");
        }
      }
      {
#line 1256
      targs->id = i;
#line 1257
      targs->s = s;
#line 1258
      tmp___7 = pthread_create((pthread_t * __restrict  )(& thread___1), (pthread_attr_t const   * __restrict  )((void *)0),
                               & thread_main, (void * __restrict  )((void *)targs));
      }
#line 1260
      if (tmp___7 < 0) {
        {
#line 1261
        perror((char const   *)"pthread_create");
        }
      }
      {
#line 1263
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1265
    printf((char const   * __restrict  )"done\n");
    }
  }
#line 1267
  if (g_use_timer) {
    {
#line 1268
    tmp___8 = current_usecs();
#line 1269
    start = (unsigned long long )tmp___8;
#line 1270
    sleep(g_timer_interval);
    }
    {
#line 1271
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1272
      tmp___9 = current_usecs();
#line 1273
      now = (unsigned long long )tmp___9;
#line 1274
      bytes_sent = g_bytes_sent;
#line 1275
      g_bytes_sent = 0LL;
#line 1276
      conn_open = g_conn_open;
#line 1277
      g_conn_open = 0;
#line 1278
      conn_succeed = g_conn_succeed;
#line 1279
      g_conn_succeed = 0;
#line 1280
      conn_fail = g_conn_fail;
#line 1281
      g_conn_fail = 0;
#line 1282
      conn_active = g_conn_active;
#line 1283
      cache_hits = g_cache_hits;
#line 1284
      g_cache_hits = 0;
#line 1285
      cache_misses = g_cache_misses;
#line 1286
      g_cache_misses = 0;
#line 1287
      printf((char const   * __restrict  )"rate: %.3g Mbits/sec   %.0f open/sec   %.0f succ/sec   %.0f fail/sec   active: %d   misses: %d   hitrate: %.1f%%   ",
             (((double )bytes_sent * (double )8) * (double )1000000) / ((double )(now - start) * (double )1048576),
             ((double )conn_open * (double )1000000) / (double )(now - start), ((double )conn_succeed * (double )1000000) / (double )(now - start),
             ((double )conn_fail * (double )1000000) / (double )(now - start), conn_active,
             cache_misses, ((double )100 * (double )cache_hits) / (double )(cache_hits + cache_misses));
#line 1292
      printf((char const   * __restrict  )"\n");
#line 1293
      start = now;
#line 1294
      sleep(g_timer_interval);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1297
  pthread_exit((void *)0);
  }
#line 1298
  return (0);
}
}
#line 1305
#pragma merger(0,"/tmp/cil-Ps5u9k6i.i","")
#line 1306
extern long syscall(long __sysno  , ...)  __attribute__((__nothrow__)) ;
#line 1307
extern int vsnprintf(char * __restrict  __s , size_t __maxlen , char const   * __restrict  __format ,
                     __gnuc_va_list __arg )  __attribute__((__nothrow__)) ;
#line 1311
extern void abort(void)  __attribute__((__nothrow__, __noreturn__)) ;
#line 1312
cpu_tick_t real_start_ticks ;
#line 1313
cpu_tick_t virtual_start_ticks ;
#line 1314
void init_cycle_clock(void)  __attribute__((__constructor__)) ;
#line 1315
void real_debug(char const   *func , char const   *fmt  , ...) ;
#line 1317
void real_toutput(int tid , char const   *func , char const   *fmt  , ...) ;
#line 1319
void output(char *fmt  , ...) ;
#line 1320
void warning(char *fmt  , ...) ;
#line 1321
void fatal(char *fmt  , ...) ;
#line 1322
cpu_tick_t ticks_diff ;
#line 1323
cpu_tick_t ticks_rdiff ;
#line 1324
void init_debug(void)  __attribute__((__constructor__)) ;
#line 1325
int conf_no_debug ;
#line 1326 "knot_comb.c"
cpu_tick_t ticks_diff  =    (cpu_tick_t )0;
#line 1327 "knot_comb.c"
cpu_tick_t ticks_rdiff  =    (cpu_tick_t )0;
#line 1328 "knot_comb.c"
static cpu_tick_t vnow_prev  =    (cpu_tick_t )0;
#line 1329 "knot_comb.c"
static cpu_tick_t vrnow_prev  =    (cpu_tick_t )0;
#line 1331
void init_debug(void)  __attribute__((__constructor__)) ;
#line 1331 "knot_comb.c"
void init_debug(void) 
{ 


  {
  {
#line 1335
  init_cycle_clock();
#line 1336
  vnow_prev = virtual_start_ticks;
#line 1337
  vrnow_prev = real_start_ticks;
  }
#line 1338
  return;
}
}
#line 1341 "knot_comb.c"
__inline static void output_aux(int tid , char const   *func , char const   *fmt ,
                                va_list ap ) 
{ 
  char str[200] ;
  int len ;
  int ret ;
  cpu_tick_t rnow ;
  cpu_tick_t vrnow ;
  cpu_tick_t rafter ;

  {
  {
#line 1351
  len = 0;
#line 1352
  __asm__  volatile   ("rdtsc": "=A" (rnow));
#line 1353
  vrnow = rnow - ticks_rdiff;
  }
#line 1354
  if (tid != -12312) {
    {
#line 1355
    ret = snprintf((char * __restrict  )(str + len), (size_t )((sizeof(str) - 1UL) - (unsigned long )((unsigned int )len)),
                   (char const   * __restrict  )"%5d %12lld us (%+8lld cyc): ", tid,
                   (vrnow - real_start_ticks) / ticks_per_microsecond, vrnow - vrnow_prev);
    }
#line 1358
    if (! (ret > 0)) {
      {
#line 1359
      assert_failed("../../util/debug.c", 67U, (char const   *)"output_aux", "ret > 0");
      }
    }
    {
#line 1361
    len += ret;
    }
  }
#line 1363
  if (func) {
    {
#line 1364
    ret = snprintf((char * __restrict  )(str + len), (size_t )((sizeof(str) - 1UL) - (unsigned long )((unsigned int )len)),
                   (char const   * __restrict  )"%s() - ", func);
    }
#line 1366
    if (! (ret > 0)) {
      {
#line 1367
      assert_failed("../../util/debug.c", 74U, (char const   *)"output_aux", "ret > 0");
      }
    }
    {
#line 1369
    len += ret;
    }
  }
  {
#line 1371
  ret = vsnprintf((char * __restrict  )(str + len), (size_t )((sizeof(str) - 1UL) - (unsigned long )((unsigned int )len)),
                  (char const   * __restrict  )fmt, ap);
  }
#line 1373
  if (! (ret > 0)) {
    {
#line 1374
    assert_failed("../../util/debug.c", 80U, (char const   *)"output_aux", "ret > 0");
    }
  }
  {
#line 1376
  len += ret;
#line 1377
  syscall(4L, 2, str, len);
#line 1378
  vrnow_prev = vrnow;
#line 1379
  __asm__  volatile   ("rdtsc": "=A" (rafter));
#line 1380
  ticks_rdiff += rafter - rnow;
  }
#line 1381
  return;
}
}
#line 1384 "knot_comb.c"
void real_toutput(int tid , char const   *func , char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
#line 1389
  if (conf_no_debug) {
#line 1390
    return;
  }
  {
#line 1392
  __builtin_va_start(ap, fmt);
#line 1393
  output_aux(tid, func, fmt, ap);
#line 1394
  __builtin_va_end(ap);
  }
#line 1395
  return;
}
}
#line 1398 "knot_comb.c"
void real_debug(char const   *func , char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
#line 1403
  if (conf_no_debug) {
#line 1404
    return;
  }
  {
#line 1406
  __builtin_va_start(ap, fmt);
#line 1407
  output_aux(-12312, func, fmt, ap);
#line 1408
  __builtin_va_end(ap);
  }
#line 1409
  return;
}
}
#line 1412 "knot_comb.c"
void output(char *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 1416
  __builtin_va_start(ap, fmt);
#line 1417
  output_aux(-12312, (char const   *)((void *)0), (char const   *)fmt, ap);
#line 1418
  __builtin_va_end(ap);
  }
#line 1419
  return;
}
}
#line 1422 "knot_comb.c"
void warning(char *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 1426
  __builtin_va_start(ap, fmt);
#line 1427
  output_aux(-12312, (char const   *)((void *)0), (char const   *)fmt, ap);
#line 1428
  __builtin_va_end(ap);
  }
#line 1429
  return;
}
}
#line 1432 "knot_comb.c"
void fatal(char *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 1436
  __builtin_va_start(ap, fmt);
#line 1437
  output_aux(-12312, (char const   *)((void *)0), (char const   *)fmt, ap);
#line 1438
  __builtin_va_end(ap);
#line 1439
  abort();
  }
}
}
#line 1442
extern char const   *__progname ;
#line 1443 "knot_comb.c"
void assert_failed(char *file , unsigned int line , char const   *func , char *expr ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 1448
  if (__progname) {
    {
#line 1449
    tmp = (char const   *)": ";
    }
  } else {
    {
#line 1451
    tmp = (char const   *)"";
    }
  }
#line 1453
  if (__progname) {
    {
#line 1454
    tmp___0 = __progname;
    }
  } else {
    {
#line 1456
    tmp___0 = (char const   *)"";
    }
  }
  {
#line 1458
  fatal("%s%s%s:%u: %s:  Assertion `%s\' failed.\n", tmp___0, tmp, file, line, func,
        expr);
#line 1460
  abort();
  }
}
}
#line 1463
#pragma merger(0,"/tmp/cil-jfY5An30.i","")
#line 1464
extern int ( __attribute__((__nonnull__(1))) gettimeofday)(struct timeval * __restrict  __tv ,
                                                           __timezone_ptr_t __tz )  __attribute__((__nothrow__)) ;
#line 1466
cpu_tick_t ticks_per_second ;
#line 1467
cpu_tick_t ticks_per_millisecond ;
#line 1468
cpu_tick_t ticks_per_nanosecond ;
#line 1469 "knot_comb.c"
cpu_tick_t ticks_per_nanosecond  =    (cpu_tick_t )((double )6 * 10e2);
#line 1470 "knot_comb.c"
cpu_tick_t ticks_per_microsecond  =    (cpu_tick_t )((double )6 * 10e5);
#line 1471 "knot_comb.c"
cpu_tick_t ticks_per_millisecond  =    (cpu_tick_t )((double )6 * 10e8);
#line 1472 "knot_comb.c"
cpu_tick_t ticks_per_second  =    (cpu_tick_t )((double )6 * 10e11);
#line 1473 "knot_comb.c"
cpu_tick_t real_start_ticks  =    (cpu_tick_t )0;
#line 1474 "knot_comb.c"
cpu_tick_t virtual_start_ticks  =    (cpu_tick_t )0;
#line 1475 "knot_comb.c"
static long long timing_loop(void) 
{ 
  struct timeval start_tv ;
  struct timeval end_tv ;
  long usec ;
  cpu_tick_t start_ticks ;
  cpu_tick_t end_ticks ;

  {
  {
#line 1483
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1484
    gettimeofday((struct timeval * __restrict  )(& start_tv), (struct timezone * __restrict  )((void *)0));
#line 1485
    usec = start_tv.tv_usec;
    }
    {
#line 1486
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1487
      gettimeofday((struct timeval * __restrict  )(& start_tv), (struct timezone * __restrict  )((void *)0));
#line 1488
      __asm__  volatile   ("rdtsc": "=A" (start_ticks));
      }
#line 1489
      if (! (start_tv.tv_usec == usec)) {
#line 1490
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1493
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1494
      gettimeofday((struct timeval * __restrict  )(& end_tv), (struct timezone * __restrict  )((void *)0));
#line 1495
      __asm__  volatile   ("rdtsc": "=A" (end_ticks));
      }
#line 1496
      if (! (1e6 * (double )((long long )end_tv.tv_sec) + (double )end_tv.tv_usec < (1e6 * (double )((long long )start_tv.tv_sec) + (double )start_tv.tv_usec) + (double )1000)) {
#line 1497
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1500
    if (1e6 * (double )((long long )end_tv.tv_sec) + (double )end_tv.tv_usec == (1e6 * (double )((long long )start_tv.tv_sec) + (double )start_tv.tv_usec) + (double )1000) {
#line 1501
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1504
  return (end_ticks - start_ticks);
}
}
#line 1507 "knot_comb.c"
static int init_done  =    0;
#line 1509
void init_cycle_clock(void)  __attribute__((__constructor__)) ;
#line 1509 "knot_comb.c"
void init_cycle_clock(void) 
{ 
  int i ;
  long long val ;
  long long tmp ;

  {
  {
#line 1515
  val = 0LL;
  }
#line 1516
  if (init_done) {
#line 1517
    return;
  }
  {
#line 1519
  init_done = 1;
#line 1520
  i = 0;
  }
  {
#line 1521
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1521
    if (! (i < 10)) {
#line 1521
      goto while_break;
    }
    {
#line 1522
    tmp = timing_loop();
#line 1523
    val += tmp;
#line 1524
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1526
  val /= 10LL;
#line 1527
  ticks_per_second = (long long )((double )val * 1e3);
#line 1528
  ticks_per_millisecond = (long long )((double )val * 1e0);
#line 1529
  ticks_per_microsecond = (long long )((double )val / 1e3);
#line 1530
  ticks_per_nanosecond = (long long )((double )val / 1e6);
#line 1531
  __asm__  volatile   ("rdtsc": "=A" (real_start_ticks));
#line 1532
  __asm__  volatile   ("rdtsc": "=A" (virtual_start_ticks));
  }
#line 1533
  return;
}
}
#line 1536
#pragma merger(0,"/tmp/cil-rxsNrgMK.i","")
#line 1537
void PL_HashTableDestroy(PLHashTable *ht ) ;
#line 1538
void *PL_HashTableLookupConst(PLHashTable *ht , void const   *key ) ;
#line 1539
int PL_HashTableEnumerateEntries(PLHashTable *ht , PRIntn (*f)(PLHashEntry *he , PRIntn i ,
                                                               void *arg ) , void *arg ) ;
#line 1541
PLHashEntry **PL_HashTableRawLookup(PLHashTable *ht , PLHashNumber keyHash , void const   *key ) ;
#line 1542
PLHashEntry **PL_HashTableRawLookupConst(PLHashTable *ht , PLHashNumber keyHash ,
                                         void const   *key ) ;
#line 1544
PLHashEntry *PL_HashTableRawAdd(PLHashTable *ht , PLHashEntry **hep , PLHashNumber keyHash ,
                                void const   *key , void *value ) ;
#line 1546
void PL_HashTableRawRemove(PLHashTable *ht , PLHashEntry **hep , PLHashEntry *he ) ;
#line 1547
int PL_HashTableDump(PLHashTable *ht , PRIntn (*dump)(PLHashEntry *he , PRIntn i ,
                                                      void *arg ) , FILE *fp ) ;
#line 1549
extern void *( __attribute__((__nonnull__(1))) memset)(void *__s , int __c , size_t __n )  __attribute__((__nothrow__)) ;
#line 1550 "knot_comb.c"
PRIntn PR_CeilingLog2(PRUint32 n ) 
{ 
  PRIntn log2 ;

  {
  {
#line 1554
  log2 = 0;
  }
#line 1555
  if (n & (n - 1U)) {
    {
#line 1556
    log2 ++;
    }
  }
#line 1558
  if (n >> 16) {
    {
#line 1559
    log2 += 16;
#line 1560
    n >>= 16;
    }
  }
#line 1562
  if (n >> 8) {
    {
#line 1563
    log2 += 8;
#line 1564
    n >>= 8;
    }
  }
#line 1566
  if (n >> 4) {
    {
#line 1567
    log2 += 4;
#line 1568
    n >>= 4;
    }
  }
#line 1570
  if (n >> 2) {
    {
#line 1571
    log2 += 2;
#line 1572
    n >>= 2;
    }
  }
#line 1574
  if (n >> 1) {
    {
#line 1575
    log2 ++;
    }
  }
#line 1577
  return (log2);
}
}
#line 1580 "knot_comb.c"
static void *DefaultAllocTable(void *pool , PRSize size ) 
{ 
  void *tmp ;

  {
  {
#line 1584
  tmp = malloc((unsigned int )size);
  }
#line 1585
  return (tmp);
}
}
#line 1588 "knot_comb.c"
static void DefaultFreeTable(void *pool , void *item ) 
{ 


  {
  {
#line 1592
  free(item);
  }
#line 1593
  return;
}
}
#line 1596 "knot_comb.c"
static PLHashEntry *DefaultAllocEntry(void *pool , void const   *key ) 
{ 
  void *tmp ;

  {
  {
#line 1600
  tmp = malloc((size_t )sizeof(PLHashEntry ));
  }
#line 1601
  return ((PLHashEntry *)tmp);
}
}
#line 1604 "knot_comb.c"
static void DefaultFreeEntry(void *pool , PLHashEntry *he , PRUintn flag ) 
{ 


  {
#line 1608
  if (flag == 1U) {
    {
#line 1609
    free((void *)he);
    }
  }
#line 1611
  return;
}
}
#line 1614 "knot_comb.c"
static PLHashAllocOps defaultHashAllocOps  =    {& DefaultAllocTable, & DefaultFreeTable, & DefaultAllocEntry, & DefaultFreeEntry};
#line 1615 "knot_comb.c"
PLHashTable *PL_NewHashTable(PRUint32 n , PLHashNumber (*keyHash)(void const   *key ) ,
                             PRIntn (*keyCompare)(void const   *v1 , void const   *v2 ) ,
                             PRIntn (*valueCompare)(void const   *v1 , void const   *v2 ) ,
                             PLHashAllocOps const   *allocOps , void *allocPriv ) 
{ 
  PLHashTable *ht ;
  PRSize nb ;
  PRIntn tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1627
  if (n <= (PRUint32 )(1 << 4)) {
    {
#line 1628
    n = 4U;
    }
  } else {
    {
#line 1630
    tmp = PR_CeilingLog2(n);
#line 1631
    n = (unsigned int )tmp;
    }
#line 1632
    if ((int )n < 0) {
#line 1633
      return ((PLHashTable *)0);
    }
  }
#line 1636
  if (! allocOps) {
    {
#line 1637
    allocOps = (PLHashAllocOps const   *)(& defaultHashAllocOps);
    }
  }
  {
#line 1639
  tmp___0 = (*(allocOps->allocTable))(allocPriv, (int )sizeof(*ht));
#line 1640
  ht = (PLHashTable *)tmp___0;
  }
#line 1641
  if (! ht) {
#line 1642
    return ((PLHashTable *)0);
  }
  {
#line 1644
  memset((void *)ht, 0, (size_t )sizeof(*ht));
#line 1645
  ht->shift = 32U - n;
#line 1646
  n = (unsigned int )(1 << n);
#line 1647
  nb = (int )((unsigned long )n * sizeof(PLHashEntry *));
#line 1648
  tmp___1 = (*(allocOps->allocTable))(allocPriv, nb);
#line 1649
  ht->buckets = (PLHashEntry **)tmp___1;
  }
#line 1650
  if (! ht->buckets) {
    {
#line 1651
    (*(allocOps->freeTable))(allocPriv, (void *)ht);
    }
#line 1652
    return ((PLHashTable *)0);
  }
  {
#line 1654
  memset((void *)ht->buckets, 0, (unsigned int )nb);
#line 1655
  ht->keyHash = keyHash;
#line 1656
  ht->keyCompare = keyCompare;
#line 1657
  ht->valueCompare = valueCompare;
#line 1658
  ht->allocOps = allocOps;
#line 1659
  ht->allocPriv = allocPriv;
  }
#line 1660
  return (ht);
}
}
#line 1663 "knot_comb.c"
void PL_HashTableDestroy(PLHashTable *ht ) 
{ 
  PRUint32 i ;
  PRUint32 n ;
  PLHashEntry *he ;
  PLHashEntry *next ;
  PLHashAllocOps const   *allocOps ;
  void *allocPriv ;

  {
  {
#line 1672
  allocOps = ht->allocOps;
#line 1673
  allocPriv = ht->allocPriv;
#line 1674
  n = (unsigned int )(1 << (32U - ht->shift));
#line 1675
  i = 0U;
  }
  {
#line 1676
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1676
    if (! (i < n)) {
#line 1676
      goto while_break;
    }
    {
#line 1677
    he = *(ht->buckets + i);
    }
    {
#line 1678
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1678
      if (! he) {
#line 1678
        goto while_break___0;
      }
      {
#line 1679
      next = he->next;
#line 1680
      (*(allocOps->freeEntry))(allocPriv, he, 1U);
#line 1681
      he = next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1683
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1685
  (*(allocOps->freeTable))(allocPriv, (void *)ht->buckets);
#line 1686
  (*(allocOps->freeTable))(allocPriv, (void *)ht);
  }
#line 1687
  return;
}
}
#line 1690 "knot_comb.c"
PLHashEntry **PL_HashTableRawLookup(PLHashTable *ht , PLHashNumber keyHash , void const   *key ) 
{ 
  PLHashEntry *he ;
  PLHashEntry **hep ;
  PLHashEntry **hep0 ;
  PLHashNumber h ;
  PRIntn tmp ;

  {
  {
#line 1698
  h = keyHash * 2654435769U;
#line 1699
  h >>= ht->shift;
#line 1700
  hep0 = ht->buckets + h;
#line 1701
  hep = hep0;
  }
  {
#line 1702
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1703
    he = *hep;
    }
#line 1704
    if (! ((unsigned int )he != (unsigned int )((PLHashEntry *)0))) {
#line 1705
      goto while_break;
    }
#line 1707
    if (he->keyHash == keyHash) {
      {
#line 1708
      tmp = (*(ht->keyCompare))(key, he->key);
      }
#line 1709
      if (tmp) {
#line 1710
        if ((unsigned int )hep != (unsigned int )hep0) {
          {
#line 1711
          *hep = he->next;
#line 1712
          he->next = *hep0;
#line 1713
          *hep0 = he;
          }
        }
#line 1715
        return (hep0);
      }
    }
    {
#line 1718
    hep = & he->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1720
  return (hep);
}
}
#line 1723 "knot_comb.c"
PLHashEntry **PL_HashTableRawLookupConst(PLHashTable *ht , PLHashNumber keyHash ,
                                         void const   *key ) 
{ 
  PLHashEntry *he ;
  PLHashEntry **hep ;
  PLHashNumber h ;
  PRIntn tmp ;

  {
  {
#line 1731
  h = keyHash * 2654435769U;
#line 1732
  h >>= ht->shift;
#line 1733
  hep = ht->buckets + h;
  }
  {
#line 1734
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1735
    he = *hep;
    }
#line 1736
    if (! ((unsigned int )he != (unsigned int )((PLHashEntry *)0))) {
#line 1737
      goto while_break;
    }
#line 1739
    if (he->keyHash == keyHash) {
      {
#line 1740
      tmp = (*(ht->keyCompare))(key, he->key);
      }
#line 1741
      if (tmp) {
#line 1742
        goto while_break;
      }
    }
    {
#line 1745
    hep = & he->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1747
  return (hep);
}
}
#line 1750 "knot_comb.c"
PLHashEntry *PL_HashTableRawAdd(PLHashTable *ht , PLHashEntry **hep , PLHashNumber keyHash ,
                                void const   *key , void *value ) 
{ 
  PRUint32 i ;
  PRUint32 n ;
  PLHashEntry *he ;
  PLHashEntry *next ;
  PLHashEntry **oldbuckets ;
  PRSize nb ;
  void *tmp ;

  {
  {
#line 1761
  n = (unsigned int )(1 << (32U - ht->shift));
  }
#line 1762
  if (ht->nentries >= n - (n >> 3)) {
    {
#line 1763
    oldbuckets = ht->buckets;
#line 1764
    nb = (int )((unsigned long )(2U * n) * sizeof(PLHashEntry *));
#line 1765
    tmp = (*((ht->allocOps)->allocTable))(ht->allocPriv, nb);
#line 1766
    ht->buckets = (PLHashEntry **)tmp;
    }
#line 1767
    if (! ht->buckets) {
      {
#line 1768
      ht->buckets = oldbuckets;
      }
#line 1769
      return ((PLHashEntry *)0);
    }
    {
#line 1771
    memset((void *)ht->buckets, 0, (unsigned int )nb);
#line 1772
    (ht->shift) --;
#line 1773
    i = 0U;
    }
    {
#line 1774
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1774
      if (! (i < n)) {
#line 1774
        goto while_break;
      }
      {
#line 1775
      he = *(oldbuckets + i);
      }
      {
#line 1776
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1776
        if (! he) {
#line 1776
          goto while_break___0;
        }
        {
#line 1777
        next = he->next;
#line 1778
        hep = PL_HashTableRawLookup(ht, he->keyHash, he->key);
        }
        {
#line 1779
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1780
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 1782
        he->next = (PLHashEntry *)0;
#line 1783
        *hep = he;
#line 1784
        he = next;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1786
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1788
    (*((ht->allocOps)->freeTable))(ht->allocPriv, (void *)oldbuckets);
#line 1789
    hep = PL_HashTableRawLookup(ht, keyHash, key);
    }
  }
  {
#line 1791
  he = (*((ht->allocOps)->allocEntry))(ht->allocPriv, key);
  }
#line 1792
  if (! he) {
#line 1793
    return ((PLHashEntry *)0);
  }
  {
#line 1795
  he->keyHash = keyHash;
#line 1796
  he->key = key;
#line 1797
  he->value = value;
#line 1798
  he->next = *hep;
#line 1799
  *hep = he;
#line 1800
  (ht->nentries) ++;
  }
#line 1801
  return (he);
}
}
#line 1804 "knot_comb.c"
PLHashEntry *PL_HashTableAdd(PLHashTable *ht , void const   *key , void *value ) 
{ 
  PLHashNumber keyHash ;
  PLHashEntry *he ;
  PLHashEntry **hep ;
  PRIntn tmp ;
  PLHashEntry *tmp___0 ;

  {
  {
#line 1812
  keyHash = (*(ht->keyHash))(key);
#line 1813
  hep = PL_HashTableRawLookup(ht, keyHash, key);
#line 1814
  he = *hep;
  }
#line 1815
  if ((unsigned int )he != (unsigned int )((PLHashEntry *)0)) {
    {
#line 1816
    tmp = (*(ht->valueCompare))((void const   *)he->value, (void const   *)value);
    }
#line 1817
    if (tmp) {
#line 1818
      return (he);
    }
#line 1820
    if (he->value) {
      {
#line 1821
      (*((ht->allocOps)->freeEntry))(ht->allocPriv, he, 0U);
      }
    }
    {
#line 1823
    he->value = value;
    }
#line 1824
    return (he);
  }
  {
#line 1826
  tmp___0 = PL_HashTableRawAdd(ht, hep, keyHash, key, value);
  }
#line 1827
  return (tmp___0);
}
}
#line 1830 "knot_comb.c"
void PL_HashTableRawRemove(PLHashTable *ht , PLHashEntry **hep , PLHashEntry *he ) 
{ 
  PRUint32 i ;
  PRUint32 n ;
  PLHashEntry *next ;
  PLHashEntry **oldbuckets ;
  PRSize nb ;
  void *tmp ;
  PRUint32 tmp___0 ;

  {
  {
#line 1840
  *hep = he->next;
#line 1841
  (*((ht->allocOps)->freeEntry))(ht->allocPriv, he, 1U);
#line 1842
  n = (unsigned int )(1 << (32U - ht->shift));
#line 1843
  (ht->nentries) --;
  }
#line 1844
  if (n > (PRUint32 )(1 << 4)) {
    {
#line 1845
    tmp___0 = n >> 2;
    }
  } else {
    {
#line 1847
    tmp___0 = 0U;
    }
  }
#line 1849
  if (ht->nentries < tmp___0) {
    {
#line 1850
    oldbuckets = ht->buckets;
#line 1851
    nb = (int )(((unsigned long )n * sizeof(PLHashEntry *)) / 2UL);
#line 1852
    tmp = (*((ht->allocOps)->allocTable))(ht->allocPriv, nb);
#line 1853
    ht->buckets = (PLHashEntry **)tmp;
    }
#line 1854
    if (! ht->buckets) {
      {
#line 1855
      ht->buckets = oldbuckets;
      }
#line 1856
      return;
    }
    {
#line 1858
    memset((void *)ht->buckets, 0, (unsigned int )nb);
#line 1859
    (ht->shift) ++;
#line 1860
    i = 0U;
    }
    {
#line 1861
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1861
      if (! (i < n)) {
#line 1861
        goto while_break;
      }
      {
#line 1862
      he = *(oldbuckets + i);
      }
      {
#line 1863
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1863
        if (! he) {
#line 1863
          goto while_break___0;
        }
        {
#line 1864
        next = he->next;
#line 1865
        hep = PL_HashTableRawLookup(ht, he->keyHash, he->key);
        }
        {
#line 1866
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1867
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 1869
        he->next = (PLHashEntry *)0;
#line 1870
        *hep = he;
#line 1871
        he = next;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1873
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1875
    (*((ht->allocOps)->freeTable))(ht->allocPriv, (void *)oldbuckets);
    }
  }
#line 1877
  return;
}
}
#line 1880 "knot_comb.c"
PRBool PL_HashTableRemove(PLHashTable *ht , void const   *key ) 
{ 
  PLHashNumber keyHash ;
  PLHashEntry *he ;
  PLHashEntry **hep ;

  {
  {
#line 1886
  keyHash = (*(ht->keyHash))(key);
#line 1887
  hep = PL_HashTableRawLookup(ht, keyHash, key);
#line 1888
  he = *hep;
  }
#line 1889
  if ((unsigned int )he == (unsigned int )((PLHashEntry *)0)) {
#line 1890
    return (0);
  }
  {
#line 1892
  PL_HashTableRawRemove(ht, hep, he);
  }
#line 1893
  return (1);
}
}
#line 1896 "knot_comb.c"
void *PL_HashTableLookup(PLHashTable *ht , void const   *key ) 
{ 
  PLHashNumber keyHash ;
  PLHashEntry *he ;
  PLHashEntry **hep ;

  {
  {
#line 1902
  keyHash = (*(ht->keyHash))(key);
#line 1903
  hep = PL_HashTableRawLookup(ht, keyHash, key);
#line 1904
  he = *hep;
  }
#line 1905
  if ((unsigned int )he != (unsigned int )((PLHashEntry *)0)) {
#line 1906
    return (he->value);
  }
#line 1908
  return ((void *)0);
}
}
#line 1911 "knot_comb.c"
void *PL_HashTableLookupConst(PLHashTable *ht , void const   *key ) 
{ 
  PLHashNumber keyHash ;
  PLHashEntry *he ;
  PLHashEntry **hep ;

  {
  {
#line 1917
  keyHash = (*(ht->keyHash))(key);
#line 1918
  hep = PL_HashTableRawLookupConst(ht, keyHash, key);
#line 1919
  he = *hep;
  }
#line 1920
  if ((unsigned int )he != (unsigned int )((PLHashEntry *)0)) {
#line 1921
    return (he->value);
  }
#line 1923
  return ((void *)0);
}
}
#line 1926 "knot_comb.c"
int PL_HashTableEnumerateEntries(PLHashTable *ht , PRIntn (*f)(PLHashEntry *he , PRIntn i ,
                                                               void *arg ) , void *arg ) 
{ 
  PLHashEntry *he ;
  PLHashEntry **hep ;
  PRUint32 i ;
  PRUint32 nbuckets ;
  int rv ;
  int n ;
  PLHashEntry *todo ;

  {
  {
#line 1937
  n = 0;
#line 1938
  todo = (PLHashEntry *)0;
#line 1939
  nbuckets = (unsigned int )(1 << (32U - ht->shift));
#line 1940
  i = 0U;
  }
  {
#line 1941
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1941
    if (! (i < nbuckets)) {
#line 1941
      goto while_break;
    }
    {
#line 1942
    hep = ht->buckets + i;
    }
    {
#line 1943
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1944
      he = *hep;
      }
#line 1945
      if (! ((unsigned int )he != (unsigned int )((PLHashEntry *)0))) {
#line 1946
        goto while_break___0;
      }
      {
#line 1948
      rv = (*f)(he, n, arg);
#line 1949
      n ++;
      }
#line 1950
      if (rv & 6) {
        {
#line 1951
        *hep = he->next;
        }
#line 1952
        if (rv & 2) {
          {
#line 1953
          he->next = todo;
#line 1954
          todo = he;
          }
        }
      } else {
        {
#line 1957
        hep = & he->next;
        }
      }
#line 1959
      if (rv & 1) {
#line 1960
        goto out;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1963
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  out: 
  {
#line 1966
  hep = & todo;
  }
  {
#line 1967
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1968
    he = *hep;
    }
#line 1969
    if (! ((unsigned int )he != (unsigned int )((PLHashEntry *)0))) {
#line 1970
      goto while_break___1;
    }
    {
#line 1972
    PL_HashTableRawRemove(ht, hep, he);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1974
  return (n);
}
}
#line 1977 "knot_comb.c"
int PL_HashTableDump(PLHashTable *ht , PRIntn (*dump)(PLHashEntry *he , PRIntn i ,
                                                      void *arg ) , FILE *fp ) 
{ 
  int count ;

  {
  {
#line 1982
  count = PL_HashTableEnumerateEntries(ht, dump, (void *)fp);
  }
#line 1983
  return (count);
}
}
#line 1986 "knot_comb.c"
PLHashNumber PL_HashString(void const   *key ) 
{ 
  PLHashNumber h ;
  PRUint8 const   *s ;

  {
  {
#line 1991
  h = 0U;
#line 1992
  s = (PRUint8 const   *)key;
  }
  {
#line 1993
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1993
    if (! *s) {
#line 1993
      goto while_break;
    }
    {
#line 1994
    h = ((h >> 28) ^ (h << 4)) ^ (unsigned int )*s;
#line 1995
    s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1997
  return (h);
}
}
#line 2000 "knot_comb.c"
int PL_CompareStrings(void const   *v1 , void const   *v2 ) 
{ 
  int tmp ;

  {
  {
#line 2004
  tmp = strcmp((char const   *)v1, (char const   *)v2);
  }
#line 2005
  return (tmp == 0);
}
}
#line 2008 "knot_comb.c"
int PL_CompareValues(void const   *v1 , void const   *v2 ) 
{ 


  {
#line 2012
  return ((unsigned int )v1 == (unsigned int )v2);
}
}
#line 2015
#pragma merger(0,"/tmp/cil-14RurMIC.i","")
#line 2016
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 2017
extern long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                      char ** __restrict  __endptr ,
                                                      int __base )  __attribute__((__nothrow__)) ;
#line 2019
extern char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name )  __attribute__((__nothrow__)) ;
#line 2020
extern int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nothrow__)) ;
#line 2022
int conf_no_init_messages ;
#line 2023
int conf_dump_blocking_graph ;
#line 2024
int conf_dump_timing_info ;
#line 2025
int conf_show_thread_stacks ;
#line 2026
int conf_show_thread_details ;
#line 2027
int conf_no_stacktrace ;
#line 2028
int conf_no_statcollect ;
#line 2029
long conf_new_stack_size ;
#line 2030
int conf_new_stack_kb_log2 ;
#line 2031
void read_config(void)  __attribute__((__constructor__)) ;
#line 2032 "knot_comb.c"
int conf_no_init_messages  =    0;
#line 2033 "knot_comb.c"
int conf_dump_blocking_graph  =    0;
#line 2034 "knot_comb.c"
int conf_dump_timing_info  =    0;
#line 2035 "knot_comb.c"
int conf_show_thread_stacks  =    0;
#line 2036 "knot_comb.c"
int conf_show_thread_details  =    0;
#line 2037 "knot_comb.c"
int conf_no_debug  =    0;
#line 2038 "knot_comb.c"
int conf_no_stacktrace  =    0;
#line 2039 "knot_comb.c"
int conf_no_statcollect  =    0;
#line 2040 "knot_comb.c"
long conf_new_stack_size  =    131072L;
#line 2041 "knot_comb.c"
int conf_new_stack_kb_log2  =    7;
#line 2042 "knot_comb.c"
__inline static int bool_value(char *str ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 2049
  if ((unsigned int )str == (unsigned int )((void *)0)) {
#line 2050
    return (0);
  }
  {
#line 2052
  tmp = atoi((char const   *)str);
  }
#line 2053
  if (tmp) {
#line 2054
    return (1);
  }
  {
#line 2056
  tmp___0 = strcasecmp((char const   *)str, (char const   *)"true");
  }
#line 2057
  if (! tmp___0) {
#line 2058
    return (1);
  }
  {
#line 2060
  tmp___1 = strcasecmp((char const   *)str, (char const   *)"yes");
  }
#line 2061
  if (! tmp___1) {
#line 2062
    return (1);
  }
  {
#line 2064
  tmp___2 = strcasecmp((char const   *)str, (char const   *)"y");
  }
#line 2065
  if (! tmp___2) {
#line 2066
    return (1);
  }
#line 2068
  return (0);
}
}
#line 2071 "knot_comb.c"
static int read_config_done  =    0;
#line 2073
void read_config(void)  __attribute__((__constructor__)) ;
#line 2073 "knot_comb.c"
void read_config(void) 
{ 
  char *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  char const   *tmp___10 ;
  char *tmp___11 ;
  char const   *tmp___12 ;
  char *tmp___13 ;
  char const   *tmp___14 ;
  char *str ;
  char *p ;
  int mult ;
  long val ;
  unsigned short const   **tmp___15 ;

  {
#line 2097
  if (read_config_done) {
#line 2098
    return;
  }
  {
#line 2100
  read_config_done = 1;
#line 2101
  tmp = getenv((char const   *)"CAPRICCIO_NO_INIT_MESSAGES");
#line 2102
  conf_no_init_messages = bool_value(tmp);
  }
#line 2103
  if (! conf_no_init_messages) {
#line 2104
    if (conf_no_init_messages) {
      {
#line 2105
      tmp___0 = (char const   *)"yes";
      }
    } else {
      {
#line 2107
      tmp___0 = (char const   *)"no";
      }
    }
    {
#line 2109
    output("%s=%s\n", "CAPRICCIO_NO_INIT_MESSAGES", tmp___0);
    }
  }
  {
#line 2111
  tmp___1 = getenv((char const   *)"CAPRICCIO_NO_DEBUG");
#line 2112
  conf_no_debug = bool_value(tmp___1);
  }
#line 2113
  if (! conf_no_init_messages) {
#line 2114
    if (conf_no_debug) {
      {
#line 2115
      tmp___2 = (char const   *)"yes";
      }
    } else {
      {
#line 2117
      tmp___2 = (char const   *)"no";
      }
    }
    {
#line 2119
    output("%s=%s\n", "CAPRICCIO_NO_DEBUG", tmp___2);
    }
  }
  {
#line 2121
  tmp___3 = getenv((char const   *)"CAPRICCIO_NO_STACKTRACE");
#line 2122
  conf_no_stacktrace = bool_value(tmp___3);
  }
#line 2123
  if (! conf_no_init_messages) {
#line 2124
    if (conf_no_stacktrace) {
      {
#line 2125
      tmp___4 = (char const   *)"yes";
      }
    } else {
      {
#line 2127
      tmp___4 = (char const   *)"no";
      }
    }
    {
#line 2129
    output("%s=%s\n", "CAPRICCIO_NO_STACKTRACE", tmp___4);
    }
  }
  {
#line 2131
  tmp___5 = getenv((char const   *)"CAPRICCIO_NO_STATCOLLECT");
#line 2132
  conf_no_statcollect = bool_value(tmp___5);
  }
#line 2133
  if (! conf_no_init_messages) {
#line 2134
    if (conf_no_statcollect) {
      {
#line 2135
      tmp___6 = (char const   *)"yes";
      }
    } else {
      {
#line 2137
      tmp___6 = (char const   *)"no";
      }
    }
    {
#line 2139
    output("%s=%s\n", "CAPRICCIO_NO_STATCOLLECT", tmp___6);
    }
  }
  {
#line 2141
  tmp___7 = getenv((char const   *)"CAPRICCIO_DUMP_BLOCKING_GRAPH");
#line 2142
  conf_dump_blocking_graph = bool_value(tmp___7);
  }
#line 2143
  if (! conf_no_init_messages) {
#line 2144
    if (conf_dump_blocking_graph) {
      {
#line 2145
      tmp___8 = (char const   *)"yes";
      }
    } else {
      {
#line 2147
      tmp___8 = (char const   *)"no";
      }
    }
    {
#line 2149
    output("%s=%s\n", "CAPRICCIO_DUMP_BLOCKING_GRAPH", tmp___8);
    }
  }
  {
#line 2151
  tmp___9 = getenv((char const   *)"CAPRICCIO_DUMP_TIMING_INFO");
#line 2152
  conf_dump_timing_info = bool_value(tmp___9);
  }
#line 2153
  if (! conf_no_init_messages) {
#line 2154
    if (conf_dump_timing_info) {
      {
#line 2155
      tmp___10 = (char const   *)"yes";
      }
    } else {
      {
#line 2157
      tmp___10 = (char const   *)"no";
      }
    }
    {
#line 2159
    output("%s=%s\n", "CAPRICCIO_DUMP_TIMING_INFO", tmp___10);
    }
  }
  {
#line 2161
  tmp___11 = getenv((char const   *)"CAPRICCIO_SHOW_THREAD_DETAILS");
#line 2162
  conf_show_thread_details = bool_value(tmp___11);
  }
#line 2163
  if (! conf_no_init_messages) {
#line 2164
    if (conf_show_thread_details) {
      {
#line 2165
      tmp___12 = (char const   *)"yes";
      }
    } else {
      {
#line 2167
      tmp___12 = (char const   *)"no";
      }
    }
    {
#line 2169
    output("%s=%s\n", "CAPRICCIO_SHOW_THREAD_DETAILS", tmp___12);
    }
  }
  {
#line 2171
  tmp___13 = getenv((char const   *)"CAPRICCIO_SHOW_THREAD_STACKS");
#line 2172
  conf_show_thread_stacks = bool_value(tmp___13);
  }
#line 2173
  if (! conf_no_init_messages) {
#line 2174
    if (conf_show_thread_stacks) {
      {
#line 2175
      tmp___14 = (char const   *)"yes";
      }
    } else {
      {
#line 2177
      tmp___14 = (char const   *)"no";
      }
    }
    {
#line 2179
    output("%s=%s\n", "CAPRICCIO_SHOW_THREAD_STACKS", tmp___14);
    }
  }
  {
#line 2181
  str = getenv((char const   *)"CAPRICCIO_DEFAULT_STACK_SIZE");
  }
#line 2182
  if ((unsigned int )str != (unsigned int )((void *)0)) {
    {
#line 2183
    mult = 0;
#line 2184
    val = strtol((char const   * __restrict  )str, (char ** __restrict  )(& p), 0);
    }
#line 2185
    if ((unsigned int )p == (unsigned int )str) {
      {
#line 2186
      fatal("Bad number format for CAPRICCIO_DEFAULT_STACK_SIZE: \'%s\'\n", str);
      }
    }
    {
#line 2189
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 2190
      tmp___15 = __ctype_b_loc();
      }
#line 2191
      if (! ((int const   )*(*tmp___15 + (int )*p) & 8192)) {
#line 2192
        goto while_break;
      }
      {
#line 2194
      p ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 2196
    if ((int )*p == 0) {
      {
#line 2197
      mult = 1024;
      }
    } else
#line 2199
    if ((int )*p == 98) {
      {
#line 2200
      mult = 1;
      }
    } else
#line 2202
    if ((int )*p == 66) {
      {
#line 2203
      mult = 1;
      }
    } else
#line 2205
    if ((int )*p == 107) {
      {
#line 2206
      mult = 1024;
      }
    } else
#line 2208
    if ((int )*p == 75) {
      {
#line 2209
      mult = 1024;
      }
    } else
#line 2211
    if ((int )*p == 109) {
      {
#line 2212
      mult = 1048576;
      }
    } else
#line 2214
    if ((int )*p == 77) {
      {
#line 2215
      mult = 1048576;
      }
    } else {
      {
#line 2217
      fatal("Bad units for CAPRICCIO_DEFAULT_STACK_SIZE: \'%s\'\n", str);
      }
    }
    {
#line 2226
    conf_new_stack_size = 1024L;
#line 2227
    conf_new_stack_kb_log2 = 0;
    }
    {
#line 2228
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2228
      if (! (conf_new_stack_size < (long )mult * val)) {
#line 2228
        goto while_break___0;
      }
      {
#line 2229
      conf_new_stack_kb_log2 ++;
#line 2230
      conf_new_stack_size <<= 1;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 2233
  if (! conf_no_init_messages) {
#line 2234
    if (conf_new_stack_size > 1048576L) {
#line 2235
      if (! (conf_new_stack_size & 1048575L)) {
        {
#line 2236
        output("CAPRICCIO_DEFAULT_STACKSIZE=%ldM\n", (conf_new_stack_size / 1024L) / 1024L);
        }
      } else {
#line 2238
        goto _L;
      }
    } else
    _L: 
#line 2242
    if (conf_new_stack_size > 1024L) {
#line 2243
      if (! (conf_new_stack_size & 1023L)) {
        {
#line 2244
        output("CAPRICCIO_DEFAULT_STACKSIZE=%ldK\n", conf_new_stack_size / 1024L);
        }
      } else {
        {
#line 2246
        output("CAPRICCIO_DEFAULT_STACKSIZE=%ldb\n", conf_new_stack_size);
        }
      }
    } else {
      {
#line 2249
      output("CAPRICCIO_DEFAULT_STACKSIZE=%ldb\n", conf_new_stack_size);
      }
    }
  }
#line 2253
  return;
}
}
