/* Generated by CIL v. 1.3.5 */
/* print_CIL_Input is true */

#line 214 "/usr/lib/gcc/i486-linux-gnu/4.1.3/include/stddef.h"
typedef unsigned int size_t;
#line 59 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 60 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 137 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 143 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 144 "/usr/include/bits/types.h"
typedef long __off_t;
#line 145 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 146 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 147 "/usr/include/bits/types.h"
struct __anonstruct___fsid_t_1 {
   int __val[2] ;
};
#line 147 "/usr/include/bits/types.h"
typedef struct __anonstruct___fsid_t_1 __fsid_t;
#line 149 "/usr/include/bits/types.h"
typedef unsigned long __rlim_t;
#line 152 "/usr/include/bits/types.h"
typedef long __time_t;
#line 167 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 172 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 176 "/usr/include/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 180 "/usr/include/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 183 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 35 "/usr/include/dirent.h"
typedef __ino_t ino_t;
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 62 "/usr/include/sys/types.h"
typedef __dev_t dev_t;
#line 67 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 72 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 82 "/usr/include/sys/types.h"
typedef __uid_t uid_t;
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 77 "/usr/include/time.h"
typedef __time_t time_t;
#line 29 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_3 {
   unsigned long __val[(int )(1024U / (8U * sizeof(unsigned long )))] ;
};
#line 29 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_3 __sigset_t;
#line 38 "/usr/include/sys/select.h"
typedef __sigset_t sigset_t;
#line 121 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 36 "/usr/include/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 39 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_attr_t_5 {
   char __size[36] ;
   long __align ;
};
#line 39 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_attr_t_5 pthread_attr_t;
#line 46 "/usr/include/bits/pthreadtypes.h"
struct __pthread_internal_slist {
   struct __pthread_internal_slist *__next ;
};
#line 46 "/usr/include/bits/pthreadtypes.h"
typedef struct __pthread_internal_slist __pthread_slist_t;
#line 54 "/usr/include/bits/pthreadtypes.h"
union __anonunion____missing_field_name_7 {
   int __spins ;
   __pthread_slist_t __list ;
};
#line 54 "/usr/include/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   int __kind ;
   unsigned int __nusers ;
   union __anonunion____missing_field_name_7 __annonCompField1 ;
};
#line 54 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_6 {
   struct __pthread_mutex_s __data ;
   char __size[24] ;
   long __align ;
};
#line 54 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_6 pthread_mutex_t;
#line 84 "/usr/include/bits/pthreadtypes.h"
struct __anonstruct___data_10 {
   int __lock ;
   unsigned int __futex ;
   unsigned long long __total_seq ;
   unsigned long long __wakeup_seq ;
   unsigned long long __woken_seq ;
   void *__mutex ;
   unsigned int __nwaiters ;
   unsigned int __broadcast_seq ;
};
#line 84 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_cond_t_9 {
   struct __anonstruct___data_10 __data ;
   char __size[48] ;
   long long __align ;
};
#line 84 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_cond_t_9 pthread_cond_t;
#line 109 "/usr/include/bits/pthreadtypes.h"
typedef unsigned int pthread_key_t;
#line 119 "/usr/include/bits/pthreadtypes.h"
struct __anonstruct___data_13 {
   int __lock ;
   unsigned int __nr_readers ;
   unsigned int __readers_wakeup ;
   unsigned int __writer_wakeup ;
   unsigned int __nr_readers_queued ;
   unsigned int __nr_writers_queued ;
   unsigned int __flags ;
   int __writer ;
};
#line 119 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_rwlock_t_12 {
   struct __anonstruct___data_13 __data ;
   char __size[32] ;
   long __align ;
};
#line 119 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_rwlock_t_12 pthread_rwlock_t;
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 106 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 177 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 183 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 268 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(int )((15U * sizeof(int ) - 4U * sizeof(void *)) - sizeof(size_t ))] ;
};
#line 33 "/usr/include/bits/resource.h"
enum __rlimit_resource {
    RLIMIT_CPU = 0,
    RLIMIT_FSIZE = 1,
    RLIMIT_DATA = 2,
    RLIMIT_STACK = 3,
    RLIMIT_CORE = 4,
    __RLIMIT_RSS = 5,
    RLIMIT_NOFILE = 7,
    __RLIMIT_OFILE = 7,
    RLIMIT_AS = 9,
    __RLIMIT_NPROC = 6,
    __RLIMIT_MEMLOCK = 8,
    __RLIMIT_LOCKS = 10,
    __RLIMIT_SIGPENDING = 11,
    __RLIMIT_MSGQUEUE = 12,
    __RLIMIT_NICE = 13,
    __RLIMIT_RTPRIO = 14,
    __RLIMIT_NLIMITS = 15,
    __RLIM_NLIMITS = 15
} ;
#line 127 "/usr/include/bits/resource.h"
typedef __rlim_t rlim_t;
#line 135 "/usr/include/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 39 "/usr/include/sys/resource.h"
typedef enum __rlimit_resource __rlimit_resource_t;
#line 37 "/usr/include/sys/poll.h"
typedef unsigned long nfds_t;
#line 40 "/usr/include/sys/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 25 "/usr/include/bits/statfs.h"
struct statfs {
   int f_type ;
   int f_bsize ;
   __fsblkcnt_t f_blocks ;
   __fsblkcnt_t f_bfree ;
   __fsblkcnt_t f_bavail ;
   __fsfilcnt_t f_files ;
   __fsfilcnt_t f_ffree ;
   __fsid_t f_fsid ;
   int f_namelen ;
   int f_frsize ;
   int f_spare[5] ;
};
#line 49 "/usr/include/sys/utsname.h"
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char domainname[65] ;
};
#line 20 "/usr/include/asm-i386/types.h"
typedef unsigned int __u32;
#line 24 "/usr/include/asm-i386/types.h"
typedef unsigned long long __u64;
#line 29 "/usr/include/bits/setjmp.h"
typedef int __jmp_buf[6];
#line 492 "/usr/include/pthread.h"
struct __anonstruct___cancel_jmp_buf_73 {
   __jmp_buf __cancel_jmp_buf ;
   int __mask_was_saved ;
};
#line 492 "/usr/include/pthread.h"
struct __anonstruct___pthread_unwind_buf_t_72 {
   struct __anonstruct___cancel_jmp_buf_73 __cancel_jmp_buf[1] ;
   void *__pad[4] ;
};
#line 492 "/usr/include/pthread.h"
typedef struct __anonstruct___pthread_unwind_buf_t_72  __attribute__((__aligned__)) __pthread_unwind_buf_t;
#line 709
struct __jmp_buf_tag;
#line 14 "../include/list.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 51 "../include/linux/auto_fs.h"
typedef unsigned long autofs_wqt_t;
#line 58 "../include/linux/auto_fs.h"
struct autofs_packet_hdr {
   int proto_version ;
   int type ;
};
#line 64 "../include/linux/auto_fs.h"
struct autofs_packet_missing {
   struct autofs_packet_hdr hdr ;
   autofs_wqt_t wait_queue_token ;
   int len ;
   char name[256] ;
};
#line 72 "../include/linux/auto_fs.h"
struct autofs_packet_expire {
   struct autofs_packet_hdr hdr ;
   int len ;
   char name[256] ;
};
#line 55 "../include/linux/auto_fs4.h"
struct autofs_packet_expire_multi {
   struct autofs_packet_hdr hdr ;
   autofs_wqt_t wait_queue_token ;
   int len ;
   char name[256] ;
};
#line 63 "../include/linux/auto_fs4.h"
struct autofs_v5_packet {
   struct autofs_packet_hdr hdr ;
   autofs_wqt_t wait_queue_token ;
   __u32 dev ;
   __u64 ino ;
   __u32 uid ;
   __u32 gid ;
   __u32 pid ;
   __u32 tgid ;
   __u32 len ;
   char name[256] ;
};
#line 76 "../include/linux/auto_fs4.h"
typedef struct autofs_v5_packet autofs_packet_missing_indirect_t;
#line 77 "../include/linux/auto_fs4.h"
typedef struct autofs_v5_packet autofs_packet_expire_indirect_t;
#line 78 "../include/linux/auto_fs4.h"
typedef struct autofs_v5_packet autofs_packet_missing_direct_t;
#line 79 "../include/linux/auto_fs4.h"
typedef struct autofs_v5_packet autofs_packet_expire_direct_t;
#line 81 "../include/linux/auto_fs4.h"
union autofs_packet_union {
   struct autofs_packet_hdr hdr ;
   struct autofs_packet_missing missing ;
   struct autofs_packet_expire expire ;
   struct autofs_packet_expire_multi expire_multi ;
   struct autofs_v5_packet v5_packet ;
};
#line 40 "../include/state.h"
enum states {
    ST_INVAL = -1,
    ST_INIT = 0,
    ST_READY = 1,
    ST_EXPIRE = 2,
    ST_PRUNE = 3,
    ST_READMAP = 4,
    ST_SHUTDOWN_PENDING = 5,
    ST_SHUTDOWN_FORCE = 6,
    ST_SHUTDOWN = 7
} ;
#line 52
struct autofs_point;
#line 27 "../include/master.h"
struct mapent_cache;
#line 27
struct lookup_mod;
#line 27 "../include/master.h"
struct map_source {
   char *type ;
   char *format ;
   time_t age ;
   unsigned int master_line ;
   struct mapent_cache *mc ;
   unsigned int stale ;
   unsigned int recurse ;
   unsigned int depth ;
   struct lookup_mod *lookup ;
   int argc ;
   char const   **argv ;
   struct map_source *instance ;
   struct map_source *next ;
};
#line 43
struct master;
#line 43 "../include/master.h"
struct master_mapent {
   char *path ;
   pthread_t thid ;
   time_t age ;
   struct master *master ;
   pthread_rwlock_t source_lock ;
   pthread_mutex_t current_mutex ;
   pthread_cond_t current_cond ;
   struct map_source *current ;
   struct map_source *maps ;
   struct autofs_point *ap ;
   struct list_head list ;
};
#line 57 "../include/master.h"
struct master {
   char *name ;
   unsigned int recurse ;
   unsigned int depth ;
   unsigned int reading ;
   unsigned int default_ghost ;
   unsigned int default_logging ;
   unsigned int default_timeout ;
   struct mapent_cache *nc ;
   struct list_head mounts ;
};
#line 21 "../include/parse_subs.h"
struct mapent;
#line 129 "../include/automount.h"
struct mapent_cache {
   pthread_rwlock_t rwlock ;
   unsigned int size ;
   pthread_mutex_t ino_index_mutex ;
   struct list_head *ino_index ;
   struct map_source *map ;
   struct mapent **hash ;
};
#line 138 "../include/automount.h"
struct mapent {
   struct mapent *next ;
   struct list_head ino_index ;
   pthread_mutex_t multi_mutex ;
   struct list_head multi_list ;
   struct mapent_cache *mc ;
   struct map_source *source ;
   struct mapent *multi ;
   struct mapent *parent ;
   char *key ;
   char *mapent ;
   time_t age ;
   time_t status ;
   int dir_created ;
   int ioctlfd ;
   dev_t dev ;
   ino_t ino ;
};
#line 249 "../include/automount.h"
struct lookup_mod {
   int (*lookup_init)(char const   * , int  , char const   * const  * , void ** ) ;
   int (*lookup_read_master)(struct master *master , time_t  , void * ) ;
   int (*lookup_read_map)(struct autofs_point * , time_t  , void * ) ;
   int (*lookup_mount)(struct autofs_point * , char const   * , int  , void * ) ;
   int (*lookup_done)(void * ) ;
   void *dlhandle ;
   void *context ;
};
#line 381 "../include/automount.h"
struct startup_cond {
   pthread_mutex_t mutex ;
   pthread_cond_t cond ;
   unsigned int done ;
   unsigned int status ;
};
#line 388 "../include/automount.h"
struct master_readmap_cond {
   pthread_mutex_t mutex ;
   pthread_cond_t cond ;
   pthread_t thid ;
   struct master *master ;
   time_t age ;
   enum states state ;
   unsigned int signaled ;
   unsigned int busy ;
};
#line 416 "../include/automount.h"
struct thread_stdenv_vars {
   uid_t uid ;
   gid_t gid ;
   char *user ;
   char *group ;
   char *home ;
};
#line 431 "../include/automount.h"
struct autofs_point {
   pthread_t thid ;
   char *path ;
   int pipefd ;
   int kpipefd ;
   int ioctlfd ;
   dev_t dev ;
   struct master_mapent *entry ;
   unsigned int type ;
   time_t exp_timeout ;
   time_t exp_runfreq ;
   unsigned int ghost ;
   unsigned int logopt ;
   pthread_t exp_thread ;
   pthread_t readmap_thread ;
   pthread_mutex_t state_mutex ;
   enum states state ;
   int state_pipe[2] ;
   unsigned int dir_created ;
   struct autofs_point *parent ;
   pthread_mutex_t mounts_mutex ;
   pthread_cond_t mounts_cond ;
   unsigned int mounts_signaled ;
   struct list_head mounts ;
   unsigned int submount ;
   unsigned int submnt_count ;
   struct list_head submounts ;
};
#line 329 "automount.c"
struct counter_args {
   unsigned int count ;
   dev_t dev ;
};
#line 101 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_condattr_t_11 {
   char __size[4] ;
   long __align ;
};
#line 101 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_condattr_t_11 pthread_condattr_t;
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 43 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 52 "../include/state.h"
struct expire_args {
   pthread_mutex_t mutex ;
   pthread_cond_t cond ;
   unsigned int signaled ;
   struct autofs_point *ap ;
   enum states state ;
   unsigned int when ;
   int status ;
};
#line 37 "../include/log.h"
typedef void logger(unsigned int logopt , char const   *msg  , ...);
#line 328 "../include/automount.h"
struct mnt_list {
   char *path ;
   char *fs_name ;
   char *fs_type ;
   char *opts ;
   pid_t owner ;
   struct mnt_list *next ;
   struct mnt_list *left ;
   struct mnt_list *right ;
   struct list_head self ;
   struct list_head list ;
   struct list_head entries ;
   struct list_head sublist ;
   struct list_head ordered ;
};
#line 399 "../include/automount.h"
struct pending_args {
   pthread_mutex_t mutex ;
   pthread_cond_t cond ;
   unsigned int signaled ;
   struct autofs_point *ap ;
   int status ;
   int type ;
   int ioctlfd ;
   struct mapent_cache *mc ;
   char name[255] ;
   dev_t dev ;
   unsigned int len ;
   uid_t uid ;
   gid_t gid ;
   unsigned long wait_queue_token ;
};
#line 113 "/usr/include/bits/pthreadtypes.h"
//typedef int pthread_once_t;
#line 45 "direct.c"
struct mnt_params {
   char *options ;
};
#line 148 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 33 "/usr/include/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 33 "/usr/include/bits/siginfo.h"
typedef union sigval sigval_t;
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__kill_17 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__timer_18 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__rt_19 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigchld_20 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigfault_21 {
   void *si_addr ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigpoll_22 {
   long si_band ;
   int si_fd ;
};
#line 51 "/usr/include/bits/siginfo.h"
union __anonunion__sifields_16 {
   int _pad[(int )(128U / sizeof(int ) - 3U)] ;
   struct __anonstruct__kill_17 _kill ;
   struct __anonstruct__timer_18 _timer ;
   struct __anonstruct__rt_19 _rt ;
   struct __anonstruct__sigchld_20 _sigchld ;
   struct __anonstruct__sigfault_21 _sigfault ;
   struct __anonstruct__sigpoll_22 _sigpoll ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_16 _sifields ;
};
#line 51 "/usr/include/bits/siginfo.h"
typedef struct siginfo siginfo_t;
#line 25 "/usr/include/bits/sigaction.h"
union __anonunion___sigaction_handler_34 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 25 "/usr/include/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_34 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 43 "/usr/lib/gcc/i486-linux-gnu/4.1.3/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 105 "/usr/lib/gcc/i486-linux-gnu/4.1.3/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 277 "../include/automount.h"
struct parse_mod {
   int (*parse_init)(int  , char const   * const  * , void ** ) ;
   int (*parse_mount)(struct autofs_point * , char const   * , int  , char const   * ,
                      void * ) ;
   int (*parse_done)(void * ) ;
   void *dlhandle ;
   void *context ;
};
#line 304 "../include/automount.h"
struct mount_mod {
   int (*mount_init)(void ** ) ;
   int (*mount_mount)(struct autofs_point * , char const   * , char const   * , int  ,
                      char const   * , char const   * , char const   * , void * ) ;
   int (*mount_done)(void * ) ;
   void *dlhandle ;
   void *context ;
};
#line 29 "../include/nsswitch.h"
enum nsswitch_status {
    NSS_STATUS_UNKNOWN = -1,
    NSS_STATUS_SUCCESS = 0,
    NSS_STATUS_NOTFOUND = 1,
    NSS_STATUS_UNAVAIL = 2,
    NSS_STATUS_TRYAGAIN = 3,
    NSS_STATUS_MAX = 4
} ;
#line 41
enum nsswitch_action {
    NSS_ACTION_UNKNOWN = 0,
    NSS_ACTION_CONTINUE = 1,
    NSS_ACTION_RETURN = 2
} ;
#line 47 "../include/nsswitch.h"
struct nss_action {
   enum nsswitch_action action ;
   int negated ;
};
#line 52 "../include/nsswitch.h"
struct nss_source {
   char *source ;
   struct nss_action action[4] ;
   struct list_head list ;
};
#line 75 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_7 {
   char __size[4] ;
   long __align ;
};
#line 75 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_7 pthread_mutexattr_t;
#line 76 "../include/state.h"
struct readmap_args {
   pthread_mutex_t mutex ;
   pthread_cond_t cond ;
   unsigned int signaled ;
   struct autofs_point *ap ;
   time_t now ;
};
#line 21 "state.c"
struct state_queue {
   pthread_t thid ;
   struct list_head list ;
   struct list_head pending ;
   struct autofs_point *ap ;
   enum states state ;
   unsigned int busy ;
   unsigned int done ;
   unsigned int cancel ;
};
#line 213
enum expire {
    EXP_ERROR = 0,
    EXP_STARTED = 1,
    EXP_PARTIAL = 2
} ;
#line 1 "automount.o"
#pragma merger(0,"/tmp/cil-MnezGtJu.i","-O2,-Wall,-fPIE")
#line 135 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 150
extern int closedir(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
#line 184
extern int readdir_r(DIR * __restrict  __dirp , struct dirent * __restrict  __entry ,
                     struct dirent ** __restrict  __result )  __attribute__((__nonnull__(1,2,3))) ;
#line 250
extern int scandir(char const   * __restrict  __dir , struct dirent *** __restrict  __namelist ,
                   int (*__selector)(struct dirent  const  * ) , int (*__cmp)(void const   * ,
                                                                              void const   * ) )  __attribute__((__nonnull__(1,2))) ;
#line 280
extern  __attribute__((__nothrow__)) int alphasort(void const   *__e1 , void const   *__e2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 318 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int mkdir(char const   *__path , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 399
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
#line 401
extern  __attribute__((__nothrow__)) int __lxstat(int __ver , char const   *__filename ,
                                                  struct stat *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
#line 450
/*__inline static  __attribute__((__nothrow__)) int stat__extinline(char const   *__path ,
                                                                  struct stat *__statbuf ) ;
*/
#line 450 "/usr/include/sys/stat.h"
__inline static int stat__extinline(char const   *__path , struct stat *__statbuf ) 
{ int tmp ;

  {
#line 453
  tmp = __xstat(3, __path, __statbuf);
#line 453
  return (tmp);
}
}
#line 457
/*__inline static  __attribute__((__nothrow__)) int lstat__extinline(char const   *__path ,
                                                                   struct stat *__statbuf ) ;
*/
#line 457 "/usr/include/sys/stat.h"
__inline static int lstat__extinline(char const   *__path , struct stat *__statbuf ) 
{ int tmp ;

  {
#line 460
  tmp = __lxstat(3, __path, __statbuf);
#line 460
  return (tmp);
}
}
#line 59 "/usr/include/getopt.h"
extern char *optarg ;
#line 73
extern int optind ;
#line 78
extern int opterr ;
#line 159
extern  __attribute__((__nothrow__)) int getopt_long(int ___argc , char * const  *___argv ,
                                                     char const   *__shortopts , struct option  const  *__longopts ,
                                                     int *__longind ) ;
#line 117 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 219
extern  __attribute__((__nothrow__)) int sigfillset(sigset_t *__set )  __attribute__((__nonnull__(1))) ;
#line 225
extern  __attribute__((__nothrow__)) int sigdelset(sigset_t *__set , int __signo )  __attribute__((__nonnull__(1))) ;
#line 249
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t const   * __restrict  __set ,
                                                     sigset_t * __restrict  __oset ) ;
#line 271
extern int sigwait(sigset_t const   * __restrict  __set , int * __restrict  __sig )  __attribute__((__nonnull__(1,2))) ;
#line 147 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 214
extern int fclose(FILE *__stream ) ;
#line 249
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 331
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 337
extern int printf(char const   * __restrict  __format  , ...) ;
#line 339
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 361
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 445
extern int fgetc(FILE *__stream ) ;
#line 290 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   * __restrict  __nptr ,
                                                            char ** __restrict  __endptr ,
                                                            int __base , int __group )  __attribute__((__nonnull__(1))) ;
#line 297
extern  __attribute__((__nothrow__)) unsigned long __strtoul_internal(char const   * __restrict  __nptr ,
                                                                      char ** __restrict  __endptr ,
                                                                      int __base ,
                                                                      int __group )  __attribute__((__nonnull__(1))) ;
#line 332
/*__inline static  __attribute__((__nothrow__)) long strtol__extinline(char const   * __restrict  __nptr ,
                                                                     char ** __restrict  __endptr ,
                                                                     int __base ) ;
*/
#line 332 "/usr/include/stdlib.h"
__inline static long strtol__extinline(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                       int __base ) 
{ long tmp ;

  {
#line 336
  tmp = __strtol_internal(__nptr, __endptr, __base, 0);
#line 336
  return (tmp);
}
}
#line 338
/*__inline static  __attribute__((__nothrow__)) unsigned long strtoul__extinline(char const   * __restrict  __nptr ,
                                                                               char ** __restrict  __endptr ,
                                                                               int __base ) ;
*/
#line 338 "/usr/include/stdlib.h"
__inline static unsigned long strtoul__extinline(char const   * __restrict  __nptr ,
                                                 char ** __restrict  __endptr , int __base ) 
{ unsigned long tmp ;

  {
#line 342
  tmp = __strtoul_internal(__nptr, __endptr, __base, 0);
#line 342
  return (tmp);
}
}
#line 401
//__inline static  __attribute__((__nothrow__)) int atoi__extinline(char const   *__nptr ) ;
#line 401 "/usr/include/stdlib.h"
__inline static int atoi__extinline(char const   *__nptr ) 
{ int tmp ;

  {
#line 404
  tmp = (int )strtol__extinline((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                                10);
#line 404
  return (tmp);
}
}
#line 498
extern  __attribute__((__nothrow__)) int rand(void) ;
#line 603
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 628
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 646
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 38 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                                                  size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 59
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n )  __attribute__((__nonnull__(1))) ;
#line 84
extern  __attribute__((__nothrow__)) char *strcpy(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
#line 92
extern  __attribute__((__nothrow__)) char *strcat(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
#line 170
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 194
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 242
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 281
extern  __attribute__((__nothrow__)) char *strerror_r(int __errnum , char *__buf ,
                                                      size_t __buflen )  __attribute__((__nonnull__(2))) ;
#line 1304 "/usr/include/bits/string2.h"
extern  __attribute__((__nothrow__)) char *__strdup(char const   *__string )  __attribute__((__malloc__)) ;
#line 320 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 327
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 333
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 384
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 457
extern  __attribute__((__nothrow__)) int chdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 573
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 634
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 645
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 723
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 792
extern  __attribute__((__nothrow__)) int unlink(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 801
extern  __attribute__((__nothrow__)) int rmdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 51 "/usr/include/asm-generic/ioctl.h"
extern unsigned int __invalid_size_argument_for_IOC ;
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 81 "/usr/include/ctype.h"
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 70 "/usr/include/sys/resource.h"
extern  __attribute__((__nothrow__)) int setrlimit(__rlimit_resource_t __resource ,
                                                   struct rlimit  const  *__rlimits ) ;
#line 58 "/usr/include/sys/poll.h"
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
#line 32 "/usr/include/sys/statfs.h"
extern  __attribute__((__nothrow__)) int statfs(char const   *__file , struct statfs *__buf )  __attribute__((__nonnull__(1,2))) ;
#line 82 "/usr/include/sys/utsname.h"
extern  __attribute__((__nothrow__)) int uname(struct utsname *__name ) ;
#line 187 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 184 "../include/syslog.h"
extern void closelog(void) ;
#line 54 "/usr/include/sched.h"
extern  __attribute__((__nothrow__)) int sched_yield(void) ;
#line 222 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int pthread_create(pthread_t * __restrict  __newthread ,
                                                        pthread_attr_t const   * __restrict  __attr ,
                                                        void *(*__start_routine)(void * ) ,
                                                        void * __restrict  __arg )  __attribute__((__nonnull__(1,3))) ;
#line 231
extern  __attribute__((__noreturn__)) void pthread_exit(void *__retval ) ;
#line 275
extern  __attribute__((__nothrow__)) int pthread_attr_init(pthread_attr_t *__attr )  __attribute__((__nonnull__(1))) ;
#line 287
extern  __attribute__((__nothrow__)) int pthread_attr_setdetachstate(pthread_attr_t *__attr ,
                                                                     int __detachstate )  __attribute__((__nonnull__(1))) ;
#line 364
extern  __attribute__((__nothrow__)) int pthread_attr_setstacksize(pthread_attr_t *__attr ,
                                                                   size_t __stacksize )  __attribute__((__nonnull__(1))) ;
#line 475
extern int pthread_setcancelstate(int __state , int *__oldstate ) ;
#line 649
extern void ( __attribute__((__regparm__(1))) __pthread_register_cancel)(__pthread_unwind_buf_t *__buf ) ;
#line 660
extern void ( __attribute__((__regparm__(1))) __pthread_unregister_cancel)(__pthread_unwind_buf_t *__buf ) ;
#line 700
extern  __attribute__((__noreturn__)) void ( __attribute__((__regparm__(1))) __pthread_unwind_next)(__pthread_unwind_buf_t *__buf )  __attribute__((__weak__)) ;
#line 710
extern  __attribute__((__nothrow__)) int __sigsetjmp(struct __jmp_buf_tag *__env ,
                                                     int __savemask ) ;
#line 725
extern  __attribute__((__nothrow__)) int pthread_mutex_trylock(pthread_mutex_t *__mutex )  __attribute__((__nonnull__(1))) ;
#line 729
extern  __attribute__((__nothrow__)) int pthread_mutex_lock(pthread_mutex_t *__mutex )  __attribute__((__nonnull__(1))) ;
#line 740
extern  __attribute__((__nothrow__)) int pthread_mutex_unlock(pthread_mutex_t *__mutex )  __attribute__((__nonnull__(1))) ;
#line 932
extern  __attribute__((__nothrow__)) int pthread_cond_signal(pthread_cond_t *__cond )  __attribute__((__nonnull__(1))) ;
#line 944
extern int pthread_cond_wait(pthread_cond_t * __restrict  __cond , pthread_mutex_t * __restrict  __mutex )  __attribute__((__nonnull__(1,2))) ;
#line 1066
extern  __attribute__((__nothrow__)) int pthread_key_create(pthread_key_t *__key ,
                                                            void (*__destr_function)(void * ) )  __attribute__((__nonnull__(1))) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 40 "../include/defaults.h"
extern unsigned int defaults_read_config(void) ;
#line 42
extern unsigned int defaults_get_timeout(void) ;
#line 43
extern unsigned int defaults_get_browse_mode(void) ;
#line 44
extern unsigned int defaults_get_logging(void) ;
#line 86 "../include/state.h"
void nextstate(int statefd , enum states next ) ;
#line 88
int st_add_task(struct autofs_point *ap , enum states state ) ;
#line 89
void st_remove_tasks(struct autofs_point *ap ) ;
#line 90
int st_start_handler(void) ;
#line 91 "../include/master.h"
extern void master_source_readlock(struct master_mapent * ) ;
#line 93
extern void master_source_lock_cleanup(void * ) ;
#line 99
extern void master_remove_mapent(struct master_mapent * ) ;
#line 100
extern void master_free_mapent_sources(struct master_mapent * , unsigned int  ) ;
#line 101
extern void master_free_mapent(struct master_mapent * ) ;
#line 102
extern struct master *master_new(char const   * , unsigned int  , unsigned int  ) ;
#line 103
extern int master_read_master(struct master * , time_t  , int  ) ;
#line 106
extern void master_signal_submount(struct autofs_point * , unsigned int  ) ;
#line 107
extern void master_notify_state_change(struct master * , int  ) ;
#line 109
extern int master_list_empty(struct master * ) ;
#line 110
extern int master_kill(struct master * ) ;
#line 31 "../include/macros.h"
extern int macro_parse_globalvar(char const   *define ) ;
#line 30 "../include/log.h"
extern void set_log_verbose(void) ;
#line 31
extern void set_log_debug(void) ;
#line 34
extern void log_to_syslog(void) ;
#line 35
extern void log_to_stderr(void) ;
#line 39
extern void (*log_info)(unsigned int  , char const   *msg  , ...) ;
#line 41
extern void (*log_warn)(unsigned int  , char const   *msg  , ...) ;
#line 42
extern void (*log_error)(unsigned int  , char const   *msg  , ...) ;
#line 43
extern void (*log_crit)(unsigned int  , char const   *msg  , ...) ;
#line 44
extern void (*log_debug)(unsigned int  , char const   *msg  , ...) ;
#line 30 "../include/parse_subs.h"
extern int umount_ent(struct autofs_point * , char const   * ) ;
#line 32
extern int umount_multi_triggers(struct autofs_point * , char * , struct mapent * ,
                                 char const   * ) ;
#line 162 "../include/automount.h"
extern void cache_lock_cleanup(void *arg ) ;
#line 163
extern void cache_readlock(struct mapent_cache *mc ) ;
#line 165
extern int cache_try_writelock(struct mapent_cache *mc ) ;
#line 166
extern void cache_unlock(struct mapent_cache *mc ) ;
#line 176
extern struct mapent *cache_lookup_distinct(struct mapent_cache *mc , char const   *key ) ;
#line 183
extern int cache_delete(struct mapent_cache *mc , char const   *key ) ;
#line 184
extern void cache_multi_lock(struct mapent *me ) ;
#line 185
extern void cache_multi_unlock(struct mapent *me ) ;
#line 199
void dump_core(void) ;
#line 211
int mkdir_path(char const   *path , mode_t mode ) ;
#line 212
int rmdir_path(struct autofs_point *ap , char const   *path , dev_t dev ) ;
#line 230
void lookup_close_lookup(struct autofs_point *ap ) ;
#line 233
struct mapent *lookup_source_mapent(struct autofs_point *ap , char const   *key ,
                                    unsigned int type ) ;
#line 318
extern int cat_path(char *buf , size_t len , char const   *dir , char const   *base ) ;
#line 319
extern int ncat_path(char *buf , size_t len , char const   *dir , char const   *base ,
                     size_t blen ) ;
#line 355
extern unsigned int query_kproto_ver(void) ;
#line 356
extern unsigned int get_kver_major(void) ;
#line 357
extern unsigned int get_kver_minor(void) ;
#line 363
extern int contained_in_local_fs(char const   *path ) ;
#line 364
extern int is_mounted(char const   *table , char const   *path , unsigned int type ) ;
#line 424 "../include/automount.h"
pthread_key_t key_thread_stdenv_vars  ;
#line 462
void *handle_mounts(void *arg ) ;
#line 463
int umount_multi(struct autofs_point *ap , char const   *path , int incl ) ;
#line 464
int send_ready(int ioctlfd , unsigned int wait_queue_token ) ;
#line 465
int send_fail(int ioctlfd , unsigned int wait_queue_token ) ;
#line 466
int do_expire(struct autofs_point *ap , char const   *name , int namelen ) ;
#line 470
int mount_autofs_indirect(struct autofs_point *ap ) ;
#line 471
int mount_autofs_direct(struct autofs_point *ap ) ;
#line 474
int umount_autofs(struct autofs_point *ap , int force ) ;
#line 475
int umount_autofs_indirect(struct autofs_point *ap ) ;
#line 477
int umount_autofs_direct(struct autofs_point *ap ) ;
#line 479
int handle_packet_expire_indirect(struct autofs_point *ap , autofs_packet_expire_indirect_t *pkt ) ;
#line 480
int handle_packet_expire_direct(struct autofs_point *ap , autofs_packet_expire_direct_t *pkt ) ;
#line 481
int handle_packet_missing_indirect(struct autofs_point *ap , autofs_packet_missing_indirect_t *pkt ) ;
#line 482
int handle_packet_missing_direct(struct autofs_point *ap , autofs_packet_missing_direct_t *pkt ) ;
#line 483
void rm_unwanted(char const   *path , int incl , dev_t dev ) ;
#line 484
int count_mounts(char const   *path , dev_t dev ) ;
#line 515
extern int alarm_start_handler(void) ;
#line 516
extern int alarm_add(struct autofs_point *ap , time_t seconds ) ;
#line 517
extern void alarm_delete(struct autofs_point *ap ) ;
#line 44 "automount.c"
char const   *program  ;
#line 45 "automount.c"
char const   *version  =    "5.0.2";
#line 46 "automount.c"
char const   *libdir  =    "/usr/lib/autofs";
#line 47 "automount.c"
char const   *mapdir  =    "/etc";
#line 48 "automount.c"
char const   *confdir  =    "";
#line 50 "automount.c"
char const   *global_options  ;
#line 52 "automount.c"
static char *pid_file  =    (char *)((void *)0);
#line 53 "automount.c"
unsigned int random_selection  ;
#line 55 "automount.c"
static int start_pipefd[2]  ;
#line 56 "automount.c"
static int st_stat  =    0;
#line 57 "automount.c"
static int *pst_stat  =    & st_stat;
#line 60 "automount.c"
static size_t kpkt_len  ;
#line 63 "automount.c"
pthread_attr_t thread_attr  ;
#line 65 "automount.c"
struct master_readmap_cond mrc  = 
#line 65
     {{{0, 0U, 0, 0, 0U, {0}}}, {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}}, (pthread_t )0,
    (struct master *)((void *)0), (time_t )0, (enum states )0, 0U, 0U};
#line 68 "automount.c"
struct startup_cond suc  =    {{{0, 0U, 0, 0, 0U, {0}}}, {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}}, 0U,
    0U};
#line 78
static int umount_all(struct autofs_point *ap , int force ) ;
#line 81
extern struct master *master_list ;
#line 83 "automount.c"
static int do_mkdir(char const   *parent , char const   *path , mode_t mode ) 
{ int status ;
  struct stat st ;
  struct statfs fs ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 90
  status = stat__extinline(path, & st);
#line 91
  if (status == 0) {
#line 92
    if (! ((st.st_mode & 61440U) == 16384U)) {
#line 93
      tmp = __errno_location();
#line 93
      (*tmp) = 20;
    }
#line 94
    tmp___0 = __errno_location();
#line 94
    (*tmp___0) = 17;
#line 95
    return (0);
  }
#line 102
  status = -1;
#line 103
  if ((*parent)) {
#line 104
    status = statfs(parent, & fs);
  }
#line 105
  if (status != -1) {
#line 105
    if (fs.f_type == 391) {
      goto _L;
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 105
    tmp___2 = contained_in_local_fs(path);
#line 105
    if (tmp___2) {
      _L: /* CIL Label */ 
#line 107
      tmp___1 = mkdir(path, mode);
#line 107
      if (tmp___1 == -1) {
#line 108
        return (0);
      }
#line 109
      return (1);
    }
  }
#line 112
  return (0);
}
}
#line 115 "automount.c"
int mkdir_path(char const   *path , mode_t mode ) 
{ char *buf ;
  size_t tmp ;
  char *tmp___0 ;
  char *parent ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char const   *cp ;
  char const   *lcp ;
  char *bp ;
  char *pp ;
  int tmp___3 ;
  char const   *tmp___4 ;

  {
#line 117
  tmp = strlen(path);
#line 117
  tmp___0 = (char *)__builtin_alloca(tmp + 1U);
#line 117
  buf = tmp___0;
#line 118
  tmp___1 = strlen(path);
#line 118
  tmp___2 = (char *)__builtin_alloca(tmp___1 + 1U);
#line 118
  parent = tmp___2;
#line 119
  cp = path;
#line 119
  lcp = path;
#line 120
  bp = buf;
#line 120
  pp = parent;
#line 122
  (*parent) = (char )'\000';
#line 124
  while (1) {
#line 125
    if ((unsigned int )cp != (unsigned int )path) {
#line 125
      if ((int const   )(*cp) == 47) {
        goto _L;
      } else {
#line 125
        if ((int const   )(*cp) == 0) {
          _L: /* CIL Label */ 
#line 126
          memcpy((void * __restrict  )bp, (void const   * __restrict  )lcp, (unsigned int )(cp - lcp));
#line 127
          bp += cp - lcp;
#line 128
          (*bp) = (char )'\000';
#line 129
          tmp___3 = do_mkdir((char const   *)parent, (char const   *)buf, mode);
#line 129
          if (! tmp___3) {
#line 130
            if ((int const   )(*cp) != 0) {
#line 131
              memcpy((void * __restrict  )pp, (void const   * __restrict  )lcp, (unsigned int )(cp - lcp));
#line 132
              pp += cp - lcp;
#line 133
              (*pp) = (char )'\000';
#line 134
              lcp = cp;
              goto __Cont;
            }
#line 137
            return (-1);
          }
#line 139
          memcpy((void * __restrict  )pp, (void const   * __restrict  )lcp, (unsigned int )(cp - lcp));
#line 140
          pp += cp - lcp;
#line 141
          (*pp) = (char )'\000';
#line 142
          lcp = cp;
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 124
    tmp___4 = cp;
#line 124
    cp ++;
#line 124
    if (! ((int const   )(*tmp___4) != 0)) {
#line 124
      break;
    }
  }
#line 146
  return (0);
}
}
#line 150 "automount.c"
int rmdir_path(struct autofs_point *ap , char const   *path , dev_t dev ) 
{ int len ;
  int tmp ;
  char *buf ;
  char *tmp___0 ;
  char *cp ;
  int first ;
  struct stat st ;
  struct statfs fs ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 152
  tmp = (int )strlen(path);
#line 152
  len = tmp;
#line 153
  tmp___0 = (char *)__builtin_alloca((unsigned int )(len + 1));
#line 153
  buf = tmp___0;
#line 155
  first = 1;
#line 159
  strcpy((char * __restrict  )buf, (char const   * __restrict  )path);
#line 160
  cp = buf + len;
#line 162
  while (1) {
#line 163
    (*cp) = (char )'\000';
#line 170
    memset((void *)(& st), 0, sizeof(st));
#line 171
    tmp___1 = lstat__extinline((char const   *)buf, & st);
#line 171
    if (tmp___1 != 0) {
#line 172
      while (1) {
#line 172
        ((*log_crit))(ap->logopt, "%s: lstat of %s failed.", "rmdir_path", buf);
#line 172
        break;
      }
#line 173
      return (-1);
    }
#line 177
    if (st.st_dev != dev) {
#line 178
      return (0);
    }
#line 180
    tmp___2 = statfs((char const   *)buf, & fs);
#line 180
    if (tmp___2 != 0) {
#line 181
      while (1) {
#line 181
        ((*log_error))(ap->logopt, "%s: could not stat fs of %s", "rmdir_path", buf);
#line 181
        break;
      }
#line 182
      return (-1);
    }
#line 185
    if (fs.f_type != 391) {
#line 186
      while (1) {
#line 186
        ((*log_crit))(ap->logopt, "%s: attempt to remove directory from a non-autofs filesystem!",
                      "rmdir_path");
#line 186
        break;
      }
#line 188
      while (1) {
#line 188
        ((*log_crit))(ap->logopt, "%s: requestor dev == %llu, \"%s\" owner dev == %llu",
                      "rmdir_path", dev, buf, st.st_dev);
#line 188
        break;
      }
#line 191
      return (-1);
    }
#line 199
    tmp___5 = rmdir((char const   *)buf);
#line 199
    if (tmp___5 == -1) {
#line 200
      if (first) {
#line 200
        tmp___4 = __errno_location();
#line 200
        if ((*tmp___4) == 20) {
#line 205
          if ((st.st_mode & 61440U) == 40960U) {
#line 206
            tmp___3 = unlink((char const   *)buf);
#line 206
            if (tmp___3 == -1) {
#line 207
              return (-1);
            }
          } else {
#line 209
            while (1) {
#line 209
              ((*log_crit))(ap->logopt, "%s: file \"%s\" is neither a directory nor a symbolic link. mode %d",
                            "rmdir_path", buf, st.st_mode);
#line 209
              break;
            }
#line 213
            return (-1);
          }
        }
      }
#line 221
      return (-1);
    }
#line 224
    first = 0;
#line 162
    cp = strrchr((char const   *)buf, '/');
#line 162
    if ((unsigned int )cp != (unsigned int )((void *)0)) {
#line 162
      if (! ((unsigned int )cp != (unsigned int )buf)) {
#line 162
        break;
      }
    } else {
#line 162
      break;
    }
  }
#line 227
  return (0);
}
}
#line 233 "automount.c"
static int walk_tree(char const   *base , int (*fn)(char const   *file , struct stat  const  *st ,
                                                    int  , void * ) , int incl , void *arg ) 
{ char buf[4097] ;
  struct stat st ;
  struct dirent **de ;
  int n ;
  int ret ;
  int size ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 240
  tmp___21 = lstat__extinline(base, & st);
#line 240
  if (tmp___21 != -1) {
#line 240
    tmp___22 = ((*fn))(base, (struct stat  const  *)(& st), 0, arg);
#line 240
    if (tmp___22) {
#line 241
      if ((st.st_mode & 61440U) == 16384U) {
#line 245
        n = scandir((char const   * __restrict  )base, (struct dirent *** __restrict  )(& de),
                    (int (*)(struct dirent  const  * ))0, & alphasort);
#line 246
        if (n < 0) {
#line 247
          return (-1);
        }
#line 249
        while (1) {
#line 249
          tmp___20 = n;
#line 249
          n --;
#line 249
          if (! tmp___20) {
#line 249
            break;
          }
#line 252
          if (0) {
#line 252
            __s1_len = strlen((char const   *)(((*(de + n)))->d_name));
#line 252
            __s2_len = strlen(".");
#line 252
            if (! ((unsigned int )((void const   *)(((*(de + n)))->d_name + 1)) - (unsigned int )((void const   *)(((*(de + n)))->d_name)) == 1U)) {
              goto _L___0;
            } else {
#line 252
              if (__s1_len >= 4U) {
                _L___0: /* CIL Label */ 
#line 252
                if (! ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") == 1U)) {
#line 252
                  tmp___8 = 1;
                } else {
#line 252
                  if (__s2_len >= 4U) {
#line 252
                    tmp___8 = 1;
                  } else {
#line 252
                    tmp___8 = 0;
                  }
                }
              } else {
#line 252
                tmp___8 = 0;
              }
            }
#line 252
            if (tmp___8) {
#line 252
              tmp___4 = __builtin_strcmp((char const   *)(((*(de + n)))->d_name),
                                         ".");
            } else {
#line 252
              tmp___7 = __builtin_strcmp((char const   *)(((*(de + n)))->d_name),
                                         ".");
#line 252
              tmp___4 = tmp___7;
            }
          } else {
#line 252
            tmp___7 = __builtin_strcmp((char const   *)(((*(de + n)))->d_name), ".");
#line 252
            tmp___4 = tmp___7;
          }
#line 253
          if (tmp___4 == 0) {
#line 254
            free((void *)(*(de + n)));
#line 255
            continue;
          } else {
#line 253
            if (0) {
#line 253
              __s1_len___0 = strlen((char const   *)(((*(de + n)))->d_name));
#line 253
              __s2_len___0 = strlen("..");
#line 253
              if (! ((unsigned int )((void const   *)(((*(de + n)))->d_name + 1)) - (unsigned int )((void const   *)(((*(de + n)))->d_name)) == 1U)) {
                goto _L___2;
              } else {
#line 253
                if (__s1_len___0 >= 4U) {
                  _L___2: /* CIL Label */ 
#line 253
                  if (! ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") == 1U)) {
#line 253
                    tmp___18 = 1;
                  } else {
#line 253
                    if (__s2_len___0 >= 4U) {
#line 253
                      tmp___18 = 1;
                    } else {
#line 253
                      tmp___18 = 0;
                    }
                  }
                } else {
#line 253
                  tmp___18 = 0;
                }
              }
#line 253
              if (tmp___18) {
#line 253
                tmp___14 = __builtin_strcmp((char const   *)(((*(de + n)))->d_name),
                                            "..");
              } else {
#line 253
                tmp___17 = __builtin_strcmp((char const   *)(((*(de + n)))->d_name),
                                            "..");
#line 253
                tmp___14 = tmp___17;
              }
            } else {
#line 253
              tmp___17 = __builtin_strcmp((char const   *)(((*(de + n)))->d_name),
                                          "..");
#line 253
              tmp___14 = tmp___17;
            }
#line 253
            if (tmp___14 == 0) {
#line 254
              free((void *)(*(de + n)));
#line 255
              continue;
            }
          }
#line 258
          size = (int )sizeof(buf);
#line 259
          ret = cat_path(buf, (unsigned int )size, base, (char const   *)(((*(de + n)))->d_name));
#line 260
          if (! ret) {
#line 261
            while (1) {
#line 262
              free((void *)(*(de + n)));
#line 261
              tmp___19 = n;
#line 261
              n --;
#line 261
              if (! tmp___19) {
#line 261
                break;
              }
            }
#line 264
            free((void *)de);
#line 265
            return (-1);
          }
#line 268
          walk_tree((char const   *)(buf), fn, 1, arg);
#line 269
          free((void *)(*(de + n)));
        }
#line 271
        free((void *)de);
      }
#line 273
      if (incl) {
#line 274
        ((*fn))(base, (struct stat  const  *)(& st), 1, arg);
      }
    }
  }
#line 276
  return (0);
}
}
#line 279 "automount.c"
static int rm_unwanted_fn(char const   *file , struct stat  const  *st , int when ,
                          void *arg ) 
{ dev_t dev ;
  char buf[128] ;
  struct stat newst ;
  int tmp ;
  char *estr ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 281
  dev = (*((dev_t *)arg));
#line 285
  if (when == 0) {
#line 286
    if (st->st_dev != (__dev_t const   )dev) {
#line 287
      return (0);
    }
#line 288
    return (1);
  }
#line 291
  tmp = lstat__extinline(file, & newst);
#line 291
  if (tmp) {
#line 292
    while (1) {
#line 292
      ((*log_crit))(3U, "%s: unable to stat file, possible race condition", "rm_unwanted_fn");
#line 292
      break;
    }
#line 294
    return (0);
  }
#line 297
  if (newst.st_dev != dev) {
#line 298
    while (1) {
#line 298
      ((*log_crit))(3U, "%s: file %s has the wrong device, possible race condition",
                    "rm_unwanted_fn", file);
#line 298
      break;
    }
#line 301
    return (0);
  }
#line 304
  if ((newst.st_mode & 61440U) == 16384U) {
#line 305
    while (1) {
#line 305
      ((*log_debug))(3U, "%s: removing directory %s", "rm_unwanted_fn", file);
#line 305
      break;
    }
#line 306
    tmp___2 = rmdir(file);
#line 306
    if (tmp___2) {
#line 307
      tmp___0 = __errno_location();
#line 307
      tmp___1 = strerror_r((*tmp___0), buf, 128U);
#line 307
      estr = tmp___1;
#line 308
      while (1) {
#line 308
        ((*log_warn))(3U, "%s: unable to remove directory %s: %s", "rm_unwanted_fn",
                      file, estr);
#line 308
        break;
      }
#line 310
      return (0);
    }
  } else {
#line 312
    if ((newst.st_mode & 61440U) == 32768U) {
#line 313
      while (1) {
#line 313
        ((*log_crit))(3U, "%s: attempting to remove files from a mounted directory. file %s",
                      "rm_unwanted_fn", file);
#line 313
        break;
      }
#line 316
      return (0);
    } else {
#line 317
      if ((newst.st_mode & 61440U) == 40960U) {
#line 318
        while (1) {
#line 318
          ((*log_debug))(3U, "%s: removing symlink %s", "rm_unwanted_fn", file);
#line 318
          break;
        }
#line 319
        unlink(file);
      }
    }
  }
#line 321
  return (1);
}
}
#line 324 "automount.c"
void rm_unwanted(char const   *path , int incl , dev_t dev ) 
{ 

  {
#line 326
  walk_tree(path, & rm_unwanted_fn, incl, (void *)(& dev));
#line 327
  return;
}
}
#line 334 "automount.c"
static int counter_fn(char const   *file , struct stat  const  *st , int when , void *arg ) 
{ struct counter_args *counter ;

  {
#line 336
  counter = (struct counter_args *)arg;
#line 338
  if ((st->st_mode & 61440U) == 40960U) {
#line 340
    counter->count ++;
#line 341
    return (0);
  } else {
#line 338
    if ((st->st_mode & 61440U) == 16384U) {
#line 338
      if (st->st_dev != (__dev_t const   )counter->dev) {
#line 340
        counter->count ++;
#line 341
        return (0);
      }
    }
  }
#line 344
  return (1);
}
}
#line 348 "automount.c"
int count_mounts(char const   *path , dev_t dev ) 
{ struct counter_args counter ;
  int tmp ;

  {
#line 352
  counter.count = 0U;
#line 353
  counter.dev = dev;
#line 355
  tmp = walk_tree(path, & counter_fn, 0, (void *)(& counter));
#line 355
  if (tmp == -1) {
#line 356
    return (-1);
  }
#line 358
  return ((int )counter.count);
}
}
#line 361 "automount.c"
static void check_rm_dirs(struct autofs_point *ap , char const   *path , int incl ) 
{ 

  {
#line 363
  if (! ap->ghost) {
#line 367
    rm_unwanted(path, incl, ap->dev);
  } else {
#line 363
    if ((int )ap->state == 5) {
#line 367
      rm_unwanted(path, incl, ap->dev);
    } else {
#line 363
      if ((int )ap->state == 6) {
#line 367
        rm_unwanted(path, incl, ap->dev);
      } else {
#line 363
        if ((int )ap->state == 7) {
#line 367
          rm_unwanted(path, incl, ap->dev);
        } else {
#line 368
          if (ap->ghost) {
#line 368
            if (ap->type == 2U) {
#line 369
              rm_unwanted(path, 0, ap->dev);
            }
          }
        }
      }
    }
  }
#line 370
  return;
}
}
#line 373 "automount.c"
static void update_map_cache(struct autofs_point *ap , char const   *path ) 
{ struct map_source *map ;
  struct mapent_cache *mc ;
  char const   *key ;
  char *tmp ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___0 ;
  long tmp___1 ;
  struct mapent *me ;
  int tmp___2 ;

  {
#line 379
  if (ap->type == 2U) {
#line 380
    tmp = strrchr(path, '/');
#line 380
    key = (char const   *)(tmp + 1);
  } else {
#line 382
    key = path;
  }
#line 384
  while (1) {
#line 384
    __cancel_routine = & master_source_lock_cleanup;
#line 384
    __cancel_arg = (void *)ap->entry;
#line 384
    tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
#line 384
    not_first_call = tmp___0;
#line 384
    tmp___1 = __builtin_expect((long )not_first_call, 0L);
#line 384
    if (tmp___1) {
#line 384
      ((*__cancel_routine))(__cancel_arg);
#line 384
      __pthread_unwind_next(& __cancel_buf);
    }
#line 384
    __pthread_register_cancel(& __cancel_buf);
#line 384
    while (1) {
#line 385
      master_source_readlock(ap->entry);
#line 386
      map = (ap->entry)->maps;
#line 387
      while (map) {
#line 388
        me = (struct mapent *)((void *)0);
#line 391
        if ((ap->entry)->age <= map->age) {
#line 392
          map = map->next;
#line 393
          continue;
        }
#line 396
        mc = map->mc;
#line 398
        tmp___2 = cache_try_writelock(mc);
#line 398
        if (tmp___2) {
#line 399
          me = cache_lookup_distinct(mc, key);
#line 400
          if (me) {
#line 400
            if (me->ioctlfd == -1) {
#line 401
              cache_delete(mc, key);
            }
          }
#line 402
          cache_unlock(mc);
        }
#line 405
        map = map->next;
      }
#line 384
      break;
    }
#line 407
    __pthread_unregister_cancel(& __cancel_buf);
#line 407
    ((*__cancel_routine))(__cancel_arg);
#line 384
    break;
  }
#line 409
  return;
}
}
#line 412 "automount.c"
static int umount_subtree_mounts(struct autofs_point *ap , char const   *path , unsigned int is_autofs_fs ) 
{ struct mapent_cache *mc ;
  struct mapent *me ;
  unsigned int is_mm_root ;
  int left ;
  char *ind_key ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp ;
  long tmp___0 ;
  char *root ;
  char *base ;
  size_t ap_len ;
  int cur_state ;
  size_t tmp___1 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 419
  me = lookup_source_mapent(ap, path, 8192U);
#line 420
  if (! me) {
#line 423
    ind_key = strrchr(path, '/');
#line 424
    if (ind_key) {
#line 425
      ind_key ++;
    }
#line 427
    me = lookup_source_mapent(ap, (char const   *)ind_key, 4096U);
#line 428
    if (! me) {
#line 429
      return (0);
    }
  }
#line 432
  mc = me->mc;
#line 433
  is_mm_root = (unsigned int )((unsigned int )me->multi == (unsigned int )me);
#line 435
  left = 0;
#line 437
  while (1) {
#line 437
    __cancel_routine = & cache_lock_cleanup;
#line 437
    __cancel_arg = (void *)mc;
#line 437
    tmp = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf), 0);
#line 437
    not_first_call = tmp;
#line 437
    tmp___0 = __builtin_expect((long )not_first_call, 0L);
#line 437
    if (tmp___0) {
#line 437
      ((*__cancel_routine))(__cancel_arg);
#line 437
      __pthread_unwind_next(& __cancel_buf);
    }
#line 437
    __pthread_register_cancel(& __cancel_buf);
#line 437
    while (1) {
#line 439
      if (me->multi) {
#line 444
        ap_len = strlen((char const   *)ap->path);
#line 446
        tmp___3 = __builtin_strchr((me->multi)->key, (char )'/');
#line 446
        if (tmp___3) {
#line 453
          root = (me->multi)->key;
        } else {
#line 448
          tmp___1 = strlen((char const   *)(me->multi)->key);
#line 448
          root = (char *)__builtin_alloca((ap_len + tmp___1) + 2U);
#line 449
          strcpy((char * __restrict  )root, (char const   * __restrict  )ap->path);
#line 450
          strcat((char * __restrict  )root, (char const   * __restrict  )"/");
#line 451
          strcat((char * __restrict  )root, (char const   * __restrict  )(me->multi)->key);
        }
#line 455
        if (is_mm_root) {
#line 456
          base = (char *)((void *)0);
        } else {
#line 458
          tmp___4 = strlen((char const   *)root);
#line 458
          base = me->key + tmp___4;
        }
#line 460
        pthread_setcancelstate(1, & cur_state);
#line 462
        cache_multi_lock(me->parent);
#line 463
        tmp___5 = umount_multi_triggers(ap, root, me, (char const   *)base);
#line 463
        if (tmp___5) {
#line 464
          while (1) {
#line 464
            ((*log_warn))(ap->logopt, "%s: could not umount some offsets under %s",
                          "umount_subtree_mounts", path);
#line 464
            break;
          }
#line 466
          left ++;
        }
#line 468
        cache_multi_unlock(me->parent);
#line 469
        pthread_setcancelstate(cur_state, (int *)((void *)0));
      }
#line 437
      break;
    }
#line 472
    __pthread_unregister_cancel(& __cancel_buf);
#line 472
    ((*__cancel_routine))(__cancel_arg);
#line 437
    break;
  }
#line 474
  if (left) {
#line 475
    return (left);
  } else {
#line 474
    if (is_autofs_fs) {
#line 475
      return (left);
    }
  }
#line 481
  if (! is_mm_root) {
#line 481
    tmp___7 = is_mounted("/etc/mtab", path, 2U);
#line 481
    if (tmp___7) {
#line 482
      while (1) {
#line 482
        ((*log_info))(0U, "unmounting dir = %s", path);
#line 482
        break;
      }
#line 483
      tmp___6 = umount_ent(ap, path);
#line 483
      if (tmp___6) {
#line 484
        while (1) {
#line 484
          ((*log_warn))(ap->logopt, "%s: could not umount dir %s", "umount_subtree_mounts",
                        path);
#line 484
          break;
        }
#line 485
        left ++;
      }
    }
  }
#line 489
  return (left);
}
}
#line 494 "automount.c"
int umount_multi(struct autofs_point *ap , char const   *path , int incl ) 
{ struct mapent_cache *nc ;
  struct statfs fs ;
  int is_autofs_fs ;
  int ret ;
  int left ;
  struct mapent *tmp ;
  int tmp___0 ;

  {
#line 501
  while (1) {
#line 501
    ((*log_debug))(ap->logopt, "%s: path %s incl %d", "umount_multi", path, incl);
#line 501
    break;
  }
#line 503
  nc = ((ap->entry)->master)->nc;
#line 504
  cache_readlock(nc);
#line 505
  tmp = cache_lookup_distinct(nc, path);
#line 505
  if (tmp) {
#line 506
    cache_unlock(nc);
#line 507
    return (0);
  }
#line 509
  cache_unlock(nc);
#line 511
  ret = statfs(path, & fs);
#line 512
  if (ret == -1) {
#line 513
    while (1) {
#line 513
      ((*log_error))(ap->logopt, "%s: could not stat fs of %s", "umount_multi", path);
#line 513
      break;
    }
#line 514
    return (1);
  }
#line 517
  if (fs.f_type == 391) {
#line 517
    is_autofs_fs = 1;
  } else {
#line 517
    is_autofs_fs = 0;
  }
#line 519
  left = 0;
#line 528
  tmp___0 = umount_subtree_mounts(ap, path, (unsigned int )is_autofs_fs);
#line 528
  left += tmp___0;
#line 531
  if (left == 0) {
#line 531
    if ((int )ap->state != 4) {
#line 532
      update_map_cache(ap, path);
#line 533
      check_rm_dirs(ap, path, incl);
    }
  }
#line 536
  return (left);
}
}
#line 539 "automount.c"
static int umount_all(struct autofs_point *ap , int force ) 
{ int left ;

  {
#line 543
  left = umount_multi(ap, (char const   *)ap->path, 0);
#line 544
  if (force) {
#line 544
    if (left) {
#line 545
      while (1) {
#line 545
        ((*log_warn))(ap->logopt, "%s: could not unmount %d dirs under %s", "umount_all",
                      left, ap->path);
#line 545
        break;
      }
    }
  }
#line 548
  return (left);
}
}
#line 551 "automount.c"
int umount_autofs(struct autofs_point *ap , int force ) 
{ int ret ;
  int tmp ;

  {
#line 553
  ret = 0;
#line 555
  if ((int )ap->state == 0) {
#line 556
    return (-1);
  }
#line 563
  lookup_close_lookup(ap);
#line 565
  if (ap->type == 2U) {
#line 566
    tmp = umount_all(ap, force);
#line 566
    if (tmp) {
#line 566
      if (! force) {
#line 567
        return (-1);
      }
    }
#line 568
    ret = umount_autofs_indirect(ap);
  } else {
#line 570
    ret = umount_autofs_direct(ap);
  }
#line 572
  return (ret);
}
}
#line 575 "automount.c"
int send_ready(int ioctlfd , unsigned int wait_queue_token ) 
{ char buf[128] ;
  char *estr ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 579
  if (wait_queue_token == 0U) {
#line 580
    return (0);
  }
#line 582
  while (1) {
#line 582
    ((*log_debug))(0U, "%s: token = %d", "send_ready", wait_queue_token);
#line 582
    break;
  }
#line 584
  tmp___1 = ioctl(ioctlfd, 37728UL, wait_queue_token);
#line 584
  if (tmp___1 < 0) {
#line 585
    tmp = __errno_location();
#line 585
    tmp___0 = strerror_r((*tmp), buf, 128U);
#line 585
    estr = tmp___0;
#line 586
    while (1) {
#line 586
      ((*log_error))(3U, "%s: AUTOFS_IOC_READY: error %s", "send_ready", estr);
#line 586
      break;
    }
#line 587
    return (1);
  }
#line 589
  return (0);
}
}
#line 592 "automount.c"
int send_fail(int ioctlfd , unsigned int wait_queue_token ) 
{ char buf[128] ;
  char *estr ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 596
  if (wait_queue_token == 0U) {
#line 597
    return (0);
  }
#line 599
  while (1) {
#line 599
    ((*log_debug))(0U, "%s: token = %d", "send_fail", wait_queue_token);
#line 599
    break;
  }
#line 601
  tmp___1 = ioctl(ioctlfd, 37729UL, wait_queue_token);
#line 601
  if (tmp___1 < 0) {
#line 602
    tmp = __errno_location();
#line 602
    tmp___0 = strerror_r((*tmp), buf, 128U);
#line 602
    estr = tmp___0;
#line 603
    while (1) {
#line 603
      ((*log_error))(3U, "%s: AUTOFS_IOC_FAIL: error %s", "send_fail", estr);
#line 603
      break;
    }
#line 604
    return (1);
  }
#line 606
  return (0);
}
}
#line 609 "automount.c"
static size_t get_kpkt_len(void) 
{ size_t pkt_len ;
  struct utsname un ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;

  {
#line 611
  pkt_len = sizeof(struct autofs_v5_packet );
#line 614
  uname(& un);
#line 616
  if (pkt_len % 8U) {
#line 617
    if (0) {
#line 617
      __s1_len = strlen((char const   *)(un.machine));
#line 617
      __s2_len = strlen("alpha");
#line 617
      if (! ((unsigned int )((void const   *)(un.machine + 1)) - (unsigned int )((void const   *)(un.machine)) == 1U)) {
        goto _L___0;
      } else {
#line 617
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 617
          if (! ((unsigned int )((void const   *)("alpha" + 1)) - (unsigned int )((void const   *)"alpha") == 1U)) {
#line 617
            tmp___8 = 1;
          } else {
#line 617
            if (__s2_len >= 4U) {
#line 617
              tmp___8 = 1;
            } else {
#line 617
              tmp___8 = 0;
            }
          }
        } else {
#line 617
          tmp___8 = 0;
        }
      }
#line 617
      if (tmp___8) {
#line 617
        tmp___4 = __builtin_strcmp((char const   *)(un.machine), "alpha");
      } else {
#line 617
        tmp___7 = __builtin_strcmp((char const   *)(un.machine), "alpha");
#line 617
        tmp___4 = tmp___7;
      }
    } else {
#line 617
      tmp___7 = __builtin_strcmp((char const   *)(un.machine), "alpha");
#line 617
      tmp___4 = tmp___7;
    }
#line 620
    if (tmp___4 == 0) {
#line 621
      pkt_len += 4U;
    } else {
#line 618
      if (0) {
#line 618
        __s1_len___0 = strlen((char const   *)(un.machine));
#line 618
        __s2_len___0 = strlen("ia64");
#line 618
        if (! ((unsigned int )((void const   *)(un.machine + 1)) - (unsigned int )((void const   *)(un.machine)) == 1U)) {
          goto _L___2;
        } else {
#line 618
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 618
            if (! ((unsigned int )((void const   *)("ia64" + 1)) - (unsigned int )((void const   *)"ia64") == 1U)) {
#line 618
              tmp___18 = 1;
            } else {
#line 618
              if (__s2_len___0 >= 4U) {
#line 618
                tmp___18 = 1;
              } else {
#line 618
                tmp___18 = 0;
              }
            }
          } else {
#line 618
            tmp___18 = 0;
          }
        }
#line 618
        if (tmp___18) {
#line 618
          tmp___14 = __builtin_strcmp((char const   *)(un.machine), "ia64");
        } else {
#line 618
          tmp___17 = __builtin_strcmp((char const   *)(un.machine), "ia64");
#line 618
          tmp___14 = tmp___17;
        }
      } else {
#line 618
        tmp___17 = __builtin_strcmp((char const   *)(un.machine), "ia64");
#line 618
        tmp___14 = tmp___17;
      }
#line 620
      if (tmp___14 == 0) {
#line 621
        pkt_len += 4U;
      } else {
#line 619
        if (0) {
#line 619
          __s1_len___1 = strlen((char const   *)(un.machine));
#line 619
          __s2_len___1 = strlen("x86_64");
#line 619
          if (! ((unsigned int )((void const   *)(un.machine + 1)) - (unsigned int )((void const   *)(un.machine)) == 1U)) {
            goto _L___4;
          } else {
#line 619
            if (__s1_len___1 >= 4U) {
              _L___4: /* CIL Label */ 
#line 619
              if (! ((unsigned int )((void const   *)("x86_64" + 1)) - (unsigned int )((void const   *)"x86_64") == 1U)) {
#line 619
                tmp___28 = 1;
              } else {
#line 619
                if (__s2_len___1 >= 4U) {
#line 619
                  tmp___28 = 1;
                } else {
#line 619
                  tmp___28 = 0;
                }
              }
            } else {
#line 619
              tmp___28 = 0;
            }
          }
#line 619
          if (tmp___28) {
#line 619
            tmp___24 = __builtin_strcmp((char const   *)(un.machine), "x86_64");
          } else {
#line 619
            tmp___27 = __builtin_strcmp((char const   *)(un.machine), "x86_64");
#line 619
            tmp___24 = tmp___27;
          }
        } else {
#line 619
          tmp___27 = __builtin_strcmp((char const   *)(un.machine), "x86_64");
#line 619
          tmp___24 = tmp___27;
        }
#line 620
        if (tmp___24 == 0) {
#line 621
          pkt_len += 4U;
        } else {
#line 620
          if (0) {
#line 620
            __s1_len___2 = strlen((char const   *)(un.machine));
#line 620
            __s2_len___2 = strlen("ppc64");
#line 620
            if (! ((unsigned int )((void const   *)(un.machine + 1)) - (unsigned int )((void const   *)(un.machine)) == 1U)) {
              goto _L___6;
            } else {
#line 620
              if (__s1_len___2 >= 4U) {
                _L___6: /* CIL Label */ 
#line 620
                if (! ((unsigned int )((void const   *)("ppc64" + 1)) - (unsigned int )((void const   *)"ppc64") == 1U)) {
#line 620
                  tmp___38 = 1;
                } else {
#line 620
                  if (__s2_len___2 >= 4U) {
#line 620
                    tmp___38 = 1;
                  } else {
#line 620
                    tmp___38 = 0;
                  }
                }
              } else {
#line 620
                tmp___38 = 0;
              }
            }
#line 620
            if (tmp___38) {
#line 620
              tmp___34 = __builtin_strcmp((char const   *)(un.machine), "ppc64");
            } else {
#line 620
              tmp___37 = __builtin_strcmp((char const   *)(un.machine), "ppc64");
#line 620
              tmp___34 = tmp___37;
            }
          } else {
#line 620
            tmp___37 = __builtin_strcmp((char const   *)(un.machine), "ppc64");
#line 620
            tmp___34 = tmp___37;
          }
#line 620
          if (tmp___34 == 0) {
#line 621
            pkt_len += 4U;
          }
        }
      }
    }
  }
#line 625
  return (pkt_len);
}
}
#line 628 "automount.c"
static int fullread(int fd , void *ptr , size_t len ) 
{ char *buf ;
  ssize_t r ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
#line 630
  buf = (char *)ptr;
#line 632
  while (len > 0U) {
#line 633
    tmp = read(fd, (void *)buf, len);
#line 633
    r = tmp;
#line 635
    if (r == -1) {
#line 636
      tmp___0 = __errno_location();
#line 636
      if ((*tmp___0) == 4) {
#line 637
        continue;
      }
#line 638
      break;
    }
#line 641
    buf += r;
#line 642
    len -= (size_t )r;
  }
#line 645
  return ((int )len);
}
}
#line 648 "automount.c"
static int get_pkt(struct autofs_point *ap , union autofs_packet_union *pkt ) 
{ struct pollfd fds[2] ;
  char buf[128] ;
  char *estr ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  enum states next_state ;
  enum states post_state ;
  size_t read_size ;
  int state_pipe ;
  int _st_lock ;
  int tmp___2 ;
  int _st_unlock ;
  int tmp___3 ;
  int tmp___4 ;
  int _st_unlock___0 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 653
  fds[0].fd = ap->pipefd;
#line 654
  fds[0].events = (short)1;
#line 655
  fds[1].fd = ap->state_pipe[0];
#line 656
  fds[1].events = (short)1;
#line 658
  while (1) {
#line 659
    tmp___1 = poll(fds, 2UL, -1);
#line 659
    if (tmp___1 == -1) {
#line 661
      tmp = __errno_location();
#line 661
      if ((*tmp) == 4) {
        goto __Cont;
      }
#line 663
      tmp___0 = __errno_location();
#line 663
      estr = strerror_r((*tmp___0), buf, 128U);
#line 664
      while (1) {
#line 664
        ((*log_error))(ap->logopt, "%s: poll failed: %s", "get_pkt", estr);
#line 664
        break;
      }
#line 665
      return (-1);
    }
#line 668
    if ((int )fds[1].revents & 1) {
#line 670
      read_size = sizeof(next_state);
#line 673
      post_state = -1;
#line 673
      next_state = post_state;
#line 675
      while (1) {
#line 675
        tmp___2 = pthread_mutex_lock(& ap->state_mutex);
#line 675
        _st_lock = tmp___2;
#line 675
        if (_st_lock) {
#line 675
          while (1) {
#line 675
            if (_st_lock == 35) {
#line 675
              ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                            "get_pkt", 675, "automount.c");
#line 675
              dump_core();
            }
#line 675
            ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_lock,
                          675, "automount.c");
#line 675
            abort();
#line 675
            break;
          }
        }
#line 675
        break;
      }
#line 677
      state_pipe = ap->state_pipe[0];
#line 679
      tmp___4 = fullread(state_pipe, (void *)(& next_state), read_size);
#line 679
      if (tmp___4) {
#line 680
        while (1) {
#line 680
          tmp___3 = pthread_mutex_unlock(& ap->state_mutex);
#line 680
          _st_unlock = tmp___3;
#line 680
          if (_st_unlock) {
#line 680
            while (1) {
#line 680
              if (_st_unlock == 35) {
#line 680
                ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                              "get_pkt", 680, "automount.c");
#line 680
                dump_core();
              }
#line 680
              ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_unlock,
                            680, "automount.c");
#line 680
              abort();
#line 680
              break;
            }
          }
#line 680
          break;
        }
        goto __Cont;
      }
#line 684
      if ((int )next_state != -1) {
#line 684
        if ((int )next_state != (int )ap->state) {
#line 685
          if ((int )next_state != 7) {
#line 686
            post_state = next_state;
          } else {
#line 688
            ap->state = 7;
          }
        }
      }
#line 691
      while (1) {
#line 691
        tmp___5 = pthread_mutex_unlock(& ap->state_mutex);
#line 691
        _st_unlock___0 = tmp___5;
#line 691
        if (_st_unlock___0) {
#line 691
          while (1) {
#line 691
            if (_st_unlock___0 == 35) {
#line 691
              ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                            "get_pkt", 691, "automount.c");
#line 691
              dump_core();
            }
#line 691
            ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_unlock___0,
                          691, "automount.c");
#line 691
            abort();
#line 691
            break;
          }
        }
#line 691
        break;
      }
#line 693
      if ((int )post_state != -1) {
#line 694
        if ((int )post_state == 5) {
#line 696
          alarm_delete(ap);
#line 697
          st_remove_tasks(ap);
        } else {
#line 694
          if ((int )post_state == 6) {
#line 696
            alarm_delete(ap);
#line 697
            st_remove_tasks(ap);
          }
        }
#line 699
        st_add_task(ap, post_state);
      }
#line 702
      if ((int )next_state == 7) {
#line 703
        return (-1);
      }
    }
#line 706
    if ((int )fds[0].revents & 1) {
#line 707
      tmp___6 = fullread(ap->pipefd, (void *)pkt, kpkt_len);
#line 707
      return (tmp___6);
    }
    __Cont: /* CIL Label */ ;
  }
}
}
#line 711 "automount.c"
int do_expire(struct autofs_point *ap , char const   *name , int namelen ) 
{ char buf[4097] ;
  int len ;
  int ret ;

  {
#line 716
  if ((int const   )(*name) != 47) {
#line 717
    len = ncat_path(buf, sizeof(buf), (char const   *)ap->path, name, (unsigned int )namelen);
  } else {
#line 719
    len = snprintf((char * __restrict  )(buf), 4096U, (char const   * __restrict  )"%s",
                   name);
#line 720
    if (len > 4096) {
#line 721
      len = 0;
    }
  }
#line 724
  if (! len) {
#line 725
    while (1) {
#line 725
      ((*log_crit))(ap->logopt, "%s: path to long for buffer", "do_expire");
#line 725
      break;
    }
#line 726
    return (1);
  }
#line 729
  while (1) {
#line 729
    ((*log_info))(0U, "expiring path %s", buf);
#line 729
    break;
  }
#line 731
  ret = umount_multi(ap, (char const   *)(buf), 1);
#line 732
  if (ret == 0) {
#line 733
    while (1) {
#line 733
      ((*log_info))(0U, "expired %s", buf);
#line 733
      break;
    }
  } else {
#line 735
    while (1) {
#line 735
      ((*log_warn))(ap->logopt, "%s: couldn\'t complete expire of %s", "do_expire",
                    buf);
#line 735
      break;
    }
  }
#line 737
  return (ret);
}
}
#line 740 "automount.c"
static int mount_autofs(struct autofs_point *ap ) 
{ int status ;

  {
#line 742
  status = 0;
#line 744
  if (ap->type == 4U) {
#line 745
    status = mount_autofs_direct(ap);
  } else {
#line 747
    status = mount_autofs_indirect(ap);
  }
#line 749
  if (status < 0) {
#line 750
    return (-1);
  }
#line 752
  ap->state = 1;
#line 754
  return (0);
}
}
#line 757 "automount.c"
static int handle_packet(struct autofs_point *ap ) 
{ union autofs_packet_union pkt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 761
  tmp = get_pkt(ap, & pkt);
#line 761
  if (tmp) {
#line 762
    return (-1);
  }
#line 764
  while (1) {
#line 764
    ((*log_debug))(ap->logopt, "%s: type = %d", "handle_packet", pkt.hdr.type);
#line 764
    break;
  }
#line 766
  switch (pkt.hdr.type) {
  case 3: 
#line 768
  tmp___0 = handle_packet_missing_indirect(ap, & pkt.v5_packet);
#line 768
  return (tmp___0);
  case 5: 
#line 771
  tmp___1 = handle_packet_missing_direct(ap, & pkt.v5_packet);
#line 771
  return (tmp___1);
  case 4: 
#line 774
  tmp___2 = handle_packet_expire_indirect(ap, & pkt.v5_packet);
#line 774
  return (tmp___2);
  case 6: 
#line 777
  tmp___3 = handle_packet_expire_direct(ap, & pkt.v5_packet);
#line 777
  return (tmp___3);
  }
#line 779
  while (1) {
#line 779
    ((*log_error))(ap->logopt, "%s: unknown packet type %d", "handle_packet", pkt.hdr.type);
#line 779
    break;
  }
#line 780
  return (-1);
}
}
#line 783 "automount.c"
static void become_daemon(unsigned int foreground ) 
{ FILE *pidfp ;
  char buf[128] ;
  unsigned int to_stderr ;
  pid_t pid ;
  int tmp ;
  int tmp___0 ;
  int r ;
  char *estr ;
  int *tmp___1 ;
  char *tmp___2 ;
  __pid_t tmp___3 ;
  __pid_t tmp___4 ;
  char *estr___0 ;
  int *tmp___5 ;
  char *tmp___6 ;

  {
#line 787
  to_stderr = 0U;
#line 791
  tmp = chdir("/");
#line 791
  if (tmp) {
#line 792
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: failed change working directory.\n",
            program);
#line 794
    exit(0);
  }
#line 797
  tmp___0 = pipe(start_pipefd);
#line 797
  if (tmp___0 < 0) {
#line 798
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: failed to create start_pipefd.\n",
            program);
#line 800
    exit(0);
  }
#line 804
  if (! foreground) {
#line 805
    pid = fork();
#line 806
    if (pid > 0) {
#line 808
      close(start_pipefd[1]);
#line 809
      r = read(start_pipefd[0], (void *)pst_stat, sizeof(pst_stat));
#line 810
      if (r < 0) {
#line 811
        exit(1);
      }
#line 812
      exit((*pst_stat));
    } else {
#line 813
      if (pid < 0) {
#line 814
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Could not detach process\n",
                program);
#line 816
        exit(1);
      }
    }
#line 818
    close(start_pipefd[0]);
#line 824
    tmp___3 = setsid();
#line 824
    if (tmp___3 == -1) {
#line 825
      tmp___1 = __errno_location();
#line 825
      tmp___2 = strerror_r((*tmp___1), buf, 128U);
#line 825
      estr = tmp___2;
#line 826
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"setsid: %s",
              estr);
#line 827
      exit(1);
    }
  }
#line 832
  if (to_stderr) {
#line 833
    log_to_stderr();
  } else {
#line 835
    log_to_syslog();
  }
#line 838
  if (pid_file) {
#line 839
    pidfp = fopen((char const   * __restrict  )pid_file, (char const   * __restrict  )"wt");
#line 839
    if (pidfp) {
#line 840
      tmp___4 = getpid();
#line 840
      fprintf((FILE * __restrict  )pidfp, (char const   * __restrict  )"%lu\n", (unsigned long )tmp___4);
#line 841
      fclose(pidfp);
    } else {
#line 843
      tmp___5 = __errno_location();
#line 843
      tmp___6 = strerror_r((*tmp___5), buf, 128U);
#line 843
      estr___0 = tmp___6;
#line 844
      while (1) {
#line 844
        ((*log_warn))(3U, "%s: failed to write pid file %s: %s", "become_daemon",
                      pid_file, estr___0);
#line 844
        break;
      }
#line 847
      pid_file = (char *)((void *)0);
    }
  }
#line 850
  return;
}
}
#line 852 "automount.c"
static unsigned long getnumopt(char *str , char option ) 
{ unsigned long val ;
  char *end ;

  {
#line 857
  val = strtoul__extinline((char const   * __restrict  )str, (char ** __restrict  )(& end),
                           0);
#line 858
  if (! (*str)) {
#line 859
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: option -%c requires a numeric argument, got %s\n",
            program, option, str);
#line 862
    exit(1);
  } else {
#line 858
    if ((*end)) {
#line 859
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: option -%c requires a numeric argument, got %s\n",
              program, option, str);
#line 862
      exit(1);
    }
  }
#line 864
  return (val);
}
}
#line 867 "automount.c"
static void do_master_cleanup_unlock(void *arg ) 
{ int status ;

  {
#line 871
  status = pthread_mutex_unlock(& mrc.mutex);
#line 872
  if (status) {
#line 873
    while (1) {
#line 873
      if (status == 35) {
#line 873
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "do_master_cleanup_unlock", 873, "automount.c");
#line 873
        dump_core();
      }
#line 873
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 873,
                    "automount.c");
#line 873
      abort();
#line 873
      break;
    }
  }
#line 875
  return;
}
}
#line 878 "automount.c"
static void *do_notify_state(void *arg ) 
{ struct master *master ;
  int sig ;
  int status ;

  {
#line 884
  sig = (*((int *)arg));
#line 886
  status = pthread_mutex_lock(& mrc.mutex);
#line 887
  if (status) {
#line 888
    while (1) {
#line 888
      if (status == 35) {
#line 888
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "do_notify_state", 888, "automount.c");
#line 888
        dump_core();
      }
#line 888
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 888,
                    "automount.c");
#line 888
      abort();
#line 888
      break;
    }
  }
#line 890
  master = mrc.master;
#line 892
  while (1) {
#line 892
    ((*log_debug))(master->default_logging, "%s: signal %d", "do_notify_state", sig);
#line 892
    break;
  }
#line 894
  mrc.signaled = 1U;
#line 895
  status = pthread_cond_signal(& mrc.cond);
#line 896
  if (status) {
#line 897
    while (1) {
#line 897
      ((*log_error))(master->default_logging, "%s: failed to signal state notify condition",
                     "do_notify_state");
#line 897
      break;
    }
#line 899
    status = pthread_mutex_unlock(& mrc.mutex);
#line 900
    if (status) {
#line 901
      while (1) {
#line 901
        if (status == 35) {
#line 901
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "do_notify_state", 901, "automount.c");
#line 901
          dump_core();
        }
#line 901
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 901,
                      "automount.c");
#line 901
        abort();
#line 901
        break;
      }
    }
#line 902
    pthread_exit((void *)0);
  }
#line 905
  status = pthread_mutex_unlock(& mrc.mutex);
#line 906
  if (status) {
#line 907
    while (1) {
#line 907
      if (status == 35) {
#line 907
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "do_notify_state", 907, "automount.c");
#line 907
        dump_core();
      }
#line 907
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 907,
                    "automount.c");
#line 907
      abort();
#line 907
      break;
    }
  }
#line 909
  master_notify_state_change(master, sig);
#line 911
  return ((void *)0);
}
}
#line 914 "automount.c"
static int do_signals(struct master *master , int sig ) 
{ pthread_t thid ;
  int r_sig ;
  int status ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp ;
  long tmp___0 ;

  {
#line 917
  r_sig = sig;
#line 920
  status = pthread_mutex_lock(& mrc.mutex);
#line 921
  if (status) {
#line 922
    while (1) {
#line 922
      if (status == 35) {
#line 922
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "do_signals", 922, "automount.c");
#line 922
        dump_core();
      }
#line 922
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 922,
                    "automount.c");
#line 922
      abort();
#line 922
      break;
    }
  }
#line 924
  status = pthread_create((pthread_t * __restrict  )(& thid), (pthread_attr_t const   * __restrict  )(& thread_attr),
                          & do_notify_state, (void * __restrict  )(& r_sig));
#line 925
  if (status) {
#line 926
    while (1) {
#line 926
      ((*log_error))(master->default_logging, "%s: mount state notify thread create failed",
                     "do_signals");
#line 926
      break;
    }
#line 928
    status = pthread_mutex_unlock(& mrc.mutex);
#line 929
    if (status) {
#line 930
      while (1) {
#line 930
        if (status == 35) {
#line 930
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "do_signals", 930, "automount.c");
#line 930
          dump_core();
        }
#line 930
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 930,
                      "automount.c");
#line 930
        abort();
#line 930
        break;
      }
    }
#line 931
    return (0);
  }
#line 934
  mrc.thid = thid;
#line 935
  mrc.master = master;
#line 937
  while (1) {
#line 937
    __cancel_routine = & do_master_cleanup_unlock;
#line 937
    __cancel_arg = (void *)0;
#line 937
    tmp = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf), 0);
#line 937
    not_first_call = tmp;
#line 937
    tmp___0 = __builtin_expect((long )not_first_call, 0L);
#line 937
    if (tmp___0) {
#line 937
      ((*__cancel_routine))(__cancel_arg);
#line 937
      __pthread_unwind_next(& __cancel_buf);
    }
#line 937
    __pthread_register_cancel(& __cancel_buf);
#line 937
    while (1) {
#line 939
      mrc.signaled = 0U;
#line 940
      while (! mrc.signaled) {
#line 941
        status = pthread_cond_wait((pthread_cond_t * __restrict  )(& mrc.cond), (pthread_mutex_t * __restrict  )(& mrc.mutex));
#line 942
        if (status) {
#line 943
          while (1) {
#line 943
            if (status == 35) {
#line 943
              ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                            "do_signals", 943, "automount.c");
#line 943
              dump_core();
            }
#line 943
            ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status,
                          943, "automount.c");
#line 943
            abort();
#line 943
            break;
          }
        }
      }
#line 937
      break;
    }
#line 946
    __pthread_unregister_cancel(& __cancel_buf);
#line 946
    ((*__cancel_routine))(__cancel_arg);
#line 937
    break;
  }
#line 948
  return (1);
}
}
#line 951 "automount.c"
static void *do_read_master(void *arg ) 
{ struct master *master ;
  time_t age ;
  int readall ;
  int status ;

  {
#line 955
  readall = 1;
#line 958
  status = pthread_mutex_lock(& mrc.mutex);
#line 959
  if (status) {
#line 960
    while (1) {
#line 960
      if (status == 35) {
#line 960
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "do_read_master", 960, "automount.c");
#line 960
        dump_core();
      }
#line 960
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 960,
                    "automount.c");
#line 960
      abort();
#line 960
      break;
    }
  }
#line 962
  master = mrc.master;
#line 963
  age = mrc.age;
#line 965
  mrc.signaled = 1U;
#line 966
  status = pthread_cond_signal(& mrc.cond);
#line 967
  if (status) {
#line 968
    while (1) {
#line 968
      ((*log_error))(master->default_logging, "%s: failed to signal master read map condition",
                     "do_read_master");
#line 968
      break;
    }
#line 970
    master->reading = 0U;
#line 971
    status = pthread_mutex_unlock(& mrc.mutex);
#line 972
    if (status) {
#line 973
      while (1) {
#line 973
        if (status == 35) {
#line 973
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "do_read_master", 973, "automount.c");
#line 973
          dump_core();
        }
#line 973
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 973,
                      "automount.c");
#line 973
        abort();
#line 973
        break;
      }
    }
#line 974
    pthread_exit((void *)0);
  }
#line 977
  status = pthread_mutex_unlock(& mrc.mutex);
#line 978
  if (status) {
#line 979
    while (1) {
#line 979
      if (status == 35) {
#line 979
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "do_read_master", 979, "automount.c");
#line 979
        dump_core();
      }
#line 979
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 979,
                    "automount.c");
#line 979
      abort();
#line 979
      break;
    }
  }
#line 981
  status = master_read_master(master, age, readall);
#line 983
  master->reading = 0U;
#line 985
  return ((void *)0);
}
}
#line 988 "automount.c"
static int do_hup_signal(struct master *master , time_t age ) 
{ pthread_t thid ;
  int status ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp ;
  long tmp___0 ;

  {
#line 993
  status = pthread_mutex_lock(& mrc.mutex);
#line 994
  if (status) {
#line 995
    while (1) {
#line 995
      if (status == 35) {
#line 995
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "do_hup_signal", 995, "automount.c");
#line 995
        dump_core();
      }
#line 995
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 995,
                    "automount.c");
#line 995
      abort();
#line 995
      break;
    }
  }
#line 997
  if (master->reading) {
#line 998
    status = pthread_mutex_unlock(& mrc.mutex);
#line 999
    if (status) {
#line 1000
      while (1) {
#line 1000
        if (status == 35) {
#line 1000
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "do_hup_signal", 1000, "automount.c");
#line 1000
          dump_core();
        }
#line 1000
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1000,
                      "automount.c");
#line 1000
        abort();
#line 1000
        break;
      }
    }
#line 1001
    return (1);
  }
#line 1004
  master->reading = 1U;
#line 1006
  status = pthread_create((pthread_t * __restrict  )(& thid), (pthread_attr_t const   * __restrict  )(& thread_attr),
                          & do_read_master, (void * __restrict  )((void *)0));
#line 1007
  if (status) {
#line 1008
    while (1) {
#line 1008
      ((*log_error))(master->default_logging, "%s: master read map thread create failed",
                     "do_hup_signal");
#line 1008
      break;
    }
#line 1010
    master->reading = 0U;
#line 1011
    status = pthread_mutex_unlock(& mrc.mutex);
#line 1012
    if (status) {
#line 1013
      while (1) {
#line 1013
        if (status == 35) {
#line 1013
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "do_hup_signal", 1013, "automount.c");
#line 1013
          dump_core();
        }
#line 1013
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1013,
                      "automount.c");
#line 1013
        abort();
#line 1013
        break;
      }
    }
#line 1014
    return (0);
  }
#line 1017
  mrc.thid = thid;
#line 1018
  mrc.master = master;
#line 1019
  mrc.age = age;
#line 1021
  while (1) {
#line 1021
    __cancel_routine = & do_master_cleanup_unlock;
#line 1021
    __cancel_arg = (void *)0;
#line 1021
    tmp = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf), 0);
#line 1021
    not_first_call = tmp;
#line 1021
    tmp___0 = __builtin_expect((long )not_first_call, 0L);
#line 1021
    if (tmp___0) {
#line 1021
      ((*__cancel_routine))(__cancel_arg);
#line 1021
      __pthread_unwind_next(& __cancel_buf);
    }
#line 1021
    __pthread_register_cancel(& __cancel_buf);
#line 1021
    while (1) {
#line 1023
      mrc.signaled = 0U;
#line 1024
      while (! mrc.signaled) {
#line 1025
        status = pthread_cond_wait((pthread_cond_t * __restrict  )(& mrc.cond), (pthread_mutex_t * __restrict  )(& mrc.mutex));
#line 1026
        if (status) {
#line 1027
          while (1) {
#line 1027
            if (status == 35) {
#line 1027
              ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                            "do_hup_signal", 1027, "automount.c");
#line 1027
              dump_core();
            }
#line 1027
            ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status,
                          1027, "automount.c");
#line 1027
            abort();
#line 1027
            break;
          }
        }
      }
#line 1021
      break;
    }
#line 1030
    __pthread_unregister_cancel(& __cancel_buf);
#line 1030
    ((*__cancel_routine))(__cancel_arg);
#line 1021
    break;
  }
#line 1032
  return (1);
}
}
#line 1036 "automount.c"
static void *statemachine(void *arg ) 
{ sigset_t signalset ;
  int sig ;
  int tmp ;
  time_t tmp___0 ;

  {
#line 1041
  sigfillset(& signalset);
#line 1042
  sigdelset(& signalset, 17);
#line 1043
  sigdelset(& signalset, 18);
#line 1045
  while (1) {
#line 1046
    sigwait((sigset_t const   * __restrict  )(& signalset), (int * __restrict  )(& sig));
#line 1049
    tmp = master_list_empty(master_list);
#line 1049
    if (tmp) {
#line 1050
      return ((void *)0);
    }
#line 1052
    switch (sig) {
    case 15: 
    case 12: 
    case 10: 
#line 1056
    do_signals(master_list, sig);
#line 1057
    break;
    case 1: 
#line 1060
    tmp___0 = time((time_t *)((void *)0));
#line 1060
    do_hup_signal(master_list, tmp___0);
#line 1061
    break;
    default: ;
#line 1064
    while (1) {
#line 1064
      ((*log_error))(master_list->default_logging, "%s: got unexpected signal %d!",
                     "statemachine", sig);
#line 1064
      break;
    }
#line 1066
    continue;
    }
  }
}
}
#line 1071 "automount.c"
static void return_start_status(void *arg ) 
{ struct startup_cond *sc ;
  int status ;

  {
#line 1076
  sc = (struct startup_cond *)arg;
#line 1078
  sc->done = 1U;
#line 1084
  status = pthread_cond_signal(& sc->cond);
#line 1085
  if (status) {
#line 1086
    while (1) {
#line 1086
      if (status == 35) {
#line 1086
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "return_start_status", 1086, "automount.c");
#line 1086
        dump_core();
      }
#line 1086
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1086,
                    "automount.c");
#line 1086
      abort();
#line 1086
      break;
    }
  }
#line 1088
  status = pthread_mutex_unlock(& sc->mutex);
#line 1089
  if (status) {
#line 1090
    while (1) {
#line 1090
      if (status == 35) {
#line 1090
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "return_start_status", 1090, "automount.c");
#line 1090
        dump_core();
      }
#line 1090
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1090,
                    "automount.c");
#line 1090
      abort();
#line 1090
      break;
    }
  }
#line 1091
  return;
}
}
#line 1093 "automount.c"
static void mutex_operation_wait(pthread_mutex_t *mutex___0 ) 
{ int status ;

  {
#line 1101
  status = pthread_mutex_trylock(mutex___0);
#line 1102
  if (status) {
#line 1103
    if (status == 16) {
#line 1105
      status = pthread_mutex_unlock(mutex___0);
#line 1106
      if (status) {
#line 1107
        if (status != 1) {
#line 1108
          while (1) {
#line 1108
            if (status == 35) {
#line 1108
              ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                            "mutex_operation_wait", 1108, "automount.c");
#line 1108
              dump_core();
            }
#line 1108
            ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status,
                          1108, "automount.c");
#line 1108
            abort();
#line 1108
            break;
          }
        }
      } else {
#line 1110
        return;
      }
#line 1112
      status = pthread_mutex_lock(mutex___0);
#line 1113
      if (status) {
#line 1114
        while (1) {
#line 1114
          if (status == 35) {
#line 1114
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "mutex_operation_wait", 1114, "automount.c");
#line 1114
            dump_core();
          }
#line 1114
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1114,
                        "automount.c");
#line 1114
          abort();
#line 1114
          break;
        }
      }
    } else {
#line 1116
      while (1) {
#line 1116
        if (status == 35) {
#line 1116
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "mutex_operation_wait", 1116, "automount.c");
#line 1116
          dump_core();
        }
#line 1116
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1116,
                      "automount.c");
#line 1116
        abort();
#line 1116
        break;
      }
    }
#line 1119
    status = pthread_mutex_unlock(mutex___0);
#line 1120
    if (status) {
#line 1121
      while (1) {
#line 1121
        if (status == 35) {
#line 1121
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "mutex_operation_wait", 1121, "automount.c");
#line 1121
          dump_core();
        }
#line 1121
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1121,
                      "automount.c");
#line 1121
        abort();
#line 1121
        break;
      }
    }
  } else {
#line 1123
    status = pthread_mutex_unlock(mutex___0);
#line 1124
    if (status) {
#line 1125
      while (1) {
#line 1125
        if (status == 35) {
#line 1125
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "mutex_operation_wait", 1125, "automount.c");
#line 1125
          dump_core();
        }
#line 1125
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1125,
                      "automount.c");
#line 1125
        abort();
#line 1125
        break;
      }
    }
  }
#line 1128
  return;
}
}
#line 1131 "automount.c"
static void handle_mounts_cleanup(void *arg ) 
{ struct autofs_point *ap ;
  char path[4097] ;
  char buf[128] ;
  unsigned int clean ;
  unsigned int submount ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char *estr ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  __pid_t tmp___12 ;
  int tmp___13 ;

  {
#line 1136
  clean = 0U;
#line 1138
  ap = (struct autofs_point *)arg;
#line 1140
  submount = ap->submount;
#line 1142
  strcpy((char * __restrict  )(path), (char const   * __restrict  )ap->path);
#line 1143
  if (! submount) {
#line 1143
    if (0) {
#line 1143
      __s1_len = strlen((char const   *)ap->path);
#line 1143
      __s2_len = strlen("/-");
#line 1143
      if (! ((unsigned int )((void const   *)(ap->path + 1)) - (unsigned int )((void const   *)ap->path) == 1U)) {
        goto _L___0;
      } else {
#line 1143
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 1143
          if (! ((unsigned int )((void const   *)("/-" + 1)) - (unsigned int )((void const   *)"/-") == 1U)) {
#line 1143
            tmp___8 = 1;
          } else {
#line 1143
            if (__s2_len >= 4U) {
#line 1143
              tmp___8 = 1;
            } else {
#line 1143
              tmp___8 = 0;
            }
          }
        } else {
#line 1143
          tmp___8 = 0;
        }
      }
#line 1143
      if (tmp___8) {
#line 1143
        tmp___4 = __builtin_strcmp((char const   *)ap->path, "/-");
      } else {
#line 1143
        tmp___7 = __builtin_strcmp((char const   *)ap->path, "/-");
#line 1143
        tmp___4 = tmp___7;
      }
    } else {
#line 1143
      tmp___7 = __builtin_strcmp((char const   *)ap->path, "/-");
#line 1143
      tmp___4 = tmp___7;
    }
#line 1143
    if (tmp___4) {
#line 1143
      if (ap->dir_created) {
#line 1144
        clean = 1U;
      }
    }
  }
#line 1147
  mutex_operation_wait(& ap->state_mutex);
#line 1149
  alarm_delete(ap);
#line 1150
  st_remove_tasks(ap);
#line 1152
  umount_autofs(ap, 1);
#line 1154
  master_signal_submount(ap, 2U);
#line 1155
  master_remove_mapent(ap->entry);
#line 1156
  master_free_mapent_sources(ap->entry, 1U);
#line 1157
  master_free_mapent(ap->entry);
#line 1159
  sched_yield();
#line 1161
  if (clean) {
#line 1162
    tmp___11 = rmdir((char const   *)(path));
#line 1162
    if (tmp___11 == -1) {
#line 1163
      tmp___9 = __errno_location();
#line 1163
      tmp___10 = strerror_r((*tmp___9), buf, 128U);
#line 1163
      estr = tmp___10;
#line 1164
      while (1) {
#line 1164
        ((*log_warn))(0U, "%s: failed to remove dir %s: %s", "handle_mounts_cleanup",
                      path, estr);
#line 1164
        break;
      }
    }
  }
#line 1169
  while (1) {
#line 1169
    ((*log_info))(0U, "shut down path %s", path);
#line 1169
    break;
  }
#line 1172
  if (! submount) {
#line 1172
    tmp___13 = master_list_empty(master_list);
#line 1172
    if (tmp___13) {
#line 1173
      tmp___12 = getpid();
#line 1173
      kill(tmp___12, 15);
    }
  }
#line 1175
  return;
}
}
#line 1178 "automount.c"
void *handle_mounts(void *arg ) 
{ struct autofs_point *ap ;
  int cancel_state ;
  int status ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp ;
  long tmp___0 ;
  int _st_lock ;
  int tmp___1 ;
  int _st_unlock ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___0)(void * ) ;
  void *__cancel_arg___0 ;
  int not_first_call___0 ;
  int tmp___5 ;
  long tmp___6 ;
  int _st_unlock___0 ;
  int tmp___7 ;
  int ret ;
  int result ;
  int _st_lock___0 ;
  int tmp___8 ;
  int _st_unlock___1 ;
  int tmp___9 ;
  unsigned int tmp___10 ;
  int _st_unlock___2 ;
  int tmp___11 ;
  int _st_unlock___3 ;
  int tmp___12 ;
  int _st_unlock___4 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 1181
  status = 0;
#line 1183
  ap = (struct autofs_point *)arg;
#line 1185
  while (1) {
#line 1185
    __cancel_routine = & return_start_status;
#line 1185
    __cancel_arg = (void *)(& suc);
#line 1185
    tmp = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf), 0);
#line 1185
    not_first_call = tmp;
#line 1185
    tmp___0 = __builtin_expect((long )not_first_call, 0L);
#line 1185
    if (tmp___0) {
#line 1185
      ((*__cancel_routine))(__cancel_arg);
#line 1185
      __pthread_unwind_next(& __cancel_buf);
    }
#line 1185
    __pthread_register_cancel(& __cancel_buf);
#line 1185
    while (1) {
#line 1186
      pthread_setcancelstate(1, & cancel_state);
#line 1188
      while (1) {
#line 1188
        tmp___1 = pthread_mutex_lock(& ap->state_mutex);
#line 1188
        _st_lock = tmp___1;
#line 1188
        if (_st_lock) {
#line 1188
          while (1) {
#line 1188
            if (_st_lock == 35) {
#line 1188
              ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                            "handle_mounts", 1188, "automount.c");
#line 1188
              dump_core();
            }
#line 1188
            ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_lock,
                          1188, "automount.c");
#line 1188
            abort();
#line 1188
            break;
          }
        }
#line 1188
        break;
      }
#line 1190
      status = pthread_mutex_lock(& suc.mutex);
#line 1191
      if (status) {
#line 1192
        while (1) {
#line 1192
          ((*log_crit))(ap->logopt, "%s: failed to lock startup condition mutex!",
                        "handle_mounts");
#line 1192
          break;
        }
#line 1193
        while (1) {
#line 1193
          if (status == 35) {
#line 1193
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "handle_mounts", 1193, "automount.c");
#line 1193
            dump_core();
          }
#line 1193
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1193,
                        "automount.c");
#line 1193
          abort();
#line 1193
          break;
        }
      }
#line 1196
      tmp___3 = mount_autofs(ap);
#line 1196
      if (tmp___3 < 0) {
#line 1197
        while (1) {
#line 1197
          ((*log_crit))(ap->logopt, "%s: mount of %s failed!", "handle_mounts", ap->path);
#line 1197
          break;
        }
#line 1198
        suc.status = 1U;
#line 1199
        while (1) {
#line 1199
          tmp___2 = pthread_mutex_unlock(& ap->state_mutex);
#line 1199
          _st_unlock = tmp___2;
#line 1199
          if (_st_unlock) {
#line 1199
            while (1) {
#line 1199
              if (_st_unlock == 35) {
#line 1199
                ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                              "handle_mounts", 1199, "automount.c");
#line 1199
                dump_core();
              }
#line 1199
              ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_unlock,
                            1199, "automount.c");
#line 1199
              abort();
#line 1199
              break;
            }
          }
#line 1199
          break;
        }
#line 1200
        umount_autofs(ap, 1);
#line 1201
        pthread_setcancelstate(cancel_state, (int *)((void *)0));
#line 1202
        pthread_exit((void *)0);
      }
#line 1205
      if (ap->ghost) {
#line 1205
        if (ap->type != 4U) {
#line 1206
          while (1) {
#line 1206
            ((*log_info))(0U, "ghosting enabled");
#line 1206
            break;
          }
        }
      }
#line 1208
      suc.status = 0U;
#line 1185
      break;
    }
#line 1209
    __pthread_unregister_cancel(& __cancel_buf);
#line 1209
    ((*__cancel_routine))(__cancel_arg);
#line 1185
    break;
  }
#line 1213
  if (! ap->submount) {
#line 1213
    if (ap->exp_timeout) {
#line 1214
      tmp___4 = rand();
#line 1214
      alarm_add(ap, ap->exp_runfreq + (long )tmp___4 % ap->exp_runfreq);
    }
  }
#line 1216
  while (1) {
#line 1216
    __cancel_routine___0 = & handle_mounts_cleanup;
#line 1216
    __cancel_arg___0 = (void *)ap;
#line 1216
    tmp___5 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf),
                          0);
#line 1216
    not_first_call___0 = tmp___5;
#line 1216
    tmp___6 = __builtin_expect((long )not_first_call___0, 0L);
#line 1216
    if (tmp___6) {
#line 1216
      ((*__cancel_routine___0))(__cancel_arg___0);
#line 1216
      __pthread_unwind_next(& __cancel_buf___0);
    }
#line 1216
    __pthread_register_cancel(& __cancel_buf___0);
#line 1216
    while (1) {
#line 1217
      pthread_setcancelstate(cancel_state, (int *)((void *)0));
#line 1219
      while (1) {
#line 1219
        tmp___7 = pthread_mutex_unlock(& ap->state_mutex);
#line 1219
        _st_unlock___0 = tmp___7;
#line 1219
        if (_st_unlock___0) {
#line 1219
          while (1) {
#line 1219
            if (_st_unlock___0 == 35) {
#line 1219
              ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                            "handle_mounts", 1219, "automount.c");
#line 1219
              dump_core();
            }
#line 1219
            ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_unlock___0,
                          1219, "automount.c");
#line 1219
            abort();
#line 1219
            break;
          }
        }
#line 1219
        break;
      }
#line 1221
      while ((int )ap->state != 7) {
#line 1222
        tmp___14 = handle_packet(ap);
#line 1222
        if (tmp___14) {
#line 1225
          while (1) {
#line 1225
            tmp___8 = pthread_mutex_lock(& ap->state_mutex);
#line 1225
            _st_lock___0 = tmp___8;
#line 1225
            if (_st_lock___0) {
#line 1225
              while (1) {
#line 1225
                if (_st_lock___0 == 35) {
#line 1225
                  ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                                "handle_mounts", 1225, "automount.c");
#line 1225
                  dump_core();
                }
#line 1225
                ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_lock___0,
                              1225, "automount.c");
#line 1225
                abort();
#line 1225
                break;
              }
            }
#line 1225
            break;
          }
#line 1230
          if (ap->type == 4U) {
#line 1231
            status = 1;
#line 1232
            while (1) {
#line 1232
              tmp___9 = pthread_mutex_unlock(& ap->state_mutex);
#line 1232
              _st_unlock___1 = tmp___9;
#line 1232
              if (_st_unlock___1) {
#line 1232
                while (1) {
#line 1232
                  if (_st_unlock___1 == 35) {
#line 1232
                    ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                                  "handle_mounts", 1232, "automount.c");
#line 1232
                    dump_core();
                  }
#line 1232
                  ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_unlock___1,
                                1232, "automount.c");
#line 1232
                  abort();
#line 1232
                  break;
                }
              }
#line 1232
              break;
            }
#line 1233
            break;
          }
#line 1240
          if (sizeof(int ) == sizeof(int [1])) {
#line 1240
            if (sizeof(int ) < 16384U) {
#line 1240
              tmp___10 = sizeof(int );
            } else {
#line 1240
              tmp___10 = __invalid_size_argument_for_IOC;
            }
          } else {
#line 1240
            tmp___10 = __invalid_size_argument_for_IOC;
          }
#line 1240
          ret = ioctl(ap->ioctlfd, (unsigned long )(2147521392U | (tmp___10 << 16)),
                      & result);
#line 1241
          if (ret == -1) {
#line 1242
            while (1) {
#line 1242
              tmp___11 = pthread_mutex_unlock(& ap->state_mutex);
#line 1242
              _st_unlock___2 = tmp___11;
#line 1242
              if (_st_unlock___2) {
#line 1242
                while (1) {
#line 1242
                  if (_st_unlock___2 == 35) {
#line 1242
                    ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                                  "handle_mounts", 1242, "automount.c");
#line 1242
                    dump_core();
                  }
#line 1242
                  ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_unlock___2,
                                1242, "automount.c");
#line 1242
                  abort();
#line 1242
                  break;
                }
              }
#line 1242
              break;
            }
#line 1243
            break;
          }
#line 1247
          if ((int )ap->state == 7) {
            goto _L;
          } else {
#line 1247
            if (result) {
              _L: /* CIL Label */ 
#line 1248
              while (1) {
#line 1248
                tmp___12 = pthread_mutex_unlock(& ap->state_mutex);
#line 1248
                _st_unlock___3 = tmp___12;
#line 1248
                if (_st_unlock___3) {
#line 1248
                  while (1) {
#line 1248
                    if (_st_unlock___3 == 35) {
#line 1248
                      ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                                    "handle_mounts", 1248, "automount.c");
#line 1248
                      dump_core();
                    }
#line 1248
                    ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s",
                                  _st_unlock___3, 1248, "automount.c");
#line 1248
                    abort();
#line 1248
                    break;
                  }
                }
#line 1248
                break;
              }
#line 1249
              break;
            }
          }
#line 1253
          while (1) {
#line 1253
            ((*log_warn))(ap->logopt, "%s: can\'t shutdown: filesystem %s still busy",
                          "handle_mounts", ap->path);
#line 1253
            break;
          }
#line 1256
          if (! ap->submount) {
#line 1257
            alarm_add(ap, ap->exp_runfreq);
          }
#line 1258
          nextstate(ap->state_pipe[1], 1);
#line 1260
          while (1) {
#line 1260
            tmp___13 = pthread_mutex_unlock(& ap->state_mutex);
#line 1260
            _st_unlock___4 = tmp___13;
#line 1260
            if (_st_unlock___4) {
#line 1260
              while (1) {
#line 1260
                if (_st_unlock___4 == 35) {
#line 1260
                  ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                                "handle_mounts", 1260, "automount.c");
#line 1260
                  dump_core();
                }
#line 1260
                ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_unlock___4,
                              1260, "automount.c");
#line 1260
                abort();
#line 1260
                break;
              }
            }
#line 1260
            break;
          }
        }
      }
#line 1216
      break;
    }
#line 1264
    __pthread_unregister_cancel(& __cancel_buf___0);
#line 1264
    ((*__cancel_routine___0))(__cancel_arg___0);
#line 1216
    break;
  }
#line 1281
  sched_yield();
#line 1283
  return ((void *)0);
}
}
#line 1286 "automount.c"
static void key_thread_stdenv_vars_destroy(void *arg ) 
{ struct thread_stdenv_vars *tsv ;

  {
#line 1290
  tsv = (struct thread_stdenv_vars *)arg;
#line 1291
  if (tsv->user) {
#line 1292
    free((void *)tsv->user);
  }
#line 1293
  if (tsv->group) {
#line 1294
    free((void *)tsv->group);
  }
#line 1295
  if (tsv->home) {
#line 1296
    free((void *)tsv->home);
  }
#line 1297
  free((void *)tsv);
#line 1298
  return;
}
}
#line 1301 "automount.c"
static int is_automount_running(void) 
{ FILE *fp ;
  DIR *dir ;
  struct dirent entry ;
  struct dirent *result ;
  char path[4097] ;
  char buf[4096] ;
  int path_len ;
  int pid ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned short const   **tmp___9 ;
  __pid_t tmp___10 ;
  int c ;
  int len ;
  int tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;

  {
#line 1309
  dir = opendir("/proc");
#line 1309
  if ((unsigned int )dir == (unsigned int )((void *)0)) {
#line 1310
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"cannot opendir(/proc)\n");
#line 1311
    exit(1);
  }
#line 1314
  while (1) {
#line 1314
    tmp___13 = readdir_r((DIR * __restrict  )dir, (struct dirent * __restrict  )(& entry),
                         (struct dirent ** __restrict  )(& result));
#line 1314
    if (! (tmp___13 == 0)) {
#line 1314
      break;
    }
#line 1315
    pid = 0;
#line 1317
    if (! result) {
#line 1318
      break;
    }
#line 1320
    if ((int )entry.d_name[0] == 46) {
#line 1321
      continue;
    }
#line 1323
    if (0) {
#line 1323
      __s1_len = strlen((char const   *)(entry.d_name));
#line 1323
      __s2_len = strlen("self");
#line 1323
      if (! ((unsigned int )((void const   *)(entry.d_name + 1)) - (unsigned int )((void const   *)(entry.d_name)) == 1U)) {
        goto _L___0;
      } else {
#line 1323
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 1323
          if (! ((unsigned int )((void const   *)("self" + 1)) - (unsigned int )((void const   *)"self") == 1U)) {
#line 1323
            tmp___8 = 1;
          } else {
#line 1323
            if (__s2_len >= 4U) {
#line 1323
              tmp___8 = 1;
            } else {
#line 1323
              tmp___8 = 0;
            }
          }
        } else {
#line 1323
          tmp___8 = 0;
        }
      }
#line 1323
      if (tmp___8) {
#line 1323
        tmp___4 = __builtin_strcmp((char const   *)(entry.d_name), "self");
      } else {
#line 1323
        tmp___7 = __builtin_strcmp((char const   *)(entry.d_name), "self");
#line 1323
        tmp___4 = tmp___7;
      }
    } else {
#line 1323
      tmp___7 = __builtin_strcmp((char const   *)(entry.d_name), "self");
#line 1323
      tmp___4 = tmp___7;
    }
#line 1323
    if (! tmp___4) {
#line 1324
      continue;
    }
#line 1326
    tmp___9 = __ctype_b_loc();
#line 1326
    if (! ((int const   )(*((*tmp___9) + (int )entry.d_name[0])) & 2048)) {
#line 1327
      continue;
    }
#line 1329
    pid = atoi__extinline((char const   *)(entry.d_name));
#line 1330
    tmp___10 = getpid();
#line 1330
    if (pid == tmp___10) {
#line 1331
      continue;
    }
#line 1333
    path_len = sprintf((char * __restrict  )(path), (char const   * __restrict  )"/proc/%s/cmdline",
                       entry.d_name);
#line 1334
    if (path_len >= 4096) {
#line 1335
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"buffer to small for /proc path\n");
#line 1337
      return (-1);
    }
#line 1339
    path[path_len] = (char )'\000';
#line 1341
    fp = fopen((char const   * __restrict  )(path), (char const   * __restrict  )"r");
#line 1342
    if (fp) {
#line 1343
      len = 0;
#line 1345
      while (1) {
#line 1345
        if (len < 127) {
#line 1345
          c = fgetc(fp);
#line 1345
          if (c != -1) {
#line 1345
            if (! c) {
#line 1345
              break;
            }
          } else {
#line 1345
            break;
          }
        } else {
#line 1345
          break;
        }
#line 1346
        tmp___11 = len;
#line 1346
        len ++;
#line 1346
        buf[tmp___11] = (char )c;
      }
#line 1347
      buf[len] = (char )'\000';
#line 1349
      tmp___12 = strstr((char const   *)(buf), "automount");
#line 1349
      if (tmp___12) {
#line 1350
        return (pid);
      }
#line 1351
      fclose(fp);
    }
  }
#line 1354
  closedir(dir);
#line 1356
  return (0);
}
}
#line 1359 "automount.c"
static void usage(void) 
{ 

  {
#line 1361
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: %s [options] [master_map_name]\n\t-h --help\tthis text\n\t-p --pid-file f write process id to file f\n\t-t --timeout n\tauto-unmount in n seconds (0-disable)\n\t-v --verbose\tbe verbose\n\t-d --debug\tlog debuging info\n\t-D --define\tdefine global macro variable\n\t-r --random-replicated-selection\n\t\t\tuse ramdom replicated server selection\n\t-O --global-options\n\t\t\tspecify global mount options\n\t-V --version\tprint version, build config and exit\n",
          program);
#line 1376
  return;
}
}
#line 1378 "automount.c"
static void show_build_info(void) 
{ char buf[2048] ;
  int count ;

  {
#line 1381
  count = 0;
#line 1383
  printf((char const   * __restrict  )"\nLinux automount version %s\n", version);
#line 1385
  printf((char const   * __restrict  )"\nDirectories:\n");
#line 1386
  printf((char const   * __restrict  )"\tconfig dir:\t%s\n", confdir);
#line 1387
  printf((char const   * __restrict  )"\tmaps dir:\t%s\n", mapdir);
#line 1388
  printf((char const   * __restrict  )"\tmodules dir:\t%s\n", libdir);
#line 1390
  printf((char const   * __restrict  )"\nCompile options:\n  ");
#line 1392
  memset((void *)(buf), 0, 2048U);
#line 1450
  printf((char const   * __restrict  )"\n\n");
#line 1452
  return;
}
}
#line 1464
int main(int argc , char **argv ) ;
#line 1464 "automount.c"
static struct option  const  long_options[11]  = 
#line 1464
  {      {"help", 0, (int *)0, 'h'}, 
        {"pid-file", 1, (int *)0, 'p'}, 
        {"timeout", 1, (int *)0, 't'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"debug", 0, (int *)0, 'd'}, 
        {"define", 1, (int *)0, 'D'}, 
        {"foreground", 0, (int *)0, 'f'}, 
        {"random-selection", 0, (int *)0, 'r'}, 
        {"global-options", 1, (int *)0, 'O'}, 
        {"version", 0, (int *)0, 'V'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 1455 "automount.c"
int main(int argc , char **argv ) 
{ int res ;
  int opt ;
  int status ;
  unsigned int ghost ;
  unsigned int logging ;
  unsigned int foreground ;
  unsigned int have_global_options ;
  time_t timeout ;
  time_t age ;
  time_t tmp ;
  sigset_t allsigs ;
  struct rlimit rlim ;
  __uid_t tmp___10 ;
  int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  unsigned int tmp___17 ;
  unsigned int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 1461
  tmp = time((time_t *)((void *)0));
#line 1461
  age = tmp;
#line 1478
  sigfillset(& allsigs);
#line 1479
  sigprocmask(0, (sigset_t const   * __restrict  )(& allsigs), (sigset_t * __restrict  )((void *)0));
#line 1481
  program = (char const   *)(*(argv + 0));
#line 1483
  defaults_read_config();
#line 1485
  kpkt_len = get_kpkt_len();
#line 1486
  timeout = (time_t )defaults_get_timeout();
#line 1487
  ghost = defaults_get_browse_mode();
#line 1488
  logging = defaults_get_logging();
#line 1489
  random_selection = 0U;
#line 1490
  global_options = (char const   *)((void *)0);
#line 1491
  have_global_options = 0U;
#line 1492
  foreground = 0U;
#line 1494
  opterr = 0;
#line 1495
  while (1) {
#line 1495
    opt = getopt_long(argc, (char * const  *)argv, "+hp:t:vdD:fVrO:", long_options,
                      (int *)((void *)0));
#line 1495
    if (! (opt != -1)) {
#line 1495
      break;
    }
#line 1496
    switch (opt) {
    case 104: 
#line 1498
    usage();
#line 1499
    exit(0);
    case 112: 
#line 1502
    pid_file = optarg;
#line 1503
    break;
    case 116: 
#line 1506
    timeout = (time_t )getnumopt(optarg, (char )opt);
#line 1507
    break;
    case 118: 
#line 1510
    logging |= 2U;
#line 1511
    break;
    case 100: 
#line 1514
    logging |= 1U;
#line 1515
    break;
    case 68: 
#line 1518
    macro_parse_globalvar((char const   *)optarg);
#line 1519
    break;
    case 102: 
#line 1522
    foreground = 1U;
#line 1523
    break;
    case 86: 
#line 1526
    show_build_info();
#line 1527
    exit(0);
    case 114: 
#line 1530
    random_selection = 1U;
#line 1531
    break;
    case 79: 
#line 1534
    if (! have_global_options) {
#line 1535
      global_options = (char const   *)__strdup((char const   *)optarg);
#line 1536
      have_global_options = 1U;
#line 1537
      break;
    }
#line 1539
    printf((char const   * __restrict  )"%s: global options already specified.\n",
           program);
#line 1541
    break;
    case 63: 
    case 58: 
#line 1545
    printf((char const   * __restrict  )"%s: Ambiguous or unknown options\n", program);
#line 1546
    exit(1);
    }
  }
#line 1550
  if (logging & 2U) {
#line 1551
    set_log_verbose();
  }
#line 1553
  if (logging & 1U) {
#line 1554
    set_log_debug();
  }
#line 1556
  tmp___10 = geteuid();
#line 1556
  if (tmp___10 != 0U) {
#line 1557
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: this program must be run by root.\n",
            program);
#line 1559
    exit(1);
  }
#line 1563
  argv += optind;
#line 1564
  argc -= optind;
#line 1566
  tmp___11 = is_automount_running();
#line 1566
  if (tmp___11 > 0) {
#line 1567
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: program is already running.\n",
            program);
#line 1569
    exit(1);
  }
#line 1579
  tmp___12 = query_kproto_ver();
#line 1579
  if (tmp___12) {
#line 1579
    tmp___13 = get_kver_major();
#line 1579
    if (tmp___13 < 5U) {
#line 1580
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: kernel protocol version 5.00 or above required.\n",
              program);
#line 1583
      exit(1);
    }
  } else {
#line 1580
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: kernel protocol version 5.00 or above required.\n",
            program);
#line 1583
    exit(1);
  }
#line 1586
  rlim.rlim_cur = 10240UL;
#line 1587
  rlim.rlim_max = 10240UL;
#line 1588
  res = setrlimit(7, (struct rlimit  const  *)(& rlim));
#line 1589
  if (res) {
#line 1590
    while (1) {
#line 1590
      ((*log_warn))(0U, "%s: can\'t increase open file limit - continuing", "main");
#line 1590
      break;
    }
  }
#line 1594
  rlim.rlim_cur = ~ 0UL;
#line 1595
  rlim.rlim_max = ~ 0UL;
#line 1596
  res = setrlimit(4, (struct rlimit  const  *)(& rlim));
#line 1597
  if (res) {
#line 1598
    while (1) {
#line 1598
      ((*log_warn))(0U, "%s: can\'t increase core file limit - continuing", "main");
#line 1598
      break;
    }
  }
#line 1602
  become_daemon(foreground);
#line 1604
  if (argc == 0) {
#line 1605
    master_list = master_new((char const   *)((void *)0), (unsigned int )timeout,
                             ghost);
  } else {
#line 1607
    master_list = master_new((char const   *)(*(argv + 0)), (unsigned int )timeout,
                             ghost);
  }
#line 1609
  if (! master_list) {
#line 1610
    while (1) {
#line 1610
      ((*log_crit))(3U, "%s: %s: can\'t create master map %s", "main", program, (*(argv + 0)));
#line 1610
      break;
    }
#line 1612
    close(start_pipefd[1]);
#line 1613
    exit(1);
  }
#line 1616
  tmp___14 = pthread_attr_init(& thread_attr);
#line 1616
  if (tmp___14) {
#line 1617
    while (1) {
#line 1617
      ((*log_crit))(3U, "%s: %s: failed to init thread attribute struct!", "main",
                    program);
#line 1617
      break;
    }
#line 1620
    close(start_pipefd[1]);
#line 1621
    exit(1);
  }
#line 1624
  tmp___15 = pthread_attr_setdetachstate(& thread_attr, 1);
#line 1624
  if (tmp___15) {
#line 1626
    while (1) {
#line 1626
      ((*log_crit))(3U, "%s: %s: failed to set detached thread attribute!", "main",
                    program);
#line 1626
      break;
    }
#line 1629
    close(start_pipefd[1]);
#line 1630
    exit(1);
  }
#line 1634
  tmp___16 = pthread_attr_setstacksize(& thread_attr, 1048576U);
#line 1634
  if (tmp___16) {
#line 1636
    while (1) {
#line 1636
      ((*log_crit))(3U, "%s: %s: failed to set stack size thread attribute!", "main",
                    program);
#line 1636
      break;
    }
#line 1639
    close(start_pipefd[1]);
#line 1640
    exit(1);
  }
#line 1644
  while (1) {
#line 1644
    ((*log_info))(0U, "Starting automounter version %s, master map %s", version, master_list->name);
#line 1644
    break;
  }
#line 1646
  while (1) {
#line 1646
    tmp___17 = get_kver_minor();
#line 1646
    tmp___18 = get_kver_major();
#line 1646
    ((*log_info))(0U, "using kernel protocol version %d.%02d", tmp___18, tmp___17);
#line 1646
    break;
  }
#line 1649
  status = pthread_key_create(& key_thread_stdenv_vars, & key_thread_stdenv_vars_destroy);
#line 1651
  if (status) {
#line 1652
    while (1) {
#line 1652
      ((*log_crit))(3U, "%s: failed to create thread data key for std env vars!",
                    "main");
#line 1652
      break;
    }
#line 1654
    master_kill(master_list);
#line 1655
    close(start_pipefd[1]);
#line 1656
    exit(1);
  }
#line 1659
  tmp___19 = alarm_start_handler();
#line 1659
  if (! tmp___19) {
#line 1660
    while (1) {
#line 1660
      ((*log_crit))(3U, "%s: failed to create alarm handler thread!", "main");
#line 1660
      break;
    }
#line 1661
    master_kill(master_list);
#line 1662
    close(start_pipefd[1]);
#line 1663
    exit(1);
  }
#line 1666
  tmp___20 = st_start_handler();
#line 1666
  if (! tmp___20) {
#line 1667
    while (1) {
#line 1667
      ((*log_crit))(3U, "%s: failed to create FSM handler thread!", "main");
#line 1667
      break;
    }
#line 1668
    master_kill(master_list);
#line 1669
    close(start_pipefd[1]);
#line 1670
    exit(1);
  }
#line 1672
  tmp___21 = master_read_master(master_list, age, 0);
#line 1672
  if (! tmp___21) {
#line 1673
    master_kill(master_list);
#line 1674
    (*pst_stat) = 3;
#line 1675
    res = write(start_pipefd[1], (void const   *)pst_stat, sizeof(pst_stat));
#line 1676
    close(start_pipefd[1]);
#line 1677
    exit(3);
  }
#line 1680
  res = write(start_pipefd[1], (void const   *)pst_stat, sizeof(pst_stat));
#line 1681
  close(start_pipefd[1]);
#line 1683
  statemachine((void *)0);
#line 1685
  master_kill(master_list);
#line 1687
  if (pid_file) {
#line 1688
    unlink((char const   *)pid_file);
#line 1689
    pid_file = (char *)((void *)0);
  }
#line 1691
  closelog();
#line 1693
  exit(0);
}
}
#line 1 "indirect.o"
#pragma merger(0,"/tmp/cil-13QBzBas.i","-O2,-Wall,-fPIE")
#line 397 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf )  __attribute__((__nonnull__(3))) ;
#line 464
//__inline static  __attribute__((__nothrow__)) int fstat__extinline(int __fd , struct stat *__statbuf ) ;
#line 464 "/usr/include/sys/stat.h"
__inline static int fstat__extinline(int __fd , struct stat *__statbuf ) 
{ int tmp ;

  {
#line 467
  tmp = __fxstat(3, __fd, __statbuf);
#line 467
  return (tmp);
}
}
#line 76 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 85
extern int open(char const   *__file , int __oflag  , ...)  __attribute__((__nonnull__(1))) ;
#line 589 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 564 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long sysconf(int __name ) ;
#line 581
extern  __attribute__((__nothrow__)) __pid_t getpgrp(void) ;
#line 107 "/usr/include/sys/mount.h"
extern  __attribute__((__nothrow__)) int mount(char const   *__special_file , char const   *__dir ,
                                               char const   *__fstype , unsigned long __rwflag ,
                                               void const   *__data ) ;
#line 112
extern  __attribute__((__nothrow__)) int umount(char const   *__special_file ) ;
#line 115
extern  __attribute__((__nothrow__)) int umount2(char const   *__special_file , int __flags ) ;
#line 145 "/usr/include/pwd.h"
extern int getpwuid_r(__uid_t __uid , struct passwd * __restrict  __resultbuf , char * __restrict  __buffer ,
                      size_t __buflen , struct passwd ** __restrict  __result ) ;
#line 142 "/usr/include/grp.h"
extern int getgrgid_r(__gid_t __gid , struct group * __restrict  __resultbuf , char * __restrict  __buffer ,
                      size_t __buflen , struct group ** __restrict  __result ) ;
#line 327 "/usr/include/time.h"
extern int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
#line 487 "/usr/include/pthread.h"
extern void pthread_testcancel(void) ;
#line 923
extern  __attribute__((__nothrow__)) int pthread_cond_init(pthread_cond_t * __restrict  __cond ,
                                                           pthread_condattr_t const   * __restrict  __cond_attr )  __attribute__((__nonnull__(1))) ;
#line 928
extern  __attribute__((__nothrow__)) int pthread_cond_destroy(pthread_cond_t *__cond )  __attribute__((__nonnull__(1))) ;
#line 1077
extern  __attribute__((__nothrow__)) int pthread_setspecific(pthread_key_t __key ,
                                                             void const   *__pointer ) ;
#line 84 "../include/state.h"
void expire_cleanup(void *arg ) ;
#line 105 "../include/master.h"
extern int master_notify_submount(struct autofs_point * , char const   *path , enum states  ) ;
#line 206 "../include/automount.h"
int spawn_umount(logger *log  , ...) ;
#line 225
int lookup_nss_read_map(struct autofs_point *ap , struct map_source *source , time_t age ) ;
#line 228
int lookup_ghost(struct autofs_point *ap ) ;
#line 229
int lookup_nss_mount(struct autofs_point *ap , struct map_source *source , char const   *name ,
                     int name_len ) ;
#line 231
int lookup_prune_cache(struct autofs_point *ap , time_t age ) ;
#line 234
int lookup_source_close_ioctlfd(struct autofs_point *ap , char const   *key ) ;
#line 358
extern char *make_options_string(char *path , int kernel_pipefd , char *extra ) ;
#line 360
extern struct mnt_list *get_mnt_list(char const   *table , char const   *path , int include ) ;
#line 362
extern void free_mnt_list(struct mnt_list *list ) ;
#line 467
void *expire_proc_indirect(void *arg ) ;
#line 43 "indirect.c"
static union __anonunion_pthread_mutex_t_6 ma_mutex  =    {{0, 0U, 0, 0, 0U, {0}}};
#line 44 "indirect.c"
static union __anonunion_pthread_mutex_t_6 ea_mutex  =    {{0, 0U, 0, 0, 0U, {0}}};
#line 46 "indirect.c"
static int autofs_init_indirect(struct autofs_point *ap ) 
{ int pipefd[2] ;
  int cl_flags ;
  int tmp ;
  int tmp___0 ;

  {
#line 50
  if ((int )ap->state != 0) {
#line 52
    while (1) {
#line 52
      ((*log_error))(ap->logopt, "%s: bad state %d", "autofs_init_indirect", ap->state);
#line 52
      break;
    }
#line 53
    return (-1);
  }
#line 56
  ap->ioctlfd = -1;
#line 56
  ap->kpipefd = ap->ioctlfd;
#line 56
  ap->pipefd = ap->kpipefd;
#line 59
  tmp = pipe(pipefd);
#line 59
  if (tmp < 0) {
#line 60
    while (1) {
#line 60
      ((*log_crit))(ap->logopt, "%s: failed to create commumication pipe for autofs path %s",
                    "autofs_init_indirect", ap->path);
#line 60
      break;
    }
#line 63
    free((void *)ap->path);
#line 64
    return (-1);
  }
#line 67
  ap->pipefd = pipefd[0];
#line 68
  ap->kpipefd = pipefd[1];
#line 70
  cl_flags = fcntl(ap->pipefd, 1, 0);
#line 70
  if (cl_flags != -1) {
#line 71
    cl_flags |= 1;
#line 72
    fcntl(ap->pipefd, 2, cl_flags);
  }
#line 75
  cl_flags = fcntl(ap->kpipefd, 1, 0);
#line 75
  if (cl_flags != -1) {
#line 76
    cl_flags |= 1;
#line 77
    fcntl(ap->kpipefd, 2, cl_flags);
  }
#line 81
  tmp___0 = pipe(ap->state_pipe);
#line 81
  if (tmp___0 < 0) {
#line 82
    while (1) {
#line 82
      ((*log_crit))(ap->logopt, "%s: failed create state pipe for autofs path %s",
                    "autofs_init_indirect", ap->path);
#line 82
      break;
    }
#line 84
    close(ap->pipefd);
#line 85
    close(ap->kpipefd);
#line 86
    free((void *)ap->path);
#line 87
    return (-1);
  }
#line 90
  cl_flags = fcntl(ap->state_pipe[0], 1, 0);
#line 90
  if (cl_flags != -1) {
#line 91
    cl_flags |= 1;
#line 92
    fcntl(ap->state_pipe[0], 2, cl_flags);
  }
#line 95
  cl_flags = fcntl(ap->state_pipe[1], 1, 0);
#line 95
  if (cl_flags != -1) {
#line 96
    cl_flags |= 1;
#line 97
    fcntl(ap->state_pipe[1], 2, cl_flags);
  }
#line 100
  return (0);
}
}
#line 103 "indirect.c"
static int unlink_mount_tree(struct autofs_point *ap , struct mnt_list *mnts ) 
{ struct mnt_list *this ;
  int rv ;
  int ret ;
  pid_t pgrp ;
  pid_t tmp ;
  char spgrp[20] ;
  char *tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;

  {
#line 107
  tmp = getpgrp();
#line 107
  pgrp = tmp;
#line 110
  sprintf((char * __restrict  )(spgrp), (char const   * __restrict  )"pgrp=%d", pgrp);
#line 112
  ret = 1;
#line 113
  this = mnts;
#line 114
  while (this) {
#line 115
    tmp___0 = strstr((char const   *)this->opts, (char const   *)(spgrp));
#line 115
    if (tmp___0) {
#line 116
      this = this->next;
#line 117
      continue;
    }
#line 120
    if (0) {
#line 120
      __s1_len = strlen((char const   *)this->fs_type);
#line 120
      __s2_len = strlen("autofs");
#line 120
      if (! ((unsigned int )((void const   *)(this->fs_type + 1)) - (unsigned int )((void const   *)this->fs_type) == 1U)) {
        goto _L___0;
      } else {
#line 120
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 120
          if (! ((unsigned int )((void const   *)("autofs" + 1)) - (unsigned int )((void const   *)"autofs") == 1U)) {
#line 120
            tmp___10 = 1;
          } else {
#line 120
            if (__s2_len >= 4U) {
#line 120
              tmp___10 = 1;
            } else {
#line 120
              tmp___10 = 0;
            }
          }
        } else {
#line 120
          tmp___10 = 0;
        }
      }
#line 120
      if (tmp___10) {
#line 120
        tmp___6 = __builtin_strcmp((char const   *)this->fs_type, "autofs");
      } else {
#line 120
        tmp___9 = __builtin_strcmp((char const   *)this->fs_type, "autofs");
#line 120
        tmp___6 = tmp___9;
      }
    } else {
#line 120
      tmp___9 = __builtin_strcmp((char const   *)this->fs_type, "autofs");
#line 120
      tmp___6 = tmp___9;
    }
#line 120
    if (tmp___6) {
#line 121
      rv = spawn_umount(log_debug, "-l", this->path, (void *)0);
    } else {
#line 123
      rv = umount2((char const   *)this->path, 2);
    }
#line 124
    if (rv == -1) {
#line 125
      ret = 0;
#line 126
      while (1) {
#line 126
        ((*log_debug))(ap->logopt, "%s: can\'t unlink %s from mount tree", "unlink_mount_tree",
                       this->path);
#line 126
        break;
      }
#line 129
      tmp___11 = __errno_location();
#line 129
      switch ((*tmp___11)) {
      case 22: 
#line 131
      while (1) {
#line 131
        ((*log_warn))(ap->logopt, "%s: bad superblock or not mounted", "unlink_mount_tree");
#line 131
        break;
      }
#line 133
      break;
      case 2: 
      case 14: 
#line 137
      while (1) {
#line 137
        ((*log_warn))(ap->logopt, "%s: bad path for mount", "unlink_mount_tree");
#line 137
        break;
      }
#line 138
      break;
      }
    }
#line 141
    this = this->next;
  }
#line 143
  return (ret);
}
}
#line 146 "indirect.c"
static int do_mount_autofs_indirect(struct autofs_point *ap ) 
{ time_t timeout ;
  char *options ;
  char const   *type ;
  char const   *map_name ;
  struct stat st ;
  struct mnt_list *mnts ;
  int cl_flags ;
  int ret ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___9 ;
  int tmp___12 ;
  int tmp___13 ;
  unsigned int tmp___14 ;

  {
#line 148
  timeout = ap->exp_timeout;
#line 149
  options = (char *)((void *)0);
#line 150
  map_name = (char const   *)((void *)0);
#line 155
  mnts = get_mnt_list("/proc/mounts", (char const   *)ap->path, 1);
#line 156
  if (mnts) {
#line 157
    ret = unlink_mount_tree(ap, mnts);
#line 158
    free_mnt_list(mnts);
#line 159
    if (! ret) {
#line 160
      while (1) {
#line 160
        ((*log_debug))(ap->logopt, "%s: already mounted as other than autofs or failed to unlink entry in tree",
                       "do_mount_autofs_indirect");
#line 160
        break;
      }
      goto out_err;
    }
  }
#line 167
  options = make_options_string(ap->path, ap->kpipefd, (char *)((void *)0));
#line 168
  if (! options) {
    goto out_err;
  }
#line 172
  tmp___1 = mkdir_path((char const   *)ap->path, 365U);
#line 172
  if (tmp___1 < 0) {
#line 173
    tmp = __errno_location();
#line 173
    if ((*tmp) != 17) {
#line 173
      tmp___0 = __errno_location();
#line 173
      if ((*tmp___0) != 30) {
#line 174
        while (1) {
#line 174
          ((*log_crit))(ap->logopt, "%s: failed to create autofs directory %s", "do_mount_autofs_indirect",
                        ap->path);
#line 174
          break;
        }
        goto out_err;
      }
    }
#line 181
    ap->dir_created = 0U;
  } else {
#line 184
    ap->dir_created = 1U;
  }
#line 187
  type = (char const   *)((ap->entry)->maps)->type;
#line 188
  if (type) {
#line 188
    if (0) {
#line 188
      __s1_len = strlen((char const   *)((ap->entry)->maps)->type);
#line 188
      __s2_len = strlen("hosts");
#line 188
      if (! ((unsigned int )((void const   *)(((ap->entry)->maps)->type + 1)) - (unsigned int )((void const   *)((ap->entry)->maps)->type) == 1U)) {
        goto _L___0;
      } else {
#line 188
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 188
          if (! ((unsigned int )((void const   *)("hosts" + 1)) - (unsigned int )((void const   *)"hosts") == 1U)) {
#line 188
            tmp___13 = 1;
          } else {
#line 188
            if (__s2_len >= 4U) {
#line 188
              tmp___13 = 1;
            } else {
#line 188
              tmp___13 = 0;
            }
          }
        } else {
#line 188
          tmp___13 = 0;
        }
      }
#line 188
      if (tmp___13) {
#line 188
        tmp___9 = __builtin_strcmp((char const   *)((ap->entry)->maps)->type, "hosts");
      } else {
#line 188
        tmp___12 = __builtin_strcmp((char const   *)((ap->entry)->maps)->type, "hosts");
#line 188
        tmp___9 = tmp___12;
      }
    } else {
#line 188
      tmp___12 = __builtin_strcmp((char const   *)((ap->entry)->maps)->type, "hosts");
#line 188
      tmp___9 = tmp___12;
    }
#line 188
    if (tmp___9) {
#line 195
      map_name = (*(((ap->entry)->maps)->argv + 0));
    } else {
#line 189
      tmp___3 = (char *)__builtin_alloca(7U);
#line 189
      tmp___2 = tmp___3;
#line 190
      if (tmp___2) {
#line 191
        strcpy((char * __restrict  )tmp___2, (char const   * __restrict  )"-hosts");
#line 192
        map_name = (char const   *)tmp___2;
      }
    }
  } else {
#line 195
    map_name = (*(((ap->entry)->maps)->argv + 0));
  }
#line 197
  ret = mount(map_name, (char const   *)ap->path, "autofs", 3236757504UL, (void const   *)options);
#line 198
  if (ret) {
#line 199
    while (1) {
#line 199
      ((*log_crit))(ap->logopt, "%s: failed to mount autofs path %s", "do_mount_autofs_indirect",
                    ap->path);
#line 199
      break;
    }
    goto out_rmdir;
  }
#line 203
  free((void *)options);
#line 205
  options = (char *)((void *)0);
#line 208
  ap->ioctlfd = open((char const   *)ap->path, 0);
#line 209
  if (ap->ioctlfd < 0) {
#line 210
    while (1) {
#line 210
      ((*log_crit))(ap->logopt, "%s: failed to create ioctl fd for autofs path %s",
                    "do_mount_autofs_indirect", ap->path);
#line 210
      break;
    }
    goto out_umount;
  }
#line 215
  cl_flags = fcntl(ap->ioctlfd, 1, 0);
#line 215
  if (cl_flags != -1) {
#line 216
    cl_flags |= 1;
#line 217
    fcntl(ap->ioctlfd, 2, cl_flags);
  }
#line 220
  ap->exp_runfreq = ((timeout + 4L) - 1L) / 4L;
#line 222
  if (sizeof(unsigned long ) == sizeof(unsigned long [1])) {
#line 222
    if (sizeof(unsigned long ) < 16384U) {
#line 222
      tmp___14 = sizeof(unsigned long );
    } else {
#line 222
      tmp___14 = __invalid_size_argument_for_IOC;
    }
  } else {
#line 222
    tmp___14 = __invalid_size_argument_for_IOC;
  }
#line 222
  ioctl(ap->ioctlfd, (unsigned long )(3221263204U | (tmp___14 << 16)), & timeout);
#line 224
  if (ap->exp_timeout) {
#line 225
    while (1) {
#line 225
      ((*log_info))(0U, "mounted indirect mount on %s with timeout %u, freq %u seconds",
                    ap->path, (unsigned int )ap->exp_timeout, (unsigned int )ap->exp_runfreq);
#line 225
      break;
    }
  } else {
#line 230
    while (1) {
#line 230
      ((*log_info))(0U, "mounted indirect mount on %s with timeouts disabled", ap->path);
#line 230
      break;
    }
  }
#line 233
  fstat__extinline(ap->ioctlfd, & st);
#line 234
  ap->dev = st.st_dev;
#line 236
  return (0);
  out_umount: 
#line 239
  umount((char const   *)ap->path);
  out_rmdir: 
#line 241
  if (ap->dir_created) {
#line 242
    rmdir_path(ap, (char const   *)ap->path, ap->dev);
  }
  out_err: 
#line 244
  if (options) {
#line 245
    free((void *)options);
  }
#line 246
  close(ap->state_pipe[0]);
#line 247
  close(ap->state_pipe[1]);
#line 248
  close(ap->pipefd);
#line 249
  close(ap->kpipefd);
#line 251
  return (-1);
}
}
#line 254 "indirect.c"
int mount_autofs_indirect(struct autofs_point *ap ) 
{ time_t now ;
  time_t tmp ;
  int status ;
  int map ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 256
  tmp = time((time_t *)((void *)0));
#line 256
  now = tmp;
#line 260
  tmp___0 = autofs_init_indirect(ap);
#line 260
  if (tmp___0) {
#line 261
    return (-1);
  }
#line 264
  tmp___1 = lookup_nss_read_map(ap, (struct map_source *)((void *)0), now);
#line 264
  if (tmp___1) {
#line 265
    lookup_prune_cache(ap, now);
  } else {
#line 267
    while (1) {
#line 267
      ((*log_error))(ap->logopt, "%s: failed to read map for %s", "mount_autofs_indirect",
                     ap->path);
#line 267
      break;
    }
#line 268
    return (-1);
  }
#line 271
  status = do_mount_autofs_indirect(ap);
#line 272
  if (status < 0) {
#line 273
    return (-1);
  }
#line 275
  map = lookup_ghost(ap);
#line 276
  if (map & 1) {
#line 277
    if (map & 4) {
#line 278
      while (1) {
#line 278
        ((*log_error))(ap->logopt, "%s: bad map format,found direct, expected indirect exiting",
                       "mount_autofs_indirect");
#line 278
        break;
      }
    } else {
#line 282
      while (1) {
#line 282
        ((*log_error))(ap->logopt, "%s: failed to load map, exiting", "mount_autofs_indirect");
#line 282
        break;
      }
    }
#line 285
    return (-1);
  }
#line 288
  if (map & 32768) {
#line 289
    ap->ghost = 0U;
  }
#line 291
  return (0);
}
}
#line 294 "indirect.c"
int umount_autofs_indirect(struct autofs_point *ap ) 
{ char buf[128] ;
  int ret ;
  int rv ;
  int retries ;
  unsigned int tmp ;
  char *estr ;
  int *tmp___0 ;
  char *tmp___1 ;
  struct timespec tm ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;

  {
#line 305
  if (ap->submount) {
#line 306
    lookup_source_close_ioctlfd(ap->parent, (char const   *)ap->path);
  }
#line 309
  if (sizeof(int ) == sizeof(int [1])) {
#line 309
    if (sizeof(int ) < 16384U) {
#line 309
      tmp = sizeof(int );
    } else {
#line 309
      tmp = __invalid_size_argument_for_IOC;
    }
  } else {
#line 309
    tmp = __invalid_size_argument_for_IOC;
  }
#line 309
  rv = ioctl(ap->ioctlfd, (unsigned long )(2147521392U | (tmp << 16)), & ret);
#line 310
  if (rv == -1) {
#line 311
    tmp___0 = __errno_location();
#line 311
    tmp___1 = strerror_r((*tmp___0), buf, 128U);
#line 311
    estr = tmp___1;
#line 312
    while (1) {
#line 312
      ((*log_error))(ap->logopt, "%s: ioctl failed: %s", "umount_autofs_indirect",
                     estr);
#line 312
      break;
    }
#line 313
    return (1);
  } else {
#line 314
    if (! ret) {
#line 315
      while (1) {
#line 315
        ((*log_error))(ap->logopt, "%s: ask umount returned busy %s", "umount_autofs_indirect",
                       ap->path);
#line 315
        break;
      }
#line 316
      return (1);
    }
  }
#line 319
  ioctl(ap->ioctlfd, 37730UL, 0);
#line 320
  close(ap->ioctlfd);
#line 321
  ap->ioctlfd = -1;
#line 322
  close(ap->state_pipe[0]);
#line 323
  close(ap->state_pipe[1]);
#line 324
  ap->state_pipe[0] = -1;
#line 325
  ap->state_pipe[1] = -1;
#line 327
  if (ap->pipefd >= 0) {
#line 328
    close(ap->pipefd);
  }
#line 330
  if (ap->kpipefd >= 0) {
#line 331
    close(ap->kpipefd);
  }
#line 333
  sched_yield();
#line 335
  retries = 8;
#line 336
  while (1) {
#line 336
    rv = umount((char const   *)ap->path);
#line 336
    if (rv == -1) {
#line 336
      tmp___3 = retries;
#line 336
      retries --;
#line 336
      if (! tmp___3) {
#line 336
        break;
      }
    } else {
#line 336
      break;
    }
#line 337
    tm.tv_sec = (__time_t )0;
#line 337
    tm.tv_nsec = 100000000L;
#line 338
    tmp___2 = __errno_location();
#line 338
    if ((*tmp___2) != 16) {
#line 339
      break;
    }
#line 340
    nanosleep((struct timespec  const  *)(& tm), (struct timespec *)((void *)0));
  }
#line 343
  if (rv == -1) {
#line 344
    tmp___4 = __errno_location();
#line 344
    switch ((*tmp___4)) {
    case 2: 
    case 22: 
#line 347
    while (1) {
#line 347
      ((*log_error))(ap->logopt, "%s: mount point %s does not exist", "umount_autofs_indirect",
                     ap->path);
#line 347
      break;
    }
#line 349
    return (0);
#line 350
    break;
    case 16: 
#line 352
    while (1) {
#line 352
      ((*log_error))(ap->logopt, "%s: mount point %s is in use", "umount_autofs_indirect",
                     ap->path);
#line 352
      break;
    }
#line 354
    if ((int )ap->state == 6) {
      goto force_umount;
    } else {
#line 357
      return (0);
    }
#line 358
    break;
    case 20: 
#line 360
    while (1) {
#line 360
      ((*log_error))(ap->logopt, "%s: mount point is not a directory", "umount_autofs_indirect");
#line 360
      break;
    }
#line 361
    return (0);
#line 362
    break;
    }
#line 364
    return (1);
  }
  force_umount: 
#line 368
  if (rv != 0) {
#line 369
    while (1) {
#line 369
      ((*log_warn))(ap->logopt, "%s: forcing umount of indirect mount %s", "umount_autofs_indirect",
                    ap->path);
#line 369
      break;
    }
#line 371
    rv = umount2((char const   *)ap->path, 2);
  } else {
#line 373
    while (1) {
#line 373
      ((*log_info))(0U, "umounted indirect mount %s", ap->path);
#line 373
      break;
    }
#line 374
    if (ap->submount) {
#line 375
      rm_unwanted((char const   *)ap->path, 1, ap->dev);
    }
  }
#line 378
  return (rv);
}
}
#line 381 "indirect.c"
static int expire_indirect(struct autofs_point *ap , int ioctlfd , char const   *path ,
                           unsigned int when ) 
{ char buf[128] ;
  int ret ;
  int retries ;
  struct stat st ;
  char *estr ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct timespec tm ;
  unsigned int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  unsigned int tmp___8 ;
  int tmp___9 ;

  {
#line 387
  tmp___1 = fstat__extinline(ioctlfd, & st);
#line 387
  if (tmp___1 == -1) {
#line 388
    tmp = __errno_location();
#line 388
    tmp___0 = strerror_r((*tmp), buf, 128U);
#line 388
    estr = tmp___0;
#line 389
    while (1) {
#line 389
      ((*log_error))(ap->logopt, "%s: fstat failed: %s", "expire_indirect", estr);
#line 389
      break;
    }
#line 390
    return (0);
  }
#line 393
  tmp___2 = count_mounts(path, st.st_dev);
#line 393
  retries = (tmp___2 + 1) * 3;
#line 395
  while (1) {
#line 395
    tmp___7 = retries;
#line 395
    retries --;
#line 395
    if (! tmp___7) {
#line 395
      break;
    }
#line 396
    tm.tv_sec = (__time_t )0;
#line 396
    tm.tv_nsec = 100000000L;
#line 399
    if (sizeof(int ) == sizeof(int [1])) {
#line 399
      if (sizeof(int ) < 16384U) {
#line 399
        tmp___3 = sizeof(int );
      } else {
#line 399
        tmp___3 = __invalid_size_argument_for_IOC;
      }
    } else {
#line 399
      tmp___3 = __invalid_size_argument_for_IOC;
    }
#line 399
    ret = ioctl(ioctlfd, (unsigned long )(1073779558U | (tmp___3 << 16)), & when);
#line 400
    if (ret == -1) {
#line 402
      tmp___4 = __errno_location();
#line 402
      if ((*tmp___4) == 9) {
#line 403
        return (1);
      } else {
#line 402
        tmp___5 = __errno_location();
#line 402
        if ((*tmp___5) == 22) {
#line 403
          return (1);
        }
      }
#line 406
      tmp___6 = __errno_location();
#line 406
      if ((*tmp___6) != 11) {
#line 407
        return (0);
      }
    }
#line 410
    nanosleep((struct timespec  const  *)(& tm), (struct timespec *)((void *)0));
  }
#line 413
  if (sizeof(int ) == sizeof(int [1])) {
#line 413
    if (sizeof(int ) < 16384U) {
#line 413
      tmp___8 = sizeof(int );
    } else {
#line 413
      tmp___8 = __invalid_size_argument_for_IOC;
    }
  } else {
#line 413
    tmp___8 = __invalid_size_argument_for_IOC;
  }
#line 413
  tmp___9 = ioctl(ioctlfd, (unsigned long )(2147521392U | (tmp___8 << 16)), & ret);
#line 413
  if (! tmp___9) {
#line 414
    if (! ret) {
#line 415
      return (0);
    }
  }
#line 418
  return (1);
}
}
#line 421 "indirect.c"
static void mnts_cleanup(void *arg ) 
{ struct mnt_list *mnts ;

  {
#line 423
  mnts = (struct mnt_list *)arg;
#line 424
  free_mnt_list(mnts);
#line 425
  return;
}
}
#line 428 "indirect.c"
void *expire_proc_indirect(void *arg ) 
{ struct autofs_point *ap ;
  struct mapent *me ;
  struct mnt_list *mnts ;
  struct mnt_list *next ;
  struct expire_args *ea ;
  struct expire_args ec ;
  unsigned int now ;
  int offsets ;
  int submnts ;
  int count ;
  int ioctlfd ;
  int cur_state ;
  int status ;
  int ret ;
  int left ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp ;
  long tmp___0 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___0)(void * ) ;
  void *__cancel_arg___0 ;
  int not_first_call___0 ;
  int tmp___1 ;
  long tmp___2 ;
  char *ind_key ;
  int ret___0 ;
  char *tmp___3 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___9 ;
  int tmp___12 ;
  int tmp___13 ;
  __pthread_unwind_buf_t __cancel_buf___1 ;
  void (*__cancel_routine___1)(void * ) ;
  void *__cancel_arg___1 ;
  int not_first_call___1 ;
  int tmp___14 ;
  long tmp___15 ;
  char *tmp___16 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  unsigned int tmp___27 ;
  int tmp___28 ;

  {
#line 431
  me = (struct mapent *)((void *)0);
#line 432
  mnts = (struct mnt_list *)((void *)0);
#line 440
  ea = (struct expire_args *)arg;
#line 442
  status = pthread_mutex_lock(& ea->mutex);
#line 443
  if (status) {
#line 444
    while (1) {
#line 444
      if (status == 35) {
#line 444
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "expire_proc_indirect", 444, "indirect.c");
#line 444
        dump_core();
      }
#line 444
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 444,
                    "indirect.c");
#line 444
      abort();
#line 444
      break;
    }
  }
#line 446
  ec.ap = ea->ap;
#line 446
  ap = ec.ap;
#line 447
  now = ea->when;
#line 448
  ec.status = -1;
#line 450
  ea->signaled = 1U;
#line 451
  status = pthread_cond_signal(& ea->cond);
#line 452
  if (status) {
#line 453
    while (1) {
#line 453
      if (status == 35) {
#line 453
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "expire_proc_indirect", 453, "indirect.c");
#line 453
        dump_core();
      }
#line 453
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 453,
                    "indirect.c");
#line 453
      abort();
#line 453
      break;
    }
  }
#line 455
  status = pthread_mutex_unlock(& ea->mutex);
#line 456
  if (status) {
#line 457
    while (1) {
#line 457
      if (status == 35) {
#line 457
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "expire_proc_indirect", 457, "indirect.c");
#line 457
        dump_core();
      }
#line 457
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 457,
                    "indirect.c");
#line 457
      abort();
#line 457
      break;
    }
  }
#line 459
  while (1) {
#line 459
    __cancel_routine = & expire_cleanup;
#line 459
    __cancel_arg = (void *)(& ec);
#line 459
    tmp = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf), 0);
#line 459
    not_first_call = tmp;
#line 459
    tmp___0 = __builtin_expect((long )not_first_call, 0L);
#line 459
    if (tmp___0) {
#line 459
      ((*__cancel_routine))(__cancel_arg);
#line 459
      __pthread_unwind_next(& __cancel_buf);
    }
#line 459
    __pthread_register_cancel(& __cancel_buf);
#line 459
    while (1) {
#line 461
      left = 0;
#line 464
      mnts = get_mnt_list("/proc/mounts", (char const   *)ap->path, 0);
#line 465
      while (1) {
#line 465
        __cancel_routine___0 = & mnts_cleanup;
#line 465
        __cancel_arg___0 = (void *)mnts;
#line 465
        tmp___1 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf),
                              0);
#line 465
        not_first_call___0 = tmp___1;
#line 465
        tmp___2 = __builtin_expect((long )not_first_call___0, 0L);
#line 465
        if (tmp___2) {
#line 465
          ((*__cancel_routine___0))(__cancel_arg___0);
#line 465
          __pthread_unwind_next(& __cancel_buf___0);
        }
#line 465
        __pthread_register_cancel(& __cancel_buf___0);
#line 465
        while (1) {
#line 466
          next = mnts;
#line 466
          while (next) {
#line 470
            if (0) {
#line 470
              __s1_len = strlen((char const   *)next->fs_type);
#line 470
              __s2_len = strlen("autofs");
#line 470
              if (! ((unsigned int )((void const   *)(next->fs_type + 1)) - (unsigned int )((void const   *)next->fs_type) == 1U)) {
                goto _L___0;
              } else {
#line 470
                if (__s1_len >= 4U) {
                  _L___0: /* CIL Label */ 
#line 470
                  if (! ((unsigned int )((void const   *)("autofs" + 1)) - (unsigned int )((void const   *)"autofs") == 1U)) {
#line 470
                    tmp___13 = 1;
                  } else {
#line 470
                    if (__s2_len >= 4U) {
#line 470
                      tmp___13 = 1;
                    } else {
#line 470
                      tmp___13 = 0;
                    }
                  }
                } else {
#line 470
                  tmp___13 = 0;
                }
              }
#line 470
              if (tmp___13) {
#line 470
                tmp___9 = __builtin_strcmp((char const   *)next->fs_type, "autofs");
              } else {
#line 470
                tmp___12 = __builtin_strcmp((char const   *)next->fs_type, "autofs");
#line 470
                tmp___9 = tmp___12;
              }
            } else {
#line 470
              tmp___12 = __builtin_strcmp((char const   *)next->fs_type, "autofs");
#line 470
              tmp___9 = tmp___12;
            }
#line 470
            if (! tmp___9) {
#line 475
              pthread_setcancelstate(1, & cur_state);
#line 476
              tmp___3 = strstr((char const   *)next->opts, "indirect");
#line 476
              if (tmp___3) {
#line 477
                master_notify_submount(ap, (char const   *)next->path, ap->state);
              }
#line 478
              pthread_setcancelstate(cur_state, (int *)((void *)0));
              goto __Cont;
            }
#line 483
            if ((int )ap->state == 2) {
#line 484
              pthread_testcancel();
            } else {
#line 483
              if ((int )ap->state == 3) {
#line 484
                pthread_testcancel();
              }
            }
#line 490
            ind_key = strrchr((char const   *)next->path, '/');
#line 491
            if (ind_key) {
#line 492
              ind_key ++;
            }
#line 501
            me = lookup_source_mapent(ap, (char const   *)next->path, 8192U);
#line 502
            if (! me) {
#line 502
              if (ind_key) {
#line 503
                me = lookup_source_mapent(ap, (char const   *)ind_key, 4096U);
              }
            }
#line 504
            if (! me) {
              goto __Cont;
            }
#line 507
            if ((int )(*(me->key)) == 47) {
#line 508
              ioctlfd = me->ioctlfd;
            } else {
#line 510
              ioctlfd = ap->ioctlfd;
            }
#line 512
            cache_unlock(me->mc);
#line 514
            while (1) {
#line 514
              ((*log_debug))(ap->logopt, "%s: expire %s", "expire_proc_indirect",
                             next->path);
#line 514
              break;
            }
#line 516
            pthread_setcancelstate(1, & cur_state);
#line 517
            ret___0 = expire_indirect(ap, ioctlfd, (char const   *)next->path, now);
#line 518
            if (! ret___0) {
#line 519
              left ++;
            }
#line 520
            pthread_setcancelstate(cur_state, (int *)((void *)0));
            __Cont: /* CIL Label */ 
#line 466
            next = next->next;
          }
#line 465
          break;
        }
#line 522
        __pthread_unregister_cancel(& __cancel_buf___0);
#line 522
        ((*__cancel_routine___0))(__cancel_arg___0);
#line 465
        break;
      }
#line 529
      if (mnts) {
#line 530
        pthread_setcancelstate(1, & cur_state);
#line 531
        ret = expire_indirect(ap, ap->ioctlfd, (char const   *)ap->path, now);
#line 532
        if (! ret) {
#line 533
          left ++;
        }
#line 534
        pthread_setcancelstate(cur_state, (int *)((void *)0));
      }
#line 537
      submnts = 0;
#line 537
      offsets = submnts;
#line 537
      count = offsets;
#line 538
      mnts = get_mnt_list("/proc/mounts", (char const   *)ap->path, 0);
#line 539
      while (1) {
#line 539
        __cancel_routine___1 = & mnts_cleanup;
#line 539
        __cancel_arg___1 = (void *)mnts;
#line 539
        tmp___14 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___1.__cancel_jmp_buf),
                               0);
#line 539
        not_first_call___1 = tmp___14;
#line 539
        tmp___15 = __builtin_expect((long )not_first_call___1, 0L);
#line 539
        if (tmp___15) {
#line 539
          ((*__cancel_routine___1))(__cancel_arg___1);
#line 539
          __pthread_unwind_next(& __cancel_buf___1);
        }
#line 539
        __pthread_register_cancel(& __cancel_buf___1);
#line 539
        while (1) {
#line 541
          next = mnts;
#line 541
          while (next) {
#line 542
            if (0) {
#line 542
              __s1_len___0 = strlen((char const   *)next->fs_type);
#line 542
              __s2_len___0 = strlen("autofs");
#line 542
              if (! ((unsigned int )((void const   *)(next->fs_type + 1)) - (unsigned int )((void const   *)next->fs_type) == 1U)) {
                goto _L___2;
              } else {
#line 542
                if (__s1_len___0 >= 4U) {
                  _L___2: /* CIL Label */ 
#line 542
                  if (! ((unsigned int )((void const   *)("autofs" + 1)) - (unsigned int )((void const   *)"autofs") == 1U)) {
#line 542
                    tmp___26 = 1;
                  } else {
#line 542
                    if (__s2_len___0 >= 4U) {
#line 542
                      tmp___26 = 1;
                    } else {
#line 542
                      tmp___26 = 0;
                    }
                  }
                } else {
#line 542
                  tmp___26 = 0;
                }
              }
#line 542
              if (tmp___26) {
#line 542
                tmp___22 = __builtin_strcmp((char const   *)next->fs_type, "autofs");
              } else {
#line 542
                tmp___25 = __builtin_strcmp((char const   *)next->fs_type, "autofs");
#line 542
                tmp___22 = tmp___25;
              }
            } else {
#line 542
              tmp___25 = __builtin_strcmp((char const   *)next->fs_type, "autofs");
#line 542
              tmp___22 = tmp___25;
            }
#line 542
            if (tmp___22) {
#line 543
              count ++;
            } else {
#line 545
              tmp___16 = strstr((char const   *)next->opts, "indirect");
#line 545
              if (tmp___16) {
#line 546
                submnts ++;
              } else {
#line 548
                offsets ++;
              }
            }
#line 541
            next = next->next;
          }
#line 539
          break;
        }
#line 551
        __pthread_unregister_cancel(& __cancel_buf___1);
#line 551
        ((*__cancel_routine___1))(__cancel_arg___1);
#line 539
        break;
      }
#line 553
      if (submnts) {
#line 554
        while (1) {
#line 554
          ((*log_debug))(ap->logopt, "%s: %d submounts remaining in %s", "expire_proc_indirect",
                         submnts, ap->path);
#line 554
          break;
        }
      }
#line 561
      if (count) {
#line 562
        while (1) {
#line 562
          ((*log_debug))(ap->logopt, "%s: %d remaining in %s", "expire_proc_indirect",
                         count, ap->path);
#line 562
          break;
        }
      }
#line 565
      if (sizeof(int ) == sizeof(int [1])) {
#line 565
        if (sizeof(int ) < 16384U) {
#line 565
          tmp___27 = sizeof(int );
        } else {
#line 565
          tmp___27 = __invalid_size_argument_for_IOC;
        }
      } else {
#line 565
        tmp___27 = __invalid_size_argument_for_IOC;
      }
#line 565
      tmp___28 = ioctl(ap->ioctlfd, (unsigned long )(2147521392U | (tmp___27 << 16)),
                       & ret);
#line 565
      if (! tmp___28) {
#line 566
        if (! ret) {
#line 567
          while (1) {
#line 567
            ((*log_info))(0U, "mount still busy %s", ap->path);
#line 567
            break;
          }
        }
      }
#line 570
      ec.status = left;
#line 572
      pthread_setcancelstate(1, & cur_state);
#line 459
      break;
    }
#line 573
    __pthread_unregister_cancel(& __cancel_buf);
#line 573
    ((*__cancel_routine))(__cancel_arg);
#line 459
    break;
  }
#line 574
  pthread_setcancelstate(cur_state, (int *)((void *)0));
#line 576
  return ((void *)0);
}
}
#line 579 "indirect.c"
static void pending_cond_destroy(void *arg ) 
{ struct pending_args *mt ;
  int status ;

  {
#line 584
  mt = (struct pending_args *)arg;
#line 585
  status = pthread_cond_destroy(& mt->cond);
#line 586
  if (status) {
#line 587
    while (1) {
#line 587
      if (status == 35) {
#line 587
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "pending_cond_destroy", 587, "indirect.c");
#line 587
        dump_core();
      }
#line 587
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 587,
                    "indirect.c");
#line 587
      abort();
#line 587
      break;
    }
  }
#line 588
  return;
}
}
#line 590 "indirect.c"
static void expire_send_fail(void *arg ) 
{ struct pending_args *mt ;

  {
#line 592
  mt = (struct pending_args *)arg;
#line 593
  send_fail((mt->ap)->ioctlfd, (unsigned int )mt->wait_queue_token);
#line 594
  return;
}
}
#line 596 "indirect.c"
static void free_pending_args(void *arg ) 
{ struct pending_args *mt ;

  {
#line 598
  mt = (struct pending_args *)arg;
#line 599
  free((void *)mt);
#line 600
  return;
}
}
#line 602 "indirect.c"
static void expire_mutex_unlock(void *arg ) 
{ int status ;
  int tmp ;

  {
#line 604
  tmp = pthread_mutex_unlock(& ea_mutex);
#line 604
  status = tmp;
#line 605
  if (status) {
#line 606
    while (1) {
#line 606
      if (status == 35) {
#line 606
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "expire_mutex_unlock", 606, "indirect.c");
#line 606
        dump_core();
      }
#line 606
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 606,
                    "indirect.c");
#line 606
      abort();
#line 606
      break;
    }
  }
#line 607
  return;
}
}
#line 609 "indirect.c"
static void *do_expire_indirect(void *arg ) 
{ struct pending_args *mt ;
  struct autofs_point *ap ;
  int status ;
  int state ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp ;
  long tmp___0 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___0)(void * ) ;
  void *__cancel_arg___0 ;
  int not_first_call___0 ;
  int tmp___1 ;
  long tmp___2 ;
  __pthread_unwind_buf_t __cancel_buf___1 ;
  void (*__cancel_routine___1)(void * ) ;
  void *__cancel_arg___1 ;
  int not_first_call___1 ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 615
  mt = (struct pending_args *)arg;
#line 617
  status = pthread_mutex_lock(& ea_mutex);
#line 618
  if (status) {
#line 619
    while (1) {
#line 619
      if (status == 35) {
#line 619
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "do_expire_indirect", 619, "indirect.c");
#line 619
        dump_core();
      }
#line 619
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 619,
                    "indirect.c");
#line 619
      abort();
#line 619
      break;
    }
  }
#line 621
  ap = mt->ap;
#line 623
  mt->signaled = 1U;
#line 624
  status = pthread_cond_signal(& mt->cond);
#line 625
  if (status) {
#line 626
    while (1) {
#line 626
      if (status == 35) {
#line 626
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "do_expire_indirect", 626, "indirect.c");
#line 626
        dump_core();
      }
#line 626
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 626,
                    "indirect.c");
#line 626
      abort();
#line 626
      break;
    }
  }
#line 628
  expire_mutex_unlock((void *)0);
#line 630
  while (1) {
#line 630
    __cancel_routine = & free_pending_args;
#line 630
    __cancel_arg = (void *)mt;
#line 630
    tmp = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf), 0);
#line 630
    not_first_call = tmp;
#line 630
    tmp___0 = __builtin_expect((long )not_first_call, 0L);
#line 630
    if (tmp___0) {
#line 630
      ((*__cancel_routine))(__cancel_arg);
#line 630
      __pthread_unwind_next(& __cancel_buf);
    }
#line 630
    __pthread_register_cancel(& __cancel_buf);
#line 630
    while (1) {
#line 631
      while (1) {
#line 631
        __cancel_routine___0 = & pending_cond_destroy;
#line 631
        __cancel_arg___0 = (void *)mt;
#line 631
        tmp___1 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf),
                              0);
#line 631
        not_first_call___0 = tmp___1;
#line 631
        tmp___2 = __builtin_expect((long )not_first_call___0, 0L);
#line 631
        if (tmp___2) {
#line 631
          ((*__cancel_routine___0))(__cancel_arg___0);
#line 631
          __pthread_unwind_next(& __cancel_buf___0);
        }
#line 631
        __pthread_register_cancel(& __cancel_buf___0);
#line 631
        while (1) {
#line 632
          while (1) {
#line 632
            __cancel_routine___1 = & expire_send_fail;
#line 632
            __cancel_arg___1 = (void *)mt;
#line 632
            tmp___3 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___1.__cancel_jmp_buf),
                                  0);
#line 632
            not_first_call___1 = tmp___3;
#line 632
            tmp___4 = __builtin_expect((long )not_first_call___1, 0L);
#line 632
            if (tmp___4) {
#line 632
              ((*__cancel_routine___1))(__cancel_arg___1);
#line 632
              __pthread_unwind_next(& __cancel_buf___1);
            }
#line 632
            __pthread_register_cancel(& __cancel_buf___1);
#line 632
            while (1) {
#line 634
              status = do_expire(mt->ap, (char const   *)(mt->name), (int )mt->len);
#line 635
              pthread_setcancelstate(1, & state);
#line 636
              if (status) {
#line 637
                send_fail(ap->ioctlfd, (unsigned int )mt->wait_queue_token);
              } else {
#line 639
                send_ready(ap->ioctlfd, (unsigned int )mt->wait_queue_token);
              }
#line 640
              pthread_setcancelstate(state, (int *)((void *)0));
#line 632
              break;
            }
#line 642
            __pthread_unregister_cancel(& __cancel_buf___1);
#line 632
            break;
          }
#line 631
          break;
        }
#line 643
        __pthread_unregister_cancel(& __cancel_buf___0);
#line 643
        ((*__cancel_routine___0))(__cancel_arg___0);
#line 631
        break;
      }
#line 630
      break;
    }
#line 644
    __pthread_unregister_cancel(& __cancel_buf);
#line 644
    ((*__cancel_routine))(__cancel_arg);
#line 630
    break;
  }
#line 646
  return ((void *)0);
}
}
#line 649 "indirect.c"
int handle_packet_expire_indirect(struct autofs_point *ap , autofs_packet_expire_indirect_t *pkt ) 
{ struct pending_args *mt ;
  char buf[128] ;
  pthread_t thid ;
  int status ;
  int state ;
  char *estr ;
  int *tmp ;
  char *tmp___0 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 656
  pthread_setcancelstate(1, & state);
#line 658
  while (1) {
#line 658
    ((*log_debug))(ap->logopt, "%s: token %ld, name %s", "handle_packet_expire_indirect",
                   pkt->wait_queue_token, pkt->name);
#line 658
    break;
  }
#line 661
  mt = (struct pending_args *)malloc(sizeof(struct pending_args ));
#line 662
  if (! mt) {
#line 663
    tmp = __errno_location();
#line 663
    tmp___0 = strerror_r((*tmp), buf, 128U);
#line 663
    estr = tmp___0;
#line 664
    while (1) {
#line 664
      ((*log_error))(ap->logopt, "%s: malloc: %s", "handle_packet_expire_indirect",
                     estr);
#line 664
      break;
    }
#line 665
    send_fail(ap->ioctlfd, (unsigned int )pkt->wait_queue_token);
#line 666
    pthread_setcancelstate(state, (int *)((void *)0));
#line 667
    return (1);
  }
#line 670
  status = pthread_cond_init((pthread_cond_t * __restrict  )(& mt->cond), (pthread_condattr_t const   * __restrict  )((void *)0));
#line 671
  if (status) {
#line 672
    while (1) {
#line 672
      if (status == 35) {
#line 672
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "handle_packet_expire_indirect", 672, "indirect.c");
#line 672
        dump_core();
      }
#line 672
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 672,
                    "indirect.c");
#line 672
      abort();
#line 672
      break;
    }
  }
#line 674
  status = pthread_mutex_lock(& ea_mutex);
#line 675
  if (status) {
#line 676
    while (1) {
#line 676
      if (status == 35) {
#line 676
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "handle_packet_expire_indirect", 676, "indirect.c");
#line 676
        dump_core();
      }
#line 676
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 676,
                    "indirect.c");
#line 676
      abort();
#line 676
      break;
    }
  }
#line 678
  mt->ap = ap;
#line 679
  __builtin_strncpy(mt->name, (char const   *)(pkt->name), pkt->len);
#line 680
  mt->name[pkt->len] = (char )'\000';
#line 681
  mt->len = pkt->len;
#line 682
  mt->wait_queue_token = pkt->wait_queue_token;
#line 684
  status = pthread_create((pthread_t * __restrict  )(& thid), (pthread_attr_t const   * __restrict  )(& thread_attr),
                          & do_expire_indirect, (void * __restrict  )mt);
#line 685
  if (status) {
#line 686
    while (1) {
#line 686
      ((*log_error))(ap->logopt, "%s: expire thread create failed", "handle_packet_expire_indirect");
#line 686
      break;
    }
#line 687
    send_fail(ap->ioctlfd, (unsigned int )pkt->wait_queue_token);
#line 688
    expire_mutex_unlock((void *)0);
#line 689
    pending_cond_destroy((void *)mt);
#line 690
    free_pending_args((void *)mt);
#line 691
    pthread_setcancelstate(state, (int *)((void *)0));
#line 692
    return (1);
  }
#line 695
  while (1) {
#line 695
    __cancel_routine = & expire_mutex_unlock;
#line 695
    __cancel_arg = (void *)0;
#line 695
    tmp___1 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
#line 695
    not_first_call = tmp___1;
#line 695
    tmp___2 = __builtin_expect((long )not_first_call, 0L);
#line 695
    if (tmp___2) {
#line 695
      ((*__cancel_routine))(__cancel_arg);
#line 695
      __pthread_unwind_next(& __cancel_buf);
    }
#line 695
    __pthread_register_cancel(& __cancel_buf);
#line 695
    while (1) {
#line 696
      pthread_setcancelstate(state, (int *)((void *)0));
#line 698
      mt->signaled = 0U;
#line 699
      while (! mt->signaled) {
#line 700
        status = pthread_cond_wait((pthread_cond_t * __restrict  )(& mt->cond), (pthread_mutex_t * __restrict  )(& ea_mutex));
#line 701
        if (status) {
#line 702
          while (1) {
#line 702
            if (status == 35) {
#line 702
              ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                            "handle_packet_expire_indirect", 702, "indirect.c");
#line 702
              dump_core();
            }
#line 702
            ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status,
                          702, "indirect.c");
#line 702
            abort();
#line 702
            break;
          }
        }
      }
#line 695
      break;
    }
#line 705
    __pthread_unregister_cancel(& __cancel_buf);
#line 705
    ((*__cancel_routine))(__cancel_arg);
#line 695
    break;
  }
#line 707
  return (0);
}
}
#line 710 "indirect.c"
static void mount_send_fail(void *arg ) 
{ struct pending_args *mt ;

  {
#line 712
  mt = (struct pending_args *)arg;
#line 713
  send_fail((mt->ap)->ioctlfd, (unsigned int )mt->wait_queue_token);
#line 714
  return;
}
}
#line 716 "indirect.c"
static void mount_mutex_unlock(void *arg ) 
{ int status ;
  int tmp ;

  {
#line 718
  tmp = pthread_mutex_unlock(& ma_mutex);
#line 718
  status = tmp;
#line 719
  if (status) {
#line 720
    while (1) {
#line 720
      if (status == 35) {
#line 720
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "mount_mutex_unlock", 720, "indirect.c");
#line 720
        dump_core();
      }
#line 720
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 720,
                    "indirect.c");
#line 720
      abort();
#line 720
      break;
    }
  }
#line 721
  return;
}
}
#line 723 "indirect.c"
static void *do_mount_indirect(void *arg ) 
{ struct pending_args *mt ;
  struct autofs_point *ap ;
  char buf[4097] ;
  struct stat st ;
  struct passwd pw ;
  struct passwd *ppw ;
  struct passwd **pppw ;
  struct group gr ;
  struct group *pgr ;
  struct group **ppgr ;
  char *pw_tmp ;
  char *gr_tmp ;
  struct thread_stdenv_vars *tsv ;
  int len ;
  int tmplen ;
  int status ;
  int state ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp ;
  long tmp___0 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___0)(void * ) ;
  void *__cancel_arg___0 ;
  int not_first_call___0 ;
  int tmp___1 ;
  long tmp___2 ;
  __pthread_unwind_buf_t __cancel_buf___1 ;
  void (*__cancel_routine___1)(void * ) ;
  void *__cancel_arg___1 ;
  int not_first_call___1 ;
  int tmp___3 ;
  long tmp___4 ;
  char *tmp___14 ;
  char *tmp___24 ;
  char *tmp___34 ;

  {
#line 730
  ppw = & pw;
#line 731
  pppw = & ppw;
#line 733
  pgr = & gr;
#line 734
  ppgr = & pgr;
#line 739
  mt = (struct pending_args *)arg;
#line 741
  status = pthread_mutex_lock(& ma_mutex);
#line 742
  if (status) {
#line 743
    while (1) {
#line 743
      if (status == 35) {
#line 743
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "do_mount_indirect", 743, "indirect.c");
#line 743
        dump_core();
      }
#line 743
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 743,
                    "indirect.c");
#line 743
      abort();
#line 743
      break;
    }
  }
#line 745
  ap = mt->ap;
#line 746
  mt->status = 0;
#line 748
  mt->signaled = 1U;
#line 749
  status = pthread_cond_signal(& mt->cond);
#line 750
  if (status) {
#line 751
    while (1) {
#line 751
      if (status == 35) {
#line 751
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "do_mount_indirect", 751, "indirect.c");
#line 751
        dump_core();
      }
#line 751
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 751,
                    "indirect.c");
#line 751
      abort();
#line 751
      break;
    }
  }
#line 753
  mount_mutex_unlock((void *)0);
#line 755
  while (1) {
#line 755
    __cancel_routine = & free_pending_args;
#line 755
    __cancel_arg = (void *)mt;
#line 755
    tmp = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf), 0);
#line 755
    not_first_call = tmp;
#line 755
    tmp___0 = __builtin_expect((long )not_first_call, 0L);
#line 755
    if (tmp___0) {
#line 755
      ((*__cancel_routine))(__cancel_arg);
#line 755
      __pthread_unwind_next(& __cancel_buf);
    }
#line 755
    __pthread_register_cancel(& __cancel_buf);
#line 755
    while (1) {
#line 756
      while (1) {
#line 756
        __cancel_routine___0 = & pending_cond_destroy;
#line 756
        __cancel_arg___0 = (void *)mt;
#line 756
        tmp___1 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf),
                              0);
#line 756
        not_first_call___0 = tmp___1;
#line 756
        tmp___2 = __builtin_expect((long )not_first_call___0, 0L);
#line 756
        if (tmp___2) {
#line 756
          ((*__cancel_routine___0))(__cancel_arg___0);
#line 756
          __pthread_unwind_next(& __cancel_buf___0);
        }
#line 756
        __pthread_register_cancel(& __cancel_buf___0);
#line 756
        while (1) {
#line 757
          while (1) {
#line 757
            __cancel_routine___1 = & mount_send_fail;
#line 757
            __cancel_arg___1 = (void *)mt;
#line 757
            tmp___3 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___1.__cancel_jmp_buf),
                                  0);
#line 757
            not_first_call___1 = tmp___3;
#line 757
            tmp___4 = __builtin_expect((long )not_first_call___1, 0L);
#line 757
            if (tmp___4) {
#line 757
              ((*__cancel_routine___1))(__cancel_arg___1);
#line 757
              __pthread_unwind_next(& __cancel_buf___1);
            }
#line 757
            __pthread_register_cancel(& __cancel_buf___1);
#line 757
            while (1) {
#line 759
              pthread_setcancelstate(1, & state);
#line 761
              len = ncat_path(buf, sizeof(buf), (char const   *)ap->path, (char const   *)(mt->name),
                              mt->len);
#line 762
              if (! len) {
#line 763
                while (1) {
#line 763
                  ((*log_crit))(ap->logopt, "%s: path to be mounted is to long", "do_mount_indirect");
#line 763
                  break;
                }
#line 764
                pthread_setcancelstate(state, (int *)((void *)0));
#line 765
                pthread_exit((void *)0);
              }
#line 768
              status = lstat__extinline((char const   *)(buf), & st);
#line 769
              if (status != -1) {
#line 769
                if ((st.st_mode & 61440U) == 16384U) {
#line 769
                  if (! (st.st_dev == mt->dev)) {
                    goto _L;
                  }
                } else {
                  _L: /* CIL Label */ 
#line 770
                  while (1) {
#line 770
                    ((*log_error))(ap->logopt, "%s: indirect trigger not valid or already mounted %s",
                                   "do_mount_indirect", buf);
#line 770
                    break;
                  }
#line 772
                  pthread_setcancelstate(state, (int *)((void *)0));
#line 773
                  pthread_exit((void *)0);
                }
              }
#line 776
              pthread_setcancelstate(state, (int *)((void *)0));
#line 778
              while (1) {
#line 778
                ((*log_info))(0U, "attempting to mount entry %s", buf);
#line 778
                break;
              }
#line 786
              tsv = (struct thread_stdenv_vars *)malloc(sizeof(struct thread_stdenv_vars ));
#line 787
              if (! tsv) {
                goto cont;
              }
#line 790
              tsv->uid = mt->uid;
#line 791
              tsv->gid = mt->gid;
#line 795
              tmplen = (int )sysconf(70);
#line 796
              if (tmplen < 0) {
#line 797
                while (1) {
#line 797
                  ((*log_error))(ap->logopt, "%s: failed to get buffer size for getpwuid_r",
                                 "do_mount_indirect");
#line 797
                  break;
                }
#line 798
                free((void *)tsv);
                goto cont;
              }
#line 802
              pw_tmp = (char *)malloc((unsigned int )(tmplen + 1));
#line 803
              if (! pw_tmp) {
#line 804
                while (1) {
#line 804
                  ((*log_error))(ap->logopt, "%s: failed to malloc buffer for getpwuid_r",
                                 "do_mount_indirect");
#line 804
                  break;
                }
#line 805
                free((void *)tsv);
                goto cont;
              }
#line 809
              status = getpwuid_r(mt->uid, (struct passwd * __restrict  )ppw, (char * __restrict  )pw_tmp,
                                  (unsigned int )tmplen, (struct passwd ** __restrict  )pppw);
#line 810
              if (status) {
                goto _L___0;
              } else {
#line 810
                if (! ppw) {
                  _L___0: /* CIL Label */ 
#line 811
                  while (1) {
#line 811
                    ((*log_error))(ap->logopt, "%s: failed to get passwd info from getpwuid_r",
                                   "do_mount_indirect");
#line 811
                    break;
                  }
#line 812
                  free((void *)tsv);
#line 813
                  free((void *)pw_tmp);
                  goto cont;
                }
              }
#line 817
              tmp___14 = __strdup((char const   *)pw.pw_name);
#line 817
              tsv->user = tmp___14;
#line 818
              if (! tsv->user) {
#line 819
                while (1) {
#line 819
                  ((*log_error))(ap->logopt, "%s: failed to malloc buffer for user",
                                 "do_mount_indirect");
#line 819
                  break;
                }
#line 820
                free((void *)tsv);
#line 821
                free((void *)pw_tmp);
                goto cont;
              }
#line 825
              tmp___24 = __strdup((char const   *)pw.pw_dir);
#line 825
              tsv->home = tmp___24;
#line 826
              if (! tsv->user) {
#line 827
                while (1) {
#line 827
                  ((*log_error))(ap->logopt, "%s: failed to malloc buffer for home",
                                 "do_mount_indirect");
#line 827
                  break;
                }
#line 828
                free((void *)pw_tmp);
#line 829
                free((void *)tsv->user);
#line 830
                free((void *)tsv);
                goto cont;
              }
#line 834
              free((void *)pw_tmp);
#line 838
              tmplen = (int )sysconf(69);
#line 839
              if (tmplen < 0) {
#line 840
                while (1) {
#line 840
                  ((*log_error))(ap->logopt, "%s: failed to get buffer size for getgrgid_r",
                                 "do_mount_indirect");
#line 840
                  break;
                }
#line 841
                free((void *)tsv->user);
#line 842
                free((void *)tsv->home);
#line 843
                free((void *)tsv);
                goto cont;
              }
#line 847
              gr_tmp = (char *)malloc((unsigned int )(tmplen + 1));
#line 848
              if (! gr_tmp) {
#line 849
                while (1) {
#line 849
                  ((*log_error))(ap->logopt, "%s: failed to malloc buffer for getgrgid_r",
                                 "do_mount_indirect");
#line 849
                  break;
                }
#line 850
                free((void *)tsv->user);
#line 851
                free((void *)tsv->home);
#line 852
                free((void *)tsv);
                goto cont;
              }
#line 856
              status = getgrgid_r(mt->gid, (struct group * __restrict  )pgr, (char * __restrict  )gr_tmp,
                                  (unsigned int )tmplen, (struct group ** __restrict  )ppgr);
#line 857
              if (status) {
                goto _L___1;
              } else {
#line 857
                if (! pgr) {
                  _L___1: /* CIL Label */ 
#line 858
                  while (1) {
#line 858
                    ((*log_error))(ap->logopt, "%s: failed to get group info from getgrgid_r",
                                   "do_mount_indirect");
#line 858
                    break;
                  }
#line 859
                  free((void *)tsv->user);
#line 860
                  free((void *)tsv->home);
#line 861
                  free((void *)tsv);
#line 862
                  free((void *)gr_tmp);
                  goto cont;
                }
              }
#line 866
              tmp___34 = __strdup((char const   *)gr.gr_name);
#line 866
              tsv->group = tmp___34;
#line 867
              if (! tsv->group) {
#line 868
                while (1) {
#line 868
                  ((*log_error))(ap->logopt, "%s: failed to malloc buffer for group",
                                 "do_mount_indirect");
#line 868
                  break;
                }
#line 869
                free((void *)tsv->user);
#line 870
                free((void *)tsv->home);
#line 871
                free((void *)tsv);
#line 872
                free((void *)gr_tmp);
                goto cont;
              }
#line 876
              free((void *)gr_tmp);
#line 878
              status = pthread_setspecific(key_thread_stdenv_vars, (void const   *)tsv);
#line 879
              if (status) {
#line 880
                while (1) {
#line 880
                  ((*log_error))(ap->logopt, "%s: failed to set stdenv thread var",
                                 "do_mount_indirect");
#line 880
                  break;
                }
#line 881
                free((void *)tsv->group);
#line 882
                free((void *)tsv->user);
#line 883
                free((void *)tsv->home);
#line 884
                free((void *)tsv);
              }
              cont: 
#line 887
              status = lookup_nss_mount(ap, (struct map_source *)((void *)0), (char const   *)(mt->name),
                                        (int )mt->len);
#line 888
              pthread_setcancelstate(1, & state);
#line 889
              if (status) {
#line 890
                send_ready(ap->ioctlfd, (unsigned int )mt->wait_queue_token);
#line 891
                while (1) {
#line 891
                  ((*log_info))(0U, "mounted %s", buf);
#line 891
                  break;
                }
              } else {
#line 893
                send_fail(ap->ioctlfd, (unsigned int )mt->wait_queue_token);
#line 894
                while (1) {
#line 894
                  ((*log_info))(0U, "failed to mount %s", buf);
#line 894
                  break;
                }
              }
#line 896
              pthread_setcancelstate(state, (int *)((void *)0));
#line 757
              break;
            }
#line 898
            __pthread_unregister_cancel(& __cancel_buf___1);
#line 757
            break;
          }
#line 756
          break;
        }
#line 899
        __pthread_unregister_cancel(& __cancel_buf___0);
#line 899
        ((*__cancel_routine___0))(__cancel_arg___0);
#line 756
        break;
      }
#line 755
      break;
    }
#line 900
    __pthread_unregister_cancel(& __cancel_buf);
#line 900
    ((*__cancel_routine))(__cancel_arg);
#line 755
    break;
  }
#line 902
  return ((void *)0);
}
}
#line 905 "indirect.c"
int handle_packet_missing_indirect(struct autofs_point *ap , autofs_packet_missing_indirect_t *pkt ) 
{ pthread_t thid ;
  char buf[128] ;
  struct pending_args *mt ;
  int status ;
  int state ;
  char *estr ;
  int *tmp ;
  char *tmp___0 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 912
  pthread_setcancelstate(1, & state);
#line 914
  while (1) {
#line 914
    ((*log_debug))(ap->logopt, "%s: token %ld, name %s, request pid %u", "handle_packet_missing_indirect",
                   pkt->wait_queue_token, pkt->name, pkt->pid);
#line 914
    break;
  }
#line 918
  if ((int )ap->state == 5) {
#line 921
    send_fail(ap->ioctlfd, (unsigned int )pkt->wait_queue_token);
#line 922
    pthread_setcancelstate(state, (int *)((void *)0));
#line 923
    return (0);
  } else {
#line 918
    if ((int )ap->state == 6) {
#line 921
      send_fail(ap->ioctlfd, (unsigned int )pkt->wait_queue_token);
#line 922
      pthread_setcancelstate(state, (int *)((void *)0));
#line 923
      return (0);
    } else {
#line 918
      if ((int )ap->state == 7) {
#line 921
        send_fail(ap->ioctlfd, (unsigned int )pkt->wait_queue_token);
#line 922
        pthread_setcancelstate(state, (int *)((void *)0));
#line 923
        return (0);
      }
    }
  }
#line 926
  mt = (struct pending_args *)malloc(sizeof(struct pending_args ));
#line 927
  if (! mt) {
#line 928
    tmp = __errno_location();
#line 928
    tmp___0 = strerror_r((*tmp), buf, 128U);
#line 928
    estr = tmp___0;
#line 929
    while (1) {
#line 929
      ((*log_error))(ap->logopt, "%s: malloc: %s", "handle_packet_missing_indirect",
                     estr);
#line 929
      break;
    }
#line 930
    send_fail(ap->ioctlfd, (unsigned int )pkt->wait_queue_token);
#line 931
    pthread_setcancelstate(state, (int *)((void *)0));
#line 932
    return (1);
  }
#line 934
  memset((void *)mt, 0, sizeof(struct pending_args ));
#line 936
  status = pthread_cond_init((pthread_cond_t * __restrict  )(& mt->cond), (pthread_condattr_t const   * __restrict  )((void *)0));
#line 937
  if (status) {
#line 938
    while (1) {
#line 938
      if (status == 35) {
#line 938
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "handle_packet_missing_indirect", 938, "indirect.c");
#line 938
        dump_core();
      }
#line 938
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 938,
                    "indirect.c");
#line 938
      abort();
#line 938
      break;
    }
  }
#line 940
  status = pthread_mutex_lock(& ma_mutex);
#line 941
  if (status) {
#line 942
    while (1) {
#line 942
      if (status == 35) {
#line 942
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "handle_packet_missing_indirect", 942, "indirect.c");
#line 942
        dump_core();
      }
#line 942
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 942,
                    "indirect.c");
#line 942
      abort();
#line 942
      break;
    }
  }
#line 944
  mt->ap = ap;
#line 945
  __builtin_strncpy(mt->name, (char const   *)(pkt->name), pkt->len);
#line 946
  mt->name[pkt->len] = (char )'\000';
#line 947
  mt->len = pkt->len;
#line 948
  mt->dev = (unsigned long long )pkt->dev;
#line 949
  mt->uid = pkt->uid;
#line 950
  mt->gid = pkt->gid;
#line 951
  mt->wait_queue_token = pkt->wait_queue_token;
#line 953
  status = pthread_create((pthread_t * __restrict  )(& thid), (pthread_attr_t const   * __restrict  )(& thread_attr),
                          & do_mount_indirect, (void * __restrict  )mt);
#line 954
  if (status) {
#line 955
    while (1) {
#line 955
      ((*log_error))(ap->logopt, "%s: expire thread create failed", "handle_packet_missing_indirect");
#line 955
      break;
    }
#line 956
    send_fail(ap->ioctlfd, (unsigned int )pkt->wait_queue_token);
#line 957
    mount_mutex_unlock((void *)0);
#line 958
    pending_cond_destroy((void *)mt);
#line 959
    free_pending_args((void *)mt);
#line 960
    pthread_setcancelstate(state, (int *)((void *)0));
#line 961
    return (1);
  }
#line 964
  while (1) {
#line 964
    __cancel_routine = & mount_mutex_unlock;
#line 964
    __cancel_arg = (void *)0;
#line 964
    tmp___1 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
#line 964
    not_first_call = tmp___1;
#line 964
    tmp___2 = __builtin_expect((long )not_first_call, 0L);
#line 964
    if (tmp___2) {
#line 964
      ((*__cancel_routine))(__cancel_arg);
#line 964
      __pthread_unwind_next(& __cancel_buf);
    }
#line 964
    __pthread_register_cancel(& __cancel_buf);
#line 964
    while (1) {
#line 965
      pthread_setcancelstate(state, (int *)((void *)0));
#line 967
      mt->signaled = 0U;
#line 968
      while (! mt->signaled) {
#line 969
        status = pthread_cond_wait((pthread_cond_t * __restrict  )(& mt->cond), (pthread_mutex_t * __restrict  )(& ma_mutex));
#line 970
        if (status) {
#line 971
          while (1) {
#line 971
            if (status == 35) {
#line 971
              ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                            "handle_packet_missing_indirect", 971, "indirect.c");
#line 971
              dump_core();
            }
#line 971
            ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status,
                          971, "indirect.c");
#line 971
            abort();
#line 971
            break;
          }
        }
      }
#line 964
      break;
    }
#line 974
    __pthread_unregister_cancel(& __cancel_buf);
#line 974
    ((*__cancel_routine))(__cancel_arg);
#line 964
    break;
  }
#line 976
  return (0);
}
}
#line 1 "direct.o"
#pragma merger(0,"/tmp/cil-n2xqQPXz.i","-O2,-Wall,-fPIE")
#line 463 "/usr/include/pthread.h"

/*pthread_once_impl*/

typedef struct {
  pthread_mutex_t mut;
  int             val;
} my_pthread_once_t;

#define MY_PTHREAD_ONCE_INIT     {0,0}

int my_pthread_once(my_pthread_once_t *m , void (*func)(void) )  {

  pthread_mutex_lock(&m->mut);

  if (!(m->val)){
    m->val = 1;
    func();
  }

  pthread_mutex_unlock(&m->mut);

  return 0;
}

#define pthread_once_t    my_pthread_once_t
#define pthread_once      my_pthread_once
#define PTHREAD_ONCE_INIT MY_PTHREAD_ONCE_INIT

/*pthread_once_impl*/

//extern int pthread_once(pthread_once_t *__once_control , void (*__init_routine)(void) )  __attribute__((__nonnull__(1,2))) ;
#line 1074
extern  __attribute__((__nothrow__)) void *pthread_getspecific(pthread_key_t __key ) ;
#line 92 "../include/master.h"
extern void master_source_unlock(struct master_mapent * ) ;
#line 169 "../include/automount.h"
extern int cache_set_ino_index(struct mapent_cache *mc , char const   *key , dev_t dev ,
                               ino_t ino ) ;
#line 171
extern struct mapent *cache_lookup_ino(struct mapent_cache *mc , dev_t dev , ino_t ino ) ;
#line 178
extern struct mapent *cache_partial_match(struct mapent_cache *mc , char const   *prefix ) ;
#line 189
extern struct mapent *cache_enumerate(struct mapent_cache *mc , struct mapent *me ) ;
#line 317
extern size_t _strlen(char const   *str , size_t max ) ;
#line 370
extern void tree_free_mnt_tree(struct mnt_list *tree ) ;
#line 371
extern struct mnt_list *tree_make_mnt_tree(char const   *table , char const   *path ) ;
#line 372
extern int tree_get_mnt_list(struct mnt_list *mnts , struct list_head *list , char const   *path ,
                             int include ) ;
#line 375
extern int tree_is_mounted(struct mnt_list *mnts , char const   *path , unsigned int type ) ;
#line 468
void *expire_proc_direct(void *arg ) ;
#line 472
int mount_autofs_offset(struct autofs_point *ap , struct mapent *me , int is_autofs_fs ) ;
#line 476
int do_umount_autofs_direct(struct autofs_point *ap , struct mnt_list *mnts , struct mapent *me ) ;
#line 478
int umount_autofs_offset(struct autofs_point *ap , struct mapent *me ) ;
#line 49 "direct.c"
pthread_key_t key_mnt_direct_params  ;
#line 50 "direct.c"
pthread_key_t key_mnt_offset_params  ;
#line 51 "direct.c"
pthread_once_t key_mnt_params_once  =    PTHREAD_ONCE_INIT;
#line 53 "direct.c"
static union __anonunion_pthread_mutex_t_6 ma_mutex___0  =    {{0, 0U, 0, 0, 0U, {0}}};
#line 54 "direct.c"
static union __anonunion_pthread_mutex_t_6 ea_mutex___0  =    {{0, 0U, 0, 0, 0U, {0}}};
#line 56 "direct.c"
static void key_mnt_params_destroy(void *arg ) 
{ struct mnt_params *mp ;

  {
#line 60
  mp = (struct mnt_params *)arg;
#line 61
  if (mp->options) {
#line 62
    free((void *)mp->options);
  }
#line 63
  free((void *)mp);
#line 64
  return;
}
}
#line 67 "direct.c"
static void key_mnt_params_init(void) 
{ int status ;

  {
#line 71
  status = pthread_key_create(& key_mnt_direct_params, & key_mnt_params_destroy);
#line 72
  if (status) {
#line 73
    while (1) {
#line 73
      if (status == 35) {
#line 73
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "key_mnt_params_init", 73, "direct.c");
#line 73
        dump_core();
      }
#line 73
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 73, "direct.c");
#line 73
      abort();
#line 73
      break;
    }
  }
#line 75
  status = pthread_key_create(& key_mnt_offset_params, & key_mnt_params_destroy);
#line 76
  if (status) {
#line 77
    while (1) {
#line 77
      if (status == 35) {
#line 77
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "key_mnt_params_init", 77, "direct.c");
#line 77
        dump_core();
      }
#line 77
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 77, "direct.c");
#line 77
      abort();
#line 77
      break;
    }
  }
#line 79
  return;
}
}
#line 82 "direct.c"
static void mnts_cleanup___0(void *arg ) 
{ struct mnt_list *mnts ;

  {
#line 84
  mnts = (struct mnt_list *)arg;
#line 85
  tree_free_mnt_tree(mnts);
#line 86
  return;
}
}
#line 89 "direct.c"
static int autofs_init_direct(struct autofs_point *ap ) 
{ int pipefd[2] ;
  int cl_flags ;
  int tmp ;
  int tmp___0 ;

  {
#line 93
  if ((int )ap->state != 0) {
#line 95
    while (1) {
#line 95
      ((*log_error))(ap->logopt, "%s: bad state %d", "autofs_init_direct", ap->state);
#line 95
      break;
    }
#line 96
    return (-1);
  }
#line 99
  ap->ioctlfd = -1;
#line 99
  ap->kpipefd = ap->ioctlfd;
#line 99
  ap->pipefd = ap->kpipefd;
#line 102
  tmp = pipe(pipefd);
#line 102
  if (tmp < 0) {
#line 103
    while (1) {
#line 103
      ((*log_crit))(ap->logopt, "%s: failed to create commumication pipe for autofs path %s",
                    "autofs_init_direct", ap->path);
#line 103
      break;
    }
#line 106
    return (-1);
  }
#line 109
  ap->pipefd = pipefd[0];
#line 110
  ap->kpipefd = pipefd[1];
#line 112
  cl_flags = fcntl(ap->pipefd, 1, 0);
#line 112
  if (cl_flags != -1) {
#line 113
    cl_flags |= 1;
#line 114
    fcntl(ap->pipefd, 2, cl_flags);
  }
#line 117
  cl_flags = fcntl(ap->kpipefd, 1, 0);
#line 117
  if (cl_flags != -1) {
#line 118
    cl_flags |= 1;
#line 119
    fcntl(ap->kpipefd, 2, cl_flags);
  }
#line 123
  tmp___0 = pipe(ap->state_pipe);
#line 123
  if (tmp___0 < 0) {
#line 124
    while (1) {
#line 124
      ((*log_crit))(ap->logopt, "%s: failed create state pipe for autofs path %s",
                    "autofs_init_direct", ap->path);
#line 124
      break;
    }
#line 126
    close(ap->pipefd);
#line 127
    close(ap->kpipefd);
#line 128
    return (-1);
  }
#line 131
  cl_flags = fcntl(ap->state_pipe[0], 1, 0);
#line 131
  if (cl_flags != -1) {
#line 132
    cl_flags |= 1;
#line 133
    fcntl(ap->state_pipe[0], 2, cl_flags);
  }
#line 136
  cl_flags = fcntl(ap->state_pipe[1], 1, 0);
#line 136
  if (cl_flags != -1) {
#line 137
    cl_flags |= 1;
#line 138
    fcntl(ap->state_pipe[1], 2, cl_flags);
  }
#line 141
  return (0);
}
}
#line 144 "direct.c"
int do_umount_autofs_direct(struct autofs_point *ap , struct mnt_list *mnts , struct mapent *me ) 
{ char buf[128] ;
  int ioctlfd ;
  int rv ;
  int left ;
  int retries ;
  int tmp ;
  int cl_flags ;
  int status ;
  unsigned int tmp___0 ;
  char *estr ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *estr___0 ;
  int *tmp___3 ;
  char *tmp___4 ;
  struct timespec tm ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *estr___1 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;

  {
#line 149
  left = umount_multi(ap, (char const   *)me->key, 0);
#line 150
  if (left) {
#line 151
    while (1) {
#line 151
      ((*log_warn))(ap->logopt, "%s: could not unmount %d dirs under %s", "do_umount_autofs_direct",
                    left, me->key);
#line 151
      break;
    }
#line 153
    return (1);
  }
#line 156
  if (me->ioctlfd != -1) {
#line 157
    tmp = tree_is_mounted(mnts, (char const   *)me->key, 2U);
#line 157
    if (tmp) {
#line 158
      while (1) {
#line 158
        ((*log_error))(ap->logopt, "%s: attempt to umount busy direct mount %s", "do_umount_autofs_direct",
                       me->key);
#line 158
        break;
      }
#line 161
      return (1);
    }
#line 163
    ioctlfd = me->ioctlfd;
  } else {
#line 167
    ioctlfd = open((char const   *)me->key, 0);
#line 168
    if (ioctlfd != -1) {
#line 169
      cl_flags = fcntl(ioctlfd, 1, 0);
#line 169
      if (cl_flags != -1) {
#line 170
        cl_flags |= 1;
#line 171
        fcntl(ioctlfd, 2, cl_flags);
      }
    }
  }
#line 177
  if (ioctlfd >= 0) {
#line 178
    status = 1;
#line 180
    if (sizeof(int ) == sizeof(int [1])) {
#line 180
      if (sizeof(int ) < 16384U) {
#line 180
        tmp___0 = sizeof(int );
      } else {
#line 180
        tmp___0 = __invalid_size_argument_for_IOC;
      }
    } else {
#line 180
      tmp___0 = __invalid_size_argument_for_IOC;
    }
#line 180
    rv = ioctl(ioctlfd, (unsigned long )(2147521392U | (tmp___0 << 16)), & status);
#line 181
    if (rv) {
#line 182
      tmp___1 = __errno_location();
#line 182
      tmp___2 = strerror_r((*tmp___1), buf, 128U);
#line 182
      estr = tmp___2;
#line 183
      while (1) {
#line 183
        ((*log_error))(ap->logopt, "%s: ioctl failed: %s", "do_umount_autofs_direct",
                       estr);
#line 183
        break;
      }
#line 184
      return (1);
    } else {
#line 185
      if (! status) {
#line 186
        if ((int )ap->state != 6) {
#line 187
          while (1) {
#line 187
            ((*log_error))(ap->logopt, "%s: ask umount returned busy for %s", "do_umount_autofs_direct",
                           me->key);
#line 187
            break;
          }
#line 190
          return (1);
        } else {
#line 192
          me->ioctlfd = -1;
#line 193
          ioctl(ioctlfd, 37730UL, 0);
#line 194
          close(ioctlfd);
          goto force_umount;
        }
      }
    }
#line 198
    me->ioctlfd = -1;
#line 199
    ioctl(ioctlfd, 37730UL, 0);
#line 200
    close(ioctlfd);
  } else {
#line 202
    tmp___3 = __errno_location();
#line 202
    tmp___4 = strerror_r((*tmp___3), buf, 128U);
#line 202
    estr___0 = tmp___4;
#line 203
    while (1) {
#line 203
      ((*log_error))(ap->logopt, "%s: couldn\'t get ioctl fd for direct mount %s",
                     "do_umount_autofs_direct", me->key);
#line 203
      break;
    }
#line 205
    while (1) {
#line 205
      ((*log_debug))(ap->logopt, "%s: open: %s", "do_umount_autofs_direct", estr___0);
#line 205
      break;
    }
#line 206
    return (1);
  }
#line 209
  sched_yield();
#line 211
  retries = 8;
#line 212
  while (1) {
#line 212
    rv = umount((char const   *)me->key);
#line 212
    if (rv == -1) {
#line 212
      tmp___6 = retries;
#line 212
      retries --;
#line 212
      if (! tmp___6) {
#line 212
        break;
      }
    } else {
#line 212
      break;
    }
#line 213
    tm.tv_sec = (__time_t )0;
#line 213
    tm.tv_nsec = 100000000L;
#line 214
    tmp___5 = __errno_location();
#line 214
    if ((*tmp___5) != 16) {
#line 215
      break;
    }
#line 216
    nanosleep((struct timespec  const  *)(& tm), (struct timespec *)((void *)0));
  }
#line 219
  if (rv == -1) {
#line 220
    tmp___7 = __errno_location();
#line 220
    switch ((*tmp___7)) {
    case 2: 
    case 22: 
#line 223
    while (1) {
#line 223
      ((*log_warn))(ap->logopt, "%s: mount point %s does not exist", "do_umount_autofs_direct",
                    me->key);
#line 223
      break;
    }
#line 225
    return (0);
#line 226
    break;
    case 16: 
#line 228
    while (1) {
#line 228
      ((*log_warn))(ap->logopt, "%s: mount point %s is in use", "do_umount_autofs_direct",
                    me->key);
#line 228
      break;
    }
#line 229
    if ((int )ap->state == 6) {
      goto force_umount;
    } else {
#line 232
      return (0);
    }
#line 233
    break;
    case 20: 
#line 235
    while (1) {
#line 235
      ((*log_error))(ap->logopt, "%s: mount point is not a directory", "do_umount_autofs_direct");
#line 235
      break;
    }
#line 236
    return (0);
#line 237
    break;
    }
#line 239
    return (1);
  }
  force_umount: 
#line 243
  if (rv != 0) {
#line 244
    while (1) {
#line 244
      ((*log_info))(0U, "forcing umount of direct mount %s", me->key);
#line 244
      break;
    }
#line 245
    rv = umount2((char const   *)me->key, 2);
  } else {
#line 247
    while (1) {
#line 247
      ((*log_info))(0U, "umounted direct mount %s", me->key);
#line 247
      break;
    }
  }
#line 249
  if (! rv) {
#line 249
    if (me->dir_created) {
#line 250
      tmp___10 = rmdir((char const   *)me->key);
#line 250
      if (tmp___10 == -1) {
#line 251
        tmp___8 = __errno_location();
#line 251
        tmp___9 = strerror_r((*tmp___8), buf, 128U);
#line 251
        estr___1 = tmp___9;
#line 252
        while (1) {
#line 252
          ((*log_warn))(ap->logopt, "%s: failed to remove dir %s: %s", "do_umount_autofs_direct",
                        me->key, estr___1);
#line 252
          break;
        }
      }
    }
  }
#line 256
  return (rv);
}
}
#line 259 "direct.c"
int umount_autofs_direct(struct autofs_point *ap ) 
{ struct map_source *map ;
  struct mapent_cache *nc ;
  struct mapent_cache *mc ;
  struct mnt_list *mnts ;
  struct mapent *me ;
  struct mapent *ne ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp ;
  long tmp___0 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___0)(void * ) ;
  void *__cancel_arg___0 ;
  int not_first_call___0 ;
  int tmp___1 ;
  long tmp___2 ;
  __pthread_unwind_buf_t __cancel_buf___1 ;
  void (*__cancel_routine___1)(void * ) ;
  void *__cancel_arg___1 ;
  int not_first_call___1 ;
  int tmp___3 ;
  long tmp___4 ;
  __pthread_unwind_buf_t __cancel_buf___2 ;
  void (*__cancel_routine___2)(void * ) ;
  void *__cancel_arg___2 ;
  int not_first_call___2 ;
  int tmp___5 ;
  long tmp___6 ;

  {
#line 266
  close(ap->state_pipe[0]);
#line 267
  close(ap->state_pipe[1]);
#line 268
  if (ap->pipefd >= 0) {
#line 269
    close(ap->pipefd);
  }
#line 270
  if (ap->kpipefd >= 0) {
#line 271
    close(ap->kpipefd);
#line 272
    ap->kpipefd = -1;
  }
#line 275
  mnts = tree_make_mnt_tree("/proc/mounts", "/");
#line 276
  while (1) {
#line 276
    __cancel_routine = & mnts_cleanup___0;
#line 276
    __cancel_arg = (void *)mnts;
#line 276
    tmp = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf), 0);
#line 276
    not_first_call = tmp;
#line 276
    tmp___0 = __builtin_expect((long )not_first_call, 0L);
#line 276
    if (tmp___0) {
#line 276
      ((*__cancel_routine))(__cancel_arg);
#line 276
      __pthread_unwind_next(& __cancel_buf);
    }
#line 276
    __pthread_register_cancel(& __cancel_buf);
#line 276
    while (1) {
#line 277
      while (1) {
#line 277
        __cancel_routine___0 = & master_source_lock_cleanup;
#line 277
        __cancel_arg___0 = (void *)ap->entry;
#line 277
        tmp___1 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf),
                              0);
#line 277
        not_first_call___0 = tmp___1;
#line 277
        tmp___2 = __builtin_expect((long )not_first_call___0, 0L);
#line 277
        if (tmp___2) {
#line 277
          ((*__cancel_routine___0))(__cancel_arg___0);
#line 277
          __pthread_unwind_next(& __cancel_buf___0);
        }
#line 277
        __pthread_register_cancel(& __cancel_buf___0);
#line 277
        while (1) {
#line 278
          master_source_readlock(ap->entry);
#line 279
          nc = ((ap->entry)->master)->nc;
#line 280
          cache_readlock(nc);
#line 281
          while (1) {
#line 281
            __cancel_routine___1 = & cache_lock_cleanup;
#line 281
            __cancel_arg___1 = (void *)nc;
#line 281
            tmp___3 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___1.__cancel_jmp_buf),
                                  0);
#line 281
            not_first_call___1 = tmp___3;
#line 281
            tmp___4 = __builtin_expect((long )not_first_call___1, 0L);
#line 281
            if (tmp___4) {
#line 281
              ((*__cancel_routine___1))(__cancel_arg___1);
#line 281
              __pthread_unwind_next(& __cancel_buf___1);
            }
#line 281
            __pthread_register_cancel(& __cancel_buf___1);
#line 281
            while (1) {
#line 282
              map = (ap->entry)->maps;
#line 283
              while (map) {
#line 284
                mc = map->mc;
#line 285
                while (1) {
#line 285
                  __cancel_routine___2 = & cache_lock_cleanup;
#line 285
                  __cancel_arg___2 = (void *)mc;
#line 285
                  tmp___5 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___2.__cancel_jmp_buf),
                                        0);
#line 285
                  not_first_call___2 = tmp___5;
#line 285
                  tmp___6 = __builtin_expect((long )not_first_call___2, 0L);
#line 285
                  if (tmp___6) {
#line 285
                    ((*__cancel_routine___2))(__cancel_arg___2);
#line 285
                    __pthread_unwind_next(& __cancel_buf___2);
                  }
#line 285
                  __pthread_register_cancel(& __cancel_buf___2);
#line 285
                  while (1) {
#line 286
                    cache_readlock(mc);
#line 287
                    me = cache_enumerate(mc, (struct mapent *)((void *)0));
#line 288
                    while (me) {
#line 289
                      ne = cache_lookup_distinct(nc, (char const   *)me->key);
#line 290
                      if (ne) {
#line 290
                        if ((unsigned long )map->master_line > (unsigned long )ne->age) {
#line 291
                          me = cache_enumerate(mc, me);
#line 292
                          continue;
                        }
                      }
#line 296
                      do_umount_autofs_direct(ap, mnts, me);
#line 298
                      me = cache_enumerate(mc, me);
                    }
#line 285
                    break;
                  }
#line 300
                  __pthread_unregister_cancel(& __cancel_buf___2);
#line 300
                  ((*__cancel_routine___2))(__cancel_arg___2);
#line 285
                  break;
                }
#line 301
                map = map->next;
              }
#line 281
              break;
            }
#line 303
            __pthread_unregister_cancel(& __cancel_buf___1);
#line 303
            ((*__cancel_routine___1))(__cancel_arg___1);
#line 281
            break;
          }
#line 277
          break;
        }
#line 304
        __pthread_unregister_cancel(& __cancel_buf___0);
#line 304
        ((*__cancel_routine___0))(__cancel_arg___0);
#line 277
        break;
      }
#line 276
      break;
    }
#line 305
    __pthread_unregister_cancel(& __cancel_buf);
#line 305
    ((*__cancel_routine))(__cancel_arg);
#line 276
    break;
  }
#line 307
  return (0);
}
}
#line 310 "direct.c"
static int unlink_mount_tree___0(struct autofs_point *ap , struct list_head *list ) 
{ struct list_head *p ;
  int rv ;
  int ret ;
  pid_t pgrp ;
  pid_t tmp ;
  char spgrp[20] ;
  struct mnt_list *mnt ;
  char *tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;

  {
#line 314
  tmp = getpgrp();
#line 314
  pgrp = tmp;
#line 317
  sprintf((char * __restrict  )(spgrp), (char const   * __restrict  )"pgrp=%d", pgrp);
#line 319
  ret = 1;
#line 320
  p = list->next;
#line 320
  while ((unsigned int )p != (unsigned int )list) {
#line 323
    mnt = (struct mnt_list *)((char *)p - (unsigned long )(& ((struct mnt_list *)0)->list));
#line 325
    tmp___0 = strstr((char const   *)mnt->opts, (char const   *)(spgrp));
#line 325
    if (tmp___0) {
      goto __Cont;
    }
#line 328
    if (0) {
#line 328
      __s1_len = strlen((char const   *)mnt->fs_type);
#line 328
      __s2_len = strlen("autofs");
#line 328
      if (! ((unsigned int )((void const   *)(mnt->fs_type + 1)) - (unsigned int )((void const   *)mnt->fs_type) == 1U)) {
        goto _L___0;
      } else {
#line 328
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 328
          if (! ((unsigned int )((void const   *)("autofs" + 1)) - (unsigned int )((void const   *)"autofs") == 1U)) {
#line 328
            tmp___10 = 1;
          } else {
#line 328
            if (__s2_len >= 4U) {
#line 328
              tmp___10 = 1;
            } else {
#line 328
              tmp___10 = 0;
            }
          }
        } else {
#line 328
          tmp___10 = 0;
        }
      }
#line 328
      if (tmp___10) {
#line 328
        tmp___6 = __builtin_strcmp((char const   *)mnt->fs_type, "autofs");
      } else {
#line 328
        tmp___9 = __builtin_strcmp((char const   *)mnt->fs_type, "autofs");
#line 328
        tmp___6 = tmp___9;
      }
    } else {
#line 328
      tmp___9 = __builtin_strcmp((char const   *)mnt->fs_type, "autofs");
#line 328
      tmp___6 = tmp___9;
    }
#line 328
    if (tmp___6) {
#line 329
      rv = spawn_umount(log_debug, "-l", mnt->path, (void *)0);
    } else {
#line 331
      rv = umount2((char const   *)mnt->path, 2);
    }
#line 332
    if (rv == -1) {
#line 333
      ret = 0;
#line 334
      while (1) {
#line 334
        ((*log_debug))(ap->logopt, "%s: can\'t unlink %s from mount tree", "unlink_mount_tree",
                       mnt->path);
#line 334
        break;
      }
#line 337
      tmp___11 = __errno_location();
#line 337
      switch ((*tmp___11)) {
      case 22: 
#line 339
      while (1) {
#line 339
        ((*log_warn))(ap->logopt, "%s: bad superblock or not mounted", "unlink_mount_tree");
#line 339
        break;
      }
#line 341
      break;
      case 2: 
      case 14: 
#line 345
      while (1) {
#line 345
        ((*log_warn))(ap->logopt, "%s: bad path for mount", "unlink_mount_tree");
#line 345
        break;
      }
#line 346
      break;
      }
    }
    __Cont: /* CIL Label */ 
#line 320
    p = p->next;
  }
#line 350
  return (ret);
}
}
#line 353 "direct.c"
int do_mount_autofs_direct(struct autofs_point *ap , struct mnt_list *mnts , struct mapent *me ) 
{ struct mnt_params *mp ;
  time_t timeout ;
  struct stat st ;
  int status ;
  int ret ;
  int ioctlfd ;
  int cl_flags ;
  struct list_head list ;
  char const   *map_name ;
  time_t tout ;
  int save_ioctlfd ;
  int ioctlfd___0 ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;

  {
#line 356
  timeout = ap->exp_timeout;
#line 362
  while (1) {
#line 362
    list.next = & list;
#line 362
    list.prev = & list;
#line 362
    break;
  }
#line 364
  tmp___1 = tree_get_mnt_list(mnts, & list, (char const   *)me->key, 1);
#line 364
  if (tmp___1) {
#line 365
    if ((int )ap->state == 4) {
#line 366
      tout = ap->exp_timeout;
#line 369
      ioctlfd___0 = me->ioctlfd;
#line 369
      save_ioctlfd = ioctlfd___0;
#line 371
      if (ioctlfd___0 == -1) {
#line 372
        ioctlfd___0 = open((char const   *)me->key, 0);
#line 373
        if (ioctlfd___0 != -1) {
#line 374
          cl_flags = fcntl(ioctlfd___0, 1, 0);
#line 375
          if (cl_flags != -1) {
#line 376
            cl_flags |= 1;
#line 377
            fcntl(ioctlfd___0, 2, cl_flags);
          }
        }
      }
#line 382
      if (ioctlfd___0 < 0) {
#line 383
        while (1) {
#line 383
          ((*log_error))(ap->logopt, "%s: failed to create ioctl fd for %s", "do_mount_autofs_direct",
                         me->key);
#line 383
          break;
        }
#line 386
        return (0);
      }
#line 389
      if (sizeof(unsigned long ) == sizeof(unsigned long [1])) {
#line 389
        if (sizeof(unsigned long ) < 16384U) {
#line 389
          tmp = sizeof(unsigned long );
        } else {
#line 389
          tmp = __invalid_size_argument_for_IOC;
        }
      } else {
#line 389
        tmp = __invalid_size_argument_for_IOC;
      }
#line 389
      ioctl(ioctlfd___0, (unsigned long )(3221263204U | (tmp << 16)), & tout);
#line 391
      if (save_ioctlfd == -1) {
#line 392
        close(ioctlfd___0);
      }
#line 394
      return (0);
    }
#line 396
    tmp___0 = unlink_mount_tree___0(ap, & list);
#line 396
    if (! tmp___0) {
#line 397
      while (1) {
#line 397
        ((*log_debug))(ap->logopt, "%s: already mounted as other than autofs or failed to unlink entry in tree",
                       "do_mount_autofs_direct");
#line 397
        break;
      }
#line 400
      return (-1);
    }
  }
#line 404
  if (me->ioctlfd != -1) {
#line 405
    while (1) {
#line 405
      ((*log_error))(ap->logopt, "%s: active direct mount %s", "do_mount_autofs_direct",
                     me->key);
#line 405
      break;
    }
#line 406
    return (-1);
  }
#line 409
  status = pthread_once(& key_mnt_params_once, & key_mnt_params_init);
#line 410
  if (status) {
#line 411
    while (1) {
#line 411
      if (status == 35) {
#line 411
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "do_mount_autofs_direct", 411, "direct.c");
#line 411
        dump_core();
      }
#line 411
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 411,
                    "direct.c");
#line 411
      abort();
#line 411
      break;
    }
  }
#line 413
  mp = (struct mnt_params *)pthread_getspecific(key_mnt_direct_params);
#line 414
  if (! mp) {
#line 415
    mp = (struct mnt_params *)malloc(sizeof(struct mnt_params ));
#line 416
    if (! mp) {
#line 417
      while (1) {
#line 417
        ((*log_crit))(ap->logopt, "%s: mnt_params value create failed for direct mount %s",
                      "do_mount_autofs_direct", ap->path);
#line 417
        break;
      }
#line 420
      return (0);
    }
#line 422
    mp->options = (char *)((void *)0);
#line 424
    status = pthread_setspecific(key_mnt_direct_params, (void const   *)mp);
#line 425
    if (status) {
#line 426
      free((void *)mp);
#line 427
      while (1) {
#line 427
        if (status == 35) {
#line 427
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "do_mount_autofs_direct", 427, "direct.c");
#line 427
          dump_core();
        }
#line 427
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 427,
                      "direct.c");
#line 427
        abort();
#line 427
        break;
      }
    }
  }
#line 431
  if (! mp->options) {
#line 432
    mp->options = make_options_string(ap->path, ap->kpipefd, (char *)"direct");
#line 433
    if (! mp->options) {
#line 434
      return (0);
    }
  }
#line 438
  tmp___5 = mkdir_path((char const   *)me->key, 365U);
#line 438
  if (tmp___5 < 0) {
#line 439
    tmp___3 = __errno_location();
#line 439
    if ((*tmp___3) != 17) {
#line 439
      tmp___4 = __errno_location();
#line 439
      if ((*tmp___4) != 30) {
#line 440
        while (1) {
#line 440
          ((*log_crit))(ap->logopt, "%s: failed to create mount directory %s", "do_mount_autofs_direct",
                        me->key);
#line 440
          break;
        }
#line 442
        return (-1);
      }
    }
#line 446
    me->dir_created = 0;
  } else {
#line 449
    me->dir_created = 1;
  }
#line 452
  map_name = (*(((me->mc)->map)->argv + 0));
#line 454
  ret = mount(map_name, (char const   *)me->key, "autofs", 3236757504UL, (void const   *)mp->options);
#line 455
  if (ret) {
#line 456
    while (1) {
#line 456
      ((*log_crit))(ap->logopt, "%s: failed to mount autofs path %s", "do_mount_autofs_direct",
                    me->key);
#line 456
      break;
    }
    goto out_err;
  }
#line 461
  ioctlfd = open((char const   *)me->key, 0);
#line 462
  if (ioctlfd < 0) {
#line 463
    while (1) {
#line 463
      ((*log_crit))(ap->logopt, "%s: failed to create ioctl fd for %s", "do_mount_autofs_direct",
                    me->key);
#line 463
      break;
    }
    goto out_umount;
  }
#line 467
  cl_flags = fcntl(ioctlfd, 1, 0);
#line 467
  if (cl_flags != -1) {
#line 468
    cl_flags |= 1;
#line 469
    fcntl(ioctlfd, 2, cl_flags);
  }
#line 473
  ap->exp_runfreq = ((timeout + 4L) - 1L) / 4L;
#line 475
  if (sizeof(unsigned long ) == sizeof(unsigned long [1])) {
#line 475
    if (sizeof(unsigned long ) < 16384U) {
#line 475
      tmp___6 = sizeof(unsigned long );
    } else {
#line 475
      tmp___6 = __invalid_size_argument_for_IOC;
    }
  } else {
#line 475
    tmp___6 = __invalid_size_argument_for_IOC;
  }
#line 475
  ioctl(ioctlfd, (unsigned long )(3221263204U | (tmp___6 << 16)), & timeout);
#line 477
  if (ap->exp_timeout) {
#line 478
    while (1) {
#line 478
      ((*log_info))(0U, "mounted direct mount on %s with timeout %u, freq %u seconds",
                    me->key, (unsigned int )ap->exp_timeout, (unsigned int )ap->exp_runfreq);
#line 478
      break;
    }
  } else {
#line 483
    while (1) {
#line 483
      ((*log_info))(0U, "mounted direct mount on %s with timeouts disabled", me->key);
#line 483
      break;
    }
  }
#line 486
  ret = fstat__extinline(ioctlfd, & st);
#line 487
  if (ret == -1) {
#line 488
    while (1) {
#line 488
      ((*log_error))(ap->logopt, "%s: failed to stat direct mount trigger %s", "do_mount_autofs_direct",
                     me->key);
#line 488
      break;
    }
    goto out_close;
  }
#line 492
  cache_set_ino_index(me->mc, (char const   *)me->key, st.st_dev, st.st_ino);
#line 494
  close(ioctlfd);
#line 496
  while (1) {
#line 496
    ((*log_debug))(ap->logopt, "%s: mounted trigger %s", "do_mount_autofs_direct",
                   me->key);
#line 496
    break;
  }
#line 498
  return (0);
  out_close: 
#line 501
  close(ioctlfd);
  out_umount: 
#line 504
  umount((char const   *)me->key);
  out_err: 
#line 506
  if (me->dir_created) {
#line 507
    rmdir((char const   *)me->key);
  }
#line 509
  return (-1);
}
}
#line 512 "direct.c"
int mount_autofs_direct(struct autofs_point *ap ) 
{ struct map_source *map ;
  struct mapent_cache *nc ;
  struct mapent_cache *mc ;
  struct mapent *me ;
  struct mapent *ne ;
  struct mapent *nested ;
  struct mnt_list *mnts ;
  time_t now ;
  time_t tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___12 ;
  long tmp___13 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___0)(void * ) ;
  void *__cancel_arg___0 ;
  int not_first_call___0 ;
  int tmp___14 ;
  long tmp___15 ;
  __pthread_unwind_buf_t __cancel_buf___1 ;
  void (*__cancel_routine___1)(void * ) ;
  void *__cancel_arg___1 ;
  int not_first_call___1 ;
  int tmp___16 ;
  long tmp___17 ;
  __pthread_unwind_buf_t __cancel_buf___2 ;
  void (*__cancel_routine___2)(void * ) ;
  void *__cancel_arg___2 ;
  int not_first_call___2 ;
  int tmp___18 ;
  long tmp___19 ;

  {
#line 518
  tmp = time((time_t *)((void *)0));
#line 518
  now = tmp;
#line 520
  if (0) {
#line 520
    __s1_len = strlen((char const   *)ap->path);
#line 520
    __s2_len = strlen("/-");
#line 520
    if (! ((unsigned int )((void const   *)(ap->path + 1)) - (unsigned int )((void const   *)ap->path) == 1U)) {
      goto _L___0;
    } else {
#line 520
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 520
        if (! ((unsigned int )((void const   *)("/-" + 1)) - (unsigned int )((void const   *)"/-") == 1U)) {
#line 520
          tmp___9 = 1;
        } else {
#line 520
          if (__s2_len >= 4U) {
#line 520
            tmp___9 = 1;
          } else {
#line 520
            tmp___9 = 0;
          }
        }
      } else {
#line 520
        tmp___9 = 0;
      }
    }
#line 520
    if (tmp___9) {
#line 520
      tmp___5 = __builtin_strcmp((char const   *)ap->path, "/-");
    } else {
#line 520
      tmp___8 = __builtin_strcmp((char const   *)ap->path, "/-");
#line 520
      tmp___5 = tmp___8;
    }
  } else {
#line 520
    tmp___8 = __builtin_strcmp((char const   *)ap->path, "/-");
#line 520
    tmp___5 = tmp___8;
  }
#line 520
  if (tmp___5) {
#line 521
    while (1) {
#line 521
      ((*log_error))(ap->logopt, "%s: expected direct map, exiting", "mount_autofs_direct");
#line 521
      break;
    }
#line 522
    return (-1);
  }
#line 525
  tmp___10 = autofs_init_direct(ap);
#line 525
  if (tmp___10) {
#line 526
    return (-1);
  }
#line 529
  tmp___11 = lookup_nss_read_map(ap, (struct map_source *)((void *)0), now);
#line 529
  if (tmp___11) {
#line 530
    lookup_prune_cache(ap, now);
  } else {
#line 532
    while (1) {
#line 532
      ((*log_error))(ap->logopt, "%s: failed to read direct map", "mount_autofs_direct");
#line 532
      break;
    }
#line 533
    return (-1);
  }
#line 536
  mnts = tree_make_mnt_tree("/proc/mounts", "/");
#line 537
  while (1) {
#line 537
    __cancel_routine = & mnts_cleanup___0;
#line 537
    __cancel_arg = (void *)mnts;
#line 537
    tmp___12 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                           0);
#line 537
    not_first_call = tmp___12;
#line 537
    tmp___13 = __builtin_expect((long )not_first_call, 0L);
#line 537
    if (tmp___13) {
#line 537
      ((*__cancel_routine))(__cancel_arg);
#line 537
      __pthread_unwind_next(& __cancel_buf);
    }
#line 537
    __pthread_register_cancel(& __cancel_buf);
#line 537
    while (1) {
#line 538
      while (1) {
#line 538
        __cancel_routine___0 = & master_source_lock_cleanup;
#line 538
        __cancel_arg___0 = (void *)ap->entry;
#line 538
        tmp___14 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf),
                               0);
#line 538
        not_first_call___0 = tmp___14;
#line 538
        tmp___15 = __builtin_expect((long )not_first_call___0, 0L);
#line 538
        if (tmp___15) {
#line 538
          ((*__cancel_routine___0))(__cancel_arg___0);
#line 538
          __pthread_unwind_next(& __cancel_buf___0);
        }
#line 538
        __pthread_register_cancel(& __cancel_buf___0);
#line 538
        while (1) {
#line 539
          master_source_readlock(ap->entry);
#line 540
          nc = ((ap->entry)->master)->nc;
#line 541
          cache_readlock(nc);
#line 542
          while (1) {
#line 542
            __cancel_routine___1 = & cache_lock_cleanup;
#line 542
            __cancel_arg___1 = (void *)nc;
#line 542
            tmp___16 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___1.__cancel_jmp_buf),
                                   0);
#line 542
            not_first_call___1 = tmp___16;
#line 542
            tmp___17 = __builtin_expect((long )not_first_call___1, 0L);
#line 542
            if (tmp___17) {
#line 542
              ((*__cancel_routine___1))(__cancel_arg___1);
#line 542
              __pthread_unwind_next(& __cancel_buf___1);
            }
#line 542
            __pthread_register_cancel(& __cancel_buf___1);
#line 542
            while (1) {
#line 543
              map = (ap->entry)->maps;
#line 544
              while (map) {
#line 549
                if ((ap->entry)->age > map->age) {
#line 550
                  map = map->next;
#line 551
                  continue;
                }
#line 554
                mc = map->mc;
#line 555
                while (1) {
#line 555
                  __cancel_routine___2 = & cache_lock_cleanup;
#line 555
                  __cancel_arg___2 = (void *)mc;
#line 555
                  tmp___18 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___2.__cancel_jmp_buf),
                                         0);
#line 555
                  not_first_call___2 = tmp___18;
#line 555
                  tmp___19 = __builtin_expect((long )not_first_call___2, 0L);
#line 555
                  if (tmp___19) {
#line 555
                    ((*__cancel_routine___2))(__cancel_arg___2);
#line 555
                    __pthread_unwind_next(& __cancel_buf___2);
                  }
#line 555
                  __pthread_register_cancel(& __cancel_buf___2);
#line 555
                  while (1) {
#line 556
                    cache_readlock(mc);
#line 557
                    me = cache_enumerate(mc, (struct mapent *)((void *)0));
#line 558
                    while (me) {
#line 559
                      ne = cache_lookup_distinct(nc, (char const   *)me->key);
#line 560
                      if (ne) {
#line 561
                        if ((unsigned long )map->master_line < (unsigned long )ne->age) {
#line 563
                          do_mount_autofs_direct(ap, mnts, me);
                        }
#line 565
                        me = cache_enumerate(mc, me);
#line 566
                        continue;
                      }
#line 569
                      nested = cache_partial_match(nc, (char const   *)me->key);
#line 570
                      if (nested) {
#line 571
                        while (1) {
#line 571
                          ((*log_error))(ap->logopt, "%s: removing invalid nested null entry %s",
                                         "mount_autofs_direct", nested->key);
#line 571
                          break;
                        }
#line 574
                        nested = cache_partial_match(nc, (char const   *)me->key);
#line 575
                        if (nested) {
#line 576
                          cache_delete(nc, (char const   *)nested->key);
                        }
                      }
#line 580
                      do_mount_autofs_direct(ap, mnts, me);
#line 582
                      me = cache_enumerate(mc, me);
                    }
#line 555
                    break;
                  }
#line 584
                  __pthread_unregister_cancel(& __cancel_buf___2);
#line 584
                  ((*__cancel_routine___2))(__cancel_arg___2);
#line 555
                  break;
                }
#line 585
                map = map->next;
              }
#line 542
              break;
            }
#line 587
            __pthread_unregister_cancel(& __cancel_buf___1);
#line 587
            ((*__cancel_routine___1))(__cancel_arg___1);
#line 542
            break;
          }
#line 538
          break;
        }
#line 588
        __pthread_unregister_cancel(& __cancel_buf___0);
#line 588
        ((*__cancel_routine___0))(__cancel_arg___0);
#line 538
        break;
      }
#line 537
      break;
    }
#line 589
    __pthread_unregister_cancel(& __cancel_buf);
#line 589
    ((*__cancel_routine))(__cancel_arg);
#line 537
    break;
  }
#line 591
  return (0);
}
}
#line 594 "direct.c"
int umount_autofs_offset(struct autofs_point *ap , struct mapent *me ) 
{ char buf[128] ;
  int ioctlfd ;
  int cl_flags ;
  int rv ;
  int retries ;
  int tmp ;
  int status ;
  unsigned int tmp___0 ;
  char *estr ;
  int *tmp___1 ;
  char *tmp___2 ;
  struct stat st ;
  char *estr___0 ;
  int save_errno ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  struct timespec tm ;
  int *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;

  {
#line 597
  rv = 1;
#line 599
  if (me->ioctlfd != -1) {
#line 600
    tmp = is_mounted("/etc/mtab", (char const   *)me->key, 2U);
#line 600
    if (tmp) {
#line 601
      while (1) {
#line 601
        ((*log_error))(ap->logopt, "%s: attempt to umount busy offset %s", "umount_autofs_offset",
                       me->key);
#line 601
        break;
      }
#line 603
      return (1);
    }
#line 605
    ioctlfd = me->ioctlfd;
  } else {
#line 607
    ioctlfd = open((char const   *)me->key, 0);
#line 608
    if (ioctlfd != -1) {
#line 609
      cl_flags = fcntl(ioctlfd, 1, 0);
#line 609
      if (cl_flags != -1) {
#line 610
        cl_flags |= 1;
#line 611
        fcntl(ioctlfd, 2, cl_flags);
      }
    }
  }
#line 616
  if (ioctlfd >= 0) {
#line 617
    status = 1;
#line 619
    if (sizeof(int ) == sizeof(int [1])) {
#line 619
      if (sizeof(int ) < 16384U) {
#line 619
        tmp___0 = sizeof(int );
      } else {
#line 619
        tmp___0 = __invalid_size_argument_for_IOC;
      }
    } else {
#line 619
      tmp___0 = __invalid_size_argument_for_IOC;
    }
#line 619
    rv = ioctl(ioctlfd, (unsigned long )(2147521392U | (tmp___0 << 16)), & status);
#line 620
    if (rv) {
#line 621
      tmp___1 = __errno_location();
#line 621
      tmp___2 = strerror_r((*tmp___1), buf, 128U);
#line 621
      estr = tmp___2;
#line 622
      while (1) {
#line 622
        ((*log_error))(ap->logopt, "%s: ioctl failed: %s", "umount_autofs_offset",
                       estr);
#line 622
        break;
      }
#line 623
      return (1);
    } else {
#line 624
      if (! status) {
#line 625
        if ((int )ap->state != 6) {
#line 626
          while (1) {
#line 626
            ((*log_error))(ap->logopt, "%s: ask umount returned busy for %s", "umount_autofs_offset",
                           me->key);
#line 626
            break;
          }
#line 629
          return (1);
        } else {
#line 631
          me->ioctlfd = -1;
#line 632
          ioctl(ioctlfd, 37730UL, 0);
#line 633
          close(ioctlfd);
          goto force_umount;
        }
      }
    }
#line 637
    me->ioctlfd = -1;
#line 638
    ioctl(ioctlfd, 37730UL, 0);
#line 639
    close(ioctlfd);
  } else {
#line 643
    tmp___3 = __errno_location();
#line 643
    save_errno = (*tmp___3);
#line 646
    tmp___4 = stat__extinline((char const   *)me->key, & st);
#line 646
    if (tmp___4 == -1) {
#line 646
      tmp___5 = __errno_location();
#line 646
      if ((*tmp___5) == 2) {
#line 647
        return (0);
      }
    }
#line 649
    estr___0 = strerror_r(save_errno, buf, 128U);
#line 650
    while (1) {
#line 650
      ((*log_error))(ap->logopt, "%s: couldn\'t get ioctl fd for offset %s: %s", "umount_autofs_offset",
                     me->key, estr___0);
#line 650
      break;
    }
    goto force_umount;
  }
#line 656
  sched_yield();
#line 658
  retries = 8;
#line 659
  while (1) {
#line 659
    rv = umount((char const   *)me->key);
#line 659
    if (rv == -1) {
#line 659
      tmp___7 = retries;
#line 659
      retries --;
#line 659
      if (! tmp___7) {
#line 659
        break;
      }
    } else {
#line 659
      break;
    }
#line 660
    tm.tv_sec = (__time_t )0;
#line 660
    tm.tv_nsec = 100000000L;
#line 661
    tmp___6 = __errno_location();
#line 661
    if ((*tmp___6) != 16) {
#line 662
      break;
    }
#line 663
    nanosleep((struct timespec  const  *)(& tm), (struct timespec *)((void *)0));
  }
#line 666
  if (rv == -1) {
#line 667
    tmp___8 = __errno_location();
#line 667
    switch ((*tmp___8)) {
    case 2: 
#line 669
    while (1) {
#line 669
      ((*log_warn))(ap->logopt, "%s: mount point does not exist", "umount_autofs_offset");
#line 669
      break;
    }
#line 670
    return (0);
#line 671
    break;
    case 16: 
#line 673
    while (1) {
#line 673
      ((*log_error))(ap->logopt, "%s: mount point %s is in use", "umount_autofs_offset",
                     me->key);
#line 673
      break;
    }
#line 674
    if ((int )ap->state != 6) {
#line 675
      return (1);
    }
#line 676
    break;
    case 20: 
#line 678
    while (1) {
#line 678
      ((*log_error))(ap->logopt, "%s: mount point is not a directory", "umount_autofs_offset");
#line 678
      break;
    }
#line 679
    return (0);
#line 680
    break;
    }
    goto force_umount;
  }
  force_umount: 
#line 686
  if (rv != 0) {
#line 687
    while (1) {
#line 687
      ((*log_info))(0U, "forcing umount of offset mount %s", me->key);
#line 687
      break;
    }
#line 688
    rv = umount2((char const   *)me->key, 2);
  } else {
#line 690
    while (1) {
#line 690
      ((*log_info))(0U, "umounted offset mount %s", me->key);
#line 690
      break;
    }
  }
#line 692
  return (rv);
}
}
#line 695 "direct.c"
int mount_autofs_offset(struct autofs_point *ap , struct mapent *me , int is_autofs_fs ) 
{ struct mnt_params *mp ;
  time_t timeout ;
  struct stat st ;
  int ioctlfd ;
  int cl_flags ;
  int status ;
  int ret ;
  char const   *type ;
  char const   *map_name ;
  int tmp ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___13 ;
  int tmp___16 ;
  int tmp___17 ;
  unsigned int tmp___18 ;
  int tmp___19 ;

  {
#line 698
  timeout = ap->exp_timeout;
#line 701
  map_name = (char const   *)((void *)0);
#line 703
  tmp = is_mounted("/proc/mounts", (char const   *)me->key, 4U);
#line 703
  if (tmp) {
#line 704
    if ((int )ap->state != 4) {
#line 705
      while (1) {
#line 705
        ((*log_warn))(ap->logopt, "%s: trigger %s already mounted", "mount_autofs_offset",
                      me->key);
#line 705
        break;
      }
    }
#line 707
    return (0);
  }
#line 710
  if (me->ioctlfd != -1) {
#line 711
    while (1) {
#line 711
      ((*log_error))(ap->logopt, "%s: active offset mount %s", "mount_autofs_offset",
                     me->key);
#line 711
      break;
    }
#line 712
    return (-1);
  }
#line 715
  status = pthread_once(& key_mnt_params_once, & key_mnt_params_init);
#line 716
  if (status) {
#line 717
    while (1) {
#line 717
      if (status == 35) {
#line 717
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "mount_autofs_offset", 717, "direct.c");
#line 717
        dump_core();
      }
#line 717
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 717,
                    "direct.c");
#line 717
      abort();
#line 717
      break;
    }
  }
#line 719
  mp = (struct mnt_params *)pthread_getspecific(key_mnt_offset_params);
#line 720
  if (! mp) {
#line 721
    mp = (struct mnt_params *)malloc(sizeof(struct mnt_params ));
#line 722
    if (! mp) {
#line 723
      while (1) {
#line 723
        ((*log_crit))(ap->logopt, "%s: mnt_params value create failed for offset mount %s",
                      "mount_autofs_offset", me->key);
#line 723
        break;
      }
#line 726
      return (0);
    }
#line 728
    mp->options = (char *)((void *)0);
#line 730
    status = pthread_setspecific(key_mnt_offset_params, (void const   *)mp);
#line 731
    if (status) {
#line 732
      free((void *)mp);
#line 733
      while (1) {
#line 733
        if (status == 35) {
#line 733
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "mount_autofs_offset", 733, "direct.c");
#line 733
          dump_core();
        }
#line 733
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 733,
                      "direct.c");
#line 733
        abort();
#line 733
        break;
      }
    }
  }
#line 737
  if (! mp->options) {
#line 738
    mp->options = make_options_string(ap->path, ap->kpipefd, (char *)"offset");
#line 739
    if (! mp->options) {
#line 740
      return (0);
    }
  }
#line 743
  if (is_autofs_fs) {
#line 745
    tmp___3 = mkdir_path((char const   *)me->key, 365U);
#line 745
    if (tmp___3 < 0) {
#line 746
      tmp___2 = __errno_location();
#line 746
      if ((*tmp___2) != 17) {
#line 747
        while (1) {
#line 747
          tmp___1 = __errno_location();
#line 747
          ((*log_crit))(ap->logopt, "%s: failed to create mount directory %s %d",
                        "mount_autofs_offset", me->key, (*tmp___1));
#line 747
          break;
        }
#line 750
        return (-1);
      }
#line 756
      me->dir_created = 0;
    } else {
#line 759
      me->dir_created = 1;
    }
  } else {
#line 762
    me->dir_created = 0;
#line 771
    tmp___4 = stat__extinline((char const   *)me->key, & st);
#line 771
    if (tmp___4 == -1) {
#line 771
      tmp___5 = __errno_location();
#line 771
      if ((*tmp___5) == 2) {
#line 772
        return (0);
      }
    }
  }
#line 775
  while (1) {
#line 775
    ((*log_debug))(ap->logopt, "%s: calling mount -t autofs -s  -o %s automount %s",
                   "mount_autofs_offset", mp->options, me->key);
#line 775
    break;
  }
#line 779
  type = (char const   *)((ap->entry)->maps)->type;
#line 780
  if (type) {
#line 780
    if (0) {
#line 780
      __s1_len = strlen((char const   *)((ap->entry)->maps)->type);
#line 780
      __s2_len = strlen("hosts");
#line 780
      if (! ((unsigned int )((void const   *)(((ap->entry)->maps)->type + 1)) - (unsigned int )((void const   *)((ap->entry)->maps)->type) == 1U)) {
        goto _L___0;
      } else {
#line 780
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 780
          if (! ((unsigned int )((void const   *)("hosts" + 1)) - (unsigned int )((void const   *)"hosts") == 1U)) {
#line 780
            tmp___17 = 1;
          } else {
#line 780
            if (__s2_len >= 4U) {
#line 780
              tmp___17 = 1;
            } else {
#line 780
              tmp___17 = 0;
            }
          }
        } else {
#line 780
          tmp___17 = 0;
        }
      }
#line 780
      if (tmp___17) {
#line 780
        tmp___13 = __builtin_strcmp((char const   *)((ap->entry)->maps)->type, "hosts");
      } else {
#line 780
        tmp___16 = __builtin_strcmp((char const   *)((ap->entry)->maps)->type, "hosts");
#line 780
        tmp___13 = tmp___16;
      }
    } else {
#line 780
      tmp___16 = __builtin_strcmp((char const   *)((ap->entry)->maps)->type, "hosts");
#line 780
      tmp___13 = tmp___16;
    }
#line 780
    if (tmp___13) {
#line 787
      map_name = (*(((me->mc)->map)->argv + 0));
    } else {
#line 781
      tmp___7 = (char *)__builtin_alloca(7U);
#line 781
      tmp___6 = tmp___7;
#line 782
      if (tmp___6) {
#line 783
        strcpy((char * __restrict  )tmp___6, (char const   * __restrict  )"-hosts");
#line 784
        map_name = (char const   *)tmp___6;
      }
    }
  } else {
#line 787
    map_name = (*(((me->mc)->map)->argv + 0));
  }
#line 789
  ret = mount(map_name, (char const   *)me->key, "autofs", 3236757504UL, (void const   *)mp->options);
#line 790
  if (ret) {
#line 791
    while (1) {
#line 791
      ((*log_crit))(ap->logopt, "%s: failed to mount autofs path %s", "mount_autofs_offset",
                    me->key);
#line 791
      break;
    }
    goto out_err;
  }
#line 795
  if (ret != 0) {
#line 796
    while (1) {
#line 796
      ((*log_crit))(ap->logopt, "%s: failed to mount autofs offset trigger %s", "mount_autofs_offset",
                    me->key);
#line 796
      break;
    }
    goto out_err;
  }
#line 802
  ioctlfd = open((char const   *)me->key, 0);
#line 803
  if (ioctlfd < 0) {
#line 804
    while (1) {
#line 804
      ((*log_crit))(ap->logopt, "%s: failed to create ioctl fd for %s", "mount_autofs_offset",
                    me->key);
#line 804
      break;
    }
    goto out_umount;
  }
#line 808
  cl_flags = fcntl(ioctlfd, 1, 0);
#line 808
  if (cl_flags != -1) {
#line 809
    cl_flags |= 1;
#line 810
    fcntl(ioctlfd, 2, cl_flags);
  }
#line 813
  if (sizeof(unsigned long ) == sizeof(unsigned long [1])) {
#line 813
    if (sizeof(unsigned long ) < 16384U) {
#line 813
      tmp___18 = sizeof(unsigned long );
    } else {
#line 813
      tmp___18 = __invalid_size_argument_for_IOC;
    }
  } else {
#line 813
    tmp___18 = __invalid_size_argument_for_IOC;
  }
#line 813
  ioctl(ioctlfd, (unsigned long )(3221263204U | (tmp___18 << 16)), & timeout);
#line 815
  ret = fstat__extinline(ioctlfd, & st);
#line 816
  if (ret == -1) {
#line 817
    while (1) {
#line 817
      ((*log_error))(ap->logopt, "%s: failed to stat direct mount trigger %s", "mount_autofs_offset",
                     me->key);
#line 817
      break;
    }
    goto out_close;
  }
#line 822
  cache_set_ino_index(me->mc, (char const   *)me->key, st.st_dev, st.st_ino);
#line 824
  close(ioctlfd);
#line 826
  while (1) {
#line 826
    ((*log_debug))(ap->logopt, "%s: mounted trigger %s", "mount_autofs_offset", me->key);
#line 826
    break;
  }
#line 828
  return (0);
  out_close: 
#line 831
  close(ioctlfd);
  out_umount: 
#line 833
  umount((char const   *)me->key);
  out_err: 
#line 835
  if (is_autofs_fs) {
#line 836
    tmp___19 = stat__extinline((char const   *)me->key, & st);
#line 836
    if (tmp___19 == 0) {
#line 836
      if (me->dir_created) {
#line 837
        rmdir_path(ap, (char const   *)me->key, st.st_dev);
      }
    }
  }
#line 840
  return (-1);
}
}
#line 843 "direct.c"
static int expire_direct(int ioctlfd , char const   *path , unsigned int when , unsigned int logopt ) 
{ char buf[128] ;
  int ret ;
  int retries ;
  struct stat st ;
  char *estr ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct timespec tm ;
  unsigned int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  unsigned int tmp___8 ;
  int tmp___9 ;

  {
#line 849
  tmp___1 = fstat__extinline(ioctlfd, & st);
#line 849
  if (tmp___1 == -1) {
#line 850
    tmp = __errno_location();
#line 850
    tmp___0 = strerror_r((*tmp), buf, 128U);
#line 850
    estr = tmp___0;
#line 851
    while (1) {
#line 851
      ((*log_error))(logopt, "%s: fstat failed: %s", "expire_direct", estr);
#line 851
      break;
    }
#line 852
    return (0);
  }
#line 855
  tmp___2 = count_mounts(path, st.st_dev);
#line 855
  retries = (tmp___2 + 1) * 3;
#line 857
  while (1) {
#line 857
    tmp___7 = retries;
#line 857
    retries --;
#line 857
    if (! tmp___7) {
#line 857
      break;
    }
#line 858
    tm.tv_sec = (__time_t )0;
#line 858
    tm.tv_nsec = 100000000L;
#line 861
    if (sizeof(int ) == sizeof(int [1])) {
#line 861
      if (sizeof(int ) < 16384U) {
#line 861
        tmp___3 = sizeof(int );
      } else {
#line 861
        tmp___3 = __invalid_size_argument_for_IOC;
      }
    } else {
#line 861
      tmp___3 = __invalid_size_argument_for_IOC;
    }
#line 861
    ret = ioctl(ioctlfd, (unsigned long )(1073779558U | (tmp___3 << 16)), & when);
#line 862
    if (ret == -1) {
#line 864
      tmp___4 = __errno_location();
#line 864
      if ((*tmp___4) == 9) {
#line 865
        return (1);
      } else {
#line 864
        tmp___5 = __errno_location();
#line 864
        if ((*tmp___5) == 22) {
#line 865
          return (1);
        }
      }
#line 868
      tmp___6 = __errno_location();
#line 868
      if ((*tmp___6) != 11) {
#line 869
        return (0);
      }
    }
#line 872
    nanosleep((struct timespec  const  *)(& tm), (struct timespec *)((void *)0));
  }
#line 875
  if (sizeof(int ) == sizeof(int [1])) {
#line 875
    if (sizeof(int ) < 16384U) {
#line 875
      tmp___8 = sizeof(int );
    } else {
#line 875
      tmp___8 = __invalid_size_argument_for_IOC;
    }
  } else {
#line 875
    tmp___8 = __invalid_size_argument_for_IOC;
  }
#line 875
  tmp___9 = ioctl(ioctlfd, (unsigned long )(2147521392U | (tmp___8 << 16)), & ret);
#line 875
  if (! tmp___9) {
#line 876
    if (! ret) {
#line 877
      return (0);
    }
  }
#line 880
  return (1);
}
}
#line 883 "direct.c"
void *expire_proc_direct(void *arg ) 
{ struct mnt_list *mnts ;
  struct mnt_list *next ;
  struct list_head list ;
  struct list_head *p ;
  struct expire_args *ea ;
  struct expire_args ec ;
  struct autofs_point *ap ;
  struct mapent *me ;
  unsigned int now ;
  int ioctlfd ;
  int cur_state ;
  int status ;
  int ret ;
  int left ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___0)(void * ) ;
  void *__cancel_arg___0 ;
  int not_first_call___0 ;
  int tmp___2 ;
  long tmp___3 ;
  struct stat st ;
  struct statfs fs ;
  int ioctlfd___0 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 885
  mnts = (struct mnt_list *)((void *)0);
#line 890
  me = (struct mapent *)((void *)0);
#line 895
  ea = (struct expire_args *)arg;
#line 897
  status = pthread_mutex_lock(& ea->mutex);
#line 898
  if (status) {
#line 899
    while (1) {
#line 899
      if (status == 35) {
#line 899
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "expire_proc_direct", 899, "direct.c");
#line 899
        dump_core();
      }
#line 899
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 899,
                    "direct.c");
#line 899
      abort();
#line 899
      break;
    }
  }
#line 901
  ec.ap = ea->ap;
#line 901
  ap = ec.ap;
#line 902
  now = ea->when;
#line 903
  ec.status = -1;
#line 905
  ea->signaled = 1U;
#line 906
  status = pthread_cond_signal(& ea->cond);
#line 907
  if (status) {
#line 908
    while (1) {
#line 908
      if (status == 35) {
#line 908
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "expire_proc_direct", 908, "direct.c");
#line 908
        dump_core();
      }
#line 908
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 908,
                    "direct.c");
#line 908
      abort();
#line 908
      break;
    }
  }
#line 910
  status = pthread_mutex_unlock(& ea->mutex);
#line 911
  if (status) {
#line 912
    while (1) {
#line 912
      if (status == 35) {
#line 912
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "expire_proc_direct", 912, "direct.c");
#line 912
        dump_core();
      }
#line 912
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 912,
                    "direct.c");
#line 912
      abort();
#line 912
      break;
    }
  }
#line 914
  while (1) {
#line 914
    __cancel_routine = & expire_cleanup;
#line 914
    __cancel_arg = (void *)(& ec);
#line 914
    tmp = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf), 0);
#line 914
    not_first_call = tmp;
#line 914
    tmp___0 = __builtin_expect((long )not_first_call, 0L);
#line 914
    if (tmp___0) {
#line 914
      ((*__cancel_routine))(__cancel_arg);
#line 914
      __pthread_unwind_next(& __cancel_buf);
    }
#line 914
    __pthread_register_cancel(& __cancel_buf);
#line 914
    while (1) {
#line 916
      left = 0;
#line 918
      mnts = tree_make_mnt_tree("/proc/mounts", "/");
#line 921
      while (1) {
#line 921
        list.next = & list;
#line 921
        list.prev = & list;
#line 921
        break;
      }
#line 922
      tmp___1 = tree_get_mnt_list(mnts, & list, "/", 0);
#line 922
      if (! tmp___1) {
#line 923
        ec.status = 0;
#line 924
        return ((void *)0);
      }
#line 926
      while (1) {
#line 926
        __cancel_routine___0 = & mnts_cleanup___0;
#line 926
        __cancel_arg___0 = (void *)mnts;
#line 926
        tmp___2 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf),
                              0);
#line 926
        not_first_call___0 = tmp___2;
#line 926
        tmp___3 = __builtin_expect((long )not_first_call___0, 0L);
#line 926
        if (tmp___3) {
#line 926
          ((*__cancel_routine___0))(__cancel_arg___0);
#line 926
          __pthread_unwind_next(& __cancel_buf___0);
        }
#line 926
        __pthread_register_cancel(& __cancel_buf___0);
#line 926
        while (1) {
#line 928
          p = list.next;
#line 928
          while ((unsigned int )p != (unsigned int )(& list)) {
#line 929
            next = (struct mnt_list *)((char *)p - (unsigned long )(& ((struct mnt_list *)0)->list));
#line 935
            me = lookup_source_mapent(ap, (char const   *)next->path, 8192U);
#line 936
            if (! me) {
              goto __Cont;
            }
#line 939
            if (0) {
#line 939
              __s1_len = strlen((char const   *)next->fs_type);
#line 939
              __s2_len = strlen("autofs");
#line 939
              if (! ((unsigned int )((void const   *)(next->fs_type + 1)) - (unsigned int )((void const   *)next->fs_type) == 1U)) {
                goto _L___0;
              } else {
#line 939
                if (__s1_len >= 4U) {
                  _L___0: /* CIL Label */ 
#line 939
                  if (! ((unsigned int )((void const   *)("autofs" + 1)) - (unsigned int )((void const   *)"autofs") == 1U)) {
#line 939
                    tmp___18 = 1;
                  } else {
#line 939
                    if (__s2_len >= 4U) {
#line 939
                      tmp___18 = 1;
                    } else {
#line 939
                      tmp___18 = 0;
                    }
                  }
                } else {
#line 939
                  tmp___18 = 0;
                }
              }
#line 939
              if (tmp___18) {
#line 939
                tmp___14 = __builtin_strcmp((char const   *)next->fs_type, "autofs");
              } else {
#line 939
                tmp___17 = __builtin_strcmp((char const   *)next->fs_type, "autofs");
#line 939
                tmp___14 = tmp___17;
              }
            } else {
#line 939
              tmp___17 = __builtin_strcmp((char const   *)next->fs_type, "autofs");
#line 939
              tmp___14 = tmp___17;
            }
#line 939
            if (! tmp___14) {
#line 944
              cache_unlock(me->mc);
#line 950
              pthread_setcancelstate(1, & cur_state);
#line 951
              tmp___4 = strstr((char const   *)next->opts, "indirect");
#line 951
              if (tmp___4) {
#line 952
                master_notify_submount(ap, (char const   *)next->path, ap->state);
#line 953
                pthread_setcancelstate(cur_state, (int *)((void *)0));
                goto __Cont;
              }
#line 957
              if (me->ioctlfd == -1) {
#line 958
                pthread_setcancelstate(cur_state, (int *)((void *)0));
                goto __Cont;
              }
#line 962
              tmp___5 = statfs((char const   *)next->path, & fs);
#line 962
              if (tmp___5 == -1) {
#line 963
                pthread_setcancelstate(cur_state, (int *)((void *)0));
#line 964
                while (1) {
#line 964
                  ((*log_warn))(ap->logopt, "%s: fstatfs failed for %s", "expire_proc_direct",
                                next->path);
#line 964
                  break;
                }
                goto __Cont;
              }
#line 969
              if (fs.f_type != 391) {
#line 970
                pthread_setcancelstate(cur_state, (int *)((void *)0));
                goto __Cont;
              }
#line 987
              tmp___6 = strstr((char const   *)next->opts, "offset");
#line 987
              if (tmp___6) {
#line 988
                close(me->ioctlfd);
#line 989
                me->ioctlfd = -1;
#line 990
                pthread_setcancelstate(cur_state, (int *)((void *)0));
                goto __Cont;
              }
#line 994
              ioctlfd___0 = me->ioctlfd;
#line 996
              ret = expire_direct(ioctlfd___0, (char const   *)next->path, now, ap->logopt);
#line 997
              if (! ret) {
#line 998
                left ++;
#line 999
                pthread_setcancelstate(cur_state, (int *)((void *)0));
                goto __Cont;
              }
#line 1003
              if (me->ioctlfd != -1) {
#line 1003
                tmp___7 = fstat__extinline(ioctlfd___0, & st);
#line 1003
                if (tmp___7 != -1) {
#line 1003
                  tmp___8 = count_mounts((char const   *)next->path, st.st_dev);
#line 1003
                  if (! tmp___8) {
#line 1006
                    close(ioctlfd___0);
#line 1007
                    me->ioctlfd = -1;
                  }
                }
              }
#line 1010
              pthread_setcancelstate(cur_state, (int *)((void *)0));
              goto __Cont;
            }
#line 1014
            if (me->ioctlfd >= 0) {
#line 1016
              ioctlfd = me->ioctlfd;
#line 1017
              cache_unlock(me->mc);
            } else {
#line 1019
              cache_unlock(me->mc);
              goto __Cont;
            }
#line 1023
            if ((int )ap->state == 2) {
#line 1024
              pthread_testcancel();
            } else {
#line 1023
              if ((int )ap->state == 3) {
#line 1024
                pthread_testcancel();
              }
            }
#line 1026
            while (1) {
#line 1026
              ((*log_debug))(ap->logopt, "%s: send expire to trigger %s", "expire_proc_direct",
                             next->path);
#line 1026
              break;
            }
#line 1028
            pthread_setcancelstate(1, & cur_state);
#line 1029
            ret = expire_direct(ioctlfd, (char const   *)next->path, now, ap->logopt);
#line 1030
            if (! ret) {
#line 1031
              left ++;
            }
#line 1032
            pthread_setcancelstate(cur_state, (int *)((void *)0));
            __Cont: /* CIL Label */ 
#line 928
            p = p->next;
          }
#line 926
          break;
        }
#line 1034
        __pthread_unregister_cancel(& __cancel_buf___0);
#line 1034
        ((*__cancel_routine___0))(__cancel_arg___0);
#line 926
        break;
      }
#line 1036
      ec.status = left;
#line 1038
      pthread_setcancelstate(1, & cur_state);
#line 914
      break;
    }
#line 1039
    __pthread_unregister_cancel(& __cancel_buf);
#line 1039
    ((*__cancel_routine))(__cancel_arg);
#line 914
    break;
  }
#line 1040
  pthread_setcancelstate(cur_state, (int *)((void *)0));
#line 1042
  return ((void *)0);
}
}
#line 1045 "direct.c"
static void pending_cond_destroy___0(void *arg ) 
{ struct pending_args *mt ;
  int status ;

  {
#line 1050
  mt = (struct pending_args *)arg;
#line 1051
  status = pthread_cond_destroy(& mt->cond);
#line 1052
  if (status) {
#line 1053
    while (1) {
#line 1053
      if (status == 35) {
#line 1053
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "pending_cond_destroy", 1053, "direct.c");
#line 1053
        dump_core();
      }
#line 1053
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1053,
                    "direct.c");
#line 1053
      abort();
#line 1053
      break;
    }
  }
#line 1054
  return;
}
}
#line 1056 "direct.c"
static void expire_send_fail___0(void *arg ) 
{ struct pending_args *mt ;

  {
#line 1058
  mt = (struct pending_args *)arg;
#line 1059
  send_fail(mt->ioctlfd, (unsigned int )mt->wait_queue_token);
#line 1060
  return;
}
}
#line 1062 "direct.c"
static void free_pending_args___0(void *arg ) 
{ struct pending_args *mt ;

  {
#line 1064
  mt = (struct pending_args *)arg;
#line 1065
  free((void *)mt);
#line 1066
  return;
}
}
#line 1068 "direct.c"
static void expire_mutex_unlock___0(void *arg ) 
{ int status ;
  int tmp ;

  {
#line 1070
  tmp = pthread_mutex_unlock(& ea_mutex___0);
#line 1070
  status = tmp;
#line 1071
  if (status) {
#line 1072
    while (1) {
#line 1072
      if (status == 35) {
#line 1072
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "expire_mutex_unlock", 1072, "direct.c");
#line 1072
        dump_core();
      }
#line 1072
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1072,
                    "direct.c");
#line 1072
      abort();
#line 1072
      break;
    }
  }
#line 1073
  return;
}
}
#line 1075 "direct.c"
static void *do_expire_direct(void *arg ) 
{ struct pending_args *mt ;
  struct autofs_point *ap ;
  size_t len ;
  int status ;
  int state ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp ;
  long tmp___0 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___0)(void * ) ;
  void *__cancel_arg___0 ;
  int not_first_call___0 ;
  int tmp___1 ;
  long tmp___2 ;
  __pthread_unwind_buf_t __cancel_buf___1 ;
  void (*__cancel_routine___1)(void * ) ;
  void *__cancel_arg___1 ;
  int not_first_call___1 ;
  int tmp___3 ;
  long tmp___4 ;
  struct mapent *me ;

  {
#line 1082
  mt = (struct pending_args *)arg;
#line 1084
  status = pthread_mutex_lock(& ea_mutex___0);
#line 1085
  if (status) {
#line 1086
    while (1) {
#line 1086
      if (status == 35) {
#line 1086
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "do_expire_direct", 1086, "direct.c");
#line 1086
        dump_core();
      }
#line 1086
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1086,
                    "direct.c");
#line 1086
      abort();
#line 1086
      break;
    }
  }
#line 1088
  ap = mt->ap;
#line 1090
  mt->signaled = 1U;
#line 1091
  status = pthread_cond_signal(& mt->cond);
#line 1092
  if (status) {
#line 1093
    while (1) {
#line 1093
      if (status == 35) {
#line 1093
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "do_expire_direct", 1093, "direct.c");
#line 1093
        dump_core();
      }
#line 1093
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1093,
                    "direct.c");
#line 1093
      abort();
#line 1093
      break;
    }
  }
#line 1095
  expire_mutex_unlock___0((void *)0);
#line 1097
  while (1) {
#line 1097
    __cancel_routine = & free_pending_args___0;
#line 1097
    __cancel_arg = (void *)mt;
#line 1097
    tmp = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf), 0);
#line 1097
    not_first_call = tmp;
#line 1097
    tmp___0 = __builtin_expect((long )not_first_call, 0L);
#line 1097
    if (tmp___0) {
#line 1097
      ((*__cancel_routine))(__cancel_arg);
#line 1097
      __pthread_unwind_next(& __cancel_buf);
    }
#line 1097
    __pthread_register_cancel(& __cancel_buf);
#line 1097
    while (1) {
#line 1098
      while (1) {
#line 1098
        __cancel_routine___0 = & pending_cond_destroy___0;
#line 1098
        __cancel_arg___0 = (void *)mt;
#line 1098
        tmp___1 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf),
                              0);
#line 1098
        not_first_call___0 = tmp___1;
#line 1098
        tmp___2 = __builtin_expect((long )not_first_call___0, 0L);
#line 1098
        if (tmp___2) {
#line 1098
          ((*__cancel_routine___0))(__cancel_arg___0);
#line 1098
          __pthread_unwind_next(& __cancel_buf___0);
        }
#line 1098
        __pthread_register_cancel(& __cancel_buf___0);
#line 1098
        while (1) {
#line 1099
          while (1) {
#line 1099
            __cancel_routine___1 = & expire_send_fail___0;
#line 1099
            __cancel_arg___1 = (void *)mt;
#line 1099
            tmp___3 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___1.__cancel_jmp_buf),
                                  0);
#line 1099
            not_first_call___1 = tmp___3;
#line 1099
            tmp___4 = __builtin_expect((long )not_first_call___1, 0L);
#line 1099
            if (tmp___4) {
#line 1099
              ((*__cancel_routine___1))(__cancel_arg___1);
#line 1099
              __pthread_unwind_next(& __cancel_buf___1);
            }
#line 1099
            __pthread_register_cancel(& __cancel_buf___1);
#line 1099
            while (1) {
#line 1101
              len = _strlen((char const   *)(mt->name), 255U);
#line 1102
              if (! len) {
#line 1103
                while (1) {
#line 1103
                  ((*log_warn))(ap->logopt, "%s: direct key path too long %s", "do_expire_direct",
                                mt->name);
#line 1103
                  break;
                }
#line 1105
                pthread_exit((void *)0);
              }
#line 1108
              status = do_expire(ap, (char const   *)(mt->name), (int )len);
#line 1109
              pthread_setcancelstate(1, & state);
#line 1110
              if (status) {
#line 1111
                send_fail(mt->ioctlfd, (unsigned int )mt->wait_queue_token);
              } else {
#line 1114
                cache_readlock(mt->mc);
#line 1115
                me = cache_lookup_distinct(mt->mc, (char const   *)(mt->name));
#line 1116
                me->ioctlfd = -1;
#line 1117
                cache_unlock(mt->mc);
#line 1118
                send_ready(mt->ioctlfd, (unsigned int )mt->wait_queue_token);
#line 1119
                close(mt->ioctlfd);
              }
#line 1121
              pthread_setcancelstate(state, (int *)((void *)0));
#line 1099
              break;
            }
#line 1123
            __pthread_unregister_cancel(& __cancel_buf___1);
#line 1099
            break;
          }
#line 1098
          break;
        }
#line 1124
        __pthread_unregister_cancel(& __cancel_buf___0);
#line 1124
        ((*__cancel_routine___0))(__cancel_arg___0);
#line 1098
        break;
      }
#line 1097
      break;
    }
#line 1125
    __pthread_unregister_cancel(& __cancel_buf);
#line 1125
    ((*__cancel_routine))(__cancel_arg);
#line 1097
    break;
  }
#line 1127
  return ((void *)0);
}
}
#line 1130 "direct.c"
int handle_packet_expire_direct(struct autofs_point *ap , autofs_packet_expire_direct_t *pkt ) 
{ struct map_source *map ;
  struct mapent_cache *mc ;
  struct mapent *me ;
  struct pending_args *mt ;
  char buf[128] ;
  pthread_t thid ;
  int status ;
  int state ;
  char *estr ;
  int *tmp ;
  char *tmp___0 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 1133
  mc = (struct mapent_cache *)((void *)0);
#line 1134
  me = (struct mapent *)((void *)0);
#line 1140
  pthread_setcancelstate(1, & state);
#line 1152
  master_source_readlock(ap->entry);
#line 1153
  map = (ap->entry)->maps;
#line 1154
  while (map) {
#line 1155
    mc = map->mc;
#line 1156
    cache_readlock(mc);
#line 1157
    me = cache_lookup_ino(mc, (unsigned long long )pkt->dev, (unsigned long )pkt->ino);
#line 1158
    if (me) {
#line 1159
      break;
    }
#line 1160
    cache_unlock(mc);
#line 1161
    map = map->next;
  }
#line 1163
  master_source_unlock(ap->entry);
#line 1165
  if (! me) {
#line 1170
    while (1) {
#line 1170
      ((*log_crit))(ap->logopt, "%s: can\'t find map entry for (%lu,%lu)", "handle_packet_expire_direct",
                    (unsigned long )pkt->dev, (unsigned long )pkt->ino);
#line 1170
      break;
    }
#line 1172
    pthread_setcancelstate(state, (int *)((void *)0));
#line 1173
    return (1);
  }
#line 1177
  mt = (struct pending_args *)malloc(sizeof(struct pending_args ));
#line 1178
  if (! mt) {
#line 1179
    tmp = __errno_location();
#line 1179
    tmp___0 = strerror_r((*tmp), buf, 128U);
#line 1179
    estr = tmp___0;
#line 1180
    while (1) {
#line 1180
      ((*log_error))(ap->logopt, "%s: malloc: %s", "handle_packet_expire_direct",
                     estr);
#line 1180
      break;
    }
#line 1181
    send_fail(me->ioctlfd, (unsigned int )pkt->wait_queue_token);
#line 1182
    cache_unlock(mc);
#line 1183
    pthread_setcancelstate(state, (int *)((void *)0));
#line 1184
    return (1);
  }
#line 1187
  status = pthread_cond_init((pthread_cond_t * __restrict  )(& mt->cond), (pthread_condattr_t const   * __restrict  )((void *)0));
#line 1188
  if (status) {
#line 1189
    while (1) {
#line 1189
      if (status == 35) {
#line 1189
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "handle_packet_expire_direct", 1189, "direct.c");
#line 1189
        dump_core();
      }
#line 1189
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1189,
                    "direct.c");
#line 1189
      abort();
#line 1189
      break;
    }
  }
#line 1191
  status = pthread_mutex_lock(& ea_mutex___0);
#line 1192
  if (status) {
#line 1193
    while (1) {
#line 1193
      if (status == 35) {
#line 1193
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "handle_packet_expire_direct", 1193, "direct.c");
#line 1193
        dump_core();
      }
#line 1193
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1193,
                    "direct.c");
#line 1193
      abort();
#line 1193
      break;
    }
  }
#line 1195
  mt->ap = ap;
#line 1196
  mt->ioctlfd = me->ioctlfd;
#line 1197
  mt->mc = mc;
#line 1199
  strcpy((char * __restrict  )(mt->name), (char const   * __restrict  )me->key);
#line 1200
  mt->dev = me->dev;
#line 1201
  mt->type = 2;
#line 1202
  mt->wait_queue_token = pkt->wait_queue_token;
#line 1204
  while (1) {
#line 1204
    ((*log_debug))(ap->logopt, "%s: token %ld, name %s", "handle_packet_expire_direct",
                   pkt->wait_queue_token, mt->name);
#line 1204
    break;
  }
#line 1207
  status = pthread_create((pthread_t * __restrict  )(& thid), (pthread_attr_t const   * __restrict  )(& thread_attr),
                          & do_expire_direct, (void * __restrict  )mt);
#line 1208
  if (status) {
#line 1209
    while (1) {
#line 1209
      ((*log_error))(ap->logopt, "%s: expire thread create failed", "handle_packet_expire_direct");
#line 1209
      break;
    }
#line 1210
    send_fail(mt->ioctlfd, (unsigned int )pkt->wait_queue_token);
#line 1211
    cache_unlock(mc);
#line 1212
    expire_mutex_unlock___0((void *)0);
#line 1213
    pending_cond_destroy___0((void *)mt);
#line 1214
    free_pending_args___0((void *)mt);
#line 1215
    pthread_setcancelstate(state, (int *)((void *)0));
#line 1216
    return (1);
  }
#line 1219
  cache_unlock(mc);
#line 1221
  while (1) {
#line 1221
    __cancel_routine = & expire_mutex_unlock___0;
#line 1221
    __cancel_arg = (void *)0;
#line 1221
    tmp___1 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
#line 1221
    not_first_call = tmp___1;
#line 1221
    tmp___2 = __builtin_expect((long )not_first_call, 0L);
#line 1221
    if (tmp___2) {
#line 1221
      ((*__cancel_routine))(__cancel_arg);
#line 1221
      __pthread_unwind_next(& __cancel_buf);
    }
#line 1221
    __pthread_register_cancel(& __cancel_buf);
#line 1221
    while (1) {
#line 1222
      pthread_setcancelstate(state, (int *)((void *)0));
#line 1224
      mt->signaled = 0U;
#line 1225
      while (! mt->signaled) {
#line 1226
        status = pthread_cond_wait((pthread_cond_t * __restrict  )(& mt->cond), (pthread_mutex_t * __restrict  )(& ea_mutex___0));
#line 1227
        if (status) {
#line 1228
          while (1) {
#line 1228
            if (status == 35) {
#line 1228
              ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                            "handle_packet_expire_direct", 1228, "direct.c");
#line 1228
              dump_core();
            }
#line 1228
            ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status,
                          1228, "direct.c");
#line 1228
            abort();
#line 1228
            break;
          }
        }
      }
#line 1221
      break;
    }
#line 1231
    __pthread_unregister_cancel(& __cancel_buf);
#line 1231
    ((*__cancel_routine))(__cancel_arg);
#line 1221
    break;
  }
#line 1233
  return (0);
}
}
#line 1236 "direct.c"
static void mount_send_fail___0(void *arg ) 
{ struct pending_args *mt ;

  {
#line 1238
  mt = (struct pending_args *)arg;
#line 1239
  send_fail(mt->ioctlfd, (unsigned int )mt->wait_queue_token);
#line 1240
  close(mt->ioctlfd);
#line 1241
  return;
}
}
#line 1243 "direct.c"
static void mount_mutex_unlock___0(void *arg ) 
{ int status ;
  int tmp ;

  {
#line 1245
  tmp = pthread_mutex_unlock(& ma_mutex___0);
#line 1245
  status = tmp;
#line 1246
  if (status) {
#line 1247
    while (1) {
#line 1247
      if (status == 35) {
#line 1247
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "mount_mutex_unlock", 1247, "direct.c");
#line 1247
        dump_core();
      }
#line 1247
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1247,
                    "direct.c");
#line 1247
      abort();
#line 1247
      break;
    }
  }
#line 1248
  return;
}
}
#line 1250 "direct.c"
static void *do_mount_direct(void *arg ) 
{ struct pending_args *mt ;
  struct autofs_point *ap ;
  struct passwd pw ;
  struct passwd *ppw ;
  struct passwd **pppw ;
  struct group gr ;
  struct group *pgr ;
  struct group **ppgr ;
  char *pw_tmp ;
  char *gr_tmp ;
  struct thread_stdenv_vars *tsv ;
  int tmplen ;
  struct stat st ;
  int status ;
  int state ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp ;
  long tmp___0 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___0)(void * ) ;
  void *__cancel_arg___0 ;
  int not_first_call___0 ;
  int tmp___1 ;
  long tmp___2 ;
  __pthread_unwind_buf_t __cancel_buf___1 ;
  void (*__cancel_routine___1)(void * ) ;
  void *__cancel_arg___1 ;
  int not_first_call___1 ;
  int tmp___3 ;
  long tmp___4 ;
  char *tmp___14 ;
  char *tmp___24 ;
  char *tmp___34 ;
  size_t tmp___35 ;
  struct mapent *me ;
  int real_mount ;
  int set_fd ;
  int tmp___36 ;

  {
#line 1255
  ppw = & pw;
#line 1256
  pppw = & ppw;
#line 1258
  pgr = & gr;
#line 1259
  ppgr = & pgr;
#line 1266
  mt = (struct pending_args *)arg;
#line 1268
  status = pthread_mutex_lock(& ma_mutex___0);
#line 1269
  if (status) {
#line 1270
    while (1) {
#line 1270
      if (status == 35) {
#line 1270
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "do_mount_direct", 1270, "direct.c");
#line 1270
        dump_core();
      }
#line 1270
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1270,
                    "direct.c");
#line 1270
      abort();
#line 1270
      break;
    }
  }
#line 1272
  ap = mt->ap;
#line 1274
  mt->signaled = 1U;
#line 1275
  status = pthread_cond_signal(& mt->cond);
#line 1276
  if (status) {
#line 1277
    while (1) {
#line 1277
      if (status == 35) {
#line 1277
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "do_mount_direct", 1277, "direct.c");
#line 1277
        dump_core();
      }
#line 1277
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1277,
                    "direct.c");
#line 1277
      abort();
#line 1277
      break;
    }
  }
#line 1279
  mount_mutex_unlock___0((void *)0);
#line 1281
  while (1) {
#line 1281
    __cancel_routine = & free_pending_args___0;
#line 1281
    __cancel_arg = (void *)mt;
#line 1281
    tmp = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf), 0);
#line 1281
    not_first_call = tmp;
#line 1281
    tmp___0 = __builtin_expect((long )not_first_call, 0L);
#line 1281
    if (tmp___0) {
#line 1281
      ((*__cancel_routine))(__cancel_arg);
#line 1281
      __pthread_unwind_next(& __cancel_buf);
    }
#line 1281
    __pthread_register_cancel(& __cancel_buf);
#line 1281
    while (1) {
#line 1282
      while (1) {
#line 1282
        __cancel_routine___0 = & pending_cond_destroy___0;
#line 1282
        __cancel_arg___0 = (void *)mt;
#line 1282
        tmp___1 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf),
                              0);
#line 1282
        not_first_call___0 = tmp___1;
#line 1282
        tmp___2 = __builtin_expect((long )not_first_call___0, 0L);
#line 1282
        if (tmp___2) {
#line 1282
          ((*__cancel_routine___0))(__cancel_arg___0);
#line 1282
          __pthread_unwind_next(& __cancel_buf___0);
        }
#line 1282
        __pthread_register_cancel(& __cancel_buf___0);
#line 1282
        while (1) {
#line 1283
          while (1) {
#line 1283
            __cancel_routine___1 = & mount_send_fail___0;
#line 1283
            __cancel_arg___1 = (void *)mt;
#line 1283
            tmp___3 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___1.__cancel_jmp_buf),
                                  0);
#line 1283
            not_first_call___1 = tmp___3;
#line 1283
            tmp___4 = __builtin_expect((long )not_first_call___1, 0L);
#line 1283
            if (tmp___4) {
#line 1283
              ((*__cancel_routine___1))(__cancel_arg___1);
#line 1283
              __pthread_unwind_next(& __cancel_buf___1);
            }
#line 1283
            __pthread_register_cancel(& __cancel_buf___1);
#line 1283
            while (1) {
#line 1285
              pthread_setcancelstate(1, & state);
#line 1287
              status = fstat__extinline(mt->ioctlfd, & st);
#line 1288
              if (status == -1) {
#line 1289
                while (1) {
#line 1289
                  ((*log_error))(ap->logopt, "%s: can\'t stat direct mount trigger %s",
                                 "do_mount_direct", mt->name);
#line 1289
                  break;
                }
#line 1291
                pthread_setcancelstate(state, (int *)((void *)0));
#line 1292
                pthread_exit((void *)0);
              }
#line 1295
              status = stat__extinline((char const   *)(mt->name), & st);
#line 1296
              if (! ((st.st_mode & 61440U) == 16384U)) {
                goto _L;
              } else {
#line 1296
                if (st.st_dev != mt->dev) {
                  _L: /* CIL Label */ 
#line 1297
                  while (1) {
#line 1297
                    ((*log_error))(ap->logopt, "%s: direct trigger not valid or already mounted %s",
                                   "do_mount_direct", mt->name);
#line 1297
                    break;
                  }
#line 1300
                  pthread_setcancelstate(state, (int *)((void *)0));
#line 1301
                  pthread_exit((void *)0);
                }
              }
#line 1304
              pthread_setcancelstate(state, (int *)((void *)0));
#line 1306
              while (1) {
#line 1306
                ((*log_info))(0U, "attempting to mount entry %s", mt->name);
#line 1306
                break;
              }
#line 1314
              tsv = (struct thread_stdenv_vars *)malloc(sizeof(struct thread_stdenv_vars ));
#line 1315
              if (! tsv) {
                goto cont;
              }
#line 1318
              tsv->uid = mt->uid;
#line 1319
              tsv->gid = mt->gid;
#line 1323
              tmplen = (int )sysconf(70);
#line 1324
              if (tmplen < 0) {
#line 1325
                while (1) {
#line 1325
                  ((*log_error))(ap->logopt, "%s: failed to get buffer size for getpwuid_r",
                                 "do_mount_direct");
#line 1325
                  break;
                }
#line 1326
                free((void *)tsv);
                goto cont;
              }
#line 1330
              pw_tmp = (char *)malloc((unsigned int )(tmplen + 1));
#line 1331
              if (! pw_tmp) {
#line 1332
                while (1) {
#line 1332
                  ((*log_error))(ap->logopt, "%s: failed to malloc buffer for getpwuid_r",
                                 "do_mount_direct");
#line 1332
                  break;
                }
#line 1333
                free((void *)tsv);
                goto cont;
              }
#line 1337
              status = getpwuid_r(mt->uid, (struct passwd * __restrict  )ppw, (char * __restrict  )pw_tmp,
                                  (unsigned int )tmplen, (struct passwd ** __restrict  )pppw);
#line 1338
              if (status) {
                goto _L___0;
              } else {
#line 1338
                if (! ppw) {
                  _L___0: /* CIL Label */ 
#line 1339
                  while (1) {
#line 1339
                    ((*log_error))(ap->logopt, "%s: failed to get passwd info from getpwuid_r",
                                   "do_mount_direct");
#line 1339
                    break;
                  }
#line 1340
                  free((void *)tsv);
#line 1341
                  free((void *)pw_tmp);
                  goto cont;
                }
              }
#line 1345
              tmp___14 = __strdup((char const   *)pw.pw_name);
#line 1345
              tsv->user = tmp___14;
#line 1346
              if (! tsv->user) {
#line 1347
                while (1) {
#line 1347
                  ((*log_error))(ap->logopt, "%s: failed to malloc buffer for user",
                                 "do_mount_direct");
#line 1347
                  break;
                }
#line 1348
                free((void *)tsv);
#line 1349
                free((void *)pw_tmp);
                goto cont;
              }
#line 1353
              tmp___24 = __strdup((char const   *)pw.pw_dir);
#line 1353
              tsv->home = tmp___24;
#line 1354
              if (! tsv->user) {
#line 1355
                while (1) {
#line 1355
                  ((*log_error))(ap->logopt, "%s: failed to malloc buffer for home",
                                 "do_mount_direct");
#line 1355
                  break;
                }
#line 1356
                free((void *)pw_tmp);
#line 1357
                free((void *)tsv->user);
#line 1358
                free((void *)tsv);
                goto cont;
              }
#line 1362
              free((void *)pw_tmp);
#line 1366
              tmplen = (int )sysconf(69);
#line 1367
              if (tmplen < 0) {
#line 1368
                while (1) {
#line 1368
                  ((*log_error))(ap->logopt, "%s: failed to get buffer size for getgrgid_r",
                                 "do_mount_direct");
#line 1368
                  break;
                }
#line 1369
                free((void *)tsv->user);
#line 1370
                free((void *)tsv->home);
#line 1371
                free((void *)tsv);
                goto cont;
              }
#line 1375
              gr_tmp = (char *)malloc((unsigned int )(tmplen + 1));
#line 1376
              if (! gr_tmp) {
#line 1377
                while (1) {
#line 1377
                  ((*log_error))(ap->logopt, "%s: failed to malloc buffer for getgrgid_r",
                                 "do_mount_direct");
#line 1377
                  break;
                }
#line 1378
                free((void *)tsv->user);
#line 1379
                free((void *)tsv->home);
#line 1380
                free((void *)tsv);
                goto cont;
              }
#line 1384
              status = getgrgid_r(mt->gid, (struct group * __restrict  )pgr, (char * __restrict  )gr_tmp,
                                  (unsigned int )tmplen, (struct group ** __restrict  )ppgr);
#line 1385
              if (status) {
                goto _L___1;
              } else {
#line 1385
                if (! pgr) {
                  _L___1: /* CIL Label */ 
#line 1386
                  while (1) {
#line 1386
                    ((*log_error))(ap->logopt, "%s: failed to get group info from getgrgid_r",
                                   "do_mount_direct");
#line 1386
                    break;
                  }
#line 1387
                  free((void *)tsv->user);
#line 1388
                  free((void *)tsv->home);
#line 1389
                  free((void *)tsv);
#line 1390
                  free((void *)gr_tmp);
                  goto cont;
                }
              }
#line 1394
              tmp___34 = __strdup((char const   *)gr.gr_name);
#line 1394
              tsv->group = tmp___34;
#line 1395
              if (! tsv->group) {
#line 1396
                while (1) {
#line 1396
                  ((*log_error))(ap->logopt, "%s: failed to malloc buffer for group",
                                 "do_mount_direct");
#line 1396
                  break;
                }
#line 1397
                free((void *)tsv->user);
#line 1398
                free((void *)tsv->home);
#line 1399
                free((void *)tsv);
#line 1400
                free((void *)gr_tmp);
                goto cont;
              }
#line 1404
              free((void *)gr_tmp);
#line 1406
              status = pthread_setspecific(key_thread_stdenv_vars, (void const   *)tsv);
#line 1407
              if (status) {
#line 1408
                while (1) {
#line 1408
                  ((*log_error))(ap->logopt, "%s: failed to set stdenv thread var",
                                 "do_mount_direct");
#line 1408
                  break;
                }
#line 1409
                free((void *)tsv->group);
#line 1410
                free((void *)tsv->user);
#line 1411
                free((void *)tsv->home);
#line 1412
                free((void *)tsv);
              }
              cont: 
#line 1416
              tmp___35 = strlen((char const   *)(mt->name));
#line 1416
              status = lookup_nss_mount(ap, (struct map_source *)((void *)0), (char const   *)(mt->name),
                                        (int )tmp___35);
#line 1421
              pthread_setcancelstate(1, & state);
#line 1422
              if (status) {
#line 1425
                cache_readlock(mt->mc);
#line 1426
                me = cache_lookup_distinct(mt->mc, (char const   *)(mt->name));
#line 1427
                real_mount = is_mounted("/etc/mtab", (char const   *)me->key, 2U);
#line 1428
                if (real_mount) {
#line 1428
                  tmp___36 = 1;
                } else {
#line 1428
                  if ((unsigned int )me->multi == (unsigned int )me) {
#line 1428
                    tmp___36 = 1;
                  } else {
#line 1428
                    tmp___36 = 0;
                  }
                }
#line 1428
                set_fd = tmp___36;
#line 1429
                cache_unlock(mt->mc);
#line 1430
                if (set_fd) {
#line 1431
                  me->ioctlfd = mt->ioctlfd;
#line 1432
                  send_ready(mt->ioctlfd, (unsigned int )mt->wait_queue_token);
                } else {
#line 1434
                  send_ready(mt->ioctlfd, (unsigned int )mt->wait_queue_token);
#line 1435
                  close(mt->ioctlfd);
                }
#line 1437
                while (1) {
#line 1437
                  ((*log_info))(0U, "mounted %s", mt->name);
#line 1437
                  break;
                }
              } else {
#line 1439
                send_fail(mt->ioctlfd, (unsigned int )mt->wait_queue_token);
#line 1440
                close(mt->ioctlfd);
#line 1441
                while (1) {
#line 1441
                  ((*log_info))(0U, "failed to mount %s", mt->name);
#line 1441
                  break;
                }
              }
#line 1443
              pthread_setcancelstate(state, (int *)((void *)0));
#line 1283
              break;
            }
#line 1445
            __pthread_unregister_cancel(& __cancel_buf___1);
#line 1283
            break;
          }
#line 1282
          break;
        }
#line 1446
        __pthread_unregister_cancel(& __cancel_buf___0);
#line 1446
        ((*__cancel_routine___0))(__cancel_arg___0);
#line 1282
        break;
      }
#line 1281
      break;
    }
#line 1447
    __pthread_unregister_cancel(& __cancel_buf);
#line 1447
    ((*__cancel_routine))(__cancel_arg);
#line 1281
    break;
  }
#line 1449
  return ((void *)0);
}
}
#line 1452 "direct.c"
int handle_packet_missing_direct(struct autofs_point *ap , autofs_packet_missing_direct_t *pkt ) 
{ struct map_source *map ;
  struct mapent_cache *mc ;
  struct mapent *me ;
  pthread_t thid ;
  struct pending_args *mt ;
  char buf[128] ;
  int status ;
  int ioctlfd ;
  int cl_flags ;
  int state ;
  char *estr ;
  int *tmp ;
  char *tmp___0 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 1455
  mc = (struct mapent_cache *)((void *)0);
#line 1456
  me = (struct mapent *)((void *)0);
#line 1460
  status = 0;
#line 1463
  pthread_setcancelstate(1, & state);
#line 1465
  master_source_readlock(ap->entry);
#line 1466
  map = (ap->entry)->maps;
#line 1467
  while (map) {
#line 1472
    if ((ap->entry)->age > map->age) {
#line 1473
      map = map->next;
#line 1474
      continue;
    }
#line 1477
    mc = map->mc;
#line 1478
    cache_readlock(mc);
#line 1479
    me = cache_lookup_ino(mc, (unsigned long long )pkt->dev, (unsigned long )pkt->ino);
#line 1480
    if (me) {
#line 1481
      break;
    }
#line 1482
    cache_unlock(mc);
#line 1483
    map = map->next;
  }
#line 1485
  master_source_unlock(ap->entry);
#line 1487
  if (! me) {
#line 1492
    while (1) {
#line 1492
      ((*log_crit))(ap->logopt, "%s: can\'t find map entry for (%lu,%lu)", "handle_packet_missing_direct",
                    (unsigned long )pkt->dev, (unsigned long )pkt->ino);
#line 1492
      break;
    }
#line 1494
    pthread_setcancelstate(state, (int *)((void *)0));
#line 1495
    return (1);
  }
#line 1498
  if (me->ioctlfd != -1) {
#line 1500
    ioctlfd = me->ioctlfd;
#line 1501
    me->ioctlfd = -1;
  } else {
#line 1503
    ioctlfd = open((char const   *)me->key, 0);
  }
#line 1505
  if (ioctlfd == -1) {
#line 1506
    cache_unlock(mc);
#line 1507
    pthread_setcancelstate(state, (int *)((void *)0));
#line 1508
    while (1) {
#line 1508
      ((*log_crit))(ap->logopt, "%s: failed to create ioctl fd for %s", "handle_packet_missing_direct",
                    me->key);
#line 1508
      break;
    }
#line 1510
    return (1);
  }
#line 1513
  cl_flags = fcntl(ioctlfd, 1, 0);
#line 1513
  if (cl_flags != -1) {
#line 1514
    cl_flags |= 1;
#line 1515
    fcntl(ioctlfd, 2, cl_flags);
  }
#line 1518
  while (1) {
#line 1518
    ((*log_debug))(ap->logopt, "%s: token %ld, name %s, request pid %u", "handle_packet_missing_direct",
                   pkt->wait_queue_token, me->key, pkt->pid);
#line 1518
    break;
  }
#line 1522
  if ((int )ap->state == 5) {
#line 1525
    send_fail(ioctlfd, (unsigned int )pkt->wait_queue_token);
#line 1526
    close(ioctlfd);
#line 1527
    cache_unlock(mc);
#line 1528
    pthread_setcancelstate(state, (int *)((void *)0));
#line 1529
    return (1);
  } else {
#line 1522
    if ((int )ap->state == 6) {
#line 1525
      send_fail(ioctlfd, (unsigned int )pkt->wait_queue_token);
#line 1526
      close(ioctlfd);
#line 1527
      cache_unlock(mc);
#line 1528
      pthread_setcancelstate(state, (int *)((void *)0));
#line 1529
      return (1);
    } else {
#line 1522
      if ((int )ap->state == 7) {
#line 1525
        send_fail(ioctlfd, (unsigned int )pkt->wait_queue_token);
#line 1526
        close(ioctlfd);
#line 1527
        cache_unlock(mc);
#line 1528
        pthread_setcancelstate(state, (int *)((void *)0));
#line 1529
        return (1);
      }
    }
  }
#line 1532
  mt = (struct pending_args *)malloc(sizeof(struct pending_args ));
#line 1533
  if (! mt) {
#line 1534
    tmp = __errno_location();
#line 1534
    tmp___0 = strerror_r((*tmp), buf, 128U);
#line 1534
    estr = tmp___0;
#line 1535
    while (1) {
#line 1535
      ((*log_error))(ap->logopt, "%s: malloc: %s", "handle_packet_missing_direct",
                     estr);
#line 1535
      break;
    }
#line 1536
    send_fail(ioctlfd, (unsigned int )pkt->wait_queue_token);
#line 1537
    close(ioctlfd);
#line 1538
    cache_unlock(mc);
#line 1539
    pthread_setcancelstate(state, (int *)((void *)0));
#line 1540
    return (1);
  }
#line 1542
  memset((void *)mt, 0, sizeof(struct pending_args ));
#line 1544
  status = pthread_cond_init((pthread_cond_t * __restrict  )(& mt->cond), (pthread_condattr_t const   * __restrict  )((void *)0));
#line 1545
  if (status) {
#line 1546
    while (1) {
#line 1546
      if (status == 35) {
#line 1546
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "handle_packet_missing_direct", 1546, "direct.c");
#line 1546
        dump_core();
      }
#line 1546
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1546,
                    "direct.c");
#line 1546
      abort();
#line 1546
      break;
    }
  }
#line 1548
  status = pthread_mutex_lock(& ma_mutex___0);
#line 1549
  if (status) {
#line 1550
    while (1) {
#line 1550
      if (status == 35) {
#line 1550
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "handle_packet_missing_direct", 1550, "direct.c");
#line 1550
        dump_core();
      }
#line 1550
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 1550,
                    "direct.c");
#line 1550
      abort();
#line 1550
      break;
    }
  }
#line 1552
  mt->ap = ap;
#line 1553
  mt->ioctlfd = ioctlfd;
#line 1554
  mt->mc = mc;
#line 1555
  strcpy((char * __restrict  )(mt->name), (char const   * __restrict  )me->key);
#line 1556
  mt->dev = me->dev;
#line 1557
  mt->type = 1;
#line 1558
  mt->uid = pkt->uid;
#line 1559
  mt->gid = pkt->gid;
#line 1560
  mt->wait_queue_token = pkt->wait_queue_token;
#line 1562
  status = pthread_create((pthread_t * __restrict  )(& thid), (pthread_attr_t const   * __restrict  )(& thread_attr),
                          & do_mount_direct, (void * __restrict  )mt);
#line 1563
  if (status) {
#line 1564
    while (1) {
#line 1564
      ((*log_error))(ap->logopt, "%s: missing mount thread create failed", "handle_packet_missing_direct");
#line 1564
      break;
    }
#line 1565
    send_fail(ioctlfd, (unsigned int )pkt->wait_queue_token);
#line 1566
    close(ioctlfd);
#line 1567
    cache_unlock(mc);
#line 1568
    mount_mutex_unlock___0((void *)0);
#line 1569
    pending_cond_destroy___0((void *)mt);
#line 1570
    free_pending_args___0((void *)mt);
#line 1571
    pthread_setcancelstate(state, (int *)((void *)0));
#line 1572
    return (1);
  }
#line 1575
  cache_unlock(mc);
#line 1576
  while (1) {
#line 1576
    __cancel_routine = & mount_mutex_unlock___0;
#line 1576
    __cancel_arg = (void *)0;
#line 1576
    tmp___1 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
#line 1576
    not_first_call = tmp___1;
#line 1576
    tmp___2 = __builtin_expect((long )not_first_call, 0L);
#line 1576
    if (tmp___2) {
#line 1576
      ((*__cancel_routine))(__cancel_arg);
#line 1576
      __pthread_unwind_next(& __cancel_buf);
    }
#line 1576
    __pthread_register_cancel(& __cancel_buf);
#line 1576
    while (1) {
#line 1577
      pthread_setcancelstate(state, (int *)((void *)0));
#line 1579
      mt->signaled = 0U;
#line 1580
      while (! mt->signaled) {
#line 1581
        status = pthread_cond_wait((pthread_cond_t * __restrict  )(& mt->cond), (pthread_mutex_t * __restrict  )(& ma_mutex___0));
#line 1582
        if (status) {
#line 1583
          while (1) {
#line 1583
            if (status == 35) {
#line 1583
              ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                            "handle_packet_missing_direct", 1583, "direct.c");
#line 1583
              dump_core();
            }
#line 1583
            ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status,
                          1583, "direct.c");
#line 1583
            abort();
#line 1583
            break;
          }
        }
      }
#line 1576
      break;
    }
#line 1586
    __pthread_unregister_cancel(& __cancel_buf);
#line 1586
    ((*__cancel_routine))(__cancel_arg);
#line 1576
    break;
  }
#line 1588
  return (0);
}
}
#line 1 "spawn.o"
#pragma merger(0,"/tmp/cil-kdUas04X.i","-O2,-Wall,-fPIE")
#line 129 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int raise(int __sig ) ;
#line 216
extern  __attribute__((__nothrow__)) int sigemptyset(sigset_t *__set )  __attribute__((__nonnull__(1))) ;
#line 222
extern  __attribute__((__nothrow__)) int sigaddset(sigset_t *__set , int __signo )  __attribute__((__nonnull__(1))) ;
#line 260
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
#line 31 "/usr/include/bits/sigthread.h"
extern  __attribute__((__nothrow__)) int pthread_sigmask(int __how , __sigset_t const   * __restrict  __newmask ,
                                                         __sigset_t * __restrict  __oldmask ) ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 66
extern  __attribute__((__nothrow__)) void *memchr(void const   *__s , int __c , size_t __n )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 258 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int access(char const   *__name , int __type )  __attribute__((__nonnull__(1))) ;
#line 493
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 516
extern  __attribute__((__nothrow__)) int execv(char const   *__path , char * const  *__argv )  __attribute__((__nonnull__(1))) ;
#line 548
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 600
extern  __attribute__((__nothrow__)) int setpgid(__pid_t __pid , __pid_t __pgid ) ;
#line 617
extern  __attribute__((__nothrow__)) int setpgrp(void) ;
#line 677
extern  __attribute__((__nothrow__)) int seteuid(__uid_t __uid ) ;
#line 694
extern  __attribute__((__nothrow__)) int setegid(__gid_t __gid ) ;
#line 139 "/usr/include/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 202 "../include/automount.h"
int spawnl(logger *log , char const   *prog  , ...) ;
#line 203
int spawnv(logger *log , char const   *prog , char const   * const  *argv ) ;
#line 204
int spawn_mount(logger *log  , ...) ;
#line 205
int spawn_bind_mount(logger *log  , ...) ;
#line 207
void reset_signals(void) ;
#line 31 "spawn.c"
static union __anonunion_pthread_mutex_t_6 spawn_mutex  =    {{0, 0U, 0, 0, 0U, {0}}};
#line 39 "spawn.c"
void dump_core(void) 
{ sigset_t segv ;

  {
#line 43
  sigemptyset(& segv);
#line 44
  sigaddset(& segv, 11);
#line 45
  pthread_sigmask(1, (__sigset_t const   * __restrict  )(& segv), (__sigset_t * __restrict  )((void *)0));
#line 46
  sigprocmask(1, (sigset_t const   * __restrict  )(& segv), (sigset_t * __restrict  )((void *)0));
#line 48
  raise(11);
#line 49
  return;
}
}
#line 55 "spawn.c"
void reset_signals(void) 
{ struct sigaction sa ;
  sigset_t allsignals ;
  int i ;

  {
#line 61
  sigfillset(& allsignals);
#line 62
  sigprocmask(0, (sigset_t const   * __restrict  )(& allsignals), (sigset_t * __restrict  )((void *)0));
#line 65
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 66
  sigemptyset(& sa.sa_mask);
#line 67
  sa.sa_flags = 0;
#line 69
  i = 1;
#line 69
  while (i < 65) {
#line 70
    if (i != 9) {
#line 70
      if (i != 19) {
#line 71
        sigaction(i, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
      }
    }
#line 69
    i ++;
  }
#line 73
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))0;
#line 75
  i = 1;
#line 75
  while (i < 65) {
#line 76
    if (i != 9) {
#line 76
      if (i != 19) {
#line 77
        sigaction(i, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
      }
    }
#line 75
    i ++;
  }
#line 81
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 82
  sa.sa_flags = 268435456;
#line 83
  sigaction(10, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
#line 84
  sigaction(12, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
#line 86
  sigprocmask(1, (sigset_t const   * __restrict  )(& allsignals), (sigset_t * __restrict  )((void *)0));
#line 87
  return;
}
}
#line 91 "spawn.c"
static int do_spawn(logger *log , unsigned int options , char const   *prog , char const   * const  *argv ) 
{ pid_t f ;
  int ret ;
  int status ;
  int pipefd[2] ;
  char errbuf[2048] ;
  char *p ;
  char *sp ;
  int errp ;
  int errn ;
  int cancel_state ;
  unsigned int use_lock ;
  unsigned int use_access ;
  sigset_t allsigs ;
  sigset_t tmpsig ;
  sigset_t oldsig ;
  struct thread_stdenv_vars *tsv ;
  pid_t euid ;
  gid_t egid ;
  int tmp ;
  char **pargv ;
  int argc ;
  pid_t pgrp ;
  pid_t tmp___0 ;
  char **tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  __pid_t tmp___6 ;

  {
#line 98
  use_lock = options & 1U;
#line 99
  use_access = options & 2U;
#line 102
  euid = 0;
#line 103
  egid = (gid_t )0;
#line 105
  tmp = pipe(pipefd);
#line 105
  if (tmp) {
#line 106
    return (-1);
  }
#line 108
  pthread_setcancelstate(1, & cancel_state);
#line 110
  sigfillset(& allsigs);
#line 111
  pthread_sigmask(0, (__sigset_t const   * __restrict  )(& allsigs), (__sigset_t * __restrict  )(& oldsig));
#line 113
  if (use_lock) {
#line 114
    status = pthread_mutex_lock(& spawn_mutex);
#line 115
    if (status) {
#line 116
      while (1) {
#line 116
        if (status == 35) {
#line 116
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "do_spawn", 116, "spawn.c");
#line 116
          dump_core();
        }
#line 116
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 116,
                      "spawn.c");
#line 116
        abort();
#line 116
        break;
      }
    }
  }
#line 119
  tsv = (struct thread_stdenv_vars *)pthread_getspecific(key_thread_stdenv_vars);
#line 120
  if (tsv) {
#line 121
    euid = (int )tsv->uid;
#line 122
    egid = tsv->gid;
  }
#line 125
  f = fork();
#line 126
  if (f == 0) {
#line 127
    reset_signals();
#line 128
    close(pipefd[0]);
#line 129
    dup2(pipefd[1], 1);
#line 130
    dup2(pipefd[1], 2);
#line 131
    close(pipefd[1]);
#line 134
    if (use_access) {
#line 135
      pargv = (char **)argv;
#line 136
      argc = 0;
#line 137
      tmp___0 = getpgrp();
#line 137
      pgrp = tmp___0;
#line 140
      while (1) {
#line 140
        tmp___1 = pargv;
#line 140
        pargv ++;
#line 140
        if (! (*tmp___1)) {
#line 140
          break;
        }
#line 141
        argc ++;
      }
#line 142
      argc -= 2;
#line 148
      if (euid) {
#line 149
        seteuid((unsigned int )euid);
#line 150
        setegid(egid);
      }
#line 152
      setpgrp();
#line 155
      tmp___3 = access((char const   *)(*(argv + argc)), 0);
#line 155
      if (tmp___3 == -1) {
#line 156
        tmp___2 = __errno_location();
#line 156
        _exit((*tmp___2));
      }
#line 158
      seteuid(0U);
#line 159
      setegid(0U);
#line 160
      setpgid(0, pgrp);
    }
#line 163
    execv(prog, (char * const  *)argv);
#line 164
    _exit(255);
  } else {
#line 166
    tmpsig = oldsig;
#line 168
    sigaddset(& tmpsig, 17);
#line 169
    pthread_sigmask(2, (__sigset_t const   * __restrict  )(& tmpsig), (__sigset_t * __restrict  )((void *)0));
#line 171
    close(pipefd[1]);
#line 173
    if (f < 0) {
#line 174
      close(pipefd[0]);
#line 175
      if (use_lock) {
#line 176
        status = pthread_mutex_unlock(& spawn_mutex);
#line 177
        if (status) {
#line 178
          while (1) {
#line 178
            if (status == 35) {
#line 178
              ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                            "do_spawn", 178, "spawn.c");
#line 178
              dump_core();
            }
#line 178
            ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status,
                          178, "spawn.c");
#line 178
            abort();
#line 178
            break;
          }
        }
      }
#line 180
      pthread_sigmask(2, (__sigset_t const   * __restrict  )(& oldsig), (__sigset_t * __restrict  )((void *)0));
#line 181
      pthread_setcancelstate(cancel_state, (int *)((void *)0));
#line 182
      return (-1);
    }
#line 185
    errp = 0;
#line 186
    while (1) {
#line 187
      while (1) {
#line 187
        errn = read(pipefd[0], (void *)(errbuf + errp), (unsigned int )(2047 - errp));
#line 187
        if (errn == -1) {
#line 187
          tmp___4 = __errno_location();
#line 187
          if (! ((*tmp___4) == 4)) {
#line 187
            break;
          }
        } else {
#line 187
          break;
        }
      }
#line 191
      if (errn > 0) {
#line 192
        errp += errn;
#line 194
        sp = errbuf;
#line 195
        while (1) {
#line 195
          if (errp) {
#line 195
            p = (char *)memchr((void const   *)sp, '\n', (unsigned int )errp);
#line 195
            if (! p) {
#line 195
              break;
            }
          } else {
#line 195
            break;
          }
#line 196
          tmp___5 = p;
#line 196
          p ++;
#line 196
          (*tmp___5) = (char )'\000';
#line 197
          if ((*(sp + 0))) {
#line 198
            ((*log))(3U, ">> %s", sp);
          }
#line 199
          errp -= p - sp;
#line 200
          sp = p;
        }
#line 203
        if (errp) {
#line 203
          if ((unsigned int )sp != (unsigned int )(errbuf)) {
#line 204
            memmove((void *)(errbuf), (void const   *)sp, (unsigned int )errp);
          }
        }
#line 206
        if (errp >= 2047) {
#line 208
          errbuf[errp] = (char )'\000';
#line 209
          ((*log))(3U, ">> %s", errbuf);
#line 210
          errp = 0;
        }
      }
#line 186
      if (! (errn > 0)) {
#line 186
        break;
      }
    }
#line 215
    close(pipefd[0]);
#line 217
    if (errp > 0) {
#line 219
      errbuf[errp] = (char )'\000';
#line 220
      ((*log))(3U, ">> %s", errbuf);
    }
#line 223
    tmp___6 = waitpid(f, & ret, 0);
#line 223
    if (tmp___6 != f) {
#line 224
      ret = -1;
    }
#line 226
    if (use_lock) {
#line 227
      status = pthread_mutex_unlock(& spawn_mutex);
#line 228
      if (status) {
#line 229
        while (1) {
#line 229
          if (status == 35) {
#line 229
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "do_spawn", 229, "spawn.c");
#line 229
            dump_core();
          }
#line 229
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 229,
                        "spawn.c");
#line 229
          abort();
#line 229
          break;
        }
      }
    }
#line 231
    pthread_sigmask(2, (__sigset_t const   * __restrict  )(& oldsig), (__sigset_t * __restrict  )((void *)0));
#line 232
    pthread_setcancelstate(cancel_state, (int *)((void *)0));
#line 234
    return (ret);
  }
}
}
#line 238 "spawn.c"
int spawnv(logger *log , char const   *prog , char const   * const  *argv ) 
{ int tmp ;

  {
#line 240
  tmp = do_spawn(log, 0U, prog, argv);
#line 240
  return (tmp);
}
}
#line 243 "spawn.c"
int spawnl(logger *log , char const   *prog  , ...) 
{ va_list arg ;
  int argc ;
  char **argv ;
  char **p ;
  char *tmp ;
  char **tmp___0 ;
  int tmp___1 ;

  {
#line 249
  __builtin_va_start(arg, prog);
#line 250
  argc = 1;
#line 250
  while (1) {
#line 250
    tmp = __builtin_va_arg(arg, char *);
#line 250
    if (! tmp) {
#line 250
      break;
    }
#line 250
    argc ++;
  }
#line 251
  __builtin_va_end(arg);
#line 253
  argv = (char **)__builtin_alloca(sizeof(char *) * (unsigned int )argc);
#line 253
  if (! argv) {
#line 254
    return (-1);
  }
#line 256
  __builtin_va_start(arg, prog);
#line 257
  p = argv;
#line 258
  while (1) {
#line 258
    tmp___0 = p;
#line 258
    p ++;
#line 258
    (*tmp___0) = __builtin_va_arg(arg, char *);
#line 258
    if (! (*tmp___0)) {
#line 258
      break;
    }
  }
#line 259
  __builtin_va_end(arg);
#line 261
  tmp___1 = do_spawn(log, 0U, prog, (char const   * const  *)((char const   **)argv));
#line 261
  return (tmp___1);
}
}
#line 264 "spawn.c"
int spawn_mount(logger *log  , ...) 
{ va_list arg ;
  int argc ;
  char **argv ;
  char **p ;
  char prog[11] ;
  char arg0[11] ;
  unsigned int options ;
  unsigned int retries ;
  int ret ;
  char *tmp ;
  char **tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 269
  prog[0] = (char )'/';
#line 269
  prog[1] = (char )'b';
#line 269
  prog[2] = (char )'i';
#line 269
  prog[3] = (char )'n';
#line 269
  prog[4] = (char )'/';
#line 269
  prog[5] = (char )'m';
#line 269
  prog[6] = (char )'o';
#line 269
  prog[7] = (char )'u';
#line 269
  prog[8] = (char )'n';
#line 269
  prog[9] = (char )'t';
#line 269
  prog[10] = (char )'\000';
#line 270
  arg0[0] = (char )'/';
#line 270
  arg0[1] = (char )'b';
#line 270
  arg0[2] = (char )'i';
#line 270
  arg0[3] = (char )'n';
#line 270
  arg0[4] = (char )'/';
#line 270
  arg0[5] = (char )'m';
#line 270
  arg0[6] = (char )'o';
#line 270
  arg0[7] = (char )'u';
#line 270
  arg0[8] = (char )'n';
#line 270
  arg0[9] = (char )'t';
#line 270
  arg0[10] = (char )'\000';
#line 272
  retries = 3U;
#line 277
  options = 1U;
#line 282
  __builtin_va_start(arg, log);
#line 283
  argc = 1;
#line 283
  while (1) {
#line 283
    tmp = __builtin_va_arg(arg, char *);
#line 283
    if (! tmp) {
#line 283
      break;
    }
#line 283
    argc ++;
  }
#line 284
  __builtin_va_end(arg);
#line 286
  argv = (char **)__builtin_alloca(sizeof(char *) * (unsigned int )argc + 1U);
#line 286
  if (! argv) {
#line 287
    return (-1);
  }
#line 289
  (*(argv + 0)) = arg0;
#line 291
  __builtin_va_start(arg, log);
#line 292
  p = argv + 1;
#line 293
  while (1) {
#line 293
    tmp___0 = p;
#line 293
    p ++;
#line 293
    (*tmp___0) = __builtin_va_arg(arg, char *);
#line 293
    if (! (*tmp___0)) {
#line 293
      break;
    }
  }
#line 294
  __builtin_va_end(arg);
#line 296
  while (1) {
#line 296
    tmp___1 = retries;
#line 296
    retries --;
#line 296
    if (! tmp___1) {
#line 296
      break;
    }
#line 297
    ret = do_spawn(log, options, (char const   *)(prog), (char const   * const  *)((char const   **)argv));
#line 298
    if (ret & 4096) {
#line 299
      continue;
    }
#line 300
    break;
  }
#line 303
  return (ret);
}
}
#line 314 "spawn.c"
int spawn_bind_mount(logger *log  , ...) 
{ va_list arg ;
  int argc ;
  char **argv ;
  char **p ;
  char prog[11] ;
  char arg0[11] ;
  char bind___0[7] ;
  unsigned int options ;
  unsigned int retries ;
  int ret ;
  char *tmp ;
  char **tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 319
  prog[0] = (char )'/';
#line 319
  prog[1] = (char )'b';
#line 319
  prog[2] = (char )'i';
#line 319
  prog[3] = (char )'n';
#line 319
  prog[4] = (char )'/';
#line 319
  prog[5] = (char )'m';
#line 319
  prog[6] = (char )'o';
#line 319
  prog[7] = (char )'u';
#line 319
  prog[8] = (char )'n';
#line 319
  prog[9] = (char )'t';
#line 319
  prog[10] = (char )'\000';
#line 320
  arg0[0] = (char )'/';
#line 320
  arg0[1] = (char )'b';
#line 320
  arg0[2] = (char )'i';
#line 320
  arg0[3] = (char )'n';
#line 320
  arg0[4] = (char )'/';
#line 320
  arg0[5] = (char )'m';
#line 320
  arg0[6] = (char )'o';
#line 320
  arg0[7] = (char )'u';
#line 320
  arg0[8] = (char )'n';
#line 320
  arg0[9] = (char )'t';
#line 320
  arg0[10] = (char )'\000';
#line 321
  bind___0[0] = (char )'-';
#line 321
  bind___0[1] = (char )'-';
#line 321
  bind___0[2] = (char )'b';
#line 321
  bind___0[3] = (char )'i';
#line 321
  bind___0[4] = (char )'n';
#line 321
  bind___0[5] = (char )'d';
#line 321
  bind___0[6] = (char )'\000';
#line 323
  retries = 3U;
#line 328
  options = 1U;
#line 333
  __builtin_va_start(arg, log);
#line 334
  argc = 1;
#line 334
  while (1) {
#line 334
    tmp = __builtin_va_arg(arg, char *);
#line 334
    if (! tmp) {
#line 334
      break;
    }
#line 334
    argc ++;
  }
#line 335
  __builtin_va_end(arg);
#line 337
  argv = (char **)__builtin_alloca(sizeof(char *) * (unsigned int )argc + 2U);
#line 337
  if (! argv) {
#line 338
    return (-1);
  }
#line 340
  (*(argv + 0)) = arg0;
#line 341
  (*(argv + 1)) = bind___0;
#line 343
  __builtin_va_start(arg, log);
#line 344
  p = argv + 2;
#line 345
  while (1) {
#line 345
    tmp___0 = p;
#line 345
    p ++;
#line 345
    (*tmp___0) = __builtin_va_arg(arg, char *);
#line 345
    if (! (*tmp___0)) {
#line 345
      break;
    }
  }
#line 346
  __builtin_va_end(arg);
#line 348
  while (1) {
#line 348
    tmp___1 = retries;
#line 348
    retries --;
#line 348
    if (! tmp___1) {
#line 348
      break;
    }
#line 349
    ret = do_spawn(log, options, (char const   *)(prog), (char const   * const  *)((char const   **)argv));
#line 350
    if (ret & 4096) {
#line 351
      continue;
    }
#line 352
    break;
  }
#line 355
  return (ret);
}
}
#line 358 "spawn.c"
int spawn_umount(logger *log  , ...) 
{ va_list arg ;
  int argc ;
  char **argv ;
  char **p ;
  char prog[12] ;
  char arg0[12] ;
  unsigned int options ;
  unsigned int retries ;
  int ret ;
  char *tmp ;
  char **tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 363
  prog[0] = (char )'/';
#line 363
  prog[1] = (char )'b';
#line 363
  prog[2] = (char )'i';
#line 363
  prog[3] = (char )'n';
#line 363
  prog[4] = (char )'/';
#line 363
  prog[5] = (char )'u';
#line 363
  prog[6] = (char )'m';
#line 363
  prog[7] = (char )'o';
#line 363
  prog[8] = (char )'u';
#line 363
  prog[9] = (char )'n';
#line 363
  prog[10] = (char )'t';
#line 363
  prog[11] = (char )'\000';
#line 364
  arg0[0] = (char )'/';
#line 364
  arg0[1] = (char )'b';
#line 364
  arg0[2] = (char )'i';
#line 364
  arg0[3] = (char )'n';
#line 364
  arg0[4] = (char )'/';
#line 364
  arg0[5] = (char )'u';
#line 364
  arg0[6] = (char )'m';
#line 364
  arg0[7] = (char )'o';
#line 364
  arg0[8] = (char )'u';
#line 364
  arg0[9] = (char )'n';
#line 364
  arg0[10] = (char )'t';
#line 364
  arg0[11] = (char )'\000';
#line 366
  retries = 3U;
#line 370
  options = 1U;
#line 375
  __builtin_va_start(arg, log);
#line 376
  argc = 1;
#line 376
  while (1) {
#line 376
    tmp = __builtin_va_arg(arg, char *);
#line 376
    if (! tmp) {
#line 376
      break;
    }
#line 376
    argc ++;
  }
#line 377
  __builtin_va_end(arg);
#line 379
  argv = (char **)__builtin_alloca(sizeof(char *) * (unsigned int )argc + 1U);
#line 379
  if (! argv) {
#line 380
    return (-1);
  }
#line 382
  (*(argv + 0)) = arg0;
#line 384
  __builtin_va_start(arg, log);
#line 385
  p = argv + 1;
#line 386
  while (1) {
#line 386
    tmp___0 = p;
#line 386
    p ++;
#line 386
    (*tmp___0) = __builtin_va_arg(arg, char *);
#line 386
    if (! (*tmp___0)) {
#line 386
      break;
    }
  }
#line 387
  __builtin_va_end(arg);
#line 389
  while (1) {
#line 389
    tmp___1 = retries;
#line 389
    retries --;
#line 389
    if (! tmp___1) {
#line 389
      break;
    }
#line 390
    ret = do_spawn(log, options, (char const   *)(prog), (char const   * const  *)((char const   **)argv));
#line 391
    if (ret & 4096) {
#line 392
      continue;
    }
#line 393
    break;
  }
#line 396
  return (ret);
}
}
#line 1 "module.o"
#pragma merger(0,"/tmp/cil-enPVUdB3.i","-O2,-Wall,-fPIE")
#line 536 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 58 "/usr/include/dlfcn.h"
extern  __attribute__((__nothrow__)) void *dlopen(char const   *__file , int __mode ) ;
#line 62
extern  __attribute__((__nothrow__)) int dlclose(void *__handle )  __attribute__((__nonnull__(1))) ;
#line 66
extern  __attribute__((__nothrow__)) void *dlsym(void * __restrict  __handle , char const   * __restrict  __name )  __attribute__((__nonnull__(2))) ;
#line 84
extern  __attribute__((__nothrow__)) char *dlerror(void) ;
#line 57 "../include/automount.h"
int load_autofs4_module(void) ;
#line 259
struct lookup_mod *open_lookup(char const   *name , char const   *err_prefix , char const   *mapfmt ,
                               int argc , char const   * const  *argv ) ;
#line 261
int close_lookup(struct lookup_mod *mod ) ;
#line 285
struct parse_mod *open_parse(char const   *name , char const   *err_prefix , int argc ,
                             char const   * const  *argv ) ;
#line 287
int close_parse(struct parse_mod *mod ) ;
#line 312
struct mount_mod *open_mount(char const   *name , char const   *err_prefix ) ;
#line 313
int close_mount(struct mount_mod *mod ) ;
#line 21 "module.c"
int load_autofs4_module(void) 
{ FILE *fp ;
  char buf[4096] ;
  int ret ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 34
  fp = fopen((char const   * __restrict  )"/proc/filesystems", (char const   * __restrict  )"r");
#line 35
  if (! fp) {
#line 36
    while (1) {
#line 36
      ((*log_error))(3U, "%s: cannot open /proc/filesystems\n", "load_autofs4_module");
#line 36
      break;
    }
#line 37
    return (0);
  }
#line 40
  while (1) {
#line 40
    tmp___0 = fgets((char * __restrict  )(buf), 4095, (FILE * __restrict  )fp);
#line 40
    if (! tmp___0) {
#line 40
      break;
    }
#line 41
    tmp = strstr((char const   *)(buf), "autofs");
#line 41
    if (tmp) {
#line 42
      fclose(fp);
#line 43
      return (1);
    }
  }
#line 46
  fclose(fp);
#line 48
  ret = spawnl(log_debug, "/sbin/modprobe", "/sbin/modprobe", "-q", "autofs4", (void *)0);
#line 50
  if (ret) {
#line 51
    return (0);
  }
#line 53
  return (1);
}
}
#line 56 "module.c"
struct lookup_mod *open_lookup(char const   *name , char const   *err_prefix , char const   *mapfmt ,
                               int argc , char const   * const  *argv ) 
{ struct lookup_mod *mod ;
  char buf[128] ;
  char *fnbuf ;
  size_t size_name ;
  size_t size_fnbuf ;
  void *dh ;
  int *ver ;
  char *estr ;
  int *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *estr___0 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___11 ;

  {
#line 67
  size_name = _strlen(name, 4097U);
#line 68
  if (! size_name) {
#line 69
    return ((struct lookup_mod *)((void *)0));
  }
#line 71
  mod = (struct lookup_mod *)malloc(sizeof(struct lookup_mod ));
#line 72
  if (! mod) {
#line 73
    if (err_prefix) {
#line 74
      tmp = __errno_location();
#line 74
      tmp___0 = strerror_r((*tmp), buf, 128U);
#line 74
      estr = tmp___0;
#line 75
      while (1) {
#line 75
        ((*log_crit))(3U, "%s: %s%s", "open_lookup", err_prefix, estr);
#line 75
        break;
      }
    }
#line 77
    return ((struct lookup_mod *)((void *)0));
  }
#line 80
  tmp___1 = strlen("/usr/lib/autofs");
#line 80
  size_fnbuf = (size_name + tmp___1) + 13U;
#line 81
  fnbuf = (char *)__builtin_alloca(size_fnbuf);
#line 82
  if (! fnbuf) {
#line 83
    free((void *)mod);
#line 84
    if (err_prefix) {
#line 85
      tmp___2 = __errno_location();
#line 85
      tmp___3 = strerror_r((*tmp___2), buf, 128U);
#line 85
      estr___0 = tmp___3;
#line 86
      while (1) {
#line 86
        ((*log_crit))(3U, "%s: %s%s", "open_lookup", err_prefix, estr___0);
#line 86
        break;
      }
    }
#line 88
    return ((struct lookup_mod *)((void *)0));
  }
#line 90
  snprintf((char * __restrict  )fnbuf, size_fnbuf, (char const   * __restrict  )"%s/lookup_%s.so",
           "/usr/lib/autofs", name);
#line 92
  dh = dlopen((char const   *)fnbuf, 2);
#line 92
  if (! dh) {
#line 93
    if (err_prefix) {
#line 94
      while (1) {
#line 94
        tmp___4 = dlerror();
#line 94
        ((*log_crit))(3U, "%s: %scannot open lookup module %s (%s)", "open_lookup",
                      err_prefix, name, tmp___4);
#line 94
        break;
      }
    }
#line 96
    free((void *)mod);
#line 97
    return ((struct lookup_mod *)((void *)0));
  }
#line 100
  ver = (int *)dlsym((void * __restrict  )dh, (char const   * __restrict  )"lookup_version");
#line 100
  if (ver) {
#line 100
    if ((*ver) != 5) {
      _L: /* CIL Label */ 
#line 102
      if (err_prefix) {
#line 103
        while (1) {
#line 103
          ((*log_crit))(3U, "%s: %slookup module %s version mismatch", "open_lookup",
                        err_prefix, name);
#line 103
          break;
        }
      }
#line 106
      dlclose(dh);
#line 107
      free((void *)mod);
#line 108
      return ((struct lookup_mod *)((void *)0));
    }
  } else {
    goto _L;
  }
#line 111
  mod->lookup_init = (int (*)(char const   * , int  , char const   * const  * , void ** ))dlsym((void * __restrict  )dh,
                                                                                                (char const   * __restrict  )"lookup_init");
#line 111
  if (mod->lookup_init) {
#line 111
    mod->lookup_read_master = (int (*)(struct master *master , time_t  , void * ))dlsym((void * __restrict  )dh,
                                                                                        (char const   * __restrict  )"lookup_read_master");
#line 111
    if (mod->lookup_read_master) {
#line 111
      mod->lookup_read_map = (int (*)(struct autofs_point * , time_t  , void * ))dlsym((void * __restrict  )dh,
                                                                                       (char const   * __restrict  )"lookup_read_map");
#line 111
      if (mod->lookup_read_map) {
#line 111
        mod->lookup_mount = (int (*)(struct autofs_point * , char const   * , int  ,
                                     void * ))dlsym((void * __restrict  )dh, (char const   * __restrict  )"lookup_mount");
#line 111
        if (mod->lookup_mount) {
#line 111
          mod->lookup_done = (int (*)(void * ))dlsym((void * __restrict  )dh, (char const   * __restrict  )"lookup_done");
#line 111
          if (! mod->lookup_done) {
            _L___0: /* CIL Label */ 
#line 116
            if (err_prefix) {
#line 117
              while (1) {
#line 117
                ((*log_crit))(3U, "%s: %slookup module %s corrupt", "open_lookup",
                              err_prefix, name);
#line 117
                break;
              }
            }
#line 118
            dlclose(dh);
#line 119
            free((void *)mod);
#line 120
            return ((struct lookup_mod *)((void *)0));
          }
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    goto _L___0;
  }
#line 123
  tmp___11 = ((*(mod->lookup_init)))(mapfmt, argc, argv, & mod->context);
#line 123
  if (tmp___11) {
#line 124
    dlclose(dh);
#line 125
    free((void *)mod);
#line 126
    return ((struct lookup_mod *)((void *)0));
  }
#line 128
  mod->dlhandle = dh;
#line 129
  return (mod);
}
}
#line 132 "module.c"
int close_lookup(struct lookup_mod *mod ) 
{ int rv ;
  int tmp ;

  {
#line 134
  tmp = ((*(mod->lookup_done)))(mod->context);
#line 134
  rv = tmp;
#line 135
  dlclose(mod->dlhandle);
#line 136
  free((void *)mod);
#line 137
  return (rv);
}
}
#line 140 "module.c"
struct parse_mod *open_parse(char const   *name , char const   *err_prefix , int argc ,
                             char const   * const  *argv ) 
{ struct parse_mod *mod ;
  char buf[128] ;
  char *fnbuf ;
  size_t size_name ;
  size_t size_fnbuf ;
  void *dh ;
  int *ver ;
  char *estr ;
  int *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *estr___0 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___9 ;

  {
#line 151
  size_name = _strlen(name, 4097U);
#line 152
  if (! size_name) {
#line 153
    return ((struct parse_mod *)((void *)0));
  }
#line 155
  mod = (struct parse_mod *)malloc(sizeof(struct parse_mod ));
#line 156
  if (! mod) {
#line 157
    if (err_prefix) {
#line 158
      tmp = __errno_location();
#line 158
      tmp___0 = strerror_r((*tmp), buf, 128U);
#line 158
      estr = tmp___0;
#line 159
      while (1) {
#line 159
        ((*log_crit))(3U, "%s: %s%s", "open_parse", err_prefix, estr);
#line 159
        break;
      }
    }
#line 161
    return ((struct parse_mod *)((void *)0));
  }
#line 164
  tmp___1 = strlen("/usr/lib/autofs");
#line 164
  size_fnbuf = (size_name + tmp___1) + 13U;
#line 165
  fnbuf = (char *)__builtin_alloca(size_fnbuf);
#line 166
  if (! fnbuf) {
#line 167
    free((void *)mod);
#line 168
    if (err_prefix) {
#line 169
      tmp___2 = __errno_location();
#line 169
      tmp___3 = strerror_r((*tmp___2), buf, 128U);
#line 169
      estr___0 = tmp___3;
#line 170
      while (1) {
#line 170
        ((*log_crit))(3U, "%s: %s%s", "open_parse", err_prefix, estr___0);
#line 170
        break;
      }
    }
#line 172
    return ((struct parse_mod *)((void *)0));
  }
#line 174
  snprintf((char * __restrict  )fnbuf, size_fnbuf, (char const   * __restrict  )"%s/parse_%s.so",
           "/usr/lib/autofs", name);
#line 176
  dh = dlopen((char const   *)fnbuf, 2);
#line 176
  if (! dh) {
#line 177
    if (err_prefix) {
#line 178
      while (1) {
#line 178
        tmp___4 = dlerror();
#line 178
        ((*log_crit))(3U, "%s: %scannot open parse module %s (%s)", "open_parse",
                      err_prefix, name, tmp___4);
#line 178
        break;
      }
    }
#line 181
    free((void *)mod);
#line 182
    return ((struct parse_mod *)((void *)0));
  }
#line 185
  ver = (int *)dlsym((void * __restrict  )dh, (char const   * __restrict  )"parse_version");
#line 185
  if (ver) {
#line 185
    if ((*ver) != 5) {
      _L: /* CIL Label */ 
#line 187
      if (err_prefix) {
#line 188
        while (1) {
#line 188
          ((*log_crit))(3U, "%s: %sparse module %s version mismatch", "open_parse",
                        err_prefix, name);
#line 188
          break;
        }
      }
#line 191
      dlclose(dh);
#line 192
      free((void *)mod);
#line 193
      return ((struct parse_mod *)((void *)0));
    }
  } else {
    goto _L;
  }
#line 196
  mod->parse_init = (int (*)(int  , char const   * const  * , void ** ))dlsym((void * __restrict  )dh,
                                                                              (char const   * __restrict  )"parse_init");
#line 196
  if (mod->parse_init) {
#line 196
    mod->parse_mount = (int (*)(struct autofs_point * , char const   * , int  , char const   * ,
                                void * ))dlsym((void * __restrict  )dh, (char const   * __restrict  )"parse_mount");
#line 196
    if (mod->parse_mount) {
#line 196
      mod->parse_done = (int (*)(void * ))dlsym((void * __restrict  )dh, (char const   * __restrict  )"parse_done");
#line 196
      if (! mod->parse_done) {
        _L___0: /* CIL Label */ 
#line 199
        if (err_prefix) {
#line 200
          while (1) {
#line 200
            ((*log_crit))(3U, "%s: %sparse module %s corrupt", "open_parse", err_prefix,
                          name);
#line 200
            break;
          }
        }
#line 203
        dlclose(dh);
#line 204
        free((void *)mod);
#line 205
        return ((struct parse_mod *)((void *)0));
      }
    } else {
      goto _L___0;
    }
  } else {
    goto _L___0;
  }
#line 208
  tmp___9 = ((*(mod->parse_init)))(argc, argv, & mod->context);
#line 208
  if (tmp___9) {
#line 209
    dlclose(dh);
#line 210
    free((void *)mod);
#line 211
    return ((struct parse_mod *)((void *)0));
  }
#line 213
  mod->dlhandle = dh;
#line 214
  return (mod);
}
}
#line 217 "module.c"
int close_parse(struct parse_mod *mod ) 
{ int rv ;
  int tmp ;

  {
#line 219
  tmp = ((*(mod->parse_done)))(mod->context);
#line 219
  rv = tmp;
#line 220
  dlclose(mod->dlhandle);
#line 221
  free((void *)mod);
#line 222
  return (rv);
}
}
#line 225 "module.c"
struct mount_mod *open_mount(char const   *name , char const   *err_prefix ) 
{ struct mount_mod *mod ;
  char buf[128] ;
  char *fnbuf ;
  size_t size_name ;
  size_t size_fnbuf ;
  void *dh ;
  int *ver ;
  char *estr ;
  int *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *estr___0 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___9 ;

  {
#line 235
  size_name = _strlen(name, 4097U);
#line 236
  if (! size_name) {
#line 237
    return ((struct mount_mod *)((void *)0));
  }
#line 239
  mod = (struct mount_mod *)malloc(sizeof(struct mount_mod ));
#line 240
  if (! mod) {
#line 241
    if (err_prefix) {
#line 242
      tmp = __errno_location();
#line 242
      tmp___0 = strerror_r((*tmp), buf, 128U);
#line 242
      estr = tmp___0;
#line 243
      while (1) {
#line 243
        ((*log_crit))(3U, "%s: %s%s", "open_mount", err_prefix, estr);
#line 243
        break;
      }
    }
#line 245
    return ((struct mount_mod *)((void *)0));
  }
#line 248
  tmp___1 = strlen("/usr/lib/autofs");
#line 248
  size_fnbuf = (size_name + tmp___1) + 13U;
#line 249
  fnbuf = (char *)__builtin_alloca(size_fnbuf);
#line 250
  if (! fnbuf) {
#line 251
    free((void *)mod);
#line 252
    if (err_prefix) {
#line 253
      tmp___2 = __errno_location();
#line 253
      tmp___3 = strerror_r((*tmp___2), buf, 128U);
#line 253
      estr___0 = tmp___3;
#line 254
      while (1) {
#line 254
        ((*log_crit))(3U, "%s: %s%s", "open_mount", err_prefix, estr___0);
#line 254
        break;
      }
    }
#line 256
    return ((struct mount_mod *)((void *)0));
  }
#line 258
  snprintf((char * __restrict  )fnbuf, size_fnbuf, (char const   * __restrict  )"%s/mount_%s.so",
           "/usr/lib/autofs", name);
#line 260
  dh = dlopen((char const   *)fnbuf, 2);
#line 260
  if (! dh) {
#line 261
    if (err_prefix) {
#line 262
      while (1) {
#line 262
        tmp___4 = dlerror();
#line 262
        ((*log_crit))(3U, "%s: %scannot open mount module %s (%s)", "open_mount",
                      err_prefix, name, tmp___4);
#line 262
        break;
      }
    }
#line 265
    free((void *)mod);
#line 266
    return ((struct mount_mod *)((void *)0));
  }
#line 269
  ver = (int *)dlsym((void * __restrict  )dh, (char const   * __restrict  )"mount_version");
#line 269
  if (ver) {
#line 269
    if ((*ver) != 4) {
      _L: /* CIL Label */ 
#line 271
      if (err_prefix) {
#line 272
        while (1) {
#line 272
          ((*log_crit))(3U, "%s: %smount module %s version mismatch", "open_mount",
                        err_prefix, name);
#line 272
          break;
        }
      }
#line 275
      dlclose(dh);
#line 276
      free((void *)mod);
#line 277
      return ((struct mount_mod *)((void *)0));
    }
  } else {
    goto _L;
  }
#line 280
  mod->mount_init = (int (*)(void ** ))dlsym((void * __restrict  )dh, (char const   * __restrict  )"mount_init");
#line 280
  if (mod->mount_init) {
#line 280
    mod->mount_mount = (int (*)(struct autofs_point * , char const   * , char const   * ,
                                int  , char const   * , char const   * , char const   * ,
                                void * ))dlsym((void * __restrict  )dh, (char const   * __restrict  )"mount_mount");
#line 280
    if (mod->mount_mount) {
#line 280
      mod->mount_done = (int (*)(void * ))dlsym((void * __restrict  )dh, (char const   * __restrict  )"mount_done");
#line 280
      if (! mod->mount_done) {
        _L___0: /* CIL Label */ 
#line 283
        if (err_prefix) {
#line 284
          while (1) {
#line 284
            ((*log_crit))(3U, "%s: %smount module %s corrupt", "open_mount", err_prefix,
                          name);
#line 284
            break;
          }
        }
#line 287
        dlclose(dh);
#line 288
        free((void *)mod);
#line 289
        return ((struct mount_mod *)((void *)0));
      }
    } else {
      goto _L___0;
    }
  } else {
    goto _L___0;
  }
#line 292
  tmp___9 = ((*(mod->mount_init)))(& mod->context);
#line 292
  if (tmp___9) {
#line 293
    dlclose(dh);
#line 294
    free((void *)mod);
#line 295
    return ((struct mount_mod *)((void *)0));
  }
#line 297
  mod->dlhandle = dh;
#line 298
  return (mod);
}
}
#line 301 "module.c"
int close_mount(struct mount_mod *mod ) 
{ int rv ;
  int tmp ;

  {
#line 303
  tmp = ((*(mod->mount_done)))(mod->context);
#line 303
  rv = tmp;
#line 304
  dlclose(mod->dlhandle);
#line 305
  free((void *)mod);
#line 306
  return (rv);
}
}
#line 1 "mount.o"
#pragma merger(0,"/tmp/cil-r86XTcFO.i","-O2,-Wall,-fPIE")
#line 208 "../include/automount.h"
int do_mount(struct autofs_point *ap , char const   *root , char const   *name , int name_len ,
             char const   *what , char const   *fstype , char const   *options ) ;
#line 29 "mount.c"
static char *not_generic[7]  = {      (char *)"nfs",      (char *)"userfs",      (char *)"afs",      (char *)"autofs", 
        (char *)"changer",      (char *)"bind",      (char *)((void *)0)};
#line 33 "mount.c"
int do_mount(struct autofs_point *ap , char const   *root , char const   *name , int name_len ,
             char const   *what , char const   *fstype , char const   *options ) 
{ struct mount_mod *mod ;
  char const   *modstr ;
  char **ngp ;
  int rv ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 41
  modstr = fstype;
#line 41
  mod = open_mount(modstr, "(mount):");
#line 42
  if (! mod) {
#line 43
    ngp = not_generic;
#line 43
    while ((*ngp)) {
#line 44
      if (0) {
#line 44
        __s1_len = strlen(fstype);
#line 44
        __s2_len = strlen((char const   *)(*ngp));
#line 44
        if (! ((unsigned int )((void const   *)(fstype + 1)) - (unsigned int )((void const   *)fstype) == 1U)) {
          goto _L___0;
        } else {
#line 44
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 44
            if (! ((unsigned int )((void const   *)((*ngp) + 1)) - (unsigned int )((void const   *)(*ngp)) == 1U)) {
#line 44
              tmp___8 = 1;
            } else {
#line 44
              if (__s2_len >= 4U) {
#line 44
                tmp___8 = 1;
              } else {
#line 44
                tmp___8 = 0;
              }
            }
          } else {
#line 44
            tmp___8 = 0;
          }
        }
#line 44
        if (tmp___8) {
#line 44
          tmp___4 = __builtin_strcmp(fstype, (char const   *)(*ngp));
        } else {
#line 44
          tmp___7 = __builtin_strcmp(fstype, (char const   *)(*ngp));
#line 44
          tmp___4 = tmp___7;
        }
      } else {
#line 44
        tmp___7 = __builtin_strcmp(fstype, (char const   *)(*ngp));
#line 44
        tmp___4 = tmp___7;
      }
#line 44
      if (! tmp___4) {
#line 45
        break;
      }
#line 43
      ngp ++;
    }
#line 47
    if (! (*ngp)) {
#line 48
      modstr = "generic";
#line 48
      mod = open_mount(modstr, "(mount):");
    }
#line 49
    if (! mod) {
#line 50
      while (1) {
#line 50
        ((*log_error))(ap->logopt, "%s: cannot find mount method for filesystem %s",
                       "do_mount", fstype);
#line 50
        break;
      }
#line 53
      return (-1);
    }
  }
#line 57
  if (ap->type == 4U) {
#line 58
    while (1) {
#line 58
      ((*log_debug))(ap->logopt, "%s: %s %s type %s options %s using module %s", "do_mount",
                     what, name, fstype, options, modstr);
#line 58
      break;
    }
  } else {
#line 62
    while (1) {
#line 62
      ((*log_debug))(ap->logopt, "%s: %s %s/%s type %s options %s using module %s",
                     "do_mount", what, root, name, fstype, options, modstr);
#line 62
      break;
    }
  }
#line 66
  rv = ((*(mod->mount_mount)))(ap, root, name, name_len, what, fstype, options, mod->context);
#line 67
  close_mount(mod);
#line 69
  return (rv);
}
}
#line 1 "lookup.o"
#pragma merger(0,"/tmp/cil-jfSX7yip.i","-O2,-Wall,-fPIE")
#line 102 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 331
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 107 "../include/list.h"
__inline static int list_empty(struct list_head *head ) 
{ 

  {
#line 109
  return ((unsigned int )head->next == (unsigned int )head);
}
}
#line 85 "../include/master.h"
extern struct map_source *master_find_source_instance(struct map_source * , char const   * ,
                                                      char const   * , int  , char const   ** ) ;
#line 87
extern struct map_source *master_add_source_instance(struct map_source * , char const   * ,
                                                     char const   * , time_t  , int  ,
                                                     char const   ** ) ;
#line 89
extern void send_map_update_request(struct autofs_point * ) ;
#line 94
extern void master_source_current_wait(struct master_mapent * ) ;
#line 164 "../include/automount.h"
extern void cache_writelock(struct mapent_cache *mc ) ;
#line 175
extern struct mapent *cache_lookup(struct mapent_cache *mc , char const   *key ) ;
#line 195
extern char const   **copy_argv(int argc , char const   **argv ) ;
#line 197
extern int free_argv(int argc , char const   **argv ) ;
#line 224
int lookup_nss_read_master(struct master *master , time_t age ) ;
#line 232
struct mapent *lookup_source_valid_mapent(struct autofs_point *ap , char const   *key ,
                                          unsigned int type ) ;
#line 60 "../include/nsswitch.h"
extern int free_sources(struct list_head *list ) ;
#line 62
extern int nsswitch_parse(struct list_head *list ) ;
#line 29 "lookup.c"
static int check_nss_result(struct nss_source *this , enum nsswitch_status result ) 
{ enum nsswitch_status status ;
  struct nss_action a ;

  {
#line 35
  status = (enum nsswitch_status )0;
#line 35
  while ((int )status < 4) {
#line 36
    a = this->action[status];
#line 37
    if ((int )a.action == 0) {
      goto __Cont;
    }
#line 40
    if (a.negated) {
#line 40
      if ((int )result != (int )status) {
#line 41
        if ((int )a.action == 2) {
#line 42
          if ((int )result == 0) {
#line 43
            return (1);
          } else {
#line 45
            return (0);
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 35
    status = (enum nsswitch_status )((int )status + 1);
  }
#line 50
  a = this->action[result];
#line 53
  switch ((int )result) {
  case 0: 
#line 55
  if ((int )a.action == 1) {
#line 56
    break;
  }
#line 57
  return (1);
  case 1: 
  case 2: 
  case 3: 
#line 62
  if ((int )a.action == 2) {
#line 63
    return (0);
  }
#line 65
  break;
  default: ;
#line 68
  break;
  }
#line 71
  return (-1);
}
}
#line 74 "lookup.c"
static void nsslist_cleanup(void *arg ) 
{ struct list_head *nsslist ;
  int tmp ;

  {
#line 76
  nsslist = (struct list_head *)arg;
#line 77
  tmp = list_empty(nsslist);
#line 77
  if (! tmp) {
#line 78
    free_sources(nsslist);
  }
#line 79
  return;
}
}
#line 82 "lookup.c"
static int do_read_master___0(struct master *master , char *type , time_t age ) 
{ struct lookup_mod *lookup ;
  char const   *argv[2] ;
  int argc ;
  int status ;

  {
#line 89
  argc = 1;
#line 90
  argv[0] = (char const   *)master->name;
#line 91
  argv[1] = (char const   *)((void *)0);
#line 93
  lookup = open_lookup((char const   *)type, "", (char const   *)((void *)0), argc,
                       (char const   * const  *)(argv));
#line 94
  if (! lookup) {
#line 95
    return (2);
  }
#line 97
  status = ((*(lookup->lookup_read_master)))(master, age, lookup->context);
#line 99
  close_lookup(lookup);
#line 101
  return (status);
}
}
#line 104 "lookup.c"
static int read_master_map(struct master *master , char *type , time_t age ) 
{ char *path ;
  char *save_name ;
  int result ;
  int tmp ;
  int tmp___0 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
#line 109
  tmp___0 = strcasecmp((char const   *)type, "files");
#line 109
  if (tmp___0) {
#line 110
    tmp = do_read_master___0(master, type, age);
#line 110
    return (tmp);
  }
#line 119
  tmp___2 = __builtin_strchr(master->name, (char )'/');
#line 119
  if (tmp___2) {
#line 120
    while (1) {
#line 120
      ((*log_error))(3U, "%s: relative path invalid in files map name", "read_master_map");
#line 120
      break;
    }
#line 121
    return (1);
  }
#line 124
  tmp___3 = strlen("/etc");
#line 124
  tmp___4 = strlen((char const   *)master->name);
#line 124
  path = (char *)malloc((tmp___3 + tmp___4) + 2U);
#line 125
  if (! path) {
#line 126
    return (-1);
  }
#line 128
  strcpy((char * __restrict  )path, (char const   * __restrict  )"/etc");
#line 129
  strcat((char * __restrict  )path, (char const   * __restrict  )"/");
#line 130
  strcat((char * __restrict  )path, (char const   * __restrict  )master->name);
#line 132
  save_name = master->name;
#line 133
  master->name = path;
#line 135
  result = do_read_master___0(master, type, age);
#line 137
  master->name = save_name;
#line 138
  free((void *)path);
#line 140
  return (result);
}
}
#line 143 "lookup.c"
int lookup_nss_read_master(struct master *master , time_t age ) 
{ struct list_head nsslist ;
  struct list_head *head ;
  struct list_head *p ;
  int result ;
  char *name ;
  char *tmp ;
  char *tmp___1 ;
  char source[10] ;
  int tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___41 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___47 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___67 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___73 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___93 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___99 ;
  int tmp___102 ;
  int tmp___103 ;
  int tmp___119 ;
  size_t __s1_len___8 ;
  size_t __s2_len___8 ;
  int tmp___125 ;
  int tmp___128 ;
  int tmp___129 ;
  int tmp___145 ;
  size_t __s1_len___10 ;
  size_t __s2_len___10 ;
  int tmp___151 ;
  int tmp___154 ;
  int tmp___155 ;
  int tmp___171 ;
  size_t __s1_len___12 ;
  size_t __s2_len___12 ;
  int tmp___177 ;
  int tmp___180 ;
  int tmp___181 ;
  int tmp___184 ;
  struct nss_source *this ;
  int status ;
  int tmp___185 ;

  {
#line 147
  result = -1;
#line 150
  if ((int )(*(master->name)) == 47) {
#line 151
    if ((int )(*(master->name + 1)) == 47) {
#line 152
      while (1) {
#line 152
        ((*log_debug))(0U, "%s: reading master ldap %s", "lookup_nss_read_master",
                       master->name);
#line 152
        break;
      }
#line 154
      result = do_read_master___0(master, (char *)"ldap", age);
    } else {
#line 156
      while (1) {
#line 156
        ((*log_debug))(0U, "%s: reading master file %s", "lookup_nss_read_master",
                       master->name);
#line 156
        break;
      }
#line 158
      result = do_read_master___0(master, (char *)"file", age);
    }
#line 161
    return (! result);
  } else {
#line 163
    name = master->name;
#line 167
    tmp___1 = __builtin_strchr(name, (char )':');
#line 167
    tmp = tmp___1;
#line 168
    if (tmp) {
#line 171
      memset((void *)(source), 0, 10U);
#line 172
      if (0) {
#line 172
        if (0) {
#line 172
          __s1_len___2 = strlen((char const   *)name);
#line 172
          __s2_len___2 = strlen("file:");
#line 172
          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
            goto _L___6;
          } else {
#line 172
            if (__s1_len___2 >= 4U) {
              _L___6: /* CIL Label */ 
#line 172
              if (! ((unsigned int )((void const   *)("file:" + 1)) - (unsigned int )((void const   *)"file:") == 1U)) {
#line 172
                tmp___51 = 1;
              } else {
#line 172
                if (__s2_len___2 >= 4U) {
#line 172
                  tmp___51 = 1;
                } else {
#line 172
                  tmp___51 = 0;
                }
              }
            } else {
#line 172
              tmp___51 = 0;
            }
          }
#line 172
          if (tmp___51) {
#line 172
            tmp___47 = __builtin_strcmp((char const   *)name, "file:");
          } else {
#line 172
            tmp___50 = __builtin_strcmp((char const   *)name, "file:");
#line 172
            tmp___47 = tmp___50;
          }
        } else {
#line 172
          tmp___50 = __builtin_strcmp((char const   *)name, "file:");
#line 172
          tmp___47 = tmp___50;
        }
#line 172
        tmp___41 = tmp___47;
      } else {
#line 172
        tmp___41 = strncmp((char const   *)name, "file:", 5U);
      }
#line 177
      if (tmp___41) {
#line 173
        if (0) {
#line 173
          if (0) {
#line 173
            __s1_len___4 = strlen((char const   *)name);
#line 173
            __s2_len___4 = strlen("yp:");
#line 173
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
              goto _L___10;
            } else {
#line 173
              if (__s1_len___4 >= 4U) {
                _L___10: /* CIL Label */ 
#line 173
                if (! ((unsigned int )((void const   *)("yp:" + 1)) - (unsigned int )((void const   *)"yp:") == 1U)) {
#line 173
                  tmp___77 = 1;
                } else {
#line 173
                  if (__s2_len___4 >= 4U) {
#line 173
                    tmp___77 = 1;
                  } else {
#line 173
                    tmp___77 = 0;
                  }
                }
              } else {
#line 173
                tmp___77 = 0;
              }
            }
#line 173
            if (tmp___77) {
#line 173
              tmp___73 = __builtin_strcmp((char const   *)name, "yp:");
            } else {
#line 173
              tmp___76 = __builtin_strcmp((char const   *)name, "yp:");
#line 173
              tmp___73 = tmp___76;
            }
          } else {
#line 173
            tmp___76 = __builtin_strcmp((char const   *)name, "yp:");
#line 173
            tmp___73 = tmp___76;
          }
#line 173
          tmp___67 = tmp___73;
        } else {
#line 173
          tmp___67 = strncmp((char const   *)name, "yp:", 3U);
        }
#line 177
        if (tmp___67) {
#line 174
          if (0) {
#line 174
            if (0) {
#line 174
              __s1_len___6 = strlen((char const   *)name);
#line 174
              __s2_len___6 = strlen("nis:");
#line 174
              if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                goto _L___14;
              } else {
#line 174
                if (__s1_len___6 >= 4U) {
                  _L___14: /* CIL Label */ 
#line 174
                  if (! ((unsigned int )((void const   *)("nis:" + 1)) - (unsigned int )((void const   *)"nis:") == 1U)) {
#line 174
                    tmp___103 = 1;
                  } else {
#line 174
                    if (__s2_len___6 >= 4U) {
#line 174
                      tmp___103 = 1;
                    } else {
#line 174
                      tmp___103 = 0;
                    }
                  }
                } else {
#line 174
                  tmp___103 = 0;
                }
              }
#line 174
              if (tmp___103) {
#line 174
                tmp___99 = __builtin_strcmp((char const   *)name, "nis:");
              } else {
#line 174
                tmp___102 = __builtin_strcmp((char const   *)name, "nis:");
#line 174
                tmp___99 = tmp___102;
              }
            } else {
#line 174
              tmp___102 = __builtin_strcmp((char const   *)name, "nis:");
#line 174
              tmp___99 = tmp___102;
            }
#line 174
            tmp___93 = tmp___99;
          } else {
#line 174
            tmp___93 = strncmp((char const   *)name, "nis:", 4U);
          }
#line 177
          if (tmp___93) {
#line 175
            if (0) {
#line 175
              if (0) {
#line 175
                __s1_len___8 = strlen((char const   *)name);
#line 175
                __s2_len___8 = strlen("nisplus:");
#line 175
                if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                  goto _L___18;
                } else {
#line 175
                  if (__s1_len___8 >= 4U) {
                    _L___18: /* CIL Label */ 
#line 175
                    if (! ((unsigned int )((void const   *)("nisplus:" + 1)) - (unsigned int )((void const   *)"nisplus:") == 1U)) {
#line 175
                      tmp___129 = 1;
                    } else {
#line 175
                      if (__s2_len___8 >= 4U) {
#line 175
                        tmp___129 = 1;
                      } else {
#line 175
                        tmp___129 = 0;
                      }
                    }
                  } else {
#line 175
                    tmp___129 = 0;
                  }
                }
#line 175
                if (tmp___129) {
#line 175
                  tmp___125 = __builtin_strcmp((char const   *)name, "nisplus:");
                } else {
#line 175
                  tmp___128 = __builtin_strcmp((char const   *)name, "nisplus:");
#line 175
                  tmp___125 = tmp___128;
                }
              } else {
#line 175
                tmp___128 = __builtin_strcmp((char const   *)name, "nisplus:");
#line 175
                tmp___125 = tmp___128;
              }
#line 175
              tmp___119 = tmp___125;
            } else {
#line 175
              tmp___119 = strncmp((char const   *)name, "nisplus:", 8U);
            }
#line 177
            if (tmp___119) {
#line 176
              if (0) {
#line 176
                if (0) {
#line 176
                  __s1_len___10 = strlen((char const   *)name);
#line 176
                  __s2_len___10 = strlen("ldap:");
#line 176
                  if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                    goto _L___22;
                  } else {
#line 176
                    if (__s1_len___10 >= 4U) {
                      _L___22: /* CIL Label */ 
#line 176
                      if (! ((unsigned int )((void const   *)("ldap:" + 1)) - (unsigned int )((void const   *)"ldap:") == 1U)) {
#line 176
                        tmp___155 = 1;
                      } else {
#line 176
                        if (__s2_len___10 >= 4U) {
#line 176
                          tmp___155 = 1;
                        } else {
#line 176
                          tmp___155 = 0;
                        }
                      }
                    } else {
#line 176
                      tmp___155 = 0;
                    }
                  }
#line 176
                  if (tmp___155) {
#line 176
                    tmp___151 = __builtin_strcmp((char const   *)name, "ldap:");
                  } else {
#line 176
                    tmp___154 = __builtin_strcmp((char const   *)name, "ldap:");
#line 176
                    tmp___151 = tmp___154;
                  }
                } else {
#line 176
                  tmp___154 = __builtin_strcmp((char const   *)name, "ldap:");
#line 176
                  tmp___151 = tmp___154;
                }
#line 176
                tmp___145 = tmp___151;
              } else {
#line 176
                tmp___145 = strncmp((char const   *)name, "ldap:", 5U);
              }
#line 177
              if (tmp___145) {
#line 177
                if (0) {
#line 177
                  if (0) {
#line 177
                    __s1_len___12 = strlen((char const   *)name);
#line 177
                    __s2_len___12 = strlen("ldaps:");
#line 177
                    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                      goto _L___26;
                    } else {
#line 177
                      if (__s1_len___12 >= 4U) {
                        _L___26: /* CIL Label */ 
#line 177
                        if (! ((unsigned int )((void const   *)("ldaps:" + 1)) - (unsigned int )((void const   *)"ldaps:") == 1U)) {
#line 177
                          tmp___181 = 1;
                        } else {
#line 177
                          if (__s2_len___12 >= 4U) {
#line 177
                            tmp___181 = 1;
                          } else {
#line 177
                            tmp___181 = 0;
                          }
                        }
                      } else {
#line 177
                        tmp___181 = 0;
                      }
                    }
#line 177
                    if (tmp___181) {
#line 177
                      tmp___177 = __builtin_strcmp((char const   *)name, "ldaps:");
                    } else {
#line 177
                      tmp___180 = __builtin_strcmp((char const   *)name, "ldaps:");
#line 177
                      tmp___177 = tmp___180;
                    }
                  } else {
#line 177
                    tmp___180 = __builtin_strcmp((char const   *)name, "ldaps:");
#line 177
                    tmp___177 = tmp___180;
                  }
#line 177
                  tmp___171 = tmp___177;
                } else {
#line 177
                  tmp___171 = strncmp((char const   *)name, "ldaps:", 6U);
                }
#line 177
                if (! tmp___171) {
                  _L___27: /* CIL Label */ 
#line 178
                  __builtin_strncpy(source, (char const   *)name, (unsigned int )(tmp - name));
#line 185
                  if (0) {
#line 185
                    if (0) {
#line 185
                      __s1_len___0 = strlen((char const   *)name);
#line 185
                      __s2_len___0 = strlen("ldap");
#line 185
                      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                        goto _L___2;
                      } else {
#line 185
                        if (__s1_len___0 >= 4U) {
                          _L___2: /* CIL Label */ 
#line 185
                          if (! ((unsigned int )((void const   *)("ldap" + 1)) - (unsigned int )((void const   *)"ldap") == 1U)) {
#line 185
                            tmp___25 = 1;
                          } else {
#line 185
                            if (__s2_len___0 >= 4U) {
#line 185
                              tmp___25 = 1;
                            } else {
#line 185
                              tmp___25 = 0;
                            }
                          }
                        } else {
#line 185
                          tmp___25 = 0;
                        }
                      }
#line 185
                      if (tmp___25) {
#line 185
                        tmp___21 = __builtin_strcmp((char const   *)name, "ldap");
                      } else {
#line 185
                        tmp___24 = __builtin_strcmp((char const   *)name, "ldap");
#line 185
                        tmp___21 = tmp___24;
                      }
                    } else {
#line 185
                      tmp___24 = __builtin_strcmp((char const   *)name, "ldap");
#line 185
                      tmp___21 = tmp___24;
                    }
#line 185
                    tmp___15 = tmp___21;
                  } else {
#line 185
                    tmp___15 = strncmp((char const   *)name, "ldap", 4U);
                  }
#line 185
                  if (tmp___15) {
#line 186
                    master->name = tmp + 1;
#line 187
                    while (1) {
#line 187
                      ((*log_debug))(0U, "%s: reading master %s %s", "lookup_nss_read_master",
                                     source, master->name);
#line 187
                      break;
                    }
                  } else {
#line 191
                    master->name = name;
#line 192
                    while (1) {
#line 192
                      ((*log_debug))(0U, "%s: reading master %s %s", "lookup_nss_read_master",
                                     source, tmp + 1);
#line 192
                      break;
                    }
                  }
#line 197
                  result = do_read_master___0(master, source, age);
#line 198
                  master->name = name;
#line 200
                  return (! result);
                }
              } else {
                goto _L___27;
              }
            } else {
              goto _L___27;
            }
          } else {
            goto _L___27;
          }
        } else {
          goto _L___27;
        }
      } else {
        goto _L___27;
      }
    }
  }
#line 205
  while (1) {
#line 205
    nsslist.next = & nsslist;
#line 205
    nsslist.prev = & nsslist;
#line 205
    break;
  }
#line 207
  result = nsswitch_parse(& nsslist);
#line 208
  if (result) {
#line 209
    tmp___184 = list_empty(& nsslist);
#line 209
    if (! tmp___184) {
#line 210
      free_sources(& nsslist);
    }
#line 211
    while (1) {
#line 211
      ((*log_error))(3U, "%s: can\'t to read name service switch config.", "lookup_nss_read_master");
#line 211
      break;
    }
#line 212
    return (0);
  }
#line 216
  head = & nsslist;
#line 217
  p = head->next;
#line 217
  while ((unsigned int )p != (unsigned int )head) {
#line 221
    this = (struct nss_source *)((char *)p - (unsigned long )(& ((struct nss_source *)0)->list));
#line 223
    while (1) {
#line 223
      ((*log_debug))(0U, "%s: reading master %s %s", "lookup_nss_read_master", this->source,
                     master->name);
#line 223
      break;
    }
#line 226
    result = read_master_map(master, this->source, age);
#line 227
    if (result == -1) {
#line 228
      while (1) {
#line 228
        ((*log_debug))(0U, "%s: no map - continuing to next source", "lookup_nss_read_master");
#line 228
        break;
      }
      goto __Cont;
    }
#line 233
    status = check_nss_result(this, (enum nsswitch_status )result);
#line 234
    if (status >= 0) {
#line 235
      free_sources(& nsslist);
#line 236
      return (status);
    }
    __Cont: /* CIL Label */ 
#line 217
    p = p->next;
  }
#line 240
  tmp___185 = list_empty(& nsslist);
#line 240
  if (! tmp___185) {
#line 241
    free_sources(& nsslist);
  }
#line 243
  return (! result);
}
}
#line 246 "lookup.c"
static int do_read_map(struct autofs_point *ap , struct map_source *map , time_t age ) 
{ struct lookup_mod *lookup ;
  int status ;

  {
#line 251
  if (! map->lookup) {
#line 252
    lookup = open_lookup((char const   *)map->type, "", (char const   *)map->format,
                         map->argc, (char const   * const  *)map->argv);
#line 254
    if (! lookup) {
#line 255
      while (1) {
#line 255
        ((*log_debug))(ap->logopt, "%s: lookup module %s failed", "do_read_map", map->type);
#line 255
        break;
      }
#line 256
      return (2);
    }
#line 258
    map->lookup = lookup;
  }
#line 261
  lookup = map->lookup;
#line 271
  if (! ap->ghost) {
#line 271
    if (ap->type != 4U) {
#line 272
      return (0);
    }
  }
#line 274
  if (! map->stale) {
#line 275
    return (0);
  }
#line 277
  master_source_current_wait(ap->entry);
#line 278
  (ap->entry)->current = map;
#line 280
  status = ((*(lookup->lookup_read_map)))(ap, age, lookup->context);
#line 282
  map->stale = 0U;
#line 289
  if (status == -1) {
#line 290
    return (0);
  }
#line 292
  return (status);
}
}
#line 295 "lookup.c"
static int read_file_source_instance(struct autofs_point *ap , struct map_source *map ,
                                     time_t age ) 
{ struct map_source *instance ;
  char src_file[5] ;
  char src_prog[8] ;
  struct stat st ;
  char *type ;
  char *format ;
  int tmp ;
  int argc ;
  char const   **argv ;
  int tmp___0 ;

  {
#line 298
  src_file[0] = (char )'f';
#line 298
  src_file[1] = (char )'i';
#line 298
  src_file[2] = (char )'l';
#line 298
  src_file[3] = (char )'e';
#line 298
  src_file[4] = (char )'\000';
#line 299
  src_prog[0] = (char )'p';
#line 299
  src_prog[1] = (char )'r';
#line 299
  src_prog[2] = (char )'o';
#line 299
  src_prog[3] = (char )'g';
#line 299
  src_prog[4] = (char )'r';
#line 299
  src_prog[5] = (char )'a';
#line 299
  src_prog[6] = (char )'m';
#line 299
  src_prog[7] = (char )'\000';
#line 303
  tmp = stat__extinline((*(map->argv + 0)), & st);
#line 303
  if (tmp == -1) {
#line 304
    while (1) {
#line 304
      ((*log_warn))(ap->logopt, "%s: file map %s not found", "read_file_source_instance",
                    (*(map->argv + 0)));
#line 304
      break;
    }
#line 305
    return (1);
  }
#line 308
  if (! ((st.st_mode & 61440U) == 32768U)) {
#line 309
    return (1);
  }
#line 311
  if (st.st_mode & 64U) {
#line 312
    type = src_prog;
  } else {
#line 314
    type = src_file;
  }
#line 316
  format = map->format;
#line 318
  instance = master_find_source_instance(map, (char const   *)type, (char const   *)format,
                                         0, (char const   **)((void *)0));
#line 319
  if (! instance) {
#line 320
    argc = map->argc;
#line 321
    argv = map->argv;
#line 322
    instance = master_add_source_instance(map, (char const   *)type, (char const   *)format,
                                          age, argc, argv);
#line 323
    if (! instance) {
#line 324
      return (2);
    }
#line 325
    instance->recurse = map->recurse;
#line 326
    instance->depth = map->depth;
  }
#line 329
  tmp___0 = do_read_map(ap, instance, age);
#line 329
  return (tmp___0);
}
}
#line 332 "lookup.c"
static int read_source_instance(struct autofs_point *ap , struct map_source *map ,
                                char const   *type , time_t age ) 
{ struct map_source *instance ;
  char const   *format ;
  int argc ;
  char const   **argv ;
  int tmp ;

  {
#line 337
  format = (char const   *)map->format;
#line 339
  instance = master_find_source_instance(map, type, format, 0, (char const   **)((void *)0));
#line 340
  if (! instance) {
#line 341
    argc = map->argc;
#line 342
    argv = map->argv;
#line 343
    instance = master_add_source_instance(map, type, format, age, argc, argv);
#line 344
    if (! instance) {
#line 345
      return (2);
    }
#line 346
    instance->recurse = map->recurse;
#line 347
    instance->depth = map->depth;
  }
#line 350
  tmp = do_read_map(ap, instance, age);
#line 350
  return (tmp);
}
}
#line 353 "lookup.c"
static void argv_cleanup(void *arg ) 
{ struct map_source *tmap ;

  {
#line 355
  tmap = (struct map_source *)arg;
#line 357
  free_argv(tmap->argc, tmap->argv);
#line 358
  return;
}
}
#line 361 "lookup.c"
static enum nsswitch_status read_map_source(struct nss_source *this , struct autofs_point *ap ,
                                            struct map_source *map , time_t age ) 
{ enum nsswitch_status result ;
  struct map_source tmap ;
  char *path ;
  enum nsswitch_status tmp ;
  int tmp___0 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___5 ;
  long tmp___6 ;

  {
#line 368
  tmp___0 = strcasecmp((char const   *)this->source, "files");
#line 368
  if (tmp___0) {
#line 369
    tmp = (enum nsswitch_status )read_source_instance(ap, map, (char const   *)this->source,
                                                      age);
#line 369
    return (tmp);
  }
#line 379
  tmp___2 = __builtin_strchr((char *)(*(map->argv + 0)), (char )'/');
#line 379
  if (tmp___2) {
#line 380
    while (1) {
#line 380
      ((*log_error))(ap->logopt, "%s: relative path invalid in files map name", "read_map_source");
#line 380
      break;
    }
#line 381
    return (1);
  }
#line 384
  (*(this->source + 4)) = (char )'\000';
#line 385
  tmap.type = this->source;
#line 386
  tmap.format = map->format;
#line 387
  tmap.lookup = map->lookup;
#line 388
  tmap.mc = map->mc;
#line 389
  tmap.instance = map->instance;
#line 390
  tmap.recurse = map->recurse;
#line 391
  tmap.depth = map->depth;
#line 392
  tmap.argc = 0;
#line 393
  tmap.argv = (char const   **)((void *)0);
#line 395
  tmp___3 = strlen("/etc");
#line 395
  tmp___4 = strlen((*(map->argv + 0)));
#line 395
  path = (char *)malloc((tmp___3 + tmp___4) + 2U);
#line 396
  if (! path) {
#line 397
    return (-1);
  }
#line 399
  strcpy((char * __restrict  )path, (char const   * __restrict  )"/etc");
#line 400
  strcat((char * __restrict  )path, (char const   * __restrict  )"/");
#line 401
  strcat((char * __restrict  )path, (char const   * __restrict  )(*(map->argv + 0)));
#line 403
  if (map->argc >= 1) {
#line 404
    tmap.argc = map->argc;
#line 405
    tmap.argv = copy_argv(map->argc, map->argv);
#line 406
    if (! tmap.argv) {
#line 407
      while (1) {
#line 407
        ((*log_error))(ap->logopt, "%s: failed to copy args", "read_map_source");
#line 407
        break;
      }
#line 408
      free((void *)path);
#line 409
      return (-1);
    }
#line 411
    if ((*(tmap.argv + 0))) {
#line 412
      free((void *)((char *)(*(tmap.argv + 0))));
    }
#line 413
    (*(tmap.argv + 0)) = (char const   *)path;
  } else {
#line 415
    while (1) {
#line 415
      ((*log_error))(ap->logopt, "%s: invalid arguments for autofs_point", "read_map_source");
#line 415
      break;
    }
#line 416
    free((void *)path);
#line 417
    return (-1);
  }
#line 420
  while (1) {
#line 420
    __cancel_routine = & argv_cleanup;
#line 420
    __cancel_arg = (void *)(& tmap);
#line 420
    tmp___5 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
#line 420
    not_first_call = tmp___5;
#line 420
    tmp___6 = __builtin_expect((long )not_first_call, 0L);
#line 420
    if (tmp___6) {
#line 420
      ((*__cancel_routine))(__cancel_arg);
#line 420
      __pthread_unwind_next(& __cancel_buf);
    }
#line 420
    __pthread_register_cancel(& __cancel_buf);
#line 420
    while (1) {
#line 421
      result = (enum nsswitch_status )read_file_source_instance(ap, & tmap, age);
#line 420
      break;
    }
#line 422
    __pthread_unregister_cancel(& __cancel_buf);
#line 422
    ((*__cancel_routine))(__cancel_arg);
#line 420
    break;
  }
#line 424
  map->instance = tmap.instance;
#line 426
  return (result);
}
}
#line 429 "lookup.c"
int lookup_nss_read_map(struct autofs_point *ap , struct map_source *source , time_t age ) 
{ struct master_mapent *entry ;
  struct list_head nsslist ;
  struct list_head *head ;
  struct list_head *p ;
  struct nss_source *this ;
  struct map_source *map ;
  enum nsswitch_status status ;
  unsigned int at_least_one ;
  int result ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp ;
  long tmp___0 ;
  char *tmp___1 ;
  char *tmp___11 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___0)(void * ) ;
  void *__cancel_arg___0 ;
  int not_first_call___0 ;
  int tmp___12 ;
  long tmp___13 ;
  __pthread_unwind_buf_t __cancel_buf___1 ;
  void (*__cancel_routine___1)(void * ) ;
  void *__cancel_arg___1 ;
  int not_first_call___1 ;
  int tmp___14 ;
  long tmp___15 ;

  {
#line 431
  entry = ap->entry;
#line 437
  at_least_one = 0U;
#line 438
  result = 0;
#line 445
  while (1) {
#line 445
    __cancel_routine = & master_source_lock_cleanup;
#line 445
    __cancel_arg = (void *)entry;
#line 445
    tmp = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf), 0);
#line 445
    not_first_call = tmp;
#line 445
    tmp___0 = __builtin_expect((long )not_first_call, 0L);
#line 445
    if (tmp___0) {
#line 445
      ((*__cancel_routine))(__cancel_arg);
#line 445
      __pthread_unwind_next(& __cancel_buf);
    }
#line 445
    __pthread_register_cancel(& __cancel_buf);
#line 445
    while (1) {
#line 446
      master_source_readlock(entry);
#line 447
      if (source) {
#line 448
        map = source;
      } else {
#line 450
        map = entry->maps;
      }
#line 451
      while (map) {
#line 453
        if (! map->stale) {
#line 454
          map = map->next;
#line 455
          continue;
        } else {
#line 453
          if (entry->age > map->age) {
#line 454
            map = map->next;
#line 455
            continue;
          }
        }
#line 458
        if (map->type) {
#line 459
          while (1) {
#line 459
            ((*log_debug))(ap->logopt, "%s: reading map %s %s", "lookup_nss_read_map",
                           map->type, (*(map->argv + 0)));
#line 459
            break;
          }
#line 461
          result = do_read_map(ap, map, age);
#line 462
          map = map->next;
#line 463
          continue;
        }
#line 467
        if (map->argv) {
#line 467
          if ((int const   )(*((*(map->argv + 0)))) == 47) {
#line 468
            if ((int const   )(*((*(map->argv + 0)) + 1)) == 47) {
#line 469
              tmp___11 = __strdup("ldap");
#line 469
              tmp___1 = tmp___11;
#line 470
              if (! tmp___1) {
#line 471
                map = map->next;
#line 472
                continue;
              }
#line 474
              map->type = tmp___1;
#line 475
              while (1) {
#line 475
                ((*log_debug))(ap->logopt, "%s: reading map %s %s", "lookup_nss_read_map",
                               tmp___1, (*(map->argv + 0)));
#line 475
                break;
              }
#line 477
              result = do_read_map(ap, map, age);
            } else {
#line 479
              while (1) {
#line 479
                ((*log_debug))(ap->logopt, "%s: reading map file %s", "lookup_nss_read_map",
                               (*(map->argv + 0)));
#line 479
                break;
              }
#line 481
              result = read_file_source_instance(ap, map, age);
            }
#line 483
            map = map->next;
#line 484
            continue;
          }
        }
#line 487
        while (1) {
#line 487
          nsslist.next = & nsslist;
#line 487
          nsslist.prev = & nsslist;
#line 487
          break;
        }
#line 489
        while (1) {
#line 489
          __cancel_routine___0 = & nsslist_cleanup;
#line 489
          __cancel_arg___0 = (void *)(& nsslist);
#line 489
          tmp___12 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf),
                                 0);
#line 489
          not_first_call___0 = tmp___12;
#line 489
          tmp___13 = __builtin_expect((long )not_first_call___0, 0L);
#line 489
          if (tmp___13) {
#line 489
            ((*__cancel_routine___0))(__cancel_arg___0);
#line 489
            __pthread_unwind_next(& __cancel_buf___0);
          }
#line 489
          __pthread_register_cancel(& __cancel_buf___0);
#line 489
          while (1) {
#line 490
            status = (enum nsswitch_status )nsswitch_parse(& nsslist);
#line 489
            break;
          }
#line 491
          __pthread_unregister_cancel(& __cancel_buf___0);
#line 489
          break;
        }
#line 492
        if (status) {
#line 493
          while (1) {
#line 493
            ((*log_error))(ap->logopt, "%s: can\'t to read name service switch config.",
                           "lookup_nss_read_map");
#line 493
            break;
          }
#line 495
          result = 1;
#line 496
          break;
        }
#line 499
        while (1) {
#line 499
          __cancel_routine___1 = & nsslist_cleanup;
#line 499
          __cancel_arg___1 = (void *)(& nsslist);
#line 499
          tmp___14 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___1.__cancel_jmp_buf),
                                 0);
#line 499
          not_first_call___1 = tmp___14;
#line 499
          tmp___15 = __builtin_expect((long )not_first_call___1, 0L);
#line 499
          if (tmp___15) {
#line 499
            ((*__cancel_routine___1))(__cancel_arg___1);
#line 499
            __pthread_unwind_next(& __cancel_buf___1);
          }
#line 499
          __pthread_register_cancel(& __cancel_buf___1);
#line 499
          while (1) {
#line 500
            head = & nsslist;
#line 501
            p = head->next;
#line 501
            while ((unsigned int )p != (unsigned int )head) {
#line 502
              this = (struct nss_source *)((char *)p - (unsigned long )(& ((struct nss_source *)0)->list));
#line 504
              while (1) {
#line 504
                ((*log_debug))(ap->logopt, "%s: reading map %s %s", "lookup_nss_read_map",
                               this->source, (*(map->argv + 0)));
#line 504
                break;
              }
#line 507
              result = (int )read_map_source(this, ap, map, age);
#line 508
              if (result == -1) {
                goto __Cont;
              }
#line 511
              if (result == 0) {
#line 512
                at_least_one = 1U;
#line 513
                result = 3;
              }
#line 516
              status = (enum nsswitch_status )check_nss_result(this, (enum nsswitch_status )result);
#line 517
              if ((int )status >= 0) {
#line 518
                map = (struct map_source *)((void *)0);
#line 519
                break;
              }
              __Cont: /* CIL Label */ 
#line 501
              p = p->next;
            }
#line 499
            break;
          }
#line 522
          __pthread_unregister_cancel(& __cancel_buf___1);
#line 522
          ((*__cancel_routine___1))(__cancel_arg___1);
#line 499
          break;
        }
#line 524
        if (! map) {
#line 525
          break;
        }
#line 527
        map = map->next;
      }
#line 445
      break;
    }
#line 529
    __pthread_unregister_cancel(& __cancel_buf);
#line 529
    ((*__cancel_routine))(__cancel_arg);
#line 445
    break;
  }
#line 531
  if (! result) {
#line 532
    return (1);
  } else {
#line 531
    if (at_least_one) {
#line 532
      return (1);
    }
  }
#line 534
  return (0);
}
}
#line 537 "lookup.c"
int lookup_ghost(struct autofs_point *ap ) 
{ struct master_mapent *entry ;
  struct map_source *map ;
  struct mapent_cache *mc ;
  struct mapent *me ;
  char buf[128] ;
  struct stat st ;
  char *fullpath ;
  int ret ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___9 ;
  long tmp___10 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___0)(void * ) ;
  void *__cancel_arg___0 ;
  int not_first_call___0 ;
  int tmp___11 ;
  long tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  char *estr ;
  int *tmp___16 ;
  char *tmp___17 ;
  int *tmp___18 ;
  char *estr___0 ;
  int *tmp___19 ;
  char *tmp___20 ;
  int *tmp___21 ;
  int tmp___22 ;

  {
#line 539
  entry = ap->entry;
#line 548
  if (0) {
#line 548
    __s1_len = strlen((char const   *)ap->path);
#line 548
    __s2_len = strlen("/-");
#line 548
    if (! ((unsigned int )((void const   *)(ap->path + 1)) - (unsigned int )((void const   *)ap->path) == 1U)) {
      goto _L___0;
    } else {
#line 548
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 548
        if (! ((unsigned int )((void const   *)("/-" + 1)) - (unsigned int )((void const   *)"/-") == 1U)) {
#line 548
          tmp___8 = 1;
        } else {
#line 548
          if (__s2_len >= 4U) {
#line 548
            tmp___8 = 1;
          } else {
#line 548
            tmp___8 = 0;
          }
        }
      } else {
#line 548
        tmp___8 = 0;
      }
    }
#line 548
    if (tmp___8) {
#line 548
      tmp___4 = __builtin_strcmp((char const   *)ap->path, "/-");
    } else {
#line 548
      tmp___7 = __builtin_strcmp((char const   *)ap->path, "/-");
#line 548
      tmp___4 = tmp___7;
    }
  } else {
#line 548
    tmp___7 = __builtin_strcmp((char const   *)ap->path, "/-");
#line 548
    tmp___4 = tmp___7;
  }
#line 548
  if (! tmp___4) {
#line 549
    return (5);
  }
#line 551
  if (! ap->ghost) {
#line 552
    return (2);
  }
#line 554
  while (1) {
#line 554
    __cancel_routine = & master_source_lock_cleanup;
#line 554
    __cancel_arg = (void *)entry;
#line 554
    tmp___9 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
#line 554
    not_first_call = tmp___9;
#line 554
    tmp___10 = __builtin_expect((long )not_first_call, 0L);
#line 554
    if (tmp___10) {
#line 554
      ((*__cancel_routine))(__cancel_arg);
#line 554
      __pthread_unwind_next(& __cancel_buf);
    }
#line 554
    __pthread_register_cancel(& __cancel_buf);
#line 554
    while (1) {
#line 555
      master_source_readlock(entry);
#line 556
      map = entry->maps;
#line 557
      while (map) {
#line 562
        if (entry->age > map->age) {
#line 563
          map = map->next;
#line 564
          continue;
        }
#line 567
        mc = map->mc;
#line 568
        while (1) {
#line 568
          __cancel_routine___0 = & cache_lock_cleanup;
#line 568
          __cancel_arg___0 = (void *)mc;
#line 568
          tmp___11 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf),
                                 0);
#line 568
          not_first_call___0 = tmp___11;
#line 568
          tmp___12 = __builtin_expect((long )not_first_call___0, 0L);
#line 568
          if (tmp___12) {
#line 568
            ((*__cancel_routine___0))(__cancel_arg___0);
#line 568
            __pthread_unwind_next(& __cancel_buf___0);
          }
#line 568
          __pthread_register_cancel(& __cancel_buf___0);
#line 568
          while (1) {
#line 569
            cache_readlock(mc);
#line 570
            me = cache_enumerate(mc, (struct mapent *)((void *)0));
#line 571
            while (me) {
#line 572
              if ((int )(*(me->key)) == 42) {
                goto next;
              }
#line 575
              if ((int )(*(me->key)) == 47) {
#line 577
                tmp___13 = list_empty(& me->multi_list);
#line 577
                if (tmp___13) {
#line 578
                  while (1) {
#line 578
                    ((*log_error))(ap->logopt, "%s: invalid key %s", "lookup_ghost",
                                   me->key);
#line 578
                    break;
                  }
                }
                goto next;
              }
#line 583
              tmp___14 = strlen((char const   *)me->key);
#line 583
              tmp___15 = strlen((char const   *)ap->path);
#line 583
              fullpath = (char *)__builtin_alloca((tmp___14 + tmp___15) + 3U);
#line 584
              if (! fullpath) {
#line 585
                while (1) {
#line 585
                  ((*log_warn))(ap->logopt, "%s: failed to allocate full path", "lookup_ghost");
#line 585
                  break;
                }
                goto next;
              }
#line 588
              sprintf((char * __restrict  )fullpath, (char const   * __restrict  )"%s/%s",
                      ap->path, me->key);
#line 590
              ret = stat__extinline((char const   *)fullpath, & st);
#line 591
              if (ret == -1) {
#line 591
                tmp___18 = __errno_location();
#line 591
                if ((*tmp___18) != 2) {
#line 592
                  tmp___16 = __errno_location();
#line 592
                  tmp___17 = strerror_r((*tmp___16), buf, 128U);
#line 592
                  estr = tmp___17;
#line 593
                  while (1) {
#line 593
                    ((*log_warn))(ap->logopt, "%s: stat error %s", "lookup_ghost",
                                  estr);
#line 593
                    break;
                  }
                  goto next;
                }
              }
#line 597
              ret = mkdir_path((char const   *)fullpath, 365U);
#line 598
              if (ret < 0) {
#line 598
                tmp___21 = __errno_location();
#line 598
                if ((*tmp___21) != 17) {
#line 599
                  tmp___19 = __errno_location();
#line 599
                  tmp___20 = strerror_r((*tmp___19), buf, 128U);
#line 599
                  estr___0 = tmp___20;
#line 600
                  while (1) {
#line 600
                    ((*log_warn))(ap->logopt, "%s: mkdir_path %s failed: %s", "lookup_ghost",
                                  fullpath, estr___0);
#line 600
                    break;
                  }
                  goto next;
                }
              }
#line 605
              tmp___22 = stat__extinline((char const   *)fullpath, & st);
#line 605
              if (tmp___22 != -1) {
#line 606
                me->dev = st.st_dev;
#line 607
                me->ino = st.st_ino;
              }
              next: 
#line 610
              me = cache_enumerate(mc, me);
            }
#line 568
            break;
          }
#line 612
          __pthread_unregister_cancel(& __cancel_buf___0);
#line 612
          ((*__cancel_routine___0))(__cancel_arg___0);
#line 568
          break;
        }
#line 613
        map = map->next;
      }
#line 554
      break;
    }
#line 615
    __pthread_unregister_cancel(& __cancel_buf);
#line 615
    ((*__cancel_routine))(__cancel_arg);
#line 554
    break;
  }
#line 617
  return (2);
}
}
#line 620 "lookup.c"
int do_lookup_mount(struct autofs_point *ap , struct map_source *map , char const   *name ,
                    int name_len ) 
{ struct lookup_mod *lookup ;
  int status ;

  {
#line 625
  if (! map->lookup) {
#line 626
    lookup = open_lookup((char const   *)map->type, "", (char const   *)map->format,
                         map->argc, (char const   * const  *)map->argv);
#line 628
    if (! lookup) {
#line 629
      while (1) {
#line 629
        ((*log_debug))(ap->logopt, "%s: lookup module %s failed", "do_lookup_mount",
                       map->type);
#line 629
        break;
      }
#line 631
      return (2);
    }
#line 633
    map->lookup = lookup;
  }
#line 636
  lookup = map->lookup;
#line 638
  master_source_current_wait(ap->entry);
#line 639
  (ap->entry)->current = map;
#line 641
  status = ((*(lookup->lookup_mount)))(ap, name, name_len, lookup->context);
#line 643
  return (status);
}
}
#line 646 "lookup.c"
static int lookup_name_file_source_instance(struct autofs_point *ap , struct map_source *map ,
                                            char const   *name , int name_len ) 
{ struct map_source *instance ;
  char src_file[5] ;
  char src_prog[8] ;
  time_t age ;
  time_t tmp ;
  struct stat st ;
  char *type ;
  char *format ;
  int tmp___0 ;
  int argc ;
  char const   **argv ;
  int tmp___1 ;

  {
#line 649
  src_file[0] = (char )'f';
#line 649
  src_file[1] = (char )'i';
#line 649
  src_file[2] = (char )'l';
#line 649
  src_file[3] = (char )'e';
#line 649
  src_file[4] = (char )'\000';
#line 650
  src_prog[0] = (char )'p';
#line 650
  src_prog[1] = (char )'r';
#line 650
  src_prog[2] = (char )'o';
#line 650
  src_prog[3] = (char )'g';
#line 650
  src_prog[4] = (char )'r';
#line 650
  src_prog[5] = (char )'a';
#line 650
  src_prog[6] = (char )'m';
#line 650
  src_prog[7] = (char )'\000';
#line 651
  tmp = time((time_t *)((void *)0));
#line 651
  age = tmp;
#line 655
  tmp___0 = stat__extinline((*(map->argv + 0)), & st);
#line 655
  if (tmp___0 == -1) {
#line 656
    while (1) {
#line 656
      ((*log_warn))(ap->logopt, "%s: file map not found", "lookup_name_file_source_instance");
#line 656
      break;
    }
#line 657
    return (1);
  }
#line 660
  if (! ((st.st_mode & 61440U) == 32768U)) {
#line 661
    return (1);
  }
#line 663
  if (st.st_mode & 64U) {
#line 664
    type = src_prog;
  } else {
#line 666
    type = src_file;
  }
#line 668
  format = map->format;
#line 670
  instance = master_find_source_instance(map, (char const   *)type, (char const   *)format,
                                         0, (char const   **)((void *)0));
#line 671
  if (! instance) {
#line 672
    argc = map->argc;
#line 673
    argv = map->argv;
#line 674
    instance = master_add_source_instance(map, (char const   *)type, (char const   *)format,
                                          age, argc, argv);
#line 675
    if (! instance) {
#line 676
      return (1);
    }
#line 677
    instance->recurse = map->recurse;
#line 678
    instance->depth = map->depth;
  }
#line 681
  tmp___1 = do_lookup_mount(ap, instance, name, name_len);
#line 681
  return (tmp___1);
}
}
#line 684 "lookup.c"
static int lookup_name_source_instance(struct autofs_point *ap , struct map_source *map ,
                                       char const   *type , char const   *name , int name_len ) 
{ struct map_source *instance ;
  char const   *format ;
  time_t age ;
  time_t tmp ;
  int argc ;
  char const   **argv ;
  int tmp___0 ;

  {
#line 688
  tmp = time((time_t *)((void *)0));
#line 688
  age = tmp;
#line 690
  format = (char const   *)map->format;
#line 692
  instance = master_find_source_instance(map, type, format, 0, (char const   **)((void *)0));
#line 693
  if (! instance) {
#line 694
    argc = map->argc;
#line 695
    argv = map->argv;
#line 696
    instance = master_add_source_instance(map, type, format, age, argc, argv);
#line 697
    if (! instance) {
#line 698
      return (1);
    }
#line 699
    instance->recurse = map->recurse;
#line 700
    instance->depth = map->depth;
  }
#line 703
  tmp___0 = do_lookup_mount(ap, instance, name, name_len);
#line 703
  return (tmp___0);
}
}
#line 706 "lookup.c"
static enum nsswitch_status lookup_map_name(struct nss_source *this , struct autofs_point *ap ,
                                            struct map_source *map , char const   *name ,
                                            int name_len ) 
{ enum nsswitch_status result ;
  struct map_source tmap ;
  char *path ;
  enum nsswitch_status tmp ;
  int tmp___0 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
#line 714
  tmp___0 = strcasecmp((char const   *)this->source, "files");
#line 714
  if (tmp___0) {
#line 715
    tmp = (enum nsswitch_status )lookup_name_source_instance(ap, map, (char const   *)this->source,
                                                             name, name_len);
#line 715
    return (tmp);
  }
#line 725
  tmp___2 = __builtin_strchr((char *)(*(map->argv + 0)), (char )'/');
#line 725
  if (tmp___2) {
#line 726
    while (1) {
#line 726
      ((*log_error))(ap->logopt, "%s: relative path invalid in files map name", "lookup_map_name");
#line 726
      break;
    }
#line 727
    return (1);
  }
#line 730
  (*(this->source + 4)) = (char )'\000';
#line 731
  tmap.type = this->source;
#line 732
  tmap.format = map->format;
#line 733
  tmap.mc = map->mc;
#line 734
  tmap.instance = map->instance;
#line 735
  tmap.recurse = map->recurse;
#line 736
  tmap.depth = map->depth;
#line 737
  tmap.argc = 0;
#line 738
  tmap.argv = (char const   **)((void *)0);
#line 740
  tmp___3 = strlen("/etc");
#line 740
  tmp___4 = strlen((*(map->argv + 0)));
#line 740
  path = (char *)malloc((tmp___3 + tmp___4) + 2U);
#line 741
  if (! path) {
#line 742
    return (-1);
  }
#line 744
  strcpy((char * __restrict  )path, (char const   * __restrict  )"/etc");
#line 745
  strcat((char * __restrict  )path, (char const   * __restrict  )"/");
#line 746
  strcat((char * __restrict  )path, (char const   * __restrict  )(*(map->argv + 0)));
#line 748
  if (map->argc >= 1) {
#line 749
    tmap.argc = map->argc;
#line 750
    tmap.argv = copy_argv(map->argc, map->argv);
#line 751
    if (! tmap.argv) {
#line 752
      while (1) {
#line 752
        ((*log_error))(ap->logopt, "%s: failed to copy args", "lookup_map_name");
#line 752
        break;
      }
#line 753
      free((void *)path);
#line 754
      return (-1);
    }
#line 756
    if ((*(tmap.argv + 0))) {
#line 757
      free((void *)((char *)(*(tmap.argv + 0))));
    }
#line 758
    (*(tmap.argv + 0)) = (char const   *)path;
  } else {
#line 760
    while (1) {
#line 760
      ((*log_error))(ap->logopt, "%s: invalid arguments for autofs_point", "lookup_map_name");
#line 760
      break;
    }
#line 761
    free((void *)path);
#line 762
    return (-1);
  }
#line 765
  result = (enum nsswitch_status )lookup_name_file_source_instance(ap, & tmap, name,
                                                                   name_len);
#line 767
  map->instance = tmap.instance;
#line 770
  free_argv(tmap.argc, tmap.argv);
#line 772
  return (result);
}
}
#line 775 "lookup.c"
int lookup_nss_mount(struct autofs_point *ap , struct map_source *source , char const   *name ,
                     int name_len ) 
{ struct master_mapent *entry ;
  struct list_head nsslist ;
  struct list_head *head ;
  struct list_head *p ;
  struct nss_source *this ;
  struct map_source *map ;
  enum nsswitch_status status ;
  int result ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp ;
  long tmp___0 ;
  char *tmp___1 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
#line 777
  entry = ap->entry;
#line 783
  result = 0;
#line 790
  while (1) {
#line 790
    __cancel_routine = & master_source_lock_cleanup;
#line 790
    __cancel_arg = (void *)entry;
#line 790
    tmp = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf), 0);
#line 790
    not_first_call = tmp;
#line 790
    tmp___0 = __builtin_expect((long )not_first_call, 0L);
#line 790
    if (tmp___0) {
#line 790
      ((*__cancel_routine))(__cancel_arg);
#line 790
      __pthread_unwind_next(& __cancel_buf);
    }
#line 790
    __pthread_register_cancel(& __cancel_buf);
#line 790
    while (1) {
#line 791
      master_source_readlock(entry);
#line 792
      if (source) {
#line 793
        map = source;
      } else {
#line 795
        map = entry->maps;
      }
#line 796
      while (map) {
#line 801
        if (entry->age > map->age) {
#line 802
          map = map->next;
#line 803
          continue;
        }
#line 806
        sched_yield();
#line 808
        if (map->type) {
#line 809
          result = do_lookup_mount(ap, map, name, name_len);
#line 811
          if (result == 0) {
#line 812
            break;
          }
#line 814
          map = map->next;
#line 815
          continue;
        }
#line 819
        if ((int const   )(*((*(map->argv + 0)))) == 47) {
#line 820
          if ((int const   )(*((*(map->argv + 0)) + 1)) == 47) {
#line 821
            tmp___11 = __strdup("ldap");
#line 821
            tmp___1 = tmp___11;
#line 822
            if (! tmp___1) {
#line 823
              map = map->next;
#line 824
              continue;
            }
#line 826
            map->type = tmp___1;
#line 827
            result = do_lookup_mount(ap, map, name, name_len);
          } else {
#line 829
            result = lookup_name_file_source_instance(ap, map, name, name_len);
          }
#line 831
          if (result == 0) {
#line 832
            break;
          }
#line 834
          map = map->next;
#line 835
          continue;
        }
#line 838
        while (1) {
#line 838
          nsslist.next = & nsslist;
#line 838
          nsslist.prev = & nsslist;
#line 838
          break;
        }
#line 840
        status = (enum nsswitch_status )nsswitch_parse(& nsslist);
#line 841
        if (status) {
#line 842
          while (1) {
#line 842
            ((*log_error))(ap->logopt, "%s: can\'t to read name service switch config.",
                           "lookup_nss_mount");
#line 842
            break;
          }
#line 844
          result = 1;
#line 845
          break;
        }
#line 848
        head = & nsslist;
#line 849
        p = head->next;
#line 849
        while ((unsigned int )p != (unsigned int )head) {
#line 850
          this = (struct nss_source *)((char *)p - (unsigned long )(& ((struct nss_source *)0)->list));
#line 852
          result = (int )lookup_map_name(this, ap, map, name, name_len);
#line 854
          if (result == -1) {
#line 855
            map = map->next;
            goto __Cont;
          }
#line 859
          status = (enum nsswitch_status )check_nss_result(this, (enum nsswitch_status )result);
#line 860
          if ((int )status >= 0) {
#line 861
            map = (struct map_source *)((void *)0);
#line 862
            break;
          }
          __Cont: /* CIL Label */ 
#line 849
          p = p->next;
        }
#line 866
        tmp___12 = list_empty(& nsslist);
#line 866
        if (! tmp___12) {
#line 867
          free_sources(& nsslist);
        }
#line 869
        if (! map) {
#line 870
          break;
        }
#line 872
        map = map->next;
      }
#line 874
      send_map_update_request(ap);
#line 790
      break;
    }
#line 875
    __pthread_unregister_cancel(& __cancel_buf);
#line 875
    ((*__cancel_routine))(__cancel_arg);
#line 790
    break;
  }
#line 877
  return (! result);
}
}
#line 880 "lookup.c"
static void lookup_close_lookup_instances(struct map_source *map ) 
{ struct map_source *instance ;

  {
#line 884
  instance = map->instance;
#line 885
  while (instance) {
#line 886
    lookup_close_lookup_instances(instance);
#line 887
    instance = instance->next;
  }
#line 890
  if (map->lookup) {
#line 891
    close_lookup(map->lookup);
#line 892
    map->lookup = (struct lookup_mod *)((void *)0);
  }
#line 894
  return;
}
}
#line 896 "lookup.c"
void lookup_close_lookup(struct autofs_point *ap ) 
{ struct map_source *map ;

  {
#line 900
  map = (ap->entry)->maps;
#line 901
  if (! map) {
#line 902
    return;
  }
#line 904
  while (map) {
#line 905
    lookup_close_lookup_instances(map);
#line 906
    map = map->next;
  }
#line 908
  return;
}
}
#line 911 "lookup.c"
static char *make_fullpath(char const   *root , char const   *key ) 
{ int l ;
  char *path ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 916
  if ((int const   )(*key) == 47) {
#line 917
    tmp = strlen(key);
#line 917
    l = (int )(tmp + 1U);
#line 918
    if (l > 255) {
#line 919
      return ((char *)((void *)0));
    }
#line 920
    path = (char *)malloc((unsigned int )l);
#line 921
    strcpy((char * __restrict  )path, (char const   * __restrict  )key);
  } else {
#line 923
    tmp___0 = strlen(key);
#line 923
    tmp___1 = strlen(root);
#line 923
    l = (int )(((tmp___0 + 1U) + tmp___1) + 1U);
#line 924
    if (l > 255) {
#line 925
      return ((char *)((void *)0));
    }
#line 926
    path = (char *)malloc((unsigned int )l);
#line 927
    sprintf((char * __restrict  )path, (char const   * __restrict  )"%s/%s", root,
            key);
  }
#line 929
  return (path);
}
}
#line 932 "lookup.c"
int lookup_prune_cache(struct autofs_point *ap , time_t age ) 
{ struct master_mapent *entry ;
  struct map_source *map ;
  struct mapent_cache *mc ;
  struct mapent *me ;
  struct mapent *this ;
  char *path ;
  int status ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp ;
  long tmp___0 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___0)(void * ) ;
  void *__cancel_arg___0 ;
  int not_first_call___0 ;
  int tmp___1 ;
  long tmp___2 ;
  char *key ;
  char *next_key ;
  char *tmp___12 ;
  int tmp___13 ;
  char *tmp___23 ;
  int tmp___24 ;

  {
#line 934
  entry = ap->entry;
#line 939
  status = 0;
#line 941
  while (1) {
#line 941
    __cancel_routine = & master_source_lock_cleanup;
#line 941
    __cancel_arg = (void *)entry;
#line 941
    tmp = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf), 0);
#line 941
    not_first_call = tmp;
#line 941
    tmp___0 = __builtin_expect((long )not_first_call, 0L);
#line 941
    if (tmp___0) {
#line 941
      ((*__cancel_routine))(__cancel_arg);
#line 941
      __pthread_unwind_next(& __cancel_buf);
    }
#line 941
    __pthread_register_cancel(& __cancel_buf);
#line 941
    while (1) {
#line 942
      master_source_readlock(entry);
#line 944
      map = entry->maps;
#line 945
      while (map) {
#line 947
        if (! map->stale) {
#line 948
          map = map->next;
#line 949
          continue;
        }
#line 951
        mc = map->mc;
#line 952
        while (1) {
#line 952
          __cancel_routine___0 = & cache_lock_cleanup;
#line 952
          __cancel_arg___0 = (void *)mc;
#line 952
          tmp___1 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf),
                                0);
#line 952
          not_first_call___0 = tmp___1;
#line 952
          tmp___2 = __builtin_expect((long )not_first_call___0, 0L);
#line 952
          if (tmp___2) {
#line 952
            ((*__cancel_routine___0))(__cancel_arg___0);
#line 952
            __pthread_unwind_next(& __cancel_buf___0);
          }
#line 952
          __pthread_register_cancel(& __cancel_buf___0);
#line 952
          while (1) {
#line 953
            cache_readlock(mc);
#line 954
            me = cache_enumerate(mc, (struct mapent *)((void *)0));
#line 955
            while (me) {
#line 956
              key = (char *)((void *)0);
#line 956
              next_key = (char *)((void *)0);
#line 958
              if (me->age >= age) {
#line 959
                me = cache_enumerate(mc, me);
#line 960
                continue;
              }
#line 963
              tmp___12 = __strdup((char const   *)me->key);
#line 963
              key = tmp___12;
#line 964
              me = cache_enumerate(mc, me);
#line 965
              if (! key) {
#line 966
                continue;
              } else {
#line 965
                if ((int )(*key) == 42) {
#line 966
                  continue;
                }
              }
#line 968
              path = make_fullpath((char const   *)ap->path, (char const   *)key);
#line 969
              if (! path) {
#line 970
                while (1) {
#line 970
                  ((*log_warn))(ap->logopt, "%s: can\'t malloc storage for path",
                                "lookup_prune_cache");
#line 970
                  break;
                }
#line 972
                free((void *)key);
#line 973
                continue;
              }
#line 976
              tmp___13 = is_mounted("/etc/mtab", (char const   *)path, 2U);
#line 976
              if (tmp___13) {
#line 977
                while (1) {
#line 977
                  ((*log_debug))(ap->logopt, "%s: prune check posponed, %s mounted",
                                 "lookup_prune_cache", path);
#line 977
                  break;
                }
#line 979
                free((void *)key);
#line 980
                free((void *)path);
#line 981
                continue;
              }
#line 984
              if (me) {
#line 985
                tmp___23 = __strdup((char const   *)me->key);
#line 985
                next_key = tmp___23;
              }
#line 987
              cache_unlock(mc);
#line 989
              cache_writelock(mc);
#line 990
              this = cache_lookup_distinct(mc, (char const   *)key);
#line 991
              if (! this) {
#line 992
                cache_unlock(mc);
#line 993
                free((void *)key);
#line 994
                if (next_key) {
#line 995
                  free((void *)next_key);
                }
#line 996
                free((void *)path);
                goto next;
              }
#line 1000
              tmp___24 = is_mounted("/proc/mounts", (char const   *)path, 4U);
#line 1000
              if (! tmp___24) {
#line 1001
                status = 0;
#line 1002
                if (this->ioctlfd == -1) {
#line 1003
                  status = cache_delete(mc, (char const   *)key);
                }
#line 1004
                if (status != 0) {
#line 1005
                  if (ap->type == 2U) {
#line 1006
                    rmdir_path(ap, (char const   *)path, ap->dev);
                  } else {
#line 1008
                    rmdir_path(ap, (char const   *)path, this->dev);
                  }
                }
              }
#line 1011
              cache_unlock(mc);
#line 1013
              if (! next_key) {
#line 1014
                free((void *)key);
#line 1015
                free((void *)path);
#line 1016
                cache_readlock(mc);
#line 1017
                continue;
              }
              next: 
#line 1020
              cache_readlock(mc);
#line 1021
              me = cache_lookup_distinct(mc, (char const   *)next_key);
#line 1022
              free((void *)key);
#line 1023
              free((void *)path);
#line 1024
              free((void *)next_key);
            }
#line 952
            break;
          }
#line 1026
          __pthread_unregister_cancel(& __cancel_buf___0);
#line 1026
          ((*__cancel_routine___0))(__cancel_arg___0);
#line 952
          break;
        }
#line 1027
        map->stale = 0U;
#line 1028
        map = map->next;
      }
#line 941
      break;
    }
#line 1031
    __pthread_unregister_cancel(& __cancel_buf);
#line 1031
    ((*__cancel_routine))(__cancel_arg);
#line 941
    break;
  }
#line 1033
  return (1);
}
}
#line 1037 "lookup.c"
struct mapent *lookup_source_valid_mapent(struct autofs_point *ap , char const   *key ,
                                          unsigned int type ) 
{ struct master_mapent *entry ;
  struct map_source *map ;
  struct mapent_cache *mc ;
  struct mapent *me ;

  {
#line 1039
  entry = ap->entry;
#line 1042
  me = (struct mapent *)((void *)0);
#line 1044
  master_source_readlock(entry);
#line 1045
  map = entry->maps;
#line 1046
  while (map) {
#line 1051
    if ((ap->entry)->age > map->age) {
#line 1052
      map = map->next;
#line 1053
      continue;
    }
#line 1056
    mc = map->mc;
#line 1057
    cache_readlock(mc);
#line 1058
    if (type == 8192U) {
#line 1059
      me = cache_lookup_distinct(mc, key);
    } else {
#line 1061
      me = cache_lookup(mc, key);
    }
#line 1062
    if (me) {
#line 1063
      break;
    }
#line 1064
    cache_unlock(mc);
#line 1065
    map = map->next;
  }
#line 1067
  master_source_unlock(entry);
#line 1069
  return (me);
}
}
#line 1073 "lookup.c"
struct mapent *lookup_source_mapent(struct autofs_point *ap , char const   *key ,
                                    unsigned int type ) 
{ struct master_mapent *entry ;
  struct map_source *map ;
  struct mapent_cache *mc ;
  struct mapent *me ;

  {
#line 1075
  entry = ap->entry;
#line 1078
  me = (struct mapent *)((void *)0);
#line 1080
  master_source_readlock(entry);
#line 1081
  map = entry->maps;
#line 1082
  while (map) {
#line 1083
    mc = map->mc;
#line 1084
    cache_readlock(mc);
#line 1085
    if (type == 8192U) {
#line 1086
      me = cache_lookup_distinct(mc, key);
    } else {
#line 1088
      me = cache_lookup(mc, key);
    }
#line 1089
    if (me) {
#line 1090
      break;
    }
#line 1091
    cache_unlock(mc);
#line 1092
    map = map->next;
  }
#line 1094
  master_source_unlock(entry);
#line 1096
  return (me);
}
}
#line 1099 "lookup.c"
int lookup_source_close_ioctlfd(struct autofs_point *ap , char const   *key ) 
{ struct master_mapent *entry ;
  struct map_source *map ;
  struct mapent_cache *mc ;
  struct mapent *me ;
  int ret ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp ;
  long tmp___0 ;

  {
#line 1101
  entry = ap->entry;
#line 1105
  ret = 0;
#line 1107
  while (1) {
#line 1107
    __cancel_routine = & master_source_lock_cleanup;
#line 1107
    __cancel_arg = (void *)entry;
#line 1107
    tmp = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf), 0);
#line 1107
    not_first_call = tmp;
#line 1107
    tmp___0 = __builtin_expect((long )not_first_call, 0L);
#line 1107
    if (tmp___0) {
#line 1107
      ((*__cancel_routine))(__cancel_arg);
#line 1107
      __pthread_unwind_next(& __cancel_buf);
    }
#line 1107
    __pthread_register_cancel(& __cancel_buf);
#line 1107
    while (1) {
#line 1108
      master_source_readlock(entry);
#line 1109
      map = entry->maps;
#line 1110
      while (map) {
#line 1111
        mc = map->mc;
#line 1112
        cache_readlock(mc);
#line 1113
        me = cache_lookup_distinct(mc, key);
#line 1114
        if (me) {
#line 1115
          if (me->ioctlfd != -1) {
#line 1116
            close(me->ioctlfd);
#line 1117
            me->ioctlfd = -1;
          }
#line 1119
          cache_unlock(mc);
#line 1120
          ret = 1;
#line 1121
          break;
        }
#line 1123
        cache_unlock(mc);
#line 1124
        map = map->next;
      }
#line 1107
      break;
    }
#line 1126
    __pthread_unregister_cancel(& __cancel_buf);
#line 1126
    ((*__cancel_routine))(__cancel_arg);
#line 1107
    break;
  }
#line 1128
  return (ret);
}
}
#line 1 "state.o"
#pragma merger(0,"/tmp/cil-ivnIXVPw.i","-O2,-Wall,-fPIE")
#line 264 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) pthread_t pthread_self(void)  __attribute__((__const__)) ;
#line 482
extern int pthread_cancel(pthread_t __th ) ;
#line 716
extern  __attribute__((__nothrow__)) int pthread_mutex_init(pthread_mutex_t *__mutex ,
                                                            pthread_mutexattr_t const   *__mutexattr )  __attribute__((__nonnull__(1))) ;
#line 721
extern  __attribute__((__nothrow__)) int pthread_mutex_destroy(pthread_mutex_t *__mutex )  __attribute__((__nonnull__(1))) ;
#line 955
extern int pthread_cond_timedwait(pthread_cond_t * __restrict  __cond , pthread_mutex_t * __restrict  __mutex ,
                                  struct timespec  const  * __restrict  __abstime )  __attribute__((__nonnull__(1,2,3))) ;
#line 33 "../include/list.h"
__inline static void __list_add(struct list_head *new , struct list_head *prev , struct list_head *next ) 
{ 

  {
#line 37
  next->prev = new;
#line 38
  new->next = next;
#line 39
  new->prev = prev;
#line 40
  prev->next = new;
#line 41
  return;
}
}
#line 51 "../include/list.h"
__inline static void list_add(struct list_head *new , struct list_head *head ) 
{ 

  {
#line 53
  __list_add(new, head, head->next);
#line 54
  return;
}
}
#line 64 "../include/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 

  {
#line 66
  __list_add(new, head->prev, head);
#line 67
  return;
}
}
#line 76 "../include/list.h"
__inline static void __list_del(struct list_head *prev , struct list_head *next ) 
{ 

  {
#line 79
  next->prev = prev;
#line 80
  prev->next = next;
#line 81
  return;
}
}
#line 88 "../include/list.h"
__inline static void list_del(struct list_head *entry ) 
{ 

  {
#line 90
  __list_del(entry->prev, entry->next);
#line 91
  return;
}
}
#line 97 "../include/list.h"
__inline static void list_del_init(struct list_head *entry ) 
{ 

  {
#line 99
  __list_del(entry->prev, entry->next);
#line 100
  while (1) {
#line 100
    entry->next = entry;
#line 100
    entry->prev = entry;
#line 100
    break;
  }
#line 101
  return;
}
}
#line 85 "../include/state.h"
void expire_proc_cleanup(void *arg ) ;
#line 32 "state.c"
static union __anonunion_pthread_mutex_t_6 mutex  =    {{0, 0U, 0, 0, 0U, {0}}};
#line 33 "state.c"
static union __anonunion_pthread_cond_t_9 cond  =    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}};
#line 34 "state.c"
static unsigned int signaled  =    0U;
#line 35 "state.c"
static struct list_head state_queue  =    {& state_queue, & state_queue};
#line 37
static void st_set_thid(struct autofs_point *ap , pthread_t thid ) ;
#line 38
static void st_set_done(struct autofs_point *ap ) ;
#line 56 "state.c"
void dump_state_queue(void) 
{ struct list_head *head ;
  struct list_head *p ;
  struct list_head *q ;
  struct state_queue *entry ;
  struct state_queue *this ;

  {
#line 58
  head = & state_queue;
#line 61
  while (1) {
#line 61
    ((*log_debug))(3U, "%s: dumping queue", "dump_state_queue");
#line 61
    break;
  }
#line 63
  p = head->next;
#line 63
  while ((unsigned int )p != (unsigned int )head) {
#line 66
    entry = (struct state_queue *)((char *)p - (unsigned long )(& ((struct state_queue *)0)->list));
#line 67
    while (1) {
#line 67
      ((*log_debug))(3U, "%s: queue list head path %s state %d busy %d", "dump_state_queue",
                     (entry->ap)->path, entry->state, entry->busy);
#line 67
      break;
    }
#line 71
    q = entry->pending.next;
#line 71
    while ((unsigned int )q != (unsigned int )(& entry->pending)) {
#line 74
      this = (struct state_queue *)((char *)q - (unsigned long )(& ((struct state_queue *)0)->pending));
#line 75
      while (1) {
#line 75
        ((*log_debug))(3U, "%s: queue list entry path %s state %d busy %d", "dump_state_queue",
                       (this->ap)->path, this->state, this->busy);
#line 75
        break;
      }
#line 71
      q = q->next;
    }
#line 63
    p = p->next;
  }
#line 80
  return;
}
}
#line 82 "state.c"
void nextstate(int statefd , enum states next ) 
{ char buf[128] ;
  char *estr ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 86
  tmp___1 = write(statefd, (void const   *)(& next), sizeof(next));
#line 86
  if ((unsigned int )tmp___1 != sizeof(next)) {
#line 87
    tmp = __errno_location();
#line 87
    tmp___0 = strerror_r((*tmp), buf, 128U);
#line 87
    estr = tmp___0;
#line 88
    while (1) {
#line 88
      ((*log_error))(3U, "%s: write failed %s", "nextstate", estr);
#line 88
      break;
    }
  }
#line 90
  return;
}
}
#line 96 "state.c"
void expire_cleanup(void *arg ) 
{ pthread_t thid ;
  pthread_t tmp ;
  struct expire_args *ec ;
  struct autofs_point *ap ;
  int statefd ;
  int success ;
  enum states next ;
  int _st_lock ;
  int tmp___0 ;
  int rv ;
  int idle ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int _st_unlock ;
  int tmp___3 ;

  {
#line 98
  tmp = pthread_self();
#line 98
  thid = tmp;
#line 102
  next = -1;
#line 104
  ec = (struct expire_args *)arg;
#line 105
  ap = ec->ap;
#line 106
  success = ec->status;
#line 108
  while (1) {
#line 108
    tmp___0 = pthread_mutex_lock(& ap->state_mutex);
#line 108
    _st_lock = tmp___0;
#line 108
    if (_st_lock) {
#line 108
      while (1) {
#line 108
        if (_st_lock == 35) {
#line 108
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "expire_cleanup", 108, "state.c");
#line 108
          dump_core();
        }
#line 108
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_lock, 108,
                      "state.c");
#line 108
        abort();
#line 108
        break;
      }
    }
#line 108
    break;
  }
#line 110
  while (1) {
#line 110
    ((*log_debug))(ap->logopt, "%s: got thid %lu path %s stat %d", "expire_cleanup",
                   thid, ap->path, success);
#line 110
    break;
  }
#line 114
  statefd = ap->state_pipe[1];
#line 117
  if (thid == ap->exp_thread) {
#line 118
    ap->exp_thread = 0UL;
#line 120
    switch ((int )ap->state) {
    case 2: 
    case 3: 
#line 137
    if (ap->submount) {
#line 137
      if (! success) {
#line 140
        if (sizeof(int ) == sizeof(int [1])) {
#line 140
          if (sizeof(int ) < 16384U) {
#line 140
            tmp___1 = sizeof(int );
          } else {
#line 140
            tmp___1 = __invalid_size_argument_for_IOC;
          }
        } else {
#line 140
          tmp___1 = __invalid_size_argument_for_IOC;
        }
#line 140
        rv = ioctl(ap->ioctlfd, (unsigned long )(2147521392U | (tmp___1 << 16)), & idle);
#line 141
        if (! rv) {
#line 141
          if (idle) {
#line 141
            if (ap->submount > 1U) {
#line 142
              next = 5;
#line 143
              break;
            }
          }
        }
#line 146
        tmp___2 = ap->submount;
#line 146
        ap->submount ++;
#line 146
        if (tmp___2 == 0U) {
#line 147
          ap->submount = 2U;
        }
      }
    }
#line 150
    if (! ap->submount) {
#line 151
      alarm_add(ap, ap->exp_runfreq);
    }
    case 1: 
#line 156
    next = 1;
#line 157
    break;
    case 5: 
#line 160
    next = 7;
#line 164
    if (success == 0) {
#line 165
      break;
    }
#line 168
    while (1) {
#line 168
      ((*log_warn))(ap->logopt, "%s: filesystem %s still busy", "expire_cleanup",
                    ap->path);
#line 168
      break;
    }
#line 169
    if (! ap->submount) {
#line 170
      alarm_add(ap, ap->exp_runfreq);
    }
#line 171
    next = 1;
#line 172
    break;
    case 6: 
#line 176
    next = 7;
#line 177
    break;
    default: ;
#line 180
    while (1) {
#line 180
      ((*log_error))(ap->logopt, "%s: bad state %d", "expire_cleanup", ap->state);
#line 180
      break;
    }
    }
#line 183
    if ((int )next != -1) {
#line 184
      while (1) {
#line 184
        ((*log_debug))(ap->logopt, "%s: sigchld: exp %lu finished, switching from %d to %d",
                       "expire_cleanup", thid, ap->state, next);
#line 184
        break;
      }
    }
  }
#line 190
  if ((int )next != -1) {
#line 191
    nextstate(statefd, next);
  }
#line 193
  st_set_done(ap);
#line 195
  while (1) {
#line 195
    tmp___3 = pthread_mutex_unlock(& ap->state_mutex);
#line 195
    _st_unlock = tmp___3;
#line 195
    if (_st_unlock) {
#line 195
      while (1) {
#line 195
        if (_st_unlock == 35) {
#line 195
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "expire_cleanup", 195, "state.c");
#line 195
          dump_core();
        }
#line 195
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_unlock,
                      195, "state.c");
#line 195
        abort();
#line 195
        break;
      }
    }
#line 195
    break;
  }
#line 197
  return;
}
}
#line 200 "state.c"
static unsigned int st_ready(struct autofs_point *ap ) 
{ 

  {
#line 202
  while (1) {
#line 202
    ((*log_debug))(ap->logopt, "%s: st_ready(): state = %d path %s", "st_ready", ap->state,
                   ap->path);
#line 202
    break;
  }
#line 205
  ap->state = 1;
#line 207
  if (ap->submount) {
#line 208
    master_signal_submount(ap, 1U);
  }
#line 210
  return (1U);
}
}
#line 228 "state.c"
void expire_proc_cleanup(void *arg ) 
{ struct expire_args *ea ;
  int status ;

  {
#line 233
  ea = (struct expire_args *)arg;
#line 235
  status = pthread_mutex_unlock(& ea->mutex);
#line 236
  if (status) {
#line 237
    while (1) {
#line 237
      if (status == 35) {
#line 237
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "expire_proc_cleanup", 237, "state.c");
#line 237
        dump_core();
      }
#line 237
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 237,
                    "state.c");
#line 237
      abort();
#line 237
      break;
    }
  }
#line 239
  status = pthread_cond_destroy(& ea->cond);
#line 240
  if (status) {
#line 241
    while (1) {
#line 241
      if (status == 35) {
#line 241
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "expire_proc_cleanup", 241, "state.c");
#line 241
        dump_core();
      }
#line 241
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 241,
                    "state.c");
#line 241
      abort();
#line 241
      break;
    }
  }
#line 243
  status = pthread_mutex_destroy(& ea->mutex);
#line 244
  if (status) {
#line 245
    while (1) {
#line 245
      if (status == 35) {
#line 245
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "expire_proc_cleanup", 245, "state.c");
#line 245
        dump_core();
      }
#line 245
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 245,
                    "state.c");
#line 245
      abort();
#line 245
      break;
    }
  }
#line 247
  free((void *)ea);
#line 249
  return;
}
}
#line 252 "state.c"
static enum expire expire_proc(struct autofs_point *ap , int now ) 
{ pthread_t thid ;
  struct expire_args *ea ;
  void *(*expire)(void * ) ;
  int status ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp ;
  long tmp___0 ;

  {
#line 259
  while (1) {
#line 259
    if (! (ap->exp_thread == 0UL)) {
#line 259
      ((*log_crit))(3U, "state.c:%d: assertion failed: ap->exp_thread == 0", 259);
    }
#line 259
    break;
  }
#line 261
  ea = (struct expire_args *)malloc(sizeof(struct expire_args ));
#line 262
  if (! ea) {
#line 263
    while (1) {
#line 263
      ((*log_error))(ap->logopt, "%s: failed to malloc expire cond struct", "expire_proc");
#line 263
      break;
    }
#line 264
    return (0);
  }
#line 267
  status = pthread_mutex_init(& ea->mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 268
  if (status) {
#line 269
    while (1) {
#line 269
      if (status == 35) {
#line 269
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "expire_proc", 269, "state.c");
#line 269
        dump_core();
      }
#line 269
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 269,
                    "state.c");
#line 269
      abort();
#line 269
      break;
    }
  }
#line 271
  status = pthread_cond_init((pthread_cond_t * __restrict  )(& ea->cond), (pthread_condattr_t const   * __restrict  )((void *)0));
#line 272
  if (status) {
#line 273
    while (1) {
#line 273
      if (status == 35) {
#line 273
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "expire_proc", 273, "state.c");
#line 273
        dump_core();
      }
#line 273
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 273,
                    "state.c");
#line 273
      abort();
#line 273
      break;
    }
  }
#line 275
  status = pthread_mutex_lock(& ea->mutex);
#line 276
  if (status) {
#line 277
    while (1) {
#line 277
      if (status == 35) {
#line 277
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "expire_proc", 277, "state.c");
#line 277
        dump_core();
      }
#line 277
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 277,
                    "state.c");
#line 277
      abort();
#line 277
      break;
    }
  }
#line 279
  ea->ap = ap;
#line 280
  ea->when = (unsigned int )now;
#line 281
  ea->status = 1;
#line 283
  if (ap->type == 2U) {
#line 284
    expire = & expire_proc_indirect;
  } else {
#line 286
    expire = & expire_proc_direct;
  }
#line 288
  status = pthread_create((pthread_t * __restrict  )(& thid), (pthread_attr_t const   * __restrict  )(& thread_attr),
                          expire, (void * __restrict  )ea);
#line 289
  if (status) {
#line 290
    while (1) {
#line 290
      ((*log_error))(ap->logopt, "%s: expire thread create for %s failed", "expire_proc",
                     ap->path);
#line 290
      break;
    }
#line 292
    expire_proc_cleanup((void *)ea);
#line 293
    free((void *)ea);
#line 294
    return (0);
  }
#line 296
  ap->exp_thread = thid;
#line 297
  st_set_thid(ap, thid);
#line 299
  while (1) {
#line 299
    __cancel_routine = & expire_proc_cleanup;
#line 299
    __cancel_arg = (void *)ea;
#line 299
    tmp = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf), 0);
#line 299
    not_first_call = tmp;
#line 299
    tmp___0 = __builtin_expect((long )not_first_call, 0L);
#line 299
    if (tmp___0) {
#line 299
      ((*__cancel_routine))(__cancel_arg);
#line 299
      __pthread_unwind_next(& __cancel_buf);
    }
#line 299
    __pthread_register_cancel(& __cancel_buf);
#line 299
    while (1) {
#line 301
      while (1) {
#line 301
        ((*log_debug))(ap->logopt, "%s: exp_proc = %lu path %s", "expire_proc", ap->exp_thread,
                       ap->path);
#line 301
        break;
      }
#line 304
      ea->signaled = 0U;
#line 305
      while (! ea->signaled) {
#line 306
        status = pthread_cond_wait((pthread_cond_t * __restrict  )(& ea->cond), (pthread_mutex_t * __restrict  )(& ea->mutex));
#line 307
        if (status) {
#line 308
          while (1) {
#line 308
            if (status == 35) {
#line 308
              ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                            "expire_proc", 308, "state.c");
#line 308
              dump_core();
            }
#line 308
            ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status,
                          308, "state.c");
#line 308
            abort();
#line 308
            break;
          }
        }
      }
#line 299
      break;
    }
#line 311
    __pthread_unregister_cancel(& __cancel_buf);
#line 311
    ((*__cancel_routine))(__cancel_arg);
#line 299
    break;
  }
#line 313
  return (1);
}
}
#line 316 "state.c"
static void do_readmap_cleanup(void *arg ) 
{ struct readmap_args *ra ;
  struct autofs_point *ap ;
  int _st_lock ;
  int tmp ;
  int _st_unlock ;
  int tmp___0 ;

  {
#line 321
  ra = (struct readmap_args *)arg;
#line 323
  ap = ra->ap;
#line 324
  ap->readmap_thread = 0UL;
#line 326
  while (1) {
#line 326
    tmp = pthread_mutex_lock(& ap->state_mutex);
#line 326
    _st_lock = tmp;
#line 326
    if (_st_lock) {
#line 326
      while (1) {
#line 326
        if (_st_lock == 35) {
#line 326
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "do_readmap_cleanup", 326, "state.c");
#line 326
          dump_core();
        }
#line 326
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_lock, 326,
                      "state.c");
#line 326
        abort();
#line 326
        break;
      }
    }
#line 326
    break;
  }
#line 328
  nextstate(ap->state_pipe[1], 1);
#line 329
  st_set_done(ap);
#line 331
  while (1) {
#line 331
    tmp___0 = pthread_mutex_unlock(& ap->state_mutex);
#line 331
    _st_unlock = tmp___0;
#line 331
    if (_st_unlock) {
#line 331
      while (1) {
#line 331
        if (_st_unlock == 35) {
#line 331
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "do_readmap_cleanup", 331, "state.c");
#line 331
          dump_core();
        }
#line 331
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_unlock,
                      331, "state.c");
#line 331
        abort();
#line 331
        break;
      }
    }
#line 331
    break;
  }
#line 333
  if (! ap->submount) {
#line 334
    alarm_add(ap, ap->exp_runfreq);
  }
#line 336
  free((void *)ra);
#line 338
  return;
}
}
#line 341 "state.c"
static void tree_mnts_cleanup(void *arg ) 
{ struct mnt_list *mnts ;

  {
#line 343
  mnts = (struct mnt_list *)arg;
#line 344
  tree_free_mnt_tree(mnts);
#line 345
  return;
}
}
#line 348 "state.c"
static void *do_readmap(void *arg ) 
{ struct autofs_point *ap ;
  struct map_source *map ;
  struct mapent_cache *nc ;
  struct mapent_cache *mc ;
  struct readmap_args *ra ;
  struct mnt_list *mnts ;
  int status ;
  time_t now ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp ;
  long tmp___0 ;
  struct mapent *me ;
  struct mapent *ne ;
  struct mapent *nested ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___0)(void * ) ;
  void *__cancel_arg___0 ;
  int not_first_call___0 ;
  int tmp___1 ;
  long tmp___2 ;
  __pthread_unwind_buf_t __cancel_buf___1 ;
  void (*__cancel_routine___1)(void * ) ;
  void *__cancel_arg___1 ;
  int not_first_call___1 ;
  int tmp___3 ;
  long tmp___4 ;
  __pthread_unwind_buf_t __cancel_buf___2 ;
  void (*__cancel_routine___2)(void * ) ;
  void *__cancel_arg___2 ;
  int not_first_call___2 ;
  int tmp___5 ;
  long tmp___6 ;
  __pthread_unwind_buf_t __cancel_buf___3 ;
  void (*__cancel_routine___3)(void * ) ;
  void *__cancel_arg___3 ;
  int not_first_call___3 ;
  int tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;

  {
#line 358
  ra = (struct readmap_args *)arg;
#line 360
  status = pthread_mutex_lock(& ra->mutex);
#line 361
  if (status) {
#line 362
    while (1) {
#line 362
      if (status == 35) {
#line 362
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "do_readmap", 362, "state.c");
#line 362
        dump_core();
      }
#line 362
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 362,
                    "state.c");
#line 362
      abort();
#line 362
      break;
    }
  }
#line 364
  ap = ra->ap;
#line 365
  now = ra->now;
#line 367
  ra->signaled = 1U;
#line 368
  status = pthread_cond_signal(& ra->cond);
#line 369
  if (status) {
#line 370
    while (1) {
#line 370
      ((*log_error))(ap->logopt, "%s: failed to signal expire condition", "do_readmap");
#line 370
      break;
    }
#line 371
    pthread_mutex_unlock(& ra->mutex);
#line 372
    while (1) {
#line 372
      if (status == 35) {
#line 372
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "do_readmap", 372, "state.c");
#line 372
        dump_core();
      }
#line 372
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 372,
                    "state.c");
#line 372
      abort();
#line 372
      break;
    }
  }
#line 375
  status = pthread_mutex_unlock(& ra->mutex);
#line 376
  if (status) {
#line 377
    while (1) {
#line 377
      if (status == 35) {
#line 377
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "do_readmap", 377, "state.c");
#line 377
        dump_core();
      }
#line 377
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 377,
                    "state.c");
#line 377
      abort();
#line 377
      break;
    }
  }
#line 379
  while (1) {
#line 379
    __cancel_routine = & do_readmap_cleanup;
#line 379
    __cancel_arg = (void *)ra;
#line 379
    tmp = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf), 0);
#line 379
    not_first_call = tmp;
#line 379
    tmp___0 = __builtin_expect((long )not_first_call, 0L);
#line 379
    if (tmp___0) {
#line 379
      ((*__cancel_routine))(__cancel_arg);
#line 379
      __pthread_unwind_next(& __cancel_buf);
    }
#line 379
    __pthread_register_cancel(& __cancel_buf);
#line 379
    while (1) {
#line 381
      status = lookup_nss_read_map(ap, (struct map_source *)((void *)0), now);
#line 382
      if (! status) {
#line 383
        pthread_exit((void *)0);
      }
#line 385
      if (ap->type == 2U) {
#line 386
        lookup_prune_cache(ap, now);
#line 387
        status = lookup_ghost(ap);
      } else {
#line 390
        mnts = tree_make_mnt_tree("/proc/mounts", "/");
#line 391
        while (1) {
#line 391
          __cancel_routine___0 = & tree_mnts_cleanup;
#line 391
          __cancel_arg___0 = (void *)mnts;
#line 391
          tmp___1 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf),
                                0);
#line 391
          not_first_call___0 = tmp___1;
#line 391
          tmp___2 = __builtin_expect((long )not_first_call___0, 0L);
#line 391
          if (tmp___2) {
#line 391
            ((*__cancel_routine___0))(__cancel_arg___0);
#line 391
            __pthread_unwind_next(& __cancel_buf___0);
          }
#line 391
          __pthread_register_cancel(& __cancel_buf___0);
#line 391
          while (1) {
#line 392
            while (1) {
#line 392
              __cancel_routine___1 = & master_source_lock_cleanup;
#line 392
              __cancel_arg___1 = (void *)ap->entry;
#line 392
              tmp___3 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___1.__cancel_jmp_buf),
                                    0);
#line 392
              not_first_call___1 = tmp___3;
#line 392
              tmp___4 = __builtin_expect((long )not_first_call___1, 0L);
#line 392
              if (tmp___4) {
#line 392
                ((*__cancel_routine___1))(__cancel_arg___1);
#line 392
                __pthread_unwind_next(& __cancel_buf___1);
              }
#line 392
              __pthread_register_cancel(& __cancel_buf___1);
#line 392
              while (1) {
#line 393
                master_source_readlock(ap->entry);
#line 394
                nc = ((ap->entry)->master)->nc;
#line 395
                cache_readlock(nc);
#line 396
                while (1) {
#line 396
                  __cancel_routine___2 = & cache_lock_cleanup;
#line 396
                  __cancel_arg___2 = (void *)nc;
#line 396
                  tmp___5 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___2.__cancel_jmp_buf),
                                        0);
#line 396
                  not_first_call___2 = tmp___5;
#line 396
                  tmp___6 = __builtin_expect((long )not_first_call___2, 0L);
#line 396
                  if (tmp___6) {
#line 396
                    ((*__cancel_routine___2))(__cancel_arg___2);
#line 396
                    __pthread_unwind_next(& __cancel_buf___2);
                  }
#line 396
                  __pthread_register_cancel(& __cancel_buf___2);
#line 396
                  while (1) {
#line 397
                    map = (ap->entry)->maps;
#line 398
                    while (map) {
#line 400
                      if (! map->stale) {
#line 401
                        map = map->next;
#line 402
                        continue;
                      }
#line 404
                      mc = map->mc;
#line 405
                      while (1) {
#line 405
                        __cancel_routine___3 = & cache_lock_cleanup;
#line 405
                        __cancel_arg___3 = (void *)mc;
#line 405
                        tmp___7 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___3.__cancel_jmp_buf),
                                              0);
#line 405
                        not_first_call___3 = tmp___7;
#line 405
                        tmp___8 = __builtin_expect((long )not_first_call___3, 0L);
#line 405
                        if (tmp___8) {
#line 405
                          ((*__cancel_routine___3))(__cancel_arg___3);
#line 405
                          __pthread_unwind_next(& __cancel_buf___3);
                        }
#line 405
                        __pthread_register_cancel(& __cancel_buf___3);
#line 405
                        while (1) {
#line 406
                          cache_readlock(mc);
#line 407
                          me = cache_enumerate(mc, (struct mapent *)((void *)0));
#line 408
                          while (me) {
#line 409
                            ne = cache_lookup_distinct(nc, (char const   *)me->key);
#line 410
                            if (! ne) {
#line 411
                              nested = cache_partial_match(nc, (char const   *)me->key);
#line 412
                              if (nested) {
#line 413
                                while (1) {
#line 413
                                  ((*log_error))(ap->logopt, "%s: removing invalid nested null entry %s",
                                                 "do_readmap", nested->key);
#line 413
                                  break;
                                }
#line 416
                                nested = cache_partial_match(nc, (char const   *)me->key);
#line 417
                                if (nested) {
#line 418
                                  cache_delete(nc, (char const   *)nested->key);
                                }
                              }
                            }
#line 423
                            if (me->age < now) {
                              goto _L;
                            } else {
#line 423
                              if (ne) {
#line 423
                                if ((unsigned long )map->master_line > (unsigned long )ne->age) {
                                  _L: /* CIL Label */ 
#line 424
                                  tmp___9 = tree_is_mounted(mnts, (char const   *)me->key,
                                                            2U);
#line 424
                                  if (tmp___9) {
#line 427
                                    while (1) {
#line 427
                                      ((*log_debug))(ap->logopt, "%s: %s is mounted",
                                                     "do_readmap", me->key);
#line 427
                                      break;
                                    }
                                  } else {
#line 425
                                    do_umount_autofs_direct(ap, mnts, me);
                                  }
                                } else {
#line 430
                                  do_mount_autofs_direct(ap, mnts, me);
                                }
                              } else {
#line 430
                                do_mount_autofs_direct(ap, mnts, me);
                              }
                            }
#line 432
                            me = cache_enumerate(mc, me);
                          }
#line 405
                          break;
                        }
#line 434
                        __pthread_unregister_cancel(& __cancel_buf___3);
#line 434
                        ((*__cancel_routine___3))(__cancel_arg___3);
#line 405
                        break;
                      }
#line 435
                      map = map->next;
                    }
#line 396
                    break;
                  }
#line 437
                  __pthread_unregister_cancel(& __cancel_buf___2);
#line 437
                  ((*__cancel_routine___2))(__cancel_arg___2);
#line 396
                  break;
                }
#line 392
                break;
              }
#line 438
              __pthread_unregister_cancel(& __cancel_buf___1);
#line 438
              ((*__cancel_routine___1))(__cancel_arg___1);
#line 392
              break;
            }
#line 391
            break;
          }
#line 439
          __pthread_unregister_cancel(& __cancel_buf___0);
#line 439
          ((*__cancel_routine___0))(__cancel_arg___0);
#line 391
          break;
        }
#line 440
        lookup_prune_cache(ap, now);
      }
#line 379
      break;
    }
#line 443
    __pthread_unregister_cancel(& __cancel_buf);
#line 443
    ((*__cancel_routine))(__cancel_arg);
#line 379
    break;
  }
#line 445
  return ((void *)0);
}
}
#line 448 "state.c"
static void st_readmap_cleanup(void *arg ) 
{ struct readmap_args *ra ;
  int status ;

  {
#line 453
  ra = (struct readmap_args *)arg;
#line 455
  status = pthread_mutex_unlock(& ra->mutex);
#line 456
  if (status) {
#line 457
    while (1) {
#line 457
      if (status == 35) {
#line 457
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "st_readmap_cleanup", 457, "state.c");
#line 457
        dump_core();
      }
#line 457
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 457,
                    "state.c");
#line 457
      abort();
#line 457
      break;
    }
  }
#line 459
  status = pthread_cond_destroy(& ra->cond);
#line 460
  if (status) {
#line 461
    while (1) {
#line 461
      if (status == 35) {
#line 461
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "st_readmap_cleanup", 461, "state.c");
#line 461
        dump_core();
      }
#line 461
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 461,
                    "state.c");
#line 461
      abort();
#line 461
      break;
    }
  }
#line 463
  status = pthread_mutex_destroy(& ra->mutex);
#line 464
  if (status) {
#line 465
    while (1) {
#line 465
      if (status == 35) {
#line 465
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "st_readmap_cleanup", 465, "state.c");
#line 465
        dump_core();
      }
#line 465
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 465,
                    "state.c");
#line 465
      abort();
#line 465
      break;
    }
  }
#line 467
  return;
}
}
#line 470 "state.c"
static unsigned int st_readmap(struct autofs_point *ap ) 
{ pthread_t thid ;
  struct readmap_args *ra ;
  int status ;
  int now ;
  int tmp ;
  int _st_lock ;
  int tmp___0 ;
  int _st_unlock ;
  int tmp___1 ;
  int _st_lock___0 ;
  int tmp___2 ;
  int _st_unlock___0 ;
  int tmp___3 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___4 ;
  long tmp___5 ;

  {
#line 475
  tmp = (int )time((time_t *)((void *)0));
#line 475
  now = tmp;
#line 477
  while (1) {
#line 477
    ((*log_debug))(ap->logopt, "%s: state %d path %s", "st_readmap", ap->state, ap->path);
#line 477
    break;
  }
#line 479
  while (1) {
#line 479
    if (! ((int )ap->state == 1)) {
#line 479
      ((*log_crit))(3U, "state.c:%d: assertion failed: ap->state == ST_READY", 479);
    }
#line 479
    break;
  }
#line 480
  while (1) {
#line 480
    if (! (ap->readmap_thread == 0UL)) {
#line 480
      ((*log_crit))(3U, "state.c:%d: assertion failed: ap->readmap_thread == 0", 480);
    }
#line 480
    break;
  }
#line 482
  ap->state = 4;
#line 484
  ra = (struct readmap_args *)malloc(sizeof(struct readmap_args ));
#line 485
  if (! ra) {
#line 486
    while (1) {
#line 486
      ((*log_error))(ap->logopt, "%s: failed to malloc reamap cond struct", "st_readmap");
#line 486
      break;
    }
#line 487
    while (1) {
#line 487
      tmp___0 = pthread_mutex_lock(& ap->state_mutex);
#line 487
      _st_lock = tmp___0;
#line 487
      if (_st_lock) {
#line 487
        while (1) {
#line 487
          if (_st_lock == 35) {
#line 487
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "st_readmap", 487, "state.c");
#line 487
            dump_core();
          }
#line 487
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_lock,
                        487, "state.c");
#line 487
          abort();
#line 487
          break;
        }
      }
#line 487
      break;
    }
#line 488
    nextstate(ap->state_pipe[1], 1);
#line 489
    while (1) {
#line 489
      tmp___1 = pthread_mutex_unlock(& ap->state_mutex);
#line 489
      _st_unlock = tmp___1;
#line 489
      if (_st_unlock) {
#line 489
        while (1) {
#line 489
          if (_st_unlock == 35) {
#line 489
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "st_readmap", 489, "state.c");
#line 489
            dump_core();
          }
#line 489
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_unlock,
                        489, "state.c");
#line 489
          abort();
#line 489
          break;
        }
      }
#line 489
      break;
    }
#line 491
    if (! ap->submount) {
#line 492
      alarm_add(ap, ap->exp_runfreq);
    }
#line 493
    return (0U);
  }
#line 496
  status = pthread_mutex_init(& ra->mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 497
  if (status) {
#line 498
    while (1) {
#line 498
      if (status == 35) {
#line 498
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "st_readmap", 498, "state.c");
#line 498
        dump_core();
      }
#line 498
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 498,
                    "state.c");
#line 498
      abort();
#line 498
      break;
    }
  }
#line 500
  status = pthread_cond_init((pthread_cond_t * __restrict  )(& ra->cond), (pthread_condattr_t const   * __restrict  )((void *)0));
#line 501
  if (status) {
#line 502
    while (1) {
#line 502
      if (status == 35) {
#line 502
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "st_readmap", 502, "state.c");
#line 502
        dump_core();
      }
#line 502
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 502,
                    "state.c");
#line 502
      abort();
#line 502
      break;
    }
  }
#line 504
  status = pthread_mutex_lock(& ra->mutex);
#line 505
  if (status) {
#line 506
    while (1) {
#line 506
      if (status == 35) {
#line 506
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "st_readmap", 506, "state.c");
#line 506
        dump_core();
      }
#line 506
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 506,
                    "state.c");
#line 506
      abort();
#line 506
      break;
    }
  }
#line 508
  ra->ap = ap;
#line 509
  ra->now = (long )now;
#line 511
  status = pthread_create((pthread_t * __restrict  )(& thid), (pthread_attr_t const   * __restrict  )(& thread_attr),
                          & do_readmap, (void * __restrict  )ra);
#line 512
  if (status) {
#line 513
    while (1) {
#line 513
      ((*log_error))(ap->logopt, "%s: read map thread create failed", "st_readmap");
#line 513
      break;
    }
#line 514
    st_readmap_cleanup((void *)ra);
#line 515
    free((void *)ra);
#line 516
    while (1) {
#line 516
      tmp___2 = pthread_mutex_lock(& ap->state_mutex);
#line 516
      _st_lock___0 = tmp___2;
#line 516
      if (_st_lock___0) {
#line 516
        while (1) {
#line 516
          if (_st_lock___0 == 35) {
#line 516
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "st_readmap", 516, "state.c");
#line 516
            dump_core();
          }
#line 516
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_lock___0,
                        516, "state.c");
#line 516
          abort();
#line 516
          break;
        }
      }
#line 516
      break;
    }
#line 517
    nextstate(ap->state_pipe[1], 1);
#line 518
    while (1) {
#line 518
      tmp___3 = pthread_mutex_unlock(& ap->state_mutex);
#line 518
      _st_unlock___0 = tmp___3;
#line 518
      if (_st_unlock___0) {
#line 518
        while (1) {
#line 518
          if (_st_unlock___0 == 35) {
#line 518
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "st_readmap", 518, "state.c");
#line 518
            dump_core();
          }
#line 518
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_unlock___0,
                        518, "state.c");
#line 518
          abort();
#line 518
          break;
        }
      }
#line 518
      break;
    }
#line 520
    if (! ap->submount) {
#line 521
      alarm_add(ap, ap->exp_runfreq);
    }
#line 522
    return (0U);
  }
#line 524
  ap->readmap_thread = thid;
#line 525
  st_set_thid(ap, thid);
#line 527
  while (1) {
#line 527
    __cancel_routine = & st_readmap_cleanup;
#line 527
    __cancel_arg = (void *)ra;
#line 527
    tmp___4 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
#line 527
    not_first_call = tmp___4;
#line 527
    tmp___5 = __builtin_expect((long )not_first_call, 0L);
#line 527
    if (tmp___5) {
#line 527
      ((*__cancel_routine))(__cancel_arg);
#line 527
      __pthread_unwind_next(& __cancel_buf);
    }
#line 527
    __pthread_register_cancel(& __cancel_buf);
#line 527
    while (1) {
#line 529
      ra->signaled = 0U;
#line 530
      while (! ra->signaled) {
#line 531
        status = pthread_cond_wait((pthread_cond_t * __restrict  )(& ra->cond), (pthread_mutex_t * __restrict  )(& ra->mutex));
#line 532
        if (status) {
#line 533
          while (1) {
#line 533
            if (status == 35) {
#line 533
              ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                            "st_readmap", 533, "state.c");
#line 533
              dump_core();
            }
#line 533
            ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status,
                          533, "state.c");
#line 533
            abort();
#line 533
            break;
          }
        }
      }
#line 527
      break;
    }
#line 536
    __pthread_unregister_cancel(& __cancel_buf);
#line 536
    ((*__cancel_routine))(__cancel_arg);
#line 527
    break;
  }
#line 538
  return (1U);
}
}
#line 541 "state.c"
static unsigned int st_prepare_shutdown(struct autofs_point *ap ) 
{ int exp ;

  {
#line 545
  while (1) {
#line 545
    ((*log_debug))(ap->logopt, "%s: state %d path %s", "st_prepare_shutdown", ap->state,
                   ap->path);
#line 545
    break;
  }
#line 547
  while (1) {
#line 547
    if (! ((int )ap->state == 1)) {
#line 547
      if (! ((int )ap->state == 2)) {
#line 547
        ((*log_crit))(3U, "state.c:%d: assertion failed: ap->state == ST_READY || ap->state == ST_EXPIRE",
                      547);
      }
    }
#line 547
    break;
  }
#line 548
  ap->state = 5;
#line 551
  exp = (int )expire_proc(ap, 1);
#line 552
  switch (exp) {
  case 0: 
  case 2: 
#line 556
  if (! ap->submount) {
#line 557
    alarm_add(ap, ap->exp_runfreq);
  }
#line 558
  nextstate(ap->state_pipe[1], 1);
#line 559
  return (0U);
  case 1: 
#line 562
  return (1U);
  }
#line 564
  return (0U);
}
}
#line 567 "state.c"
static unsigned int st_force_shutdown(struct autofs_point *ap ) 
{ int exp ;

  {
#line 571
  while (1) {
#line 571
    ((*log_debug))(ap->logopt, "%s: state %d path %s", "st_force_shutdown", ap->state,
                   ap->path);
#line 571
    break;
  }
#line 573
  while (1) {
#line 573
    if (! ((int )ap->state == 1)) {
#line 573
      if (! ((int )ap->state == 2)) {
#line 573
        ((*log_crit))(3U, "state.c:%d: assertion failed: ap->state == ST_READY || ap->state == ST_EXPIRE",
                      573);
      }
    }
#line 573
    break;
  }
#line 574
  ap->state = 6;
#line 577
  exp = (int )expire_proc(ap, 1);
#line 578
  switch (exp) {
  case 0: 
  case 2: 
#line 582
  if (! ap->submount) {
#line 583
    alarm_add(ap, ap->exp_runfreq);
  }
#line 584
  nextstate(ap->state_pipe[1], 1);
#line 585
  return (0U);
  case 1: 
#line 588
  return (1U);
  }
#line 590
  return (0U);
}
}
#line 593 "state.c"
static unsigned int st_prune(struct autofs_point *ap ) 
{ int tmp ;

  {
#line 595
  while (1) {
#line 595
    ((*log_debug))(ap->logopt, "%s: state %d path %s", "st_prune", ap->state, ap->path);
#line 595
    break;
  }
#line 597
  while (1) {
#line 597
    if (! ((int )ap->state == 1)) {
#line 597
      ((*log_crit))(3U, "state.c:%d: assertion failed: ap->state == ST_READY", 597);
    }
#line 597
    break;
  }
#line 598
  ap->state = 3;
#line 600
  tmp = (int )expire_proc(ap, 1);
#line 600
  switch (tmp) {
  case 0: 
  case 2: 
#line 603
  if (! ap->submount) {
#line 604
    alarm_add(ap, ap->exp_runfreq);
  }
#line 605
  nextstate(ap->state_pipe[1], 1);
#line 606
  return (0U);
  case 1: 
#line 609
  return (1U);
  }
#line 611
  return (0U);
}
}
#line 614 "state.c"
static unsigned int st_expire(struct autofs_point *ap ) 
{ int tmp ;

  {
#line 616
  while (1) {
#line 616
    ((*log_debug))(ap->logopt, "%s: state %d path %s", "st_expire", ap->state, ap->path);
#line 616
    break;
  }
#line 618
  while (1) {
#line 618
    if (! ((int )ap->state == 1)) {
#line 618
      ((*log_crit))(3U, "state.c:%d: assertion failed: ap->state == ST_READY", 618);
    }
#line 618
    break;
  }
#line 619
  ap->state = 2;
#line 621
  tmp = (int )expire_proc(ap, 0);
#line 621
  switch (tmp) {
  case 0: 
  case 2: 
#line 624
  if (! ap->submount) {
#line 625
    alarm_add(ap, ap->exp_runfreq);
  }
#line 626
  nextstate(ap->state_pipe[1], 1);
#line 627
  return (0U);
  case 1: 
#line 630
  return (1U);
  }
#line 632
  return (0U);
}
}
#line 635 "state.c"
static struct state_queue *st_alloc_task(struct autofs_point *ap , enum states state ) 
{ struct state_queue *task ;

  {
#line 639
  task = (struct state_queue *)malloc(sizeof(struct state_queue ));
#line 640
  if (! task) {
#line 641
    return ((struct state_queue *)((void *)0));
  }
#line 642
  memset((void *)task, 0, sizeof(struct state_queue ));
#line 644
  task->ap = ap;
#line 645
  task->state = state;
#line 647
  while (1) {
#line 647
    task->list.next = & task->list;
#line 647
    task->list.prev = & task->list;
#line 647
    break;
  }
#line 648
  while (1) {
#line 648
    task->pending.next = & task->pending;
#line 648
    task->pending.prev = & task->pending;
#line 648
    break;
  }
#line 650
  return (task);
}
}
#line 654 "state.c"
int st_add_task(struct autofs_point *ap , enum states state ) 
{ struct list_head *head ;
  struct list_head *p ;
  struct list_head *q ;
  struct state_queue *new ;
  enum states ap_state ;
  unsigned int empty ;
  int status ;
  int _st_lock ;
  int tmp ;
  int _st_unlock ;
  int tmp___0 ;
  int status___0 ;
  int tmp___1 ;
  int status___1 ;
  int tmp___2 ;
  int _st_lock___0 ;
  int tmp___3 ;
  int _st_unlock___0 ;
  int tmp___4 ;
  int _st_unlock___1 ;
  int tmp___5 ;
  int status___2 ;
  int tmp___6 ;
  struct state_queue *task ;
  int tmp___7 ;
  struct state_queue *p_task ;
  int status___3 ;
  int tmp___8 ;

  {
#line 660
  empty = 1U;
#line 664
  if ((int )state == 1) {
#line 665
    while (1) {
#line 665
      tmp = pthread_mutex_lock(& ap->state_mutex);
#line 665
      _st_lock = tmp;
#line 665
      if (_st_lock) {
#line 665
        while (1) {
#line 665
          if (_st_lock == 35) {
#line 665
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "st_add_task", 665, "state.c");
#line 665
            dump_core();
          }
#line 665
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_lock,
                        665, "state.c");
#line 665
          abort();
#line 665
          break;
        }
      }
#line 665
      break;
    }
#line 666
    st_ready(ap);
#line 667
    while (1) {
#line 667
      tmp___0 = pthread_mutex_unlock(& ap->state_mutex);
#line 667
      _st_unlock = tmp___0;
#line 667
      if (_st_unlock) {
#line 667
        while (1) {
#line 667
          if (_st_unlock == 35) {
#line 667
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "st_add_task", 667, "state.c");
#line 667
            dump_core();
          }
#line 667
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_unlock,
                        667, "state.c");
#line 667
          abort();
#line 667
          break;
        }
      }
#line 667
      break;
    }
#line 669
    while (1) {
#line 669
      tmp___1 = pthread_mutex_lock(& mutex);
#line 669
      status___0 = tmp___1;
#line 669
      if (status___0) {
#line 669
        while (1) {
#line 669
          if (status___0 == 35) {
#line 669
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "st_add_task", 669, "state.c");
#line 669
            dump_core();
          }
#line 669
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status___0,
                        669, "state.c");
#line 669
          abort();
#line 669
          break;
        }
      }
#line 669
      break;
    }
#line 671
    signaled = 1U;
#line 672
    status = pthread_cond_signal(& cond);
#line 673
    if (status) {
#line 674
      while (1) {
#line 674
        if (status == 35) {
#line 674
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "st_add_task", 674, "state.c");
#line 674
          dump_core();
        }
#line 674
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 674,
                      "state.c");
#line 674
        abort();
#line 674
        break;
      }
    }
#line 676
    while (1) {
#line 676
      tmp___2 = pthread_mutex_unlock(& mutex);
#line 676
      status___1 = tmp___2;
#line 676
      if (status___1) {
#line 676
        while (1) {
#line 676
          if (status___1 == 35) {
#line 676
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "st_add_task", 676, "state.c");
#line 676
            dump_core();
          }
#line 676
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status___1,
                        676, "state.c");
#line 676
          abort();
#line 676
          break;
        }
      }
#line 676
      break;
    }
#line 678
    return (1);
  }
#line 681
  while (1) {
#line 681
    tmp___3 = pthread_mutex_lock(& ap->state_mutex);
#line 681
    _st_lock___0 = tmp___3;
#line 681
    if (_st_lock___0) {
#line 681
      while (1) {
#line 681
        if (_st_lock___0 == 35) {
#line 681
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "st_add_task", 681, "state.c");
#line 681
          dump_core();
        }
#line 681
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_lock___0,
                      681, "state.c");
#line 681
        abort();
#line 681
        break;
      }
    }
#line 681
    break;
  }
#line 682
  ap_state = ap->state;
#line 683
  if ((int )ap_state == 7) {
#line 684
    while (1) {
#line 684
      tmp___4 = pthread_mutex_unlock(& ap->state_mutex);
#line 684
      _st_unlock___0 = tmp___4;
#line 684
      if (_st_unlock___0) {
#line 684
        while (1) {
#line 684
          if (_st_unlock___0 == 35) {
#line 684
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "st_add_task", 684, "state.c");
#line 684
            dump_core();
          }
#line 684
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_unlock___0,
                        684, "state.c");
#line 684
          abort();
#line 684
          break;
        }
      }
#line 684
      break;
    }
#line 685
    return (1);
  }
#line 687
  while (1) {
#line 687
    tmp___5 = pthread_mutex_unlock(& ap->state_mutex);
#line 687
    _st_unlock___1 = tmp___5;
#line 687
    if (_st_unlock___1) {
#line 687
      while (1) {
#line 687
        if (_st_unlock___1 == 35) {
#line 687
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "st_add_task", 687, "state.c");
#line 687
          dump_core();
        }
#line 687
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_unlock___1,
                      687, "state.c");
#line 687
        abort();
#line 687
        break;
      }
    }
#line 687
    break;
  }
#line 689
  while (1) {
#line 689
    tmp___6 = pthread_mutex_lock(& mutex);
#line 689
    status___2 = tmp___6;
#line 689
    if (status___2) {
#line 689
      while (1) {
#line 689
        if (status___2 == 35) {
#line 689
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "st_add_task", 689, "state.c");
#line 689
          dump_core();
        }
#line 689
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status___2,
                      689, "state.c");
#line 689
        abort();
#line 689
        break;
      }
    }
#line 689
    break;
  }
#line 691
  head = & state_queue;
#line 694
  p = head->next;
#line 694
  while ((unsigned int )p != (unsigned int )head) {
#line 697
    task = (struct state_queue *)((char *)p - (unsigned long )(& ((struct state_queue *)0)->list));
#line 699
    if ((unsigned int )task->ap != (unsigned int )ap) {
      goto __Cont;
    }
#line 702
    empty = 0U;
#line 705
    if ((int )task->state == (int )state) {
#line 705
      if (! task->done) {
#line 708
        break;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 705
      if ((int )ap_state == 5) {
#line 708
        break;
      } else {
#line 705
        if ((int )ap_state == 6) {
#line 708
          break;
        }
      }
    }
#line 711
    tmp___7 = list_empty(& task->pending);
#line 711
    if (tmp___7) {
#line 712
      new = st_alloc_task(ap, state);
#line 713
      if (new) {
#line 714
        list_add_tail(& new->pending, & task->pending);
      }
      goto done;
    }
#line 718
    q = task->pending.next;
#line 718
    while ((unsigned int )q != (unsigned int )(& task->pending)) {
#line 721
      p_task = (struct state_queue *)((char *)q - (unsigned long )(& ((struct state_queue *)0)->pending));
#line 723
      if ((int )p_task->state == (int )state) {
        goto done;
      } else {
#line 723
        if ((int )ap_state == 5) {
          goto done;
        } else {
#line 723
          if ((int )ap_state == 6) {
            goto done;
          }
        }
      }
#line 718
      q = q->next;
    }
#line 729
    new = st_alloc_task(ap, state);
#line 730
    if (new) {
#line 731
      list_add_tail(& new->pending, & task->pending);
    }
    done: 
#line 733
    break;
    __Cont: /* CIL Label */ 
#line 694
    p = p->next;
  }
#line 736
  if (empty) {
#line 737
    new = st_alloc_task(ap, state);
#line 738
    if (new) {
#line 739
      list_add(& new->list, head);
    }
  }
#line 743
  signaled = 1U;
#line 744
  status = pthread_cond_signal(& cond);
#line 745
  if (status) {
#line 746
    while (1) {
#line 746
      if (status == 35) {
#line 746
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "st_add_task", 746, "state.c");
#line 746
        dump_core();
      }
#line 746
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 746,
                    "state.c");
#line 746
      abort();
#line 746
      break;
    }
  }
#line 748
  while (1) {
#line 748
    tmp___8 = pthread_mutex_unlock(& mutex);
#line 748
    status___3 = tmp___8;
#line 748
    if (status___3) {
#line 748
      while (1) {
#line 748
        if (status___3 == 35) {
#line 748
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "st_add_task", 748, "state.c");
#line 748
          dump_core();
        }
#line 748
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status___3,
                      748, "state.c");
#line 748
        abort();
#line 748
        break;
      }
    }
#line 748
    break;
  }
#line 750
  return (1);
}
}
#line 753 "state.c"
void st_remove_tasks(struct autofs_point *ap ) 
{ struct list_head *head ;
  struct list_head *p ;
  struct list_head *q ;
  struct state_queue *task ;
  struct state_queue *waiting ;
  int status ;
  int status___0 ;
  int tmp ;
  int status___1 ;
  int tmp___0 ;
  int tmp___1 ;
  int status___2 ;
  int tmp___2 ;

  {
#line 760
  while (1) {
#line 760
    tmp = pthread_mutex_lock(& mutex);
#line 760
    status___0 = tmp;
#line 760
    if (status___0) {
#line 760
      while (1) {
#line 760
        if (status___0 == 35) {
#line 760
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "st_remove_tasks", 760, "state.c");
#line 760
          dump_core();
        }
#line 760
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status___0,
                      760, "state.c");
#line 760
        abort();
#line 760
        break;
      }
    }
#line 760
    break;
  }
#line 762
  head = & state_queue;
#line 764
  tmp___1 = list_empty(head);
#line 764
  if (tmp___1) {
#line 765
    while (1) {
#line 765
      tmp___0 = pthread_mutex_unlock(& mutex);
#line 765
      status___1 = tmp___0;
#line 765
      if (status___1) {
#line 765
        while (1) {
#line 765
          if (status___1 == 35) {
#line 765
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "st_remove_tasks", 765, "state.c");
#line 765
            dump_core();
          }
#line 765
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status___1,
                        765, "state.c");
#line 765
          abort();
#line 765
          break;
        }
      }
#line 765
      break;
    }
#line 766
    return;
  }
#line 769
  p = head->next;
#line 770
  while ((unsigned int )p != (unsigned int )head) {
#line 771
    task = (struct state_queue *)((char *)p - (unsigned long )(& ((struct state_queue *)0)->list));
#line 772
    p = p->next;
#line 774
    if ((unsigned int )task->ap != (unsigned int )ap) {
#line 775
      continue;
    }
#line 777
    if (task->busy) {
#line 779
      if ((int )task->state == 2) {
#line 782
        task->cancel = 1U;
      } else {
#line 779
        if ((int )task->state == 3) {
#line 782
          task->cancel = 1U;
        } else {
#line 779
          if ((int )task->state == 4) {
#line 782
            task->cancel = 1U;
          }
        }
      }
    }
#line 785
    q = task->pending.next;
#line 786
    while ((unsigned int )q != (unsigned int )(& task->pending)) {
#line 787
      waiting = (struct state_queue *)((char *)q - (unsigned long )(& ((struct state_queue *)0)->pending));
#line 788
      q = q->next;
#line 791
      if ((int )waiting->state != 5) {
#line 791
        if ((int )waiting->state != 6) {
#line 793
          list_del(& waiting->pending);
#line 794
          free((void *)waiting);
        }
      }
    }
  }
#line 799
  signaled = 1U;
#line 800
  status = pthread_cond_signal(& cond);
#line 801
  if (status) {
#line 802
    while (1) {
#line 802
      if (status == 35) {
#line 802
        ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                      "st_remove_tasks", 802, "state.c");
#line 802
        dump_core();
      }
#line 802
      ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 802,
                    "state.c");
#line 802
      abort();
#line 802
      break;
    }
  }
#line 804
  while (1) {
#line 804
    tmp___2 = pthread_mutex_unlock(& mutex);
#line 804
    status___2 = tmp___2;
#line 804
    if (status___2) {
#line 804
      while (1) {
#line 804
        if (status___2 == 35) {
#line 804
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "st_remove_tasks", 804, "state.c");
#line 804
          dump_core();
        }
#line 804
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status___2,
                      804, "state.c");
#line 804
        abort();
#line 804
        break;
      }
    }
#line 804
    break;
  }
#line 806
  return;
}
}
#line 810 "state.c"
static int run_state_task(struct state_queue *task ) 
{ struct autofs_point *ap ;
  enum states next_state ;
  enum states state ;
  unsigned long ret ;
  int _st_lock ;
  int tmp ;
  int _st_unlock ;
  int tmp___0 ;

  {
#line 814
  ret = 0UL;
#line 816
  ap = task->ap;
#line 817
  next_state = task->state;
#line 819
  while (1) {
#line 819
    tmp = pthread_mutex_lock(& ap->state_mutex);
#line 819
    _st_lock = tmp;
#line 819
    if (_st_lock) {
#line 819
      while (1) {
#line 819
        if (_st_lock == 35) {
#line 819
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "run_state_task", 819, "state.c");
#line 819
          dump_core();
        }
#line 819
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_lock, 819,
                      "state.c");
#line 819
        abort();
#line 819
        break;
      }
    }
#line 819
    break;
  }
#line 821
  state = ap->state;
#line 823
  if ((int )next_state != (int )state) {
#line 824
    switch ((int )next_state) {
    case 3: 
#line 826
    ret = (unsigned long )st_prune(ap);
#line 827
    break;
    case 2: 
#line 830
    ret = (unsigned long )st_expire(ap);
#line 831
    break;
    case 4: 
#line 834
    ret = (unsigned long )st_readmap(ap);
#line 835
    break;
    case 5: 
#line 838
    ret = (unsigned long )st_prepare_shutdown(ap);
#line 839
    break;
    case 6: 
#line 842
    ret = (unsigned long )st_force_shutdown(ap);
#line 843
    break;
    default: ;
#line 846
    while (1) {
#line 846
      ((*log_error))(ap->logopt, "%s: bad next state %d", "run_state_task", next_state);
#line 846
      break;
    }
    }
  }
#line 850
  while (1) {
#line 850
    tmp___0 = pthread_mutex_unlock(& ap->state_mutex);
#line 850
    _st_unlock = tmp___0;
#line 850
    if (_st_unlock) {
#line 850
      while (1) {
#line 850
        if (_st_unlock == 35) {
#line 850
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "run_state_task", 850, "state.c");
#line 850
          dump_core();
        }
#line 850
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", _st_unlock,
                      850, "state.c");
#line 850
        abort();
#line 850
        break;
      }
    }
#line 850
    break;
  }
#line 852
  return ((int )ret);
}
}
#line 855 "state.c"
static void st_set_thid(struct autofs_point *ap , pthread_t thid ) 
{ struct list_head *p ;
  struct list_head *head ;
  struct state_queue *task ;

  {
#line 857
  head = & state_queue;
#line 860
  p = head->next;
#line 860
  while ((unsigned int )p != (unsigned int )head) {
#line 861
    task = (struct state_queue *)((char *)p - (unsigned long )(& ((struct state_queue *)0)->list));
#line 862
    if ((unsigned int )task->ap == (unsigned int )ap) {
#line 863
      task->thid = thid;
#line 864
      break;
    }
#line 860
    p = p->next;
  }
#line 867
  return;
}
}
#line 871 "state.c"
static void st_set_done(struct autofs_point *ap ) 
{ struct list_head *p ;
  struct list_head *head ;
  struct state_queue *task ;
  int status ;
  int tmp ;
  int status___0 ;
  int tmp___0 ;

  {
#line 876
  while (1) {
#line 876
    tmp = pthread_mutex_lock(& mutex);
#line 876
    status = tmp;
#line 876
    if (status) {
#line 876
      while (1) {
#line 876
        if (status == 35) {
#line 876
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "st_set_done", 876, "state.c");
#line 876
          dump_core();
        }
#line 876
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 876,
                      "state.c");
#line 876
        abort();
#line 876
        break;
      }
    }
#line 876
    break;
  }
#line 878
  head = & state_queue;
#line 879
  p = head->next;
#line 879
  while ((unsigned int )p != (unsigned int )head) {
#line 880
    task = (struct state_queue *)((char *)p - (unsigned long )(& ((struct state_queue *)0)->list));
#line 881
    if ((unsigned int )task->ap == (unsigned int )ap) {
#line 882
      task->done = 1U;
#line 883
      break;
    }
#line 879
    p = p->next;
  }
#line 887
  while (1) {
#line 887
    tmp___0 = pthread_mutex_unlock(& mutex);
#line 887
    status___0 = tmp___0;
#line 887
    if (status___0) {
#line 887
      while (1) {
#line 887
        if (status___0 == 35) {
#line 887
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "st_set_done", 887, "state.c");
#line 887
          dump_core();
        }
#line 887
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status___0,
                      887, "state.c");
#line 887
        abort();
#line 887
        break;
      }
    }
#line 887
    break;
  }
#line 889
  return;
}
}
#line 892 "state.c"
static void *st_queue_handler(void *arg ) 
{ struct list_head *head ;
  struct list_head *p ;
  struct timespec wait ;
  int status ;
  int ret ;
  int status___0 ;
  int tmp ;
  time_t tmp___0 ;
  int tmp___1 ;
  struct state_queue *task ;
  time_t tmp___2 ;
  struct state_queue *task___0 ;
  struct state_queue *next ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 899
  while (1) {
#line 899
    tmp = pthread_mutex_lock(& mutex);
#line 899
    status___0 = tmp;
#line 899
    if (status___0) {
#line 899
      while (1) {
#line 899
        if (status___0 == 35) {
#line 899
          ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                        "st_queue_handler", 899, "state.c");
#line 899
          dump_core();
        }
#line 899
        ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status___0,
                      899, "state.c");
#line 899
        abort();
#line 899
        break;
      }
    }
#line 899
    break;
  }
#line 901
  while (1) {
#line 906
    head = & state_queue;
#line 907
    tmp___0 = time((time_t *)((void *)0));
#line 907
    wait.tv_sec = tmp___0 + 1L;
#line 908
    wait.tv_nsec = 0L;
#line 910
    while (1) {
#line 910
      tmp___1 = list_empty(head);
#line 910
      if (! tmp___1) {
#line 910
        break;
      }
#line 911
      status = pthread_cond_timedwait((pthread_cond_t * __restrict  )(& cond), (pthread_mutex_t * __restrict  )(& mutex),
                                      (struct timespec  const  * __restrict  )(& wait));
#line 912
      if (status) {
#line 913
        if (status == 110) {
#line 914
          break;
        }
#line 915
        while (1) {
#line 915
          if (status == 35) {
#line 915
            ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                          "st_queue_handler", 915, "state.c");
#line 915
            dump_core();
          }
#line 915
          ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status, 915,
                        "state.c");
#line 915
          abort();
#line 915
          break;
        }
      }
    }
#line 919
    p = head->next;
#line 920
    while ((unsigned int )p != (unsigned int )head) {
#line 923
      task = (struct state_queue *)((char *)p - (unsigned long )(& ((struct state_queue *)0)->list));
#line 924
      p = p->next;
#line 926
      if (task->cancel) {
#line 927
        list_del(& task->list);
#line 928
        free((void *)task);
#line 929
        continue;
      }
#line 932
      task->busy = 1U;
#line 934
      ret = run_state_task(task);
#line 935
      if (! ret) {
#line 936
        list_del(& task->list);
#line 937
        free((void *)task);
      }
    }
#line 941
    while (1) {
#line 942
      tmp___2 = time((time_t *)((void *)0));
#line 942
      wait.tv_sec = tmp___2 + 1L;
#line 943
      wait.tv_nsec = 0L;
#line 945
      signaled = 0U;
#line 946
      while (! signaled) {
#line 947
        status = pthread_cond_timedwait((pthread_cond_t * __restrict  )(& cond), (pthread_mutex_t * __restrict  )(& mutex),
                                        (struct timespec  const  * __restrict  )(& wait));
#line 948
        if (status) {
#line 949
          if (status == 110) {
#line 950
            break;
          }
#line 951
          while (1) {
#line 951
            if (status == 35) {
#line 951
              ((*log_crit))(3U, "%s: deadlock detected at line %d in %s, dumping core.",
                            "st_queue_handler", 951, "state.c");
#line 951
              dump_core();
            }
#line 951
            ((*log_crit))(3U, "unexpected pthreads error: %d at %d in %s", status,
                          951, "state.c");
#line 951
            abort();
#line 951
            break;
          }
        }
      }
#line 955
      head = & state_queue;
#line 956
      p = head->next;
#line 957
      while ((unsigned int )p != (unsigned int )head) {
#line 960
        task___0 = (struct state_queue *)((char *)p - (unsigned long )(& ((struct state_queue *)0)->list));
#line 961
        p = p->next;
#line 963
        if (! task___0->busy) {
#line 965
          task___0->busy = 1U;
#line 967
          ret = run_state_task(task___0);
#line 968
          if (! ret) {
            goto remove;
          }
#line 970
          continue;
        }
#line 974
        if (! task___0->thid) {
#line 975
          continue;
        }
#line 977
        if (task___0->cancel) {
#line 978
          pthread_cancel(task___0->thid);
#line 979
          task___0->cancel = 0U;
#line 980
          continue;
        }
#line 984
        if (! task___0->done) {
#line 985
          continue;
        }
        remove: 
#line 989
        tmp___3 = list_empty(& task___0->pending);
#line 989
        if (tmp___3) {
#line 990
          list_del(& task___0->list);
#line 991
          free((void *)task___0);
#line 992
          continue;
        }
#line 996
        next = (struct state_queue *)((char *)task___0->pending.next - (unsigned long )(& ((struct state_queue *)0)->pending));
#line 999
        list_del_init(& next->pending);
#line 1000
        list_add_tail(& next->list, p);
#line 1002
        list_del(& task___0->list);
#line 1003
        free((void *)task___0);
      }
#line 1006
      tmp___4 = list_empty(head);
#line 1006
      if (tmp___4) {
#line 1007
        break;
      }
    }
  }
}
}
#line 1012 "state.c"
int st_start_handler(void) 
{ pthread_t thid ;
  pthread_attr_t attrs ;
  pthread_attr_t *pattrs ;
  int status ;

  {
#line 1016
  pattrs = & attrs;
#line 1019
  status = pthread_attr_init(pattrs);
#line 1020
  if (status) {
#line 1021
    pattrs = (pthread_attr_t *)((void *)0);
  } else {
#line 1023
    pthread_attr_setdetachstate(pattrs, 1);
#line 1025
    pthread_attr_setstacksize(pattrs, 65536U);
  }
#line 1029
  status = pthread_create((pthread_t * __restrict  )(& thid), (pthread_attr_t const   * __restrict  )pattrs,
                          & st_queue_handler, (void * __restrict  )((void *)0));
#line 1030
  if (status) {
#line 1031
    return (0);
  }
#line 1033
  return (1);
}
}








