/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

#line 214 "/usr/lib/gcc/i486-linux-gnu/4.1.2/include/stddef.h"
typedef unsigned int size_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 145 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 147 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 28 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_11 {
   unsigned long __val[1024U / (8U * sizeof(unsigned long ))] ;
};
#line 28 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_11 __sigset_t;
#line 50 "/usr/include/signal.h"
typedef __sigset_t sigset_t;
#line 33 "/usr/include/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 33 "/usr/include/bits/siginfo.h"
typedef union sigval sigval_t;
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__kill_13 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__timer_14 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__rt_15 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigchld_16 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigfault_17 {
   void *si_addr ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigpoll_18 {
   long si_band ;
   int si_fd ;
};
#line 51 "/usr/include/bits/siginfo.h"
union __anonunion__sifields_12 {
   int _pad[128U / sizeof(int ) - 3U] ;
   struct __anonstruct__kill_13 _kill ;
   struct __anonstruct__timer_14 _timer ;
   struct __anonstruct__rt_15 _rt ;
   struct __anonstruct__sigchld_16 _sigchld ;
   struct __anonstruct__sigfault_17 _sigfault ;
   struct __anonstruct__sigpoll_18 _sigpoll ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_12 _sifields ;
};
#line 51 "/usr/include/bits/siginfo.h"
typedef struct siginfo siginfo_t;
#line 25 "/usr/include/bits/sigaction.h"
union __anonunion___sigaction_handler_30 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 25 "/usr/include/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_30 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 36 "lib/libsolkerncompat/include/sys/types.h"
enum boolean {
    B_FALSE = 0,
    B_TRUE = 1
} ;
#line 36 "lib/libsolkerncompat/include/sys/types.h"
typedef enum boolean boolean_t;
#line 59 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 60 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 136 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 143 "/usr/include/bits/types.h"
typedef long __off_t;
#line 144 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 182 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 194 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 62 "/usr/include/sys/types.h"
typedef __dev_t dev_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 193 "/usr/include/sys/types.h"
typedef int int32_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 59 "/usr/include/stdint.h"
typedef unsigned long long uint64_t;
#line 126 "/usr/include/stdint.h"
typedef int intptr_t;
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 176 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 182 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 267 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   int _mode ;
   char _unused2[15U * sizeof(int ) - 2U * sizeof(void *)] ;
};
#line 36 "/usr/include/bits/socket.h"
typedef __socklen_t socklen_t;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 145 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/sys/poll.h"
typedef unsigned long nfds_t;
#line 33 "/usr/include/sys/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 50 "lib/libsolkerncompat/include/sys/cred.h"
struct cred;
#line 50 "lib/libsolkerncompat/include/sys/cred.h"
typedef struct cred cred_t;
#line 51 "lib/libzfscommon/include/sys/zfs_ioctl.h"
enum __anonenum_cmd_type_59 {
    IOCTL_REQ = 0,
    IOCTL_ANS = 1,
    COPYIN_REQ = 2,
    COPYOUT_REQ = 3,
    MOUNT_REQ = 4,
    GETF_REQ = 5
} ;
#line 51 "lib/libzfscommon/include/sys/zfs_ioctl.h"
struct ioctl_req {
   int32_t cmd ;
   uint64_t arg ;
};
#line 51 "lib/libzfscommon/include/sys/zfs_ioctl.h"
struct copy_req {
   uint64_t ptr ;
   uint64_t size ;
};
#line 51 "lib/libzfscommon/include/sys/zfs_ioctl.h"
struct mount_req {
   uint32_t speclen ;
   uint32_t dirlen ;
   int32_t mflag ;
   int32_t optlen ;
};
#line 51 "lib/libzfscommon/include/sys/zfs_ioctl.h"
union __anonunion_cmd_u_60 {
   struct ioctl_req ioctl_req ;
   int32_t ioctl_ans_ret ;
   struct copy_req copy_req ;
   struct mount_req mount_req ;
   int32_t getf_req_fd ;
};
#line 51 "lib/libzfscommon/include/sys/zfs_ioctl.h"
struct __anonstruct_zfsfuse_cmd_t_58 {
   enum __anonenum_cmd_type_59 cmd_type ;
   union __anonunion_cmd_u_60 cmd_u ;
};
#line 51 "lib/libzfscommon/include/sys/zfs_ioctl.h"
typedef struct __anonstruct_zfsfuse_cmd_t_58 zfsfuse_cmd_t;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 140 "/usr/include/bits/types.h"
typedef __u_quad_t __ino64_t;
#line 141 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 151 "/usr/include/bits/types.h"
typedef long __time_t;
#line 166 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 172 "/usr/include/bits/types.h"
typedef __quad_t __blkcnt64_t;
#line 118 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 82 "/usr/include/bits/pthreadtypes.h"
typedef unsigned int pthread_key_t;
#line 106 "/usr/include/bits/pthreadtypes.h"
typedef int pthread_once_t;
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t __st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off64_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __ino64_t st_ino ;
};
#line 69 "zfs-fuse/ptrace.c"
enum __anonenum_entry_t_41 {
    FUNCTION_ENTRY = 0,
    FUNCTION_EXIT = 1
} ;
#line 69 "zfs-fuse/ptrace.c"
typedef enum __anonenum_entry_t_41 entry_t;
#line 70
enum __anonenum_active_t_42 {
    A_UNINITIALIZED = 0,
    A_DISABLED = 1,
    A_ACTIVE = 2,
    A_INACTIVE = 3
} ;
#line 70 "zfs-fuse/ptrace.c"
typedef enum __anonenum_active_t_42 active_t;
#line 176 "/usr/include/bits/types.h"
typedef __u_quad_t __fsblkcnt64_t;
#line 180 "/usr/include/bits/types.h"
typedef __u_quad_t __fsfilcnt64_t;
#line 188 "/usr/include/bits/types.h"
typedef char *__caddr_t;
#line 67 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 72 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 77 "/usr/include/sys/types.h"
typedef __nlink_t nlink_t;
#line 82 "/usr/include/sys/types.h"
typedef __uid_t uid_t;
#line 90 "/usr/include/sys/types.h"
typedef __off64_t off_t;
#line 117 "/usr/include/sys/types.h"
typedef __caddr_t caddr_t;
#line 259 "/usr/include/sys/types.h"
typedef __fsblkcnt64_t fsblkcnt64_t;
#line 260 "/usr/include/sys/types.h"
typedef __fsfilcnt64_t fsfilcnt64_t;
#line 83 "/usr/include/bits/sched.h"
struct __sched_param {
   int __sched_priority ;
};
#line 25 "/usr/include/bits/pthreadtypes.h"
typedef int __atomic_lock_t;
#line 28 "/usr/include/bits/pthreadtypes.h"
struct _pthread_fastlock {
   long __status ;
   __atomic_lock_t __spinlock ;
};
#line 37
struct _pthread_descr_struct;
#line 37 "/usr/include/bits/pthreadtypes.h"
typedef struct _pthread_descr_struct *_pthread_descr;
#line 43 "/usr/include/bits/pthreadtypes.h"
struct __pthread_attr_s {
   int __detachstate ;
   int __schedpolicy ;
   struct __sched_param __schedparam ;
   int __inheritsched ;
   int __scope ;
   size_t __guardsize ;
   int __stackaddr_set ;
   void *__stackaddr ;
   size_t __stacksize ;
};
#line 43 "/usr/include/bits/pthreadtypes.h"
typedef struct __pthread_attr_s pthread_attr_t;
#line 88 "/usr/include/bits/pthreadtypes.h"
struct __anonstruct_pthread_mutex_t_8 {
   int __m_reserved ;
   int __m_count ;
   _pthread_descr __m_owner ;
   int __m_kind ;
   struct _pthread_fastlock __m_lock ;
};
#line 88 "/usr/include/bits/pthreadtypes.h"
typedef struct __anonstruct_pthread_mutex_t_8 pthread_mutex_t;
#line 111 "/usr/include/bits/pthreadtypes.h"
struct _pthread_rwlock_t {
   struct _pthread_fastlock __rw_lock ;
   int __rw_readers ;
   _pthread_descr __rw_writer ;
   _pthread_descr __rw_read_waiting ;
   _pthread_descr __rw_write_waiting ;
   int __rw_kind ;
   int __rw_pshared ;
};
#line 111 "/usr/include/bits/pthreadtypes.h"
typedef struct _pthread_rwlock_t pthread_rwlock_t;
#line 152 "/usr/include/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 38 "lib/libsolkerncompat/include/sys/types.h"
typedef unsigned char uchar_t;
#line 39 "lib/libsolkerncompat/include/sys/types.h"
typedef unsigned short ushort_t;
#line 40 "lib/libsolkerncompat/include/sys/types.h"
typedef unsigned int uint_t;
#line 41 "lib/libsolkerncompat/include/sys/types.h"
typedef unsigned long ulong_t;
#line 43 "lib/libsolkerncompat/include/sys/types.h"
typedef long long longlong_t;
#line 44 "lib/libsolkerncompat/include/sys/types.h"
typedef unsigned long long u_longlong_t;
#line 46 "lib/libsolkerncompat/include/sys/types.h"
typedef longlong_t offset_t;
#line 47 "lib/libsolkerncompat/include/sys/types.h"
typedef u_longlong_t u_offset_t;
#line 67 "lib/libsolkerncompat/include/sys/types.h"
struct __anonstruct__p_15 {
   int32_t _l ;
   int32_t _u ;
};
#line 67 "lib/libsolkerncompat/include/sys/types.h"
union __anonunion_lloff_t_14 {
   offset_t _f ;
   struct __anonstruct__p_15 _p ;
};
#line 67 "lib/libsolkerncompat/include/sys/types.h"
typedef union __anonunion_lloff_t_14 lloff_t;
#line 34 "lib/libsolkerncompat/include/sys/time.h"
typedef struct timespec timestruc_t;
#line 47 "lib/libzfscommon/include/sys/dmu.h"
struct uio;
#line 48
struct page;
#line 49
struct vnode;
#line 32 "lib/libsolkerncompat/include/sys/mutex.h"
struct kmutex {
   void *m_owner ;
   pthread_mutex_t m_lock ;
};
#line 32 "lib/libsolkerncompat/include/sys/mutex.h"
typedef struct kmutex kmutex_t;
#line 33 "lib/libsolkerncompat/include/sys/rwlock.h"
struct krwlock {
   kmutex_t mutex ;
   int thr_count ;
   void *rw_owner ;
   pthread_rwlock_t rw_lock ;
};
#line 33 "lib/libsolkerncompat/include/sys/rwlock.h"
typedef struct krwlock krwlock_t;
#line 153 "/usr/include/bits/fcntl.h"
struct flock64 {
   short l_type ;
   short l_whence ;
   __off64_t l_start ;
   __off64_t l_len ;
   __pid_t l_pid ;
};
#line 31 "lib/libsolkerncompat/include/sys/rwstlock.h"
typedef krwlock_t rwslock_t;
#line 42 "/usr/include/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 62 "lib/libsolkerncompat/include/sys/uio.h"
typedef struct iovec iovec_t;
#line 97
enum uio_seg {
    UIO_USERSPACE = 0,
    UIO_SYSSPACE = 1,
    UIO_USERISPACE = 2
} ;
#line 97 "lib/libsolkerncompat/include/sys/uio.h"
typedef enum uio_seg uio_seg_t;
#line 99 "lib/libsolkerncompat/include/sys/uio.h"
struct uio {
   iovec_t *uio_iov ;
   int uio_iovcnt ;
   lloff_t _uio_offset ;
   uio_seg_t uio_segflg ;
   uint16_t uio_fmode ;
   uint16_t uio_extflg ;
   lloff_t _uio_limit ;
   ssize_t uio_resid ;
};
#line 99 "lib/libsolkerncompat/include/sys/uio.h"
typedef struct uio uio_t;
#line 34 "lib/libsolkerncompat/include/vm/seg_enum.h"
enum seg_rw {
    S_OTHER = 0,
    S_READ = 1,
    S_WRITE = 2,
    S_EXEC = 3,
    S_CREATE = 4,
    S_READ_NOCOW = 5
} ;
#line 74 "lib/libsolkerncompat/include/sys/vnode.h"
struct vn_vfslocks_entry {
   rwslock_t ve_lock ;
};
#line 74 "lib/libsolkerncompat/include/sys/vnode.h"
typedef struct vn_vfslocks_entry vn_vfslocks_entry_t;
#line 82
enum vtype {
    VNON = 0,
    VREG = 1,
    VDIR = 2,
    VBLK = 3,
    VCHR = 4,
    VLNK = 5,
    VFIFO = 6,
    VDOOR = 7,
    VPROC = 8,
    VSOCK = 9,
    VPORT = 10,
    VBAD = 11
} ;
#line 82 "lib/libsolkerncompat/include/sys/vnode.h"
typedef enum vtype vtype_t;
#line 155
struct vfs;
#line 155
struct vnodeops;
#line 155 "lib/libsolkerncompat/include/sys/vnode.h"
struct vnode {
   kmutex_t v_lock ;
   uint_t v_flag ;
   struct vfs *v_vfsp ;
   vn_vfslocks_entry_t v_vfsmhlock ;
   int v_fd ;
   uint64_t v_size ;
   char *v_path ;
   uint_t v_rdcnt ;
   uint_t v_wrcnt ;
   void *v_data ;
   uint_t v_count ;
   enum vtype v_type ;
   dev_t v_rdev ;
   struct vnodeops *v_op ;
};
#line 155 "lib/libsolkerncompat/include/sys/vnode.h"
typedef struct vnode vnode_t;
#line 172 "lib/libsolkerncompat/include/sys/vnode.h"
struct vattr {
   uint_t va_mask ;
   vtype_t va_type ;
   mode_t va_mode ;
   uid_t va_uid ;
   gid_t va_gid ;
   dev_t va_fsid ;
   u_longlong_t va_nodeid ;
   nlink_t va_nlink ;
   u_offset_t va_size ;
   timestruc_t va_atime ;
   timestruc_t va_mtime ;
   timestruc_t va_ctime ;
   dev_t va_rdev ;
   uint_t va_blksize ;
   u_longlong_t va_nblocks ;
   uint_t va_seq ;
};
#line 172 "lib/libsolkerncompat/include/sys/vnode.h"
typedef struct vattr vattr_t;
#line 195 "lib/libsolkerncompat/include/sys/vnode.h"
struct vsecattr {
   uint_t vsa_mask ;
   int vsa_aclcnt ;
   void *vsa_aclentp ;
   int vsa_dfaclcnt ;
   void *vsa_dfaclentp ;
};
#line 195 "lib/libsolkerncompat/include/sys/vnode.h"
typedef struct vsecattr vsecattr_t;
#line 211 "lib/libsolkerncompat/include/sys/vnode.h"
typedef int caller_context_t;
#line 216
struct pathname;
#line 217
struct fid;
#line 219
struct flk_callback;
#line 220
struct shrlock;
#line 222
struct seg;
#line 223
struct as;
#line 224
struct pollhead;
#line 258
enum vcexcl {
    NONEXCL = 0,
    EXCL = 1
} ;
#line 267
enum vnevent {
    VE_SUPPORT = 0,
    VE_RENAME_SRC = 1,
    VE_RENAME_DEST = 2,
    VE_REMOVE = 3,
    VE_RMDIR = 4
} ;
#line 267 "lib/libsolkerncompat/include/sys/vnode.h"
typedef enum vnevent vnevent_t;
#line 277 "lib/libsolkerncompat/include/sys/vnode.h"
typedef enum vcexcl vcexcl_t;
#line 354 "lib/libsolkerncompat/include/sys/vnode.h"
struct vnodeops {
   char const   *vnop_name ;
   int (*vop_open)(vnode_t ** , int  , cred_t * ) ;
   int (*vop_close)(vnode_t * , int  , int  , offset_t  , cred_t * ) ;
   int (*vop_read)(vnode_t * , uio_t * , int  , cred_t * , caller_context_t * ) ;
   int (*vop_write)(vnode_t * , uio_t * , int  , cred_t * , caller_context_t * ) ;
   int (*vop_ioctl)(vnode_t * , int  , intptr_t  , int  , cred_t * , int * ) ;
   int (*vop_setfl)(vnode_t * , int  , int  , cred_t * ) ;
   int (*vop_getattr)(vnode_t * , vattr_t * , int  , cred_t * ) ;
   int (*vop_setattr)(vnode_t * , vattr_t * , int  , cred_t * , caller_context_t * ) ;
   int (*vop_access)(vnode_t * , int  , int  , cred_t * ) ;
   int (*vop_lookup)(vnode_t * , char * , vnode_t ** , struct pathname * , int  ,
                     vnode_t * , cred_t * ) ;
   int (*vop_create)(vnode_t * , char * , vattr_t * , vcexcl_t  , int  , vnode_t ** ,
                     cred_t * , int  ) ;
   int (*vop_remove)(vnode_t * , char * , cred_t * ) ;
   int (*vop_link)(vnode_t * , vnode_t * , char * , cred_t * ) ;
   int (*vop_rename)(vnode_t * , char * , vnode_t * , char * , cred_t * ) ;
   int (*vop_mkdir)(vnode_t * , char * , vattr_t * , vnode_t ** , cred_t * ) ;
   int (*vop_rmdir)(vnode_t * , char * , vnode_t * , cred_t * ) ;
   int (*vop_readdir)(vnode_t * , uio_t * , cred_t * , int * ) ;
   int (*vop_symlink)(vnode_t * , char * , vattr_t * , char * , cred_t * ) ;
   int (*vop_readlink)(vnode_t * , uio_t * , cred_t * ) ;
   int (*vop_fsync)(vnode_t * , int  , cred_t * ) ;
   void (*vop_inactive)(vnode_t * , cred_t * ) ;
   int (*vop_fid)(vnode_t * , struct fid * ) ;
   int (*vop_rwlock)(vnode_t * , int  , caller_context_t * ) ;
   void (*vop_rwunlock)(vnode_t * , int  , caller_context_t * ) ;
   int (*vop_seek)(vnode_t * , offset_t  , offset_t * ) ;
   int (*vop_cmp)(vnode_t * , vnode_t * ) ;
   int (*vop_frlock)(vnode_t * , int  , struct flock64 * , int  , offset_t  , struct flk_callback * ,
                     cred_t * ) ;
   int (*vop_space)(vnode_t * , int  , struct flock64 * , int  , offset_t  , cred_t * ,
                    caller_context_t * ) ;
   int (*vop_realvp)(vnode_t * , vnode_t ** ) ;
   int (*vop_getpage)(vnode_t * , offset_t  , size_t  , uint_t * , struct page ** ,
                      size_t  , struct seg * , caddr_t  , enum seg_rw  , cred_t * ) ;
   int (*vop_putpage)(vnode_t * , offset_t  , size_t  , int  , cred_t * ) ;
   int (*vop_map)(vnode_t * , offset_t  , struct as * , caddr_t * , size_t  , uchar_t  ,
                  uchar_t  , uint_t  , cred_t * ) ;
   int (*vop_addmap)(vnode_t * , offset_t  , struct as * , caddr_t  , size_t  , uchar_t  ,
                     uchar_t  , uint_t  , cred_t * ) ;
   int (*vop_delmap)(vnode_t * , offset_t  , struct as * , caddr_t  , size_t  , uint_t  ,
                     uint_t  , uint_t  , cred_t * ) ;
   int (*vop_poll)(vnode_t * , short  , int  , short * , struct pollhead ** ) ;
   int (*vop_dump)(vnode_t * , caddr_t  , int  , int  ) ;
   int (*vop_pathconf)(vnode_t * , int  , ulong_t * , cred_t * ) ;
   int (*vop_pageio)(vnode_t * , struct page * , u_offset_t  , size_t  , int  , cred_t * ) ;
   int (*vop_dumpctl)(vnode_t * , int  , int * ) ;
   void (*vop_dispose)(vnode_t * , struct page * , int  , int  , cred_t * ) ;
   int (*vop_setsecattr)(vnode_t * , vsecattr_t * , int  , cred_t * ) ;
   int (*vop_getsecattr)(vnode_t * , vsecattr_t * , int  , cred_t * ) ;
   int (*vop_shrlock)(vnode_t * , int  , struct shrlock * , int  , cred_t * ) ;
   int (*vop_vnevent)(vnode_t * , vnevent_t  ) ;
};
#line 105 "/usr/local/include/fuse/fuse_opt.h"
struct fuse_args {
   int argc ;
   char **argv ;
   int allocated ;
};
#line 42 "/usr/local/include/fuse/fuse_common.h"
struct fuse_file_info {
   int flags ;
   unsigned long fh_old ;
   int writepage ;
   unsigned int direct_io : 1 ;
   unsigned int keep_cache : 1 ;
   unsigned int flush : 1 ;
   unsigned int padding : 29 ;
   uint64_t fh ;
   uint64_t lock_owner ;
};
#line 116
struct fuse_session;
#line 117
struct fuse_chan;
#line 100 "lib/libsolkerncompat/include/sys/statvfs.h"
struct statvfs64 {
   unsigned long f_bsize ;
   unsigned long f_frsize ;
   fsblkcnt64_t f_blocks ;
   fsblkcnt64_t f_bfree ;
   fsblkcnt64_t f_bavail ;
   fsfilcnt64_t f_files ;
   fsfilcnt64_t f_ffree ;
   fsfilcnt64_t f_favail ;
   unsigned long f_fsid ;
   char f_basetype[16] ;
   unsigned long f_flag ;
   unsigned long f_namemax ;
   char f_fstr[32] ;
   unsigned long f_filler[16] ;
};
#line 100 "lib/libsolkerncompat/include/sys/statvfs.h"
typedef struct statvfs64 statvfs64_t;
#line 46 "/usr/local/include/fuse/fuse_lowlevel.h"
typedef unsigned long fuse_ino_t;
#line 49
struct fuse_req;
#line 49 "/usr/local/include/fuse/fuse_lowlevel.h"
typedef struct fuse_req *fuse_req_t;
#line 12 "/usr/local/include/fuse/fuse_lowlevel_compat.h"
struct fuse_lowlevel_ops_compat25 {
   void (*init)(void *userdata ) ;
   void (*destroy)(void *userdata ) ;
   void (*lookup)(fuse_req_t req , fuse_ino_t parent , char const   *name ) ;
   void (*forget)(fuse_req_t req , fuse_ino_t ino , unsigned long nlookup ) ;
   void (*getattr)(fuse_req_t req , fuse_ino_t ino , struct fuse_file_info *fi ) ;
   void (*setattr)(fuse_req_t req , fuse_ino_t ino , struct stat *attr , int to_set ,
                   struct fuse_file_info *fi ) ;
   void (*readlink)(fuse_req_t req , fuse_ino_t ino ) ;
   void (*mknod)(fuse_req_t req , fuse_ino_t parent , char const   *name , mode_t mode ,
                 dev_t rdev ) ;
   void (*mkdir)(fuse_req_t req , fuse_ino_t parent , char const   *name , mode_t mode ) ;
   void (*unlink)(fuse_req_t req , fuse_ino_t parent , char const   *name ) ;
   void (*rmdir)(fuse_req_t req , fuse_ino_t parent , char const   *name ) ;
   void (*symlink)(fuse_req_t req , char const   *link , fuse_ino_t parent , char const   *name ) ;
   void (*rename)(fuse_req_t req , fuse_ino_t parent , char const   *name , fuse_ino_t newparent ,
                  char const   *newname ) ;
   void (*link)(fuse_req_t req , fuse_ino_t ino , fuse_ino_t newparent , char const   *newname ) ;
   void (*open)(fuse_req_t req , fuse_ino_t ino , struct fuse_file_info *fi ) ;
   void (*read)(fuse_req_t req , fuse_ino_t ino , size_t size , off_t off , struct fuse_file_info *fi ) ;
   void (*write)(fuse_req_t req , fuse_ino_t ino , char const   *buf , size_t size ,
                 off_t off , struct fuse_file_info *fi ) ;
   void (*flush)(fuse_req_t req , fuse_ino_t ino , struct fuse_file_info *fi ) ;
   void (*release)(fuse_req_t req , fuse_ino_t ino , struct fuse_file_info *fi ) ;
   void (*fsync)(fuse_req_t req , fuse_ino_t ino , int datasync , struct fuse_file_info *fi ) ;
   void (*opendir)(fuse_req_t req , fuse_ino_t ino , struct fuse_file_info *fi ) ;
   void (*readdir)(fuse_req_t req , fuse_ino_t ino , size_t size , off_t off , struct fuse_file_info *fi ) ;
   void (*releasedir)(fuse_req_t req , fuse_ino_t ino , struct fuse_file_info *fi ) ;
   void (*fsyncdir)(fuse_req_t req , fuse_ino_t ino , int datasync , struct fuse_file_info *fi ) ;
   void (*statfs)(fuse_req_t req ) ;
   void (*setxattr)(fuse_req_t req , fuse_ino_t ino , char const   *name , char const   *value ,
                    size_t size , int flags ) ;
   void (*getxattr)(fuse_req_t req , fuse_ino_t ino , char const   *name , size_t size ) ;
   void (*listxattr)(fuse_req_t req , fuse_ino_t ino , size_t size ) ;
   void (*removexattr)(fuse_req_t req , fuse_ino_t ino , char const   *name ) ;
   void (*access)(fuse_req_t req , fuse_ino_t ino , int mask ) ;
   void (*create)(fuse_req_t req , fuse_ino_t parent , char const   *name , mode_t mode ,
                  struct fuse_file_info *fi ) ;
};
#line 41 "lib/libsolkerncompat/include/sys/refstr.h"
struct refstr;
#line 41 "lib/libsolkerncompat/include/sys/refstr.h"
typedef struct refstr refstr_t;
#line 37 "lib/libsolkerncompat/include/sys/vfs.h"
struct vfsops;
#line 37 "lib/libsolkerncompat/include/sys/vfs.h"
typedef struct vfsops vfsops_t;
#line 44 "lib/libsolkerncompat/include/sys/vfs.h"
struct vfs {
   struct vfs *vfs_next ;
   struct vfs *vfs_prev ;
   vfsops_t *vfs_op ;
   struct vnode *vfs_vnodecovered ;
   uint_t vfs_flag ;
   uint_t vfs_bsize ;
   int vfs_fstype ;
   void *vfs_data ;
   dev_t vfs_dev ;
   ulong_t vfs_bcount ;
   uint_t vfs_count ;
   refstr_t *vfs_resource ;
};
#line 44 "lib/libsolkerncompat/include/sys/vfs.h"
typedef struct vfs vfs_t;
#line 69 "lib/libsolkerncompat/include/sys/vfs.h"
struct mounta {
   char *spec ;
   char *dir ;
   int flags ;
   char *fstype ;
   char *dataptr ;
   int datalen ;
   char *optptr ;
   int optlen ;
};
#line 143 "lib/libsolkerncompat/include/sys/vfs.h"
struct __anonstruct__fid_61 {
   ushort_t len ;
   char data[64] ;
};
#line 143 "lib/libsolkerncompat/include/sys/vfs.h"
union __anonunion_un_60 {
   long fid_pad ;
   struct __anonstruct__fid_61 _fid ;
};
#line 143 "lib/libsolkerncompat/include/sys/vfs.h"
struct fid {
   union __anonunion_un_60 un ;
};
#line 143 "lib/libsolkerncompat/include/sys/vfs.h"
typedef struct fid fid_t;
#line 159
enum whymountroot {
    ROOT_INIT = 0,
    ROOT_REMOUNT = 1,
    ROOT_UNMOUNT = 2
} ;
#line 165
enum vntrans {
    VNTRANS_EXISTS = 0,
    VNTRANS_IDLED = 1,
    VNTRANS_RECLAIMED = 2,
    VNTRANS_DESTROYED = 3
} ;
#line 171 "lib/libsolkerncompat/include/sys/vfs.h"
typedef enum vntrans vntrans_t;
#line 176 "lib/libsolkerncompat/include/sys/vfs.h"
struct vfsops {
   int (*vfs_mount)(vfs_t * , vnode_t * , struct mounta * , cred_t * ) ;
   int (*vfs_unmount)(vfs_t * , int  , cred_t * ) ;
   int (*vfs_root)(vfs_t * , vnode_t ** ) ;
   int (*vfs_statvfs)(vfs_t * , statvfs64_t * ) ;
   int (*vfs_sync)(vfs_t * , short  , cred_t * ) ;
   int (*vfs_vget)(vfs_t * , vnode_t ** , fid_t * ) ;
   int (*vfs_mountroot)(vfs_t * , enum whymountroot  ) ;
   int (*vfs_freevfs)(vfs_t * ) ;
   int (*vfs_vnstate)(vfs_t * , vnode_t * , vntrans_t  ) ;
};
#line 60 "/usr/include/bits/pthreadtypes.h"
typedef long long __pthread_cond_align_t;
#line 65 "/usr/include/bits/pthreadtypes.h"
struct __anonstruct_pthread_cond_t_4 {
   struct _pthread_fastlock __c_lock ;
   _pthread_descr __c_waiting ;
   char __padding[((48U - sizeof(struct _pthread_fastlock )) - sizeof(_pthread_descr )) - sizeof(__pthread_cond_align_t )] ;
   __pthread_cond_align_t __align ;
};
#line 65 "/usr/include/bits/pthreadtypes.h"
typedef struct __anonstruct_pthread_cond_t_4 pthread_cond_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 61 "lib/libavl/include/sys/avl_impl.h"
struct avl_node {
   struct avl_node *avl_child[2] ;
   struct avl_node *avl_parent ;
   unsigned short avl_child_index ;
   short avl_balance ;
};
#line 146 "lib/libavl/include/sys/avl_impl.h"
struct avl_tree {
   struct avl_node *avl_root ;
   int (*avl_compar)(void const   * , void const   * ) ;
   size_t avl_offset ;
   ulong_t avl_numnodes ;
   size_t avl_size ;
};
#line 110 "lib/libavl/include/sys/avl.h"
typedef struct avl_tree avl_tree_t;
#line 38 "lib/libzfscommon/include/sys/list_impl.h"
struct list_node {
   struct list_node *list_next ;
   struct list_node *list_prev ;
};
#line 43 "lib/libzfscommon/include/sys/list_impl.h"
struct list {
   size_t list_size ;
   size_t list_offset ;
   struct list_node list_head ;
};
#line 38 "lib/libzfscommon/include/sys/list.h"
typedef struct list_node list_node_t;
#line 39 "lib/libzfscommon/include/sys/list.h"
typedef struct list list_t;
#line 51 "lib/libzfscommon/include/sys/dmu.h"
struct zilog;
#line 64
struct objset;
#line 64 "lib/libzfscommon/include/sys/dmu.h"
typedef struct objset objset_t;
#line 65
struct dmu_tx;
#line 65 "lib/libzfscommon/include/sys/dmu.h"
typedef struct dmu_tx dmu_tx_t;
#line 68
enum dmu_object_type {
    DMU_OT_NONE = 0,
    DMU_OT_OBJECT_DIRECTORY = 1,
    DMU_OT_OBJECT_ARRAY = 2,
    DMU_OT_PACKED_NVLIST = 3,
    DMU_OT_PACKED_NVLIST_SIZE = 4,
    DMU_OT_BPLIST = 5,
    DMU_OT_BPLIST_HDR = 6,
    DMU_OT_SPACE_MAP_HEADER = 7,
    DMU_OT_SPACE_MAP = 8,
    DMU_OT_INTENT_LOG = 9,
    DMU_OT_DNODE = 10,
    DMU_OT_OBJSET = 11,
    DMU_OT_DSL_DIR = 12,
    DMU_OT_DSL_DIR_CHILD_MAP = 13,
    DMU_OT_DSL_DS_SNAP_MAP = 14,
    DMU_OT_DSL_PROPS = 15,
    DMU_OT_DSL_DATASET = 16,
    DMU_OT_ZNODE = 17,
    DMU_OT_ACL = 18,
    DMU_OT_PLAIN_FILE_CONTENTS = 19,
    DMU_OT_DIRECTORY_CONTENTS = 20,
    DMU_OT_MASTER_NODE = 21,
    DMU_OT_DELETE_QUEUE = 22,
    DMU_OT_ZVOL = 23,
    DMU_OT_ZVOL_PROP = 24,
    DMU_OT_PLAIN_OTHER = 25,
    DMU_OT_UINT64_OTHER = 26,
    DMU_OT_ZAP_OTHER = 27,
    DMU_OT_ERROR_LOG = 28,
    DMU_OT_SPA_HISTORY = 29,
    DMU_OT_SPA_HISTORY_OFFSETS = 30,
    DMU_OT_NUMTYPES = 31
} ;
#line 68 "lib/libzfscommon/include/sys/dmu.h"
typedef enum dmu_object_type dmu_object_type_t;
#line 170 "lib/libzfscommon/include/sys/dmu.h"
struct dmu_buf {
   uint64_t db_object ;
   uint64_t db_offset ;
   uint64_t db_size ;
   void *db_data ;
};
#line 170 "lib/libzfscommon/include/sys/dmu.h"
typedef struct dmu_buf dmu_buf_t;
#line 38 "lib/libsolkerncompat/include/sys/condvar.h"
typedef pthread_cond_t kcondvar_t;
#line 48 "lib/libzfscommon/include/sys/spa.h"
typedef struct zilog zilog_t;
#line 42 "lib/libzfscommon/include/sys/zfs_vfsops.h"
struct zfs_delete_list {
   kmutex_t z_mutex ;
   kcondvar_t z_cv ;
   kcondvar_t z_quiesce_cv ;
   uint8_t z_drained ;
   uint8_t z_draining ;
   uint32_t z_thread_target ;
   uint32_t z_thread_count ;
   uint64_t z_znode_count ;
   list_t z_znodes ;
};
#line 42 "lib/libzfscommon/include/sys/zfs_vfsops.h"
typedef struct zfs_delete_list zfs_delete_t;
#line 54
struct zfsvfs;
#line 54 "lib/libzfscommon/include/sys/zfs_vfsops.h"
typedef struct zfsvfs zfsvfs_t;
#line 56 "lib/libzfscommon/include/sys/zfs_vfsops.h"
struct zfsvfs {
   vfs_t *z_vfs ;
   zfsvfs_t *z_parent ;
   objset_t *z_os ;
   uint64_t z_root ;
   uint64_t z_dqueue ;
   uint64_t z_max_blksz ;
   uint64_t z_assign ;
   zilog_t *z_log ;
   uint_t z_acl_mode ;
   uint_t z_acl_inherit ;
   boolean_t z_atime ;
   boolean_t z_unmounted1 ;
   boolean_t z_unmounted2 ;
   uint32_t z_op_cnt ;
   krwlock_t z_um_lock ;
   zfs_delete_t z_delete_head ;
   list_t z_all_znodes ;
   kmutex_t z_znodes_lock ;
   vnode_t *z_ctldir ;
   boolean_t z_show_ctldir ;
   boolean_t z_issnap ;
   kmutex_t z_hold_mtx[64] ;
};
#line 44 "lib/libsolkerncompat/include/sys/acl.h"
struct ace {
   uid_t a_who ;
   uint32_t a_access_mask ;
   uint16_t a_flags ;
   uint16_t a_type ;
};
#line 44 "lib/libsolkerncompat/include/sys/acl.h"
typedef struct ace ace_t;
#line 42 "lib/libzfscommon/include/sys/zfs_acl.h"
struct znode_phys;
#line 48 "lib/libzfscommon/include/sys/zfs_acl.h"
struct zfs_znode_acl {
   uint64_t z_acl_extern_obj ;
   uint32_t z_acl_count ;
   uint16_t z_acl_version ;
   uint16_t z_acl_pad ;
   ace_t z_ace_data[6] ;
};
#line 48 "lib/libzfscommon/include/sys/zfs_acl.h"
typedef struct zfs_znode_acl zfs_znode_acl_t;
#line 64 "lib/libzfscommon/include/sys/zfs_acl.h"
struct zfs_acl {
   int z_slots ;
   int z_acl_count ;
   uint_t z_state ;
   ace_t *z_acl ;
};
#line 64 "lib/libzfscommon/include/sys/zfs_acl.h"
typedef struct zfs_acl zfs_acl_t;
#line 86
struct znode;
#line 92 "lib/libzfscommon/include/sys/zfs_znode.h"
struct znode_phys {
   uint64_t zp_atime[2] ;
   uint64_t zp_mtime[2] ;
   uint64_t zp_ctime[2] ;
   uint64_t zp_crtime[2] ;
   uint64_t zp_gen ;
   uint64_t zp_mode ;
   uint64_t zp_size ;
   uint64_t zp_parent ;
   uint64_t zp_links ;
   uint64_t zp_xattr ;
   uint64_t zp_rdev ;
   uint64_t zp_flags ;
   uint64_t zp_uid ;
   uint64_t zp_gid ;
   uint64_t zp_pad[4] ;
   zfs_znode_acl_t zp_acl ;
};
#line 92 "lib/libzfscommon/include/sys/zfs_znode.h"
typedef struct znode_phys znode_phys_t;
#line 126 "lib/libzfscommon/include/sys/zfs_znode.h"
struct zfs_dirlock {
   char *dl_name ;
   uint32_t dl_sharecnt ;
   uint16_t dl_namesize ;
   kcondvar_t dl_cv ;
   struct znode *dl_dzp ;
   struct zfs_dirlock *dl_next ;
};
#line 126 "lib/libzfscommon/include/sys/zfs_znode.h"
typedef struct zfs_dirlock zfs_dirlock_t;
#line 135 "lib/libzfscommon/include/sys/zfs_znode.h"
struct znode {
   struct zfsvfs *z_zfsvfs ;
   vnode_t *z_vnode ;
   list_node_t z_list_node ;
   uint64_t z_id ;
   kmutex_t z_lock ;
   krwlock_t z_map_lock ;
   krwlock_t z_parent_lock ;
   zfs_dirlock_t *z_dirlocks ;
   kmutex_t z_range_lock ;
   avl_tree_t z_range_avl ;
   uint8_t z_reap ;
   uint8_t z_atime_dirty ;
   uint8_t z_dbuf_held ;
   uint8_t z_zn_prefetch ;
   uint_t z_blksz ;
   uint_t z_seq ;
   uint64_t z_mapcnt ;
   uint64_t z_last_itx ;
   uint32_t z_sync_cnt ;
   kmutex_t z_acl_lock ;
   list_node_t z_link_node ;
   znode_phys_t *z_phys ;
   dmu_buf_t *z_dbuf ;
};
#line 135 "lib/libzfscommon/include/sys/zfs_znode.h"
typedef struct znode znode_t;
#line 33 "lib/libsolkerncompat/include/vm/page.h"
struct page {
   u_offset_t p_offset ;
};
#line 30 "lib/libsolkerncompat/include/sys/callb.h"
struct callb_cpr {
   kmutex_t *cc_lockp ;
};
#line 30 "lib/libsolkerncompat/include/sys/callb.h"
typedef struct callb_cpr callb_cpr_t;
#line 53 "lib/libsolkerncompat/include/sys/flock.h"
enum __anonenum_flk_cb_when_t_68 {
    FLK_BEFORE_SLEEP = 0,
    FLK_AFTER_SLEEP = 1
} ;
#line 53 "lib/libsolkerncompat/include/sys/flock.h"
typedef enum __anonenum_flk_cb_when_t_68 flk_cb_when_t;
#line 55 "lib/libsolkerncompat/include/sys/flock.h"
struct flk_callback {
   struct flk_callback *cb_next ;
   struct flk_callback *cb_prev ;
   callb_cpr_t *(*cb_callback)(flk_cb_when_t  , void * ) ;
   void *cb_data ;
};
#line 40 "lib/libsolkerncompat/include/sys/rwlock.h"
typedef int krw_t;
#line 63 "lib/libsolkerncompat/include/sys/pathname.h"
struct pathname {
   char *pn_buf ;
   char *pn_path ;
   size_t pn_pathlen ;
   size_t pn_bufsize ;
};
#line 54 "lib/libzfscommon/include/sys/dmu.h"
struct zap_cursor;
#line 440 "lib/libzfscommon/include/sys/dmu.h"
struct dmu_object_info {
   uint32_t doi_data_block_size ;
   uint32_t doi_metadata_block_size ;
   uint64_t doi_bonus_size ;
   dmu_object_type_t doi_type ;
   dmu_object_type_t doi_bonus_type ;
   uint8_t doi_indirection ;
   uint8_t doi_checksum ;
   uint8_t doi_compress ;
   uint8_t doi_pad[5] ;
   uint64_t doi_physical_blks ;
   uint64_t doi_max_block_offset ;
};
#line 440 "lib/libzfscommon/include/sys/dmu.h"
typedef struct dmu_object_info dmu_object_info_t;
#line 31 "lib/libsolkerncompat/include/sys/thread.h"
typedef pthread_t kthread_t;
#line 200 "lib/libzfscommon/include/sys/zap.h"
struct zap;
#line 201
struct zap_leaf;
#line 202 "lib/libzfscommon/include/sys/zap.h"
struct zap_cursor {
   objset_t *zc_objset ;
   struct zap *zc_zap ;
   struct zap_leaf *zc_leaf ;
   uint64_t zc_zapobj ;
   uint64_t zc_hash ;
   uint32_t zc_cd ;
};
#line 202 "lib/libzfscommon/include/sys/zap.h"
typedef struct zap_cursor zap_cursor_t;
#line 212 "lib/libzfscommon/include/sys/zap.h"
struct __anonstruct_zap_attribute_t_68 {
   int za_integer_length ;
   uint64_t za_num_integers ;
   uint64_t za_first_integer ;
   char za_name[256] ;
};
#line 212 "lib/libzfscommon/include/sys/zap.h"
typedef struct __anonstruct_zap_attribute_t_68 zap_attribute_t;
#line 60 "/usr/include/time.h"
typedef __clock_t clock_t;
#line 192 "/usr/include/sys/types.h"
typedef short int16_t;
#line 194 "/usr/include/sys/types.h"
typedef long long int64_t;
#line 43 "/usr/lib/gcc/i486-linux-gnu/4.1.2/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 77 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 115 "lib/libavl/include/sys/avl.h"
typedef struct avl_node avl_node_t;
#line 36 "lib/libsolkerncompat/include/sys/file.h"
struct file {
   struct vnode *f_vnode ;
   offset_t f_offset ;
   int f_client ;
   int f_oldfd ;
   avl_node_t f_node ;
};
#line 36 "lib/libsolkerncompat/include/sys/file.h"
typedef struct file file_t;
#line 141 "lib/libsolkerncompat/include/sys/dditypes.h"
struct __dev_info;
#line 141 "lib/libsolkerncompat/include/sys/dditypes.h"
typedef struct __dev_info *dev_info_t;
#line 50 "lib/libzfscommon/include/sys/dmu.h"
struct spa;
#line 58
struct drr_begin;
#line 60
struct zbookmark;
#line 62
struct nvlist;
#line 113
enum dmu_objset_type {
    DMU_OST_NONE = 0,
    DMU_OST_META = 1,
    DMU_OST_ZFS = 2,
    DMU_OST_ZVOL = 3,
    DMU_OST_OTHER = 4,
    DMU_OST_ANY = 5,
    DMU_OST_NUMTYPES = 6
} ;
#line 113 "lib/libzfscommon/include/sys/dmu.h"
typedef enum dmu_objset_type dmu_objset_type_t;
#line 477 "lib/libzfscommon/include/sys/dmu.h"
struct dmu_objset_stats {
   uint64_t dds_num_clones ;
   uint64_t dds_creation_txg ;
   dmu_objset_type_t dds_type ;
   uint8_t dds_is_snapshot ;
   uint8_t dds_inconsistent ;
   char dds_clone_of[256] ;
};
#line 477 "lib/libzfscommon/include/sys/dmu.h"
typedef struct dmu_objset_stats dmu_objset_stats_t;
#line 44 "lib/libnvpair/include/sys/nvpair.h"
enum __anonenum_data_type_t_46 {
    DATA_TYPE_UNKNOWN = 0,
    DATA_TYPE_BOOLEAN = 1,
    DATA_TYPE_BYTE = 2,
    DATA_TYPE_INT16 = 3,
    DATA_TYPE_UINT16 = 4,
    DATA_TYPE_INT32 = 5,
    DATA_TYPE_UINT32 = 6,
    DATA_TYPE_INT64 = 7,
    DATA_TYPE_UINT64 = 8,
    DATA_TYPE_STRING = 9,
    DATA_TYPE_BYTE_ARRAY = 10,
    DATA_TYPE_INT16_ARRAY = 11,
    DATA_TYPE_UINT16_ARRAY = 12,
    DATA_TYPE_INT32_ARRAY = 13,
    DATA_TYPE_UINT32_ARRAY = 14,
    DATA_TYPE_INT64_ARRAY = 15,
    DATA_TYPE_UINT64_ARRAY = 16,
    DATA_TYPE_STRING_ARRAY = 17,
    DATA_TYPE_HRTIME = 18,
    DATA_TYPE_NVLIST = 19,
    DATA_TYPE_NVLIST_ARRAY = 20,
    DATA_TYPE_BOOLEAN_VALUE = 21,
    DATA_TYPE_INT8 = 22,
    DATA_TYPE_UINT8 = 23,
    DATA_TYPE_BOOLEAN_ARRAY = 24,
    DATA_TYPE_INT8_ARRAY = 25,
    DATA_TYPE_UINT8_ARRAY = 26
} ;
#line 44 "lib/libnvpair/include/sys/nvpair.h"
typedef enum __anonenum_data_type_t_46 data_type_t;
#line 74 "lib/libnvpair/include/sys/nvpair.h"
struct nvpair {
   int32_t nvp_size ;
   int16_t nvp_name_sz ;
   int16_t nvp_reserve ;
   int32_t nvp_value_elem ;
   data_type_t nvp_type ;
};
#line 74 "lib/libnvpair/include/sys/nvpair.h"
typedef struct nvpair nvpair_t;
#line 86 "lib/libnvpair/include/sys/nvpair.h"
struct nvlist {
   int32_t nvl_version ;
   uint32_t nvl_nvflag ;
   uint64_t nvl_priv ;
   uint32_t nvl_flag ;
   int32_t nvl_pad ;
};
#line 86 "lib/libnvpair/include/sys/nvpair.h"
typedef struct nvlist nvlist_t;
#line 59 "lib/libzfscommon/include/sys/fs/zfs.h"
enum __anonenum_zfs_prop_t_48 {
    ZFS_PROP_INVAL = -1,
    ZFS_PROP_TYPE = 0,
    ZFS_PROP_CREATION = 1,
    ZFS_PROP_USED = 2,
    ZFS_PROP_AVAILABLE = 3,
    ZFS_PROP_REFERENCED = 4,
    ZFS_PROP_COMPRESSRATIO = 5,
    ZFS_PROP_MOUNTED = 6,
    ZFS_PROP_ORIGIN = 7,
    ZFS_PROP_QUOTA = 8,
    ZFS_PROP_RESERVATION = 9,
    ZFS_PROP_VOLSIZE = 10,
    ZFS_PROP_VOLBLOCKSIZE = 11,
    ZFS_PROP_RECORDSIZE = 12,
    ZFS_PROP_MOUNTPOINT = 13,
    ZFS_PROP_SHARENFS = 14,
    ZFS_PROP_SHAREISCSI = 15,
    ZFS_PROP_CHECKSUM = 16,
    ZFS_PROP_COMPRESSION = 17,
    ZFS_PROP_ATIME = 18,
    ZFS_PROP_DEVICES = 19,
    ZFS_PROP_EXEC = 20,
    ZFS_PROP_SETUID = 21,
    ZFS_PROP_READONLY = 22,
    ZFS_PROP_ZONED = 23,
    ZFS_PROP_SNAPDIR = 24,
    ZFS_PROP_ACLMODE = 25,
    ZFS_PROP_ACLINHERIT = 26,
    ZFS_PROP_CANMOUNT = 27,
    ZFS_PROP_XATTR = 28,
    ZFS_PROP_CREATETXG = 29,
    ZFS_PROP_NAME = 30,
    ZFS_PROP_ISCSIOPTIONS = 31,
    ZFS_PROP_NUMCLONES = 32,
    ZFS_NPROP_ALL = 33
} ;
#line 59 "lib/libzfscommon/include/sys/fs/zfs.h"
typedef enum __anonenum_zfs_prop_t_48 zfs_prop_t;
#line 252
enum pool_scrub_type {
    POOL_SCRUB_NONE = 0,
    POOL_SCRUB_RESILVER = 1,
    POOL_SCRUB_EVERYTHING = 2,
    POOL_SCRUB_TYPES = 3
} ;
#line 252 "lib/libzfscommon/include/sys/fs/zfs.h"
typedef enum pool_scrub_type pool_scrub_type_t;
#line 45 "lib/libzfscommon/include/sys/spa.h"
typedef struct spa spa_t;
#line 46
struct vdev;
#line 46 "lib/libzfscommon/include/sys/spa.h"
typedef struct vdev vdev_t;
#line 183 "lib/libzfscommon/include/sys/zio.h"
struct zbookmark {
   uint64_t zb_objset ;
   uint64_t zb_object ;
   int64_t zb_level ;
   uint64_t zb_blkid ;
};
#line 183 "lib/libzfscommon/include/sys/zio.h"
typedef struct zbookmark zbookmark_t;
#line 338
struct zinject_record;
#line 82 "lib/libzfscommon/include/sys/zfs_ioctl.h"
struct drr_begin {
   uint64_t drr_magic ;
   uint64_t drr_version ;
   uint64_t drr_creation_time ;
   dmu_objset_type_t drr_type ;
   uint32_t drr_pad ;
   uint64_t drr_toguid ;
   uint64_t drr_fromguid ;
   char drr_toname[256] ;
};
#line 133 "lib/libzfscommon/include/sys/zfs_ioctl.h"
struct zinject_record {
   uint64_t zi_objset ;
   uint64_t zi_object ;
   uint64_t zi_start ;
   uint64_t zi_end ;
   uint64_t zi_guid ;
   uint32_t zi_level ;
   uint32_t zi_error ;
   uint64_t zi_type ;
   uint32_t zi_freq ;
};
#line 133 "lib/libzfscommon/include/sys/zfs_ioctl.h"
typedef struct zinject_record zinject_record_t;
#line 149 "lib/libzfscommon/include/sys/zfs_ioctl.h"
struct zfs_cmd {
   char zc_name[4096] ;
   char zc_value[4096] ;
   uint64_t zc_guid ;
   uint64_t zc_nvlist_src ;
   uint64_t zc_nvlist_src_size ;
   uint64_t zc_nvlist_dst ;
   uint64_t zc_nvlist_dst_size ;
   uint64_t zc_cookie ;
   uint64_t zc_cred ;
   uint64_t zc_dev ;
   uint64_t zc_objset_type ;
   uint64_t zc_history ;
   uint64_t zc_history_len ;
   uint64_t zc_history_offset ;
   dmu_objset_stats_t zc_objset_stats ;
   struct drr_begin zc_begin_record ;
   zinject_record_t zc_inject_record ;
   zbookmark_t zc_bookmark ;
};
#line 149 "lib/libzfscommon/include/sys/zfs_ioctl.h"
typedef struct zfs_cmd zfs_cmd_t;
#line 170 "lib/libzfscommon/include/sys/zfs_ioctl.h"
struct zfs_create_data {
   cred_t *zc_cred ;
   dev_t zc_dev ;
   nvlist_t *zc_props ;
};
#line 170 "lib/libzfscommon/include/sys/zfs_ioctl.h"
typedef struct zfs_create_data zfs_create_data_t;
#line 30 "lib/libsolkerncompat/include/sys/sunldi.h"
typedef void *ldi_ident_t;
#line 35 "lib/libzfscommon/include/zfs_namecheck.h"
enum __anonenum_namecheck_err_t_73 {
    NAME_ERR_LEADING_SLASH = 0,
    NAME_ERR_EMPTY_COMPONENT = 1,
    NAME_ERR_TRAILING_SLASH = 2,
    NAME_ERR_INVALCHAR = 3,
    NAME_ERR_MULTIPLE_AT = 4,
    NAME_ERR_NOLETTER = 5,
    NAME_ERR_RESERVED = 6,
    NAME_ERR_DISKLIKE = 7,
    NAME_ERR_TOOLONG = 8
} ;
#line 35 "lib/libzfscommon/include/zfs_namecheck.h"
typedef enum __anonenum_namecheck_err_t_73 namecheck_err_t;
#line 42 "lib/libzfscommon/include/zfs_prop.h"
enum __anonenum_zfs_proptype_t_74 {
    prop_type_number = 0,
    prop_type_string = 1,
    prop_type_boolean = 2,
    prop_type_index = 3
} ;
#line 42 "lib/libzfscommon/include/zfs_prop.h"
typedef enum __anonenum_zfs_proptype_t_74 zfs_proptype_t;
#line 72 "zfs-fuse/zfs_ioctl.c"
typedef int zfs_ioc_func_t(zfs_cmd_t * );
#line 73 "zfs-fuse/zfs_ioctl.c"
typedef int zfs_secpolicy_func_t(char const   * , cred_t * );
#line 75
enum __anonenum_zvec_namecheck_75 {
    no_name = 0,
    pool_name = 1,
    dataset_name = 2
} ;
#line 75 "zfs-fuse/zfs_ioctl.c"
struct zfs_ioc_vec {
   zfs_ioc_func_t *zvec_func ;
   zfs_secpolicy_func_t *zvec_secpolicy ;
   enum __anonenum_zvec_namecheck_75 zvec_namecheck ;
};
#line 75 "zfs-fuse/zfs_ioctl.c"
typedef struct zfs_ioc_vec zfs_ioc_vec_t;
#line 53 "lib/libzfscommon/include/sys/dmu.h"
struct blkptr;
#line 105 "lib/libzfscommon/include/sys/spa.h"
struct dva {
   uint64_t dva_word[2] ;
};
#line 105 "lib/libzfscommon/include/sys/spa.h"
typedef struct dva dva_t;
#line 112 "lib/libzfscommon/include/sys/spa.h"
struct zio_cksum {
   uint64_t zc_word[4] ;
};
#line 112 "lib/libzfscommon/include/sys/spa.h"
typedef struct zio_cksum zio_cksum_t;
#line 173 "lib/libzfscommon/include/sys/spa.h"
struct blkptr {
   dva_t blk_dva[3] ;
   uint64_t blk_prop ;
   uint64_t blk_pad[3] ;
   uint64_t blk_birth ;
   uint64_t blk_fill ;
   zio_cksum_t blk_cksum ;
};
#line 173 "lib/libzfscommon/include/sys/spa.h"
typedef struct blkptr blkptr_t;
#line 120 "lib/libzfscommon/include/sys/zil.h"
struct __anonstruct_lr_t_52 {
   uint64_t lrc_txtype ;
   uint64_t lrc_reclen ;
   uint64_t lrc_txg ;
   uint64_t lrc_seq ;
};
#line 120 "lib/libzfscommon/include/sys/zil.h"
typedef struct __anonstruct_lr_t_52 lr_t;
#line 127 "lib/libzfscommon/include/sys/zil.h"
struct __anonstruct_lr_create_t_53 {
   lr_t lr_common ;
   uint64_t lr_doid ;
   uint64_t lr_foid ;
   uint64_t lr_mode ;
   uint64_t lr_uid ;
   uint64_t lr_gid ;
   uint64_t lr_gen ;
   uint64_t lr_crtime[2] ;
   uint64_t lr_rdev ;
};
#line 127 "lib/libzfscommon/include/sys/zil.h"
typedef struct __anonstruct_lr_create_t_53 lr_create_t;
#line 141 "lib/libzfscommon/include/sys/zil.h"
struct __anonstruct_lr_remove_t_54 {
   lr_t lr_common ;
   uint64_t lr_doid ;
};
#line 141 "lib/libzfscommon/include/sys/zil.h"
typedef struct __anonstruct_lr_remove_t_54 lr_remove_t;
#line 147 "lib/libzfscommon/include/sys/zil.h"
struct __anonstruct_lr_link_t_55 {
   lr_t lr_common ;
   uint64_t lr_doid ;
   uint64_t lr_link_obj ;
};
#line 147 "lib/libzfscommon/include/sys/zil.h"
typedef struct __anonstruct_lr_link_t_55 lr_link_t;
#line 154 "lib/libzfscommon/include/sys/zil.h"
struct __anonstruct_lr_rename_t_56 {
   lr_t lr_common ;
   uint64_t lr_sdoid ;
   uint64_t lr_tdoid ;
};
#line 154 "lib/libzfscommon/include/sys/zil.h"
typedef struct __anonstruct_lr_rename_t_56 lr_rename_t;
#line 161 "lib/libzfscommon/include/sys/zil.h"
struct __anonstruct_lr_write_t_57 {
   lr_t lr_common ;
   uint64_t lr_foid ;
   uint64_t lr_offset ;
   uint64_t lr_length ;
   uint64_t lr_blkoff ;
   blkptr_t lr_blkptr ;
};
#line 161 "lib/libzfscommon/include/sys/zil.h"
typedef struct __anonstruct_lr_write_t_57 lr_write_t;
#line 171 "lib/libzfscommon/include/sys/zil.h"
struct __anonstruct_lr_truncate_t_58 {
   lr_t lr_common ;
   uint64_t lr_foid ;
   uint64_t lr_offset ;
   uint64_t lr_length ;
};
#line 171 "lib/libzfscommon/include/sys/zil.h"
typedef struct __anonstruct_lr_truncate_t_58 lr_truncate_t;
#line 178 "lib/libzfscommon/include/sys/zil.h"
struct __anonstruct_lr_setattr_t_59 {
   lr_t lr_common ;
   uint64_t lr_foid ;
   uint64_t lr_mask ;
   uint64_t lr_mode ;
   uint64_t lr_uid ;
   uint64_t lr_gid ;
   uint64_t lr_size ;
   uint64_t lr_atime[2] ;
   uint64_t lr_mtime[2] ;
};
#line 178 "lib/libzfscommon/include/sys/zil.h"
typedef struct __anonstruct_lr_setattr_t_59 lr_setattr_t;
#line 190 "lib/libzfscommon/include/sys/zil.h"
struct __anonstruct_lr_acl_t_60 {
   lr_t lr_common ;
   uint64_t lr_foid ;
   uint64_t lr_aclcnt ;
};
#line 190 "lib/libzfscommon/include/sys/zil.h"
typedef struct __anonstruct_lr_acl_t_60 lr_acl_t;
#line 204
enum __anonenum_itx_wr_state_t_61 {
    WR_INDIRECT = 0,
    WR_COPIED = 1,
    WR_NEED_COPY = 2
} ;
#line 204 "lib/libzfscommon/include/sys/zil.h"
typedef enum __anonenum_itx_wr_state_t_61 itx_wr_state_t;
#line 211 "lib/libzfscommon/include/sys/zil.h"
struct itx {
   list_node_t itx_node ;
   void *itx_private ;
   itx_wr_state_t itx_wr_state ;
   uint8_t itx_sync ;
   lr_t itx_lr ;
};
#line 211 "lib/libzfscommon/include/sys/zil.h"
typedef struct itx itx_t;
#line 149 "/usr/include/bits/types.h"
typedef __u_quad_t __rlim64_t;
#line 127 "lib/libsolkerncompat/include/sys/uio.h"
enum uio_rw {
    UIO_READ = 0,
    UIO_WRITE = 1
} ;
#line 132 "/usr/include/bits/resource.h"
typedef __rlim64_t rlim64_t;
#line 34 "lib/libsolkerncompat/include/sys/fcntl.h"
typedef struct flock64 flock64_t;
#line 236 "lib/libzfscommon/include/sys/zil.h"
typedef int zil_replay_func_t();
#line 129 "/usr/include/stdint.h"
typedef unsigned int uintptr_t;
#line 121 "lib/libavl/include/sys/avl.h"
typedef uintptr_t avl_index_t;
#line 225 "lib/libzfscommon/include/sys/zil.h"
struct rl;
#line 39 "lib/libzfscommon/include/sys/zfs_rlock.h"
enum __anonenum_rl_type_t_63 {
    RL_READER = 0,
    RL_WRITER = 1,
    RL_APPEND = 2
} ;
#line 39 "lib/libzfscommon/include/sys/zfs_rlock.h"
typedef enum __anonenum_rl_type_t_63 rl_type_t;
#line 45 "lib/libzfscommon/include/sys/zfs_rlock.h"
struct rl {
   znode_t *r_zp ;
   avl_node_t r_node ;
   uint64_t r_off ;
   uint64_t r_len ;
   uint_t r_cnt ;
   rl_type_t r_type ;
   kcondvar_t r_wr_cv ;
   kcondvar_t r_rd_cv ;
   uint8_t r_proxy ;
   uint8_t r_write_wanted ;
   uint8_t r_read_wanted ;
};
#line 45 "lib/libzfscommon/include/sys/zfs_rlock.h"
typedef struct rl rl_t;
#line 50 "lib/libsolkerncompat/include/sys/vnode.h"
struct fs_operation_def {
   char *name ;
   int (*func)() ;
};
#line 50 "lib/libsolkerncompat/include/sys/vnode.h"
typedef struct fs_operation_def fs_operation_def_t;
#line 63 "lib/libsolkerncompat/include/sys/pathname.h"
typedef struct pathname pathname_t;
#line 52 "lib/libzfscommon/include/sys/dmu.h"
struct zio;
#line 56
struct dsl_pool;
#line 66
struct dsl_dir;
#line 262 "lib/libzfscommon/include/sys/fs/zfs.h"
enum zio_type {
    ZIO_TYPE_NULL = 0,
    ZIO_TYPE_READ = 1,
    ZIO_TYPE_WRITE = 2,
    ZIO_TYPE_FREE = 3,
    ZIO_TYPE_CLAIM = 4,
    ZIO_TYPE_IOCTL = 5,
    ZIO_TYPES = 6
} ;
#line 48 "lib/libzfscommon/include/sys/txg.h"
struct tx_cpu;
#line 48 "lib/libzfscommon/include/sys/txg.h"
typedef struct tx_cpu tx_cpu_t;
#line 55 "lib/libzfscommon/include/sys/txg.h"
struct txg_node {
   struct txg_node *tn_next[4] ;
   uint8_t tn_member[4] ;
};
#line 55 "lib/libzfscommon/include/sys/txg.h"
typedef struct txg_node txg_node_t;
#line 60 "lib/libzfscommon/include/sys/txg.h"
struct txg_list {
   kmutex_t tl_lock ;
   size_t tl_offset ;
   txg_node_t *tl_head[4] ;
};
#line 60 "lib/libzfscommon/include/sys/txg.h"
typedef struct txg_list txg_list_t;
#line 190 "lib/libsolkerncompat/include/sys/dkio.h"
struct dk_callback {
   void (*dkc_callback)(void *dkc_cookie , int error ) ;
   void *dkc_cookie ;
};
#line 42 "lib/libzfscommon/include/sys/zio_impl.h"
enum zio_stage {
    ZIO_STAGE_OPEN = 0,
    ZIO_STAGE_WAIT_CHILDREN_READY = 1,
    ZIO_STAGE_WRITE_COMPRESS = 2,
    ZIO_STAGE_CHECKSUM_GENERATE = 3,
    ZIO_STAGE_GANG_PIPELINE = 4,
    ZIO_STAGE_GET_GANG_HEADER = 5,
    ZIO_STAGE_REWRITE_GANG_MEMBERS = 6,
    ZIO_STAGE_FREE_GANG_MEMBERS = 7,
    ZIO_STAGE_CLAIM_GANG_MEMBERS = 8,
    ZIO_STAGE_DVA_ALLOCATE = 9,
    ZIO_STAGE_DVA_FREE = 10,
    ZIO_STAGE_DVA_CLAIM = 11,
    ZIO_STAGE_GANG_CHECKSUM_GENERATE = 12,
    ZIO_STAGE_READY = 13,
    ZIO_STAGE_VDEV_IO_START = 14,
    ZIO_STAGE_VDEV_IO_DONE = 15,
    ZIO_STAGE_VDEV_IO_ASSESS = 16,
    ZIO_STAGE_WAIT_CHILDREN_DONE = 17,
    ZIO_STAGE_CHECKSUM_VERIFY = 18,
    ZIO_STAGE_READ_GANG_MEMBERS = 19,
    ZIO_STAGE_READ_DECOMPRESS = 20,
    ZIO_STAGE_DONE = 21
} ;
#line 190
struct zio_transform;
#line 190 "lib/libzfscommon/include/sys/zio_impl.h"
typedef struct zio_transform zio_transform_t;
#line 191 "lib/libzfscommon/include/sys/zio_impl.h"
struct zio_transform {
   void *zt_data ;
   uint64_t zt_size ;
   uint64_t zt_bufsize ;
   zio_transform_t *zt_next ;
};
#line 72 "lib/libzfscommon/include/sys/zio.h"
enum zio_checksum {
    ZIO_CHECKSUM_INHERIT = 0,
    ZIO_CHECKSUM_ON = 1,
    ZIO_CHECKSUM_OFF = 2,
    ZIO_CHECKSUM_LABEL = 3,
    ZIO_CHECKSUM_GANG_HEADER = 4,
    ZIO_CHECKSUM_ZILOG = 5,
    ZIO_CHECKSUM_FLETCHER_2 = 6,
    ZIO_CHECKSUM_FLETCHER_4 = 7,
    ZIO_CHECKSUM_SHA256 = 8,
    ZIO_CHECKSUM_FUNCTIONS = 9
} ;
#line 88
enum zio_compress {
    ZIO_COMPRESS_INHERIT = 0,
    ZIO_COMPRESS_ON = 1,
    ZIO_COMPRESS_OFF = 2,
    ZIO_COMPRESS_LZJB = 3,
    ZIO_COMPRESS_EMPTY = 4,
    ZIO_COMPRESS_FUNCTIONS = 5
} ;
#line 157 "lib/libzfscommon/include/sys/zio.h"
typedef struct zio zio_t;
#line 158 "lib/libzfscommon/include/sys/zio.h"
typedef void zio_done_func_t(zio_t *zio );
#line 190 "lib/libzfscommon/include/sys/zio.h"
struct zio {
   zio_t *io_parent ;
   zio_t *io_root ;
   spa_t *io_spa ;
   zbookmark_t io_bookmark ;
   enum zio_checksum io_checksum ;
   enum zio_compress io_compress ;
   int io_ndvas ;
   uint64_t io_txg ;
   blkptr_t *io_bp ;
   blkptr_t io_bp_copy ;
   zio_t *io_child ;
   zio_t *io_sibling_prev ;
   zio_t *io_sibling_next ;
   zio_transform_t *io_transform_stack ;
   zio_t *io_logical ;
   zio_done_func_t *io_done ;
   void *io_private ;
   blkptr_t io_bp_orig ;
   void *io_data ;
   uint64_t io_size ;
   vdev_t *io_vd ;
   void *io_vsd ;
   uint64_t io_offset ;
   uint64_t io_deadline ;
   uint64_t io_timestamp ;
   avl_node_t io_offset_node ;
   avl_node_t io_deadline_node ;
   avl_tree_t *io_vdev_tree ;
   zio_t *io_delegate_list ;
   zio_t *io_delegate_next ;
   int io_flags ;
   enum zio_type io_type ;
   enum zio_stage io_stage ;
   uint8_t io_stalled ;
   uint8_t io_priority ;
   struct dk_callback io_dk_callback ;
   int io_cmd ;
   int io_retries ;
   int io_error ;
   uint32_t io_numerrors ;
   uint32_t io_pipeline ;
   uint32_t io_async_stages ;
   uint64_t io_children_notready ;
   uint64_t io_children_notdone ;
   void *io_waiter ;
   kmutex_t io_lock ;
   kcondvar_t io_cv ;
   uint64_t io_ena ;
};
#line 237 "lib/libzfscommon/include/sys/zil.h"
typedef int zil_get_data_t(void *arg , lr_write_t *lr , char *dbuf , zio_t *zio );
#line 39 "lib/libzfscommon/include/sys/txg_impl.h"
struct tx_cpu {
   kmutex_t tc_lock ;
   kcondvar_t tc_cv[4] ;
   uint64_t tc_count[4] ;
   char tc_pad[16] ;
};
#line 46 "lib/libzfscommon/include/sys/txg_impl.h"
struct tx_state {
   tx_cpu_t *tx_cpu ;
   kmutex_t tx_sync_lock ;
   krwlock_t tx_suspend ;
   uint64_t tx_open_txg ;
   uint64_t tx_quiesced_txg ;
   uint64_t tx_syncing_txg ;
   uint64_t tx_synced_txg ;
   uint64_t tx_sync_txg_waiting ;
   uint64_t tx_quiesce_txg_waiting ;
   kcondvar_t tx_sync_more_cv ;
   kcondvar_t tx_sync_done_cv ;
   kcondvar_t tx_quiesce_more_cv ;
   kcondvar_t tx_quiesce_done_cv ;
   kcondvar_t tx_timeout_exit_cv ;
   kcondvar_t tx_exit_cv ;
   uint8_t tx_threads ;
   uint8_t tx_exiting ;
   kthread_t *tx_sync_thread ;
   kthread_t *tx_quiesce_thread ;
   kthread_t *tx_timelimit_thread ;
};
#line 46 "lib/libzfscommon/include/sys/txg_impl.h"
typedef struct tx_state tx_state_t;
#line 43 "lib/libzfscommon/include/sys/dsl_pool.h"
struct dsl_pool {
   spa_t *dp_spa ;
   struct objset *dp_meta_objset ;
   struct dsl_dir *dp_root_dir ;
   struct dsl_dir *dp_mos_dir ;
   uint64_t dp_root_dir_obj ;
   blkptr_t dp_meta_rootbp ;
   list_t dp_synced_objsets ;
   tx_state_t dp_tx ;
   txg_list_t dp_dirty_datasets ;
   txg_list_t dp_dirty_dirs ;
   txg_list_t dp_sync_tasks ;
   krwlock_t dp_config_rwlock ;
};
#line 57 "/usr/include/sys/types.h"
typedef __ino64_t ino64_t;
#line 95 "/usr/include/sys/types.h"
typedef __off64_t off64_t;
#line 354 "lib/libsolkerncompat/include/sys/vnode.h"
typedef struct vnodeops vnodeops_t;
#line 70 "lib/libsolkerncompat/include/sys/dirent.h"
struct dirent64 {
   ino64_t d_ino ;
   off64_t d_off ;
   unsigned short d_reclen ;
   char d_name[1] ;
};
#line 70 "lib/libsolkerncompat/include/sys/dirent.h"
typedef struct dirent64 dirent64_t;
#line 548 "lib/libzfscommon/include/sys/dmu.h"
typedef void dmu_sync_cb_t(dmu_buf_t *db , void *arg );
#line 225 "lib/libzfscommon/include/sys/zil.h"
struct __anonstruct_zgd_t_65 {
   zilog_t *zgd_zilog ;
   blkptr_t *zgd_bp ;
   struct rl *zgd_rl ;
};
#line 225 "lib/libzfscommon/include/sys/zil.h"
typedef struct __anonstruct_zgd_t_65 zgd_t;
#line 97 "lib/libzfscommon/include/sys/zfs_vfsops.h"
struct zfid_short {
   uint16_t zf_len ;
   uint8_t zf_object[6] ;
   uint8_t zf_gen[4] ;
};
#line 97 "lib/libzfscommon/include/sys/zfs_vfsops.h"
typedef struct zfid_short zfid_short_t;
#line 103 "lib/libzfscommon/include/sys/zfs_vfsops.h"
struct zfid_long {
   zfid_short_t z_fid ;
   uint8_t zf_setid[6] ;
   uint8_t zf_setgen[4] ;
};
#line 103 "lib/libzfscommon/include/sys/zfs_vfsops.h"
typedef struct zfid_long zfid_long_t;
#line 33 "lib/libsolkerncompat/include/vm/page.h"
typedef struct page page_t;
#line 62 "lib/libsolkerncompat/include/sys/flock.h"
typedef struct flk_callback flk_callback_t;
#line 2245 "zfs-fuse/zfs_vnops.c"
struct zfs_zlock {
   krwlock_t *zl_rwlock ;
   znode_t *zl_znode ;
   struct zfs_zlock *zl_next ;
};
#line 2245 "zfs-fuse/zfs_vnops.c"
typedef struct zfs_zlock zfs_zlock_t;
#line 160 "/usr/include/bits/types.h"
typedef int __clockid_t;
#line 92 "/usr/include/time.h"
typedef __clockid_t clockid_t;
#line 31 "lib/libsolkerncompat/include/sys/vmem.h"
struct vmem;
#line 32 "lib/libsolkerncompat/include/sys/vmem.h"
typedef struct vmem vmem_t;
#line 61 "lib/libumem/include/umem.h"
struct umem_cache;
#line 63 "lib/libumem/include/umem.h"
typedef struct umem_cache umem_cache_t;
#line 64 "lib/libumem/include/umem.h"
typedef int umem_constructor_t(void * , void * , int  );
#line 65 "lib/libumem/include/umem.h"
typedef void umem_destructor_t(void * , void * );
#line 66 "lib/libumem/include/umem.h"
typedef void umem_reclaim_t(void * );
#line 46 "lib/libsolkerncompat/include/sys/kmem.h"
typedef umem_cache_t kmem_cache_t;
#line 177 "lib/libzfscommon/include/sys/dmu.h"
typedef void dmu_buf_evict_func_t(struct dmu_buf *db , void *user_ptr );
#line 191 "/usr/include/bits/types.h"
typedef int __intptr_t;
#line 35 "zfs-fuse/fuse_listener.h"
struct file_info {
   vnode_t *vp ;
   int flags ;
};
#line 35 "zfs-fuse/fuse_listener.h"
typedef struct file_info file_info_t;
#line 44 "zfs-fuse/fuse_listener.c"
struct fuse_fs_info {
   int fd ;
   size_t bufsize ;
   struct fuse_chan *ch ;
   struct fuse_session *se ;
   int mntlen ;
};
#line 44 "zfs-fuse/fuse_listener.c"
typedef struct fuse_fs_info fuse_fs_info_t;
#line 215 "/usr/include/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 230 "/usr/include/bits/socket.h"
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
#line 87 "/usr/include/sys/socket.h"
struct sockaddr_un;
#line 30 "/usr/include/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 248 "/usr/include/sys/types.h"
typedef __fsblkcnt64_t fsblkcnt_t;
#line 252 "/usr/include/sys/types.h"
typedef __fsfilcnt64_t fsfilcnt_t;
#line 54 "lib/libsolkerncompat/include/sys/statvfs.h"
struct statvfs {
   unsigned long f_bsize ;
   unsigned long f_frsize ;
   fsblkcnt_t f_blocks ;
   fsblkcnt_t f_bfree ;
   fsblkcnt_t f_bavail ;
   fsfilcnt_t f_files ;
   fsfilcnt_t f_ffree ;
   fsfilcnt_t f_favail ;
   unsigned long f_fsid ;
   char f_basetype[16] ;
   unsigned long f_flag ;
   unsigned long f_namemax ;
   char f_fstr[32] ;
   unsigned long f_filler[16] ;
};
#line 67 "/usr/local/include/fuse/fuse_lowlevel.h"
struct fuse_entry_param {
   fuse_ino_t ino ;
   unsigned long generation ;
   struct stat attr ;
   double attr_timeout ;
   double entry_timeout ;
};
#line 92 "/usr/local/include/fuse/fuse_lowlevel.h"
struct fuse_ctx {
   uid_t uid ;
   gid_t gid ;
   pid_t pid ;
};
#line 32 "lib/libsolkerncompat/include/sys/cred_impl.h"
struct cred {
   uid_t cr_uid ;
   gid_t cr_gid ;
};
#line 391 "zfs-fuse/zfs_operations.c"
union __anonunion_entry_63 {
   char buf[((((unsigned int )(& ((dirent64_t *)0)->d_name[0]) + 1U) + 256U) + 7U) & 4294967288U] ;
   struct dirent64 dirent ;
};
#line 1 "main.o"
#pragma merger(0,"/tmp/cil-AFpRtKdS.i","-pipe,-Wall,-Werror,-std=c99,-Wno-unused,-Wno-missing-braces,-Wno-parentheses,-Wno-uninitialized,-fno-strict-aliasing,-ggdb,-O2")
#line 740 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 59 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n )  __attribute__((__nonnull__(1))) ;
#line 216 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int sigemptyset(sigset_t *__set )  __attribute__((__nonnull__(1))) ;
#line 260
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
#line 32 "zfs-fuse/util.h"
int do_init(void) ;
#line 33
void do_exit(void) ;
#line 42 "zfs-fuse/fuse_listener.h"
boolean_t exit_fuse_listener ;
#line 45
int zfsfuse_listener_start(void) ;
#line 32 "zfs-fuse/main.c"
static void exit_handler(int sig ) 
{ 

  {
#line 34
  exit_fuse_listener = 1;
#line 35
  return;
}
}
#line 37 "zfs-fuse/main.c"
static int set_signal_handler(int sig , void (*handler)(int  ) ) 
{ struct sigaction sa ;
  int tmp ;

  {
#line 41
  memset((void *)(& sa), 0, sizeof(struct sigaction ));
#line 43
  sa.__sigaction_handler.sa_handler = handler;
#line 44
  sigemptyset(& sa.sa_mask);
#line 45
  sa.sa_flags = 0;
#line 47
  tmp = sigaction(sig, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
#line 47
  if (tmp == -1) {
#line 48
    perror("sigaction");
#line 49
    return (-1);
  }
#line 52
  return (0);
}
}
#line 55 "zfs-fuse/main.c"
int main(int argc , char **argv ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int ret ;
  int tmp___4 ;

  {
#line 57
  tmp = do_init();
#line 57
  if (tmp != 0) {
#line 58
    do_exit();
#line 59
    return (1);
  }
#line 62
  tmp___0 = set_signal_handler(1, & exit_handler);
#line 62
  if (tmp___0 != 0) {
#line 66
    do_exit();
#line 67
    return (2);
  } else {
#line 62
    tmp___1 = set_signal_handler(2, & exit_handler);
#line 62
    if (tmp___1 != 0) {
#line 66
      do_exit();
#line 67
      return (2);
    } else {
#line 62
      tmp___2 = set_signal_handler(15, & exit_handler);
#line 62
      if (tmp___2 != 0) {
#line 66
        do_exit();
#line 67
        return (2);
      } else {
#line 62
        tmp___3 = set_signal_handler(13, (void (*)(int  ))1);
#line 62
        if (tmp___3 != 0) {
#line 66
          do_exit();
#line 67
          return (2);
        }
      }
    }
  }
#line 70
  tmp___4 = zfsfuse_listener_start();
#line 70
  ret = tmp___4;
#line 72
  do_exit();
#line 74
  return (ret);
}
}
#line 1 "cmd_listener.o"
#pragma merger(0,"/tmp/cil-kqxsQJOd.i","-pipe,-Wall,-Werror,-std=c99,-Wno-unused,-Wno-missing-braces,-Wno-parentheses,-Wno-uninitialized,-fno-strict-aliasing,-ggdb,-O2")
#line 70 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
#line 144 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 321
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 584 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 597
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 622
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 209 "/usr/include/sys/socket.h"
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 48 "/usr/include/sys/poll.h"
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
#line 38 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 305 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 318
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 32 "zfs-fuse/zfs_ioctl.h"
int zfsdev_ioctl(dev_t dev , int cmd , intptr_t arg , int flag , cred_t *cr , int *rvalp ) ;
#line 33 "zfs-fuse/zfsfuse_socket.h"
int cur_fd ;
#line 38
int zfsfuse_socket_read_loop(int fd , void *buf , int bytes ) ;
#line 39
int zfsfuse_socket_ioctl_write(int fd , int ret ) ;
#line 34 "zfs-fuse/util.h"
int do_mount(char *spec , char *dir , int mflag , char *opt ) ;
#line 42 "zfs-fuse/cmd_listener.c"
boolean_t exit_listener  =    0;
#line 44 "zfs-fuse/cmd_listener.c"
int cmd_ioctl_req(int sock , zfsfuse_cmd_t *cmd ) 
{ dev_t dev ;
  int ioctl_ret ;
  int tmp ;
  int tmp___0 ;

  {
#line 46
  dev = (dev_t )0;
#line 48
  cur_fd = sock;
#line 49
  tmp = zfsdev_ioctl(dev, cmd->cmd_u.ioctl_req.cmd, (int )((unsigned int )cmd->cmd_u.ioctl_req.arg),
                     0, (cred_t *)((void *)0), (int *)((void *)0));
#line 49
  ioctl_ret = tmp;
#line 50
  cur_fd = -1;
#line 52
  tmp___0 = zfsfuse_socket_ioctl_write(sock, ioctl_ret);
#line 52
  return (tmp___0);
}
}
#line 55 "zfs-fuse/cmd_listener.c"
int cmd_mount_req(int sock , zfsfuse_cmd_t *cmd ) 
{ uint32_t speclen ;
  uint32_t dirlen ;
  int32_t optlen ;
  char *spec ;
  void *tmp ;
  char *dir ;
  void *tmp___0 ;
  char *opt ;
  void *tmp___1 ;
  boolean_t error ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  uint32_t ret ;
  int tmp___6 ;
  ssize_t tmp___7 ;
  int tmp___8 ;

  {
#line 57
  speclen = cmd->cmd_u.mount_req.speclen;
#line 58
  dirlen = cmd->cmd_u.mount_req.dirlen;
#line 59
  optlen = cmd->cmd_u.mount_req.optlen;
#line 61
  tmp = malloc(speclen + 1U);
#line 61
  spec = (char *)tmp;
#line 62
  tmp___0 = malloc(dirlen + 1U);
#line 62
  dir = (char *)tmp___0;
#line 63
  tmp___1 = malloc((unsigned int )(optlen + 1));
#line 63
  opt = (char *)tmp___1;
#line 65
  if ((unsigned int )spec == (unsigned int )((void *)0)) {
#line 65
    tmp___2 = 1;
  } else {
#line 65
    if ((unsigned int )dir == (unsigned int )((void *)0)) {
#line 65
      tmp___2 = 1;
    } else {
#line 65
      if ((unsigned int )opt == (unsigned int )((void *)0)) {
#line 65
        tmp___2 = 1;
      } else {
#line 65
        tmp___2 = 0;
      }
    }
  }
#line 65
  error = (boolean_t )tmp___2;
#line 67
  if (! error) {
#line 67
    tmp___3 = zfsfuse_socket_read_loop(sock, (void *)spec, (int )speclen);
#line 67
    if (tmp___3 == -1) {
#line 68
      error = 1;
    }
  }
#line 69
  if (! error) {
#line 69
    tmp___4 = zfsfuse_socket_read_loop(sock, (void *)dir, (int )dirlen);
#line 69
    if (tmp___4 == -1) {
#line 70
      error = 1;
    }
  }
#line 71
  if (! error) {
#line 71
    tmp___5 = zfsfuse_socket_read_loop(sock, (void *)opt, optlen);
#line 71
    if (tmp___5 == -1) {
#line 72
      error = 1;
    }
  }
#line 73
  if (! error) {
#line 74
    *(spec + speclen) = (char )'\000';
#line 75
    *(dir + dirlen) = (char )'\000';
#line 76
    *(opt + optlen) = (char )'\000';
#line 80
    tmp___6 = do_mount(spec, dir, cmd->cmd_u.mount_req.mflag, opt);
#line 80
    ret = (uint32_t )tmp___6;
#line 81
    tmp___7 = write(sock, (void const   *)(& ret), sizeof(uint32_t ));
#line 81
    if ((unsigned int )tmp___7 != sizeof(uint32_t )) {
#line 82
      error = 1;
    }
  }
#line 84
  if ((unsigned int )opt != (unsigned int )((void *)0)) {
#line 84
    free((void *)opt);
  }
#line 85
  if ((unsigned int )dir != (unsigned int )((void *)0)) {
#line 85
    free((void *)dir);
  }
#line 86
  if ((unsigned int )spec != (unsigned int )((void *)0)) {
#line 86
    free((void *)spec);
  }
#line 88
  if (error) {
#line 88
    tmp___8 = -1;
  } else {
#line 88
    tmp___8 = 0;
  }
#line 88
  return (tmp___8);
}
}
#line 91 "zfs-fuse/cmd_listener.c"
void *listener_loop(void *arg ) 
{ int *ioctl_fd___0 ;
  struct pollfd fds___0[100] ;
  int nfds___0 ;
  int ret ;
  int tmp ;
  int *tmp___0 ;
  int oldfds ;
  int i ;
  short rev ;
  int sock ;
  int tmp___1 ;
  zfsfuse_cmd_t cmd ;
  int sock___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int write_ptr ;
  int read_ptr ;

  {
#line 93
  ioctl_fd___0 = (int *)arg;
#line 97
  fds___0[0].fd = *ioctl_fd___0;
#line 98
  fds___0[0].events = (short)1;
#line 100
  nfds___0 = 1;
#line 102
  while (! exit_listener) {
#line 104
    tmp = poll(fds___0, (unsigned long )nfds___0, 1000);
#line 104
    ret = tmp;
#line 105
    if (ret == 0) {
#line 106
      continue;
    } else {
#line 105
      if (ret == -1) {
#line 105
        tmp___0 = __errno_location();
#line 105
        if (*tmp___0 == 4) {
#line 106
          continue;
        }
      }
    }
#line 108
    if (ret == -1) {
#line 109
      perror("poll");
#line 110
      break;
    }
#line 113
    oldfds = nfds___0;
#line 115
    i = 0;
#line 115
    while (i < oldfds) {
#line 116
      rev = fds___0[i].revents;
#line 118
      if ((int )rev == 0) {
        goto __Cont;
      }
#line 121
      fds___0[i].revents = (short)0;
#line 123
      if (! (((int )rev & 32) == 0)) {
#line 123
        __assert_fail("(rev & 0x020) == 0", "zfs-fuse/cmd_listener.c", 123U, "listener_loop");
      }
#line 125
      if (! ((int )rev & 1)) {
#line 125
        if (! ((int )rev & 8)) {
#line 125
          if (! ((int )rev & 16)) {
            goto __Cont;
          }
        }
      }
#line 128
      if (i == 0) {
#line 131
        tmp___1 = accept(*ioctl_fd___0, (struct sockaddr * __restrict  )((void *)0),
                         (socklen_t * __restrict  )((void *)0));
#line 131
        sock = tmp___1;
#line 132
        if (sock == -1) {
#line 133
          perror("accept");
          goto __Cont;
        }
#line 137
        if (nfds___0 == 100) {
#line 138
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Warning: connection limit reached (%i), closing connection.\n",
                  100);
#line 139
          close(sock);
          goto __Cont;
        }
#line 143
        fds___0[nfds___0].fd = sock;
#line 144
        fds___0[nfds___0].events = (short)1;
#line 145
        fds___0[nfds___0].revents = (short)0;
#line 146
        nfds___0 ++;
      } else {
#line 151
        sock___0 = fds___0[i].fd;
#line 152
        tmp___2 = zfsfuse_socket_read_loop(sock___0, (void *)(& cmd), (int )sizeof(zfsfuse_cmd_t ));
#line 152
        if (tmp___2 == -1) {
#line 153
          close(sock___0);
#line 154
          fds___0[i].fd = -1;
          goto __Cont;
        }
#line 158
        switch ((int )cmd.cmd_type) {
        case 0: 
#line 160
        tmp___3 = cmd_ioctl_req(sock___0, & cmd);
#line 160
        if (tmp___3 != 0) {
#line 161
          close(sock___0);
#line 162
          fds___0[i].fd = -1;
          goto __Cont;
        }
#line 165
        break;
        case 4: 
#line 167
        tmp___4 = cmd_mount_req(sock___0, & cmd);
#line 167
        if (tmp___4 != 0) {
#line 168
          close(sock___0);
#line 169
          fds___0[i].fd = -1;
          goto __Cont;
        }
#line 172
        break;
        default: 
#line 174
        abort();
#line 175
        break;
        }
      }
      __Cont: /* CIL Label */ 
#line 115
      i ++;
    }
#line 181
    write_ptr = 0;
#line 182
    read_ptr = 0;
#line 182
    while (read_ptr < nfds___0) {
#line 183
      if (fds___0[read_ptr].fd == -1) {
        goto __Cont___0;
      }
#line 185
      if (read_ptr != write_ptr) {
#line 186
        fds___0[write_ptr] = fds___0[read_ptr];
      }
#line 187
      write_ptr ++;
      __Cont___0: /* CIL Label */ 
#line 182
      read_ptr ++;
    }
#line 189
    nfds___0 = write_ptr;
  }
#line 192
  return ((void *)0);
}
}
#line 1 "ptrace.o"
#pragma merger(0,"/tmp/cil-JvVXTtj9.i","-pipe,-Wall,-Werror,-std=c99,-Wno-unused,-Wno-missing-braces,-Wno-parentheses,-Wno-uninitialized,-fno-strict-aliasing,-ggdb,-O2")
#line 206 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 211
extern int fflush(FILE *__stream ) ;
#line 252
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 329
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 335
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf )  __asm__("__xstat64") __attribute__((__nonnull__(2,3))) ;
#line 363
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 363 "/usr/include/sys/stat.h"
__inline static int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
#line 366
  tmp = __xstat(3, (char const   *)__path, (struct stat *)__statbuf);
#line 366
  return (tmp);
}
}
#line 549 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 744
extern  __attribute__((__nothrow__)) int unlink(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 557 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int pthread_key_create(pthread_key_t *__key ,
                                                            void (*__destr_function)(void * ) ) ;
#line 564
extern  __attribute__((__nothrow__)) int pthread_setspecific(pthread_key_t __key ,
                                                             void const   *__pointer ) ;
#line 568
extern  __attribute__((__nothrow__)) void *pthread_getspecific(pthread_key_t __key ) ;
#line 580
extern int pthread_once(pthread_once_t *__once_control , void (*__init_routine)(void) ) ;
#line 131 "lib/libsolkerncompat/include/sys/atomic.h"
extern uint32_t atomic_inc_32_nv(uint32_t volatile   * ) ;
#line 73 "zfs-fuse/ptrace.c"
static void gnu_ptrace_close(void *arg )  __attribute__((__no_instrument_function__)) ;
#line 73 "zfs-fuse/ptrace.c"
static void gnu_ptrace_close(void *arg ) 
{ 

  {
#line 77
  fprintf((FILE * __restrict  )((FILE *)arg), (char const   * __restrict  )"EXIT\n");
#line 78
  fclose((FILE *)arg);
#line 80
  return;
}
}
#line 83 "zfs-fuse/ptrace.c"
static pthread_key_t key  ;
#line 85
static void gnu_ptrace_process_init(void)  __attribute__((__no_instrument_function__)) ;
#line 85 "zfs-fuse/ptrace.c"
static void gnu_ptrace_process_init(void) 
{ 

  {
#line 90
  pthread_key_create(& key, & gnu_ptrace_close);
#line 91
  return;
}
}
#line 98
FILE *gnu_ptrace_thread_init(void)  __attribute__((__no_instrument_function__)) ;
#line 98 "zfs-fuse/ptrace.c"
static pthread_once_t key_once  =    0;
#line 99 "zfs-fuse/ptrace.c"
static unsigned int volatile   thread_n  =    (uint32_t volatile   )0;
#line 94
FILE *gnu_ptrace_thread_init(void)  __attribute__((__no_instrument_function__)) ;
#line 94 "zfs-fuse/ptrace.c"
FILE *gnu_ptrace_thread_init(void) 
{ struct stat sta ;
  int tmp ;
  char fname[100] ;
  uint32_t tmp___0 ;
  __pid_t tmp___1 ;
  FILE *ret ;
  FILE *tmp___2 ;
  void *tmp___3 ;

  {
#line 104
  tmp = stat((char const   * __restrict  )"TRACE", (struct stat * __restrict  )(& sta));
#line 104
  if (tmp != 0) {
#line 106
    return ((FILE *)((void *)0));
  }
#line 110
  tmp___0 = atomic_inc_32_nv(& thread_n);
#line 110
  tmp___1 = getpid();
#line 110
  sprintf((char * __restrict  )(fname), (char const   * __restrict  )"trace/%u-TRACE.%u.unparsed",
          tmp___1, tmp___0);
#line 112
  unlink((char const   *)(fname));
#line 114
  tmp___2 = fopen((char const   * __restrict  )(fname), (char const   * __restrict  )"a");
#line 114
  ret = tmp___2;
#line 115
  if ((unsigned int )ret == (unsigned int )((void *)0)) {
#line 116
    return ((FILE *)((void *)0));
  }
#line 119
  pthread_once(& key_once, & gnu_ptrace_process_init);
#line 121
  tmp___3 = pthread_getspecific(key);
#line 121
  if ((unsigned int )tmp___3 == (unsigned int )((void *)0)) {
#line 122
    pthread_setspecific(key, (void const   *)ret);
  }
#line 124
  fprintf((FILE * __restrict  )ret, (char const   * __restrict  )"START\n");
#line 125
  fflush(ret);
#line 127
  return (ret);
}
}
#line 135
void gnu_ptrace(entry_t e , void *p )  __attribute__((__no_instrument_function__)) ;
#line 135 "zfs-fuse/ptrace.c"
static  __thread  active_t active  =    0;
#line 136 "zfs-fuse/ptrace.c"
static  __thread  FILE *f  =    (FILE *)((void *)0);
#line 137 "zfs-fuse/ptrace.c"
static  __thread  int indent_level  =    0;
#line 131
void gnu_ptrace(entry_t e , void *p )  __attribute__((__no_instrument_function__)) ;
#line 131 "zfs-fuse/ptrace.c"
void gnu_ptrace(entry_t e , void *p ) 
{ int i ;
  int tmp ;

  {
#line 139
  switch ((int )active) {
  case 3: 
  case 1: 
#line 142
  return;
  case 2: 
#line 144
  active = 1;
#line 145
  break;
  case 0: 
#line 147
  active = 1;
#line 149
  f = gnu_ptrace_thread_init();
#line 149
  if ((unsigned int )f == (unsigned int )((void *)0)) {
#line 150
    return;
  }
#line 152
  break;
  }
#line 155
  switch ((int )e) {
  case 0: 
#line 157
  i = 0;
#line 157
  while (i < indent_level) {
#line 158
    if (i == indent_level - 1) {
#line 158
      tmp = '\\';
    } else {
#line 158
      tmp = '|';
    }
#line 158
    fprintf((FILE * __restrict  )f, (char const   * __restrict  )"    %c  ", tmp);
#line 157
    i ++;
  }
#line 160
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%p\n", p);
#line 162
  indent_level ++;
#line 163
  break;
  case 1: 
#line 166
  indent_level --;
  }
#line 169
  fflush(f);
#line 171
  active = 2;
#line 173
  return;
}
}
#line 177
void __cyg_profile_func_enter(void *this_fn , void *call_site )  __attribute__((__no_instrument_function__)) ;
#line 177 "zfs-fuse/ptrace.c"
void __cyg_profile_func_enter(void *this_fn , void *call_site ) 
{ 

  {
#line 181
  gnu_ptrace(0, this_fn);
#line 183
  return;
}
}
#line 186
void __cyg_profile_func_exit(void *this_fn , void *call_site )  __attribute__((__no_instrument_function__)) ;
#line 186 "zfs-fuse/ptrace.c"
void __cyg_profile_func_exit(void *this_fn , void *call_site ) 
{ 

  {
#line 190
  gnu_ptrace(1, this_fn);
#line 192
  return;
}
}
#line 1 "util.o"
#pragma merger(0,"/tmp/cil-Zd5xoMBB.i","-pipe,-Wall,-Werror,-std=c99,-Wno-unused,-Wno-missing-braces,-Wno-parentheses,-Wno-uninitialized,-fno-strict-aliasing,-ggdb,-O2")
#line 370 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  asprintf)(char ** __restrict  __ptr ,
                                                                             char const   * __restrict  __fmt 
                                                                             , ...) ;
#line 65 "lib/libsolkerncompat/include/sys/cred.h"
extern struct cred *kcred ;
#line 163 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int pthread_create(pthread_t * __restrict  __threadp ,
                                                        pthread_attr_t const   * __restrict  __attr ,
                                                        void *(*__start_routine)(void * ) ,
                                                        void * __restrict  __arg ) ;
#line 180
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 26 "lib/libsolkerncompat/include/libsolkerncompat.h"
extern void libsolkerncompat_init() ;
#line 27
extern void libsolkerncompat_exit() ;
#line 34 "zfs-fuse/zfs_ioctl.h"
int zfs_ioctl_init(void) ;
#line 35
int zfs_ioctl_fini(void) ;
#line 47 "lib/libumem/include/umem.h"
extern void *umem_zalloc(size_t  , int  ) ;
#line 48
extern void umem_free(void * , size_t  ) ;
#line 242 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 45 "lib/libsolkerncompat/include/sys/systm.h"
extern struct vnode *rootdir ;
#line 35 "zfs-fuse/zfsfuse_socket.h"
int zfsfuse_socket_create(void) ;
#line 36
void zfsfuse_socket_close(int fd ) ;
#line 218 "/usr/local/include/fuse/fuse_opt.h"
extern int fuse_opt_add_arg(struct fuse_args *args , char const   *arg ) ;
#line 242
extern void fuse_opt_free_args(struct fuse_args *args ) ;
#line 20 "/usr/local/include/fuse/fuse_common_compat.h"
extern int fuse_mount_compat25(char const   *mountpoint , struct fuse_args *args ) ;
#line 26
extern void fuse_unmount_compat22(char const   *mountpoint ) ;
#line 1135 "/usr/local/include/fuse/fuse_lowlevel.h"
extern void fuse_session_add_chan(struct fuse_session *se , struct fuse_chan *ch ) ;
#line 1176
extern void fuse_session_destroy(struct fuse_session *se ) ;
#line 61 "/usr/local/include/fuse/fuse_lowlevel_compat.h"
extern struct fuse_session *fuse_lowlevel_new_compat25(struct fuse_args *args , struct fuse_lowlevel_ops_compat25  const  *op ,
                                                       size_t op_size , void *userdata ) ;
#line 144
extern struct fuse_chan *fuse_kern_chan_new(int fd ) ;
#line 44 "zfs-fuse/fuse_listener.h"
int zfsfuse_listener_init(void) ;
#line 46
void zfsfuse_listener_exit(void) ;
#line 47
int zfsfuse_newfs(char *mntpoint , struct fuse_chan *ch ) ;
#line 31 "zfs-fuse/zfs_operations.h"
struct fuse_lowlevel_ops_compat25 zfs_operations ;
#line 86 "lib/libsolkerncompat/include/sys/vfs.h"
extern void vfs_hold(vfs_t * ) ;
#line 87
extern void vfs_rele(vfs_t * ) ;
#line 188
extern int fsop_mount(vfs_t * , vnode_t * , struct mounta * , cred_t * ) ;
#line 189
extern int fsop_unmount(vfs_t * , int  , cred_t * ) ;
#line 192
extern int fsop_sync(vfs_t * , short  , cred_t * ) ;
#line 35 "zfs-fuse/util.h"
int do_umount(vfs_t *vfs , boolean_t force ) ;
#line 46 "zfs-fuse/util.c"
int ioctl_fd  =    -1;
#line 48 "zfs-fuse/util.c"
boolean_t listener_thread_started  =    0;
#line 49 "zfs-fuse/util.c"
pthread_t listener_thread  ;
#line 51 "zfs-fuse/util.c"
int num_filesystems  ;
#line 54
vfsops_t *zfs_vfsops ;
#line 55
int zfs_vfsinit(int fstype , char *name ) ;
#line 57 "zfs-fuse/util.c"
int do_init(void) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 59
  libsolkerncompat_init();
#line 61
  zfs_vfsinit(1, (char *)((void *)0));
#line 63
  while (1) {
#line 63
    tmp = zfs_ioctl_init();
#line 63
    if (! (tmp == 0)) {
#line 63
      while (1) {
#line 63
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                "zfs-fuse/util.c", 63, "do_init", "zfs_ioctl_init() == 0");
#line 63
        abort();
#line 63
        break;
      }
    }
#line 63
    break;
  }
#line 65
  ioctl_fd = zfsfuse_socket_create();
#line 66
  if (ioctl_fd == -1) {
#line 67
    return (-1);
  }
#line 69
  tmp___0 = pthread_create((pthread_t * __restrict  )(& listener_thread), (pthread_attr_t const   * __restrict  )((void *)0),
                           & listener_loop, (void * __restrict  )((void *)(& ioctl_fd)));
#line 69
  if (tmp___0 != 0) {
#line 70
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error creating listener thread\n");
#line 71
    return (-1);
  }
#line 74
  listener_thread_started = 1;
#line 76
  tmp___1 = zfsfuse_listener_init();
#line 76
  return (tmp___1);
}
}
#line 79 "zfs-fuse/util.c"
void do_exit(void) 
{ int tmp ;
  int ret ;
  int tmp___0 ;

  {
#line 81
  if (listener_thread_started) {
#line 82
    exit_listener = 1;
#line 83
    tmp = pthread_join(listener_thread, (void **)((void *)0));
#line 83
    if (tmp != 0) {
#line 84
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error in pthread_join()\n");
    }
  }
#line 87
  zfsfuse_listener_exit();
#line 89
  if (ioctl_fd != -1) {
#line 90
    zfsfuse_socket_close(ioctl_fd);
  }
#line 92
  tmp___0 = zfs_ioctl_fini();
#line 92
  ret = tmp___0;
#line 93
  if (ret != 0) {
#line 94
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error %i in zfs_ioctl_fini()\n",
            ret);
  }
#line 96
  libsolkerncompat_exit();
#line 97
  return;
}
}
#line 105 "zfs-fuse/util.c"
int do_mount(char *spec , char *dir , int mflag , char *opt ) 
{ vfs_t *vfs ;
  void *tmp ;
  struct mounta uap ;
  size_t tmp___0 ;
  int ret ;
  char *fuse_opts ;
  int tmp___1 ;
  int tmp___2 ;
  struct fuse_args args ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int fd ;
  int tmp___7 ;
  int tmp___8 ;
  struct fuse_session *se ;
  struct fuse_session *tmp___9 ;
  int tmp___10 ;
  struct fuse_chan *ch ;
  struct fuse_chan *tmp___11 ;
  int tmp___12 ;

  {
#line 107
  while (1) {
#line 107
    if (! (mflag == 0)) {
#line 107
      while (1) {
#line 107
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                "zfs-fuse/util.c", 107, "do_mount", "mflag == 0");
#line 107
        abort();
#line 107
        break;
      }
    }
#line 107
    break;
  }
#line 108
  while (1) {
#line 108
    if (! ((int )*(opt + 0) == 0)) {
#line 108
      while (1) {
#line 108
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                "zfs-fuse/util.c", 108, "do_mount", "opt[0] == \'\\0\'");
#line 108
        abort();
#line 108
        break;
      }
    }
#line 108
    break;
  }
#line 110
  tmp = umem_zalloc(sizeof(vfs_t ), 256);
#line 110
  vfs = (vfs_t *)tmp;
#line 111
  if ((unsigned int )vfs == (unsigned int )((void *)0)) {
#line 112
    return (12);
  }
#line 114
  vfs->vfs_op = zfs_vfsops;
#line 115
  vfs_hold(vfs);
#line 117
  tmp___0 = strlen((char const   *)opt);
#line 117
  uap.spec = spec;
#line 117
  uap.dir = dir;
#line 117
  uap.flags = mflag;
#line 117
  uap.fstype = (char *)((void *)0);
#line 117
  uap.dataptr = opt;
#line 117
  uap.datalen = (int )tmp___0;
#line 117
  uap.optptr = (char *)0;
#line 117
  uap.optlen = 0;
#line 120
  ret = fsop_mount(vfs, rootdir, & uap, kcred);
#line 120
  if (ret != 0) {
#line 121
    umem_free((void *)vfs, sizeof(vfs_t ));
#line 122
    return (ret);
  }
#line 132
  tmp___2 = asprintf((char ** __restrict  )(& fuse_opts), (char const   * __restrict  )"fsname=%s,allow_other",
                     spec);
#line 132
  if (tmp___2 == -1) {
#line 133
    while (1) {
#line 133
      tmp___1 = do_umount(vfs, 0);
#line 133
      if (! (tmp___1 == 0)) {
#line 133
        while (1) {
#line 133
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                  "zfs-fuse/util.c", 133, "do_mount", "do_umount(vfs, B_FALSE) == 0");
#line 133
          abort();
#line 133
          break;
        }
      }
#line 133
      break;
    }
#line 134
    return (12);
  }
#line 137
  args.argc = 0;
#line 137
  args.argv = (char **)((void *)0);
#line 137
  args.allocated = 0;
#line 139
  tmp___4 = fuse_opt_add_arg(& args, "");
#line 139
  if (tmp___4 == -1) {
    goto _L;
  } else {
#line 139
    tmp___5 = fuse_opt_add_arg(& args, "-o");
#line 139
    if (tmp___5 == -1) {
      goto _L;
    } else {
#line 139
      tmp___6 = fuse_opt_add_arg(& args, (char const   *)fuse_opts);
#line 139
      if (tmp___6 == -1) {
        _L: /* CIL Label */ 
#line 142
        fuse_opt_free_args(& args);
#line 143
        free((void *)fuse_opts);
#line 144
        while (1) {
#line 144
          tmp___3 = do_umount(vfs, 0);
#line 144
          if (! (tmp___3 == 0)) {
#line 144
            while (1) {
#line 144
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                      "zfs-fuse/util.c", 144, "do_mount", "do_umount(vfs, B_FALSE) == 0");
#line 144
              abort();
#line 144
              break;
            }
          }
#line 144
          break;
        }
#line 145
        return (12);
      }
    }
  }
#line 147
  free((void *)fuse_opts);
#line 149
  tmp___7 = fuse_mount_compat25((char const   *)dir, & args);
#line 149
  fd = tmp___7;
#line 151
  if (fd == -1) {
#line 152
    while (1) {
#line 152
      tmp___8 = do_umount(vfs, 0);
#line 152
      if (! (tmp___8 == 0)) {
#line 152
        while (1) {
#line 152
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                  "zfs-fuse/util.c", 152, "do_mount", "do_umount(vfs, B_FALSE) == 0");
#line 152
          abort();
#line 152
          break;
        }
      }
#line 152
      break;
    }
#line 153
    return (5);
  }
#line 156
  tmp___9 = fuse_lowlevel_new_compat25(& args, (struct fuse_lowlevel_ops_compat25  const  *)(& zfs_operations),
                                       sizeof(zfs_operations), (void *)vfs);
#line 156
  se = tmp___9;
#line 157
  fuse_opt_free_args(& args);
#line 159
  if ((unsigned int )se == (unsigned int )((void *)0)) {
#line 160
    while (1) {
#line 160
      tmp___10 = do_umount(vfs, 0);
#line 160
      if (! (tmp___10 == 0)) {
#line 160
        while (1) {
#line 160
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                  "zfs-fuse/util.c", 160, "do_mount", "do_umount(vfs, B_FALSE) == 0");
#line 160
          abort();
#line 160
          break;
        }
      }
#line 160
      break;
    }
#line 161
    close(fd);
#line 162
    fuse_unmount_compat22((char const   *)dir);
#line 163
    return (5);
  }
#line 166
  tmp___11 = fuse_kern_chan_new(fd);
#line 166
  ch = tmp___11;
#line 167
  if ((unsigned int )ch == (unsigned int )((void *)0)) {
#line 168
    fuse_session_destroy(se);
#line 169
    close(fd);
#line 170
    fuse_unmount_compat22((char const   *)dir);
#line 171
    return (5);
  }
#line 174
  fuse_session_add_chan(se, ch);
#line 176
  tmp___12 = zfsfuse_newfs(dir, ch);
#line 176
  if (tmp___12 != 0) {
#line 177
    fuse_session_destroy(se);
#line 178
    close(fd);
#line 179
    fuse_unmount_compat22((char const   *)dir);
#line 180
    return (5);
  }
#line 183
  return (0);
}
}
#line 186 "zfs-fuse/util.c"
int do_umount(vfs_t *vfs , boolean_t force ) 
{ int ret ;
  int tmp ;
  int tmp___0 ;

  {
#line 188
  fsop_sync(vfs, (short)0, kcred);
#line 190
  if (force) {
#line 190
    tmp = 1024;
  } else {
#line 190
    tmp = 0;
  }
#line 190
  tmp___0 = fsop_unmount(vfs, tmp, kcred);
#line 190
  ret = tmp___0;
#line 191
  if (ret != 0) {
#line 192
    return (ret);
  }
#line 194
  if (! force) {
#line 194
    if (! (vfs->vfs_count == 1U)) {
#line 194
      __assert_fail("force || vfs->vfs_count == 1", "zfs-fuse/util.c", 194U, "do_umount");
    }
  }
#line 195
  vfs_rele(vfs);
#line 201
  return (0);
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned int  ) ;  */
#line 1 "zfs_acl.o"
#pragma merger(0,"/tmp/cil-ge7LFKIn.i","-pipe,-Wall,-Werror,-std=c99,-Wno-unused,-Wno-missing-braces,-Wno-parentheses,-Wno-uninitialized,-fno-strict-aliasing,-ggdb,-O2")
#line 351 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 292
extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 78 "lib/libsolkerncompat/include/sys/cred.h"
extern int groupmember(gid_t  , cred_t const   * ) ;
#line 85
extern uid_t crgetuid(cred_t const   * ) ;
#line 88
extern gid_t crgetgid(cred_t const   * ) ;
#line 169 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) pthread_t pthread_self(void) ;
#line 46 "lib/libsolkerncompat/include/sys/mutex.h"
extern void mutex_enter(kmutex_t *mp ) ;
#line 47
extern void mutex_exit(kmutex_t *mp ) ;
#line 45 "lib/libumem/include/umem.h"
extern void *umem_alloc(size_t  , int  ) ;
#line 307 "lib/libsolkerncompat/include/sys/vnode.h"
extern void vn_rele(vnode_t *vp ) ;
#line 50 "lib/libsolkerncompat/include/sys/mode.h"
extern ushort_t vttoif_tab[] ;
#line 62 "lib/libsolkerncompat/include/sys/policy.h"
extern int secpolicy_vnode_setids_setgids(cred_t const   *cred , gid_t gid ) ;
#line 63
extern int secpolicy_vnode_setdac(cred_t const   *cred , uid_t owner ) ;
#line 64
extern int secpolicy_vnode_access(cred_t const   *cr , vnode_t *vp , uid_t owner ,
                                  mode_t mode ) ;
#line 65
extern int secpolicy_vnode_create_gid(cred_t const   *cred ) ;
#line 212 "lib/libzfscommon/include/sys/dmu.h"
extern uint64_t dmu_object_alloc(objset_t *os , dmu_object_type_t ot , int blocksize ,
                                 dmu_object_type_t bonus_type , int bonus_len , dmu_tx_t *tx ) ;
#line 235
extern int dmu_object_free(objset_t *os , uint64_t object , dmu_tx_t *tx ) ;
#line 262
extern int dmu_object_set_blocksize(objset_t *os , uint64_t object , uint64_t size ,
                                    int ibs , dmu_tx_t *tx ) ;
#line 376
extern void dmu_buf_will_dirty(dmu_buf_t *db , dmu_tx_t *tx ) ;
#line 399
extern dmu_tx_t *dmu_tx_create(objset_t *os ) ;
#line 400
extern void dmu_tx_hold_write(dmu_tx_t *tx , uint64_t object , uint64_t off , int len ) ;
#line 404
extern void dmu_tx_hold_bonus(dmu_tx_t *tx , uint64_t object ) ;
#line 405
extern void dmu_tx_abort(dmu_tx_t *tx ) ;
#line 406
extern int dmu_tx_assign(dmu_tx_t *tx , uint64_t txg_how ) ;
#line 407
extern void dmu_tx_wait(dmu_tx_t *tx ) ;
#line 408
extern void dmu_tx_commit(dmu_tx_t *tx ) ;
#line 423
extern int dmu_read(objset_t *os , uint64_t object , uint64_t offset , uint64_t size ,
                    void *buf ) ;
#line 425
extern void dmu_write(objset_t *os , uint64_t object , uint64_t offset , uint64_t size ,
                      void const   *buf , dmu_tx_t *tx ) ;
#line 89 "lib/libzfscommon/include/sys/zfs_acl.h"
void zfs_perm_init(struct znode *zp , struct znode *parent , int flag , vattr_t *vap ,
                   dmu_tx_t *tx , cred_t *cr ) ;
#line 91
int zfs_getacl(struct znode *zp , vsecattr_t *vsecp , cred_t *cr ) ;
#line 93
int zfs_setacl(struct znode *zp , vsecattr_t *vsecp , cred_t *cr ) ;
#line 96
int zfs_zaccess(struct znode *zp , int mode , cred_t *cr ) ;
#line 97
int zfs_zaccess_rwx(struct znode *zp , mode_t mode , cred_t *cr ) ;
#line 99
int zfs_acl_chmod_setattr(struct znode *zp , uint64_t mode , dmu_tx_t *tx ) ;
#line 100
int zfs_zaccess_delete(struct znode *dzp , struct znode *zp , cred_t *cr ) ;
#line 101
int zfs_zaccess_rename(struct znode *sdzp , struct znode *szp , struct znode *tdzp ,
                       struct znode *tzp , cred_t *cr ) ;
#line 103
int zfs_zaccess_v4_perm(struct znode *zp , int mode , cred_t *cr ) ;
#line 104
void zfs_acl_free(zfs_acl_t *aclp ) ;
#line 243 "lib/libzfscommon/include/sys/zfs_znode.h"
void zfs_time_stamper_locked(znode_t *zp , uint_t flag , dmu_tx_t *tx ) ;
#line 248
int zfs_zget(zfsvfs_t *zfsvfs , uint64_t obj_num , znode_t **zpp ) ;
#line 275
void zfs_log_acl(zilog_t *zilog , dmu_tx_t *tx , int txtype , znode_t *zp , int aclcnt ,
                 ace_t *z_ace ) ;
#line 61 "lib/libzfscommon/include/sys/zfs_dir.h"
int zfs_sticky_remove_access(znode_t *zdp , znode_t *zp , cred_t *cr ) ;
#line 44 "lib/libsolkerncompat/include/acl/acl_common.h"
extern void adjust_ace_pair(ace_t *pair , mode_t mode ) ;
#line 45
extern int ace_trivial(ace_t *acep , int aclcnt ) ;
#line 82 "zfs-fuse/zfs_acl.c"
static int zfs_ace_can_use(znode_t *zp , ace_t *acep ) ;
#line 84 "zfs-fuse/zfs_acl.c"
static zfs_acl_t *zfs_acl_alloc(int slots ) 
{ zfs_acl_t *aclp ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 89
  tmp = umem_zalloc(sizeof(zfs_acl_t ), 256);
#line 89
  aclp = (zfs_acl_t *)tmp;
#line 90
  if (slots != 0) {
#line 91
    tmp___0 = umem_alloc(sizeof(ace_t ) * (unsigned int )slots, 256);
#line 91
    aclp->z_acl = (ace_t *)tmp___0;
#line 92
    aclp->z_acl_count = 0;
#line 93
    aclp->z_state = 1U;
  } else {
#line 95
    aclp->z_state = 0U;
  }
#line 97
  aclp->z_slots = slots;
#line 98
  return (aclp);
}
}
#line 101 "zfs-fuse/zfs_acl.c"
void zfs_acl_free(zfs_acl_t *aclp ) 
{ 

  {
#line 104
  if (aclp->z_state == 1U) {
#line 105
    umem_free((void *)aclp->z_acl, sizeof(ace_t ) * (unsigned int )aclp->z_slots);
  }
#line 107
  umem_free((void *)aclp, sizeof(zfs_acl_t ));
#line 108
  return;
}
}
#line 110 "zfs-fuse/zfs_acl.c"
static uint32_t zfs_v4_to_unix(uint32_t access_mask ) 
{ uint32_t new_mask ;

  {
#line 113
  new_mask = (uint32_t )0;
#line 119
  if (access_mask & 131201U) {
#line 121
    new_mask |= (unsigned int )((256 >> 3) >> 3);
  }
#line 122
  if (access_mask & 278U) {
#line 124
    new_mask |= (unsigned int )((128 >> 3) >> 3);
  }
#line 125
  if (access_mask & 40U) {
#line 126
    new_mask |= (unsigned int )((64 >> 3) >> 3);
  }
#line 128
  return (new_mask);
}
}
#line 134 "zfs-fuse/zfs_acl.c"
static uint32_t zfs_unix_to_v4(uint32_t access_mask ) 
{ uint32_t new_mask ;

  {
#line 137
  new_mask = (uint32_t )0;
#line 139
  if (access_mask & 1U) {
#line 140
    new_mask |= 32U;
  }
#line 141
  if (access_mask & 2U) {
#line 142
    new_mask |= 2U;
  }
#line 143
  if (access_mask & 4U) {
#line 144
    new_mask |= 1U;
  }
#line 146
  return (new_mask);
}
}
#line 149 "zfs-fuse/zfs_acl.c"
static void zfs_set_ace(ace_t *zacep , uint32_t access_mask , int access_type , uid_t uid ,
                        int entry_type ) 
{ 

  {
#line 153
  zacep->a_access_mask = access_mask;
#line 154
  zacep->a_type = (unsigned short )access_type;
#line 155
  zacep->a_who = uid;
#line 156
  zacep->a_flags = (unsigned short )entry_type;
#line 157
  return;
}
}
#line 159 "zfs-fuse/zfs_acl.c"
static uint64_t zfs_mode_compute(znode_t *zp , zfs_acl_t *aclp ) 
{ int i ;
  int entry_type ;
  mode_t mode ;
  mode_t seen ;
  ace_t *acep ;

  {
#line 164
  mode = (mode_t )((zp->z_phys)->zp_mode & 65024ULL);
#line 166
  seen = (mode_t )0;
#line 169
  i = 0;
#line 169
  acep = aclp->z_acl;
#line 169
  while (i != aclp->z_acl_count) {
#line 171
    entry_type = (int )acep->a_flags & 28736;
#line 172
    if (entry_type == 4096) {
#line 173
      if (acep->a_access_mask & 1U) {
#line 173
        if (! (seen & 256U)) {
#line 175
          seen |= 256U;
#line 176
          if ((int )acep->a_type == 0) {
#line 177
            mode |= 256U;
          }
        }
      }
#line 180
      if (acep->a_access_mask & 2U) {
#line 180
        if (! (seen & 128U)) {
#line 182
          seen |= 128U;
#line 183
          if ((int )acep->a_type == 0) {
#line 184
            mode |= 128U;
          }
        }
      }
#line 187
      if (acep->a_access_mask & 32U) {
#line 187
        if (! (seen & 64U)) {
#line 189
          seen |= 64U;
#line 190
          if ((int )acep->a_type == 0) {
#line 191
            mode |= 64U;
          }
        }
      }
    } else {
#line 194
      if (entry_type == 8256) {
#line 195
        if (acep->a_access_mask & 1U) {
#line 195
          if (! (seen & (unsigned int )(256 >> 3))) {
#line 197
            seen |= (unsigned int )(256 >> 3);
#line 198
            if ((int )acep->a_type == 0) {
#line 199
              mode |= (unsigned int )(256 >> 3);
            }
          }
        }
#line 202
        if (acep->a_access_mask & 2U) {
#line 202
          if (! (seen & (unsigned int )(128 >> 3))) {
#line 204
            seen |= (unsigned int )(128 >> 3);
#line 205
            if ((int )acep->a_type == 0) {
#line 206
              mode |= (unsigned int )(128 >> 3);
            }
          }
        }
#line 209
        if (acep->a_access_mask & 32U) {
#line 209
          if (! (seen & (unsigned int )(64 >> 3))) {
#line 211
            seen |= (unsigned int )(64 >> 3);
#line 212
            if ((int )acep->a_type == 0) {
#line 213
              mode |= (unsigned int )(64 >> 3);
            }
          }
        }
      } else {
#line 216
        if (entry_type == 16384) {
#line 217
          if (acep->a_access_mask & 1U) {
#line 218
            if (! (seen & 256U)) {
#line 219
              seen |= 256U;
#line 220
              if ((int )acep->a_type == 0) {
#line 221
                mode |= 256U;
              }
            }
#line 224
            if (! (seen & (unsigned int )(256 >> 3))) {
#line 225
              seen |= (unsigned int )(256 >> 3);
#line 226
              if ((int )acep->a_type == 0) {
#line 227
                mode |= (unsigned int )(256 >> 3);
              }
            }
#line 230
            if (! (seen & (unsigned int )((256 >> 3) >> 3))) {
#line 231
              seen |= (unsigned int )((256 >> 3) >> 3);
#line 232
              if ((int )acep->a_type == 0) {
#line 233
                mode |= (unsigned int )((256 >> 3) >> 3);
              }
            }
          }
#line 237
          if (acep->a_access_mask & 2U) {
#line 238
            if (! (seen & 128U)) {
#line 239
              seen |= 128U;
#line 240
              if ((int )acep->a_type == 0) {
#line 241
                mode |= 128U;
              }
            }
#line 244
            if (! (seen & (unsigned int )(128 >> 3))) {
#line 245
              seen |= (unsigned int )(128 >> 3);
#line 246
              if ((int )acep->a_type == 0) {
#line 247
                mode |= (unsigned int )(128 >> 3);
              }
            }
#line 250
            if (! (seen & (unsigned int )((128 >> 3) >> 3))) {
#line 251
              seen |= (unsigned int )((128 >> 3) >> 3);
#line 252
              if ((int )acep->a_type == 0) {
#line 253
                mode |= (unsigned int )((128 >> 3) >> 3);
              }
            }
          }
#line 257
          if (acep->a_access_mask & 32U) {
#line 258
            if (! (seen & 64U)) {
#line 259
              seen |= 64U;
#line 260
              if ((int )acep->a_type == 0) {
#line 261
                mode |= 64U;
              }
            }
#line 264
            if (! (seen & (unsigned int )(64 >> 3))) {
#line 265
              seen |= (unsigned int )(64 >> 3);
#line 266
              if ((int )acep->a_type == 0) {
#line 267
                mode |= (unsigned int )(64 >> 3);
              }
            }
#line 270
            if (! (seen & (unsigned int )((64 >> 3) >> 3))) {
#line 271
              seen |= (unsigned int )((64 >> 3) >> 3);
#line 272
              if ((int )acep->a_type == 0) {
#line 273
                mode |= (unsigned int )((64 >> 3) >> 3);
              }
            }
          }
        }
      }
    }
#line 169
    i ++;
#line 169
    acep ++;
  }
#line 279
  return ((unsigned long long )mode);
}
}
#line 282 "zfs-fuse/zfs_acl.c"
static zfs_acl_t *zfs_acl_node_read_internal(znode_t *zp ) 
{ zfs_acl_t *aclp ;

  {
#line 287
  aclp = zfs_acl_alloc(0);
#line 288
  aclp->z_acl_count = (int )(zp->z_phys)->zp_acl.z_acl_count;
#line 289
  aclp->z_acl = & (zp->z_phys)->zp_acl.z_ace_data[0];
#line 291
  return (aclp);
}
}
#line 297 "zfs-fuse/zfs_acl.c"
static int zfs_acl_node_read(znode_t *zp , zfs_acl_t **aclpp ) 
{ uint64_t extacl ;
  zfs_acl_t *aclp ;
  int error ;
  pthread_t tmp ;

  {
#line 300
  extacl = (zp->z_phys)->zp_acl.z_acl_extern_obj;
#line 304
  tmp = pthread_self();
#line 304
  if (! ((unsigned int )zp->z_acl_lock.m_owner == (unsigned int )((void *)((unsigned int )tmp)))) {
#line 304
    __assert_fail("((&zp->z_acl_lock)->m_owner == ((void *)(uintptr_t)pthread_self()))",
                  "zfs-fuse/zfs_acl.c", 304U, "zfs_acl_node_read");
  }
#line 306
  if ((zp->z_phys)->zp_acl.z_acl_extern_obj == 0ULL) {
#line 307
    *aclpp = zfs_acl_node_read_internal(zp);
#line 308
    return (0);
  }
#line 311
  aclp = zfs_acl_alloc((int )(zp->z_phys)->zp_acl.z_acl_count);
#line 313
  error = dmu_read((zp->z_zfsvfs)->z_os, extacl, 0ULL, (unsigned long long )(sizeof(ace_t ) * (zp->z_phys)->zp_acl.z_acl_count),
                   (void *)aclp->z_acl);
#line 315
  if (error != 0) {
#line 316
    zfs_acl_free(aclp);
#line 317
    return (error);
  }
#line 320
  aclp->z_acl_count = (int )(zp->z_phys)->zp_acl.z_acl_count;
#line 322
  *aclpp = aclp;
#line 323
  return (0);
}
}
#line 326 "zfs-fuse/zfs_acl.c"
static boolean_t zfs_acl_valid(znode_t *zp , ace_t *uace , int aclcnt , int *inherit ) 
{ ace_t *acep ;
  int i ;

  {
#line 332
  *inherit = 0;
#line 334
  if (aclcnt > 1024) {
#line 335
    return (0);
  } else {
#line 334
    if (aclcnt <= 0) {
#line 335
      return (0);
    }
  }
#line 338
  i = 0;
#line 338
  acep = uace;
#line 338
  while (i != aclcnt) {
#line 344
    switch ((int )acep->a_flags & 28736) {
    case 4096: 
#line 346
    acep->a_who = 4294967295U;
#line 347
    break;
    case 8256: 
    case 64: 
#line 350
    if ((int )acep->a_flags & 8192) {
#line 351
      acep->a_who = 4294967295U;
    }
#line 353
    break;
    case 16384: 
#line 355
    acep->a_who = 4294967295U;
#line 356
    break;
    }
#line 363
    if ((int )acep->a_type != 0) {
#line 363
      if ((int )acep->a_type != 1) {
#line 364
        return (0);
      }
    }
#line 369
    if ((int )(zp->z_vnode)->v_type != 2) {
#line 369
      if ((int )acep->a_flags & 15) {
#line 372
        return (0);
      }
    }
#line 375
    if ((int )acep->a_flags & 3) {
#line 377
      *inherit = 1;
    }
#line 379
    if ((int )acep->a_flags & 12) {
#line 381
      if (((int )acep->a_flags & 3) == 0) {
#line 383
        return (0);
      }
    }
#line 338
    i ++;
#line 338
    acep ++;
  }
#line 388
  return (1);
}
}
#line 397 "zfs-fuse/zfs_acl.c"
int zfs_aclset_common(znode_t *zp , zfs_acl_t *aclp , dmu_tx_t *tx , int *ihp ) 
{ int inherit ;
  int error ;
  znode_phys_t *zphys ;
  zfs_znode_acl_t *zacl ;
  uint32_t acl_phys_size ;
  zfsvfs_t *zfsvfs ;
  uint64_t aoid ;
  pthread_t tmp ;
  pthread_t tmp___0 ;
  boolean_t tmp___1 ;
  int tmp___2 ;

  {
#line 400
  inherit = 0;
#line 402
  zphys = zp->z_phys;
#line 403
  zacl = & zphys->zp_acl;
#line 404
  acl_phys_size = sizeof(ace_t ) * (unsigned int )aclp->z_acl_count;
#line 405
  zfsvfs = zp->z_zfsvfs;
#line 406
  aoid = zphys->zp_acl.z_acl_extern_obj;
#line 408
  tmp = pthread_self();
#line 408
  if (! ((unsigned int )zp->z_lock.m_owner == (unsigned int )((void *)((unsigned int )tmp)))) {
#line 408
    __assert_fail("((&zp->z_lock)->m_owner == ((void *)(uintptr_t)pthread_self()))",
                  "zfs-fuse/zfs_acl.c", 408U, "zfs_aclset_common");
  }
#line 409
  tmp___0 = pthread_self();
#line 409
  if (! ((unsigned int )zp->z_acl_lock.m_owner == (unsigned int )((void *)((unsigned int )tmp___0)))) {
#line 409
    __assert_fail("((&zp->z_acl_lock)->m_owner == ((void *)(uintptr_t)pthread_self()))",
                  "zfs-fuse/zfs_acl.c", 409U, "zfs_aclset_common");
  }
#line 411
  if (ihp) {
#line 412
    inherit = *ihp;
  } else {
#line 413
    tmp___1 = zfs_acl_valid(zp, aclp->z_acl, aclp->z_acl_count, & inherit);
#line 413
    if (! tmp___1) {
#line 415
      return (22);
    }
  }
#line 418
  dmu_buf_will_dirty(zp->z_dbuf, tx);
#line 423
  if (aclp->z_acl_count > 6) {
#line 424
    if (aoid == 0ULL) {
#line 425
      aoid = dmu_object_alloc(zfsvfs->z_os, 18, (int )acl_phys_size, 0, 0, tx);
    } else {
#line 428
      dmu_object_set_blocksize(zfsvfs->z_os, aoid, (unsigned long long )acl_phys_size,
                               0, tx);
    }
#line 431
    zphys->zp_acl.z_acl_extern_obj = aoid;
#line 432
    zphys->zp_acl.z_acl_count = (unsigned int )aclp->z_acl_count;
#line 433
    dmu_write(zfsvfs->z_os, aoid, 0ULL, (unsigned long long )acl_phys_size, (void const   *)aclp->z_acl,
              tx);
  } else {
#line 439
    if (zphys->zp_acl.z_acl_extern_obj) {
#line 440
      error = dmu_object_free(zfsvfs->z_os, (zp->z_phys)->zp_acl.z_acl_extern_obj,
                              tx);
#line 442
      if (error) {
#line 443
        return (error);
      }
#line 444
      zphys->zp_acl.z_acl_extern_obj = 0ULL;
    }
#line 446
    bcopy((void const   *)aclp->z_acl, (void *)(zacl->z_ace_data), (unsigned int )aclp->z_acl_count * sizeof(ace_t ));
#line 448
    zacl->z_acl_count = (unsigned int )aclp->z_acl_count;
  }
#line 451
  (zp->z_phys)->zp_flags &= 0xfffffffffffffff9ULL;
#line 452
  if (inherit) {
#line 453
    (zp->z_phys)->zp_flags |= 2ULL;
  } else {
#line 454
    tmp___2 = ace_trivial(zacl->z_ace_data, (int )zacl->z_acl_count);
#line 454
    if (tmp___2 == 0) {
#line 455
      (zp->z_phys)->zp_flags |= 4ULL;
    }
  }
#line 458
  zphys->zp_mode = zfs_mode_compute(zp, aclp);
#line 459
  zfs_time_stamper_locked(zp, 1024U, tx);
#line 461
  return (0);
}
}
#line 468 "zfs-fuse/zfs_acl.c"
static void zfs_acl_append(zfs_acl_t *aclp , int slots_needed ) 
{ ace_t *newacep ;
  ace_t *oldaclp ;
  int slot_cnt ;
  int slots_left ;
  void *tmp ;

  {
#line 474
  slots_left = aclp->z_slots - aclp->z_acl_count;
#line 476
  if (aclp->z_state == 1U) {
#line 477
    if (! (aclp->z_slots >= aclp->z_acl_count)) {
#line 477
      __assert_fail("aclp->z_slots >= aclp->z_acl_count", "zfs-fuse/zfs_acl.c", 477U,
                    "zfs_acl_append");
    }
  }
#line 478
  if (slots_left < slots_needed) {
    goto _L;
  } else {
#line 478
    if (aclp->z_state != 1U) {
      _L: /* CIL Label */ 
#line 479
      slot_cnt = (aclp->z_slots + 1) + (slots_needed - slots_left);
#line 480
      tmp = umem_alloc(sizeof(ace_t ) * (unsigned int )slot_cnt, 256);
#line 480
      newacep = (ace_t *)tmp;
#line 481
      bcopy((void const   *)aclp->z_acl, (void *)newacep, sizeof(ace_t ) * (unsigned int )aclp->z_acl_count);
#line 483
      oldaclp = aclp->z_acl;
#line 484
      if (aclp->z_state == 1U) {
#line 485
        umem_free((void *)oldaclp, sizeof(ace_t ) * (unsigned int )aclp->z_slots);
      }
#line 486
      aclp->z_acl = newacep;
#line 487
      aclp->z_slots = slot_cnt;
#line 488
      aclp->z_state = 1U;
    }
  }
#line 490
  return;
}
}
#line 495 "zfs-fuse/zfs_acl.c"
static void zfs_ace_remove(zfs_acl_t *aclp , int slot ) 
{ 

  {
#line 498
  if (aclp->z_acl_count > 1) {
#line 499
    (aclp->z_acl_count) --;
#line 499
    memmove((void *)(aclp->z_acl + slot), (void const   *)(aclp->z_acl + (slot + 1)),
            sizeof(ace_t ) * (unsigned int )(aclp->z_acl_count - slot));
  } else {
#line 503
    (aclp->z_acl_count) --;
  }
#line 504
  return;
}
}
#line 511 "zfs-fuse/zfs_acl.c"
static void zfs_acl_prepend_fixup(ace_t *acep , ace_t *origacep , mode_t mode , uid_t owner ) 
{ int rmask ;
  int wmask ;
  int xmask ;
  int user_ace ;

  {
#line 518
  user_ace = ! ((int )acep->a_flags & 12352);
#line 521
  if (user_ace) {
#line 521
    if (acep->a_who == owner) {
#line 522
      rmask = 256;
#line 523
      wmask = 128;
#line 524
      xmask = 64;
    } else {
#line 526
      rmask = 256 >> 3;
#line 527
      wmask = 128 >> 3;
#line 528
      xmask = 64 >> 3;
    }
  } else {
#line 526
    rmask = 256 >> 3;
#line 527
    wmask = 128 >> 3;
#line 528
    xmask = 64 >> 3;
  }
#line 531
  if (origacep->a_access_mask & 1U) {
#line 532
    if (mode & (unsigned int )rmask) {
#line 533
      acep->a_access_mask &= 4294967294U;
    } else {
#line 535
      acep->a_access_mask |= 1U;
    }
  }
#line 538
  if (origacep->a_access_mask & 2U) {
#line 539
    if (mode & (unsigned int )wmask) {
#line 540
      acep->a_access_mask &= 4294967293U;
    } else {
#line 542
      acep->a_access_mask |= 2U;
    }
  }
#line 545
  if (origacep->a_access_mask & 4U) {
#line 546
    if (mode & (unsigned int )wmask) {
#line 547
      acep->a_access_mask &= 4294967291U;
    } else {
#line 549
      acep->a_access_mask |= 4U;
    }
  }
#line 552
  if (origacep->a_access_mask & 32U) {
#line 553
    if (mode & (unsigned int )xmask) {
#line 554
      acep->a_access_mask &= 4294967263U;
    } else {
#line 556
      acep->a_access_mask |= 32U;
    }
  }
#line 558
  return;
}
}
#line 563 "zfs-fuse/zfs_acl.c"
static void zfs_acl_fixup_canonical_six(zfs_acl_t *aclp , mode_t mode ) 
{ int cnt ;
  ace_t *acep ;

  {
#line 569
  cnt = aclp->z_acl_count - 1;
#line 570
  acep = aclp->z_acl;
#line 576
  if (! (cnt >= 5)) {
#line 576
    __assert_fail("cnt >= 5", "zfs-fuse/zfs_acl.c", 576U, "zfs_acl_fixup_canonical_six");
  }
#line 577
  adjust_ace_pair(acep + (cnt - 1), mode);
#line 578
  adjust_ace_pair(acep + (cnt - 3), (mode & 56U) >> 3);
#line 579
  adjust_ace_pair(acep + (cnt - 5), (mode & 448U) >> 6);
#line 580
  return;
}
}
#line 583 "zfs-fuse/zfs_acl.c"
static int zfs_acl_ace_match(ace_t *acep , int allow_deny , int type , int mask ) 
{ int tmp ;

  {
#line 586
  if (acep->a_access_mask == (uint32_t )mask) {
#line 586
    if ((int )acep->a_type == allow_deny) {
#line 586
      if (((int )acep->a_flags & 28736) == type) {
#line 586
        tmp = 1;
      } else {
#line 586
        tmp = 0;
      }
    } else {
#line 586
      tmp = 0;
    }
  } else {
#line 586
    tmp = 0;
  }
#line 586
  return (tmp);
}
}
#line 593 "zfs-fuse/zfs_acl.c"
static int zfs_reuse_deny(ace_t *acep , int i ) 
{ int okay_masks ;

  {
#line 598
  if (i < 1) {
#line 599
    return (0);
  }
#line 601
  if ((int )(acep + (i - 1))->a_type != 1) {
#line 602
    return (0);
  }
#line 604
  if ((int )(acep + (i - 1))->a_flags != ((int )(acep + i)->a_flags & 64)) {
#line 605
    return (0);
  }
#line 607
  okay_masks = (int )((acep + i)->a_access_mask & 39U);
#line 609
  if ((acep + (i - 1))->a_access_mask & (unsigned int )(~ okay_masks)) {
#line 610
    return (0);
  }
#line 612
  return (1);
}
}
#line 618 "zfs-fuse/zfs_acl.c"
static void zfs_acl_prepend(zfs_acl_t *aclp , int i ) 
{ ace_t *oldaclp ;
  ace_t *to ;
  ace_t *from ;
  int slots_left ;
  int oldslots ;
  int need_free ;
  void *tmp ;

  {
#line 621
  oldaclp = (ace_t *)((void *)0);
#line 623
  slots_left = aclp->z_slots - aclp->z_acl_count;
#line 625
  need_free = 0;
#line 627
  if (aclp->z_state == 1U) {
#line 628
    if (! (aclp->z_slots >= aclp->z_acl_count)) {
#line 628
      __assert_fail("aclp->z_slots >= aclp->z_acl_count", "zfs-fuse/zfs_acl.c", 628U,
                    "zfs_acl_prepend");
    }
  }
#line 630
  if (slots_left == 0) {
    goto _L;
  } else {
#line 630
    if (aclp->z_state != 1U) {
      _L: /* CIL Label */ 
#line 632
      tmp = umem_alloc(sizeof(ace_t ) * (unsigned int )(aclp->z_acl_count + 6), 256);
#line 632
      to = (ace_t *)tmp;
#line 634
      if (aclp->z_state == 1U) {
#line 635
        need_free ++;
      }
#line 636
      from = aclp->z_acl;
#line 637
      oldaclp = aclp->z_acl;
#line 638
      memmove((void *)to, (void const   *)from, sizeof(ace_t ) * (unsigned int )aclp->z_acl_count);
#line 640
      aclp->z_state = 1U;
    } else {
#line 642
      from = aclp->z_acl;
#line 643
      to = aclp->z_acl;
    }
  }
#line 647
  memmove((void *)(to + (i + 1)), (void const   *)(from + i), sizeof(ace_t ) * (unsigned int )(aclp->z_acl_count - i));
#line 650
  if (oldaclp) {
#line 651
    aclp->z_acl = to;
#line 652
    oldslots = aclp->z_slots;
#line 653
    aclp->z_slots = aclp->z_acl_count + 6;
#line 654
    if (need_free) {
#line 655
      umem_free((void *)oldaclp, sizeof(ace_t ) * (unsigned int )oldslots);
    }
  }
#line 658
  return;
}
}
#line 663 "zfs-fuse/zfs_acl.c"
static void zfs_acl_prepend_deny(znode_t *zp , zfs_acl_t *aclp , int i , mode_t mode ) 
{ ace_t *acep ;

  {
#line 669
  zfs_acl_prepend(aclp, i);
#line 671
  acep = aclp->z_acl;
#line 672
  zfs_set_ace(acep + i, 0U, 1, (acep + (i + 1))->a_who, (int )(acep + (i + 1))->a_flags & 28736);
#line 674
  zfs_acl_prepend_fixup(acep + i, acep + (i + 1), mode, (unsigned int )(zp->z_phys)->zp_uid);
#line 675
  (aclp->z_acl_count) ++;
#line 676
  return;
}
}
#line 682 "zfs-fuse/zfs_acl.c"
static void zfs_acl_split_ace(zfs_acl_t *aclp , int i ) 
{ ace_t *acep ;

  {
#line 685
  acep = aclp->z_acl;
#line 687
  zfs_acl_prepend(aclp, i);
#line 688
  acep = aclp->z_acl;
#line 689
  *(acep + i) = *(acep + (i + 1));
#line 690
  (acep + i)->a_flags = (unsigned short )((int )(acep + i)->a_flags | 8);
#line 691
  (acep + (i + 1))->a_flags = (unsigned short )((int )(acep + (i + 1))->a_flags & -16);
#line 692
  (aclp->z_acl_count) ++;
#line 693
  return;
}
}
#line 698 "zfs-fuse/zfs_acl.c"
static int zfs_have_canonical_six(zfs_acl_t *aclp , int i ) 
{ ace_t *acep ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 701
  acep = aclp->z_acl;
#line 703
  tmp = zfs_acl_ace_match(acep + i, 1, 4096, 0);
#line 703
  if (tmp) {
#line 703
    tmp___0 = zfs_acl_ace_match(acep + (i + 1), 0, 4096, 786704);
#line 703
    if (tmp___0) {
#line 703
      tmp___1 = zfs_acl_ace_match(acep + (i + 2), 1, 8256, 0);
#line 703
      if (tmp___1) {
#line 703
        tmp___2 = zfs_acl_ace_match(acep + (i + 3), 0, 8256, 0);
#line 703
        if (tmp___2) {
#line 703
          tmp___3 = zfs_acl_ace_match(acep + (i + 4), 1, 16384, 786704);
#line 703
          if (tmp___3) {
#line 703
            tmp___4 = zfs_acl_ace_match(acep + (i + 5), 0, 16384, 1179784);
#line 703
            if (tmp___4) {
#line 712
              return (1);
            } else {
#line 714
              return (0);
            }
          } else {
#line 714
            return (0);
          }
        } else {
#line 714
          return (0);
        }
      } else {
#line 714
        return (0);
      }
    } else {
#line 714
      return (0);
    }
  } else {
#line 714
    return (0);
  }
}
}
#line 726 "zfs-fuse/zfs_acl.c"
static void zfs_fixup_group_entries(ace_t *acep , mode_t mode ) 
{ mode_t extramode ;
  mode_t ownermode ;

  {
#line 729
  extramode = (mode >> 3) & 7U;
#line 730
  ownermode = mode >> 6;
#line 732
  if ((int )(acep + 0)->a_flags & 64) {
#line 734
    extramode &= ~ ownermode;
#line 736
    if (extramode) {
#line 737
      if (extramode & 4U) {
#line 738
        (acep + 0)->a_access_mask &= 4294967294U;
#line 739
        (acep + 1)->a_access_mask &= 4294967294U;
      }
#line 741
      if (extramode & 2U) {
#line 742
        (acep + 0)->a_access_mask &= 4294967289U;
#line 744
        (acep + 1)->a_access_mask &= 4294967289U;
      }
#line 747
      if (extramode & 1U) {
#line 748
        (acep + 0)->a_access_mask &= 4294967263U;
#line 749
        (acep + 1)->a_access_mask &= 4294967263U;
      }
    }
  }
#line 753
  return;
}
}
#line 759 "zfs-fuse/zfs_acl.c"
static int zfs_acl_chmod(znode_t *zp , uint64_t mode , zfs_acl_t *aclp , dmu_tx_t *tx ) 
{ zfsvfs_t *zfsvfs ;
  ace_t *acep ;
  int i ;
  int error ;
  int entry_type ;
  int reuse_deny ;
  int need_canonical_six ;
  int inherit ;
  int iflags ;
  pthread_t tmp ;
  pthread_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 763
  zfsvfs = zp->z_zfsvfs;
#line 769
  need_canonical_six = 1;
#line 770
  inherit = 0;
#line 773
  tmp = pthread_self();
#line 773
  if (! ((unsigned int )zp->z_acl_lock.m_owner == (unsigned int )((void *)((unsigned int )tmp)))) {
#line 773
    __assert_fail("((&zp->z_acl_lock)->m_owner == ((void *)(uintptr_t)pthread_self()))",
                  "zfs-fuse/zfs_acl.c", 773U, "zfs_acl_chmod");
  }
#line 774
  tmp___0 = pthread_self();
#line 774
  if (! ((unsigned int )zp->z_lock.m_owner == (unsigned int )((void *)((unsigned int )tmp___0)))) {
#line 774
    __assert_fail("((&zp->z_lock)->m_owner == ((void *)(uintptr_t)pthread_self()))",
                  "zfs-fuse/zfs_acl.c", 774U, "zfs_acl_chmod");
  }
#line 776
  i = 0;
#line 777
  while (i < aclp->z_acl_count) {
#line 778
    acep = aclp->z_acl;
#line 779
    entry_type = (int )(acep + i)->a_flags & 28736;
#line 780
    iflags = (int )(acep + i)->a_flags & 15;
#line 782
    if ((int )(acep + i)->a_type != 0) {
#line 782
      if ((int )(acep + i)->a_type != 1) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 782
      if (iflags & 8) {
        _L: /* CIL Label */ 
#line 784
        i ++;
#line 785
        if (iflags) {
#line 786
          inherit = 1;
        }
#line 787
        continue;
      }
    }
#line 791
    if (zfsvfs->z_acl_mode == 0U) {
#line 792
      zfs_ace_remove(aclp, i);
#line 793
      continue;
    }
#line 799
    if (iflags & 3) {
#line 799
      if (! (iflags & 8)) {
#line 802
        zfs_acl_split_ace(aclp, i);
#line 803
        i ++;
#line 804
        inherit = 1;
#line 805
        continue;
      }
    }
#line 808
    if (entry_type == 4096) {
#line 810
      (acep + i)->a_access_mask &= 4294967256U;
#line 811
      i ++;
#line 812
      continue;
    } else {
#line 808
      if (entry_type == 16384) {
#line 810
        (acep + i)->a_access_mask &= 4294967256U;
#line 811
        i ++;
#line 812
        continue;
      } else {
#line 808
        if (entry_type == 8256) {
#line 810
          (acep + i)->a_access_mask &= 4294967256U;
#line 811
          i ++;
#line 812
          continue;
        } else {
#line 815
          if ((int )(acep + i)->a_type == 0) {
#line 823
            if (zfsvfs->z_acl_mode == 2U) {
#line 825
              reuse_deny = zfs_reuse_deny(acep, i);
#line 827
              if (reuse_deny == 0) {
#line 828
                zfs_acl_prepend_deny(zp, aclp, i, (unsigned int )mode);
#line 830
                i ++;
#line 831
                acep = aclp->z_acl;
              } else {
#line 833
                zfs_acl_prepend_fixup(acep + (i - 1), acep + i, (unsigned int )mode,
                                      (unsigned int )(zp->z_phys)->zp_uid);
              }
#line 838
              zfs_fixup_group_entries(acep + (i - 1), (unsigned int )mode);
            }
          }
#line 842
          i ++;
        }
      }
    }
  }
#line 850
  if (aclp->z_acl_count >= 6) {
#line 851
    i = aclp->z_acl_count - 6;
#line 853
    tmp___1 = zfs_have_canonical_six(aclp, i);
#line 853
    if (tmp___1) {
#line 854
      need_canonical_six = 0;
    }
  }
#line 858
  if (need_canonical_six) {
#line 860
    zfs_acl_append(aclp, 6);
#line 861
    i = aclp->z_acl_count;
#line 862
    acep = aclp->z_acl;
#line 863
    tmp___2 = i;
#line 863
    i ++;
#line 863
    zfs_set_ace(acep + tmp___2, 0U, 1, 4294967295U, 4096);
#line 864
    tmp___3 = i;
#line 864
    i ++;
#line 864
    zfs_set_ace(acep + tmp___3, 786704U, 0, 4294967295U, 4096);
#line 865
    tmp___4 = i;
#line 865
    i ++;
#line 865
    zfs_set_ace(acep + tmp___4, 0U, 1, 4294967295U, 8256);
#line 866
    tmp___5 = i;
#line 866
    i ++;
#line 866
    zfs_set_ace(acep + tmp___5, 0U, 0, 4294967295U, 8256);
#line 867
    tmp___6 = i;
#line 867
    i ++;
#line 867
    zfs_set_ace(acep + tmp___6, 786704U, 1, 4294967295U, 16384);
#line 869
    tmp___7 = i;
#line 869
    i ++;
#line 869
    zfs_set_ace(acep + tmp___7, 1179784U, 0, 4294967295U, 16384);
#line 871
    aclp->z_acl_count += 6;
  }
#line 874
  zfs_acl_fixup_canonical_six(aclp, (unsigned int )mode);
#line 876
  (zp->z_phys)->zp_mode = mode;
#line 877
  error = zfs_aclset_common(zp, aclp, tx, & inherit);
#line 878
  return (error);
}
}
#line 882 "zfs-fuse/zfs_acl.c"
int zfs_acl_chmod_setattr(struct znode *zp , uint64_t mode , dmu_tx_t *tx ) 
{ zfs_acl_t *aclp ;
  int error ;
  pthread_t tmp ;

  {
#line 885
  aclp = (zfs_acl_t *)((void *)0);
#line 888
  tmp = pthread_self();
#line 888
  if (! ((unsigned int )zp->z_lock.m_owner == (unsigned int )((void *)((unsigned int )tmp)))) {
#line 888
    __assert_fail("((&zp->z_lock)->m_owner == ((void *)(uintptr_t)pthread_self()))",
                  "zfs-fuse/zfs_acl.c", 888U, "zfs_acl_chmod_setattr");
  }
#line 889
  mutex_enter(& zp->z_acl_lock);
#line 890
  error = zfs_acl_node_read(zp, & aclp);
#line 891
  if (error == 0) {
#line 892
    error = zfs_acl_chmod(zp, mode, aclp, tx);
  }
#line 893
  mutex_exit(& zp->z_acl_lock);
#line 894
  if (aclp) {
#line 895
    zfs_acl_free(aclp);
  }
#line 896
  return (error);
}
}
#line 902 "zfs-fuse/zfs_acl.c"
static void zfs_securemode_update(zfsvfs_t *zfsvfs , ace_t *acep ) 
{ 

  {
#line 905
  if (zfsvfs->z_acl_inherit == 4U) {
#line 905
    if ((int )acep->a_type == 0) {
#line 907
      acep->a_access_mask &= 4294180863U;
    }
  }
#line 908
  return;
}
}
#line 913 "zfs-fuse/zfs_acl.c"
static zfs_acl_t *zfs_acl_inherit(znode_t *zp , zfs_acl_t *paclp ) 
{ zfsvfs_t *zfsvfs ;
  ace_t *pacep ;
  ace_t *acep ;
  int ace_cnt ;
  int pace_cnt ;
  int i ;
  int j ;
  zfs_acl_t *aclp ;
  int tmp ;
  int tmp___0 ;

  {
#line 916
  zfsvfs = zp->z_zfsvfs;
#line 919
  ace_cnt = 0;
#line 922
  aclp = (zfs_acl_t *)((void *)0);
#line 924
  j = 0;
#line 924
  i = j;
#line 925
  pace_cnt = paclp->z_acl_count;
#line 926
  pacep = paclp->z_acl;
#line 927
  if (zfsvfs->z_acl_inherit != 0U) {
#line 928
    i = 0;
#line 928
    while (i != pace_cnt) {
#line 930
      if (zfsvfs->z_acl_inherit == 1U) {
#line 930
        if ((int )(pacep + i)->a_type == 0) {
          goto __Cont;
        }
      }
#line 934
      tmp = zfs_ace_can_use(zp, pacep + i);
#line 934
      if (tmp) {
#line 935
        ace_cnt ++;
#line 936
        if (! ((int )(pacep + i)->a_flags & 4)) {
#line 938
          ace_cnt ++;
        }
      }
      __Cont: /* CIL Label */ 
#line 928
      i ++;
    }
  }
#line 943
  aclp = zfs_acl_alloc(ace_cnt + 6);
#line 944
  if (ace_cnt) {
#line 944
    if (zfsvfs->z_acl_inherit != 0U) {
#line 945
      acep = aclp->z_acl;
#line 946
      pacep = paclp->z_acl;
#line 947
      i = 0;
#line 947
      while (i != pace_cnt) {
#line 949
        if (zfsvfs->z_acl_inherit == 1U) {
#line 949
          if ((int )(pacep + i)->a_type == 0) {
            goto __Cont___0;
          }
        }
#line 953
        tmp___0 = zfs_ace_can_use(zp, pacep + i);
#line 953
        if (tmp___0) {
#line 959
          *(acep + j) = *(pacep + i);
#line 966
          if ((int )(pacep + i)->a_flags & 4) {
#line 969
            (acep + j)->a_flags = (unsigned short )((int )(acep + j)->a_flags & -16);
#line 970
            zfs_securemode_update(zfsvfs, acep + j);
#line 971
            j ++;
            goto __Cont___0;
          } else {
#line 966
            if ((int )(zp->z_vnode)->v_type != 2) {
#line 969
              (acep + j)->a_flags = (unsigned short )((int )(acep + j)->a_flags & -16);
#line 970
              zfs_securemode_update(zfsvfs, acep + j);
#line 971
              j ++;
              goto __Cont___0;
            }
          }
#line 975
          if (! ((int )(zp->z_vnode)->v_type == 2)) {
#line 975
            __assert_fail("((zp)->z_vnode)->v_type == VDIR", "zfs-fuse/zfs_acl.c",
                          975U, "zfs_acl_inherit");
          }
#line 982
          if (((int )(pacep + i)->a_flags & 3) != 1) {
#line 985
            j ++;
#line 986
            *(acep + j) = *(acep + (j - 1));
#line 987
            (acep + (j - 1))->a_flags = (unsigned short )((int )(acep + (j - 1))->a_flags | 8);
#line 989
            (acep + j)->a_flags = (unsigned short )((int )(acep + j)->a_flags & -16);
          } else {
#line 991
            (acep + j)->a_flags = (unsigned short )((int )(acep + j)->a_flags | 8);
          }
#line 993
          zfs_securemode_update(zfsvfs, acep + j);
#line 994
          j ++;
        }
        __Cont___0: /* CIL Label */ 
#line 947
        i ++;
      }
    }
  }
#line 998
  aclp->z_acl_count = j;
#line 999
  if (! (aclp->z_slots >= aclp->z_acl_count)) {
#line 999
    __assert_fail("aclp->z_slots >= aclp->z_acl_count", "zfs-fuse/zfs_acl.c", 999U,
                  "zfs_acl_inherit");
  }
#line 1001
  return (aclp);
}
}
#line 1008 "zfs-fuse/zfs_acl.c"
void zfs_perm_init(struct znode *zp , struct znode *parent , int flag , vattr_t *vap ,
                   dmu_tx_t *tx , cred_t *cr ) 
{ uint64_t mode ;
  uid_t uid ;
  gid_t gid ;
  int error ;
  int pull_down ;
  zfs_acl_t *aclp ;
  zfs_acl_t *paclp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  uint64_t __left ;
  uint64_t __right ;
  char *__buf ;
  void *tmp___4 ;

  {
#line 1019
  mode = (unsigned long long )((unsigned int )vttoif_tab[(int )vap->va_type] | (vap->va_mode & 4294905855U));
#line 1024
  if (flag & 5) {
#line 1026
    uid = vap->va_uid;
#line 1027
    gid = vap->va_gid;
  } else {
#line 1024
    if (flag & 2) {
#line 1024
      if ((int )vap->va_type == 2) {
#line 1026
        uid = vap->va_uid;
#line 1027
        gid = vap->va_gid;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 1029
      uid = crgetuid((cred_t const   *)cr);
#line 1030
      if (vap->va_mask & 8U) {
#line 1030
        if ((uint64_t )vap->va_gid == (parent->z_phys)->zp_gid) {
#line 1034
          gid = vap->va_gid;
        } else {
#line 1030
          tmp___0 = groupmember(vap->va_gid, (cred_t const   *)cr);
#line 1030
          if (tmp___0) {
#line 1034
            gid = vap->va_gid;
          } else {
#line 1030
            tmp___1 = secpolicy_vnode_create_gid((cred_t const   *)cr);
#line 1030
            if (tmp___1 == 0) {
#line 1034
              gid = vap->va_gid;
            } else {
              goto _L;
            }
          }
        }
      } else {
        _L: /* CIL Label */ 
#line 1036
        if ((parent->z_phys)->zp_mode & 1024ULL) {
#line 1036
          gid = (unsigned int )(parent->z_phys)->zp_gid;
        } else {
#line 1036
          gid = crgetgid((cred_t const   *)cr);
        }
      }
    }
  }
#line 1047
  if ((parent->z_phys)->zp_mode & 1024ULL) {
#line 1047
    if ((int )vap->va_type == 2) {
#line 1048
      mode |= 1024ULL;
    } else {
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 1050
    if (mode & 1024ULL) {
#line 1050
      tmp___2 = secpolicy_vnode_setids_setgids((cred_t const   *)cr, gid);
#line 1050
      if (tmp___2 != 0) {
#line 1052
        mode &= 0xfffffffffffffbffULL;
      }
    }
  }
#line 1055
  (zp->z_phys)->zp_uid = (unsigned long long )uid;
#line 1056
  (zp->z_phys)->zp_gid = (unsigned long long )gid;
#line 1057
  (zp->z_phys)->zp_mode = mode;
#line 1059
  mutex_enter(& parent->z_lock);
#line 1060
  pull_down = (int )((parent->z_phys)->zp_flags & 2ULL);
#line 1061
  if (pull_down) {
#line 1062
    mutex_enter(& parent->z_acl_lock);
#line 1063
    while (1) {
#line 1063
      tmp___3 = zfs_acl_node_read(parent, & paclp);
#line 1063
      if (! (0 == tmp___3)) {
#line 1063
        while (1) {
#line 1063
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                  "zfs-fuse/zfs_acl.c", 1063, "zfs_perm_init", "0 == zfs_acl_node_read(parent, &paclp)");
#line 1063
          abort();
#line 1063
          break;
        }
      }
#line 1063
      break;
    }
#line 1064
    mutex_exit(& parent->z_acl_lock);
#line 1065
    aclp = zfs_acl_inherit(zp, paclp);
#line 1066
    zfs_acl_free(paclp);
  } else {
#line 1068
    aclp = zfs_acl_alloc(6);
  }
#line 1070
  mutex_exit(& parent->z_lock);
#line 1071
  mutex_enter(& zp->z_lock);
#line 1072
  mutex_enter(& zp->z_acl_lock);
#line 1073
  error = zfs_acl_chmod(zp, mode, aclp, tx);
#line 1074
  mutex_exit(& zp->z_lock);
#line 1075
  mutex_exit(& zp->z_acl_lock);
#line 1076
  while (1) {
#line 1076
    __left = (unsigned long long )error;
#line 1076
    __right = 0ULL;
#line 1076
    if (! (__left == __right)) {
#line 1076
      tmp___4 = __builtin_alloca(256U);
#line 1076
      __buf = (char *)tmp___4;
#line 1076
      snprintf((char * __restrict  )__buf, 256U, (char const   * __restrict  )"%s %s %s (0x%llx %s 0x%llx)",
               "error", "==", "0", __left, "==", __right);
#line 1076
      while (1) {
#line 1076
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                "zfs-fuse/zfs_acl.c", 1076, "zfs_perm_init", __buf);
#line 1076
        abort();
#line 1076
        break;
      }
    }
#line 1076
    break;
  }
#line 1077
  zfs_acl_free(aclp);
#line 1078
  return;
}
}
#line 1083 "zfs-fuse/zfs_acl.c"
static int zfs_ace_can_use(znode_t *zp , ace_t *acep ) 
{ int vtype ;
  int iflags ;
  int tmp ;

  {
#line 1086
  vtype = (int )(zp->z_vnode)->v_type;
#line 1088
  iflags = (int )acep->a_flags & 15;
#line 1090
  if (vtype == 2) {
#line 1090
    if (iflags & 2) {
#line 1091
      return (1);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1092
    if (iflags & 1) {
#line 1093
      if (vtype == 2) {
#line 1093
        if (iflags & 4) {
#line 1093
          tmp = 0;
        } else {
#line 1093
          tmp = 1;
        }
      } else {
#line 1093
        tmp = 1;
      }
#line 1093
      return (tmp);
    }
  }
#line 1095
  return (0);
}
}
#line 1101 "zfs-fuse/zfs_acl.c"
int zfs_getacl(struct znode *zp , vsecattr_t *vsecp , cred_t *cr ) 
{ zfs_acl_t *aclp ;
  ulong_t mask ;
  int error ;
  uid_t tmp ;

  {
#line 1105
  mask = (ulong_t )(vsecp->vsa_mask & 48U);
#line 1108
  error = zfs_zaccess(zp, 131072, cr);
#line 1108
  if (error) {
#line 1113
    tmp = crgetuid((cred_t const   *)cr);
#line 1113
    if ((uint64_t )tmp != (zp->z_phys)->zp_uid) {
#line 1114
      return (error);
    }
  }
#line 1117
  if (mask == 0UL) {
#line 1118
    return (38);
  }
#line 1120
  mutex_enter(& zp->z_acl_lock);
#line 1122
  error = zfs_acl_node_read(zp, & aclp);
#line 1123
  if (error != 0) {
#line 1124
    mutex_exit(& zp->z_acl_lock);
#line 1125
    return (error);
  }
#line 1129
  if (mask & 32UL) {
#line 1130
    vsecp->vsa_aclcnt = aclp->z_acl_count;
  }
#line 1133
  if (mask & 16UL) {
#line 1134
    vsecp->vsa_aclentp = umem_alloc((unsigned int )aclp->z_acl_count * sizeof(ace_t ),
                                    256);
#line 1136
    bcopy((void const   *)aclp->z_acl, vsecp->vsa_aclentp, (unsigned int )aclp->z_acl_count * sizeof(ace_t ));
  }
#line 1140
  mutex_exit(& zp->z_acl_lock);
#line 1142
  zfs_acl_free(aclp);
#line 1144
  return (0);
}
}
#line 1150 "zfs-fuse/zfs_acl.c"
int zfs_setacl(struct znode *zp , vsecattr_t *vsecp , cred_t *cr ) 
{ zfsvfs_t *zfsvfs ;
  zilog_t *zilog ;
  ace_t *acep ;
  int aclcnt ;
  ulong_t mask ;
  dmu_tx_t *tx ;
  int error ;
  int inherit ;
  zfs_acl_t *aclp ;
  boolean_t tmp ;
  int tmp___0 ;

  {
#line 1153
  zfsvfs = zp->z_zfsvfs;
#line 1154
  zilog = zfsvfs->z_log;
#line 1155
  acep = (ace_t *)vsecp->vsa_aclentp;
#line 1156
  aclcnt = vsecp->vsa_aclcnt;
#line 1157
  mask = (ulong_t )(vsecp->vsa_mask & 48U);
#line 1163
  if (mask == 0UL) {
#line 1164
    return (22);
  }
#line 1166
  tmp = zfs_acl_valid(zp, acep, aclcnt, & inherit);
#line 1166
  if (! tmp) {
#line 1167
    return (22);
  }
  top: 
#line 1169
  error = zfs_zaccess_v4_perm(zp, 262144, cr);
#line 1170
  if (error == 13) {
    goto _L;
  } else {
#line 1170
    if (error == -1) {
      _L: /* CIL Label */ 
#line 1171
      error = secpolicy_vnode_setdac((cred_t const   *)cr, (unsigned int )(zp->z_phys)->zp_uid);
#line 1171
      if (error != 0) {
#line 1173
        return (error);
      }
    } else {
#line 1175
      if (error) {
#line 1176
        if (error == 30) {
#line 1176
          tmp___0 = error;
        } else {
#line 1176
          tmp___0 = 1;
        }
#line 1176
        return (tmp___0);
      }
    }
  }
#line 1179
  mutex_enter(& zp->z_lock);
#line 1180
  mutex_enter(& zp->z_acl_lock);
#line 1182
  tx = dmu_tx_create(zfsvfs->z_os);
#line 1183
  dmu_tx_hold_bonus(tx, zp->z_id);
#line 1185
  if ((zp->z_phys)->zp_acl.z_acl_extern_obj) {
#line 1186
    dmu_tx_hold_write(tx, (zp->z_phys)->zp_acl.z_acl_extern_obj, 0ULL, (int )(sizeof(ace_t ) * (unsigned int )aclcnt));
  } else {
#line 1188
    if (aclcnt > 6) {
#line 1189
      dmu_tx_hold_write(tx, 0xffffffffffffffffULL, 0ULL, (int )(sizeof(ace_t ) * (unsigned int )aclcnt));
    }
  }
#line 1192
  error = dmu_tx_assign(tx, zfsvfs->z_assign);
#line 1193
  if (error) {
#line 1194
    mutex_exit(& zp->z_acl_lock);
#line 1195
    mutex_exit(& zp->z_lock);
#line 1197
    if (error == 85) {
#line 1197
      if (zfsvfs->z_assign == 2ULL) {
#line 1198
        dmu_tx_wait(tx);
#line 1199
        dmu_tx_abort(tx);
        goto top;
      }
    }
#line 1202
    dmu_tx_abort(tx);
#line 1203
    return (error);
  }
#line 1206
  aclp = zfs_acl_alloc(aclcnt);
#line 1207
  bcopy((void const   *)acep, (void *)aclp->z_acl, sizeof(ace_t ) * (unsigned int )aclcnt);
#line 1208
  aclp->z_acl_count = aclcnt;
#line 1209
  error = zfs_aclset_common(zp, aclp, tx, & inherit);
#line 1210
  if (! (error == 0)) {
#line 1210
    __assert_fail("error == 0", "zfs-fuse/zfs_acl.c", 1210U, "zfs_setacl");
  }
#line 1212
  zfs_acl_free(aclp);
#line 1213
  zfs_log_acl(zilog, tx, 12, zp, aclcnt, acep);
#line 1214
  dmu_tx_commit(tx);
#line 1216
  mutex_exit(& zp->z_acl_lock);
#line 1217
  mutex_exit(& zp->z_lock);
#line 1219
  return (error);
}
}
#line 1222 "zfs-fuse/zfs_acl.c"
static int zfs_ace_access(ace_t *zacep , int *working_mode ) 
{ 

  {
#line 1225
  if (*working_mode == 0) {
#line 1226
    return (0);
  }
#line 1229
  if (zacep->a_access_mask & (unsigned int )*working_mode) {
#line 1230
    if ((int )zacep->a_type == 0) {
#line 1231
      *working_mode = (int )((unsigned int )*working_mode & ~ ((unsigned int )*working_mode & zacep->a_access_mask));
#line 1233
      if (*working_mode == 0) {
#line 1234
        return (0);
      }
    } else {
#line 1235
      if ((int )zacep->a_type == 1) {
#line 1236
        return (13);
      }
    }
  }
#line 1245
  return (-1);
}
}
#line 1249 "zfs-fuse/zfs_acl.c"
static int zfs_zaccess_common(znode_t *zp , int v4_mode , int *working_mode , cred_t *cr ) 
{ zfs_acl_t *aclp ;
  zfsvfs_t *zfsvfs ;
  ace_t *zacep ;
  gid_t gid ;
  int cnt ;
  int i ;
  int error ;
  int access_deny ;
  uint_t entry_type ;
  uid_t uid ;
  uid_t tmp ;
  int tmp___0 ;

  {
#line 1253
  zfsvfs = zp->z_zfsvfs;
#line 1259
  access_deny = -1;
#line 1261
  tmp = crgetuid((cred_t const   *)cr);
#line 1261
  uid = tmp;
#line 1263
  if (zfsvfs->z_assign >= 4ULL) {
#line 1264
    *working_mode = 0;
#line 1265
    return (0);
  }
#line 1268
  *working_mode = v4_mode;
#line 1270
  if (v4_mode & 786710) {
#line 1270
    if (((zp->z_zfsvfs)->z_vfs)->vfs_flag & 1U) {
#line 1270
      if (! ((int )(zp->z_vnode)->v_type == 4)) {
#line 1270
        if (! ((int )(zp->z_vnode)->v_type == 3)) {
#line 1270
          if (! ((int )(zp->z_vnode)->v_type == 6)) {
#line 1273
            return (30);
          }
        }
      }
    }
  }
#line 1276
  mutex_enter(& zp->z_acl_lock);
#line 1278
  error = zfs_acl_node_read(zp, & aclp);
#line 1279
  if (error != 0) {
#line 1280
    mutex_exit(& zp->z_acl_lock);
#line 1281
    return (error);
  }
#line 1285
  zacep = aclp->z_acl;
#line 1286
  cnt = aclp->z_acl_count;
#line 1288
  i = 0;
#line 1288
  while (i != cnt) {
#line 1293
    if ((int )(zacep + i)->a_flags & 8) {
      goto __Cont;
    }
#line 1296
    entry_type = (unsigned int )((int )(zacep + i)->a_flags & 28736);
#line 1297
    switch ((int )entry_type) {
    case 4096: 
#line 1299
    if ((uint64_t )uid == (zp->z_phys)->zp_uid) {
#line 1300
      access_deny = zfs_ace_access(zacep + i, working_mode);
    }
#line 1303
    break;
    case 8256: 
    case 64: 
#line 1309
    if (entry_type == 8256U) {
#line 1310
      gid = (unsigned int )(zp->z_phys)->zp_gid;
    } else {
#line 1312
      gid = (zacep + i)->a_who;
    }
#line 1314
    tmp___0 = groupmember(gid, (cred_t const   *)cr);
#line 1314
    if (tmp___0) {
#line 1315
      access_deny = zfs_ace_access(zacep + i, working_mode);
    }
#line 1318
    break;
    case 16384: 
#line 1320
    access_deny = zfs_ace_access(zacep + i, working_mode);
#line 1321
    break;
    default: ;
#line 1325
    if (entry_type == 0U) {
#line 1326
      if (uid == (zacep + i)->a_who) {
#line 1327
        access_deny = zfs_ace_access(zacep + i, working_mode);
      }
#line 1330
      break;
    }
#line 1332
    zfs_acl_free(aclp);
#line 1333
    mutex_exit(& zp->z_acl_lock);
#line 1334
    return (5);
    }
#line 1337
    if (access_deny != -1) {
#line 1338
      break;
    }
    __Cont: /* CIL Label */ 
#line 1288
    i ++;
  }
#line 1341
  mutex_exit(& zp->z_acl_lock);
#line 1342
  zfs_acl_free(aclp);
#line 1344
  return (access_deny);
}
}
#line 1352 "zfs-fuse/zfs_acl.c"
int zfs_zaccess(struct znode *zp , int mode , cred_t *cr ) 
{ int working_mode ;
  int error ;
  int is_attr ;
  znode_t *xzp ;
  znode_t *check_zp ;
  int tmp ;
  uint32_t tmp___0 ;

  {
#line 1359
  check_zp = zp;
#line 1361
  if ((zp->z_phys)->zp_flags & 1ULL) {
#line 1361
    if ((int )(zp->z_vnode)->v_type == 2) {
#line 1361
      tmp = 1;
    } else {
#line 1361
      tmp = 0;
    }
  } else {
#line 1361
    tmp = 0;
  }
#line 1361
  is_attr = tmp;
#line 1367
  if (is_attr) {
#line 1368
    error = zfs_zget(zp->z_zfsvfs, (zp->z_phys)->zp_parent, & xzp);
#line 1368
    if (error != 0) {
#line 1370
      return (error);
    }
#line 1372
    check_zp = xzp;
#line 1377
    if (mode & 6) {
#line 1378
      mode &= -7;
#line 1379
      mode |= 16;
    }
#line 1382
    if (mode & 33) {
#line 1383
      mode &= -34;
#line 1384
      mode |= 8;
    }
  }
#line 1388
  error = zfs_zaccess_common(check_zp, mode, & working_mode, cr);
#line 1390
  if (error == 30) {
#line 1391
    if (is_attr) {
#line 1392
      vn_rele(xzp->z_vnode);
    }
#line 1393
    return (error);
  }
#line 1396
  if (error) {
#line 1397
    tmp___0 = zfs_v4_to_unix((unsigned int )working_mode);
#line 1397
    working_mode = (int )(tmp___0 << 6);
#line 1398
    error = secpolicy_vnode_access((cred_t const   *)cr, check_zp->z_vnode, (unsigned int )(check_zp->z_phys)->zp_uid,
                                   (unsigned int )working_mode);
  } else {
#line 1396
    if (working_mode) {
#line 1397
      tmp___0 = zfs_v4_to_unix((unsigned int )working_mode);
#line 1397
      working_mode = (int )(tmp___0 << 6);
#line 1398
      error = secpolicy_vnode_access((cred_t const   *)cr, check_zp->z_vnode, (unsigned int )(check_zp->z_phys)->zp_uid,
                                     (unsigned int )working_mode);
    }
  }
#line 1402
  if (is_attr) {
#line 1403
    vn_rele(xzp->z_vnode);
  }
#line 1405
  return (error);
}
}
#line 1415 "zfs-fuse/zfs_acl.c"
int zfs_zaccess_v4_perm(struct znode *zp , int mode , cred_t *cr ) 
{ int working_mode ;
  int tmp ;

  {
#line 1418
  working_mode = 0;
#line 1419
  tmp = zfs_zaccess_common(zp, mode, & working_mode, cr);
#line 1419
  return (tmp);
}
}
#line 1426 "zfs-fuse/zfs_acl.c"
int zfs_zaccess_rwx(struct znode *zp , mode_t mode , cred_t *cr ) 
{ int v4_mode ;
  uint32_t tmp ;
  int tmp___0 ;

  {
#line 1429
  tmp = zfs_unix_to_v4(mode >> 6);
#line 1429
  v4_mode = (int )tmp;
#line 1431
  tmp___0 = zfs_zaccess(zp, v4_mode, cr);
#line 1431
  return (tmp___0);
}
}
#line 1434 "zfs-fuse/zfs_acl.c"
static int zfs_delete_final_check(znode_t *zp , znode_t *dzp , cred_t *cr ) 
{ int error ;

  {
#line 1439
  error = secpolicy_vnode_access((cred_t const   *)cr, zp->z_vnode, (unsigned int )(dzp->z_phys)->zp_uid,
                                 192U);
#line 1442
  if (error == 0) {
#line 1443
    error = zfs_sticky_remove_access(dzp, zp, cr);
  }
#line 1445
  return (error);
}
}
#line 1483 "zfs-fuse/zfs_acl.c"
int zfs_zaccess_delete(struct znode *dzp , struct znode *zp , cred_t *cr ) 
{ int dzp_working_mode ;
  int zp_working_mode ;
  int dzp_error ;
  int zp_error ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1486
  dzp_working_mode = 0;
#line 1487
  zp_working_mode = 0;
#line 1501
  dzp_error = zfs_zaccess_common(dzp, 64, & dzp_working_mode, cr);
#line 1503
  zp_error = zfs_zaccess_common(zp, 65536, & zp_working_mode, cr);
#line 1505
  if (dzp_error == 30) {
#line 1506
    return (dzp_error);
  } else {
#line 1505
    if (zp_error == 30) {
#line 1506
      return (dzp_error);
    }
  }
#line 1512
  if ((dzp_working_mode & 64) == 0) {
#line 1513
    return (0);
  }
#line 1521
  if ((zp_working_mode & 65536) == 0) {
#line 1522
    return (0);
  }
#line 1536
  if (zp_error != 0) {
#line 1536
    if (! (dzp_error != 0)) {
#line 1536
      __assert_fail("zp_error != 0 && dzp_error != 0", "zfs-fuse/zfs_acl.c", 1536U,
                    "zfs_zaccess_delete");
    }
  } else {
#line 1536
    __assert_fail("zp_error != 0 && dzp_error != 0", "zfs-fuse/zfs_acl.c", 1536U,
                  "zfs_zaccess_delete");
  }
#line 1537
  if (dzp_error == 13) {
#line 1538
    tmp = zfs_delete_final_check(zp, dzp, cr);
#line 1538
    return (tmp);
  }
#line 1545
  dzp_error = zfs_zaccess_common(dzp, 34, & dzp_working_mode, cr);
#line 1548
  if (dzp_error == 30) {
#line 1549
    return (dzp_error);
  }
#line 1551
  if ((dzp_working_mode & 34) == 0) {
#line 1552
    tmp___0 = zfs_sticky_remove_access(dzp, zp, cr);
#line 1552
    return (tmp___0);
  }
#line 1558
  if ((dzp_working_mode & 34) != 0) {
#line 1558
    if ((zp_working_mode & 65536) == 0) {
#line 1560
      tmp___1 = zfs_sticky_remove_access(dzp, zp, cr);
#line 1560
      return (tmp___1);
    }
  }
#line 1562
  tmp___2 = zfs_delete_final_check(zp, dzp, cr);
#line 1562
  return (tmp___2);
}
}
#line 1565 "zfs-fuse/zfs_acl.c"
int zfs_zaccess_rename(struct znode *sdzp , struct znode *szp , struct znode *tdzp ,
                       struct znode *tzp , cred_t *cr ) 
{ int add_perm ;
  int error ;

  {
#line 1572
  if ((int )(szp->z_vnode)->v_type == 2) {
#line 1572
    add_perm = 4;
  } else {
#line 1572
    add_perm = 2;
  }
#line 1586
  error = zfs_zaccess_delete(sdzp, szp, cr);
#line 1586
  if (error) {
#line 1587
    return (error);
  }
#line 1592
  if (tzp) {
#line 1593
    error = zfs_zaccess_delete(tdzp, tzp, cr);
#line 1593
    if (error) {
#line 1594
      return (error);
    }
  }
#line 1600
  error = zfs_zaccess(tdzp, add_perm, cr);
#line 1602
  return (error);
}
}
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
#line 1 "zfs_dir.o"
#pragma merger(0,"/tmp/cil-u01NrW1U.i","-pipe,-Wall,-Werror,-std=c99,-Wno-unused,-Wno-missing-braces,-Wno-parentheses,-Wno-uninitialized,-fno-strict-aliasing,-ggdb,-O2")
#line 296 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void bzero(void *__s , size_t __n )  __attribute__((__nonnull__(1))) ;
#line 175 "/usr/include/pthread.h"
extern  __attribute__((__noreturn__)) void pthread_exit(void *__retval ) ;
#line 53 "lib/libsolkerncompat/include/sys/rwlock.h"
extern void rw_enter(krwlock_t *rwlp , krw_t rw ) ;
#line 56
extern void rw_exit(krwlock_t *rwlp ) ;
#line 280 "lib/libsolkerncompat/include/sys/vnode.h"
extern int vn_vfswlock(vnode_t * ) ;
#line 281
extern void vn_vfsunlock(vnode_t *vp ) ;
#line 401 "lib/libzfscommon/include/sys/dmu.h"
extern void dmu_tx_hold_free(dmu_tx_t *tx , uint64_t object , uint64_t off , uint64_t len ) ;
#line 403
extern void dmu_tx_hold_zap(dmu_tx_t *tx , uint64_t object , int add , char *name ) ;
#line 471
extern int dmu_object_info(objset_t *os , uint64_t object , dmu_object_info_t *doi ) ;
#line 47 "lib/libzfscommon/include/sys/list.h"
extern void list_insert_tail(list_t * , void * ) ;
#line 48
extern void list_remove(list_t * , void * ) ;
#line 51
extern void *list_head(list_t * ) ;
#line 42 "lib/libsolkerncompat/include/sys/condvar.h"
extern void cv_init(kcondvar_t *cv , char *name , int type , void *arg ) ;
#line 43
extern void cv_destroy(kcondvar_t *cv ) ;
#line 44
extern void cv_wait(kcondvar_t *cv , kmutex_t *mp ) ;
#line 47
extern void cv_broadcast(kcondvar_t *cv ) ;
#line 33 "lib/libsolkerncompat/include/sys/thread.h"
extern kthread_t *zk_thread_create(void (*func)() , void *arg ) ;
#line 34 "lib/libsolkerncompat/include/sys/cpuvar.h"
extern int ncpus ;
#line 250 "lib/libzfscommon/include/sys/zfs_znode.h"
void zfs_znode_delete(znode_t *zp , dmu_tx_t *tx ) ;
#line 252
int zfs_delete_thread_target(zfsvfs_t *zfsvfs , int nthreads ) ;
#line 253
void zfs_delete_wait_empty(zfsvfs_t *zfsvfs ) ;
#line 259
void zfs_log_create(zilog_t *zilog , dmu_tx_t *tx , int txtype , znode_t *dzp , znode_t *zp ,
                    char *name ) ;
#line 50 "lib/libzfscommon/include/sys/zfs_dir.h"
int zfs_dirent_lock(zfs_dirlock_t **dlpp , znode_t *dzp , char *name , znode_t **zpp ,
                    int flag ) ;
#line 52
void zfs_dirent_unlock(zfs_dirlock_t *dl ) ;
#line 53
int zfs_link_create(zfs_dirlock_t *dl , znode_t *zp , dmu_tx_t *tx , int flag ) ;
#line 54
int zfs_link_destroy(zfs_dirlock_t *dl , znode_t *zp , dmu_tx_t *tx , int flag , int *reaped_ptr ) ;
#line 55
int zfs_dirlook(znode_t *dzp , char *name , vnode_t **vpp ) ;
#line 56
void zfs_mknode(znode_t *dzp , vattr_t *vap , uint64_t *oid , dmu_tx_t *tx , cred_t *cr ,
                uint_t flag , znode_t **zpp , int bonuslen ) ;
#line 58
void zfs_rmnode(znode_t *zp ) ;
#line 59
boolean_t zfs_dirempty(znode_t *dzp ) ;
#line 60
void zfs_dq_add(znode_t *zp , dmu_tx_t *tx ) ;
#line 63
int zfs_make_xattrdir(znode_t *zp , vattr_t *vap , vnode_t **xvpp , cred_t *cr ) ;
#line 144 "lib/libzfscommon/include/sys/zap.h"
extern int zap_lookup(objset_t *ds , uint64_t zapobj , char const   *name , uint64_t integer_size ,
                      uint64_t num_integers , void *buf ) ;
#line 153
extern int zap_add(objset_t *ds , uint64_t zapobj , char const   *name , int integer_size ,
                   uint64_t num_integers , void const   *val , dmu_tx_t *tx ) ;
#line 184
extern int zap_remove(objset_t *ds , uint64_t zapobj , char const   *name , dmu_tx_t *tx ) ;
#line 230
extern void zap_cursor_init(zap_cursor_t *zc , objset_t *ds , uint64_t zapobj ) ;
#line 231
extern void zap_cursor_fini(zap_cursor_t *zc ) ;
#line 237
extern int zap_cursor_retrieve(zap_cursor_t *zc , zap_attribute_t *za ) ;
#line 242
extern void zap_cursor_advance(zap_cursor_t *zc ) ;
#line 79 "zfs-fuse/zfs_dir.c"
int zfs_dirent_lock(zfs_dirlock_t **dlpp , znode_t *dzp , char *name , znode_t **zpp ,
                    int flag ) 
{ zfsvfs_t *zfsvfs ;
  zfs_dirlock_t *dl ;
  uint64_t zoid ;
  int error ;
  vnode_t *vp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  void *tmp___19 ;
  size_t tmp___20 ;
  void *tmp___21 ;

  {
#line 83
  zfsvfs = dzp->z_zfsvfs;
#line 89
  *zpp = (znode_t *)((void *)0);
#line 90
  *dlpp = (zfs_dirlock_t *)((void *)0);
#line 97
  if ((int )*(name + 0) == 46) {
#line 97
    if ((int )*(name + 1) == 0) {
#line 98
      return (17);
    } else {
#line 97
      if ((int )*(name + 1) == 46) {
#line 97
        if ((int )*(name + 2) == 0) {
#line 98
          return (17);
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    }
  } else {
    _L___1: /* CIL Label */ 
#line 97
    if (dzp->z_id == (dzp->z_zfsvfs)->z_root) {
#line 97
      if ((unsigned int )(dzp->z_zfsvfs)->z_ctldir != (unsigned int )((void *)0)) {
#line 97
        if (0) {
#line 97
          __s1_len = strlen((char const   *)name);
#line 97
          __s2_len = strlen(".zfs");
#line 97
          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
            goto _L___0;
          } else {
#line 97
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 97
              if (! ((unsigned int )((void const   *)(".zfs" + 1)) - (unsigned int )((void const   *)".zfs") == 1U)) {
#line 97
                tmp___8 = 1;
              } else {
#line 97
                if (__s2_len >= 4U) {
#line 97
                  tmp___8 = 1;
                } else {
#line 97
                  tmp___8 = 0;
                }
              }
            } else {
#line 97
              tmp___8 = 0;
            }
          }
#line 97
          if (tmp___8) {
#line 97
            tmp___4 = __builtin_strcmp((char const   *)name, ".zfs");
          } else {
#line 97
            tmp___7 = __builtin_strcmp((char const   *)name, ".zfs");
#line 97
            tmp___4 = tmp___7;
          }
        } else {
#line 97
          tmp___7 = __builtin_strcmp((char const   *)name, ".zfs");
#line 97
          tmp___4 = tmp___7;
        }
#line 97
        if (tmp___4 == 0) {
#line 98
          return (17);
        }
      }
    }
  }
#line 103
  mutex_enter(& dzp->z_lock);
#line 104
  while (1) {
#line 105
    if (dzp->z_reap) {
#line 106
      mutex_exit(& dzp->z_lock);
#line 107
      return (2);
    }
#line 109
    dl = dzp->z_dirlocks;
#line 109
    while ((unsigned int )dl != (unsigned int )((void *)0)) {
#line 110
      if (0) {
#line 110
        __s1_len___0 = strlen((char const   *)name);
#line 110
        __s2_len___0 = strlen((char const   *)dl->dl_name);
#line 110
        if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
          goto _L___3;
        } else {
#line 110
          if (__s1_len___0 >= 4U) {
            _L___3: /* CIL Label */ 
#line 110
            if (! ((unsigned int )((void const   *)(dl->dl_name + 1)) - (unsigned int )((void const   *)dl->dl_name) == 1U)) {
#line 110
              tmp___18 = 1;
            } else {
#line 110
              if (__s2_len___0 >= 4U) {
#line 110
                tmp___18 = 1;
              } else {
#line 110
                tmp___18 = 0;
              }
            }
          } else {
#line 110
            tmp___18 = 0;
          }
        }
#line 110
        if (tmp___18) {
#line 110
          tmp___14 = __builtin_strcmp((char const   *)name, (char const   *)dl->dl_name);
        } else {
#line 110
          tmp___17 = __builtin_strcmp((char const   *)name, (char const   *)dl->dl_name);
#line 110
          tmp___14 = tmp___17;
        }
      } else {
#line 110
        tmp___17 = __builtin_strcmp((char const   *)name, (char const   *)dl->dl_name);
#line 110
        tmp___14 = tmp___17;
      }
#line 110
      if (tmp___14 == 0) {
#line 111
        break;
      }
#line 109
      dl = dl->dl_next;
    }
#line 112
    if ((unsigned int )dl == (unsigned int )((void *)0)) {
#line 116
      tmp___19 = umem_alloc(sizeof(zfs_dirlock_t ), 256);
#line 116
      dl = (zfs_dirlock_t *)tmp___19;
#line 117
      cv_init(& dl->dl_cv, (char *)((void *)0), 0, (void *)0);
#line 118
      dl->dl_name = name;
#line 119
      dl->dl_sharecnt = 0U;
#line 120
      dl->dl_namesize = (unsigned short)0;
#line 121
      dl->dl_dzp = dzp;
#line 122
      dl->dl_next = dzp->z_dirlocks;
#line 123
      dzp->z_dirlocks = dl;
#line 124
      break;
    }
#line 126
    if (flag & 4) {
#line 126
      if (dl->dl_sharecnt != 0U) {
#line 127
        break;
      }
    }
#line 128
    cv_wait(& dl->dl_cv, & dzp->z_lock);
  }
#line 131
  if (flag & 4) {
#line 131
    (dl->dl_sharecnt) ++;
#line 131
    if (dl->dl_sharecnt > 1U) {
#line 131
      if ((int )dl->dl_namesize == 0) {
#line 140
        tmp___20 = strlen((char const   *)dl->dl_name);
#line 140
        dl->dl_namesize = (unsigned short )(tmp___20 + 1U);
#line 141
        tmp___21 = umem_alloc((unsigned int )dl->dl_namesize, 256);
#line 141
        name = (char *)tmp___21;
#line 142
        bcopy((void const   *)dl->dl_name, (void *)name, (unsigned int )dl->dl_namesize);
#line 143
        dl->dl_name = name;
      }
    }
  }
#line 146
  mutex_exit(& dzp->z_lock);
#line 153
  if (flag & 8) {
#line 154
    zoid = (dzp->z_phys)->zp_xattr;
#line 155
    if (zoid == 0ULL) {
#line 155
      error = 2;
    } else {
#line 155
      error = 0;
    }
  } else {
#line 157
    vp = (vnode_t *)((void *)0);
#line 158
    if ((unsigned int )vp == (unsigned int )((void *)305419896)) {
#line 159
      vn_rele(vp);
#line 160
      error = 2;
    } else {
#line 161
      if (vp) {
#line 162
        if (flag & 1) {
#line 163
          zfs_dirent_unlock(dl);
#line 164
          vn_rele(vp);
#line 165
          return (17);
        }
#line 167
        *dlpp = dl;
#line 168
        *zpp = (znode_t *)vp->v_data;
#line 169
        return (0);
      } else {
#line 171
        error = zap_lookup(zfsvfs->z_os, dzp->z_id, (char const   *)name, 8ULL, 1ULL,
                           (void *)(& zoid));
#line 173
        if (error == 2) {

        }
      }
    }
  }
#line 177
  if (error) {
#line 178
    if (error != 2) {
#line 179
      zfs_dirent_unlock(dl);
#line 180
      return (error);
    } else {
#line 178
      if (flag & 2) {
#line 179
        zfs_dirent_unlock(dl);
#line 180
        return (error);
      }
    }
  } else {
#line 183
    if (flag & 1) {
#line 184
      zfs_dirent_unlock(dl);
#line 185
      return (17);
    }
#line 187
    error = zfs_zget(zfsvfs, zoid, zpp);
#line 188
    if (error) {
#line 189
      zfs_dirent_unlock(dl);
#line 190
      return (error);
    }
#line 192
    if (! (flag & 8)) {

    }
  }
#line 196
  *dlpp = dl;
#line 198
  return (0);
}
}
#line 204 "zfs-fuse/zfs_dir.c"
void zfs_dirent_unlock(zfs_dirlock_t *dl ) 
{ znode_t *dzp ;
  zfs_dirlock_t **prev_dl ;
  zfs_dirlock_t *cur_dl ;

  {
#line 207
  dzp = dl->dl_dzp;
#line 210
  mutex_enter(& dzp->z_lock);
#line 211
  if (dl->dl_sharecnt > 1U) {
#line 212
    (dl->dl_sharecnt) --;
#line 213
    mutex_exit(& dzp->z_lock);
#line 214
    return;
  }
#line 216
  prev_dl = & dzp->z_dirlocks;
#line 217
  while (1) {
#line 217
    cur_dl = *prev_dl;
#line 217
    if (! ((unsigned int )cur_dl != (unsigned int )dl)) {
#line 217
      break;
    }
#line 218
    prev_dl = & cur_dl->dl_next;
  }
#line 219
  *prev_dl = dl->dl_next;
#line 220
  cv_broadcast(& dl->dl_cv);
#line 221
  mutex_exit(& dzp->z_lock);
#line 223
  if ((int )dl->dl_namesize != 0) {
#line 224
    umem_free((void *)dl->dl_name, (unsigned int )dl->dl_namesize);
  }
#line 225
  cv_destroy(& dl->dl_cv);
#line 226
  umem_free((void *)dl, sizeof(*dl));
#line 227
  return;
}
}
#line 237 "zfs-fuse/zfs_dir.c"
int zfs_dirlook(znode_t *dzp , char *name , vnode_t **vpp ) 
{ zfs_dirlock_t *dl ;
  znode_t *zp ;
  int error ;
  zfsvfs_t *zfsvfs ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 242
  error = 0;
#line 244
  if ((int )*(name + 0) == 0) {
#line 245
    *vpp = dzp->z_vnode;
#line 246
    mutex_enter(& (*vpp)->v_lock);
#line 246
    ((*vpp)->v_count) ++;
#line 246
    mutex_exit(& (*vpp)->v_lock);
  } else {
#line 244
    if ((int )*(name + 0) == 46) {
#line 244
      if ((int )*(name + 1) == 0) {
#line 245
        *vpp = dzp->z_vnode;
#line 246
        mutex_enter(& (*vpp)->v_lock);
#line 246
        ((*vpp)->v_count) ++;
#line 246
        mutex_exit(& (*vpp)->v_lock);
      } else {
        goto _L___5;
      }
    } else {
      _L___5: /* CIL Label */ 
#line 247
      if ((int )*(name + 0) == 46) {
#line 247
        if ((int )*(name + 1) == 46) {
#line 247
          if ((int )*(name + 2) == 0) {
#line 248
            zfsvfs = dzp->z_zfsvfs;
#line 253
            if ((dzp->z_phys)->zp_parent == dzp->z_id) {
#line 253
              if ((unsigned int )zfsvfs->z_parent != (unsigned int )zfsvfs) {
#line 255
                abort();
#line 255
                error = 0;
#line 257
                return (error);
              }
            }
#line 259
            rw_enter(& dzp->z_parent_lock, 0);
#line 260
            error = zfs_zget(zfsvfs, (dzp->z_phys)->zp_parent, & zp);
#line 261
            if (error == 0) {
#line 262
              *vpp = zp->z_vnode;
            }
#line 263
            rw_exit(& dzp->z_parent_lock);
          } else {
            goto _L___4;
          }
        } else {
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ 
#line 264
        if (dzp->z_id == (dzp->z_zfsvfs)->z_root) {
#line 264
          if ((unsigned int )(dzp->z_zfsvfs)->z_ctldir != (unsigned int )((void *)0)) {
#line 264
            if (0) {
#line 264
              __s1_len = strlen((char const   *)name);
#line 264
              __s2_len = strlen(".zfs");
#line 264
              if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                goto _L___0;
              } else {
#line 264
                if (__s1_len >= 4U) {
                  _L___0: /* CIL Label */ 
#line 264
                  if (! ((unsigned int )((void const   *)(".zfs" + 1)) - (unsigned int )((void const   *)".zfs") == 1U)) {
#line 264
                    tmp___8 = 1;
                  } else {
#line 264
                    if (__s2_len >= 4U) {
#line 264
                      tmp___8 = 1;
                    } else {
#line 264
                      tmp___8 = 0;
                    }
                  }
                } else {
#line 264
                  tmp___8 = 0;
                }
              }
#line 264
              if (tmp___8) {
#line 264
                tmp___4 = __builtin_strcmp((char const   *)name, ".zfs");
              } else {
#line 264
                tmp___7 = __builtin_strcmp((char const   *)name, ".zfs");
#line 264
                tmp___4 = tmp___7;
              }
            } else {
#line 264
              tmp___7 = __builtin_strcmp((char const   *)name, ".zfs");
#line 264
              tmp___4 = tmp___7;
            }
#line 264
            if (tmp___4 == 0) {
#line 265
              abort();
#line 265
              *vpp = (vnode_t *)((void *)0);
            } else {
              goto _L___2;
            }
          } else {
            goto _L___2;
          }
        } else {
          _L___2: /* CIL Label */ 
#line 267
          error = zfs_dirent_lock(& dl, dzp, name, & zp, 6);
#line 268
          if (error == 0) {
#line 269
            *vpp = zp->z_vnode;
#line 270
            zfs_dirent_unlock(dl);
#line 271
            dzp->z_zn_prefetch = (unsigned char)1;
          }
        }
      }
    }
  }
#line 275
  return (error);
}
}
#line 278 "zfs-fuse/zfs_dir.c"
static char *zfs_dq_hexname(char *namebuf , uint64_t x ) 
{ char *name ;
  char digits[16] ;

  {
#line 281
  name = namebuf + 16;
#line 282
  digits[0] = (char )'0';
#line 282
  digits[1] = (char )'1';
#line 282
  digits[2] = (char )'2';
#line 282
  digits[3] = (char )'3';
#line 282
  digits[4] = (char )'4';
#line 282
  digits[5] = (char )'5';
#line 282
  digits[6] = (char )'6';
#line 282
  digits[7] = (char )'7';
#line 282
  digits[8] = (char )'8';
#line 282
  digits[9] = (char )'9';
#line 282
  digits[10] = (char )'a';
#line 282
  digits[11] = (char )'b';
#line 282
  digits[12] = (char )'c';
#line 282
  digits[13] = (char )'d';
#line 282
  digits[14] = (char )'e';
#line 282
  digits[15] = (char )'f';
#line 284
  *name = (char )'\000';
#line 285
  while (1) {
#line 286
    name --;
#line 286
    *name = digits[x & 15ULL];
#line 287
    x >>= 4;
#line 285
    if (! (x != 0ULL)) {
#line 285
      break;
    }
  }
#line 290
  return (name);
}
}
#line 308 "zfs-fuse/zfs_dir.c"
void zfs_dq_add(znode_t *zp , dmu_tx_t *tx ) 
{ zfsvfs_t *zfsvfs ;
  char obj_name[17] ;
  int error ;
  uint64_t __left ;
  uint64_t __right ;
  char *__buf ;
  void *tmp ;
  char *tmp___0 ;
  uint64_t __left___0 ;
  uint64_t __right___0 ;
  char *__buf___0 ;
  void *tmp___1 ;

  {
#line 311
  zfsvfs = zp->z_zfsvfs;
#line 315
  if (! zp->z_reap) {
#line 315
    __assert_fail("zp->z_reap", "zfs-fuse/zfs_dir.c", 315U, "zfs_dq_add");
  }
#line 316
  while (1) {
#line 316
    __left = (zp->z_phys)->zp_links;
#line 316
    __right = 0ULL;
#line 316
    if (! (__left == __right)) {
#line 316
      tmp = __builtin_alloca(256U);
#line 316
      __buf = (char *)tmp;
#line 316
      snprintf((char * __restrict  )__buf, 256U, (char const   * __restrict  )"%s %s %s (0x%llx %s 0x%llx)",
               "zp->z_phys->zp_links", "==", "0", __left, "==", __right);
#line 316
      while (1) {
#line 316
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                "zfs-fuse/zfs_dir.c", 316, "zfs_dq_add", __buf);
#line 316
        abort();
#line 316
        break;
      }
    }
#line 316
    break;
  }
#line 318
  tmp___0 = zfs_dq_hexname((char *)(obj_name), zp->z_id);
#line 318
  error = zap_add(zfsvfs->z_os, zfsvfs->z_dqueue, (char const   *)tmp___0, 8, 1ULL,
                  (void const   *)(& zp->z_id), tx);
#line 320
  while (1) {
#line 320
    __left___0 = (unsigned long long )error;
#line 320
    __right___0 = 0ULL;
#line 320
    if (! (__left___0 == __right___0)) {
#line 320
      tmp___1 = __builtin_alloca(256U);
#line 320
      __buf___0 = (char *)tmp___1;
#line 320
      snprintf((char * __restrict  )__buf___0, 256U, (char const   * __restrict  )"%s %s %s (0x%llx %s 0x%llx)",
               "error", "==", "0", __left___0, "==", __right___0);
#line 320
      while (1) {
#line 320
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                "zfs-fuse/zfs_dir.c", 320, "zfs_dq_add", __buf___0);
#line 320
        abort();
#line 320
        break;
      }
    }
#line 320
    break;
  }
#line 321
  return;
}
}
#line 332 "zfs-fuse/zfs_dir.c"
static int zfs_purgedir(znode_t *dzp ) 
{ zap_cursor_t zc ;
  zap_attribute_t zap ;
  znode_t *xzp ;
  dmu_tx_t *tx ;
  zfsvfs_t *zfsvfs ;
  zfs_dirlock_t dl ;
  int skipped ;
  int error ;
  uint64_t __left ;
  uint64_t __right ;
  char *__buf ;
  void *tmp ;
  uint64_t __left___0 ;
  uint64_t __right___0 ;
  char *__buf___0 ;
  void *tmp___0 ;

  {
#line 339
  zfsvfs = dzp->z_zfsvfs;
#line 341
  skipped = 0;
#line 345
  zap_cursor_init(& zc, zfsvfs->z_os, dzp->z_id);
#line 345
  while (1) {
#line 345
    error = zap_cursor_retrieve(& zc, & zap);
#line 345
    if (! (error == 0)) {
#line 345
      break;
    }
#line 348
    error = zfs_zget(zfsvfs, zap.za_first_integer, & xzp);
#line 349
    while (1) {
#line 349
      __left = (unsigned long long )error;
#line 349
      __right = 0ULL;
#line 349
      if (! (__left == __right)) {
#line 349
        tmp = __builtin_alloca(256U);
#line 349
        __buf = (char *)tmp;
#line 349
        snprintf((char * __restrict  )__buf, 256U, (char const   * __restrict  )"%s %s %s (0x%llx %s 0x%llx)",
                 "error", "==", "0", __left, "==", __right);
#line 349
        while (1) {
#line 349
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                  "zfs-fuse/zfs_dir.c", 349, "zfs_purgedir", __buf);
#line 349
          abort();
#line 349
          break;
        }
      }
#line 349
      break;
    }
#line 351
    if (! ((int )(xzp->z_vnode)->v_type == 1)) {
#line 351
      if (! ((int )(xzp->z_vnode)->v_type == 5)) {
#line 351
        __assert_fail("(((xzp)->z_vnode)->v_type == VREG) || (((xzp)->z_vnode)->v_type == VLNK)",
                      "zfs-fuse/zfs_dir.c", 352U, "zfs_purgedir");
      }
    }
#line 354
    tx = dmu_tx_create(zfsvfs->z_os);
#line 355
    dmu_tx_hold_bonus(tx, dzp->z_id);
#line 356
    dmu_tx_hold_zap(tx, dzp->z_id, 0, zap.za_name);
#line 357
    dmu_tx_hold_bonus(tx, xzp->z_id);
#line 358
    dmu_tx_hold_zap(tx, zfsvfs->z_dqueue, 0, (char *)((void *)0));
#line 359
    error = dmu_tx_assign(tx, 1ULL);
#line 360
    if (error) {
#line 361
      dmu_tx_abort(tx);
#line 362
      vn_rele(xzp->z_vnode);
#line 363
      skipped ++;
      goto __Cont;
    }
#line 366
    bzero((void *)(& dl), sizeof(dl));
#line 367
    dl.dl_dzp = dzp;
#line 368
    dl.dl_name = zap.za_name;
#line 370
    error = zfs_link_destroy(& dl, xzp, tx, 0, (int *)((void *)0));
#line 371
    while (1) {
#line 371
      __left___0 = (unsigned long long )error;
#line 371
      __right___0 = 0ULL;
#line 371
      if (! (__left___0 == __right___0)) {
#line 371
        tmp___0 = __builtin_alloca(256U);
#line 371
        __buf___0 = (char *)tmp___0;
#line 371
        snprintf((char * __restrict  )__buf___0, 256U, (char const   * __restrict  )"%s %s %s (0x%llx %s 0x%llx)",
                 "error", "==", "0", __left___0, "==", __right___0);
#line 371
        while (1) {
#line 371
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                  "zfs-fuse/zfs_dir.c", 371, "zfs_purgedir", __buf___0);
#line 371
          abort();
#line 371
          break;
        }
      }
#line 371
      break;
    }
#line 372
    dmu_tx_commit(tx);
#line 374
    vn_rele(xzp->z_vnode);
    __Cont: /* CIL Label */ 
#line 345
    zap_cursor_advance(& zc);
  }
#line 376
  zap_cursor_fini(& zc);
#line 377
  if (! (error == 2)) {
#line 377
    __assert_fail("error == 2", "zfs-fuse/zfs_dir.c", 377U, "zfs_purgedir");
  }
#line 378
  return (skipped);
}
}
#line 387 "zfs-fuse/zfs_dir.c"
static int zfs_drain_dq(zfsvfs_t *zfsvfs ) 
{ zap_cursor_t zc ;
  zap_attribute_t zap ;
  dmu_object_info_t doi ;
  znode_t *zp ;
  int error ;
  int tmp ;
  int tmp___0 ;

  {
#line 399
  zap_cursor_init(& zc, zfsvfs->z_os, zfsvfs->z_dqueue);
#line 399
  while (1) {
#line 399
    tmp___0 = zap_cursor_retrieve(& zc, & zap);
#line 399
    if (! (tmp___0 == 0)) {
#line 399
      break;
    }
#line 407
    tmp = zfs_delete_thread_target(zfsvfs, -1);
#line 407
    if (tmp != 0) {
#line 408
      return (0);
    }
#line 414
    error = dmu_object_info(zfsvfs->z_os, zap.za_first_integer, & doi);
#line 416
    if (error != 0) {
      goto __Cont;
    }
#line 419
    if (! ((int )doi.doi_type == 19)) {
#line 419
      if (! ((int )doi.doi_type == 20)) {
#line 419
        __assert_fail("(doi.doi_type == DMU_OT_PLAIN_FILE_CONTENTS) || (doi.doi_type == DMU_OT_DIRECTORY_CONTENTS)",
                      "zfs-fuse/zfs_dir.c", 420U, "zfs_drain_dq");
      }
    }
#line 425
    error = zfs_zget(zfsvfs, zap.za_first_integer, & zp);
#line 434
    if (error != 0) {
      goto __Cont;
    }
#line 438
    zp->z_reap = (unsigned char)1;
#line 439
    vn_rele(zp->z_vnode);
    __Cont: /* CIL Label */ 
#line 399
    zap_cursor_advance(& zc);
  }
#line 441
  zap_cursor_fini(& zc);
#line 442
  return (1);
}
}
#line 445 "zfs-fuse/zfs_dir.c"
void zfs_delete_thread(void *arg ) 
{ zfsvfs_t *zfsvfs ;
  zfs_delete_t *zd ;
  znode_t *zp ;
  callb_cpr_t cprinfo ;
  int drained ;
  void *tmp ;
  pthread_t tmp___0 ;
  pthread_t tmp___1 ;
  pthread_t tmp___2 ;

  {
#line 448
  zfsvfs = (zfsvfs_t *)arg;
#line 449
  zd = & zfsvfs->z_delete_head;
#line 454
  cprinfo.cc_lockp = & zd->z_mutex;
#line 456
  mutex_enter(& zd->z_mutex);
#line 458
  if (! zd->z_drained) {
#line 458
    if (! zd->z_draining) {
#line 459
      zd->z_draining = (unsigned char)1;
#line 460
      mutex_exit(& zd->z_mutex);
#line 461
      drained = zfs_drain_dq(zfsvfs);
#line 462
      mutex_enter(& zd->z_mutex);
#line 463
      zd->z_draining = (unsigned char)0;
#line 464
      zd->z_drained = (unsigned char )drained;
#line 465
      cv_broadcast(& zd->z_quiesce_cv);
    }
  }
#line 468
  while (zd->z_thread_count <= zd->z_thread_target) {
#line 469
    tmp = list_head(& zd->z_znodes);
#line 469
    zp = (znode_t *)tmp;
#line 470
    if ((unsigned int )zp == (unsigned int )((void *)0)) {
#line 471
      if (! (zd->z_znode_count == 0ULL)) {
#line 471
        __assert_fail("zd->z_znode_count == 0", "zfs-fuse/zfs_dir.c", 471U, "zfs_delete_thread");
      }
#line 472
      tmp___0 = pthread_self();
#line 472
      if (! ((unsigned int )(cprinfo.cc_lockp)->m_owner == (unsigned int )((void *)((unsigned int )tmp___0)))) {
#line 472
        __assert_fail("(((&cprinfo)->cc_lockp)->m_owner == ((void *)(uintptr_t)pthread_self()))",
                      "zfs-fuse/zfs_dir.c", 472U, "zfs_delete_thread");
      }
#line 473
      cv_wait(& zd->z_cv, & zd->z_mutex);
#line 474
      tmp___1 = pthread_self();
#line 474
      if (! ((unsigned int )(cprinfo.cc_lockp)->m_owner == (unsigned int )((void *)((unsigned int )tmp___1)))) {
#line 474
        __assert_fail("(((&cprinfo)->cc_lockp)->m_owner == ((void *)(uintptr_t)pthread_self()))",
                      "zfs-fuse/zfs_dir.c", 474U, "zfs_delete_thread");
      }
#line 475
      continue;
    }
#line 477
    if (! (zd->z_znode_count != 0ULL)) {
#line 477
      __assert_fail("zd->z_znode_count != 0", "zfs-fuse/zfs_dir.c", 477U, "zfs_delete_thread");
    }
#line 478
    list_remove(& zd->z_znodes, (void *)zp);
#line 479
    (zd->z_znode_count) --;
#line 479
    if (zd->z_znode_count == 0ULL) {
#line 480
      cv_broadcast(& zd->z_quiesce_cv);
    }
#line 481
    mutex_exit(& zd->z_mutex);
#line 482
    zfs_rmnode(zp);
#line 483
    zfs_delete_thread_target(zfsvfs, -1);
#line 484
    mutex_enter(& zd->z_mutex);
  }
#line 487
  if (! (zd->z_thread_count != 0U)) {
#line 487
    __assert_fail("zd->z_thread_count != 0", "zfs-fuse/zfs_dir.c", 487U, "zfs_delete_thread");
  }
#line 488
  (zd->z_thread_count) --;
#line 488
  if (zd->z_thread_count == 0U) {
#line 489
    cv_broadcast(& zd->z_cv);
  }
#line 491
  tmp___2 = pthread_self();
#line 491
  if (! ((unsigned int )(cprinfo.cc_lockp)->m_owner == (unsigned int )((void *)((unsigned int )tmp___2)))) {
#line 491
    __assert_fail("(((&cprinfo)->cc_lockp)->m_owner == ((void *)(uintptr_t)pthread_self()))",
                  "zfs-fuse/zfs_dir.c", 491U, "zfs_delete_thread");
  }
#line 491
  mutex_exit(cprinfo.cc_lockp);
#line 492
  pthread_exit((void *)0);
}
}
#line 495 "zfs-fuse/zfs_dir.c"
static int zfs_work_per_thread_shift  =    11;
#line 502 "zfs-fuse/zfs_dir.c"
int zfs_delete_thread_target(zfsvfs_t *zfsvfs , int nthreads ) 
{ zfs_delete_t *zd ;

  {
#line 505
  zd = & zfsvfs->z_delete_head;
#line 507
  mutex_enter(& zd->z_mutex);
#line 509
  if (nthreads == -1) {
#line 510
    if (zd->z_thread_target == 0U) {
#line 511
      mutex_exit(& zd->z_mutex);
#line 512
      return (16);
    }
#line 514
    nthreads = (int )(zd->z_znode_count >> zfs_work_per_thread_shift);
#line 515
    if (nthreads < ncpus << 1) {
#line 515
      nthreads = nthreads;
    } else {
#line 515
      nthreads = ncpus << 1;
    }
#line 516
    if (nthreads > 1) {
#line 516
      nthreads = nthreads;
    } else {
#line 516
      nthreads = 1;
    }
#line 517
    nthreads += ! (! zd->z_draining);
  }
#line 520
  zd->z_thread_target = (unsigned int )nthreads;
#line 522
  while (zd->z_thread_count < zd->z_thread_target) {
#line 523
    zk_thread_create((void (*)())(& zfs_delete_thread), (void *)zfsvfs);
#line 525
    (zd->z_thread_count) ++;
  }
#line 528
  while (1) {
#line 528
    if (zd->z_thread_count > zd->z_thread_target) {
#line 528
      if (! (nthreads == 0)) {
#line 528
        break;
      }
    } else {
#line 528
      break;
    }
#line 529
    cv_broadcast(& zd->z_cv);
#line 530
    cv_wait(& zd->z_cv, & zd->z_mutex);
  }
#line 533
  mutex_exit(& zd->z_mutex);
#line 535
  return (0);
}
}
#line 541 "zfs-fuse/zfs_dir.c"
void zfs_delete_wait_empty(zfsvfs_t *zfsvfs ) 
{ zfs_delete_t *zd ;

  {
#line 544
  zd = & zfsvfs->z_delete_head;
#line 546
  mutex_enter(& zd->z_mutex);
#line 547
  if (! (zd->z_thread_target != 0U)) {
#line 547
    __assert_fail("zd->z_thread_target != 0", "zfs-fuse/zfs_dir.c", 547U, "zfs_delete_wait_empty");
  }
#line 548
  while (1) {
#line 548
    if (! (! zd->z_drained)) {
#line 548
      if (! (zd->z_znode_count != 0ULL)) {
#line 548
        break;
      }
    }
#line 549
    if (! (zd->z_thread_target != 0U)) {
#line 549
      __assert_fail("zd->z_thread_target != 0", "zfs-fuse/zfs_dir.c", 549U, "zfs_delete_wait_empty");
    }
#line 550
    cv_wait(& zd->z_quiesce_cv, & zd->z_mutex);
  }
#line 552
  mutex_exit(& zd->z_mutex);
#line 553
  return;
}
}
#line 555 "zfs-fuse/zfs_dir.c"
void zfs_rmnode(znode_t *zp ) 
{ zfsvfs_t *zfsvfs ;
  objset_t *os ;
  znode_t *xzp ;
  char obj_name[17] ;
  dmu_tx_t *tx ;
  uint64_t acl_obj ;
  int error ;
  zfs_delete_t *delq ;
  int tmp ;
  zfs_delete_t *delq___0 ;
  char *tmp___0 ;
  uint64_t __left ;
  uint64_t __right ;
  char *__buf ;
  void *tmp___1 ;

  {
#line 558
  zfsvfs = zp->z_zfsvfs;
#line 559
  os = zfsvfs->z_os;
#line 560
  xzp = (znode_t *)((void *)0);
#line 566
  if (! ((zp->z_vnode)->v_count == 0U)) {
#line 566
    __assert_fail("((zp)->z_vnode)->v_count == 0", "zfs-fuse/zfs_dir.c", 566U, "zfs_rmnode");
  }
#line 567
  if (! ((zp->z_phys)->zp_links == 0ULL)) {
#line 567
    __assert_fail("zp->z_phys->zp_links == 0", "zfs-fuse/zfs_dir.c", 567U, "zfs_rmnode");
  }
#line 572
  if ((int )(zp->z_vnode)->v_type == 2) {
#line 572
    if ((zp->z_phys)->zp_flags & 1ULL) {
#line 573
      tmp = zfs_purgedir(zp);
#line 573
      if (tmp != 0) {
#line 574
        delq = & zfsvfs->z_delete_head;
#line 580
        mutex_enter(& delq->z_mutex);
#line 581
        list_insert_tail(& delq->z_znodes, (void *)zp);
#line 582
        (delq->z_znode_count) ++;
#line 583
        mutex_exit(& delq->z_mutex);
#line 584
        return;
      }
    }
  }
#line 590
  if ((zp->z_phys)->zp_xattr) {
#line 591
    error = zfs_zget(zfsvfs, (zp->z_phys)->zp_xattr, & xzp);
#line 592
    if (! (error == 0)) {
#line 592
      __assert_fail("error == 0", "zfs-fuse/zfs_dir.c", 592U, "zfs_rmnode");
    }
  }
#line 595
  acl_obj = (zp->z_phys)->zp_acl.z_acl_extern_obj;
#line 600
  tx = dmu_tx_create(os);
#line 601
  dmu_tx_hold_free(tx, zp->z_id, 0ULL, 0xffffffffffffffffULL);
#line 602
  dmu_tx_hold_zap(tx, zfsvfs->z_dqueue, 0, (char *)((void *)0));
#line 603
  if (xzp) {
#line 604
    dmu_tx_hold_bonus(tx, xzp->z_id);
#line 605
    dmu_tx_hold_zap(tx, zfsvfs->z_dqueue, 1, (char *)((void *)0));
  }
#line 607
  if (acl_obj) {
#line 608
    dmu_tx_hold_free(tx, acl_obj, 0ULL, 0xffffffffffffffffULL);
  }
#line 609
  error = dmu_tx_assign(tx, 1ULL);
#line 610
  if (error) {
#line 611
    delq___0 = & zfsvfs->z_delete_head;
#line 613
    dmu_tx_abort(tx);
#line 619
    mutex_enter(& delq___0->z_mutex);
#line 620
    list_insert_tail(& delq___0->z_znodes, (void *)zp);
#line 621
    (delq___0->z_znode_count) ++;
#line 622
    mutex_exit(& delq___0->z_mutex);
#line 623
    return;
  }
#line 626
  if (xzp) {
#line 627
    dmu_buf_will_dirty(xzp->z_dbuf, tx);
#line 628
    mutex_enter(& xzp->z_lock);
#line 629
    xzp->z_reap = (unsigned char)1;
#line 630
    (xzp->z_phys)->zp_links = 0ULL;
#line 631
    mutex_exit(& xzp->z_lock);
#line 632
    zfs_dq_add(xzp, tx);
  }
#line 638
  tmp___0 = zfs_dq_hexname((char *)(obj_name), zp->z_id);
#line 638
  error = zap_remove(os, zfsvfs->z_dqueue, (char const   *)tmp___0, tx);
#line 640
  while (1) {
#line 640
    __left = (unsigned long long )error;
#line 640
    __right = 0ULL;
#line 640
    if (! (__left == __right)) {
#line 640
      tmp___1 = __builtin_alloca(256U);
#line 640
      __buf = (char *)tmp___1;
#line 640
      snprintf((char * __restrict  )__buf, 256U, (char const   * __restrict  )"%s %s %s (0x%llx %s 0x%llx)",
               "error", "==", "0", __left, "==", __right);
#line 640
      while (1) {
#line 640
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                "zfs-fuse/zfs_dir.c", 640, "zfs_rmnode", __buf);
#line 640
        abort();
#line 640
        break;
      }
    }
#line 640
    break;
  }
#line 642
  zfs_znode_delete(zp, tx);
#line 644
  dmu_tx_commit(tx);
#line 646
  if (xzp) {
#line 647
    vn_rele(xzp->z_vnode);
  }
#line 648
  return;
}
}
#line 653 "zfs-fuse/zfs_dir.c"
int zfs_link_create(zfs_dirlock_t *dl , znode_t *zp , dmu_tx_t *tx , int flag ) 
{ znode_t *dzp ;
  vnode_t *vp ;
  int zp_is_dir ;
  int error ;

  {
#line 656
  dzp = dl->dl_dzp;
#line 657
  vp = zp->z_vnode;
#line 658
  zp_is_dir = (int )vp->v_type == 2;
#line 661
  dmu_buf_will_dirty(zp->z_dbuf, tx);
#line 662
  mutex_enter(& zp->z_lock);
#line 664
  if (! (flag & 16)) {
#line 665
    if (zp->z_reap) {
#line 666
      if (! (! (flag & 3))) {
#line 666
        __assert_fail("!(flag & (0x0001 | 0x0002))", "zfs-fuse/zfs_dir.c", 666U, "zfs_link_create");
      }
#line 667
      mutex_exit(& zp->z_lock);
#line 668
      return (2);
    }
#line 670
    ((zp->z_phys)->zp_links) ++;
  }
#line 672
  (zp->z_phys)->zp_parent = dzp->z_id;
#line 674
  if (! (flag & 1)) {
#line 675
    zfs_time_stamper_locked(zp, 1024U, tx);
  }
#line 676
  mutex_exit(& zp->z_lock);
#line 678
  dmu_buf_will_dirty(dzp->z_dbuf, tx);
#line 679
  mutex_enter(& dzp->z_lock);
#line 680
  ((dzp->z_phys)->zp_size) ++;
#line 681
  (dzp->z_phys)->zp_links += (uint64_t )zp_is_dir;
#line 682
  zfs_time_stamper_locked(dzp, 1536U, tx);
#line 683
  mutex_exit(& dzp->z_lock);
#line 685
  error = zap_add((zp->z_zfsvfs)->z_os, dzp->z_id, (char const   *)dl->dl_name, 8,
                  1ULL, (void const   *)(& zp->z_id), tx);
#line 687
  if (! (error == 0)) {
#line 687
    __assert_fail("error == 0", "zfs-fuse/zfs_dir.c", 687U, "zfs_link_create");
  }
#line 691
  return (0);
}
}
#line 701 "zfs-fuse/zfs_dir.c"
int zfs_link_destroy(zfs_dirlock_t *dl , znode_t *zp , dmu_tx_t *tx , int flag , int *reaped_ptr ) 
{ znode_t *dzp ;
  vnode_t *vp ;
  int zp_is_dir ;
  int reaped ;
  int error ;
  int tmp ;
  boolean_t tmp___0 ;

  {
#line 705
  dzp = dl->dl_dzp;
#line 706
  vp = zp->z_vnode;
#line 707
  zp_is_dir = (int )vp->v_type == 2;
#line 708
  reaped = 0;
#line 713
  if (! (flag & 16)) {
#line 714
    dmu_buf_will_dirty(zp->z_dbuf, tx);
#line 716
    tmp = vn_vfswlock(vp);
#line 716
    if (tmp) {
#line 717
      return (16);
    }
#line 724
    mutex_enter(& zp->z_lock);
#line 725
    if (zp_is_dir) {
#line 725
      tmp___0 = zfs_dirempty(zp);
#line 725
      if (! tmp___0) {
#line 726
        mutex_exit(& zp->z_lock);
#line 727
        vn_vfsunlock(vp);
#line 728
        return (17);
      }
    }
#line 730
    if (! ((zp->z_phys)->zp_links > (uint64_t )zp_is_dir)) {
#line 730
      __assert_fail("zp->z_phys->zp_links > zp_is_dir", "zfs-fuse/zfs_dir.c", 730U,
                    "zfs_link_destroy");
    }
#line 731
    ((zp->z_phys)->zp_links) --;
#line 731
    if ((zp->z_phys)->zp_links == (uint64_t )zp_is_dir) {
#line 732
      zp->z_reap = (unsigned char)1;
#line 733
      (zp->z_phys)->zp_links = 0ULL;
#line 734
      reaped = 1;
    } else {
#line 736
      zfs_time_stamper_locked(zp, 1024U, tx);
    }
#line 738
    mutex_exit(& zp->z_lock);
#line 739
    vn_vfsunlock(vp);
  }
#line 742
  dmu_buf_will_dirty(dzp->z_dbuf, tx);
#line 743
  mutex_enter(& dzp->z_lock);
#line 744
  ((dzp->z_phys)->zp_size) --;
#line 745
  (dzp->z_phys)->zp_links -= (uint64_t )zp_is_dir;
#line 746
  zfs_time_stamper_locked(dzp, 1536U, tx);
#line 747
  mutex_exit(& dzp->z_lock);
#line 749
  error = zap_remove((zp->z_zfsvfs)->z_os, dzp->z_id, (char const   *)dl->dl_name,
                     tx);
#line 750
  if (! (error == 0)) {
#line 750
    __assert_fail("error == 0", "zfs-fuse/zfs_dir.c", 750U, "zfs_link_destroy");
  }
#line 752
  if ((unsigned int )reaped_ptr != (unsigned int )((void *)0)) {
#line 753
    *reaped_ptr = reaped;
  } else {
#line 754
    if (reaped) {
#line 755
      zfs_dq_add(zp, tx);
    }
  }
#line 757
  return (0);
}
}
#line 765 "zfs-fuse/zfs_dir.c"
boolean_t zfs_dirempty(znode_t *dzp ) 
{ int tmp ;

  {
#line 768
  if ((dzp->z_phys)->zp_size == 2ULL) {
#line 768
    if ((unsigned int )dzp->z_dirlocks == (unsigned int )((zfs_dirlock_t *)0)) {
#line 768
      tmp = 1;
    } else {
#line 768
      tmp = 0;
    }
  } else {
#line 768
    tmp = 0;
  }
#line 768
  return ((enum boolean )tmp);
}
}
#line 771 "zfs-fuse/zfs_dir.c"
int zfs_make_xattrdir(znode_t *zp , vattr_t *vap , vnode_t **xvpp , cred_t *cr ) 
{ zfsvfs_t *zfsvfs ;
  znode_t *xzp ;
  dmu_tx_t *tx ;
  uint64_t xoid ;
  int error ;

  {
#line 774
  zfsvfs = zp->z_zfsvfs;
#line 780
  *xvpp = (vnode_t *)((void *)0);
#line 782
  error = zfs_zaccess(zp, 16, cr);
#line 782
  if (error) {
#line 783
    return (error);
  }
#line 785
  tx = dmu_tx_create(zfsvfs->z_os);
#line 786
  dmu_tx_hold_bonus(tx, zp->z_id);
#line 787
  dmu_tx_hold_zap(tx, 0xffffffffffffffffULL, 0, (char *)((void *)0));
#line 788
  error = dmu_tx_assign(tx, zfsvfs->z_assign);
#line 789
  if (error) {
#line 790
    if (error == 85) {
#line 790
      if (zfsvfs->z_assign == 2ULL) {
#line 791
        dmu_tx_wait(tx);
      }
    }
#line 792
    dmu_tx_abort(tx);
#line 793
    return (error);
  }
#line 795
  zfs_mknode(zp, vap, & xoid, tx, cr, 2U, & xzp, 0);
#line 796
  if (! (xzp->z_id == xoid)) {
#line 796
    __assert_fail("xzp->z_id == xoid", "zfs-fuse/zfs_dir.c", 796U, "zfs_make_xattrdir");
  }
#line 797
  if (! ((xzp->z_phys)->zp_parent == zp->z_id)) {
#line 797
    __assert_fail("xzp->z_phys->zp_parent == zp->z_id", "zfs-fuse/zfs_dir.c", 797U,
                  "zfs_make_xattrdir");
  }
#line 798
  dmu_buf_will_dirty(zp->z_dbuf, tx);
#line 799
  (zp->z_phys)->zp_xattr = xoid;
#line 801
  zfs_log_create(zfsvfs->z_log, tx, 3, zp, xzp, (char *)"");
#line 802
  dmu_tx_commit(tx);
#line 804
  *xvpp = xzp->z_vnode;
#line 806
  return (0);
}
}
#line 895 "zfs-fuse/zfs_dir.c"
int zfs_sticky_remove_access(znode_t *zdp , znode_t *zp , cred_t *cr ) 
{ uid_t uid ;
  int tmp___0 ;
  uid_t tmp___1 ;
  int tmp___2 ;

  {
#line 900
  if ((zdp->z_zfsvfs)->z_assign >= 4ULL) {
#line 901
    return (0);
  }
#line 903
  if (((zdp->z_phys)->zp_mode & 512ULL) == 0ULL) {
#line 908
    return (0);
  } else {
#line 903
    uid = crgetuid((cred_t const   *)cr);
#line 903
    if ((uint64_t )uid == (zdp->z_phys)->zp_uid) {
#line 908
      return (0);
    } else {
#line 903
      if ((uint64_t )uid == (zp->z_phys)->zp_uid) {
#line 908
        return (0);
      } else {
#line 903
        if ((int )(zp->z_vnode)->v_type == 1) {
#line 903
          tmp___2 = zfs_zaccess(zp, 2, cr);
#line 903
          if (tmp___2 == 0) {
#line 908
            return (0);
          } else {
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 910
          tmp___1 = crgetuid((cred_t const   *)cr);
#line 910
          if (tmp___1 == 0U) {
#line 910
            tmp___0 = 0;
          } else {
#line 910
            tmp___0 = 13;
          }
#line 910
          return (tmp___0);
        }
      }
    }
  }
}
}
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned int  ) ;  */
/* compiler builtin: 
   char *__builtin_strncat(char * , char const   * , unsigned int  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 1 "zfs_ioctl.o"
#pragma merger(0,"/tmp/cil-eFX7p18d.i","-pipe,-Wall,-Werror,-std=c99,-Wno-unused,-Wno-missing-braces,-Wno-parentheses,-Wno-uninitialized,-fno-strict-aliasing,-ggdb,-O2")
#line 355 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 446 "lib/libsolkerncompat/include/sys/vnode.h"
extern int fop_seek(vnode_t * , offset_t  , offset_t * ) ;
#line 46 "lib/libsolkerncompat/include/sys/file.h"
file_t *getf(int fd ) ;
#line 47
void releasef(int fd ) ;
#line 170 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 47 "lib/libsolkerncompat/include/sys/systm.h"
extern void delay(clock_t ticks ) ;
#line 86
int xcopyin(void const   *src , void *dest , size_t size ) ;
#line 87
int xcopyout(void const   *src , void *dest , size_t size ) ;
#line 38 "lib/libsolkerncompat/include/sys/cmn_err.h"
extern void cmn_err(int  , char const   *  , ...) ;
#line 154 "lib/libzfscommon/include/sys/dmu.h"
extern int dmu_objset_open(char const   *name , dmu_objset_type_t type , int mode ,
                           objset_t **osp ) ;
#line 156
extern void dmu_objset_close(objset_t *os ) ;
#line 158
extern int dmu_objset_create(char const   *name , dmu_objset_type_t type , objset_t *clone_parent ,
                             void (*func)(objset_t *os , void *arg , dmu_tx_t *tx ) ,
                             void *arg ) ;
#line 161
extern int dmu_objset_destroy(char const   *name ) ;
#line 162
extern int dmu_snapshots_destroy(char *fsname , char *snapname ) ;
#line 163
extern int dmu_objset_rollback(char const   *name ) ;
#line 164
extern int dmu_objset_snapshot(char *fsname , char *snapname , boolean_t recursive ) ;
#line 165
extern int dmu_objset_rename(char const   *name , char const   *newname ) ;
#line 166
extern int dmu_objset_find(char *name , int (*func)(char * , void * ) , void *arg ,
                           int flags ) ;
#line 489
extern void dmu_objset_fast_stat(objset_t *os , dmu_objset_stats_t *stat ) ;
#line 495
extern void dmu_objset_stats(objset_t *os , struct nvlist *nv ) ;
#line 521
extern struct spa *dmu_objset_spa(objset_t *os ) ;
#line 526
extern dmu_objset_type_t dmu_objset_type(objset_t *os ) ;
#line 528
extern int dmu_snapshot_list_next(objset_t *os , int namelen , char *name , uint64_t *id ,
                                  uint64_t *offp ) ;
#line 530
extern int dmu_dir_list_next(objset_t *os , int namelen , char *name , uint64_t *idp ,
                             uint64_t *offp ) ;
#line 570
extern int dmu_sendbackup(objset_t *tosnap , objset_t *fromsnap , struct vnode *vp ) ;
#line 571
extern int dmu_recvbackup(char *tosnap , struct drr_begin *drrb , uint64_t *sizep ,
                          boolean_t force , struct vnode *vp , uint64_t voffset ) ;
#line 151 "lib/libnvpair/include/sys/nvpair.h"
extern int nvlist_alloc(nvlist_t ** , uint_t  , int  ) ;
#line 152
extern void nvlist_free(nvlist_t * ) ;
#line 153
extern int nvlist_size(nvlist_t * , size_t * , int  ) ;
#line 154
extern int nvlist_pack(nvlist_t * , char ** , size_t * , int  , int  ) ;
#line 155
extern int nvlist_unpack(char * , size_t  , nvlist_t ** , int  ) ;
#line 206
extern int nvlist_lookup_uint64(nvlist_t * , char const   * , uint64_t * ) ;
#line 227
extern nvpair_t *nvlist_next_nvpair(nvlist_t *nvl , nvpair_t * ) ;
#line 228
extern char *nvpair_name(nvpair_t * ) ;
#line 229
extern data_type_t nvpair_type(nvpair_t * ) ;
#line 239
extern int nvpair_value_uint64(nvpair_t * , uint64_t * ) ;
#line 240
extern int nvpair_value_string(nvpair_t * , char ** ) ;
#line 109 "lib/libzfscommon/include/sys/fs/zfs.h"
extern zfs_prop_t zfs_name_to_prop(char const   * ) ;
#line 110
extern boolean_t zfs_prop_user(char const   * ) ;
#line 115
extern int zfs_prop_inheritable(zfs_prop_t  ) ;
#line 117
extern int zfs_prop_index_to_string(zfs_prop_t  , uint64_t  , char const   ** ) ;
#line 317 "lib/libzfscommon/include/sys/spa.h"
extern int spa_open(char const   *pool , spa_t ** , void *tag ) ;
#line 318
extern int spa_get_stats(char const   *pool , nvlist_t **config , char *altroot ,
                         size_t buflen ) ;
#line 320
extern int spa_create(char const   *pool , nvlist_t *config , char const   *altroot ) ;
#line 321
extern int spa_import(char const   *pool , nvlist_t *config , char const   *altroot ) ;
#line 322
extern nvlist_t *spa_tryimport(nvlist_t *tryconfig ) ;
#line 323
extern int spa_destroy(char *pool ) ;
#line 324
extern int spa_export(char *pool , nvlist_t **oldconfig ) ;
#line 339
extern int spa_vdev_add(spa_t *spa , nvlist_t *nvroot ) ;
#line 340
extern int spa_vdev_attach(spa_t *spa , uint64_t guid , nvlist_t *nvroot , int replacing ) ;
#line 342
extern int spa_vdev_detach(spa_t *spa , uint64_t guid , int replace_done ) ;
#line 343
extern int spa_vdev_remove(spa_t *spa , uint64_t guid , boolean_t unspare ) ;
#line 344
extern int spa_vdev_setpath(spa_t *spa , uint64_t guid , char const   *newpath ) ;
#line 353
extern int spa_scrub(spa_t *spa , pool_scrub_type_t type , boolean_t force ) ;
#line 372
extern nvlist_t *spa_all_configs(uint64_t * ) ;
#line 390
extern void spa_close(spa_t *spa , void *tag ) ;
#line 394
extern void spa_config_enter(spa_t *spa , krw_t rw , void *tag ) ;
#line 395
extern void spa_config_exit(spa_t *spa , void *tag ) ;
#line 408
extern void spa_altroot(spa_t * , char * , size_t  ) ;
#line 425
extern int spa_busy(void) ;
#line 434
extern void spa_freeze(spa_t *spa ) ;
#line 435
extern void spa_upgrade(spa_t *spa ) ;
#line 437
extern vdev_t *spa_lookup_by_guid(spa_t *spa , uint64_t guid ) ;
#line 443
extern int spa_history_get(spa_t *spa , uint64_t *offset , uint64_t *len_read , char *his_buf ) ;
#line 445
extern int spa_history_log(spa_t *spa , char const   *his_buf , uint64_t pool_create ) ;
#line 455
extern uint64_t spa_get_errlog_size(spa_t *spa ) ;
#line 456
extern int spa_get_errlog(spa_t *spa , void *uaddr , size_t *count ) ;
#line 460
extern int spa_bookmark_name(spa_t *spa , struct zbookmark *zb , nvlist_t *nvl ) ;
#line 465
extern void spa_init(int flags ) ;
#line 466
extern void spa_fini(void) ;
#line 339 "lib/libzfscommon/include/sys/zio.h"
extern uint32_t zio_injection_enabled ;
#line 340
extern int zio_inject_fault(char *name , int flags , int *id , struct zinject_record *record ) ;
#line 342
extern int zio_inject_list_next(int *id , char *name , size_t buflen , struct zinject_record *record ) ;
#line 344
extern int zio_clear_fault(int id ) ;
#line 181 "lib/libzfscommon/include/sys/zfs_ioctl.h"
dev_info_t *zfs_dip  ;
#line 183
int zfs_secpolicy_write(char const   *dataset , cred_t *cr ) ;
#line 184
int zfs_busy(void) ;
#line 87 "lib/libzfscommon/include/sys/vdev.h"
extern int vdev_online(spa_t *spa , uint64_t guid ) ;
#line 88
extern int vdev_offline(spa_t *spa , uint64_t guid , int istmp ) ;
#line 89
extern void vdev_clear(spa_t *spa , vdev_t *vd ) ;
#line 116 "lib/libzfscommon/include/sys/dsl_dir.h"
extern int dsl_dir_set_quota(char const   *ddname , uint64_t quota ) ;
#line 117
extern int dsl_dir_set_reservation(char const   *ddname , uint64_t reservation ) ;
#line 135 "lib/libzfscommon/include/sys/dsl_dataset.h"
extern int dsl_dataset_promote(char const   *name ) ;
#line 60 "lib/libzfscommon/include/sys/dsl_prop.h"
extern int dsl_prop_get_integer(char const   *ddname , char const   *propname , uint64_t *valuep ,
                                char *setpoint ) ;
#line 62
extern int dsl_prop_get_all(objset_t *os , nvlist_t **nvp ) ;
#line 64
extern int dsl_prop_set(char const   *ddname , char const   *propname , int intsz ,
                        int numints , void const   *buf ) ;
#line 32 "lib/libsolkerncompat/include/sys/ddi.h"
extern size_t strlcat(char *dst , char const   *src , size_t dstsize ) ;
#line 41 "lib/libzfscommon/include/sys/zvol.h"
int zvol_get_stats(objset_t *os , nvlist_t *nv ) ;
#line 47 "lib/libzfscommon/include/zfs_namecheck.h"
extern int pool_namecheck(char const   * , namecheck_err_t * , char * ) ;
#line 48
extern int dataset_namecheck(char const   * , namecheck_err_t * , char * ) ;
#line 50
extern int snapshot_namecheck(char const   * , namecheck_err_t * , char * ) ;
#line 49 "lib/libzfscommon/include/zfs_prop.h"
extern zfs_proptype_t zfs_prop_get_type(zfs_prop_t  ) ;
#line 66 "zfs-fuse/zfs_ioctl.c"
void zfs_init(void) ;
#line 67
void zfs_fini(void) ;
#line 69 "zfs-fuse/zfs_ioctl.c"
ldi_ident_t zfs_li  =    (void *)0;
#line 86 "zfs-fuse/zfs_ioctl.c"
void __dprintf(char const   *file , char const   *func , int line , char const   *fmt 
               , ...) 
{ char const   *newfile ;
  char buf[256] ;
  va_list adx ;
  char *tmp ;

  {
#line 96
  tmp = strrchr(file, '/');
#line 96
  newfile = (char const   *)tmp;
#line 97
  if ((unsigned int )newfile != (unsigned int )((void *)0)) {
#line 98
    newfile ++;
  } else {
#line 100
    newfile = file;
  }
#line 103
  __builtin_va_start(adx, fmt);
#line 104
  vsnprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )fmt,
            adx);
#line 105
  __builtin_va_end(adx);
#line 121
  return;
}
}
#line 128 "zfs-fuse/zfs_ioctl.c"
static int zfs_secpolicy_none(char const   *unused1 , cred_t *cr ) 
{ 

  {
#line 131
  return (0);
}
}
#line 139 "zfs-fuse/zfs_ioctl.c"
static int zfs_secpolicy_read(char const   *dataset , cred_t *cr ) 
{ 

  {
#line 144
  return (0);
#line 146
  return (2);
}
}
#line 149 "zfs-fuse/zfs_ioctl.c"
static int zfs_dozonecheck(char const   *dataset , cred_t *cr ) 
{ uint64_t zoned ;
  int writable ;
  int tmp ;

  {
#line 153
  writable = 1;
#line 163
  tmp = dsl_prop_get_integer(dataset, "zoned", & zoned, (char *)((void *)0));
#line 163
  if (tmp) {
#line 164
    return (2);
  }
#line 184
  return (0);
}
}
#line 191 "zfs-fuse/zfs_ioctl.c"
int zfs_secpolicy_write(char const   *dataset , cred_t *cr ) 
{ int error ;

  {
#line 196
  error = zfs_dozonecheck(dataset, cr);
#line 196
  if (error) {
#line 197
    return (error);
  }
#line 199
  return (0);
}
}
#line 206 "zfs-fuse/zfs_ioctl.c"
static int zfs_secpolicy_parent(char const   *dataset , cred_t *cr ) 
{ char parentname[256] ;
  char *cp ;
  int tmp ;

  {
#line 215
  __builtin_strncpy(parentname, dataset, sizeof(parentname));
#line 216
  cp = strrchr((char const   *)(parentname), '@');
#line 217
  if ((unsigned int )cp != (unsigned int )((void *)0)) {
#line 218
    *(cp + 0) = (char )'\000';
  } else {
#line 220
    cp = strrchr((char const   *)(parentname), '/');
#line 221
    if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 222
      return (2);
    }
#line 223
    *(cp + 0) = (char )'\000';
  }
#line 227
  tmp = zfs_secpolicy_write((char const   *)(parentname), cr);
#line 227
  return (tmp);
}
}
#line 235 "zfs-fuse/zfs_ioctl.c"
static int zfs_secpolicy_config(char const   *unused , cred_t *cr ) 
{ 

  {
#line 241
  return (0);
}
}
#line 248 "zfs-fuse/zfs_ioctl.c"
static int zfs_secpolicy_inject(char const   *unused , cred_t *cr ) 
{ 

  {
#line 251
  return (0);
}
}
#line 257 "zfs-fuse/zfs_ioctl.c"
static int get_nvlist(zfs_cmd_t *zc , nvlist_t **nvp ) 
{ char *packed ;
  size_t size ;
  int error ;
  nvlist_t *config ;
  void *tmp ;

  {
#line 263
  config = (nvlist_t *)((void *)0);
#line 268
  size = (unsigned int )zc->zc_nvlist_src_size;
#line 268
  if (size == 0U) {
#line 269
    return (22);
  }
#line 271
  tmp = umem_alloc(size, 256);
#line 271
  packed = (char *)tmp;
#line 273
  error = xcopyin((void const   *)((void *)((unsigned int )zc->zc_nvlist_src)), (void *)packed,
                  size);
#line 273
  if (error != 0) {
#line 275
    umem_free((void *)packed, size);
#line 276
    return (error);
  }
#line 279
  error = nvlist_unpack(packed, size, & config, 0);
#line 279
  if (error != 0) {
#line 280
    umem_free((void *)packed, size);
#line 281
    return (error);
  }
#line 284
  umem_free((void *)packed, size);
#line 286
  *nvp = config;
#line 287
  return (0);
}
}
#line 290 "zfs-fuse/zfs_ioctl.c"
static int put_nvlist(zfs_cmd_t *zc , nvlist_t *nvl ) 
{ char *packed ;
  size_t size ;
  int error ;
  int tmp ;
  int tmp___0 ;

  {
#line 293
  packed = (char *)((void *)0);
#line 297
  while (1) {
#line 297
    tmp = nvlist_size(nvl, & size, 0);
#line 297
    if (! (tmp == 0)) {
#line 297
      while (1) {
#line 297
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                "zfs-fuse/zfs_ioctl.c", 297, "put_nvlist", "nvlist_size(nvl, &size, NV_ENCODE_NATIVE) == 0");
#line 297
        abort();
#line 297
        break;
      }
    }
#line 297
    break;
  }
#line 299
  if ((uint64_t )size > zc->zc_nvlist_dst_size) {
#line 300
    error = 12;
  } else {
#line 302
    while (1) {
#line 302
      tmp___0 = nvlist_pack(nvl, & packed, & size, 0, 256);
#line 302
      if (! (tmp___0 == 0)) {
#line 302
        while (1) {
#line 302
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                  "zfs-fuse/zfs_ioctl.c", 303, "put_nvlist", "nvlist_pack(nvl, &packed, &size, NV_ENCODE_NATIVE, KM_SLEEP) == 0");
#line 302
          abort();
#line 302
          break;
        }
      }
#line 302
      break;
    }
#line 304
    error = xcopyout((void const   *)packed, (void *)((unsigned int )zc->zc_nvlist_dst),
                     size);
#line 306
    umem_free((void *)packed, size);
  }
#line 309
  zc->zc_nvlist_dst_size = (unsigned long long )size;
#line 310
  return (error);
}
}
#line 313 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_pool_create(zfs_cmd_t *zc ) 
{ int error ;
  nvlist_t *config ;
  char *tmp ;

  {
#line 319
  error = get_nvlist(zc, & config);
#line 319
  if (error != 0) {
#line 320
    return (error);
  }
#line 322
  if ((int )zc->zc_value[0] == 0) {
#line 322
    tmp = (char *)((void *)0);
  } else {
#line 322
    tmp = zc->zc_value;
  }
#line 322
  error = spa_create((char const   *)(zc->zc_name), config, (char const   *)tmp);
#line 325
  nvlist_free(config);
#line 327
  return (error);
}
}
#line 330 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_pool_destroy(zfs_cmd_t *zc ) 
{ int tmp ;

  {
#line 333
  tmp = spa_destroy(zc->zc_name);
#line 333
  return (tmp);
}
}
#line 336 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_pool_import(zfs_cmd_t *zc ) 
{ int error ;
  nvlist_t *config ;
  uint64_t guid ;
  char *tmp ;
  int tmp___0 ;

  {
#line 343
  error = get_nvlist(zc, & config);
#line 343
  if (error != 0) {
#line 344
    return (error);
  }
#line 346
  tmp___0 = nvlist_lookup_uint64(config, "pool_guid", & guid);
#line 346
  if (tmp___0 != 0) {
#line 348
    error = 22;
  } else {
#line 346
    if (guid != zc->zc_guid) {
#line 348
      error = 22;
    } else {
#line 350
      if ((int )zc->zc_value[0] == 0) {
#line 350
        tmp = (char *)((void *)0);
      } else {
#line 350
        tmp = zc->zc_value;
      }
#line 350
      error = spa_import((char const   *)(zc->zc_name), config, (char const   *)tmp);
    }
  }
#line 353
  nvlist_free(config);
#line 355
  return (error);
}
}
#line 358 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_pool_export(zfs_cmd_t *zc ) 
{ int tmp ;

  {
#line 361
  tmp = spa_export(zc->zc_name, (nvlist_t **)((void *)0));
#line 361
  return (tmp);
}
}
#line 364 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_pool_configs(zfs_cmd_t *zc ) 
{ nvlist_t *configs ;
  int error ;

  {
#line 370
  configs = spa_all_configs(& zc->zc_cookie);
#line 370
  if ((unsigned int )configs == (unsigned int )((void *)0)) {
#line 371
    return (17);
  }
#line 373
  error = put_nvlist(zc, configs);
#line 375
  nvlist_free(configs);
#line 377
  return (error);
}
}
#line 380 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_pool_stats(zfs_cmd_t *zc ) 
{ nvlist_t *config ;
  int error ;
  int ret ;

  {
#line 385
  ret = 0;
#line 387
  error = spa_get_stats((char const   *)(zc->zc_name), & config, zc->zc_value, sizeof(zc->zc_value));
#line 390
  if ((unsigned int )config != (unsigned int )((void *)0)) {
#line 391
    ret = put_nvlist(zc, config);
#line 392
    nvlist_free(config);
#line 399
    zc->zc_cookie = (unsigned long long )error;
  } else {
#line 401
    ret = error;
  }
#line 404
  return (ret);
}
}
#line 411 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_pool_tryimport(zfs_cmd_t *zc ) 
{ nvlist_t *tryconfig ;
  nvlist_t *config ;
  int error ;

  {
#line 417
  error = get_nvlist(zc, & tryconfig);
#line 417
  if (error != 0) {
#line 418
    return (error);
  }
#line 420
  config = spa_tryimport(tryconfig);
#line 422
  nvlist_free(tryconfig);
#line 424
  if ((unsigned int )config == (unsigned int )((void *)0)) {
#line 425
    return (22);
  }
#line 427
  error = put_nvlist(zc, config);
#line 428
  nvlist_free(config);
#line 430
  return (error);
}
}
#line 433 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_pool_scrub(zfs_cmd_t *zc ) 
{ spa_t *spa ;
  int error ;

  {
#line 439
  error = spa_open((char const   *)(zc->zc_name), & spa, (void *)((char *)"zfs_ioc_pool_scrub"));
#line 439
  if (error != 0) {
#line 440
    return (error);
  }
#line 442
  error = spa_scrub(spa, (enum pool_scrub_type )zc->zc_cookie, 0);
#line 444
  spa_close(spa, (void *)((char *)"zfs_ioc_pool_scrub"));
#line 446
  return (error);
}
}
#line 449 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_pool_freeze(zfs_cmd_t *zc ) 
{ spa_t *spa ;
  int error ;

  {
#line 455
  error = spa_open((char const   *)(zc->zc_name), & spa, (void *)((char *)"zfs_ioc_pool_freeze"));
#line 456
  if (error == 0) {
#line 457
    spa_freeze(spa);
#line 458
    spa_close(spa, (void *)((char *)"zfs_ioc_pool_freeze"));
  }
#line 460
  return (error);
}
}
#line 463 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_pool_upgrade(zfs_cmd_t *zc ) 
{ spa_t *spa ;
  int error ;

  {
#line 469
  error = spa_open((char const   *)(zc->zc_name), & spa, (void *)((char *)"zfs_ioc_pool_upgrade"));
#line 469
  if (error != 0) {
#line 470
    return (error);
  }
#line 472
  spa_upgrade(spa);
#line 474
  spa_close(spa, (void *)((char *)"zfs_ioc_pool_upgrade"));
#line 476
  return (error);
}
}
#line 479 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_pool_get_history(zfs_cmd_t *zc ) 
{ spa_t *spa ;
  char *hist_buf ;
  uint64_t size ;
  int error ;
  void *tmp ;

  {
#line 487
  size = zc->zc_history_len;
#line 487
  if (size == 0ULL) {
#line 488
    return (22);
  }
#line 490
  error = spa_open((char const   *)(zc->zc_name), & spa, (void *)((char *)"zfs_ioc_pool_get_history"));
#line 490
  if (error != 0) {
#line 491
    return (error);
  }
#line 493
  tmp = umem_alloc((unsigned int )size, 256);
#line 493
  hist_buf = (char *)tmp;
#line 494
  error = spa_history_get(spa, & zc->zc_history_offset, & zc->zc_history_len, hist_buf);
#line 494
  if (error == 0) {
#line 496
    error = xcopyout((void const   *)hist_buf, (void *)((char *)((unsigned int )zc->zc_history)),
                     (unsigned int )zc->zc_history_len);
  }
#line 500
  spa_close(spa, (void *)((char *)"zfs_ioc_pool_get_history"));
#line 501
  umem_free((void *)hist_buf, (unsigned int )size);
#line 502
  return (error);
}
}
#line 505 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_pool_log_history(zfs_cmd_t *zc ) 
{ spa_t *spa ;
  char *history_str ;
  size_t size ;
  int error ;
  void *tmp ;

  {
#line 509
  history_str = (char *)((void *)0);
#line 513
  size = (unsigned int )zc->zc_history_len;
#line 514
  if (size == 0U) {
#line 515
    return (22);
  } else {
#line 514
    if (size > 8193U) {
#line 515
      return (22);
    }
  }
#line 517
  error = spa_open((char const   *)(zc->zc_name), & spa, (void *)((char *)"zfs_ioc_pool_log_history"));
#line 517
  if (error != 0) {
#line 518
    return (error);
  }
#line 521
  size ++;
#line 522
  tmp = umem_alloc(size, 256);
#line 522
  history_str = (char *)tmp;
#line 523
  error = xcopyin((void const   *)((void *)((unsigned int )zc->zc_history)), (void *)history_str,
                  size);
#line 523
  if (error != 0) {
#line 525
    spa_close(spa, (void *)((char *)"zfs_ioc_pool_log_history"));
#line 526
    umem_free((void *)history_str, size);
#line 527
    return (error);
  }
#line 529
  *(history_str + (size - 1U)) = (char )'\000';
#line 531
  error = spa_history_log(spa, (char const   *)history_str, zc->zc_history_offset);
#line 533
  spa_close(spa, (void *)((char *)"zfs_ioc_pool_log_history"));
#line 534
  umem_free((void *)history_str, size);
#line 536
  return (error);
}
}
#line 539 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_vdev_add(zfs_cmd_t *zc ) 
{ spa_t *spa ;
  int error ;
  nvlist_t *config ;

  {
#line 546
  error = spa_open((char const   *)(zc->zc_name), & spa, (void *)((char *)"zfs_ioc_vdev_add"));
#line 547
  if (error != 0) {
#line 548
    return (error);
  }
#line 550
  error = get_nvlist(zc, & config);
#line 550
  if (error == 0) {
#line 551
    error = spa_vdev_add(spa, config);
#line 552
    nvlist_free(config);
  }
#line 555
  spa_close(spa, (void *)((char *)"zfs_ioc_vdev_add"));
#line 556
  return (error);
}
}
#line 559 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_vdev_remove(zfs_cmd_t *zc ) 
{ spa_t *spa ;
  int error ;

  {
#line 565
  error = spa_open((char const   *)(zc->zc_name), & spa, (void *)((char *)"zfs_ioc_vdev_remove"));
#line 566
  if (error != 0) {
#line 567
    return (error);
  }
#line 568
  error = spa_vdev_remove(spa, zc->zc_guid, 0);
#line 569
  spa_close(spa, (void *)((char *)"zfs_ioc_vdev_remove"));
#line 570
  return (error);
}
}
#line 573 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_vdev_online(zfs_cmd_t *zc ) 
{ spa_t *spa ;
  int error ;

  {
#line 579
  error = spa_open((char const   *)(zc->zc_name), & spa, (void *)((char *)"zfs_ioc_vdev_online"));
#line 579
  if (error != 0) {
#line 580
    return (error);
  }
#line 581
  error = vdev_online(spa, zc->zc_guid);
#line 582
  spa_close(spa, (void *)((char *)"zfs_ioc_vdev_online"));
#line 583
  return (error);
}
}
#line 586 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_vdev_offline(zfs_cmd_t *zc ) 
{ spa_t *spa ;
  int istmp ;
  int error ;

  {
#line 590
  istmp = (int )zc->zc_cookie;
#line 593
  error = spa_open((char const   *)(zc->zc_name), & spa, (void *)((char *)"zfs_ioc_vdev_offline"));
#line 593
  if (error != 0) {
#line 594
    return (error);
  }
#line 595
  error = vdev_offline(spa, zc->zc_guid, istmp);
#line 596
  spa_close(spa, (void *)((char *)"zfs_ioc_vdev_offline"));
#line 597
  return (error);
}
}
#line 600 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_vdev_attach(zfs_cmd_t *zc ) 
{ spa_t *spa ;
  int replacing ;
  nvlist_t *config ;
  int error ;

  {
#line 604
  replacing = (int )zc->zc_cookie;
#line 608
  error = spa_open((char const   *)(zc->zc_name), & spa, (void *)((char *)"zfs_ioc_vdev_attach"));
#line 608
  if (error != 0) {
#line 609
    return (error);
  }
#line 611
  error = get_nvlist(zc, & config);
#line 611
  if (error == 0) {
#line 612
    error = spa_vdev_attach(spa, zc->zc_guid, config, replacing);
#line 613
    nvlist_free(config);
  }
#line 616
  spa_close(spa, (void *)((char *)"zfs_ioc_vdev_attach"));
#line 617
  return (error);
}
}
#line 620 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_vdev_detach(zfs_cmd_t *zc ) 
{ spa_t *spa ;
  int error ;

  {
#line 626
  error = spa_open((char const   *)(zc->zc_name), & spa, (void *)((char *)"zfs_ioc_vdev_detach"));
#line 626
  if (error != 0) {
#line 627
    return (error);
  }
#line 629
  error = spa_vdev_detach(spa, zc->zc_guid, 0);
#line 631
  spa_close(spa, (void *)((char *)"zfs_ioc_vdev_detach"));
#line 632
  return (error);
}
}
#line 635 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_vdev_setpath(zfs_cmd_t *zc ) 
{ spa_t *spa ;
  char *path ;
  uint64_t guid ;
  int error ;

  {
#line 639
  path = zc->zc_value;
#line 640
  guid = zc->zc_guid;
#line 643
  error = spa_open((char const   *)(zc->zc_name), & spa, (void *)((char *)"zfs_ioc_vdev_setpath"));
#line 644
  if (error != 0) {
#line 645
    return (error);
  }
#line 647
  error = spa_vdev_setpath(spa, guid, (char const   *)path);
#line 648
  spa_close(spa, (void *)((char *)"zfs_ioc_vdev_setpath"));
#line 649
  return (error);
}
}
#line 652 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_objset_stats(zfs_cmd_t *zc ) 
{ objset_t *os ;
  int error ;
  nvlist_t *nv ;
  int tmp ;
  dmu_objset_type_t tmp___0 ;
  struct spa *tmp___1 ;

  {
#line 655
  os = (objset_t *)((void *)0);
  retry: 
#line 660
  error = dmu_objset_open((char const   *)(zc->zc_name), 5, 9, & os);
#line 662
  if (error != 0) {
#line 670
    if (error == 16) {
#line 671
      delay(1L);
      goto retry;
    }
#line 674
    return (error);
  }
#line 677
  dmu_objset_fast_stat(os, & zc->zc_objset_stats);
#line 679
  if (zc->zc_nvlist_dst != 0ULL) {
#line 679
    error = dsl_prop_get_all(os, & nv);
#line 679
    if (error == 0) {
#line 681
      dmu_objset_stats(os, nv);
#line 688
      if (! zc->zc_objset_stats.dds_inconsistent) {
#line 688
        tmp___0 = dmu_objset_type(os);
#line 688
        if ((int )tmp___0 == 3) {
#line 690
          while (1) {
#line 690
            tmp = zvol_get_stats(os, nv);
#line 690
            if (! (tmp == 0)) {
#line 690
              while (1) {
#line 690
                fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                        "zfs-fuse/zfs_ioctl.c", 690, "zfs_ioc_objset_stats", "zvol_get_stats(os, nv) == 0");
#line 690
                abort();
#line 690
                break;
              }
            }
#line 690
            break;
          }
        }
      }
#line 691
      error = put_nvlist(zc, nv);
#line 692
      nvlist_free(nv);
    }
  }
#line 695
  tmp___1 = dmu_objset_spa(os);
#line 695
  spa_altroot(tmp___1, zc->zc_value, sizeof(zc->zc_value));
#line 697
  dmu_objset_close(os);
#line 698
  return (error);
}
}
#line 701 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_dataset_list_next(zfs_cmd_t *zc ) 
{ objset_t *os ;
  int error ;
  char *p ;
  size_t tmp ;
  char *tmp___1 ;

  {
  retry: 
#line 709
  error = dmu_objset_open((char const   *)(zc->zc_name), 5, 9, & os);
#line 711
  if (error != 0) {
#line 719
    if (error == 16) {
#line 720
      delay(1L);
      goto retry;
    }
#line 723
    if (error == 2) {
#line 724
      error = 3;
    }
#line 725
    return (error);
  }
#line 728
  p = strrchr((char const   *)(zc->zc_name), '/');
#line 729
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 730
    strlcat(zc->zc_name, "/", sizeof(zc->zc_name));
  } else {
#line 729
    if ((int )*(p + 1) != 0) {
#line 730
      strlcat(zc->zc_name, "/", sizeof(zc->zc_name));
    }
  }
#line 731
  tmp = strlen((char const   *)(zc->zc_name));
#line 731
  p = zc->zc_name + tmp;
#line 733
  while (1) {
#line 734
    error = dmu_dir_list_next(os, (int )(sizeof(zc->zc_name) - (unsigned int )(p - zc->zc_name)),
                              p, (uint64_t *)((void *)0), & zc->zc_cookie);
#line 737
    if (error == 2) {
#line 738
      error = 3;
    }
#line 733
    if (error == 0) {
#line 733
      break;
    } else {
#line 733
      break;
    }
  }
#line 746
  if (error == 0) {
#line 746
    tmp___1 = __builtin_strchr(zc->zc_name, '$');
#line 746
    if ((unsigned int )tmp___1 == (unsigned int )((void *)0)) {
#line 747
      error = zfs_ioc_objset_stats(zc);
    }
  }
#line 749
  dmu_objset_close(os);
#line 750
  return (error);
}
}
#line 753 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_snapshot_list_next(zfs_cmd_t *zc ) 
{ objset_t *os ;
  int error ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  retry: 
#line 760
  error = dmu_objset_open((char const   *)(zc->zc_name), 5, 9, & os);
#line 762
  if (error != 0) {
#line 770
    if (error == 16) {
#line 771
      delay(1L);
      goto retry;
    }
#line 774
    if (error == 2) {
#line 775
      error = 3;
    }
#line 776
    return (error);
  }
#line 783
  tmp = strlcat(zc->zc_name, "@", sizeof(zc->zc_name));
#line 783
  if (tmp >= 256U) {
#line 784
    dmu_objset_close(os);
#line 785
    return (3);
  }
#line 788
  tmp___0 = strlen((char const   *)(zc->zc_name));
#line 788
  tmp___1 = strlen((char const   *)(zc->zc_name));
#line 788
  error = dmu_snapshot_list_next(os, (int )(sizeof(zc->zc_name) - tmp___1), zc->zc_name + tmp___0,
                                 (uint64_t *)((void *)0), & zc->zc_cookie);
#line 791
  if (error == 2) {
#line 792
    error = 3;
  }
#line 794
  if (error == 0) {
#line 795
    error = zfs_ioc_objset_stats(zc);
  }
#line 797
  dmu_objset_close(os);
#line 798
  return (error);
}
}
#line 801 "zfs-fuse/zfs_ioctl.c"
static int zfs_set_prop_nvlist(char const   *name , dev_t dev , cred_t *cr , nvlist_t *nvl ) 
{ nvpair_t *elem ;
  int error ;
  char const   *propname ;
  zfs_prop_t prop ;
  uint64_t intval ;
  char *strval ;
  char *tmp ;
  boolean_t tmp___0 ;
  data_type_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  zfs_proptype_t tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  char const   *unused ;
  int tmp___11 ;
  zfs_proptype_t tmp___12 ;
  int tmp___13 ;
  data_type_t tmp___14 ;
  data_type_t tmp___15 ;

  {
#line 811
  elem = (nvpair_t *)((void *)0);
#line 812
  while (1) {
#line 812
    elem = nvlist_next_nvpair(nvl, elem);
#line 812
    if (! ((unsigned int )elem != (unsigned int )((void *)0))) {
#line 812
      break;
    }
#line 813
    tmp = nvpair_name(elem);
#line 813
    propname = (char const   *)tmp;
#line 815
    prop = zfs_name_to_prop(propname);
#line 815
    if ((int )prop == -1) {
#line 821
      tmp___0 = zfs_prop_user(propname);
#line 821
      if (tmp___0) {
#line 821
        tmp___1 = nvpair_type(elem);
#line 821
        if ((int )tmp___1 != 9) {
#line 823
          return (22);
        }
      } else {
#line 823
        return (22);
      }
#line 825
      while (1) {
#line 825
        tmp___2 = nvpair_value_string(elem, & strval);
#line 825
        if (! (tmp___2 == 0)) {
#line 825
          while (1) {
#line 825
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                    "zfs-fuse/zfs_ioctl.c", 825, "zfs_set_prop_nvlist", "nvpair_value_string(elem, &strval) == 0");
#line 825
            abort();
#line 825
            break;
          }
        }
#line 825
        break;
      }
#line 826
      tmp___3 = strlen((char const   *)strval);
#line 826
      error = dsl_prop_set(name, propname, 1, (int )(tmp___3 + 1U), (void const   *)strval);
#line 828
      if (error == 0) {
#line 829
        continue;
      } else {
#line 831
        break;
      }
    }
#line 837
    switch ((int )prop) {
    case 23: ;
#line 844
    break;
    case 8: 
#line 847
    error = zfs_dozonecheck(name, cr);
#line 847
    if (error) {
#line 848
      return (error);
    }
#line 868
    break;
    default: ;
#line 871
    break;
    }
#line 874
    switch ((int )prop) {
    case 8: 
#line 876
    error = nvpair_value_uint64(elem, & intval);
#line 876
    if (error != 0) {
#line 879
      return (error);
    } else {
#line 876
      error = dsl_dir_set_quota(name, intval);
#line 876
      if (error != 0) {
#line 879
        return (error);
      }
    }
#line 880
    break;
    case 9: 
#line 883
    error = nvpair_value_uint64(elem, & intval);
#line 883
    if (error != 0) {
#line 886
      return (error);
    } else {
#line 883
      error = dsl_dir_set_reservation(name, intval);
#line 883
      if (error != 0) {
#line 886
        return (error);
      }
    }
#line 887
    break;
    case 10: 
#line 891
    return (6);
#line 892
    break;
    case 11: 
#line 896
    return (6);
#line 897
    break;
    default: 
#line 900
    tmp___15 = nvpair_type(elem);
#line 900
    if ((int )tmp___15 == 9) {
#line 901
      tmp___7 = zfs_prop_get_type(prop);
#line 901
      if ((int )tmp___7 != 1) {
#line 903
        return (22);
      }
#line 904
      while (1) {
#line 904
        tmp___8 = nvpair_value_string(elem, & strval);
#line 904
        if (! (tmp___8 == 0)) {
#line 904
          while (1) {
#line 904
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                    "zfs-fuse/zfs_ioctl.c", 904, "zfs_set_prop_nvlist", "nvpair_value_string(elem, &strval) == 0");
#line 904
            abort();
#line 904
            break;
          }
        }
#line 904
        break;
      }
#line 905
      tmp___9 = strlen((char const   *)strval);
#line 905
      tmp___10 = nvpair_name(elem);
#line 905
      error = dsl_prop_set(name, (char const   *)tmp___10, 1, (int )(tmp___9 + 1U),
                           (void const   *)strval);
#line 905
      if (error != 0) {
#line 908
        return (error);
      }
    } else {
#line 909
      tmp___14 = nvpair_type(elem);
#line 909
      if ((int )tmp___14 == 8) {
#line 912
        while (1) {
#line 912
          tmp___11 = nvpair_value_uint64(elem, & intval);
#line 912
          if (! (tmp___11 == 0)) {
#line 912
            while (1) {
#line 912
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                      "zfs-fuse/zfs_ioctl.c", 912, "zfs_set_prop_nvlist", "nvpair_value_uint64(elem, &intval) == 0");
#line 912
              abort();
#line 912
              break;
            }
          }
#line 912
          break;
        }
#line 914
        tmp___12 = zfs_prop_get_type(prop);
#line 914
        switch ((int )tmp___12) {
        case 0: 
#line 916
        break;
        case 2: 
#line 918
        if (intval > 1ULL) {
#line 919
          return (22);
        }
#line 920
        break;
        case 1: 
#line 922
        return (22);
        case 3: 
#line 924
        tmp___13 = zfs_prop_index_to_string(prop, intval, & unused);
#line 924
        if (tmp___13 != 0) {
#line 926
          return (22);
        }
#line 927
        break;
        default: 
#line 929
        cmn_err(3, "unknown property type");
#line 931
        break;
        }
#line 934
        error = dsl_prop_set(name, propname, 8, 1, (void const   *)(& intval));
#line 934
        if (error != 0) {
#line 936
          return (error);
        }
      } else {
#line 938
        return (22);
      }
    }
#line 940
    break;
    }
  }
#line 944
  return (0);
}
}
#line 947 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_set_prop(zfs_cmd_t *zc ) 
{ nvlist_t *nvl ;
  int error ;
  zfs_prop_t prop ;
  boolean_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 958
  if ((int )zc->zc_value[0] != 0) {
#line 959
    tmp = zfs_prop_user((char const   *)(zc->zc_value));
#line 959
    if (! tmp) {
#line 959
      prop = zfs_name_to_prop((char const   *)(zc->zc_value));
#line 959
      if ((int )prop == -1) {
#line 963
        return (22);
      } else {
#line 959
        tmp___0 = zfs_prop_inheritable(prop);
#line 959
        if (! tmp___0) {
#line 963
          return (22);
        }
      }
    }
#line 965
    tmp___1 = dsl_prop_set((char const   *)(zc->zc_name), (char const   *)(zc->zc_value),
                           0, 0, (void const   *)((void *)0));
#line 965
    return (tmp___1);
  }
#line 968
  error = get_nvlist(zc, & nvl);
#line 968
  if (error != 0) {
#line 969
    return (error);
  }
#line 971
  error = zfs_set_prop_nvlist((char const   *)(zc->zc_name), zc->zc_dev, (cred_t *)((unsigned int )zc->zc_cred),
                              nvl);
#line 973
  nvlist_free(nvl);
#line 974
  return (error);
}
}
#line 977 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_create_minor(zfs_cmd_t *zc ) 
{ 

  {
#line 981
  return (6);
}
}
#line 984 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_remove_minor(zfs_cmd_t *zc ) 
{ 

  {
#line 988
  return (6);
}
}
#line 1018 "zfs-fuse/zfs_ioctl.c"
static void zfs_create_cb(objset_t *os , void *arg , dmu_tx_t *tx ) 
{ 

  {
#line 1022
  return;
}
}
#line 1024 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_create(zfs_cmd_t *zc ) 
{ objset_t *clone___0 ;
  int error ;
  zfs_create_data_t cbdata ;
  void (*cbfunc)(objset_t *os , void *arg , dmu_tx_t *tx ) ;
  dmu_objset_type_t type ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 1028
  error = 0;
#line 1029
  cbdata.zc_cred = (cred_t *)0;
#line 1029
  cbdata.zc_dev = 0ULL;
#line 1029
  cbdata.zc_props = (nvlist_t *)0;
#line 1031
  type = (dmu_objset_type_t )zc->zc_objset_type;
#line 1033
  switch ((int )type) {
  case 2: 
#line 1036
  cbfunc = & zfs_create_cb;
#line 1037
  break;
  case 3: 
#line 1041
  return (38);
  default: 
#line 1043
  cbfunc = (void (*)(objset_t *os , void *arg , dmu_tx_t *tx ))((void *)0);
  }
#line 1045
  tmp___0 = __builtin_strchr(zc->zc_name, '@');
#line 1045
  if (tmp___0) {
#line 1046
    return (22);
  }
#line 1048
  if (zc->zc_nvlist_src != (unsigned long long )((unsigned int )((void *)0))) {
#line 1048
    error = get_nvlist(zc, & cbdata.zc_props);
#line 1048
    if (error != 0) {
#line 1050
      return (error);
    }
  }
#line 1052
  cbdata.zc_cred = (cred_t *)((unsigned int )zc->zc_cred);
#line 1053
  cbdata.zc_dev = zc->zc_dev;
#line 1055
  if ((int )zc->zc_value[0] != 0) {
#line 1059
    zc->zc_value[sizeof(zc->zc_value) - 1U] = (char )'\000';
#line 1060
    tmp___1 = dataset_namecheck((char const   *)(zc->zc_value), (namecheck_err_t *)((void *)0),
                                (char *)((void *)0));
#line 1060
    if (tmp___1 != 0) {
#line 1061
      nvlist_free(cbdata.zc_props);
#line 1062
      return (22);
    }
#line 1065
    error = dmu_objset_open((char const   *)(zc->zc_value), type, 9, & clone___0);
#line 1067
    if (error) {
#line 1068
      nvlist_free(cbdata.zc_props);
#line 1069
      return (error);
    }
#line 1071
    error = dmu_objset_create((char const   *)(zc->zc_name), type, clone___0, (void (*)(objset_t *os ,
                                                                                        void *arg ,
                                                                                        dmu_tx_t *tx ))((void *)0),
                              (void *)0);
#line 1072
    dmu_objset_close(clone___0);
  } else {
#line 1074
    if ((unsigned int )cbfunc == (unsigned int )((void *)0)) {
#line 1075
      nvlist_free(cbdata.zc_props);
#line 1076
      return (22);
    }
#line 1113
    error = dmu_objset_create((char const   *)(zc->zc_name), type, (objset_t *)((void *)0),
                              cbfunc, (void *)(& cbdata));
  }
#line 1120
  if (error == 0) {
#line 1121
    error = zfs_set_prop_nvlist((char const   *)(zc->zc_name), zc->zc_dev, (cred_t *)((unsigned int )zc->zc_cred),
                                cbdata.zc_props);
#line 1121
    if (error != 0) {
#line 1124
      dmu_objset_destroy((char const   *)(zc->zc_name));
    }
  }
#line 1127
  nvlist_free(cbdata.zc_props);
#line 1128
  return (error);
}
}
#line 1131 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_snapshot(zfs_cmd_t *zc ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 1134
  tmp = snapshot_namecheck((char const   *)(zc->zc_value), (namecheck_err_t *)((void *)0),
                           (char *)((void *)0));
#line 1134
  if (tmp != 0) {
#line 1135
    return (22);
  }
#line 1136
  tmp___0 = dmu_objset_snapshot(zc->zc_name, zc->zc_value, (enum boolean )zc->zc_cookie);
#line 1136
  return (tmp___0);
}
}
#line 1140 "zfs-fuse/zfs_ioctl.c"
static int zfs_unmount_snap(char *name , void *arg ) 
{ 

  {
#line 1180
  return (0);
}
}
#line 1183 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_destroy_snaps(zfs_cmd_t *zc ) 
{ int err ;
  int tmp ;
  int tmp___0 ;

  {
#line 1188
  tmp = snapshot_namecheck((char const   *)(zc->zc_value), (namecheck_err_t *)((void *)0),
                           (char *)((void *)0));
#line 1188
  if (tmp != 0) {
#line 1189
    return (22);
  }
#line 1190
  err = dmu_objset_find(zc->zc_name, & zfs_unmount_snap, (void *)(zc->zc_value), 1 << 1);
#line 1192
  if (err) {
#line 1193
    return (err);
  }
#line 1194
  tmp___0 = dmu_snapshots_destroy(zc->zc_name, zc->zc_value);
#line 1194
  return (tmp___0);
}
}
#line 1197 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_destroy(zfs_cmd_t *zc ) 
{ int err ;
  int tmp ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 1200
  tmp___1 = __builtin_strchr(zc->zc_name, '@');
#line 1200
  if (tmp___1) {
#line 1200
    if (zc->zc_objset_type == 2ULL) {
#line 1201
      tmp = zfs_unmount_snap(zc->zc_name, (void *)0);
#line 1201
      err = tmp;
#line 1202
      if (err) {
#line 1203
        return (err);
      }
    }
  }
#line 1206
  tmp___2 = dmu_objset_destroy((char const   *)(zc->zc_name));
#line 1206
  return (tmp___2);
}
}
#line 1209 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_rollback(zfs_cmd_t *zc ) 
{ int tmp ;

  {
#line 1212
  tmp = dmu_objset_rollback((char const   *)(zc->zc_name));
#line 1212
  return (tmp);
}
}
#line 1215 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_rename(zfs_cmd_t *zc ) 
{ int tmp ;
  int err ;
  int tmp___0 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 1218
  zc->zc_value[sizeof(zc->zc_value) - 1U] = (char )'\000';
#line 1219
  tmp = dataset_namecheck((char const   *)(zc->zc_value), (namecheck_err_t *)((void *)0),
                          (char *)((void *)0));
#line 1219
  if (tmp != 0) {
#line 1220
    return (22);
  }
#line 1222
  tmp___2 = __builtin_strchr(zc->zc_name, '@');
#line 1222
  if ((unsigned int )tmp___2 != (unsigned int )((void *)0)) {
#line 1222
    if (zc->zc_objset_type == 2ULL) {
#line 1224
      tmp___0 = zfs_unmount_snap(zc->zc_name, (void *)0);
#line 1224
      err = tmp___0;
#line 1225
      if (err) {
#line 1226
        return (err);
      }
    }
  }
#line 1229
  tmp___3 = dmu_objset_rename((char const   *)(zc->zc_name), (char const   *)(zc->zc_value));
#line 1229
  return (tmp___3);
}
}
#line 1232 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_recvbackup(zfs_cmd_t *zc ) 
{ file_t *fp ;
  int error ;
  int fd ;
  offset_t new_off ;
  int tmp ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 1239
  tmp = dataset_namecheck((char const   *)(zc->zc_value), (namecheck_err_t *)((void *)0),
                          (char *)((void *)0));
#line 1239
  if (tmp != 0) {
#line 1241
    return (22);
  } else {
#line 1239
    tmp___1 = __builtin_strchr(zc->zc_value, '@');
#line 1239
    if ((unsigned int )tmp___1 == (unsigned int )((void *)0)) {
#line 1241
      return (22);
    }
  }
#line 1243
  fd = (int )zc->zc_cookie;
#line 1244
  fp = getf(fd);
#line 1245
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 1246
    return (9);
  }
#line 1247
  error = dmu_recvbackup(zc->zc_value, & zc->zc_begin_record, & zc->zc_cookie, (enum boolean )zc->zc_guid,
                         fp->f_vnode, (unsigned long long )fp->f_offset);
#line 1251
  new_off = (long long )((uint64_t )fp->f_offset + zc->zc_cookie);
#line 1252
  tmp___2 = fop_seek(fp->f_vnode, fp->f_offset, & new_off);
#line 1252
  if (tmp___2 == 0) {
#line 1253
    fp->f_offset = new_off;
  }
#line 1255
  releasef(fd);
#line 1256
  return (error);
}
}
#line 1259 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_sendbackup(zfs_cmd_t *zc ) 
{ objset_t *fromsnap ;
  objset_t *tosnap ;
  file_t *fp ;
  int error ;
  char buf[4096] ;
  char *cp ;
  char *tmp___0 ;

  {
#line 1262
  fromsnap = (objset_t *)((void *)0);
#line 1267
  error = dmu_objset_open((char const   *)(zc->zc_name), 5, 9, & tosnap);
#line 1269
  if (error) {
#line 1270
    return (error);
  }
#line 1272
  if ((int )zc->zc_value[0] != 0) {
#line 1276
    __builtin_strncpy(buf, (char const   *)(zc->zc_name), sizeof(buf));
#line 1277
    tmp___0 = __builtin_strchr(buf, '@');
#line 1277
    cp = tmp___0;
#line 1278
    if (cp) {
#line 1279
      *(cp + 1) = (char)0;
    }
#line 1280
    __builtin_strncat(buf, (char const   *)(zc->zc_value), sizeof(buf));
#line 1281
    error = dmu_objset_open((char const   *)(buf), 5, 9, & fromsnap);
#line 1283
    if (error) {
#line 1284
      dmu_objset_close(tosnap);
#line 1285
      return (error);
    }
  }
#line 1289
  fp = getf((int )zc->zc_cookie);
#line 1290
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 1291
    dmu_objset_close(tosnap);
#line 1292
    if (fromsnap) {
#line 1293
      dmu_objset_close(fromsnap);
    }
#line 1294
    return (9);
  }
#line 1297
  error = dmu_sendbackup(tosnap, fromsnap, fp->f_vnode);
#line 1299
  releasef((int )zc->zc_cookie);
#line 1300
  if (fromsnap) {
#line 1301
    dmu_objset_close(fromsnap);
  }
#line 1302
  dmu_objset_close(tosnap);
#line 1303
  return (error);
}
}
#line 1306 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_inject_fault(zfs_cmd_t *zc ) 
{ int id ;
  int error ;

  {
#line 1311
  error = zio_inject_fault(zc->zc_name, (int )zc->zc_guid, & id, & zc->zc_inject_record);
#line 1314
  if (error == 0) {
#line 1315
    zc->zc_guid = (unsigned long long )id;
  }
#line 1317
  return (error);
}
}
#line 1320 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_clear_fault(zfs_cmd_t *zc ) 
{ int tmp ;

  {
#line 1323
  tmp = zio_clear_fault((int )zc->zc_guid);
#line 1323
  return (tmp);
}
}
#line 1326 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_inject_list_next(zfs_cmd_t *zc ) 
{ int id ;
  int error ;

  {
#line 1329
  id = (int )zc->zc_guid;
#line 1332
  error = zio_inject_list_next(& id, zc->zc_name, sizeof(zc->zc_name), & zc->zc_inject_record);
#line 1335
  zc->zc_guid = (unsigned long long )id;
#line 1337
  return (error);
}
}
#line 1340 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_error_log(zfs_cmd_t *zc ) 
{ spa_t *spa ;
  int error ;
  size_t count ;

  {
#line 1345
  count = (unsigned int )zc->zc_nvlist_dst_size;
#line 1347
  error = spa_open((char const   *)(zc->zc_name), & spa, (void *)((char *)"zfs_ioc_error_log"));
#line 1347
  if (error != 0) {
#line 1348
    return (error);
  }
#line 1350
  error = spa_get_errlog(spa, (void *)((unsigned int )zc->zc_nvlist_dst), & count);
#line 1352
  if (error == 0) {
#line 1353
    zc->zc_nvlist_dst_size = (unsigned long long )count;
  } else {
#line 1355
    zc->zc_nvlist_dst_size = spa_get_errlog_size(spa);
  }
#line 1357
  spa_close(spa, (void *)((char *)"zfs_ioc_error_log"));
#line 1359
  return (error);
}
}
#line 1362 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_clear(zfs_cmd_t *zc ) 
{ spa_t *spa ;
  vdev_t *vd ;
  int error ;

  {
#line 1369
  error = spa_open((char const   *)(zc->zc_name), & spa, (void *)((char *)"zfs_ioc_clear"));
#line 1369
  if (error != 0) {
#line 1370
    return (error);
  }
#line 1372
  spa_config_enter(spa, 1, (void *)((char *)"zfs_ioc_clear"));
#line 1374
  if (zc->zc_guid == 0ULL) {
#line 1375
    vd = (vdev_t *)((void *)0);
  } else {
#line 1376
    vd = spa_lookup_by_guid(spa, zc->zc_guid);
#line 1376
    if ((unsigned int )vd == (unsigned int )((void *)0)) {
#line 1377
      spa_config_exit(spa, (void *)((char *)"zfs_ioc_clear"));
#line 1378
      spa_close(spa, (void *)((char *)"zfs_ioc_clear"));
#line 1379
      return (19);
    }
  }
#line 1382
  vdev_clear(spa, vd);
#line 1384
  spa_config_exit(spa, (void *)((char *)"zfs_ioc_clear"));
#line 1386
  spa_close(spa, (void *)((char *)"zfs_ioc_clear"));
#line 1388
  return (0);
}
}
#line 1391 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_bookmark_name(zfs_cmd_t *zc ) 
{ spa_t *spa ;
  int error ;
  nvlist_t *nvl ;
  int tmp ;

  {
#line 1398
  error = spa_open((char const   *)(zc->zc_name), & spa, (void *)((char *)"zfs_ioc_bookmark_name"));
#line 1398
  if (error != 0) {
#line 1399
    return (error);
  }
#line 1401
  while (1) {
#line 1401
    tmp = nvlist_alloc(& nvl, 1U, 256);
#line 1401
    if (! (tmp == 0)) {
#line 1401
      while (1) {
#line 1401
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                "zfs-fuse/zfs_ioctl.c", 1401, "zfs_ioc_bookmark_name", "nvlist_alloc(&nvl, NV_UNIQUE_NAME, KM_SLEEP) == 0");
#line 1401
        abort();
#line 1401
        break;
      }
    }
#line 1401
    break;
  }
#line 1403
  error = spa_bookmark_name(spa, & zc->zc_bookmark, nvl);
#line 1404
  if (error == 0) {
#line 1405
    error = put_nvlist(zc, nvl);
  }
#line 1406
  nvlist_free(nvl);
#line 1408
  spa_close(spa, (void *)((char *)"zfs_ioc_bookmark_name"));
#line 1410
  return (error);
}
}
#line 1413 "zfs-fuse/zfs_ioctl.c"
static int zfs_ioc_promote(zfs_cmd_t *zc ) 
{ char *cp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 1422
  tmp___0 = __builtin_strchr(zc->zc_value, '@');
#line 1422
  cp = tmp___0;
#line 1423
  if (cp) {
#line 1424
    *cp = (char )'\000';
  }
#line 1425
  dmu_objset_find(zc->zc_value, & zfs_unmount_snap, (void *)0, 1);
#line 1427
  tmp___1 = dsl_dataset_promote((char const   *)(zc->zc_name));
#line 1427
  return (tmp___1);
}
}
#line 1430 "zfs-fuse/zfs_ioctl.c"
static zfs_ioc_vec_t zfs_ioc_vec[40]  = 
#line 1430
  {      {& zfs_ioc_pool_create, & zfs_secpolicy_config, 1}, 
        {& zfs_ioc_pool_destroy, & zfs_secpolicy_config, 1}, 
        {& zfs_ioc_pool_import, & zfs_secpolicy_config, 1}, 
        {& zfs_ioc_pool_export, & zfs_secpolicy_config, 1}, 
        {& zfs_ioc_pool_configs, & zfs_secpolicy_none, 0}, 
        {& zfs_ioc_pool_stats, & zfs_secpolicy_read, 1}, 
        {& zfs_ioc_pool_tryimport, & zfs_secpolicy_config, 0}, 
        {& zfs_ioc_pool_scrub, & zfs_secpolicy_config, 1}, 
        {& zfs_ioc_pool_freeze, & zfs_secpolicy_config, 0}, 
        {& zfs_ioc_pool_upgrade, & zfs_secpolicy_config, 1}, 
        {& zfs_ioc_pool_get_history, & zfs_secpolicy_config, 1}, 
        {& zfs_ioc_pool_log_history, & zfs_secpolicy_config, 1}, 
        {& zfs_ioc_vdev_add, & zfs_secpolicy_config, 1}, 
        {& zfs_ioc_vdev_remove, & zfs_secpolicy_config, 1}, 
        {& zfs_ioc_vdev_online, & zfs_secpolicy_config, 1}, 
        {& zfs_ioc_vdev_offline, & zfs_secpolicy_config, 1}, 
        {& zfs_ioc_vdev_attach, & zfs_secpolicy_config, 1}, 
        {& zfs_ioc_vdev_detach, & zfs_secpolicy_config, 1}, 
        {& zfs_ioc_vdev_setpath, & zfs_secpolicy_config, 1}, 
        {& zfs_ioc_objset_stats, & zfs_secpolicy_read, 2}, 
        {& zfs_ioc_dataset_list_next, & zfs_secpolicy_read, 2}, 
        {& zfs_ioc_snapshot_list_next, & zfs_secpolicy_read, 2}, 
        {& zfs_ioc_set_prop, & zfs_secpolicy_write, 2}, 
        {& zfs_ioc_create_minor, & zfs_secpolicy_config, 2}, 
        {& zfs_ioc_remove_minor, & zfs_secpolicy_config, 2}, 
        {& zfs_ioc_create, & zfs_secpolicy_parent, 2}, 
        {& zfs_ioc_destroy, & zfs_secpolicy_parent, 2}, 
        {& zfs_ioc_rollback, & zfs_secpolicy_write, 2}, 
        {& zfs_ioc_rename, & zfs_secpolicy_write, 2}, 
        {& zfs_ioc_recvbackup, & zfs_secpolicy_write, 2}, 
        {& zfs_ioc_sendbackup, & zfs_secpolicy_write, 2}, 
        {& zfs_ioc_inject_fault, & zfs_secpolicy_inject, 0}, 
        {& zfs_ioc_clear_fault, & zfs_secpolicy_inject, 0}, 
        {& zfs_ioc_inject_list_next, & zfs_secpolicy_inject, 0}, 
        {& zfs_ioc_error_log, & zfs_secpolicy_inject, 1}, 
        {& zfs_ioc_clear, & zfs_secpolicy_config, 1}, 
        {& zfs_ioc_bookmark_name, & zfs_secpolicy_inject, 1}, 
        {& zfs_ioc_promote, & zfs_secpolicy_write, 2}, 
        {& zfs_ioc_destroy_snaps, & zfs_secpolicy_write, 2}, 
        {& zfs_ioc_snapshot, & zfs_secpolicy_write, 2}};
#line 1473 "zfs-fuse/zfs_ioctl.c"
int zfsdev_ioctl(dev_t dev , int cmd , intptr_t arg , int flag , cred_t *cr , int *rvalp ) 
{ zfs_cmd_t *zc ;
  uint_t vec ;
  int error ;
  int rc ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1486
  vec = (unsigned int )(cmd - (90 << 8));
#line 1488
  if (vec >= sizeof(zfs_ioc_vec) / sizeof(zfs_ioc_vec[0])) {
#line 1489
    return (22);
  }
#line 1491
  tmp = umem_zalloc(sizeof(zfs_cmd_t ), 256);
#line 1491
  zc = (zfs_cmd_t *)tmp;
#line 1493
  error = xcopyin((void const   *)((void *)arg), (void *)zc, sizeof(zfs_cmd_t ));
#line 1495
  if (error == 0) {
#line 1496
    zc->zc_cred = (unsigned long long )((unsigned int )cr);
#line 1497
    zc->zc_dev = dev;
#line 1498
    error = (*(zfs_ioc_vec[vec].zvec_secpolicy))((char const   *)(zc->zc_name), cr);
  }
#line 1505
  if (error == 0) {
#line 1506
    zc->zc_name[sizeof(zc->zc_name) - 1U] = (char )'\000';
#line 1507
    switch ((int )zfs_ioc_vec[vec].zvec_namecheck) {
    case 1: 
#line 1509
    tmp___0 = pool_namecheck((char const   *)(zc->zc_name), (namecheck_err_t *)((void *)0),
                             (char *)((void *)0));
#line 1509
    if (tmp___0 != 0) {
#line 1510
      error = 22;
    }
#line 1511
    break;
    case 2: 
#line 1514
    tmp___1 = dataset_namecheck((char const   *)(zc->zc_name), (namecheck_err_t *)((void *)0),
                                (char *)((void *)0));
#line 1514
    if (tmp___1 != 0) {
#line 1515
      error = 22;
    }
#line 1516
    break;
    case 0: 
#line 1519
    break;
    }
  }
#line 1523
  if (error == 0) {
#line 1524
    error = (*(zfs_ioc_vec[vec].zvec_func))(zc);
  }
#line 1526
  rc = xcopyout((void const   *)zc, (void *)arg, sizeof(zfs_cmd_t ));
#line 1527
  if (error == 0) {
#line 1528
    error = rc;
  }
#line 1530
  umem_free((void *)zc, sizeof(zfs_cmd_t ));
#line 1531
  return (error);
}
}
#line 1642 "zfs-fuse/zfs_ioctl.c"
int zfs_ioctl_init(void) 
{ 

  {
#line 1645
  spa_init(3);
#line 1647
  zfs_init();
#line 1663
  return (0);
}
}
#line 1666 "zfs-fuse/zfs_ioctl.c"
int zfs_ioctl_fini(void) 
{ int error ;
  int tmp ;
  int tmp___0 ;

  {
#line 1669
  error = 0;
#line 1671
  tmp = spa_busy();
#line 1671
  if (tmp) {
#line 1672
    return (16);
  } else {
#line 1671
    tmp___0 = zfs_busy();
#line 1671
    if (tmp___0) {
#line 1672
      return (16);
    } else {
#line 1671
      if (zio_injection_enabled) {
#line 1672
        return (16);
      }
    }
  }
#line 1682
  zfs_fini();
#line 1683
  spa_fini();
#line 1690
  return (error);
}
}
#line 1 "zfs_log.o"
#pragma merger(0,"/tmp/cil-AlLxH2gQ.i","-pipe,-Wall,-Werror,-std=c99,-Wno-unused,-Wno-missing-braces,-Wno-parentheses,-Wno-uninitialized,-fno-strict-aliasing,-ggdb,-O2")
#line 255 "lib/libzfscommon/include/sys/zil.h"
extern itx_t *zil_itx_create(int txtype , size_t lrsize ) ;
#line 256
extern uint64_t zil_itx_assign(zilog_t *zilog , itx_t *itx , dmu_tx_t *tx ) ;
#line 261 "lib/libzfscommon/include/sys/zfs_znode.h"
void zfs_log_remove(zilog_t *zilog , dmu_tx_t *tx , int txtype , znode_t *dzp , char *name ) ;
#line 263
void zfs_log_link(zilog_t *zilog , dmu_tx_t *tx , int txtype , znode_t *dzp , znode_t *zp ,
                  char *name ) ;
#line 265
void zfs_log_symlink(zilog_t *zilog , dmu_tx_t *tx , int txtype , znode_t *dzp , znode_t *zp ,
                     char *name , char *link ) ;
#line 267
void zfs_log_rename(zilog_t *zilog , dmu_tx_t *tx , int txtype , znode_t *sdzp , char *sname ,
                    znode_t *tdzp , char *dname , znode_t *szp ) ;
#line 269
void zfs_log_write(zilog_t *zilog , dmu_tx_t *tx , int txtype , znode_t *zp , offset_t off ,
                   ssize_t len , int ioflag , uio_t *uio ) ;
#line 271
void zfs_log_truncate(zilog_t *zilog , dmu_tx_t *tx , int txtype , znode_t *zp , uint64_t off ,
                      uint64_t len ) ;
#line 273
void zfs_log_setattr(zilog_t *zilog , dmu_tx_t *tx , int txtype , znode_t *zp , vattr_t *vap ,
                     uint_t mask_applied ) ;
#line 61 "zfs-fuse/zfs_log.c"
void zfs_log_create(zilog_t *zilog , dmu_tx_t *tx , int txtype , znode_t *dzp , znode_t *zp ,
                    char *name ) 
{ itx_t *itx ;
  uint64_t seq ;
  lr_create_t *lr ;
  size_t namesize ;
  size_t tmp ;

  {
#line 68
  tmp = strlen((char const   *)name);
#line 68
  namesize = tmp + 1U;
#line 70
  if ((unsigned int )zilog == (unsigned int )((void *)0)) {
#line 71
    return;
  }
#line 73
  itx = zil_itx_create(txtype, sizeof(*lr) + namesize);
#line 74
  lr = (lr_create_t *)(& itx->itx_lr);
#line 75
  lr->lr_doid = dzp->z_id;
#line 76
  lr->lr_foid = zp->z_id;
#line 77
  lr->lr_mode = (zp->z_phys)->zp_mode;
#line 78
  lr->lr_uid = (zp->z_phys)->zp_uid;
#line 79
  lr->lr_gid = (zp->z_phys)->zp_gid;
#line 80
  lr->lr_gen = (zp->z_phys)->zp_gen;
#line 81
  lr->lr_crtime[0] = (zp->z_phys)->zp_crtime[0];
#line 82
  lr->lr_crtime[1] = (zp->z_phys)->zp_crtime[1];
#line 83
  lr->lr_rdev = (zp->z_phys)->zp_rdev;
#line 84
  bcopy((void const   *)name, (void *)((char *)(lr + 1)), namesize);
#line 86
  seq = zil_itx_assign(zilog, itx, tx);
#line 87
  dzp->z_last_itx = seq;
#line 88
  zp->z_last_itx = seq;
#line 89
  return;
}
}
#line 94 "zfs-fuse/zfs_log.c"
void zfs_log_remove(zilog_t *zilog , dmu_tx_t *tx , int txtype , znode_t *dzp , char *name ) 
{ itx_t *itx ;
  uint64_t seq ;
  lr_remove_t *lr ;
  size_t namesize ;
  size_t tmp ;

  {
#line 101
  tmp = strlen((char const   *)name);
#line 101
  namesize = tmp + 1U;
#line 103
  if ((unsigned int )zilog == (unsigned int )((void *)0)) {
#line 104
    return;
  }
#line 106
  itx = zil_itx_create(txtype, sizeof(*lr) + namesize);
#line 107
  lr = (lr_remove_t *)(& itx->itx_lr);
#line 108
  lr->lr_doid = dzp->z_id;
#line 109
  bcopy((void const   *)name, (void *)((char *)(lr + 1)), namesize);
#line 111
  seq = zil_itx_assign(zilog, itx, tx);
#line 112
  dzp->z_last_itx = seq;
#line 113
  return;
}
}
#line 118 "zfs-fuse/zfs_log.c"
void zfs_log_link(zilog_t *zilog , dmu_tx_t *tx , int txtype , znode_t *dzp , znode_t *zp ,
                  char *name ) 
{ itx_t *itx ;
  uint64_t seq ;
  lr_link_t *lr ;
  size_t namesize ;
  size_t tmp ;

  {
#line 125
  tmp = strlen((char const   *)name);
#line 125
  namesize = tmp + 1U;
#line 127
  if ((unsigned int )zilog == (unsigned int )((void *)0)) {
#line 128
    return;
  }
#line 130
  itx = zil_itx_create(txtype, sizeof(*lr) + namesize);
#line 131
  lr = (lr_link_t *)(& itx->itx_lr);
#line 132
  lr->lr_doid = dzp->z_id;
#line 133
  lr->lr_link_obj = zp->z_id;
#line 134
  bcopy((void const   *)name, (void *)((char *)(lr + 1)), namesize);
#line 136
  seq = zil_itx_assign(zilog, itx, tx);
#line 137
  dzp->z_last_itx = seq;
#line 138
  zp->z_last_itx = seq;
#line 139
  return;
}
}
#line 144 "zfs-fuse/zfs_log.c"
void zfs_log_symlink(zilog_t *zilog , dmu_tx_t *tx , int txtype , znode_t *dzp , znode_t *zp ,
                     char *name , char *link ) 
{ itx_t *itx ;
  uint64_t seq ;
  lr_create_t *lr ;
  size_t namesize ;
  size_t tmp ;
  size_t linksize ;
  size_t tmp___0 ;

  {
#line 151
  tmp = strlen((char const   *)name);
#line 151
  namesize = tmp + 1U;
#line 152
  tmp___0 = strlen((char const   *)link);
#line 152
  linksize = tmp___0 + 1U;
#line 154
  if ((unsigned int )zilog == (unsigned int )((void *)0)) {
#line 155
    return;
  }
#line 157
  itx = zil_itx_create(txtype, (sizeof(*lr) + namesize) + linksize);
#line 158
  lr = (lr_create_t *)(& itx->itx_lr);
#line 159
  lr->lr_doid = dzp->z_id;
#line 160
  lr->lr_foid = zp->z_id;
#line 161
  lr->lr_mode = (zp->z_phys)->zp_mode;
#line 162
  lr->lr_uid = (zp->z_phys)->zp_uid;
#line 163
  lr->lr_gid = (zp->z_phys)->zp_gid;
#line 164
  lr->lr_gen = (zp->z_phys)->zp_gen;
#line 165
  lr->lr_crtime[0] = (zp->z_phys)->zp_crtime[0];
#line 166
  lr->lr_crtime[1] = (zp->z_phys)->zp_crtime[1];
#line 167
  bcopy((void const   *)name, (void *)((char *)(lr + 1)), namesize);
#line 168
  bcopy((void const   *)link, (void *)((char *)(lr + 1) + namesize), linksize);
#line 170
  seq = zil_itx_assign(zilog, itx, tx);
#line 171
  dzp->z_last_itx = seq;
#line 172
  zp->z_last_itx = seq;
#line 173
  return;
}
}
#line 178 "zfs-fuse/zfs_log.c"
void zfs_log_rename(zilog_t *zilog , dmu_tx_t *tx , int txtype , znode_t *sdzp , char *sname ,
                    znode_t *tdzp , char *dname , znode_t *szp ) 
{ itx_t *itx ;
  uint64_t seq ;
  lr_rename_t *lr ;
  size_t snamesize ;
  size_t tmp ;
  size_t dnamesize ;
  size_t tmp___0 ;

  {
#line 185
  tmp = strlen((char const   *)sname);
#line 185
  snamesize = tmp + 1U;
#line 186
  tmp___0 = strlen((char const   *)dname);
#line 186
  dnamesize = tmp___0 + 1U;
#line 188
  if ((unsigned int )zilog == (unsigned int )((void *)0)) {
#line 189
    return;
  }
#line 191
  itx = zil_itx_create(txtype, (sizeof(*lr) + snamesize) + dnamesize);
#line 192
  lr = (lr_rename_t *)(& itx->itx_lr);
#line 193
  lr->lr_sdoid = sdzp->z_id;
#line 194
  lr->lr_tdoid = tdzp->z_id;
#line 195
  bcopy((void const   *)sname, (void *)((char *)(lr + 1)), snamesize);
#line 196
  bcopy((void const   *)dname, (void *)((char *)(lr + 1) + snamesize), dnamesize);
#line 198
  seq = zil_itx_assign(zilog, itx, tx);
#line 199
  sdzp->z_last_itx = seq;
#line 200
  tdzp->z_last_itx = seq;
#line 201
  szp->z_last_itx = seq;
#line 202
  return;
}
}
#line 207 "zfs-fuse/zfs_log.c"
ssize_t zfs_immediate_write_sz  =    32768;
#line 209 "zfs-fuse/zfs_log.c"
void zfs_log_write(zilog_t *zilog , dmu_tx_t *tx , int txtype , znode_t *zp , offset_t off ,
                   ssize_t len , int ioflag , uio_t *uio ) 
{ itx_t *itx ;
  uint64_t seq ;
  lr_write_t *lr ;
  itx_wr_state_t write_state ;
  size_t dlen ;
  int err ;

  {
#line 220
  if ((unsigned int )zilog == (unsigned int )((void *)0)) {
#line 221
    return;
  } else {
#line 220
    if (zp->z_reap) {
#line 221
      return;
    }
  }
#line 240
  if (len > zfs_immediate_write_sz) {
#line 241
    dlen = 0U;
#line 242
    write_state = 0;
  } else {
#line 243
    if (ioflag & 4096) {
#line 244
      dlen = (unsigned int )len;
#line 245
      write_state = 1;
    } else {
#line 247
      dlen = 0U;
#line 248
      write_state = 2;
    }
  }
#line 250
  itx = zil_itx_create(txtype, sizeof(*lr) + dlen);
#line 251
  if ((int )write_state == 1) {
#line 253
    memmove((void *)(((char *)itx + (unsigned int )(& ((itx_t *)0)->itx_lr)) + sizeof(*lr)),
            (void const   *)((char *)(uio->uio_iov)->iov_base - len), (unsigned int )len);
#line 254
    err = 0;
#line 260
    if (err) {
#line 261
      umem_free((void *)itx, (unsigned int )((uint64_t )((unsigned int )(& ((itx_t *)0)->itx_lr)) + itx->itx_lr.lrc_reclen));
#line 263
      itx = zil_itx_create(txtype, sizeof(*lr));
#line 264
      write_state = 2;
    }
  }
#line 267
  itx->itx_wr_state = write_state;
#line 268
  lr = (lr_write_t *)(& itx->itx_lr);
#line 269
  lr->lr_foid = zp->z_id;
#line 270
  lr->lr_offset = (unsigned long long )off;
#line 271
  lr->lr_length = (unsigned long long )len;
#line 272
  lr->lr_blkoff = 0ULL;
#line 273
  lr->lr_blkptr.blk_dva[0].dva_word[0] = 0ULL;
#line 273
  lr->lr_blkptr.blk_dva[0].dva_word[1] = 0ULL;
#line 273
  lr->lr_blkptr.blk_dva[1].dva_word[0] = 0ULL;
#line 273
  lr->lr_blkptr.blk_dva[1].dva_word[1] = 0ULL;
#line 273
  lr->lr_blkptr.blk_dva[2].dva_word[0] = 0ULL;
#line 273
  lr->lr_blkptr.blk_dva[2].dva_word[1] = 0ULL;
#line 273
  lr->lr_blkptr.blk_prop = 0ULL;
#line 273
  lr->lr_blkptr.blk_pad[0] = 0ULL;
#line 273
  lr->lr_blkptr.blk_pad[1] = 0ULL;
#line 273
  lr->lr_blkptr.blk_pad[2] = 0ULL;
#line 273
  lr->lr_blkptr.blk_birth = 0ULL;
#line 273
  lr->lr_blkptr.blk_fill = 0ULL;
#line 273
  lr->lr_blkptr.blk_cksum.zc_word[0] = 0ULL;
#line 273
  lr->lr_blkptr.blk_cksum.zc_word[1] = 0ULL;
#line 273
  lr->lr_blkptr.blk_cksum.zc_word[2] = 0ULL;
#line 273
  lr->lr_blkptr.blk_cksum.zc_word[3] = 0ULL;
#line 275
  itx->itx_private = (void *)zp->z_zfsvfs;
#line 277
  itx->itx_sync = (unsigned char )(zp->z_sync_cnt != 0U);
#line 278
  seq = zil_itx_assign(zilog, itx, tx);
#line 279
  zp->z_last_itx = seq;
#line 280
  return;
}
}
#line 285 "zfs-fuse/zfs_log.c"
void zfs_log_truncate(zilog_t *zilog , dmu_tx_t *tx , int txtype , znode_t *zp , uint64_t off ,
                      uint64_t len ) 
{ itx_t *itx ;
  uint64_t seq ;
  lr_truncate_t *lr ;

  {
#line 293
  if ((unsigned int )zilog == (unsigned int )((void *)0)) {
#line 294
    return;
  } else {
#line 293
    if (zp->z_reap) {
#line 294
      return;
    }
  }
#line 296
  itx = zil_itx_create(txtype, sizeof(*lr));
#line 297
  lr = (lr_truncate_t *)(& itx->itx_lr);
#line 298
  lr->lr_foid = zp->z_id;
#line 299
  lr->lr_offset = off;
#line 300
  lr->lr_length = len;
#line 302
  itx->itx_sync = (unsigned char )(zp->z_sync_cnt != 0U);
#line 303
  seq = zil_itx_assign(zilog, itx, tx);
#line 304
  zp->z_last_itx = seq;
#line 305
  return;
}
}
#line 310 "zfs-fuse/zfs_log.c"
void zfs_log_setattr(zilog_t *zilog , dmu_tx_t *tx , int txtype , znode_t *zp , vattr_t *vap ,
                     uint_t mask_applied ) 
{ itx_t *itx ;
  uint64_t seq ;
  lr_setattr_t *lr ;

  {
#line 318
  if ((unsigned int )zilog == (unsigned int )((void *)0)) {
#line 319
    return;
  } else {
#line 318
    if (zp->z_reap) {
#line 319
      return;
    }
  }
#line 321
  itx = zil_itx_create(txtype, sizeof(*lr));
#line 322
  lr = (lr_setattr_t *)(& itx->itx_lr);
#line 323
  lr->lr_foid = zp->z_id;
#line 324
  lr->lr_mask = (unsigned long long )mask_applied;
#line 325
  lr->lr_mode = (unsigned long long )vap->va_mode;
#line 326
  lr->lr_uid = (unsigned long long )vap->va_uid;
#line 327
  lr->lr_gid = (unsigned long long )vap->va_gid;
#line 328
  lr->lr_size = vap->va_size;
#line 329
  lr->lr_atime[0] = (unsigned long long )vap->va_atime.tv_sec;
#line 329
  lr->lr_atime[1] = (unsigned long long )vap->va_atime.tv_nsec;
#line 330
  lr->lr_mtime[0] = (unsigned long long )vap->va_mtime.tv_sec;
#line 330
  lr->lr_mtime[1] = (unsigned long long )vap->va_mtime.tv_nsec;
#line 332
  itx->itx_sync = (unsigned char )(zp->z_sync_cnt != 0U);
#line 333
  seq = zil_itx_assign(zilog, itx, tx);
#line 334
  zp->z_last_itx = seq;
#line 335
  return;
}
}
#line 340 "zfs-fuse/zfs_log.c"
void zfs_log_acl(zilog_t *zilog , dmu_tx_t *tx , int txtype , znode_t *zp , int aclcnt ,
                 ace_t *z_ace ) 
{ itx_t *itx ;
  uint64_t seq ;
  lr_acl_t *lr ;

  {
#line 348
  if ((unsigned int )zilog == (unsigned int )((void *)0)) {
#line 349
    return;
  } else {
#line 348
    if (zp->z_reap) {
#line 349
      return;
    }
  }
#line 351
  itx = zil_itx_create(txtype, sizeof(*lr) + (unsigned int )aclcnt * sizeof(ace_t ));
#line 352
  lr = (lr_acl_t *)(& itx->itx_lr);
#line 353
  lr->lr_foid = zp->z_id;
#line 354
  lr->lr_aclcnt = (unsigned long long )aclcnt;
#line 355
  bcopy((void const   *)z_ace, (void *)((ace_t *)(lr + 1)), (unsigned int )aclcnt * sizeof(ace_t ));
#line 357
  itx->itx_sync = (unsigned char )(zp->z_sync_cnt != 0U);
#line 358
  seq = zil_itx_assign(zilog, itx, tx);
#line 359
  zp->z_last_itx = seq;
#line 360
  return;
}
}
#line 1 "zfs_replay.o"
#pragma merger(0,"/tmp/cil-DEdLe5wv.i","-pipe,-Wall,-Werror,-std=c99,-Wno-unused,-Wno-missing-braces,-Wno-parentheses,-Wno-uninitialized,-fno-strict-aliasing,-ggdb,-O2")
#line 311 "lib/libsolkerncompat/include/sys/vnode.h"
extern int vn_rdwr(enum uio_rw rw , struct vnode *vp , caddr_t base , ssize_t len ,
                   offset_t offset , enum uio_seg seg , int ioflag , rlim64_t ulimit ,
                   cred_t *cr , ssize_t *residp ) ;
#line 426
extern int fop_setattr(vnode_t * , vattr_t * , int  , cred_t * , caller_context_t * ) ;
#line 431
extern int fop_create(vnode_t * , char * , vattr_t * , vcexcl_t  , int  , vnode_t ** ,
                      cred_t * , int  ) ;
#line 433
extern int fop_remove(vnode_t *vp , char * , cred_t * ) ;
#line 434
extern int fop_link(vnode_t * , vnode_t * , char * , cred_t * ) ;
#line 435
extern int fop_rename(vnode_t * , char * , vnode_t * , char * , cred_t * ) ;
#line 436
extern int fop_mkdir(vnode_t * , char * , vattr_t * , vnode_t ** , cred_t * ) ;
#line 437
extern int fop_rmdir(vnode_t * , char * , vnode_t * , cred_t * ) ;
#line 439
extern int fop_symlink(vnode_t * , char * , vattr_t * , char * , cred_t * ) ;
#line 450
extern int fop_space(vnode_t * , int  , struct flock64 * , int  , offset_t  , cred_t * ,
                     caller_context_t * ) ;
#line 470
extern int fop_setsecattr(vnode_t * , vsecattr_t * , int  , cred_t * ) ;
#line 123 "lib/libzfscommon/include/sys/dmu.h"
extern void byteswap_uint64_array(void *buf , size_t size ) ;
#line 95 "lib/libzfscommon/include/sys/zfs_acl.h"
extern void zfs_ace_byteswap(ace_t * , int  ) ;
#line 257 "lib/libzfscommon/include/sys/zfs_znode.h"
dev_t zfs_cmpldev(uint64_t dev ) ;
#line 279
zil_replay_func_t *zfs_replay_vector[13] ;
#line 49 "lib/libsolkerncompat/include/sys/mode.h"
extern enum vtype iftovt_tab[] ;
#line 57 "zfs-fuse/zfs_replay.c"
static void zfs_init_vattr(vattr_t *vap , uint64_t mask , uint64_t mode , uint64_t uid ,
                           uint64_t gid , uint64_t rdev , uint64_t nodeid ) 
{ 

  {
#line 61
  bzero((void *)vap, sizeof(*vap));
#line 62
  vap->va_mask = (unsigned int )mask;
#line 63
  vap->va_type = iftovt_tab[(mode & 61440ULL) >> 12];
#line 64
  vap->va_mode = (unsigned int )(mode & 4095ULL);
#line 65
  vap->va_uid = (unsigned int )uid;
#line 66
  vap->va_gid = (unsigned int )gid;
#line 67
  vap->va_rdev = zfs_cmpldev(rdev);
#line 68
  vap->va_nodeid = nodeid;
#line 69
  return;
}
}
#line 72 "zfs-fuse/zfs_replay.c"
static int zfs_replay_error(zfsvfs_t *zfsvfs , lr_t *lr , boolean_t byteswap ) 
{ 

  {
#line 75
  return (95);
}
}
#line 78 "zfs-fuse/zfs_replay.c"
static int zfs_replay_create(zfsvfs_t *zfsvfs , lr_create_t *lr , boolean_t byteswap ) 
{ char *name ;
  char *link ;
  znode_t *dzp ;
  vnode_t *vp ;
  vattr_t va ;
  int error ;
  size_t tmp ;

  {
#line 81
  name = (char *)(lr + 1);
#line 84
  vp = (vnode_t *)((void *)0);
#line 88
  if (byteswap) {
#line 89
    byteswap_uint64_array((void *)lr, sizeof(*lr));
  }
#line 91
  error = zfs_zget(zfsvfs, lr->lr_doid, & dzp);
#line 91
  if (error != 0) {
#line 92
    return (error);
  }
#line 94
  zfs_init_vattr(& va, 15ULL, lr->lr_mode, lr->lr_uid, lr->lr_gid, lr->lr_rdev, lr->lr_foid);
#line 104
  va.va_ctime.tv_sec = (long )lr->lr_crtime[0];
#line 104
  va.va_ctime.tv_nsec = (long )lr->lr_crtime[1];
#line 105
  va.va_nblocks = lr->lr_gen;
#line 107
  switch ((int )lr->lr_common.lrc_txtype) {
  case 1: 
#line 109
  error = fop_create(dzp->z_vnode, name, & va, (enum vcexcl )0, 0, & vp, kcred, 0);
#line 110
  break;
  case 2: 
#line 112
  error = fop_mkdir(dzp->z_vnode, name, & va, & vp, kcred);
#line 113
  break;
  case 3: 
#line 115
  error = zfs_make_xattrdir(dzp, & va, & vp, kcred);
#line 116
  break;
  case 4: 
#line 118
  tmp = strlen((char const   *)name);
#line 118
  link = (name + tmp) + 1;
#line 119
  error = fop_symlink(dzp->z_vnode, name, & va, link, kcred);
#line 120
  break;
  default: 
#line 122
  error = 95;
  }
#line 125
  if (error == 0) {
#line 125
    if ((unsigned int )vp != (unsigned int )((void *)0)) {
#line 126
      vn_rele(vp);
    }
  }
#line 128
  vn_rele(dzp->z_vnode);
#line 130
  return (error);
}
}
#line 133 "zfs-fuse/zfs_replay.c"
static int zfs_replay_remove(zfsvfs_t *zfsvfs , lr_remove_t *lr , boolean_t byteswap ) 
{ char *name ;
  znode_t *dzp ;
  int error ;

  {
#line 136
  name = (char *)(lr + 1);
#line 140
  if (byteswap) {
#line 141
    byteswap_uint64_array((void *)lr, sizeof(*lr));
  }
#line 143
  error = zfs_zget(zfsvfs, lr->lr_doid, & dzp);
#line 143
  if (error != 0) {
#line 144
    return (error);
  }
#line 146
  switch ((int )lr->lr_common.lrc_txtype) {
  case 5: 
#line 148
  error = fop_remove(dzp->z_vnode, name, kcred);
#line 149
  break;
  case 6: 
#line 151
  error = fop_rmdir(dzp->z_vnode, name, (vnode_t *)((void *)0), kcred);
#line 152
  break;
  default: 
#line 154
  error = 95;
  }
#line 157
  vn_rele(dzp->z_vnode);
#line 159
  return (error);
}
}
#line 162 "zfs-fuse/zfs_replay.c"
static int zfs_replay_link(zfsvfs_t *zfsvfs , lr_link_t *lr , boolean_t byteswap ) 
{ char *name ;
  znode_t *dzp ;
  znode_t *zp ;
  int error ;

  {
#line 165
  name = (char *)(lr + 1);
#line 169
  if (byteswap) {
#line 170
    byteswap_uint64_array((void *)lr, sizeof(*lr));
  }
#line 172
  error = zfs_zget(zfsvfs, lr->lr_doid, & dzp);
#line 172
  if (error != 0) {
#line 173
    return (error);
  }
#line 175
  error = zfs_zget(zfsvfs, lr->lr_link_obj, & zp);
#line 175
  if (error != 0) {
#line 176
    vn_rele(dzp->z_vnode);
#line 177
    return (error);
  }
#line 180
  error = fop_link(dzp->z_vnode, zp->z_vnode, name, kcred);
#line 182
  vn_rele(zp->z_vnode);
#line 183
  vn_rele(dzp->z_vnode);
#line 185
  return (error);
}
}
#line 188 "zfs-fuse/zfs_replay.c"
static int zfs_replay_rename(zfsvfs_t *zfsvfs , lr_rename_t *lr , boolean_t byteswap ) 
{ char *sname ;
  char *tname ;
  size_t tmp ;
  znode_t *sdzp ;
  znode_t *tdzp ;
  int error ;

  {
#line 191
  sname = (char *)(lr + 1);
#line 192
  tmp = strlen((char const   *)sname);
#line 192
  tname = (sname + tmp) + 1;
#line 196
  if (byteswap) {
#line 197
    byteswap_uint64_array((void *)lr, sizeof(*lr));
  }
#line 199
  error = zfs_zget(zfsvfs, lr->lr_sdoid, & sdzp);
#line 199
  if (error != 0) {
#line 200
    return (error);
  }
#line 202
  error = zfs_zget(zfsvfs, lr->lr_tdoid, & tdzp);
#line 202
  if (error != 0) {
#line 203
    vn_rele(sdzp->z_vnode);
#line 204
    return (error);
  }
#line 207
  error = fop_rename(sdzp->z_vnode, sname, tdzp->z_vnode, tname, kcred);
#line 209
  vn_rele(tdzp->z_vnode);
#line 210
  vn_rele(sdzp->z_vnode);
#line 212
  return (error);
}
}
#line 215 "zfs-fuse/zfs_replay.c"
static int zfs_replay_write(zfsvfs_t *zfsvfs , lr_write_t *lr , boolean_t byteswap ) 
{ char *data ;
  znode_t *zp ;
  int error ;
  ssize_t resid ;

  {
#line 218
  data = (char *)(lr + 1);
#line 223
  if (byteswap) {
#line 224
    byteswap_uint64_array((void *)lr, sizeof(*lr));
  }
#line 226
  error = zfs_zget(zfsvfs, lr->lr_foid, & zp);
#line 226
  if (error != 0) {
#line 232
    if (error == 2) {
#line 233
      error = 0;
    }
#line 234
    return (error);
  }
#line 237
  error = vn_rdwr(1, zp->z_vnode, data, (int )lr->lr_length, (long long )lr->lr_offset,
                  1, 0, 0xffffffffffffffffULL, kcred, & resid);
#line 240
  vn_rele(zp->z_vnode);
#line 242
  return (error);
}
}
#line 245 "zfs-fuse/zfs_replay.c"
static int zfs_replay_truncate(zfsvfs_t *zfsvfs , lr_truncate_t *lr , boolean_t byteswap ) 
{ znode_t *zp ;
  flock64_t fl ;
  int error ;

  {
#line 252
  if (byteswap) {
#line 253
    byteswap_uint64_array((void *)lr, sizeof(*lr));
  }
#line 255
  error = zfs_zget(zfsvfs, lr->lr_foid, & zp);
#line 255
  if (error != 0) {
#line 261
    if (error == 2) {
#line 262
      error = 0;
    }
#line 263
    return (error);
  }
#line 266
  bzero((void *)(& fl), sizeof(fl));
#line 267
  fl.l_type = (short)1;
#line 268
  fl.l_whence = (short)0;
#line 269
  fl.l_start = (long long )lr->lr_offset;
#line 270
  fl.l_len = (long long )lr->lr_length;
#line 272
  error = fop_space(zp->z_vnode, 27, & fl, 32770, (long long )lr->lr_offset, kcred,
                    (caller_context_t *)((void *)0));
#line 275
  vn_rele(zp->z_vnode);
#line 277
  return (error);
}
}
#line 280 "zfs-fuse/zfs_replay.c"
static int zfs_replay_setattr(zfsvfs_t *zfsvfs , lr_setattr_t *lr , boolean_t byteswap ) 
{ znode_t *zp ;
  vattr_t va ;
  int error ;

  {
#line 287
  if (byteswap) {
#line 288
    byteswap_uint64_array((void *)lr, sizeof(*lr));
  }
#line 290
  error = zfs_zget(zfsvfs, lr->lr_foid, & zp);
#line 290
  if (error != 0) {
#line 296
    if (error == 2) {
#line 297
      error = 0;
    }
#line 298
    return (error);
  }
#line 301
  zfs_init_vattr(& va, lr->lr_mask, lr->lr_mode, lr->lr_uid, lr->lr_gid, 0ULL, lr->lr_foid);
#line 304
  va.va_size = lr->lr_size;
#line 305
  va.va_atime.tv_sec = (long )lr->lr_atime[0];
#line 305
  va.va_atime.tv_nsec = (long )lr->lr_atime[1];
#line 306
  va.va_mtime.tv_sec = (long )lr->lr_mtime[0];
#line 306
  va.va_mtime.tv_nsec = (long )lr->lr_mtime[1];
#line 308
  error = fop_setattr(zp->z_vnode, & va, 0, kcred, (caller_context_t *)((void *)0));
#line 310
  vn_rele(zp->z_vnode);
#line 312
  return (error);
}
}
#line 315 "zfs-fuse/zfs_replay.c"
static int zfs_replay_acl(zfsvfs_t *zfsvfs , lr_acl_t *lr , boolean_t byteswap ) 
{ ace_t *ace ;
  vsecattr_t vsa ;
  znode_t *zp ;
  int error ;

  {
#line 318
  ace = (ace_t *)(lr + 1);
#line 323
  if (byteswap) {
#line 324
    byteswap_uint64_array((void *)lr, sizeof(*lr));
#line 325
    zfs_ace_byteswap(ace, (int )lr->lr_aclcnt);
  }
#line 328
  error = zfs_zget(zfsvfs, lr->lr_foid, & zp);
#line 328
  if (error != 0) {
#line 334
    if (error == 2) {
#line 335
      error = 0;
    }
#line 336
    return (error);
  }
#line 339
  bzero((void *)(& vsa), sizeof(vsa));
#line 340
  vsa.vsa_mask = 48U;
#line 341
  vsa.vsa_aclcnt = (int )lr->lr_aclcnt;
#line 342
  vsa.vsa_aclentp = (void *)ace;
#line 344
  error = fop_setsecattr(zp->z_vnode, & vsa, 0, kcred);
#line 346
  vn_rele(zp->z_vnode);
#line 348
  return (error);
}
}
#line 354 "zfs-fuse/zfs_replay.c"
zil_replay_func_t *zfs_replay_vector[13]  = 
#line 354
  {      (zil_replay_func_t *)(& zfs_replay_error),      (zil_replay_func_t *)(& zfs_replay_create),      (zil_replay_func_t *)(& zfs_replay_create),      (zil_replay_func_t *)(& zfs_replay_create), 
        (zil_replay_func_t *)(& zfs_replay_create),      (zil_replay_func_t *)(& zfs_replay_remove),      (zil_replay_func_t *)(& zfs_replay_remove),      (zil_replay_func_t *)(& zfs_replay_link), 
        (zil_replay_func_t *)(& zfs_replay_rename),      (zil_replay_func_t *)(& zfs_replay_write),      (zil_replay_func_t *)(& zfs_replay_truncate),      (zil_replay_func_t *)(& zfs_replay_setattr), 
        (zil_replay_func_t *)(& zfs_replay_acl)};
#line 1 "zfs_rlock.o"
#pragma merger(0,"/tmp/cil-dUipcAmT.i","-pipe,-Wall,-Werror,-std=c99,-Wno-unused,-Wno-missing-braces,-Wno-parentheses,-Wno-uninitialized,-fno-strict-aliasing,-ggdb,-O2")
#line 158 "lib/libavl/include/sys/avl_impl.h"
extern void *avl_walk(struct avl_tree * , void * , int  ) ;
#line 167 "lib/libavl/include/sys/avl.h"
extern void *avl_find(avl_tree_t *tree , void *node , avl_index_t *where ) ;
#line 175
extern void avl_insert(avl_tree_t *tree , void *node , avl_index_t where ) ;
#line 188
extern void avl_insert_here(avl_tree_t *tree , void *new_data , void *here , int direction ) ;
#line 234
extern void *avl_nearest(avl_tree_t *tree , avl_index_t where , int direction ) ;
#line 244
extern void avl_add(avl_tree_t *tree , void *node ) ;
#line 252
extern void avl_remove(avl_tree_t *tree , void *node ) ;
#line 258
extern ulong_t avl_numnodes(avl_tree_t *tree ) ;
#line 65 "lib/libzfscommon/include/sys/zfs_rlock.h"
rl_t *zfs_range_lock(znode_t *zp , uint64_t off , uint64_t len , rl_type_t type ) ;
#line 70
void zfs_range_unlock(rl_t *rl ) ;
#line 76
void zfs_range_reduce(rl_t *rl , uint64_t off , uint64_t len ) ;
#line 81
int zfs_range_compare(void const   *arg1 , void const   *arg2 ) ;
#line 102 "zfs-fuse/zfs_rlock.c"
static void zfs_range_lock_writer(znode_t *zp , rl_t *new ) 
{ avl_tree_t *tree ;
  rl_t *rl ;
  avl_index_t where ;
  uint64_t end_size ;
  uint64_t off ;
  uint64_t len ;
  int max_blksz ;
  ulong_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 105
  tree = & zp->z_range_avl;
#line 109
  off = new->r_off;
#line 110
  len = new->r_len;
#line 111
  max_blksz = (int )(zp->z_zfsvfs)->z_max_blksz;
#line 113
  while (1) {
#line 118
    if ((int )new->r_type == 2) {
#line 119
      new->r_off = (zp->z_phys)->zp_size;
    }
#line 126
    if ((zp->z_phys)->zp_size > new->r_off + len) {
#line 126
      end_size = (zp->z_phys)->zp_size;
    } else {
#line 126
      end_size = new->r_off + len;
    }
#line 127
    if (end_size > (uint64_t )zp->z_blksz) {
#line 127
      if (! ((zp->z_blksz & (zp->z_blksz - 1U)) == 0U)) {
#line 129
        new->r_off = 0ULL;
#line 130
        new->r_len = 0xffffffffffffffffULL;
      } else {
#line 127
        if (zp->z_blksz < (uint_t )max_blksz) {
#line 129
          new->r_off = 0ULL;
#line 130
          new->r_len = 0xffffffffffffffffULL;
        }
      }
    }
#line 136
    tmp = avl_numnodes(tree);
#line 136
    if (tmp == 0UL) {
#line 137
      new->r_type = 1;
#line 138
      avl_add(tree, (void *)new);
#line 139
      return;
    }
#line 145
    tmp___0 = avl_find(tree, (void *)new, & where);
#line 145
    rl = (rl_t *)tmp___0;
#line 146
    if (rl) {
      goto wait;
    }
#line 149
    tmp___1 = avl_nearest(tree, where, 1);
#line 149
    rl = (rl_t *)tmp___1;
#line 150
    if (rl) {
#line 150
      if (rl->r_off < new->r_off + new->r_len) {
        goto wait;
      }
    }
#line 153
    tmp___2 = avl_nearest(tree, where, 0);
#line 153
    rl = (rl_t *)tmp___2;
#line 154
    if (rl) {
#line 154
      if (rl->r_off + rl->r_len > new->r_off) {
        goto wait;
      }
    }
#line 157
    new->r_type = 1;
#line 158
    avl_insert(tree, (void *)new, where);
#line 159
    return;
    wait: 
#line 161
    if (! rl->r_write_wanted) {
#line 162
      cv_init(& rl->r_wr_cv, (char *)((void *)0), 0, (void *)0);
#line 163
      rl->r_write_wanted = (unsigned char)1;
    }
#line 165
    cv_wait(& rl->r_wr_cv, & zp->z_range_lock);
#line 168
    new->r_off = off;
#line 169
    new->r_len = len;
  }
}
}
#line 177 "zfs-fuse/zfs_rlock.c"
static rl_t *zfs_range_proxify(avl_tree_t *tree , rl_t *rl ) 
{ rl_t *proxy ;
  uint64_t __left ;
  uint64_t __right ;
  char *__buf ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 182
  if (rl->r_proxy) {
#line 183
    return (rl);
  }
#line 185
  while (1) {
#line 185
    __left = (unsigned long long )rl->r_cnt;
#line 185
    __right = 1ULL;
#line 185
    if (! (__left == __right)) {
#line 185
      tmp = __builtin_alloca(256U);
#line 185
      __buf = (char *)tmp;
#line 185
      snprintf((char * __restrict  )__buf, 256U, (char const   * __restrict  )"%s %s %s (0x%llx %s 0x%llx)",
               "rl->r_cnt", "==", "1", __left, "==", __right);
#line 185
      while (1) {
#line 185
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                "zfs-fuse/zfs_rlock.c", 185, "zfs_range_proxify", __buf);
#line 185
        abort();
#line 185
        break;
      }
    }
#line 185
    break;
  }
#line 186
  if (! ((int )rl->r_write_wanted == 0)) {
#line 186
    __assert_fail("rl->r_write_wanted == B_FALSE", "zfs-fuse/zfs_rlock.c", 186U, "zfs_range_proxify");
  }
#line 187
  if (! ((int )rl->r_read_wanted == 0)) {
#line 187
    __assert_fail("rl->r_read_wanted == B_FALSE", "zfs-fuse/zfs_rlock.c", 187U, "zfs_range_proxify");
  }
#line 188
  avl_remove(tree, (void *)rl);
#line 189
  rl->r_cnt = 0U;
#line 192
  tmp___0 = umem_alloc(sizeof(rl_t ), 256);
#line 192
  proxy = (rl_t *)tmp___0;
#line 193
  proxy->r_off = rl->r_off;
#line 194
  proxy->r_len = rl->r_len;
#line 195
  proxy->r_cnt = 1U;
#line 196
  proxy->r_type = 0;
#line 197
  proxy->r_proxy = (unsigned char)1;
#line 198
  proxy->r_write_wanted = (unsigned char)0;
#line 199
  proxy->r_read_wanted = (unsigned char)0;
#line 200
  avl_add(tree, (void *)proxy);
#line 202
  return (proxy);
}
}
#line 209 "zfs-fuse/zfs_rlock.c"
static rl_t *zfs_range_split(avl_tree_t *tree , rl_t *rl , uint64_t off ) 
{ rl_t *front ;
  rl_t *rear ;
  uint64_t __left ;
  uint64_t __right ;
  char *__buf ;
  void *tmp ;
  uint64_t __left___0 ;
  uint64_t __right___0 ;
  char *__buf___0 ;
  void *tmp___0 ;
  uint64_t __left___1 ;
  uint64_t __right___1 ;
  char *__buf___1 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 214
  while (1) {
#line 214
    __left = rl->r_len;
#line 214
    __right = 1ULL;
#line 214
    if (! (__left > __right)) {
#line 214
      tmp = __builtin_alloca(256U);
#line 214
      __buf = (char *)tmp;
#line 214
      snprintf((char * __restrict  )__buf, 256U, (char const   * __restrict  )"%s %s %s (0x%llx %s 0x%llx)",
               "rl->r_len", ">", "1", __left, ">", __right);
#line 214
      while (1) {
#line 214
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                "zfs-fuse/zfs_rlock.c", 214, "zfs_range_split", __buf);
#line 214
        abort();
#line 214
        break;
      }
    }
#line 214
    break;
  }
#line 215
  while (1) {
#line 215
    __left___0 = off;
#line 215
    __right___0 = rl->r_off;
#line 215
    if (! (__left___0 > __right___0)) {
#line 215
      tmp___0 = __builtin_alloca(256U);
#line 215
      __buf___0 = (char *)tmp___0;
#line 215
      snprintf((char * __restrict  )__buf___0, 256U, (char const   * __restrict  )"%s %s %s (0x%llx %s 0x%llx)",
               "off", ">", "rl->r_off", __left___0, ">", __right___0);
#line 215
      while (1) {
#line 215
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                "zfs-fuse/zfs_rlock.c", 215, "zfs_range_split", __buf___0);
#line 215
        abort();
#line 215
        break;
      }
    }
#line 215
    break;
  }
#line 216
  while (1) {
#line 216
    __left___1 = off;
#line 216
    __right___1 = rl->r_off + rl->r_len;
#line 216
    if (! (__left___1 < __right___1)) {
#line 216
      tmp___1 = __builtin_alloca(256U);
#line 216
      __buf___1 = (char *)tmp___1;
#line 216
      snprintf((char * __restrict  )__buf___1, 256U, (char const   * __restrict  )"%s %s %s (0x%llx %s 0x%llx)",
               "off", "<", "rl->r_off + rl->r_len", __left___1, "<", __right___1);
#line 216
      while (1) {
#line 216
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                "zfs-fuse/zfs_rlock.c", 216, "zfs_range_split", __buf___1);
#line 216
        abort();
#line 216
        break;
      }
    }
#line 216
    break;
  }
#line 217
  if (! ((int )rl->r_write_wanted == 0)) {
#line 217
    __assert_fail("rl->r_write_wanted == B_FALSE", "zfs-fuse/zfs_rlock.c", 217U, "zfs_range_split");
  }
#line 218
  if (! ((int )rl->r_read_wanted == 0)) {
#line 218
    __assert_fail("rl->r_read_wanted == B_FALSE", "zfs-fuse/zfs_rlock.c", 218U, "zfs_range_split");
  }
#line 221
  tmp___2 = umem_alloc(sizeof(rl_t ), 256);
#line 221
  rear = (rl_t *)tmp___2;
#line 222
  rear->r_off = off;
#line 223
  rear->r_len = (rl->r_off + rl->r_len) - off;
#line 224
  rear->r_cnt = rl->r_cnt;
#line 225
  rear->r_type = 0;
#line 226
  rear->r_proxy = (unsigned char)1;
#line 227
  rear->r_write_wanted = (unsigned char)0;
#line 228
  rear->r_read_wanted = (unsigned char)0;
#line 230
  front = zfs_range_proxify(tree, rl);
#line 231
  front->r_len = off - rl->r_off;
#line 233
  avl_insert_here(tree, (void *)rear, (void *)front, 1);
#line 234
  return (front);
}
}
#line 240 "zfs-fuse/zfs_rlock.c"
static void zfs_range_new_proxy(avl_tree_t *tree , uint64_t off , uint64_t len ) 
{ rl_t *rl ;
  void *tmp ;

  {
#line 245
  if (! len) {
#line 245
    __assert_fail("len", "zfs-fuse/zfs_rlock.c", 245U, "zfs_range_new_proxy");
  }
#line 246
  tmp = umem_alloc(sizeof(rl_t ), 256);
#line 246
  rl = (rl_t *)tmp;
#line 247
  rl->r_off = off;
#line 248
  rl->r_len = len;
#line 249
  rl->r_cnt = 1U;
#line 250
  rl->r_type = 0;
#line 251
  rl->r_proxy = (unsigned char)1;
#line 252
  rl->r_write_wanted = (unsigned char)0;
#line 253
  rl->r_read_wanted = (unsigned char)0;
#line 254
  avl_add(tree, (void *)rl);
#line 255
  return;
}
}
#line 257 "zfs-fuse/zfs_rlock.c"
static void zfs_range_add_reader(avl_tree_t *tree , rl_t *new , rl_t *prev , avl_index_t where ) 
{ rl_t *next ;
  uint64_t off ;
  uint64_t len ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  uint64_t __left ;
  uint64_t __right ;
  char *__buf ;
  void *tmp___2 ;
  uint64_t __left___0 ;
  uint64_t __right___0 ;
  char *__buf___0 ;
  void *tmp___3 ;

  {
#line 261
  off = new->r_off;
#line 262
  len = new->r_len;
#line 271
  if (prev) {
#line 272
    if (prev->r_off + prev->r_len <= off) {
#line 273
      prev = (rl_t *)((void *)0);
    } else {
#line 274
      if (prev->r_off != off) {
#line 279
        prev = zfs_range_split(tree, prev, off);
#line 280
        tmp = avl_walk(tree, (void *)prev, 1);
#line 280
        prev = (rl_t *)tmp;
      }
    }
  }
#line 283
  if (! ((unsigned int )prev == (unsigned int )((void *)0))) {
#line 283
    if (! (prev->r_off == off)) {
#line 283
      __assert_fail("(prev == ((void *)0)) || (prev->r_off == off)", "zfs-fuse/zfs_rlock.c",
                    283U, "zfs_range_add_reader");
    }
  }
#line 285
  if (prev) {
#line 286
    next = prev;
  } else {
#line 288
    tmp___0 = avl_nearest(tree, where, 1);
#line 288
    next = (rl_t *)tmp___0;
  }
#line 290
  if ((unsigned int )next == (unsigned int )((void *)0)) {
#line 292
    avl_insert(tree, (void *)new, where);
#line 293
    return;
  } else {
#line 290
    if (off + len <= next->r_off) {
#line 292
      avl_insert(tree, (void *)new, where);
#line 293
      return;
    }
  }
#line 296
  if (off < next->r_off) {
#line 298
    zfs_range_new_proxy(tree, off, next->r_off - off);
  }
#line 301
  new->r_cnt = 0U;
#line 308
  prev = (rl_t *)((void *)0);
#line 308
  while (next) {
#line 309
    if (off + len <= next->r_off) {
#line 310
      break;
    }
#line 311
    if (prev) {
#line 311
      if (prev->r_off + prev->r_len < next->r_off) {
#line 313
        while (1) {
#line 313
          __left = next->r_off;
#line 313
          __right = prev->r_off + prev->r_len;
#line 313
          if (! (__left > __right)) {
#line 313
            tmp___2 = __builtin_alloca(256U);
#line 313
            __buf = (char *)tmp___2;
#line 313
            snprintf((char * __restrict  )__buf, 256U, (char const   * __restrict  )"%s %s %s (0x%llx %s 0x%llx)",
                     "next->r_off", ">", "prev->r_off + prev->r_len", __left, ">",
                     __right);
#line 313
            while (1) {
#line 313
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                      "zfs-fuse/zfs_rlock.c", 313, "zfs_range_add_reader", __buf);
#line 313
              abort();
#line 313
              break;
            }
          }
#line 313
          break;
        }
#line 314
        zfs_range_new_proxy(tree, prev->r_off + prev->r_len, next->r_off - (prev->r_off + prev->r_len));
      }
    }
#line 317
    if (off + len == next->r_off + next->r_len) {
#line 319
      next = zfs_range_proxify(tree, next);
#line 320
      (next->r_cnt) ++;
#line 321
      return;
    }
#line 323
    if (off + len < next->r_off + next->r_len) {
#line 325
      next = zfs_range_split(tree, next, off + len);
#line 326
      (next->r_cnt) ++;
#line 327
      return;
    }
#line 329
    while (1) {
#line 329
      __left___0 = off + len;
#line 329
      __right___0 = next->r_off + next->r_len;
#line 329
      if (! (__left___0 > __right___0)) {
#line 329
        tmp___3 = __builtin_alloca(256U);
#line 329
        __buf___0 = (char *)tmp___3;
#line 329
        snprintf((char * __restrict  )__buf___0, 256U, (char const   * __restrict  )"%s %s %s (0x%llx %s 0x%llx)",
                 "off + len", ">", "next->r_off + next->r_len", __left___0, ">", __right___0);
#line 329
        while (1) {
#line 329
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                  "zfs-fuse/zfs_rlock.c", 329, "zfs_range_add_reader", __buf___0);
#line 329
          abort();
#line 329
          break;
        }
      }
#line 329
      break;
    }
#line 330
    next = zfs_range_proxify(tree, next);
#line 331
    (next->r_cnt) ++;
#line 308
    prev = next;
#line 308
    tmp___1 = avl_walk(tree, (void *)next, 1);
#line 308
    next = (rl_t *)tmp___1;
  }
#line 335
  zfs_range_new_proxy(tree, prev->r_off + prev->r_len, (off + len) - (prev->r_off + prev->r_len));
#line 337
  return;
}
}
#line 342 "zfs-fuse/zfs_rlock.c"
static void zfs_range_lock_reader(znode_t *zp , rl_t *new ) 
{ avl_tree_t *tree ;
  rl_t *prev ;
  rl_t *next ;
  avl_index_t where ;
  uint64_t off ;
  uint64_t len ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 345
  tree = & zp->z_range_avl;
#line 348
  off = new->r_off;
#line 349
  len = new->r_len;
  retry: 
#line 355
  tmp = avl_find(tree, (void *)new, & where);
#line 355
  prev = (rl_t *)tmp;
#line 356
  if ((unsigned int )prev == (unsigned int )((void *)0)) {
#line 357
    tmp___0 = avl_nearest(tree, where, 0);
#line 357
    prev = (rl_t *)tmp___0;
  }
#line 362
  if (prev) {
#line 362
    if (off < prev->r_off + prev->r_len) {
#line 363
      if ((int )prev->r_type == 1) {
        goto _L;
      } else {
#line 363
        if (prev->r_write_wanted) {
          _L: /* CIL Label */ 
#line 364
          if (! prev->r_read_wanted) {
#line 365
            cv_init(& prev->r_rd_cv, (char *)((void *)0), 0, (void *)0);
#line 366
            prev->r_read_wanted = (unsigned char)1;
          }
#line 368
          cv_wait(& prev->r_rd_cv, & zp->z_range_lock);
          goto retry;
        }
      }
#line 371
      if (off + len < prev->r_off + prev->r_len) {
        goto got_lock;
      }
    }
  }
#line 379
  if (prev) {
#line 380
    tmp___1 = avl_walk(tree, (void *)prev, 1);
#line 380
    next = (rl_t *)tmp___1;
  } else {
#line 382
    tmp___2 = avl_nearest(tree, where, 1);
#line 382
    next = (rl_t *)tmp___2;
  }
#line 383
  while (next) {
#line 384
    if (off + len <= next->r_off) {
      goto got_lock;
    }
#line 386
    if ((int )next->r_type == 1) {
      goto _L___0;
    } else {
#line 386
      if (next->r_write_wanted) {
        _L___0: /* CIL Label */ 
#line 387
        if (! next->r_read_wanted) {
#line 388
          cv_init(& next->r_rd_cv, (char *)((void *)0), 0, (void *)0);
#line 389
          next->r_read_wanted = (unsigned char)1;
        }
#line 391
        cv_wait(& next->r_rd_cv, & zp->z_range_lock);
        goto retry;
      }
    }
#line 394
    if (off + len <= next->r_off + next->r_len) {
      goto got_lock;
    }
#line 383
    tmp___3 = avl_walk(tree, (void *)next, 1);
#line 383
    next = (rl_t *)tmp___3;
  }
  got_lock: 
#line 403
  zfs_range_add_reader(tree, new, prev, where);
#line 404
  return;
}
}
#line 412 "zfs-fuse/zfs_rlock.c"
rl_t *zfs_range_lock(znode_t *zp , uint64_t off , uint64_t len , rl_type_t type ) 
{ rl_t *new ;
  void *tmp ;
  ulong_t tmp___0 ;

  {
#line 417
  if (! ((int )type == 0)) {
#line 417
    if (! ((int )type == 1)) {
#line 417
      if (! ((int )type == 2)) {
#line 417
        __assert_fail("type == RL_READER || type == RL_WRITER || type == RL_APPEND",
                      "zfs-fuse/zfs_rlock.c", 417U, "zfs_range_lock");
      }
    }
  }
#line 419
  tmp = umem_alloc(sizeof(rl_t ), 256);
#line 419
  new = (rl_t *)tmp;
#line 420
  new->r_zp = zp;
#line 421
  new->r_off = off;
#line 422
  new->r_len = len;
#line 423
  new->r_cnt = 1U;
#line 424
  new->r_type = type;
#line 425
  new->r_proxy = (unsigned char)0;
#line 426
  new->r_write_wanted = (unsigned char)0;
#line 427
  new->r_read_wanted = (unsigned char)0;
#line 429
  mutex_enter(& zp->z_range_lock);
#line 430
  if ((int )type == 0) {
#line 434
    tmp___0 = avl_numnodes(& zp->z_range_avl);
#line 434
    if (tmp___0 == 0UL) {
#line 435
      avl_add(& zp->z_range_avl, (void *)new);
    } else {
#line 437
      zfs_range_lock_reader(zp, new);
    }
  } else {
#line 439
    zfs_range_lock_writer(zp, new);
  }
#line 440
  mutex_exit(& zp->z_range_lock);
#line 441
  return (new);
}
}
#line 447 "zfs-fuse/zfs_rlock.c"
static void zfs_range_unlock_reader(znode_t *zp , rl_t *remove___0 ) 
{ avl_tree_t *tree ;
  rl_t *rl ;
  rl_t *next ;
  uint64_t len ;
  uint64_t __left ;
  uint64_t __right ;
  char *__buf ;
  void *tmp ;
  uint64_t __left___0 ;
  uint64_t __right___0 ;
  char *__buf___0 ;
  void *tmp___0 ;
  uint64_t __left___1 ;
  uint64_t __right___1 ;
  char *__buf___1 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 450
  tree = & zp->z_range_avl;
#line 461
  if (remove___0->r_cnt == 1U) {
#line 462
    avl_remove(tree, (void *)remove___0);
#line 463
    if (remove___0->r_write_wanted) {
#line 464
      cv_broadcast(& remove___0->r_wr_cv);
    }
#line 465
    if (remove___0->r_read_wanted) {
#line 466
      cv_broadcast(& remove___0->r_rd_cv);
    }
  } else {
#line 468
    while (1) {
#line 468
      __left = (unsigned long long )remove___0->r_cnt;
#line 468
      __right = 0ULL;
#line 468
      if (! (__left == __right)) {
#line 468
        tmp = __builtin_alloca(256U);
#line 468
        __buf = (char *)tmp;
#line 468
        snprintf((char * __restrict  )__buf, 256U, (char const   * __restrict  )"%s %s %s (0x%llx %s 0x%llx)",
                 "remove->r_cnt", "==", "0", __left, "==", __right);
#line 468
        while (1) {
#line 468
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                  "zfs-fuse/zfs_rlock.c", 468, "zfs_range_unlock_reader", __buf);
#line 468
          abort();
#line 468
          break;
        }
      }
#line 468
      break;
    }
#line 469
    while (1) {
#line 469
      __left___0 = (unsigned long long )remove___0->r_write_wanted;
#line 469
      __right___0 = 0ULL;
#line 469
      if (! (__left___0 == __right___0)) {
#line 469
        tmp___0 = __builtin_alloca(256U);
#line 469
        __buf___0 = (char *)tmp___0;
#line 469
        snprintf((char * __restrict  )__buf___0, 256U, (char const   * __restrict  )"%s %s %s (0x%llx %s 0x%llx)",
                 "remove->r_write_wanted", "==", "0", __left___0, "==", __right___0);
#line 469
        while (1) {
#line 469
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                  "zfs-fuse/zfs_rlock.c", 469, "zfs_range_unlock_reader", __buf___0);
#line 469
          abort();
#line 469
          break;
        }
      }
#line 469
      break;
    }
#line 470
    while (1) {
#line 470
      __left___1 = (unsigned long long )remove___0->r_read_wanted;
#line 470
      __right___1 = 0ULL;
#line 470
      if (! (__left___1 == __right___1)) {
#line 470
        tmp___1 = __builtin_alloca(256U);
#line 470
        __buf___1 = (char *)tmp___1;
#line 470
        snprintf((char * __restrict  )__buf___1, 256U, (char const   * __restrict  )"%s %s %s (0x%llx %s 0x%llx)",
                 "remove->r_read_wanted", "==", "0", __left___1, "==", __right___1);
#line 470
        while (1) {
#line 470
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                  "zfs-fuse/zfs_rlock.c", 470, "zfs_range_unlock_reader", __buf___1);
#line 470
          abort();
#line 470
          break;
        }
      }
#line 470
      break;
    }
#line 476
    tmp___2 = avl_find(tree, (void *)remove___0, (avl_index_t *)((void *)0));
#line 476
    rl = (rl_t *)tmp___2;
#line 477
    if (! rl) {
#line 477
      __assert_fail("rl", "zfs-fuse/zfs_rlock.c", 477U, "zfs_range_unlock_reader");
    }
#line 478
    if (! rl->r_cnt) {
#line 478
      __assert_fail("rl->r_cnt", "zfs-fuse/zfs_rlock.c", 478U, "zfs_range_unlock_reader");
    }
#line 479
    if (! ((int )rl->r_type == 0)) {
#line 479
      __assert_fail("rl->r_type == RL_READER", "zfs-fuse/zfs_rlock.c", 479U, "zfs_range_unlock_reader");
    }
#line 480
    len = remove___0->r_len;
#line 480
    while (len != 0ULL) {
#line 481
      len -= rl->r_len;
#line 482
      if (len) {
#line 483
        tmp___3 = avl_walk(tree, (void *)rl, 1);
#line 483
        next = (rl_t *)tmp___3;
#line 484
        if (! next) {
#line 484
          __assert_fail("next", "zfs-fuse/zfs_rlock.c", 484U, "zfs_range_unlock_reader");
        }
#line 485
        if (! (rl->r_off + rl->r_len == next->r_off)) {
#line 485
          __assert_fail("rl->r_off + rl->r_len == next->r_off", "zfs-fuse/zfs_rlock.c",
                        485U, "zfs_range_unlock_reader");
        }
#line 486
        if (! next->r_cnt) {
#line 486
          __assert_fail("next->r_cnt", "zfs-fuse/zfs_rlock.c", 486U, "zfs_range_unlock_reader");
        }
#line 487
        if (! ((int )next->r_type == 0)) {
#line 487
          __assert_fail("next->r_type == RL_READER", "zfs-fuse/zfs_rlock.c", 487U,
                        "zfs_range_unlock_reader");
        }
      }
#line 489
      (rl->r_cnt) --;
#line 490
      if (rl->r_cnt == 0U) {
#line 491
        avl_remove(tree, (void *)rl);
#line 492
        if (rl->r_write_wanted) {
#line 493
          cv_broadcast(& rl->r_wr_cv);
        }
#line 494
        if (rl->r_read_wanted) {
#line 495
          cv_broadcast(& rl->r_rd_cv);
        }
#line 496
        umem_free((void *)rl, sizeof(rl_t ));
      }
#line 480
      rl = next;
    }
  }
#line 500
  umem_free((void *)remove___0, sizeof(rl_t ));
#line 501
  return;
}
}
#line 506 "zfs-fuse/zfs_rlock.c"
void zfs_range_unlock(rl_t *rl ) 
{ znode_t *zp ;

  {
#line 509
  zp = rl->r_zp;
#line 511
  if (! ((int )rl->r_type == 1)) {
#line 511
    if (! ((int )rl->r_type == 0)) {
#line 511
      __assert_fail("rl->r_type == RL_WRITER || rl->r_type == RL_READER", "zfs-fuse/zfs_rlock.c",
                    511U, "zfs_range_unlock");
    }
  }
#line 512
  if (! (rl->r_cnt == 1U)) {
#line 512
    if (! (rl->r_cnt == 0U)) {
#line 512
      __assert_fail("rl->r_cnt == 1 || rl->r_cnt == 0", "zfs-fuse/zfs_rlock.c", 512U,
                    "zfs_range_unlock");
    }
  }
#line 513
  if (! (! rl->r_proxy)) {
#line 513
    __assert_fail("!rl->r_proxy", "zfs-fuse/zfs_rlock.c", 513U, "zfs_range_unlock");
  }
#line 515
  mutex_enter(& zp->z_range_lock);
#line 516
  if ((int )rl->r_type == 1) {
#line 518
    avl_remove(& zp->z_range_avl, (void *)rl);
#line 519
    mutex_exit(& zp->z_range_lock);
#line 520
    if (rl->r_write_wanted) {
#line 521
      cv_broadcast(& rl->r_wr_cv);
    }
#line 522
    if (rl->r_read_wanted) {
#line 523
      cv_broadcast(& rl->r_rd_cv);
    }
#line 524
    umem_free((void *)rl, sizeof(rl_t ));
  } else {
#line 530
    zfs_range_unlock_reader(zp, rl);
#line 531
    mutex_exit(& zp->z_range_lock);
  }
#line 533
  return;
}
}
#line 540 "zfs-fuse/zfs_rlock.c"
void zfs_range_reduce(rl_t *rl , uint64_t off , uint64_t len ) 
{ znode_t *zp ;
  ulong_t tmp ;
  uint64_t __left ;
  uint64_t __right ;
  char *__buf ;
  void *tmp___0 ;
  uint64_t __left___0 ;
  uint64_t __right___0 ;
  char *__buf___0 ;
  void *tmp___1 ;

  {
#line 543
  zp = rl->r_zp;
#line 546
  tmp = avl_numnodes(& zp->z_range_avl);
#line 546
  if (! (tmp == 1UL)) {
#line 546
    __assert_fail("avl_numnodes(&zp->z_range_avl) == 1", "zfs-fuse/zfs_rlock.c", 546U,
                  "zfs_range_reduce");
  }
#line 547
  if (! (rl->r_off == 0ULL)) {
#line 547
    __assert_fail("rl->r_off == 0", "zfs-fuse/zfs_rlock.c", 547U, "zfs_range_reduce");
  }
#line 548
  if (! ((int )rl->r_type == 1)) {
#line 548
    __assert_fail("rl->r_type == RL_WRITER", "zfs-fuse/zfs_rlock.c", 548U, "zfs_range_reduce");
  }
#line 549
  if (! (! rl->r_proxy)) {
#line 549
    __assert_fail("!rl->r_proxy", "zfs-fuse/zfs_rlock.c", 549U, "zfs_range_reduce");
  }
#line 550
  while (1) {
#line 550
    __left = rl->r_len;
#line 550
    __right = 0xffffffffffffffffULL;
#line 550
    if (! (__left == __right)) {
#line 550
      tmp___0 = __builtin_alloca(256U);
#line 550
      __buf = (char *)tmp___0;
#line 550
      snprintf((char * __restrict  )__buf, 256U, (char const   * __restrict  )"%s %s %s (0x%llx %s 0x%llx)",
               "rl->r_len", "==", "(18446744073709551615ULL)", __left, "==", __right);
#line 550
      while (1) {
#line 550
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                "zfs-fuse/zfs_rlock.c", 550, "zfs_range_reduce", __buf);
#line 550
        abort();
#line 550
        break;
      }
    }
#line 550
    break;
  }
#line 551
  while (1) {
#line 551
    __left___0 = (unsigned long long )rl->r_cnt;
#line 551
    __right___0 = 1ULL;
#line 551
    if (! (__left___0 == __right___0)) {
#line 551
      tmp___1 = __builtin_alloca(256U);
#line 551
      __buf___0 = (char *)tmp___1;
#line 551
      snprintf((char * __restrict  )__buf___0, 256U, (char const   * __restrict  )"%s %s %s (0x%llx %s 0x%llx)",
               "rl->r_cnt", "==", "1", __left___0, "==", __right___0);
#line 551
      while (1) {
#line 551
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                "zfs-fuse/zfs_rlock.c", 551, "zfs_range_reduce", __buf___0);
#line 551
        abort();
#line 551
        break;
      }
    }
#line 551
    break;
  }
#line 553
  mutex_enter(& zp->z_range_lock);
#line 554
  rl->r_off = off;
#line 555
  rl->r_len = len;
#line 556
  mutex_exit(& zp->z_range_lock);
#line 557
  if (rl->r_write_wanted) {
#line 558
    cv_broadcast(& rl->r_wr_cv);
  }
#line 559
  if (rl->r_read_wanted) {
#line 560
    cv_broadcast(& rl->r_rd_cv);
  }
#line 561
  return;
}
}
#line 567 "zfs-fuse/zfs_rlock.c"
int zfs_range_compare(void const   *arg1 , void const   *arg2 ) 
{ rl_t const   *rl1 ;
  rl_t const   *rl2 ;

  {
#line 570
  rl1 = (rl_t const   *)arg1;
#line 571
  rl2 = (rl_t const   *)arg2;
#line 573
  if (rl1->r_off > rl2->r_off) {
#line 574
    return (1);
  }
#line 575
  if (rl1->r_off < rl2->r_off) {
#line 576
    return (-1);
  }
#line 577
  return (0);
}
}
#line 1 "zfs_vfsops.o"
#pragma merger(0,"/tmp/cil-SPF2vMjF.i","-pipe,-Wall,-Werror,-std=c99,-Wno-unused,-Wno-missing-braces,-Wno-parentheses,-Wno-uninitialized,-fno-strict-aliasing,-ggdb,-O2")
#line 36 "/usr/include/sys/sysmacros.h"
__inline static  __attribute__((__nothrow__)) unsigned long long gnu_dev_makedev(unsigned int __major ,
                                                                                 unsigned int __minor ) ;
#line 53
__inline static  __attribute__((__nothrow__)) unsigned long long gnu_dev_makedev(unsigned int __major ,
                                                                                 unsigned int __minor ) ;
#line 53 "/usr/include/sys/sysmacros.h"
__inline static unsigned long long gnu_dev_makedev(unsigned int __major , unsigned int __minor ) 
{ 

  {
#line 56
  return (((unsigned long long )((__minor & 255U) | ((__major & 4095U) << 8)) | ((unsigned long long )(__minor & 4294967040U) << 12)) | ((unsigned long long )(__major & 4294963200U) << 32));
}
}
#line 44 "lib/libsolkerncompat/include/sys/mutex.h"
extern void zmutex_init(kmutex_t *mp ) ;
#line 51 "lib/libsolkerncompat/include/sys/rwlock.h"
extern void rw_init(krwlock_t *rwlp , char *name , int type , void *arg ) ;
#line 73 "lib/libsolkerncompat/include/sys/pathname.h"
extern int pn_get(char * , enum uio_seg  , struct pathname * ) ;
#line 84
extern void pn_free(struct pathname * ) ;
#line 101 "lib/libsolkerncompat/include/sys/vfs.h"
extern int vfs_setfsops(int  , fs_operation_def_t const   * , vfsops_t ** ) ;
#line 41 "lib/libzfscommon/include/sys/list.h"
extern void list_create(list_t * , size_t  , size_t  ) ;
#line 53
extern void *list_next(list_t * , void * ) ;
#line 157 "lib/libzfscommon/include/sys/dmu.h"
extern int dmu_objset_evict_dbufs(objset_t *os , int try ) ;
#line 315
extern void dmu_buf_rele(dmu_buf_t *db , void *tag ) ;
#line 509
extern void dmu_objset_space(objset_t *os , uint64_t *refdbytesp , uint64_t *availbytesp ,
                             uint64_t *usedobjsp , uint64_t *availobjsp ) ;
#line 519
extern int dmu_objset_is_snapshot(objset_t *os ) ;
#line 523
extern struct dsl_pool *dmu_objset_pool(objset_t *os ) ;
#line 80 "lib/libsolkerncompat/include/sys/atomic.h"
extern void atomic_add_32(uint32_t volatile   * , int32_t  ) ;
#line 361 "lib/libzfscommon/include/sys/spa.h"
extern void spa_sync_allpools(void) ;
#line 84 "lib/libzfscommon/include/sys/txg.h"
extern void txg_wait_synced(struct dsl_pool *dp , uint64_t txg ) ;
#line 248 "lib/libzfscommon/include/sys/zil.h"
extern zilog_t *zil_open(objset_t *os , zil_get_data_t *get_data ) ;
#line 249
extern void zil_close(zilog_t *zilog ) ;
#line 251
extern void zil_replay(objset_t *os , void *arg , uint64_t *txgp , zil_replay_func_t **replay_func ,
                       void (*rm_wait)(void * ) ) ;
#line 258
extern void zil_commit(zilog_t *zilog , uint64_t seq , uint64_t oid ) ;
#line 270
extern int zil_disable ;
#line 239 "lib/libzfscommon/include/sys/zfs_znode.h"
int zfs_init_fs(zfsvfs_t *zfsvfs , znode_t **zpp , cred_t *cr ) ;
#line 246
void zfs_znode_init(void) ;
#line 247
void zfs_znode_fini(void) ;
#line 254
void zfs_remove_op_tables(void) ;
#line 255
int zfs_create_op_tables(void) ;
#line 256
int zfs_sync(vfs_t *vfsp , short flag , cred_t *cr ) ;
#line 278
int zfs_get_data(void *arg , lr_write_t *lr , char *buf , zio_t *zio ) ;
#line 280 "lib/libzfscommon/include/sys/zfs_znode.h"
int zfsfstype  ;
#line 60 "zfs-fuse/zfs_vfsops.c"
vfsops_t *zfs_vfsops  =    (vfsops_t *)((void *)0);
#line 64 "zfs-fuse/zfs_vfsops.c"
static kmutex_t zfs_dev_mtx  ;
#line 68
static int zfs_mount(vfs_t *vfsp , vnode_t *mvp , struct mounta *uap , cred_t *cr ) ;
#line 69
static int zfs_umount(vfs_t *vfsp , int fflag , cred_t *cr ) ;
#line 70
static int zfs_mountroot(vfs_t *vfsp , enum whymountroot why ) ;
#line 71
static int zfs_root(vfs_t *vfsp , vnode_t **vpp ) ;
#line 72
static int zfs_statvfs(vfs_t *vfsp , struct statvfs64 *statp ) ;
#line 73
static int zfs_vget(vfs_t *vfsp , vnode_t **vpp , fid_t *fidp ) ;
#line 74
static void zfs_freevfs(vfs_t *vfsp ) ;
#line 75
static void zfs_objset_close(zfsvfs_t *zfsvfs ) ;
#line 77 "zfs-fuse/zfs_vfsops.c"
static fs_operation_def_t const   zfs_vfsops_template[9]  = 
#line 77
  {      {(char *)"mount", (int (*)())(& zfs_mount)}, 
        {(char *)"mountroot", (int (*)())(& zfs_mountroot)}, 
        {(char *)"unmount", (int (*)())(& zfs_umount)}, 
        {(char *)"root", (int (*)())(& zfs_root)}, 
        {(char *)"statvfs", (int (*)())(& zfs_statvfs)}, 
        {(char *)"sync", (int (*)())(& zfs_sync)}, 
        {(char *)"vget", (int (*)())(& zfs_vget)}, 
        {(char *)"freevfs", (int (*)())(& zfs_freevfs)}, 
        {(char *)((void *)0), (int (*)())((void *)0)}};
#line 101 "zfs-fuse/zfs_vfsops.c"
static uint32_t zfs_active_fs_count  =    (uint32_t )0;
#line 127 "zfs-fuse/zfs_vfsops.c"
int zfs_sync(vfs_t *vfsp , short flag , cred_t *cr ) 
{ zfsvfs_t *zfsvfs ;
  struct dsl_pool *tmp ;

  {
#line 149
  if ((unsigned int )vfsp != (unsigned int )((void *)0)) {
#line 153
    zfsvfs = (zfsvfs_t *)vfsp->vfs_data;
#line 155
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 155
    if (zfsvfs->z_unmounted1) {
#line 155
      atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 155
      return (5);
    }
#line 156
    if ((unsigned int )zfsvfs->z_log != (unsigned int )((void *)0)) {
#line 157
      zil_commit(zfsvfs->z_log, 0xffffffffffffffffULL, 0ULL);
    } else {
#line 159
      tmp = dmu_objset_pool(zfsvfs->z_os);
#line 159
      txg_wait_synced(tmp, 0ULL);
    }
#line 160
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
  } else {
#line 167
    spa_sync_allpools();
  }
#line 170
  return (0);
}
}
#line 173 "zfs-fuse/zfs_vfsops.c"
static int zfs_create_unique_device(dev_t *dev ) 
{ 

  {
#line 177
  *dev = gnu_dev_makedev(0U, 0U);
#line 178
  return (0);
}
}
#line 230 "zfs-fuse/zfs_vfsops.c"
static void atime_changed_cb(void *arg , uint64_t newval ) 
{ zfsvfs_t *zfsvfs ;

  {
#line 233
  zfsvfs = (zfsvfs_t *)arg;
#line 235
  if (newval == 1ULL) {
#line 236
    zfsvfs->z_atime = (enum boolean )1;
  } else {
#line 240
    zfsvfs->z_atime = (enum boolean )0;
  }
#line 244
  return;
}
}
#line 246 "zfs-fuse/zfs_vfsops.c"
static void xattr_changed_cb(void *arg , uint64_t newval ) 
{ zfsvfs_t *zfsvfs ;

  {
#line 249
  zfsvfs = (zfsvfs_t *)arg;
#line 251
  if (newval == 1ULL) {
#line 253
    (zfsvfs->z_vfs)->vfs_flag |= 1024U;
  } else {
#line 258
    (zfsvfs->z_vfs)->vfs_flag &= 4294966271U;
  }
#line 262
  return;
}
}
#line 278 "zfs-fuse/zfs_vfsops.c"
static void readonly_changed_cb(void *arg , uint64_t newval ) 
{ zfsvfs_t *zfsvfs ;

  {
#line 281
  zfsvfs = (zfsvfs_t *)arg;
#line 283
  if (newval) {
#line 285
    (zfsvfs->z_vfs)->vfs_flag |= 1U;
#line 288
    zfs_delete_thread_target(zfsvfs, 0);
  } else {
#line 291
    (zfsvfs->z_vfs)->vfs_flag &= 4294967294U;
#line 294
    zfs_delete_thread_target(zfsvfs, 1);
  }
#line 296
  return;
}
}
#line 372 "zfs-fuse/zfs_vfsops.c"
static int zfs_refresh_properties(vfs_t *vfsp ) 
{ zfsvfs_t *zfsvfs ;
  int tmp ;

  {
#line 375
  zfsvfs = (zfsvfs_t *)vfsp->vfs_data;
#line 384
  tmp = dmu_objset_is_snapshot(zfsvfs->z_os);
#line 384
  if (! tmp) {
#line 385
    readonly_changed_cb((void *)zfsvfs, 0ULL);
  }
#line 420
  return (0);
}
}
#line 561 "zfs-fuse/zfs_vfsops.c"
static int zfs_domount(vfs_t *vfsp , char *osname , cred_t *cr ) 
{ dev_t mount_dev ;
  uint64_t recordsize ;
  uint64_t readonly ;
  int error ;
  int mode ;
  zfsvfs_t *zfsvfs ;
  znode_t *zp ;
  void *tmp ;
  int tmp___0 ;
  uint64_t xattr ;
  int tmp___1 ;

  {
#line 566
  error = 0;
#line 569
  zp = (znode_t *)((void *)0);
#line 571
  if (! vfsp) {
#line 571
    __assert_fail("vfsp", "zfs-fuse/zfs_vfsops.c", 571U, "zfs_domount");
  }
#line 572
  if (! osname) {
#line 572
    __assert_fail("osname", "zfs-fuse/zfs_vfsops.c", 572U, "zfs_domount");
  }
#line 579
  tmp = umem_zalloc(sizeof(zfsvfs_t ), 256);
#line 579
  zfsvfs = (zfsvfs_t *)tmp;
#line 580
  zfsvfs->z_vfs = vfsp;
#line 581
  zfsvfs->z_parent = zfsvfs;
#line 582
  zfsvfs->z_assign = 2ULL;
#line 583
  zfsvfs->z_max_blksz = 1ULL << 17;
#line 584
  zfsvfs->z_show_ctldir = (enum boolean )1;
#line 586
  zmutex_init(& zfsvfs->z_znodes_lock);
#line 587
  list_create(& zfsvfs->z_all_znodes, sizeof(znode_t ), (unsigned int )(& ((znode_t *)0)->z_link_node));
#line 589
  rw_init(& zfsvfs->z_um_lock, (char *)((void *)0), 0, (void *)0);
#line 592
  vfsp->vfs_bcount = 0UL;
#line 593
  vfsp->vfs_data = (void *)0;
#line 595
  tmp___0 = zfs_create_unique_device(& mount_dev);
#line 595
  if (tmp___0 == -1) {
#line 596
    error = 19;
    goto out;
  }
#line 602
  error = dsl_prop_get_integer((char const   *)osname, "recordsize", & recordsize,
                               (char *)((void *)0));
#line 602
  if (error) {
    goto out;
  }
#line 606
  vfsp->vfs_dev = mount_dev;
#line 607
  vfsp->vfs_fstype = zfsfstype;
#line 608
  vfsp->vfs_bsize = (unsigned int )recordsize;
#line 609
  vfsp->vfs_flag |= 32U;
#line 610
  vfsp->vfs_data = (void *)zfsvfs;
#line 612
  error = dsl_prop_get_integer((char const   *)osname, "readonly", & readonly, (char *)((void *)0));
#line 612
  if (error) {
    goto out;
  }
#line 615
  if (readonly) {
#line 616
    mode = 10;
  } else {
#line 618
    mode = 2;
  }
#line 620
  error = dmu_objset_open((char const   *)osname, 2, mode, & zfsvfs->z_os);
#line 621
  if (error == 30) {
#line 622
    mode = 10;
#line 623
    error = dmu_objset_open((char const   *)osname, 2, mode, & zfsvfs->z_os);
  }
#line 627
  if (error) {
    goto out;
  }
#line 630
  error = zfs_init_fs(zfsvfs, & zp, cr);
#line 630
  if (error) {
    goto out;
  }
#line 634
  vn_rele(zp->z_vnode);
#line 636
  tmp___1 = dmu_objset_is_snapshot(zfsvfs->z_os);
#line 636
  if (tmp___1) {
#line 639
    if (! (mode & 8)) {
#line 639
      __assert_fail("mode & 0x8", "zfs-fuse/zfs_vfsops.c", 639U, "zfs_domount");
    }
#line 640
    atime_changed_cb((void *)zfsvfs, 0ULL);
#line 641
    readonly_changed_cb((void *)zfsvfs, 1ULL);
#line 642
    error = dsl_prop_get_integer((char const   *)osname, "xattr", & xattr, (char *)((void *)0));
#line 642
    if (error) {
      goto out;
    }
#line 644
    xattr_changed_cb((void *)zfsvfs, xattr);
#line 645
    zfsvfs->z_issnap = 1;
  } else {
#line 655
    zfs_delete_thread_target(zfsvfs, 1);
#line 660
    zil_replay(zfsvfs->z_os, (void *)zfsvfs, & zfsvfs->z_assign, (zil_replay_func_t **)(zfs_replay_vector),
               (void (*)(void * ))(& zfs_delete_wait_empty));
#line 663
    if (! zil_disable) {
#line 664
      zfsvfs->z_log = zil_open(zfsvfs->z_os, & zfs_get_data);
    }
  }
  out: 
#line 671
  if (error) {
#line 672
    if (zfsvfs->z_os) {
#line 673
      dmu_objset_close(zfsvfs->z_os);
    }
#line 674
    umem_free((void *)zfsvfs, sizeof(zfsvfs_t ));
  } else {
#line 676
    atomic_add_32((uint32_t volatile   *)(& zfs_active_fs_count), 1);
  }
#line 679
  return (error);
}
}
#line 728 "zfs-fuse/zfs_vfsops.c"
static int zfs_mountroot(vfs_t *vfsp , enum whymountroot why ) 
{ 

  {
#line 732
  abort();
}
}
#line 817 "zfs-fuse/zfs_vfsops.c"
static int zfs_mount(vfs_t *vfsp , vnode_t *mvp , struct mounta *uap , cred_t *cr ) 
{ char *osname ;
  pathname_t spn ;
  int error ;
  uio_seg_t fromspace ;
  int tmp ;
  int tmp___0 ;

  {
#line 822
  error = 0;
#line 823
  if (uap->flags & 8) {
#line 823
    tmp = 1;
  } else {
#line 823
    tmp = 0;
  }
#line 823
  fromspace = (uio_seg_t )tmp;
#line 827
  if ((int )mvp->v_type != 2) {
#line 828
    return (20);
  }
#line 830
  mutex_enter(& mvp->v_lock);
#line 831
  if ((uap->flags & 32) == 0) {
#line 831
    if ((uap->flags & 128) == 0) {
#line 831
      if (mvp->v_count != 1U) {
#line 834
        mutex_exit(& mvp->v_lock);
#line 835
        return (16);
      } else {
#line 831
        if (mvp->v_flag & 1U) {
#line 834
          mutex_exit(& mvp->v_lock);
#line 835
          return (16);
        }
      }
    }
  }
#line 837
  mutex_exit(& mvp->v_lock);
#line 845
  if (uap->flags & 4) {
#line 845
    if (uap->datalen > 0) {
#line 846
      return (22);
    }
  }
#line 852
  if (uap->flags & 32) {
#line 853
    tmp___0 = zfs_refresh_properties(vfsp);
#line 853
    return (tmp___0);
  }
#line 859
  error = pn_get(uap->spec, fromspace, & spn);
#line 859
  if (error) {
#line 860
    return (error);
  }
#line 862
  osname = spn.pn_path;
#line 864
  error = 0;
#line 864
  if (error != 0) {
    goto out;
  }
#line 877
  error = zfs_domount(vfsp, osname, cr);
  out: 
#line 880
  pn_free(& spn);
#line 881
  return (error);
}
}
#line 884 "zfs-fuse/zfs_vfsops.c"
static int zfs_statvfs(vfs_t *vfsp , struct statvfs64 *statp ) 
{ zfsvfs_t *zfsvfs ;
  uint64_t refdbytes ;
  uint64_t availbytes ;
  uint64_t usedobjs ;
  uint64_t availobjs ;

  {
#line 887
  zfsvfs = (zfsvfs_t *)vfsp->vfs_data;
#line 891
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 891
  if (zfsvfs->z_unmounted1) {
#line 891
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 891
    return (5);
  }
#line 893
  dmu_objset_space(zfsvfs->z_os, & refdbytes, & availbytes, & usedobjs, & availobjs);
#line 901
  statp->f_frsize = 1UL << 9;
#line 902
  statp->f_bsize = (unsigned long )zfsvfs->z_max_blksz;
#line 910
  statp->f_blocks = (refdbytes + availbytes) >> 9;
#line 911
  statp->f_bfree = availbytes >> 9;
#line 912
  statp->f_bavail = statp->f_bfree;
#line 922
  if (availobjs < statp->f_bfree) {
#line 922
    statp->f_ffree = availobjs;
  } else {
#line 922
    statp->f_ffree = statp->f_bfree;
  }
#line 923
  statp->f_favail = statp->f_ffree;
#line 924
  statp->f_files = statp->f_ffree + usedobjs;
#line 938
  statp->f_namemax = 255UL;
#line 944
  bzero((void *)(statp->f_fstr), sizeof(statp->f_fstr));
#line 946
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 947
  return (0);
}
}
#line 950 "zfs-fuse/zfs_vfsops.c"
static int zfs_root(vfs_t *vfsp , vnode_t **vpp ) 
{ zfsvfs_t *zfsvfs ;
  znode_t *rootzp ;
  int error ;

  {
#line 953
  zfsvfs = (zfsvfs_t *)vfsp->vfs_data;
#line 957
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 957
  if (zfsvfs->z_unmounted1) {
#line 957
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 957
    return (5);
  }
#line 959
  error = zfs_zget(zfsvfs, zfsvfs->z_root, & rootzp);
#line 960
  if (error == 0) {
#line 961
    *vpp = rootzp->z_vnode;
  }
#line 963
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 964
  return (error);
}
}
#line 968 "zfs-fuse/zfs_vfsops.c"
static int zfs_umount(vfs_t *vfsp , int fflag , cred_t *cr ) 
{ zfsvfs_t *zfsvfs ;
  int ret ;

  {
#line 971
  zfsvfs = (zfsvfs_t *)vfsp->vfs_data;
#line 974
  ret = 0;
#line 974
  if (ret != 0) {
#line 975
    return (ret);
  }
#line 989
  if (fflag & 1024) {
#line 990
    vfsp->vfs_flag |= 256U;
#line 991
    zfsvfs->z_unmounted1 = 1;
#line 1007
    while (zfsvfs->z_op_cnt) {
#line 1008
      delay(1L);
    }
#line 1011
    zfs_objset_close(zfsvfs);
#line 1013
    return (0);
  }
#line 1018
  zfs_delete_thread_target(zfsvfs, 0);
#line 1028
  if ((unsigned int )zfsvfs->z_ctldir == (unsigned int )((void *)0)) {
#line 1029
    if (vfsp->vfs_count > 1U) {
#line 1030
      if (((zfsvfs->z_vfs)->vfs_flag & 1U) == 0U) {
#line 1031
        zfs_delete_thread_target(zfsvfs, 1);
      }
#line 1032
      return (16);
    }
  } else {
#line 1035
    if (vfsp->vfs_count > 2U) {
      goto _L;
    } else {
#line 1035
      if ((zfsvfs->z_ctldir)->v_count > 1U) {
#line 1035
        if (! (fflag & 1024)) {
          _L: /* CIL Label */ 
#line 1037
          if (((zfsvfs->z_vfs)->vfs_flag & 1U) == 0U) {
#line 1038
            zfs_delete_thread_target(zfsvfs, 1);
          }
#line 1039
          return (16);
        }
      }
    }
  }
#line 1043
  vfsp->vfs_flag |= 256U;
#line 1044
  zfs_objset_close(zfsvfs);
#line 1046
  return (0);
}
}
#line 1049 "zfs-fuse/zfs_vfsops.c"
static int zfs_vget(vfs_t *vfsp , vnode_t **vpp , fid_t *fidp ) 
{ 

  {
#line 1053
  abort();
}
}
#line 1137 "zfs-fuse/zfs_vfsops.c"
static void zfs_objset_close(zfsvfs_t *zfsvfs ) 
{ zfs_delete_t *zd ;
  znode_t *zp ;
  znode_t *nextzp ;
  objset_t *os ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  struct dsl_pool *tmp___3 ;
  int tmp___4 ;

  {
#line 1140
  zd = & zfsvfs->z_delete_head;
#line 1142
  os = zfsvfs->z_os;
#line 1147
  zfs_delete_thread_target(zfsvfs, 0);
#line 1155
  rw_enter(& zfsvfs->z_um_lock, 1);
#line 1161
  mutex_enter(& zd->z_mutex);
#line 1162
  while (1) {
#line 1162
    tmp = list_head(& zd->z_znodes);
#line 1162
    zp = (znode_t *)tmp;
#line 1162
    if (! zp) {
#line 1162
      break;
    }
#line 1163
    list_remove(& zd->z_znodes, (void *)zp);
#line 1164
    zp->z_dbuf_held = (unsigned char)0;
#line 1165
    dmu_buf_rele(zp->z_dbuf, (void *)0);
  }
#line 1167
  mutex_exit(& zd->z_mutex);
#line 1178
  mutex_enter(& zfsvfs->z_znodes_lock);
#line 1179
  tmp___0 = list_head(& zfsvfs->z_all_znodes);
#line 1179
  zp = (znode_t *)tmp___0;
#line 1179
  while (zp) {
#line 1180
    tmp___1 = list_next(& zfsvfs->z_all_znodes, (void *)zp);
#line 1180
    nextzp = (znode_t *)tmp___1;
#line 1181
    if (zp->z_dbuf_held) {
#line 1183
      zp->z_dbuf_held = (unsigned char)0;
#line 1184
      mutex_exit(& zfsvfs->z_znodes_lock);
#line 1185
      dmu_buf_rele(zp->z_dbuf, (void *)0);
#line 1187
      mutex_enter(& zfsvfs->z_znodes_lock);
#line 1188
      tmp___2 = list_head(& zfsvfs->z_all_znodes);
#line 1188
      nextzp = (znode_t *)tmp___2;
    }
#line 1179
    zp = nextzp;
  }
#line 1191
  mutex_exit(& zfsvfs->z_znodes_lock);
#line 1205
  zfsvfs->z_unmounted2 = 1;
#line 1206
  rw_exit(& zfsvfs->z_um_lock);
#line 1212
  if (zfsvfs->z_log) {
#line 1213
    zil_close(zfsvfs->z_log);
#line 1214
    zfsvfs->z_log = (zilog_t *)((void *)0);
  }
#line 1220
  tmp___4 = dmu_objset_evict_dbufs(os, 1);
#line 1220
  if (tmp___4) {
#line 1221
    tmp___3 = dmu_objset_pool(zfsvfs->z_os);
#line 1221
    txg_wait_synced(tmp___3, 0ULL);
#line 1222
    dmu_objset_evict_dbufs(os, 0);
  }
#line 1228
  dmu_objset_close(os);
#line 1237
  return;
}
}
#line 1239 "zfs-fuse/zfs_vfsops.c"
static void zfs_freevfs(vfs_t *vfsp ) 
{ zfsvfs_t *zfsvfs ;

  {
#line 1242
  zfsvfs = (zfsvfs_t *)vfsp->vfs_data;
#line 1244
  umem_free((void *)zfsvfs, sizeof(zfsvfs_t ));
#line 1246
  atomic_add_32((uint32_t volatile   *)(& zfs_active_fs_count), -1);
#line 1247
  return;
}
}
#line 1256 "zfs-fuse/zfs_vfsops.c"
int zfs_vfsinit(int fstype , char *name ) 
{ int error ;

  {
#line 1261
  zfsfstype = fstype;
#line 1266
  error = vfs_setfsops(fstype, zfs_vfsops_template, & zfs_vfsops);
#line 1267
  if (error != 0) {
#line 1268
    cmn_err(2, "zfs: bad vfs ops template");
  }
#line 1271
  error = zfs_create_op_tables();
#line 1272
  if (error) {
#line 1273
    zfs_remove_op_tables();
#line 1274
    cmn_err(2, "zfs: bad vnode ops template");
#line 1276
    return (error);
  }
#line 1279
  zmutex_init(& zfs_dev_mtx);
#line 1289
  return (0);
}
}
#line 1292 "zfs-fuse/zfs_vfsops.c"
void zfs_init(void) 
{ 

  {
#line 1304
  zfs_znode_init();
#line 1305
  return;
}
}
#line 1307 "zfs-fuse/zfs_vfsops.c"
void zfs_fini(void) 
{ 

  {
#line 1312
  zfs_znode_fini();
#line 1313
  return;
}
}
#line 1315 "zfs-fuse/zfs_vfsops.c"
int zfs_busy(void) 
{ 

  {
#line 1318
  return (zfs_active_fs_count != 0U);
}
}
#line 1 "zfs_vnops.o"
#pragma merger(0,"/tmp/cil-zfDNPrDM.i","-pipe,-Wall,-Werror,-std=c99,-Wno-unused,-Wno-missing-braces,-Wno-parentheses,-Wno-uninitialized,-fno-strict-aliasing,-ggdb,-O2")
#line 84 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strcpy(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
#line 54 "lib/libsolkerncompat/include/sys/rwlock.h"
extern int rw_tryenter(krwlock_t *rwlp , krw_t rw ) ;
#line 144 "lib/libsolkerncompat/include/sys/uio.h"
extern int uiomove(void * , size_t  , enum uio_rw  , uio_t * ) ;
#line 452 "lib/libsolkerncompat/include/sys/vnode.h"
extern int fop_realvp(vnode_t * , vnode_t ** ) ;
#line 52 "lib/libsolkerncompat/include/sys/atomic.h"
extern void atomic_inc_32(uint32_t volatile   * ) ;
#line 66
extern void atomic_dec_32(uint32_t volatile   * ) ;
#line 207
extern uint64_t atomic_cas_64(uint64_t volatile   * , uint64_t  , uint64_t  ) ;
#line 296 "lib/libzfscommon/include/sys/dmu.h"
extern int dmu_bonus_max(void) ;
#line 312
extern int dmu_buf_hold(objset_t *os , uint64_t object , uint64_t offset , void *tag ,
                        dmu_buf_t ** ) ;
#line 328
extern int dmu_buf_hold_array_by_bonus(dmu_buf_t *db , uint64_t offset , uint64_t length ,
                                       int read , void *tag , int *numbufsp , dmu_buf_t ***dbpp ) ;
#line 330
extern void dmu_buf_rele_array(dmu_buf_t ** , int numbufs , void *tag ) ;
#line 427
extern int dmu_write_uio(objset_t *os , uint64_t object , uint64_t offset , uint64_t size ,
                         struct uio *uio , dmu_tx_t *tx ) ;
#line 437
extern void dmu_prefetch(objset_t *os , uint64_t object , uint64_t offset , uint64_t len ) ;
#line 474
extern void dmu_object_size_from_db(dmu_buf_t *db , uint32_t *blksize , u_longlong_t *nblk512 ) ;
#line 527
extern uint64_t dmu_objset_id(objset_t *os ) ;
#line 549
extern int dmu_sync(struct zio *zio , dmu_buf_t *db , struct blkptr *bp , uint64_t txg ,
                    dmu_sync_cb_t *done , void *arg ) ;
#line 268 "lib/libzfscommon/include/sys/zil.h"
extern void zil_add_vdev(zilog_t *zilog , uint64_t vdev ) ;
#line 242 "lib/libzfscommon/include/sys/zfs_znode.h"
void zfs_time_stamper(znode_t *zp , uint_t flag , dmu_tx_t *tx ) ;
#line 244
void zfs_grow_blocksize(znode_t *zp , uint64_t size , dmu_tx_t *tx ) ;
#line 245
int zfs_freesp(znode_t *zp , uint64_t off , uint64_t len , int flag , boolean_t log ) ;
#line 249
void zfs_zinactive(znode_t *zp ) ;
#line 251
void zfs_znode_free(znode_t *zp ) ;
#line 62 "lib/libzfscommon/include/sys/zfs_dir.h"
extern int zfs_get_xattrdir(znode_t * , vnode_t ** , cred_t * , int  ) ;
#line 251 "lib/libzfscommon/include/sys/zap.h"
extern uint64_t zap_cursor_serialize(zap_cursor_t *zc ) ;
#line 260
extern void zap_cursor_init_serialized(zap_cursor_t *zc , objset_t *ds , uint64_t zapobj ,
                                       uint64_t serialized ) ;
#line 58 "lib/libsolkerncompat/include/sys/policy.h"
extern int secpolicy_vnode_setid_retain(cred_t const   *cred , boolean_t issuidroot ) ;
#line 59
extern void secpolicy_setid_clear(vattr_t *vap , cred_t *cr ) ;
#line 60
extern int secpolicy_setid_setsticky_clear(vnode_t *vp , vattr_t *vap , vattr_t const   *ovap ,
                                           cred_t *cr ) ;
#line 61
extern int secpolicy_vnode_setattr(cred_t *cr , struct vnode *vp , struct vattr *vap ,
                                   struct vattr  const  *ovap , int flags , int (*unlocked_access)(void * ,
                                                                                                   int  ,
                                                                                                   cred_t * ) ,
                                   void *node ) ;
#line 36 "lib/libsolkerncompat/include/sys/flock.h"
extern int convoff(struct vnode *vp , struct flock64 *lckdat , int whence , offset_t offset ) ;
#line 82 "lib/libsolkerncompat/include/fs/fs_subr.h"
extern int fs_vnevent_support(vnode_t * , vnevent_t  ) ;
#line 158 "zfs-fuse/zfs_vnops.c"
static int zfs_open(vnode_t **vpp , int flag , cred_t *cr ) 
{ znode_t *zp ;

  {
#line 161
  zp = (znode_t *)(*vpp)->v_data;
#line 164
  if (flag & 4096) {
#line 165
    atomic_inc_32((uint32_t volatile   *)(& zp->z_sync_cnt));
  }
#line 166
  return (0);
}
}
#line 170 "zfs-fuse/zfs_vnops.c"
static int zfs_close(vnode_t *vp , int flag , int count , offset_t offset , cred_t *cr ) 
{ znode_t *zp ;

  {
#line 173
  zp = (znode_t *)vp->v_data;
#line 176
  if (flag & 4096) {
#line 177
    atomic_dec_32((uint32_t volatile   *)(& zp->z_sync_cnt));
  }
#line 185
  return (0);
}
}
#line 235 "zfs-fuse/zfs_vnops.c"
static int zfs_ioctl(vnode_t *vp , int com , intptr_t data , int flag , cred_t *cred ,
                     int *rvalp ) 
{ 

  {
#line 240
  abort();
}
}
#line 388 "zfs-fuse/zfs_vnops.c"
uint_t zfs_read_chunk_size  =    (uint_t )1048576;
#line 408 "zfs-fuse/zfs_vnops.c"
static int zfs_read(vnode_t *vp , uio_t *uio , int ioflag , cred_t *cr , caller_context_t *ct ) 
{ znode_t *zp ;
  zfsvfs_t *zfsvfs ;
  uint64_t delta ;
  ssize_t n ;
  ssize_t size ;
  ssize_t cnt ;
  ssize_t ndone ;
  int error ;
  int i ;
  int numbufs ;
  dmu_buf_t *dbp ;
  dmu_buf_t **dbpp ;
  rl_t *rl ;
  ssize_t tmp___0 ;

  {
#line 411
  zp = (znode_t *)vp->v_data;
#line 412
  zfsvfs = zp->z_zfsvfs;
#line 419
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 419
  if (zfsvfs->z_unmounted1) {
#line 419
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 419
    return (5);
  }
#line 424
  if (uio->_uio_offset._f < 0LL) {
#line 425
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 426
    return (22);
  }
#line 432
  if (uio->uio_resid == 0) {
#line 433
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 434
    return (0);
  }
#line 440
  if (((unsigned int )(zp->z_phys)->zp_mode & (unsigned int )(1024 | (64 >> 3))) == 1024U) {
#line 441
    error = 0;
#line 441
    if (error) {
#line 443
      atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 444
      return (error);
    }
  }
#line 451
  if (ioflag & 4096) {
#line 452
    zil_commit(zfsvfs->z_log, zp->z_last_itx, zp->z_id);
  }
#line 457
  rl = zfs_range_lock(zp, (unsigned long long )uio->_uio_offset._f, (unsigned long long )uio->uio_resid,
                      0);
#line 463
  if ((uint64_t )uio->_uio_offset._f >= (zp->z_phys)->zp_size) {
#line 464
    cnt = 0;
#line 465
    error = 0;
    goto out;
  }
#line 469
  if ((uint64_t )uio->uio_resid < (zp->z_phys)->zp_size - (uint64_t )uio->_uio_offset._f) {
#line 469
    cnt = uio->uio_resid;
  } else {
#line 469
    cnt = (int )((zp->z_phys)->zp_size - (uint64_t )uio->_uio_offset._f);
  }
#line 471
  ndone = 0;
#line 471
  while (ndone < cnt) {
#line 472
    if (! ((uint64_t )uio->_uio_offset._f < (zp->z_phys)->zp_size)) {
#line 472
      __assert_fail("uio->_uio_offset._f < zp->z_phys->zp_size", "zfs-fuse/zfs_vnops.c",
                    472U, "zfs_read");
    }
#line 473
    if ((uint64_t )zfs_read_chunk_size < (zp->z_phys)->zp_size - (uint64_t )uio->_uio_offset._f) {
#line 473
      n = (int )zfs_read_chunk_size;
    } else {
#line 473
      n = (int )((zp->z_phys)->zp_size - (uint64_t )uio->_uio_offset._f);
    }
#line 475
    if (n < cnt) {
#line 475
      n = n;
    } else {
#line 475
      n = cnt;
    }
#line 476
    error = dmu_buf_hold_array_by_bonus(zp->z_dbuf, (unsigned long long )uio->_uio_offset._f,
                                        (unsigned long long )n, 1, (void *)((char *)"zfs_read"),
                                        & numbufs, & dbpp);
#line 478
    if (error) {
      goto out;
    }
#line 484
    delta = (uint64_t )uio->_uio_offset._f - (*(dbpp + 0))->db_offset;
#line 486
    i = 0;
#line 486
    while (i < numbufs) {
#line 487
      if (n < 0) {
#line 488
        break;
      }
#line 489
      dbp = *(dbpp + i);
#line 490
      size = (int )(dbp->db_size - delta);
#line 501
      if (n < size) {
#line 501
        tmp___0 = n;
      } else {
#line 501
        tmp___0 = size;
      }
#line 501
      error = uiomove((void *)((char *)dbp->db_data + delta), (unsigned int )tmp___0,
                      0, uio);
#line 504
      if (error) {
#line 505
        dmu_buf_rele_array(dbpp, numbufs, (void *)((char *)"zfs_read"));
        goto out;
      }
#line 508
      n = (int )((uint64_t )n - dbp->db_size);
#line 509
      if (delta) {
#line 510
        n = (int )((uint64_t )n + delta);
#line 511
        delta = 0ULL;
      }
#line 486
      i ++;
    }
#line 514
    dmu_buf_rele_array(dbpp, numbufs, (void *)((char *)"zfs_read"));
#line 471
    ndone = (int )((uint_t )ndone + zfs_read_chunk_size);
  }
  out: 
#line 517
  zfs_range_unlock(rl);
#line 519
  if (zfsvfs->z_atime) {
#line 519
    if (! ((zfsvfs->z_vfs)->vfs_flag & 1U)) {
#line 519
      zfs_time_stamper(zp, 256U, (dmu_tx_t *)((void *)0));
    }
  }
#line 520
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 521
  return (error);
}
}
#line 608 "zfs-fuse/zfs_vnops.c"
static int zfs_write(vnode_t *vp , uio_t *uio , int ioflag , cred_t *cr , caller_context_t *ct ) 
{ znode_t *zp ;
  rlim64_t limit ;
  ssize_t start_resid ;
  ssize_t tx_bytes ;
  uint64_t end_size ;
  dmu_tx_t *tx ;
  zfsvfs_t *zfsvfs ;
  zilog_t *zilog ;
  offset_t woff ;
  ssize_t n ;
  ssize_t nbytes ;
  rl_t *rl ;
  int max_blksz ;
  int error ;
  ssize_t tmp ;
  uint64_t new_blksz ;
  int tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 611
  zp = (znode_t *)vp->v_data;
#line 612
  limit = (rlim64_t )uio->_uio_limit._f;
#line 613
  start_resid = uio->uio_resid;
#line 617
  zfsvfs = zp->z_zfsvfs;
#line 618
  zilog = zfsvfs->z_log;
#line 622
  max_blksz = (int )zfsvfs->z_max_blksz;
#line 628
  n = start_resid;
#line 629
  if (n == 0) {
#line 630
    return (0);
  }
#line 632
  if (limit == 0xffffffffffffffffULL) {
#line 633
    limit = 9223372036854775807ULL;
  } else {
#line 632
    if (limit > 9223372036854775807ULL) {
#line 633
      limit = 9223372036854775807ULL;
    }
  }
#line 635
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 635
  if (zfsvfs->z_unmounted1) {
#line 635
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 635
    return (5);
  }
#line 647
  if (ioflag & 1024) {
#line 656
    rl = zfs_range_lock(zp, 0ULL, (unsigned long long )n, 2);
#line 657
    if (rl->r_len == 0xffffffffffffffffULL) {
#line 659
      uio->_uio_offset._f = (long long )(zp->z_phys)->zp_size;
#line 659
      woff = uio->_uio_offset._f;
    } else {
#line 661
      uio->_uio_offset._f = (long long )rl->r_off;
#line 661
      woff = uio->_uio_offset._f;
    }
  } else {
#line 664
    woff = uio->_uio_offset._f;
#line 668
    if (woff < 0LL) {
#line 669
      atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 670
      return (22);
    }
#line 678
    rl = zfs_range_lock(zp, (unsigned long long )woff, (unsigned long long )n, 1);
  }
#line 681
  if ((rlim64_t )woff >= limit) {
#line 682
    error = 27;
    goto no_tx_done;
  }
#line 686
  if ((rlim64_t )(woff + (offset_t )n) > limit) {
#line 687
    n = (int )(limit - (rlim64_t )woff);
  } else {
#line 686
    if ((rlim64_t )woff > limit - (rlim64_t )n) {
#line 687
      n = (int )(limit - (rlim64_t )woff);
    }
  }
#line 692
  if (((unsigned int )(zp->z_phys)->zp_mode & (unsigned int )(1024 | (64 >> 3))) == 1024U) {
#line 692
    error = 0;
#line 692
    if (error != 0) {
      goto no_tx_done;
    }
  }
#line 695
  if ((zp->z_phys)->zp_size > (uint64_t )(woff + (offset_t )n)) {
#line 695
    end_size = (zp->z_phys)->zp_size;
  } else {
#line 695
    end_size = (unsigned long long )(woff + (offset_t )n);
  }
  top: 
#line 697
  tx = dmu_tx_create(zfsvfs->z_os);
#line 698
  dmu_tx_hold_bonus(tx, zp->z_id);
#line 699
  if (n < max_blksz) {
#line 699
    tmp = n;
  } else {
#line 699
    tmp = max_blksz;
  }
#line 699
  dmu_tx_hold_write(tx, zp->z_id, (unsigned long long )woff, tmp);
#line 700
  error = dmu_tx_assign(tx, zfsvfs->z_assign);
#line 701
  if (error) {
#line 702
    if (error == 85) {
#line 702
      if (zfsvfs->z_assign == 2ULL) {
#line 703
        dmu_tx_wait(tx);
#line 704
        dmu_tx_abort(tx);
        goto top;
      }
    }
#line 707
    dmu_tx_abort(tx);
    goto no_tx_done;
  }
#line 715
  if (rl->r_len == 0xffffffffffffffffULL) {
#line 718
    if (zp->z_blksz > (uint_t )max_blksz) {
#line 719
      if (! (! ((zp->z_blksz & (zp->z_blksz - 1U)) == 0U))) {
#line 719
        __assert_fail("!(((zp->z_blksz) & ((zp->z_blksz) - 1)) == 0)", "zfs-fuse/zfs_vnops.c",
                      719U, "zfs_write");
      }
#line 720
      if (end_size < 1ULL << 17) {
#line 720
        new_blksz = end_size;
      } else {
#line 720
        new_blksz = 1ULL << 17;
      }
    } else {
#line 722
      if (end_size < (uint64_t )max_blksz) {
#line 722
        new_blksz = end_size;
      } else {
#line 722
        new_blksz = (unsigned long long )max_blksz;
      }
    }
#line 724
    zfs_grow_blocksize(zp, new_blksz, tx);
#line 725
    zfs_range_reduce(rl, (unsigned long long )woff, (unsigned long long )n);
  }
#line 735
  while (n > 0) {
#line 740
    if ((long long )n < (long long )max_blksz - (woff & (long long )(max_blksz - 1))) {
#line 740
      nbytes = n;
    } else {
#line 740
      nbytes = (int )((long long )max_blksz - (woff & (long long )(max_blksz - 1)));
    }
#line 741
    rw_enter(& zp->z_map_lock, 0);
#line 743
    tx_bytes = uio->uio_resid;
#line 748
    error = dmu_write_uio(zfsvfs->z_os, zp->z_id, (unsigned long long )woff, (unsigned long long )nbytes,
                          uio, tx);
#line 750
    rw_exit(& zp->z_map_lock);
#line 752
    tx_bytes -= uio->uio_resid;
#line 754
    if (error) {
#line 756
      break;
    }
#line 759
    if (! (tx_bytes == nbytes)) {
#line 759
      __assert_fail("tx_bytes == nbytes", "zfs-fuse/zfs_vnops.c", 759U, "zfs_write");
    }
#line 770
    mutex_enter(& zp->z_acl_lock);
#line 771
    if (((zp->z_phys)->zp_mode & (unsigned long long )((64 | (64 >> 3)) | (64 >> 6))) != 0ULL) {
#line 771
      if (((zp->z_phys)->zp_mode & 3072ULL) != 0ULL) {
#line 771
        if (((zp->z_phys)->zp_mode & 2048ULL) != 0ULL) {
#line 771
          if ((zp->z_phys)->zp_uid == 0ULL) {
#line 771
            tmp___0 = 1;
          } else {
#line 771
            tmp___0 = 0;
          }
        } else {
#line 771
          tmp___0 = 0;
        }
#line 771
        tmp___1 = secpolicy_vnode_setid_retain((cred_t const   *)cr, (enum boolean )tmp___0);
#line 771
        if (tmp___1 != 0) {
#line 777
          (zp->z_phys)->zp_mode &= 0xfffffffffffff3ffULL;
        }
      }
    }
#line 779
    mutex_exit(& zp->z_acl_lock);
#line 781
    n -= nbytes;
#line 782
    if (n <= 0) {
#line 783
      break;
    }
#line 789
    while (1) {
#line 789
      end_size = (zp->z_phys)->zp_size;
#line 789
      if (! (end_size < (uint64_t )uio->_uio_offset._f)) {
#line 789
        break;
      }
#line 790
      dmu_buf_will_dirty(zp->z_dbuf, tx);
#line 791
      atomic_cas_64((uint64_t volatile   *)(& (zp->z_phys)->zp_size), end_size, (unsigned long long )uio->_uio_offset._f);
    }
#line 794
    zfs_time_stamper(zp, 1536U, tx);
#line 795
    zfs_log_write(zilog, tx, 9, zp, woff, tx_bytes, ioflag, uio);
#line 797
    dmu_tx_commit(tx);
#line 802
    woff = uio->_uio_offset._f;
#line 803
    tx = dmu_tx_create(zfsvfs->z_os);
#line 804
    dmu_tx_hold_bonus(tx, zp->z_id);
#line 805
    if (n < max_blksz) {
#line 805
      tmp___2 = n;
    } else {
#line 805
      tmp___2 = max_blksz;
    }
#line 805
    dmu_tx_hold_write(tx, zp->z_id, (unsigned long long )woff, tmp___2);
#line 806
    error = dmu_tx_assign(tx, zfsvfs->z_assign);
#line 807
    if (error) {
#line 808
      if (error == 85) {
#line 808
        if (zfsvfs->z_assign == 2ULL) {
#line 810
          dmu_tx_wait(tx);
#line 811
          dmu_tx_abort(tx);
          goto top;
        }
      }
#line 814
      dmu_tx_abort(tx);
      goto no_tx_done;
    }
  }
#line 819
  if (tx_bytes != 0) {
#line 824
    while (1) {
#line 824
      end_size = (zp->z_phys)->zp_size;
#line 824
      if (! (end_size < (uint64_t )uio->_uio_offset._f)) {
#line 824
        break;
      }
#line 825
      dmu_buf_will_dirty(zp->z_dbuf, tx);
#line 826
      atomic_cas_64((uint64_t volatile   *)(& (zp->z_phys)->zp_size), end_size, (unsigned long long )uio->_uio_offset._f);
    }
#line 829
    zfs_time_stamper(zp, 1536U, tx);
#line 830
    zfs_log_write(zilog, tx, 9, zp, woff, tx_bytes, ioflag, uio);
  }
#line 833
  dmu_tx_commit(tx);
  no_tx_done: 
#line 838
  zfs_range_unlock(rl);
#line 844
  if (zfsvfs->z_assign >= 4ULL) {
#line 845
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 846
    return (error);
  } else {
#line 844
    if (uio->uio_resid == start_resid) {
#line 845
      atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 846
      return (error);
    }
  }
#line 849
  if (ioflag & 4096) {
#line 850
    zil_commit(zilog, zp->z_last_itx, zp->z_id);
  }
#line 852
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 853
  return (0);
}
}
#line 856 "zfs-fuse/zfs_vnops.c"
void zfs_get_done(dmu_buf_t *db , void *vzgd ) 
{ zgd_t *zgd ;
  rl_t *rl ;
  vnode_t *vp ;

  {
#line 859
  zgd = (zgd_t *)vzgd;
#line 860
  rl = zgd->zgd_rl;
#line 861
  vp = (rl->r_zp)->z_vnode;
#line 863
  dmu_buf_rele(db, vzgd);
#line 864
  zfs_range_unlock(rl);
#line 865
  vn_rele(vp);
#line 866
  zil_add_vdev(zgd->zgd_zilog, ((zgd->zgd_bp)->blk_dva[0].dva_word[0] >> 32) & ((1ULL << 32) - 1ULL));
#line 867
  umem_free((void *)zgd, sizeof(zgd_t ));
#line 868
  return;
}
}
#line 873 "zfs-fuse/zfs_vnops.c"
int zfs_get_data(void *arg , lr_write_t *lr , char *buf , zio_t *zio ) 
{ zfsvfs_t *zfsvfs ;
  objset_t *os ;
  znode_t *zp ;
  uint64_t off ;
  dmu_buf_t *db ;
  rl_t *rl ;
  zgd_t *zgd ;
  int dlen ;
  int error ;
  int tmp ;
  int tmp___0 ;
  uint64_t boff ;
  uint64_t __left ;
  uint64_t __right ;
  char *__buf ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 876
  zfsvfs = (zfsvfs_t *)arg;
#line 877
  os = zfsvfs->z_os;
#line 879
  off = lr->lr_offset;
#line 883
  dlen = (int )lr->lr_length;
#line 884
  error = 0;
#line 886
  if (! zio) {
#line 886
    __assert_fail("zio", "zfs-fuse/zfs_vnops.c", 886U, "zfs_get_data");
  }
#line 887
  if (! (dlen != 0)) {
#line 887
    __assert_fail("dlen != 0", "zfs-fuse/zfs_vnops.c", 887U, "zfs_get_data");
  }
#line 892
  tmp = zfs_zget(zfsvfs, lr->lr_foid, & zp);
#line 892
  if (tmp != 0) {
#line 893
    return (2);
  }
#line 894
  if (zp->z_reap) {
#line 895
    vn_rele(zp->z_vnode);
#line 896
    return (2);
  }
#line 906
  if ((unsigned int )buf != (unsigned int )((void *)0)) {
#line 907
    rl = zfs_range_lock(zp, off, (unsigned long long )dlen, 0);
#line 909
    if (off >= (zp->z_phys)->zp_size) {
#line 910
      error = 2;
      goto out;
    }
#line 913
    while (1) {
#line 913
      tmp___0 = dmu_read(os, lr->lr_foid, off, (unsigned long long )dlen, (void *)buf);
#line 913
      if (! (0 == tmp___0)) {
#line 913
        while (1) {
#line 913
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                  "zfs-fuse/zfs_vnops.c", 913, "zfs_get_data", "0 == dmu_read(os, lr->lr_foid, off, dlen, buf)");
#line 913
          abort();
#line 913
          break;
        }
      }
#line 913
      break;
    }
  } else {
#line 917
    while (1) {
#line 917
      __left = (unsigned long long )dlen;
#line 917
      __right = (unsigned long long )zp->z_blksz;
#line 917
      if (! (__left <= __right)) {
#line 917
        tmp___1 = __builtin_alloca(256U);
#line 917
        __buf = (char *)tmp___1;
#line 917
        snprintf((char * __restrict  )__buf, 256U, (char const   * __restrict  )"%s %s %s (0x%llx %s 0x%llx)",
                 "dlen", "<=", "zp->z_blksz", __left, "<=", __right);
#line 917
        while (1) {
#line 917
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                  "zfs-fuse/zfs_vnops.c", 917, "zfs_get_data", __buf);
#line 917
          abort();
#line 917
          break;
        }
      }
#line 917
      break;
    }
#line 924
    while (1) {
#line 925
      if ((zp->z_blksz & (zp->z_blksz - 1U)) == 0U) {
#line 926
        boff = off & - ((unsigned long long )zp->z_blksz);
      } else {
#line 929
        boff = 0ULL;
      }
#line 931
      dlen = (int )zp->z_blksz;
#line 932
      rl = zfs_range_lock(zp, boff, (unsigned long long )dlen, 0);
#line 933
      if (zp->z_blksz == (uint_t )dlen) {
#line 934
        break;
      }
#line 935
      zfs_range_unlock(rl);
    }
#line 938
    if (off >= (zp->z_phys)->zp_size) {
#line 939
      error = 2;
      goto out;
    }
#line 942
    tmp___2 = umem_alloc(sizeof(zgd_t ), 256);
#line 942
    zgd = (zgd_t *)tmp___2;
#line 943
    zgd->zgd_rl = rl;
#line 944
    zgd->zgd_zilog = zfsvfs->z_log;
#line 945
    zgd->zgd_bp = & lr->lr_blkptr;
#line 946
    while (1) {
#line 946
      tmp___3 = dmu_buf_hold(os, lr->lr_foid, boff, (void *)zgd, & db);
#line 946
      if (! (0 == tmp___3)) {
#line 946
        while (1) {
#line 946
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                  "zfs-fuse/zfs_vnops.c", 946, "zfs_get_data", "0 == dmu_buf_hold(os, lr->lr_foid, boff, zgd, &db)");
#line 946
          abort();
#line 946
          break;
        }
      }
#line 946
      break;
    }
#line 947
    if (! (boff == db->db_offset)) {
#line 947
      __assert_fail("boff == db->db_offset", "zfs-fuse/zfs_vnops.c", 947U, "zfs_get_data");
    }
#line 948
    lr->lr_blkoff = off - boff;
#line 949
    error = dmu_sync(zio, db, & lr->lr_blkptr, lr->lr_common.lrc_txg, & zfs_get_done,
                     (void *)zgd);
#line 951
    if (error == 0) {
#line 952
      zil_add_vdev(zfsvfs->z_log, (lr->lr_blkptr.blk_dva[0].dva_word[0] >> 32) & ((1ULL << 32) - 1ULL));
    }
#line 961
    if (error == 115) {
#line 962
      return (0);
    }
#line 963
    dmu_buf_rele(db, (void *)zgd);
#line 964
    umem_free((void *)zgd, sizeof(zgd_t ));
  }
  out: 
#line 967
  zfs_range_unlock(rl);
#line 968
  vn_rele(zp->z_vnode);
#line 969
  return (error);
}
}
#line 973 "zfs-fuse/zfs_vnops.c"
static int zfs_access(vnode_t *vp , int mode , int flags , cred_t *cr ) 
{ znode_t *zp ;
  zfsvfs_t *zfsvfs ;
  int error ;

  {
#line 976
  zp = (znode_t *)vp->v_data;
#line 977
  zfsvfs = zp->z_zfsvfs;
#line 980
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 980
  if (zfsvfs->z_unmounted1) {
#line 980
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 980
    return (5);
  }
#line 981
  error = zfs_zaccess_rwx(zp, (unsigned int )mode, cr);
#line 982
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 983
  return (error);
}
}
#line 1006 "zfs-fuse/zfs_vnops.c"
static int zfs_lookup(vnode_t *dvp , char *nm , vnode_t **vpp , struct pathname *pnp ,
                      int flags , vnode_t *rdir , cred_t *cr ) 
{ znode_t *zdp ;
  zfsvfs_t *zfsvfs ;
  int error ;

  {
#line 1011
  zdp = (znode_t *)dvp->v_data;
#line 1012
  zfsvfs = zdp->z_zfsvfs;
#line 1015
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 1015
  if (zfsvfs->z_unmounted1) {
#line 1015
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1015
    return (5);
  }
#line 1017
  *vpp = (vnode_t *)((void *)0);
#line 1019
  if (flags & 2) {
#line 1021
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1022
    return (22);
#line 1026
    if (! ((zfsvfs->z_vfs)->vfs_flag & 1024U)) {
#line 1027
      atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1028
      return (22);
    }
#line 1035
    if ((zdp->z_phys)->zp_flags & 1ULL) {
#line 1036
      atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1037
      return (22);
    }
#line 1040
    error = zfs_get_xattrdir((znode_t *)dvp->v_data, vpp, cr, flags);
#line 1040
    if (error) {
#line 1041
      atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1042
      return (error);
    }
#line 1049
    error = zfs_zaccess((znode_t *)(*vpp)->v_data, 32, cr);
#line 1049
    if (error) {
#line 1050
      vn_rele(*vpp);
    }
#line 1053
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1054
    return (error);
  }
#line 1057
  if ((int )dvp->v_type != 2) {
#line 1058
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1059
    return (20);
  }
#line 1066
  error = zfs_zaccess(zdp, 32, cr);
#line 1066
  if (error) {
#line 1067
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1068
    return (error);
  }
#line 1071
  error = zfs_dirlook(zdp, nm, vpp);
#line 1071
  if (error == 0) {

  }
#line 1091
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1092
  return (error);
}
}
#line 1118 "zfs-fuse/zfs_vnops.c"
static int zfs_create(vnode_t *dvp , char *name , vattr_t *vap , vcexcl_t excl , int mode ,
                      vnode_t **vpp , cred_t *cr , int flag ) 
{ znode_t *zp ;
  znode_t *dzp ;
  zfsvfs_t *zfsvfs ;
  zilog_t *zilog ;
  objset_t *os ;
  zfs_dirlock_t *dl ;
  dmu_tx_t *tx ;
  int error ;
  uint64_t zoid ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 1122
  dzp = (znode_t *)dvp->v_data;
#line 1123
  zfsvfs = dzp->z_zfsvfs;
#line 1124
  zilog = zfsvfs->z_log;
#line 1125
  os = zfsvfs->z_os;
#line 1131
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 1131
  if (zfsvfs->z_unmounted1) {
#line 1131
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1131
    return (5);
  }
  top: 
#line 1134
  *vpp = (vnode_t *)((void *)0);
#line 1136
  if (vap->va_mode & 512U) {

  }
#line 1139
  if ((int )*name == 0) {
#line 1143
    mutex_enter(& dvp->v_lock);
#line 1143
    (dvp->v_count) ++;
#line 1143
    mutex_exit(& dvp->v_lock);
#line 1144
    zp = dzp;
#line 1145
    dl = (zfs_dirlock_t *)((void *)0);
#line 1146
    error = 0;
  } else {
#line 1149
    error = zfs_dirent_lock(& dl, dzp, name, & zp, 0);
#line 1149
    if (error) {
#line 1150
      if (0) {
#line 1150
        __s1_len = strlen((char const   *)name);
#line 1150
        __s2_len = strlen("..");
#line 1150
        if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
          goto _L___0;
        } else {
#line 1150
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 1150
            if (! ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") == 1U)) {
#line 1150
              tmp___8 = 1;
            } else {
#line 1150
              if (__s2_len >= 4U) {
#line 1150
                tmp___8 = 1;
              } else {
#line 1150
                tmp___8 = 0;
              }
            }
          } else {
#line 1150
            tmp___8 = 0;
          }
        }
#line 1150
        if (tmp___8) {
#line 1150
          tmp___4 = __builtin_strcmp((char const   *)name, "..");
        } else {
#line 1150
          tmp___7 = __builtin_strcmp((char const   *)name, "..");
#line 1150
          tmp___4 = tmp___7;
        }
      } else {
#line 1150
        tmp___7 = __builtin_strcmp((char const   *)name, "..");
#line 1150
        tmp___4 = tmp___7;
      }
#line 1150
      if (tmp___4 == 0) {
#line 1151
        error = 21;
      }
#line 1152
      atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1153
      return (error);
    }
  }
#line 1157
  if (zp) {
#line 1157
    zoid = zp->z_id;
  } else {
#line 1157
    zoid = 0xffffffffffffffffULL;
  }
#line 1159
  if ((unsigned int )zp == (unsigned int )((void *)0)) {
#line 1164
    error = zfs_zaccess(dzp, 2, cr);
#line 1164
    if (error) {
      goto out;
    }
#line 1172
    if ((dzp->z_phys)->zp_flags & 1ULL) {
#line 1172
      if ((int )vap->va_type != 1) {
#line 1174
        error = 22;
        goto out;
      }
    }
#line 1178
    tx = dmu_tx_create(os);
#line 1179
    dmu_tx_hold_bonus(tx, 0xffffffffffffffffULL);
#line 1180
    dmu_tx_hold_bonus(tx, dzp->z_id);
#line 1181
    dmu_tx_hold_zap(tx, dzp->z_id, 1, name);
#line 1182
    if ((dzp->z_phys)->zp_flags & 2ULL) {
#line 1183
      dmu_tx_hold_write(tx, 0xffffffffffffffffULL, 0ULL, (int )(1ULL << 17));
    }
#line 1185
    error = dmu_tx_assign(tx, zfsvfs->z_assign);
#line 1186
    if (error) {
#line 1187
      zfs_dirent_unlock(dl);
#line 1188
      if (error == 85) {
#line 1188
        if (zfsvfs->z_assign == 2ULL) {
#line 1190
          dmu_tx_wait(tx);
#line 1191
          dmu_tx_abort(tx);
          goto top;
        }
      }
#line 1194
      dmu_tx_abort(tx);
#line 1195
      atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1196
      return (error);
    }
#line 1198
    zfs_mknode(dzp, vap, & zoid, tx, cr, 0U, & zp, 0);
#line 1199
    if (! (zp->z_id == zoid)) {
#line 1199
      __assert_fail("zp->z_id == zoid", "zfs-fuse/zfs_vnops.c", 1199U, "zfs_create");
    }
#line 1200
    zfs_link_create(dl, zp, tx, 1);
#line 1201
    zfs_log_create(zilog, tx, 1, dzp, zp, name);
#line 1202
    dmu_tx_commit(tx);
  } else {
#line 1210
    if ((int )excl == 1) {
#line 1211
      error = 17;
      goto out;
    }
#line 1217
    if ((int )(zp->z_vnode)->v_type == 2) {
#line 1217
      if (mode & 128) {
#line 1218
        error = 21;
        goto out;
      }
    }
#line 1224
    if (mode) {
#line 1224
      error = zfs_zaccess_rwx(zp, (unsigned int )mode, cr);
#line 1224
      if (error) {
        goto out;
      }
    }
#line 1228
    mutex_enter(& dzp->z_lock);
#line 1229
    (dzp->z_seq) ++;
#line 1230
    mutex_exit(& dzp->z_lock);
#line 1235
    if ((int )(zp->z_vnode)->v_type == 1) {
#line 1235
      if ((zp->z_phys)->zp_size != 0ULL) {
#line 1235
        if (vap->va_mask & 128U) {
#line 1235
          if (vap->va_size == 0ULL) {
#line 1238
            error = zfs_freesp(zp, 0ULL, 0ULL, mode, (enum boolean )1);
#line 1239
            if (error == 85) {
#line 1239
              if (zfsvfs->z_assign == 2ULL) {
#line 1242
                zfs_dirent_unlock(dl);
#line 1243
                vn_rele(zp->z_vnode);
                goto top;
              }
            }
          }
        }
      }
    }
  }
  out: 
#line 1250
  if (dl) {
#line 1251
    zfs_dirent_unlock(dl);
  }
#line 1253
  if (error) {
#line 1254
    if (zp) {
#line 1255
      vn_rele(zp->z_vnode);
    }
  } else {
#line 1257
    *vpp = zp->z_vnode;
  }
#line 1276
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1277
  return (error);
}
}
#line 1294 "zfs-fuse/zfs_vnops.c"
static int zfs_remove(vnode_t *dvp , char *name , cred_t *cr ) 
{ znode_t *zp ;
  znode_t *dzp ;
  znode_t *xzp ;
  vnode_t *vp ;
  zfsvfs_t *zfsvfs ;
  zilog_t *zilog ;
  uint64_t acl_obj ;
  uint64_t xattr_obj ;
  zfs_dirlock_t *dl ;
  dmu_tx_t *tx ;
  int may_delete_now ;
  int delete_now ;
  int reaped ;
  int error ;
  int tmp ;
  int tmp___0 ;
  uint64_t __left ;
  uint64_t __right ;
  char *__buf ;
  void *tmp___1 ;
  uint64_t __left___0 ;
  uint64_t __right___0 ;
  char *__buf___0 ;
  void *tmp___2 ;
  uint64_t __left___1 ;
  uint64_t __right___1 ;
  char *__buf___1 ;
  void *tmp___3 ;

  {
#line 1297
  dzp = (znode_t *)dvp->v_data;
#line 1298
  xzp = (znode_t *)((void *)0);
#line 1300
  zfsvfs = dzp->z_zfsvfs;
#line 1301
  zilog = zfsvfs->z_log;
#line 1305
  delete_now = 0;
#line 1309
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 1309
  if (zfsvfs->z_unmounted1) {
#line 1309
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1309
    return (5);
  }
  top: 
#line 1315
  error = zfs_dirent_lock(& dl, dzp, name, & zp, 2);
#line 1315
  if (error) {
#line 1316
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1317
    return (error);
  }
#line 1320
  vp = zp->z_vnode;
#line 1322
  error = zfs_zaccess_delete(dzp, zp, cr);
#line 1322
  if (error) {
    goto out;
  }
#line 1329
  if ((int )vp->v_type == 2) {
#line 1330
    error = 1;
    goto out;
  }
#line 1338
  mutex_enter(& vp->v_lock);
#line 1339
  if (vp->v_count == 1U) {
#line 1339
    tmp = 1;
  } else {
#line 1339
    tmp = 0;
  }
#line 1339
  may_delete_now = tmp;
#line 1340
  mutex_exit(& vp->v_lock);
#line 1348
  tx = dmu_tx_create(zfsvfs->z_os);
#line 1349
  dmu_tx_hold_zap(tx, dzp->z_id, 0, name);
#line 1350
  dmu_tx_hold_bonus(tx, zp->z_id);
#line 1351
  if (may_delete_now) {
#line 1352
    dmu_tx_hold_free(tx, zp->z_id, 0ULL, 0xffffffffffffffffULL);
  }
#line 1355
  xattr_obj = (zp->z_phys)->zp_xattr;
#line 1355
  if (xattr_obj != 0ULL) {
#line 1363
    dmu_tx_hold_bonus(tx, xattr_obj);
  }
#line 1367
  acl_obj = (zp->z_phys)->zp_acl.z_acl_extern_obj;
#line 1367
  if (acl_obj != 0ULL) {
#line 1367
    if (may_delete_now) {
#line 1369
      dmu_tx_hold_free(tx, acl_obj, 0ULL, 0xffffffffffffffffULL);
    }
  }
#line 1372
  dmu_tx_hold_zap(tx, zfsvfs->z_dqueue, 0, (char *)((void *)0));
#line 1374
  error = dmu_tx_assign(tx, zfsvfs->z_assign);
#line 1375
  if (error) {
#line 1376
    zfs_dirent_unlock(dl);
#line 1377
    vn_rele(vp);
#line 1378
    if (error == 85) {
#line 1378
      if (zfsvfs->z_assign == 2ULL) {
#line 1379
        dmu_tx_wait(tx);
#line 1380
        dmu_tx_abort(tx);
        goto top;
      }
    }
#line 1383
    dmu_tx_abort(tx);
#line 1384
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1385
    return (error);
  }
#line 1391
  error = zfs_link_destroy(dl, zp, tx, 0, & reaped);
#line 1393
  if (error) {
#line 1394
    dmu_tx_commit(tx);
    goto out;
  }
#line 1398
  if (reaped) {
#line 1399
    mutex_enter(& vp->v_lock);
#line 1400
    if (may_delete_now) {
#line 1400
      if (vp->v_count == 1U) {
#line 1400
        if ((zp->z_phys)->zp_xattr == xattr_obj) {
#line 1400
          if ((zp->z_phys)->zp_acl.z_acl_extern_obj == acl_obj) {
#line 1400
            tmp___0 = 1;
          } else {
#line 1400
            tmp___0 = 0;
          }
        } else {
#line 1400
          tmp___0 = 0;
        }
      } else {
#line 1400
        tmp___0 = 0;
      }
    } else {
#line 1400
      tmp___0 = 0;
    }
#line 1400
    delete_now = tmp___0;
#line 1404
    mutex_exit(& vp->v_lock);
  }
#line 1407
  if (delete_now) {
#line 1408
    if ((zp->z_phys)->zp_xattr) {
#line 1409
      error = zfs_zget(zfsvfs, (zp->z_phys)->zp_xattr, & xzp);
#line 1410
      while (1) {
#line 1410
        __left = (unsigned long long )error;
#line 1410
        __right = 0ULL;
#line 1410
        if (! (__left == __right)) {
#line 1410
          tmp___1 = __builtin_alloca(256U);
#line 1410
          __buf = (char *)tmp___1;
#line 1410
          snprintf((char * __restrict  )__buf, 256U, (char const   * __restrict  )"%s %s %s (0x%llx %s 0x%llx)",
                   "error", "==", "0", __left, "==", __right);
#line 1410
          while (1) {
#line 1410
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                    "zfs-fuse/zfs_vnops.c", 1410, "zfs_remove", __buf);
#line 1410
            abort();
#line 1410
            break;
          }
        }
#line 1410
        break;
      }
#line 1411
      while (1) {
#line 1411
        __left___0 = (xzp->z_phys)->zp_links;
#line 1411
        __right___0 = 2ULL;
#line 1411
        if (! (__left___0 == __right___0)) {
#line 1411
          tmp___2 = __builtin_alloca(256U);
#line 1411
          __buf___0 = (char *)tmp___2;
#line 1411
          snprintf((char * __restrict  )__buf___0, 256U, (char const   * __restrict  )"%s %s %s (0x%llx %s 0x%llx)",
                   "xzp->z_phys->zp_links", "==", "2", __left___0, "==", __right___0);
#line 1411
          while (1) {
#line 1411
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                    "zfs-fuse/zfs_vnops.c", 1411, "zfs_remove", __buf___0);
#line 1411
            abort();
#line 1411
            break;
          }
        }
#line 1411
        break;
      }
#line 1412
      dmu_buf_will_dirty(xzp->z_dbuf, tx);
#line 1413
      mutex_enter(& xzp->z_lock);
#line 1414
      xzp->z_reap = (unsigned char)1;
#line 1415
      (xzp->z_phys)->zp_links = 0ULL;
#line 1416
      mutex_exit(& xzp->z_lock);
#line 1417
      zfs_dq_add(xzp, tx);
#line 1418
      (zp->z_phys)->zp_xattr = 0ULL;
    }
#line 1420
    mutex_enter(& zp->z_lock);
#line 1421
    mutex_enter(& vp->v_lock);
#line 1422
    (vp->v_count) --;
#line 1423
    while (1) {
#line 1423
      __left___1 = (unsigned long long )vp->v_count;
#line 1423
      __right___1 = 0ULL;
#line 1423
      if (! (__left___1 == __right___1)) {
#line 1423
        tmp___3 = __builtin_alloca(256U);
#line 1423
        __buf___1 = (char *)tmp___3;
#line 1423
        snprintf((char * __restrict  )__buf___1, 256U, (char const   * __restrict  )"%s %s %s (0x%llx %s 0x%llx)",
                 "vp->v_count", "==", "0", __left___1, "==", __right___1);
#line 1423
        while (1) {
#line 1423
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                  "zfs-fuse/zfs_vnops.c", 1423, "zfs_remove", __buf___1);
#line 1423
          abort();
#line 1423
          break;
        }
      }
#line 1423
      break;
    }
#line 1424
    mutex_exit(& vp->v_lock);
#line 1425
    mutex_exit(& zp->z_lock);
#line 1426
    zfs_znode_delete(zp, tx);
#line 1427
    vfs_rele(zfsvfs->z_vfs);
  } else {
#line 1428
    if (reaped) {
#line 1429
      zfs_dq_add(zp, tx);
    }
  }
#line 1432
  zfs_log_remove(zilog, tx, 5, dzp, name);
#line 1434
  dmu_tx_commit(tx);
  out: 
#line 1436
  zfs_dirent_unlock(dl);
#line 1438
  if (! delete_now) {
#line 1439
    vn_rele(vp);
  } else {
#line 1440
    if (xzp) {
#line 1442
      vn_rele(xzp->z_vnode);
    }
  }
#line 1445
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1446
  return (error);
}
}
#line 1467 "zfs-fuse/zfs_vnops.c"
static int zfs_mkdir(vnode_t *dvp , char *dirname , vattr_t *vap , vnode_t **vpp ,
                     cred_t *cr ) 
{ znode_t *zp ;
  znode_t *dzp ;
  zfsvfs_t *zfsvfs ;
  zilog_t *zilog ;
  zfs_dirlock_t *dl ;
  uint64_t zoid ;
  dmu_tx_t *tx ;
  int error ;

  {
#line 1470
  dzp = (znode_t *)dvp->v_data;
#line 1471
  zfsvfs = dzp->z_zfsvfs;
#line 1472
  zilog = zfsvfs->z_log;
#line 1474
  zoid = (uint64_t )0;
#line 1478
  if (! ((int )vap->va_type == 2)) {
#line 1478
    __assert_fail("vap->va_type == VDIR", "zfs-fuse/zfs_vnops.c", 1478U, "zfs_mkdir");
  }
#line 1480
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 1480
  if (zfsvfs->z_unmounted1) {
#line 1480
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1480
    return (5);
  }
#line 1482
  if ((dzp->z_phys)->zp_flags & 1ULL) {
#line 1483
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1484
    return (22);
  }
  top: 
#line 1487
  *vpp = (vnode_t *)((void *)0);
#line 1492
  error = zfs_dirent_lock(& dl, dzp, dirname, & zp, 1);
#line 1492
  if (error) {
#line 1493
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1494
    return (error);
  }
#line 1497
  error = zfs_zaccess(dzp, 4, cr);
#line 1497
  if (error) {
#line 1498
    zfs_dirent_unlock(dl);
#line 1499
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1500
    return (error);
  }
#line 1506
  tx = dmu_tx_create(zfsvfs->z_os);
#line 1507
  dmu_tx_hold_zap(tx, dzp->z_id, 1, dirname);
#line 1508
  dmu_tx_hold_zap(tx, 0xffffffffffffffffULL, 0, (char *)((void *)0));
#line 1509
  if ((dzp->z_phys)->zp_flags & 2ULL) {
#line 1510
    dmu_tx_hold_write(tx, 0xffffffffffffffffULL, 0ULL, (int )(1ULL << 17));
  }
#line 1512
  error = dmu_tx_assign(tx, zfsvfs->z_assign);
#line 1513
  if (error) {
#line 1514
    zfs_dirent_unlock(dl);
#line 1515
    if (error == 85) {
#line 1515
      if (zfsvfs->z_assign == 2ULL) {
#line 1516
        dmu_tx_wait(tx);
#line 1517
        dmu_tx_abort(tx);
        goto top;
      }
    }
#line 1520
    dmu_tx_abort(tx);
#line 1521
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1522
    return (error);
  }
#line 1528
  zfs_mknode(dzp, vap, & zoid, tx, cr, 0U, & zp, 0);
#line 1533
  zfs_link_create(dl, zp, tx, 1);
#line 1535
  *vpp = zp->z_vnode;
#line 1537
  zfs_log_create(zilog, tx, 2, dzp, zp, dirname);
#line 1538
  dmu_tx_commit(tx);
#line 1540
  zfs_dirent_unlock(dl);
#line 1542
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1543
  return (0);
}
}
#line 1562 "zfs-fuse/zfs_vnops.c"
static int zfs_rmdir(vnode_t *dvp , char *name , vnode_t *cwd , cred_t *cr ) 
{ znode_t *dzp ;
  znode_t *zp ;
  vnode_t *vp ;
  zfsvfs_t *zfsvfs ;
  zilog_t *zilog ;
  zfs_dirlock_t *dl ;
  dmu_tx_t *tx ;
  int error ;

  {
#line 1565
  dzp = (znode_t *)dvp->v_data;
#line 1568
  zfsvfs = dzp->z_zfsvfs;
#line 1569
  zilog = zfsvfs->z_log;
#line 1574
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 1574
  if (zfsvfs->z_unmounted1) {
#line 1574
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1574
    return (5);
  }
  top: 
#line 1577
  zp = (znode_t *)((void *)0);
#line 1582
  error = zfs_dirent_lock(& dl, dzp, name, & zp, 2);
#line 1582
  if (error) {
#line 1583
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1584
    return (error);
  }
#line 1587
  vp = zp->z_vnode;
#line 1589
  error = zfs_zaccess_delete(dzp, zp, cr);
#line 1589
  if (error) {
    goto out;
  }
#line 1593
  if ((int )vp->v_type != 2) {
#line 1594
    error = 20;
    goto out;
  }
#line 1598
  if ((unsigned int )vp == (unsigned int )cwd) {
#line 1599
    error = 22;
    goto out;
  }
#line 1609
  rw_enter(& zp->z_parent_lock, 1);
#line 1611
  tx = dmu_tx_create(zfsvfs->z_os);
#line 1612
  dmu_tx_hold_zap(tx, dzp->z_id, 0, name);
#line 1613
  dmu_tx_hold_bonus(tx, zp->z_id);
#line 1614
  dmu_tx_hold_zap(tx, zfsvfs->z_dqueue, 0, (char *)((void *)0));
#line 1615
  error = dmu_tx_assign(tx, zfsvfs->z_assign);
#line 1616
  if (error) {
#line 1617
    rw_exit(& zp->z_parent_lock);
#line 1618
    zfs_dirent_unlock(dl);
#line 1619
    vn_rele(vp);
#line 1620
    if (error == 85) {
#line 1620
      if (zfsvfs->z_assign == 2ULL) {
#line 1621
        dmu_tx_wait(tx);
#line 1622
        dmu_tx_abort(tx);
        goto top;
      }
    }
#line 1625
    dmu_tx_abort(tx);
#line 1626
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1627
    return (error);
  }
#line 1630
  error = zfs_link_destroy(dl, zp, tx, 0, (int *)((void *)0));
#line 1632
  if (error == 0) {
#line 1633
    zfs_log_remove(zilog, tx, 6, dzp, name);
  }
#line 1635
  dmu_tx_commit(tx);
#line 1637
  rw_exit(& zp->z_parent_lock);
  out: 
#line 1639
  zfs_dirent_unlock(dl);
#line 1641
  vn_rele(vp);
#line 1643
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1644
  return (error);
}
}
#line 1672 "zfs-fuse/zfs_vnops.c"
static int zfs_readdir(vnode_t *vp , uio_t *uio , cred_t *cr , int *eofp ) 
{ znode_t *zp ;
  iovec_t *iovp ;
  dirent64_t *odp ;
  zfsvfs_t *zfsvfs ;
  objset_t *os ;
  caddr_t outbuf ;
  size_t bufsize ;
  zap_cursor_t zc ;
  zap_attribute_t zap ;
  uint_t bytes_wanted ;
  ushort_t this_reclen ;
  uint64_t offset ;
  off64_t *next ;
  int local_eof ;
  int outcount ;
  int error ;
  uint8_t prefetch ;
  void *tmp ;
  size_t tmp___0 ;

  {
#line 1675
  zp = (znode_t *)vp->v_data;
#line 1678
  zfsvfs = zp->z_zfsvfs;
#line 1693
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 1693
  if (zfsvfs->z_unmounted1) {
#line 1693
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1693
    return (5);
  }
#line 1699
  if ((unsigned int )eofp == (unsigned int )((void *)0)) {
#line 1700
    eofp = & local_eof;
  }
#line 1705
  if ((uio->uio_iov)->iov_len <= 0U) {
#line 1706
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1707
    return (22);
  }
#line 1713
  *eofp = (int )zp->z_reap;
#line 1713
  if (*eofp != 0) {
#line 1714
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1715
    return (0);
  }
#line 1718
  error = 0;
#line 1719
  os = zfsvfs->z_os;
#line 1720
  offset = (unsigned long long )uio->_uio_offset._f;
#line 1721
  prefetch = zp->z_zn_prefetch;
#line 1726
  if (offset <= 3ULL) {
#line 1730
    zap_cursor_init(& zc, os, zp->z_id);
  } else {
#line 1735
    zap_cursor_init_serialized(& zc, os, zp->z_id, offset);
  }
#line 1741
  iovp = uio->uio_iov;
#line 1742
  bytes_wanted = iovp->iov_len;
#line 1743
  if ((int )uio->uio_segflg != 1) {
#line 1744
    bufsize = bytes_wanted;
#line 1745
    tmp = umem_alloc(bufsize, 256);
#line 1745
    outbuf = (char *)tmp;
#line 1746
    odp = (struct dirent64 *)outbuf;
  } else {
#line 1743
    if (uio->uio_iovcnt != 1) {
#line 1744
      bufsize = bytes_wanted;
#line 1745
      tmp = umem_alloc(bufsize, 256);
#line 1745
      outbuf = (char *)tmp;
#line 1746
      odp = (struct dirent64 *)outbuf;
    } else {
#line 1748
      bufsize = bytes_wanted;
#line 1749
      odp = (struct dirent64 *)iovp->iov_base;
    }
  }
#line 1755
  outcount = 0;
#line 1756
  while ((uint_t )outcount < bytes_wanted) {
#line 1760
    if (offset == 0ULL) {
#line 1761
      strcpy((char * __restrict  )(zap.za_name), (char const   * __restrict  )".");
#line 1762
      zap.za_first_integer = zp->z_id;
#line 1763
      this_reclen = (unsigned short )(((((unsigned int )(& ((dirent64_t *)0)->d_name[0]) + 1U) + 1U) + 7U) & 4294967288U);
    } else {
#line 1764
      if (offset == 1ULL) {
#line 1765
        strcpy((char * __restrict  )(zap.za_name), (char const   * __restrict  )"..");
#line 1766
        zap.za_first_integer = (zp->z_phys)->zp_parent;
#line 1767
        this_reclen = (unsigned short )(((((unsigned int )(& ((dirent64_t *)0)->d_name[0]) + 1U) + 2U) + 7U) & 4294967288U);
      } else {
#line 1768
        if (offset == 2ULL) {
#line 1768
          if (zp->z_id == (zp->z_zfsvfs)->z_root) {
#line 1768
            if ((unsigned int )(zp->z_zfsvfs)->z_ctldir != (unsigned int )((void *)0)) {
#line 1768
              if ((zp->z_zfsvfs)->z_show_ctldir) {
#line 1769
                strcpy((char * __restrict  )(zap.za_name), (char const   * __restrict  )".zfs");
#line 1770
                zap.za_first_integer = 1ULL;
#line 1771
                this_reclen = (unsigned short )(((((unsigned int )(& ((dirent64_t *)0)->d_name[0]) + 1U) + (sizeof(".zfs") - 1U)) + 7U) & 4294967288U);
              } else {
                goto _L;
              }
            } else {
              goto _L;
            }
          } else {
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 1777
          error = zap_cursor_retrieve(& zc, & zap);
#line 1777
          if (error) {
#line 1778
            *eofp = error == 2;
#line 1778
            if (*eofp != 0) {
#line 1779
              break;
            } else {
              goto update;
            }
          }
#line 1784
          if (zap.za_integer_length != 8) {
#line 1786
            cmn_err(2, "zap_readdir: bad directory entry, obj = %lld, offset = %lld\n",
                    zp->z_id, offset);
#line 1790
            error = 6;
            goto update;
          } else {
#line 1784
            if (zap.za_num_integers != 1ULL) {
#line 1786
              cmn_err(2, "zap_readdir: bad directory entry, obj = %lld, offset = %lld\n",
                      zp->z_id, offset);
#line 1790
              error = 6;
              goto update;
            }
          }
#line 1793
          tmp___0 = strlen((char const   *)(zap.za_name));
#line 1793
          this_reclen = (unsigned short )(((((unsigned int )(& ((dirent64_t *)0)->d_name[0]) + 1U) + tmp___0) + 7U) & 4294967288U);
        }
      }
    }
#line 1799
    if ((size_t )(outcount + (int )this_reclen) > bufsize) {
#line 1803
      if (! outcount) {
#line 1804
        error = 22;
        goto update;
      }
#line 1807
      break;
    }
#line 1812
    odp->d_ino = zap.za_first_integer;
#line 1813
    odp->d_reclen = this_reclen;
#line 1815
    next = & odp->d_off;
#line 1816
    __builtin_strncpy(odp->d_name, (char const   *)(zap.za_name), (unsigned int )this_reclen - (unsigned int )(& ((dirent64_t *)0)->d_name[0]));
#line 1818
    outcount += (int )this_reclen;
#line 1819
    odp = (dirent64_t *)((int )odp + (int )this_reclen);
#line 1821
    if (! ((size_t )outcount <= bufsize)) {
#line 1821
      __assert_fail("outcount <= bufsize", "zfs-fuse/zfs_vnops.c", 1821U, "zfs_readdir");
    }
#line 1824
    if (prefetch) {
#line 1825
      dmu_prefetch(os, zap.za_first_integer, 0ULL, 0ULL);
    }
#line 1830
    if (offset > 2ULL) {
#line 1831
      zap_cursor_advance(& zc);
#line 1832
      offset = zap_cursor_serialize(& zc);
    } else {
#line 1830
      if (offset == 2ULL) {
#line 1830
        if (zp->z_id == (zp->z_zfsvfs)->z_root) {
#line 1830
          if ((unsigned int )(zp->z_zfsvfs)->z_ctldir != (unsigned int )((void *)0)) {
#line 1830
            if ((zp->z_zfsvfs)->z_show_ctldir) {
#line 1834
              offset ++;
            } else {
#line 1831
              zap_cursor_advance(& zc);
#line 1832
              offset = zap_cursor_serialize(& zc);
            }
          } else {
#line 1831
            zap_cursor_advance(& zc);
#line 1832
            offset = zap_cursor_serialize(& zc);
          }
        } else {
#line 1831
          zap_cursor_advance(& zc);
#line 1832
          offset = zap_cursor_serialize(& zc);
        }
      } else {
#line 1834
        offset ++;
      }
    }
#line 1836
    *next = (long long )offset;
  }
#line 1838
  zp->z_zn_prefetch = (unsigned char)0;
#line 1840
  if ((int )uio->uio_segflg == 1) {
#line 1840
    if (uio->uio_iovcnt == 1) {
#line 1841
      iovp->iov_base = (void *)((char *)iovp->iov_base + outcount);
#line 1842
      iovp->iov_len -= (size_t )outcount;
#line 1843
      uio->uio_resid -= outcount;
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 1844
    error = uiomove((void *)outbuf, (unsigned int )((long )outcount), 0, uio);
#line 1844
    if (error) {
#line 1848
      offset = (unsigned long long )uio->_uio_offset._f;
    }
  }
  update: 
#line 1852
  zap_cursor_fini(& zc);
#line 1853
  if ((int )uio->uio_segflg != 1) {
#line 1854
    umem_free((void *)outbuf, bufsize);
  } else {
#line 1853
    if (uio->uio_iovcnt != 1) {
#line 1854
      umem_free((void *)outbuf, bufsize);
    }
  }
#line 1856
  if (error == 2) {
#line 1857
    error = 0;
  }
#line 1859
  if (zfsvfs->z_atime) {
#line 1859
    if (! ((zfsvfs->z_vfs)->vfs_flag & 1U)) {
#line 1859
      zfs_time_stamper(zp, 256U, (dmu_tx_t *)((void *)0));
    }
  }
#line 1861
  uio->_uio_offset._f = (long long )offset;
#line 1862
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1863
  return (error);
}
}
#line 1866 "zfs-fuse/zfs_vnops.c"
static int zfs_fsync(vnode_t *vp , int syncflag , cred_t *cr ) 
{ znode_t *zp ;
  zfsvfs_t *zfsvfs ;

  {
#line 1869
  zp = (znode_t *)vp->v_data;
#line 1870
  zfsvfs = zp->z_zfsvfs;
#line 1882
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 1882
  if (zfsvfs->z_unmounted1) {
#line 1882
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1882
    return (5);
  }
#line 1883
  zil_commit(zfsvfs->z_log, zp->z_last_itx, zp->z_id);
#line 1884
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1885
  return (0);
}
}
#line 1902 "zfs-fuse/zfs_vnops.c"
static int zfs_getattr(vnode_t *vp , vattr_t *vap , int flags , cred_t *cr ) 
{ znode_t *zp ;
  zfsvfs_t *zfsvfs ;
  znode_phys_t *pzp ;
  int error ;
  uid_t tmp ;

  {
#line 1905
  zp = (znode_t *)vp->v_data;
#line 1906
  zfsvfs = zp->z_zfsvfs;
#line 1907
  pzp = zp->z_phys;
#line 1910
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 1910
  if (zfsvfs->z_unmounted1) {
#line 1910
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1910
    return (5);
  }
#line 1916
  mutex_enter(& zp->z_lock);
#line 1918
  vap->va_type = vp->v_type;
#line 1919
  vap->va_mode = (unsigned int )(pzp->zp_mode & 4095ULL);
#line 1920
  vap->va_uid = (unsigned int )(zp->z_phys)->zp_uid;
#line 1921
  vap->va_gid = (unsigned int )(zp->z_phys)->zp_gid;
#line 1922
  vap->va_fsid = ((zp->z_zfsvfs)->z_vfs)->vfs_dev;
#line 1923
  vap->va_nodeid = zp->z_id;
#line 1924
  if (pzp->zp_links < 4294967295ULL) {
#line 1924
    vap->va_nlink = (unsigned int )pzp->zp_links;
  } else {
#line 1924
    vap->va_nlink = 4294967295U;
  }
#line 1925
  vap->va_size = pzp->zp_size;
#line 1926
  vap->va_rdev = vp->v_rdev;
#line 1927
  vap->va_seq = zp->z_seq;
#line 1929
  vap->va_atime.tv_sec = (long )pzp->zp_atime[0];
#line 1929
  vap->va_atime.tv_nsec = (long )pzp->zp_atime[1];
#line 1930
  vap->va_mtime.tv_sec = (long )pzp->zp_mtime[0];
#line 1930
  vap->va_mtime.tv_nsec = (long )pzp->zp_mtime[1];
#line 1931
  vap->va_ctime.tv_sec = (long )pzp->zp_ctime[0];
#line 1931
  vap->va_ctime.tv_nsec = (long )pzp->zp_ctime[1];
#line 1938
  if (! ((zp->z_phys)->zp_flags & 4ULL)) {
#line 1938
    tmp = crgetuid((cred_t const   *)cr);
#line 1938
    if ((zp->z_phys)->zp_uid != (uint64_t )tmp) {
#line 1940
      error = zfs_zaccess(zp, 128, cr);
#line 1940
      if (error) {
#line 1941
        mutex_exit(& zp->z_lock);
#line 1942
        atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1943
        return (error);
      }
    }
  }
#line 1947
  mutex_exit(& zp->z_lock);
#line 1949
  dmu_object_size_from_db(zp->z_dbuf, & vap->va_blksize, & vap->va_nblocks);
#line 1951
  if (zp->z_blksz == 0U) {
#line 1955
    vap->va_blksize = (unsigned int )zfsvfs->z_max_blksz;
  }
#line 1958
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1959
  return (0);
}
}
#line 1978 "zfs-fuse/zfs_vnops.c"
static int zfs_setattr(vnode_t *vp , vattr_t *vap , int flags , cred_t *cr , caller_context_t *ct ) 
{ struct znode *zp ;
  znode_phys_t *pzp ;
  zfsvfs_t *zfsvfs ;
  zilog_t *zilog ;
  dmu_tx_t *tx ;
  vattr_t oldva ;
  uint_t mask ;
  uint_t saved_mask ;
  int trim_mask ;
  uint64_t new_mode ;
  znode_t *attrzp ;
  int need_policy ;
  int err ;
  int idmask ;
  int take_owner ;
  int take_group ;
  uid_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  uint64_t pmode ;
  uint64_t __left ;
  uint64_t __right ;
  char *__buf ;
  void *tmp___5 ;

  {
#line 1982
  zp = (znode_t *)vp->v_data;
#line 1983
  pzp = zp->z_phys;
#line 1984
  zfsvfs = zp->z_zfsvfs;
#line 1985
  zilog = zfsvfs->z_log;
#line 1988
  mask = vap->va_mask;
#line 1990
  trim_mask = 0;
#line 1993
  need_policy = 0;
#line 1996
  if (mask == 0U) {
#line 1997
    return (0);
  }
#line 1999
  if (mask & 47217U) {
#line 2000
    return (22);
  }
#line 2002
  if (mask & 128U) {
#line 2002
    if ((int )vp->v_type == 2) {
#line 2003
      return (21);
    }
  }
#line 2005
  if (mask & 128U) {
#line 2005
    if ((int )vp->v_type != 1) {
#line 2005
      if ((int )vp->v_type != 6) {
#line 2006
        return (22);
      }
    }
  }
#line 2008
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 2008
  if (zfsvfs->z_unmounted1) {
#line 2008
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 2008
    return (5);
  }
  top: 
#line 2011
  attrzp = (znode_t *)((void *)0);
#line 2013
  if ((zfsvfs->z_vfs)->vfs_flag & 1U) {
#line 2014
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 2015
    return (30);
  }
#line 2022
  if (mask & 128U) {
#line 2023
    err = zfs_zaccess(zp, 2, cr);
#line 2024
    if (err) {
#line 2025
      atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 2026
      return (err);
    }
#line 2034
    while (1) {
#line 2035
      err = zfs_freesp(zp, vap->va_size, 0ULL, 0, (enum boolean )0);
#line 2034
      if (err == 85) {
#line 2034
        if (! (zfsvfs->z_assign == 2ULL)) {
#line 2034
          break;
        }
      } else {
#line 2034
        break;
      }
    }
#line 2038
    if (err) {
#line 2039
      atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 2040
      return (err);
    }
  }
#line 2044
  if (mask & 768U) {
#line 2045
    need_policy = zfs_zaccess_v4_perm(zp, 256, cr);
  }
#line 2047
  if (mask & 12U) {
#line 2048
    idmask = (int )(mask & 12U);
#line 2057
    if (! (mask & 2U)) {
#line 2058
      vap->va_mode = (unsigned int )pzp->zp_mode;
    }
#line 2064
    if (mask & 4U) {
#line 2064
      tmp = crgetuid((cred_t const   *)cr);
#line 2064
      if (vap->va_uid == tmp) {
#line 2064
        tmp___0 = 1;
      } else {
#line 2064
        tmp___0 = 0;
      }
    } else {
#line 2064
      tmp___0 = 0;
    }
#line 2064
    take_owner = tmp___0;
#line 2065
    if (mask & 8U) {
#line 2065
      tmp___1 = groupmember(vap->va_gid, (cred_t const   *)cr);
#line 2065
      if (tmp___1) {
#line 2065
        tmp___2 = 1;
      } else {
#line 2065
        tmp___2 = 0;
      }
    } else {
#line 2065
      tmp___2 = 0;
    }
#line 2065
    take_group = tmp___2;
#line 2076
    if (idmask == 12) {
#line 2076
      if (take_owner) {
#line 2076
        if (take_group) {
          goto _L;
        } else {
          goto _L___2;
        }
      } else {
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
#line 2076
      if (idmask == 4) {
#line 2076
        if (take_owner) {
          goto _L;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 2076
        if (idmask == 8) {
#line 2076
          if (take_group) {
            _L: /* CIL Label */ 
#line 2079
            tmp___3 = zfs_zaccess_v4_perm(zp, 524288, cr);
#line 2079
            if (tmp___3 == 0) {
#line 2083
              secpolicy_setid_clear(vap, cr);
#line 2084
              trim_mask = (int )(mask & 12U);
            } else {
#line 2086
              need_policy = 1;
            }
          } else {
#line 2089
            need_policy = 1;
          }
        } else {
#line 2089
          need_policy = 1;
        }
      }
    }
  }
#line 2093
  mutex_enter(& zp->z_lock);
#line 2094
  oldva.va_mode = (unsigned int )pzp->zp_mode;
#line 2095
  oldva.va_uid = (unsigned int )(zp->z_phys)->zp_uid;
#line 2096
  oldva.va_gid = (unsigned int )(zp->z_phys)->zp_gid;
#line 2097
  mutex_exit(& zp->z_lock);
#line 2099
  if (mask & 2U) {
#line 2100
    tmp___4 = zfs_zaccess_v4_perm(zp, 262144, cr);
#line 2100
    if (tmp___4 == 0) {
#line 2101
      err = secpolicy_setid_setsticky_clear(vp, vap, (vattr_t const   *)(& oldva),
                                            cr);
#line 2103
      if (err) {
#line 2104
        atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 2105
        return (err);
      }
#line 2107
      trim_mask |= 2;
    } else {
#line 2109
      need_policy = 1;
    }
  }
#line 2113
  if (need_policy) {
#line 2122
    if (trim_mask) {
#line 2123
      saved_mask = vap->va_mask;
#line 2124
      vap->va_mask &= (unsigned int )(~ trim_mask);
    }
#line 2127
    err = secpolicy_vnode_setattr(cr, vp, vap, (struct vattr  const  *)(& oldva),
                                  flags, (int (*)(void * , int  , cred_t * ))(& zfs_zaccess_rwx),
                                  (void *)zp);
#line 2129
    if (err) {
#line 2130
      atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 2131
      return (err);
    }
#line 2134
    if (trim_mask) {
#line 2135
      vap->va_mask |= saved_mask;
    }
  }
#line 2142
  mask = vap->va_mask;
#line 2144
  tx = dmu_tx_create(zfsvfs->z_os);
#line 2145
  dmu_tx_hold_bonus(tx, zp->z_id);
#line 2147
  if (mask & 2U) {
#line 2148
    pmode = pzp->zp_mode;
#line 2150
    new_mode = (pmode & 61440ULL) | (unsigned long long )(vap->va_mode & 4294905855U);
#line 2152
    if ((zp->z_phys)->zp_acl.z_acl_extern_obj) {
#line 2153
      dmu_tx_hold_write(tx, pzp->zp_acl.z_acl_extern_obj, 0ULL, (int )(1ULL << 17));
    } else {
#line 2156
      dmu_tx_hold_write(tx, 0xffffffffffffffffULL, 0ULL, (int )(sizeof(ace_t ) * 2054U));
    }
  }
#line 2160
  if (mask & 12U) {
#line 2160
    if ((zp->z_phys)->zp_xattr != 0ULL) {
#line 2161
      err = zfs_zget(zp->z_zfsvfs, (zp->z_phys)->zp_xattr, & attrzp);
#line 2162
      if (err) {
#line 2163
        dmu_tx_abort(tx);
#line 2164
        atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 2165
        return (err);
      }
#line 2167
      dmu_tx_hold_bonus(tx, attrzp->z_id);
    }
  }
#line 2170
  err = dmu_tx_assign(tx, zfsvfs->z_assign);
#line 2171
  if (err) {
#line 2172
    if (attrzp) {
#line 2173
      vn_rele(attrzp->z_vnode);
    }
#line 2174
    if (err == 85) {
#line 2174
      if (zfsvfs->z_assign == 2ULL) {
#line 2175
        dmu_tx_wait(tx);
#line 2176
        dmu_tx_abort(tx);
        goto top;
      }
    }
#line 2179
    dmu_tx_abort(tx);
#line 2180
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 2181
    return (err);
  }
#line 2184
  dmu_buf_will_dirty(zp->z_dbuf, tx);
#line 2194
  mutex_enter(& zp->z_lock);
#line 2196
  if (mask & 2U) {
#line 2197
    err = zfs_acl_chmod_setattr(zp, new_mode, tx);
#line 2198
    while (1) {
#line 2198
      __left = (unsigned long long )err;
#line 2198
      __right = 0ULL;
#line 2198
      if (! (__left == __right)) {
#line 2198
        tmp___5 = __builtin_alloca(256U);
#line 2198
        __buf = (char *)tmp___5;
#line 2198
        snprintf((char * __restrict  )__buf, 256U, (char const   * __restrict  )"%s %s %s (0x%llx %s 0x%llx)",
                 "err", "==", "0", __left, "==", __right);
#line 2198
        while (1) {
#line 2198
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                  "zfs-fuse/zfs_vnops.c", 2198, "zfs_setattr", __buf);
#line 2198
          abort();
#line 2198
          break;
        }
      }
#line 2198
      break;
    }
  }
#line 2201
  if (attrzp) {
#line 2202
    mutex_enter(& attrzp->z_lock);
  }
#line 2204
  if (mask & 4U) {
#line 2205
    (zp->z_phys)->zp_uid = (unsigned long long )vap->va_uid;
#line 2206
    if (attrzp) {
#line 2207
      (attrzp->z_phys)->zp_uid = (unsigned long long )vap->va_uid;
    }
  }
#line 2211
  if (mask & 8U) {
#line 2212
    (zp->z_phys)->zp_gid = (unsigned long long )vap->va_gid;
#line 2213
    if (attrzp) {
#line 2214
      (attrzp->z_phys)->zp_gid = (unsigned long long )vap->va_gid;
    }
  }
#line 2217
  if (attrzp) {
#line 2218
    mutex_exit(& attrzp->z_lock);
  }
#line 2220
  if (mask & 256U) {
#line 2221
    pzp->zp_atime[0] = (unsigned long long )vap->va_atime.tv_sec;
#line 2221
    pzp->zp_atime[1] = (unsigned long long )vap->va_atime.tv_nsec;
  }
#line 2223
  if (mask & 512U) {
#line 2224
    pzp->zp_mtime[0] = (unsigned long long )vap->va_mtime.tv_sec;
#line 2224
    pzp->zp_mtime[1] = (unsigned long long )vap->va_mtime.tv_nsec;
  }
#line 2226
  if (mask & 128U) {
#line 2227
    zfs_time_stamper_locked(zp, 1536U, tx);
  } else {
#line 2228
    if (mask != 0U) {
#line 2229
      zfs_time_stamper_locked(zp, 1024U, tx);
    }
  }
#line 2231
  if (mask != 0U) {
#line 2232
    zfs_log_setattr(zilog, tx, 11, zp, vap, mask);
  }
#line 2234
  mutex_exit(& zp->z_lock);
#line 2236
  if (attrzp) {
#line 2237
    vn_rele(attrzp->z_vnode);
  }
#line 2239
  dmu_tx_commit(tx);
#line 2241
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 2242
  return (err);
}
}
#line 2254 "zfs-fuse/zfs_vnops.c"
static void zfs_rename_unlock(zfs_zlock_t **zlpp ) 
{ zfs_zlock_t *zl ;

  {
#line 2259
  while (1) {
#line 2259
    zl = *zlpp;
#line 2259
    if (! ((unsigned int )zl != (unsigned int )((void *)0))) {
#line 2259
      break;
    }
#line 2260
    if ((unsigned int )zl->zl_znode != (unsigned int )((void *)0)) {
#line 2261
      vn_rele((zl->zl_znode)->z_vnode);
    }
#line 2262
    rw_exit(zl->zl_rwlock);
#line 2263
    *zlpp = zl->zl_next;
#line 2264
    umem_free((void *)zl, sizeof(*zl));
  }
#line 2266
  return;
}
}
#line 2274 "zfs-fuse/zfs_vnops.c"
static int zfs_rename_lock(znode_t *szp , znode_t *tdzp , znode_t *sdzp , zfs_zlock_t **zlpp ) 
{ zfs_zlock_t *zl ;
  znode_t *zp ;
  uint64_t rootid ;
  uint64_t *oidp ;
  krwlock_t *rwlp ;
  krw_t rw ;
  int tmp ;
  void *tmp___0 ;
  int error ;
  int tmp___1 ;

  {
#line 2278
  zp = tdzp;
#line 2279
  rootid = (zp->z_zfsvfs)->z_root;
#line 2280
  oidp = & zp->z_id;
#line 2281
  rwlp = & szp->z_parent_lock;
#line 2282
  rw = 1;
#line 2288
  while (1) {
#line 2289
    tmp = rw_tryenter(rwlp, rw);
#line 2289
    if (! tmp) {
#line 2295
      if (rw == 0) {
#line 2295
        if (zp->z_id > szp->z_id) {
#line 2299
          zfs_rename_unlock(& zl);
#line 2300
          *zlpp = (zfs_zlock_t *)((void *)0);
#line 2301
          zp = tdzp;
#line 2302
          oidp = & zp->z_id;
#line 2303
          rwlp = & szp->z_parent_lock;
#line 2304
          rw = 1;
          goto __Cont;
        } else {
#line 2310
          rw_enter(rwlp, rw);
        }
      } else {
#line 2310
        rw_enter(rwlp, rw);
      }
    }
#line 2314
    tmp___0 = umem_alloc(sizeof(*zl), 256);
#line 2314
    zl = (zfs_zlock_t *)tmp___0;
#line 2315
    zl->zl_rwlock = rwlp;
#line 2316
    zl->zl_znode = (znode_t *)((void *)0);
#line 2317
    zl->zl_next = *zlpp;
#line 2318
    *zlpp = zl;
#line 2320
    if (*oidp == szp->z_id) {
#line 2321
      return (22);
    }
#line 2323
    if (*oidp == rootid) {
#line 2324
      return (0);
    }
#line 2326
    if (rw == 0) {
#line 2327
      tmp___1 = zfs_zget(zp->z_zfsvfs, *oidp, & zp);
#line 2327
      error = tmp___1;
#line 2328
      if (error) {
#line 2329
        return (error);
      }
#line 2330
      zl->zl_znode = zp;
    }
#line 2332
    oidp = & (zp->z_phys)->zp_parent;
#line 2333
    rwlp = & zp->z_parent_lock;
#line 2334
    rw = 0;
    __Cont: /* CIL Label */ 
#line 2288
    if (! (zp->z_id != sdzp->z_id)) {
#line 2288
      break;
    }
  }
#line 2338
  return (0);
}
}
#line 2357 "zfs-fuse/zfs_vnops.c"
static int zfs_rename(vnode_t *sdvp , char *snm , vnode_t *tdvp , char *tnm , cred_t *cr ) 
{ znode_t *tdzp ;
  znode_t *szp ;
  znode_t *tzp ;
  znode_t *sdzp ;
  zfsvfs_t *zfsvfs ;
  zilog_t *zilog ;
  vnode_t *realvp ;
  zfs_dirlock_t *sdl ;
  zfs_dirlock_t *tdl ;
  dmu_tx_t *tx ;
  zfs_zlock_t *zl ;
  int cmp ;
  int serr ;
  int terr ;
  int error ;
  int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___25 ;
  int tmp___28 ;
  int tmp___29 ;

  {
#line 2361
  sdzp = (znode_t *)sdvp->v_data;
#line 2362
  zfsvfs = sdzp->z_zfsvfs;
#line 2363
  zilog = zfsvfs->z_log;
#line 2370
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 2370
  if (zfsvfs->z_unmounted1) {
#line 2370
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 2370
    return (5);
  }
#line 2375
  tmp = fop_realvp(tdvp, & realvp);
#line 2375
  if (tmp == 0) {
#line 2376
    tdvp = realvp;
  }
#line 2378
  if ((unsigned int )tdvp->v_vfsp != (unsigned int )sdvp->v_vfsp) {
#line 2379
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 2380
    return (18);
  }
#line 2383
  tdzp = (znode_t *)tdvp->v_data;
  top: 
#line 2385
  szp = (znode_t *)((void *)0);
#line 2386
  tzp = (znode_t *)((void *)0);
#line 2387
  zl = (zfs_zlock_t *)((void *)0);
#line 2394
  if (((tdzp->z_phys)->zp_flags & 1ULL) != ((sdzp->z_phys)->zp_flags & 1ULL)) {
#line 2396
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 2397
    return (22);
  }
#line 2406
  if (sdzp->z_id < tdzp->z_id) {
#line 2407
    cmp = -1;
  } else {
#line 2408
    if (sdzp->z_id > tdzp->z_id) {
#line 2409
      cmp = 1;
    } else {
#line 2411
      if (0) {
#line 2411
        __s1_len = strlen((char const   *)snm);
#line 2411
        __s2_len = strlen((char const   *)tnm);
#line 2411
        if (! ((unsigned int )((void const   *)(snm + 1)) - (unsigned int )((void const   *)snm) == 1U)) {
          goto _L___0;
        } else {
#line 2411
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 2411
            if (! ((unsigned int )((void const   *)(tnm + 1)) - (unsigned int )((void const   *)tnm) == 1U)) {
#line 2411
              tmp___9 = 1;
            } else {
#line 2411
              if (__s2_len >= 4U) {
#line 2411
                tmp___9 = 1;
              } else {
#line 2411
                tmp___9 = 0;
              }
            }
          } else {
#line 2411
            tmp___9 = 0;
          }
        }
#line 2411
        if (tmp___9) {
#line 2411
          tmp___5 = __builtin_strcmp((char const   *)snm, (char const   *)tnm);
        } else {
#line 2411
          tmp___8 = __builtin_strcmp((char const   *)snm, (char const   *)tnm);
#line 2411
          tmp___5 = tmp___8;
        }
      } else {
#line 2411
        tmp___8 = __builtin_strcmp((char const   *)snm, (char const   *)tnm);
#line 2411
        tmp___5 = tmp___8;
      }
#line 2411
      cmp = tmp___5;
#line 2412
      if (cmp == 0) {
#line 2419
        atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 2420
        return (0);
      }
    }
  }
#line 2423
  if (cmp < 0) {
#line 2424
    serr = zfs_dirent_lock(& sdl, sdzp, snm, & szp, 2);
#line 2425
    terr = zfs_dirent_lock(& tdl, tdzp, tnm, & tzp, 0);
  } else {
#line 2427
    terr = zfs_dirent_lock(& tdl, tdzp, tnm, & tzp, 0);
#line 2428
    serr = zfs_dirent_lock(& sdl, sdzp, snm, & szp, 2);
  }
#line 2431
  if (serr) {
#line 2435
    if (! terr) {
#line 2436
      zfs_dirent_unlock(tdl);
#line 2437
      if (tzp) {
#line 2438
        vn_rele(tzp->z_vnode);
      }
    }
#line 2440
    if (0) {
#line 2440
      __s1_len___0 = strlen((char const   *)snm);
#line 2440
      __s2_len___0 = strlen("..");
#line 2440
      if (! ((unsigned int )((void const   *)(snm + 1)) - (unsigned int )((void const   *)snm) == 1U)) {
        goto _L___2;
      } else {
#line 2440
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 2440
          if (! ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") == 1U)) {
#line 2440
            tmp___19 = 1;
          } else {
#line 2440
            if (__s2_len___0 >= 4U) {
#line 2440
              tmp___19 = 1;
            } else {
#line 2440
              tmp___19 = 0;
            }
          }
        } else {
#line 2440
          tmp___19 = 0;
        }
      }
#line 2440
      if (tmp___19) {
#line 2440
        tmp___15 = __builtin_strcmp((char const   *)snm, "..");
      } else {
#line 2440
        tmp___18 = __builtin_strcmp((char const   *)snm, "..");
#line 2440
        tmp___15 = tmp___18;
      }
    } else {
#line 2440
      tmp___18 = __builtin_strcmp((char const   *)snm, "..");
#line 2440
      tmp___15 = tmp___18;
    }
#line 2440
    if (tmp___15 == 0) {
#line 2441
      serr = 22;
    }
#line 2442
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 2443
    return (serr);
  }
#line 2445
  if (terr) {
#line 2446
    zfs_dirent_unlock(sdl);
#line 2447
    vn_rele(szp->z_vnode);
#line 2448
    if (0) {
#line 2448
      __s1_len___1 = strlen((char const   *)tnm);
#line 2448
      __s2_len___1 = strlen("..");
#line 2448
      if (! ((unsigned int )((void const   *)(tnm + 1)) - (unsigned int )((void const   *)tnm) == 1U)) {
        goto _L___4;
      } else {
#line 2448
        if (__s1_len___1 >= 4U) {
          _L___4: /* CIL Label */ 
#line 2448
          if (! ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") == 1U)) {
#line 2448
            tmp___29 = 1;
          } else {
#line 2448
            if (__s2_len___1 >= 4U) {
#line 2448
              tmp___29 = 1;
            } else {
#line 2448
              tmp___29 = 0;
            }
          }
        } else {
#line 2448
          tmp___29 = 0;
        }
      }
#line 2448
      if (tmp___29) {
#line 2448
        tmp___25 = __builtin_strcmp((char const   *)tnm, "..");
      } else {
#line 2448
        tmp___28 = __builtin_strcmp((char const   *)tnm, "..");
#line 2448
        tmp___25 = tmp___28;
      }
    } else {
#line 2448
      tmp___28 = __builtin_strcmp((char const   *)tnm, "..");
#line 2448
      tmp___25 = tmp___28;
    }
#line 2448
    if (tmp___25 == 0) {
#line 2449
      terr = 22;
    }
#line 2450
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 2451
    return (terr);
  }
#line 2461
  error = zfs_zaccess_rename(sdzp, szp, tdzp, tzp, cr);
#line 2461
  if (error) {
    goto out;
  }
#line 2464
  if ((int )(szp->z_vnode)->v_type == 2) {
#line 2469
    error = zfs_rename_lock(szp, tdzp, sdzp, & zl);
#line 2469
    if (error) {
      goto out;
    }
  }
#line 2476
  if (tzp) {
#line 2480
    if ((int )(szp->z_vnode)->v_type == 2) {
#line 2481
      if ((int )(tzp->z_vnode)->v_type != 2) {
#line 2482
        error = 20;
        goto out;
      }
    } else {
#line 2486
      if ((int )(tzp->z_vnode)->v_type == 2) {
#line 2487
        error = 21;
        goto out;
      }
    }
#line 2496
    if (szp->z_id == tzp->z_id) {
#line 2497
      error = 0;
      goto out;
    }
  }
#line 2503
  if (tzp) {

  }
#line 2506
  tx = dmu_tx_create(zfsvfs->z_os);
#line 2507
  dmu_tx_hold_bonus(tx, szp->z_id);
#line 2508
  dmu_tx_hold_bonus(tx, sdzp->z_id);
#line 2509
  dmu_tx_hold_zap(tx, sdzp->z_id, 0, snm);
#line 2510
  dmu_tx_hold_zap(tx, tdzp->z_id, 1, tnm);
#line 2511
  if ((unsigned int )sdzp != (unsigned int )tdzp) {
#line 2512
    dmu_tx_hold_bonus(tx, tdzp->z_id);
  }
#line 2513
  if (tzp) {
#line 2514
    dmu_tx_hold_bonus(tx, tzp->z_id);
  }
#line 2515
  dmu_tx_hold_zap(tx, zfsvfs->z_dqueue, 0, (char *)((void *)0));
#line 2516
  error = dmu_tx_assign(tx, zfsvfs->z_assign);
#line 2517
  if (error) {
#line 2518
    if ((unsigned int )zl != (unsigned int )((void *)0)) {
#line 2519
      zfs_rename_unlock(& zl);
    }
#line 2520
    zfs_dirent_unlock(sdl);
#line 2521
    zfs_dirent_unlock(tdl);
#line 2522
    vn_rele(szp->z_vnode);
#line 2523
    if (tzp) {
#line 2524
      vn_rele(tzp->z_vnode);
    }
#line 2525
    if (error == 85) {
#line 2525
      if (zfsvfs->z_assign == 2ULL) {
#line 2526
        dmu_tx_wait(tx);
#line 2527
        dmu_tx_abort(tx);
        goto top;
      }
    }
#line 2530
    dmu_tx_abort(tx);
#line 2531
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 2532
    return (error);
  }
#line 2535
  if (tzp) {
#line 2536
    error = zfs_link_destroy(tdl, tzp, tx, 0, (int *)((void *)0));
  }
#line 2538
  if (error == 0) {
#line 2539
    error = zfs_link_create(tdl, szp, tx, 16);
#line 2540
    if (error == 0) {
#line 2541
      error = zfs_link_destroy(sdl, szp, tx, 16, (int *)((void *)0));
#line 2542
      if (! (error == 0)) {
#line 2542
        __assert_fail("error == 0", "zfs-fuse/zfs_vnops.c", 2542U, "zfs_rename");
      }
#line 2543
      zfs_log_rename(zilog, tx, 8, sdzp, sdl->dl_name, tdzp, tdl->dl_name, szp);
    }
  }
#line 2548
  dmu_tx_commit(tx);
  out: 
#line 2550
  if ((unsigned int )zl != (unsigned int )((void *)0)) {
#line 2551
    zfs_rename_unlock(& zl);
  }
#line 2553
  zfs_dirent_unlock(sdl);
#line 2554
  zfs_dirent_unlock(tdl);
#line 2556
  vn_rele(szp->z_vnode);
#line 2557
  if (tzp) {
#line 2558
    vn_rele(tzp->z_vnode);
  }
#line 2560
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 2561
  return (error);
}
}
#line 2579 "zfs-fuse/zfs_vnops.c"
static int zfs_symlink(vnode_t *dvp , char *name , vattr_t *vap , char *link___0 ,
                       cred_t *cr ) 
{ znode_t *zp ;
  znode_t *dzp ;
  zfs_dirlock_t *dl ;
  dmu_tx_t *tx ;
  zfsvfs_t *zfsvfs ;
  zilog_t *zilog ;
  uint64_t zoid ;
  int len ;
  size_t tmp ;
  int error ;
  int tmp___0 ;
  dmu_buf_t *dbp ;
  int tmp___1 ;
  uint64_t __left ;
  uint64_t __right ;
  char *__buf ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 2582
  dzp = (znode_t *)dvp->v_data;
#line 2585
  zfsvfs = dzp->z_zfsvfs;
#line 2586
  zilog = zfsvfs->z_log;
#line 2588
  tmp = strlen((char const   *)link___0);
#line 2588
  len = (int )tmp;
#line 2591
  if (! ((int )vap->va_type == 5)) {
#line 2591
    __assert_fail("vap->va_type == VLNK", "zfs-fuse/zfs_vnops.c", 2591U, "zfs_symlink");
  }
#line 2593
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 2593
  if (zfsvfs->z_unmounted1) {
#line 2593
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 2593
    return (5);
  }
  top: 
#line 2595
  error = zfs_zaccess(dzp, 2, cr);
#line 2595
  if (error) {
#line 2596
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 2597
    return (error);
  }
#line 2600
  if (len > 4096) {
#line 2601
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 2602
    return (36);
  }
#line 2608
  error = zfs_dirent_lock(& dl, dzp, name, & zp, 1);
#line 2608
  if (error) {
#line 2609
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 2610
    return (error);
  }
#line 2613
  tx = dmu_tx_create(zfsvfs->z_os);
#line 2614
  if (1 > len) {
#line 2614
    tmp___0 = 1;
  } else {
#line 2614
    tmp___0 = len;
  }
#line 2614
  dmu_tx_hold_write(tx, 0xffffffffffffffffULL, 0ULL, tmp___0);
#line 2615
  dmu_tx_hold_bonus(tx, dzp->z_id);
#line 2616
  dmu_tx_hold_zap(tx, dzp->z_id, 1, name);
#line 2617
  if ((dzp->z_phys)->zp_flags & 2ULL) {
#line 2618
    dmu_tx_hold_write(tx, 0xffffffffffffffffULL, 0ULL, (int )(1ULL << 17));
  }
#line 2619
  error = dmu_tx_assign(tx, zfsvfs->z_assign);
#line 2620
  if (error) {
#line 2621
    zfs_dirent_unlock(dl);
#line 2622
    if (error == 85) {
#line 2622
      if (zfsvfs->z_assign == 2ULL) {
#line 2623
        dmu_tx_wait(tx);
#line 2624
        dmu_tx_abort(tx);
        goto top;
      }
    }
#line 2627
    dmu_tx_abort(tx);
#line 2628
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 2629
    return (error);
  }
#line 2632
  dmu_buf_will_dirty(dzp->z_dbuf, tx);
#line 2639
  zoid = 0ULL;
#line 2640
  tmp___3 = dmu_bonus_max();
#line 2640
  if (sizeof(znode_phys_t ) + (unsigned int )len <= (unsigned int )tmp___3) {
#line 2641
    zfs_mknode(dzp, vap, & zoid, tx, cr, 0U, & zp, len);
#line 2642
    if (len != 0) {
#line 2643
      bcopy((void const   *)link___0, (void *)(zp->z_phys + 1), (unsigned int )len);
    }
  } else {
#line 2647
    zfs_mknode(dzp, vap, & zoid, tx, cr, 0U, & zp, 0);
#line 2653
    zfs_grow_blocksize(zp, (unsigned long long )len, tx);
#line 2655
    while (1) {
#line 2655
      tmp___1 = dmu_buf_hold(zfsvfs->z_os, zoid, 0ULL, (void *)((char *)"zfs_symlink"),
                             & dbp);
#line 2655
      if (! (0 == tmp___1)) {
#line 2655
        while (1) {
#line 2655
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                  "zfs-fuse/zfs_vnops.c", 2655, "zfs_symlink", "0 == dmu_buf_hold(zfsvfs->z_os, zoid, 0, FTAG, &dbp)");
#line 2655
          abort();
#line 2655
          break;
        }
      }
#line 2655
      break;
    }
#line 2656
    dmu_buf_will_dirty(dbp, tx);
#line 2658
    while (1) {
#line 2658
      __left = (unsigned long long )len;
#line 2658
      __right = dbp->db_size;
#line 2658
      if (! (__left <= __right)) {
#line 2658
        tmp___2 = __builtin_alloca(256U);
#line 2658
        __buf = (char *)tmp___2;
#line 2658
        snprintf((char * __restrict  )__buf, 256U, (char const   * __restrict  )"%s %s %s (0x%llx %s 0x%llx)",
                 "len", "<=", "dbp->db_size", __left, "<=", __right);
#line 2658
        while (1) {
#line 2658
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                  "zfs-fuse/zfs_vnops.c", 2658, "zfs_symlink", __buf);
#line 2658
          abort();
#line 2658
          break;
        }
      }
#line 2658
      break;
    }
#line 2659
    bcopy((void const   *)link___0, dbp->db_data, (unsigned int )len);
#line 2660
    dmu_buf_rele(dbp, (void *)((char *)"zfs_symlink"));
  }
#line 2662
  (zp->z_phys)->zp_size = (unsigned long long )len;
#line 2667
  zfs_link_create(dl, zp, tx, 1);
#line 2669
  if (error == 0) {
#line 2670
    zfs_log_symlink(zilog, tx, 4, dzp, zp, name, link___0);
  }
#line 2672
  dmu_tx_commit(tx);
#line 2674
  zfs_dirent_unlock(dl);
#line 2676
  vn_rele(zp->z_vnode);
#line 2678
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 2679
  return (error);
}
}
#line 2699 "zfs-fuse/zfs_vnops.c"
static int zfs_readlink(vnode_t *vp , uio_t *uio , cred_t *cr ) 
{ znode_t *zp ;
  zfsvfs_t *zfsvfs ;
  size_t bufsz ;
  int error ;
  unsigned int tmp ;
  dmu_buf_t *dbp ;
  unsigned int tmp___0 ;

  {
#line 2702
  zp = (znode_t *)vp->v_data;
#line 2703
  zfsvfs = zp->z_zfsvfs;
#line 2707
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 2707
  if (zfsvfs->z_unmounted1) {
#line 2707
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 2707
    return (5);
  }
#line 2709
  bufsz = (unsigned int )(zp->z_phys)->zp_size;
#line 2710
  if ((uint64_t )(bufsz + sizeof(znode_phys_t )) <= (zp->z_dbuf)->db_size) {
#line 2711
    if (bufsz < (unsigned int )uio->uio_resid) {
#line 2711
      tmp = bufsz;
    } else {
#line 2711
      tmp = (unsigned int )uio->uio_resid;
    }
#line 2711
    error = uiomove((void *)(zp->z_phys + 1), tmp, 0, uio);
  } else {
#line 2715
    error = dmu_buf_hold(zfsvfs->z_os, zp->z_id, 0ULL, (void *)((char *)"zfs_readlink"),
                         & dbp);
#line 2716
    if (error) {
#line 2717
      atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 2718
      return (error);
    }
#line 2720
    if (bufsz < (unsigned int )uio->uio_resid) {
#line 2720
      tmp___0 = bufsz;
    } else {
#line 2720
      tmp___0 = (unsigned int )uio->uio_resid;
    }
#line 2720
    error = uiomove(dbp->db_data, tmp___0, 0, uio);
#line 2722
    dmu_buf_rele(dbp, (void *)((char *)"zfs_readlink"));
  }
#line 2725
  if (zfsvfs->z_atime) {
#line 2725
    if (! ((zfsvfs->z_vfs)->vfs_flag & 1U)) {
#line 2725
      zfs_time_stamper(zp, 256U, (dmu_tx_t *)((void *)0));
    }
  }
#line 2726
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 2727
  return (error);
}
}
#line 2746 "zfs-fuse/zfs_vnops.c"
static int zfs_link(vnode_t *tdvp , vnode_t *svp , char *name , cred_t *cr ) 
{ znode_t *dzp ;
  znode_t *tzp ;
  znode_t *szp ;
  zfsvfs_t *zfsvfs ;
  zilog_t *zilog ;
  zfs_dirlock_t *dl ;
  dmu_tx_t *tx ;
  vnode_t *realvp ;
  int error ;
  int tmp ;
  uid_t tmp___0 ;
  int tmp___2 ;
  uid_t tmp___3 ;

  {
#line 2749
  dzp = (znode_t *)tdvp->v_data;
#line 2751
  zfsvfs = dzp->z_zfsvfs;
#line 2752
  zilog = zfsvfs->z_log;
#line 2758
  if (! ((int )tdvp->v_type == 2)) {
#line 2758
    __assert_fail("tdvp->v_type == VDIR", "zfs-fuse/zfs_vnops.c", 2758U, "zfs_link");
  }
#line 2760
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 2760
  if (zfsvfs->z_unmounted1) {
#line 2760
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 2760
    return (5);
  }
#line 2762
  tmp = fop_realvp(svp, & realvp);
#line 2762
  if (tmp == 0) {
#line 2763
    svp = realvp;
  }
#line 2765
  if ((unsigned int )svp->v_vfsp != (unsigned int )tdvp->v_vfsp) {
#line 2766
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 2767
    return (18);
  }
#line 2770
  szp = (znode_t *)svp->v_data;
  top: 
#line 2778
  if (((szp->z_phys)->zp_flags & 1ULL) != ((dzp->z_phys)->zp_flags & 1ULL)) {
#line 2780
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 2781
    return (22);
  }
#line 2788
  if ((int )svp->v_type == 2) {
#line 2789
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 2790
    return (1);
  }
#line 2793
  tmp___0 = crgetuid((cred_t const   *)cr);
#line 2793
  if ((unsigned int )(szp->z_phys)->zp_uid != tmp___0) {
#line 2793
    tmp___3 = crgetuid((cred_t const   *)cr);
#line 2793
    if (tmp___3 == 0U) {
#line 2793
      tmp___2 = 0;
    } else {
#line 2793
      tmp___2 = 1;
    }
#line 2793
    if (tmp___2 != 0) {
#line 2795
      atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 2796
      return (1);
    }
  }
#line 2799
  error = zfs_zaccess(dzp, 2, cr);
#line 2799
  if (error) {
#line 2800
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 2801
    return (error);
  }
#line 2807
  error = zfs_dirent_lock(& dl, dzp, name, & tzp, 1);
#line 2807
  if (error) {
#line 2808
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 2809
    return (error);
  }
#line 2812
  tx = dmu_tx_create(zfsvfs->z_os);
#line 2813
  dmu_tx_hold_bonus(tx, szp->z_id);
#line 2814
  dmu_tx_hold_zap(tx, dzp->z_id, 1, name);
#line 2815
  error = dmu_tx_assign(tx, zfsvfs->z_assign);
#line 2816
  if (error) {
#line 2817
    zfs_dirent_unlock(dl);
#line 2818
    if (error == 85) {
#line 2818
      if (zfsvfs->z_assign == 2ULL) {
#line 2819
        dmu_tx_wait(tx);
#line 2820
        dmu_tx_abort(tx);
        goto top;
      }
    }
#line 2823
    dmu_tx_abort(tx);
#line 2824
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 2825
    return (error);
  }
#line 2828
  error = zfs_link_create(dl, szp, tx, 0);
#line 2830
  if (error == 0) {
#line 2831
    zfs_log_link(zilog, tx, 7, dzp, szp, name);
  }
#line 2833
  dmu_tx_commit(tx);
#line 2835
  zfs_dirent_unlock(dl);
#line 2837
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 2838
  return (error);
}
}
#line 2996 "zfs-fuse/zfs_vnops.c"
static int zfs_putpage(vnode_t *vp , offset_t off , size_t len , int flags , cred_t *cr ) 
{ 

  {
#line 3000
  abort();
}
}
#line 3063 "zfs-fuse/zfs_vnops.c"
void zfs_inactive(vnode_t *vp , cred_t *cr ) 
{ znode_t *zp ;
  zfsvfs_t *zfsvfs ;
  int error ;
  dmu_tx_t *tx ;
  dmu_tx_t *tmp ;

  {
#line 3066
  zp = (znode_t *)vp->v_data;
#line 3067
  zfsvfs = zp->z_zfsvfs;
#line 3070
  rw_enter(& zfsvfs->z_um_lock, 0);
#line 3071
  if (zfsvfs->z_unmounted2) {
#line 3072
    if (! ((int )zp->z_dbuf_held == 0)) {
#line 3072
      __assert_fail("zp->z_dbuf_held == 0", "zfs-fuse/zfs_vnops.c", 3072U, "zfs_inactive");
    }
#line 3079
    mutex_enter(& zp->z_lock);
#line 3080
    vp->v_count = 0U;
#line 3081
    if ((unsigned int )zp->z_dbuf == (unsigned int )((void *)0)) {
#line 3082
      mutex_exit(& zp->z_lock);
#line 3083
      zfs_znode_free(zp);
    } else {
#line 3085
      mutex_exit(& zp->z_lock);
    }
#line 3087
    rw_exit(& zfsvfs->z_um_lock);
#line 3088
    vfs_rele(zfsvfs->z_vfs);
#line 3089
    return;
  }
#line 3101
  if (zp->z_atime_dirty) {
#line 3101
    if ((int )zp->z_reap == 0) {
#line 3102
      tmp = dmu_tx_create(zfsvfs->z_os);
#line 3102
      tx = tmp;
#line 3104
      dmu_tx_hold_bonus(tx, zp->z_id);
#line 3105
      error = dmu_tx_assign(tx, 1ULL);
#line 3106
      if (error) {
#line 3107
        dmu_tx_abort(tx);
      } else {
#line 3109
        dmu_buf_will_dirty(zp->z_dbuf, tx);
#line 3110
        mutex_enter(& zp->z_lock);
#line 3111
        zp->z_atime_dirty = (unsigned char)0;
#line 3112
        mutex_exit(& zp->z_lock);
#line 3113
        dmu_tx_commit(tx);
      }
    }
  }
#line 3117
  zfs_zinactive(zp);
#line 3118
  rw_exit(& zfsvfs->z_um_lock);
#line 3119
  return;
}
}
#line 3132 "zfs-fuse/zfs_vnops.c"
static int zfs_seek(vnode_t *vp , offset_t ooff , offset_t *noffp ) 
{ int tmp ;

  {
#line 3135
  if ((int )vp->v_type == 2) {
#line 3136
    return (0);
  }
#line 3137
  if (*noffp < 0LL) {
#line 3137
    tmp = 22;
  } else {
#line 3137
    if (*noffp > 9223372036854775807LL) {
#line 3137
      tmp = 22;
    } else {
#line 3137
      tmp = 0;
    }
  }
#line 3137
  return (tmp);
}
}
#line 3144 "zfs-fuse/zfs_vnops.c"
static int zfs_frlock(vnode_t *vp , int cmd , flock64_t *bfp , int flag , offset_t offset ,
                      flk_callback_t *flk_cbp , cred_t *cr ) 
{ 

  {
#line 3149
  abort();
}
}
#line 3300 "zfs-fuse/zfs_vnops.c"
static int zfs_getpage(vnode_t *vp , offset_t off , size_t len , uint_t *protp , page_t **pl ,
                       size_t plsz , struct seg *seg , caddr_t addr , enum seg_rw rw ,
                       cred_t *cr ) 
{ 

  {
#line 3306
  abort();
}
}
#line 3438 "zfs-fuse/zfs_vnops.c"
static int zfs_map(vnode_t *vp , offset_t off , struct as *as , caddr_t *addrp , size_t len ,
                   uchar_t prot , uchar_t maxprot , uint_t flags , cred_t *cr ) 
{ 

  {
#line 3443
  abort();
}
}
#line 3510 "zfs-fuse/zfs_vnops.c"
static int zfs_addmap(vnode_t *vp , offset_t off , struct as *as , caddr_t addr ,
                      size_t len , uchar_t prot , uchar_t maxprot , uint_t flags ,
                      cred_t *cr ) 
{ 

  {
#line 3515
  abort();
}
}
#line 3546 "zfs-fuse/zfs_vnops.c"
static int zfs_delmap(vnode_t *vp , offset_t off , struct as *as , caddr_t addr ,
                      size_t len , uint_t prot , uint_t maxprot , uint_t flags , cred_t *cr ) 
{ 

  {
#line 3551
  abort();
}
}
#line 3586 "zfs-fuse/zfs_vnops.c"
static int zfs_space(vnode_t *vp , int cmd , flock64_t *bfp , int flag , offset_t offset ,
                     cred_t *cr , caller_context_t *ct ) 
{ znode_t *zp ;
  zfsvfs_t *zfsvfs ;
  uint64_t off ;
  uint64_t len ;
  int error ;

  {
#line 3590
  zp = (znode_t *)vp->v_data;
#line 3591
  zfsvfs = zp->z_zfsvfs;
#line 3595
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 3595
  if (zfsvfs->z_unmounted1) {
#line 3595
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 3595
    return (5);
  }
#line 3597
  if (cmd != 27) {
#line 3598
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 3599
    return (22);
  }
#line 3602
  error = convoff(vp, bfp, 0, offset);
#line 3602
  if (error) {
#line 3603
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 3604
    return (error);
  }
#line 3607
  if (bfp->l_len < 0LL) {
#line 3608
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 3609
    return (22);
  }
#line 3612
  off = (unsigned long long )bfp->l_start;
#line 3613
  len = (unsigned long long )bfp->l_len;
#line 3615
  while (1) {
#line 3616
    error = zfs_freesp(zp, off, len, flag, (enum boolean )1);
#line 3615
    if (error == 85) {
#line 3615
      if (! (zfsvfs->z_assign == 2ULL)) {
#line 3615
        break;
      }
    } else {
#line 3615
      break;
    }
  }
#line 3620
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 3621
  return (error);
}
}
#line 3624 "zfs-fuse/zfs_vnops.c"
static int zfs_fid(vnode_t *vp , fid_t *fidp ) 
{ znode_t *zp ;
  zfsvfs_t *zfsvfs ;
  uint32_t gen ;
  uint64_t object ;
  zfid_short_t *zfid ;
  int size ;
  int i ;
  uint64_t objsetid ;
  uint64_t tmp ;
  zfid_long_t *zlfid ;

  {
#line 3627
  zp = (znode_t *)vp->v_data;
#line 3628
  zfsvfs = zp->z_zfsvfs;
#line 3629
  gen = (unsigned int )(zp->z_phys)->zp_gen;
#line 3630
  object = zp->z_id;
#line 3634
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 3634
  if (zfsvfs->z_unmounted1) {
#line 3634
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 3634
    return (5);
  }
#line 3636
  if ((unsigned int )zfsvfs->z_parent != (unsigned int )zfsvfs) {
#line 3636
    size = (int )(sizeof(zfid_long_t ) - sizeof(uint16_t ));
  } else {
#line 3636
    size = (int )(sizeof(zfid_short_t ) - sizeof(uint16_t ));
  }
#line 3637
  if ((int )fidp->un._fid.len < size) {
#line 3638
    fidp->un._fid.len = (unsigned short )size;
#line 3639
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 3640
    return (28);
  }
#line 3643
  zfid = (zfid_short_t *)fidp;
#line 3645
  zfid->zf_len = (unsigned short )size;
#line 3647
  i = 0;
#line 3647
  while ((unsigned int )i < sizeof(zfid->zf_object)) {
#line 3648
    zfid->zf_object[i] = (unsigned char )(object >> 8 * i);
#line 3647
    i ++;
  }
#line 3651
  if (gen == 0U) {
#line 3652
    gen = 1U;
  }
#line 3653
  i = 0;
#line 3653
  while ((unsigned int )i < sizeof(zfid->zf_gen)) {
#line 3654
    zfid->zf_gen[i] = (unsigned char )(gen >> 8 * i);
#line 3653
    i ++;
  }
#line 3656
  if ((unsigned int )size == sizeof(zfid_long_t ) - sizeof(uint16_t )) {
#line 3657
    tmp = dmu_objset_id(zfsvfs->z_os);
#line 3657
    objsetid = tmp;
#line 3660
    zlfid = (zfid_long_t *)fidp;
#line 3662
    i = 0;
#line 3662
    while ((unsigned int )i < sizeof(zlfid->zf_setid)) {
#line 3663
      zlfid->zf_setid[i] = (unsigned char )(objsetid >> 8 * i);
#line 3662
      i ++;
    }
#line 3666
    i = 0;
#line 3666
    while ((unsigned int )i < sizeof(zlfid->zf_setgen)) {
#line 3667
      zlfid->zf_setgen[i] = (unsigned char)0;
#line 3666
      i ++;
    }
  }
#line 3670
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 3671
  return (0);
}
}
#line 3674 "zfs-fuse/zfs_vnops.c"
static int zfs_pathconf(vnode_t *vp , int cmd , ulong_t *valp , cred_t *cr ) 
{ 

  {
#line 3678
  abort();
}
}
#line 3731 "zfs-fuse/zfs_vnops.c"
static int zfs_getsecattr(vnode_t *vp , vsecattr_t *vsecp , int flag , cred_t *cr ) 
{ znode_t *zp ;
  zfsvfs_t *zfsvfs ;
  int error ;

  {
#line 3734
  zp = (znode_t *)vp->v_data;
#line 3735
  zfsvfs = zp->z_zfsvfs;
#line 3738
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 3738
  if (zfsvfs->z_unmounted1) {
#line 3738
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 3738
    return (5);
  }
#line 3739
  error = zfs_getacl(zp, vsecp, cr);
#line 3740
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 3742
  return (error);
}
}
#line 3746 "zfs-fuse/zfs_vnops.c"
static int zfs_setsecattr(vnode_t *vp , vsecattr_t *vsecp , int flag , cred_t *cr ) 
{ znode_t *zp ;
  zfsvfs_t *zfsvfs ;
  int error ;

  {
#line 3749
  zp = (znode_t *)vp->v_data;
#line 3750
  zfsvfs = zp->z_zfsvfs;
#line 3753
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 3753
  if (zfsvfs->z_unmounted1) {
#line 3753
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 3753
    return (5);
  }
#line 3754
  error = zfs_setacl(zp, vsecp, cr);
#line 3755
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 3756
  return (error);
}
}
#line 3765
static int zfs_inval(void) ;
#line 3766
static int zfs_isdir(void) ;
#line 3768 "zfs-fuse/zfs_vnops.c"
static int zfs_inval(void) 
{ 

  {
#line 3771
  return (22);
}
}
#line 3774 "zfs-fuse/zfs_vnops.c"
static int zfs_isdir(void) 
{ 

  {
#line 3777
  return (21);
}
}
#line 3782 "zfs-fuse/zfs_vnops.c"
struct vnodeops *zfs_dvnodeops  ;
#line 3783 "zfs-fuse/zfs_vnops.c"
fs_operation_def_t const   zfs_dvnodeops_template[25]  = 
#line 3783
  {      {(char *)"open", (int (*)())(& zfs_open)}, 
        {(char *)"close", (int (*)())(& zfs_close)}, 
        {(char *)"read", & zfs_isdir}, 
        {(char *)"write", & zfs_isdir}, 
        {(char *)"ioctl", (int (*)())(& zfs_ioctl)}, 
        {(char *)"getattr", (int (*)())(& zfs_getattr)}, 
        {(char *)"setattr", (int (*)())(& zfs_setattr)}, 
        {(char *)"access", (int (*)())(& zfs_access)}, 
        {(char *)"lookup", (int (*)())(& zfs_lookup)}, 
        {(char *)"create", (int (*)())(& zfs_create)}, 
        {(char *)"remove", (int (*)())(& zfs_remove)}, 
        {(char *)"link", (int (*)())(& zfs_link)}, 
        {(char *)"rename", (int (*)())(& zfs_rename)}, 
        {(char *)"mkdir", (int (*)())(& zfs_mkdir)}, 
        {(char *)"rmdir", (int (*)())(& zfs_rmdir)}, 
        {(char *)"readdir", (int (*)())(& zfs_readdir)}, 
        {(char *)"symlink", (int (*)())(& zfs_symlink)}, 
        {(char *)"fsync", (int (*)())(& zfs_fsync)}, 
        {(char *)"inactive", (int (*)())(& zfs_inactive)}, 
        {(char *)"fid", (int (*)())(& zfs_fid)}, 
        {(char *)"seek", (int (*)())(& zfs_seek)}, 
        {(char *)"pathconf", (int (*)())(& zfs_pathconf)}, 
        {(char *)"getsecattr", (int (*)())(& zfs_getsecattr)}, 
        {(char *)"setsecattr", (int (*)())(& zfs_setsecattr)}, 
        {(char *)((void *)0), (int (*)())((void *)0)}};
#line 3814 "zfs-fuse/zfs_vnops.c"
struct vnodeops *zfs_fvnodeops  ;
#line 3815 "zfs-fuse/zfs_vnops.c"
fs_operation_def_t const   zfs_fvnodeops_template[26]  = 
#line 3815
  {      {(char *)"open", (int (*)())(& zfs_open)}, 
        {(char *)"close", (int (*)())(& zfs_close)}, 
        {(char *)"read", (int (*)())(& zfs_read)}, 
        {(char *)"write", (int (*)())(& zfs_write)}, 
        {(char *)"ioctl", (int (*)())(& zfs_ioctl)}, 
        {(char *)"getattr", (int (*)())(& zfs_getattr)}, 
        {(char *)"setattr", (int (*)())(& zfs_setattr)}, 
        {(char *)"access", (int (*)())(& zfs_access)}, 
        {(char *)"lookup", (int (*)())(& zfs_lookup)}, 
        {(char *)"rename", (int (*)())(& zfs_rename)}, 
        {(char *)"fsync", (int (*)())(& zfs_fsync)}, 
        {(char *)"inactive", (int (*)())(& zfs_inactive)}, 
        {(char *)"fid", (int (*)())(& zfs_fid)}, 
        {(char *)"seek", (int (*)())(& zfs_seek)}, 
        {(char *)"frlock", (int (*)())(& zfs_frlock)}, 
        {(char *)"space", (int (*)())(& zfs_space)}, 
        {(char *)"getpage", (int (*)())(& zfs_getpage)}, 
        {(char *)"putpage", (int (*)())(& zfs_putpage)}, 
        {(char *)"map", (int (*)())(& zfs_map)}, 
        {(char *)"addmap", (int (*)())(& zfs_addmap)}, 
        {(char *)"delmap", (int (*)())(& zfs_delmap)}, 
        {(char *)"pathconf", (int (*)())(& zfs_pathconf)}, 
        {(char *)"getsecattr", (int (*)())(& zfs_getsecattr)}, 
        {(char *)"setsecattr", (int (*)())(& zfs_setsecattr)}, 
        {(char *)"vnevent", (int (*)())(& fs_vnevent_support)}, 
        {(char *)((void *)0), (int (*)())((void *)0)}};
#line 3847 "zfs-fuse/zfs_vnops.c"
struct vnodeops *zfs_symvnodeops  ;
#line 3848 "zfs-fuse/zfs_vnops.c"
fs_operation_def_t const   zfs_symvnodeops_template[10]  = 
#line 3848
  {      {(char *)"getattr", (int (*)())(& zfs_getattr)}, 
        {(char *)"setattr", (int (*)())(& zfs_setattr)}, 
        {(char *)"access", (int (*)())(& zfs_access)}, 
        {(char *)"rename", (int (*)())(& zfs_rename)}, 
        {(char *)"readlink", (int (*)())(& zfs_readlink)}, 
        {(char *)"inactive", (int (*)())(& zfs_inactive)}, 
        {(char *)"fid", (int (*)())(& zfs_fid)}, 
        {(char *)"pathconf", (int (*)())(& zfs_pathconf)}, 
        {(char *)"vnevent", (int (*)())(& fs_vnevent_support)}, 
        {(char *)((void *)0), (int (*)())((void *)0)}};
#line 3872 "zfs-fuse/zfs_vnops.c"
struct vnodeops *zfs_xdvnodeops  ;
#line 3873 "zfs-fuse/zfs_vnops.c"
fs_operation_def_t const   zfs_xdvnodeops_template[24]  = 
#line 3873
  {      {(char *)"open", (int (*)())(& zfs_open)}, 
        {(char *)"close", (int (*)())(& zfs_close)}, 
        {(char *)"ioctl", (int (*)())(& zfs_ioctl)}, 
        {(char *)"getattr", (int (*)())(& zfs_getattr)}, 
        {(char *)"setattr", (int (*)())(& zfs_setattr)}, 
        {(char *)"access", (int (*)())(& zfs_access)}, 
        {(char *)"lookup", (int (*)())(& zfs_lookup)}, 
        {(char *)"create", (int (*)())(& zfs_create)}, 
        {(char *)"remove", (int (*)())(& zfs_remove)}, 
        {(char *)"link", (int (*)())(& zfs_link)}, 
        {(char *)"rename", (int (*)())(& zfs_rename)}, 
        {(char *)"mkdir", & zfs_inval}, 
        {(char *)"rmdir", (int (*)())(& zfs_rmdir)}, 
        {(char *)"readdir", (int (*)())(& zfs_readdir)}, 
        {(char *)"symlink", & zfs_inval}, 
        {(char *)"fsync", (int (*)())(& zfs_fsync)}, 
        {(char *)"inactive", (int (*)())(& zfs_inactive)}, 
        {(char *)"fid", (int (*)())(& zfs_fid)}, 
        {(char *)"seek", (int (*)())(& zfs_seek)}, 
        {(char *)"pathconf", (int (*)())(& zfs_pathconf)}, 
        {(char *)"getsecattr", (int (*)())(& zfs_getsecattr)}, 
        {(char *)"setsecattr", (int (*)())(& zfs_setsecattr)}, 
        {(char *)"vnevent", (int (*)())(& fs_vnevent_support)}, 
        {(char *)((void *)0), (int (*)())((void *)0)}};
#line 3903 "zfs-fuse/zfs_vnops.c"
struct vnodeops *zfs_evnodeops  ;
#line 3904 "zfs-fuse/zfs_vnops.c"
fs_operation_def_t const   zfs_evnodeops_template[3]  = {      {(char *)"inactive", (int (*)())(& zfs_inactive)}, 
        {(char *)"pathconf", (int (*)())(& zfs_pathconf)}, 
        {(char *)((void *)0), (int (*)())((void *)0)}};
#line 1 "zfs_znode.o"
#pragma merger(0,"/tmp/cil-BqRFsugI.i","-pipe,-Wall,-Werror,-std=c99,-Wno-unused,-Wno-missing-braces,-Wno-parentheses,-Wno-uninitialized,-fno-strict-aliasing,-ggdb,-O2")
#line 327 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 332 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) int clock_gettime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 45 "lib/libsolkerncompat/include/sys/mutex.h"
extern void zmutex_destroy(kmutex_t *mp ) ;
#line 52 "lib/libsolkerncompat/include/sys/rwlock.h"
extern void rw_destroy(krwlock_t *rwlp ) ;
#line 74 "lib/libumem/include/umem.h"
extern umem_cache_t *umem_cache_create(char * , size_t  , size_t  , umem_constructor_t * ,
                                       umem_destructor_t * , umem_reclaim_t * , void * ,
                                       vmem_t * , int  ) ;
#line 77
extern void umem_cache_destroy(umem_cache_t * ) ;
#line 79
extern void *umem_cache_alloc(umem_cache_t * , int  ) ;
#line 80
extern void umem_cache_free(umem_cache_t * , void * ) ;
#line 303 "lib/libsolkerncompat/include/sys/vnode.h"
extern vnode_t *vn_alloc(int kmflag ) ;
#line 304
extern void vn_reinit(vnode_t *vp ) ;
#line 306
extern void vn_free(vnode_t *vp ) ;
#line 344
extern int vn_make_ops(char const   *name , fs_operation_def_t const   *templ , struct vnodeops **actual ) ;
#line 345
extern void vn_freevnodeops(struct vnodeops *vnops ) ;
#line 347
extern void vn_setops(vnode_t *vp , struct vnodeops *vnodeops ) ;
#line 155 "lib/libavl/include/sys/avl.h"
extern void avl_create(avl_tree_t *tree , int (*compar)(void const   * , void const   * ) ,
                       size_t size , size_t offset ) ;
#line 290
extern void avl_destroy(avl_tree_t *tree ) ;
#line 214 "lib/libzfscommon/include/sys/dmu.h"
extern int dmu_object_claim(objset_t *os , uint64_t object , dmu_object_type_t ot ,
                            int blocksize , dmu_object_type_t bonus_type , int bonus_len ,
                            dmu_tx_t *tx ) ;
#line 295
extern int dmu_bonus_hold(objset_t *os , uint64_t object , void *tag , dmu_buf_t ** ) ;
#line 351
extern void *dmu_buf_set_user(dmu_buf_t *db , void *user_ptr , void *user_data_ptr_ptr ,
                              dmu_buf_evict_func_t *pageout_func ) ;
#line 367
extern void *dmu_buf_get_user(dmu_buf_t *db ) ;
#line 414
extern int dmu_free_range(objset_t *os , uint64_t object , uint64_t offset , uint64_t size ,
                          dmu_tx_t *tx ) ;
#line 473
extern void dmu_object_info_from_db(dmu_buf_t *db , dmu_object_info_t *doi ) ;
#line 536
extern uint64_t dmu_tx_get_txg(dmu_tx_t *tx ) ;
#line 241 "lib/libzfscommon/include/sys/zfs_znode.h"
void zfs_create_fs(objset_t *os , cred_t *cr , dmu_tx_t *tx ) ;
#line 96 "lib/libzfscommon/include/sys/zap.h"
extern uint64_t zap_create(objset_t *ds , dmu_object_type_t ot , dmu_object_type_t bonustype ,
                           int bonuslen , dmu_tx_t *tx ) ;
#line 103
extern int zap_create_claim(objset_t *ds , uint64_t obj , dmu_object_type_t ot , dmu_object_type_t bonustype ,
                            int bonuslen , dmu_tx_t *tx ) ;
#line 165
extern int zap_update(objset_t *ds , uint64_t zapobj , char const   *name , int integer_size ,
                      uint64_t num_integers , void const   *val , dmu_tx_t *tx ) ;
#line 57 "zfs-fuse/zfs_znode.c"
kmem_cache_t *znode_cache  =    (kmem_cache_t *)((void *)0);
#line 60 "zfs-fuse/zfs_znode.c"
static void znode_pageout_func(dmu_buf_t *dbuf , void *user_ptr ) 
{ znode_t *zp ;
  vnode_t *vp ;

  {
#line 63
  zp = (znode_t *)user_ptr;
#line 64
  vp = zp->z_vnode;
#line 66
  mutex_enter(& zp->z_lock);
#line 67
  if (vp->v_count == 0U) {
#line 68
    mutex_exit(& zp->z_lock);
#line 70
    zfs_znode_free(zp);
  } else {
#line 73
    zp->z_dbuf = (dmu_buf_t *)((void *)0);
#line 74
    mutex_exit(& zp->z_lock);
  }
#line 76
  return;
}
}
#line 79 "zfs-fuse/zfs_znode.c"
static int zfs_znode_cache_constructor(void *buf , void *cdrarg , int kmflags ) 
{ znode_t *zp ;

  {
#line 82
  zp = (znode_t *)buf;
#line 84
  zp->z_vnode = vn_alloc(256);
#line 85
  (zp->z_vnode)->v_data = (void *)((char *)zp);
#line 86
  zmutex_init(& zp->z_lock);
#line 87
  rw_init(& zp->z_map_lock, (char *)((void *)0), 0, (void *)0);
#line 88
  rw_init(& zp->z_parent_lock, (char *)((void *)0), 0, (void *)0);
#line 89
  zmutex_init(& zp->z_acl_lock);
#line 91
  zmutex_init(& zp->z_range_lock);
#line 92
  avl_create(& zp->z_range_avl, & zfs_range_compare, sizeof(rl_t ), (unsigned int )(& ((rl_t *)0)->r_node));
#line 95
  zp->z_dbuf_held = (unsigned char)0;
#line 96
  zp->z_dirlocks = (zfs_dirlock_t *)0;
#line 97
  return (0);
}
}
#line 101 "zfs-fuse/zfs_znode.c"
static void zfs_znode_cache_destructor(void *buf , void *cdarg ) 
{ znode_t *zp ;

  {
#line 104
  zp = (znode_t *)buf;
#line 106
  if (! ((unsigned int )zp->z_dirlocks == (unsigned int )((zfs_dirlock_t *)0))) {
#line 106
    __assert_fail("zp->z_dirlocks == 0", "zfs-fuse/zfs_znode.c", 106U, "zfs_znode_cache_destructor");
  }
#line 107
  zmutex_destroy(& zp->z_lock);
#line 108
  rw_destroy(& zp->z_map_lock);
#line 109
  rw_destroy(& zp->z_parent_lock);
#line 110
  zmutex_destroy(& zp->z_acl_lock);
#line 111
  avl_destroy(& zp->z_range_avl);
#line 113
  if (! ((int )zp->z_dbuf_held == 0)) {
#line 113
    __assert_fail("zp->z_dbuf_held == 0", "zfs-fuse/zfs_znode.c", 113U, "zfs_znode_cache_destructor");
  }
#line 114
  if (! ((zp->z_vnode)->v_count == 0U)) {
#line 114
    __assert_fail("((zp)->z_vnode)->v_count == 0", "zfs-fuse/zfs_znode.c", 114U, "zfs_znode_cache_destructor");
  }
#line 115
  vn_free(zp->z_vnode);
#line 116
  return;
}
}
#line 118 "zfs-fuse/zfs_znode.c"
void zfs_znode_init(void) 
{ 

  {
#line 124
  if (! ((unsigned int )znode_cache == (unsigned int )((void *)0))) {
#line 124
    __assert_fail("znode_cache == ((void *)0)", "zfs-fuse/zfs_znode.c", 124U, "zfs_znode_init");
  }
#line 125
  znode_cache = umem_cache_create((char *)"zfs_znode_cache", sizeof(znode_t ), 0U,
                                  & zfs_znode_cache_constructor, & zfs_znode_cache_destructor,
                                  (umem_reclaim_t *)((void *)0), (void *)0, (vmem_t *)((void *)0),
                                  0);
#line 128
  return;
}
}
#line 130 "zfs-fuse/zfs_znode.c"
void zfs_znode_fini(void) 
{ 

  {
#line 142
  if (znode_cache) {
#line 143
    umem_cache_destroy(znode_cache);
  }
#line 144
  znode_cache = (kmem_cache_t *)((void *)0);
#line 145
  return;
}
}
#line 153 "zfs-fuse/zfs_znode.c"
void zfs_remove_op_tables(void) 
{ 

  {
#line 159
  if (! zfsfstype) {
#line 159
    __assert_fail("zfsfstype", "zfs-fuse/zfs_znode.c", 159U, "zfs_remove_op_tables");
  }
#line 161
  zfsfstype = 0;
#line 166
  if (zfs_dvnodeops) {
#line 167
    vn_freevnodeops(zfs_dvnodeops);
  }
#line 168
  if (zfs_fvnodeops) {
#line 169
    vn_freevnodeops(zfs_fvnodeops);
  }
#line 170
  if (zfs_symvnodeops) {
#line 171
    vn_freevnodeops(zfs_symvnodeops);
  }
#line 172
  if (zfs_xdvnodeops) {
#line 173
    vn_freevnodeops(zfs_xdvnodeops);
  }
#line 174
  if (zfs_evnodeops) {
#line 175
    vn_freevnodeops(zfs_evnodeops);
  }
#line 177
  zfs_dvnodeops = (struct vnodeops *)((void *)0);
#line 178
  zfs_fvnodeops = (struct vnodeops *)((void *)0);
#line 179
  zfs_symvnodeops = (struct vnodeops *)((void *)0);
#line 180
  zfs_xdvnodeops = (struct vnodeops *)((void *)0);
#line 181
  zfs_evnodeops = (struct vnodeops *)((void *)0);
#line 182
  return;
}
}
#line 190 "zfs-fuse/zfs_znode.c"
int zfs_create_op_tables(void) 
{ int error ;

  {
#line 200
  if (zfs_dvnodeops) {
#line 201
    return (0);
  }
#line 203
  error = vn_make_ops("zfs", zfs_dvnodeops_template, & zfs_dvnodeops);
#line 205
  if (error) {
#line 206
    return (error);
  }
#line 208
  error = vn_make_ops("zfs", zfs_fvnodeops_template, & zfs_fvnodeops);
#line 210
  if (error) {
#line 211
    return (error);
  }
#line 213
  error = vn_make_ops("zfs", zfs_symvnodeops_template, & zfs_symvnodeops);
#line 215
  if (error) {
#line 216
    return (error);
  }
#line 218
  error = vn_make_ops("zfs", zfs_xdvnodeops_template, & zfs_xdvnodeops);
#line 220
  if (error) {
#line 221
    return (error);
  }
#line 223
  error = vn_make_ops("zfs", zfs_evnodeops_template, & zfs_evnodeops);
#line 226
  return (error);
}
}
#line 233 "zfs-fuse/zfs_znode.c"
int zfs_init_fs(zfsvfs_t *zfsvfs , znode_t **zpp , cred_t *cr ) 
{ objset_t *os ;
  uint64_t zoid ;
  uint64_t version ;
  int i ;
  int error ;
  dmu_object_info_t doi ;
  dmu_tx_t *tx ;
  dmu_tx_t *tmp ;
  uint64_t __left ;
  uint64_t __right ;
  char *__buf ;
  void *tmp___0 ;
  int tmp___1 ;
  uint64_t __left___0 ;
  uint64_t __right___0 ;
  char *__buf___0 ;
  void *tmp___2 ;

  {
#line 236
  os = zfsvfs->z_os;
#line 238
  version = 1ULL;
#line 242
  *zpp = (znode_t *)((void *)0);
#line 248
  tmp___1 = dmu_object_info(os, 1ULL, & doi);
#line 248
  if (tmp___1 == 2) {
#line 249
    tmp = dmu_tx_create(os);
#line 249
    tx = tmp;
#line 251
    dmu_tx_hold_zap(tx, 0xffffffffffffffffULL, 1, (char *)((void *)0));
#line 252
    dmu_tx_hold_zap(tx, 0xffffffffffffffffULL, 1, (char *)((void *)0));
#line 253
    dmu_tx_hold_bonus(tx, 0xffffffffffffffffULL);
#line 254
    error = dmu_tx_assign(tx, 1ULL);
#line 255
    while (1) {
#line 255
      __left = (unsigned long long )error;
#line 255
      __right = 0ULL;
#line 255
      if (! (__left == __right)) {
#line 255
        tmp___0 = __builtin_alloca(256U);
#line 255
        __buf = (char *)tmp___0;
#line 255
        snprintf((char * __restrict  )__buf, 256U, (char const   * __restrict  )"%s %s %s (0x%llx %s 0x%llx)",
                 "error", "==", "0", __left, "==", __right);
#line 255
        while (1) {
#line 255
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                  "zfs-fuse/zfs_znode.c", 255, "zfs_init_fs", __buf);
#line 255
          abort();
#line 255
          break;
        }
      }
#line 255
      break;
    }
#line 256
    zfs_create_fs(os, cr, tx);
#line 257
    dmu_tx_commit(tx);
  }
#line 260
  error = zap_lookup(os, 1ULL, "VERSION", 8ULL, 1ULL, (void *)(& version));
#line 262
  if (error) {
#line 263
    return (error);
  } else {
#line 264
    if (version != 1ULL) {
#line 265
      printf((char const   * __restrict  )"Mismatched versions:  File system is version %lld on-disk format, which is incompatible with this software version %lld!",
             version, 1ULL);
#line 269
      return (95);
    }
  }
#line 289
  error = zap_lookup(os, 1ULL, "ROOT", 8ULL, 1ULL, (void *)(& zoid));
#line 290
  if (error) {
#line 291
    return (error);
  }
#line 292
  if (! (zoid != 0ULL)) {
#line 292
    __assert_fail("zoid != 0", "zfs-fuse/zfs_znode.c", 292U, "zfs_init_fs");
  }
#line 293
  zfsvfs->z_root = zoid;
#line 302
  i = 0;
#line 302
  while (i != 64) {
#line 303
    zmutex_init(& zfsvfs->z_hold_mtx[i]);
#line 302
    i ++;
  }
#line 305
  error = zfs_zget(zfsvfs, zoid, zpp);
#line 306
  if (error) {
#line 307
    return (error);
  }
#line 308
  while (1) {
#line 308
    __left___0 = (*zpp)->z_id;
#line 308
    __right___0 = zoid;
#line 308
    if (! (__left___0 == __right___0)) {
#line 308
      tmp___2 = __builtin_alloca(256U);
#line 308
      __buf___0 = (char *)tmp___2;
#line 308
      snprintf((char * __restrict  )__buf___0, 256U, (char const   * __restrict  )"%s %s %s (0x%llx %s 0x%llx)",
               "(*zpp)->z_id", "==", "zoid", __left___0, "==", __right___0);
#line 308
      while (1) {
#line 308
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                "zfs-fuse/zfs_znode.c", 308, "zfs_init_fs", __buf___0);
#line 308
        abort();
#line 308
        break;
      }
    }
#line 308
    break;
  }
#line 310
  error = zap_lookup(os, 1ULL, "DELETE_QUEUE", 8ULL, 1ULL, (void *)(& zoid));
#line 311
  if (error) {
#line 312
    return (error);
  }
#line 314
  zfsvfs->z_dqueue = zoid;
#line 322
  list_create(& zfsvfs->z_delete_head.z_znodes, sizeof(znode_t ), (unsigned int )(& ((znode_t *)0)->z_list_node));
#line 325
  zmutex_init(& zfsvfs->z_delete_head.z_mutex);
#line 327
  return (0);
}
}
#line 352 "zfs-fuse/zfs_znode.c"
static uint64_t zfs_expldev(dev_t dev ) 
{ 

  {
#line 361
  return (dev);
}
}
#line 372 "zfs-fuse/zfs_znode.c"
dev_t zfs_cmpldev(uint64_t dev ) 
{ 

  {
#line 385
  return (dev);
}
}
#line 396 "zfs-fuse/zfs_znode.c"
static znode_t *zfs_znode_alloc(zfsvfs_t *zfsvfs , dmu_buf_t *db , uint64_t obj_num ,
                                int blksz ) 
{ znode_t *zp ;
  vnode_t *vp ;
  void *tmp ;

  {
#line 402
  tmp = umem_cache_alloc(znode_cache, 256);
#line 402
  zp = (znode_t *)tmp;
#line 404
  if (! ((unsigned int )zp->z_dirlocks == (unsigned int )((void *)0))) {
#line 404
    __assert_fail("zp->z_dirlocks == ((void *)0)", "zfs-fuse/zfs_znode.c", 404U, "zfs_znode_alloc");
  }
#line 406
  zp->z_phys = (znode_phys_t *)db->db_data;
#line 407
  zp->z_zfsvfs = zfsvfs;
#line 408
  zp->z_reap = (unsigned char)0;
#line 409
  zp->z_atime_dirty = (unsigned char)0;
#line 410
  zp->z_dbuf_held = (unsigned char)0;
#line 411
  zp->z_mapcnt = 0ULL;
#line 412
  zp->z_last_itx = 0ULL;
#line 413
  zp->z_dbuf = db;
#line 414
  zp->z_id = obj_num;
#line 415
  zp->z_blksz = (unsigned int )blksz;
#line 416
  zp->z_seq = 8013395U;
#line 417
  zp->z_sync_cnt = 0U;
#line 419
  mutex_enter(& zfsvfs->z_znodes_lock);
#line 420
  list_insert_tail(& zfsvfs->z_all_znodes, (void *)zp);
#line 421
  mutex_exit(& zfsvfs->z_znodes_lock);
#line 423
  vp = zp->z_vnode;
#line 424
  vn_reinit(vp);
#line 426
  vp->v_vfsp = (zfsvfs->z_parent)->z_vfs;
#line 427
  vp->v_type = iftovt_tab[((unsigned int )(zp->z_phys)->zp_mode & 61440U) >> 12];
#line 429
  switch ((int )vp->v_type) {
  case 2: 
#line 431
  if ((zp->z_phys)->zp_flags & 1ULL) {
#line 432
    vn_setops(vp, zfs_xdvnodeops);
#line 433
    vp->v_flag |= 16384U;
  } else {
#line 435
    vn_setops(vp, zfs_dvnodeops);
  }
#line 436
  zp->z_zn_prefetch = (unsigned char)1;
#line 437
  break;
  case 3: 
  case 4: 
#line 440
  vp->v_rdev = zfs_cmpldev((zp->z_phys)->zp_rdev);
  case 6: 
  case 9: 
  case 7: 
#line 445
  vn_setops(vp, zfs_fvnodeops);
#line 446
  break;
  case 1: 
#line 448
  vp->v_flag |= 65536U;
#line 449
  vn_setops(vp, zfs_fvnodeops);
#line 450
  break;
  case 5: 
#line 452
  vn_setops(vp, zfs_symvnodeops);
#line 453
  break;
  default: 
#line 455
  vn_setops(vp, zfs_evnodeops);
#line 456
  break;
  }
#line 459
  return (zp);
}
}
#line 462 "zfs-fuse/zfs_znode.c"
static void zfs_znode_dmu_init(znode_t *zp ) 
{ znode_t *nzp ;
  zfsvfs_t *zfsvfs ;
  dmu_buf_t *db ;
  void *tmp ;
  uintptr_t __left ;
  uintptr_t __right ;
  char *__buf ;
  void *tmp___0 ;

  {
#line 466
  zfsvfs = zp->z_zfsvfs;
#line 467
  db = zp->z_dbuf;
#line 469
  mutex_enter(& zp->z_lock);
#line 471
  tmp = dmu_buf_set_user(db, (void *)zp, (void *)(& zp->z_phys), & znode_pageout_func);
#line 471
  nzp = (znode_t *)tmp;
#line 477
  while (1) {
#line 477
    __left = (unsigned int )nzp;
#line 477
    __right = (unsigned int )((void *)0);
#line 477
    if (! (__left == __right)) {
#line 477
      tmp___0 = __builtin_alloca(256U);
#line 477
      __buf = (char *)tmp___0;
#line 477
      snprintf((char * __restrict  )__buf, 256U, (char const   * __restrict  )"%s %s %s (0x%llx %s 0x%llx)",
               "nzp", "==", "((void *)0)", (unsigned long long )__left, "==", (unsigned long long )__right);
#line 477
      while (1) {
#line 477
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                "zfs-fuse/zfs_znode.c", 477, "zfs_znode_dmu_init", __buf);
#line 477
        abort();
#line 477
        break;
      }
    }
#line 477
    break;
  }
#line 482
  if (zp->z_id == zfsvfs->z_root) {
#line 483
    (zp->z_vnode)->v_flag |= 1U;
  }
#line 486
  if (! ((int )zp->z_dbuf_held == 0)) {
#line 486
    __assert_fail("zp->z_dbuf_held == 0", "zfs-fuse/zfs_znode.c", 486U, "zfs_znode_dmu_init");
  }
#line 487
  zp->z_dbuf_held = (unsigned char)1;
#line 488
  vfs_hold(zfsvfs->z_vfs);
#line 489
  mutex_exit(& zp->z_lock);
#line 491
  return;
}
}
#line 508 "zfs-fuse/zfs_znode.c"
void zfs_mknode(znode_t *dzp , vattr_t *vap , uint64_t *oid , dmu_tx_t *tx , cred_t *cr ,
                uint_t flag , znode_t **zpp , int bonuslen ) 
{ dmu_buf_t *dbp ;
  znode_phys_t *pzp ;
  znode_t *zp ;
  zfsvfs_t *zfsvfs ;
  timestruc_t now ;
  uint64_t gen ;
  int err ;
  int tmp ;
  uint64_t __left ;
  uint64_t __right ;
  char *__buf ;
  void *tmp___0 ;
  uint64_t __left___0 ;
  uint64_t __right___0 ;
  char *__buf___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  kmutex_t *hash_mtx ;

  {
#line 515
  zfsvfs = dzp->z_zfsvfs;
#line 520
  if (vap) {
#line 520
    if (! ((vap->va_mask & 3U) == 3U)) {
#line 520
      __assert_fail("vap && (vap->va_mask & (0x0001|0x0002)) == (0x0001|0x0002)",
                    "zfs-fuse/zfs_znode.c", 520U, "zfs_mknode");
    }
  } else {
#line 520
    __assert_fail("vap && (vap->va_mask & (0x0001|0x0002)) == (0x0001|0x0002)", "zfs-fuse/zfs_znode.c",
                  520U, "zfs_mknode");
  }
#line 522
  if (zfsvfs->z_assign >= 4ULL) {
#line 523
    *oid = vap->va_nodeid;
#line 524
    flag |= 4U;
#line 525
    now = vap->va_ctime;
#line 526
    gen = vap->va_nblocks;
  } else {
#line 528
    *oid = 0ULL;
#line 529
    while (1) {
#line 529
      tmp = clock_gettime(0, & now);
#line 529
      if (! (tmp == 0)) {
#line 529
        while (1) {
#line 529
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                  "zfs-fuse/zfs_znode.c", 529, "zfs_mknode", "clock_gettime(CLOCK_REALTIME, &now) == 0");
#line 529
          abort();
#line 529
          break;
        }
      }
#line 529
      break;
    }
#line 530
    gen = dmu_tx_get_txg(tx);
  }
#line 542
  if ((int )vap->va_type == 2) {
#line 543
    if (flag & 4U) {
#line 544
      err = zap_create_claim(zfsvfs->z_os, *oid, 20, 17, (int )(sizeof(znode_phys_t ) + (unsigned int )bonuslen),
                             tx);
#line 547
      while (1) {
#line 547
        __left = (unsigned long long )err;
#line 547
        __right = 0ULL;
#line 547
        if (! (__left == __right)) {
#line 547
          tmp___0 = __builtin_alloca(256U);
#line 547
          __buf = (char *)tmp___0;
#line 547
          snprintf((char * __restrict  )__buf, 256U, (char const   * __restrict  )"%s %s %s (0x%llx %s 0x%llx)",
                   "err", "==", "0", __left, "==", __right);
#line 547
          while (1) {
#line 547
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                    "zfs-fuse/zfs_znode.c", 547, "zfs_mknode", __buf);
#line 547
            abort();
#line 547
            break;
          }
        }
#line 547
        break;
      }
    } else {
#line 549
      *oid = zap_create(zfsvfs->z_os, 20, 17, (int )(sizeof(znode_phys_t ) + (unsigned int )bonuslen),
                        tx);
    }
  } else {
#line 554
    if (flag & 4U) {
#line 555
      err = dmu_object_claim(zfsvfs->z_os, *oid, 19, 0, 17, (int )(sizeof(znode_phys_t ) + (unsigned int )bonuslen),
                             tx);
#line 558
      while (1) {
#line 558
        __left___0 = (unsigned long long )err;
#line 558
        __right___0 = 0ULL;
#line 558
        if (! (__left___0 == __right___0)) {
#line 558
          tmp___1 = __builtin_alloca(256U);
#line 558
          __buf___0 = (char *)tmp___1;
#line 558
          snprintf((char * __restrict  )__buf___0, 256U, (char const   * __restrict  )"%s %s %s (0x%llx %s 0x%llx)",
                   "err", "==", "0", __left___0, "==", __right___0);
#line 558
          while (1) {
#line 558
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                    "zfs-fuse/zfs_znode.c", 558, "zfs_mknode", __buf___0);
#line 558
            abort();
#line 558
            break;
          }
        }
#line 558
        break;
      }
    } else {
#line 560
      *oid = dmu_object_alloc(zfsvfs->z_os, 19, 0, 17, (int )(sizeof(znode_phys_t ) + (unsigned int )bonuslen),
                              tx);
    }
  }
#line 565
  while (1) {
#line 565
    tmp___2 = dmu_bonus_hold(zfsvfs->z_os, *oid, (void *)0, & dbp);
#line 565
    if (! (0 == tmp___2)) {
#line 565
      while (1) {
#line 565
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                "zfs-fuse/zfs_znode.c", 565, "zfs_mknode", "0 == dmu_bonus_hold(zfsvfs->z_os, *oid, NULL, &dbp)");
#line 565
        abort();
#line 565
        break;
      }
    }
#line 565
    break;
  }
#line 566
  dmu_buf_will_dirty(dbp, tx);
#line 571
  if (! (dbp->db_size >= (uint64_t )sizeof(znode_phys_t ))) {
#line 571
    __assert_fail("dbp->db_size >= sizeof (znode_phys_t)", "zfs-fuse/zfs_znode.c",
                  571U, "zfs_mknode");
  }
#line 572
  bzero(dbp->db_data, (unsigned int )dbp->db_size);
#line 573
  pzp = (znode_phys_t *)dbp->db_data;
#line 579
  if (flag & 1U) {
#line 580
    dzp->z_phys = pzp;
#line 581
    dzp->z_id = *oid;
  }
#line 587
  if ((dzp->z_phys)->zp_flags & 1ULL) {
#line 588
    flag |= 2U;
  }
#line 590
  if ((int )vap->va_type == 3) {
#line 591
    pzp->zp_rdev = zfs_expldev(vap->va_rdev);
  } else {
#line 590
    if ((int )vap->va_type == 4) {
#line 591
      pzp->zp_rdev = zfs_expldev(vap->va_rdev);
    }
  }
#line 594
  if ((int )vap->va_type == 2) {
#line 595
    pzp->zp_size = 2ULL;
#line 596
    if (flag & 3U) {
#line 596
      pzp->zp_links = 2ULL;
    } else {
#line 596
      pzp->zp_links = 1ULL;
    }
  }
#line 599
  pzp->zp_parent = dzp->z_id;
#line 600
  if (flag & 2U) {
#line 601
    pzp->zp_flags |= 1ULL;
  }
#line 603
  pzp->zp_gen = gen;
#line 605
  pzp->zp_crtime[0] = (unsigned long long )now.tv_sec;
#line 605
  pzp->zp_crtime[1] = (unsigned long long )now.tv_nsec;
#line 606
  pzp->zp_ctime[0] = (unsigned long long )now.tv_sec;
#line 606
  pzp->zp_ctime[1] = (unsigned long long )now.tv_nsec;
#line 608
  if (vap->va_mask & 256U) {
#line 609
    pzp->zp_atime[0] = (unsigned long long )vap->va_atime.tv_sec;
#line 609
    pzp->zp_atime[1] = (unsigned long long )vap->va_atime.tv_nsec;
  } else {
#line 611
    pzp->zp_atime[0] = (unsigned long long )now.tv_sec;
#line 611
    pzp->zp_atime[1] = (unsigned long long )now.tv_nsec;
  }
#line 614
  if (vap->va_mask & 512U) {
#line 615
    pzp->zp_mtime[0] = (unsigned long long )vap->va_mtime.tv_sec;
#line 615
    pzp->zp_mtime[1] = (unsigned long long )vap->va_mtime.tv_nsec;
  } else {
#line 617
    pzp->zp_mtime[0] = (unsigned long long )now.tv_sec;
#line 617
    pzp->zp_mtime[1] = (unsigned long long )now.tv_nsec;
  }
#line 620
  pzp->zp_mode = (unsigned long long )((unsigned int )vttoif_tab[(int )vap->va_type] | (vap->va_mode & 4294905855U));
#line 621
  zp = zfs_znode_alloc(zfsvfs, dbp, *oid, 0);
#line 623
  zfs_perm_init(zp, dzp, (int )flag, vap, tx, cr);
#line 625
  if (zpp) {
#line 626
    hash_mtx = & (zp->z_zfsvfs)->z_hold_mtx[zp->z_id & 63ULL];
#line 628
    mutex_enter(hash_mtx);
#line 629
    zfs_znode_dmu_init(zp);
#line 630
    mutex_exit(hash_mtx);
#line 632
    *zpp = zp;
  } else {
#line 634
    (zp->z_vnode)->v_count = 0U;
#line 635
    dmu_buf_rele(dbp, (void *)0);
#line 636
    zfs_znode_free(zp);
  }
#line 638
  return;
}
}
#line 640 "zfs-fuse/zfs_znode.c"
int zfs_zget(zfsvfs_t *zfsvfs , uint64_t obj_num , znode_t **zpp ) 
{ dmu_object_info_t doi ;
  dmu_buf_t *db ;
  znode_t *zp ;
  int err ;
  void *tmp ;
  uint64_t __left ;
  uint64_t __right ;
  char *__buf ;
  void *tmp___0 ;
  uint64_t __left___0 ;
  uint64_t __right___0 ;
  char *__buf___0 ;
  void *tmp___1 ;

  {
#line 648
  *zpp = (znode_t *)((void *)0);
#line 650
  mutex_enter(& zfsvfs->z_hold_mtx[obj_num & 63ULL]);
#line 652
  err = dmu_bonus_hold(zfsvfs->z_os, obj_num, (void *)0, & db);
#line 653
  if (err) {
#line 654
    mutex_exit(& zfsvfs->z_hold_mtx[obj_num & 63ULL]);
#line 655
    return (err);
  }
#line 658
  dmu_object_info_from_db(db, & doi);
#line 659
  if ((int )doi.doi_bonus_type != 17) {
#line 661
    dmu_buf_rele(db, (void *)0);
#line 662
    mutex_exit(& zfsvfs->z_hold_mtx[obj_num & 63ULL]);
#line 663
    return (22);
  } else {
#line 659
    if (doi.doi_bonus_size < (uint64_t )sizeof(znode_phys_t )) {
#line 661
      dmu_buf_rele(db, (void *)0);
#line 662
      mutex_exit(& zfsvfs->z_hold_mtx[obj_num & 63ULL]);
#line 663
      return (22);
    }
  }
#line 666
  if (! (db->db_object == obj_num)) {
#line 666
    __assert_fail("db->db_object == obj_num", "zfs-fuse/zfs_znode.c", 666U, "zfs_zget");
  }
#line 667
  if (! (db->db_offset == 0xffffffffffffffffULL)) {
#line 667
    __assert_fail("db->db_offset == -1", "zfs-fuse/zfs_znode.c", 667U, "zfs_zget");
  }
#line 668
  if (! ((unsigned int )db->db_data != (unsigned int )((void *)0))) {
#line 668
    __assert_fail("db->db_data != ((void *)0)", "zfs-fuse/zfs_znode.c", 668U, "zfs_zget");
  }
#line 670
  tmp = dmu_buf_get_user(db);
#line 670
  zp = (znode_t *)tmp;
#line 672
  if ((unsigned int )zp != (unsigned int )((void *)0)) {
#line 673
    mutex_enter(& zp->z_lock);
#line 675
    while (1) {
#line 675
      __left = zp->z_id;
#line 675
      __right = obj_num;
#line 675
      if (! (__left == __right)) {
#line 675
        tmp___0 = __builtin_alloca(256U);
#line 675
        __buf = (char *)tmp___0;
#line 675
        snprintf((char * __restrict  )__buf, 256U, (char const   * __restrict  )"%s %s %s (0x%llx %s 0x%llx)",
                 "zp->z_id", "==", "obj_num", __left, "==", __right);
#line 675
        while (1) {
#line 675
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                  "zfs-fuse/zfs_znode.c", 675, "zfs_zget", __buf);
#line 675
          abort();
#line 675
          break;
        }
      }
#line 675
      break;
    }
#line 676
    if (zp->z_reap) {
#line 677
      dmu_buf_rele(db, (void *)0);
#line 678
      mutex_exit(& zp->z_lock);
#line 679
      mutex_exit(& zfsvfs->z_hold_mtx[obj_num & 63ULL]);
#line 680
      return (2);
    } else {
#line 681
      if (zp->z_dbuf_held) {
#line 682
        dmu_buf_rele(db, (void *)0);
      } else {
#line 684
        zp->z_dbuf_held = (unsigned char)1;
#line 685
        vfs_hold(zfsvfs->z_vfs);
      }
    }
#line 689
    mutex_enter(& (zp->z_vnode)->v_lock);
#line 689
    ((zp->z_vnode)->v_count) ++;
#line 689
    mutex_exit(& (zp->z_vnode)->v_lock);
#line 690
    mutex_exit(& zp->z_lock);
#line 691
    mutex_exit(& zfsvfs->z_hold_mtx[obj_num & 63ULL]);
#line 692
    *zpp = zp;
#line 693
    return (0);
  }
#line 699
  zp = zfs_znode_alloc(zfsvfs, db, obj_num, (int )doi.doi_data_block_size);
#line 700
  while (1) {
#line 700
    __left___0 = zp->z_id;
#line 700
    __right___0 = obj_num;
#line 700
    if (! (__left___0 == __right___0)) {
#line 700
      tmp___1 = __builtin_alloca(256U);
#line 700
      __buf___0 = (char *)tmp___1;
#line 700
      snprintf((char * __restrict  )__buf___0, 256U, (char const   * __restrict  )"%s %s %s (0x%llx %s 0x%llx)",
               "zp->z_id", "==", "obj_num", __left___0, "==", __right___0);
#line 700
      while (1) {
#line 700
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                "zfs-fuse/zfs_znode.c", 700, "zfs_zget", __buf___0);
#line 700
        abort();
#line 700
        break;
      }
    }
#line 700
    break;
  }
#line 701
  zfs_znode_dmu_init(zp);
#line 702
  mutex_exit(& zfsvfs->z_hold_mtx[obj_num & 63ULL]);
#line 703
  *zpp = zp;
#line 704
  return (0);
}
}
#line 707 "zfs-fuse/zfs_znode.c"
void zfs_znode_delete(znode_t *zp , dmu_tx_t *tx ) 
{ zfsvfs_t *zfsvfs ;
  int error ;
  uint64_t __left ;
  uint64_t __right ;
  char *__buf ;
  void *tmp ;
  uint64_t __left___0 ;
  uint64_t __right___0 ;
  char *__buf___0 ;
  void *tmp___0 ;

  {
#line 710
  zfsvfs = zp->z_zfsvfs;
#line 713
  mutex_enter(& zfsvfs->z_hold_mtx[zp->z_id & 63ULL]);
#line 714
  if ((zp->z_phys)->zp_acl.z_acl_extern_obj) {
#line 715
    error = dmu_object_free(zfsvfs->z_os, (zp->z_phys)->zp_acl.z_acl_extern_obj, tx);
#line 717
    while (1) {
#line 717
      __left = (unsigned long long )error;
#line 717
      __right = 0ULL;
#line 717
      if (! (__left == __right)) {
#line 717
        tmp = __builtin_alloca(256U);
#line 717
        __buf = (char *)tmp;
#line 717
        snprintf((char * __restrict  )__buf, 256U, (char const   * __restrict  )"%s %s %s (0x%llx %s 0x%llx)",
                 "error", "==", "0", __left, "==", __right);
#line 717
        while (1) {
#line 717
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                  "zfs-fuse/zfs_znode.c", 717, "zfs_znode_delete", __buf);
#line 717
          abort();
#line 717
          break;
        }
      }
#line 717
      break;
    }
  }
#line 719
  error = dmu_object_free(zfsvfs->z_os, zp->z_id, tx);
#line 720
  while (1) {
#line 720
    __left___0 = (unsigned long long )error;
#line 720
    __right___0 = 0ULL;
#line 720
    if (! (__left___0 == __right___0)) {
#line 720
      tmp___0 = __builtin_alloca(256U);
#line 720
      __buf___0 = (char *)tmp___0;
#line 720
      snprintf((char * __restrict  )__buf___0, 256U, (char const   * __restrict  )"%s %s %s (0x%llx %s 0x%llx)",
               "error", "==", "0", __left___0, "==", __right___0);
#line 720
      while (1) {
#line 720
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                "zfs-fuse/zfs_znode.c", 720, "zfs_znode_delete", __buf___0);
#line 720
        abort();
#line 720
        break;
      }
    }
#line 720
    break;
  }
#line 721
  zp->z_dbuf_held = (unsigned char)0;
#line 722
  mutex_exit(& zfsvfs->z_hold_mtx[zp->z_id & 63ULL]);
#line 723
  dmu_buf_rele(zp->z_dbuf, (void *)0);
#line 724
  return;
}
}
#line 726 "zfs-fuse/zfs_znode.c"
void zfs_zinactive(znode_t *zp ) 
{ vnode_t *vp ;
  zfsvfs_t *zfsvfs ;
  uint64_t z_id ;

  {
#line 729
  vp = zp->z_vnode;
#line 730
  zfsvfs = zp->z_zfsvfs;
#line 731
  z_id = zp->z_id;
#line 733
  if (zp->z_dbuf_held) {
#line 733
    if (! zp->z_phys) {
#line 733
      __assert_fail("zp->z_dbuf_held && zp->z_phys", "zfs-fuse/zfs_znode.c", 733U,
                    "zfs_zinactive");
    }
  } else {
#line 733
    __assert_fail("zp->z_dbuf_held && zp->z_phys", "zfs-fuse/zfs_znode.c", 733U, "zfs_zinactive");
  }
#line 738
  mutex_enter(& zfsvfs->z_hold_mtx[z_id & 63ULL]);
#line 740
  mutex_enter(& zp->z_lock);
#line 741
  mutex_enter(& vp->v_lock);
#line 742
  (vp->v_count) --;
#line 743
  if (vp->v_count > 0U) {
#line 755
    mutex_exit(& vp->v_lock);
#line 756
    mutex_exit(& zp->z_lock);
#line 757
    mutex_exit(& zfsvfs->z_hold_mtx[z_id & 63ULL]);
#line 758
    return;
  }
#line 760
  mutex_exit(& vp->v_lock);
#line 766
  if (zp->z_reap) {
#line 767
    mutex_exit(& zp->z_lock);
#line 768
    mutex_exit(& zfsvfs->z_hold_mtx[z_id & 63ULL]);
#line 770
    if ((zp->z_phys)->zp_flags & 1ULL) {
#line 771
      zfs_rmnode(zp);
    } else {
#line 773
      mutex_enter(& zfsvfs->z_delete_head.z_mutex);
#line 774
      list_insert_tail(& zfsvfs->z_delete_head.z_znodes, (void *)zp);
#line 775
      (zfsvfs->z_delete_head.z_znode_count) ++;
#line 776
      cv_broadcast(& zfsvfs->z_delete_head.z_cv);
#line 777
      mutex_exit(& zfsvfs->z_delete_head.z_mutex);
    }
#line 779
    vfs_rele(zfsvfs->z_vfs);
#line 780
    return;
  }
#line 782
  if (! zp->z_phys) {
#line 782
    __assert_fail("zp->z_phys", "zfs-fuse/zfs_znode.c", 782U, "zfs_zinactive");
  }
#line 783
  if (! zp->z_dbuf_held) {
#line 783
    __assert_fail("zp->z_dbuf_held", "zfs-fuse/zfs_znode.c", 783U, "zfs_zinactive");
  }
#line 785
  zp->z_dbuf_held = (unsigned char)0;
#line 786
  mutex_exit(& zp->z_lock);
#line 787
  dmu_buf_rele(zp->z_dbuf, (void *)0);
#line 788
  mutex_exit(& zfsvfs->z_hold_mtx[z_id & 63ULL]);
#line 789
  vfs_rele(zfsvfs->z_vfs);
#line 790
  return;
}
}
#line 792 "zfs-fuse/zfs_znode.c"
void zfs_znode_free(znode_t *zp ) 
{ zfsvfs_t *zfsvfs ;

  {
#line 795
  zfsvfs = zp->z_zfsvfs;
#line 797
  mutex_enter(& zfsvfs->z_znodes_lock);
#line 798
  list_remove(& zfsvfs->z_all_znodes, (void *)zp);
#line 799
  mutex_exit(& zfsvfs->z_znodes_lock);
#line 801
  umem_cache_free(znode_cache, (void *)zp);
#line 802
  return;
}
}
#line 804 "zfs-fuse/zfs_znode.c"
void zfs_time_stamper_locked(znode_t *zp , uint_t flag , dmu_tx_t *tx ) 
{ timestruc_t now ;
  pthread_t tmp ;
  int tmp___0 ;

  {
#line 809
  tmp = pthread_self();
#line 809
  if (! ((unsigned int )zp->z_lock.m_owner == (unsigned int )((void *)((unsigned int )tmp)))) {
#line 809
    __assert_fail("((&zp->z_lock)->m_owner == ((void *)(uintptr_t)pthread_self()))",
                  "zfs-fuse/zfs_znode.c", 809U, "zfs_time_stamper_locked");
  }
#line 811
  while (1) {
#line 811
    tmp___0 = clock_gettime(0, & now);
#line 811
    if (! (tmp___0 == 0)) {
#line 811
      while (1) {
#line 811
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                "zfs-fuse/zfs_znode.c", 811, "zfs_time_stamper_locked", "clock_gettime(CLOCK_REALTIME, &now) == 0");
#line 811
        abort();
#line 811
        break;
      }
    }
#line 811
    break;
  }
#line 813
  if (tx) {
#line 814
    dmu_buf_will_dirty(zp->z_dbuf, tx);
#line 815
    zp->z_atime_dirty = (unsigned char)0;
#line 816
    (zp->z_seq) ++;
  } else {
#line 818
    zp->z_atime_dirty = (unsigned char)1;
  }
#line 821
  if (flag & 256U) {
#line 822
    (zp->z_phys)->zp_atime[0] = (unsigned long long )now.tv_sec;
#line 822
    (zp->z_phys)->zp_atime[1] = (unsigned long long )now.tv_nsec;
  }
#line 824
  if (flag & 512U) {
#line 825
    (zp->z_phys)->zp_mtime[0] = (unsigned long long )now.tv_sec;
#line 825
    (zp->z_phys)->zp_mtime[1] = (unsigned long long )now.tv_nsec;
  }
#line 827
  if (flag & 1024U) {
#line 828
    (zp->z_phys)->zp_ctime[0] = (unsigned long long )now.tv_sec;
#line 828
    (zp->z_phys)->zp_ctime[1] = (unsigned long long )now.tv_nsec;
  }
#line 829
  return;
}
}
#line 843 "zfs-fuse/zfs_znode.c"
void zfs_time_stamper(znode_t *zp , uint_t flag , dmu_tx_t *tx ) 
{ 

  {
#line 846
  mutex_enter(& zp->z_lock);
#line 847
  zfs_time_stamper_locked(zp, flag, tx);
#line 848
  mutex_exit(& zp->z_lock);
#line 849
  return;
}
}
#line 860 "zfs-fuse/zfs_znode.c"
void zfs_grow_blocksize(znode_t *zp , uint64_t size , dmu_tx_t *tx ) 
{ int error ;
  u_longlong_t dummy ;
  uint64_t __left ;
  uint64_t __right ;
  char *__buf ;
  void *tmp ;

  {
#line 866
  if (size <= (uint64_t )zp->z_blksz) {
#line 867
    return;
  }
#line 873
  if (zp->z_blksz) {
#line 873
    if ((zp->z_phys)->zp_size > (uint64_t )zp->z_blksz) {
#line 874
      return;
    }
  }
#line 876
  error = dmu_object_set_blocksize((zp->z_zfsvfs)->z_os, zp->z_id, size, 0, tx);
#line 878
  if (error == 95) {
#line 879
    return;
  }
#line 880
  while (1) {
#line 880
    __left = (unsigned long long )error;
#line 880
    __right = 0ULL;
#line 880
    if (! (__left == __right)) {
#line 880
      tmp = __builtin_alloca(256U);
#line 880
      __buf = (char *)tmp;
#line 880
      snprintf((char * __restrict  )__buf, 256U, (char const   * __restrict  )"%s %s %s (0x%llx %s 0x%llx)",
               "error", "==", "0", __left, "==", __right);
#line 880
      while (1) {
#line 880
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                "zfs-fuse/zfs_znode.c", 880, "zfs_grow_blocksize", __buf);
#line 880
        abort();
#line 880
        break;
      }
    }
#line 880
    break;
  }
#line 883
  dmu_object_size_from_db(zp->z_dbuf, & zp->z_blksz, & dummy);
#line 884
  return;
}
}
#line 913 "zfs-fuse/zfs_znode.c"
int zfs_freesp(znode_t *zp , uint64_t off , uint64_t len , int flag , boolean_t log ) 
{ vnode_t *vp ;
  dmu_tx_t *tx ;
  zfsvfs_t *zfsvfs ;
  zilog_t *zilog ;
  rl_t *rl ;
  uint64_t end ;
  uint64_t size ;
  uint64_t new_blksz ;
  int error ;
  uint64_t start ;
  uint64_t extent ;
  uint64_t tmp ;
  uint64_t tmp___0 ;
  objset_t *os ;
  uint64_t rlen ;
  int tmp___1 ;

  {
#line 916
  vp = zp->z_vnode;
#line 918
  zfsvfs = zp->z_zfsvfs;
#line 919
  zilog = zfsvfs->z_log;
#line 921
  end = off + len;
#line 925
  if ((int )(zp->z_vnode)->v_type == 6) {
#line 926
    return (0);
  }
#line 932
  if (len == 0ULL) {
#line 933
    rl = zfs_range_lock(zp, 0ULL, 0xffffffffffffffffULL, 1);
  } else {
#line 932
    if (off + len > (zp->z_phys)->zp_size) {
#line 933
      rl = zfs_range_lock(zp, 0ULL, 0xffffffffffffffffULL, 1);
    } else {
#line 935
      rl = zfs_range_lock(zp, off, len, 1);
#line 937
      if (off + len > (zp->z_phys)->zp_size) {
#line 939
        zfs_range_unlock(rl);
#line 940
        rl = zfs_range_lock(zp, 0ULL, 0xffffffffffffffffULL, 1);
      }
    }
  }
#line 947
  size = (zp->z_phys)->zp_size;
#line 948
  if (len == 0ULL) {
#line 948
    if (size == off) {
#line 949
      zfs_range_unlock(rl);
#line 950
      return (0);
    }
  }
#line 956
  if ((int )vp->v_type == 1) {
#line 956
    if (((unsigned int )(zp->z_phys)->zp_mode & (unsigned int )(1024 | (64 >> 3))) == 1024U) {
#line 957
      start = off;
#line 958
      extent = len;
#line 960
      if (off > size) {
#line 961
        start = size;
#line 962
        extent += off - size;
      } else {
#line 963
        if (len == 0ULL) {
#line 964
          extent = size - off;
        }
      }
#line 966
      error = 0;
#line 966
      if (error) {
#line 967
        zfs_range_unlock(rl);
#line 968
        return (error);
      }
    }
  }
#line 972
  tx = dmu_tx_create(zfsvfs->z_os);
#line 973
  dmu_tx_hold_bonus(tx, zp->z_id);
#line 974
  new_blksz = 0ULL;
#line 975
  if (end > size) {
#line 975
    if (! ((zp->z_blksz & (zp->z_blksz - 1U)) == 0U)) {
      goto _L___0;
    } else {
#line 975
      if ((uint64_t )zp->z_blksz < zfsvfs->z_max_blksz) {
        _L___0: /* CIL Label */ 
#line 980
        if ((uint64_t )zp->z_blksz > (zp->z_zfsvfs)->z_max_blksz) {
#line 981
          if (! (! ((zp->z_blksz & (zp->z_blksz - 1U)) == 0U))) {
#line 981
            __assert_fail("!(((zp->z_blksz) & ((zp->z_blksz) - 1)) == 0)", "zfs-fuse/zfs_znode.c",
                          981U, "zfs_freesp");
          }
#line 982
          if (end < 1ULL << 17) {
#line 982
            new_blksz = end;
          } else {
#line 982
            new_blksz = 1ULL << 17;
          }
        } else {
#line 984
          if (end < (zp->z_zfsvfs)->z_max_blksz) {
#line 984
            new_blksz = end;
          } else {
#line 984
            new_blksz = (zp->z_zfsvfs)->z_max_blksz;
          }
        }
#line 986
        if (end < new_blksz) {
#line 986
          tmp = end;
        } else {
#line 986
          tmp = new_blksz;
        }
#line 986
        dmu_tx_hold_write(tx, zp->z_id, 0ULL, (int )tmp);
      } else {
        goto _L;
      }
    }
  } else {
    _L: /* CIL Label */ 
#line 987
    if (off < size) {
#line 991
      if (len) {
#line 991
        tmp___0 = len;
      } else {
#line 991
        tmp___0 = 0xffffffffffffffffULL;
      }
#line 991
      dmu_tx_hold_free(tx, zp->z_id, off, tmp___0);
    }
  }
#line 994
  error = dmu_tx_assign(tx, zfsvfs->z_assign);
#line 995
  if (error) {
#line 996
    if (error == 85) {
#line 996
      if (zfsvfs->z_assign == 2ULL) {
#line 997
        dmu_tx_wait(tx);
      }
    }
#line 998
    dmu_tx_abort(tx);
#line 999
    zfs_range_unlock(rl);
#line 1000
    return (error);
  }
#line 1003
  if (new_blksz) {
#line 1004
    zfs_grow_blocksize(zp, new_blksz, tx);
  }
#line 1006
  if (end > size) {
#line 1007
    (zp->z_phys)->zp_size = end;
  } else {
#line 1006
    if (len == 0ULL) {
#line 1007
      (zp->z_phys)->zp_size = end;
    }
  }
#line 1009
  if (off < size) {
#line 1010
    os = zfsvfs->z_os;
#line 1011
    rlen = len;
#line 1013
    if (len == 0ULL) {
#line 1014
      rlen = 0xffffffffffffffffULL;
    } else {
#line 1015
      if (end > size) {
#line 1016
        rlen = size - off;
      }
    }
#line 1017
    while (1) {
#line 1017
      tmp___1 = dmu_free_range(os, zp->z_id, off, rlen, tx);
#line 1017
      if (! (0 == tmp___1)) {
#line 1017
        while (1) {
#line 1017
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                  "zfs-fuse/zfs_znode.c", 1017, "zfs_freesp", "0 == dmu_free_range(os, zp->z_id, off, rlen, tx)");
#line 1017
          abort();
#line 1017
          break;
        }
      }
#line 1017
      break;
    }
  }
#line 1020
  if (log) {
#line 1021
    zfs_time_stamper(zp, 1536U, tx);
#line 1022
    zfs_log_truncate(zilog, tx, 10, zp, off, len);
  }
#line 1025
  zfs_range_unlock(rl);
#line 1027
  dmu_tx_commit(tx);
#line 1035
  rw_enter(& zp->z_map_lock, 1);
#line 1036
  if (off < size) {

  }
#line 1057
  rw_exit(& zp->z_map_lock);
#line 1059
  return (0);
}
}
#line 1062 "zfs-fuse/zfs_znode.c"
void zfs_create_fs(objset_t *os , cred_t *cr , dmu_tx_t *tx ) 
{ zfsvfs_t zfsvfs ;
  uint64_t moid ;
  uint64_t doid ;
  uint64_t roid ;
  uint64_t version ;
  int error ;
  znode_t *rootzp ;
  vnode_t *vp ;
  vattr_t vattr ;
  void *tmp ;
  uint64_t __left ;
  uint64_t __right ;
  char *__buf ;
  void *tmp___0 ;

  {
#line 1066
  roid = (uint64_t )0;
#line 1067
  version = 1ULL;
#line 1069
  rootzp = (znode_t *)((void *)0);
#line 1080
  moid = 1ULL;
#line 1081
  error = zap_create_claim(os, moid, 21, 0, 0, tx);
#line 1083
  if (! (error == 0)) {
#line 1083
    __assert_fail("error == 0", "zfs-fuse/zfs_znode.c", 1083U, "zfs_create_fs");
  }
#line 1089
  error = zap_update(os, moid, "VERSION", 8, 1ULL, (void const   *)(& version), tx);
#line 1090
  if (! (error == 0)) {
#line 1090
    __assert_fail("error == 0", "zfs-fuse/zfs_znode.c", 1090U, "zfs_create_fs");
  }
#line 1095
  doid = zap_create(os, 22, 0, 0, tx);
#line 1097
  error = zap_add(os, moid, "DELETE_QUEUE", 8, 1ULL, (void const   *)(& doid), tx);
#line 1098
  if (! (error == 0)) {
#line 1098
    __assert_fail("error == 0", "zfs-fuse/zfs_znode.c", 1098U, "zfs_create_fs");
  }
#line 1104
  vattr.va_mask = 15U;
#line 1105
  vattr.va_type = 2;
#line 1106
  vattr.va_mode = 16877U;
#line 1107
  vattr.va_uid = 0U;
#line 1108
  vattr.va_gid = 3U;
#line 1110
  tmp = umem_cache_alloc(znode_cache, 256);
#line 1110
  rootzp = (znode_t *)tmp;
#line 1111
  rootzp->z_zfsvfs = & zfsvfs;
#line 1112
  rootzp->z_reap = (unsigned char)0;
#line 1113
  rootzp->z_atime_dirty = (unsigned char)0;
#line 1114
  rootzp->z_dbuf_held = (unsigned char)0;
#line 1116
  vp = rootzp->z_vnode;
#line 1117
  vn_reinit(vp);
#line 1118
  vp->v_type = 2;
#line 1120
  bzero((void *)(& zfsvfs), sizeof(zfsvfs_t ));
#line 1122
  zfsvfs.z_os = os;
#line 1123
  zfsvfs.z_assign = 2ULL;
#line 1124
  zfsvfs.z_parent = & zfsvfs;
#line 1126
  zmutex_init(& zfsvfs.z_znodes_lock);
#line 1127
  list_create(& zfsvfs.z_all_znodes, sizeof(znode_t ), (unsigned int )(& ((znode_t *)0)->z_link_node));
#line 1130
  zfs_mknode(rootzp, & vattr, & roid, tx, cr, 1U, (znode_t **)((void *)0), 0);
#line 1131
  while (1) {
#line 1131
    __left = rootzp->z_id;
#line 1131
    __right = roid;
#line 1131
    if (! (__left == __right)) {
#line 1131
      tmp___0 = __builtin_alloca(256U);
#line 1131
      __buf = (char *)tmp___0;
#line 1131
      snprintf((char * __restrict  )__buf, 256U, (char const   * __restrict  )"%s %s %s (0x%llx %s 0x%llx)",
               "rootzp->z_id", "==", "roid", __left, "==", __right);
#line 1131
      while (1) {
#line 1131
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                "zfs-fuse/zfs_znode.c", 1131, "zfs_create_fs", __buf);
#line 1131
        abort();
#line 1131
        break;
      }
    }
#line 1131
    break;
  }
#line 1132
  error = zap_add(os, moid, "ROOT", 8, 1ULL, (void const   *)(& roid), tx);
#line 1133
  if (! (error == 0)) {
#line 1133
    __assert_fail("error == 0", "zfs-fuse/zfs_znode.c", 1133U, "zfs_create_fs");
  }
#line 1135
  (rootzp->z_vnode)->v_count = 0U;
#line 1136
  umem_cache_free(znode_cache, (void *)rootzp);
#line 1137
  return;
}
}
#line 1 "zvol.o"
#pragma merger(0,"/tmp/cil-zyAtV3Ev.i","-pipe,-Wall,-Werror,-std=c99,-Wno-unused,-Wno-missing-braces,-Wno-parentheses,-Wno-uninitialized,-fno-strict-aliasing,-ggdb,-O2")
#line 69 "lib/libzfscommon/include/sys/dsl_prop.h"
extern void dsl_prop_nvlist_add_uint64(nvlist_t *nv , zfs_prop_t prop , uint64_t value ) ;
#line 163 "zfs-fuse/zvol.c"
int zvol_get_stats(objset_t *os , nvlist_t *nv ) 
{ int error ;
  dmu_object_info_t doi ;
  uint64_t val ;

  {
#line 171
  error = zap_lookup(os, 2ULL, "size", 8ULL, 1ULL, (void *)(& val));
#line 172
  if (error) {
#line 173
    return (error);
  }
#line 175
  dsl_prop_nvlist_add_uint64(nv, 10, val);
#line 177
  error = dmu_object_info(os, 1ULL, & doi);
#line 179
  if (error == 0) {
#line 180
    dsl_prop_nvlist_add_uint64(nv, 11, (unsigned long long )doi.doi_data_block_size);
  }
#line 184
  return (error);
}
}
#line 1 "fuse_listener.o"
#pragma merger(0,"/tmp/cil-XpDC6zeu.i","-pipe,-Wall,-Werror,-std=c99,-Wno-unused,-Wno-missing-braces,-Wno-parentheses,-Wno-uninitialized,-fno-strict-aliasing,-ggdb,-O2")
#line 312 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 369
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 595 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size )  __attribute__((__malloc__)) ;
#line 343 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int pthread_mutex_lock(pthread_mutex_t *__mutex ) ;
#line 353
extern  __attribute__((__nothrow__)) int pthread_mutex_unlock(pthread_mutex_t *__mutex ) ;
#line 1168 "/usr/local/include/fuse/fuse_lowlevel.h"
extern void fuse_session_process(struct fuse_session *se , char const   *buf , size_t len ,
                                 struct fuse_chan *ch ) ;
#line 1183
extern void fuse_session_exit(struct fuse_session *se ) ;
#line 1190
extern void fuse_session_reset(struct fuse_session *se ) ;
#line 1198
extern int fuse_session_exited(struct fuse_session *se ) ;
#line 1275
extern int fuse_chan_fd(struct fuse_chan *ch ) ;
#line 1283
extern size_t fuse_chan_bufsize(struct fuse_chan *ch ) ;
#line 1299
extern struct fuse_session *fuse_chan_session(struct fuse_chan *ch ) ;
#line 143 "/usr/local/include/fuse/fuse_lowlevel_compat.h"
extern int fuse_chan_receive(struct fuse_chan *ch , char *buf , size_t size ) ;
#line 40 "zfs-fuse/fuse_listener.h"
kmem_cache_t *file_info_cache  ;
#line 52 "zfs-fuse/fuse_listener.c"
boolean_t exit_fuse_listener  =    0;
#line 54 "zfs-fuse/fuse_listener.c"
int newfs_fd[2]  ;
#line 58 "zfs-fuse/fuse_listener.c"
int nfds  ;
#line 59 "zfs-fuse/fuse_listener.c"
struct pollfd fds[1001]  ;
#line 60 "zfs-fuse/fuse_listener.c"
fuse_fs_info_t fsinfo[1001]  ;
#line 61 "zfs-fuse/fuse_listener.c"
char *mountpoints[1001]  ;
#line 63 "zfs-fuse/fuse_listener.c"
pthread_t fuse_threads[40]  ;
#line 64 "zfs-fuse/fuse_listener.c"
pthread_mutex_t mtx  =    {0, 0, (_pthread_descr )0, 0, {0L, 0}};
#line 68 "zfs-fuse/fuse_listener.c"
int zfsfuse_listener_init(void) 
{ int tmp ;

  {
#line 70
  tmp = pipe((int *)(newfs_fd));
#line 70
  if (tmp == -1) {
#line 71
    perror("pipe");
#line 72
    return (-1);
  }
#line 75
  fds[0].fd = newfs_fd[0];
#line 76
  fds[0].events = (short)1;
#line 77
  nfds = 1;
#line 79
  file_info_cache = umem_cache_create((char *)"file_info_t", sizeof(file_info_t ),
                                      0U, (umem_constructor_t *)((void *)0), (umem_destructor_t *)((void *)0),
                                      (umem_reclaim_t *)((void *)0), (void *)0, (vmem_t *)((void *)0),
                                      0);
#line 80
  while (1) {
#line 80
    if (! ((unsigned int )file_info_cache != (unsigned int )((void *)0))) {
#line 80
      while (1) {
#line 80
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                "zfs-fuse/fuse_listener.c", 80, "zfsfuse_listener_init", "file_info_cache != NULL");
#line 80
        abort();
#line 80
        break;
      }
    }
#line 80
    break;
  }
#line 82
  return (0);
}
}
#line 85 "zfs-fuse/fuse_listener.c"
void zfsfuse_listener_exit(void) 
{ 

  {
#line 87
  umem_cache_destroy(file_info_cache);
#line 89
  close(newfs_fd[0]);
#line 90
  close(newfs_fd[1]);
#line 91
  return;
}
}
#line 93 "zfs-fuse/fuse_listener.c"
int zfsfuse_newfs(char *mntpoint , struct fuse_chan *ch ) 
{ fuse_fs_info_t info ;
  size_t tmp ;
  ssize_t tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 95
  info.fd = 0;
#line 95
  info.bufsize = 0U;
#line 95
  info.ch = (struct fuse_chan *)0;
#line 95
  info.se = (struct fuse_session *)0;
#line 95
  info.mntlen = 0;
#line 97
  info.fd = fuse_chan_fd(ch);
#line 98
  info.bufsize = fuse_chan_bufsize(ch);
#line 99
  info.ch = ch;
#line 100
  info.se = fuse_chan_session(ch);
#line 101
  tmp = strlen((char const   *)mntpoint);
#line 101
  info.mntlen = (int )tmp;
#line 103
  tmp___0 = write(newfs_fd[1], (void const   *)(& info), sizeof(info));
#line 103
  if ((unsigned int )tmp___0 != sizeof(info)) {
#line 104
    perror("Warning (while writing fsinfo to newfs_fd)");
#line 105
    return (-1);
  }
#line 108
  tmp___1 = write(newfs_fd[1], (void const   *)mntpoint, (unsigned int )info.mntlen);
#line 108
  if (tmp___1 != info.mntlen) {
#line 109
    perror("Warning (while writing mntpoint to newfs_fd)");
#line 110
    return (-1);
  }
#line 112
  return (0);
}
}
#line 119 "zfs-fuse/fuse_listener.c"
static int fd_read_loop(int fd , void *buf , int bytes ) 
{ int read_bytes ;
  int left_bytes ;
  int ret ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
#line 121
  read_bytes = 0;
#line 122
  left_bytes = bytes;
#line 124
  while (left_bytes > 0) {
#line 125
    tmp = read(fd, (void *)((char *)buf + read_bytes), (unsigned int )left_bytes);
#line 125
    ret = tmp;
#line 126
    if (ret == 0) {
#line 127
      return (-1);
    }
#line 129
    if (ret == -1) {
#line 130
      tmp___0 = __errno_location();
#line 130
      if (*tmp___0 == 4) {
#line 131
        continue;
      }
#line 132
      perror("read");
#line 133
      return (-1);
    }
#line 135
    read_bytes += ret;
#line 136
    left_bytes -= ret;
  }
#line 138
  return (0);
}
}
#line 145 "zfs-fuse/fuse_listener.c"
static void new_fs(void) 
{ fuse_fs_info_t fs ;
  int tmp ;
  char *mntpoint ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 153
  while (1) {
#line 153
    tmp = fd_read_loop(fds[0].fd, (void *)(& fs), (int )sizeof(fuse_fs_info_t ));
#line 153
    if (! (tmp == 0)) {
#line 153
      while (1) {
#line 153
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                "zfs-fuse/fuse_listener.c", 153, "new_fs", "fd_read_loop(fds[0].fd, &fs, sizeof(fuse_fs_info_t)) == 0");
#line 153
        abort();
#line 153
        break;
      }
    }
#line 153
    break;
  }
#line 155
  tmp___0 = malloc((unsigned int )(fs.mntlen + 1));
#line 155
  mntpoint = (char *)tmp___0;
#line 156
  if ((unsigned int )mntpoint == (unsigned int )((void *)0)) {
#line 157
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Warning: out of memory!\n");
#line 158
    return;
  }
#line 161
  while (1) {
#line 161
    tmp___1 = fd_read_loop(fds[0].fd, (void *)mntpoint, fs.mntlen);
#line 161
    if (! (tmp___1 == 0)) {
#line 161
      while (1) {
#line 161
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                "zfs-fuse/fuse_listener.c", 161, "new_fs", "fd_read_loop(fds[0].fd, mntpoint, fs.mntlen) == 0");
#line 161
        abort();
#line 161
        break;
      }
    }
#line 161
    break;
  }
#line 163
  *(mntpoint + fs.mntlen) = (char )'\000';
#line 165
  if (nfds == 1001) {
#line 166
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Warning: filesystem limit (%i) reached, unmounting..\n",
            1000);
#line 167
    fuse_unmount_compat22((char const   *)mntpoint);
#line 168
    free((void *)mntpoint);
#line 169
    return;
  }
#line 176
  fsinfo[nfds] = fs;
#line 177
  mountpoints[nfds] = mntpoint;
#line 179
  fds[nfds].fd = fs.fd;
#line 180
  fds[nfds].events = (short)1;
#line 181
  fds[nfds].revents = (short)0;
#line 182
  nfds ++;
#line 183
  return;
}
}
#line 189 "zfs-fuse/fuse_listener.c"
static void destroy_fs(int i ) 
{ 

  {
#line 194
  fuse_session_reset(fsinfo[i].se);
#line 195
  fuse_session_destroy(fsinfo[i].se);
#line 196
  close(fds[i].fd);
#line 197
  fds[i].fd = -1;
#line 198
  free((void *)mountpoints[i]);
#line 199
  return;
}
}
#line 201 "zfs-fuse/fuse_listener.c"
static void *zfsfuse_listener_loop(void *arg ) 
{ size_t bufsize ;
  char *buf ;
  int tmp ;
  int ret ;
  int tmp___0 ;
  int *tmp___1 ;
  int oldfds ;
  int i ;
  short rev ;
  char *new_buf ;
  void *tmp___2 ;
  int res ;
  int tmp___3 ;
  int tmp___4 ;
  struct fuse_session *se ;
  struct fuse_chan *ch ;
  int tmp___5 ;
  int tmp___6 ;
  int write_ptr ;
  int read_ptr ;
  int tmp___7 ;

  {
#line 203
  bufsize = (size_t )0;
#line 204
  buf = (char *)((void *)0);
#line 206
  while (1) {
#line 206
    tmp = pthread_mutex_lock(& mtx);
#line 206
    if (! (tmp == 0)) {
#line 206
      while (1) {
#line 206
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                "zfs-fuse/fuse_listener.c", 206, "zfsfuse_listener_loop", "pthread_mutex_lock(&mtx) == 0");
#line 206
        abort();
#line 206
        break;
      }
    }
#line 206
    break;
  }
#line 208
  while (! exit_fuse_listener) {
#line 209
    tmp___0 = poll(fds, (unsigned long )nfds, 1000);
#line 209
    ret = tmp___0;
#line 210
    if (ret == 0) {
#line 211
      continue;
    } else {
#line 210
      if (ret == -1) {
#line 210
        tmp___1 = __errno_location();
#line 210
        if (*tmp___1 == 4) {
#line 211
          continue;
        }
      }
    }
#line 213
    if (ret == -1) {
#line 214
      perror("poll");
#line 215
      continue;
    }
#line 218
    oldfds = nfds;
#line 220
    i = 0;
#line 220
    while (i < oldfds) {
#line 221
      rev = fds[i].revents;
#line 223
      if ((int )rev == 0) {
        goto __Cont;
      }
#line 226
      fds[i].revents = (short)0;
#line 228
      if (! (((int )rev & 32) == 0)) {
#line 228
        __assert_fail("(rev & 0x020) == 0", "zfs-fuse/fuse_listener.c", 228U, "zfsfuse_listener_loop");
      }
#line 230
      if (! ((int )rev & 1)) {
#line 230
        if (! ((int )rev & 8)) {
#line 230
          if (! ((int )rev & 16)) {
            goto __Cont;
          }
        }
      }
#line 233
      if (i == 0) {
#line 234
        new_fs();
      } else {
#line 238
        if (fsinfo[i].bufsize > bufsize) {
#line 239
          tmp___2 = realloc((void *)buf, fsinfo[i].bufsize);
#line 239
          new_buf = (char *)tmp___2;
#line 240
          if ((unsigned int )new_buf == (unsigned int )((void *)0)) {
#line 241
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Warning: out of memory!\n");
            goto __Cont;
          }
#line 244
          buf = new_buf;
#line 245
          bufsize = fsinfo[i].bufsize;
        }
#line 248
        tmp___3 = fuse_chan_receive(fsinfo[i].ch, buf, fsinfo[i].bufsize);
#line 248
        res = tmp___3;
#line 249
        if (res == -1) {
#line 250
          destroy_fs(i);
          goto __Cont;
        } else {
#line 249
          tmp___4 = fuse_session_exited(fsinfo[i].se);
#line 249
          if (tmp___4) {
#line 250
            destroy_fs(i);
            goto __Cont;
          }
        }
#line 254
        if (res == 0) {
          goto __Cont;
        }
#line 257
        se = fsinfo[i].se;
#line 258
        ch = fsinfo[i].ch;
#line 264
        while (1) {
#line 264
          tmp___5 = pthread_mutex_unlock(& mtx);
#line 264
          if (! (tmp___5 == 0)) {
#line 264
            while (1) {
#line 264
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                      "zfs-fuse/fuse_listener.c", 264, "zfsfuse_listener_loop", "pthread_mutex_unlock(&mtx) == 0");
#line 264
              abort();
#line 264
              break;
            }
          }
#line 264
          break;
        }
#line 266
        fuse_session_process(se, (char const   *)buf, (unsigned int )res, ch);
#line 269
        while (1) {
#line 269
          tmp___6 = pthread_mutex_lock(& mtx);
#line 269
          if (! (tmp___6 == 0)) {
#line 269
            while (1) {
#line 269
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                      "zfs-fuse/fuse_listener.c", 269, "zfsfuse_listener_loop", "pthread_mutex_lock(&mtx) == 0");
#line 269
              abort();
#line 269
              break;
            }
          }
#line 269
          break;
        }
#line 275
        break;
      }
      __Cont: /* CIL Label */ 
#line 220
      i ++;
    }
#line 280
    write_ptr = 0;
#line 281
    read_ptr = 0;
#line 281
    while (read_ptr < nfds) {
#line 282
      if (fds[read_ptr].fd == -1) {
        goto __Cont___0;
      }
#line 284
      if (read_ptr != write_ptr) {
#line 285
        fds[write_ptr] = fds[read_ptr];
#line 286
        fsinfo[write_ptr] = fsinfo[read_ptr];
#line 287
        mountpoints[write_ptr] = mountpoints[read_ptr];
      }
#line 289
      write_ptr ++;
      __Cont___0: /* CIL Label */ 
#line 281
      read_ptr ++;
    }
#line 291
    nfds = write_ptr;
  }
#line 294
  while (1) {
#line 294
    tmp___7 = pthread_mutex_unlock(& mtx);
#line 294
    if (! (tmp___7 == 0)) {
#line 294
      while (1) {
#line 294
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                "zfs-fuse/fuse_listener.c", 294, "zfsfuse_listener_loop", "pthread_mutex_unlock(&mtx) == 0");
#line 294
        abort();
#line 294
        break;
      }
    }
#line 294
    break;
  }
#line 296
  return ((void *)0);
}
}
#line 299 "zfs-fuse/fuse_listener.c"
int zfsfuse_listener_start(void) 
{ int i ;
  int tmp ;
  int i___0 ;
  int ret ;
  int tmp___0 ;
  int i___1 ;

  {
#line 301
  i = 0;
#line 301
  while (i < 40) {
#line 302
    while (1) {
#line 302
      tmp = pthread_create((pthread_t * __restrict  )(& fuse_threads[i]), (pthread_attr_t const   * __restrict  )((void *)0),
                           & zfsfuse_listener_loop, (void * __restrict  )((void *)0));
#line 302
      if (! (tmp == 0)) {
#line 302
        while (1) {
#line 302
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                  "zfs-fuse/fuse_listener.c", 302, "zfsfuse_listener_start", "pthread_create(&fuse_threads[i], NULL, zfsfuse_listener_loop, NULL) == 0");
#line 302
          abort();
#line 302
          break;
        }
      }
#line 302
      break;
    }
#line 301
    i ++;
  }
#line 304
  i___0 = 0;
#line 304
  while (i___0 < 40) {
#line 305
    tmp___0 = pthread_join(fuse_threads[i___0], (void **)((void *)0));
#line 305
    ret = tmp___0;
#line 306
    if (ret != 0) {
#line 307
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Warning: pthread_join() on thread %i returned %i\n",
              i___0, ret);
    }
#line 304
    i___0 ++;
  }
#line 314
  i___1 = 1;
#line 314
  while (i___1 < nfds) {
#line 315
    if (fds[i___1].fd == -1) {
      goto __Cont;
    }
#line 318
    fuse_session_exit(fsinfo[i___1].se);
#line 319
    fuse_session_reset(fsinfo[i___1].se);
#line 320
    fuse_unmount_compat22((char const   *)mountpoints[i___1]);
#line 321
    fuse_session_destroy(fsinfo[i___1].se);
#line 323
    free((void *)mountpoints[i___1]);
    __Cont: /* CIL Label */ 
#line 314
    i___1 ++;
  }
#line 326
  return (1);
}
}
#line 1 "zfsfuse_socket.o"
#pragma merger(0,"/tmp/cil-k9H1035Y.i","-pipe,-Wall,-Werror,-std=c99,-Wno-unused,-Wno-missing-braces,-Wno-parentheses,-Wno-uninitialized,-fno-strict-aliasing,-ggdb,-O2")
#line 256 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 983 "/usr/include/unistd.h"
extern int lockf(int __fd , int __cmd , __off64_t __len )  __asm__("lockf64")  ;
#line 284 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int mkdir(char const   *__path , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 100 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 110
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  * __restrict  __addr ,
                                              socklen_t __len ) ;
#line 161
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 179
extern ssize_t recvmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 199
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 94 "/usr/include/fcntl.h"
extern int creat(char const   *__file , __mode_t __mode )  __asm__("creat64") __attribute__((__nonnull__(1))) ;
#line 315 "lib/libsolkerncompat/include/sys/vnode.h"
extern int vn_fromfd(int fd , char *path , int flags , struct vnode **vpp , boolean_t fromfd ) ;
#line 419
extern int fop_close(vnode_t * , int  , int  , offset_t  , cred_t * ) ;
#line 49 "zfs-fuse/zfsfuse_socket.c"
int cur_fd  =    -1;
#line 51 "zfs-fuse/zfsfuse_socket.c"
avl_tree_t fd_avl  ;
#line 52 "zfs-fuse/zfsfuse_socket.c"
pthread_mutex_t fd_avl_mtx  =    {0, 0, (_pthread_descr )0, 0, {0L, 0}};
#line 54 "zfs-fuse/zfsfuse_socket.c"
static int zfsfuse_do_locking(void) 
{ int lock_fd ;
  int tmp ;
  int tmp___0 ;

  {
#line 57
  mkdir("/var/lock/zfs", 448U);
#line 59
  tmp = creat("/var/lock/zfs/zfs_lock", 384U);
#line 59
  lock_fd = tmp;
#line 60
  if (lock_fd == -1) {
#line 61
    return (-1);
  }
#line 63
  tmp___0 = lockf(lock_fd, 2, 0LL);
#line 63
  return (tmp___0);
}
}
#line 69 "zfs-fuse/zfsfuse_socket.c"
int zfsfuse_fd_compare(void const   *arg1 , void const   *arg2 ) 
{ file_t const   *f1 ;
  file_t const   *f2 ;

  {
#line 72
  f1 = (file_t const   *)arg1;
#line 73
  f2 = (file_t const   *)arg2;
#line 75
  if (f1->f_client > f2->f_client) {
#line 76
    return (1);
  }
#line 77
  if (f1->f_client < f2->f_client) {
#line 78
    return (-1);
  }
#line 80
  if (f1->f_oldfd > f2->f_oldfd) {
#line 81
    return (1);
  }
#line 82
  if (f1->f_oldfd < f2->f_oldfd) {
#line 83
    return (-1);
  }
#line 85
  return (0);
}
}
#line 88 "zfs-fuse/zfsfuse_socket.c"
int zfsfuse_socket_create(void) 
{ struct sockaddr_un name ;
  int sock ;
  size_t size ;
  int tmp ;
  int err ;
  int *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  int err___0 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int err___1 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
#line 95
  tmp = zfsfuse_do_locking();
#line 95
  if (tmp != 0) {
#line 96
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error locking /var/lock/zfs/zfs_lock\nMake sure there isn\'t another zfs-fuse process running and that you have appropriate permissions\n");
#line 97
    return (-1);
  }
#line 101
  sock = socket(1, 1, 0);
#line 102
  if (sock == -1) {
#line 103
    tmp___0 = __errno_location();
#line 103
    err = *tmp___0;
#line 104
    tmp___1 = strerror(err);
#line 104
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error creating UNIX socket: %s\n",
            tmp___1);
#line 105
    return (-1);
  }
#line 109
  mkdir("/etc/zfs", 448U);
#line 112
  name.sun_family = (unsigned short)1;
#line 113
  __builtin_strncpy(name.sun_path, "/etc/zfs/zfs_socket", sizeof(name.sun_path));
#line 115
  name.sun_path[sizeof(name.sun_path) - 1U] = (char )'\000';
#line 117
  tmp___2 = strlen((char const   *)(name.sun_path));
#line 117
  size = (unsigned int )(((struct sockaddr_un *)0)->sun_path) + tmp___2;
#line 119
  unlink("/etc/zfs/zfs_socket");
#line 121
  tmp___5 = bind(sock, (struct sockaddr  const  * __restrict  )(& name), size);
#line 121
  if (tmp___5 != 0) {
#line 122
    tmp___3 = __errno_location();
#line 122
    err___0 = *tmp___3;
#line 123
    tmp___4 = strerror(err___0);
#line 123
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error binding UNIX socket to %s: %s\n",
            "/etc/zfs/zfs_socket", tmp___4);
#line 124
    return (-1);
  }
#line 127
  tmp___8 = listen(sock, 5);
#line 127
  if (tmp___8 != 0) {
#line 128
    tmp___6 = __errno_location();
#line 128
    err___1 = *tmp___6;
#line 129
    tmp___7 = strerror(err___1);
#line 129
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error binding UNIX socket to %s: %s\n",
            "/etc/zfs/zfs_socket", tmp___7);
#line 130
    return (-1);
  }
#line 133
  avl_create(& fd_avl, & zfsfuse_fd_compare, sizeof(file_t ), (unsigned int )(& ((file_t *)0)->f_node));
#line 135
  return (sock);
}
}
#line 138 "zfs-fuse/zfsfuse_socket.c"
void zfsfuse_socket_close(int fd ) 
{ 

  {
#line 140
  close(fd);
#line 142
  unlink("/etc/zfs/zfs_socket");
#line 144
  avl_destroy(& fd_avl);
#line 145
  return;
}
}
#line 151 "zfs-fuse/zfsfuse_socket.c"
int zfsfuse_socket_read_loop(int fd , void *buf , int bytes ) 
{ int read_bytes ;
  int left_bytes ;
  int ret ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
#line 153
  read_bytes = 0;
#line 154
  left_bytes = bytes;
#line 156
  while (left_bytes > 0) {
#line 157
    tmp = recvfrom(fd, (void * __restrict  )((char *)buf + read_bytes), (unsigned int )left_bytes,
                   0, (struct sockaddr * __restrict  )((void *)0), (socklen_t * __restrict  )((void *)0));
#line 157
    ret = tmp;
#line 158
    if (ret == 0) {
#line 159
      return (-1);
    }
#line 161
    if (ret == -1) {
#line 162
      tmp___0 = __errno_location();
#line 162
      if (*tmp___0 == 4) {
#line 163
        continue;
      }
#line 164
      return (-1);
    }
#line 166
    read_bytes += ret;
#line 167
    left_bytes -= ret;
  }
#line 169
  return (0);
}
}
#line 172 "zfs-fuse/zfsfuse_socket.c"
int zfsfuse_socket_ioctl_write(int fd , int ret ) 
{ zfsfuse_cmd_t cmd ;
  ssize_t tmp ;

  {
#line 181
  cmd.cmd_type = 1;
#line 182
  cmd.cmd_u.ioctl_ans_ret = ret;
#line 184
  tmp = write(fd, (void const   *)(& cmd), sizeof(zfsfuse_cmd_t ));
#line 184
  if ((unsigned int )tmp != sizeof(zfsfuse_cmd_t )) {
#line 185
    return (-1);
  }
#line 187
  return (0);
}
}
#line 190 "zfs-fuse/zfsfuse_socket.c"
int xcopyin(void const   *src , void *dest , size_t size ) 
{ zfsfuse_cmd_t cmd ;
  ssize_t tmp ;
  int tmp___0 ;

  {
#line 200
  while (1) {
#line 200
    if (! (cur_fd >= 0)) {
#line 200
      while (1) {
#line 200
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                "zfs-fuse/zfsfuse_socket.c", 200, "xcopyin", "cur_fd >= 0");
#line 200
        abort();
#line 200
        break;
      }
    }
#line 200
    break;
  }
#line 202
  cmd.cmd_type = 2;
#line 203
  cmd.cmd_u.copy_req.ptr = (unsigned long long )((unsigned int )src);
#line 204
  cmd.cmd_u.copy_req.size = (unsigned long long )size;
#line 206
  tmp = write(cur_fd, (void const   *)(& cmd), sizeof(zfsfuse_cmd_t ));
#line 206
  if ((unsigned int )tmp != sizeof(zfsfuse_cmd_t )) {
#line 207
    return (14);
  }
#line 209
  tmp___0 = zfsfuse_socket_read_loop(cur_fd, dest, (int )size);
#line 209
  if (tmp___0 != 0) {
#line 210
    return (14);
  }
#line 212
  return (0);
}
}
#line 215 "zfs-fuse/zfsfuse_socket.c"
int xcopyout(void const   *src , void *dest , size_t size ) 
{ zfsfuse_cmd_t cmd ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
#line 225
  while (1) {
#line 225
    if (! (cur_fd >= 0)) {
#line 225
      while (1) {
#line 225
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                "zfs-fuse/zfsfuse_socket.c", 225, "xcopyout", "cur_fd >= 0");
#line 225
        abort();
#line 225
        break;
      }
    }
#line 225
    break;
  }
#line 227
  cmd.cmd_type = 3;
#line 228
  cmd.cmd_u.copy_req.ptr = (unsigned long long )((unsigned int )dest);
#line 229
  cmd.cmd_u.copy_req.size = (unsigned long long )size;
#line 231
  tmp = write(cur_fd, (void const   *)(& cmd), sizeof(zfsfuse_cmd_t ));
#line 231
  if ((unsigned int )tmp != sizeof(zfsfuse_cmd_t )) {
#line 232
    return (14);
  }
#line 234
  tmp___0 = write(cur_fd, src, size);
#line 234
  if ((size_t )tmp___0 != size) {
#line 235
    return (14);
  }
#line 237
  return (0);
}
}
#line 246 "zfs-fuse/zfsfuse_socket.c"
file_t *getf(int fd ) 
{ zfsfuse_cmd_t cmd ;
  ssize_t tmp ;
  struct msghdr msg ;
  struct cmsghdr *cmsg ;
  char buf[(((sizeof(int ) + sizeof(size_t )) - 1U) & ~ (sizeof(size_t ) - 1U)) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1U) & ~ (sizeof(size_t ) - 1U))] ;
  int32_t *fdptr ;
  struct iovec iov[1] ;
  char c ;
  int r ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  int new_fd ;
  file_t *ret ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 256
  while (1) {
#line 256
    if (! (cur_fd >= 0)) {
#line 256
      while (1) {
#line 256
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                "zfs-fuse/zfsfuse_socket.c", 256, "getf", "cur_fd >= 0");
#line 256
        abort();
#line 256
        break;
      }
    }
#line 256
    break;
  }
#line 258
  cmd.cmd_type = 5;
#line 259
  cmd.cmd_u.getf_req_fd = fd;
#line 261
  tmp = write(cur_fd, (void const   *)(& cmd), sizeof(zfsfuse_cmd_t ));
#line 261
  if ((unsigned int )tmp != sizeof(zfsfuse_cmd_t )) {
#line 262
    return ((file_t *)((void *)0));
  }
  retry: 
#line 267
  msg.msg_name = (void *)0;
#line 267
  msg.msg_namelen = 0U;
#line 267
  msg.msg_iov = (struct iovec *)0;
#line 267
  msg.msg_iovlen = 0U;
#line 267
  msg.msg_control = (void *)0;
#line 267
  msg.msg_controllen = 0U;
#line 267
  msg.msg_flags = 0;
#line 274
  iov[0].iov_base = (void *)(& c);
#line 275
  iov[0].iov_len = 1U;
#line 276
  msg.msg_iov = iov;
#line 277
  msg.msg_iovlen = 1U;
#line 279
  msg.msg_control = (void *)(buf);
#line 280
  msg.msg_controllen = sizeof(buf);
#line 281
  if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 281
    cmsg = (struct cmsghdr *)msg.msg_control;
  } else {
#line 281
    cmsg = (struct cmsghdr *)((void *)0);
  }
#line 282
  cmsg->cmsg_level = 1;
#line 283
  cmsg->cmsg_type = 1;
#line 284
  msg.msg_controllen = (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1U) & ~ (sizeof(size_t ) - 1U)) + sizeof(int );
#line 286
  tmp___0 = recvmsg(cur_fd, & msg, 0);
#line 286
  r = tmp___0;
#line 287
  if (r == 0) {
#line 288
    return ((file_t *)((void *)0));
  }
#line 290
  if (r == -1) {
#line 291
    tmp___1 = __errno_location();
#line 291
    if (*tmp___1 == 4) {
      goto retry;
    }
#line 293
    return ((file_t *)((void *)0));
  }
#line 296
  if (cmsg->cmsg_len != (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1U) & ~ (sizeof(size_t ) - 1U)) + sizeof(int )) {
#line 297
    return ((file_t *)((void *)0));
  } else {
#line 296
    if (cmsg->cmsg_level != 1) {
#line 297
      return ((file_t *)((void *)0));
    } else {
#line 296
      if (cmsg->cmsg_type != 1) {
#line 297
        return ((file_t *)((void *)0));
      }
    }
  }
#line 299
  fdptr = (int *)(cmsg->__cmsg_data);
#line 300
  new_fd = *fdptr;
#line 302
  tmp___2 = umem_alloc(sizeof(file_t ), 256);
#line 302
  ret = (file_t *)tmp___2;
#line 304
  tmp___3 = vn_fromfd(new_fd, (char *)"file descriptor", 3, & ret->f_vnode, 1);
#line 304
  if (tmp___3 != 0) {
#line 305
    umem_free((void *)ret, sizeof(file_t ));
#line 306
    return ((file_t *)((void *)0));
  }
#line 309
  ret->f_client = cur_fd;
#line 310
  ret->f_oldfd = fd;
#line 311
  ret->f_offset = 0LL;
#line 313
  while (1) {
#line 313
    tmp___4 = pthread_mutex_lock(& fd_avl_mtx);
#line 313
    if (! (tmp___4 == 0)) {
#line 313
      while (1) {
#line 313
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                "zfs-fuse/zfsfuse_socket.c", 313, "getf", "pthread_mutex_lock(&fd_avl_mtx) == 0");
#line 313
        abort();
#line 313
        break;
      }
    }
#line 313
    break;
  }
#line 315
  avl_add(& fd_avl, (void *)ret);
#line 317
  while (1) {
#line 317
    tmp___5 = pthread_mutex_unlock(& fd_avl_mtx);
#line 317
    if (! (tmp___5 == 0)) {
#line 317
      while (1) {
#line 317
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                "zfs-fuse/zfsfuse_socket.c", 317, "getf", "pthread_mutex_unlock(&fd_avl_mtx) == 0");
#line 317
        abort();
#line 317
        break;
      }
    }
#line 317
    break;
  }
#line 319
  return (ret);
}
}
#line 327 "zfs-fuse/zfsfuse_socket.c"
void releasef(int fd ) 
{ file_t f___0 ;
  int tmp ;
  file_t *node ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 330
  f___0.f_client = cur_fd;
#line 331
  f___0.f_oldfd = fd;
#line 333
  while (1) {
#line 333
    tmp = pthread_mutex_lock(& fd_avl_mtx);
#line 333
    if (! (tmp == 0)) {
#line 333
      while (1) {
#line 333
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                "zfs-fuse/zfsfuse_socket.c", 333, "releasef", "pthread_mutex_lock(&fd_avl_mtx) == 0");
#line 333
        abort();
#line 333
        break;
      }
    }
#line 333
    break;
  }
#line 335
  tmp___0 = avl_find(& fd_avl, (void *)(& f___0), (avl_index_t *)((void *)0));
#line 335
  node = (file_t *)tmp___0;
#line 336
  while (1) {
#line 336
    if (! ((unsigned int )node != (unsigned int )((void *)0))) {
#line 336
      while (1) {
#line 336
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                "zfs-fuse/zfsfuse_socket.c", 336, "releasef", "node != NULL");
#line 336
        abort();
#line 336
        break;
      }
    }
#line 336
    break;
  }
#line 338
  fop_close(node->f_vnode, 3, 1, 0LL, kcred);
#line 339
  vn_rele(node->f_vnode);
#line 341
  avl_remove(& fd_avl, (void *)node);
#line 343
  while (1) {
#line 343
    tmp___1 = pthread_mutex_unlock(& fd_avl_mtx);
#line 343
    if (! (tmp___1 == 0)) {
#line 343
      while (1) {
#line 343
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                "zfs-fuse/zfsfuse_socket.c", 343, "releasef", "pthread_mutex_unlock(&fd_avl_mtx) == 0");
#line 343
        abort();
#line 343
        break;
      }
    }
#line 343
    break;
  }
#line 345
  umem_free((void *)node, sizeof(file_t ));
#line 346
  return;
}
}
#line 1 "zfs_operations.o"
#pragma merger(0,"/tmp/cil-B4qjDJzm.i","-pipe,-Wall,-Werror,-std=c99,-Wno-unused,-Wno-missing-braces,-Wno-parentheses,-Wno-uninitialized,-fno-strict-aliasing,-ggdb,-O2")
#line 324 "/usr/include/time.h"
extern int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
#line 810 "/usr/local/include/fuse/fuse_lowlevel.h"
extern int fuse_reply_err(fuse_req_t req , int err ) ;
#line 832
extern int fuse_reply_entry(fuse_req_t req , struct fuse_entry_param  const  *e ) ;
#line 848
extern int fuse_reply_create(fuse_req_t req , struct fuse_entry_param  const  *e ,
                             struct fuse_file_info  const  *fi ) ;
#line 862
extern int fuse_reply_attr(fuse_req_t req , struct stat  const  *attr , double attr_timeout ) ;
#line 875
extern int fuse_reply_readlink(fuse_req_t req , char const   *link ) ;
#line 890
extern int fuse_reply_open(fuse_req_t req , struct fuse_file_info  const  *fi ) ;
#line 902
extern int fuse_reply_write(fuse_req_t req , size_t count ) ;
#line 915
extern int fuse_reply_buf(fuse_req_t req , char const   *buf , size_t size ) ;
#line 927
extern int fuse_reply_statfs(fuse_req_t req , struct statvfs  const  *stbuf ) ;
#line 1007
extern void *fuse_req_userdata(fuse_req_t req ) ;
#line 1018
extern struct fuse_ctx  const  *fuse_req_ctx(fuse_req_t req ) ;
#line 65 "/usr/local/include/fuse/fuse_lowlevel_compat.h"
extern size_t fuse_dirent_size(size_t namelen ) ;
#line 67
extern char *fuse_add_dirent(char *buf , char const   *name , struct stat  const  *stbuf ,
                             off_t off ) ;
#line 418 "lib/libsolkerncompat/include/sys/vnode.h"
extern int fop_open(vnode_t ** , int  , cred_t * ) ;
#line 420
extern int fop_read(vnode_t * , uio_t * , int  , cred_t * , caller_context_t * ) ;
#line 421
extern int fop_write(vnode_t * , uio_t * , int  , cred_t * , caller_context_t * ) ;
#line 425
extern int fop_getattr(vnode_t * , vattr_t * , int  , cred_t * ) ;
#line 428
extern int fop_access(vnode_t * , int  , int  , cred_t * ) ;
#line 429
extern int fop_lookup(vnode_t * , char * , vnode_t ** , struct pathname * , int  ,
                      vnode_t * , cred_t * ) ;
#line 438
extern int fop_readdir(vnode_t * , uio_t * , cred_t * , int * ) ;
#line 440
extern int fop_readlink(vnode_t * , uio_t * , cred_t * ) ;
#line 441
extern int fop_fsync(vnode_t * , int  , cred_t * ) ;
#line 190 "lib/libsolkerncompat/include/sys/vfs.h"
extern int fsop_statfs(vfs_t * , statvfs64_t * ) ;
#line 49 "zfs-fuse/zfs_operations.c"
static void zfsfuse_getcred(fuse_req_t req , cred_t *cred ) 
{ struct fuse_ctx  const  *ctx ;
  struct fuse_ctx  const  *tmp ;

  {
#line 51
  tmp = fuse_req_ctx(req);
#line 51
  ctx = tmp;
#line 53
  cred->cr_uid = (unsigned int )ctx->uid;
#line 54
  cred->cr_gid = (unsigned int )ctx->gid;
#line 55
  return;
}
}
#line 57 "zfs-fuse/zfs_operations.c"
static void zfsfuse_destroy(void *userdata ) 
{ vfs_t *vfs ;
  struct timespec req ;
  int tmp ;

  {
#line 59
  vfs = (vfs_t *)userdata;
#line 62
  req.tv_sec = 0L;
#line 63
  req.tv_nsec = 100000000L;
#line 73
  while (1) {
#line 73
    tmp = do_umount(vfs, exit_fuse_listener);
#line 73
    if (! (tmp != 0)) {
#line 73
      break;
    }
#line 74
    nanosleep((struct timespec  const  *)(& req), (struct timespec *)((void *)0));
  }
#line 78
  return;
}
}
#line 80 "zfs-fuse/zfs_operations.c"
static void zfsfuse_statfs(fuse_req_t req ) 
{ vfs_t *vfs ;
  void *tmp ;
  struct statvfs64 zfs_stat ;
  int ret ;
  int tmp___0 ;
  struct statvfs stat___0 ;

  {
#line 82
  tmp = fuse_req_userdata(req);
#line 82
  vfs = (vfs_t *)tmp;
#line 86
  tmp___0 = fsop_statfs(vfs, & zfs_stat);
#line 86
  ret = tmp___0;
#line 87
  if (ret != 0) {
#line 88
    fuse_reply_err(req, ret);
#line 89
    return;
  }
#line 92
  stat___0.f_bsize = 0UL;
#line 92
  stat___0.f_frsize = 0UL;
#line 92
  stat___0.f_blocks = 0ULL;
#line 92
  stat___0.f_bfree = 0ULL;
#line 92
  stat___0.f_bavail = 0ULL;
#line 92
  stat___0.f_files = 0ULL;
#line 92
  stat___0.f_ffree = 0ULL;
#line 92
  stat___0.f_favail = 0ULL;
#line 92
  stat___0.f_fsid = 0UL;
#line 92
  stat___0.f_basetype[0] = (char)0;
#line 92
  stat___0.f_basetype[1] = (char)0;
#line 92
  stat___0.f_basetype[2] = (char)0;
#line 92
  stat___0.f_basetype[3] = (char)0;
#line 92
  stat___0.f_basetype[4] = (char)0;
#line 92
  stat___0.f_basetype[5] = (char)0;
#line 92
  stat___0.f_basetype[6] = (char)0;
#line 92
  stat___0.f_basetype[7] = (char)0;
#line 92
  stat___0.f_basetype[8] = (char)0;
#line 92
  stat___0.f_basetype[9] = (char)0;
#line 92
  stat___0.f_basetype[10] = (char)0;
#line 92
  stat___0.f_basetype[11] = (char)0;
#line 92
  stat___0.f_basetype[12] = (char)0;
#line 92
  stat___0.f_basetype[13] = (char)0;
#line 92
  stat___0.f_basetype[14] = (char)0;
#line 92
  stat___0.f_basetype[15] = (char)0;
#line 92
  stat___0.f_flag = 0UL;
#line 92
  stat___0.f_namemax = 0UL;
#line 92
  stat___0.f_fstr[0] = (char)0;
#line 92
  stat___0.f_fstr[1] = (char)0;
#line 92
  stat___0.f_fstr[2] = (char)0;
#line 92
  stat___0.f_fstr[3] = (char)0;
#line 92
  stat___0.f_fstr[4] = (char)0;
#line 92
  stat___0.f_fstr[5] = (char)0;
#line 92
  stat___0.f_fstr[6] = (char)0;
#line 92
  stat___0.f_fstr[7] = (char)0;
#line 92
  stat___0.f_fstr[8] = (char)0;
#line 92
  stat___0.f_fstr[9] = (char)0;
#line 92
  stat___0.f_fstr[10] = (char)0;
#line 92
  stat___0.f_fstr[11] = (char)0;
#line 92
  stat___0.f_fstr[12] = (char)0;
#line 92
  stat___0.f_fstr[13] = (char)0;
#line 92
  stat___0.f_fstr[14] = (char)0;
#line 92
  stat___0.f_fstr[15] = (char)0;
#line 92
  stat___0.f_fstr[16] = (char)0;
#line 92
  stat___0.f_fstr[17] = (char)0;
#line 92
  stat___0.f_fstr[18] = (char)0;
#line 92
  stat___0.f_fstr[19] = (char)0;
#line 92
  stat___0.f_fstr[20] = (char)0;
#line 92
  stat___0.f_fstr[21] = (char)0;
#line 92
  stat___0.f_fstr[22] = (char)0;
#line 92
  stat___0.f_fstr[23] = (char)0;
#line 92
  stat___0.f_fstr[24] = (char)0;
#line 92
  stat___0.f_fstr[25] = (char)0;
#line 92
  stat___0.f_fstr[26] = (char)0;
#line 92
  stat___0.f_fstr[27] = (char)0;
#line 92
  stat___0.f_fstr[28] = (char)0;
#line 92
  stat___0.f_fstr[29] = (char)0;
#line 92
  stat___0.f_fstr[30] = (char)0;
#line 92
  stat___0.f_fstr[31] = (char)0;
#line 92
  stat___0.f_filler[0] = 0UL;
#line 92
  stat___0.f_filler[1] = 0UL;
#line 92
  stat___0.f_filler[2] = 0UL;
#line 92
  stat___0.f_filler[3] = 0UL;
#line 92
  stat___0.f_filler[4] = 0UL;
#line 92
  stat___0.f_filler[5] = 0UL;
#line 92
  stat___0.f_filler[6] = 0UL;
#line 92
  stat___0.f_filler[7] = 0UL;
#line 92
  stat___0.f_filler[8] = 0UL;
#line 92
  stat___0.f_filler[9] = 0UL;
#line 92
  stat___0.f_filler[10] = 0UL;
#line 92
  stat___0.f_filler[11] = 0UL;
#line 92
  stat___0.f_filler[12] = 0UL;
#line 92
  stat___0.f_filler[13] = 0UL;
#line 92
  stat___0.f_filler[14] = 0UL;
#line 92
  stat___0.f_filler[15] = 0UL;
#line 97
  stat___0.f_bsize = zfs_stat.f_frsize;
#line 98
  stat___0.f_frsize = zfs_stat.f_frsize;
#line 99
  stat___0.f_blocks = zfs_stat.f_blocks;
#line 100
  stat___0.f_bfree = zfs_stat.f_bfree;
#line 101
  stat___0.f_bavail = zfs_stat.f_bavail;
#line 102
  stat___0.f_files = zfs_stat.f_files;
#line 103
  stat___0.f_ffree = zfs_stat.f_ffree;
#line 104
  stat___0.f_favail = zfs_stat.f_favail;
#line 105
  stat___0.f_fsid = zfs_stat.f_fsid;
#line 106
  stat___0.f_flag = zfs_stat.f_flag;
#line 107
  stat___0.f_namemax = zfs_stat.f_namemax;
#line 109
  fuse_reply_statfs(req, (struct statvfs  const  *)(& stat___0));
#line 110
  return;
}
}
#line 112 "zfs-fuse/zfs_operations.c"
static int zfsfuse_stat(vnode_t *vp , struct stat *stbuf , cred_t *cred ) 
{ vattr_t vattr ;
  int error ;
  int tmp ;

  {
#line 114
  if (! ((unsigned int )vp != (unsigned int )((void *)0))) {
#line 114
    __assert_fail("vp != ((void *)0)", "zfs-fuse/zfs_operations.c", 114U, "zfsfuse_stat");
  }
#line 115
  if (! ((unsigned int )stbuf != (unsigned int )((void *)0))) {
#line 115
    __assert_fail("stbuf != ((void *)0)", "zfs-fuse/zfs_operations.c", 115U, "zfsfuse_stat");
  }
#line 118
  vattr.va_mask = 16383U;
#line 120
  tmp = fop_getattr(vp, & vattr, 0, cred);
#line 120
  error = tmp;
#line 121
  if (error) {
#line 122
    return (error);
  }
#line 124
  memset((void *)stbuf, 0, sizeof(struct stat ));
#line 126
  stbuf->st_dev = vattr.va_fsid;
#line 127
  if (vattr.va_nodeid == 3ULL) {
#line 127
    stbuf->st_ino = 1ULL;
  } else {
#line 127
    stbuf->st_ino = vattr.va_nodeid;
  }
#line 128
  stbuf->st_mode = (unsigned int )vttoif_tab[(int )vattr.va_type] | vattr.va_mode;
#line 129
  stbuf->st_nlink = vattr.va_nlink;
#line 130
  stbuf->st_uid = vattr.va_uid;
#line 131
  stbuf->st_gid = vattr.va_gid;
#line 132
  stbuf->st_rdev = vattr.va_rdev;
#line 133
  stbuf->st_size = (long long )vattr.va_size;
#line 134
  stbuf->st_blksize = (long )vattr.va_blksize;
#line 135
  stbuf->st_blocks = (long long )vattr.va_nblocks;
#line 136
  stbuf->st_atim.tv_sec = vattr.va_atime.tv_sec;
#line 137
  stbuf->st_mtim.tv_sec = vattr.va_mtime.tv_sec;
#line 138
  stbuf->st_ctim.tv_sec = vattr.va_ctime.tv_sec;
#line 140
  return (0);
}
}
#line 143 "zfs-fuse/zfs_operations.c"
static int zfsfuse_getattr(fuse_req_t req , fuse_ino_t ino , struct fuse_file_info *fi ) 
{ vfs_t *vfs ;
  void *tmp ;
  zfsvfs_t *zfsvfs ;
  znode_t *znode ;
  int error ;
  int tmp___0 ;
  int tmp___1 ;
  vnode_t *vp ;
  cred_t cred ;
  struct stat stbuf ;

  {
#line 145
  tmp = fuse_req_userdata(req);
#line 145
  vfs = (vfs_t *)tmp;
#line 146
  zfsvfs = (zfsvfs_t *)vfs->vfs_data;
#line 148
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 148
  if (zfsvfs->z_unmounted1) {
#line 148
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 148
    return (5);
  }
#line 152
  tmp___0 = zfs_zget(zfsvfs, (unsigned long long )ino, & znode);
#line 152
  error = tmp___0;
#line 153
  if (error) {
#line 154
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 157
    if (error == 17) {
#line 157
      tmp___1 = 2;
    } else {
#line 157
      tmp___1 = error;
    }
#line 157
    return (tmp___1);
  }
#line 160
  if (! ((unsigned int )znode != (unsigned int )((void *)0))) {
#line 160
    __assert_fail("znode != ((void *)0)", "zfs-fuse/zfs_operations.c", 160U, "zfsfuse_getattr");
  }
#line 161
  vp = znode->z_vnode;
#line 162
  if (! ((unsigned int )vp != (unsigned int )((void *)0))) {
#line 162
    __assert_fail("vp != ((void *)0)", "zfs-fuse/zfs_operations.c", 162U, "zfsfuse_getattr");
  }
#line 165
  zfsfuse_getcred(req, & cred);
#line 168
  error = zfsfuse_stat(vp, & stbuf, & cred);
#line 170
  vn_rele(vp);
#line 171
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 173
  if (! error) {
#line 174
    fuse_reply_attr(req, (struct stat  const  *)(& stbuf), 0.0);
  }
#line 176
  return (error);
}
}
#line 179 "zfs-fuse/zfs_operations.c"
static void zfsfuse_getattr_helper(fuse_req_t req , fuse_ino_t ino , struct fuse_file_info *fi ) 
{ fuse_ino_t real_ino ;
  fuse_ino_t tmp ;
  int error ;
  int tmp___0 ;

  {
#line 181
  if (ino == 1UL) {
#line 181
    tmp = 3UL;
  } else {
#line 181
    tmp = ino;
  }
#line 181
  real_ino = tmp;
#line 183
  tmp___0 = zfsfuse_getattr(req, real_ino, fi);
#line 183
  error = tmp___0;
#line 184
  if (error) {
#line 185
    fuse_reply_err(req, error);
  }
#line 186
  return;
}
}
#line 188 "zfs-fuse/zfs_operations.c"
static int zfsfuse_lookup(fuse_req_t req , fuse_ino_t parent , char const   *name ) 
{ size_t tmp ;
  vfs_t *vfs ;
  void *tmp___0 ;
  zfsvfs_t *zfsvfs ;
  znode_t *znode ;
  int error ;
  int tmp___1 ;
  int tmp___2 ;
  vnode_t *dvp ;
  vnode_t *vp ;
  cred_t cred ;
  struct fuse_entry_param e ;

  {
#line 190
  tmp = strlen(name);
#line 190
  if (tmp >= 256U) {
#line 191
    return (36);
  }
#line 193
  tmp___0 = fuse_req_userdata(req);
#line 193
  vfs = (vfs_t *)tmp___0;
#line 194
  zfsvfs = (zfsvfs_t *)vfs->vfs_data;
#line 196
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 196
  if (zfsvfs->z_unmounted1) {
#line 196
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 196
    return (5);
  }
#line 200
  tmp___1 = zfs_zget(zfsvfs, (unsigned long long )parent, & znode);
#line 200
  error = tmp___1;
#line 201
  if (error) {
#line 202
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 205
    if (error == 17) {
#line 205
      tmp___2 = 2;
    } else {
#line 205
      tmp___2 = error;
    }
#line 205
    return (tmp___2);
  }
#line 208
  if (! ((unsigned int )znode != (unsigned int )((void *)0))) {
#line 208
    __assert_fail("znode != ((void *)0)", "zfs-fuse/zfs_operations.c", 208U, "zfsfuse_lookup");
  }
#line 209
  dvp = znode->z_vnode;
#line 210
  if (! ((unsigned int )dvp != (unsigned int )((void *)0))) {
#line 210
    __assert_fail("dvp != ((void *)0)", "zfs-fuse/zfs_operations.c", 210U, "zfsfuse_lookup");
  }
#line 212
  vp = (vnode_t *)((void *)0);
#line 215
  zfsfuse_getcred(req, & cred);
#line 217
  error = fop_lookup(dvp, (char *)name, & vp, (struct pathname *)((void *)0), 0, (vnode_t *)((void *)0),
                     & cred);
#line 218
  if (error) {
    goto out;
  }
#line 221
  e.ino = (fuse_ino_t )0;
#line 221
  e.generation = 0UL;
#line 221
  e.attr.st_dev = 0ULL;
#line 221
  e.attr.__pad1 = (unsigned short)0;
#line 221
  e.attr.__st_ino = 0UL;
#line 221
  e.attr.st_mode = 0U;
#line 221
  e.attr.st_nlink = 0U;
#line 221
  e.attr.st_uid = 0U;
#line 221
  e.attr.st_gid = 0U;
#line 221
  e.attr.st_rdev = 0ULL;
#line 221
  e.attr.__pad2 = (unsigned short)0;
#line 221
  e.attr.st_size = 0LL;
#line 221
  e.attr.st_blksize = 0L;
#line 221
  e.attr.st_blocks = 0LL;
#line 221
  e.attr.st_atim.tv_sec = 0L;
#line 221
  e.attr.st_atim.tv_nsec = 0L;
#line 221
  e.attr.st_mtim.tv_sec = 0L;
#line 221
  e.attr.st_mtim.tv_nsec = 0L;
#line 221
  e.attr.st_ctim.tv_sec = 0L;
#line 221
  e.attr.st_ctim.tv_nsec = 0L;
#line 221
  e.attr.st_ino = 0ULL;
#line 221
  e.attr_timeout = 0.;
#line 221
  e.entry_timeout = 0.;
#line 223
  e.attr_timeout = 0.0;
#line 224
  e.entry_timeout = 0.0;
#line 226
  if ((unsigned int )vp == (unsigned int )((void *)0)) {
    goto out;
  }
#line 229
  e.ino = (unsigned long )((znode_t *)vp->v_data)->z_id;
#line 230
  if (e.ino == 3UL) {
#line 231
    e.ino = 1UL;
  }
#line 233
  e.generation = (unsigned long )(((znode_t *)vp->v_data)->z_phys)->zp_gen;
#line 235
  error = zfsfuse_stat(vp, & e.attr, & cred);
  out: 
#line 238
  if ((unsigned int )vp != (unsigned int )((void *)0)) {
#line 239
    vn_rele(vp);
  }
#line 240
  vn_rele(dvp);
#line 241
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 243
  if (! error) {
#line 244
    fuse_reply_entry(req, (struct fuse_entry_param  const  *)(& e));
  }
#line 246
  return (error);
}
}
#line 249 "zfs-fuse/zfs_operations.c"
static void zfsfuse_lookup_helper(fuse_req_t req , fuse_ino_t parent , char const   *name ) 
{ fuse_ino_t real_parent ;
  fuse_ino_t tmp ;
  int error ;
  int tmp___0 ;

  {
#line 251
  if (parent == 1UL) {
#line 251
    tmp = 3UL;
  } else {
#line 251
    tmp = parent;
  }
#line 251
  real_parent = tmp;
#line 253
  tmp___0 = zfsfuse_lookup(req, real_parent, name);
#line 253
  error = tmp___0;
#line 254
  if (error) {
#line 255
    fuse_reply_err(req, error);
  }
#line 256
  return;
}
}
#line 258 "zfs-fuse/zfs_operations.c"
static int zfsfuse_opendir(fuse_req_t req , fuse_ino_t ino , struct fuse_file_info *fi ) 
{ vfs_t *vfs ;
  void *tmp ;
  zfsvfs_t *zfsvfs ;
  znode_t *znode ;
  int error ;
  int tmp___0 ;
  int tmp___1 ;
  vnode_t *vp ;
  cred_t cred ;
  vnode_t *old_vp ;
  file_info_t *info ;
  void *tmp___2 ;

  {
#line 260
  tmp = fuse_req_userdata(req);
#line 260
  vfs = (vfs_t *)tmp;
#line 261
  zfsvfs = (zfsvfs_t *)vfs->vfs_data;
#line 263
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 263
  if (zfsvfs->z_unmounted1) {
#line 263
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 263
    return (5);
  }
#line 267
  tmp___0 = zfs_zget(zfsvfs, (unsigned long long )ino, & znode);
#line 267
  error = tmp___0;
#line 268
  if (error) {
#line 269
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 272
    if (error == 17) {
#line 272
      tmp___1 = 2;
    } else {
#line 272
      tmp___1 = error;
    }
#line 272
    return (tmp___1);
  }
#line 275
  if (! ((unsigned int )znode != (unsigned int )((void *)0))) {
#line 275
    __assert_fail("znode != ((void *)0)", "zfs-fuse/zfs_operations.c", 275U, "zfsfuse_opendir");
  }
#line 276
  vp = znode->z_vnode;
#line 277
  if (! ((unsigned int )vp != (unsigned int )((void *)0))) {
#line 277
    __assert_fail("vp != ((void *)0)", "zfs-fuse/zfs_operations.c", 277U, "zfsfuse_opendir");
  }
#line 279
  if ((int )vp->v_type != 2) {
#line 280
    error = 20;
    goto out;
  }
#line 285
  zfsfuse_getcred(req, & cred);
#line 290
  error = fop_access(vp, 320, 0, & cred);
#line 290
  if (error) {
    goto out;
  }
#line 293
  old_vp = vp;
#line 296
  error = fop_open(& vp, 1, & cred);
#line 298
  if (! ((unsigned int )old_vp == (unsigned int )vp)) {
#line 298
    __assert_fail("old_vp == vp", "zfs-fuse/zfs_operations.c", 298U, "zfsfuse_opendir");
  }
#line 300
  if (! error) {
#line 301
    tmp___2 = umem_cache_alloc(file_info_cache, 0);
#line 301
    info = (file_info_t *)tmp___2;
#line 302
    if ((unsigned int )info == (unsigned int )((void *)0)) {
#line 303
      error = 12;
      goto out;
    }
#line 307
    info->vp = vp;
#line 308
    info->flags = 1;
#line 310
    fi->fh = (unsigned long long )((unsigned int )info);
  }
  out: 
#line 314
  if (error) {
#line 315
    vn_rele(vp);
  }
#line 316
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 318
  if (! error) {
#line 319
    fuse_reply_open(req, (struct fuse_file_info  const  *)fi);
  }
#line 321
  return (error);
}
}
#line 324 "zfs-fuse/zfs_operations.c"
static void zfsfuse_opendir_helper(fuse_req_t req , fuse_ino_t ino , struct fuse_file_info *fi ) 
{ fuse_ino_t real_ino ;
  fuse_ino_t tmp ;
  int error ;
  int tmp___0 ;

  {
#line 326
  if (ino == 1UL) {
#line 326
    tmp = 3UL;
  } else {
#line 326
    tmp = ino;
  }
#line 326
  real_ino = tmp;
#line 328
  tmp___0 = zfsfuse_opendir(req, real_ino, fi);
#line 328
  error = tmp___0;
#line 329
  if (error) {
#line 330
    fuse_reply_err(req, error);
  }
#line 331
  return;
}
}
#line 333 "zfs-fuse/zfs_operations.c"
static int zfsfuse_release(fuse_req_t req , fuse_ino_t ino , struct fuse_file_info *fi ) 
{ vfs_t *vfs ;
  void *tmp ;
  zfsvfs_t *zfsvfs ;
  file_info_t *info ;
  cred_t cred ;
  int error ;
  int tmp___0 ;

  {
#line 335
  tmp = fuse_req_userdata(req);
#line 335
  vfs = (vfs_t *)tmp;
#line 336
  zfsvfs = (zfsvfs_t *)vfs->vfs_data;
#line 338
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 338
  if (zfsvfs->z_unmounted1) {
#line 338
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 338
    return (5);
  }
#line 340
  info = (file_info_t *)((unsigned int )fi->fh);
#line 341
  if (! ((unsigned int )info->vp != (unsigned int )((void *)0))) {
#line 341
    __assert_fail("info->vp != ((void *)0)", "zfs-fuse/zfs_operations.c", 341U, "zfsfuse_release");
  }
#line 342
  if (! ((unsigned int )((znode_t *)(info->vp)->v_data) != (unsigned int )((void *)0))) {
#line 342
    __assert_fail("((znode_t *)(info->vp)->v_data) != ((void *)0)", "zfs-fuse/zfs_operations.c",
                  342U, "zfsfuse_release");
  }
#line 343
  if (! (((znode_t *)(info->vp)->v_data)->z_id == (uint64_t )ino)) {
#line 343
    __assert_fail("((znode_t *)(info->vp)->v_data)->z_id == ino", "zfs-fuse/zfs_operations.c",
                  343U, "zfsfuse_release");
  }
#line 346
  zfsfuse_getcred(req, & cred);
#line 348
  tmp___0 = fop_close(info->vp, info->flags, 1, 0LL, & cred);
#line 348
  error = tmp___0;
#line 349
  while (1) {
#line 349
    if (! (error == 0)) {
#line 349
      while (1) {
#line 349
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                "zfs-fuse/zfs_operations.c", 349, "zfsfuse_release", "error == 0");
#line 349
        abort();
#line 349
        break;
      }
    }
#line 349
    break;
  }
#line 351
  vn_rele(info->vp);
#line 353
  umem_cache_free(file_info_cache, (void *)info);
#line 355
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 357
  return (error);
}
}
#line 360 "zfs-fuse/zfs_operations.c"
static void zfsfuse_release_helper(fuse_req_t req , fuse_ino_t ino , struct fuse_file_info *fi ) 
{ fuse_ino_t real_ino ;
  fuse_ino_t tmp ;
  int error ;
  int tmp___0 ;

  {
#line 362
  if (ino == 1UL) {
#line 362
    tmp = 3UL;
  } else {
#line 362
    tmp = ino;
  }
#line 362
  real_ino = tmp;
#line 364
  tmp___0 = zfsfuse_release(req, real_ino, fi);
#line 364
  error = tmp___0;
#line 366
  fuse_reply_err(req, error);
#line 367
  return;
}
}
#line 369 "zfs-fuse/zfs_operations.c"
static int zfsfuse_readdir(fuse_req_t req , fuse_ino_t ino , size_t size , off_t off ,
                           struct fuse_file_info *fi ) 
{ vnode_t *vp ;
  vfs_t *vfs ;
  void *tmp ;
  zfsvfs_t *zfsvfs ;
  char *outbuf ;
  void *tmp___0 ;
  cred_t cred ;
  union __anonunion_entry_63 entry ;
  struct stat fstat___0 ;
  iovec_t iovec ;
  uio_t uio ;
  int eofp ;
  int outbuf_off ;
  int outbuf_resid ;
  off_t next ;
  int error ;
  int dsize ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 371
  vp = ((file_info_t *)((unsigned int )fi->fh))->vp;
#line 372
  if (! ((unsigned int )vp != (unsigned int )((void *)0))) {
#line 372
    __assert_fail("vp != ((void *)0)", "zfs-fuse/zfs_operations.c", 372U, "zfsfuse_readdir");
  }
#line 373
  if (! ((unsigned int )((znode_t *)vp->v_data) != (unsigned int )((void *)0))) {
#line 373
    __assert_fail("((znode_t *)(vp)->v_data) != ((void *)0)", "zfs-fuse/zfs_operations.c",
                  373U, "zfsfuse_readdir");
  }
#line 374
  if (! (((znode_t *)vp->v_data)->z_id == (uint64_t )ino)) {
#line 374
    __assert_fail("((znode_t *)(vp)->v_data)->z_id == ino", "zfs-fuse/zfs_operations.c",
                  374U, "zfsfuse_readdir");
  }
#line 376
  if ((int )vp->v_type != 2) {
#line 377
    return (20);
  }
#line 379
  tmp = fuse_req_userdata(req);
#line 379
  vfs = (vfs_t *)tmp;
#line 380
  zfsvfs = (zfsvfs_t *)vfs->vfs_data;
#line 382
  tmp___0 = umem_alloc(size, 0);
#line 382
  outbuf = (char *)tmp___0;
#line 383
  if ((unsigned int )outbuf == (unsigned int )((void *)0)) {
#line 384
    return (12);
  }
#line 386
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 386
  if (zfsvfs->z_unmounted1) {
#line 386
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 386
    return (5);
  }
#line 389
  zfsfuse_getcred(req, & cred);
#line 396
  fstat___0.st_dev = (__dev_t )0;
#line 396
  fstat___0.__pad1 = (unsigned short)0;
#line 396
  fstat___0.__st_ino = 0UL;
#line 396
  fstat___0.st_mode = 0U;
#line 396
  fstat___0.st_nlink = 0U;
#line 396
  fstat___0.st_uid = 0U;
#line 396
  fstat___0.st_gid = 0U;
#line 396
  fstat___0.st_rdev = 0ULL;
#line 396
  fstat___0.__pad2 = (unsigned short)0;
#line 396
  fstat___0.st_size = 0LL;
#line 396
  fstat___0.st_blksize = 0L;
#line 396
  fstat___0.st_blocks = 0LL;
#line 396
  fstat___0.st_atim.tv_sec = 0L;
#line 396
  fstat___0.st_atim.tv_nsec = 0L;
#line 396
  fstat___0.st_mtim.tv_sec = 0L;
#line 396
  fstat___0.st_mtim.tv_nsec = 0L;
#line 396
  fstat___0.st_ctim.tv_sec = 0L;
#line 396
  fstat___0.st_ctim.tv_nsec = 0L;
#line 396
  fstat___0.st_ino = 0ULL;
#line 400
  uio.uio_iov = & iovec;
#line 401
  uio.uio_iovcnt = 1;
#line 402
  uio.uio_segflg = 1;
#line 403
  uio.uio_fmode = (unsigned short)0;
#line 404
  uio._uio_limit._f = -1LL;
#line 406
  eofp = 0;
#line 408
  outbuf_off = 0;
#line 409
  outbuf_resid = (int )size;
#line 411
  next = off;
#line 415
  while (1) {
#line 416
    iovec.iov_base = (void *)(entry.buf);
#line 417
    iovec.iov_len = sizeof(entry.buf);
#line 418
    uio.uio_resid = (int )iovec.iov_len;
#line 419
    uio._uio_offset._f = next;
#line 421
    error = fop_readdir(vp, & uio, & cred, & eofp);
#line 422
    if (error) {
      goto out;
    }
#line 426
    if ((unsigned int )iovec.iov_base == (unsigned int )(entry.buf)) {
#line 427
      break;
    }
#line 429
    fstat___0.st_ino = entry.dirent.d_ino;
#line 430
    fstat___0.st_mode = 0U;
#line 432
    tmp___1 = strlen((char const   *)(entry.dirent.d_name));
#line 432
    tmp___2 = fuse_dirent_size(tmp___1);
#line 432
    dsize = (int )tmp___2;
#line 433
    if (dsize > outbuf_resid) {
#line 434
      break;
    }
#line 436
    fuse_add_dirent(outbuf + outbuf_off, (char const   *)(entry.dirent.d_name), (struct stat  const  *)(& fstat___0),
                    entry.dirent.d_off);
#line 438
    outbuf_off += dsize;
#line 439
    outbuf_resid -= dsize;
#line 440
    next = entry.dirent.d_off;
  }
  out: 
#line 444
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 446
  if (! error) {
#line 447
    fuse_reply_buf(req, (char const   *)outbuf, (unsigned int )outbuf_off);
  }
#line 449
  umem_free((void *)outbuf, size);
#line 451
  return (error);
}
}
#line 454 "zfs-fuse/zfs_operations.c"
static void zfsfuse_readdir_helper(fuse_req_t req , fuse_ino_t ino , size_t size ,
                                   off_t off , struct fuse_file_info *fi ) 
{ fuse_ino_t real_ino ;
  fuse_ino_t tmp ;
  int error ;
  int tmp___0 ;

  {
#line 456
  if (ino == 1UL) {
#line 456
    tmp = 3UL;
  } else {
#line 456
    tmp = ino;
  }
#line 456
  real_ino = tmp;
#line 458
  tmp___0 = zfsfuse_readdir(req, real_ino, size, off, fi);
#line 458
  error = tmp___0;
#line 459
  if (error) {
#line 460
    fuse_reply_err(req, error);
  }
#line 461
  return;
}
}
#line 463 "zfs-fuse/zfs_operations.c"
static int zfsfuse_opencreate(fuse_req_t req , fuse_ino_t ino , struct fuse_file_info *fi ,
                              int fflags , mode_t createmode , char const   *name ) 
{ size_t tmp ;
  vfs_t *vfs ;
  void *tmp___0 ;
  zfsvfs_t *zfsvfs ;
  cred_t cred ;
  int mode ;
  int flags ;
  znode_t *znode ;
  int error ;
  int tmp___1 ;
  vnode_t *vp ;
  enum vcexcl excl ;
  vattr_t vattr ;
  vnode_t *new_vp ;
  vattr_t vattr___0 ;
  vnode_t *old_vp ;
  struct fuse_entry_param e ;
  file_info_t *info ;
  void *tmp___2 ;

  {
#line 465
  if (name) {
#line 465
    tmp = strlen(name);
#line 465
    if (tmp >= 256U) {
#line 466
      return (36);
    }
  }
#line 468
  tmp___0 = fuse_req_userdata(req);
#line 468
  vfs = (vfs_t *)tmp___0;
#line 469
  zfsvfs = (zfsvfs_t *)vfs->vfs_data;
#line 471
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 471
  if (zfsvfs->z_unmounted1) {
#line 471
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 471
    return (5);
  }
#line 474
  zfsfuse_getcred(req, & cred);
#line 479
  if (fflags & 1) {
#line 480
    mode = 128;
#line 481
    flags = 2;
  } else {
#line 482
    if (fflags & 2) {
#line 483
      mode = 384;
#line 484
      flags = 3;
    } else {
#line 486
      mode = 256;
#line 487
      flags = 1;
    }
  }
#line 490
  if (fflags & 64) {
#line 491
    flags |= 64;
  }
#line 492
  if (fflags & 4096) {
#line 493
    flags |= 4096;
  }
#line 494
  if (fflags & 4096) {
#line 495
    flags |= 4096;
  }
#line 496
  if (fflags & 4096) {
#line 497
    flags |= 4096;
  }
#line 498
  if (fflags & 1024) {
#line 499
    flags |= 1024;
  }
#line 500
  if (fflags & 32768) {
#line 501
    flags |= 32768;
  }
#line 502
  if (fflags & 131072) {
#line 503
    flags |= 131072;
  }
#line 504
  if (fflags & 512) {
#line 505
    flags |= 512;
  }
#line 506
  if (fflags & 128) {
#line 507
    flags |= 128;
  }
#line 511
  tmp___1 = zfs_zget(zfsvfs, (unsigned long long )ino, & znode);
#line 511
  error = tmp___1;
#line 512
  if (error) {
#line 513
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 514
    return (error);
  }
#line 517
  if (! ((unsigned int )znode != (unsigned int )((void *)0))) {
#line 517
    __assert_fail("znode != ((void *)0)", "zfs-fuse/zfs_operations.c", 517U, "zfsfuse_opencreate");
  }
#line 518
  vp = znode->z_vnode;
#line 519
  if (! ((unsigned int )vp != (unsigned int )((void *)0))) {
#line 519
    __assert_fail("vp != ((void *)0)", "zfs-fuse/zfs_operations.c", 519U, "zfsfuse_opencreate");
  }
#line 521
  if (flags & 64) {
#line 528
    vattr.va_type = 1;
#line 529
    vattr.va_mode = createmode;
#line 530
    vattr.va_mask = 3U;
#line 531
    if (flags & 512) {
#line 532
      vattr.va_size = 0ULL;
#line 533
      vattr.va_mask |= 128U;
    }
#line 535
    if (flags & 128) {
#line 536
      excl = 1;
    } else {
#line 538
      excl = 0;
    }
#line 542
    error = fop_create(vp, (char *)name, & vattr, excl, mode, & new_vp, & cred, 0);
#line 544
    if (error) {
      goto out;
    }
#line 547
    vn_rele(vp);
#line 548
    vp = new_vp;
  } else {
#line 555
    if (! (flags & 32768)) {
#line 555
      if ((int )vp->v_type == 1) {
#line 557
        vattr___0.va_mask = 128U;
#line 558
        error = fop_getattr(vp, & vattr___0, 0, & cred);
#line 558
        if (error) {
          goto out;
        }
#line 561
        if (vattr___0.va_size > 2147483647ULL) {
#line 566
          error = 75;
          goto out;
        }
      }
    }
#line 574
    error = fop_access(vp, mode, 0, & cred);
#line 574
    if (error) {
      goto out;
    }
  }
#line 578
  if (flags & 131072) {
#line 578
    if ((int )vp->v_type == 5) {
#line 579
      error = 40;
      goto out;
    }
  }
#line 583
  old_vp = vp;
#line 585
  error = fop_open(& vp, flags, & cred);
#line 587
  if (! ((unsigned int )old_vp == (unsigned int )vp)) {
#line 587
    __assert_fail("old_vp == vp", "zfs-fuse/zfs_operations.c", 587U, "zfsfuse_opencreate");
  }
#line 589
  if (error) {
    goto out;
  }
#line 592
  e.ino = (fuse_ino_t )0;
#line 592
  e.generation = 0UL;
#line 592
  e.attr.st_dev = 0ULL;
#line 592
  e.attr.__pad1 = (unsigned short)0;
#line 592
  e.attr.__st_ino = 0UL;
#line 592
  e.attr.st_mode = 0U;
#line 592
  e.attr.st_nlink = 0U;
#line 592
  e.attr.st_uid = 0U;
#line 592
  e.attr.st_gid = 0U;
#line 592
  e.attr.st_rdev = 0ULL;
#line 592
  e.attr.__pad2 = (unsigned short)0;
#line 592
  e.attr.st_size = 0LL;
#line 592
  e.attr.st_blksize = 0L;
#line 592
  e.attr.st_blocks = 0LL;
#line 592
  e.attr.st_atim.tv_sec = 0L;
#line 592
  e.attr.st_atim.tv_nsec = 0L;
#line 592
  e.attr.st_mtim.tv_sec = 0L;
#line 592
  e.attr.st_mtim.tv_nsec = 0L;
#line 592
  e.attr.st_ctim.tv_sec = 0L;
#line 592
  e.attr.st_ctim.tv_nsec = 0L;
#line 592
  e.attr.st_ino = 0ULL;
#line 592
  e.attr_timeout = 0.;
#line 592
  e.entry_timeout = 0.;
#line 594
  if (flags & 64) {
#line 595
    error = zfsfuse_stat(vp, & e.attr, & cred);
#line 596
    if (error) {
      goto out;
    }
  }
#line 600
  tmp___2 = umem_cache_alloc(file_info_cache, 0);
#line 600
  info = (file_info_t *)tmp___2;
#line 601
  if ((unsigned int )info == (unsigned int )((void *)0)) {
#line 602
    error = 12;
    goto out;
  }
#line 606
  info->vp = vp;
#line 607
  info->flags = flags;
#line 609
  fi->fh = (unsigned long long )((unsigned int )info);
#line 610
  fi->keep_cache = 1U;
#line 612
  if (flags & 64) {
#line 613
    e.attr_timeout = 0.0;
#line 614
    e.entry_timeout = 0.0;
#line 615
    e.ino = (unsigned long )((znode_t *)vp->v_data)->z_id;
#line 616
    if (e.ino == 3UL) {
#line 617
      e.ino = 1UL;
    }
#line 618
    e.generation = (unsigned long )(((znode_t *)vp->v_data)->z_phys)->zp_gen;
  }
  out: 
#line 622
  if (error) {
#line 623
    if (! (vp->v_count > 0U)) {
#line 623
      __assert_fail("vp->v_count > 0", "zfs-fuse/zfs_operations.c", 623U, "zfsfuse_opencreate");
    }
#line 624
    vn_rele(vp);
  }
#line 627
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 629
  if (! error) {
#line 630
    if (! (flags & 64)) {
#line 631
      fuse_reply_open(req, (struct fuse_file_info  const  *)fi);
    } else {
#line 633
      fuse_reply_create(req, (struct fuse_entry_param  const  *)(& e), (struct fuse_file_info  const  *)fi);
    }
  }
#line 635
  return (error);
}
}
#line 638 "zfs-fuse/zfs_operations.c"
static void zfsfuse_open_helper(fuse_req_t req , fuse_ino_t ino , struct fuse_file_info *fi ) 
{ fuse_ino_t real_ino ;
  fuse_ino_t tmp ;
  int error ;
  int tmp___0 ;

  {
#line 640
  if (ino == 1UL) {
#line 640
    tmp = 3UL;
  } else {
#line 640
    tmp = ino;
  }
#line 640
  real_ino = tmp;
#line 642
  tmp___0 = zfsfuse_opencreate(req, real_ino, fi, fi->flags, 0U, (char const   *)((void *)0));
#line 642
  error = tmp___0;
#line 643
  if (error) {
#line 644
    fuse_reply_err(req, error);
  }
#line 645
  return;
}
}
#line 647 "zfs-fuse/zfs_operations.c"
static void zfsfuse_create_helper(fuse_req_t req , fuse_ino_t parent , char const   *name ,
                                  mode_t mode , struct fuse_file_info *fi ) 
{ fuse_ino_t real_parent ;
  fuse_ino_t tmp ;
  int error ;
  int tmp___0 ;

  {
#line 649
  if (parent == 1UL) {
#line 649
    tmp = 3UL;
  } else {
#line 649
    tmp = parent;
  }
#line 649
  real_parent = tmp;
#line 651
  tmp___0 = zfsfuse_opencreate(req, real_parent, fi, fi->flags | 64, mode, name);
#line 651
  error = tmp___0;
#line 652
  if (error) {
#line 653
    fuse_reply_err(req, error);
  }
#line 654
  return;
}
}
#line 656 "zfs-fuse/zfs_operations.c"
static int zfsfuse_readlink(fuse_req_t req , fuse_ino_t ino ) 
{ vfs_t *vfs ;
  void *tmp ;
  zfsvfs_t *zfsvfs ;
  znode_t *znode ;
  int error ;
  int tmp___0 ;
  int tmp___1 ;
  vnode_t *vp ;
  char buffer[4097] ;
  iovec_t iovec ;
  uio_t uio ;
  cred_t cred ;

  {
#line 658
  tmp = fuse_req_userdata(req);
#line 658
  vfs = (vfs_t *)tmp;
#line 659
  zfsvfs = (zfsvfs_t *)vfs->vfs_data;
#line 661
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 661
  if (zfsvfs->z_unmounted1) {
#line 661
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 661
    return (5);
  }
#line 665
  tmp___0 = zfs_zget(zfsvfs, (unsigned long long )ino, & znode);
#line 665
  error = tmp___0;
#line 666
  if (error) {
#line 667
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 670
    if (error == 17) {
#line 670
      tmp___1 = 2;
    } else {
#line 670
      tmp___1 = error;
    }
#line 670
    return (tmp___1);
  }
#line 673
  if (! ((unsigned int )znode != (unsigned int )((void *)0))) {
#line 673
    __assert_fail("znode != ((void *)0)", "zfs-fuse/zfs_operations.c", 673U, "zfsfuse_readlink");
  }
#line 674
  vp = znode->z_vnode;
#line 675
  if (! ((unsigned int )vp != (unsigned int )((void *)0))) {
#line 675
    __assert_fail("vp != ((void *)0)", "zfs-fuse/zfs_operations.c", 675U, "zfsfuse_readlink");
  }
#line 681
  uio.uio_iov = & iovec;
#line 682
  uio.uio_iovcnt = 1;
#line 683
  uio.uio_segflg = 1;
#line 684
  uio.uio_fmode = (unsigned short)0;
#line 685
  uio._uio_limit._f = -1LL;
#line 686
  iovec.iov_base = (void *)(buffer);
#line 687
  iovec.iov_len = sizeof(buffer) - 1U;
#line 688
  uio.uio_resid = (int )iovec.iov_len;
#line 689
  uio._uio_offset._f = 0LL;
#line 692
  zfsfuse_getcred(req, & cred);
#line 694
  error = fop_readlink(vp, & uio, & cred);
#line 696
  vn_rele(vp);
#line 697
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 699
  if (! error) {
#line 700
    while (1) {
#line 700
      if (! (uio._uio_offset._f < (offset_t )sizeof(buffer))) {
#line 700
        while (1) {
#line 700
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                  "zfs-fuse/zfs_operations.c", 700, "zfsfuse_readlink", "uio.uio_loffset < sizeof(buffer)");
#line 700
          abort();
#line 700
          break;
        }
      }
#line 700
      break;
    }
#line 701
    buffer[uio._uio_offset._f] = (char )'\000';
#line 702
    fuse_reply_readlink(req, (char const   *)(buffer));
  }
#line 705
  return (error);
}
}
#line 708 "zfs-fuse/zfs_operations.c"
static void zfsfuse_readlink_helper(fuse_req_t req , fuse_ino_t ino ) 
{ fuse_ino_t real_ino ;
  fuse_ino_t tmp ;
  int error ;
  int tmp___0 ;

  {
#line 710
  if (ino == 1UL) {
#line 710
    tmp = 3UL;
  } else {
#line 710
    tmp = ino;
  }
#line 710
  real_ino = tmp;
#line 712
  tmp___0 = zfsfuse_readlink(req, real_ino);
#line 712
  error = tmp___0;
#line 713
  if (error) {
#line 714
    fuse_reply_err(req, error);
  }
#line 715
  return;
}
}
#line 717 "zfs-fuse/zfs_operations.c"
static int zfsfuse_read(fuse_req_t req , fuse_ino_t ino , size_t size , off_t off ,
                        struct fuse_file_info *fi ) 
{ file_info_t *info ;
  vnode_t *vp ;
  vfs_t *vfs ;
  void *tmp ;
  zfsvfs_t *zfsvfs ;
  char *outbuf ;
  void *tmp___0 ;
  iovec_t iovec ;
  uio_t uio ;
  cred_t cred ;
  int error ;
  int tmp___1 ;

  {
#line 719
  info = (file_info_t *)((unsigned int )fi->fh);
#line 721
  vp = info->vp;
#line 722
  if (! ((unsigned int )vp != (unsigned int )((void *)0))) {
#line 722
    __assert_fail("vp != ((void *)0)", "zfs-fuse/zfs_operations.c", 722U, "zfsfuse_read");
  }
#line 723
  if (! ((unsigned int )((znode_t *)vp->v_data) != (unsigned int )((void *)0))) {
#line 723
    __assert_fail("((znode_t *)(vp)->v_data) != ((void *)0)", "zfs-fuse/zfs_operations.c",
                  723U, "zfsfuse_read");
  }
#line 724
  if (! (((znode_t *)vp->v_data)->z_id == (uint64_t )ino)) {
#line 724
    __assert_fail("((znode_t *)(vp)->v_data)->z_id == ino", "zfs-fuse/zfs_operations.c",
                  724U, "zfsfuse_read");
  }
#line 726
  tmp = fuse_req_userdata(req);
#line 726
  vfs = (vfs_t *)tmp;
#line 727
  zfsvfs = (zfsvfs_t *)vfs->vfs_data;
#line 729
  tmp___0 = umem_alloc(size, 0);
#line 729
  outbuf = (char *)tmp___0;
#line 730
  if ((unsigned int )outbuf == (unsigned int )((void *)0)) {
#line 731
    return (12);
  }
#line 733
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 733
  if (zfsvfs->z_unmounted1) {
#line 733
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 733
    return (5);
  }
#line 737
  uio.uio_iov = & iovec;
#line 738
  uio.uio_iovcnt = 1;
#line 739
  uio.uio_segflg = 1;
#line 740
  uio.uio_fmode = (unsigned short)0;
#line 741
  uio._uio_limit._f = -1LL;
#line 743
  iovec.iov_base = (void *)outbuf;
#line 744
  iovec.iov_len = size;
#line 745
  uio.uio_resid = (int )iovec.iov_len;
#line 746
  uio._uio_offset._f = off;
#line 749
  zfsfuse_getcred(req, & cred);
#line 751
  tmp___1 = fop_read(vp, & uio, info->flags, & cred, (caller_context_t *)((void *)0));
#line 751
  error = tmp___1;
#line 753
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 755
  if (! error) {
#line 756
    fuse_reply_buf(req, (char const   *)outbuf, (unsigned int )(uio._uio_offset._f - off));
  }
#line 758
  umem_free((void *)outbuf, size);
#line 760
  return (error);
}
}
#line 763 "zfs-fuse/zfs_operations.c"
static void zfsfuse_read_helper(fuse_req_t req , fuse_ino_t ino , size_t size , off_t off ,
                                struct fuse_file_info *fi ) 
{ fuse_ino_t real_ino ;
  fuse_ino_t tmp ;
  int error ;
  int tmp___0 ;

  {
#line 765
  if (ino == 1UL) {
#line 765
    tmp = 3UL;
  } else {
#line 765
    tmp = ino;
  }
#line 765
  real_ino = tmp;
#line 767
  tmp___0 = zfsfuse_read(req, real_ino, size, off, fi);
#line 767
  error = tmp___0;
#line 768
  if (error) {
#line 769
    fuse_reply_err(req, error);
  }
#line 770
  return;
}
}
#line 772 "zfs-fuse/zfs_operations.c"
static int zfsfuse_mkdir(fuse_req_t req , fuse_ino_t parent , char const   *name ,
                         mode_t mode ) 
{ size_t tmp ;
  vfs_t *vfs ;
  void *tmp___0 ;
  zfsvfs_t *zfsvfs ;
  znode_t *znode ;
  int error ;
  int tmp___1 ;
  vnode_t *dvp ;
  vnode_t *vp ;
  vattr_t vattr ;
  cred_t cred ;
  struct fuse_entry_param e ;

  {
#line 774
  tmp = strlen(name);
#line 774
  if (tmp >= 256U) {
#line 775
    return (36);
  }
#line 777
  tmp___0 = fuse_req_userdata(req);
#line 777
  vfs = (vfs_t *)tmp___0;
#line 778
  zfsvfs = (zfsvfs_t *)vfs->vfs_data;
#line 780
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 780
  if (zfsvfs->z_unmounted1) {
#line 780
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 780
    return (5);
  }
#line 784
  tmp___1 = zfs_zget(zfsvfs, (unsigned long long )parent, & znode);
#line 784
  error = tmp___1;
#line 785
  if (error) {
#line 786
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 787
    return (error);
  }
#line 790
  if (! ((unsigned int )znode != (unsigned int )((void *)0))) {
#line 790
    __assert_fail("znode != ((void *)0)", "zfs-fuse/zfs_operations.c", 790U, "zfsfuse_mkdir");
  }
#line 791
  dvp = znode->z_vnode;
#line 792
  if (! ((unsigned int )dvp != (unsigned int )((void *)0))) {
#line 792
    __assert_fail("dvp != ((void *)0)", "zfs-fuse/zfs_operations.c", 792U, "zfsfuse_mkdir");
  }
#line 794
  vp = (vnode_t *)((void *)0);
#line 796
  vattr.va_mask = (uint_t )0;
#line 796
  vattr.va_type = 0;
#line 796
  vattr.va_mode = 0U;
#line 796
  vattr.va_uid = 0U;
#line 796
  vattr.va_gid = 0U;
#line 796
  vattr.va_fsid = 0ULL;
#line 796
  vattr.va_nodeid = 0ULL;
#line 796
  vattr.va_nlink = 0U;
#line 796
  vattr.va_size = 0ULL;
#line 796
  vattr.va_atime.tv_sec = 0L;
#line 796
  vattr.va_atime.tv_nsec = 0L;
#line 796
  vattr.va_mtime.tv_sec = 0L;
#line 796
  vattr.va_mtime.tv_nsec = 0L;
#line 796
  vattr.va_ctime.tv_sec = 0L;
#line 796
  vattr.va_ctime.tv_nsec = 0L;
#line 796
  vattr.va_rdev = 0ULL;
#line 796
  vattr.va_blksize = 0U;
#line 796
  vattr.va_nblocks = 0ULL;
#line 796
  vattr.va_seq = 0U;
#line 797
  vattr.va_type = 2;
#line 798
  vattr.va_mode = mode & 511U;
#line 799
  vattr.va_mask = 3U;
#line 802
  zfsfuse_getcred(req, & cred);
#line 804
  error = fop_mkdir(dvp, (char *)name, & vattr, & vp, & cred);
#line 805
  if (error) {
    goto out;
  }
#line 808
  if (! ((unsigned int )vp != (unsigned int )((void *)0))) {
#line 808
    __assert_fail("vp != ((void *)0)", "zfs-fuse/zfs_operations.c", 808U, "zfsfuse_mkdir");
  }
#line 810
  e.ino = (fuse_ino_t )0;
#line 810
  e.generation = 0UL;
#line 810
  e.attr.st_dev = 0ULL;
#line 810
  e.attr.__pad1 = (unsigned short)0;
#line 810
  e.attr.__st_ino = 0UL;
#line 810
  e.attr.st_mode = 0U;
#line 810
  e.attr.st_nlink = 0U;
#line 810
  e.attr.st_uid = 0U;
#line 810
  e.attr.st_gid = 0U;
#line 810
  e.attr.st_rdev = 0ULL;
#line 810
  e.attr.__pad2 = (unsigned short)0;
#line 810
  e.attr.st_size = 0LL;
#line 810
  e.attr.st_blksize = 0L;
#line 810
  e.attr.st_blocks = 0LL;
#line 810
  e.attr.st_atim.tv_sec = 0L;
#line 810
  e.attr.st_atim.tv_nsec = 0L;
#line 810
  e.attr.st_mtim.tv_sec = 0L;
#line 810
  e.attr.st_mtim.tv_nsec = 0L;
#line 810
  e.attr.st_ctim.tv_sec = 0L;
#line 810
  e.attr.st_ctim.tv_nsec = 0L;
#line 810
  e.attr.st_ino = 0ULL;
#line 810
  e.attr_timeout = 0.;
#line 810
  e.entry_timeout = 0.;
#line 812
  e.attr_timeout = 0.0;
#line 813
  e.entry_timeout = 0.0;
#line 815
  e.ino = (unsigned long )((znode_t *)vp->v_data)->z_id;
#line 816
  if (e.ino == 3UL) {
#line 817
    e.ino = 1UL;
  }
#line 819
  e.generation = (unsigned long )(((znode_t *)vp->v_data)->z_phys)->zp_gen;
#line 821
  error = zfsfuse_stat(vp, & e.attr, & cred);
  out: 
#line 824
  if ((unsigned int )vp != (unsigned int )((void *)0)) {
#line 825
    vn_rele(vp);
  }
#line 826
  vn_rele(dvp);
#line 827
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 829
  if (! error) {
#line 830
    fuse_reply_entry(req, (struct fuse_entry_param  const  *)(& e));
  }
#line 832
  return (error);
}
}
#line 835 "zfs-fuse/zfs_operations.c"
static void zfsfuse_mkdir_helper(fuse_req_t req , fuse_ino_t parent , char const   *name ,
                                 mode_t mode ) 
{ fuse_ino_t real_parent ;
  fuse_ino_t tmp ;
  int error ;
  int tmp___0 ;

  {
#line 837
  if (parent == 1UL) {
#line 837
    tmp = 3UL;
  } else {
#line 837
    tmp = parent;
  }
#line 837
  real_parent = tmp;
#line 839
  tmp___0 = zfsfuse_mkdir(req, real_parent, name, mode);
#line 839
  error = tmp___0;
#line 840
  if (error) {
#line 841
    fuse_reply_err(req, error);
  }
#line 842
  return;
}
}
#line 844 "zfs-fuse/zfs_operations.c"
static int zfsfuse_rmdir(fuse_req_t req , fuse_ino_t parent , char const   *name ) 
{ size_t tmp ;
  vfs_t *vfs ;
  void *tmp___0 ;
  zfsvfs_t *zfsvfs ;
  znode_t *znode ;
  int error ;
  int tmp___1 ;
  int tmp___2 ;
  vnode_t *dvp ;
  cred_t cred ;

  {
#line 846
  tmp = strlen(name);
#line 846
  if (tmp >= 256U) {
#line 847
    return (36);
  }
#line 849
  tmp___0 = fuse_req_userdata(req);
#line 849
  vfs = (vfs_t *)tmp___0;
#line 850
  zfsvfs = (zfsvfs_t *)vfs->vfs_data;
#line 852
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 852
  if (zfsvfs->z_unmounted1) {
#line 852
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 852
    return (5);
  }
#line 856
  tmp___1 = zfs_zget(zfsvfs, (unsigned long long )parent, & znode);
#line 856
  error = tmp___1;
#line 857
  if (error) {
#line 858
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 861
    if (error == 17) {
#line 861
      tmp___2 = 2;
    } else {
#line 861
      tmp___2 = error;
    }
#line 861
    return (tmp___2);
  }
#line 864
  if (! ((unsigned int )znode != (unsigned int )((void *)0))) {
#line 864
    __assert_fail("znode != ((void *)0)", "zfs-fuse/zfs_operations.c", 864U, "zfsfuse_rmdir");
  }
#line 865
  dvp = znode->z_vnode;
#line 866
  if (! ((unsigned int )dvp != (unsigned int )((void *)0))) {
#line 866
    __assert_fail("dvp != ((void *)0)", "zfs-fuse/zfs_operations.c", 866U, "zfsfuse_rmdir");
  }
#line 869
  zfsfuse_getcred(req, & cred);
#line 873
  error = fop_rmdir(dvp, (char *)name, (vnode_t *)((void *)0), & cred);
#line 875
  vn_rele(dvp);
#line 876
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 878
  return (error);
}
}
#line 881 "zfs-fuse/zfs_operations.c"
static void zfsfuse_rmdir_helper(fuse_req_t req , fuse_ino_t parent , char const   *name ) 
{ fuse_ino_t real_parent ;
  fuse_ino_t tmp ;
  int error ;
  int tmp___0 ;

  {
#line 883
  if (parent == 1UL) {
#line 883
    tmp = 3UL;
  } else {
#line 883
    tmp = parent;
  }
#line 883
  real_parent = tmp;
#line 885
  tmp___0 = zfsfuse_rmdir(req, real_parent, name);
#line 885
  error = tmp___0;
#line 887
  fuse_reply_err(req, error);
#line 888
  return;
}
}
#line 890 "zfs-fuse/zfs_operations.c"
static int zfsfuse_setattr(fuse_req_t req , fuse_ino_t ino , struct stat *attr , int to_set ,
                           struct fuse_file_info *fi ) 
{ vfs_t *vfs ;
  void *tmp ;
  zfsvfs_t *zfsvfs ;
  vnode_t *vp ;
  boolean_t release ;
  int error ;
  cred_t cred ;
  znode_t *znode ;
  int tmp___0 ;
  file_info_t *info ;
  flock64_t bf ;
  vattr_t vattr ;
  int flags ;
  int tmp___1 ;
  struct stat stat_reply ;

  {
#line 892
  tmp = fuse_req_userdata(req);
#line 892
  vfs = (vfs_t *)tmp;
#line 893
  zfsvfs = (zfsvfs_t *)vfs->vfs_data;
#line 895
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 895
  if (zfsvfs->z_unmounted1) {
#line 895
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 895
    return (5);
  }
#line 903
  zfsfuse_getcred(req, & cred);
#line 905
  if ((unsigned int )fi == (unsigned int )((void *)0)) {
#line 908
    error = zfs_zget(zfsvfs, (unsigned long long )ino, & znode);
#line 909
    if (error) {
#line 910
      atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 913
      if (error == 17) {
#line 913
        tmp___0 = 2;
      } else {
#line 913
        tmp___0 = error;
      }
#line 913
      return (tmp___0);
    }
#line 915
    if (! ((unsigned int )znode != (unsigned int )((void *)0))) {
#line 915
      __assert_fail("znode != ((void *)0)", "zfs-fuse/zfs_operations.c", 915U, "zfsfuse_setattr");
    }
#line 916
    vp = znode->z_vnode;
#line 917
    release = 1;
  } else {
#line 919
    info = (file_info_t *)((unsigned int )fi->fh);
#line 920
    vp = info->vp;
#line 921
    release = 0;
#line 930
    if (to_set & (1 << 3)) {
#line 932
      if ((info->flags & 2) == 0) {
#line 933
        error = 9;
        goto out;
      }
#line 937
      if ((int )vp->v_type != 1) {
#line 938
        error = 22;
        goto out;
      }
#line 944
      bf.l_whence = (short)0;
#line 945
      bf.l_start = attr->st_size;
#line 946
      bf.l_type = (short)1;
#line 947
      bf.l_len = 0LL;
#line 950
      error = fop_space(vp, 27, & bf, info->flags, 0LL, & cred, (caller_context_t *)((void *)0));
#line 951
      if (error) {
        goto out;
      }
#line 954
      to_set &= ~ (1 << 3);
#line 955
      if (to_set == 0) {
        goto out;
      }
    }
  }
#line 960
  if (! ((unsigned int )vp != (unsigned int )((void *)0))) {
#line 960
    __assert_fail("vp != ((void *)0)", "zfs-fuse/zfs_operations.c", 960U, "zfsfuse_setattr");
  }
#line 962
  vattr.va_mask = (uint_t )0;
#line 962
  vattr.va_type = 0;
#line 962
  vattr.va_mode = 0U;
#line 962
  vattr.va_uid = 0U;
#line 962
  vattr.va_gid = 0U;
#line 962
  vattr.va_fsid = 0ULL;
#line 962
  vattr.va_nodeid = 0ULL;
#line 962
  vattr.va_nlink = 0U;
#line 962
  vattr.va_size = 0ULL;
#line 962
  vattr.va_atime.tv_sec = 0L;
#line 962
  vattr.va_atime.tv_nsec = 0L;
#line 962
  vattr.va_mtime.tv_sec = 0L;
#line 962
  vattr.va_mtime.tv_nsec = 0L;
#line 962
  vattr.va_ctime.tv_sec = 0L;
#line 962
  vattr.va_ctime.tv_nsec = 0L;
#line 962
  vattr.va_rdev = 0ULL;
#line 962
  vattr.va_blksize = 0U;
#line 962
  vattr.va_nblocks = 0ULL;
#line 962
  vattr.va_seq = 0U;
#line 964
  if (to_set & 1) {
#line 965
    vattr.va_mask |= 2U;
#line 966
    vattr.va_mode = attr->st_mode;
  }
#line 968
  if (to_set & (1 << 1)) {
#line 969
    vattr.va_mask |= 4U;
#line 970
    vattr.va_uid = attr->st_uid;
  }
#line 972
  if (to_set & (1 << 2)) {
#line 973
    vattr.va_mask |= 8U;
#line 974
    vattr.va_gid = attr->st_gid;
  }
#line 976
  if (to_set & (1 << 3)) {
#line 977
    vattr.va_mask |= 128U;
#line 978
    vattr.va_size = (unsigned long long )attr->st_size;
  }
#line 980
  if (to_set & (1 << 4)) {
#line 981
    vattr.va_mask |= 256U;
#line 982
    while (1) {
#line 982
      vattr.va_atime.tv_sec = attr->st_atim.tv_sec;
#line 982
      vattr.va_atime.tv_nsec = 0L;
#line 982
      break;
    }
  }
#line 984
  if (to_set & (1 << 5)) {
#line 985
    vattr.va_mask |= 512U;
#line 986
    while (1) {
#line 986
      vattr.va_mtime.tv_sec = attr->st_mtim.tv_sec;
#line 986
      vattr.va_mtime.tv_nsec = 0L;
#line 986
      break;
    }
  }
#line 989
  if (to_set & ((1 << 4) | (1 << 5))) {
#line 989
    tmp___1 = 1;
  } else {
#line 989
    tmp___1 = 0;
  }
#line 989
  flags = tmp___1;
#line 990
  error = fop_setattr(vp, & vattr, flags, & cred, (caller_context_t *)((void *)0));
  out: ;
#line 995
  if (! error) {
#line 996
    error = zfsfuse_stat(vp, & stat_reply, & cred);
  }
#line 999
  if (release) {
#line 1000
    vn_rele(vp);
  }
#line 1002
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1004
  if (! error) {
#line 1005
    fuse_reply_attr(req, (struct stat  const  *)(& stat_reply), 0.0);
  }
#line 1007
  return (error);
}
}
#line 1010 "zfs-fuse/zfs_operations.c"
static void zfsfuse_setattr_helper(fuse_req_t req , fuse_ino_t ino , struct stat *attr ,
                                   int to_set , struct fuse_file_info *fi ) 
{ fuse_ino_t real_ino ;
  fuse_ino_t tmp ;
  int error ;
  int tmp___0 ;

  {
#line 1012
  if (ino == 1UL) {
#line 1012
    tmp = 3UL;
  } else {
#line 1012
    tmp = ino;
  }
#line 1012
  real_ino = tmp;
#line 1014
  tmp___0 = zfsfuse_setattr(req, real_ino, attr, to_set, fi);
#line 1014
  error = tmp___0;
#line 1015
  if (error) {
#line 1016
    fuse_reply_err(req, error);
  }
#line 1017
  return;
}
}
#line 1019 "zfs-fuse/zfs_operations.c"
static int zfsfuse_unlink(fuse_req_t req , fuse_ino_t parent , char const   *name ) 
{ size_t tmp ;
  vfs_t *vfs ;
  void *tmp___0 ;
  zfsvfs_t *zfsvfs ;
  znode_t *znode ;
  int error ;
  int tmp___1 ;
  int tmp___2 ;
  vnode_t *dvp ;
  cred_t cred ;

  {
#line 1021
  tmp = strlen(name);
#line 1021
  if (tmp >= 256U) {
#line 1022
    return (36);
  }
#line 1024
  tmp___0 = fuse_req_userdata(req);
#line 1024
  vfs = (vfs_t *)tmp___0;
#line 1025
  zfsvfs = (zfsvfs_t *)vfs->vfs_data;
#line 1027
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 1027
  if (zfsvfs->z_unmounted1) {
#line 1027
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1027
    return (5);
  }
#line 1031
  tmp___1 = zfs_zget(zfsvfs, (unsigned long long )parent, & znode);
#line 1031
  error = tmp___1;
#line 1032
  if (error) {
#line 1033
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1036
    if (error == 17) {
#line 1036
      tmp___2 = 2;
    } else {
#line 1036
      tmp___2 = error;
    }
#line 1036
    return (tmp___2);
  }
#line 1039
  if (! ((unsigned int )znode != (unsigned int )((void *)0))) {
#line 1039
    __assert_fail("znode != ((void *)0)", "zfs-fuse/zfs_operations.c", 1039U, "zfsfuse_unlink");
  }
#line 1040
  dvp = znode->z_vnode;
#line 1041
  if (! ((unsigned int )dvp != (unsigned int )((void *)0))) {
#line 1041
    __assert_fail("dvp != ((void *)0)", "zfs-fuse/zfs_operations.c", 1041U, "zfsfuse_unlink");
  }
#line 1044
  zfsfuse_getcred(req, & cred);
#line 1046
  error = fop_remove(dvp, (char *)name, & cred);
#line 1048
  vn_rele(dvp);
#line 1049
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1051
  return (error);
}
}
#line 1054 "zfs-fuse/zfs_operations.c"
static void zfsfuse_unlink_helper(fuse_req_t req , fuse_ino_t parent , char const   *name ) 
{ fuse_ino_t real_parent ;
  fuse_ino_t tmp ;
  int error ;
  int tmp___0 ;

  {
#line 1056
  if (parent == 1UL) {
#line 1056
    tmp = 3UL;
  } else {
#line 1056
    tmp = parent;
  }
#line 1056
  real_parent = tmp;
#line 1058
  tmp___0 = zfsfuse_unlink(req, real_parent, name);
#line 1058
  error = tmp___0;
#line 1060
  fuse_reply_err(req, error);
#line 1061
  return;
}
}
#line 1063 "zfs-fuse/zfs_operations.c"
static int zfsfuse_write(fuse_req_t req , fuse_ino_t ino , char const   *buf , size_t size ,
                         off_t off , struct fuse_file_info *fi ) 
{ file_info_t *info ;
  vnode_t *vp ;
  vfs_t *vfs ;
  void *tmp ;
  zfsvfs_t *zfsvfs ;
  iovec_t iovec ;
  uio_t uio ;
  cred_t cred ;
  int error ;
  int tmp___0 ;

  {
#line 1065
  info = (file_info_t *)((unsigned int )fi->fh);
#line 1067
  vp = info->vp;
#line 1068
  if (! ((unsigned int )vp != (unsigned int )((void *)0))) {
#line 1068
    __assert_fail("vp != ((void *)0)", "zfs-fuse/zfs_operations.c", 1068U, "zfsfuse_write");
  }
#line 1069
  if (! ((unsigned int )((znode_t *)vp->v_data) != (unsigned int )((void *)0))) {
#line 1069
    __assert_fail("((znode_t *)(vp)->v_data) != ((void *)0)", "zfs-fuse/zfs_operations.c",
                  1069U, "zfsfuse_write");
  }
#line 1070
  if (! (((znode_t *)vp->v_data)->z_id == (uint64_t )ino)) {
#line 1070
    __assert_fail("((znode_t *)(vp)->v_data)->z_id == ino", "zfs-fuse/zfs_operations.c",
                  1070U, "zfsfuse_write");
  }
#line 1072
  tmp = fuse_req_userdata(req);
#line 1072
  vfs = (vfs_t *)tmp;
#line 1073
  zfsvfs = (zfsvfs_t *)vfs->vfs_data;
#line 1075
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 1075
  if (zfsvfs->z_unmounted1) {
#line 1075
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1075
    return (5);
  }
#line 1079
  uio.uio_iov = & iovec;
#line 1080
  uio.uio_iovcnt = 1;
#line 1081
  uio.uio_segflg = 1;
#line 1082
  uio.uio_fmode = (unsigned short)0;
#line 1083
  uio._uio_limit._f = -1LL;
#line 1085
  iovec.iov_base = (void *)buf;
#line 1086
  iovec.iov_len = size;
#line 1087
  uio.uio_resid = (int )iovec.iov_len;
#line 1088
  uio._uio_offset._f = off;
#line 1091
  zfsfuse_getcred(req, & cred);
#line 1093
  tmp___0 = fop_write(vp, & uio, info->flags, & cred, (caller_context_t *)((void *)0));
#line 1093
  error = tmp___0;
#line 1095
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1097
  if (! error) {
#line 1099
    while (1) {
#line 1099
      if (! (uio.uio_resid == 0)) {
#line 1099
        while (1) {
#line 1099
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%i: %s: Assertion `%s` failed.\n",
                  "zfs-fuse/zfs_operations.c", 1099, "zfsfuse_write", "uio.uio_resid == 0");
#line 1099
          abort();
#line 1099
          break;
        }
      }
#line 1099
      break;
    }
#line 1100
    fuse_reply_write(req, size - (size_t )uio.uio_resid);
  }
#line 1103
  return (error);
}
}
#line 1106 "zfs-fuse/zfs_operations.c"
static void zfsfuse_write_helper(fuse_req_t req , fuse_ino_t ino , char const   *buf ,
                                 size_t size , off_t off , struct fuse_file_info *fi ) 
{ fuse_ino_t real_ino ;
  fuse_ino_t tmp ;
  int error ;
  int tmp___0 ;

  {
#line 1108
  if (ino == 1UL) {
#line 1108
    tmp = 3UL;
  } else {
#line 1108
    tmp = ino;
  }
#line 1108
  real_ino = tmp;
#line 1110
  tmp___0 = zfsfuse_write(req, real_ino, buf, size, off, fi);
#line 1110
  error = tmp___0;
#line 1111
  if (error) {
#line 1112
    fuse_reply_err(req, error);
  }
#line 1113
  return;
}
}
#line 1115 "zfs-fuse/zfs_operations.c"
static int zfsfuse_mknod(fuse_req_t req , fuse_ino_t parent , char const   *name ,
                         mode_t mode , dev_t rdev ) 
{ size_t tmp ;
  vfs_t *vfs ;
  void *tmp___0 ;
  zfsvfs_t *zfsvfs ;
  znode_t *znode ;
  int error ;
  int tmp___1 ;
  vnode_t *dvp ;
  cred_t cred ;
  vattr_t vattr ;
  vnode_t *vp ;
  struct fuse_entry_param e ;

  {
#line 1117
  tmp = strlen(name);
#line 1117
  if (tmp >= 256U) {
#line 1118
    return (36);
  }
#line 1120
  tmp___0 = fuse_req_userdata(req);
#line 1120
  vfs = (vfs_t *)tmp___0;
#line 1121
  zfsvfs = (zfsvfs_t *)vfs->vfs_data;
#line 1123
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 1123
  if (zfsvfs->z_unmounted1) {
#line 1123
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1123
    return (5);
  }
#line 1127
  tmp___1 = zfs_zget(zfsvfs, (unsigned long long )parent, & znode);
#line 1127
  error = tmp___1;
#line 1128
  if (error) {
#line 1129
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1130
    return (error);
  }
#line 1133
  if (! ((unsigned int )znode != (unsigned int )((void *)0))) {
#line 1133
    __assert_fail("znode != ((void *)0)", "zfs-fuse/zfs_operations.c", 1133U, "zfsfuse_mknod");
  }
#line 1134
  dvp = znode->z_vnode;
#line 1135
  if (! ((unsigned int )dvp != (unsigned int )((void *)0))) {
#line 1135
    __assert_fail("dvp != ((void *)0)", "zfs-fuse/zfs_operations.c", 1135U, "zfsfuse_mknod");
  }
#line 1138
  zfsfuse_getcred(req, & cred);
#line 1141
  vattr.va_type = iftovt_tab[(mode & 61440U) >> 12];
#line 1142
  vattr.va_mode = mode & 511U;
#line 1143
  vattr.va_mask = 3U;
#line 1145
  if (mode & 24576U) {
#line 1146
    vattr.va_rdev = rdev;
#line 1147
    vattr.va_mask |= 2048U;
  }
#line 1150
  vp = (vnode_t *)((void *)0);
#line 1153
  error = fop_create(dvp, (char *)name, & vattr, 1, 0, & vp, & cred, 0);
#line 1155
  vn_rele(dvp);
#line 1157
  if (error) {
    goto out;
  }
#line 1160
  if (! ((unsigned int )vp != (unsigned int )((void *)0))) {
#line 1160
    __assert_fail("vp != ((void *)0)", "zfs-fuse/zfs_operations.c", 1160U, "zfsfuse_mknod");
  }
#line 1162
  e.ino = (fuse_ino_t )0;
#line 1162
  e.generation = 0UL;
#line 1162
  e.attr.st_dev = 0ULL;
#line 1162
  e.attr.__pad1 = (unsigned short)0;
#line 1162
  e.attr.__st_ino = 0UL;
#line 1162
  e.attr.st_mode = 0U;
#line 1162
  e.attr.st_nlink = 0U;
#line 1162
  e.attr.st_uid = 0U;
#line 1162
  e.attr.st_gid = 0U;
#line 1162
  e.attr.st_rdev = 0ULL;
#line 1162
  e.attr.__pad2 = (unsigned short)0;
#line 1162
  e.attr.st_size = 0LL;
#line 1162
  e.attr.st_blksize = 0L;
#line 1162
  e.attr.st_blocks = 0LL;
#line 1162
  e.attr.st_atim.tv_sec = 0L;
#line 1162
  e.attr.st_atim.tv_nsec = 0L;
#line 1162
  e.attr.st_mtim.tv_sec = 0L;
#line 1162
  e.attr.st_mtim.tv_nsec = 0L;
#line 1162
  e.attr.st_ctim.tv_sec = 0L;
#line 1162
  e.attr.st_ctim.tv_nsec = 0L;
#line 1162
  e.attr.st_ino = 0ULL;
#line 1162
  e.attr_timeout = 0.;
#line 1162
  e.entry_timeout = 0.;
#line 1164
  e.attr_timeout = 0.0;
#line 1165
  e.entry_timeout = 0.0;
#line 1167
  e.ino = (unsigned long )((znode_t *)vp->v_data)->z_id;
#line 1168
  if (e.ino == 3UL) {
#line 1169
    e.ino = 1UL;
  }
#line 1171
  e.generation = (unsigned long )(((znode_t *)vp->v_data)->z_phys)->zp_gen;
#line 1173
  error = zfsfuse_stat(vp, & e.attr, & cred);
  out: 
#line 1176
  if ((unsigned int )vp != (unsigned int )((void *)0)) {
#line 1177
    vn_rele(vp);
  }
#line 1178
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1180
  if (! error) {
#line 1181
    fuse_reply_entry(req, (struct fuse_entry_param  const  *)(& e));
  }
#line 1183
  return (error);
}
}
#line 1186 "zfs-fuse/zfs_operations.c"
static void zfsfuse_mknod_helper(fuse_req_t req , fuse_ino_t parent , char const   *name ,
                                 mode_t mode , dev_t rdev ) 
{ fuse_ino_t real_parent ;
  fuse_ino_t tmp ;
  int error ;
  int tmp___0 ;

  {
#line 1188
  if (parent == 1UL) {
#line 1188
    tmp = 3UL;
  } else {
#line 1188
    tmp = parent;
  }
#line 1188
  real_parent = tmp;
#line 1190
  tmp___0 = zfsfuse_mknod(req, real_parent, name, mode, rdev);
#line 1190
  error = tmp___0;
#line 1191
  if (error) {
#line 1192
    fuse_reply_err(req, error);
  }
#line 1193
  return;
}
}
#line 1195 "zfs-fuse/zfs_operations.c"
static int zfsfuse_symlink(fuse_req_t req , char const   *link , fuse_ino_t parent ,
                           char const   *name ) 
{ size_t tmp ;
  vfs_t *vfs ;
  void *tmp___0 ;
  zfsvfs_t *zfsvfs ;
  znode_t *znode ;
  int error ;
  int tmp___1 ;
  vnode_t *dvp ;
  cred_t cred ;
  vattr_t vattr ;
  vnode_t *vp ;
  struct fuse_entry_param e ;

  {
#line 1197
  tmp = strlen(name);
#line 1197
  if (tmp >= 256U) {
#line 1198
    return (36);
  }
#line 1200
  tmp___0 = fuse_req_userdata(req);
#line 1200
  vfs = (vfs_t *)tmp___0;
#line 1201
  zfsvfs = (zfsvfs_t *)vfs->vfs_data;
#line 1203
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 1203
  if (zfsvfs->z_unmounted1) {
#line 1203
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1203
    return (5);
  }
#line 1207
  tmp___1 = zfs_zget(zfsvfs, (unsigned long long )parent, & znode);
#line 1207
  error = tmp___1;
#line 1208
  if (error) {
#line 1209
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1210
    return (error);
  }
#line 1213
  if (! ((unsigned int )znode != (unsigned int )((void *)0))) {
#line 1213
    __assert_fail("znode != ((void *)0)", "zfs-fuse/zfs_operations.c", 1213U, "zfsfuse_symlink");
  }
#line 1214
  dvp = znode->z_vnode;
#line 1215
  if (! ((unsigned int )dvp != (unsigned int )((void *)0))) {
#line 1215
    __assert_fail("dvp != ((void *)0)", "zfs-fuse/zfs_operations.c", 1215U, "zfsfuse_symlink");
  }
#line 1218
  zfsfuse_getcred(req, & cred);
#line 1221
  vattr.va_type = 5;
#line 1222
  vattr.va_mode = 511U;
#line 1223
  vattr.va_mask = 3U;
#line 1225
  error = fop_symlink(dvp, (char *)name, & vattr, (char *)link, & cred);
#line 1227
  vp = (vnode_t *)((void *)0);
#line 1229
  if (error) {
    goto out;
  }
#line 1232
  error = fop_lookup(dvp, (char *)name, & vp, (struct pathname *)((void *)0), 0, (vnode_t *)((void *)0),
                     & cred);
#line 1233
  if (error) {
    goto out;
  }
#line 1236
  if (! ((unsigned int )vp != (unsigned int )((void *)0))) {
#line 1236
    __assert_fail("vp != ((void *)0)", "zfs-fuse/zfs_operations.c", 1236U, "zfsfuse_symlink");
  }
#line 1238
  e.ino = (fuse_ino_t )0;
#line 1238
  e.generation = 0UL;
#line 1238
  e.attr.st_dev = 0ULL;
#line 1238
  e.attr.__pad1 = (unsigned short)0;
#line 1238
  e.attr.__st_ino = 0UL;
#line 1238
  e.attr.st_mode = 0U;
#line 1238
  e.attr.st_nlink = 0U;
#line 1238
  e.attr.st_uid = 0U;
#line 1238
  e.attr.st_gid = 0U;
#line 1238
  e.attr.st_rdev = 0ULL;
#line 1238
  e.attr.__pad2 = (unsigned short)0;
#line 1238
  e.attr.st_size = 0LL;
#line 1238
  e.attr.st_blksize = 0L;
#line 1238
  e.attr.st_blocks = 0LL;
#line 1238
  e.attr.st_atim.tv_sec = 0L;
#line 1238
  e.attr.st_atim.tv_nsec = 0L;
#line 1238
  e.attr.st_mtim.tv_sec = 0L;
#line 1238
  e.attr.st_mtim.tv_nsec = 0L;
#line 1238
  e.attr.st_ctim.tv_sec = 0L;
#line 1238
  e.attr.st_ctim.tv_nsec = 0L;
#line 1238
  e.attr.st_ino = 0ULL;
#line 1238
  e.attr_timeout = 0.;
#line 1238
  e.entry_timeout = 0.;
#line 1240
  e.attr_timeout = 0.0;
#line 1241
  e.entry_timeout = 0.0;
#line 1243
  e.ino = (unsigned long )((znode_t *)vp->v_data)->z_id;
#line 1244
  if (e.ino == 3UL) {
#line 1245
    e.ino = 1UL;
  }
#line 1247
  e.generation = (unsigned long )(((znode_t *)vp->v_data)->z_phys)->zp_gen;
#line 1249
  error = zfsfuse_stat(vp, & e.attr, & cred);
  out: 
#line 1252
  if ((unsigned int )vp != (unsigned int )((void *)0)) {
#line 1253
    vn_rele(vp);
  }
#line 1254
  vn_rele(dvp);
#line 1256
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1258
  if (! error) {
#line 1259
    fuse_reply_entry(req, (struct fuse_entry_param  const  *)(& e));
  }
#line 1261
  return (error);
}
}
#line 1264 "zfs-fuse/zfs_operations.c"
static void zfsfuse_symlink_helper(fuse_req_t req , char const   *link , fuse_ino_t parent ,
                                   char const   *name ) 
{ fuse_ino_t real_parent ;
  fuse_ino_t tmp ;
  int error ;
  int tmp___0 ;

  {
#line 1266
  if (parent == 1UL) {
#line 1266
    tmp = 3UL;
  } else {
#line 1266
    tmp = parent;
  }
#line 1266
  real_parent = tmp;
#line 1268
  tmp___0 = zfsfuse_symlink(req, link, real_parent, name);
#line 1268
  error = tmp___0;
#line 1269
  if (error) {
#line 1270
    fuse_reply_err(req, error);
  }
#line 1271
  return;
}
}
#line 1273 "zfs-fuse/zfs_operations.c"
static int zfsfuse_rename(fuse_req_t req , fuse_ino_t parent , char const   *name ,
                          fuse_ino_t newparent , char const   *newname ) 
{ size_t tmp ;
  size_t tmp___0 ;
  vfs_t *vfs ;
  void *tmp___1 ;
  zfsvfs_t *zfsvfs ;
  znode_t *p_znode ;
  znode_t *np_znode ;
  int error ;
  int tmp___2 ;
  vnode_t *p_vp ;
  vnode_t *np_vp ;
  cred_t cred ;

  {
#line 1275
  tmp = strlen(name);
#line 1275
  if (tmp >= 256U) {
#line 1276
    return (36);
  }
#line 1277
  tmp___0 = strlen(newname);
#line 1277
  if (tmp___0 >= 256U) {
#line 1278
    return (36);
  }
#line 1280
  tmp___1 = fuse_req_userdata(req);
#line 1280
  vfs = (vfs_t *)tmp___1;
#line 1281
  zfsvfs = (zfsvfs_t *)vfs->vfs_data;
#line 1283
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 1283
  if (zfsvfs->z_unmounted1) {
#line 1283
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1283
    return (5);
  }
#line 1287
  tmp___2 = zfs_zget(zfsvfs, (unsigned long long )parent, & p_znode);
#line 1287
  error = tmp___2;
#line 1288
  if (error) {
#line 1289
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1290
    return (error);
  }
#line 1293
  if (! ((unsigned int )p_znode != (unsigned int )((void *)0))) {
#line 1293
    __assert_fail("p_znode != ((void *)0)", "zfs-fuse/zfs_operations.c", 1293U, "zfsfuse_rename");
  }
#line 1295
  error = zfs_zget(zfsvfs, (unsigned long long )newparent, & np_znode);
#line 1296
  if (error) {
#line 1297
    vn_rele(p_znode->z_vnode);
#line 1298
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1299
    return (error);
  }
#line 1302
  if (! ((unsigned int )np_znode != (unsigned int )((void *)0))) {
#line 1302
    __assert_fail("np_znode != ((void *)0)", "zfs-fuse/zfs_operations.c", 1302U, "zfsfuse_rename");
  }
#line 1304
  p_vp = p_znode->z_vnode;
#line 1305
  np_vp = np_znode->z_vnode;
#line 1306
  if (! ((unsigned int )p_vp != (unsigned int )((void *)0))) {
#line 1306
    __assert_fail("p_vp != ((void *)0)", "zfs-fuse/zfs_operations.c", 1306U, "zfsfuse_rename");
  }
#line 1307
  if (! ((unsigned int )np_vp != (unsigned int )((void *)0))) {
#line 1307
    __assert_fail("np_vp != ((void *)0)", "zfs-fuse/zfs_operations.c", 1307U, "zfsfuse_rename");
  }
#line 1310
  zfsfuse_getcred(req, & cred);
#line 1312
  error = fop_rename(p_vp, (char *)name, np_vp, (char *)newname, & cred);
#line 1314
  vn_rele(p_vp);
#line 1315
  vn_rele(np_vp);
#line 1317
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1319
  return (error);
}
}
#line 1322 "zfs-fuse/zfs_operations.c"
static void zfsfuse_rename_helper(fuse_req_t req , fuse_ino_t parent , char const   *name ,
                                  fuse_ino_t newparent , char const   *newname ) 
{ fuse_ino_t real_parent ;
  fuse_ino_t tmp ;
  fuse_ino_t real_newparent ;
  fuse_ino_t tmp___0 ;
  int error ;
  int tmp___1 ;

  {
#line 1324
  if (parent == 1UL) {
#line 1324
    tmp = 3UL;
  } else {
#line 1324
    tmp = parent;
  }
#line 1324
  real_parent = tmp;
#line 1325
  if (newparent == 1UL) {
#line 1325
    tmp___0 = 3UL;
  } else {
#line 1325
    tmp___0 = newparent;
  }
#line 1325
  real_newparent = tmp___0;
#line 1327
  tmp___1 = zfsfuse_rename(req, real_parent, name, real_newparent, newname);
#line 1327
  error = tmp___1;
#line 1330
  fuse_reply_err(req, error);
#line 1331
  return;
}
}
#line 1333 "zfs-fuse/zfs_operations.c"
static int zfsfuse_fsync(fuse_req_t req , fuse_ino_t ino , int datasync , struct fuse_file_info *fi ) 
{ vfs_t *vfs ;
  void *tmp ;
  zfsvfs_t *zfsvfs ;
  file_info_t *info ;
  vnode_t *vp ;
  cred_t cred ;
  int error ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1335
  tmp = fuse_req_userdata(req);
#line 1335
  vfs = (vfs_t *)tmp;
#line 1336
  zfsvfs = (zfsvfs_t *)vfs->vfs_data;
#line 1338
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 1338
  if (zfsvfs->z_unmounted1) {
#line 1338
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1338
    return (5);
  }
#line 1340
  info = (file_info_t *)((unsigned int )fi->fh);
#line 1341
  if (! ((unsigned int )info->vp != (unsigned int )((void *)0))) {
#line 1341
    __assert_fail("info->vp != ((void *)0)", "zfs-fuse/zfs_operations.c", 1341U, "zfsfuse_fsync");
  }
#line 1342
  if (! ((unsigned int )((znode_t *)(info->vp)->v_data) != (unsigned int )((void *)0))) {
#line 1342
    __assert_fail("((znode_t *)(info->vp)->v_data) != ((void *)0)", "zfs-fuse/zfs_operations.c",
                  1342U, "zfsfuse_fsync");
  }
#line 1343
  if (! (((znode_t *)(info->vp)->v_data)->z_id == (uint64_t )ino)) {
#line 1343
    __assert_fail("((znode_t *)(info->vp)->v_data)->z_id == ino", "zfs-fuse/zfs_operations.c",
                  1343U, "zfsfuse_fsync");
  }
#line 1345
  vp = info->vp;
#line 1348
  zfsfuse_getcred(req, & cred);
#line 1350
  if (datasync) {
#line 1350
    tmp___0 = 4096;
  } else {
#line 1350
    tmp___0 = 4096;
  }
#line 1350
  tmp___1 = fop_fsync(vp, tmp___0, & cred);
#line 1350
  error = tmp___1;
#line 1352
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1354
  return (error);
}
}
#line 1357 "zfs-fuse/zfs_operations.c"
static void zfsfuse_fsync_helper(fuse_req_t req , fuse_ino_t ino , int datasync ,
                                 struct fuse_file_info *fi ) 
{ fuse_ino_t real_ino ;
  fuse_ino_t tmp ;
  int error ;
  int tmp___0 ;

  {
#line 1359
  if (ino == 1UL) {
#line 1359
    tmp = 3UL;
  } else {
#line 1359
    tmp = ino;
  }
#line 1359
  real_ino = tmp;
#line 1361
  tmp___0 = zfsfuse_fsync(req, real_ino, datasync, fi);
#line 1361
  error = tmp___0;
#line 1364
  fuse_reply_err(req, error);
#line 1365
  return;
}
}
#line 1367 "zfs-fuse/zfs_operations.c"
static int zfsfuse_link(fuse_req_t req , fuse_ino_t ino , fuse_ino_t newparent , char const   *newname ) 
{ size_t tmp ;
  vfs_t *vfs ;
  void *tmp___0 ;
  zfsvfs_t *zfsvfs ;
  znode_t *td_znode ;
  znode_t *s_znode ;
  int error ;
  int tmp___1 ;
  vnode_t *svp ;
  vnode_t *tdvp ;
  cred_t cred ;
  vnode_t *vp ;
  struct fuse_entry_param e ;

  {
#line 1369
  tmp = strlen(newname);
#line 1369
  if (tmp >= 256U) {
#line 1370
    return (36);
  }
#line 1372
  tmp___0 = fuse_req_userdata(req);
#line 1372
  vfs = (vfs_t *)tmp___0;
#line 1373
  zfsvfs = (zfsvfs_t *)vfs->vfs_data;
#line 1375
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 1375
  if (zfsvfs->z_unmounted1) {
#line 1375
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1375
    return (5);
  }
#line 1379
  tmp___1 = zfs_zget(zfsvfs, (unsigned long long )ino, & s_znode);
#line 1379
  error = tmp___1;
#line 1380
  if (error) {
#line 1381
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1382
    return (error);
  }
#line 1385
  if (! ((unsigned int )s_znode != (unsigned int )((void *)0))) {
#line 1385
    __assert_fail("s_znode != ((void *)0)", "zfs-fuse/zfs_operations.c", 1385U, "zfsfuse_link");
  }
#line 1387
  error = zfs_zget(zfsvfs, (unsigned long long )newparent, & td_znode);
#line 1388
  if (error) {
#line 1389
    vn_rele(s_znode->z_vnode);
#line 1390
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1391
    return (error);
  }
#line 1394
  svp = s_znode->z_vnode;
#line 1395
  tdvp = td_znode->z_vnode;
#line 1396
  if (! ((unsigned int )svp != (unsigned int )((void *)0))) {
#line 1396
    __assert_fail("svp != ((void *)0)", "zfs-fuse/zfs_operations.c", 1396U, "zfsfuse_link");
  }
#line 1397
  if (! ((unsigned int )tdvp != (unsigned int )((void *)0))) {
#line 1397
    __assert_fail("tdvp != ((void *)0)", "zfs-fuse/zfs_operations.c", 1397U, "zfsfuse_link");
  }
#line 1400
  zfsfuse_getcred(req, & cred);
#line 1402
  error = fop_link(tdvp, svp, (char *)newname, & cred);
#line 1404
  vp = (vnode_t *)((void *)0);
#line 1406
  if (error) {
    goto out;
  }
#line 1409
  error = fop_lookup(tdvp, (char *)newname, & vp, (struct pathname *)((void *)0),
                     0, (vnode_t *)((void *)0), & cred);
#line 1410
  if (error) {
    goto out;
  }
#line 1413
  if (! ((unsigned int )vp != (unsigned int )((void *)0))) {
#line 1413
    __assert_fail("vp != ((void *)0)", "zfs-fuse/zfs_operations.c", 1413U, "zfsfuse_link");
  }
#line 1415
  e.ino = (fuse_ino_t )0;
#line 1415
  e.generation = 0UL;
#line 1415
  e.attr.st_dev = 0ULL;
#line 1415
  e.attr.__pad1 = (unsigned short)0;
#line 1415
  e.attr.__st_ino = 0UL;
#line 1415
  e.attr.st_mode = 0U;
#line 1415
  e.attr.st_nlink = 0U;
#line 1415
  e.attr.st_uid = 0U;
#line 1415
  e.attr.st_gid = 0U;
#line 1415
  e.attr.st_rdev = 0ULL;
#line 1415
  e.attr.__pad2 = (unsigned short)0;
#line 1415
  e.attr.st_size = 0LL;
#line 1415
  e.attr.st_blksize = 0L;
#line 1415
  e.attr.st_blocks = 0LL;
#line 1415
  e.attr.st_atim.tv_sec = 0L;
#line 1415
  e.attr.st_atim.tv_nsec = 0L;
#line 1415
  e.attr.st_mtim.tv_sec = 0L;
#line 1415
  e.attr.st_mtim.tv_nsec = 0L;
#line 1415
  e.attr.st_ctim.tv_sec = 0L;
#line 1415
  e.attr.st_ctim.tv_nsec = 0L;
#line 1415
  e.attr.st_ino = 0ULL;
#line 1415
  e.attr_timeout = 0.;
#line 1415
  e.entry_timeout = 0.;
#line 1417
  e.attr_timeout = 0.0;
#line 1418
  e.entry_timeout = 0.0;
#line 1420
  e.ino = (unsigned long )((znode_t *)vp->v_data)->z_id;
#line 1421
  if (e.ino == 3UL) {
#line 1422
    e.ino = 1UL;
  }
#line 1424
  e.generation = (unsigned long )(((znode_t *)vp->v_data)->z_phys)->zp_gen;
#line 1426
  error = zfsfuse_stat(vp, & e.attr, & cred);
  out: 
#line 1429
  if ((unsigned int )vp != (unsigned int )((void *)0)) {
#line 1430
    vn_rele(vp);
  }
#line 1431
  vn_rele(tdvp);
#line 1432
  vn_rele(svp);
#line 1434
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1436
  if (! error) {
#line 1437
    fuse_reply_entry(req, (struct fuse_entry_param  const  *)(& e));
  }
#line 1439
  return (error);
}
}
#line 1442 "zfs-fuse/zfs_operations.c"
static void zfsfuse_link_helper(fuse_req_t req , fuse_ino_t ino , fuse_ino_t newparent ,
                                char const   *newname ) 
{ fuse_ino_t real_ino ;
  fuse_ino_t tmp ;
  fuse_ino_t real_newparent ;
  fuse_ino_t tmp___0 ;
  int error ;
  int tmp___1 ;

  {
#line 1444
  if (ino == 1UL) {
#line 1444
    tmp = 3UL;
  } else {
#line 1444
    tmp = ino;
  }
#line 1444
  real_ino = tmp;
#line 1445
  if (newparent == 1UL) {
#line 1445
    tmp___0 = 3UL;
  } else {
#line 1445
    tmp___0 = newparent;
  }
#line 1445
  real_newparent = tmp___0;
#line 1447
  tmp___1 = zfsfuse_link(req, real_ino, real_newparent, newname);
#line 1447
  error = tmp___1;
#line 1448
  if (error) {
#line 1449
    fuse_reply_err(req, error);
  }
#line 1450
  return;
}
}
#line 1452 "zfs-fuse/zfs_operations.c"
static int zfsfuse_access(fuse_req_t req , fuse_ino_t ino , int mask ) 
{ vfs_t *vfs ;
  void *tmp ;
  zfsvfs_t *zfsvfs ;
  znode_t *znode ;
  int error ;
  int tmp___0 ;
  vnode_t *vp ;
  cred_t cred ;
  int mode ;

  {
#line 1454
  tmp = fuse_req_userdata(req);
#line 1454
  vfs = (vfs_t *)tmp;
#line 1455
  zfsvfs = (zfsvfs_t *)vfs->vfs_data;
#line 1457
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), 1);
#line 1457
  if (zfsvfs->z_unmounted1) {
#line 1457
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1457
    return (5);
  }
#line 1461
  tmp___0 = zfs_zget(zfsvfs, (unsigned long long )ino, & znode);
#line 1461
  error = tmp___0;
#line 1462
  if (error) {
#line 1463
    atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1464
    return (error);
  }
#line 1467
  if (! ((unsigned int )znode != (unsigned int )((void *)0))) {
#line 1467
    __assert_fail("znode != ((void *)0)", "zfs-fuse/zfs_operations.c", 1467U, "zfsfuse_access");
  }
#line 1468
  vp = znode->z_vnode;
#line 1469
  if (! ((unsigned int )vp != (unsigned int )((void *)0))) {
#line 1469
    __assert_fail("vp != ((void *)0)", "zfs-fuse/zfs_operations.c", 1469U, "zfsfuse_access");
  }
#line 1472
  zfsfuse_getcred(req, & cred);
#line 1474
  mode = 0;
#line 1475
  if (mask & 4) {
#line 1476
    mode |= 256;
  }
#line 1477
  if (mask & 2) {
#line 1478
    mode |= 128;
  }
#line 1479
  if (mask & 1) {
#line 1480
    mode |= 64;
  }
#line 1482
  error = fop_access(vp, mode, 0, & cred);
#line 1484
  vn_rele(vp);
#line 1486
  atomic_add_32((uint32_t volatile   *)(& zfsvfs->z_op_cnt), -1);
#line 1488
  return (error);
}
}
#line 1491 "zfs-fuse/zfs_operations.c"
static void zfsfuse_access_helper(fuse_req_t req , fuse_ino_t ino , int mask ) 
{ fuse_ino_t real_ino ;
  fuse_ino_t tmp ;
  int error ;
  int tmp___0 ;

  {
#line 1493
  if (ino == 1UL) {
#line 1493
    tmp = 3UL;
  } else {
#line 1493
    tmp = ino;
  }
#line 1493
  real_ino = tmp;
#line 1495
  tmp___0 = zfsfuse_access(req, real_ino, mask);
#line 1495
  error = tmp___0;
#line 1498
  fuse_reply_err(req, error);
#line 1499
  return;
}
}
#line 1501 "zfs-fuse/zfs_operations.c"
struct fuse_lowlevel_ops_compat25 zfs_operations  = 
#line 1501
     {(void (*)(void *userdata ))0, & zfsfuse_destroy, & zfsfuse_lookup_helper, (void (*)(fuse_req_t req ,
                                                                                        fuse_ino_t ino ,
                                                                                        unsigned long nlookup ))0,
    & zfsfuse_getattr_helper, & zfsfuse_setattr_helper, & zfsfuse_readlink_helper,
    & zfsfuse_mknod_helper, & zfsfuse_mkdir_helper, & zfsfuse_unlink_helper, & zfsfuse_rmdir_helper,
    & zfsfuse_symlink_helper, & zfsfuse_rename_helper, & zfsfuse_link_helper, & zfsfuse_open_helper,
    & zfsfuse_read_helper, & zfsfuse_write_helper, (void (*)(fuse_req_t req , fuse_ino_t ino ,
                                                             struct fuse_file_info *fi ))0,
    & zfsfuse_release_helper, & zfsfuse_fsync_helper, & zfsfuse_opendir_helper, & zfsfuse_readdir_helper,
    & zfsfuse_release_helper, & zfsfuse_fsync_helper, & zfsfuse_statfs, (void (*)(fuse_req_t req ,
                                                                                  fuse_ino_t ino ,
                                                                                  char const   *name ,
                                                                                  char const   *value ,
                                                                                  size_t size ,
                                                                                  int flags ))0,
    (void (*)(fuse_req_t req , fuse_ino_t ino , char const   *name , size_t size ))0,
    (void (*)(fuse_req_t req , fuse_ino_t ino , size_t size ))0, (void (*)(fuse_req_t req ,
                                                                           fuse_ino_t ino ,
                                                                           char const   *name ))0,
    & zfsfuse_access_helper, & zfsfuse_create_helper};
