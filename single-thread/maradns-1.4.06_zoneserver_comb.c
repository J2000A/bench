/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

#line 45 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 50 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 19 "../libs/JsStr.h"
struct __anonstruct_js_string_1 {
   unsigned char *string ;
   unsigned int unit_size ;
   unsigned int unit_count ;
   unsigned int max_count ;
   int encoding ;
   int is_good ;
};
#line 19 "../libs/JsStr.h"
typedef struct __anonstruct_js_string_1 js_string;
#line 30 "../libs/JsStr.h"
struct __anonstruct_js_file_2 {
   int filetype ;
   int file_desc ;
   js_string *buffer ;
   int number ;
   int eof ;
};
#line 30 "../libs/JsStr.h"
typedef struct __anonstruct_js_file_2 js_file;
#line 169 "../MaraDns.h"
struct __anonstruct_ipv4pair_7 {
   uint32_t ip ;
   uint32_t mask ;
};
#line 169 "../MaraDns.h"
typedef struct __anonstruct_ipv4pair_7 ipv4pair;
#line 239 "../MaraDns.h"
struct __anonstruct_q_header_8 {
   uint16_t id ;
   int qr ;
   int opcode ;
   int aa ;
   int tc ;
   int rd ;
   int ra ;
   int z ;
   int rcode ;
   uint16_t qdcount ;
   uint16_t ancount ;
   uint16_t nscount ;
   uint16_t arcount ;
};
#line 239 "../MaraDns.h"
typedef struct __anonstruct_q_header_8 q_header;
#line 41 "/usr/include/i386/_types.h"
typedef unsigned char __uint8_t;
#line 43 "/usr/include/i386/_types.h"
typedef unsigned short __uint16_t;
#line 44 "/usr/include/i386/_types.h"
typedef int __int32_t;
#line 45 "/usr/include/i386/_types.h"
typedef unsigned int __uint32_t;
#line 47 "/usr/include/i386/_types.h"
typedef unsigned long long __uint64_t;
#line 90 "/usr/include/i386/_types.h"
typedef unsigned long __darwin_size_t;
#line 116 "/usr/include/i386/_types.h"
typedef __uint32_t __darwin_socklen_t;
#line 117 "/usr/include/i386/_types.h"
typedef long __darwin_ssize_t;
#line 118 "/usr/include/i386/_types.h"
typedef long __darwin_time_t;
#line 99 "/usr/include/sys/_types.h"
typedef __uint32_t __darwin_gid_t;
#line 111 "/usr/include/sys/_types.h"
typedef __int32_t __darwin_pid_t;
#line 132 "/usr/include/sys/_types.h"
typedef __int32_t __darwin_suseconds_t;
#line 133 "/usr/include/sys/_types.h"
typedef __uint32_t __darwin_uid_t;
#line 78 "/usr/include/stdio.h"
typedef __darwin_size_t size_t;
#line 442 "/usr/include/stdio.h"
typedef __darwin_ssize_t ssize_t;
#line 77 "/usr/include/unistd.h"
typedef __darwin_gid_t gid_t;
#line 92 "/usr/include/unistd.h"
typedef __darwin_pid_t pid_t;
#line 109 "/usr/include/unistd.h"
typedef __darwin_uid_t uid_t;
#line 100 "/usr/include/sys/_structs.h"
struct timeval {
   __darwin_time_t tv_sec ;
   __darwin_suseconds_t tv_usec ;
};
#line 184 "/usr/include/sys/_structs.h"
struct fd_set {
   __int32_t fds_bits[1024UL / (sizeof(__int32_t ) * 8UL)] ;
};
#line 184 "/usr/include/sys/_structs.h"
typedef struct fd_set fd_set;
#line 87 "/usr/include/sys/select.h"
typedef __darwin_time_t time_t;
#line 419 "/usr/include/sys/fcntl.h"
#pragma pack(4)
#line 431
#pragma pack()
#line 89 "/usr/include/sys/resource.h"
typedef __uint64_t rlim_t;
#line 222 "/usr/include/sys/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 126 "/usr/include/sys/types.h"
typedef __uint32_t in_addr_t;
#line 131 "/usr/include/sys/types.h"
typedef __uint16_t in_port_t;
#line 106 "/usr/include/sys/socket.h"
typedef __uint8_t sa_family_t;
#line 111 "/usr/include/sys/socket.h"
typedef __darwin_socklen_t socklen_t;
#line 322 "/usr/include/sys/socket.h"
struct sockaddr {
   __uint8_t sa_len ;
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 307 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 380 "/usr/include/netinet/in.h"
struct sockaddr_in {
   __uint8_t sin_len ;
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   char sin_zero[8] ;
};
#line 522
#pragma pack(4)
#line 565
#pragma pack()
#line 55 "../rng/rng-alg-fst.h"
typedef unsigned int u32;
#line 91 "../rng/rng-api-fst.h"
typedef unsigned char MARA_BYTE;
#line 94 "../rng/rng-api-fst.h"
struct __anonstruct_keyInstance_22 {
   MARA_BYTE direction ;
   int keyLen ;
   char keyMaterial[65] ;
   int Nr ;
   u32 rk[60] ;
   u32 ek[60] ;
};
#line 94 "../rng/rng-api-fst.h"
typedef struct __anonstruct_keyInstance_22 keyInstance;
#line 104 "../rng/rng-api-fst.h"
struct __anonstruct_cipherInstance_23 {
   MARA_BYTE mode ;
   MARA_BYTE IV[16] ;
};
#line 104 "../rng/rng-api-fst.h"
typedef struct __anonstruct_cipherInstance_23 cipherInstance;
#line 46 "/usr/include/i386/_types.h"
typedef long long __int64_t;
#line 110 "/usr/include/sys/_types.h"
typedef __int64_t __darwin_off_t;
#line 85 "/usr/include/stdio.h"
typedef __darwin_off_t fpos_t;
#line 96 "/usr/include/stdio.h"
struct __sbuf {
   unsigned char *_base ;
   int _size ;
};
#line 102
struct __sFILEX;
#line 130 "/usr/include/stdio.h"
struct __sFILE {
   unsigned char *_p ;
   int _r ;
   int _w ;
   short _flags ;
   short _file ;
   struct __sbuf _bf ;
   int _lbfsize ;
   void *_cookie ;
   int (*_close)(void * ) ;
   int (*_read)(void * , char * , int  ) ;
   fpos_t (*_seek)(void * , fpos_t  , int  ) ;
   int (*_write)(void * , char const   * , int  ) ;
   struct __sbuf _ub ;
   struct __sFILEX *_extra ;
   int _ur ;
   unsigned char _ubuf[3] ;
   unsigned char _nbuf[1] ;
   struct __sbuf _lb ;
   int _blksize ;
   fpos_t _offset ;
};
#line 130 "/usr/include/stdio.h"
typedef struct __sFILE FILE;
#line 414 "/usr/include/stdio.h"
typedef __darwin_off_t off_t;
#line 419 "/usr/include/sys/fcntl.h"
#pragma pack(4)
#line 431
#pragma pack()
#line 83 "/usr/include/sys/file.h"
#pragma pack(4)
#line 98
#pragma pack()
#line 19 "MaraHash.h"
struct __anonstruct_mara_tuple_3 {
   int elements ;
   js_string **tuple_list ;
};
#line 19 "MaraHash.h"
typedef struct __anonstruct_mara_tuple_3 mara_tuple;
#line 25 "MaraHash.h"
struct mhash_spot {
   js_string *key ;
   void *value ;
   int datatype ;
   struct mhash_spot *next ;
};
#line 25 "MaraHash.h"
typedef struct mhash_spot mhash_spot;
#line 33 "MaraHash.h"
struct __anonstruct_mhash_e_4 {
   void **point ;
   void *value ;
   int datatype ;
};
#line 33 "MaraHash.h"
typedef struct __anonstruct_mhash_e_4 mhash_e;
#line 41 "MaraHash.h"
struct __anonstruct_mhash_5 {
   int hash_bits ;
   mhash_spot **hash_table ;
   unsigned int spots ;
};
#line 41 "MaraHash.h"
typedef struct __anonstruct_mhash_5 mhash;
#line 67 "/usr/include/sys/_types.h"
struct _opaque_pthread_mutex_t {
   long __sig ;
   char __opaque[56] ;
};
#line 119 "/usr/include/sys/_types.h"
typedef struct _opaque_pthread_mutex_t __darwin_pthread_mutex_t;
#line 93 "/usr/include/i386/types.h"
typedef long long int64_t;
#line 330 "/usr/include/sys/types.h"
typedef __darwin_pthread_mutex_t pthread_mutex_t;
#line 30 "/usr/include/stdint.h"
typedef int int32_t;
#line 256 "../MaraDns.h"
struct __anonstruct_q_question_6 {
   js_string *qname ;
   uint16_t qtype ;
   uint16_t qclass ;
};
#line 256 "../MaraDns.h"
typedef struct __anonstruct_q_question_6 q_question;
#line 263 "../MaraDns.h"
struct __anonstruct_q_rr_7 {
   js_string *name ;
   uint16_t type ;
   uint16_t class ;
   uint32_t ttl ;
   uint16_t rdlength ;
   js_string *rdata ;
};
#line 263 "../MaraDns.h"
typedef struct __anonstruct_q_rr_7 q_rr;
#line 409 "../MaraDns.h"
struct __anonstruct_rr_soa_8 {
   js_string *mname ;
   js_string *rname ;
   uint32_t serial ;
   int32_t refresh ;
   int32_t retry ;
   int32_t expire ;
   uint32_t minimum ;
};
#line 409 "../MaraDns.h"
typedef struct __anonstruct_rr_soa_8 rr_soa;
#line 20 "Compress_rrs.h"
struct rrdesc {
   int rr_num ;
   char *description ;
   char tocompress ;
   struct rrdesc *next ;
};
#line 20 "Compress_rrs.h"
typedef struct rrdesc rrdesc;
#line 44 "Compress.c"
struct compress_state {
   js_string *compressed ;
   js_string *uncompressed ;
   unsigned int uncompressed_offset ;
   unsigned int this_dlabel_begin ;
   int *dlabel_points ;
   unsigned int this_rdlength_begin ;
   int this_rr_type ;
   int current_rdlength ;
   int valid_state ;
   int number_answers ;
};
#line 44 "Compress.c"
typedef struct compress_state compress_state;
#line 24 "Csv2_read.h"
struct csv2_file {
   FILE *reading ;
   char *filename ;
   struct csv2_file *next ;
};
#line 24 "Csv2_read.h"
typedef struct csv2_file csv2_file;
#line 30 "Csv2_read.h"
struct csv2_read {
   FILE *reading ;
   char *filename ;
   csv2_file *stack ;
   char context[19] ;
   char chars_allowed ;
   char tilde_seen ;
   char tilde_handling ;
   int stack_height ;
   int cplace ;
   int mnum ;
   int mplace ;
   int linenum ;
   int justread ;
   int32_t unicode ;
   int ok_to_read ;
   char seen_bug_msg ;
};
#line 30 "Csv2_read.h"
typedef struct csv2_read csv2_read;
#line 27 "Csv2_database.h"
struct csv2_rr {
   js_string *query ;
   int rtype ;
   int32_t ttl ;
   js_string *data ;
   struct csv2_rr *next ;
};
#line 27 "Csv2_database.h"
typedef struct csv2_rr csv2_rr;
#line 35 "Csv2_database.h"
struct csv2_origin {
   js_string *origin ;
   struct csv2_origin *next ;
};
#line 35 "Csv2_database.h"
typedef struct csv2_origin csv2_origin;
#line 40 "Csv2_database.h"
struct csv2_add_state {
   csv2_rr *buffer ;
   js_string *zone ;
   js_string *origin ;
   csv2_origin *ostack ;
   int ostack_height ;
   int rrnum ;
   int add_method ;
   int32_t soa_serial ;
   int32_t default_ttl ;
   int in_ns ;
   int zone_nses_added ;
   mhash *bighash ;
};
#line 40 "Csv2_database.h"
typedef struct csv2_add_state csv2_add_state;
#line 94 "/usr/include/sys/_types.h"
typedef __int64_t __darwin_blkcnt_t;
#line 95 "/usr/include/sys/_types.h"
typedef __int32_t __darwin_blksize_t;
#line 96 "/usr/include/sys/_types.h"
typedef __int32_t __darwin_dev_t;
#line 101 "/usr/include/sys/_types.h"
typedef __uint64_t __darwin_ino64_t;
#line 109 "/usr/include/sys/_types.h"
typedef __uint16_t __darwin_mode_t;
#line 103 "/usr/include/sys/types.h"
typedef __darwin_dev_t dev_t;
#line 110 "/usr/include/sys/types.h"
typedef __darwin_blkcnt_t blkcnt_t;
#line 115 "/usr/include/sys/types.h"
typedef __darwin_blksize_t blksize_t;
#line 152 "/usr/include/sys/types.h"
typedef __darwin_mode_t mode_t;
#line 157 "/usr/include/sys/types.h"
typedef __uint16_t nlink_t;
#line 88 "/usr/include/sys/_structs.h"
struct timespec {
   __darwin_time_t tv_sec ;
   long tv_nsec ;
};
#line 225 "/usr/include/sys/stat.h"
struct stat {
   dev_t st_dev ;
   mode_t st_mode ;
   nlink_t st_nlink ;
   __darwin_ino64_t st_ino ;
   uid_t st_uid ;
   gid_t st_gid ;
   dev_t st_rdev ;
   struct timespec st_atimespec ;
   struct timespec st_mtimespec ;
   struct timespec st_ctimespec ;
   struct timespec st_birthtimespec ;
   off_t st_size ;
   blkcnt_t st_blocks ;
   blksize_t st_blksize ;
   __uint32_t st_flags ;
   __uint32_t st_gen ;
   __int32_t st_lspare ;
   __int64_t st_qspare[2] ;
};
#line 90 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char *tm_zone ;
};
#line 176 "../MaraDns.h"
struct fila {
   struct fila *siguiente ;
   struct fila *previous ;
   unsigned char datatype ;
   void *record ;
   js_string *hash_point ;
   char nukable_hp ;
};
#line 176 "../MaraDns.h"
typedef struct fila fila;
#line 206
struct rr_list;
#line 206 "../MaraDns.h"
struct rr {
   int64_t expire ;
   uint32_t ttl ;
   uint32_t authoritative ;
   struct rr *next ;
   struct rr *ip ;
   js_string *ptr ;
   uint16_t rr_type ;
   js_string *query ;
   js_string *data ;
   fila *zap ;
   char seen ;
   uint16_t perms ;
   struct rr_list *list ;
   char rcode ;
};
#line 206 "../MaraDns.h"
typedef struct rr rr;
#line 231 "../MaraDns.h"
struct rr_list {
   uint16_t rr_type ;
   rr *data ;
   struct rr_list *next ;
};
#line 522 "/usr/include/netinet/in.h"
#pragma pack(4)
#line 565
#pragma pack()
#line 522
#pragma pack(4)
#line 565
#pragma pack()
#line 231 "../MaraDns.h"
typedef struct rr_list rr_list;
#line 522 "/usr/include/netinet/in.h"
#pragma pack(4)
#line 565
#pragma pack()
#line 53 "rng-alg-fst.h"
typedef unsigned char u8;
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   void __builtin_bzero(void * , unsigned long  ) ;  */
#line 1 "cil-zLjn7_vt.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-b2KR_Xzy.i","")
#line 66 "../libs/JsStr.h"
js_string *js_create(unsigned int max_count , unsigned int unit_size ) ;
#line 67
int js_set_encode(js_string *js , int encoding ) ;
#line 70
int js_destroy(js_string *object ) ;
#line 72
int js_has_sanity(js_string *object ) ;
#line 74
int js_js2str(js_string *js , char *string , int max ) ;
#line 81
int js_append(js_string *toappend , js_string *target ) ;
#line 82
int js_copy(js_string *src , js_string *dest ) ;
#line 83
int js_substr(js_string *source , js_string *dest , int start , int count ) ;
#line 86
int js_qappend(char *toappend , js_string *target ) ;
#line 90
int js_adduint16(js_string *js , int number ) ;
#line 92
int js_length(js_string *js ) ;
#line 100
int js_show_stdout(js_string *js ) ;
#line 103
int js_open_read(js_string *filename , js_file *desc ) ;
#line 106
int js_close(js_file *desc ) ;
#line 107
int js_buf_eof(js_file *desc ) ;
#line 109
int js_buf_getline(js_file *desc , js_string *js ) ;
#line 110
int js_qstr2js(js_string *js , char *string ) ;
#line 111
int js_adduint32(js_string *js , uint32_t number ) ;
#line 112
int js_substr_append(js_string *source , js_string *dest , int offset , int length ) ;
#line 123
unsigned int js_atoi(js_string *js , int offset ) ;
#line 30 "../server/read_kvars.h"
int read_numeric_kvar(char *name , int default_value ) ;
#line 43
js_string *read_string_kvar(char *name ) ;
#line 267 "/usr/include/stdio.h"
extern int ( /* format attribute */  printf)(char const   *  , ...) ;
#line 471 "/usr/include/unistd.h"
extern unsigned int alarm(unsigned int  ) ;
#line 473
extern int chdir(char const   * ) ;
#line 476
extern int close(int  )  __asm__("_close")  ;
#line 479
extern int dup2(int  , int  ) ;
#line 486
extern pid_t fork(void) ;
#line 490
extern uid_t geteuid(void) ;
#line 498
extern pid_t getpgrp(void) ;
#line 499
extern pid_t getpid(void) ;
#line 509
extern int pipe(int * ) ;
#line 511
extern ssize_t read(int  , void * , size_t  )  __asm__("_read")  ;
#line 514
extern int setgid(gid_t  ) ;
#line 515
extern int setpgid(pid_t  , pid_t  ) ;
#line 517
extern int setuid(uid_t  ) ;
#line 519
extern unsigned int sleep(unsigned int  )  __asm__("_sleep")  ;
#line 535
extern ssize_t write(int  , void const   * , size_t  )  __asm__("_write")  ;
#line 576
extern int chroot(char const   * ) ;
#line 190 "/usr/include/sys/_structs.h"
__inline static int __darwin_fd_isset(int _n , struct fd_set  const  *_p ) 
{ 

  {
#line 193
  return (_p->fds_bits[(unsigned long )_n / (sizeof(__int32_t ) * 8UL)] & (1 << (unsigned long )_n % (sizeof(__int32_t ) * 8UL)));
}
}
#line 39 "/usr/include/sys/_select.h"
extern int select(int  , fd_set * , fd_set * , fd_set * , struct timeval * )  __asm__("_select$1050")  ;
#line 464 "/usr/include/sys/fcntl.h"
extern int open(char const   * , int   , ...)  __asm__("_open")  ;
#line 466
extern int fcntl(int  , int   , ...)  __asm__("_fcntl")  ;
#line 407 "/usr/include/sys/signal.h"
extern void (*signal(int  , void (*)(int  ) ))(int  ) ;
#line 255 "/usr/include/sys/resource.h"
extern int setrlimit(int  , struct rlimit  const  * )  __asm__("_setrlimit")  ;
#line 44 "/usr/include/libkern/i386/_OSByteOrder.h"
__inline static __uint16_t _OSSwapInt16(__uint16_t _data ) 
{ 

  {
#line 50
  return ((__uint16_t )(((int )_data << 8) | ((int )_data >> 8)));
}
}
#line 60
//extern int ( /* missing proto */  __builtin_bswap32)() ;
#line 53 "/usr/include/libkern/i386/_OSByteOrder.h"
__inline static __uint32_t _OSSwapInt32(__uint32_t _data ) 
{ int tmp ;

  {
#line 60
  tmp = __builtin_bswap32(_data);
#line 60
  return ((__uint32_t )tmp);
}
}
#line 256 "/usr/include/sys/wait.h"
extern pid_t waitpid(pid_t  , int * , int  )  __asm__("_waitpid")  ;
#line 159 "/usr/include/stdlib.h"
extern  __attribute__((__noreturn__)) void exit(int  ) ;
#line 75 "/usr/include/sys/errno.h"
extern int *__error(void) ;
#line 91 "/usr/include/string.h"
extern char *strerror(int  )  __asm__("_strerror")  ;
#line 80 "/usr/include/secure/_string.h"
__inline static void *__inline_memset_chk(void *__dest , int __val , size_t __len ) 
{ unsigned long tmp ;
  void *tmp___0 ;

  {
#line 83
  tmp = __builtin_object_size(__dest, 0);
#line 83
  tmp___0 = __builtin___memset_chk(__dest, __val, __len, tmp);
#line 83
  return (tmp___0);
}
}
#line 133 "/usr/include/time.h"
extern time_t time(time_t * ) ;
#line 603 "/usr/include/sys/socket.h"
extern int accept(int  , struct sockaddr * , socklen_t * )  __asm__("_accept")  ;
#line 605
extern int bind(int  , struct sockaddr  const  * , socklen_t  )  __asm__("_bind")  ;
#line 612
extern int listen(int  , int  )  __asm__("_listen")  ;
#line 613
extern ssize_t recv(int  , void * , size_t  , int  )  __asm__("_recv")  ;
#line 614
extern ssize_t recvfrom(int  , void * , size_t  , int  , struct sockaddr * , socklen_t * )  __asm__("_recvfrom")  ;
#line 619
extern ssize_t sendto(int  , void const   * , size_t  , int  , struct sockaddr  const  * ,
                      socklen_t  )  __asm__("_sendto")  ;
#line 621
extern int setsockopt(int  , int  , int  , void const   * , socklen_t  ) ;
#line 624
extern int socket(int  , int  , int  ) ;
#line 83 "/usr/include/signal.h"
extern int killpg(pid_t  , int  )  __asm__("_killpg")  ;
#line 111 "../rng/rng-api-fst.h"
int makeKey(keyInstance *key___0 , MARA_BYTE direction , int keyLen , char *keyMaterial ) ;
#line 113
int cipherInit(cipherInstance *cipher , MARA_BYTE mode , char *IV ) ;
#line 115
int blockEncrypt(cipherInstance *cipher , keyInstance *key___0 , MARA_BYTE *input ,
                 int inputLen , MARA_BYTE *outBuffer ) ;
#line 29 "../dns/functions_dns.h"
int decompress_data(js_string *compressed , js_string *uncompressed ) ;
#line 37
int dlabel_length(js_string *raw , unsigned int offset ) ;
#line 52
int hname_2rfc1035(js_string *hostname ) ;
#line 75
int make_hdr(q_header *header , js_string *js ) ;
#line 91
int read_hdr(js_string *js , q_header *header ) ;
#line 141
int hname_translate(js_string *hostname , int qtype ) ;
#line 158
int decomp_init(int alog_level ) ;
#line 24 "../parse/functions_parse.h"
int read_kvar(js_string *name , js_string *value___0 ) ;
#line 33
int read_mararc(js_string *fileloc , js_string *errorstr , int *errorret ) ;
#line 39
int find_mararc(js_string *out ) ;
#line 52
int read_dvar(js_string *name , js_string *key___0 , js_string *value___0 ) ;
#line 69
int make_ip_acl(js_string *in , ipv4pair *out , int max , int depth ) ;
#line 79
int parse_csv1_line(js_string *line___0 , js_string *name , js_string *data , uint32_t *ttl ) ;
#line 90
int bs_process(js_string *in , js_string *out , js_string *sub ) ;
#line 215 "../parse/Csv2_functions.h"
int csv2_parse_zone_zoneserver(js_string *zone , int connect___0 , int soa_q , q_header *header ) ;
#line 26 "functions_tcp.h"
int libtcp_create_bind_addrs(void) ;
#line 33
ipv4pair *libtcp_bind_address(int type ) ;
#line 35
void set_soa_origin(js_string *in ) ;
#line 36
void set_soa_serial(int in ) ;
#line 65 "zoneserver.c"
int num_children  =    0;
#line 67 "zoneserver.c"
int srng_place  =    0;
#line 70 "zoneserver.c"
int csv2_tilde_handling  =    2;
#line 72 "zoneserver.c"
int verbose  =    0;
#line 74 "zoneserver.c"
int dns_records_served  =    0;
#line 77 "zoneserver.c"
int udp_forward_server  =    0;
#line 79 "zoneserver.c"
int dns_port  =    53;
#line 81 "zoneserver.c"
int no_cname_warnings  =    1;
#line 84 "zoneserver.c"
void handle_childs(void) 
{ pid_t tmp ;

  {
#line 85
  tmp = waitpid(0, (int *)((void *)0), 1);
#line 85
  if (tmp > 0) {
#line 86
    num_children --;
  }
#line 87
  return;
}
}
#line 90 "zoneserver.c"
void handle_term(void) 
{ pid_t tmp ;

  {
#line 91
  tmp = getpgrp();
#line 91
  killpg(tmp, 15);
#line 92
  exit(0);
}
}
#line 100 "zoneserver.c"
int mlog(char *logmessage ) 
{ 

  {
#line 102
  if ((unsigned long )logmessage == (unsigned long )((char *)0)) {
#line 103
    return (-1);
  }
#line 104
  printf("%s%s%s", "Log: ", logmessage, "\n");
#line 106
  return (1);
}
}
#line 114 "zoneserver.c"
void harderror(char *why ) 
{ pid_t tmp ;

  {
#line 115
  printf("%s%s%s", "Fatal error: ", why, "\n");
#line 116
  tmp = getpgrp();
#line 116
  killpg(tmp, 15);
#line 117
  exit(3);
}
}
#line 134 "zoneserver.c"
static MARA_BYTE r_inBlock[17]  ;
#line 134 "zoneserver.c"
static MARA_BYTE r_outBlock[17]  ;
#line 134 "zoneserver.c"
static MARA_BYTE r_binSeed[17]  ;
#line 135 "zoneserver.c"
static keyInstance r_seedInst  ;
#line 136 "zoneserver.c"
static cipherInstance r_cipherInst  ;
#line 125 "zoneserver.c"
uint16_t srng(void) 
{ js_string *kvar_query ;
  js_string *srng_filename ;
  unsigned char prng_seed[34] ;
  int desc ;
  int counter ;
  int max ;
  pid_t process_id ;
  char path[1026] ;
  uint16_t ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  int tmp___7 ;
  ssize_t tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 131
  process_id = 0;
#line 138
  if (srng_place == 0) {
#line 139
    kvar_query = js_create(256U, 1U);
#line 139
    if ((unsigned long )kvar_query == (unsigned long )((js_string *)0)) {
#line 141
      printf("AIEEEEE! I can not init string to make srng!\n");
#line 142
      exit(1);
    }
#line 144
    srng_filename = js_create(256U, 1U);
#line 144
    if ((unsigned long )srng_filename == (unsigned long )((js_string *)0)) {
#line 146
      printf("AIEEEEE! I can not init string to make srng filename!\n");
#line 147
      exit(1);
    }
#line 150
    tmp = js_qstr2js(kvar_query, (char *)"random_seed_file");
#line 150
    if (tmp == -1) {
#line 151
      printf("AIEEEEE! I can not set up srng!\n");
#line 152
      exit(1);
    }
#line 155
    tmp___0 = read_kvar(kvar_query, srng_filename);
#line 155
    if (tmp___0 != 1) {
#line 156
      srng_place = -1;
    }
#line 163
    tmp___2 = js_length(srng_filename);
#line 163
    if (tmp___2 == 0) {
#line 164
      tmp___1 = js_qstr2js(srng_filename, (char *)"/dev/urandom");
#line 164
      if (tmp___1 != 1) {
#line 165
        printf("AIEEEE! Can not set default random_seed_file");
#line 166
        exit(1);
      }
    }
#line 171
    tmp___4 = __builtin_object_size((void *)(r_inBlock), 0);
#line 171
    if (tmp___4 != 0xffffffffffffffffUL) {
#line 171
      tmp___3 = __builtin_object_size((void *)(r_inBlock), 0);
#line 171
      __builtin___memset_chk((void *)(r_inBlock), 0, 16UL, tmp___3);
    } else {
#line 171
      __inline_memset_chk((void *)(r_inBlock), 0, (size_t )16);
    }
#line 172
    time((time_t *)(& r_inBlock[0]));
#line 173
    tmp___6 = __builtin_object_size((void *)(r_binSeed), 0);
#line 173
    if (tmp___6 != 0xffffffffffffffffUL) {
#line 173
      tmp___5 = __builtin_object_size((void *)(r_binSeed), 0);
#line 173
      __builtin___memset_chk((void *)(r_binSeed), 0, 16UL, tmp___5);
    } else {
#line 173
      __inline_memset_chk((void *)(r_binSeed), 0, (size_t )16);
    }
#line 175
    tmp___7 = js_js2str(srng_filename, path, 1024);
#line 175
    if (tmp___7 == -1) {
#line 176
      printf("AIEEEEEE!  I can\'t convert random_seed_file filename.\n");
#line 177
      exit(1);
    }
#line 179
    desc = open((char const   *)(path), 0);
#line 179
    if (desc == -1) {
#line 180
      printf("AIEEEE! I can not read the random_seed_file file!\n");
#line 181
      printf("Make sure that ");
#line 182
      printf("%s", path);
#line 183
      printf(" points to a valid filename!\n");
    }
#line 185
    tmp___8 = read(desc, (void *)(prng_seed), (size_t )16);
#line 185
    if (tmp___8 != 16L) {
#line 186
      printf("AIEEEE! I can not read 16 bytes from random_seed_file!\n");
#line 187
      printf("Make sure that ");
#line 188
      printf("%s", path);
#line 189
      printf(" is at least 16 bytes long!\n");
    }
#line 191
    close(desc);
#line 192
    srng_place = 1;
#line 193
    return ((uint16_t )0);
  } else
#line 195
  if (srng_place == -1) {
#line 196
    printf("I could not get value for random_seed_file.\n");
#line 197
    printf("You must have this set in your mararc file.\n");
#line 198
    printf("Please add something like this to the mararc file\n");
#line 199
    printf("you are using:\n");
#line 200
    printf("\n\trandom_seed_file = \"/dev/urandom\"\n\n");
#line 201
    exit(1);
  } else
#line 205
  if (srng_place == 1) {
#line 209
    process_id = getpid();
#line 210
    max = (int )sizeof(pid_t );
#line 211
    if (max > 15) {
#line 212
      max = 15;
    }
#line 213
    counter = 0;
#line 213
    while (counter < max) {
#line 214
      prng_seed[15 - counter] = (unsigned char )((int )prng_seed[15 - counter] ^ (process_id & 255));
#line 215
      process_id >>= 8;
#line 213
      counter ++;
    }
#line 218
    tmp___9 = makeKey(& r_seedInst, (MARA_BYTE )0, 128, (char *)(prng_seed));
#line 218
    if (tmp___9 != 1) {
#line 219
      printf("AIEEE! Not able to make key\n");
#line 220
      exit(1);
    }
#line 222
    tmp___10 = cipherInit(& r_cipherInst, (MARA_BYTE )1, (char *)((void *)0));
#line 222
    if (tmp___10 != 1) {
#line 223
      printf("AIEEE! Not able to cinit\n");
#line 224
      exit(1);
    }
#line 226
    tmp___11 = blockEncrypt(& r_cipherInst, & r_seedInst, r_inBlock, 128, r_outBlock);
#line 226
    if (tmp___11 != 128) {
#line 228
      printf("AIEEE! Not able to benc\n");
#line 229
      exit(1);
    }
#line 231
    ret = (uint16_t )((((int )r_outBlock[0] & 255) << 8) | ((int )r_outBlock[1] & 255));
#line 233
    srng_place = 2;
#line 234
    return (ret);
  } else
#line 236
  if (srng_place < 14) {
#line 237
    ret = (uint16_t )((((int )r_outBlock[srng_place] & 255) << 8) | ((int )r_outBlock[srng_place + 1] & 255));
#line 239
    srng_place += 2;
#line 240
    return (ret);
  } else {
#line 243
    printf("AIEEEE!  srng has been run too many times!\n");
#line 244
    exit(1);
  }
#line 246
  printf("AIEEE! We should never get here in srng()\n");
#line 247
  exit(1);
#line 249
  return ((uint16_t )12);
}
}
#line 258 "zoneserver.c"
int tcpbind(int *sock , uint32_t ip ) 
{ int len_inet ;
  struct sockaddr_in dns_tcp ;
  int on ;
  __uint32_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  __uint16_t tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 261
  on = 1;
#line 264
  if ((unsigned long )sock == (unsigned long )((int *)0)) {
#line 265
    return (-1);
  }
#line 266
  if (ip == 4294967295U) {
#line 267
    return (-1);
  }
#line 270
  tmp = _OSSwapInt32(ip);
#line 270
  ip = tmp;
#line 273
  tmp___0 = socket(2, 1, 0);
#line 273
  *sock = tmp___0;
#line 273
  if (tmp___0 == -1) {
#line 274
    return (-1);
  }
#line 278
  tmp___1 = setsockopt(*sock, 65535, 4, (void const   *)((char *)(& on)), (socklen_t )sizeof(on));
#line 278
  if (tmp___1 == -1) {
#line 280
    return (-1);
  }
#line 284
  tmp___3 = __builtin_object_size((void *)(& dns_tcp), 0);
#line 284
  if (tmp___3 != 0xffffffffffffffffUL) {
#line 284
    tmp___2 = __builtin_object_size((void *)(& dns_tcp), 0);
#line 284
    __builtin___memset_chk((void *)(& dns_tcp), 0, sizeof(dns_tcp), tmp___2);
  } else {
#line 284
    __inline_memset_chk((void *)(& dns_tcp), 0, sizeof(dns_tcp));
  }
#line 285
  dns_tcp.sin_family = (sa_family_t )2;
#line 286
  tmp___4 = _OSSwapInt16((__uint16_t )dns_port);
#line 286
  dns_tcp.sin_port = (__uint16_t )((int )tmp___4);
#line 287
  dns_tcp.sin_addr.s_addr = ip;
#line 287
  if (dns_tcp.sin_addr.s_addr == 4294967295U) {
#line 288
    return (-1);
  }
#line 290
  len_inet = (int )sizeof(dns_tcp);
#line 293
  tmp___7 = bind(*sock, (struct sockaddr  const  *)((struct sockaddr *)(& dns_tcp)),
                 (socklen_t )len_inet);
#line 293
  if (tmp___7 == -1) {
#line 294
    printf("Unable to bind to to IP: ");
#line 295
    tmp___5 = __error();
#line 295
    tmp___6 = strerror(*tmp___5);
#line 295
    printf("%s", tmp___6);
#line 296
    printf("\n");
#line 297
    return (-1);
  }
#line 301
  tmp___8 = listen(*sock, 250);
#line 301
  if (tmp___8 == -1) {
#line 302
    return (-1);
  }
#line 305
  return (1);
}
}
#line 320 "zoneserver.c"
int gettcp(int *sock , ipv4pair *acl1 , ipv4pair *acl2 , ipv4pair *acl3 , int max ,
           int *perm ) 
{ int ret ;
  int counter ;
  struct sockaddr_in adr_clnt ;
  int len_inet ;
  uint32_t ip ;
  __uint32_t tmp ;

  {
#line 327
  len_inet = (int )sizeof(adr_clnt);
#line 328
  ret = accept(*sock, (struct sockaddr *)(& adr_clnt), (socklen_t *)(& len_inet));
#line 330
  if (ret == -1) {
#line 331
    return (-1);
  }
#line 334
  tmp = _OSSwapInt32(adr_clnt.sin_addr.s_addr);
#line 334
  ip = tmp;
#line 335
  *perm = 0;
#line 337
  counter = 0;
#line 338
  while (1) {
#line 338
    if (counter < max) {
#line 338
      if (! ((acl1 + counter)->ip != 4294967295U)) {
#line 338
        break;
      }
    } else {
#line 338
      break;
    }
#line 339
    if ((ip & (acl1 + counter)->mask) == ((acl1 + counter)->ip & (acl1 + counter)->mask)) {
#line 341
      *perm = 1;
    }
#line 342
    counter ++;
  }
#line 346
  counter = 0;
#line 347
  while (1) {
#line 347
    if (counter < max) {
#line 347
      if (! ((acl2 + counter)->ip != 4294967295U)) {
#line 347
        break;
      }
    } else {
#line 347
      break;
    }
#line 348
    if ((ip & (acl2 + counter)->mask) == ((acl2 + counter)->ip & (acl2 + counter)->mask)) {
#line 350
      *perm += 2;
    }
#line 351
    counter ++;
  }
#line 355
  counter = 0;
#line 356
  while (1) {
#line 356
    if (counter < max) {
#line 356
      if (! ((acl3 + counter)->ip != 4294967295U)) {
#line 356
        break;
      }
    } else {
#line 356
      break;
    }
#line 357
    if ((ip & (acl3 + counter)->mask) == ((acl3 + counter)->ip & (acl3 + counter)->mask)) {
#line 359
      *perm += 4;
    }
#line 360
    counter ++;
  }
#line 363
  if ((*perm & 3) == 0) {
#line 366
    close(ret);
#line 367
    if (verbose >= 4) {
#line 368
      printf("Failed zone transfer attempt from IP %d.%d.%d.%d\n", ip >> 24, (ip >> 16) & 255U,
             (ip >> 8) & 255U, ip & 255U);
    }
#line 374
    return (-1);
  } else {
#line 377
    return (ret);
  }
#line 381
  close(ret);
#line 382
  return (-1);
}
}
#line 392 "zoneserver.c"
int convert_query(int tcp_connect , void *udp_ip , int udp_ip_type , js_string *packet ,
                  int perm_mask ) 
{ struct sockaddr_in dns_udp ;
  struct sockaddr_in server ;
  int s ;
  int result ;
  fd_set rx_set ;
  struct timeval timeout ;
  int *ipv4_ip ;
  int n ;
  int maxd ;
  int tcp_id ;
  int udp_id ;
  int len_inet ;
  js_string *outdata ;
  js_string *indata ;
  int sid ;
  int len ;
  unsigned char get[2] ;
  q_header header ;
  int tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  __uint32_t tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  uint16_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  uint16_t tmp___14 ;
  __uint16_t tmp___15 ;
  int tmp___16 ;
  ssize_t tmp___17 ;
  int __fd ;
  ssize_t tmp___18 ;
  int tmp___19 ;
  ssize_t tmp___20 ;
  ssize_t tmp___21 ;

  {
#line 411
  tmp = js_has_sanity(packet);
#line 411
  if (tmp != 1) {
#line 412
    return (-1);
  }
#line 413
  if (udp_ip_type != 4) {
#line 414
    return (-1);
  }
#line 416
  tcp_id = ((int )*(packet->string) << 8) | (int )*(packet->string + 1);
#line 420
  ipv4_ip = (int *)udp_ip;
#line 422
  if ((unsigned int )*ipv4_ip == 4294967295U) {
#line 424
    return (-1);
  } else
#line 422
  if (*ipv4_ip == 0) {
#line 424
    return (-1);
  }
#line 426
  tmp___1 = __builtin_object_size((void *)(& server), 0);
#line 426
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 426
    tmp___0 = __builtin_object_size((void *)(& server), 0);
#line 426
    __builtin___memset_chk((void *)(& server), 0, sizeof(server), tmp___0);
  } else {
#line 426
    __inline_memset_chk((void *)(& server), 0, sizeof(server));
  }
#line 427
  server.sin_family = (sa_family_t )2;
#line 428
  server.sin_port = (__uint16_t )((int )((__uint16_t )(53 << 8)));
#line 429
  tmp___3 = _OSSwapInt32((__uint32_t )*ipv4_ip);
#line 429
  server.sin_addr.s_addr = tmp___3;
#line 429
  if (server.sin_addr.s_addr == 4294967295U) {
#line 430
    return (-1);
  }
#line 433
  tmp___5 = __builtin_object_size((void *)(& dns_udp), 0);
#line 433
  if (tmp___5 != 0xffffffffffffffffUL) {
#line 433
    tmp___4 = __builtin_object_size((void *)(& dns_udp), 0);
#line 433
    __builtin___memset_chk((void *)(& dns_udp), 0, sizeof(dns_udp), tmp___4);
  } else {
#line 433
    __inline_memset_chk((void *)(& dns_udp), 0, sizeof(dns_udp));
  }
#line 434
  dns_udp.sin_family = (sa_family_t )2;
#line 436
  dns_udp.sin_addr.s_addr = (in_addr_t )((__uint16_t )((int )((__uint16_t )0)));
#line 437
  len_inet = (int )sizeof(dns_udp);
#line 439
  tmp___7 = srng();
#line 439
  sid = (int )tmp___7;
#line 440
  header.id = (uint16_t )sid;
#line 441
  header.qr = 0;
#line 442
  header.opcode = 0;
#line 443
  header.aa = 0;
#line 444
  header.tc = 0;
#line 447
  if ((perm_mask & 4) == 4) {
#line 448
    header.rd = 1;
  } else {
#line 451
    header.rd = 0;
  }
#line 453
  header.ra = 0;
#line 454
  header.z = 0;
#line 455
  header.rcode = 0;
#line 456
  header.qdcount = (uint16_t )1;
#line 457
  header.ancount = (uint16_t )0;
#line 458
  header.nscount = (uint16_t )0;
#line 459
  header.arcount = (uint16_t )0;
#line 466
  outdata = js_create(2500U, 1U);
#line 466
  if ((unsigned long )outdata == (unsigned long )((js_string *)0)) {
#line 467
    return (-1);
  }
#line 470
  tmp___8 = make_hdr(& header, outdata);
#line 470
  if (tmp___8 == -1) {
#line 471
    js_destroy(outdata);
#line 472
    return (-1);
  }
#line 475
  len = dlabel_length(packet, 12U);
#line 476
  len += 2;
#line 478
  tmp___9 = js_substr_append(packet, outdata, 12, len);
#line 478
  if (tmp___9 == -1) {
#line 479
    js_destroy(outdata);
#line 480
    return (-1);
  }
#line 483
  tmp___10 = js_adduint16(outdata, 1);
#line 483
  if (tmp___10 == -1) {
#line 484
    js_destroy(outdata);
#line 485
    return (-1);
  }
#line 490
  s = socket(2, 2, 0);
#line 490
  if (s == -1) {
#line 491
    js_destroy(outdata);
#line 492
    return (-1);
  }
#line 497
  tmp___14 = srng();
#line 497
  tmp___15 = _OSSwapInt16((__uint16_t )(15000 + ((int )tmp___14 & 4095)));
#line 497
  dns_udp.sin_port = (__uint16_t )((int )tmp___15);
#line 498
  tmp___16 = bind(s, (struct sockaddr  const  *)((struct sockaddr *)(& dns_udp)),
                  (socklen_t )sizeof(dns_udp));
#line 498
  if (tmp___16 < 0) {
#line 499
    js_destroy(outdata);
#line 500
    return (-1);
  }
#line 503
  tmp___17 = sendto(s, (void const   *)outdata->string, (size_t )outdata->unit_count,
                    0, (struct sockaddr  const  *)((struct sockaddr *)(& server)),
                    (socklen_t )len_inet);
#line 503
  result = (int )tmp___17;
#line 505
  if (result < 0) {
#line 506
    close(s);
#line 507
    js_destroy(outdata);
#line 508
    return (-1);
  }
#line 511
  __builtin_bzero((void *)(& rx_set), sizeof(rx_set));
#line 512
  while (1) {
#line 512
    __fd = s;
#line 512
    rx_set.fds_bits[(unsigned long )__fd / (sizeof(__int32_t ) * 8UL)] |= 1 << (unsigned long )__fd % (sizeof(__int32_t ) * 8UL);
#line 512
    break;
  }
#line 513
  maxd = s + 1;
#line 514
  timeout.tv_sec = (__darwin_time_t )5;
#line 515
  timeout.tv_usec = 0;
#line 516
  n = select(maxd, & rx_set, (fd_set *)((void *)0), (fd_set *)((void *)0), & timeout);
#line 517
  if (n <= 0) {
#line 518
    close(s);
#line 519
    js_destroy(outdata);
#line 520
    return (-1);
  }
#line 524
  indata = js_create(4100U, 1U);
#line 524
  if ((unsigned long )indata == (unsigned long )((js_string *)0)) {
#line 525
    return (-1);
  }
#line 528
  tmp___18 = recvfrom(s, (void *)indata->string, (size_t )indata->max_count, 0, (struct sockaddr *)(& dns_udp),
                      (socklen_t *)(& len_inet));
#line 528
  result = (int )tmp___18;
#line 531
  if (result < 0) {
#line 532
    close(s);
#line 534
    js_destroy(outdata);
#line 535
    js_destroy(indata);
#line 536
    return (-1);
  }
#line 540
  close(s);
#line 544
  indata->unit_count = (unsigned int )result;
#line 546
  tmp___19 = decompress_data(indata, outdata);
#line 546
  if (tmp___19 == -1) {
#line 547
    js_destroy(outdata);
#line 548
    js_destroy(indata);
#line 549
    return (-1);
  }
#line 553
  udp_id = ((int )*(outdata->string) << 8) | (int )*(outdata->string + 1);
#line 554
  if (udp_id != sid) {
#line 555
    js_destroy(outdata);
#line 556
    js_destroy(indata);
#line 557
    return (-1);
  }
#line 563
  *(outdata->string) = (unsigned char )((tcp_id & 65280) >> 8);
#line 564
  *(outdata->string + 1) = (unsigned char )(tcp_id & 255);
#line 567
  get[0] = (unsigned char )((outdata->unit_count & 65280U) >> 8);
#line 568
  get[1] = (unsigned char )(outdata->unit_count & 255U);
#line 569
  tmp___20 = write(tcp_connect, (void const   *)(get), (size_t )2);
#line 569
  if (tmp___20 == -1L) {
#line 570
    js_destroy(outdata);
#line 571
    js_destroy(indata);
#line 572
    return (-1);
  }
#line 574
  tmp___21 = write(tcp_connect, (void const   *)outdata->string, (size_t )outdata->unit_count);
#line 574
  if (tmp___21 == -1L) {
#line 575
    js_destroy(outdata);
#line 576
    js_destroy(indata);
#line 577
    return (-1);
  }
#line 580
  close(tcp_connect);
#line 582
  return (1);
}
}
#line 595 "zoneserver.c"
int serve_zone(int connect___0 , int perms ) 
{ int length ;
  int rr_type ;
  q_header header ;
  q_header soa_reply_header ;
  js_file desc ;
  unsigned char get[2] ;
  js_string *name ;
  js_string *data ;
  js_string *zone ;
  js_string *query ;
  js_string *response ;
  js_string *soa ;
  js_string *filename ;
  js_string *binzone ;
  int is_soa ;
  int soa_q ;
  int counter ;
  uint32_t ttl ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  ssize_t tmp___2 ;
  ssize_t tmp___3 ;
  ssize_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  ssize_t tmp___33 ;
  ssize_t tmp___34 ;
  ssize_t tmp___35 ;
  ssize_t tmp___36 ;
  ssize_t tmp___37 ;
  ssize_t tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  ssize_t tmp___49 ;
  ssize_t tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  ssize_t tmp___53 ;
  ssize_t tmp___54 ;

  {
#line 602
  is_soa = 1;
#line 602
  soa_q = 0;
#line 607
  alarm(30U);
#line 610
  name = js_create(853U, 1U);
#line 610
  if ((unsigned long )name == (unsigned long )((js_string *)0)) {
#line 611
    return (-1);
  }
#line 612
  tmp = js_set_encode(name, 3);
#line 612
  if (tmp == -1) {
#line 613
    return (-1);
  }
#line 614
  data = js_create(853U, 1U);
#line 614
  if ((unsigned long )data == (unsigned long )((js_string *)0)) {
#line 615
    js_destroy(name);
#line 616
    return (-1);
  }
#line 618
  tmp___0 = js_set_encode(data, 3);
#line 618
  if (tmp___0 == -1) {
#line 619
    goto clean_nd;
  }
#line 622
  if (connect___0 == 1) {
#line 623
    tmp___1 = read(0, (void *)(get), (size_t )2);
#line 623
    if (tmp___1 != 2L) {
#line 624
      goto clean_nd;
    }
  } else {
#line 627
    tmp___2 = recv(connect___0, (void *)(get), (size_t )2, 64);
#line 627
    if (tmp___2 != 2L) {
#line 628
      goto clean_nd;
    }
  }
#line 632
  length = (((int )get[0] & 255) << 8) | ((int )get[1] & 255);
#line 633
  if (length > 380) {
#line 634
    goto clean_nd;
  }
#line 637
  if (connect___0 == 1) {
#line 638
    tmp___3 = read(0, (void *)name->string, (size_t )length);
#line 638
    if (tmp___3 != (ssize_t )length) {
#line 639
      goto clean_nd;
    }
  } else {
#line 642
    tmp___4 = recv(connect___0, (void *)name->string, (size_t )length, 64);
#line 642
    if (tmp___4 != (ssize_t )length) {
#line 643
      goto clean_nd;
    }
  }
#line 646
  name->unit_count = (unsigned int )length;
#line 648
  tmp___5 = decompress_data(name, data);
#line 648
  if (tmp___5 == -1) {
#line 649
    goto clean_nd;
  }
#line 653
  tmp___6 = read_hdr(data, & header);
#line 653
  if (tmp___6 == -1) {
#line 654
    goto clean_nd;
  }
#line 658
  if (header.qr != 0) {
#line 659
    goto clean_nd;
  }
#line 664
  if ((perms & 1) != 1) {
#line 665
    if ((perms & 2) == 2) {
#line 666
      convert_query(connect___0, (void *)(& udp_forward_server), 4, data, perms);
#line 667
      return (1);
    }
#line 669
    goto clean_nd;
  }
#line 673
  length = dlabel_length(data, 12U);
#line 674
  if (length == -1) {
#line 675
    goto clean_nd;
  }
#line 678
  tmp___7 = js_substr(data, name, 12, length);
#line 678
  if (tmp___7 == -1) {
#line 679
    goto clean_nd;
  }
#line 682
  if (data->unit_count < (unsigned int )(14 + length)) {
#line 683
    goto clean_nd;
  }
#line 685
  if ((int )*((data->string + 12) + length) != 0) {
#line 687
    if ((perms & 2) == 2) {
#line 688
      convert_query(connect___0, (void *)(& udp_forward_server), 4, data, perms);
#line 689
      return (1);
    }
#line 691
    goto clean_nd;
  }
#line 694
  switch ((int )*((data->string + 13) + length)) {
  case 6: 
#line 696
  soa_q = 1;
  case 251: 
  case 252: 
#line 699
  break;
  default: 
#line 705
  if ((perms & 2) == 2) {
#line 706
    convert_query(connect___0, (void *)(& udp_forward_server), 4, data, perms);
#line 707
    return (1);
  }
#line 711
  goto clean_nd;
  }
#line 715
  binzone = js_create(260U, 1U);
#line 715
  if ((unsigned long )binzone == (unsigned long )((js_string *)0)) {
#line 716
    goto clean_nd;
  }
#line 718
  tmp___8 = js_copy(name, binzone);
#line 718
  if (tmp___8 == -1) {
#line 719
    goto clean_ndb;
  }
#line 723
  counter = 0;
#line 723
  while ((unsigned int )counter < name->unit_count) {
#line 724
    if ((int )*(name->string + counter) >= 65) {
#line 724
      if ((int )*(name->string + counter) <= 90) {
#line 726
        *(name->string + counter) = (unsigned char )((int )*(name->string + counter) + 32);
      }
    }
#line 723
    counter ++;
  }
#line 731
  tmp___9 = hname_translate(name, 1);
#line 731
  if (tmp___9 == -1) {
#line 732
    goto clean_ndb;
  }
#line 733
  tmp___10 = js_substr(name, data, 1, (int )(name->unit_count - 1U));
#line 733
  if (tmp___10 == -1) {
#line 734
    goto clean_ndb;
  }
#line 737
  tmp___11 = js_qstr2js(name, (char *)"csv1");
#line 737
  if (tmp___11 == -1) {
#line 738
    goto clean_ndb;
  }
#line 741
  alarm(0U);
#line 742
  tmp___13 = read_dvar(name, data, name);
#line 742
  if (tmp___13 == -1) {
#line 745
    tmp___12 = csv2_parse_zone_zoneserver(data, connect___0, soa_q, & header);
#line 745
    if (tmp___12 == 1) {
#line 748
      exit(0);
    }
#line 750
    mlog((char *)"Zone we do not have asked for, disconnecting");
#line 751
    goto clean_ndb;
  }
#line 756
  filename = js_create(390U, 1U);
#line 756
  if ((unsigned long )filename == (unsigned long )((js_string *)0)) {
#line 757
    goto clean_ndb;
  }
#line 759
  tmp___14 = js_copy(name, filename);
#line 759
  if (tmp___14 == -1) {
#line 760
    js_destroy(filename);
#line 761
    goto clean_ndb;
  }
#line 765
  zone = js_create(390U, 1U);
#line 765
  if ((unsigned long )zone == (unsigned long )((js_string *)0)) {
#line 766
    goto clean_ndb;
  }
#line 767
  tmp___15 = js_copy(data, zone);
#line 767
  if (tmp___15 == -1) {
#line 768
    js_destroy(filename);
#line 768
    js_destroy(zone);
#line 769
    goto clean_ndb;
  }
#line 772
  query = js_create(390U, 1U);
#line 772
  if ((unsigned long )query == (unsigned long )((js_string *)0)) {
#line 773
    js_destroy(zone);
#line 773
    js_destroy(filename);
#line 774
    goto clean_ndb;
  }
#line 776
  tmp___16 = js_set_encode(query, 3);
#line 776
  if (tmp___16 == -1) {
#line 777
    js_destroy(zone);
#line 777
    js_destroy(query);
#line 777
    js_destroy(filename);
#line 778
    goto clean_ndb;
  }
#line 781
  response = js_create(512U, 1U);
#line 781
  if ((unsigned long )response == (unsigned long )((js_string *)0)) {
#line 782
    js_destroy(zone);
#line 782
    js_destroy(query);
#line 782
    js_destroy(filename);
#line 783
    goto clean_ndb;
  }
#line 785
  tmp___17 = js_set_encode(response, 3);
#line 785
  if (tmp___17 == -1) {
#line 786
    js_destroy(zone);
#line 786
    js_destroy(query);
#line 786
    js_destroy(response);
#line 787
    js_destroy(filename);
#line 788
    goto clean_ndb;
  }
#line 791
  soa = js_create(390U, 1U);
#line 791
  if ((unsigned long )soa == (unsigned long )((js_string *)0)) {
#line 792
    js_destroy(zone);
#line 792
    js_destroy(query);
#line 792
    js_destroy(response);
#line 793
    js_destroy(filename);
#line 794
    goto clean_ndb;
  }
#line 796
  tmp___18 = js_set_encode(soa, 3);
#line 796
  if (tmp___18 == -1) {
#line 797
    goto clean_ndzqrs;
  }
#line 800
  tmp___19 = js_open_read(filename, & desc);
#line 800
  if (tmp___19 == -1) {
#line 801
    goto clean_ndzqrs;
  }
#line 804
  header.aa = 1;
#line 804
  header.qr = header.aa;
#line 805
  header.ancount = (uint16_t )1;
#line 806
  header.arcount = (uint16_t )0;
#line 806
  header.nscount = header.arcount;
#line 806
  header.qdcount = header.nscount;
#line 806
  header.rcode = (int )header.qdcount;
#line 806
  header.z = header.rcode;
#line 806
  header.ra = header.z;
#line 806
  header.tc = header.ra;
#line 806
  header.opcode = header.tc;
#line 812
  if (soa_q == 1) {
#line 813
    soa_reply_header = header;
#line 816
    tmp___20 = make_hdr(& soa_reply_header, response);
#line 816
    if (tmp___20 == -1) {
#line 817
      goto clean_ndzqrs;
    }
#line 819
    tmp___21 = js_append(binzone, response);
#line 819
    if (tmp___21 == -1) {
#line 820
      goto clean_ndzqrs;
    }
#line 821
    tmp___22 = js_adduint16(response, 6);
#line 821
    if (tmp___22 == -1) {
#line 822
      goto clean_ndzqrs;
    }
#line 823
    tmp___23 = js_adduint16(response, 1);
#line 823
    if (tmp___23 == -1) {
#line 824
      goto clean_ndzqrs;
    }
#line 825
    soa_reply_header.qdcount = (uint16_t )1;
#line 827
    while (1) {
#line 827
      tmp___31 = js_buf_eof(& desc);
#line 827
      if (tmp___31) {
#line 827
        break;
      }
#line 829
      tmp___24 = js_buf_getline(& desc, data);
#line 829
      if (tmp___24 <= -1) {
#line 830
        goto clean_ndzqrs;
      }
#line 832
      tmp___25 = bs_process(data, name, zone);
#line 832
      if (tmp___25 == -1) {
#line 833
        goto clean_ndzqrs;
      }
#line 835
      rr_type = parse_csv1_line(name, query, data, & ttl);
#line 836
      if (rr_type == -1) {
#line 837
        goto clean_ndzqrs;
      }
#line 838
      if (rr_type == -2) {
#line 839
        continue;
      }
#line 840
      if (rr_type > 0) {
#line 840
        if (rr_type < 65536) {
#line 842
          if (soa_q == 2) {
#line 842
            if (rr_type != 2) {
#line 843
              soa_q = 0;
            }
          }
#line 846
          if (soa_q > 0) {
#line 848
            tmp___26 = js_append(query, response);
#line 848
            if (tmp___26 == -1) {
#line 849
              goto clean_ndzqrs;
            }
#line 850
            tmp___27 = js_adduint16(response, 1);
#line 850
            if (tmp___27 == -1) {
#line 851
              goto clean_ndzqrs;
            }
#line 852
            tmp___28 = js_adduint32(response, ttl);
#line 852
            if (tmp___28 == -1) {
#line 853
              goto clean_ndzqrs;
            }
#line 854
            tmp___29 = js_adduint16(response, (int )data->unit_count);
#line 854
            if (tmp___29 == -1) {
#line 855
              goto clean_ndzqrs;
            }
#line 856
            tmp___30 = js_append(data, response);
#line 856
            if (tmp___30 == -1) {
#line 857
              goto clean_ndzqrs;
            }
#line 859
            if (soa_q == 1) {
#line 860
              soa_q = 2;
            } else
#line 861
            if (soa_q == 2) {
#line 862
              soa_reply_header.nscount = (uint16_t )((int )soa_reply_header.nscount + 1);
            }
          }
        }
      }
    }
#line 869
    soa_q = (int )response->unit_count;
#line 870
    tmp___32 = make_hdr(& soa_reply_header, response);
#line 870
    if (tmp___32 == -1) {
#line 871
      goto clean_ndzqrs;
    }
#line 872
    response->unit_count = (unsigned int )soa_q;
#line 873
    soa_q = 0;
#line 875
    get[0] = (unsigned char )((response->unit_count & 65280U) >> 8);
#line 876
    get[1] = (unsigned char )(response->unit_count & 255U);
#line 877
    tmp___33 = write(connect___0, (void const   *)(get), (size_t )2);
#line 877
    if (tmp___33 == -1L) {
#line 878
      goto clean_ndzqrs;
    }
#line 879
    tmp___34 = write(connect___0, (void const   *)response->string, (size_t )response->unit_count);
#line 879
    if (tmp___34 == -1L) {
#line 880
      goto clean_ndzqrs;
    }
#line 885
    if (connect___0 == 1) {
#line 886
      tmp___35 = read(0, (void *)(get), (size_t )2);
#line 886
      if (tmp___35 != 2L) {
#line 887
        goto clean_ndzqrs;
      }
    } else {
#line 890
      tmp___36 = recv(connect___0, (void *)(get), (size_t )2, 64);
#line 890
      if (tmp___36 != 2L) {
#line 891
        goto clean_ndzqrs;
      }
    }
#line 895
    length = (((int )get[0] & 255) << 8) | ((int )get[1] & 255);
#line 897
    while (length > 0) {
#line 898
      if (connect___0 == 1) {
#line 899
        tmp___37 = read(0, (void *)(get), (size_t )1);
#line 899
        if (tmp___37 != 1L) {
#line 900
          goto clean_ndzqrs;
        }
      } else {
#line 903
        tmp___38 = recv(connect___0, (void *)(get), (size_t )1, 64);
#line 903
        if (tmp___38 != 1L) {
#line 904
          goto clean_ndzqrs;
        }
      }
#line 906
      length --;
    }
#line 911
    tmp___39 = js_close(& desc);
#line 911
    if (tmp___39 == -1) {
#line 912
      goto clean_ndzqrs;
    }
#line 913
    tmp___40 = js_open_read(filename, & desc);
#line 913
    if (tmp___40 == -1) {
#line 914
      goto clean_ndzqrs;
    }
  }
#line 919
  while (1) {
#line 919
    tmp___52 = js_buf_eof(& desc);
#line 919
    if (tmp___52) {
#line 919
      break;
    }
#line 921
    tmp___41 = js_buf_getline(& desc, data);
#line 921
    if (tmp___41 <= -1) {
#line 922
      goto clean_ndzqrs;
    }
#line 924
    tmp___42 = bs_process(data, name, zone);
#line 924
    if (tmp___42 == -1) {
#line 925
      goto clean_ndzqrs;
    }
#line 927
    rr_type = parse_csv1_line(name, query, data, & ttl);
#line 928
    if (rr_type == -1) {
#line 929
      goto clean_ndzqrs;
    }
#line 930
    if (rr_type == -2) {
#line 931
      continue;
    }
#line 932
    if (rr_type > 0) {
#line 932
      if (rr_type < 65536) {
#line 934
        tmp___43 = make_hdr(& header, response);
#line 934
        if (tmp___43 == -1) {
#line 935
          goto clean_ndzqrs;
        }
#line 938
        tmp___44 = js_append(query, response);
#line 938
        if (tmp___44 == -1) {
#line 939
          goto clean_ndzqrs;
        }
#line 940
        tmp___45 = js_adduint16(response, 1);
#line 940
        if (tmp___45 == -1) {
#line 941
          goto clean_ndzqrs;
        }
#line 942
        tmp___46 = js_adduint32(response, ttl);
#line 942
        if (tmp___46 == -1) {
#line 943
          goto clean_ndzqrs;
        }
#line 944
        tmp___47 = js_adduint16(response, (int )data->unit_count);
#line 944
        if (tmp___47 == -1) {
#line 945
          goto clean_ndzqrs;
        }
#line 947
        tmp___48 = js_append(data, response);
#line 947
        if (tmp___48 == -1) {
#line 948
          goto clean_ndzqrs;
        }
#line 950
        get[0] = (unsigned char )((response->unit_count & 65280U) >> 8);
#line 951
        get[1] = (unsigned char )(response->unit_count & 255U);
#line 952
        tmp___49 = write(connect___0, (void const   *)(get), (size_t )2);
#line 952
        if (tmp___49 == -1L) {
#line 953
          goto clean_ndzqrs;
        }
#line 954
        tmp___50 = write(connect___0, (void const   *)response->string, (size_t )response->unit_count);
#line 954
        if (tmp___50 == -1L) {
#line 955
          goto clean_ndzqrs;
        }
#line 958
        if (is_soa == 1) {
#line 958
          if (rr_type == 6) {
#line 959
            is_soa = 0;
#line 960
            tmp___51 = js_copy(response, soa);
#line 960
            if (tmp___51 == -1) {
#line 961
              goto clean_ndzqrs;
            }
          }
        }
      }
    }
  }
#line 966
  if (is_soa == 0) {
#line 967
    get[0] = (unsigned char )((soa->unit_count & 65280U) >> 8);
#line 968
    get[1] = (unsigned char )(soa->unit_count & 255U);
#line 969
    tmp___53 = write(connect___0, (void const   *)(get), (size_t )2);
#line 969
    if (tmp___53 == -1L) {
#line 970
      goto clean_ndzqrs;
    }
#line 971
    tmp___54 = write(connect___0, (void const   *)soa->string, (size_t )soa->unit_count);
#line 971
    if (tmp___54 == -1L) {
#line 972
      goto clean_ndzqrs;
    }
  }
#line 974
  close(connect___0);
#line 977
  js_destroy(soa);
#line 978
  js_destroy(response);
#line 979
  js_destroy(query);
#line 980
  js_destroy(zone);
#line 981
  js_destroy(filename);
#line 982
  js_destroy(binzone);
#line 983
  js_destroy(name);
#line 984
  js_destroy(data);
#line 985
  js_close(& desc);
#line 986
  return (1);
  clean_ndzqrs: 
#line 990
  js_destroy(soa);
#line 991
  js_destroy(response);
#line 992
  js_destroy(query);
#line 993
  js_destroy(zone);
#line 994
  js_destroy(filename);
  clean_ndb: 
#line 996
  js_destroy(binzone);
  clean_nd: 
#line 998
  js_destroy(name);
#line 999
  js_destroy(data);
#line 1000
  close(connect___0);
#line 1001
  js_close(& desc);
#line 1002
  return (-1);
}
}
#line 1007 "zoneserver.c"
int main(int argc , char **argv ) 
{ js_string *mararc_loc ;
  js_string *errors ;
  js_string *chrootn ;
  js_string *kvar_str ;
  js_string *maxpstr ;
  js_string *kvar_query ;
  js_string *bind_address ;
  js_string *incoming ;
  js_string *uncomp ;
  js_string *verbstr ;
  unsigned char chroot_zt[255] ;
  int errorn ;
  int sock ;
  int maxprocs ;
  int counter ;
  int connection ;
  int inetd ;
  struct rlimit rlim ;
  pid_t pid ;
  uid_t uid ;
  gid_t gid ;
  ipv4pair zonetransfer_acl[512] ;
  ipv4pair tcpconvert_acl[512] ;
  ipv4pair recursive_acl[512] ;
  ipv4pair tcpconvert_servers[512] ;
  int synth_soa_serial___0 ;
  js_string *synth_soa_origin___0 ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  unsigned int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  unsigned int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  ipv4pair *bind_addresses ;
  int bind_address_iterate ;
  int stream1[2] ;
  int tmp___29 ;
  int tmp___30 ;
  fd_set child_set ;
  fd_set read_set ;
  char buf[1024] ;
  ssize_t readed ;
  int tmp___31 ;
  int __fd ;
  int __fd___0 ;
  int tmp___32 ;
  int nowarn ;
  ssize_t tmp___33 ;
  int __fd___1 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  uid_t tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int permissions ;
  pid_t tmp___57 ;

  {
#line 1012
  inetd = 0;
#line 1017
  pid = 0;
#line 1026
  tmp___1 = setpgid(0, 0);
#line 1026
  if (tmp___1) {
#line 1027
    tmp = __error();
#line 1027
    tmp___0 = strerror(*tmp);
#line 1027
    printf("%s", tmp___0);
#line 1028
    return (3);
  }
#line 1030
  signal(15, (void (*)(int  ))(& handle_term));
#line 1033
  mararc_loc = js_create(256U, 1U);
#line 1033
  if ((unsigned long )mararc_loc == (unsigned long )((js_string *)0)) {
#line 1034
    harderror((char *)"Could not create mararc_loc string");
  }
#line 1035
  tmp___2 = js_set_encode(mararc_loc, 3);
#line 1035
  if (tmp___2 == -1) {
#line 1036
    harderror((char *)"Could not set locale for mararc_loc string");
  }
#line 1037
  errors = js_create(256U, 1U);
#line 1037
  if ((unsigned long )errors == (unsigned long )((js_string *)0)) {
#line 1038
    harderror((char *)"Could not create errors string");
  }
#line 1039
  tmp___3 = js_set_encode(errors, 3);
#line 1039
  if (tmp___3 == -1) {
#line 1040
    harderror((char *)"Could not set locale for errors string");
  }
#line 1041
  kvar_str = js_create(256U, 1U);
#line 1041
  if ((unsigned long )kvar_str == (unsigned long )((js_string *)0)) {
#line 1042
    harderror((char *)"Could not create kvar_str string");
  }
#line 1043
  tmp___4 = js_set_encode(kvar_str, 3);
#line 1043
  if (tmp___4 == -1) {
#line 1044
    harderror((char *)"Could not set locale for kvar_str string");
  }
#line 1045
  verbstr = js_create(256U, 1U);
#line 1045
  if ((unsigned long )verbstr == (unsigned long )((js_string *)0)) {
#line 1046
    harderror((char *)"Could not create verbstr string");
  }
#line 1047
  tmp___5 = js_set_encode(verbstr, 3);
#line 1047
  if (tmp___5 == -1) {
#line 1048
    harderror((char *)"Could not set locale for verbstr string");
  }
#line 1049
  maxpstr = js_create(256U, 1U);
#line 1049
  if ((unsigned long )maxpstr == (unsigned long )((js_string *)0)) {
#line 1050
    harderror((char *)"Could not create maxpstr string");
  }
#line 1051
  tmp___6 = js_set_encode(maxpstr, 3);
#line 1051
  if (tmp___6 == -1) {
#line 1052
    harderror((char *)"Could not set locale for maxpstr string");
  }
#line 1053
  chrootn = js_create(256U, 1U);
#line 1053
  if ((unsigned long )chrootn == (unsigned long )((js_string *)0)) {
#line 1054
    harderror((char *)"Could not create chrootn string");
  }
#line 1055
  tmp___7 = js_set_encode(chrootn, 3);
#line 1055
  if (tmp___7 == -1) {
#line 1056
    harderror((char *)"Could not set locale for chrootn string");
  }
#line 1057
  kvar_query = js_create(256U, 1U);
#line 1057
  if ((unsigned long )kvar_query == (unsigned long )((js_string *)0)) {
#line 1058
    harderror((char *)"Could not create kvar_query string");
  }
#line 1059
  tmp___8 = js_set_encode(kvar_query, 3);
#line 1059
  if (tmp___8 == -1) {
#line 1060
    harderror((char *)"Could not set locale for kvar_query string");
  }
#line 1061
  bind_address = js_create(64U, 1U);
#line 1061
  if ((unsigned long )bind_address == (unsigned long )((js_string *)0)) {
#line 1062
    harderror((char *)"Could not create bins_address string");
  }
#line 1063
  tmp___9 = js_set_encode(bind_address, 3);
#line 1063
  if (tmp___9 == -1) {
#line 1064
    harderror((char *)"Could not set locale for bind_address string");
  }
#line 1065
  incoming = js_create(768U, 1U);
#line 1065
  if ((unsigned long )incoming == (unsigned long )((js_string *)0)) {
#line 1066
    harderror((char *)"Could not create incoming string");
  }
#line 1067
  tmp___10 = js_set_encode(incoming, 3);
#line 1067
  if (tmp___10 == -1) {
#line 1068
    harderror((char *)"Could not set locale for incoming string");
  }
#line 1069
  uncomp = js_create(768U, 1U);
#line 1069
  if ((unsigned long )uncomp == (unsigned long )((js_string *)0)) {
#line 1070
    harderror((char *)"Could not create uncomp string");
  }
#line 1071
  tmp___11 = js_set_encode(uncomp, 3);
#line 1071
  if (tmp___11 == -1) {
#line 1072
    harderror((char *)"Could not set locale for uncomp string");
  }
#line 1075
  if (argc == 1) {
#line 1076
    tmp___12 = find_mararc(mararc_loc);
#line 1076
    if (tmp___12 == -1) {
#line 1077
      harderror((char *)"Error locating mararc file");
    }
  } else
#line 1079
  if (argc == 2) {
#line 1080
    printf("%s %s\n%s\n", "This is MaraDNS\' zoneserver version", "1.4.06", "For usage information, \'man zoneserver\'");
#line 1082
    exit(0);
  } else
#line 1084
  if (argc == 3) {
#line 1085
    tmp___13 = js_qstr2js(mararc_loc, *(argv + 2));
#line 1085
    if (tmp___13 == -1) {
#line 1086
      harderror((char *)"Could not get mararc from command line");
    }
  } else {
#line 1089
    harderror((char *)"Usage: zoneserver [-f mararc_location]");
  }
#line 1092
  tmp___14 = read_mararc(mararc_loc, errors, & errorn);
#line 1092
  if (tmp___14 == -1) {
#line 1093
    harderror((char *)"Error parsing contents of mararc file");
  }
#line 1094
  if (errorn != 0) {
#line 1095
    if (errorn != -1) {
#line 1097
      printf("%s%d%s", "Error parsing contents of mararc file on line ", errorn, "\n");
    }
#line 1098
    printf("%s", "Error code: ");
#line 1099
    js_show_stdout(errors);
#line 1100
    printf("%s", "\n");
#line 1101
    exit(2);
  }
#line 1105
  srng();
#line 1107
  inetd = 0;
#line 1112
  maxprocs = read_numeric_kvar((char *)"maxprocs", 128);
#line 1115
  csv2_tilde_handling = read_numeric_kvar((char *)"csv2_tilde_handling", 2);
#line 1116
  if (csv2_tilde_handling < 0) {
#line 1117
    harderror((char *)"csv2_tilde_handling must have a value between 0 and 3");
#line 1119
    exit(1);
  } else
#line 1116
  if (csv2_tilde_handling > 3) {
#line 1117
    harderror((char *)"csv2_tilde_handling must have a value between 0 and 3");
#line 1119
    exit(1);
  }
#line 1124
  tmp___15 = js_qstr2js(kvar_query, (char *)"max_tcp_procs");
#line 1124
  if (tmp___15 == -1) {
#line 1125
    harderror((char *)"Could not create kvar_query");
  }
#line 1127
  tmp___17 = read_kvar(kvar_query, maxpstr);
#line 1127
  if (tmp___17 != 0) {
#line 1128
    tmp___16 = js_atoi(maxpstr, 0);
#line 1128
    maxprocs = (int )tmp___16;
  }
#line 1132
  rlim.rlim_max = (rlim_t )maxprocs;
#line 1132
  rlim.rlim_cur = rlim.rlim_max;
#line 1135
  tmp___18 = setrlimit(7, (struct rlimit  const  *)(& rlim));
#line 1135
  if (tmp___18 != 0) {
#line 1136
    harderror((char *)"Unable to set maximum number of processes");
  }
#line 1141
  tmp___19 = js_qstr2js(kvar_query, (char *)"verbose_level");
#line 1141
  if (tmp___19 == -1) {
#line 1142
    harderror((char *)"Could not create kvar_query");
  }
#line 1143
  tmp___21 = read_kvar(kvar_query, verbstr);
#line 1143
  if (tmp___21 == -1) {
#line 1144
    verbose = 0;
  } else {
#line 1146
    tmp___20 = js_atoi(verbstr, 0);
#line 1146
    verbose = (int )tmp___20;
  }
#line 1149
  tmp___39 = geteuid();
#line 1149
  if (tmp___39 == 0U) {
#line 1151
    tmp___22 = js_qstr2js(kvar_query, (char *)"chroot_dir");
#line 1151
    if (tmp___22 == -1) {
#line 1152
      harderror((char *)"Could not create kvar_query");
    }
#line 1153
    tmp___23 = read_kvar(kvar_query, chrootn);
#line 1153
    if (tmp___23 == -1) {
#line 1154
      harderror((char *)"Problem getting chroot kvar.\nYou must have chroot_dir set if you start this as root");
    }
#line 1155
    tmp___24 = js_js2str(chrootn, (char *)(chroot_zt), 200);
#line 1155
    if (tmp___24 == -1) {
#line 1156
      harderror((char *)"Problem making chroot nt string.\nMake sure the chroot directory is 200 chars or less");
    }
#line 1157
    tmp___25 = chdir((char const   *)((char *)(chroot_zt)));
#line 1157
    if (tmp___25 != 0) {
#line 1158
      harderror((char *)"Problem changing to chroot dir.\nMake sure chroot_dir points to a valid directory");
    }
#line 1159
    tmp___26 = chroot((char const   *)((char *)(chroot_zt)));
#line 1159
    if (tmp___26 != 0) {
#line 1160
      harderror((char *)"Problem changing the root directory.");
    }
#line 1164
    tmp___27 = read_numeric_kvar((char *)"maradns_uid", 99);
#line 1164
    uid = (uid_t )tmp___27;
#line 1165
    tmp___28 = read_numeric_kvar((char *)"maradns_gid", 99);
#line 1165
    gid = (gid_t )tmp___28;
#line 1166
    if (uid < 10U) {
#line 1167
      uid = (uid_t )99;
    }
#line 1169
    mlog((char *)"Root directory changed");
#line 1177
    dns_port = read_numeric_kvar((char *)"dns_port", 53);
#line 1178
    if (dns_port < 1) {
#line 1179
      harderror((char *)"dns_port must be between 1 and 65530");
#line 1180
      exit(1);
    } else
#line 1178
    if (dns_port > 65530) {
#line 1179
      harderror((char *)"dns_port must be between 1 and 65530");
#line 1180
      exit(1);
    }
#line 1183
    if (inetd != 1) {
#line 1197
      bind_addresses = libtcp_bind_address(1);
#line 1198
      if ((unsigned long )bind_addresses == (unsigned long )((ipv4pair *)0)) {
#line 1199
        harderror((char *)"Could not make list of bind addresses");
      } else
#line 1198
      if ((bind_addresses + 0)->ip == 4294967295U) {
#line 1199
        harderror((char *)"Could not make list of bind addresses");
      }
#line 1201
      bind_address_iterate = 0;
#line 1202
      while (1) {
#line 1202
        if (bind_address_iterate < 70) {
#line 1202
          if (! ((bind_addresses + bind_address_iterate)->ip != 4294967295U)) {
#line 1202
            break;
          }
        } else {
#line 1202
          break;
        }
#line 1209
        tmp___29 = pipe((int *)(stream1));
#line 1209
        if (tmp___29 != 0) {
#line 1210
          harderror((char *)"Pipe()\'s broken");
        }
#line 1212
        pid = fork();
#line 1212
        if (pid) {
#line 1213
          if (pid < 0) {
#line 1214
            harderror((char *)"Could not fork");
          }
#line 1215
          close(stream1[1]);
#line 1216
          fcntl(stream1[0], 4, 4);
#line 1218
          if (stream1[0] != bind_address_iterate + 3) {
#line 1219
            dup2(stream1[0], bind_address_iterate + 3);
          }
        } else {
#line 1222
          close(stream1[0]);
#line 1223
          dup2(stream1[1], 1);
#line 1224
          dup2(stream1[1], 2);
#line 1225
          tmp___30 = tcpbind(& sock, (bind_addresses + bind_address_iterate)->ip);
#line 1225
          if (tmp___30 == -1) {
#line 1227
            harderror((char *)"Problem binding to port 53.\nMost likely, another process is already listening on port 53");
          }
#line 1228
          break;
        }
#line 1230
        bind_address_iterate ++;
      }
#line 1232
      if (pid) {
#line 1238
        setgid(gid);
#line 1239
        tmp___31 = setuid(uid);
#line 1239
        if (tmp___31 != 0) {
#line 1240
          harderror((char *)"Parent couldn\'t drop UID\n");
        }
#line 1242
        __builtin_bzero((void *)(& child_set), sizeof(child_set));
#line 1244
        counter = 3;
#line 1244
        while (counter < bind_address_iterate + 3) {
#line 1246
          while (1) {
#line 1246
            __fd = counter;
#line 1246
            child_set.fds_bits[(unsigned long )__fd / (sizeof(__int32_t ) * 8UL)] |= 1 << (unsigned long )__fd % (sizeof(__int32_t ) * 8UL);
#line 1246
            break;
          }
#line 1244
          counter ++;
        }
#line 1248
        while (1) {
#line 1249
          __builtin_bzero((void *)(& read_set), sizeof(read_set));
#line 1251
          counter = 3;
#line 1251
          while (counter < bind_address_iterate + 3) {
#line 1253
            tmp___32 = __darwin_fd_isset(counter, (struct fd_set  const  *)(& child_set));
#line 1253
            if (tmp___32) {
#line 1254
              while (1) {
#line 1254
                __fd___0 = counter;
#line 1254
                read_set.fds_bits[(unsigned long )__fd___0 / (sizeof(__int32_t ) * 8UL)] |= 1 << (unsigned long )__fd___0 % (sizeof(__int32_t ) * 8UL);
#line 1254
                break;
              }
            }
#line 1251
            counter ++;
          }
#line 1256
          tmp___35 = select(bind_address_iterate + 3, & read_set, (fd_set *)((void *)0),
                            (fd_set *)((void *)0), (struct timeval *)((void *)0));
#line 1256
          if (tmp___35 > 0) {
#line 1258
            counter = 3;
#line 1258
            while (counter < bind_address_iterate + 3) {
#line 1260
              tmp___34 = __darwin_fd_isset(counter, (struct fd_set  const  *)(& read_set));
#line 1260
              if (tmp___34) {
#line 1261
                readed = read(counter, (void *)(buf), (size_t )1024);
#line 1262
                if (readed > 0L) {
#line 1264
                  tmp___33 = write(1, (void const   *)(buf), (size_t )readed);
#line 1264
                  nowarn = (int )tmp___33;
                } else {
#line 1267
                  close(counter);
#line 1268
                  while (1) {
#line 1268
                    __fd___1 = counter;
#line 1268
                    child_set.fds_bits[(unsigned long )__fd___1 / (sizeof(__int32_t ) * 8UL)] &= ~ (1 << (unsigned long )__fd___1 % (sizeof(__int32_t ) * 8UL));
#line 1268
                    break;
                  }
                }
              }
#line 1258
              counter ++;
            }
          } else {
#line 1273
            break;
          }
#line 1275
          waitpid(0, (int *)((void *)0), 1);
        }
#line 1277
        return (0);
      }
#line 1279
      tmp___36 = libtcp_create_bind_addrs();
#line 1279
      if (tmp___36 == -1) {
#line 1280
        harderror((char *)"libtcp_create_synthip_addrs");
      }
#line 1281
      mlog((char *)"Socket opened on TCP port 53");
    }
#line 1285
    setgid(gid);
#line 1286
    tmp___37 = setuid(uid);
#line 1286
    if (tmp___37 != 0) {
#line 1287
      harderror((char *)"Could not drop root uid");
    }
#line 1288
    tmp___38 = setuid((uid_t )0);
#line 1288
    if (tmp___38 == 0) {
#line 1289
      harderror((char *)"We seem to still be root");
    }
#line 1291
    if (inetd != 1) {
#line 1292
      mlog((char *)"Root privileges dropped");
    }
  } else {
#line 1296
    harderror((char *)"inetd is not zero; this is a fatal error.  Complain loudly on the MaraDNS\nmailing list.\n");
  }
#line 1301
  counter = 0;
#line 1301
  while (counter < 512) {
#line 1302
    zonetransfer_acl[counter].ip = 4294967295U;
#line 1301
    counter ++;
  }
#line 1303
  tmp___40 = js_qstr2js(kvar_query, (char *)"zone_transfer_acl");
#line 1303
  if (tmp___40 == -1) {
#line 1304
    harderror((char *)"Could not create kvar_query");
  }
#line 1305
  tmp___41 = read_kvar(kvar_query, kvar_str);
#line 1305
  if (tmp___41 == -1) {
#line 1306
    harderror((char *)"Could not read zone_transfer_acl data");
  }
#line 1307
  if (inetd == 1) {
#line 1308
    harderror((char *)"inetd is set.  This is a fatal error.  You should not be seeing this\nComplain loudly on the MaraDNS mailing list.");
  } else {
#line 1311
    tmp___42 = make_ip_acl(kvar_str, zonetransfer_acl, 500, 0);
#line 1311
    if (tmp___42 == -1) {
#line 1313
      zonetransfer_acl[0].ip = 4294967295U;
    }
  }
#line 1320
  counter = 0;
#line 1320
  while (counter < 512) {
#line 1321
    tcpconvert_acl[counter].ip = 4294967295U;
#line 1320
    counter ++;
  }
#line 1322
  tmp___43 = js_qstr2js(kvar_query, (char *)"tcp_convert_acl");
#line 1322
  if (tmp___43 == -1) {
#line 1323
    harderror((char *)"Could not create kvar_query");
  }
#line 1324
  tmp___45 = read_kvar(kvar_query, kvar_str);
#line 1324
  if (tmp___45 == 1) {
#line 1325
    if (srng_place == -1) {
#line 1326
      printf("I could not get value for random_seed_file.\n");
#line 1327
      printf("You must have this set in your mararc file.\n");
#line 1328
      printf("Please add something like this to the mararc file\n");
#line 1329
      printf("you are using:\n");
#line 1330
      printf("\n\trandom_seed_file = \"/dev/urandom\"\n\n");
#line 1331
      exit(1);
    }
#line 1333
    tmp___44 = make_ip_acl(kvar_str, tcpconvert_acl, 500, 0);
#line 1333
    if (tmp___44 == -1) {
#line 1335
      harderror((char *)"XXX need better error message");
    }
  }
#line 1341
  counter = 0;
#line 1341
  while (counter < 512) {
#line 1342
    recursive_acl[counter].ip = 4294967295U;
#line 1341
    counter ++;
  }
#line 1343
  tmp___46 = js_qstr2js(kvar_query, (char *)"recursive_acl");
#line 1343
  if (tmp___46 == -1) {
#line 1344
    harderror((char *)"Could not create kvar_query");
  }
#line 1345
  tmp___48 = read_kvar(kvar_query, kvar_str);
#line 1345
  if (tmp___48 == 1) {
#line 1346
    if (srng_place == -1) {
#line 1347
      printf("I could not get value for random_seed_file.\n");
#line 1348
      printf("You must have this set in your mararc file.\n");
#line 1349
      printf("Please add something like this to the mararc file\n");
#line 1350
      printf("you are using:\n");
#line 1351
      printf("\n\trandom_seed_file = \"/dev/urandom\"\n\n");
#line 1352
      exit(1);
    }
#line 1354
    tmp___47 = make_ip_acl(kvar_str, recursive_acl, 500, 0);
#line 1354
    if (tmp___47 == -1) {
#line 1356
      harderror((char *)"XXX need better error message");
    }
  }
#line 1360
  counter = 0;
#line 1360
  while (counter < 512) {
#line 1361
    tcpconvert_servers[counter].ip = 4294967295U;
#line 1360
    counter ++;
  }
#line 1362
  tmp___49 = js_qstr2js(kvar_query, (char *)"tcp_convert_server");
#line 1362
  if (tmp___49 == -1) {
#line 1363
    harderror((char *)"Could not create kvar_query");
  }
#line 1364
  tmp___51 = read_kvar(kvar_query, kvar_str);
#line 1364
  if (tmp___51 == 1) {
#line 1365
    if (srng_place == -1) {
#line 1366
      printf("I could not get value for random_seed_file.\n");
#line 1367
      printf("You must have this set in your mararc file.\n");
#line 1368
      printf("Please add something like this to the mararc file\n");
#line 1369
      printf("you are using:\n");
#line 1370
      printf("\n\trandom_seed_file = \"/dev/urandom\"\n\n");
#line 1371
      exit(1);
    }
#line 1373
    tmp___50 = make_ip_acl(kvar_str, tcpconvert_servers, 500, 0);
#line 1373
    if (tmp___50 == -1) {
#line 1375
      harderror((char *)"XXX need better error message");
    }
  }
#line 1377
  udp_forward_server = (int )tcpconvert_servers[0].ip;
#line 1382
  synth_soa_serial___0 = read_numeric_kvar((char *)"synth_soa_serial", 1);
#line 1383
  if (synth_soa_serial___0 < 1) {
#line 1384
    harderror((char *)"Fatal: synth_soa_serial must be 1 or 2\n");
  } else
#line 1383
  if (synth_soa_serial___0 > 2) {
#line 1384
    harderror((char *)"Fatal: synth_soa_serial must be 1 or 2\n");
  }
#line 1386
  set_soa_serial(synth_soa_serial___0);
#line 1387
  verbstr = read_string_kvar((char *)"synth_soa_origin");
#line 1388
  if ((unsigned long )verbstr != (unsigned long )((js_string *)0)) {
#line 1388
    tmp___56 = js_length(verbstr);
#line 1388
    if (tmp___56 > 0) {
#line 1389
      synth_soa_origin___0 = js_create(256U, 1U);
#line 1390
      if ((unsigned long )synth_soa_origin___0 == (unsigned long )((js_string *)0)) {
#line 1391
        harderror((char *)"Fatal: can not create synth_soa_origin string");
      }
#line 1393
      tmp___52 = js_qstr2js(synth_soa_origin___0, (char *)"Z");
#line 1393
      if (tmp___52 != 1) {
#line 1394
        harderror((char *)"Fatal: could not make synth_soa_origin string Z");
      }
#line 1396
      tmp___53 = js_append(verbstr, synth_soa_origin___0);
#line 1396
      if (tmp___53 != 1) {
#line 1397
        harderror((char *)"Fatal: could not append to synth_soa_origin string");
      }
#line 1400
      tmp___54 = js_qappend((char *)".", synth_soa_origin___0);
#line 1400
      if (tmp___54 != 1) {
#line 1401
        harderror((char *)"Fatal: could not append final dot to soa_synth_origin");
      }
#line 1404
      tmp___55 = hname_2rfc1035(synth_soa_origin___0);
#line 1404
      if (tmp___55 <= 0) {
#line 1405
        harderror((char *)"Fatal: Malformed synth_soa_origin value.\nPlease make sure that synth_soa_origin is a valid hostname\n*without* a dot at the end.  For example:\n\n\tsynth_soa_origin = \"example.com\"\n");
      }
#line 1410
      set_soa_origin(synth_soa_origin___0);
    }
  }
#line 1414
  decomp_init(0);
#line 1416
  if (inetd == 1) {
#line 1417
    harderror((char *)"inetd is not zero.  This is a fatal error\nComplain loudly on the MaraDNS mailing list.\n");
  }
#line 1422
  signal(20, (void (*)(int  ))(& handle_childs));
#line 1425
  while (1) {
#line 1426
    permissions = 0;
#line 1437
    if (verbose >= 2) {
#line 1438
      mlog((char *)"Awaiting data on port 53");
    }
#line 1439
    connection = gettcp(& sock, zonetransfer_acl, tcpconvert_acl, recursive_acl, 500,
                        & permissions);
#line 1441
    if (connection == -1) {
#line 1442
      goto __Cont;
    }
#line 1443
    if (verbose >= 2) {
#line 1444
      mlog((char *)"Message received, processing");
    }
#line 1447
    while (num_children > maxprocs) {
#line 1448
      sleep(1U);
    }
#line 1451
    while (1) {
#line 1451
      pid = fork();
#line 1451
      if (! (pid == -1)) {
#line 1451
        break;
      }
#line 1452
      sleep(1U);
    }
#line 1454
    if (! pid) {
#line 1457
      if ((permissions & 1) == 1) {
#line 1458
        serve_zone(connection, permissions);
      } else
#line 1457
      if ((permissions & 2) == 2) {
#line 1458
        serve_zone(connection, permissions);
      }
#line 1459
      exit(0);
    }
#line 1463
    num_children ++;
#line 1467
    while (1) {
#line 1467
      tmp___57 = waitpid(0, (int *)((void *)0), 1);
#line 1467
      if (! (tmp___57 > 0)) {
#line 1467
        break;
      }
#line 1467
      num_children --;
    }
#line 1470
    close(connection);
    __Cont: /* CIL Label */ ;
  }
}
}
#line 1 "JsStr.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-cmEiAY1c.i","")
#line 65 "JsStr.h"
int js_octets(js_string *js ) ;
#line 68
int js_get_encode(js_string *js ) ;
#line 69
int js_set_chsize(js_string *js , int size ) ;
#line 71
int js_destroy_force(js_string *object ) ;
#line 73
int js_str2js(js_string *js , char *string , int count , int size ) ;
#line 75
int js_issame(js_string *js1 , js_string *js2 ) ;
#line 76
int js_fgrep(js_string *exp , js_string *js ) ;
#line 77
int js_fgrep_offset(js_string *exp , js_string *js , int offset ) ;
#line 78
int js_match(js_string *exp , js_string *js ) ;
#line 79
int js_match_offset(js_string *exp , js_string *js , int offset ) ;
#line 80
int js_insert(js_string *toinsert , js_string *target , int where ) ;
#line 84
int js_notmatch_offset(js_string *exp , js_string *js , int offset ) ;
#line 85
int js_notmatch(js_string *exp , js_string *js ) ;
#line 87
int js_qprepend(char *toprepend , js_string *target ) ;
#line 88
int js_qfgrep(char *expression , js_string *target ) ;
#line 89
int js_val(js_string *js , int offset ) ;
#line 91
int js_addbyte(js_string *js , unsigned char byte ) ;
#line 93
int js_readuint16(js_string *js , unsigned int offset ) ;
#line 94
int js_changebyte(js_string *js , unsigned char byte , int offset ) ;
#line 95
int js_qissame(char *expression , js_string *target ) ;
#line 98
void *js_alloc(int unit_count , int unit_size ) ;
#line 99
int js_dealloc(void *pointer ) ;
#line 12 "JsStr.c"
int js_octets(js_string *js ) 
{ 

  {
#line 13
  return ((int )(js->max_count * js->unit_size));
}
}
#line 20 "JsStr.c"
js_string *js_create(unsigned int max_count , unsigned int unit_size ) 
{ js_string *new ;
  void *tmp ;
  unsigned char *tmp___0 ;
  void *tmp___1 ;

  {
#line 23
  tmp = js_alloc(1, (int )sizeof(js_string ));
#line 23
  new = (js_string *)tmp;
#line 23
  if ((unsigned long )new == (unsigned long )((js_string *)0)) {
#line 24
    return ((js_string *)0);
  }
#line 27
  new->unit_size = unit_size;
#line 28
  new->unit_count = 0U;
#line 29
  new->max_count = max_count;
#line 30
  new->is_good = 3124;
#line 31
  new->encoding = 1;
#line 34
  tmp___1 = js_alloc((int )(max_count + 3U), (int )unit_size);
#line 34
  tmp___0 = (unsigned char *)tmp___1;
#line 34
  new->string = tmp___0;
#line 34
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 35
    js_dealloc((void *)new);
#line 36
    return ((js_string *)0);
  }
#line 39
  return (new);
}
}
#line 80 "JsStr.c"
int js_set_encode(js_string *js , int encoding ) 
{ int tmp ;

  {
#line 82
  tmp = js_has_sanity(js);
#line 82
  if (tmp == -1) {
#line 83
    return (-1);
  }
#line 86
  if (encoding < 1) {
#line 87
    return (-1);
  } else
#line 86
  if (encoding > 3) {
#line 87
    return (-1);
  }
#line 89
  js->encoding = encoding;
#line 91
  return (0);
}
}
#line 98 "JsStr.c"
int js_get_encode(js_string *js ) 
{ int tmp ;

  {
#line 100
  tmp = js_has_sanity(js);
#line 100
  if (tmp == -1) {
#line 101
    return (-1);
  }
#line 104
  if (js->encoding < 1) {
#line 105
    return (-1);
  } else
#line 104
  if (js->encoding > 3) {
#line 105
    return (-1);
  }
#line 107
  return (js->encoding);
#line 109
  return (0);
}
}
#line 115 "JsStr.c"
int js_length(js_string *js ) 
{ int tmp ;

  {
#line 117
  tmp = js_has_sanity(js);
#line 117
  if (tmp == -1) {
#line 118
    return (-1);
  }
#line 120
  return ((int )js->unit_count);
}
}
#line 129 "JsStr.c"
int js_set_chsize(js_string *js , int size ) 
{ int tmp ;

  {
#line 131
  tmp = js_has_sanity(js);
#line 131
  if (tmp == -1) {
#line 132
    return (-1);
  }
#line 135
  if (size < 1) {
#line 136
    return (-1);
  }
#line 140
  if (js->unit_count != 0U) {
#line 141
    return (-1);
  }
#line 164
  if ((js->max_count * js->unit_size) % (unsigned int )size != 0U) {
#line 165
    return (-1);
  }
#line 166
  js->max_count *= js->unit_size;
#line 167
  js->max_count /= (unsigned int )size;
#line 170
  js->unit_size = (unsigned int )size;
#line 172
  return (0);
}
}
#line 178 "JsStr.c"
int js_destroy(js_string *object ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 179
  tmp___0 = js_has_sanity(object);
#line 179
  if (tmp___0 != -1) {
#line 180
    tmp = js_destroy_force(object);
#line 180
    return (tmp);
  } else {
#line 182
    return (-1);
  }
}
}
#line 188 "JsStr.c"
int js_destroy_force(js_string *object ) 
{ 

  {
#line 190
  js_dealloc((void *)object->string);
#line 192
  js_dealloc((void *)object);
#line 194
  return (1);
}
}
#line 201 "JsStr.c"
int js_has_sanity(js_string *object ) 
{ 

  {
#line 204
  if ((unsigned long )object == (unsigned long )((js_string *)0)) {
#line 205
    return (-1);
  }
#line 208
  if (object->is_good != 3124) {
#line 209
    return (-1);
  }
#line 212
  if (object->unit_count > object->max_count) {
#line 213
    return (-1);
  }
#line 216
  if (object->encoding == 2) {
#line 216
    if (object->unit_size != 1U) {
#line 217
      return (-1);
    }
  }
#line 219
  return (1);
}
}
#line 226 "JsStr.c"
int js_str2js(js_string *js , char *string , int count , int size ) 
{ int counter ;
  int max ;
  int tmp ;

  {
#line 227
  counter = 0;
#line 229
  max = count;
#line 232
  if ((unsigned int )count > js->max_count) {
#line 233
    return (-1);
  }
#line 236
  tmp = js_has_sanity(js);
#line 236
  if (tmp == -1) {
#line 237
    return (-1);
  }
#line 238
  if ((unsigned int )size != js->unit_size) {
#line 239
    return (-1);
  }
#line 240
  if ((unsigned long )string == (unsigned long )((char *)0)) {
#line 241
    return (-1);
  }
#line 243
  while (counter < max * size) {
#line 244
    *(js->string + counter) = (unsigned char )*(string + counter);
#line 245
    counter ++;
  }
#line 249
  js->unit_count = (unsigned int )count;
#line 251
  return (1);
}
}
#line 258 "JsStr.c"
int js_js2str(js_string *js , char *string , int max ) 
{ int counter ;
  int tmp ;

  {
#line 259
  counter = 0;
#line 262
  tmp = js_has_sanity(js);
#line 262
  if (tmp == -1) {
#line 263
    return (-1);
  }
#line 264
  if (js->unit_size * js->unit_count >= (unsigned int )max) {
#line 265
    return (-1);
  }
#line 267
  while ((unsigned int )counter < js->unit_size * js->unit_count) {
#line 268
    *(string + counter) = (char )*(js->string + counter);
#line 269
    counter ++;
  }
#line 272
  *(string + counter) = (char)0;
#line 274
  return (1);
}
}
#line 280 "JsStr.c"
int js_issame(js_string *js1 , js_string *js2 ) 
{ int counter ;
  int max ;
  int tmp ;
  int tmp___0 ;

  {
#line 281
  counter = 0;
#line 285
  tmp = js_has_sanity(js1);
#line 285
  if (tmp == -1) {
#line 286
    return (-1);
  }
#line 287
  tmp___0 = js_has_sanity(js2);
#line 287
  if (tmp___0 == -1) {
#line 288
    return (-1);
  }
#line 291
  if (js1->unit_size != js2->unit_size) {
#line 292
    return (0);
  }
#line 294
  if (js1->unit_count != js2->unit_count) {
#line 295
    return (0);
  }
#line 301
  max = (int )js1->unit_count;
#line 304
  while ((unsigned int )counter < (unsigned int )max * js1->unit_size) {
#line 305
    if ((int )*(js1->string + counter) != (int )*(js2->string + counter)) {
#line 306
      return (0);
    }
#line 307
    counter ++;
  }
#line 311
  return (1);
}
}
#line 319 "JsStr.c"
int js_fgrep(js_string *exp , js_string *js ) 
{ int tmp ;

  {
#line 320
  tmp = js_fgrep_offset(exp, js, 0);
#line 320
  return (tmp);
}
}
#line 330 "JsStr.c"
int js_fgrep_offset(js_string *exp , js_string *js , int offset ) 
{ int counter ;
  int place ;
  int match ;
  int max ;
  int tmp ;
  int tmp___0 ;

  {
#line 331
  counter = 0;
#line 332
  place = 0;
#line 333
  match = -2;
#line 337
  tmp = js_has_sanity(exp);
#line 337
  if (tmp == -1) {
#line 338
    return (-1);
  }
#line 339
  tmp___0 = js_has_sanity(js);
#line 339
  if (tmp___0 == -1) {
#line 340
    return (-1);
  }
#line 343
  if ((unsigned int )offset > js->unit_count) {
#line 344
    return (-1);
  }
#line 347
  if (offset < 0) {
#line 348
    offset = (int )(js->unit_count + (unsigned int )offset);
  }
#line 351
  if (offset < 0) {
#line 352
    return (-1);
  }
#line 355
  if (exp->unit_size != js->unit_size) {
#line 356
    return (-2);
  }
#line 360
  if (exp->unit_count > js->unit_count) {
#line 361
    return (-2);
  }
#line 364
  if (exp->unit_count <= 0U) {
#line 365
    return (0);
  }
#line 369
  max = (int )(js->unit_count - exp->unit_count);
#line 371
  match = -2;
#line 374
  while (1) {
#line 374
    if ((unsigned int )counter <= (unsigned int )max * js->unit_size) {
#line 374
      if (! (match == -2)) {
#line 374
        break;
      }
    } else {
#line 374
      break;
    }
#line 376
    if ((int )*(exp->string) == (int )*(js->string + counter)) {
#line 376
      if ((unsigned int )counter % js->unit_size == 0U) {
#line 376
        if ((unsigned int )counter >= (unsigned int )offset * js->unit_size) {
#line 379
          match = (int )((unsigned int )counter / js->unit_size);
#line 380
          place = 0;
#line 381
          while (1) {
#line 381
            if ((unsigned int )place < exp->unit_count * exp->unit_size) {
#line 381
              if (! ((unsigned int )(place + counter) < js->unit_count * js->unit_size)) {
#line 381
                break;
              }
            } else {
#line 381
              break;
            }
#line 383
            if ((int )*(exp->string + place) != (int )*((js->string + place) + counter)) {
#line 385
              match = -2;
            }
#line 386
            place ++;
          }
        }
      }
    }
#line 389
    counter ++;
  }
#line 393
  return (match);
}
}
#line 402 "JsStr.c"
int js_match(js_string *exp , js_string *js ) 
{ int tmp ;

  {
#line 403
  tmp = js_match_offset(exp, js, 0);
#line 403
  return (tmp);
}
}
#line 412 "JsStr.c"
int js_match_offset(js_string *exp , js_string *js , int offset ) 
{ int counter ;
  int place ;
  int pexp ;
  int match ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 413
  counter = 0;
#line 414
  place = 0;
#line 415
  pexp = 0;
#line 416
  match = -2;
#line 419
  tmp = js_has_sanity(exp);
#line 419
  if (tmp == -1) {
#line 420
    return (-1);
  }
#line 421
  tmp___0 = js_has_sanity(js);
#line 421
  if (tmp___0 == -1) {
#line 422
    return (-1);
  }
#line 425
  if (offset < 0) {
#line 426
    offset = (int )(js->unit_count + (unsigned int )offset);
  }
#line 429
  if (offset < 0) {
#line 430
    return (-1);
  }
#line 433
  if (exp->unit_size != js->unit_size) {
#line 434
    return (-2);
  }
#line 437
  if (exp->unit_count <= 0U) {
#line 438
    return (-2);
  }
#line 441
  while (1) {
#line 441
    if ((unsigned int )counter < js->unit_count * js->unit_size) {
#line 441
      if (! (match == -2)) {
#line 441
        break;
      }
    } else {
#line 441
      break;
    }
#line 443
    pexp = 0;
#line 447
    while (1) {
#line 447
      if (counter >= offset) {
#line 447
        if ((unsigned int )pexp < exp->unit_count * exp->unit_size) {
#line 447
          if (! (match == -2)) {
#line 447
            break;
          }
        } else {
#line 447
          break;
        }
      } else {
#line 447
        break;
      }
#line 453
      if ((int )*(exp->string + pexp) == (int )*(js->string + counter)) {
#line 453
        if ((unsigned int )pexp % exp->unit_size == 0U) {
#line 453
          tmp___3 = js_octets(exp);
#line 453
          if (pexp < tmp___3) {
#line 456
            match = (int )((unsigned int )counter / exp->unit_size);
#line 457
            place = 1;
#line 460
            while ((unsigned int )place < exp->unit_size) {
#line 463
              if ((int )*((exp->string + pexp) + place) != (int )*((js->string + counter) + place)) {
#line 463
                tmp___1 = js_octets(exp);
#line 463
                if (pexp + place < tmp___1) {
#line 463
                  tmp___2 = js_octets(js);
#line 463
                  if (counter + place < tmp___2) {
#line 468
                    match = -2;
                  }
                }
              }
#line 469
              place ++;
            }
          }
        }
      }
#line 473
      pexp ++;
    }
#line 477
    counter ++;
  }
#line 481
  return (match);
}
}
#line 490 "JsStr.c"
int js_notmatch(js_string *exp , js_string *js ) 
{ int tmp ;

  {
#line 491
  tmp = js_notmatch_offset(exp, js, 0);
#line 491
  return (tmp);
}
}
#line 500 "JsStr.c"
int js_notmatch_offset(js_string *exp , js_string *js , int offset ) 
{ int counter ;
  int place ;
  int pexp ;
  int match ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 501
  counter = 0;
#line 502
  place = 0;
#line 503
  pexp = 0;
#line 504
  match = -2;
#line 507
  tmp = js_has_sanity(exp);
#line 507
  if (tmp == -1) {
#line 508
    return (-1);
  }
#line 509
  tmp___0 = js_has_sanity(js);
#line 509
  if (tmp___0 == -1) {
#line 510
    return (-1);
  }
#line 513
  if (offset < 0) {
#line 514
    offset = (int )(js->unit_count + (unsigned int )offset);
  }
#line 517
  if (offset < 0) {
#line 518
    return (-1);
  }
#line 521
  if (exp->unit_size != js->unit_size) {
#line 522
    return (-2);
  }
#line 525
  if (exp->unit_count <= 0U) {
#line 526
    return (-2);
  }
#line 529
  while (1) {
#line 529
    if ((unsigned int )counter < js->unit_count * js->unit_size) {
#line 529
      if (! (match == -2)) {
#line 529
        break;
      }
    } else {
#line 529
      break;
    }
#line 531
    pexp = 0;
#line 535
    while (1) {
#line 535
      if (counter >= offset) {
#line 535
        if (! ((unsigned int )pexp < exp->unit_count * exp->unit_size)) {
#line 535
          break;
        }
      } else {
#line 535
        break;
      }
#line 536
      if ((unsigned int )pexp % exp->unit_size == 0U) {
#line 537
        match = (int )((unsigned int )counter / exp->unit_size);
      }
#line 542
      if ((int )*(exp->string + pexp) == (int )*(js->string + counter)) {
#line 542
        if ((unsigned int )pexp % exp->unit_size == 0U) {
#line 542
          tmp___3 = js_octets(exp);
#line 542
          if (pexp < tmp___3) {
#line 545
            match = -2;
#line 546
            place = 1;
#line 549
            while ((unsigned int )place < exp->unit_size) {
#line 552
              if ((int )*((exp->string + pexp) + place) != (int )*((js->string + counter) + place)) {
#line 552
                tmp___1 = js_octets(exp);
#line 552
                if (pexp + place < tmp___1) {
#line 552
                  tmp___2 = js_octets(js);
#line 552
                  if (counter + place < tmp___2) {
#line 557
                    match = (int )((unsigned int )counter / exp->unit_size);
                  }
                }
              }
#line 558
              place ++;
            }
#line 560
            if (match == -2) {
#line 561
              break;
            }
          }
        }
      }
#line 564
      pexp ++;
    }
#line 568
    counter ++;
  }
#line 572
  return (match);
}
}
#line 584 "JsStr.c"
int js_insert(js_string *toinsert , js_string *target , int where ) 
{ int place ;
  int counter ;
  char *temp_str ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 585
  place = 0;
#line 590
  tmp = js_has_sanity(toinsert);
#line 590
  if (tmp == -1) {
#line 591
    return (-1);
  }
#line 592
  tmp___0 = js_has_sanity(target);
#line 592
  if (tmp___0 == -1) {
#line 593
    return (-1);
  }
#line 595
  if (toinsert->unit_size != target->unit_size) {
#line 596
    return (-1);
  }
#line 598
  if ((unsigned int )where > target->unit_count) {
#line 599
    return (-1);
  }
#line 602
  if ((unsigned int )where == target->unit_count) {
#line 603
    tmp___1 = js_append(toinsert, target);
#line 603
    return (tmp___1);
  }
#line 607
  if (toinsert->unit_count + target->unit_count > target->max_count) {
#line 608
    return (-1);
  }
#line 611
  tmp___2 = js_alloc((int )target->unit_size, (int )target->unit_count);
#line 611
  temp_str = (char *)tmp___2;
#line 611
  if ((unsigned long )temp_str == (unsigned long )((void *)-1)) {
#line 613
    return (-1);
  }
#line 616
  while ((unsigned int )place < target->unit_size * target->unit_count) {
#line 617
    *(temp_str + place) = (char )*(target->string + place);
#line 618
    place ++;
  }
#line 622
  if (where < 0) {
#line 623
    where = (int )(target->unit_count + (unsigned int )where);
  }
#line 626
  if (where < 0) {
#line 627
    js_dealloc((void *)temp_str);
#line 628
    return (-1);
  }
#line 632
  place = 0;
#line 633
  counter = 0;
#line 634
  while ((unsigned int )place < target->unit_size * target->unit_count) {
#line 636
    if ((unsigned int )place == (unsigned int )where * target->unit_size) {
#line 637
      while ((unsigned int )counter < toinsert->unit_size * toinsert->unit_count) {
#line 639
        if ((unsigned int )(place + counter) < target->unit_size * target->max_count) {
#line 641
          *((target->string + place) + counter) = *(toinsert->string + counter);
        }
#line 643
        counter ++;
      }
    }
#line 646
    if ((unsigned int )(place + counter) < target->unit_size * target->max_count) {
#line 648
      *((target->string + place) + counter) = (unsigned char )*(temp_str + place);
    }
#line 649
    place ++;
  }
#line 653
  target->unit_count += toinsert->unit_count;
#line 656
  js_dealloc((void *)temp_str);
#line 658
  return (0);
}
}
#line 667 "JsStr.c"
int js_append(js_string *toappend , js_string *target ) 
{ int counter ;
  int tmp ;
  int tmp___0 ;

  {
#line 668
  counter = 0;
#line 671
  tmp = js_has_sanity(toappend);
#line 671
  if (tmp == -1) {
#line 672
    return (-1);
  }
#line 673
  tmp___0 = js_has_sanity(target);
#line 673
  if (tmp___0 == -1) {
#line 674
    return (-1);
  }
#line 676
  if (toappend->unit_size != target->unit_size) {
#line 677
    return (-1);
  }
#line 681
  if (toappend->unit_count + target->unit_count >= target->max_count) {
#line 682
    return (-1);
  }
#line 685
  while ((unsigned int )counter < toappend->unit_size * toappend->unit_count) {
#line 686
    *((target->string + target->unit_size * target->unit_count) + counter) = *(toappend->string + counter);
#line 688
    counter ++;
  }
#line 692
  target->unit_count += toappend->unit_count;
#line 694
  return (0);
}
}
#line 702 "JsStr.c"
int js_substr(js_string *source , js_string *dest , int start , int count ) 
{ int counter ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 707
  tmp = js_has_sanity(source);
#line 707
  if (tmp == -1) {
#line 708
    return (-1);
  }
#line 709
  tmp___0 = js_has_sanity(dest);
#line 709
  if (tmp___0 == -1) {
#line 710
    return (-1);
  }
#line 711
  if (source->unit_size != dest->unit_size) {
#line 712
    return (-1);
  }
#line 715
  if (count < 0) {
#line 716
    return (-1);
  }
#line 717
  if ((unsigned int )start >= source->unit_count) {
#line 718
    return (-1);
  } else
#line 717
  if ((unsigned int )start >= source->max_count) {
#line 718
    return (-1);
  }
#line 719
  if ((unsigned int )(start + count) > source->unit_count) {
#line 720
    return (-1);
  }
#line 721
  if ((unsigned int )(start + count) > source->max_count) {
#line 722
    return (-1);
  }
#line 723
  if ((unsigned int )count >= dest->max_count) {
#line 724
    return (-1);
  }
#line 727
  counter = 0;
#line 728
  while (1) {
#line 728
    if ((unsigned int )counter < (unsigned int )count * source->unit_size) {
#line 728
      tmp___1 = js_octets(dest);
#line 728
      if (counter < tmp___1) {
#line 728
        tmp___2 = js_octets(source);
#line 728
        if (! ((unsigned int )counter + (unsigned int )start * source->unit_size < (unsigned int )tmp___2)) {
#line 728
          break;
        }
      } else {
#line 728
        break;
      }
    } else {
#line 728
      break;
    }
#line 730
    *(dest->string + counter) = *((source->string + counter) + (unsigned int )start * source->unit_size);
#line 732
    counter ++;
  }
#line 735
  dest->unit_count = (unsigned int )count;
#line 737
  return (1);
}
}
#line 743 "JsStr.c"
int js_copy(js_string *src , js_string *dest ) 
{ int counter ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 744
  counter = 0;
#line 747
  tmp = js_has_sanity(src);
#line 747
  if (tmp == -1) {
#line 748
    return (-1);
  } else {
#line 747
    tmp___0 = js_has_sanity(dest);
#line 747
    if (tmp___0 == -1) {
#line 748
      return (-1);
    }
  }
#line 750
  if (src->unit_size != dest->unit_size) {
#line 751
    return (-1);
  }
#line 753
  tmp___1 = js_octets(dest);
#line 753
  if (src->unit_size * src->unit_count >= (unsigned int )tmp___1) {
#line 754
    return (-1);
  }
#line 757
  while (1) {
#line 757
    if ((unsigned int )counter < src->unit_size * src->unit_count) {
#line 757
      tmp___2 = js_octets(dest);
#line 757
      if (counter < tmp___2) {
#line 757
        tmp___3 = js_octets(src);
#line 757
        if (! (counter < tmp___3)) {
#line 757
          break;
        }
      } else {
#line 757
        break;
      }
    } else {
#line 757
      break;
    }
#line 759
    *(dest->string + counter) = *(src->string + counter);
#line 760
    counter ++;
  }
#line 764
  dest->unit_count = src->unit_count;
#line 765
  dest->encoding = src->encoding;
#line 767
  return (1);
}
}
#line 777 "JsStr.c"
int js_val(js_string *js , int offset ) 
{ int value___0 ;
  int point ;
  int tmp ;

  {
#line 782
  tmp = js_has_sanity(js);
#line 782
  if (tmp == -1) {
#line 783
    return (-1);
  }
#line 784
  if ((unsigned int )offset >= js->unit_count) {
#line 785
    return (-1);
  }
#line 788
  if ((unsigned long )js->unit_size >= sizeof(int )) {
#line 789
    return (-1);
  }
#line 791
  point = 0;
#line 791
  value___0 = point;
#line 793
  while ((unsigned int )point < js->unit_size) {
#line 794
    value___0 *= 256;
#line 795
    value___0 += (int )*((js->string + (unsigned int )offset * js->unit_size) + point);
#line 796
    point ++;
  }
#line 799
  return (value___0);
}
}
#line 808 "JsStr.c"
int js_qappend(char *toappend , js_string *target ) 
{ js_string *temp ;
  int return_value ;
  int tmp ;
  int tmp___0 ;

  {
#line 810
  temp = (js_string *)0;
#line 814
  tmp = js_has_sanity(target);
#line 814
  if (tmp == -1) {
#line 815
    return (-1);
  }
#line 818
  if ((unsigned long )temp == (unsigned long )((js_string *)0)) {
#line 821
    temp = js_create(1024U, target->unit_size);
#line 821
    if ((unsigned long )temp == (unsigned long )((js_string *)0)) {
#line 822
      return (-1);
    }
  }
#line 824
  tmp___0 = js_qstr2js(temp, toappend);
#line 824
  if (tmp___0 == -1) {
#line 825
    js_destroy(temp);
#line 826
    return (-1);
  }
#line 829
  return_value = js_append(temp, target);
#line 831
  js_destroy(temp);
#line 833
  return (return_value);
}
}
#line 843 "JsStr.c"
int js_qprepend(char *toprepend , js_string *target ) 
{ js_string *temp ;
  int return_value ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 845
  temp = (js_string *)0;
#line 849
  tmp = js_has_sanity(target);
#line 849
  if (tmp == -1) {
#line 850
    return (-1);
  }
#line 853
  if ((unsigned long )temp == (unsigned long )((js_string *)0)) {
#line 857
    temp = js_create(1024U, target->unit_size);
#line 857
    if ((unsigned long )temp == (unsigned long )((js_string *)0)) {
#line 858
      return (-1);
    }
  }
#line 860
  tmp___0 = js_qstr2js(temp, toprepend);
#line 860
  if (tmp___0 == -1) {
#line 861
    js_destroy(temp);
#line 862
    return (-1);
  }
#line 866
  temp->encoding = target->encoding;
#line 868
  tmp___1 = js_append(target, temp);
#line 868
  if (tmp___1 == -1) {
#line 869
    js_destroy(temp);
#line 870
    return (-1);
  }
#line 873
  return_value = js_copy(temp, target);
#line 875
  js_destroy(temp);
#line 877
  return (return_value);
}
}
#line 886 "JsStr.c"
int js_qissame(char *expression , js_string *target ) 
{ js_string *temp ;
  int return_value ;
  int tmp ;
  int tmp___0 ;

  {
#line 888
  temp = (js_string *)0;
#line 892
  tmp = js_has_sanity(target);
#line 892
  if (tmp == -1) {
#line 893
    return (-1);
  }
#line 896
  if ((unsigned long )temp == (unsigned long )((js_string *)0)) {
#line 899
    temp = js_create(1024U, target->unit_size);
#line 899
    if ((unsigned long )temp == (unsigned long )((js_string *)0)) {
#line 900
      return (-1);
    }
  }
#line 902
  tmp___0 = js_qstr2js(temp, expression);
#line 902
  if (tmp___0 == -1) {
#line 903
    js_destroy(temp);
#line 904
    return (-1);
  }
#line 907
  temp->unit_size = target->unit_size;
#line 908
  temp->encoding = target->encoding;
#line 909
  return_value = js_issame(temp, target);
#line 911
  js_destroy(temp);
#line 913
  return (return_value);
}
}
#line 922 "JsStr.c"
int js_qfgrep(char *expression , js_string *target ) 
{ js_string *temp ;
  int return_value ;
  int tmp ;
  int tmp___0 ;

  {
#line 924
  temp = (js_string *)0;
#line 928
  tmp = js_has_sanity(target);
#line 928
  if (tmp == -1) {
#line 929
    return (-1);
  }
#line 932
  if ((unsigned long )temp == (unsigned long )((js_string *)0)) {
#line 935
    temp = js_create(1024U, target->unit_size);
#line 935
    if ((unsigned long )temp == (unsigned long )((js_string *)0)) {
#line 936
      return (-1);
    }
  }
#line 938
  tmp___0 = js_qstr2js(temp, expression);
#line 938
  if (tmp___0 == -1) {
#line 939
    js_destroy(temp);
#line 940
    return (-1);
  }
#line 943
  return_value = js_fgrep(temp, target);
#line 945
  js_destroy(temp);
#line 947
  return (return_value);
}
}
#line 957 "JsStr.c"
int js_addbyte(js_string *js , unsigned char byte ) 
{ int tmp ;

  {
#line 960
  tmp = js_has_sanity(js);
#line 960
  if (tmp == -1) {
#line 961
    return (-1);
  }
#line 962
  if (js->unit_size != 1U) {
#line 963
    return (-1);
  }
#line 965
  if (js->unit_count + 1U >= js->max_count) {
#line 966
    return (-1);
  }
#line 969
  *(js->string + js->unit_count) = byte;
#line 970
  (js->unit_count) ++;
#line 972
  return (1);
}
}
#line 981 "JsStr.c"
int js_changebyte(js_string *js , unsigned char byte , int offset ) 
{ int tmp ;

  {
#line 984
  tmp = js_has_sanity(js);
#line 984
  if (tmp == -1) {
#line 985
    return (-1);
  }
#line 986
  if (js->unit_size != 1U) {
#line 987
    return (-1);
  }
#line 989
  if ((unsigned int )offset >= js->unit_count) {
#line 990
    return (-1);
  }
#line 993
  *(js->string + offset) = byte;
#line 995
  return (1);
}
}
#line 1004 "JsStr.c"
int js_adduint16(js_string *js , int number ) 
{ int tmp ;

  {
#line 1007
  tmp = js_has_sanity(js);
#line 1007
  if (tmp == -1) {
#line 1008
    return (-1);
  }
#line 1009
  if (js->unit_size != 1U) {
#line 1010
    return (-1);
  }
#line 1011
  if (number < 0) {
#line 1012
    return (-1);
  } else
#line 1011
  if (number > 65535) {
#line 1012
    return (-1);
  }
#line 1014
  if (js->unit_count + 2U >= js->max_count) {
#line 1015
    return (-1);
  }
#line 1018
  *(js->string + js->unit_count) = (unsigned char )((number >> 8) & 255);
#line 1019
  *((js->string + js->unit_count) + 1) = (unsigned char )(number & 255);
#line 1020
  js->unit_count += 2U;
#line 1022
  return (1);
}
}
#line 1031 "JsStr.c"
int js_readbyte(js_string *js , unsigned int offset ) 
{ int tmp ;

  {
#line 1034
  tmp = js_has_sanity(js);
#line 1034
  if (tmp == -1) {
#line 1035
    return (-1);
  }
#line 1036
  if (js->unit_size != 1U) {
#line 1037
    return (-1);
  }
#line 1038
  if (offset > js->unit_count - 1U) {
#line 1039
    return (-1);
  } else
#line 1038
  if (offset < 0U) {
#line 1039
    return (-1);
  }
#line 1041
  return ((int )*(js->string + offset));
}
}
#line 1052 "JsStr.c"
int js_readuint16(js_string *js , unsigned int offset ) 
{ int ret ;
  int tmp ;

  {
#line 1056
  tmp = js_has_sanity(js);
#line 1056
  if (tmp == -1) {
#line 1057
    return (-1);
  }
#line 1058
  if (js->unit_size != 1U) {
#line 1059
    return (-1);
  }
#line 1060
  if (offset > js->unit_count - 2U) {
#line 1061
    return (-1);
  } else
#line 1060
  if (offset < 0U) {
#line 1061
    return (-1);
  }
#line 1063
  ret = (((int )*(js->string + offset) << 8) & 65280) | ((int )*((js->string + offset) + 1) & 255);
#line 1066
  return (ret);
}
}
#line 1081 "JsStr.c"
int js_substr_append(js_string *source , js_string *dest , int offset , int length ) 
{ js_string *temp ;
  int tmp ;
  int tmp___0 ;

  {
#line 1085
  temp = js_create((unsigned int )(length + 2), 1U);
#line 1085
  if ((unsigned long )temp == (unsigned long )((js_string *)0)) {
#line 1086
    return (-1);
  }
#line 1089
  if (source->unit_count < (unsigned int )(offset + length)) {
#line 1090
    js_destroy(temp);
#line 1091
    return (-1);
  }
#line 1094
  tmp = js_substr(source, temp, offset, length);
#line 1094
  if (tmp != 1) {
#line 1095
    js_destroy(temp);
#line 1096
    return (-1);
  }
#line 1099
  tmp___0 = js_append(temp, dest);
#line 1099
  if (tmp___0 == -1) {
#line 1100
    js_destroy(temp);
#line 1101
    return (-1);
  }
#line 1104
  js_destroy(temp);
#line 1105
  return (1);
}
}
#line 1 "JsStrOS.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-gt2wMBbw.i","")
#line 160 "/usr/include/stdlib.h"
extern void free(void * ) ;
#line 169
extern void *malloc(size_t  ) ;
#line 164 "/usr/include/stdio.h"
extern FILE *__stdinp ;
#line 165
extern FILE *__stdoutp ;
#line 241
extern int feof(FILE * ) ;
#line 263
extern int getc(FILE * ) ;
#line 268
extern int putc(int  , FILE * ) ;
#line 92 "/usr/include/string.h"
extern size_t strlen(char const   * ) ;
#line 470 "/usr/include/sys/fcntl.h"
extern int flock(int  , int  ) ;
#line 504 "/usr/include/unistd.h"
extern off_t lseek(int  , off_t  , int  ) ;
#line 101 "JsStr.h"
void js_open(js_string *filename , js_file *desc , int flags ) ;
#line 102
int js_open_write(js_string *filename , js_file *desc ) ;
#line 104
int js_read(js_file *desc , js_string *js , int count ) ;
#line 105
int js_write(js_file *desc , js_string *js ) ;
#line 108
int js_buf_read(js_file *desc ) ;
#line 114
uint32_t js_readuint32(js_string *js , unsigned int offset ) ;
#line 115
int js_strnlen(char *s , uint32_t limit ) ;
#line 116
int js_tell_memory_allocated(void) ;
#line 117
int show_esc_stdout(js_string *js ) ;
#line 118
int safe_esc_stdout(js_string *js ) ;
#line 121
int js_newline_chars(js_string *js ) ;
#line 57 "JsStrOS.c"
void *js_alloc(int unit_count , int unit_size ) 
{ void *data ;
  void *tmp ;

  {
#line 64
  if (unit_size == 0) {
#line 65
    return ((void *)0);
  } else
#line 64
  if (unit_count == 0) {
#line 65
    return ((void *)0);
  }
#line 66
  tmp = malloc((size_t )(unit_count * unit_size));
#line 66
  data = tmp;
#line 118
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 122
    printf("Aieeeeee, can not allocate memory!");
#line 123
    exit(64);
#line 124
    return ((void *)0);
  }
#line 126
  return (data);
}
}
#line 134 "JsStrOS.c"
void *js_alloc_DEBUG(int unit_count , int unit_size , char *whence ) 
{ void *data ;
  void *tmp ;

  {
#line 141
  tmp = malloc((size_t )(unit_count * unit_size));
#line 141
  data = tmp;
#line 200
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 204
    printf("Aieeeeee, can not allocate memory!");
#line 205
    exit(64);
#line 206
    return ((void *)0);
  }
#line 208
  return (data);
}
}
#line 215 "JsStrOS.c"
int js_dealloc(void *pointer ) 
{ 

  {
#line 220
  if ((unsigned long )pointer == (unsigned long )((void *)0)) {
#line 221
    return (1);
  }
#line 284
  free(pointer);
#line 285
  return (1);
}
}
#line 323 "JsStrOS.c"
int js_tell_memory_allocated(void) 
{ 

  {
#line 327
  return (0);
}
}
#line 335 "JsStrOS.c"
int js_show_stdout(js_string *js ) 
{ int counter ;
  int tmp ;

  {
#line 336
  counter = 0;
#line 338
  tmp = js_has_sanity(js);
#line 338
  if (tmp < 0) {
#line 339
    return (-1);
  }
#line 341
  while ((unsigned int )counter < js->unit_size * js->unit_count) {
#line 342
    putc((int )*(js->string + counter), __stdoutp);
#line 343
    counter ++;
  }
#line 346
  return (1);
}
}
#line 353 "JsStrOS.c"
int show_esc_stdout(js_string *js ) 
{ int counter ;
  unsigned char this ;
  int tmp ;

  {
#line 354
  counter = 0;
#line 357
  tmp = js_has_sanity(js);
#line 357
  if (tmp < 0) {
#line 358
    return (-1);
  }
#line 360
  if (js->unit_size != 1U) {
#line 362
    return (-1);
  }
#line 363
  while ((unsigned int )counter < js->unit_size * js->unit_count) {
#line 364
    this = *(js->string + counter);
#line 365
    if ((int )this < 32) {
#line 366
      printf("\\%03o", (int )this);
    } else
#line 365
    if ((int )this > 126) {
#line 366
      printf("\\%03o", (int )this);
    } else
#line 368
    if ((int )this == 92) {
#line 369
      printf("\\%c", (int )this);
    } else
#line 368
    if ((int )this == 37) {
#line 369
      printf("\\%c", (int )this);
    } else {
#line 372
      putc((int )*(js->string + counter), __stdoutp);
    }
#line 374
    counter ++;
  }
#line 377
  return (1);
}
}
#line 386 "JsStrOS.c"
int safe_esc_stdout(js_string *js ) 
{ int counter ;
  unsigned char this ;
  int tmp ;

  {
#line 387
  counter = 0;
#line 390
  tmp = js_has_sanity(js);
#line 390
  if (tmp < 0) {
#line 391
    return (-1);
  }
#line 393
  if (js->unit_size != 1U) {
#line 395
    return (-1);
  }
#line 396
  while ((unsigned int )counter < js->unit_size * js->unit_count) {
#line 397
    this = *(js->string + counter);
#line 400
    if ((int )this == 32) {
#line 400
      if (counter == 0) {
#line 401
        printf(" ");
      } else {
#line 400
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 403
    if ((int )this >= 65) {
#line 403
      if ((int )this <= 90) {
#line 406
        printf("%c", (int )this);
      } else {
#line 403
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 403
    if ((int )this >= 97) {
#line 403
      if ((int )this <= 122) {
#line 406
        printf("%c", (int )this);
      } else {
#line 403
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 403
    if ((int )this == 45) {
#line 406
      printf("%c", (int )this);
    } else
#line 403
    if ((int )this == 95) {
#line 406
      printf("%c", (int )this);
    } else
#line 403
    if ((int )this > 127) {
#line 406
      printf("%c", (int )this);
    } else
#line 403
    if ((int )this == 46) {
#line 406
      printf("%c", (int )this);
    } else
#line 403
    if ((int )this == 64) {
#line 406
      printf("%c", (int )this);
    } else
#line 403
    if ((int )this >= 48) {
#line 403
      if ((int )this <= 57) {
#line 406
        printf("%c", (int )this);
      } else {
#line 403
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 410
    if ((int )this == 42) {
#line 410
      if (counter == 0) {
#line 410
        if (js->unit_count > 2U) {
#line 410
          if ((int )*(js->string + 1) == 46) {
#line 412
            printf("%c", (int )this);
          } else {
#line 415
            printf("\\x%02x", (int )this);
          }
        } else {
#line 415
          printf("\\x%02x", (int )this);
        }
      } else {
#line 415
        printf("\\x%02x", (int )this);
      }
    } else {
#line 415
      printf("\\x%02x", (int )this);
    }
#line 417
    counter ++;
  }
#line 420
  return (1);
}
}
#line 427 "JsStrOS.c"
int js_getline_stdin(js_string *js ) 
{ char *temp ;
  js_string *newlines ;
  js_string *append ;
  int counter ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 431
  counter = 0;
#line 432
  tmp = js_alloc((int )js->unit_size, 1);
#line 432
  temp = (char *)tmp;
#line 433
  newlines = js_create(256U, js->unit_size);
#line 434
  if ((unsigned long )newlines == (unsigned long )((js_string *)0)) {
#line 435
    return (-1);
  }
#line 436
  newlines->encoding = js->encoding;
#line 437
  append = js_create(256U, js->unit_size);
#line 438
  if ((unsigned long )append == (unsigned long )((js_string *)0)) {
#line 439
    js_destroy(newlines);
#line 440
    js_dealloc((void *)temp);
#line 441
    return (-1);
  }
#line 443
  js_newline_chars(newlines);
#line 444
  tmp___0 = js_has_sanity(js);
#line 444
  if (tmp___0 == -1) {
#line 445
    goto error;
  }
#line 446
  if ((unsigned long )temp == (unsigned long )((char *)0)) {
#line 447
    js_destroy(newlines);
#line 448
    js_destroy(append);
#line 449
    js_dealloc((void *)temp);
#line 450
    return (-1);
  }
#line 453
  js->unit_count = 0U;
#line 454
  while (1) {
#line 454
    tmp___3 = feof(__stdinp);
#line 454
    if (tmp___3) {
#line 454
      break;
    } else {
#line 454
      tmp___4 = js_match(newlines, js);
#line 454
      if (! (tmp___4 == -2)) {
#line 454
        break;
      }
    }
#line 455
    tmp___1 = getc(__stdinp);
#line 455
    *(temp + counter) = (char )tmp___1;
#line 456
    counter ++;
#line 457
    if ((unsigned int )counter >= js->unit_size) {
#line 458
      counter = 0;
#line 459
      js_str2js(append, temp, 1, (int )js->unit_size);
#line 460
      tmp___2 = js_append(append, js);
#line 460
      if (tmp___2 == -1) {
#line 461
        goto error;
      }
    }
  }
#line 466
  js_destroy(append);
#line 467
  js_destroy(newlines);
#line 468
  js_dealloc((void *)temp);
#line 469
  return (1);
  error: 
#line 472
  js_destroy(append);
#line 473
  js_destroy(newlines);
#line 474
  js_dealloc((void *)temp);
#line 475
  return (-1);
}
}
#line 481 "JsStrOS.c"
void js_open(js_string *filename , js_file *desc , int flags ) 
{ char temp[256] ;

  {
#line 486
  if (filename->unit_count * filename->unit_size > 255U) {
#line 487
    desc->filetype = -1;
#line 488
    return;
  }
#line 494
  js_js2str(filename, temp, 255);
#line 496
  desc->filetype = 1;
#line 497
  desc->file_desc = open((char const   *)(temp), flags, 384);
#line 498
  desc->number = -1;
#line 499
  desc->eof = 0;
#line 500
  desc->buffer = (js_string *)0;
#line 502
  if (desc->file_desc == -1) {
#line 503
    desc->filetype = -1;
#line 504
    return;
  }
#line 507
  return;
}
}
#line 514 "JsStrOS.c"
int js_open_append(js_string *filename , js_file *desc ) 
{ 

  {
#line 515
  js_open(filename, desc, 521);
#line 516
  if (desc->filetype == -1) {
#line 517
    return (-1);
  } else {
#line 519
    return (1);
  }
}
}
#line 525 "JsStrOS.c"
int js_open_write(js_string *filename , js_file *desc ) 
{ 

  {
#line 526
  js_open(filename, desc, 513);
#line 527
  if (desc->filetype == -1) {
#line 528
    return (-1);
  } else {
#line 530
    return (1);
  }
}
}
#line 536 "JsStrOS.c"
int js_open_read(js_string *filename , js_file *desc ) 
{ 

  {
#line 537
  js_open(filename, desc, 0);
#line 538
  if (desc->filetype == -1) {
#line 539
    return (-1);
  } else {
#line 541
    return (1);
  }
}
}
#line 547 "JsStrOS.c"
int js_rewind(js_file *desc ) 
{ off_t tmp ;

  {
#line 549
  if ((unsigned long )desc == (unsigned long )((js_file *)0)) {
#line 550
    return (-1);
  }
#line 551
  if (desc->filetype != 1) {
#line 552
    return (-1);
  }
#line 555
  if ((unsigned long )desc->buffer != (unsigned long )((js_string *)0)) {
#line 556
    js_destroy(desc->buffer);
  }
#line 557
  desc->number = -1;
#line 559
  tmp = lseek(desc->file_desc, (off_t )0, 0);
#line 559
  if (tmp == -1LL) {
#line 560
    return (-1);
  }
#line 562
  return (1);
}
}
#line 570 "JsStrOS.c"
int js_read(js_file *desc , js_string *js , int count ) 
{ ssize_t value___0 ;
  int ret ;
  int tmp ;

  {
#line 576
  tmp = js_has_sanity(js);
#line 576
  if (tmp == -1) {
#line 577
    return (-1);
  }
#line 578
  if (desc->filetype != 1) {
#line 579
    return (-1);
  }
#line 580
  if ((unsigned int )count % js->unit_size != 0U) {
#line 581
    return (-1);
  }
#line 583
  if (count < 0) {
#line 584
    return (-1);
  } else
#line 583
  if (count > 1048576) {
#line 584
    return (-1);
  }
#line 594
  if ((unsigned int )count > js->unit_size * js->max_count) {
#line 595
    return (-1);
  }
#line 597
  value___0 = read(desc->file_desc, (void *)js->string, (size_t )count);
#line 599
  if (value___0 == -1L) {
#line 600
    return (-1);
  }
#line 602
  ret = (int )value___0;
#line 604
  if ((unsigned int )ret % js->unit_size != 0U) {
#line 605
    js->unit_count = 0U;
#line 606
    return (-1);
  }
#line 609
  js->unit_count = (unsigned int )ret / js->unit_size;
#line 611
  return (ret);
}
}
#line 618 "JsStrOS.c"
int js_write(js_file *desc , js_string *js ) 
{ ssize_t value___0 ;
  int to_write ;
  int written ;
  int tmp ;

  {
#line 624
  tmp = js_has_sanity(js);
#line 624
  if (tmp == -1) {
#line 625
    return (-1);
  }
#line 626
  if (desc->filetype != 1) {
#line 627
    return (-1);
  }
#line 629
  to_write = (int )(js->unit_size * js->unit_count);
#line 631
  if (to_write < 0) {
#line 632
    return (-1);
  } else
#line 631
  if (to_write > 1048576) {
#line 632
    return (-1);
  }
#line 642
  value___0 = write(desc->file_desc, (void const   *)js->string, (size_t )to_write);
#line 644
  written = (int )value___0;
#line 646
  if (written != to_write) {
#line 647
    return (-1);
  }
#line 649
  return (1);
}
}
#line 656 "JsStrOS.c"
int js_close(js_file *desc ) 
{ int ret ;

  {
#line 660
  ret = close(desc->file_desc);
#line 663
  if ((unsigned long )desc->buffer != (unsigned long )((js_string *)0)) {
#line 664
    js_destroy(desc->buffer);
  }
#line 665
  desc->number = -1;
#line 667
  if (ret == -1) {
#line 668
    return (-1);
  }
#line 671
  desc->filetype = -1;
#line 673
  return (1);
}
}
#line 687 "JsStrOS.c"
int js_lock(js_file *desc ) 
{ 

  {
#line 690
  flock(desc->file_desc, 2);
#line 692
  return (1);
}
}
#line 699 "JsStrOS.c"
int js_unlock(js_file *desc ) 
{ 

  {
#line 702
  flock(desc->file_desc, 8);
#line 704
  return (1);
}
}
#line 713 "JsStrOS.c"
int js_buf_eof(js_file *desc ) 
{ 

  {
#line 714
  if (desc->eof) {
#line 714
    if ((unsigned int )desc->number >= (desc->buffer)->unit_count) {
#line 715
      return (1);
    }
  }
#line 716
  return (0);
}
}
#line 722 "JsStrOS.c"
int js_buf_read(js_file *desc ) 
{ int bytes_read ;
  int tmp ;

  {
#line 726
  tmp = js_has_sanity(desc->buffer);
#line 726
  if (tmp == -1) {
#line 727
    return (-1);
  }
#line 728
  bytes_read = js_read(desc, desc->buffer, (int )(1024U * (desc->buffer)->unit_size));
#line 730
  if ((unsigned int )bytes_read != 1024U * (desc->buffer)->unit_size) {
#line 731
    desc->eof = 1;
  }
#line 732
  desc->number = 0;
#line 734
  return (1);
}
}
#line 744 "JsStrOS.c"
int js_buf_getline(js_file *desc , js_string *js ) 
{ js_string *newlines ;
  js_string *temp ;
  int next_newln ;
  int overflowed ;
  int tmp ;
  int tmp___0 ;

  {
#line 747
  overflowed = 0;
#line 750
  tmp = js_has_sanity(js);
#line 750
  if (tmp == -1) {
#line 751
    return (-1);
  }
#line 755
  if (desc->number == -1) {
#line 756
    if ((unsigned long )desc->buffer == (unsigned long )((js_string *)0)) {
#line 757
      desc->buffer = js_create(1034U, js->unit_size);
    }
#line 758
    js_buf_read(desc);
  }
#line 762
  if (js->unit_size != (desc->buffer)->unit_size) {
#line 763
    return (-1);
  }
#line 767
  newlines = js_create(js->max_count, js->unit_size);
#line 768
  js_copy(js, newlines);
#line 769
  js_newline_chars(newlines);
#line 772
  next_newln = js_match_offset(newlines, desc->buffer, desc->number);
#line 775
  if (next_newln == -2) {
#line 775
    if (desc->eof == 0) {
#line 779
      if ((unsigned int )(1025 - desc->number) < js->max_count) {
#line 779
        if (overflowed == 0) {
#line 780
          js_substr(desc->buffer, js, desc->number, 1024 - desc->number);
        } else {
#line 783
          js_str2js(js, (char *)"", 0, (int )js->unit_size);
#line 784
          overflowed = 1;
        }
      } else {
#line 783
        js_str2js(js, (char *)"", 0, (int )js->unit_size);
#line 784
        overflowed = 1;
      }
#line 787
      js_buf_read(desc);
#line 790
      while (1) {
#line 790
        tmp___0 = js_match(newlines, desc->buffer);
#line 790
        if (tmp___0 == -2) {
#line 790
          if (! (desc->eof == 0)) {
#line 790
            break;
          }
        } else {
#line 790
          break;
        }
#line 791
        if (js->unit_count + 1024U < js->max_count) {
#line 791
          if (overflowed == 0) {
#line 792
            js_append(desc->buffer, js);
          } else {
#line 794
            js_str2js(js, (char *)"", 0, (int )js->unit_size);
#line 795
            overflowed = 1;
          }
        } else {
#line 794
          js_str2js(js, (char *)"", 0, (int )js->unit_size);
#line 795
          overflowed = 1;
        }
#line 797
        js_buf_read(desc);
      }
#line 799
      next_newln = js_match(newlines, desc->buffer);
#line 800
      temp = js_create(js->max_count, js->unit_size);
#line 801
      js_substr(desc->buffer, temp, 0, next_newln + 1);
#line 802
      js_append(temp, js);
#line 803
      js_destroy(temp);
#line 804
      if (next_newln != -2) {
#line 805
        desc->number = next_newln + 1;
      }
#line 806
      if (desc->number >= 1024) {
#line 807
        js_buf_read(desc);
      }
#line 808
      js_destroy(newlines);
#line 809
      if (overflowed == 1) {
#line 810
        return (-2);
      }
#line 811
      return (1);
    } else {
#line 775
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 813
  if (next_newln == -2) {
#line 816
    if ((desc->buffer)->unit_count - (unsigned int )desc->number < js->max_count) {
#line 816
      if (overflowed == 0) {
#line 818
        js_substr(desc->buffer, js, desc->number, (int )((desc->buffer)->unit_count - (unsigned int )desc->number));
      } else {
#line 821
        js_str2js(js, (char *)"", 0, (int )js->unit_size);
#line 822
        overflowed = 1;
      }
    } else {
#line 821
      js_str2js(js, (char *)"", 0, (int )js->unit_size);
#line 822
      overflowed = 1;
    }
#line 826
    desc->number = (int )((desc->buffer)->unit_count + 1U);
#line 828
    js_destroy(newlines);
#line 829
    if (overflowed == 1) {
#line 830
      return (-2);
    }
#line 831
    return (1);
  }
#line 835
  if ((unsigned int )((next_newln + 1) - desc->number) < js->max_count) {
#line 836
    js_substr(desc->buffer, js, desc->number, (next_newln + 1) - desc->number);
#line 837
    desc->number = next_newln + 1;
#line 838
    if (desc->number >= 1024) {
#line 839
      js_buf_read(desc);
    }
  } else {
#line 842
    js_str2js(js, (char *)"", 0, (int )js->unit_size);
  }
#line 844
  js_destroy(newlines);
#line 846
  if (overflowed == 1) {
#line 847
    return (-2);
  }
#line 849
  return (1);
}
}
#line 857 "JsStrOS.c"
int js_qstr2js(js_string *js , char *string ) 
{ size_t tmp ;
  int tmp___0 ;

  {
#line 858
  if ((unsigned long )js == (unsigned long )((js_string *)0)) {
#line 859
    return (-1);
  }
#line 861
  tmp = strlen((char const   *)string);
#line 861
  tmp___0 = js_str2js(js, string, (int )tmp, (int )js->unit_size);
#line 861
  return (tmp___0);
}
}
#line 871 "JsStrOS.c"
int js_adduint32(js_string *js , uint32_t number ) 
{ int tmp ;

  {
#line 874
  tmp = js_has_sanity(js);
#line 874
  if (tmp == -1) {
#line 875
    return (-1);
  }
#line 876
  if (js->unit_size != 1U) {
#line 877
    return (-1);
  }
#line 879
  if (js->unit_count + 4U >= js->max_count) {
#line 880
    return (-1);
  }
#line 883
  *(js->string + js->unit_count) = (unsigned char )((number >> 24) & 255U);
#line 884
  *((js->string + js->unit_count) + 1) = (unsigned char )((number >> 16) & 255U);
#line 885
  *((js->string + js->unit_count) + 2) = (unsigned char )((number >> 8) & 255U);
#line 886
  *((js->string + js->unit_count) + 3) = (unsigned char )(number & 255U);
#line 887
  js->unit_count += 4U;
#line 889
  return (1);
}
}
#line 901 "JsStrOS.c"
uint32_t js_readuint32(js_string *js , unsigned int offset ) 
{ uint32_t ret ;
  int tmp ;

  {
#line 905
  tmp = js_has_sanity(js);
#line 905
  if (tmp == -1) {
#line 906
    return (4294967295U);
  }
#line 907
  if (js->unit_size != 1U) {
#line 908
    return (4294967295U);
  }
#line 909
  if (offset > js->unit_count - 4U) {
#line 910
    return (4294967295U);
  } else
#line 909
  if (offset < 0U) {
#line 910
    return (4294967295U);
  }
#line 912
  ret = ((((unsigned int )((int )*(js->string + offset) << 24) & 4278190080U) | (unsigned int )(((int )*((js->string + offset) + 1) << 16) & 16711680)) | (unsigned int )(((int )*((js->string + offset) + 2) << 8) & 65280)) | (unsigned int )((int )*((js->string + offset) + 3) & 255);
#line 918
  if (ret == 4294967295U) {
#line 919
    ret = 4294967294U;
  }
#line 921
  return (ret);
}
}
#line 929 "JsStrOS.c"
int js_strnlen(char *s , uint32_t limit ) 
{ uint32_t len ;
  char *tmp ;

  {
#line 931
  if (limit > 2147483600U) {
#line 932
    return (-1);
  } else
#line 931
  if (limit < 0U) {
#line 932
    return (-1);
  }
#line 934
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 935
    return (-1);
  }
#line 937
  len = (uint32_t )0;
#line 938
  while (1) {
#line 938
    if (len < limit) {
#line 938
      tmp = s;
#line 938
      s ++;
#line 938
      if (! *tmp) {
#line 938
        break;
      }
    } else {
#line 938
      break;
    }
#line 939
    len ++;
  }
#line 941
  return ((int )len);
}
}
#line 1 "JsStrCP.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-6c9w5MTV.i","")
#line 122 "JsStr.h"
int js_tolower(js_string *js ) ;
#line 124
int js_space_chars(js_string *js ) ;
#line 125
js_string *js_an_chars(js_string *js ) ;
#line 126
js_string *js_numbers(js_string *js ) ;
#line 12 "JsStrCP.c"
int js_newline_chars(js_string *js ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 15
  tmp = js_has_sanity(js);
#line 15
  if (tmp == -1) {
#line 16
    return (-1);
  }
#line 19
  switch (js->encoding) {
  case 1: 
#line 21
  js->unit_count = 0U;
#line 22
  return (1);
  case 2: 
  case 3: 
#line 25
  if (js->unit_size != 1U) {
#line 26
    return (-1);
  }
#line 27
  tmp___0 = js_octets(js);
#line 27
  if (tmp___0 < 2) {
#line 28
    return (-1);
  }
#line 29
  *(js->string) = (unsigned char )'\r';
#line 30
  *(js->string + 1) = (unsigned char )'\n';
#line 31
  js->unit_count = 2U;
#line 32
  return (1);
  }
#line 36
  return (-1);
}
}
#line 45 "JsStrCP.c"
int js_space_chars(js_string *js ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 48
  tmp = js_has_sanity(js);
#line 48
  if (tmp == -1) {
#line 49
    return (-1);
  }
#line 52
  switch (js->encoding) {
  case 1: 
#line 54
  js->unit_count = 0U;
#line 55
  return (1);
  case 2: 
  case 3: 
#line 58
  if (js->unit_size != 1U) {
#line 59
    return (-1);
  }
#line 60
  tmp___0 = js_octets(js);
#line 60
  if (tmp___0 < 3) {
#line 61
    return (-1);
  }
#line 62
  *(js->string) = (unsigned char )' ';
#line 63
  *(js->string + 1) = (unsigned char )'\t';
#line 64
  if (js->encoding != 2) {
#line 65
    *(js->string + 2) = (unsigned char)160;
#line 66
    js->unit_count = 3U;
  } else {
#line 69
    js->unit_count = 2U;
  }
#line 70
  return (1);
  }
#line 74
  return (-1);
}
}
#line 81 "JsStrCP.c"
unsigned int js_atoi(js_string *js , int offset ) 
{ int value___0 ;
  int sign ;
  int tmp ;

  {
#line 85
  tmp = js_has_sanity(js);
#line 85
  if (tmp == -1) {
#line 86
    return (0U);
  }
#line 89
  if (js->encoding != 2) {
#line 89
    if (js->encoding != 3) {
#line 90
      return (0U);
    } else {
#line 89
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 93
    if ((unsigned int )offset >= js->unit_count) {
#line 94
      return (0U);
    }
#line 95
    value___0 = 0;
#line 96
    sign = 1;
#line 97
    while (1) {
#line 97
      if ((unsigned int )offset < js->unit_count) {
#line 97
        if ((int )*(js->string + offset) >= 48) {
#line 97
          if (! ((int )*(js->string + offset) <= 57)) {
#line 97
            break;
          }
        } else {
#line 97
          break;
        }
      } else {
#line 97
        break;
      }
#line 99
      value___0 *= 10;
#line 100
      value___0 += (int )*(js->string + offset) - 48;
#line 101
      offset ++;
    }
#line 103
    value___0 *= sign;
#line 104
    return ((unsigned int )value___0);
  }
#line 107
  return (0U);
}
}
#line 113 "JsStrCP.c"
int js_tolower(js_string *js ) 
{ int counter ;
  int tmp ;

  {
#line 116
  tmp = js_has_sanity(js);
#line 116
  if (tmp == -1) {
#line 117
    return (-1);
  }
#line 119
  if (js->unit_size != 1U) {
#line 121
    return (-1);
  }
#line 123
  if (js->encoding == 2) {
#line 124
    counter = 0;
#line 124
    while ((unsigned int )counter < js->unit_count) {
#line 125
      if ((int )*(js->string + counter) >= 65) {
#line 125
        if ((int )*(js->string + counter) <= 90) {
#line 127
          *(js->string + counter) = (unsigned char )((int )*(js->string + counter) + 32);
        }
      }
#line 124
      counter ++;
    }
  } else
#line 129
  if (js->encoding == 3) {
#line 130
    counter = 0;
#line 130
    while ((unsigned int )counter < js->unit_count) {
#line 131
      if ((int )*(js->string + counter) >= 65) {
#line 131
        if ((int )*(js->string + counter) <= 90) {
#line 133
          *(js->string + counter) = (unsigned char )((int )*(js->string + counter) + 32);
        }
      }
#line 134
      if ((int )*(js->string + counter) >= 192) {
#line 134
        if ((int )*(js->string + counter) <= 214) {
#line 136
          *(js->string + counter) = (unsigned char )((int )*(js->string + counter) + 32);
        }
      }
#line 139
      if ((int )*(js->string + counter) >= 216) {
#line 139
        if ((int )*(js->string + counter) <= 222) {
#line 141
          *(js->string + counter) = (unsigned char )((int )*(js->string + counter) + 32);
        }
      }
#line 130
      counter ++;
    }
  } else {
#line 146
    return (0);
  }
#line 148
  return (1);
}
}
#line 159 "JsStrCP.c"
js_string *js_anq_chars(js_string *js , int do_nums ) 
{ int place ;
  int do_lets ;
  unsigned char counter ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 160
  place = 0;
#line 160
  do_lets = 1;
#line 164
  tmp = js_has_sanity(js);
#line 164
  if (tmp == -1) {
#line 165
    return ((js_string *)0);
  }
#line 168
  if (do_nums == 2) {
#line 169
    do_lets = 0;
  }
#line 172
  switch (js->encoding) {
  case 3: 
#line 174
  tmp___0 = js_octets(js);
#line 174
  if (tmp___0 < 192) {
#line 175
    return ((js_string *)0);
  }
#line 176
  if (do_lets == 1) {
#line 178
    counter = (unsigned char)192;
#line 178
    while ((int )counter <= 214) {
#line 179
      *(js->string + place) = counter;
#line 180
      place ++;
#line 178
      counter = (unsigned char )((int )counter + 1);
    }
#line 183
    counter = (unsigned char)216;
#line 183
    while ((int )counter <= 246) {
#line 184
      *(js->string + place) = counter;
#line 185
      place ++;
#line 183
      counter = (unsigned char )((int )counter + 1);
    }
#line 188
    counter = (unsigned char)248;
#line 188
    while ((int )counter < 255) {
#line 189
      *(js->string + place) = counter;
#line 190
      place ++;
#line 188
      counter = (unsigned char )((int )counter + 1);
    }
#line 193
    *(js->string + place) = (unsigned char)255;
#line 194
    place ++;
  }
  case 2: 
#line 197
  tmp___1 = js_octets(js);
#line 197
  if (tmp___1 < 96) {
#line 198
    return ((js_string *)0);
  }
#line 199
  if (do_lets == 1) {
#line 201
    counter = (unsigned char )'A';
#line 201
    while ((int )counter <= 90) {
#line 202
      *(js->string + place) = counter;
#line 203
      place ++;
#line 201
      counter = (unsigned char )((int )counter + 1);
    }
#line 206
    counter = (unsigned char )'a';
#line 206
    while ((int )counter <= 122) {
#line 207
      *(js->string + place) = counter;
#line 208
      place ++;
#line 206
      counter = (unsigned char )((int )counter + 1);
    }
  }
#line 211
  if (do_nums == 1) {
#line 211
    goto _L;
  } else
#line 211
  if (do_nums == 2) {
    _L: /* CIL Label */ 
#line 213
    counter = (unsigned char )'0';
#line 213
    while ((int )counter <= 57) {
#line 214
      *(js->string + place) = counter;
#line 215
      place ++;
#line 213
      counter = (unsigned char )((int )counter + 1);
    }
#line 218
    if (do_nums != 2) {
#line 219
      *(js->string + place) = (unsigned char )'_';
#line 220
      place ++;
    }
  }
#line 223
  js->unit_count = (unsigned int )place;
#line 224
  break;
  default: 
#line 226
  return ((js_string *)0);
  }
#line 229
  return (js);
}
}
#line 239 "JsStrCP.c"
js_string *js_alpha_chars(js_string *js ) 
{ js_string *tmp ;

  {
#line 240
  tmp = js_anq_chars(js, 0);
#line 240
  return (tmp);
}
}
#line 249 "JsStrCP.c"
js_string *js_an_chars(js_string *js ) 
{ js_string *tmp ;

  {
#line 250
  tmp = js_anq_chars(js, 1);
#line 250
  return (tmp);
}
}
#line 259 "JsStrCP.c"
js_string *js_numbers(js_string *js ) 
{ js_string *tmp ;

  {
#line 260
  tmp = js_anq_chars(js, 2);
#line 260
  return (tmp);
}
}
#line 1 "MaraHash.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-VU6Jvmcg.i","")
#line 58 "MaraHash.h"
mhash *mhash_create(int hash_bits ) ;
#line 59
unsigned int mhash_js(js_string *tohash , int hash_bits ) ;
#line 61
int mhash_put(mhash *hash , js_string *key___0 , void *value___0 , int datatype ) ;
#line 62
mhash_e mhash_get(mhash *hash , js_string *key___0 ) ;
#line 63
int mhash_put_js(mhash *hash , js_string *key___0 , js_string *value___0 ) ;
#line 64
js_string *mhash_get_js(mhash *hash , js_string *key___0 ) ;
#line 65
int mhash_firstkey(mhash *hash , js_string *key___0 ) ;
#line 66
int mhash_nextkey(mhash *hash , js_string *key___0 ) ;
#line 69
mara_tuple *mtuple_new(int elements ) ;
#line 70
int mtuple_put(mara_tuple *tuple , js_string *js , int element ) ;
#line 71
js_string *mtuple_get(mara_tuple *tuple , int element ) ;
#line 73
js_string *mhash_get_immutable_key(mhash *hash , js_string *key___0 ) ;
#line 5 "functions_MaraHash.h"
int mhash_undef_js(mhash *hash , js_string *key___0 ) ;
#line 13
int mhash_resize(mhash *hash , int new_bits ) ;
#line 21
int mhash_autogrow(mhash *hash ) ;
#line 40
void *mhash_undef(mhash *hash , js_string *key___0 ) ;
#line 38 "MaraHash.c"
unsigned int mhash_mask[31]  = 
#line 38 "MaraHash.c"
  {      1U,      1U,      3U,      7U, 
        15U,      31U,      63U,      127U, 
        255U,      511U,      1023U,      2047U, 
        4095U,      8191U,      16383U,      32767U, 
        65535U,      131071U,      262143U,      524287U, 
        1048575U,      2097151U,      4194303U,      8388607U, 
        16777215U,      33554431U,      67108863U,      134217727U, 
        268435455U,      536870911U,      1073741823U};
#line 50 "MaraHash.c"
mhash *mhash_create(int hash_bits ) 
{ mhash *new ;
  int counter ;
  void *tmp ;
  mhash_spot **tmp___0 ;
  void *tmp___1 ;

  {
#line 55
  tmp = js_alloc(1, (int )sizeof(mhash ));
#line 55
  new = (mhash *)tmp;
#line 55
  if ((unsigned long )new == (unsigned long )((mhash *)0)) {
#line 56
    return ((mhash *)0);
  }
#line 58
  new->hash_bits = hash_bits;
#line 62
  tmp___1 = js_alloc((int )(mhash_mask[hash_bits] + 1U), (int )sizeof(mhash_spot *));
#line 62
  tmp___0 = (mhash_spot **)tmp___1;
#line 62
  new->hash_table = tmp___0;
#line 62
  if ((unsigned long )tmp___0 == (unsigned long )((mhash_spot **)0)) {
#line 64
    js_dealloc((void *)new);
#line 65
    return ((mhash *)0);
  }
#line 69
  counter = 0;
#line 69
  while ((unsigned int )counter <= mhash_mask[hash_bits]) {
#line 70
    *(new->hash_table + counter) = (mhash_spot *)0;
#line 69
    counter ++;
  }
#line 73
  new->spots = 0U;
#line 76
  return (new);
}
}
#line 86 "MaraHash.c"
unsigned int mhash_js(js_string *tohash , int hash_bits ) 
{ unsigned int ret ;
  unsigned char *point ;
  unsigned char *max ;
  int shift ;
  int tmp ;
  int tmp___0 ;

  {
#line 88
  ret = 0U;
#line 91
  shift = 0;
#line 93
  tmp = js_has_sanity(tohash);
#line 93
  if (tmp == -1) {
#line 94
    return (0U);
  }
#line 95
  point = tohash->string;
#line 96
  max = point + tohash->unit_count * tohash->unit_size;
#line 97
  tmp___0 = js_octets(tohash);
#line 97
  if ((unsigned long )max > (unsigned long )(point + tmp___0)) {
#line 98
    return (0U);
  }
#line 101
  while ((unsigned long )point < (unsigned long )max) {
#line 102
    ret += (unsigned int )((int )*point << shift);
#line 103
    shift += 7;
#line 104
    shift %= hash_bits;
#line 105
    point ++;
  }
#line 109
  ret ^= ret >> 7;
#line 112
  ret &= mhash_mask[hash_bits];
#line 115
  if (ret == 0U) {
#line 116
    ret ++;
  }
#line 118
  return (ret);
}
}
#line 128 "MaraHash.c"
int mhash_put(mhash *hash , js_string *key___0 , void *value___0 , int datatype ) 
{ unsigned int first_found ;
  js_string *new_key ;
  mhash_spot *point ;
  mhash_spot *new ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 136
  tmp = js_has_sanity(key___0);
#line 136
  if (tmp == -1) {
#line 137
    return (-1);
  }
#line 140
  first_found = mhash_js(key___0, hash->hash_bits);
#line 141
  if (first_found == 0U) {
#line 142
    return (-1);
  }
#line 146
  new_key = js_create(key___0->unit_count + 1U, key___0->unit_size);
#line 146
  if ((unsigned long )new_key == (unsigned long )((js_string *)0)) {
#line 147
    js_dealloc((void *)*(hash->hash_table + first_found));
#line 148
    return (-1);
  }
#line 150
  tmp___0 = js_copy(key___0, new_key);
#line 150
  if (tmp___0 == -1) {
#line 151
    js_dealloc((void *)*(hash->hash_table + first_found));
#line 152
    js_destroy(new_key);
#line 153
    return (-1);
  }
#line 157
  tmp___1 = js_alloc(1, (int )sizeof(mhash_spot ));
#line 157
  new = (mhash_spot *)tmp___1;
#line 157
  if ((unsigned long )new == (unsigned long )((mhash_spot *)0)) {
#line 158
    return (-1);
  }
#line 161
  new->key = new_key;
#line 162
  new->value = value___0;
#line 163
  new->datatype = datatype;
#line 164
  new->next = (struct mhash_spot *)0;
#line 167
  point = *(hash->hash_table + first_found);
#line 169
  if ((unsigned long )point == (unsigned long )((mhash_spot *)0)) {
#line 170
    *(hash->hash_table + first_found) = new;
  } else {
#line 175
    tmp___2 = js_issame(point->key, new_key);
#line 175
    if (tmp___2) {
#line 176
      goto cleanup;
    }
#line 177
    while ((unsigned long )point->next != (unsigned long )((struct mhash_spot *)0)) {
#line 179
      tmp___3 = js_issame(point->key, new_key);
#line 179
      if (tmp___3) {
#line 180
        goto cleanup;
      }
#line 181
      point = point->next;
    }
#line 184
    tmp___4 = js_issame(point->key, new_key);
#line 184
    if (tmp___4) {
#line 185
      goto cleanup;
    }
#line 186
    point->next = new;
  }
#line 190
  (hash->spots) ++;
#line 192
  return (1);
  cleanup: 
#line 195
  js_destroy(new_key);
#line 196
  js_dealloc((void *)new);
#line 197
  return (-1);
}
}
#line 207 "MaraHash.c"
mhash_e mhash_get(mhash *hash , js_string *key___0 ) 
{ unsigned int first_found ;
  mhash_spot *point ;
  mhash_e ret ;
  int tmp ;
  int tmp___0 ;

  {
#line 213
  ret.point = (void **)0;
#line 214
  ret.value = (void *)0;
#line 215
  ret.datatype = -1;
#line 218
  tmp = js_has_sanity(key___0);
#line 218
  if (tmp == -1) {
#line 219
    return (ret);
  }
#line 222
  first_found = mhash_js(key___0, hash->hash_bits);
#line 225
  if ((unsigned long )*(hash->hash_table + first_found) == (unsigned long )((mhash_spot *)0)) {
#line 226
    ret.value = (void *)0;
#line 227
    ret.datatype = 0;
#line 228
    ret.point = (void **)0;
#line 229
    return (ret);
  }
#line 232
  point = *(hash->hash_table + first_found);
#line 235
  while (1) {
#line 235
    tmp___0 = js_issame(key___0, point->key);
#line 235
    if (tmp___0) {
#line 235
      break;
    }
#line 237
    if ((unsigned long )point->next == (unsigned long )((struct mhash_spot *)0)) {
#line 238
      ret.value = (void *)0;
#line 239
      ret.datatype = 0;
#line 240
      ret.point = (void **)0;
#line 241
      return (ret);
    }
#line 243
    point = point->next;
  }
#line 247
  ret.point = & point->value;
#line 248
  ret.value = point->value;
#line 249
  ret.datatype = point->datatype;
#line 251
  return (ret);
}
}
#line 261 "MaraHash.c"
js_string *mhash_get_immutable_key(mhash *hash , js_string *key___0 ) 
{ unsigned int first_found ;
  mhash_spot *point ;
  int tmp ;
  int tmp___0 ;

  {
#line 267
  tmp = js_has_sanity(key___0);
#line 267
  if (tmp == -1) {
#line 268
    return ((js_string *)0);
  }
#line 271
  first_found = mhash_js(key___0, hash->hash_bits);
#line 274
  if ((unsigned long )*(hash->hash_table + first_found) == (unsigned long )((mhash_spot *)0)) {
#line 275
    return ((js_string *)0);
  }
#line 277
  point = *(hash->hash_table + first_found);
#line 280
  while (1) {
#line 280
    tmp___0 = js_issame(key___0, point->key);
#line 280
    if (tmp___0) {
#line 280
      break;
    }
#line 282
    if ((unsigned long )point->next == (unsigned long )((struct mhash_spot *)0)) {
#line 283
      return ((js_string *)0);
    }
#line 284
    point = point->next;
  }
#line 289
  return (point->key);
}
}
#line 298 "MaraHash.c"
void *mhash_undef(mhash *hash , js_string *key___0 ) 
{ unsigned int first_found ;
  mhash_spot *point ;
  mhash_spot *last ;
  void *ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 304
  first_found = mhash_js(key___0, hash->hash_bits);
#line 305
  if (first_found == 0U) {
#line 306
    return ((void *)0);
  }
#line 310
  if ((unsigned long )*(hash->hash_table + first_found) == (unsigned long )((mhash_spot *)0)) {
#line 311
    return ((void *)0);
  }
#line 314
  point = *(hash->hash_table + first_found);
#line 315
  last = (mhash_spot *)0;
#line 318
  while ((unsigned long )point != (unsigned long )((mhash_spot *)0)) {
#line 320
    tmp = js_issame(key___0, point->key);
#line 320
    if (tmp) {
#line 321
      break;
    }
#line 322
    last = point;
#line 323
    point = point->next;
  }
#line 327
  if ((unsigned long )point == (unsigned long )((mhash_spot *)0)) {
#line 328
    return ((void *)0);
  }
#line 331
  if ((unsigned long )last == (unsigned long )((mhash_spot *)0)) {
#line 332
    *(hash->hash_table + first_found) = point->next;
  } else {
#line 334
    last->next = point->next;
  }
#line 337
  (hash->spots) --;
#line 340
  tmp___0 = js_destroy(point->key);
#line 340
  if (tmp___0 == -1) {
#line 341
    return ((void *)0);
  }
#line 345
  ret = point->value;
#line 348
  tmp___1 = js_dealloc((void *)point);
#line 348
  if (tmp___1 == -1) {
#line 349
    return ((void *)0);
  }
#line 354
  return (ret);
}
}
#line 362 "MaraHash.c"
int mhash_put_js(mhash *hash , js_string *key___0 , js_string *value___0 ) 
{ js_string *new ;
  int ret ;
  int tmp ;

  {
#line 371
  new = js_create(value___0->unit_count + 1U, value___0->unit_size);
#line 371
  if ((unsigned long )new == (unsigned long )((js_string *)0)) {
#line 372
    return (-1);
  }
#line 373
  tmp = js_copy(value___0, new);
#line 373
  if (tmp == -1) {
#line 374
    js_destroy(new);
#line 375
    return (-1);
  }
#line 378
  ret = mhash_put(hash, key___0, (void *)new, 1);
#line 380
  if (ret == -1) {
#line 381
    js_destroy(new);
  }
#line 383
  return (ret);
}
}
#line 390 "MaraHash.c"
js_string *mhash_get_js(mhash *hash , js_string *key___0 ) 
{ mhash_e info ;
  int tmp ;

  {
#line 392
  info = mhash_get(hash, key___0);
#line 393
  if ((unsigned long )info.value == (unsigned long )((void *)0)) {
#line 394
    return ((js_string *)0);
  }
#line 395
  if (info.datatype != 1) {
#line 396
    return ((js_string *)0);
  }
#line 397
  tmp = js_has_sanity((js_string *)info.value);
#line 397
  if (tmp == -1) {
#line 398
    return ((js_string *)0);
  }
#line 399
  return ((js_string *)info.value);
}
}
#line 406 "MaraHash.c"
int mhash_undef_js(mhash *hash , js_string *key___0 ) 
{ js_string *tonuke ;
  void *tmp ;
  int tmp___0 ;

  {
#line 408
  tmp = mhash_undef(hash, key___0);
#line 408
  tonuke = (js_string *)tmp;
#line 409
  if ((unsigned long )tonuke == (unsigned long )((js_string *)0)) {
#line 410
    js_destroy(tonuke);
#line 411
    return (-1);
  }
#line 413
  tmp___0 = js_destroy(tonuke);
#line 413
  return (tmp___0);
}
}
#line 422 "MaraHash.c"
int mhash_resize(mhash *hash , int new_bits ) 
{ unsigned int counter ;
  unsigned int old_tablesize ;
  mhash_spot **new_hash_table ;
  mhash_spot **old_hash_table ;
  mhash_spot *point ;
  mhash_spot *save ;
  void *tmp ;
  int tmp___0 ;

  {
#line 429
  if (new_bits < 1) {
#line 430
    return (-1);
  } else
#line 429
  if (new_bits > 29) {
#line 430
    return (-1);
  }
#line 433
  tmp = js_alloc((int )(mhash_mask[new_bits] + 1U), (int )sizeof(mhash_spot *));
#line 433
  new_hash_table = (mhash_spot **)tmp;
#line 433
  if ((unsigned long )new_hash_table == (unsigned long )((mhash_spot **)0)) {
#line 435
    return (-1);
  }
#line 438
  counter = 0U;
#line 438
  while (counter <= mhash_mask[new_bits]) {
#line 439
    *(new_hash_table + counter) = (mhash_spot *)0;
#line 438
    counter ++;
  }
#line 442
  old_hash_table = hash->hash_table;
#line 446
  old_tablesize = mhash_mask[hash->hash_bits];
#line 450
  hash->hash_table = new_hash_table;
#line 451
  hash->hash_bits = new_bits;
#line 454
  counter = 1U;
#line 454
  while (counter <= old_tablesize) {
#line 457
    if ((unsigned long )*(old_hash_table + counter) != (unsigned long )((mhash_spot *)0)) {
#line 458
      point = *(old_hash_table + counter);
#line 461
      while ((unsigned long )point != (unsigned long )((mhash_spot *)0)) {
#line 463
        if ((unsigned long )point->key == (unsigned long )((js_string *)0)) {
#line 464
          continue;
        }
#line 465
        tmp___0 = js_has_sanity(point->key);
#line 465
        if (tmp___0 == -1) {
#line 466
          continue;
        }
#line 469
        mhash_put(hash, point->key, point->value, point->datatype);
#line 473
        save = point->next;
#line 474
        js_dealloc((void *)point);
#line 475
        point = save;
      }
    }
#line 454
    counter ++;
  }
#line 481
  js_dealloc((void *)old_hash_table);
#line 483
  return (1);
}
}
#line 492 "MaraHash.c"
int mhash_autogrow(mhash *hash ) 
{ int bits ;
  int tmp ;
  int tmp___0 ;

  {
#line 496
  bits = hash->hash_bits;
#line 497
  if (bits < 1) {
#line 498
    return (-1);
  } else
#line 497
  if (bits > 29) {
#line 498
    return (-1);
  }
#line 501
  if (bits < 4) {
#line 502
    tmp = mhash_resize(hash, bits + 1);
#line 502
    if (tmp == -1) {
#line 503
      return (-1);
    }
#line 504
    return (2);
  }
#line 511
  if (hash->spots >= mhash_mask[bits - 1]) {
#line 512
    tmp___0 = mhash_resize(hash, bits + 1);
#line 512
    if (tmp___0 == -1) {
#line 513
      return (-1);
    }
#line 514
    return (2);
  }
#line 518
  return (1);
}
}
#line 530 "MaraHash.c"
int mhash_firstkey(mhash *hash , js_string *key___0 ) 
{ unsigned int offset ;
  mhash_spot *point ;
  int tmp ;

  {
#line 531
  offset = 0U;
#line 534
  while (offset < mhash_mask[hash->hash_bits] + 1U) {
#line 537
    if ((unsigned long )*(hash->hash_table + offset) != (unsigned long )((mhash_spot *)0)) {
#line 538
      point = *(hash->hash_table + offset);
#line 539
      tmp = js_copy(point->key, key___0);
#line 539
      return (tmp);
    } else {
#line 542
      offset ++;
    }
  }
#line 547
  return (0);
}
}
#line 560 "MaraHash.c"
int mhash_nextkey(mhash *hash , js_string *key___0 ) 
{ mhash_spot *point ;
  unsigned int offset ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 565
  offset = mhash_js(key___0, hash->hash_bits);
#line 568
  if (offset > mhash_mask[hash->hash_bits]) {
#line 569
    return (-1);
  } else
#line 568
  if (offset < 0U) {
#line 569
    return (-1);
  }
#line 573
  point = *(hash->hash_table + offset);
#line 576
  if ((unsigned long )point == (unsigned long )((mhash_spot *)0)) {
#line 577
    return (-1);
  }
#line 580
  while (1) {
#line 580
    tmp = js_issame(key___0, point->key);
#line 580
    if (tmp) {
#line 580
      break;
    }
#line 582
    if ((unsigned long )point->next == (unsigned long )((struct mhash_spot *)0)) {
#line 583
      return (-1);
    }
#line 585
    point = point->next;
  }
#line 593
  if ((unsigned long )point->next != (unsigned long )((struct mhash_spot *)0)) {
#line 594
    tmp___0 = js_copy((point->next)->key, key___0);
#line 594
    return (tmp___0);
  }
#line 599
  offset ++;
#line 601
  while (offset < mhash_mask[hash->hash_bits] + 1U) {
#line 604
    if ((unsigned long )*(hash->hash_table + offset) != (unsigned long )((mhash_spot *)0)) {
#line 605
      point = *(hash->hash_table + offset);
#line 606
      tmp___1 = js_copy(point->key, key___0);
#line 606
      return (tmp___1);
    } else {
#line 609
      offset ++;
    }
  }
#line 614
  return (0);
}
}
#line 621 "MaraHash.c"
mara_tuple *mtuple_new(int elements ) 
{ mara_tuple *ret ;
  int counter ;
  void *tmp ;
  js_string **tmp___0 ;
  void *tmp___1 ;

  {
#line 625
  tmp = js_alloc(1, (int )sizeof(mara_tuple ));
#line 625
  ret = (mara_tuple *)tmp;
#line 625
  if ((unsigned long )ret == (unsigned long )((mara_tuple *)0)) {
#line 626
    return ((mara_tuple *)0);
  }
#line 628
  ret->elements = elements;
#line 629
  tmp___1 = js_alloc(elements, (int )sizeof(js_string *));
#line 629
  tmp___0 = (js_string **)tmp___1;
#line 629
  ret->tuple_list = tmp___0;
#line 629
  if ((unsigned long )tmp___0 == (unsigned long )((js_string **)0)) {
#line 630
    js_dealloc((void *)ret);
#line 631
    return ((mara_tuple *)0);
  }
#line 635
  counter = 0;
#line 635
  while (counter < elements) {
#line 636
    *(ret->tuple_list + counter) = (js_string *)0;
#line 635
    counter ++;
  }
#line 638
  return (ret);
}
}
#line 648 "MaraHash.c"
int mtuple_put(mara_tuple *tuple , js_string *js , int element ) 
{ js_string *copy ;
  int tmp ;

  {
#line 654
  if (element >= tuple->elements) {
#line 655
    return (-1);
  } else
#line 654
  if (element < 0) {
#line 655
    return (-1);
  }
#line 656
  if ((unsigned long )*(tuple->tuple_list + element) != (unsigned long )((js_string *)0)) {
#line 657
    return (-1);
  }
#line 662
  copy = js_create(js->unit_count + 1U, js->unit_size);
#line 662
  if ((unsigned long )copy == (unsigned long )((js_string *)0)) {
#line 663
    return (-1);
  }
#line 664
  tmp = js_copy(js, copy);
#line 664
  if (tmp == -1) {
#line 665
    return (-1);
  }
#line 667
  *(tuple->tuple_list + element) = copy;
#line 669
  return (1);
}
}
#line 678 "MaraHash.c"
js_string *mtuple_get(mara_tuple *tuple , int element ) 
{ 

  {
#line 681
  if (element >= tuple->elements) {
#line 682
    return ((js_string *)0);
  } else
#line 681
  if (element < 0) {
#line 682
    return ((js_string *)0);
  }
#line 684
  return (*(tuple->tuple_list + element));
}
}
#line 1 "qual_timestamp.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-8DlZwyFA.i","")
#line 321 "/usr/include/pthread.h"
extern int pthread_mutex_lock(pthread_mutex_t * ) ;
#line 324
extern int pthread_mutex_unlock(pthread_mutex_t * ) ;
#line 33 "qual_timestamp.c"
int64_t the_time  ;
#line 34 "qual_timestamp.c"
int num_tries  =    0;
#line 41 "qual_timestamp.c"
pthread_mutex_t qtime_lock  =    {850045863L, {(char)0}};
#line 47 "qual_timestamp.c"
int64_t qual_get_time(void) 
{ int64_t ttime ;

  {
#line 50
  pthread_mutex_lock(& qtime_lock);
#line 52
  ttime = the_time;
#line 54
  pthread_mutex_unlock(& qtime_lock);
#line 56
  return (ttime);
}
}
#line 64 "qual_timestamp.c"
int qual_set_time(void) 
{ time_t sys_time ;
  int64_t ttime ;

  {
#line 68
  sys_time = time((time_t *)0);
#line 70
  if (sizeof(sys_time) > 4UL) {
#line 71
    if (sys_time == -1L) {
#line 72
      return (-1);
    }
#line 74
    ttime = (int64_t )(sys_time - 290805600L);
  } else
#line 82
  if (sys_time == -1L) {
#line 82
    if (num_tries < 3) {
#line 83
      num_tries ++;
#line 84
      return (1);
    } else {
#line 82
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 86
  if (sys_time == -1L) {
#line 87
    return (-1);
  } else
#line 99
  if (sys_time < 290805600L) {
#line 101
    ttime = (int64_t )(sys_time + 4004161696L);
#line 102
    num_tries = 0;
  } else {
#line 105
    ttime = (int64_t )(sys_time - 290805600L);
#line 106
    num_tries = 0;
  }
#line 110
  pthread_mutex_lock(& qtime_lock);
#line 112
  the_time = ttime;
#line 114
  pthread_mutex_unlock(& qtime_lock);
#line 116
  return (1);
}
}
#line 1 "Queries.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-oAH5mgHU.i","")
#line 56 "functions_dns.h"
int hname_2rfc1035_starwhitis(js_string *hostname , int starwhitis ) ;
#line 64
int email_2rfc1035(js_string *hostname ) ;
#line 68
void init_header(q_header *header ) ;
#line 127
int read_rr_h(js_string *js , q_rr *hdr , int offset ) ;
#line 133
int read_soa(js_string *js , rr_soa *soa , int offset ) ;
#line 148
int email_translate(js_string *hostname ) ;
#line 165
int make_question(q_question *question , js_string *js ) ;
#line 173
int read_question(js_string *js , q_question *question , int offset ) ;
#line 180
int read_ns(js_string *in , js_string *out , int offset ) ;
#line 187
int read_txt(js_string *in , js_string *out , int offset ) ;
#line 201
js_string *squeeze_to_fit(js_string *packet ) ;
#line 33 "Queries.c"
int dlabel_length(js_string *raw , unsigned int offset ) 
{ int length ;
  unsigned char toread ;
  int tmp ;

  {
#line 39
  tmp = js_has_sanity(raw);
#line 39
  if (tmp == -1) {
#line 40
    return (-1);
  }
#line 41
  if (raw->unit_size != 1U) {
#line 42
    return (-1);
  }
#line 44
  length = 0;
#line 45
  if (offset > raw->unit_count) {
#line 46
    return (-1);
  }
#line 47
  toread = *(raw->string + offset);
#line 48
  while (1) {
#line 48
    if (length < 256) {
#line 48
      if ((int )toread > 0) {
#line 48
        if (! ((int )toread != 95)) {
#line 48
          break;
        }
      } else {
#line 48
        break;
      }
    } else {
#line 48
      break;
    }
#line 49
    if ((int )toread >= 192) {
#line 50
      if ((unsigned int )(length + 2) + offset <= raw->unit_count) {
#line 51
        return (length + 2);
      } else {
#line 53
        return (-1);
      }
    }
#line 55
    if ((int )toread > 63) {
#line 56
      return (-1);
    }
#line 57
    length += (int )toread + 1;
#line 59
    if ((unsigned int )length + offset > raw->unit_count) {
#line 60
      return (-1);
    }
#line 61
    toread = *((raw->string + length) + offset);
  }
#line 64
  if ((unsigned int )(length + 1) + offset <= raw->unit_count) {
#line 65
    return (length + 1);
  }
#line 67
  return (-1);
}
}
#line 74 "Queries.c"
void init_header(q_header *header ) 
{ 

  {
#line 75
  header->id = (uint16_t )0;
#line 76
  header->qr = 0;
#line 77
  header->opcode = 0;
#line 78
  header->aa = 0;
#line 79
  header->tc = 0;
#line 80
  header->rd = 0;
#line 81
  header->ra = 0;
#line 82
  header->z = 0;
#line 83
  header->rcode = 0;
#line 84
  header->qdcount = (uint16_t )0;
#line 85
  header->ancount = (uint16_t )0;
#line 86
  header->nscount = (uint16_t )0;
#line 87
  header->arcount = (uint16_t )0;
#line 88
  return;
}
}
#line 96 "Queries.c"
int make_hdr(q_header *header , js_string *js ) 
{ unsigned char *raw ;
  int tmp ;
  unsigned char tmp___0 ;

  {
#line 100
  tmp = js_has_sanity(js);
#line 100
  if (tmp == -1) {
#line 101
    return (-1);
  }
#line 102
  if (js->unit_size != 1U) {
#line 103
    return (-1);
  }
#line 104
  if (js->max_count < 14U) {
#line 105
    return (-1);
  }
#line 108
  raw = js->string;
#line 111
  *(raw + 0) = (unsigned char )(((int )header->id & 65280) >> 8);
#line 112
  *(raw + 1) = (unsigned char )((int )header->id & 255);
#line 114
  tmp___0 = (unsigned char)0;
#line 114
  *(raw + 3) = tmp___0;
#line 114
  *(raw + 2) = tmp___0;
#line 115
  if (header->qr == 1) {
#line 116
    *(raw + 2) = (unsigned char )((int )*(raw + 2) | 128);
  }
#line 117
  *(raw + 2) = (unsigned char )((int )*(raw + 2) | ((header->opcode & 15) << 3));
#line 118
  if (header->aa == 1) {
#line 119
    *(raw + 2) = (unsigned char )((int )*(raw + 2) | 4);
  }
#line 120
  if (header->tc == 1) {
#line 121
    *(raw + 2) = (unsigned char )((int )*(raw + 2) | 2);
  }
#line 122
  if (header->rd == 1) {
#line 123
    *(raw + 2) = (unsigned char )((int )*(raw + 2) | 1);
  }
#line 124
  if (header->ra == 1) {
#line 125
    *(raw + 3) = (unsigned char )((int )*(raw + 3) | 128);
  }
#line 126
  *(raw + 3) = (unsigned char )((int )*(raw + 3) | ((header->z & 7) << 4));
#line 127
  *(raw + 3) = (unsigned char )((int )*(raw + 3) | (header->rcode & 15));
#line 129
  *(raw + 4) = (unsigned char )(((int )header->qdcount & 65280) >> 8);
#line 130
  *(raw + 5) = (unsigned char )((int )header->qdcount & 255);
#line 131
  *(raw + 6) = (unsigned char )(((int )header->ancount & 65280) >> 8);
#line 132
  *(raw + 7) = (unsigned char )((int )header->ancount & 255);
#line 133
  *(raw + 8) = (unsigned char )(((int )header->nscount & 65280) >> 8);
#line 134
  *(raw + 9) = (unsigned char )((int )header->nscount & 255);
#line 135
  *(raw + 10) = (unsigned char )(((int )header->arcount & 65280) >> 8);
#line 136
  *(raw + 11) = (unsigned char )((int )header->arcount & 255);
#line 139
  if (js->max_count >= 12U) {
#line 140
    js->unit_count = 12U;
  }
#line 142
  return (1);
}
}
#line 152 "Queries.c"
int read_hdr(js_string *js , q_header *header ) 
{ unsigned char *raw ;
  int tmp ;

  {
#line 156
  tmp = js_has_sanity(js);
#line 156
  if (tmp == -1) {
#line 157
    return (-1);
  }
#line 158
  if (js->unit_size != 1U) {
#line 159
    return (-1);
  }
#line 160
  if (js->max_count < 14U) {
#line 161
    return (-1);
  }
#line 163
  raw = js->string;
#line 166
  header->id = (uint16_t )(((int )*(raw + 0) << 8) | (int )*(raw + 1));
#line 168
  if ((int )*(raw + 2) & 128) {
#line 169
    header->qr = 1;
  } else {
#line 171
    header->qr = 0;
  }
#line 172
  header->opcode = ((int )*(raw + 2) & 120) >> 3;
#line 173
  if ((int )*(raw + 2) & 4) {
#line 174
    header->aa = 1;
  } else {
#line 176
    header->aa = 0;
  }
#line 177
  if ((int )*(raw + 2) & 2) {
#line 178
    header->tc = 1;
  } else {
#line 180
    header->tc = 0;
  }
#line 181
  if ((int )*(raw + 2) & 1) {
#line 182
    header->rd = 1;
  } else {
#line 184
    header->rd = 0;
  }
#line 185
  if ((int )*(raw + 3) & 128) {
#line 186
    header->ra = 1;
  } else {
#line 188
    header->ra = 0;
  }
#line 189
  header->z = ((int )*(raw + 3) & 112) >> 4;
#line 190
  header->rcode = (int )*(raw + 3) & 15;
#line 192
  header->qdcount = (uint16_t )(((int )*(raw + 4) << 8) | (int )*(raw + 5));
#line 193
  header->ancount = (uint16_t )(((int )*(raw + 6) << 8) | (int )*(raw + 7));
#line 194
  header->nscount = (uint16_t )(((int )*(raw + 8) << 8) | (int )*(raw + 9));
#line 195
  header->arcount = (uint16_t )(((int )*(raw + 10) << 8) | (int )*(raw + 11));
#line 197
  return (1);
}
}
#line 206 "Queries.c"
int make_question(q_question *question , js_string *js ) 
{ int counter ;
  unsigned char toread ;
  unsigned char read___0 ;
  int offset ;
  unsigned char *raw ;
  int tmp ;
  int tmp___0 ;

  {
#line 211
  offset = (int )js->unit_count;
#line 215
  toread = (unsigned char)0;
#line 215
  counter = (int )toread;
#line 218
  tmp = js_has_sanity(js);
#line 218
  if (tmp == -1) {
#line 219
    return (-1);
  }
#line 220
  if (js->unit_size != 1U) {
#line 221
    return (-1);
  }
#line 222
  tmp___0 = js_has_sanity(question->qname);
#line 222
  if (tmp___0 == -1) {
#line 223
    return (-1);
  }
#line 224
  if ((question->qname)->unit_size != 1U) {
#line 225
    return (-1);
  }
#line 226
  if ((unsigned int )offset >= js->max_count) {
#line 227
    return (-1);
  }
#line 229
  raw = (question->qname)->string;
#line 232
  while (counter < 256) {
#line 233
    toread = *(raw + counter);
#line 234
    if ((int )toread > 63) {
#line 235
      return (-1);
    }
#line 236
    read___0 = (unsigned char)0;
#line 237
    if ((int )toread == 0) {
#line 238
      break;
    }
#line 239
    while ((int )read___0 <= (int )toread) {
#line 241
      if ((unsigned int )counter < (question->qname)->max_count) {
#line 241
        if ((unsigned int )(counter + offset) < js->max_count) {
#line 244
          *((js->string + offset) + counter) = *(raw + counter);
        } else {
#line 246
          return (-1);
        }
      } else {
#line 246
        return (-1);
      }
#line 247
      read___0 = (unsigned char )((int )read___0 + 1);
#line 248
      counter ++;
    }
  }
#line 253
  *((js->string + offset) + counter) = (unsigned char)0;
#line 254
  counter ++;
#line 257
  if ((unsigned int )((counter + offset) + 4) < js->max_count) {
#line 258
    raw = (js->string + counter) + offset;
#line 259
    *(raw + 0) = (unsigned char )(((int )question->qtype & 65280) >> 8);
#line 260
    *(raw + 1) = (unsigned char )((int )question->qtype & 255);
#line 261
    *(raw + 2) = (unsigned char )(((int )question->qclass & 65280) >> 8);
#line 262
    *(raw + 3) = (unsigned char )((int )question->qclass & 255);
  } else {
#line 265
    return (-1);
  }
#line 268
  if (js->max_count > (unsigned int )((counter + offset) + 4)) {
#line 269
    js->unit_count = (unsigned int )((counter + offset) + 4);
  }
#line 271
  return (1);
}
}
#line 281 "Queries.c"
int read_question(js_string *js , q_question *question , int offset ) 
{ int counter ;
  unsigned char toread ;
  unsigned char read___0 ;
  unsigned char *raw ;
  int tmp ;
  int tmp___0 ;

  {
#line 288
  toread = (unsigned char)0;
#line 288
  counter = (int )toread;
#line 291
  tmp = js_has_sanity(js);
#line 291
  if (tmp == -1) {
#line 292
    return (-1);
  }
#line 293
  if (js->unit_size != 1U) {
#line 294
    return (-1);
  }
#line 295
  tmp___0 = js_has_sanity(question->qname);
#line 295
  if (tmp___0 == -1) {
#line 296
    return (-1);
  }
#line 297
  if ((question->qname)->unit_size != 1U) {
#line 298
    return (-1);
  }
#line 299
  if ((unsigned int )offset >= js->unit_count) {
#line 300
    return (-1);
  }
#line 302
  raw = js->string + offset;
#line 305
  while (counter < 256) {
#line 306
    toread = *(raw + counter);
#line 307
    if ((int )toread > 63) {
#line 308
      return (-1);
    }
#line 309
    read___0 = (unsigned char)0;
#line 310
    if ((int )toread == 0) {
#line 311
      break;
    }
#line 312
    while ((int )read___0 <= (int )toread) {
#line 314
      if ((unsigned int )counter < (question->qname)->max_count) {
#line 314
        if ((unsigned int )(counter + offset) < js->unit_count) {
#line 317
          *((question->qname)->string + counter) = *(raw + counter);
        } else {
#line 319
          return (-1);
        }
      } else {
#line 319
        return (-1);
      }
#line 320
      read___0 = (unsigned char )((int )read___0 + 1);
#line 321
      counter ++;
    }
  }
#line 327
  *((question->qname)->string + counter) = (unsigned char)0;
#line 328
  counter ++;
#line 331
  if ((unsigned int )((counter + offset) + 4) <= js->unit_count) {
#line 332
    raw = (js->string + counter) + offset;
#line 333
    question->qtype = (uint16_t )((((int )*(raw + 0) << 8) & 65280) | ((int )*(raw + 1) & 255));
#line 334
    question->qclass = (uint16_t )((((int )*(raw + 2) << 8) & 65280) | ((int )*(raw + 3) & 255));
  } else {
#line 337
    return (-1);
  }
#line 340
  if ((unsigned int )counter < (question->qname)->max_count) {
#line 341
    (question->qname)->unit_count = (unsigned int )counter;
  } else {
#line 343
    return (-1);
  }
#line 345
  return (counter + 4);
}
}
#line 356 "Queries.c"
int hname_translate(js_string *hostname , int qtype ) 
{ int counter ;
  int special_root_case ;
  unsigned char toread ;
  unsigned char *raw ;
  int dotseen ;
  int tmp ;

  {
#line 357
  counter = 0;
#line 357
  special_root_case = 0;
#line 358
  toread = (unsigned char)0;
#line 359
  raw = (unsigned char *)0;
#line 360
  dotseen = 0;
#line 363
  tmp = js_has_sanity(hostname);
#line 363
  if (tmp == -1) {
#line 364
    return (-1);
  }
#line 365
  if (hostname->unit_size != 1U) {
#line 366
    return (-1);
  }
#line 367
  if (hostname->unit_count < 1U) {
#line 368
    return (-1);
  }
#line 371
  toread = *(hostname->string);
#line 374
  if (hostname->unit_count == 1U) {
#line 374
    if ((int )toread == 0) {
#line 375
      special_root_case = 1;
    }
  }
#line 378
  raw = hostname->string;
#line 379
  switch (qtype) {
  case 1: 
#line 381
  *raw = (unsigned char )'A';
#line 382
  break;
  case 2: 
#line 384
  *raw = (unsigned char )'N';
#line 385
  break;
  case 5: 
#line 387
  *raw = (unsigned char )'C';
#line 388
  break;
  case 6: 
#line 390
  *raw = (unsigned char )'S';
#line 391
  break;
  case 12: 
#line 393
  *raw = (unsigned char )'P';
#line 394
  break;
  case 15: 
#line 396
  *raw = (unsigned char )'@';
#line 397
  break;
  case 16: 
#line 399
  *raw = (unsigned char )'T';
#line 400
  break;
  case 255: 
#line 402
  *raw = (unsigned char )'Z';
#line 403
  break;
  case -2: 
#line 405
  *raw = (unsigned char )'|';
#line 406
  break;
  case -300: 
  case -301: 
#line 410
  *raw = (unsigned char )' ';
#line 411
  break;
  default: 
#line 413
  *raw = (unsigned char )'U';
  }
#line 418
  if (special_root_case == 1) {
#line 419
    if (hostname->max_count < 2U) {
#line 420
      return (-1);
    }
#line 421
    hostname->unit_count = 2U;
#line 422
    raw ++;
#line 423
    *raw = (unsigned char )'.';
#line 424
    return (1);
  }
#line 428
  counter = 0;
#line 429
  dotseen = 0;
#line 430
  while (1) {
#line 430
    if (counter < 256) {
#line 430
      if (! ((int )toread > 0)) {
#line 430
        break;
      }
    } else {
#line 430
      break;
    }
#line 431
    if ((int )toread > 63) {
#line 432
      return (-1);
    }
#line 433
    counter += (int )toread + 1;
#line 435
    if ((unsigned int )counter > hostname->unit_count) {
#line 436
      return (-1);
    }
#line 437
    toread = *(raw + counter);
#line 439
    if ((unsigned int )counter <= hostname->unit_count) {
#line 440
      if (qtype != -301) {
#line 441
        *(raw + counter) = (unsigned char )'.';
      } else
#line 440
      if (dotseen > 0) {
#line 441
        *(raw + counter) = (unsigned char )'.';
      } else {
#line 443
        *(raw + counter) = (unsigned char )'@';
#line 444
        dotseen = 1;
      }
    } else {
#line 447
      return (-1);
    }
  }
#line 451
  return (1);
}
}
#line 460 "Queries.c"
int email_translate(js_string *hostname ) 
{ int counter ;
  unsigned char toread ;
  int first ;
  unsigned char *raw ;
  int tmp ;

  {
#line 463
  first = 1;
#line 467
  tmp = js_has_sanity(hostname);
#line 467
  if (tmp == -1) {
#line 468
    return (-1);
  }
#line 469
  if (hostname->unit_size != 1U) {
#line 470
    return (-1);
  }
#line 471
  if (hostname->unit_count < 1U) {
#line 472
    return (-1);
  }
#line 475
  toread = *(hostname->string);
#line 478
  raw = hostname->string;
#line 479
  *raw = (unsigned char )'|';
#line 482
  counter = 0;
#line 483
  while (1) {
#line 483
    if (counter < 256) {
#line 483
      if (! ((int )toread > 0)) {
#line 483
        break;
      }
    } else {
#line 483
      break;
    }
#line 484
    if ((int )toread > 63) {
#line 485
      return (-1);
    }
#line 486
    counter += (int )toread + 1;
#line 488
    if ((unsigned int )counter > hostname->unit_count) {
#line 489
      return (-1);
    }
#line 490
    toread = *(raw + counter);
#line 492
    if ((unsigned int )counter <= hostname->unit_count) {
#line 493
      if (first) {
#line 494
        *(raw + counter) = (unsigned char )'@';
#line 495
        first = 0;
      } else {
#line 498
        *(raw + counter) = (unsigned char )'.';
      }
    } else {
#line 502
      return (-1);
    }
  }
#line 505
  return (1);
}
}
#line 516 "Queries.c"
int hname_2rfc1035(js_string *hostname ) 
{ int tmp ;

  {
#line 517
  tmp = hname_2rfc1035_starwhitis(hostname, 0);
#line 517
  return (tmp);
}
}
#line 523 "Queries.c"
int hname_2rfc1035_starwhitis(js_string *hostname , int starwhitis ) 
{ int counter ;
  int seen ;
  unsigned char *raw ;
  unsigned char *towrite ;
  int ret ;
  int tmp ;

  {
#line 526
  ret = -2;
#line 529
  tmp = js_has_sanity(hostname);
#line 529
  if (tmp == -1) {
#line 530
    return (-1);
  }
#line 531
  if (hostname->unit_size != 1U) {
#line 532
    return (-1);
  }
#line 533
  if (hostname->unit_count < 1U) {
#line 534
    return (-1);
  }
#line 537
  towrite = hostname->string;
#line 537
  raw = towrite;
#line 540
  switch ((int )*raw) {
  case 65: 
#line 542
  ret = 1;
#line 543
  break;
  case 78: 
#line 545
  ret = 2;
#line 546
  break;
  case 67: 
#line 548
  ret = 5;
#line 549
  break;
  case 83: 
#line 551
  ret = 6;
#line 552
  break;
  case 80: 
#line 554
  ret = 12;
#line 555
  break;
  case 64: 
#line 557
  ret = 15;
#line 558
  break;
  case 84: 
#line 560
  ret = 16;
#line 561
  break;
  case 85: 
#line 563
  ret = -3;
#line 564
  break;
  case 90: 
#line 566
  ret = 255;
#line 567
  break;
  default: 
#line 569
  return (-2);
  }
#line 573
  if ((int )*(raw + 1) == 46) {
#line 573
    if (hostname->unit_count == 2U) {
#line 574
      *raw = (unsigned char)0;
#line 575
      hostname->unit_count = 1U;
#line 576
      return (ret);
    }
  }
#line 580
  if ((int )*(raw + 1) == 42) {
#line 580
    if (hostname->unit_count == 2U) {
#line 580
      if (starwhitis == 1) {
#line 582
        *raw = (unsigned char )'_';
#line 583
        hostname->unit_count = 1U;
#line 584
        return (ret);
      }
    }
  }
#line 588
  counter = 0;
#line 588
  seen = counter;
#line 589
  while (1) {
#line 589
    if (counter < 256) {
#line 589
      if (! ((unsigned int )counter < hostname->unit_count)) {
#line 589
        break;
      }
    } else {
#line 589
      break;
    }
#line 590
    counter ++;
#line 591
    if ((unsigned int )counter > hostname->unit_count) {
#line 592
      return (-1);
    }
#line 593
    if ((int )*(raw + counter) == 46) {
#line 594
      if (seen < 1) {
#line 595
        return (-1);
      } else
#line 594
      if (seen > 63) {
#line 595
        return (-1);
      }
#line 596
      *towrite = (unsigned char )seen;
#line 597
      towrite = raw + counter;
#line 598
      seen = 0;
    } else {
#line 601
      seen ++;
    }
#line 602
    if ((unsigned int )counter == hostname->unit_count - 1U) {
#line 603
      break;
    }
  }
#line 607
  if (counter < 256) {
#line 607
    if ((int )*(raw + counter) == 46) {
#line 608
      *(raw + counter) = (unsigned char)0;
    } else {
#line 607
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 610
  if (counter < 256) {
#line 610
    if (counter > 1) {
#line 610
      if ((int )*(raw + counter) == 42) {
#line 610
        if (hostname->unit_count > 1U) {
#line 610
          if (starwhitis == 1) {
#line 612
            *((raw + counter) - 1) = (unsigned char )'_';
#line 613
            (hostname->unit_count) --;
          } else {
#line 616
            return (-1);
          }
        } else {
#line 616
          return (-1);
        }
      } else {
#line 616
        return (-1);
      }
    } else {
#line 616
      return (-1);
    }
  } else {
#line 616
    return (-1);
  }
#line 619
  return (ret);
}
}
#line 629 "Queries.c"
int email_2rfc1035(js_string *hostname ) 
{ int counter ;
  int seen ;
  unsigned char *raw ;
  unsigned char *towrite ;
  int firstat ;
  int tmp ;
  int tmp___0 ;

  {
#line 633
  firstat = 1;
#line 636
  tmp = js_has_sanity(hostname);
#line 636
  if (tmp == -1) {
#line 637
    return (-1);
  }
#line 638
  if (hostname->unit_size != 1U) {
#line 639
    return (-1);
  }
#line 640
  if (hostname->unit_count < 1U) {
#line 641
    return (-1);
  }
#line 644
  towrite = hostname->string;
#line 644
  raw = towrite;
#line 647
  counter = 0;
#line 647
  seen = counter;
#line 649
  if (hostname->unit_count == 2U) {
#line 649
    if ((int )*(raw + 1) == 46) {
#line 650
      hostname->unit_count = 1U;
#line 651
      *(hostname->string) = (unsigned char )'\000';
#line 652
      return (1);
    }
  }
#line 655
  while (1) {
#line 655
    if (counter < 256) {
#line 655
      if (! ((unsigned int )counter < hostname->unit_count)) {
#line 655
        break;
      }
    } else {
#line 655
      break;
    }
#line 656
    counter ++;
#line 657
    if ((unsigned int )counter > hostname->unit_count) {
#line 658
      return (-1);
    }
#line 659
    if (! firstat) {
#line 659
      if ((int )*(raw + counter) == 46) {
#line 659
        goto _L;
      } else {
#line 659
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 659
    if (firstat) {
#line 659
      if ((int )*(raw + counter) == 64) {
        _L: /* CIL Label */ 
#line 661
        firstat = 0;
#line 662
        if (seen < 1) {
#line 663
          return (-1);
        } else
#line 662
        if (seen > 63) {
#line 663
          return (-1);
        }
#line 664
        *towrite = (unsigned char )seen;
#line 665
        towrite = raw + counter;
#line 666
        seen = 0;
      } else {
#line 669
        seen ++;
      }
    } else {
#line 669
      seen ++;
    }
#line 670
    if ((unsigned int )counter == hostname->unit_count - 1U) {
#line 671
      break;
    }
  }
#line 676
  if (firstat) {
#line 677
    tmp___0 = hname_2rfc1035_starwhitis(hostname, 0);
#line 677
    return (tmp___0);
  }
#line 681
  if (counter < 256) {
#line 681
    if ((int )*(raw + counter) == 46) {
#line 682
      *(raw + counter) = (unsigned char)0;
    } else {
#line 684
      return (-1);
    }
  } else {
#line 684
    return (-1);
  }
#line 686
  return (1);
}
}
#line 697 "Queries.c"
int read_rr_h(js_string *js , q_rr *hdr , int offset ) 
{ int counter ;
  unsigned char toread ;
  unsigned char read___0 ;
  unsigned char *raw ;
  int tmp ;
  int tmp___0 ;

  {
#line 703
  toread = (unsigned char)0;
#line 703
  counter = (int )toread;
#line 706
  tmp = js_has_sanity(js);
#line 706
  if (tmp == -1) {
#line 707
    return (-1);
  }
#line 708
  if (js->unit_size != 1U) {
#line 709
    return (-1);
  }
#line 710
  tmp___0 = js_has_sanity(hdr->name);
#line 710
  if (tmp___0 == -1) {
#line 711
    return (-1);
  }
#line 712
  if ((hdr->name)->unit_size != 1U) {
#line 713
    return (-1);
  }
#line 714
  if ((unsigned int )offset >= js->max_count) {
#line 715
    return (-1);
  }
#line 717
  raw = js->string + offset;
#line 720
  while (counter < 256) {
#line 721
    if ((unsigned int )(offset + counter) > js->unit_count) {
#line 722
      return (-1);
    }
#line 723
    toread = *(raw + counter);
#line 724
    if ((int )toread > 63) {
#line 725
      return (-1);
    }
#line 726
    read___0 = (unsigned char)0;
#line 727
    if ((int )toread == 0) {
#line 728
      break;
    }
#line 729
    while ((int )read___0 <= (int )toread) {
#line 731
      if ((unsigned int )counter < (hdr->name)->max_count) {
#line 731
        if ((unsigned int )(counter + offset) < js->unit_count) {
#line 734
          *((hdr->name)->string + counter) = *(raw + counter);
        } else {
#line 736
          return (-1);
        }
      } else {
#line 736
        return (-1);
      }
#line 737
      read___0 = (unsigned char )((int )read___0 + 1);
#line 738
      counter ++;
    }
  }
#line 744
  *((hdr->name)->string + counter) = *(raw + counter);
#line 746
  counter ++;
#line 749
  if ((unsigned int )((counter + offset) + 10) <= js->unit_count) {
#line 750
    raw = (js->string + counter) + offset;
#line 751
    hdr->type = (uint16_t )(((int )*(raw + 0) << 8) | (int )*(raw + 1));
#line 752
    hdr->class = (uint16_t )(((int )*(raw + 2) << 8) | (int )*(raw + 3));
#line 753
    hdr->ttl = (uint32_t )(((((int )*(raw + 4) << 24) | ((int )*(raw + 5) << 16)) | ((int )*(raw + 6) << 8)) | (int )*(raw + 7));
#line 754
    hdr->rdlength = (uint16_t )(((int )*(raw + 8) << 8) | (int )*(raw + 9));
  } else {
#line 757
    return (-1);
  }
#line 759
  if ((unsigned int )counter < (hdr->name)->max_count) {
#line 760
    (hdr->name)->unit_count = (unsigned int )counter;
  } else {
#line 762
    return (-1);
  }
#line 764
  return (counter + 10);
}
}
#line 773 "Queries.c"
int read_soa(js_string *js , rr_soa *soa , int offset ) 
{ int counter ;
  unsigned char read___0 ;
  unsigned char toread ;
  unsigned char *raw ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 780
  tmp = js_has_sanity(js);
#line 780
  if (tmp == -1) {
#line 781
    return (-1);
  }
#line 782
  tmp___0 = js_has_sanity(soa->mname);
#line 782
  if (tmp___0 == -1) {
#line 783
    return (-1);
  }
#line 784
  tmp___1 = js_has_sanity(soa->rname);
#line 784
  if (tmp___1 == -1) {
#line 785
    return (-1);
  }
#line 786
  if (js->unit_size != 1U) {
#line 787
    return (-1);
  }
#line 788
  if ((soa->mname)->unit_size != 1U) {
#line 789
    return (-1);
  }
#line 790
  if ((soa->rname)->unit_size != 1U) {
#line 791
    return (-1);
  }
#line 792
  if (js->unit_count < (unsigned int )offset) {
#line 793
    return (-1);
  }
#line 795
  raw = js->string + offset;
#line 798
  counter = 0;
#line 799
  while (counter < 256) {
#line 800
    toread = *(raw + counter);
#line 801
    if ((int )toread > 63) {
#line 802
      return (-1);
    }
#line 803
    read___0 = (unsigned char)0;
#line 804
    if ((int )toread == 0) {
#line 805
      break;
    }
#line 806
    while ((int )read___0 <= (int )toread) {
#line 808
      if ((unsigned int )counter < (soa->mname)->max_count) {
#line 808
        if ((unsigned int )(counter + offset) < js->unit_count) {
#line 811
          *((soa->mname)->string + counter) = *(raw + counter);
        } else {
#line 813
          return (-1);
        }
      } else {
#line 813
        return (-1);
      }
#line 814
      read___0 = (unsigned char )((int )read___0 + 1);
#line 815
      counter ++;
    }
  }
#line 820
  *((soa->mname)->string + counter) = (unsigned char)0;
#line 821
  counter ++;
#line 822
  offset += counter;
#line 823
  if ((soa->mname)->max_count < (unsigned int )counter) {
#line 824
    return (-1);
  }
#line 825
  (soa->mname)->unit_count = (unsigned int )counter;
#line 827
  raw = js->string + offset;
#line 830
  counter = 0;
#line 831
  while (counter < 256) {
#line 832
    toread = *(raw + counter);
#line 833
    if ((int )toread > 63) {
#line 834
      return (-1);
    }
#line 835
    read___0 = (unsigned char)0;
#line 836
    if ((int )toread == 0) {
#line 837
      break;
    }
#line 838
    while ((int )read___0 <= (int )toread) {
#line 840
      if ((unsigned int )counter < (soa->rname)->max_count) {
#line 840
        if ((unsigned int )(counter + offset) < js->unit_count) {
#line 843
          *((soa->rname)->string + counter) = *(raw + counter);
        } else {
#line 845
          return (-1);
        }
      } else {
#line 845
        return (-1);
      }
#line 846
      read___0 = (unsigned char )((int )read___0 + 1);
#line 847
      counter ++;
    }
  }
#line 852
  *((soa->rname)->string + counter) = (unsigned char)0;
#line 853
  counter ++;
#line 854
  if ((soa->rname)->max_count < (unsigned int )counter) {
#line 855
    return (-1);
  }
#line 856
  (soa->rname)->unit_count = (unsigned int )counter;
#line 858
  if ((unsigned int )((counter + offset) + 20) > js->unit_count) {
#line 859
    return (-1);
  }
#line 861
  raw = (js->string + counter) + offset;
#line 862
  soa->serial = (uint32_t )(((((int )*(raw + 0) << 24) | ((int )*(raw + 1) << 16)) | ((int )*(raw + 2) << 8)) | (int )*(raw + 3));
#line 863
  soa->refresh = ((((int )*(raw + 4) << 24) | ((int )*(raw + 5) << 16)) | ((int )*(raw + 6) << 8)) | (int )*(raw + 7);
#line 864
  soa->retry = ((((int )*(raw + 8) << 24) | ((int )*(raw + 9) << 16)) | ((int )*(raw + 10) << 8)) | (int )*(raw + 11);
#line 865
  soa->expire = ((((int )*(raw + 12) << 24) | ((int )*(raw + 13) << 16)) | ((int )*(raw + 14) << 8)) | (int )*(raw + 15);
#line 866
  soa->minimum = (uint32_t )(((((int )*(raw + 16) << 24) | ((int )*(raw + 17) << 16)) | ((int )*(raw + 18) << 8)) | (int )*(raw + 19));
#line 869
  return (counter + 20);
}
}
#line 879 "Queries.c"
int read_ns(js_string *in , js_string *out , int offset ) 
{ uint16_t toread ;
  uint16_t read___0 ;
  int counter ;
  unsigned char *raw ;
  int tmp ;
  int tmp___0 ;

  {
#line 885
  tmp = js_has_sanity(in);
#line 885
  if (tmp == -1) {
#line 886
    return (-1);
  }
#line 887
  tmp___0 = js_has_sanity(out);
#line 887
  if (tmp___0 == -1) {
#line 888
    return (-1);
  }
#line 889
  if (in->unit_size != 1U) {
#line 890
    return (-1);
  }
#line 891
  if (out->unit_size != 1U) {
#line 892
    return (-1);
  }
#line 893
  if (in->unit_count < (unsigned int )offset) {
#line 894
    return (-1);
  }
#line 896
  raw = in->string + offset;
#line 898
  counter = 0;
#line 899
  while (counter < 256) {
#line 900
    toread = (uint16_t )*(raw + counter);
#line 901
    if ((int )toread > 63) {
#line 902
      return (-1);
    }
#line 903
    read___0 = (uint16_t )0;
#line 904
    if ((int )toread == 0) {
#line 905
      break;
    }
#line 906
    while ((int )read___0 <= (int )toread) {
#line 908
      if ((unsigned int )counter < out->max_count) {
#line 908
        if ((unsigned int )(counter + offset) < in->unit_count) {
#line 911
          *(out->string + counter) = *(raw + counter);
        } else {
#line 913
          return (-1);
        }
      } else {
#line 913
        return (-1);
      }
#line 914
      read___0 = (uint16_t )((int )read___0 + 1);
#line 915
      counter ++;
    }
  }
#line 920
  *(out->string + counter) = (unsigned char)0;
#line 921
  counter ++;
#line 922
  offset += counter;
#line 923
  if (out->max_count < (unsigned int )counter) {
#line 924
    return (-1);
  }
#line 925
  out->unit_count = (unsigned int )counter;
#line 927
  return (counter);
}
}
#line 936 "Queries.c"
int read_txt(js_string *in , js_string *out , int offset ) 
{ int counter ;
  unsigned char toread ;
  int tmp ;
  int tmp___0 ;

  {
#line 940
  counter = 0;
#line 943
  tmp = js_has_sanity(in);
#line 943
  if (tmp == -1) {
#line 944
    return (-1);
  }
#line 945
  tmp___0 = js_has_sanity(out);
#line 945
  if (tmp___0 == -1) {
#line 946
    return (-1);
  }
#line 947
  if (in->unit_size != 1U) {
#line 948
    return (-1);
  }
#line 949
  if (out->unit_size != 1U) {
#line 950
    return (-1);
  }
#line 951
  if (in->unit_count < (unsigned int )offset) {
#line 952
    return (-1);
  }
#line 955
  toread = *(in->string + offset);
#line 958
  if ((unsigned int )toread >= out->max_count) {
#line 959
    return (-1);
  } else
#line 958
  if ((unsigned int )(offset + (int )toread) >= in->unit_count) {
#line 959
    return (-1);
  }
#line 962
  offset ++;
#line 963
  counter = 0;
#line 963
  while (counter < (int )toread) {
#line 964
    *(out->string + counter) = *((in->string + offset) + counter);
#line 963
    counter ++;
  }
#line 966
  out->unit_count = (unsigned int )toread;
#line 967
  return ((int )out->unit_count);
}
}
#line 982 "Queries.c"
js_string *squeeze_to_fit(js_string *packet ) 
{ q_header hdr ;
  int qd ;
  int an ;
  int ns ;
  int ar ;
  int qc ;
  int count ;
  int offset ;
  int tmp ;
  int len ;
  int len___0 ;

  {
#line 988
  tmp = read_hdr(packet, & hdr);
#line 988
  if (tmp == -1) {
#line 989
    return ((js_string *)0);
  }
#line 992
  qd = (int )hdr.qdcount;
#line 993
  an = (int )hdr.ancount;
#line 994
  ns = (int )hdr.nscount;
#line 995
  ar = (int )hdr.arcount;
#line 1002
  if (hdr.tc == 1) {
#line 1002
    goto _L;
  } else
#line 1002
  if (ns == 0) {
#line 1002
    if (ar == 0) {
      _L: /* CIL Label */ 
#line 1003
      hdr.tc = 1;
#line 1004
      hdr.arcount = (uint16_t )0;
#line 1004
      hdr.nscount = hdr.arcount;
#line 1004
      hdr.ancount = hdr.nscount;
#line 1004
      hdr.qdcount = hdr.ancount;
#line 1005
      make_hdr(& hdr, packet);
#line 1006
      return (packet);
    }
  }
#line 1009
  qc = qd;
#line 1010
  count = (an + ns) + ar;
#line 1011
  offset = 12;
#line 1013
  while (qc > 0) {
#line 1015
    len = dlabel_length(packet, (unsigned int )offset);
#line 1016
    if (len == -1) {
#line 1017
      hdr.tc = 1;
#line 1018
      hdr.arcount = (uint16_t )0;
#line 1018
      hdr.nscount = hdr.arcount;
#line 1018
      hdr.ancount = hdr.nscount;
#line 1018
      hdr.qdcount = hdr.ancount;
#line 1020
      make_hdr(& hdr, packet);
#line 1021
      return (packet);
    }
#line 1023
    len += 4;
#line 1024
    offset += len;
#line 1025
    if ((unsigned int )offset >= packet->unit_count) {
#line 1026
      hdr.tc = 1;
#line 1027
      hdr.arcount = (uint16_t )0;
#line 1027
      hdr.nscount = hdr.arcount;
#line 1027
      hdr.ancount = hdr.nscount;
#line 1027
      hdr.qdcount = hdr.ancount;
#line 1029
      make_hdr(& hdr, packet);
#line 1030
      return (packet);
    }
#line 1032
    qc --;
  }
#line 1036
  while (count > 1) {
#line 1038
    len___0 = dlabel_length(packet, (unsigned int )offset);
#line 1039
    if (len___0 == -1) {
#line 1040
      hdr.tc = 1;
#line 1041
      hdr.arcount = (uint16_t )0;
#line 1041
      hdr.nscount = hdr.arcount;
#line 1041
      hdr.ancount = hdr.nscount;
#line 1041
      hdr.qdcount = hdr.ancount;
#line 1043
      make_hdr(& hdr, packet);
#line 1044
      return (packet);
    }
#line 1046
    len___0 += 8;
#line 1047
    offset += len___0;
#line 1048
    if ((unsigned int )(offset + 2) >= packet->unit_count) {
#line 1049
      hdr.tc = 1;
#line 1050
      hdr.arcount = (uint16_t )0;
#line 1050
      hdr.nscount = hdr.arcount;
#line 1050
      hdr.ancount = hdr.nscount;
#line 1050
      hdr.qdcount = hdr.ancount;
#line 1052
      make_hdr(& hdr, packet);
#line 1053
      return (packet);
    }
#line 1057
    len___0 = (((int )*(packet->string + offset) & 255) << 8) + (int )*((packet->string + offset) + 1);
#line 1059
    offset += len___0 + 2;
#line 1060
    if ((unsigned int )offset >= packet->unit_count) {
#line 1061
      hdr.tc = 1;
#line 1062
      hdr.arcount = (uint16_t )0;
#line 1062
      hdr.nscount = hdr.arcount;
#line 1062
      hdr.ancount = hdr.nscount;
#line 1062
      hdr.qdcount = hdr.ancount;
#line 1064
      make_hdr(& hdr, packet);
#line 1065
      return (packet);
    }
#line 1067
    count --;
  }
#line 1072
  if (ar > 0) {
#line 1073
    ar --;
#line 1074
    hdr.arcount = (uint16_t )ar;
  } else
#line 1075
  if (ns > 0) {
#line 1076
    ns --;
#line 1077
    hdr.nscount = (uint16_t )ns;
  } else {
#line 1079
    hdr.tc = 1;
#line 1080
    hdr.arcount = (uint16_t )0;
#line 1080
    hdr.nscount = hdr.arcount;
#line 1080
    hdr.ancount = hdr.nscount;
#line 1080
    hdr.qdcount = hdr.ancount;
#line 1081
    make_hdr(& hdr, packet);
#line 1082
    return (packet);
  }
#line 1085
  hdr.tc = 0;
#line 1086
  make_hdr(& hdr, packet);
#line 1087
  packet->unit_count = (unsigned int )offset;
#line 1088
  return (packet);
}
}
#line 1 "Compress.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-gmCdH9BA.i","")
#line 43 "functions_dns.h"
int compress_data(js_string *in , js_string *out ) ;
#line 37 "Compress.c"
js_string *decomp_get_label(js_string *compressed , unsigned int compressed_offset ) ;
#line 39
rrdesc **decomp_export_rrformats(void) ;
#line 40
char *decomp_get_rrdesc(int rr_num ) ;
#line 64 "Compress.c"
compress_state *compress_init_state(js_string *uncompressed ) 
{ compress_state *new ;
  int tmp ;
  void *tmp___0 ;
  js_string *tmp___1 ;
  int *tmp___2 ;
  void *tmp___3 ;

  {
#line 68
  tmp = js_has_sanity(uncompressed);
#line 68
  if (tmp != 1) {
#line 69
    return ((compress_state *)0);
  }
#line 72
  tmp___0 = js_alloc(1, (int )sizeof(compress_state ));
#line 72
  new = (compress_state *)tmp___0;
#line 72
  if ((unsigned long )new == (unsigned long )((compress_state *)0)) {
#line 73
    return ((compress_state *)0);
  }
#line 76
  new->uncompressed_offset = 0U;
#line 77
  new->this_dlabel_begin = 0U;
#line 78
  new->this_rdlength_begin = 0U;
#line 79
  new->this_rr_type = 0;
#line 80
  new->current_rdlength = 0;
#line 81
  new->valid_state = 1;
#line 82
  new->number_answers = 0;
#line 83
  new->uncompressed = uncompressed;
#line 86
  tmp___1 = js_create(516U, 1U);
#line 86
  new->compressed = tmp___1;
#line 86
  if ((unsigned long )tmp___1 == (unsigned long )((js_string *)0)) {
#line 87
    js_dealloc((void *)new);
#line 88
    return ((compress_state *)0);
  }
#line 90
  tmp___3 = js_alloc(163, (int )sizeof(int ));
#line 90
  tmp___2 = (int *)tmp___3;
#line 90
  new->dlabel_points = tmp___2;
#line 90
  if ((unsigned long )tmp___2 == (unsigned long )((int *)0)) {
#line 92
    js_destroy(new->compressed);
#line 93
    js_dealloc((void *)new);
#line 94
    return ((compress_state *)0);
  }
#line 96
  *(new->dlabel_points + 0) = 0;
#line 99
  return (new);
}
}
#line 110 "Compress.c"
js_string *compress_get_dlabel(js_string *packet , int offset ) 
{ js_string *tmp ;

  {
#line 111
  tmp = decomp_get_label(packet, (unsigned int )offset);
#line 111
  return (tmp);
}
}
#line 122 "Compress.c"
int compress_compare_dlabels(js_string *packet1 , js_string *packet2 , int offset1 ,
                             int offset2 ) 
{ js_string *a ;
  js_string *b ;
  int ret ;

  {
#line 127
  a = compress_get_dlabel(packet1, offset1);
#line 128
  if ((unsigned long )a == (unsigned long )((js_string *)0)) {
#line 129
    return (-1);
  }
#line 130
  b = compress_get_dlabel(packet2, offset2);
#line 131
  if ((unsigned long )b == (unsigned long )((js_string *)0)) {
#line 132
    js_destroy(a);
#line 133
    return (-1);
  }
#line 135
  ret = js_issame(a, b);
#line 136
  js_destroy(a);
#line 137
  js_destroy(b);
#line 138
  return (ret);
}
}
#line 157 "Compress.c"
int compress_add_dlabel_points(compress_state *state , int offset ) 
{ int counter ;
  int limit ;
  unsigned int len ;

  {
#line 161
  if ((unsigned long )state == (unsigned long )((compress_state *)0)) {
#line 162
    return (-1);
  }
#line 163
  if (state->valid_state != 1) {
#line 164
    return (-1);
  }
#line 167
  counter = 0;
#line 168
  while (1) {
#line 168
    if (*(state->dlabel_points + counter) != 0) {
#line 168
      if (! (counter < 150)) {
#line 168
        break;
      }
    } else {
#line 168
      break;
    }
#line 170
    counter ++;
  }
#line 174
  limit = 0;
#line 175
  while (limit < 257) {
#line 179
    if ((unsigned int )offset >= (state->compressed)->unit_count) {
#line 180
      state->valid_state = 0;
#line 181
      return (-1);
    }
#line 185
    len = (unsigned int )*((state->compressed)->string + offset);
#line 186
    if (len >= 192U) {
#line 187
      break;
    }
#line 190
    if ((unsigned int )offset + len >= (state->compressed)->unit_count) {
#line 191
      state->valid_state = 0;
#line 192
      return (-1);
    }
#line 194
    if (counter >= 150) {
#line 195
      state->valid_state = 0;
#line 196
      return (-1);
    }
#line 200
    *(state->dlabel_points + counter) = offset;
#line 201
    *(state->dlabel_points + (counter + 1)) = 0;
#line 202
    counter ++;
#line 203
    if (len == 0U) {
#line 204
      break;
    } else
#line 203
    if (len > 63U) {
#line 204
      break;
    }
#line 206
    offset = (int )((unsigned int )offset + len);
#line 207
    offset ++;
#line 210
    limit ++;
  }
#line 214
  if (limit >= 257) {
#line 215
    state->valid_state = 0;
#line 216
    return (-1);
  }
#line 219
  return (1);
}
}
#line 236 "Compress.c"
int compress_sub_dlabel(compress_state *state ) 
{ unsigned int len ;
  unsigned int counter ;
  int tmp ;
  uint16_t compress_pointer ;
  int length ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 241
  if ((unsigned long )state == (unsigned long )((compress_state *)0)) {
#line 242
    return (-1);
  }
#line 244
  if (state->valid_state != 1) {
#line 245
    return (-1);
  }
#line 247
  if (state->uncompressed_offset >= (state->uncompressed)->unit_count) {
#line 248
    state->valid_state = 0;
#line 249
    return (-1);
  }
#line 253
  len = (unsigned int )*((state->uncompressed)->string + state->uncompressed_offset);
#line 254
  if (len == 0U) {
#line 256
    tmp = js_substr_append(state->uncompressed, state->compressed, (int )state->uncompressed_offset,
                           1);
#line 256
    if (tmp != 1) {
#line 258
      state->valid_state = 0;
#line 259
      return (-1);
    }
#line 261
    if (state->uncompressed_offset + 1U > (state->uncompressed)->unit_count) {
#line 264
      state->valid_state = 0;
#line 265
      return (-1);
    } else
#line 261
    if (state->uncompressed_offset + 1U >= (state->uncompressed)->max_count) {
#line 264
      state->valid_state = 0;
#line 265
      return (-1);
    }
#line 267
    if (state->uncompressed_offset == (state->uncompressed)->unit_count) {
#line 268
      return (3);
    }
#line 270
    (state->uncompressed_offset) ++;
#line 271
    return (0);
  }
#line 273
  if (len > 63U) {
#line 274
    state->valid_state = 0;
#line 275
    return (-1);
  } else
#line 273
  if (len < 0U) {
#line 274
    state->valid_state = 0;
#line 275
    return (-1);
  }
#line 277
  if ((state->uncompressed_offset + len) + 1U >= (state->uncompressed)->unit_count) {
#line 280
    state->valid_state = 0;
#line 281
    return (-1);
  } else
#line 277
  if ((state->uncompressed_offset + len) + 1U >= (state->uncompressed)->max_count) {
#line 280
    state->valid_state = 0;
#line 281
    return (-1);
  }
#line 286
  counter = 0U;
#line 287
  while (counter < 155U) {
#line 290
    if (*(state->dlabel_points + counter) == 0) {
#line 291
      break;
    }
#line 295
    if ((unsigned int )*(state->dlabel_points + counter) >= state->this_dlabel_begin) {
#line 296
      break;
    }
#line 300
    tmp___1 = compress_compare_dlabels(state->uncompressed, state->compressed, (int )state->uncompressed_offset,
                                       *(state->dlabel_points + counter));
#line 300
    if (tmp___1 == 1) {
#line 305
      if (*(state->dlabel_points + counter) < 12) {
#line 307
        state->valid_state = 0;
#line 308
        return (-1);
      } else
#line 305
      if (*(state->dlabel_points + counter) >= 16384) {
#line 307
        state->valid_state = 0;
#line 308
        return (-1);
      }
#line 310
      compress_pointer = (uint16_t )*(state->dlabel_points + counter);
#line 311
      compress_pointer = (uint16_t )((int )compress_pointer | 49152);
#line 312
      tmp___0 = js_adduint16(state->compressed, (int )compress_pointer);
#line 312
      if (tmp___0 != 1) {
#line 313
        state->valid_state = 0;
#line 314
        return (-1);
      }
#line 318
      length = dlabel_length(state->uncompressed, state->uncompressed_offset);
#line 320
      if (length == -1) {
#line 321
        state->valid_state = 0;
#line 322
        return (-1);
      }
#line 324
      if (state->uncompressed_offset + (unsigned int )length > (state->uncompressed)->unit_count) {
#line 328
        state->valid_state = 0;
#line 329
        return (-1);
      } else
#line 324
      if (state->uncompressed_offset + (unsigned int )length >= (state->uncompressed)->max_count) {
#line 328
        state->valid_state = 0;
#line 329
        return (-1);
      }
#line 331
      state->uncompressed_offset += (unsigned int )length;
#line 332
      if (state->uncompressed_offset == (state->uncompressed)->unit_count) {
#line 333
        return (3);
      }
#line 335
      return (2);
    }
#line 337
    counter ++;
  }
#line 341
  if (counter >= 155U) {
#line 342
    state->valid_state = 0;
#line 343
    return (-1);
  }
#line 347
  tmp___2 = js_substr_append(state->uncompressed, state->compressed, (int )state->uncompressed_offset,
                             (int )(len + 1U));
#line 347
  if (tmp___2 != 1) {
#line 349
    state->valid_state = 0;
#line 350
    return (-1);
  }
#line 352
  state->uncompressed_offset += len;
#line 353
  (state->uncompressed_offset) ++;
#line 354
  return (1);
}
}
#line 370 "Compress.c"
int compress_dlabel(compress_state *state ) 
{ int offset ;
  int ret ;
  int tmp ;

  {
#line 374
  if (state->valid_state != 1) {
#line 375
    return (-1);
  }
#line 378
  offset = (int )(state->compressed)->unit_count;
#line 379
  state->this_dlabel_begin = state->uncompressed_offset;
#line 381
  ret = 1;
#line 382
  while (ret == 1) {
#line 383
    ret = compress_sub_dlabel(state);
  }
#line 387
  if (ret == 3) {
#line 388
    return (1);
  }
#line 391
  tmp = compress_add_dlabel_points(state, offset);
#line 391
  if (tmp != 1) {
#line 392
    state->valid_state = 0;
#line 393
    return (-1);
  }
#line 396
  return (1);
}
}
#line 411 "Compress.c"
char compress_get_tocomp(int rr_num ) 
{ rrdesc *point ;
  rrdesc **hash ;

  {
#line 414
  hash = decomp_export_rrformats();
#line 415
  if ((unsigned long )hash == (unsigned long )((rrdesc **)0)) {
#line 416
    return ((char)0);
  }
#line 419
  point = *(hash + rr_num % 7);
#line 421
  if ((unsigned long )point == (unsigned long )((rrdesc *)0)) {
#line 422
    return ((char)0);
  }
#line 424
  while (point->rr_num != rr_num) {
#line 425
    point = point->next;
#line 426
    if ((unsigned long )point == (unsigned long )((rrdesc *)0)) {
#line 427
      return ((char)0);
    }
  }
#line 430
  return (point->tocompress);
}
}
#line 446 "Compress.c"
int compress_rddata(compress_state *state ) 
{ char *desc ;
  char to_compress ;
  int subtype ;
  int total ;
  int ctotal ;
  int tmp ;
  int tmp___0 ;
  int len ;
  int point ;
  int tmp___1 ;
  int tmp___2 ;
  int len___0 ;
  int clen ;
  int coffset ;
  int tmp___3 ;
  int len___1 ;
  int tmp___4 ;
  int len___2 ;
  int tmp___5 ;
  unsigned char left ;
  unsigned char right ;
  unsigned int off ;

  {
#line 452
  if (state->valid_state != 1) {
#line 453
    return (-1);
  }
#line 456
  desc = decomp_get_rrdesc(state->this_rr_type);
#line 457
  to_compress = compress_get_tocomp(state->this_rr_type);
#line 459
  if ((unsigned long )desc == (unsigned long )((char *)0)) {
#line 460
    if (state->current_rdlength == 0) {
#line 461
      return (1);
    }
#line 463
    tmp = js_substr_append(state->uncompressed, state->compressed, (int )state->uncompressed_offset,
                           state->current_rdlength);
#line 463
    if (tmp != 1) {
#line 466
      state->valid_state = 0;
#line 467
      return (-1);
    } else {
#line 470
      state->uncompressed_offset += (unsigned int )state->current_rdlength;
#line 471
      return (1);
    }
  } else {
#line 475
    subtype = (int )*desc;
#line 476
    total = 0;
#line 477
    ctotal = 0;
#line 478
    while (subtype != 0) {
#line 480
      if (subtype > 0) {
#line 480
        if (subtype < 64) {
#line 481
          tmp___0 = js_substr_append(state->uncompressed, state->compressed, (int )state->uncompressed_offset,
                                     subtype);
#line 481
          if (tmp___0 != 1) {
#line 485
            state->valid_state = 0;
#line 486
            return (-1);
          }
#line 488
          total += subtype;
#line 489
          ctotal += subtype;
#line 490
          state->uncompressed_offset += (unsigned int )subtype;
        } else {
#line 480
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 493
      if (subtype == 64) {
#line 495
        if ((int )to_compress == 0) {
#line 497
          len = dlabel_length(state->uncompressed, state->uncompressed_offset);
#line 499
          if (len < 1) {
#line 500
            state->valid_state = 0;
#line 501
            return (-1);
          }
#line 503
          point = (int )(state->compressed)->unit_count;
#line 504
          tmp___1 = js_substr_append(state->uncompressed, state->compressed, (int )state->uncompressed_offset,
                                     len);
#line 504
          if (tmp___1 != 1) {
#line 508
            state->valid_state = 0;
#line 509
            return (-1);
          }
#line 511
          tmp___2 = compress_add_dlabel_points(state, point);
#line 511
          if (tmp___2 != 1) {
#line 512
            state->valid_state = 0;
#line 513
            return (-1);
          }
#line 515
          state->uncompressed_offset += (unsigned int )len;
#line 516
          total += len;
#line 517
          ctotal += len;
        } else {
#line 521
          len___0 = dlabel_length(state->uncompressed, state->uncompressed_offset);
#line 523
          if (len___0 < 1) {
#line 524
            state->valid_state = 0;
#line 525
            return (-1);
          }
#line 527
          coffset = (int )(state->compressed)->unit_count;
#line 528
          tmp___3 = compress_dlabel(state);
#line 528
          if (tmp___3 != 1) {
#line 529
            state->valid_state = 0;
#line 530
            return (-1);
          }
#line 532
          total += len___0;
#line 533
          clen = dlabel_length(state->compressed, (unsigned int )coffset);
#line 534
          ctotal += clen;
        }
      } else
#line 538
      if (subtype == 65) {
#line 540
        if (state->uncompressed_offset >= (state->uncompressed)->unit_count) {
#line 542
          state->valid_state = 0;
#line 543
          return (-1);
        }
#line 545
        len___1 = (int )*((state->uncompressed)->string + state->uncompressed_offset);
#line 547
        if (len___1 < 0) {
#line 548
          state->valid_state = 0;
#line 549
          return (-1);
        } else
#line 547
        if (len___1 > 256) {
#line 548
          state->valid_state = 0;
#line 549
          return (-1);
        }
#line 551
        tmp___4 = js_substr_append(state->uncompressed, state->compressed, (int )state->uncompressed_offset,
                                   len___1);
#line 551
        if (tmp___4 != 1) {
#line 555
          state->valid_state = 0;
#line 556
          return (-1);
        }
#line 558
        total += len___1;
#line 559
        ctotal += len___1;
#line 560
        state->uncompressed_offset += (unsigned int )len___1;
      } else
#line 563
      if (subtype == 66) {
#line 565
        len___2 = state->current_rdlength - total;
#line 566
        if (len___2 == 0) {
#line 567
          break;
        }
#line 569
        tmp___5 = js_substr_append(state->uncompressed, state->compressed, (int )state->uncompressed_offset,
                                   len___2);
#line 569
        if (tmp___5 != 1) {
#line 573
          state->valid_state = 0;
#line 574
          return (-1);
        }
#line 576
        total += len___2;
#line 577
        ctotal += len___2;
#line 578
        state->uncompressed_offset += (unsigned int )len___2;
      } else {
#line 582
        state->valid_state = 0;
#line 583
        return (-1);
      }
#line 585
      desc ++;
#line 587
      if (subtype != 66) {
#line 588
        subtype = (int )*desc;
      } else {
#line 590
        subtype = 0;
      }
    }
#line 593
    if (state->current_rdlength != total) {
#line 594
      state->valid_state = 0;
#line 595
      return (-1);
    }
  }
#line 600
  if (ctotal != total) {
#line 603
    off = state->this_rdlength_begin;
#line 604
    if (ctotal > 65535) {
#line 605
      state->valid_state = 0;
#line 606
      return (-1);
    } else
#line 604
    if (ctotal < 2) {
#line 605
      state->valid_state = 0;
#line 606
      return (-1);
    }
#line 608
    left = (unsigned char )((ctotal >> 8) & 255);
#line 609
    right = (unsigned char )(ctotal & 255);
#line 610
    if (off < 12U) {
#line 611
      state->valid_state = 0;
#line 612
      return (-1);
    } else
#line 610
    if (off >= (state->compressed)->unit_count - 1U) {
#line 611
      state->valid_state = 0;
#line 612
      return (-1);
    }
#line 614
    *((state->compressed)->string + off) = left;
#line 615
    *(((state->compressed)->string + off) + 1) = right;
  }
#line 619
  return (1);
}
}
#line 635 "Compress.c"
int compress_get_uint16(compress_state *state ) 
{ int number ;
  int tmp ;

  {
#line 638
  if (state->valid_state != 1) {
#line 639
    return (-1);
  }
#line 642
  number = js_readuint16(state->uncompressed, state->uncompressed_offset);
#line 643
  if (number == -1) {
#line 644
    state->valid_state = 0;
#line 645
    return (-1);
  }
#line 647
  if (number < 0) {
#line 648
    state->valid_state = 0;
#line 649
    return (-1);
  } else
#line 647
  if (number > 65535) {
#line 648
    state->valid_state = 0;
#line 649
    return (-1);
  }
#line 651
  tmp = js_adduint16(state->compressed, number);
#line 651
  if (tmp != 1) {
#line 652
    state->valid_state = 0;
#line 653
    return (-1);
  }
#line 655
  state->uncompressed_offset += 2U;
#line 656
  if (state->uncompressed_offset > (state->uncompressed)->unit_count) {
#line 657
    state->valid_state = 0;
#line 658
    return (-1);
  }
#line 662
  return (number);
}
}
#line 680 "Compress.c"
int compress_get_type_etc(compress_state *state ) 
{ int number ;
  uint32_t tmp ;
  int tmp___0 ;

  {
#line 683
  if (state->valid_state != 1) {
#line 684
    return (-1);
  }
#line 688
  number = compress_get_uint16(state);
#line 689
  if (number == -1) {
#line 690
    state->valid_state = 0;
#line 691
    return (-1);
  }
#line 693
  state->this_rr_type = number;
#line 696
  number = compress_get_uint16(state);
#line 697
  if (number == -1) {
#line 698
    state->valid_state = 0;
#line 699
    return (-1);
  }
#line 703
  tmp = js_readuint32(state->uncompressed, state->uncompressed_offset);
#line 703
  number = (int )tmp;
#line 704
  if ((unsigned int )number == 4294967295U) {
#line 705
    state->valid_state = 0;
#line 706
    return (-1);
  }
#line 708
  tmp___0 = js_adduint32(state->compressed, (uint32_t )number);
#line 708
  if (tmp___0 != 1) {
#line 709
    state->valid_state = 0;
#line 710
    return (-1);
  }
#line 712
  state->uncompressed_offset += 4U;
#line 713
  if (state->uncompressed_offset >= (state->uncompressed)->unit_count) {
#line 714
    state->valid_state = 0;
#line 715
    return (-1);
  }
#line 719
  return (1);
}
}
#line 730 "Compress.c"
int compress_get_header(compress_state *state ) 
{ int qdcount ;
  int ancount ;
  int nscount ;
  int arcount ;
  int total ;
  int tmp ;

  {
#line 737
  if (state->valid_state != 1) {
#line 738
    return (-1);
  }
#line 741
  if (state->uncompressed_offset != 0U) {
#line 742
    state->valid_state = 0;
#line 743
    return (-1);
  }
#line 747
  tmp = js_substr_append(state->uncompressed, state->compressed, 0, 4);
#line 747
  if (tmp != 1) {
#line 749
    state->valid_state = 0;
#line 750
    return (-1);
  }
#line 754
  state->uncompressed_offset += 4U;
#line 755
  if (state->uncompressed_offset >= (state->uncompressed)->unit_count) {
#line 756
    state->valid_state = 0;
#line 757
    return (-1);
  }
#line 761
  qdcount = compress_get_uint16(state);
#line 762
  if (qdcount == -1) {
#line 763
    state->valid_state = 0;
#line 764
    return (-1);
  }
#line 768
  ancount = compress_get_uint16(state);
#line 769
  if (ancount == -1) {
#line 770
    state->valid_state = 0;
#line 771
    return (-1);
  }
#line 775
  nscount = compress_get_uint16(state);
#line 776
  if (nscount == -1) {
#line 777
    state->valid_state = 0;
#line 778
    return (-1);
  }
#line 782
  arcount = compress_get_uint16(state);
#line 783
  if (arcount == -1) {
#line 784
    state->valid_state = 0;
#line 785
    return (-1);
  }
#line 790
  if (qdcount < 0) {
#line 791
    state->valid_state = 0;
#line 792
    return (-1);
  } else
#line 790
  if (qdcount > 1) {
#line 791
    state->valid_state = 0;
#line 792
    return (-1);
  }
#line 794
  total = (ancount + nscount) + arcount;
#line 797
  if (total != 0) {
#line 797
    if (qdcount != 1) {
#line 798
      state->valid_state = 0;
#line 799
      return (-1);
    }
  }
#line 802
  if (qdcount == 0) {
#line 803
    state->number_answers = -2;
#line 804
    return (1);
  }
#line 807
  state->number_answers = total;
#line 808
  return (1);
}
}
#line 820 "Compress.c"
int compress_get_question(compress_state *state ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 823
  if (state->valid_state != 1) {
#line 824
    return (-1);
  }
#line 826
  if (state->uncompressed_offset != 12U) {
#line 827
    state->valid_state = 0;
#line 828
    return (-1);
  }
#line 831
  if (state->number_answers == -2) {
#line 832
    return (1);
  }
#line 836
  tmp = compress_dlabel(state);
#line 836
  if (tmp != 1) {
#line 837
    state->valid_state = 0;
#line 838
    return (-1);
  }
#line 841
  tmp___0 = compress_get_uint16(state);
#line 841
  if (tmp___0 == -1) {
#line 842
    state->valid_state = 0;
#line 843
    return (-1);
  }
#line 846
  tmp___1 = compress_get_uint16(state);
#line 846
  if (tmp___1 == -1) {
#line 847
    state->valid_state = 0;
#line 848
    return (-1);
  }
#line 851
  return (1);
}
}
#line 858 "Compress.c"
int compress_get_rdlength(compress_state *state ) 
{ int number ;

  {
#line 862
  state->this_rdlength_begin = (state->compressed)->unit_count;
#line 864
  number = compress_get_uint16(state);
#line 865
  if (number == -1) {
#line 866
    state->valid_state = 0;
#line 867
    return (-1);
  }
#line 869
  state->current_rdlength = number;
#line 871
  return (1);
}
}
#line 880 "Compress.c"
int compress_answers(compress_state *state ) 
{ int counter ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 883
  if (state->valid_state != 1) {
#line 884
    return (-1);
  }
#line 887
  counter = 0;
#line 887
  while (counter < state->number_answers) {
#line 888
    tmp = compress_dlabel(state);
#line 888
    if (tmp == -1) {
#line 889
      state->valid_state = 0;
#line 890
      return (-1);
    }
#line 892
    tmp___0 = compress_get_type_etc(state);
#line 892
    if (tmp___0 == -1) {
#line 893
      state->valid_state = 0;
#line 894
      return (-1);
    }
#line 896
    tmp___1 = compress_get_rdlength(state);
#line 896
    if (tmp___1 == -1) {
#line 897
      state->valid_state = 0;
#line 898
      return (-1);
    }
#line 900
    tmp___2 = compress_rddata(state);
#line 900
    if (tmp___2 == -1) {
#line 901
      state->valid_state = 0;
#line 902
      return (-1);
    }
#line 887
    counter ++;
  }
#line 905
  return (1);
}
}
#line 916 "Compress.c"
js_string *compress_destroy_state(compress_state *state ) 
{ js_string *ret ;

  {
#line 918
  js_dealloc((void *)state->dlabel_points);
#line 919
  ret = state->compressed;
#line 920
  js_dealloc((void *)state);
#line 921
  return (ret);
}
}
#line 937 "Compress.c"
int compress_data(js_string *in , js_string *out ) 
{ js_string *compressed ;
  compress_state *state ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 941
  state = compress_init_state(in);
#line 942
  if ((unsigned long )state == (unsigned long )((compress_state *)0)) {
#line 943
    return (-1);
  }
#line 949
  tmp = compress_get_header(state);
#line 949
  if (tmp == -1) {
#line 950
    compressed = compress_destroy_state(state);
#line 951
    js_destroy(compressed);
#line 952
    return (-1);
  }
#line 955
  tmp___0 = compress_get_question(state);
#line 955
  if (tmp___0 == -1) {
#line 956
    compressed = compress_destroy_state(state);
#line 957
    js_destroy(compressed);
#line 958
    return (-1);
  }
#line 961
  tmp___1 = compress_answers(state);
#line 961
  if (tmp___1 == -1) {
#line 962
    compressed = compress_destroy_state(state);
#line 963
    js_destroy(compressed);
#line 964
    return (-1);
  }
#line 967
  compressed = compress_destroy_state(state);
#line 973
  tmp___2 = js_copy(compressed, out);
#line 973
  if (tmp___2 == -1) {
#line 974
    js_destroy(compressed);
#line 975
    return (-1);
  }
#line 978
  js_destroy(compressed);
#line 979
  return (1);
}
}
#line 1 "bobbit.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-YxyacqW1.i","")
#line 30 "bobbit.c"
int bobbit_label(js_string *js ) 
{ int counter ;
  unsigned char length ;

  {
#line 31
  counter = 0;
#line 34
  if (js->unit_size != 1U) {
#line 35
    return (-1);
  }
#line 36
  if (js->unit_count >= js->max_count) {
#line 37
    return (-1);
  }
#line 38
  if (js->unit_count < 1U) {
#line 39
    return (-1);
  }
#line 41
  length = *(js->string);
#line 43
  if ((int )length == 95) {
#line 44
    length = (unsigned char)0;
  } else
#line 45
  if ((unsigned int )((int )length + 1) > js->unit_count) {
#line 46
    return (-1);
  } else
#line 45
  if ((int )length > 63) {
#line 46
    return (-1);
  } else
#line 47
  if ((int )length == 0) {
#line 48
    return (0);
  }
#line 50
  length = (unsigned char )((int )length + 1);
#line 52
  while ((unsigned int )counter < js->unit_count - (unsigned int )length) {
#line 53
    *(js->string + counter) = *((js->string + counter) + (int )length);
#line 54
    counter ++;
  }
#line 57
  js->unit_count -= (unsigned int )length;
#line 59
  return (1);
}
}
#line 1 "Decompress.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-oZq7FCpO.i","")
#line 40 "../server/timestamp.h"
int show_timestamp(void) ;
#line 40 "Compress_rrdescs.h"
char *rr_descs[17]  = 
#line 40 "Compress_rrdescs.h"
  {      (char *)":1|A|4|N|en;IPv4 Addresses [RFC 1035];",      (char *)":15|MX|2;D|C|en;Mail exchanger records [RFC 1035];",      (char *)":2|NS|D|C|en;NS (name server) records [RFC 1035];",      (char *)":6|SOA|D;D;4;4;4;4;4|C|en;SOA records [RFC 1035];", 
        (char *)":12|PTR|D|C|en;Reverse DNS lookup records [RFC 1035];",      (char *)":16|TXT|T;V|N|en;Text data [RFC 1035];",      (char *)":5|CNAME|D|C|en;CNAME records [RFC 1035];",      (char *)":3|MD|D|N|en;[RFC 1035];", 
        (char *)":4|MF|D|N|en;[RFC 1035];",      (char *)":7|MB|D|N|en;[RFC 1035];",      (char *)":8|MG|D|N|en;[RFC 1035];",      (char *)":9|MR|D|N|en;[RFC 1035];", 
        (char *)":14|MINFO|D;D|N|en;[RFC 1035];",      (char *)":17|RP|D;D|N|en;[RFC 1183];",      (char *)":18|AFSDB|2;D|N|en;[RFC 1183];",      (char *)":21|RT|2;D|N|en;[RFC 1183];", 
        (char *)":33|SRV|2;2;2;D|N|en;Service [RFC 2052];"};
#line 31 "Decompress.c"
rrdesc **rr_formats  ;
#line 34 "Decompress.c"
int dlog_level  =    -1;
#line 45 "Decompress.c"
int decomp_message(char *message , int min_log_level ) 
{ 

  {
#line 46
  if (dlog_level >= min_log_level) {
#line 47
    show_timestamp();
#line 48
    printf("%s\n", message);
  }
#line 50
  return (1);
}
}
#line 68 "Decompress.c"
js_string *decomp_get_label(js_string *compressed , unsigned int compressed_offset ) 
{ js_string *ret ;
  int counter ;
  int cplace ;
  int cplace_save ;
  int dplace ;
  int limit ;

  {
#line 73
  decomp_message((char *)"Performing sanity checks on compressed string...", 5);
#line 76
  if ((unsigned long )compressed == (unsigned long )((js_string *)0)) {
#line 77
    return ((js_string *)0);
  }
#line 78
  if (compressed->unit_size != 1U) {
#line 79
    return ((js_string *)0);
  }
#line 80
  if (compressed->unit_count > compressed->max_count) {
#line 81
    return ((js_string *)0);
  }
#line 82
  if (compressed_offset > compressed->unit_count) {
#line 83
    return ((js_string *)0);
  }
#line 85
  decomp_message((char *)"Compressed string is sane.  Initializing variables...",
                 5);
#line 88
  cplace = (int )compressed_offset;
#line 89
  cplace_save = cplace;
#line 90
  dplace = 0;
#line 91
  counter = 0;
#line 92
  limit = 0;
#line 93
  ret = js_create(259U, 1U);
#line 93
  if ((unsigned long )ret == (unsigned long )((js_string *)0)) {
#line 94
    return ((js_string *)0);
  }
#line 96
  decomp_message((char *)"Variables initalized.", 5);
#line 99
  while (1) {
#line 100
    if ((unsigned int )cplace >= compressed->unit_count) {
#line 101
      js_destroy(ret);
#line 102
      return ((js_string *)0);
    }
#line 104
    limit ++;
#line 105
    counter = (int )*(compressed->string + cplace);
#line 107
    if (counter > 63) {
#line 107
      if (counter < 192) {
#line 108
        decomp_message((char *)"Invalid length value in compressed string", 4);
#line 109
        js_destroy(ret);
#line 110
        return ((js_string *)0);
      } else {
#line 107
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 112
    if (counter >= 192) {
#line 114
      if ((unsigned int )(cplace + 1) >= compressed->unit_count) {
#line 115
        decomp_message((char *)"Compression pointer isn\'t fitting", 4);
#line 116
        js_destroy(ret);
#line 117
        return ((js_string *)0);
      }
#line 120
      cplace_save = cplace;
#line 121
      cplace = (counter & 63) << 8;
#line 122
      cplace |= (int )*((compressed->string + cplace_save) + 1);
#line 124
      if (cplace >= cplace_save) {
#line 125
        decomp_message((char *)"Compressed pointer goes forward", 4);
#line 126
        js_destroy(ret);
#line 127
        return ((js_string *)0);
      }
#line 130
      if (cplace < 12) {
#line 131
        decomp_message((char *)"Compressed pointer points to header", 4);
#line 132
        js_destroy(ret);
#line 133
        return ((js_string *)0);
      }
    } else
#line 137
    if (counter > 0) {
#line 137
      if (counter <= 63) {
#line 138
        counter ++;
#line 139
        if ((unsigned int )(dplace + counter) >= ret->max_count) {
#line 140
          decomp_message((char *)"Pointing past end of ret string", 4);
#line 141
          js_destroy(ret);
#line 142
          return ((js_string *)0);
        }
#line 144
        if ((unsigned int )(cplace + counter) >= compressed->unit_count) {
#line 145
          decomp_message((char *)"Pointing past end of compressed string", 4);
#line 146
          js_destroy(ret);
#line 147
          return ((js_string *)0);
        }
#line 149
        while (counter > 0) {
#line 150
          *(ret->string + dplace) = *(compressed->string + cplace);
#line 151
          (ret->unit_count) ++;
#line 152
          dplace ++;
#line 153
          cplace ++;
#line 154
          counter --;
        }
#line 156
        counter = 100;
      } else {
#line 137
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 158
    if (counter == 0) {
#line 159
      if ((unsigned int )(dplace + counter) >= ret->max_count) {
#line 160
        decomp_message((char *)"Pointing past end of the compressed string", 4);
#line 161
        js_destroy(ret);
#line 162
        return ((js_string *)0);
      }
#line 164
      *(ret->string + dplace) = (unsigned char)0;
#line 165
      (ret->unit_count) ++;
    } else {
#line 168
      decomp_message((char *)"This, folks, should never happen", 4);
#line 169
      js_destroy(ret);
#line 170
      return ((js_string *)0);
    }
#line 99
    if (counter > 0) {
#line 99
      if (! (limit < 256)) {
#line 99
        break;
      }
    } else {
#line 99
      break;
    }
  }
#line 174
  if (limit >= 256) {
#line 175
    decomp_message((char *)"Limit exceeded when decompressing dlabel", 4);
#line 176
    js_destroy(ret);
#line 177
    return ((js_string *)0);
  }
#line 182
  return (ret);
}
}
#line 202 "Decompress.c"
int decomp_append_dlabel(js_string *compressed , js_string *uncompressed , unsigned int compressed_offset ) 
{ js_string *dlabel ;
  int length ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 206
  length = 0;
#line 209
  tmp = js_has_sanity(compressed);
#line 209
  if (tmp != 1) {
#line 210
    return (-1);
  }
#line 212
  tmp___0 = js_has_sanity(uncompressed);
#line 212
  if (tmp___0 != 1) {
#line 213
    return (-1);
  }
#line 215
  if (compressed->unit_size != 1U) {
#line 216
    return (-1);
  }
#line 218
  if (uncompressed->unit_size != 1U) {
#line 219
    return (-1);
  }
#line 221
  if (compressed_offset >= compressed->unit_count) {
#line 222
    return (-1);
  }
#line 226
  dlabel = decomp_get_label(compressed, compressed_offset);
#line 227
  if ((unsigned long )dlabel == (unsigned long )((js_string *)0)) {
#line 228
    return (-1);
  }
#line 230
  length = dlabel_length(compressed, compressed_offset);
#line 231
  if (length == -1) {
#line 232
    js_destroy(dlabel);
#line 233
    return (-1);
  }
#line 237
  tmp___1 = js_append(dlabel, uncompressed);
#line 237
  if (tmp___1 == -1) {
#line 238
    js_destroy(dlabel);
#line 239
    return (-1);
  }
#line 243
  js_destroy(dlabel);
#line 244
  return (length);
}
}
#line 271 "Decompress.c"
int decomp_append_bytes(js_string *compressed , js_string *uncompressed , unsigned int compressed_offset ,
                        int length ) 
{ js_string *temp ;
  int tmp ;
  int tmp___0 ;

  {
#line 275
  temp = js_create((unsigned int )(length + 2), 1U);
#line 275
  if ((unsigned long )temp == (unsigned long )((js_string *)0)) {
#line 276
    return (-1);
  }
#line 279
  if (compressed->unit_count < compressed_offset + (unsigned int )length) {
#line 280
    js_destroy(temp);
#line 281
    return (-1);
  }
#line 284
  tmp = js_substr(compressed, temp, (int )compressed_offset, length);
#line 284
  if (tmp != 1) {
#line 285
    js_destroy(temp);
#line 286
    return (-1);
  }
#line 289
  tmp___0 = js_append(temp, uncompressed);
#line 289
  if (tmp___0 == -1) {
#line 290
    js_destroy(temp);
#line 291
    return (-1);
  }
#line 294
  js_destroy(temp);
#line 295
  return (1);
}
}
#line 319 "Decompress.c"
int decomp_get_type_etc(js_string *compressed , js_string *uncompressed , unsigned int compressed_offset ) 
{ int type ;
  int tmp ;

  {
#line 324
  type = js_readuint16(compressed, compressed_offset);
#line 326
  tmp = decomp_append_bytes(compressed, uncompressed, compressed_offset, 8);
#line 326
  if (tmp != 1) {
#line 328
    return (-1);
  }
#line 331
  return (type);
}
}
#line 354 "Decompress.c"
int decomp_get_rdlength(js_string *compressed , unsigned int compressed_offset ) 
{ int rdlength ;

  {
#line 359
  rdlength = js_readuint16(compressed, compressed_offset);
#line 361
  return (rdlength);
}
}
#line 385 "Decompress.c"
int decomp_get_header(js_string *compressed , js_string *uncompressed ) 
{ int qdcount ;
  int ancount ;
  int nscount ;
  int arcount ;
  int total ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 389
  tmp = js_has_sanity(compressed);
#line 389
  if (tmp == -1) {
#line 390
    return (-1);
  }
#line 392
  tmp___0 = js_has_sanity(uncompressed);
#line 392
  if (tmp___0 == -1) {
#line 393
    return (-1);
  }
#line 395
  if (compressed->unit_count < 12U) {
#line 396
    return (-1);
  }
#line 398
  if (uncompressed->unit_count != 0U) {
#line 399
    return (-1);
  }
#line 403
  qdcount = js_readuint16(compressed, 4U);
#line 404
  if (qdcount < 0) {
#line 405
    return (-1);
  } else
#line 404
  if (qdcount > 1) {
#line 405
    return (-1);
  }
#line 408
  ancount = js_readuint16(compressed, 6U);
#line 409
  if (ancount < 0) {
#line 410
    return (-1);
  } else
#line 409
  if (ancount > 65535) {
#line 410
    return (-1);
  }
#line 411
  nscount = js_readuint16(compressed, 8U);
#line 412
  if (nscount < 0) {
#line 413
    return (-1);
  } else
#line 412
  if (nscount > 65535) {
#line 413
    return (-1);
  }
#line 414
  arcount = js_readuint16(compressed, 10U);
#line 415
  if (arcount < 0) {
#line 416
    return (-1);
  } else
#line 415
  if (arcount > 65535) {
#line 416
    return (-1);
  }
#line 418
  total = (ancount + nscount) + arcount;
#line 421
  tmp___1 = decomp_append_bytes(compressed, uncompressed, 0U, 12);
#line 421
  if (tmp___1 != 1) {
#line 422
    return (-1);
  }
#line 425
  if (qdcount == 0) {
#line 425
    if (total >= 1) {
#line 426
      return (-2 - total);
    }
  }
#line 429
  if (qdcount == 0) {
#line 430
    return (-2);
  }
#line 432
  return (total);
}
}
#line 453 "Decompress.c"
int decomp_get_question(js_string *compressed , js_string *uncompressed ) 
{ int length ;
  int tmp ;

  {
#line 457
  if (compressed->unit_count < 12U) {
#line 458
    return (-1);
  }
#line 461
  if (uncompressed->unit_count != 12U) {
#line 462
    return (-1);
  }
#line 466
  length = decomp_append_dlabel(compressed, uncompressed, 12U);
#line 467
  if (length < 1) {
#line 468
    return (-1);
  }
#line 472
  tmp = decomp_append_bytes(compressed, uncompressed, (unsigned int )(12 + length),
                            4);
#line 472
  if (tmp != 1) {
#line 474
    return (-1);
  }
#line 477
  length += 4;
#line 479
  return (length);
}
}
#line 502 "Decompress.c"
int decomp_init_rrdesc(void) 
{ int counter ;
  void *tmp ;

  {
#line 505
  tmp = js_alloc(7, (int )sizeof(rrdesc *));
#line 505
  rr_formats = (rrdesc **)tmp;
#line 505
  if ((unsigned long )rr_formats == (unsigned long )((rrdesc **)0)) {
#line 506
    return (-1);
  }
#line 509
  counter = 0;
#line 509
  while (counter < 7) {
#line 510
    *(rr_formats + counter) = (rrdesc *)0;
#line 509
    counter ++;
  }
#line 512
  return (1);
}
}
#line 537 "Decompress.c"
int decomp_add_rrdesc(js_string *desc ) 
{ int rtype ;
  int place ;
  int counter ;
  int fieldnum ;
  int subfieldnum ;
  unsigned char c ;
  rrdesc *new ;
  rrdesc *point ;
  int tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  unsigned int tmp___3 ;

  {
#line 543
  tmp = js_has_sanity(desc);
#line 543
  if (tmp != 1) {
#line 544
    return (-1);
  }
#line 545
  js_set_encode(desc, 2);
#line 548
  tmp___0 = js_alloc(1, (int )sizeof(rrdesc ));
#line 548
  new = (rrdesc *)tmp___0;
#line 548
  if ((unsigned long )new == (unsigned long )((rrdesc *)0)) {
#line 549
    return (-1);
  }
#line 554
  tmp___2 = js_alloc(16, 1);
#line 554
  tmp___1 = (char *)tmp___2;
#line 554
  new->description = tmp___1;
#line 554
  if ((unsigned long )tmp___1 == (unsigned long )((char *)0)) {
#line 555
    js_dealloc((void *)new);
#line 556
    return (-1);
  }
#line 559
  counter = 0;
#line 559
  while (counter < 15) {
#line 560
    *(new->description + counter) = (char)0;
#line 559
    counter ++;
  }
#line 567
  new->tocompress = (char)79;
#line 570
  subfieldnum = 1;
#line 570
  fieldnum = subfieldnum;
#line 571
  rtype = -1;
#line 572
  counter = 0;
#line 572
  while ((unsigned int )counter < desc->unit_count) {
#line 573
    c = *(desc->string + counter);
#line 574
    if (fieldnum == 1) {
#line 575
      if (subfieldnum == 1) {
#line 576
        if ((int )c == 58) {
#line 577
          subfieldnum ++;
        }
      } else
#line 580
      if (subfieldnum == 2) {
#line 581
        if (rtype == -1) {
#line 582
          tmp___3 = js_atoi(desc, counter);
#line 582
          rtype = (int )tmp___3;
#line 583
          if (rtype <= 0) {
#line 584
            js_dealloc((void *)new->description);
#line 585
            js_dealloc((void *)new);
#line 586
            return (-1);
          } else
#line 583
          if (rtype > 65535) {
#line 584
            js_dealloc((void *)new->description);
#line 585
            js_dealloc((void *)new);
#line 586
            return (-1);
          }
#line 588
          new->rr_num = rtype;
        }
#line 590
        if ((int )c == 124) {
#line 591
          subfieldnum = 1;
#line 592
          fieldnum = 2;
        }
      }
    } else
#line 596
    if (fieldnum == 2) {
#line 597
      if ((int )c == 124) {
#line 598
        subfieldnum = 1;
#line 599
        fieldnum = 3;
      }
    } else
#line 602
    if (fieldnum == 3) {
#line 604
      if (subfieldnum > 14) {
#line 605
        js_dealloc((void *)new->description);
#line 606
        js_dealloc((void *)new);
#line 607
        return (-1);
      }
#line 612
      if ((int )*(new->description + (subfieldnum - 1)) == 0) {
#line 613
        if ((int )c >= 49) {
#line 613
          if ((int )c <= 57) {
#line 614
            *(new->description + (subfieldnum - 1)) = (char )((int )c - 48);
          } else {
#line 613
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 616
        if ((int )c == 68) {
#line 617
          *(new->description + (subfieldnum - 1)) = (char)64;
        } else
#line 619
        if ((int )c == 84) {
#line 620
          *(new->description + (subfieldnum - 1)) = (char)65;
        } else
#line 622
        if ((int )c == 86) {
#line 623
          *(new->description + (subfieldnum - 1)) = (char)66;
        } else {
#line 626
          js_dealloc((void *)new->description);
#line 627
          js_dealloc((void *)new);
#line 628
          return (-1);
        }
      } else
#line 631
      if ((int )c != 59) {
#line 631
        if ((int )c != 124) {
#line 632
          js_dealloc((void *)new->description);
#line 633
          js_dealloc((void *)new);
#line 634
          return (-1);
        } else {
#line 631
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 636
      if ((int )c == 59) {
#line 638
        if ((int )*(new->description + (subfieldnum - 1)) == 66) {
#line 639
          js_dealloc((void *)new->description);
#line 640
          js_dealloc((void *)new);
#line 641
          return (-1);
        }
#line 643
        subfieldnum ++;
      } else
#line 645
      if ((int )c == 124) {
#line 646
        subfieldnum = 1;
#line 647
        fieldnum = 4;
      } else {
#line 650
        js_dealloc((void *)new->description);
#line 651
        js_dealloc((void *)new);
#line 652
        return (-1);
      }
    } else
#line 655
    if (fieldnum == 4) {
#line 657
      if ((int )c == 67) {
#line 657
        if ((int )new->tocompress == 79) {
#line 658
          new->tocompress = (char)1;
        } else {
#line 657
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 660
      if ((int )c == 78) {
#line 660
        if ((int )new->tocompress == 79) {
#line 661
          new->tocompress = (char)0;
        } else {
#line 660
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 663
      if ((int )c == 124) {
#line 663
        if ((int )new->tocompress != 79) {
#line 664
          subfieldnum = 1;
#line 665
          fieldnum = 5;
        } else {
#line 668
          js_dealloc((void *)new->description);
#line 669
          js_dealloc((void *)new);
#line 670
          return (-4);
        }
      } else {
#line 668
        js_dealloc((void *)new->description);
#line 669
        js_dealloc((void *)new);
#line 670
        return (-4);
      }
    } else
#line 673
    if (fieldnum == 5) {
#line 678
      break;
    }
#line 572
    counter ++;
  }
#line 685
  place = rtype % 7;
#line 686
  if ((unsigned long )rr_formats == (unsigned long )((rrdesc **)0)) {
#line 687
    js_dealloc((void *)new->description);
#line 688
    js_dealloc((void *)new);
#line 689
    return (-1);
  }
#line 691
  point = *(rr_formats + place);
#line 692
  if ((unsigned long )point == (unsigned long )((rrdesc *)0)) {
#line 693
    *(rr_formats + place) = new;
  } else {
#line 696
    while ((unsigned long )point->next != (unsigned long )((struct rrdesc *)0)) {
#line 697
      point = point->next;
    }
#line 698
    point->next = new;
  }
#line 701
  new->next = (struct rrdesc *)0;
#line 704
  return (1);
}
}
#line 728 "Decompress.c"
int decomp_init(int alog_level ) 
{ js_string *temp ;
  int counter ;
  int tmp ;
  int tmp___0 ;

  {
#line 733
  temp = js_create(256U, 1U);
#line 733
  if ((unsigned long )temp == (unsigned long )((js_string *)0)) {
#line 734
    return (-1);
  }
#line 738
  decomp_init_rrdesc();
#line 739
  counter = 0;
#line 739
  while (counter < 17) {
#line 740
    tmp = js_qstr2js(temp, rr_descs[counter]);
#line 740
    if (tmp != 1) {
#line 741
      js_destroy(temp);
#line 742
      return (-1);
    }
#line 744
    tmp___0 = decomp_add_rrdesc(temp);
#line 744
    if (tmp___0 != 1) {
#line 745
      js_destroy(temp);
#line 746
      return (-1);
    }
#line 739
    counter ++;
  }
#line 751
  dlog_level = alog_level;
#line 753
  js_destroy(temp);
#line 754
  return (1);
}
}
#line 783 "Decompress.c"
char *decomp_get_rrdesc(int rr_num ) 
{ rrdesc *point ;

  {
#line 786
  if ((unsigned long )rr_formats == (unsigned long )((rrdesc **)0)) {
#line 787
    return ((char *)0);
  }
#line 789
  point = *(rr_formats + rr_num % 7);
#line 790
  if ((unsigned long )point == (unsigned long )((rrdesc *)0)) {
#line 791
    return ((char *)0);
  }
#line 793
  while (point->rr_num != rr_num) {
#line 794
    point = point->next;
#line 795
    if ((unsigned long )point == (unsigned long )((rrdesc *)0)) {
#line 796
      return ((char *)0);
    }
  }
#line 799
  return (point->description);
}
}
#line 823 "Decompress.c"
int decomp_get_rddata(js_string *compressed , js_string *out , unsigned int compressed_offset ,
                      int type , int rdlength ) 
{ char *desc ;
  int subtype ;
  int total ;
  int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 829
  desc = decomp_get_rrdesc(type);
#line 831
  if ((unsigned long )desc == (unsigned long )((char *)0)) {
#line 832
    if (rdlength == 0) {
#line 833
      return (1);
    }
#line 835
    tmp = decomp_append_bytes(compressed, out, compressed_offset, rdlength);
#line 835
    if (tmp != 1) {
#line 837
      return (-1);
    } else {
#line 840
      return (1);
    }
  } else {
#line 844
    subtype = (int )*desc;
#line 845
    total = 0;
#line 847
    while (subtype != 0) {
#line 849
      if (subtype > 0) {
#line 849
        if (subtype < 64) {
#line 850
          tmp___0 = decomp_append_bytes(compressed, out, compressed_offset, subtype);
#line 850
          if (tmp___0 != 1) {
#line 852
            return (-1);
          }
#line 854
          total += subtype;
#line 855
          compressed_offset += (unsigned int )subtype;
        } else {
#line 849
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 858
      if (subtype == 64) {
#line 859
        len = decomp_append_dlabel(compressed, out, compressed_offset);
#line 861
        if (len == -1) {
#line 862
          return (-1);
        }
#line 864
        total += len;
#line 865
        compressed_offset += (unsigned int )len;
      } else
#line 868
      if (subtype == 65) {
#line 870
        len = (int )*(compressed->string + compressed_offset);
#line 871
        len ++;
#line 873
        if (len < 0) {
#line 874
          return (-1);
        } else
#line 873
        if (len > 256) {
#line 874
          return (-1);
        }
#line 876
        tmp___1 = decomp_append_bytes(compressed, out, compressed_offset, len);
#line 876
        if (tmp___1 != 1) {
#line 879
          return (-1);
        }
#line 881
        total += len;
#line 882
        compressed_offset += (unsigned int )len;
      } else
#line 885
      if (subtype == 66) {
#line 886
        len = rdlength - total;
#line 887
        if (len == 0) {
#line 888
          break;
        }
#line 890
        tmp___2 = decomp_append_bytes(compressed, out, compressed_offset, len);
#line 890
        if (tmp___2 != 1) {
#line 892
          return (-1);
        }
#line 894
        total += len;
#line 895
        compressed_offset += (unsigned int )len;
      } else {
#line 898
        return (-1);
      }
#line 900
      desc ++;
#line 902
      if (subtype != 66) {
#line 903
        subtype = (int )*desc;
      } else {
#line 905
        subtype = 0;
      }
    }
#line 908
    if (rdlength != total) {
#line 909
      return (-1);
    }
  }
#line 914
  return (1);
}
}
#line 934 "Decompress.c"
int decomp_decompress_packet(js_string *compressed , js_string *uncompressed ) 
{ int answers ;
  int type ;
  int rdlength ;
  int offset ;
  int length ;
  js_string *rddata ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 943
  tmp = js_has_sanity(compressed);
#line 943
  if (tmp == -1) {
#line 944
    return (-1);
  }
#line 945
  tmp___0 = js_has_sanity(uncompressed);
#line 945
  if (tmp___0 == -1) {
#line 946
    return (-1);
  }
#line 947
  if (compressed->unit_size != 1U) {
#line 948
    return (-1);
  } else
#line 947
  if (uncompressed->unit_size != 1U) {
#line 948
    return (-1);
  }
#line 949
  if (uncompressed->unit_count != 0U) {
#line 950
    return (-1);
  }
#line 954
  rddata = js_create(512U, 1U);
#line 954
  if ((unsigned long )rddata == (unsigned long )((js_string *)0)) {
#line 955
    return (-1);
  }
#line 964
  answers = decomp_get_header(compressed, uncompressed);
#line 965
  if (answers == -2) {
#line 966
    js_destroy(rddata);
#line 967
    return (1);
  } else
#line 969
  if (answers == -1) {
#line 970
    js_destroy(rddata);
#line 971
    return (-1);
  }
#line 975
  if (answers <= -3) {
#line 976
    answers = -2 - answers;
#line 978
    length = 0;
  } else {
#line 981
    length = decomp_get_question(compressed, uncompressed);
#line 982
    if (length < 1) {
#line 983
      js_destroy(rddata);
#line 984
      return (-1);
    }
  }
#line 988
  offset = 12 + length;
#line 991
  while (answers > 0) {
#line 992
    length = decomp_append_dlabel(compressed, uncompressed, (unsigned int )offset);
#line 993
    if (length < 1) {
#line 994
      js_destroy(rddata);
#line 995
      return (-1);
    }
#line 997
    offset += length;
#line 998
    type = decomp_get_type_etc(compressed, uncompressed, (unsigned int )offset);
#line 999
    if (type == -1) {
#line 1000
      js_destroy(rddata);
#line 1001
      return (-1);
    }
#line 1003
    offset += 8;
#line 1004
    rdlength = decomp_get_rdlength(compressed, (unsigned int )offset);
#line 1005
    if (rdlength == -1) {
#line 1006
      js_destroy(rddata);
#line 1007
      return (-1);
    }
#line 1009
    offset += 2;
#line 1011
    rddata->unit_count = 0U;
#line 1012
    tmp___1 = decomp_get_rddata(compressed, rddata, (unsigned int )offset, type, rdlength);
#line 1012
    if (tmp___1 != 1) {
#line 1014
      js_destroy(rddata);
#line 1015
      return (-1);
    }
#line 1018
    tmp___2 = js_adduint16(uncompressed, (int )rddata->unit_count);
#line 1018
    if (tmp___2 == -1) {
#line 1019
      js_destroy(rddata);
#line 1020
      return (-1);
    }
#line 1023
    tmp___3 = js_append(rddata, uncompressed);
#line 1023
    if (tmp___3 == -1) {
#line 1024
      js_destroy(rddata);
#line 1025
      return (-1);
    }
#line 1027
    offset += rdlength;
#line 1028
    answers --;
  }
#line 1031
  js_destroy(rddata);
#line 1032
  return (1);
}
}
#line 1050 "Decompress.c"
int decompress_data(js_string *compressed , js_string *uncompressed ) 
{ int tmp ;

  {
#line 1052
  uncompressed->unit_count = 0U;
#line 1054
  if (dlog_level >= 5) {
#line 1055
    printf("About to decompress packet: ");
#line 1056
    show_esc_stdout(compressed);
#line 1057
    printf("\n");
  }
#line 1060
  if (dlog_level == -1) {
#line 1061
    return (-1);
  } else {
#line 1064
    tmp = decomp_decompress_packet(compressed, uncompressed);
#line 1064
    return (tmp);
  }
#line 1068
  return (-1);
}
}
#line 1075 "Decompress.c"
rrdesc **decomp_export_rrformats(void) 
{ 

  {
#line 1076
  return (rr_formats);
}
}
#line 1 "ParseMaraRc.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-Wx8P7S6i.i","")
#line 94 "/usr/include/string.h"
extern int strncmp(char const   * , char const   * , size_t  ) ;
#line 36 "ParseMaraRc.c"
char *keywords[55]  = 
#line 36 "ParseMaraRc.c"
  {      (char *)"bind_address",      (char *)"ipv4_bind_addresses",      (char *)"ipv6_bind_address",      (char *)"csv2_synthip_list", 
        (char *)"chroot_dir",      (char *)"debug_response_delay",      (char *)"debug_msg_level",      (char *)"default_rrany_set", 
        (char *)"hide_disclaimer",      (char *)"maradns_uid",      (char *)"maradns_gid",      (char *)"max_ar_chain", 
        (char *)"max_chain",      (char *)"max_glueless_level",      (char *)"max_queries_total",      (char *)"max_tcp_procs", 
        (char *)"max_total",      (char *)"maximum_cache_elements",      (char *)"maxprocs",      (char *)"min_ttl_cname", 
        (char *)"min_ttl",      (char *)"min_visible_ttl",      (char *)"no_fingerprint",      (char *)"random_seed_file", 
        (char *)"recursive_acl",      (char *)"spammers",      (char *)"timeout_seconds",      (char *)"timestamp_type", 
        (char *)"verbose_level",      (char *)"tcp_convert_acl",      (char *)"tcp_convert_server",      (char *)"tcp_convert_recursion", 
        (char *)"reject_aaaa",      (char *)"reject_ptr",      (char *)"verbose_query",      (char *)"csv2_default_zonefile", 
        (char *)"dos_protection_level",      (char *)"no_cname_warnings",      (char *)"long_packet_ipv4",      (char *)"synth_soa_origin", 
        (char *)"synth_soa_serial",      (char *)"bind_star_handling",      (char *)"admin_acl",      (char *)"remote_admin", 
        (char *)"handle_noreply",      (char *)"retry_cycles",      (char *)"csv2_tilde_handling",      (char *)"dns_port", 
        (char *)"upstream_port",      (char *)"recurse_delegation",      (char *)"recurse_min_bind_port",      (char *)"recurse_number_ports", 
        (char *)"max_mem",      (char *)"notthere_ip",      (char *)"zone_transfer_acl"};
#line 153 "ParseMaraRc.c"
int mara_goodjs(js_string *test ) 
{ int tmp ;

  {
#line 154
  tmp = js_has_sanity(test);
#line 154
  if (tmp == -1) {
#line 155
    return (-1);
  }
#line 157
  if (test->unit_size != 1U) {
#line 158
    return (-1);
  }
#line 159
  return (1);
}
}
#line 165 "ParseMaraRc.c"
int is_numeric_js(js_string *test ) 
{ int counter ;
  int tmp ;

  {
#line 167
  tmp = mara_goodjs(test);
#line 167
  if (! tmp) {
#line 168
    return (-1);
  }
#line 170
  if (test->unit_count > test->max_count) {
#line 171
    return (-1);
  }
#line 173
  if (test->unit_count == 0U) {
#line 174
    return (0);
  }
#line 175
  counter = 0;
#line 175
  while ((unsigned int )counter < test->unit_count) {
#line 176
    if ((int )*(test->string + counter) < 48) {
#line 178
      return (0);
    } else
#line 176
    if ((int )*(test->string + counter) > 57) {
#line 178
      return (0);
    }
#line 175
    counter ++;
  }
#line 180
  return (1);
}
}
#line 183 "ParseMaraRc.c"
js_string *kvar[55]  ;
#line 192 "ParseMaraRc.c"
int keyword2num(js_string *keyword ) 
{ int counter ;
  js_string *name ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 193
  counter = 0;
#line 196
  tmp = mara_goodjs(keyword);
#line 196
  if (tmp == -1) {
#line 197
    return (-1);
  }
#line 199
  name = js_create(256U, 1U);
#line 199
  if ((unsigned long )name == (unsigned long )((js_string *)0)) {
#line 200
    return (-1);
  }
#line 202
  js_set_encode(name, 3);
#line 204
  while (counter < 55) {
#line 205
    tmp___0 = js_qstr2js(name, keywords[counter]);
#line 205
    if (tmp___0 == -1) {
#line 206
      js_destroy(name);
#line 207
      return (-1);
    }
#line 209
    js_set_encode(name, 3);
#line 211
    js_set_encode(keyword, 3);
#line 212
    tmp___1 = js_issame(keyword, name);
#line 212
    if (tmp___1) {
#line 213
      js_destroy(name);
#line 214
      return (counter);
    }
#line 216
    counter ++;
  }
#line 219
  js_destroy(name);
#line 220
  return (-2);
}
}
#line 229 "ParseMaraRc.c"
int num2keyword(int num , js_string *keyword ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 230
  tmp = mara_goodjs(keyword);
#line 230
  if (tmp == -1) {
#line 231
    return (-1);
  }
#line 233
  if (num < 0) {
#line 234
    return (-1);
  } else
#line 233
  if (num >= 55) {
#line 234
    return (-1);
  }
#line 236
  tmp___0 = js_qstr2js(keyword, keywords[num]);
#line 236
  return (tmp___0);
}
}
#line 244 "ParseMaraRc.c"
int init_kvars(void) 
{ int counter ;
  js_string *tmp ;

  {
#line 246
  counter = 0;
#line 246
  while (counter < 55) {
#line 247
    tmp = js_create(256U, 1U);
#line 247
    kvar[counter] = tmp;
#line 247
    if ((unsigned long )tmp == (unsigned long )((js_string *)0)) {
#line 248
      return (-1);
    }
#line 249
    js_set_encode(kvar[counter], 3);
#line 246
    counter ++;
  }
#line 251
  return (1);
}
}
#line 263 "ParseMaraRc.c"
int read_kvar(js_string *name , js_string *value___0 ) 
{ int num ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 268
  tmp = mara_goodjs(name);
#line 268
  if (tmp == -1) {
#line 269
    return (-1);
  }
#line 270
  tmp___0 = mara_goodjs(value___0);
#line 270
  if (tmp___0 == -1) {
#line 271
    return (-1);
  }
#line 274
  num = keyword2num(name);
#line 275
  if (num == -1) {
#line 276
    return (-1);
  }
#line 279
  if (num == -2) {
#line 280
    return (num);
  }
#line 283
  tmp___1 = js_copy(kvar[num], value___0);
#line 283
  if (tmp___1 == -1) {
#line 284
    return (-1);
  }
#line 287
  tmp___2 = js_length(kvar[num]);
#line 287
  if (tmp___2 == 0) {
#line 288
    return (0);
  }
#line 290
  return (1);
}
}
#line 300 "ParseMaraRc.c"
int write_kvar(js_string *name , js_string *value___0 , int is_plus ) 
{ int num ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 303
  num = keyword2num(name);
#line 306
  tmp = mara_goodjs(name);
#line 306
  if (tmp == -1) {
#line 307
    return (-1);
  }
#line 308
  tmp___0 = mara_goodjs(value___0);
#line 308
  if (tmp___0 == -1) {
#line 309
    return (-1);
  }
#line 310
  if (num == -1) {
#line 311
    return (-1);
  }
#line 314
  if (num == -2) {
#line 315
    return (num);
  }
#line 318
  if (is_plus != 1) {
#line 319
    tmp___1 = js_copy(value___0, kvar[num]);
#line 319
    if (tmp___1 == -1) {
#line 320
      return (-1);
    }
  } else {
#line 323
    tmp___2 = is_numeric_js(kvar[num]);
#line 323
    if (tmp___2 == 1) {
#line 324
      return (-5);
    }
#line 326
    tmp___3 = js_length(kvar[num]);
#line 326
    if (tmp___3 == 0) {
#line 327
      return (-4);
    }
#line 329
    tmp___4 = js_append(value___0, kvar[num]);
#line 329
    if (tmp___4 == -1) {
#line 330
      return (-1);
    }
  }
#line 334
  return (1);
}
}
#line 342 "ParseMaraRc.c"
char *dkeywords[6]  = {      (char *)"csv1",      (char *)"csv2",      (char *)"root_servers",      (char *)"upstream_servers", 
        (char *)"ipv4_alias",      (char *)"future"};
#line 349 "ParseMaraRc.c"
mhash *dvar[6]  ;
#line 356 "ParseMaraRc.c"
mhash *dvar_raw(int index___0 ) 
{ 

  {
#line 357
  if (index___0 < 0) {
#line 358
    return ((mhash *)0);
  } else
#line 357
  if (index___0 > 6) {
#line 358
    return ((mhash *)0);
  }
#line 359
  return (dvar[index___0]);
}
}
#line 369 "ParseMaraRc.c"
int dq_keyword2n(char *in ) 
{ int counter ;
  int tmp ;

  {
#line 371
  counter = 0;
#line 371
  while (counter < 6) {
#line 372
    tmp = strncmp((char const   *)in, (char const   *)dkeywords[counter], (size_t )128);
#line 372
    if (! tmp) {
#line 373
      return (counter);
    }
#line 371
    counter ++;
  }
#line 375
  return (-2);
}
}
#line 385 "ParseMaraRc.c"
int dkeyword2num(js_string *keyword ) 
{ int counter ;
  js_string *name ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 386
  counter = 0;
#line 389
  tmp = mara_goodjs(keyword);
#line 389
  if (tmp == -1) {
#line 390
    return (-1);
  }
#line 392
  name = js_create(256U, 1U);
#line 392
  if ((unsigned long )name == (unsigned long )((js_string *)0)) {
#line 393
    return (-1);
  }
#line 395
  js_set_encode(name, 3);
#line 397
  while (counter < 6) {
#line 398
    tmp___0 = js_qstr2js(name, dkeywords[counter]);
#line 398
    if (tmp___0 == -1) {
#line 399
      js_destroy(name);
#line 400
      return (-1);
    }
#line 402
    tmp___1 = js_issame(keyword, name);
#line 402
    if (tmp___1) {
#line 403
      js_destroy(name);
#line 404
      return (counter);
    }
#line 406
    counter ++;
  }
#line 409
  js_destroy(name);
#line 410
  return (-2);
}
}
#line 419 "ParseMaraRc.c"
int num2dkeyword(int num , js_string *keyword ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 420
  tmp = mara_goodjs(keyword);
#line 420
  if (tmp == -1) {
#line 421
    return (-1);
  }
#line 423
  if (num < 0) {
#line 424
    return (-1);
  } else
#line 423
  if (num >= 6) {
#line 424
    return (-1);
  }
#line 426
  tmp___0 = js_qstr2js(keyword, dkeywords[num]);
#line 426
  return (tmp___0);
}
}
#line 434 "ParseMaraRc.c"
int init_dvars(void) 
{ int counter ;

  {
#line 437
  counter = 0;
#line 437
  while (counter < 6) {
#line 438
    dvar[counter] = (mhash *)0;
#line 437
    counter ++;
  }
#line 440
  return (1);
}
}
#line 448 "ParseMaraRc.c"
int new_dvar(js_string *name ) 
{ int num ;
  mhash *tmp ;

  {
#line 450
  num = dkeyword2num(name);
#line 451
  if ((unsigned long )dvar[num] != (unsigned long )((mhash *)0)) {
#line 452
    return (-1);
  } else
#line 451
  if (num < 0) {
#line 452
    return (-1);
  } else
#line 451
  if (num > 6) {
#line 452
    return (-1);
  }
#line 453
  tmp = mhash_create(7);
#line 453
  dvar[num] = tmp;
#line 453
  if ((unsigned long )tmp == (unsigned long )((mhash *)0)) {
#line 454
    return (-1);
  }
#line 456
  return (1);
}
}
#line 465 "ParseMaraRc.c"
int read_dvar(js_string *name , js_string *key___0 , js_string *value___0 ) 
{ int num ;
  js_string *place ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 469
  num = dkeyword2num(name);
#line 472
  tmp = mara_goodjs(name);
#line 472
  if (tmp == -1) {
#line 473
    return (-1);
  }
#line 474
  tmp___0 = mara_goodjs(key___0);
#line 474
  if (tmp___0 == -1) {
#line 475
    return (-1);
  }
#line 476
  tmp___1 = mara_goodjs(value___0);
#line 476
  if (tmp___1 == -1) {
#line 477
    return (-1);
  }
#line 478
  if (num == -1) {
#line 479
    return (-1);
  }
#line 480
  if ((unsigned long )dvar[num] == (unsigned long )((mhash *)0)) {
#line 481
    return (-1);
  } else
#line 480
  if (num < 0) {
#line 481
    return (-1);
  } else
#line 480
  if (num > 6) {
#line 481
    return (-1);
  }
#line 484
  if (num == -2) {
#line 485
    return (num);
  }
#line 488
  place = mhash_get_js(dvar[num], key___0);
#line 493
  if ((unsigned long )place == (unsigned long )((js_string *)0)) {
#line 494
    return (-1);
  }
#line 497
  tmp___2 = js_copy(place, value___0);
#line 497
  if (tmp___2 == -1) {
#line 498
    return (-1);
  }
#line 500
  return (1);
}
}
#line 515 "ParseMaraRc.c"
int write_dvar(js_string *name , js_string *key___0 , js_string *value___0 , int is_plus ) 
{ int num ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int y ;
  int z ;
  js_string *tmp___2 ;
  int tmp___3 ;
  js_string *see ;
  js_string *base ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 520
  num = dkeyword2num(name);
#line 523
  tmp = mara_goodjs(name);
#line 523
  if (tmp == -1) {
#line 524
    return (-1);
  }
#line 525
  tmp___0 = mara_goodjs(key___0);
#line 525
  if (tmp___0 == -1) {
#line 526
    return (-1);
  }
#line 527
  tmp___1 = mara_goodjs(value___0);
#line 527
  if (tmp___1 == -1) {
#line 528
    return (-1);
  }
#line 529
  if (num == -1) {
#line 530
    return (-1);
  }
#line 531
  if ((unsigned long )dvar[num] == (unsigned long )((mhash *)0)) {
#line 532
    return (-6);
  }
#line 533
  if (num < 0) {
#line 534
    return (-1);
  } else
#line 533
  if (num > 6) {
#line 534
    return (-1);
  }
#line 537
  if (num == -2) {
#line 538
    return (num);
  }
#line 542
  if (num <= 3) {
#line 544
    y = 0;
#line 545
    z = 0;
#line 545
    while ((unsigned int )z < key___0->unit_count) {
#line 546
      if ((int )*(key___0->string + z) <= 90) {
#line 546
        if ((int )*(key___0->string + z) >= 65) {
#line 547
          y = 1;
#line 548
          *(key___0->string + z) = (unsigned char )((int )*(key___0->string + z) + 32);
        }
      }
#line 545
      z ++;
    }
#line 551
    if (y == 1) {
#line 552
      if (num <= 1) {
#line 553
        printf("csv%d zone name ", num + 1);
      } else
#line 554
      if (num == 2) {
#line 555
        printf("root_servers name ");
      } else
#line 556
      if (num == 3) {
#line 557
        printf("upstream_servers name ");
      } else {
#line 559
        printf("unknown num %d name ", num);
      }
#line 561
      show_esc_stdout(key___0);
#line 562
      printf(" had upper-case letters.  Converted.\n");
    }
  }
#line 567
  tmp___2 = mhash_get_js(dvar[num], key___0);
#line 567
  if ((unsigned long )tmp___2 != (unsigned long )((js_string *)0)) {
#line 567
    if (is_plus != 1) {
#line 568
      return (-3);
    }
  }
#line 571
  if (is_plus != 1) {
#line 572
    tmp___3 = mhash_put_js(dvar[num], key___0, value___0);
#line 572
    if (tmp___3 == -1) {
#line 573
      return (-1);
    }
  } else {
#line 576
    base = mhash_get_js(dvar[num], key___0);
#line 576
    if ((unsigned long )base == (unsigned long )((js_string *)0)) {
#line 577
      return (-4);
    }
#line 579
    tmp___4 = is_numeric_js(base);
#line 579
    if (tmp___4 == 1) {
#line 580
      return (-5);
    }
#line 582
    see = js_create(256U, 1U);
#line 582
    if ((unsigned long )see == (unsigned long )((js_string *)0)) {
#line 583
      return (-1);
    }
#line 585
    tmp___5 = js_set_encode(see, 3);
#line 585
    if (tmp___5 == -1) {
#line 586
      return (-1);
    }
#line 588
    tmp___6 = js_copy(base, see);
#line 588
    if (tmp___6 == -1) {
#line 589
      return (-1);
    }
#line 591
    tmp___7 = js_append(value___0, see);
#line 591
    if (tmp___7 == -1) {
#line 592
      js_destroy(see);
#line 593
      return (-1);
    }
#line 595
    tmp___8 = js_copy(see, value___0);
#line 595
    if (tmp___8 == -1) {
#line 596
      js_destroy(see);
#line 597
      return (-1);
    }
#line 599
    js_destroy(see);
#line 600
    tmp___9 = mhash_undef(dvar[num], key___0);
#line 600
    see = (js_string *)tmp___9;
#line 600
    if ((unsigned long )see == (unsigned long )((js_string *)0)) {
#line 601
      return (-1);
    }
#line 603
    js_destroy(see);
#line 604
    tmp___10 = mhash_put_js(dvar[num], key___0, value___0);
#line 604
    if (tmp___10 == -1) {
#line 605
      return (-1);
    }
  }
#line 610
  tmp___11 = mhash_autogrow(dvar[num]);
#line 610
  return (tmp___11);
}
}
#line 631
int parseline(js_string *line___0 , js_string *var___0 , js_string *key___0 , js_string *value___0 ,
              int *do_plus ) ;
#line 631 "ParseMaraRc.c"
static js_string *quotes  =    (js_string *)0;
#line 631 "ParseMaraRc.c"
static js_string *alphanumeric  =    (js_string *)0;
#line 631 "ParseMaraRc.c"
static js_string *numbers  =    (js_string *)0;
#line 631 "ParseMaraRc.c"
static js_string *equals  =    (js_string *)0;
#line 631 "ParseMaraRc.c"
static js_string *plusq  =    (js_string *)0;
#line 631 "ParseMaraRc.c"
static js_string *hashq  =    (js_string *)0;
#line 631 "ParseMaraRc.c"
static js_string *bslashq  =    (js_string *)0;
#line 631 "ParseMaraRc.c"
static js_string *allq  =    (js_string *)0;
#line 631 "ParseMaraRc.c"
static js_string *leftq  =    (js_string *)0;
#line 631 "ParseMaraRc.c"
static js_string *rightq  =    (js_string *)0;
#line 631 "ParseMaraRc.c"
static js_string *cleftq  =    (js_string *)0;
#line 631 "ParseMaraRc.c"
static js_string *crightq  =    (js_string *)0;
#line 631 "ParseMaraRc.c"
static js_string *blankq  =    (js_string *)0;
#line 628 "ParseMaraRc.c"
int parseline(js_string *line___0 , js_string *var___0 , js_string *key___0 , js_string *value___0 ,
              int *do_plus ) 
{ int quote1 ;
  int quote2 ;
  int quote3 ;
  int quote4 ;
  int varstart ;
  int varend ;
  int valstart ;
  int valend ;
  int equalp ;
  int hashp ;
  int tempp ;
  int ret ;
  char quote ;
  char plus ;
  char equal ;
  char hash ;
  char left ;
  char right ;
  char cleft ;
  char cright ;
  char bslash ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int q ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 642
  ret = 1;
#line 643
  quote = (char )'\"';
#line 644
  plus = (char )'+';
#line 645
  equal = (char )'=';
#line 646
  hash = (char )'#';
#line 647
  left = (char )'[';
#line 648
  right = (char )']';
#line 649
  cleft = (char )'{';
#line 650
  cright = (char )'}';
#line 651
  bslash = (char )'\\';
#line 653
  if ((unsigned long )do_plus != (unsigned long )((int *)0)) {
#line 654
    *do_plus = 0;
  }
#line 657
  tmp = mara_goodjs(line___0);
#line 657
  if (tmp == -1) {
#line 658
    return (-1);
  }
#line 659
  tmp___0 = mara_goodjs(var___0);
#line 659
  if (tmp___0 == -1) {
#line 660
    return (-1);
  }
#line 661
  tmp___1 = mara_goodjs(key___0);
#line 661
  if (tmp___1 == -1) {
#line 662
    return (-1);
  }
#line 663
  tmp___2 = mara_goodjs(value___0);
#line 663
  if (tmp___2 == -1) {
#line 664
    return (-1);
  }
#line 666
  if ((unsigned long )quotes == (unsigned long )((js_string *)0)) {
#line 667
    quotes = js_create(256U, 1U);
#line 667
    if ((unsigned long )quotes == (unsigned long )((js_string *)0)) {
#line 668
      return (-1);
    }
  }
#line 669
  if ((unsigned long )numbers == (unsigned long )((js_string *)0)) {
#line 670
    numbers = js_create(256U, 1U);
#line 670
    if ((unsigned long )numbers == (unsigned long )((js_string *)0)) {
#line 671
      return (-1);
    }
  }
#line 672
  if ((unsigned long )alphanumeric == (unsigned long )((js_string *)0)) {
#line 673
    alphanumeric = js_create(256U, 1U);
#line 673
    if ((unsigned long )alphanumeric == (unsigned long )((js_string *)0)) {
#line 674
      return (-1);
    }
  }
#line 675
  if ((unsigned long )plusq == (unsigned long )((js_string *)0)) {
#line 676
    plusq = js_create(256U, 1U);
#line 676
    if ((unsigned long )plusq == (unsigned long )((js_string *)0)) {
#line 677
      return (-1);
    }
  }
#line 679
  if ((unsigned long )equals == (unsigned long )((js_string *)0)) {
#line 680
    equals = js_create(256U, 1U);
#line 680
    if ((unsigned long )equals == (unsigned long )((js_string *)0)) {
#line 681
      return (-1);
    }
  }
#line 682
  if ((unsigned long )hashq == (unsigned long )((js_string *)0)) {
#line 683
    hashq = js_create(256U, 1U);
#line 683
    if ((unsigned long )hashq == (unsigned long )((js_string *)0)) {
#line 684
      return (-1);
    }
  }
#line 685
  if ((unsigned long )bslashq == (unsigned long )((js_string *)0)) {
#line 686
    bslashq = js_create(256U, 1U);
#line 686
    if ((unsigned long )bslashq == (unsigned long )((js_string *)0)) {
#line 687
      return (-1);
    }
  }
#line 688
  if ((unsigned long )allq == (unsigned long )((js_string *)0)) {
#line 689
    allq = js_create(256U, 1U);
#line 689
    if ((unsigned long )allq == (unsigned long )((js_string *)0)) {
#line 690
      return (-1);
    }
  }
#line 691
  if ((unsigned long )leftq == (unsigned long )((js_string *)0)) {
#line 692
    leftq = js_create(256U, 1U);
#line 692
    if ((unsigned long )leftq == (unsigned long )((js_string *)0)) {
#line 693
      return (-1);
    }
  }
#line 694
  if ((unsigned long )rightq == (unsigned long )((js_string *)0)) {
#line 695
    rightq = js_create(256U, 1U);
#line 695
    if ((unsigned long )rightq == (unsigned long )((js_string *)0)) {
#line 696
      return (-1);
    }
  }
#line 697
  if ((unsigned long )cleftq == (unsigned long )((js_string *)0)) {
#line 698
    cleftq = js_create(256U, 1U);
#line 698
    if ((unsigned long )cleftq == (unsigned long )((js_string *)0)) {
#line 699
      return (-1);
    }
  }
#line 700
  if ((unsigned long )crightq == (unsigned long )((js_string *)0)) {
#line 701
    crightq = js_create(256U, 1U);
#line 701
    if ((unsigned long )crightq == (unsigned long )((js_string *)0)) {
#line 702
      return (-1);
    }
  }
#line 703
  if ((unsigned long )blankq == (unsigned long )((js_string *)0)) {
#line 704
    blankq = js_create(256U, 1U);
#line 704
    if ((unsigned long )blankq == (unsigned long )((js_string *)0)) {
#line 705
      return (-1);
    }
  }
#line 708
  js_str2js(equals, & equal, 1, 1);
#line 709
  js_str2js(plusq, & plus, 1, 1);
#line 710
  js_str2js(hashq, & hash, 1, 1);
#line 711
  js_str2js(bslashq, & bslash, 1, 1);
#line 712
  js_str2js(leftq, & left, 1, 1);
#line 713
  js_str2js(rightq, & right, 1, 1);
#line 714
  js_str2js(cleftq, & cleft, 1, 1);
#line 715
  js_str2js(crightq, & cright, 1, 1);
#line 716
  js_set_encode(alphanumeric, 3);
#line 717
  js_set_encode(numbers, 3);
#line 718
  js_set_encode(blankq, 3);
#line 719
  js_an_chars(alphanumeric);
#line 720
  js_numbers(numbers);
#line 721
  js_space_chars(blankq);
#line 723
  js_set_encode(allq, 3);
#line 724
  js_set_encode(quotes, 3);
#line 725
  js_space_chars(allq);
#line 727
  js_newline_chars(quotes);
#line 728
  js_append(quotes, allq);
#line 729
  js_append(quotes, blankq);
#line 731
  js_str2js(quotes, & quote, 1, 1);
#line 732
  js_append(quotes, allq);
#line 733
  js_append(equals, allq);
#line 734
  js_append(plusq, allq);
#line 735
  js_append(hashq, allq);
#line 736
  js_append(bslashq, allq);
#line 737
  js_append(alphanumeric, allq);
#line 738
  js_append(leftq, allq);
#line 739
  js_append(rightq, allq);
#line 740
  js_append(cleftq, allq);
#line 741
  js_append(crightq, allq);
#line 744
  js_qstr2js(var___0, (char *)"");
#line 745
  js_qstr2js(value___0, (char *)"");
#line 747
  js_qstr2js(key___0, (char *)"NOTHASH");
#line 750
  quote4 = -2;
#line 750
  quote3 = quote4;
#line 750
  quote2 = quote3;
#line 750
  quote1 = quote2;
#line 756
  hashp = js_match(hashq, line___0);
#line 756
  if (hashp == -1) {
#line 757
    return (-1);
  }
#line 758
  tempp = js_notmatch(blankq, line___0);
#line 759
  if (tempp == -1) {
#line 760
    return (-1);
  }
#line 761
  if (tempp == -2) {
#line 762
    return (1);
  } else
#line 761
  if (tempp == hashp) {
#line 762
    return (1);
  }
#line 765
  quote1 = js_match(quotes, line___0);
#line 765
  if (quote1 == -1) {
#line 766
    return (-1);
  }
#line 767
  if (quote1 != -2) {
#line 768
    quote2 = js_match_offset(quotes, line___0, quote1 + 1);
#line 769
    if (quote2 != -2) {
#line 770
      quote3 = js_match_offset(quotes, line___0, quote2 + 1);
#line 771
      if (quote3 != -2) {
#line 772
        quote4 = js_match_offset(quotes, line___0, quote3 + 1);
#line 772
        if (quote4 == -2) {
#line 773
          js_qstr2js(var___0, (char *)"ERROR");
#line 774
          js_qstr2js(value___0, (char *)"2nd quoted expression needs to be unquoted");
#line 776
          return (1);
        }
      }
    } else {
#line 781
      js_qstr2js(var___0, (char *)"ERROR");
#line 782
      js_qstr2js(value___0, (char *)"Quoted expression needs to be unquoted");
#line 783
      return (1);
    }
  }
#line 788
  hashp = js_match(hashq, line___0);
#line 788
  if (hashp == -1) {
#line 789
    return (-1);
  }
#line 791
  if (hashp > quote1) {
#line 791
    if (hashp < quote2) {
#line 792
      hashp = js_match_offset(hashq, line___0, quote2);
    }
  }
#line 794
  if (hashp > quote3) {
#line 794
    if (hashp < quote4) {
#line 795
      hashp = js_match_offset(hashq, line___0, quote4);
    }
  }
#line 797
  if (hashp == -2) {
#line 798
    tmp___3 = js_length(line___0);
#line 798
    hashp = tmp___3 + 1;
  }
#line 800
  if (quote1 > hashp) {
#line 801
    quote4 = -2;
#line 801
    quote3 = quote4;
#line 801
    quote2 = quote3;
#line 801
    quote1 = quote2;
  }
#line 802
  if (quote3 > hashp) {
#line 803
    quote4 = -2;
#line 803
    quote3 = quote4;
  }
#line 807
  tempp = js_notmatch(allq, line___0);
#line 807
  if (tempp == -1) {
#line 808
    return (-1);
  }
#line 812
  if (tempp != -2) {
#line 812
    if (tempp < hashp) {
#line 812
      if (tempp < quote1) {
#line 812
        goto _L;
      } else
#line 812
      if (tempp > quote2) {
        _L: /* CIL Label */ 
#line 812
        if (tempp < quote3) {
#line 814
          js_qstr2js(var___0, (char *)"ERROR");
#line 815
          js_qstr2js(value___0, (char *)"Unknown character in line");
#line 816
          return (1);
        } else
#line 812
        if (tempp > quote4) {
#line 814
          js_qstr2js(var___0, (char *)"ERROR");
#line 815
          js_qstr2js(value___0, (char *)"Unknown character in line");
#line 816
          return (1);
        }
      }
    }
  }
#line 820
  if (quote4 != -2) {
#line 821
    tempp = js_match_offset(quotes, line___0, quote4 + 1);
#line 821
    if (tempp == -1) {
#line 822
      return (-1);
    }
#line 823
    if (tempp != -2) {
#line 823
      if (tempp < hashp) {
#line 824
        js_qstr2js(var___0, (char *)"ERROR");
#line 825
        js_qstr2js(value___0, (char *)"Maximum allowed quotes on a line is four");
#line 826
        return (1);
      }
    }
  }
#line 831
  equalp = js_match(equals, line___0);
#line 831
  if (equalp == -1) {
#line 832
    return (-1);
  }
#line 834
  tempp = js_match(plusq, line___0);
#line 834
  if (tempp == -1) {
#line 835
    return (-1);
  }
#line 836
  if (tempp != -2) {
#line 836
    if (tempp != equalp - 1) {
#line 837
      js_qstr2js(var___0, (char *)"ERROR");
#line 838
      js_qstr2js(value___0, (char *)"+ only allowed in += form");
#line 839
      return (1);
    }
  }
#line 841
  if (tempp == equalp - 1) {
#line 841
    if ((unsigned long )do_plus != (unsigned long )((int *)0)) {
#line 842
      *do_plus = 1;
    }
  }
#line 843
  tmp___4 = js_match_offset(plusq, line___0, equalp);
#line 843
  if (tmp___4 != -2) {
#line 844
    js_qstr2js(var___0, (char *)"ERROR");
#line 845
    js_qstr2js(value___0, (char *)"+ only allowed once on line");
#line 846
    return (1);
  }
#line 850
  varend = -2;
#line 850
  varstart = varend;
#line 851
  varstart = js_match(alphanumeric, line___0);
#line 851
  if (varstart == -1) {
#line 852
    return (-1);
  }
#line 853
  if (varstart != -2) {
#line 853
    if (varstart < hashp) {
#line 854
      varend = varstart;
#line 855
      while (1) {
#line 855
        tmp___5 = js_match_offset(alphanumeric, line___0, varend + 1);
#line 855
        if (! (tmp___5 == varend + 1)) {
#line 855
          break;
        }
#line 856
        varend ++;
      }
    } else {
#line 853
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 858
  if (varstart >= hashp) {
#line 859
    varstart = -2;
  }
#line 861
  if (varstart > quote1) {
#line 861
    if (varend < quote2) {
#line 863
      js_qstr2js(var___0, (char *)"ERROR");
#line 864
      js_qstr2js(value___0, (char *)"Variable name can not be in quotes");
#line 865
      return (1);
    } else {
#line 861
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 861
  if (varstart > quote3) {
#line 861
    if (varend < quote4) {
#line 863
      js_qstr2js(var___0, (char *)"ERROR");
#line 864
      js_qstr2js(value___0, (char *)"Variable name can not be in quotes");
#line 865
      return (1);
    }
  }
#line 869
  tempp = js_match(leftq, line___0);
#line 870
  if (tempp != -2) {
#line 873
    if (tempp != varend + 1) {
#line 874
      js_qstr2js(var___0, (char *)"ERROR");
#line 875
      js_qstr2js(value___0, (char *)"Left square bracket must be immediately after variable name");
#line 877
      return (1);
    }
#line 879
    if (quote1 != tempp + 1) {
#line 880
      js_qstr2js(var___0, (char *)"ERROR");
#line 881
      js_qstr2js(value___0, (char *)"Dictionary element must be in quotes");
#line 882
      return (1);
    }
#line 884
    tmp___6 = js_match_offset(leftq, line___0, tempp + 1);
#line 884
    if (tmp___6 != -2) {
#line 885
      js_qstr2js(var___0, (char *)"ERROR");
#line 886
      js_qstr2js(value___0, (char *)"Multiple left square brackets forbidden");
#line 887
      return (1);
    }
#line 889
    tmp___7 = js_match(rightq, line___0);
#line 889
    if (tmp___7 != quote2 + 1) {
#line 890
      js_qstr2js(var___0, (char *)"ERROR");
#line 891
      js_qstr2js(value___0, (char *)"Right square bracket must be after quotes");
#line 892
      return (1);
    }
#line 896
    tmp___8 = js_substr(line___0, key___0, quote1 + 1, (quote2 - quote1) - 1);
#line 896
    if (tmp___8 == -1) {
#line 897
      return (-1);
    }
#line 903
    quote1 = quote3;
#line 904
    quote2 = quote4;
#line 905
    quote4 = -2;
#line 905
    quote3 = quote4;
#line 906
    ret = 2;
  }
#line 910
  valend = -2;
#line 910
  valstart = valend;
#line 912
  if (quote1 != -2) {
#line 912
    if (quote2 != -2) {
#line 913
      valstart = quote1 + 1;
#line 914
      valend = quote2 - 1;
#line 917
      if (ret != 2) {
#line 920
        q = js_match_offset(alphanumeric, line___0, varend + 1);
#line 921
        if (q < quote1) {
#line 921
          if (q != -2) {
#line 922
            js_qstr2js(var___0, (char *)"ERROR");
#line 923
            js_qstr2js(value___0, (char *)"Second bare word found before quotes");
#line 924
            return (1);
          }
        }
      }
    } else {
#line 912
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
#line 931
    if (equalp < 0) {
#line 932
      js_qstr2js(var___0, (char *)"ERROR");
#line 933
      js_qstr2js(value___0, (char *)"Statement needs an = sign");
#line 934
      return (1);
    }
#line 936
    valstart = js_match_offset(numbers, line___0, equalp);
#line 936
    if (valstart == -1) {
#line 937
      return (-1);
    }
#line 939
    if (valstart != -2) {
#line 939
      if (valstart < hashp) {
#line 940
        valend = valstart;
#line 941
        while (1) {
#line 941
          tmp___9 = js_match_offset(alphanumeric, line___0, valend + 1);
#line 941
          if (! (tmp___9 == valend + 1)) {
#line 941
            break;
          }
#line 942
          valend ++;
        }
      } else {
#line 939
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
#line 946
      tempp = js_match_offset(cleftq, line___0, equalp);
#line 947
      if (tempp != -2) {
#line 948
        tmp___10 = js_match(crightq, line___0);
#line 948
        if (tmp___10 != tempp + 1) {
#line 949
          js_qstr2js(var___0, (char *)"ERROR");
#line 950
          js_qstr2js(value___0, (char *)"{ must be immediately followed by }");
#line 951
          return (1);
        }
#line 953
        if (ret == 1) {
#line 954
          ret = 3;
        } else {
#line 956
          js_qstr2js(var___0, (char *)"ERROR");
#line 957
          js_qstr2js(value___0, (char *)"Dictionary elements pointing to dictionaries unsupported");
#line 959
          return (1);
        }
      } else {
#line 963
        js_qstr2js(var___0, (char *)"ERROR");
#line 964
        js_qstr2js(value___0, (char *)"Something must follow =");
#line 965
        return (1);
      }
    }
  }
#line 971
  tmp___11 = js_match(bslashq, line___0);
#line 971
  if (tmp___11 != -2) {
#line 972
    js_qstr2js(var___0, (char *)"ERROR");
#line 973
    js_qstr2js(value___0, (char *)"Backslash not supported yet");
#line 974
    return (1);
  }
#line 979
  if (varstart >= 0) {
#line 979
    if (varend >= varstart) {
#line 981
      if (equalp == -2) {
#line 982
        js_qstr2js(var___0, (char *)"ERROR");
#line 983
        js_qstr2js(value___0, (char *)"Variable name needs an = sign");
#line 984
        return (1);
      }
#line 987
      if (varstart > equalp) {
#line 988
        js_qstr2js(var___0, (char *)"ERROR");
#line 989
        js_qstr2js(value___0, (char *)"Equals sign before variable name");
#line 990
        return (1);
      }
#line 992
      tmp___12 = js_substr(line___0, var___0, varstart, (varend - varstart) + 1);
#line 992
      if (tmp___12 == -1) {
#line 993
        return (-1);
      }
    }
  }
#line 996
  if (valstart >= 0) {
#line 996
    if (valend >= valstart) {
#line 998
      if (equalp > quote1) {
#line 998
        if (equalp < quote2) {
#line 999
          js_qstr2js(var___0, (char *)"ERROR");
#line 1000
          js_qstr2js(value___0, (char *)"Quoted string not preceeded by equals sign");
#line 1001
          return (1);
        }
      }
#line 1004
      if (valstart < equalp) {
#line 1005
        js_qstr2js(var___0, (char *)"ERROR");
#line 1006
        js_qstr2js(value___0, (char *)"Equals sign after variable value");
#line 1007
        return (1);
      }
#line 1009
      tmp___13 = js_substr(line___0, value___0, valstart, (valend - valstart) + 1);
#line 1009
      if (tmp___13 == -1) {
#line 1010
        return (-1);
      }
    }
  }
#line 1014
  js_space_chars(allq);
#line 1015
  js_append(quotes, allq);
#line 1016
  js_newline_chars(quotes);
#line 1017
  js_append(quotes, allq);
#line 1018
  tempp = js_notmatch_offset(allq, line___0, valend + 1);
#line 1019
  if (tempp < hashp) {
#line 1019
    if (tempp != -2) {
#line 1020
      js_qstr2js(var___0, (char *)"ERROR");
#line 1021
      js_qstr2js(value___0, (char *)"Unexpected character near end of line");
#line 1022
      return (1);
    }
  }
#line 1025
  return (ret);
}
}
#line 1033 "ParseMaraRc.c"
int find_mararc(js_string *out ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 1036
  tmp = mara_goodjs(out);
#line 1036
  if (tmp == -1) {
#line 1037
    return (-1);
  }
#line 1040
  tmp___0 = js_qstr2js(out, (char *)"/etc/mararc");
#line 1040
  return (tmp___0);
}
}
#line 1053 "ParseMaraRc.c"
static js_string *line  =    (js_string *)0;
#line 1054 "ParseMaraRc.c"
static js_string *var  =    (js_string *)0;
#line 1055 "ParseMaraRc.c"
static js_string *key  =    (js_string *)0;
#line 1056 "ParseMaraRc.c"
static js_string *value  =    (js_string *)0;
#line 1057 "ParseMaraRc.c"
static js_string *tstr  =    (js_string *)0;
#line 1065 "ParseMaraRc.c"
static js_file *file  =    (js_file *)0;
#line 1052 "ParseMaraRc.c"
int read_mararc(js_string *fileloc , js_string *errorstr , int *errorret ) 
{ int error ;
  int linenum ;
  int command ;
  int tnum ;
  int is_plus ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int result ;
  int tmp___3 ;
  int tmp___4 ;
  int result___0 ;
  int tmp___5 ;

  {
#line 1059
  error = 0;
#line 1060
  linenum = 1;
#line 1062
  is_plus = 0;
#line 1067
  *errorret = -1;
#line 1070
  if ((unsigned long )line == (unsigned long )((js_string *)0)) {
#line 1071
    line = js_create(256U, 1U);
#line 1071
    if ((unsigned long )line == (unsigned long )((js_string *)0)) {
#line 1072
      js_qstr2js(errorstr, (char *)"Fatal error creating js_string");
#line 1073
      return (-1);
    }
  }
#line 1075
  if ((unsigned long )var == (unsigned long )((js_string *)0)) {
#line 1076
    var = js_create(256U, 1U);
#line 1076
    if ((unsigned long )var == (unsigned long )((js_string *)0)) {
#line 1077
      js_qstr2js(errorstr, (char *)"Fatal error creating js_string");
#line 1078
      return (-1);
    }
  }
#line 1080
  if ((unsigned long )key == (unsigned long )((js_string *)0)) {
#line 1081
    key = js_create(256U, 1U);
#line 1081
    if ((unsigned long )key == (unsigned long )((js_string *)0)) {
#line 1082
      js_qstr2js(errorstr, (char *)"Fatal error creating js_string");
#line 1083
      return (-1);
    }
  }
#line 1085
  if ((unsigned long )value == (unsigned long )((js_string *)0)) {
#line 1086
    value = js_create(256U, 1U);
#line 1086
    if ((unsigned long )value == (unsigned long )((js_string *)0)) {
#line 1087
      js_qstr2js(errorstr, (char *)"Fatal error creating js_string");
#line 1088
      return (-1);
    }
  }
#line 1090
  if ((unsigned long )tstr == (unsigned long )((js_string *)0)) {
#line 1091
    tstr = js_create(256U, 1U);
#line 1091
    if ((unsigned long )tstr == (unsigned long )((js_string *)0)) {
#line 1092
      js_qstr2js(errorstr, (char *)"Fatal error creating js_string");
#line 1093
      return (-1);
    }
  }
#line 1095
  if ((unsigned long )file == (unsigned long )((js_file *)0)) {
#line 1096
    tmp = js_alloc(1, (int )sizeof(js_file ));
#line 1096
    file = (js_file *)tmp;
#line 1096
    if ((unsigned long )file == (unsigned long )((js_file *)0)) {
#line 1097
      js_qstr2js(errorstr, (char *)"Fatal error creating file");
#line 1098
      return (-1);
    }
  }
#line 1102
  js_qstr2js(errorstr, (char *)"");
#line 1103
  js_set_encode(line, 3);
#line 1104
  js_set_encode(var, 3);
#line 1105
  js_set_encode(key, 3);
#line 1106
  js_set_encode(value, 3);
#line 1107
  js_set_encode(tstr, 3);
#line 1109
  init_dvars();
#line 1110
  init_kvars();
#line 1113
  tmp___0 = js_open_read(fileloc, file);
#line 1113
  if (tmp___0 == -1) {
#line 1114
    *errorret = -1;
#line 1115
    js_qstr2js(errorstr, (char *)"Could not open mararc file at ");
#line 1116
    js_append(fileloc, errorstr);
#line 1117
    return (1);
  }
#line 1119
  while (1) {
#line 1119
    tmp___5 = js_buf_eof(file);
#line 1119
    if (tmp___5) {
#line 1119
      break;
    }
#line 1120
    tmp___1 = js_buf_getline(file, line);
#line 1120
    if (tmp___1 <= -1) {
#line 1121
      js_qstr2js(errorstr, (char *)"Fatal error calling js_buf_getline");
#line 1122
      js_close(file);
#line 1123
      return (-1);
    }
#line 1125
    command = parseline(line, var, key, value, & is_plus);
#line 1125
    if (command == -1) {
#line 1126
      js_qstr2js(errorstr, (char *)"Fatal error calling parseline");
#line 1127
      js_close(file);
#line 1128
      return (-1);
    }
#line 1130
    if (command == 2) {
#line 1130
      if (! error) {
#line 1132
        tnum = dkeyword2num(var);
#line 1133
        if (tnum == -1) {
#line 1134
          js_qstr2js(errorstr, (char *)"Fatal error calling keyword2num");
#line 1135
          js_close(file);
#line 1136
          return (-1);
        }
#line 1138
        if (tnum == -2) {
#line 1140
          js_qstr2js(tstr, (char *)"ERROR");
#line 1141
          tmp___2 = js_issame(tstr, var);
#line 1141
          if (tmp___2) {
#line 1142
            if (! error) {
#line 1143
              error = linenum;
#line 1144
              *errorret = error;
#line 1145
              js_copy(value, errorstr);
            }
          }
        } else
#line 1149
        if (! error) {
#line 1151
          result = write_dvar(var, key, value, is_plus);
#line 1152
          if (result == -3) {
#line 1154
            printf("%s", "Fatal error: ");
#line 1155
            js_show_stdout(var);
#line 1156
            printf("%s", "[\"");
#line 1157
            js_show_stdout(key);
#line 1158
            printf("%s", "\"]");
#line 1159
            printf("%s", " is declared more than once in mararc file.\nPlease remove or comment out this line:\n");
#line 1160
            js_show_stdout(var);
#line 1161
            printf("%s", "[\"");
#line 1162
            js_show_stdout(key);
#line 1163
            printf("%s", "\"] = \"");
#line 1164
            js_show_stdout(value);
#line 1165
            printf("%s", "\"\n");
#line 1166
            printf("Error in line %d\n", linenum);
#line 1167
            exit(1);
          } else
#line 1169
          if (result == -4) {
#line 1170
            printf("+= operator target must be previously ");
#line 1171
            printf("defined with = operator\n");
#line 1172
            printf("Error in line %d\n", linenum);
#line 1173
            exit(1);
          } else
#line 1175
          if (result == -5) {
#line 1176
            printf("+= operator target not supported for ");
#line 1177
            printf("numeric values\n");
#line 1178
            printf("Error in line %d\n", linenum);
#line 1179
            exit(1);
          } else
#line 1181
          if (result == -6) {
#line 1182
            printf("Trying to access unitizalized dictionary var.\n");
#line 1183
            printf("Try adding this line to the beginning of the ");
#line 1184
            printf("mararc file:\n\n");
#line 1185
            js_show_stdout(var);
#line 1186
            printf(" = {}\n");
#line 1187
            printf("Error in line %d\n", linenum);
#line 1188
            exit(1);
          }
        }
      } else {
#line 1130
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1192
    if (command == 1) {
#line 1192
      if (! error) {
#line 1193
        tnum = keyword2num(var);
#line 1194
        if (tnum == -2) {
#line 1196
          js_qstr2js(tstr, (char *)"ERROR");
#line 1197
          tmp___3 = js_issame(tstr, var);
#line 1197
          if (tmp___3) {
#line 1198
            if (! error) {
#line 1199
              error = linenum;
#line 1200
              *errorret = error;
#line 1201
              js_copy(value, errorstr);
            }
          }
        }
#line 1205
        if (tnum == -2) {
#line 1205
          if (var->unit_count > 0U) {
#line 1205
            if (! error) {
#line 1206
              printf("FATAL ERROR: Unknown mararc variable ");
#line 1207
              show_esc_stdout(var);
#line 1208
              printf("\nPlease look for the uncommented string \"");
#line 1209
              show_esc_stdout(var);
#line 1210
              printf("\"\nin your mararc file and remove this line.\n");
#line 1211
              printf("\nThe line this error is on looks like this:\n");
#line 1213
              if ((int )*((line->string + line->unit_count) - 1) == 10) {
#line 1213
                if (line->unit_count > 0U) {
#line 1215
                  (line->unit_count) --;
                }
              }
#line 1217
              show_esc_stdout(line);
#line 1218
              printf("\n");
#line 1219
              exit(10);
            }
          }
        }
#line 1221
        if (tnum == -1) {
#line 1222
          js_qstr2js(errorstr, (char *)"Fatal error calling keyword2num");
#line 1223
          js_close(file);
#line 1224
          return (-1);
        }
#line 1226
        if (tnum == -2) {
#line 1228
          js_qstr2js(tstr, (char *)"ERROR");
#line 1229
          tmp___4 = js_issame(tstr, var);
#line 1229
          if (tmp___4) {
#line 1230
            if (! error) {
#line 1231
              error = linenum;
#line 1232
              *errorret = error;
#line 1233
              js_copy(value, errorstr);
            }
          }
        } else
#line 1237
        if (! error) {
#line 1239
          result___0 = write_kvar(var, value, is_plus);
#line 1240
          if (result___0 == -4) {
#line 1241
            printf("+= operator target must be previously ");
#line 1242
            printf("defined with = operator\n");
#line 1243
            printf("Error in line %d\n", linenum);
#line 1244
            exit(1);
          } else
#line 1246
          if (result___0 == -5) {
#line 1247
            printf("+= operator target not supported for ");
#line 1248
            printf("numeric values\n");
#line 1249
            printf("Error in line %d\n", linenum);
#line 1250
            exit(1);
          }
        }
      } else {
#line 1192
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1254
    if (command == 3) {
#line 1255
      new_dvar(var);
    }
#line 1256
    linenum ++;
  }
#line 1259
  if (! error) {
#line 1260
    *errorret = 0;
  }
#line 1262
  js_close(file);
#line 1298
  return (1);
}
}
#line 1 "ParseCsv1.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-LcJbP9Gq.i","")
#line 110 "functions_parse.h"
int ddip_2_ip(js_string *ddip , js_string *ip , int offset ) ;
#line 44 "ParseCsv1.c"
int parse_csv1_line(js_string *line___0 , js_string *name , js_string *data , uint32_t *ttl ) 
{ js_string *pipeq ;
  js_string *hashq___0 ;
  js_string *starq ;
  js_string *blankq___0 ;
  js_string *field ;
  js_string *tstr___0 ;
  uint16_t type ;
  uint16_t preference ;
  int tempp ;
  int pipep ;
  int opipep ;
  int counter ;
  uint32_t soanum ;
  char pipe___0 ;
  char hash ;
  char star ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  unsigned int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  unsigned int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;

  {
#line 48
  pipeq = (js_string *)0;
#line 48
  hashq___0 = (js_string *)0;
#line 48
  starq = (js_string *)0;
#line 48
  blankq___0 = (js_string *)0;
#line 48
  field = (js_string *)0;
#line 58
  pipe___0 = (char )'|';
#line 59
  hash = (char )'#';
#line 60
  star = (char )'*';
#line 63
  tmp = mara_goodjs(line___0);
#line 63
  if (tmp == -1) {
#line 64
    return (-1);
  }
#line 65
  tmp___0 = js_get_encode(line___0);
#line 65
  if (tmp___0 != 2) {
#line 65
    tmp___1 = js_get_encode(line___0);
#line 65
    if (tmp___1 != 3) {
#line 67
      return (-1);
    }
  }
#line 68
  tmp___2 = mara_goodjs(name);
#line 68
  if (tmp___2 == -1) {
#line 69
    return (-1);
  }
#line 70
  tmp___3 = mara_goodjs(data);
#line 70
  if (tmp___3 == -1) {
#line 71
    return (-1);
  }
#line 72
  if ((unsigned long )ttl == (unsigned long )((uint32_t *)0)) {
#line 73
    return (-1);
  }
#line 76
  pipeq = js_create(7U, 1U);
#line 76
  if ((unsigned long )pipeq == (unsigned long )((js_string *)0)) {
#line 77
    return (-1);
  }
#line 78
  hashq___0 = js_create(7U, 1U);
#line 78
  if ((unsigned long )hashq___0 == (unsigned long )((js_string *)0)) {
#line 79
    js_destroy(pipeq);
#line 80
    return (-1);
  }
#line 82
  starq = js_create(7U, 1U);
#line 82
  if ((unsigned long )starq == (unsigned long )((js_string *)0)) {
#line 83
    js_destroy(pipeq);
#line 83
    js_destroy(hashq___0);
#line 84
    return (-1);
  }
#line 86
  tmp___4 = js_set_encode(starq, 3);
#line 86
  if (tmp___4 == -1) {
#line 87
    js_destroy(pipeq);
#line 87
    js_destroy(hashq___0);
#line 87
    js_destroy(starq);
#line 88
    return (-1);
  }
#line 90
  blankq___0 = js_create(7U, 1U);
#line 90
  if ((unsigned long )blankq___0 == (unsigned long )((js_string *)0)) {
#line 91
    js_destroy(pipeq);
#line 91
    js_destroy(hashq___0);
#line 91
    js_destroy(starq);
#line 92
    return (-1);
  }
#line 94
  tmp___5 = js_set_encode(blankq___0, 3);
#line 94
  if (tmp___5 == -1) {
#line 95
    js_destroy(pipeq);
#line 95
    js_destroy(hashq___0);
#line 95
    js_destroy(starq);
#line 96
    js_destroy(blankq___0);
#line 97
    return (-1);
  }
#line 99
  field = js_create(256U, 1U);
#line 99
  if ((unsigned long )field == (unsigned long )((js_string *)0)) {
#line 100
    js_destroy(pipeq);
#line 100
    js_destroy(hashq___0);
#line 100
    js_destroy(starq);
#line 101
    js_destroy(blankq___0);
#line 102
    return (-1);
  }
#line 106
  tmp___6 = js_str2js(pipeq, & pipe___0, 1, 1);
#line 106
  if (tmp___6 == -1) {
#line 107
    goto clean;
  }
#line 108
  tmp___7 = js_str2js(hashq___0, & hash, 1, 1);
#line 108
  if (tmp___7 == -1) {
#line 109
    goto clean;
  }
#line 110
  tmp___8 = js_space_chars(blankq___0);
#line 110
  if (tmp___8 == -1) {
#line 111
    goto clean;
  }
#line 114
  tmp___9 = js_newline_chars(starq);
#line 114
  if (tmp___9 == -1) {
#line 115
    goto clean;
  }
#line 116
  tmp___10 = js_append(starq, blankq___0);
#line 116
  if (tmp___10 == -1) {
#line 117
    goto clean;
  }
#line 121
  tempp = js_match(starq, line___0);
#line 122
  if (tempp == -1) {
#line 123
    goto clean;
  }
#line 124
  if (tempp == -2) {
#line 125
    js_qstr2js(name, (char *)"ERROR");
#line 126
    js_qstr2js(data, (char *)"No newline found in line");
#line 127
    goto error;
  }
#line 131
  tmp___11 = js_str2js(starq, & star, 1, 1);
#line 131
  if (tmp___11 == -1) {
#line 132
    goto clean;
  }
#line 134
  tmp___12 = js_qstr2js(name, (char *)"");
#line 134
  if (tmp___12 == -1) {
#line 135
    goto clean;
  }
#line 136
  tmp___13 = js_qstr2js(data, (char *)"");
#line 136
  if (tmp___13 == -1) {
#line 137
    goto clean;
  }
#line 141
  tempp = js_match(hashq___0, line___0);
#line 142
  if (tempp == -1) {
#line 143
    goto clean;
  }
#line 144
  if (tempp == 0) {
#line 145
    goto cero;
  }
#line 149
  tempp = js_notmatch(blankq___0, line___0);
#line 150
  if (tempp == -1) {
#line 151
    goto clean;
  }
#line 152
  if (tempp == -2) {
#line 153
    goto cero;
  }
#line 157
  pipep = js_match(pipeq, line___0);
#line 158
  if (pipep == -1) {
#line 159
    goto clean;
  }
#line 160
  if (tempp == -2) {
#line 161
    js_qstr2js(name, (char *)"ERROR");
#line 162
    js_qstr2js(data, (char *)"No pipe found in line");
#line 163
    goto error;
  }
#line 168
  tmp___14 = js_substr(line___0, name, 0, pipep);
#line 168
  if (tmp___14 == -1) {
#line 169
    goto clean;
  }
#line 171
  tempp = hname_2rfc1035(name);
#line 172
  if (tempp == -1) {
#line 173
    js_qstr2js(name, (char *)"ERROR");
#line 174
    js_qstr2js(data, (char *)"Error in Query syntax.");
#line 175
    goto error;
  }
#line 178
  if (tempp == -2) {
#line 179
    js_qstr2js(name, (char *)"ERROR");
#line 180
    js_qstr2js(data, (char *)"The record type is not supported");
#line 181
    goto error;
  } else
#line 178
  if (tempp > 65535) {
#line 179
    js_qstr2js(name, (char *)"ERROR");
#line 180
    js_qstr2js(data, (char *)"The record type is not supported");
#line 181
    goto error;
  }
#line 184
  type = (uint16_t )tempp;
#line 187
  opipep = pipep;
#line 188
  pipep = js_match_offset(pipeq, line___0, pipep + 1);
#line 189
  if (pipep == -1) {
#line 190
    goto clean;
  }
#line 191
  if (pipep <= opipep) {
#line 192
    js_qstr2js(name, (char *)"ERROR");
#line 193
    js_qstr2js(data, (char *)"You must have at least three fields in the RR");
#line 194
    goto error;
  }
#line 196
  *ttl = js_atoi(line___0, opipep + 1);
#line 197
  if (*ttl == 4294967295U) {
#line 198
    goto clean;
  }
#line 201
  switch (tempp) {
  case 1: 
#line 203
  tmp___15 = ddip_2_ip(line___0, data, pipep + 1);
#line 203
  if (tmp___15 == -1) {
#line 204
    js_qstr2js(name, (char *)"ERROR");
#line 205
    js_qstr2js(data, (char *)"Malformed dotted decimal IP");
#line 206
    goto error;
  }
#line 208
  break;
  case 15: 
#line 211
  tmp___16 = js_atoi(line___0, pipep + 1);
#line 211
  tempp = (int )tmp___16;
#line 212
  if (tempp < 0) {
#line 213
    js_qstr2js(name, (char *)"ERROR");
#line 214
    js_qstr2js(data, (char *)"Bad MX type");
#line 215
    goto error;
  } else
#line 212
  if (tempp > 65535) {
#line 213
    js_qstr2js(name, (char *)"ERROR");
#line 214
    js_qstr2js(data, (char *)"Bad MX type");
#line 215
    goto error;
  }
#line 217
  preference = (uint16_t )tempp;
#line 218
  tmp___17 = js_addbyte(data, (unsigned char )(((int )preference >> 8) & 255));
#line 218
  if (tmp___17 == -1) {
#line 219
    goto clean;
  }
#line 220
  tmp___18 = js_addbyte(data, (unsigned char )((int )preference & 255));
#line 220
  if (tmp___18 == -1) {
#line 221
    goto clean;
  }
#line 222
  tempp = js_match_offset(pipeq, line___0, pipep + 1);
#line 223
  if (tempp <= pipep) {
#line 224
    js_qstr2js(name, (char *)"ERROR");
#line 225
    js_qstr2js(data, (char *)"There must be four fields in the MX");
#line 226
    goto error;
  }
#line 228
  pipep = tempp;
#line 230
  tstr___0 = js_create(512U, 1U);
#line 230
  if ((unsigned long )tstr___0 == (unsigned long )((js_string *)0)) {
#line 231
    goto clean;
  }
#line 232
  tmp___19 = js_length(line___0);
#line 232
  tmp___20 = js_substr(line___0, tstr___0, pipep, (tmp___19 - pipep) - 1);
#line 232
  if (tmp___20 == -1) {
#line 234
    js_destroy(tstr___0);
#line 235
    goto clean;
  }
#line 237
  tmp___21 = js_changebyte(tstr___0, (unsigned char )'A', 0);
#line 237
  if (tmp___21 == -1) {
#line 238
    js_destroy(tstr___0);
#line 239
    goto clean;
  }
#line 241
  tempp = hname_2rfc1035(tstr___0);
#line 242
  if (tempp == -1) {
#line 243
    js_qstr2js(name, (char *)"ERROR");
#line 244
    js_qstr2js(data, (char *)"Malformed domain email");
#line 245
    js_destroy(tstr___0);
#line 246
    goto error;
  }
#line 248
  tmp___22 = js_append(tstr___0, data);
#line 248
  if (tmp___22 == -1) {
#line 249
    js_destroy(tstr___0);
#line 250
    goto clean;
  }
#line 252
  tmp___23 = js_destroy(tstr___0);
#line 252
  if (tmp___23 == -1) {
#line 253
    goto clean;
  }
#line 254
  break;
  case 2: 
#line 258
  if (name->unit_count > 2U) {
#line 258
    if ((int )*(name->string + 1) == 42) {
#line 260
      js_qstr2js(name, (char *)"ERROR");
#line 261
      js_qstr2js(data, (char *)"Star records can not be CNAME nor NS RRs");
#line 262
      goto error;
    }
  }
  case 5: 
  case 12: 
#line 267
  tmp___24 = js_length(line___0);
#line 267
  tmp___25 = js_substr(line___0, data, pipep, (tmp___24 - pipep) - 1);
#line 267
  if (tmp___25 == -1) {
#line 269
    goto clean;
  }
#line 272
  tmp___26 = js_changebyte(data, (unsigned char )'A', 0);
#line 272
  if (tmp___26 == -1) {
#line 273
    goto clean;
  }
#line 274
  tempp = hname_2rfc1035(data);
#line 275
  if (tempp == -1) {
#line 276
    js_qstr2js(name, (char *)"ERROR");
#line 277
    js_qstr2js(data, (char *)"Malformed host/domain name");
#line 278
    goto error;
  }
#line 280
  break;
  case 16: 
#line 284
  tmp___27 = js_length(line___0);
#line 284
  tempp = (tmp___27 - pipep) - 2;
#line 285
  if (tempp < 0) {
#line 286
    goto clean;
  } else
#line 285
  if (tempp > 255) {
#line 286
    goto clean;
  }
#line 287
  tmp___28 = js_substr(line___0, data, pipep, tempp + 1);
#line 287
  if (tmp___28 == -1) {
#line 289
    goto clean;
  }
#line 290
  tmp___29 = js_changebyte(data, (unsigned char )tempp, 0);
#line 290
  if (tmp___29 == -1) {
#line 291
    goto clean;
  }
#line 292
  break;
  case -3: 
#line 296
  tmp___30 = js_atoi(line___0, pipep + 1);
#line 296
  tempp = (int )tmp___30;
#line 297
  if (tempp < 0) {
#line 298
    js_qstr2js(name, (char *)"ERROR");
#line 299
    js_qstr2js(data, (char *)"Bad MX type");
#line 300
    goto error;
  } else
#line 297
  if (tempp > 65535) {
#line 298
    js_qstr2js(name, (char *)"ERROR");
#line 299
    js_qstr2js(data, (char *)"Bad MX type");
#line 300
    goto error;
  }
#line 302
  type = (uint16_t )tempp;
#line 304
  tempp = js_match_offset(pipeq, line___0, pipep + 1);
#line 305
  if (tempp <= pipep) {
#line 306
    js_qstr2js(name, (char *)"ERROR");
#line 307
    js_qstr2js(data, (char *)"There must be four fields in the MX");
#line 308
    goto error;
  }
#line 310
  pipep = tempp;
#line 312
  tmp___31 = js_length(line___0);
#line 312
  tempp = (tmp___31 - pipep) - 2;
#line 313
  if (tempp < 0) {
#line 314
    goto clean;
  } else
#line 313
  if (tempp > 424) {
#line 314
    goto clean;
  }
#line 315
  tmp___32 = js_substr(line___0, data, pipep + 1, tempp);
#line 315
  if (tmp___32 == -1) {
#line 317
    goto clean;
  }
#line 318
  break;
  case 6: 
#line 321
  opipep = pipep;
#line 322
  pipep = js_match_offset(pipeq, line___0, pipep + 1);
#line 323
  if (pipep == -1) {
#line 324
    goto clean;
  }
#line 325
  if (pipep <= opipep) {
#line 326
    js_qstr2js(name, (char *)"ERROR");
#line 327
    js_qstr2js(data, (char *)"You must have nine fields in the SOA");
#line 328
    goto error;
  }
#line 330
  tmp___33 = js_substr(line___0, data, opipep, pipep - opipep);
#line 330
  if (tmp___33 == -1) {
#line 331
    goto clean;
  }
#line 332
  tmp___34 = js_changebyte(data, (unsigned char )'A', 0);
#line 332
  if (tmp___34 == -1) {
#line 333
    goto clean;
  }
#line 334
  tempp = hname_2rfc1035(data);
#line 335
  if (tempp == -1) {
#line 336
    js_qstr2js(name, (char *)"ERROR");
#line 337
    js_qstr2js(data, (char *)"Malformed SOA origin");
#line 338
    goto error;
  }
#line 340
  opipep = pipep;
#line 341
  pipep = js_match_offset(pipeq, line___0, pipep + 1);
#line 342
  if (pipep == -1) {
#line 343
    goto clean;
  }
#line 344
  if (pipep <= opipep) {
#line 345
    js_qstr2js(name, (char *)"ERROR");
#line 346
    js_qstr2js(data, (char *)"You must have nine fields in the SOA");
#line 347
    goto error;
  }
#line 350
  tstr___0 = js_create(512U, 1U);
#line 350
  if ((unsigned long )tstr___0 == (unsigned long )((js_string *)0)) {
#line 351
    goto clean;
  }
#line 352
  tmp___35 = js_substr(line___0, tstr___0, opipep, pipep - opipep);
#line 352
  if (tmp___35 == -1) {
#line 353
    js_destroy(tstr___0);
#line 354
    goto clean;
  }
#line 356
  tempp = email_2rfc1035(tstr___0);
#line 357
  if (tempp == -1) {
#line 358
    js_qstr2js(name, (char *)"ERROR");
#line 359
    js_qstr2js(data, (char *)"Malformed domain email");
#line 360
    js_destroy(tstr___0);
#line 361
    goto error;
  }
#line 363
  tmp___36 = js_append(tstr___0, data);
#line 363
  if (tmp___36 == -1) {
#line 364
    js_destroy(tstr___0);
#line 365
    goto clean;
  }
#line 367
  tmp___37 = js_destroy(tstr___0);
#line 367
  if (tmp___37 == -1) {
#line 368
    goto clean;
  }
#line 372
  counter = 0;
#line 372
  while (counter < 5) {
#line 373
    if (pipep == -2) {
#line 374
      js_qstr2js(name, (char *)"ERROR");
#line 375
      js_qstr2js(data, (char *)"You must have nine fields in the SOA");
#line 376
      goto error;
    }
#line 378
    soanum = js_atoi(line___0, pipep + 1);
#line 379
    tmp___38 = js_addbyte(data, (unsigned char )(soanum >> 24));
#line 379
    if (tmp___38 == -1) {
#line 380
      goto clean;
    }
#line 381
    tmp___39 = js_addbyte(data, (unsigned char )((soanum >> 16) & 255U));
#line 381
    if (tmp___39 == -1) {
#line 382
      goto clean;
    }
#line 383
    tmp___40 = js_addbyte(data, (unsigned char )((soanum >> 8) & 255U));
#line 383
    if (tmp___40 == -1) {
#line 384
      goto clean;
    }
#line 385
    tmp___41 = js_addbyte(data, (unsigned char )(soanum & 255U));
#line 385
    if (tmp___41 == -1) {
#line 386
      goto clean;
    }
#line 387
    pipep = js_match_offset(pipeq, line___0, pipep + 1);
#line 388
    if (pipep == -1) {
#line 389
      goto clean;
    }
#line 372
    counter ++;
  }
#line 391
  break;
  default: 
#line 393
  goto clean;
  }
#line 397
  tmp___42 = js_addbyte(name, (unsigned char )(((int )type & 65280) >> 16));
#line 397
  if (tmp___42 == -1) {
#line 398
    goto clean;
  }
#line 399
  tmp___43 = js_addbyte(name, (unsigned char )((int )type & 255));
#line 399
  if (tmp___43 == -1) {
#line 400
    goto clean;
  }
#line 402
  js_destroy(pipeq);
#line 402
  js_destroy(hashq___0);
#line 402
  js_destroy(starq);
#line 403
  js_destroy(blankq___0);
#line 403
  js_destroy(field);
#line 404
  return ((int )type);
  clean: 
#line 407
  js_destroy(pipeq);
#line 407
  js_destroy(hashq___0);
#line 407
  js_destroy(starq);
#line 408
  js_destroy(blankq___0);
#line 408
  js_destroy(field);
#line 409
  return (-1);
  error: 
#line 411
  js_destroy(pipeq);
#line 411
  js_destroy(hashq___0);
#line 411
  js_destroy(starq);
#line 412
  js_destroy(blankq___0);
#line 412
  js_destroy(field);
#line 413
  return (-2);
  cero: 
#line 415
  js_destroy(pipeq);
#line 415
  js_destroy(hashq___0);
#line 415
  js_destroy(starq);
#line 416
  js_destroy(blankq___0);
#line 416
  js_destroy(field);
#line 417
  return (0);
}
}
#line 429 "ParseCsv1.c"
int ddip_2_ip(js_string *ddip , js_string *ip , int offset ) 
{ int qr ;
  int counter ;
  int ret ;
  unsigned char ip_byte ;
  js_string *dotq___0 ;
  js_string *numdotq___0 ;
  char dot ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  js_string *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;
  int tmp___7 ;

  {
#line 435
  dotq___0 = (js_string *)0;
#line 436
  numdotq___0 = (js_string *)0;
#line 438
  dot = (char )'.';
#line 441
  tmp = mara_goodjs(ddip);
#line 441
  if (tmp == -1) {
#line 442
    return (-1);
  }
#line 443
  tmp___0 = mara_goodjs(ip);
#line 443
  if (tmp___0 == -1) {
#line 444
    return (-1);
  }
#line 447
  if ((unsigned long )dotq___0 == (unsigned long )((js_string *)0)) {
#line 448
    dotq___0 = js_create(7U, 1U);
#line 448
    if ((unsigned long )dotq___0 == (unsigned long )((js_string *)0)) {
#line 449
      return (-1);
    }
#line 451
    tmp___1 = js_str2js(dotq___0, & dot, 1, 1);
#line 451
    if (tmp___1 == -1) {
#line 452
      js_destroy(dotq___0);
#line 453
      dotq___0 = (js_string *)0;
#line 454
      return (-1);
    }
  }
#line 457
  if ((unsigned long )numdotq___0 == (unsigned long )((js_string *)0)) {
#line 458
    numdotq___0 = js_create(211U, 1U);
#line 458
    if ((unsigned long )numdotq___0 == (unsigned long )((js_string *)0)) {
#line 459
      js_destroy(dotq___0);
#line 460
      return (-1);
    }
#line 462
    tmp___2 = js_set_encode(numdotq___0, 3);
#line 462
    if (tmp___2 == -1) {
#line 463
      js_destroy(numdotq___0);
#line 464
      js_destroy(dotq___0);
#line 465
      numdotq___0 = (js_string *)0;
#line 466
      return (-1);
    }
#line 469
    tmp___3 = js_numbers(numdotq___0);
#line 469
    if ((unsigned long )tmp___3 == (unsigned long )((js_string *)0)) {
#line 470
      js_destroy(numdotq___0);
#line 471
      js_destroy(dotq___0);
#line 472
      numdotq___0 = (js_string *)0;
#line 473
      return (-1);
    }
#line 476
    tmp___4 = js_append(dotq___0, numdotq___0);
#line 476
    if (tmp___4 == -1) {
#line 477
      js_destroy(numdotq___0);
#line 478
      js_destroy(dotq___0);
#line 479
      numdotq___0 = (js_string *)0;
#line 480
      return (-1);
    }
  }
#line 485
  ret = js_notmatch_offset(numdotq___0, ddip, offset);
#line 486
  if (ret == -1) {
#line 487
    goto clean;
  }
#line 490
  js_qstr2js(ip, (char *)"");
#line 493
  tmp___5 = js_length(ddip);
#line 493
  if (tmp___5 < 1) {
#line 494
    goto clean;
  }
#line 496
  counter = 0;
#line 496
  while (counter < 4) {
#line 497
    if (offset == -2) {
#line 498
      goto clean;
    }
#line 500
    tmp___6 = js_atoi(ddip, offset);
#line 500
    qr = (int )tmp___6;
#line 502
    if (qr < 0) {
#line 503
      goto clean;
    } else
#line 502
    if (qr > 255) {
#line 503
      goto clean;
    }
#line 505
    ip_byte = (unsigned char )qr;
#line 507
    tmp___7 = js_addbyte(ip, ip_byte);
#line 507
    if (tmp___7 == -1) {
#line 508
      goto clean;
    }
#line 510
    offset = js_match_offset(dotq___0, ddip, offset + 1);
#line 511
    if (offset == -1) {
#line 512
      goto clean;
    }
#line 514
    offset ++;
#line 496
    counter ++;
  }
#line 518
  if (ret < offset) {
#line 518
    if (offset != -1) {
#line 519
      goto clean;
    }
  }
#line 522
  js_destroy(dotq___0);
#line 523
  js_destroy(numdotq___0);
#line 526
  if (ret == -2) {
#line 527
    return (-2);
  }
#line 529
  return (ret);
  clean: 
#line 532
  js_destroy(dotq___0);
#line 533
  js_destroy(numdotq___0);
#line 534
  return (-1);
}
}
#line 546 "ParseCsv1.c"
int bs_process(js_string *in , js_string *out , js_string *sub ) 
{ int value___0 ;
  int iplace ;
  int oplace ;
  int subq ;
  int inlabel ;
  unsigned char byte ;
  int firstchar ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 552
  tmp = mara_goodjs(in);
#line 552
  if (tmp == -1) {
#line 553
    return (-1);
  }
#line 554
  tmp___0 = mara_goodjs(out);
#line 554
  if (tmp___0 == -1) {
#line 555
    return (-1);
  }
#line 556
  subq = 1;
#line 557
  if ((unsigned long )sub == (unsigned long )((js_string *)0)) {
#line 558
    subq = 0;
  } else {
#line 559
    tmp___1 = mara_goodjs(sub);
#line 559
    if (tmp___1 == -1) {
#line 560
      return (-1);
    }
  }
#line 562
  inlabel = 0;
#line 562
  oplace = inlabel;
#line 562
  iplace = oplace;
#line 563
  firstchar = 1;
#line 564
  while ((unsigned int )iplace < in->unit_count) {
#line 565
    byte = *(in->string + iplace);
#line 568
    if (inlabel) {
#line 568
      if ((int )byte >= 65) {
#line 568
        if ((int )byte <= 90) {
#line 569
          byte = (unsigned char )((int )byte + 32);
        }
      }
    }
#line 570
    if (firstchar == 1) {
#line 571
      inlabel = 1;
#line 572
      firstchar = 0;
    }
#line 574
    if ((int )byte == 35) {
#line 575
      inlabel = 0;
    } else
#line 574
    if ((int )byte == 124) {
#line 575
      inlabel = 0;
    }
#line 576
    if (subq) {
#line 576
      if ((int )byte == 37) {
#line 577
        if ((unsigned int )oplace >= out->max_count) {
#line 578
          return (-1);
        }
#line 579
        out->unit_count = (unsigned int )oplace;
#line 580
        js_append(sub, out);
#line 581
        oplace = (int )out->unit_count;
#line 582
        iplace ++;
#line 583
        continue;
      } else {
#line 576
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 585
    if ((int )byte == 92) {
#line 586
      iplace ++;
#line 587
      if ((unsigned int )iplace >= in->unit_count) {
#line 588
        return (-1);
      }
#line 589
      byte = *(in->string + iplace);
#line 590
      if ((int )byte >= 48) {
#line 590
        if ((int )byte <= 51) {
#line 591
          value___0 = ((int )byte - 48) * 64;
#line 593
          iplace ++;
#line 594
          if ((unsigned int )iplace >= in->unit_count) {
#line 595
            return (-1);
          }
#line 596
          byte = *(in->string + iplace);
#line 597
          if ((int )byte < 48) {
#line 598
            return (-1);
          } else
#line 597
          if ((int )byte > 57) {
#line 598
            return (-1);
          }
#line 599
          value___0 += ((int )byte - 48) * 8;
#line 601
          iplace ++;
#line 602
          if ((unsigned int )iplace >= in->unit_count) {
#line 603
            return (-1);
          }
#line 604
          byte = *(in->string + iplace);
#line 605
          if ((int )byte < 48) {
#line 606
            return (-1);
          } else
#line 605
          if ((int )byte > 57) {
#line 606
            return (-1);
          }
#line 607
          value___0 += (int )byte - 48;
#line 608
          byte = (unsigned char )value___0;
        } else {
#line 590
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 610
      if ((int )byte != 92) {
#line 610
        if ((int )byte != 37) {
#line 611
          return (-1);
        }
      }
    }
#line 614
    if ((unsigned int )oplace < out->max_count) {
#line 615
      *(out->string + oplace) = byte;
    } else {
#line 617
      return (-1);
    }
#line 619
    oplace ++;
#line 621
    iplace ++;
  }
#line 625
  out->unit_count = (unsigned int )oplace;
#line 626
  return (1);
}
}
#line 1 "ParseIpAcl.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-EVsxmDs4.i","")
#line 49 "ParseIpAcl.c"
int ddip_ip_mask(js_string *ddip , ipv4pair *ips , int offset ) ;
#line 49 "ParseIpAcl.c"
static js_string *dotq  =    (js_string *)0;
#line 50 "ParseIpAcl.c"
static js_string *numdotq  =    (js_string *)0;
#line 51 "ParseIpAcl.c"
static js_string *slashq  =    (js_string *)0;
#line 52 "ParseIpAcl.c"
static uint32_t masks[33]  = 
#line 52
  {      (uint32_t )0,      (uint32_t )(-0x7FFFFFFF-1),      3221225472U,      3758096384U, 
        4026531840U,      4160749568U,      4227858432U,      4261412864U, 
        4278190080U,      4286578688U,      4290772992U,      4292870144U, 
        4293918720U,      4294443008U,      4294705152U,      4294836224U, 
        4294901760U,      4294934528U,      4294950912U,      4294959104U, 
        4294963200U,      4294965248U,      4294966272U,      4294966784U, 
        4294967040U,      4294967168U,      4294967232U,      4294967264U, 
        4294967280U,      4294967288U,      4294967292U,      4294967294U, 
        4294967295U};
#line 43 "ParseIpAcl.c"
int ddip_ip_mask(js_string *ddip , ipv4pair *ips , int offset ) 
{ int qr ;
  int counter ;
  int firstoffset ;
  int slashp ;
  int ret ;
  unsigned char ip_byte ;
  char dot ;
  char slash ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  js_string *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  int tmp___11 ;

  {
#line 87
  dot = (char )'.';
#line 88
  slash = (char )'/';
#line 91
  tmp = mara_goodjs(ddip);
#line 91
  if (tmp == -1) {
#line 92
    return (-1);
  }
#line 93
  if ((unsigned long )ips == (unsigned long )((ipv4pair *)0)) {
#line 94
    return (-1);
  }
#line 97
  if ((unsigned long )dotq == (unsigned long )((js_string *)0)) {
#line 98
    dotq = js_create(7U, 1U);
#line 98
    if ((unsigned long )dotq == (unsigned long )((js_string *)0)) {
#line 99
      return (-1);
    }
#line 101
    tmp___0 = js_str2js(dotq, & dot, 1, 1);
#line 101
    if (tmp___0 == -1) {
#line 102
      js_destroy(dotq);
#line 103
      dotq = (js_string *)0;
#line 104
      return (-1);
    }
  }
#line 107
  if ((unsigned long )numdotq == (unsigned long )((js_string *)0)) {
#line 108
    numdotq = js_create(211U, 1U);
#line 108
    if ((unsigned long )numdotq == (unsigned long )((js_string *)0)) {
#line 109
      return (-1);
    }
#line 110
    tmp___1 = js_set_encode(numdotq, 3);
#line 110
    if (tmp___1 == -1) {
#line 111
      js_destroy(numdotq);
#line 112
      numdotq = (js_string *)0;
#line 113
      return (-1);
    }
#line 116
    tmp___2 = js_numbers(numdotq);
#line 116
    if ((unsigned long )tmp___2 == (unsigned long )((js_string *)0)) {
#line 117
      js_destroy(numdotq);
#line 118
      numdotq = (js_string *)0;
#line 119
      return (-1);
    }
#line 122
    tmp___3 = js_append(dotq, numdotq);
#line 122
    if (tmp___3 == -1) {
#line 123
      js_destroy(numdotq);
#line 124
      numdotq = (js_string *)0;
#line 125
      return (-1);
    }
  }
#line 128
  if ((unsigned long )slashq == (unsigned long )((js_string *)0)) {
#line 129
    slashq = js_create(7U, 1U);
#line 129
    if ((unsigned long )slashq == (unsigned long )((js_string *)0)) {
#line 130
      return (-1);
    }
#line 132
    tmp___4 = js_str2js(slashq, & slash, 1, 1);
#line 132
    if (tmp___4 == -1) {
#line 133
      js_destroy(slashq);
#line 134
      slashq = (js_string *)0;
#line 135
      return (-1);
    }
  }
#line 140
  firstoffset = offset;
#line 143
  ret = js_notmatch_offset(numdotq, ddip, offset);
#line 146
  if (ret == -1) {
#line 147
    return (-1);
  } else
#line 146
  if (ret == offset) {
#line 147
    return (-1);
  }
#line 150
  tmp___5 = js_length(ddip);
#line 150
  if (tmp___5 < offset + 1) {
#line 151
    return (-1);
  }
#line 153
  ips->ip = (uint32_t )0;
#line 155
  counter = 0;
#line 155
  while (counter < 4) {
#line 156
    if (offset == -2) {
#line 157
      return (-1);
    }
#line 159
    tmp___6 = js_atoi(ddip, offset);
#line 159
    qr = (int )tmp___6;
#line 161
    if (qr < 0) {
#line 162
      return (-1);
    } else
#line 161
    if (qr > 255) {
#line 162
      return (-1);
    }
#line 164
    ip_byte = (unsigned char )qr;
#line 167
    ips->ip |= (unsigned int )(((int )ip_byte & 255) << (24 - 8 * counter));
#line 170
    if (counter == 4) {
#line 170
      if (ret < offset) {
#line 171
        return (-1);
      }
    }
#line 173
    offset = js_match_offset(dotq, ddip, offset + 1);
#line 174
    if (offset == -1) {
#line 175
      return (-1);
    }
#line 177
    offset ++;
#line 155
    counter ++;
  }
#line 181
  tmp___7 = js_match_offset(slashq, ddip, firstoffset);
#line 181
  if (tmp___7 != ret) {
#line 183
    ips->mask = 4294967295U;
#line 184
    return (ret);
  } else {
#line 181
    tmp___8 = js_match_offset(slashq, ddip, firstoffset);
#line 181
    if (tmp___8 == -2) {
#line 183
      ips->mask = 4294967295U;
#line 184
      return (ret);
    }
  }
#line 186
  slashp = ret;
#line 190
  ret = js_match_offset(dotq, ddip, slashp + 1);
#line 191
  if (ret == -1) {
#line 192
    return (-1);
  }
#line 193
  offset = js_notmatch_offset(numdotq, ddip, slashp + 1);
#line 194
  if (offset == -1) {
#line 195
    return (-1);
  }
#line 197
  if (ret == -2) {
#line 197
    goto _L;
  } else
#line 197
  if (offset < ret) {
#line 197
    if (offset != -2) {
      _L: /* CIL Label */ 
#line 198
      tmp___9 = js_atoi(ddip, slashp + 1);
#line 198
      ret = (int )tmp___9;
#line 199
      if (ret < 0) {
#line 200
        return (-1);
      } else
#line 199
      if (ret > 32) {
#line 200
        return (-1);
      }
#line 201
      ips->mask = masks[ret];
#line 202
      if ((unsigned int )(offset + 1) < ddip->unit_count) {
#line 203
        return (offset + 1);
      } else {
#line 205
        return (-2);
      }
    } else {
#line 197
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 208
    offset = slashp + 1;
#line 209
    ips->mask = (uint32_t )0;
#line 210
    counter = 0;
#line 210
    while (counter < 4) {
#line 211
      if (offset == -2) {
#line 212
        return (-1);
      }
#line 214
      tmp___10 = js_atoi(ddip, offset);
#line 214
      qr = (int )tmp___10;
#line 216
      if (qr < 0) {
#line 217
        return (-1);
      } else
#line 216
      if (qr > 255) {
#line 217
        return (-1);
      }
#line 219
      ip_byte = (unsigned char )qr;
#line 222
      ips->mask |= (unsigned int )(((int )ip_byte & 255) << (24 - 8 * counter));
#line 224
      if (counter != 3) {
#line 225
        offset = js_match_offset(dotq, ddip, offset + 1);
#line 226
        if (offset == -1) {
#line 227
          return (-1);
        }
      } else {
#line 230
        tmp___11 = js_notmatch_offset(numdotq, ddip, offset + 1);
#line 230
        return (tmp___11);
      }
#line 232
      offset ++;
#line 210
      counter ++;
    }
#line 234
    return (-1);
  }
#line 237
  return (-1);
}
}
#line 258 "ParseIpAcl.c"
int make_ip_acl(js_string *in , ipv4pair *out , int max , int depth ) 
{ js_string *sub ;
  js_string *delimq ;
  js_string *value___0 ;
  int start ;
  int next ;
  int index ;
  char delim ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int nx ;
  int tmp___3 ;
  int nx___0 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 260
  sub = (js_string *)0;
#line 260
  delimq = (js_string *)0;
#line 260
  value___0 = (js_string *)0;
#line 261
  index = 0;
#line 262
  delim = (char )',';
#line 265
  if (depth > 32) {
#line 266
    return (-1);
  }
#line 267
  tmp = js_has_sanity(in);
#line 267
  if (tmp == -1) {
#line 268
    return (-1);
  }
#line 269
  if (in->unit_size != 1U) {
#line 270
    return (-1);
  }
#line 271
  if ((unsigned long )out == (unsigned long )((ipv4pair *)0)) {
#line 272
    return (-1);
  }
#line 275
  sub = js_create(256U, 1U);
#line 275
  if ((unsigned long )sub == (unsigned long )((js_string *)0)) {
#line 276
    return (-1);
  }
#line 277
  tmp___0 = js_set_encode(sub, 3);
#line 277
  if (tmp___0 == -1) {
#line 278
    return (-1);
  }
#line 279
  value___0 = js_create(512U, 1U);
#line 279
  if ((unsigned long )value___0 == (unsigned long )((js_string *)0)) {
#line 280
    return (-1);
  }
#line 281
  tmp___1 = js_set_encode(value___0, 3);
#line 281
  if (tmp___1 == -1) {
#line 282
    return (-1);
  }
#line 283
  delimq = js_create(7U, 1U);
#line 283
  if ((unsigned long )delimq == (unsigned long )((js_string *)0)) {
#line 284
    js_destroy(sub);
#line 285
    return (-1);
  }
#line 287
  tmp___2 = js_str2js(delimq, & delim, 1, 1);
#line 287
  if (tmp___2 == -1) {
#line 288
    js_destroy(sub);
#line 288
    js_destroy(value___0);
#line 288
    js_destroy(delimq);
#line 289
    return (-1);
  }
#line 292
  next = -1;
#line 293
  while (1) {
#line 294
    start = next + 1;
#line 296
    next = js_match_offset(delimq, in, start);
#line 297
    if (next == -1) {
#line 298
      js_destroy(sub);
#line 298
      js_destroy(delimq);
#line 298
      js_destroy(value___0);
#line 299
      return (-1);
    }
#line 302
    if (next == -2) {
#line 303
      nx = (int )(in->unit_count - 1U);
#line 305
      while (1) {
#line 305
        if (start < nx) {
#line 305
          if (! ((int )*(in->string + start) == 32)) {
#line 305
            break;
          }
        } else {
#line 305
          break;
        }
#line 306
        start ++;
      }
#line 309
      while (1) {
#line 309
        if (nx > start) {
#line 309
          if (! ((int )*(in->string + nx) == 32)) {
#line 309
            if (! ((int )*(in->string + start) == 9)) {
#line 309
              break;
            }
          }
        } else {
#line 309
          break;
        }
#line 311
        if (nx >= 0) {
#line 312
          nx --;
        } else {
#line 315
          js_destroy(sub);
#line 315
          js_destroy(delimq);
#line 315
          js_destroy(value___0);
#line 316
          return (-1);
        }
      }
#line 320
      tmp___3 = js_substr(in, sub, start, (nx + 1) - start);
#line 320
      if (tmp___3 == -1) {
#line 321
        js_destroy(sub);
#line 321
        js_destroy(delimq);
#line 321
        js_destroy(value___0);
#line 322
        return (-1);
      }
    } else {
#line 326
      nx___0 = next;
#line 328
      while (1) {
#line 328
        if (start < nx___0) {
#line 328
          if (! ((int )*(in->string + start) == 32)) {
#line 328
            if (! ((int )*(in->string + start) == 9)) {
#line 328
              break;
            }
          }
        } else {
#line 328
          break;
        }
#line 330
        start ++;
      }
#line 333
      while (1) {
#line 333
        if (nx___0 > start) {
#line 333
          if (! ((int )*(in->string + nx___0) == 32)) {
#line 333
            if (! ((int )*(in->string + start) == 9)) {
#line 333
              if (! ((int )*(in->string + nx___0) == 44)) {
#line 333
                break;
              }
            }
          }
        } else {
#line 333
          break;
        }
#line 336
        if (nx___0 >= 0) {
#line 337
          nx___0 --;
        } else {
#line 340
          js_destroy(sub);
#line 340
          js_destroy(delimq);
#line 340
          js_destroy(value___0);
#line 341
          return (-1);
        }
      }
#line 345
      tmp___4 = js_substr(in, sub, start, (nx___0 + 1) - start);
#line 345
      if (tmp___4 == -1) {
#line 346
        js_destroy(sub);
#line 346
        js_destroy(delimq);
#line 346
        js_destroy(value___0);
#line 347
        return (-1);
      }
    }
#line 351
    tmp___5 = js_qstr2js(value___0, (char *)"ipv4_alias");
#line 351
    if (tmp___5 == -1) {
#line 352
      js_destroy(sub);
#line 352
      js_destroy(delimq);
#line 352
      js_destroy(value___0);
#line 353
      return (-1);
    }
#line 356
    tmp___8 = read_dvar(value___0, sub, value___0);
#line 356
    if (tmp___8 != -1) {
#line 357
      tmp___6 = make_ip_acl(value___0, out, max, depth + 1);
#line 357
      if (tmp___6 == -1) {
#line 358
        js_destroy(sub);
#line 358
        js_destroy(delimq);
#line 358
        js_destroy(value___0);
#line 359
        return (-1);
      }
    } else {
#line 365
      while (1) {
#line 365
        if (index < max) {
#line 365
          if (! ((out + index)->ip != 4294967295U)) {
#line 365
            break;
          }
        } else {
#line 365
          break;
        }
#line 366
        index ++;
      }
#line 368
      if (index >= max) {
#line 369
        js_destroy(sub);
#line 369
        js_destroy(delimq);
#line 369
        js_destroy(value___0);
#line 370
        return (-1);
      }
#line 373
      tmp___7 = ddip_ip_mask(sub, out + index, 0);
#line 373
      if (tmp___7 == -1) {
#line 374
        js_destroy(sub);
#line 374
        js_destroy(delimq);
#line 374
        js_destroy(value___0);
#line 375
        return (-1);
      }
    }
#line 293
    if (! (next != -2)) {
#line 293
      break;
    }
  }
#line 380
  js_destroy(sub);
#line 381
  js_destroy(delimq);
#line 382
  js_destroy(value___0);
#line 383
  return (1);
}
}
#line 1 "Parse_ipv6.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-EakKnXwQ.i","")
#line 35 "Parse_ipv6.c"
int set_nybble(unsigned int nybble , unsigned char *istring , int point , int length ) 
{ char temp ;
  int place ;

  {
#line 39
  if (nybble < 0U) {
#line 40
    return (-1);
  } else
#line 39
  if (nybble > 15U) {
#line 40
    return (-1);
  }
#line 42
  if (length < 0) {
#line 43
    return (-1);
  }
#line 45
  if (length * 2 < point) {
#line 46
    return (-1);
  }
#line 48
  place = point >> 1;
#line 49
  temp = (char )*(istring + place);
#line 50
  if ((point & 1) == 0) {
#line 51
    nybble <<= 4;
#line 52
    temp = (char )((int )temp & 15);
#line 53
    temp = (char )((unsigned int )temp | nybble);
  } else {
#line 56
    temp = (char )((int )temp & 240);
#line 57
    temp = (char )((unsigned int )temp | nybble);
  }
#line 59
  *(istring + place) = (unsigned char )temp;
#line 60
  return (1);
}
}
#line 67 "Parse_ipv6.c"
int hchar_to_nybble(char i ) 
{ 

  {
#line 68
  if ((int )i >= 48) {
#line 68
    if ((int )i <= 57) {
#line 69
      return ((int )i - 48);
    }
  }
#line 70
  if ((int )i >= 97) {
#line 70
    if ((int )i <= 102) {
#line 71
      return (((int )i + 10) - 97);
    }
  }
#line 72
  if ((int )i >= 65) {
#line 72
    if ((int )i <= 70) {
#line 73
      return (((int )i + 10) - 65);
    }
  }
#line 74
  if ((int )i == 58) {
#line 75
    return (-2);
  }
#line 76
  return (-1);
}
}
#line 87 "Parse_ipv6.c"
int set_nybble_char(char nybble , unsigned char *istring , int point , int length ) 
{ int n ;
  int tmp ;

  {
#line 89
  n = hchar_to_nybble(nybble);
#line 90
  if (n == -1) {
#line 91
    return (-1);
  }
#line 92
  if (n == -2) {
#line 93
    return (-2);
  }
#line 94
  tmp = set_nybble((unsigned int )n, istring, point, length);
#line 94
  return (tmp);
}
}
#line 102 "Parse_ipv6.c"
int set_nybble_js(js_string *i , int i_offset , js_string *o , int o_offset ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 103
  tmp = js_has_sanity(i);
#line 103
  if (tmp != 1) {
#line 104
    return (-1);
  }
#line 105
  tmp___0 = js_has_sanity(o);
#line 105
  if (tmp___0 != 1) {
#line 106
    return (-1);
  }
#line 107
  if (i->unit_size != 1U) {
#line 108
    return (-1);
  }
#line 109
  if (o->unit_size != 1U) {
#line 110
    return (-1);
  }
#line 111
  if ((unsigned int )i_offset > i->unit_count) {
#line 112
    return (-1);
  }
#line 113
  if ((unsigned int )o_offset > o->unit_count * 2U) {
#line 114
    return (-1);
  }
#line 115
  tmp___1 = set_nybble_char((char )*(i->string + i_offset), o->string, o_offset, (int )o->unit_count);
#line 115
  return (tmp___1);
}
}
#line 126 "Parse_ipv6.c"
int is_hex_digit(char c ) 
{ int tmp ;

  {
#line 127
  if ((int )c >= 48) {
#line 127
    if ((int )c <= 57) {
#line 127
      tmp = 1;
    } else {
#line 127
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 127
  if ((int )c >= 65) {
#line 127
    if ((int )c <= 70) {
#line 127
      tmp = 1;
    } else {
#line 127
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 127
  if ((int )c >= 97) {
#line 127
    if ((int )c <= 102) {
#line 127
      tmp = 1;
    } else {
#line 127
      tmp = 0;
    }
  } else {
#line 127
    tmp = 0;
  }
#line 127
  return (tmp);
}
}
#line 138 "Parse_ipv6.c"
int is_colon(char c ) 
{ 

  {
#line 139
  return ((int )c == 58);
}
}
#line 149 "Parse_ipv6.c"
int count_thingys(js_string *i , int offset , int (*is_thingy)(char in ) ) 
{ int count ;
  int tmp ;

  {
#line 151
  if (i->unit_size != 1U) {
#line 152
    return (-1);
  }
#line 154
  if (i->unit_count >= i->max_count) {
#line 155
    return (-1);
  }
#line 157
  if ((unsigned int )offset > i->unit_count) {
#line 158
    return (-1);
  }
#line 160
  count = 0;
#line 161
  while (1) {
#line 161
    tmp = (*is_thingy)((char )*(i->string + offset));
#line 161
    if (! tmp) {
#line 161
      break;
    }
#line 162
    count ++;
#line 163
    offset ++;
#line 164
    if ((unsigned int )offset == i->unit_count) {
#line 165
      return (count);
    }
#line 167
    if ((unsigned int )offset > i->unit_count) {
#line 168
      return (-1);
    }
  }
#line 171
  return (count);
}
}
#line 184 "Parse_ipv6.c"
int count_digits(js_string *i , int offset ) 
{ int tmp ;

  {
#line 185
  tmp = count_thingys(i, offset, & is_hex_digit);
#line 185
  return (tmp);
}
}
#line 190 "Parse_ipv6.c"
int see_double_colon(js_string *i , int offset ) 
{ int tmp ;

  {
#line 191
  tmp = count_thingys(i, offset, & is_colon);
#line 191
  return (tmp);
}
}
#line 206 "Parse_ipv6.c"
int count_thingys_all(js_string *i , int offset , int (*is_thingy)(char in ) ) 
{ int count ;
  int tmp ;

  {
#line 208
  if (i->unit_size != 1U) {
#line 209
    return (-1);
  }
#line 211
  if (i->unit_count >= i->max_count) {
#line 212
    return (-1);
  }
#line 214
  if ((unsigned int )offset > i->unit_count) {
#line 215
    return (-1);
  }
#line 217
  count = 0;
#line 218
  while ((unsigned int )offset < i->unit_count) {
#line 219
    tmp = (*is_thingy)((char )*(i->string + offset));
#line 219
    if (tmp) {
#line 220
      count ++;
    }
#line 222
    offset ++;
  }
#line 224
  return (count);
}
}
#line 234 "Parse_ipv6.c"
int count_colons(js_string *i , int offset ) 
{ int tmp ;

  {
#line 235
  tmp = count_thingys_all(i, offset, & is_colon);
#line 235
  return (tmp);
}
}
#line 245 "Parse_ipv6.c"
js_string *ip6_to_raw(js_string *i ) 
{ js_string *o ;
  int input_point ;
  int output_point ;
  int counter ;
  int w ;
  int l ;
  int c ;
  int skipped ;
  int init_colon ;
  int tmp ;
  int q ;
  int n ;
  int tmp___0 ;
  int cc ;

  {
#line 249
  skipped = 0;
#line 250
  init_colon = 1;
#line 253
  tmp = js_has_sanity(i);
#line 253
  if (tmp != 1) {
#line 254
    return ((js_string *)0);
  }
#line 256
  if (i->unit_size != 1U) {
#line 257
    return ((js_string *)0);
  }
#line 261
  o = js_create(16U, 1U);
#line 261
  if ((unsigned long )o == (unsigned long )((js_string *)0)) {
#line 262
    return ((js_string *)0);
  }
#line 266
  counter = 0;
#line 266
  while (counter < 16) {
#line 267
    *(o->string + counter) = (unsigned char)0;
#line 266
    counter ++;
  }
#line 269
  o->unit_count = 16U;
#line 271
  output_point = 0;
#line 271
  input_point = output_point;
#line 273
  w = 1;
#line 275
  l = js_length(i);
#line 277
  c = 0;
#line 279
  while (1) {
#line 279
    if (output_point < 32) {
#line 279
      if (! (input_point < l)) {
#line 279
        break;
      }
    } else {
#line 279
      break;
    }
#line 284
    n = count_digits(i, input_point);
#line 285
    if (init_colon == 1) {
#line 285
      if (n == 0) {
#line 286
        goto zeros;
      }
    }
#line 288
    init_colon = 0;
#line 289
    if (n > 4) {
#line 290
      show_esc_stdout(o);
#line 290
      printf("\n");
#line 291
      js_dealloc((void *)o);
#line 292
      return ((js_string *)0);
    } else
#line 289
    if (n < 1) {
#line 290
      show_esc_stdout(o);
#line 290
      printf("\n");
#line 291
      js_dealloc((void *)o);
#line 292
      return ((js_string *)0);
    }
#line 295
    counter = 0;
#line 295
    while (counter < 4 - n) {
#line 296
      set_nybble(0U, o->string, output_point, (int )o->unit_count);
#line 297
      output_point ++;
#line 295
      counter ++;
    }
#line 299
    counter = 4 - n;
#line 299
    while (counter < 4) {
#line 300
      tmp___0 = set_nybble_js(i, input_point, o, output_point);
#line 300
      if (tmp___0 != 1) {
#line 302
        js_dealloc((void *)o);
#line 303
        return ((js_string *)0);
      }
#line 305
      input_point ++;
#line 306
      output_point ++;
#line 299
      counter ++;
    }
    zeros: 
#line 311
    if ((unsigned int )input_point < i->unit_count) {
#line 312
      q = see_double_colon(i, input_point);
    } else
#line 313
    if ((unsigned int )input_point == i->unit_count) {
#line 314
      q = 0;
    } else {
#line 316
      js_dealloc((void *)o);
#line 317
      return ((js_string *)0);
    }
#line 319
    if (q == -1) {
#line 320
      js_dealloc((void *)o);
#line 321
      return ((js_string *)0);
    }
#line 323
    if (q == 2) {
#line 325
      if (skipped != 0) {
#line 329
        js_dealloc((void *)o);
#line 330
        return ((js_string *)0);
      }
#line 332
      skipped = 1;
#line 333
      input_point ++;
#line 342
      cc = count_colons(i, input_point);
#line 343
      if (cc == -1) {
#line 344
        js_dealloc((void *)o);
#line 345
        return ((js_string *)0);
      }
#line 347
      if (init_colon == 1) {
#line 348
        cc --;
      }
#line 350
      output_point += 4 * ((8 - (c + 1)) - cc);
#line 351
      input_point ++;
    } else
#line 353
    if (q == 1) {
#line 354
      input_point ++;
    } else
#line 356
    if (q == 0) {
#line 356
      if ((unsigned int )input_point == i->unit_count) {
#line 357
        return (o);
      } else {
#line 360
        js_dealloc((void *)o);
#line 361
        return ((js_string *)0);
      }
    } else {
#line 360
      js_dealloc((void *)o);
#line 361
      return ((js_string *)0);
    }
#line 363
    init_colon = 0;
#line 364
    c ++;
  }
#line 366
  if (input_point < l) {
#line 367
    js_dealloc((void *)o);
#line 368
    return ((js_string *)0);
  }
#line 370
  return (o);
}
}
#line 1 "Csv2_read.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-L_m3WcDm.i","")
#line 240 "/usr/include/stdio.h"
extern int fclose(FILE * ) ;
#line 250
extern FILE *fopen(char const   * , char const   * )  __asm__("_fopen")  ;
#line 257 "Csv2_functions.h"
int csv2_close(csv2_read *file___0 ) ;
#line 258
int csv2_readchar(csv2_read *file___0 ) ;
#line 259
int csv2_justread(csv2_read *file___0 ) ;
#line 260
int csv2_error(csv2_read *file___0 , char *why ) ;
#line 261
int32_t csv2_get_unicode(csv2_read *file___0 ) ;
#line 262
int csv2_set_unicode(csv2_read *file___0 , int32_t in ) ;
#line 263
csv2_read *csv2_open(js_string *filename ) ;
#line 289
int csv2_push_file(csv2_read *file___0 , js_string *filename ) ;
#line 290
int csv2_pop_file(csv2_read *file___0 ) ;
#line 291
void csv2_allow_tilde(csv2_read *file___0 ) ;
#line 292
void csv2_forbid_tilde(csv2_read *file___0 ) ;
#line 293
void csv2_allow_leftbrace(csv2_read *file___0 ) ;
#line 294
void csv2_forbid_leftbrace(csv2_read *file___0 ) ;
#line 295
int csv2_tilde_seen(csv2_read *file___0 ) ;
#line 296
void csv2_reset_tilde_seen(csv2_read *file___0 ) ;
#line 36 "Csv2_read.c"
csv2_read *csv2_open(js_string *filename ) 
{ csv2_read *out ;
  int c ;
  void *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  FILE *tmp___3 ;

  {
#line 41
  if (filename->unit_size != 1U) {
#line 42
    return ((csv2_read *)0);
  }
#line 45
  tmp = js_alloc((int )sizeof(csv2_read ), 1);
#line 45
  out = (csv2_read *)tmp;
#line 45
  if ((unsigned long )out == (unsigned long )((csv2_read *)0)) {
#line 46
    return ((csv2_read *)0);
  }
#line 49
  tmp___1 = js_alloc((int )(filename->unit_count + 3U), 1);
#line 49
  tmp___0 = (char *)tmp___1;
#line 49
  out->filename = tmp___0;
#line 49
  if ((unsigned long )tmp___0 == (unsigned long )((char *)0)) {
#line 50
    js_dealloc((void *)out);
#line 51
    return ((csv2_read *)0);
  }
#line 54
  tmp___2 = js_js2str(filename, out->filename, (int )(filename->unit_count + 1U));
#line 54
  if (tmp___2 == -1) {
#line 56
    js_dealloc((void *)out);
#line 57
    return ((csv2_read *)0);
  }
#line 61
  out->stack = (csv2_file *)0;
#line 62
  out->stack_height = 0;
#line 63
  out->mnum = 0;
#line 64
  out->mplace = 0;
#line 65
  out->cplace = 0;
#line 66
  c = 0;
#line 66
  while (c < 19) {
#line 67
    out->context[c] = (char)0;
#line 66
    c ++;
  }
#line 69
  out->tilde_seen = (char)0;
#line 70
  out->tilde_handling = (char )csv2_tilde_handling;
#line 71
  if (csv2_tilde_handling == 0) {
#line 72
    out->chars_allowed = (char)1;
  } else {
#line 75
    out->chars_allowed = (char)0;
  }
#line 78
  out->linenum = 1;
#line 79
  out->justread = -328;
#line 81
  out->unicode = -1;
#line 82
  out->ok_to_read = 1;
#line 83
  out->seen_bug_msg = (char)0;
#line 85
  tmp___3 = fopen((char const   *)out->filename, "rb");
#line 85
  out->reading = tmp___3;
#line 85
  if ((unsigned long )tmp___3 == (unsigned long )((FILE *)0)) {
#line 86
    js_dealloc((void *)out);
#line 87
    return ((csv2_read *)0);
  }
#line 90
  return (out);
}
}
#line 100 "Csv2_read.c"
int csv2_close(csv2_read *file___0 ) 
{ csv2_file *v ;
  csv2_file *w ;
  int a ;
  int tmp ;
  int tmp___0 ;

  {
#line 102
  a = 0;
#line 103
  tmp = fclose(file___0->reading);
#line 103
  if (tmp != 0) {
#line 104
    return (-1);
  }
#line 107
  v = file___0->stack;
#line 108
  while (1) {
#line 108
    if ((unsigned long )v != (unsigned long )((csv2_file *)0)) {
#line 108
      if (! (a < 1000)) {
#line 108
        break;
      }
    } else {
#line 108
      break;
    }
#line 109
    w = v->next;
#line 110
    fclose(v->reading);
#line 111
    js_dealloc((void *)v->filename);
#line 112
    js_dealloc((void *)v);
#line 113
    v = w;
#line 114
    a ++;
  }
#line 117
  js_dealloc((void *)file___0->filename);
#line 119
  tmp___0 = js_dealloc((void *)file___0);
#line 119
  if (tmp___0 != 1) {
#line 120
    return (-1);
  }
#line 123
  return (1);
}
}
#line 132 "Csv2_read.c"
int csv2_readchar(csv2_read *file___0 ) 
{ int out ;
  char *mstrn ;
  int tmp ;

  {
#line 133
  out = -2;
#line 134
  mstrn = (char *)"NO MACROS YET**";
#line 137
  if (file___0->ok_to_read != 1) {
#line 138
    if ((int )file___0->seen_bug_msg == 0) {
#line 139
      printf("BUG: The code shouln\'t be trying to read from");
#line 140
      printf(" a closed stream!\n");
#line 141
      file___0->seen_bug_msg = (char )((int )file___0->seen_bug_msg + 1);
    }
#line 143
    return (-2);
  }
#line 149
  if (file___0->mnum == -1) {
#line 150
    if (file___0->mplace < 0) {
#line 151
      file___0->mplace = 0;
#line 152
      file___0->mnum = 0;
    } else
#line 150
    if (file___0->mplace >= 14) {
#line 151
      file___0->mplace = 0;
#line 152
      file___0->mnum = 0;
    } else {
#line 155
      out = (int )*(mstrn + file___0->mplace);
#line 156
      if (out == 0) {
#line 157
        file___0->mplace = 0;
#line 158
        file___0->mnum = 0;
      } else {
#line 161
        (file___0->mplace) ++;
#line 162
        file___0->justread = out;
#line 163
        return (out);
      }
    }
  }
#line 169
  if (file___0->mnum == 0) {
    read_char: 
#line 171
    out = getc(file___0->reading);
#line 177
    if (out < 32) {
#line 177
      if (out >= 0) {
#line 177
        if (out != 9) {
#line 177
          if (out != 13) {
#line 177
            if (out != 10) {
#line 179
              printf("Warning: Unprintable character in zone file: %02x\n", out);
            }
          }
        }
      }
    }
#line 182
    tmp = file___0->cplace;
#line 182
    (file___0->cplace) ++;
#line 182
    file___0->context[tmp] = (char )out;
#line 183
    if (file___0->cplace == 19) {
#line 183
      file___0->cplace = 0;
    }
#line 184
    if (out == 10) {
#line 185
      (file___0->linenum) ++;
    }
#line 187
    if (out == -1) {
#line 188
      if ((unsigned long )file___0->stack != (unsigned long )((csv2_file *)0)) {
#line 189
        csv2_pop_file(file___0);
#line 190
        goto read_char;
      }
#line 192
      return (-2);
    }
#line 195
    if (out == 126) {
#line 195
      if ((int )file___0->tilde_seen < 10) {
#line 196
        file___0->tilde_seen = (char )((int )file___0->tilde_seen + 1);
      }
    }
#line 199
    if (out == 123) {
#line 199
      if (((int )file___0->chars_allowed & 2) != 2) {
#line 202
        csv2_error(file___0, (char *)"The \'{\' character is currently not allowed there in zone files.\nPlease use an unquoted \\x7b if you need this character in a txt or raw record.\nSee the csv2_txt man page for more information.");
      } else {
#line 199
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 209
    if (out == 126) {
#line 209
      if (((int )file___0->chars_allowed & 1) != 1) {
#line 211
        csv2_error(file___0, (char *)"The \'~\' character is currently not allowed there in zone files.\nPlease use an unquoted \\x7e if you need this character in a txt or raw record.\nSee the csv2_txt man page for more information.");
      } else {
#line 218
        file___0->justread = out;
#line 219
        return (out);
      }
    } else {
#line 218
      file___0->justread = out;
#line 219
      return (out);
    }
  }
#line 222
  return (out);
}
}
#line 230 "Csv2_read.c"
int csv2_justread(csv2_read *file___0 ) 
{ 

  {
#line 231
  if (file___0->ok_to_read != 1) {
#line 232
    printf("BUG: Don\'t run csv2_justread on a closed file!\n");
#line 233
    return (-1);
  }
#line 235
  return (file___0->justread);
}
}
#line 239 "Csv2_read.c"
int csv2_error(csv2_read *file___0 , char *why ) 
{ int c ;
  int lastcr ;

  {
#line 241
  printf("Error: ");
#line 242
  printf("%s\n", why);
#line 243
  printf("Error is on line ");
#line 247
  if (file___0->justread == 10) {
#line 248
    (file___0->linenum) --;
#line 249
    file___0->justread = '\000';
  }
#line 251
  printf("%d", file___0->linenum);
#line 252
  printf(" in file ");
#line 253
  printf("%s\n", file___0->filename);
#line 256
  printf("context of error: ");
#line 258
  c = file___0->cplace;
#line 263
  lastcr = -1;
#line 264
  while (1) {
#line 265
    c ++;
#line 266
    c %= 19;
#line 267
    if ((int )file___0->context[c] == 10) {
#line 267
      if (c != file___0->cplace) {
#line 268
        lastcr = c;
      }
    }
#line 264
    if (! (c != file___0->cplace)) {
#line 264
      break;
    }
  }
#line 271
  if (lastcr != -1) {
#line 272
    c = lastcr + 1;
#line 273
    c %= 19;
  }
#line 277
  if (file___0->cplace == (c + 1) % 19) {
#line 281
    printf("<near beginning of line> ");
  } else
#line 277
  if (file___0->cplace == (c + 2) % 19) {
#line 281
    printf("<near beginning of line> ");
  } else
#line 277
  if (file___0->cplace == (c + 3) % 19) {
#line 281
    printf("<near beginning of line> ");
  } else
#line 277
  if (file___0->cplace == (c + 4) % 19) {
#line 281
    printf("<near beginning of line> ");
  }
#line 285
  while (1) {
#line 286
    if ((int )file___0->context[c] >= 32) {
#line 287
      printf("%c", (int )file___0->context[c]);
    } else
#line 289
    if ((int )file___0->context[c] == 9) {
#line 290
      printf("   ");
    } else
#line 291
    if ((int )file___0->context[c] > 0) {
#line 292
      printf("~");
    }
#line 294
    c ++;
#line 295
    c %= 19;
#line 285
    if (! (c != file___0->cplace)) {
#line 285
      break;
    }
  }
#line 298
  printf(" (closing this file)\n");
#line 300
  file___0->ok_to_read = 0;
#line 301
  return (1);
}
}
#line 308 "Csv2_read.c"
int csv2_push_file(csv2_read *file___0 , js_string *filename ) 
{ csv2_file *o ;
  char *nf ;
  FILE *nfd ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 313
  if (file___0->stack_height > 7) {
#line 314
    return (0);
  }
#line 317
  if ((unsigned long )filename == (unsigned long )((js_string *)0)) {
#line 318
    return (0);
  }
#line 321
  if (filename->unit_size != 1U) {
#line 322
    return (0);
  }
#line 325
  tmp = js_alloc((int )(filename->unit_count + 3U), 1);
#line 325
  nf = (char *)tmp;
#line 325
  if ((unsigned long )nf == (unsigned long )((char *)0)) {
#line 326
    return (0);
  }
#line 329
  tmp___0 = js_js2str(filename, nf, (int )(filename->unit_count + 1U));
#line 329
  if (tmp___0 == -1) {
#line 331
    js_dealloc((void *)nf);
#line 332
    return (0);
  }
#line 335
  nfd = fopen((char const   *)nf, "rb");
#line 335
  if ((unsigned long )nfd == (unsigned long )((FILE *)0)) {
#line 336
    js_dealloc((void *)nf);
#line 337
    return (0);
  }
#line 340
  tmp___1 = js_alloc(1, (int )(sizeof(csv2_file ) + 1UL));
#line 340
  o = (csv2_file *)tmp___1;
#line 340
  if ((unsigned long )o == (unsigned long )((csv2_file *)0)) {
#line 341
    js_dealloc((void *)nf);
#line 342
    fclose(nfd);
#line 343
    return (0);
  }
#line 346
  o->filename = file___0->filename;
#line 347
  o->reading = file___0->reading;
#line 348
  o->next = file___0->stack;
#line 349
  file___0->stack = o;
#line 350
  file___0->filename = nf;
#line 351
  file___0->reading = nfd;
#line 352
  (file___0->stack_height) ++;
#line 354
  return (1);
}
}
#line 362 "Csv2_read.c"
int csv2_pop_file(csv2_read *file___0 ) 
{ csv2_file *v ;

  {
#line 364
  fclose(file___0->reading);
#line 366
  js_dealloc((void *)file___0->filename);
#line 367
  v = file___0->stack;
#line 369
  if ((unsigned long )v == (unsigned long )((csv2_file *)0)) {
#line 370
    csv2_error(file___0, (char *)"Trying to pop from empty stack");
#line 371
    return (0);
  }
#line 374
  file___0->reading = v->reading;
#line 375
  file___0->filename = v->filename;
#line 376
  file___0->stack = v->next;
#line 377
  (file___0->stack_height) --;
#line 378
  if (file___0->stack_height < 0) {
#line 379
    csv2_error(file___0, (char *)"Trying to pop from empty stack");
#line 380
    return (0);
  }
#line 382
  js_dealloc((void *)v);
#line 384
  return (1);
}
}
#line 389 "Csv2_read.c"
int csv2_set_unicode(csv2_read *file___0 , int32_t in ) 
{ 

  {
#line 390
  if (file___0->ok_to_read != 1) {
#line 391
    printf("BUG: Don\'t run csv2_set_unicode on a closed file!\n");
#line 392
    return (-1);
  }
#line 394
  file___0->unicode = in;
#line 395
  return (0);
}
}
#line 399 "Csv2_read.c"
int32_t csv2_get_unicode(csv2_read *file___0 ) 
{ 

  {
#line 400
  if (file___0->ok_to_read != 1) {
#line 401
    printf("BUG: Don\'t run csv2_get_unicode on a closed file!\n");
#line 402
    return (-1);
  }
#line 404
  return (file___0->unicode);
}
}
#line 408 "Csv2_read.c"
void csv2_allow_tilde(csv2_read *file___0 ) 
{ 

  {
#line 409
  file___0->chars_allowed = (char )((int )file___0->chars_allowed | 1);
#line 410
  return;
}
}
#line 413 "Csv2_read.c"
void csv2_forbid_tilde(csv2_read *file___0 ) 
{ 

  {
#line 414
  file___0->chars_allowed = (char )((int )file___0->chars_allowed & 126);
#line 415
  return;
}
}
#line 418 "Csv2_read.c"
void csv2_allow_leftbrace(csv2_read *file___0 ) 
{ 

  {
#line 419
  file___0->chars_allowed = (char )((int )file___0->chars_allowed | 2);
#line 420
  return;
}
}
#line 423 "Csv2_read.c"
void csv2_forbid_leftbrace(csv2_read *file___0 ) 
{ 

  {
#line 424
  file___0->chars_allowed = (char )((int )file___0->chars_allowed & 125);
#line 425
  return;
}
}
#line 428 "Csv2_read.c"
int csv2_tilde_seen(csv2_read *file___0 ) 
{ 

  {
#line 429
  return ((int )file___0->tilde_seen);
}
}
#line 433 "Csv2_read.c"
void csv2_reset_tilde_seen(csv2_read *file___0 ) 
{ 

  {
#line 434
  file___0->tilde_seen = (char)0;
#line 435
  return;
}
}
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
#line 1 "Csv2_main.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-S2h_Pp1l.i","")
#line 58 "/usr/include/secure/_string.h"
__inline static void *__inline_memcpy_chk(void *__dest , void const   *__src , size_t __len ) 
{ unsigned long tmp ;
  void *tmp___0 ;

  {
#line 61
  tmp = __builtin_object_size(__dest, 0);
#line 61
  tmp___0 = __builtin___memcpy_chk(__dest, __src, __len, tmp);
#line 61
  return (tmp___0);
}
}
#line 49 "Csv2_functions.h"
csv2_add_state *csv2_init_add_state(js_string *zone ) ;
#line 53
void csv2_zap_add_state(csv2_add_state *x ) ;
#line 58
int csv2_set_bighash(csv2_add_state *state , mhash *bighash ) ;
#line 63
int csv2_set_add_method(csv2_add_state *state , int method ) ;
#line 67
int csv2_close_state(csv2_add_state *state ) ;
#line 72
int csv2_set_soa_serial(csv2_add_state *state , js_string *filename ) ;
#line 77
js_string *csv2_zone_to_udpzone(js_string *zone ) ;
#line 143
csv2_rr *copy_csv2_rr(csv2_rr *source ) ;
#line 164
int csv2_pop_buffer(csv2_add_state *state ) ;
#line 167
int csv2_add_soa(csv2_add_state *state ) ;
#line 202
int csv2_parse_main_bighash(mhash *main_table , int32_t starwhitis ) ;
#line 222
int csv2_parse_zone_bighash(js_string *zone , js_string *filename , mhash *bighash ,
                            int32_t starwhitis ) ;
#line 224
int csv2_parse_zone(js_string *filename , csv2_add_state *state , int32_t starwhitis ) ;
#line 244
int csv2_read_rr(csv2_add_state *state , csv2_read *stream , int32_t starwhitis ) ;
#line 39 "Csv2_main.c"
ipv4pair *get_synthip_list(void) ;
#line 43 "Csv2_main.c"
int csv2_parse_main_bighash(mhash *main_table , int32_t starwhitis ) 
{ mhash *csv2s ;
  js_string *zone ;
  js_string *filename ;
  ipv4pair *iplist ;
  int x ;
  int tmp ;
  mhash *tmp___0 ;
  int tmp___1 ;
  js_string *t ;
  int tmp___2 ;

  {
#line 51
  tmp = dq_keyword2n((char *)"csv2");
#line 51
  tmp___0 = dvar_raw(tmp);
#line 51
  csv2s = tmp___0;
#line 54
  if ((unsigned long )csv2s == (unsigned long )((mhash *)0)) {
#line 55
    return (0);
  }
#line 60
  iplist = get_synthip_list();
#line 61
  x = 0;
#line 61
  while (x < 500) {
#line 62
    if ((iplist + x)->ip == 4294967295U) {
#line 63
      break;
    }
#line 65
    if ((iplist + x)->ip == 0U) {
#line 66
      printf("You can not have both csv2 zone files and have MaraDNS bind to 0.0.0.0\nMaraDNS now supports binding to multiple IPs; please use this feature.\n");
#line 71
      exit(1);
    }
#line 61
    x ++;
  }
#line 76
  zone = js_create(256U, 1U);
#line 76
  if ((unsigned long )zone == (unsigned long )((js_string *)0)) {
#line 77
    return (-1);
  }
#line 83
  tmp___1 = mhash_firstkey(csv2s, zone);
#line 83
  if (tmp___1 == 0) {
#line 84
    js_destroy(zone);
#line 85
    return (0);
  }
#line 89
  while (1) {
#line 90
    filename = mhash_get_js(csv2s, zone);
#line 91
    if ((unsigned long )zone != (unsigned long )((js_string *)0)) {
#line 94
      t = csv2_zone_to_udpzone(zone);
#line 94
      if ((unsigned long )t != (unsigned long )((js_string *)0)) {
#line 95
        csv2_parse_zone_bighash(zone, filename, main_table, starwhitis);
#line 97
        js_destroy(t);
      } else {
#line 99
        printf("Bad zone name ");
#line 100
        show_esc_stdout(zone);
#line 101
        printf(" (don\'t forget the trailing dot!)\n");
      }
    }
#line 89
    tmp___2 = mhash_nextkey(csv2s, zone);
#line 89
    if (! (tmp___2 != 0)) {
#line 89
      break;
    }
  }
#line 106
  js_destroy(zone);
#line 107
  return (0);
}
}
#line 113 "Csv2_main.c"
q_header *csv2_copy_header(q_header *in ) 
{ q_header *out ;
  void *tmp ;
  unsigned long tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  unsigned long tmp___5 ;

  {
#line 115
  tmp = js_alloc((int )sizeof(q_header ), 1);
#line 115
  out = (q_header *)tmp;
#line 115
  if ((unsigned long )out == (unsigned long )((q_header *)0)) {
#line 116
    return ((q_header *)0);
  }
#line 120
  tmp___5 = __builtin_object_size((void *)out, 0);
#line 120
  if (tmp___5 != 0xffffffffffffffffUL) {
#line 120
    tmp___1 = __builtin_object_size((void *)out, 0);
#line 120
    tmp___2 = __builtin___memcpy_chk((void *)out, (void const   *)in, sizeof(q_header ),
                                     tmp___1);
#line 120
    tmp___4 = tmp___2;
  } else {
#line 120
    tmp___3 = __inline_memcpy_chk((void *)out, (void const   *)in, sizeof(q_header ));
#line 120
    tmp___4 = tmp___3;
  }
#line 120
  if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
#line 121
    js_dealloc((void *)out);
#line 122
    return ((q_header *)0);
  }
#line 124
  return (out);
}
}
#line 131 "Csv2_main.c"
js_string *csv2_alabel_to_blabel(js_string *alabel ) 
{ js_string *tmp ;

  {
#line 132
  tmp = csv2_zone_to_udpzone(alabel);
#line 132
  return (tmp);
}
}
#line 139 "Csv2_main.c"
int csv2_append_rr(js_string *reply , csv2_rr *point ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 140
  if ((unsigned long )point == (unsigned long )((csv2_rr *)0)) {
#line 141
    return (-1);
  }
#line 143
  tmp = js_append(point->query, reply);
#line 143
  if (tmp == -1) {
#line 144
    return (-1);
  }
#line 146
  tmp___0 = js_adduint16(reply, point->rtype);
#line 146
  if (tmp___0 == -1) {
#line 147
    return (-1);
  }
#line 150
  tmp___1 = js_adduint16(reply, 1);
#line 150
  if (tmp___1 == -1) {
#line 151
    return (-1);
  }
#line 154
  js_adduint32(reply, (uint32_t )point->ttl);
#line 155
  tmp___2 = js_adduint16(reply, (int )(point->data)->unit_count);
#line 155
  if (tmp___2 == -1) {
#line 156
    return (-1);
  }
#line 158
  tmp___3 = js_append(point->data, reply);
#line 158
  if (tmp___3 == -1) {
#line 159
    return (-1);
  }
#line 161
  return (1);
}
}
#line 172 "Csv2_main.c"
int csv2_tcp_spit_data(csv2_add_state *state , int connect___0 , q_header *header ,
                       js_string *zone , int type , csv2_rr *soa ) 
{ q_header *h_copy ;
  unsigned char len[3] ;
  js_string *reply ;
  js_string *zone_name ;
  csv2_rr *point ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  csv2_rr *point___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  ssize_t tmp___7 ;
  ssize_t tmp___8 ;

  {
#line 179
  h_copy = csv2_copy_header(header);
#line 184
  h_copy->qr = 1;
#line 186
  h_copy->aa = 1;
#line 188
  h_copy->tc = 0;
#line 195
  h_copy->ra = 0;
#line 199
  h_copy->z = 0;
#line 200
  h_copy->rcode = 0;
#line 201
  h_copy->qdcount = (uint16_t )1;
#line 204
  h_copy->ancount = (uint16_t )1;
#line 205
  h_copy->nscount = (uint16_t )0;
#line 207
  h_copy->arcount = (uint16_t )0;
#line 211
  point = state->buffer;
#line 213
  if ((unsigned long )point == (unsigned long )((csv2_rr *)0)) {
#line 213
    if (type != 3) {
#line 214
      js_dealloc((void *)h_copy);
#line 215
      return (-1);
    }
  }
#line 218
  if (type != 3) {
#line 219
    point = point->next;
  }
#line 222
  if (type == 1) {
#line 223
    while ((unsigned long )point != (unsigned long )((csv2_rr *)0)) {
#line 224
      if (point->rtype != 2) {
#line 227
        break;
      }
#line 228
      h_copy->nscount = (uint16_t )((int )h_copy->nscount + 1);
#line 229
      if ((int )h_copy->nscount > 1000) {
#line 230
        js_dealloc((void *)h_copy);
#line 231
        return (-1);
      }
#line 233
      point = point->next;
    }
  }
#line 238
  reply = js_create(2048U, 1U);
#line 238
  if ((unsigned long )reply == (unsigned long )((js_string *)0)) {
#line 239
    js_dealloc((void *)h_copy);
#line 240
    return (-1);
  }
#line 244
  tmp = make_hdr(h_copy, reply);
#line 244
  if (tmp == -1) {
#line 245
    js_dealloc((void *)h_copy);
#line 246
    js_destroy(reply);
#line 247
    return (-1);
  }
#line 251
  if (type == 1) {
#line 253
    zone_name = csv2_alabel_to_blabel(zone);
#line 253
    if ((unsigned long )zone_name == (unsigned long )((js_string *)0)) {
#line 254
      js_dealloc((void *)h_copy);
#line 255
      js_destroy(reply);
#line 256
      return (-1);
    }
#line 258
    tmp___0 = js_append(zone_name, reply);
#line 258
    if (tmp___0 == -1) {
#line 259
      js_dealloc((void *)h_copy);
#line 260
      js_destroy(reply);
#line 261
      return (-1);
    }
#line 263
    tmp___1 = js_adduint16(reply, 6);
#line 263
    if (tmp___1 == -1) {
#line 264
      js_dealloc((void *)h_copy);
#line 265
      js_destroy(reply);
#line 266
      return (-1);
    }
#line 268
    js_destroy(zone_name);
  } else
#line 269
  if (type == 2) {
#line 269
    goto _L;
  } else
#line 269
  if (type == 3) {
    _L: /* CIL Label */ 
#line 271
    if (type == 2) {
#line 272
      point___0 = state->buffer;
    } else {
#line 275
      point___0 = soa;
    }
#line 277
    tmp___2 = js_append(point___0->query, reply);
#line 277
    if (tmp___2 == -1) {
#line 278
      js_dealloc((void *)h_copy);
#line 279
      js_destroy(reply);
#line 280
      return (-1);
    }
#line 282
    tmp___3 = js_adduint16(reply, point___0->rtype);
#line 282
    if (tmp___3 == -1) {
#line 283
      js_dealloc((void *)h_copy);
#line 284
      js_destroy(reply);
#line 285
      return (-1);
    }
  } else {
#line 288
    js_dealloc((void *)h_copy);
#line 289
    js_destroy(reply);
#line 290
    return (-1);
  }
#line 294
  tmp___4 = js_adduint16(reply, 1);
#line 294
  if (tmp___4 == -1) {
#line 295
    js_dealloc((void *)h_copy);
#line 296
    js_destroy(reply);
#line 297
    return (-1);
  }
#line 301
  if (type == 1) {
#line 302
    point = state->buffer;
  } else
#line 301
  if (type == 2) {
#line 302
    point = state->buffer;
  } else
#line 304
  if (type == 3) {
#line 305
    point = soa;
  }
#line 307
  tmp___5 = csv2_append_rr(reply, point);
#line 307
  if (tmp___5 == -1) {
#line 308
    js_dealloc((void *)h_copy);
#line 309
    js_destroy(reply);
#line 310
    return (-1);
  }
#line 314
  if (type == 1) {
#line 315
    point = point->next;
#line 316
    while ((unsigned long )point != (unsigned long )((csv2_rr *)0)) {
#line 317
      if (point->rtype != 2) {
#line 320
        break;
      }
#line 322
      tmp___6 = csv2_append_rr(reply, point);
#line 322
      if (tmp___6 == -1) {
#line 323
        js_dealloc((void *)h_copy);
#line 324
        js_destroy(reply);
#line 325
        return (-1);
      }
#line 327
      point = point->next;
    }
  }
#line 332
  len[0] = (unsigned char )((reply->unit_count & 65280U) >> 8);
#line 333
  len[1] = (unsigned char )(reply->unit_count & 255U);
#line 337
  tmp___7 = write(connect___0, (void const   *)(len), (size_t )2);
#line 337
  if (tmp___7 == -1L) {
#line 338
    js_dealloc((void *)h_copy);
#line 339
    js_destroy(reply);
#line 340
    return (-1);
  }
#line 342
  tmp___8 = write(connect___0, (void const   *)reply->string, (size_t )reply->unit_count);
#line 342
  if (tmp___8 == -1L) {
#line 343
    js_dealloc((void *)h_copy);
#line 344
    js_destroy(reply);
#line 345
    return (-1);
  }
#line 348
  js_dealloc((void *)h_copy);
#line 349
  js_destroy(reply);
#line 350
  return (1);
}
}
#line 355 "Csv2_main.c"
int csv2_tcp_spit_soa(csv2_add_state *state , int connect___0 , q_header *header ,
                      js_string *zone ) 
{ int tmp ;

  {
#line 357
  tmp = csv2_tcp_spit_data(state, connect___0, header, zone, 1, (csv2_rr *)0);
#line 357
  return (tmp);
}
}
#line 362 "Csv2_main.c"
int csv2_tcp_spit_buffer(csv2_add_state *state , int connect___0 , q_header *header ,
                         js_string *zone ) 
{ int tmp ;

  {
#line 364
  if (state->add_method != 2) {
#line 365
    return (-1);
  }
#line 367
  while ((unsigned long )state->buffer != (unsigned long )((csv2_rr *)0)) {
#line 368
    tmp = csv2_tcp_spit_data(state, connect___0, header, zone, 2, (csv2_rr *)0);
#line 368
    if (tmp == -1) {
#line 370
      return (-1);
    }
#line 372
    csv2_pop_buffer(state);
  }
#line 374
  return (1);
}
}
#line 389 "Csv2_main.c"
int csv2_parse_zone_zoneserver(js_string *zone , int connect___0 , int soa_q , q_header *header ) 
{ csv2_add_state *state ;
  int x ;
  csv2_read *stream ;
  csv2_rr *soa_save ;
  js_string *dvar_name ;
  js_string *filename ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int length ;
  unsigned char get[3] ;
  int tmp___4 ;
  ssize_t tmp___5 ;
  ssize_t tmp___6 ;
  ssize_t tmp___7 ;
  ssize_t tmp___8 ;
  int tmp___9 ;
  int c ;
  int q ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 399
  state = csv2_init_add_state(zone);
#line 399
  if ((unsigned long )state == (unsigned long )((csv2_add_state *)0)) {
#line 400
    return (0);
  }
#line 404
  tmp = csv2_set_add_method(state, 2);
#line 404
  if (tmp == -1) {
#line 405
    csv2_close_state(state);
#line 406
    return (0);
  }
#line 411
  filename = js_create(256U, 1U);
#line 411
  if ((unsigned long )filename == (unsigned long )((js_string *)0)) {
#line 412
    csv2_close_state(state);
#line 413
    return (0);
  }
#line 415
  dvar_name = js_create(6U, 1U);
#line 415
  if ((unsigned long )dvar_name == (unsigned long )((js_string *)0)) {
#line 416
    js_destroy(filename);
#line 417
    csv2_close_state(state);
#line 418
    return (0);
  }
#line 420
  tmp___0 = js_qstr2js(dvar_name, (char *)"csv2");
#line 420
  if (tmp___0 == -1) {
#line 421
    js_destroy(filename);
#line 422
    js_destroy(dvar_name);
#line 423
    csv2_close_state(state);
#line 424
    return (0);
  }
#line 426
  tmp___1 = read_dvar(dvar_name, zone, filename);
#line 426
  if (tmp___1 == -1) {
#line 427
    js_destroy(filename);
#line 428
    js_destroy(dvar_name);
#line 429
    csv2_close_state(state);
#line 430
    return (0);
  }
#line 436
  tmp___2 = csv2_set_soa_serial(state, filename);
#line 436
  if (tmp___2 == -1) {
#line 437
    printf("Error running stat() on ");
#line 438
    show_esc_stdout(filename);
#line 439
    printf("\n");
  }
#line 443
  stream = csv2_open(filename);
#line 444
  if ((unsigned long )stream == (unsigned long )((csv2_read *)0)) {
#line 445
    printf("Error opening ");
#line 446
    show_esc_stdout(filename);
#line 447
    printf("\n");
#line 448
    csv2_zap_add_state(state);
#line 449
    return (0);
  }
#line 455
  x = 0;
#line 455
  while (x < 29) {
#line 456
    if (state->in_ns != 1) {
#line 457
      break;
    }
#line 459
    tmp___3 = csv2_read_rr(state, stream, 0);
#line 459
    if (tmp___3 < 0) {
#line 460
      break;
    }
#line 455
    x ++;
  }
#line 466
  if (soa_q == 1) {
#line 469
    tmp___4 = csv2_tcp_spit_soa(state, connect___0, header, zone);
#line 469
    if (tmp___4 == -1) {
#line 471
      csv2_zap_add_state(state);
#line 472
      return (-1);
    }
#line 475
    if (connect___0 == 1) {
#line 476
      tmp___5 = read(0, (void *)(get), (size_t )2);
#line 476
      if (tmp___5 != 1L) {
#line 477
        csv2_zap_add_state(state);
#line 478
        return (-1);
      }
    } else {
#line 481
      tmp___6 = recv(connect___0, (void *)(get), (size_t )2, 0);
#line 481
      if (tmp___6 != 2L) {
#line 482
        csv2_zap_add_state(state);
#line 483
        return (-1);
      }
    }
#line 486
    length = (((int )get[0] & 255) << 8) | ((int )get[1] & 255);
#line 488
    while (length > 0) {
#line 489
      if (connect___0 == 1) {
#line 490
        tmp___7 = read(0, (void *)(get), (size_t )1);
#line 490
        if (tmp___7 != 1L) {
#line 491
          csv2_zap_add_state(state);
#line 492
          return (-1);
        }
      } else {
#line 495
        tmp___8 = recv(connect___0, (void *)(get), (size_t )1, 64);
#line 495
        if (tmp___8 != 1L) {
#line 496
          csv2_zap_add_state(state);
#line 497
          return (-1);
        }
      }
#line 500
      length --;
    }
  }
#line 509
  soa_save = copy_csv2_rr(state->buffer);
#line 512
  tmp___9 = csv2_tcp_spit_buffer(state, connect___0, header, zone);
#line 512
  if (tmp___9 == -1) {
#line 513
    js_dealloc((void *)soa_save);
#line 514
    csv2_zap_add_state(state);
#line 515
    return (-1);
  }
#line 519
  x = 0;
#line 519
  while (x < 100000) {
#line 522
    q = 0;
#line 523
    c = 0;
#line 523
    while (c < 20) {
#line 524
      q = csv2_read_rr(state, stream, 0);
#line 525
      if (q < 0) {
#line 526
        break;
      }
#line 523
      c ++;
    }
#line 530
    tmp___10 = csv2_tcp_spit_buffer(state, connect___0, header, zone);
#line 530
    if (tmp___10 == -1) {
#line 532
      js_dealloc((void *)soa_save);
#line 533
      csv2_zap_add_state(state);
#line 534
      return (-1);
    }
#line 537
    if (q < 0) {
#line 538
      break;
    }
#line 519
    x ++;
  }
#line 544
  tmp___11 = csv2_tcp_spit_data(state, connect___0, header, zone, 3, soa_save);
#line 544
  if (tmp___11 == -1) {
#line 546
    js_dealloc((void *)soa_save);
#line 547
    csv2_zap_add_state(state);
#line 548
    return (-1);
  }
#line 550
  csv2_zap_add_state(state);
#line 551
  return (1);
}
}
#line 556 "Csv2_main.c"
int csv2_parse_zone_bighash(js_string *zone , js_string *filename , mhash *bighash ,
                            int32_t starwhitis ) 
{ csv2_add_state *state ;
  int nostar ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 563
  nostar = 0;
#line 563
  while ((unsigned int )nostar < zone->unit_size * zone->unit_count) {
#line 565
    if ((int )*(zone->string + nostar) == 42) {
#line 565
      if (zone->unit_count > 1U) {
#line 566
        printf("Illegal zone name: ");
#line 567
        nostar = 0;
#line 567
        while ((unsigned int )nostar < zone->unit_size * zone->unit_count) {
#line 569
          printf("%c", (int )*(zone->string + nostar));
#line 567
          nostar ++;
        }
#line 571
        printf("\nThis is a fatal error.\n");
#line 572
        exit(1);
      }
    }
#line 563
    nostar ++;
  }
#line 576
  state = csv2_init_add_state(zone);
#line 576
  if ((unsigned long )state == (unsigned long )((csv2_add_state *)0)) {
#line 577
    return (0);
  }
#line 579
  tmp = csv2_set_bighash(state, bighash);
#line 579
  if (tmp == -1) {
#line 580
    csv2_close_state(state);
#line 581
    return (0);
  }
#line 583
  if (starwhitis == 0) {
#line 584
    tmp___0 = csv2_set_add_method(state, 1);
#line 584
    if (tmp___0 == -1) {
#line 585
      csv2_close_state(state);
#line 586
      return (0);
    }
  } else
#line 588
  if (starwhitis == 1) {
#line 589
    tmp___1 = csv2_set_add_method(state, 3);
#line 589
    if (tmp___1 == -1) {
#line 590
      csv2_close_state(state);
#line 591
      return (0);
    }
  } else {
#line 594
    printf("FATAL: Illegal value %d for starwhitis\n", starwhitis);
#line 595
    exit(1);
  }
#line 598
  tmp___2 = csv2_parse_zone(filename, state, starwhitis);
#line 598
  return (tmp___2);
}
}
#line 602 "Csv2_main.c"
int csv2_parse_zone(js_string *filename , csv2_add_state *state , int32_t starwhitis ) 
{ csv2_read *stream ;
  int x ;
  int tmp ;
  int tmp___0 ;

  {
#line 607
  printf("Processing zone ");
#line 608
  show_esc_stdout(state->zone);
#line 609
  printf(" right now.\n");
#line 610
  printf("Filename: ");
#line 611
  show_esc_stdout(filename);
#line 612
  printf("\n");
#line 617
  tmp = csv2_set_soa_serial(state, filename);
#line 617
  if (tmp == -1) {
#line 618
    printf("Error running stat() on ");
#line 619
    show_esc_stdout(filename);
#line 620
    printf("\n");
  }
#line 623
  stream = csv2_open(filename);
#line 624
  if ((unsigned long )stream == (unsigned long )((csv2_read *)0)) {
#line 625
    printf("Error opening ");
#line 626
    show_esc_stdout(filename);
#line 627
    printf("\n");
#line 628
    csv2_zap_add_state(state);
#line 629
    return (0);
  }
#line 634
  x = 0;
#line 634
  while (x < 100000) {
#line 635
    tmp___0 = csv2_read_rr(state, stream, starwhitis);
#line 635
    if (tmp___0 < 0) {
#line 636
      break;
    }
#line 634
    x ++;
  }
#line 639
  csv2_close(stream);
#line 642
  if (state->in_ns == 1) {
#line 643
    csv2_add_soa(state);
  }
#line 645
  csv2_zap_add_state(state);
#line 646
  return (0);
}
}
#line 1 "Csv2_parse.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-W9MxSbUH.i","")
#line 23 "Csv2_functions.h"
int starrecord_to_meta(js_string *rr___0 , int recursive ) ;
#line 176
int csv2_add_rr(csv2_add_state *state , js_string *query , int rtype , int32_t ttl ,
                js_string *data ) ;
#line 188
js_string *csv2_get_txt(csv2_read *stream , int numchunks ) ;
#line 193
js_string *csv2_get_raw(csv2_read *stream ) ;
#line 220
js_string *process_1stchar(csv2_read *stream , int (*is_ok)(int32_t in ) , char *pre ) ;
#line 226
int csv2_see_char(int32_t in , char *list ) ;
#line 227
int csv2_is_number(int32_t in ) ;
#line 228
int csv2_is_upper(int32_t in ) ;
#line 229
int csv2_is_lower(int32_t in ) ;
#line 230
int csv2_is_hibit(int32_t in ) ;
#line 231
int csv2_is_delimiter(int in ) ;
#line 232
int32_t csv2_get_utf8(csv2_read *stream ) ;
#line 233
int32_t csv2_read_unicode(csv2_read *stream ) ;
#line 234
int csv2_append_utf8(js_string *toappend , int32_t in ) ;
#line 235
int csv2_get_1st(csv2_read *stream , int (*is_ok)(int32_t in ) , int options ) ;
#line 236
int csv2_is_alpha(int32_t in ) ;
#line 237
int csv2_is_alphanum(int32_t in ) ;
#line 238
int csv2_is_text(int32_t in ) ;
#line 239
int csv2_is_dchar(int32_t in ) ;
#line 240
int csv2_is_starwhitis(int32_t in ) ;
#line 241
int csv2_numeric_rtype(js_string *text_rtype ) ;
#line 242
int32_t csv2_get_rtype(csv2_read *stream ) ;
#line 243
int32_t csv2_get_num(csv2_read *stream ) ;
#line 245
void process_comment(csv2_read *stream ) ;
#line 246
js_string *process_something(csv2_read *stream , int (*is_ok)(int32_t in ) ) ;
#line 247
js_string *process_number(csv2_read *stream ) ;
#line 248
js_string *process_textlabel(csv2_read *stream ) ;
#line 249
js_string *process_dname(csv2_read *stream , int starwhitis ) ;
#line 250
js_string *js_append_dname(js_string *o , csv2_read *stream , int starwhitis ) ;
#line 251
js_string *csv2_get_hostname(csv2_read *stream , js_string *zonename , int starwhitis ) ;
#line 253
js_string *csv2_get_dname(csv2_read *stream ) ;
#line 254
js_string *csv2_get_soa(csv2_read *stream , js_string *zone , csv2_add_state *state ) ;
#line 256
js_string *csv2_convert_percent(js_string *in , js_string *psub ) ;
#line 269
js_string *csv2_get_a(csv2_read *stream ) ;
#line 275
js_string *csv2_get_aaaa(csv2_read *stream ) ;
#line 282
js_string *csv2_get_wks(csv2_read *stream ) ;
#line 283
js_string *csv2_get_mbox(csv2_read *stream , js_string *zone , int count ) ;
#line 284
js_string *csv2_get_hex(csv2_read *stream ) ;
#line 285
js_string *csv2_get_loc(csv2_read *stream ) ;
#line 286
js_string *csv2_get_naptr(csv2_read *stream ) ;
#line 44 "Csv2_parse.c"
int csv2_see_char(int32_t in , char *list ) 
{ int counter ;

  {
#line 45
  counter = 0;
#line 46
  if ((unsigned long )list == (unsigned long )((char *)0)) {
#line 47
    return (0);
  }
#line 49
  while (1) {
#line 49
    if ((int )*list != 0) {
#line 49
      counter ++;
#line 49
      if (! (counter < 128)) {
#line 49
        break;
      }
    } else {
#line 49
      break;
    }
#line 50
    if ((int )*list == in) {
#line 51
      return (1);
    }
#line 53
    list ++;
  }
#line 55
  return (0);
}
}
#line 62 "Csv2_parse.c"
int csv2_is_number(int32_t in ) 
{ int tmp ;

  {
#line 63
  if (in >= 48) {
#line 63
    if (in <= 57) {
#line 63
      tmp = 1;
    } else {
#line 63
      tmp = 0;
    }
  } else {
#line 63
    tmp = 0;
  }
#line 63
  return (tmp);
}
}
#line 69 "Csv2_parse.c"
int csv2_is_number_orslash(int32_t in ) 
{ int tmp ;

  {
#line 70
  if (in >= 48) {
#line 70
    if (in <= 57) {
#line 70
      tmp = 1;
    } else {
#line 70
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 70
  if (in == 47) {
#line 70
    tmp = 1;
  } else {
#line 70
    tmp = 0;
  }
#line 70
  return (tmp);
}
}
#line 76 "Csv2_parse.c"
int csv2_is_upper(int32_t in ) 
{ int tmp ;

  {
#line 77
  if (in >= 65) {
#line 77
    if (in <= 90) {
#line 77
      tmp = 1;
    } else {
#line 77
      tmp = 0;
    }
  } else {
#line 77
    tmp = 0;
  }
#line 77
  return (tmp);
}
}
#line 83 "Csv2_parse.c"
int csv2_is_lower(int32_t in ) 
{ int tmp ;

  {
#line 84
  if (in >= 97) {
#line 84
    if (in <= 122) {
#line 84
      tmp = 1;
    } else {
#line 84
      tmp = 0;
    }
  } else {
#line 84
    tmp = 0;
  }
#line 84
  return (tmp);
}
}
#line 90 "Csv2_parse.c"
int csv2_is_hibit(int32_t in ) 
{ int tmp ;

  {
#line 91
  if (in >= 128) {
#line 91
    if (in <= 253) {
#line 91
      tmp = 1;
    } else {
#line 91
      tmp = 0;
    }
  } else {
#line 91
    tmp = 0;
  }
#line 91
  return (tmp);
}
}
#line 97 "Csv2_parse.c"
int csv2_is_delimiter(int in ) 
{ int tmp ;

  {
#line 98
  if (in == 13) {
#line 98
    tmp = 1;
  } else
#line 98
  if (in == 10) {
#line 98
    tmp = 1;
  } else
#line 98
  if (in == 9) {
#line 98
    tmp = 1;
  } else
#line 98
  if (in == 32) {
#line 98
    tmp = 1;
  } else
#line 98
  if (in == 124) {
#line 98
    tmp = 1;
  } else {
#line 98
    tmp = 0;
  }
#line 98
  return (tmp);
}
}
#line 104 "Csv2_parse.c"
int csv2_isnt_delimiter(int in ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 105
  tmp = csv2_is_delimiter(in);
#line 105
  if (tmp) {
#line 105
    tmp___0 = 0;
  } else {
#line 105
    tmp___0 = 1;
  }
#line 105
  return (tmp___0);
}
}
#line 115 "Csv2_parse.c"
int csv2_utf8_length(int in ) 
{ 

  {
#line 116
  if (in >= 254) {
#line 117
    return (-2);
  }
#line 119
  if (in < 0) {
#line 120
    return (-1);
  }
#line 122
  if (in < 128) {
#line 122
    if (in > 0) {
#line 123
      return (0);
    }
  }
#line 125
  if (in >= 128) {
#line 125
    if (in < 192) {
#line 126
      return (1);
    }
  }
#line 128
  if (in >= 192) {
#line 128
    if (in < 224) {
#line 129
      return (2);
    }
  }
#line 131
  if (in >= 224) {
#line 131
    if (in < 240) {
#line 132
      return (3);
    }
  }
#line 134
  if (in >= 240) {
#line 134
    if (in < 248) {
#line 135
      return (4);
    }
  }
#line 137
  if (in >= 248) {
#line 137
    if (in < 252) {
#line 138
      return (5);
    }
  }
#line 140
  if (in >= 252) {
#line 140
    if (in < 254) {
#line 141
      return (6);
    }
  }
#line 143
  return (-1);
}
}
#line 155 "Csv2_parse.c"
int32_t csv2_get_utf8(csv2_read *stream ) 
{ int32_t in ;
  int32_t out ;
  int len ;
  int count ;

  {
#line 158
  in = csv2_justread(stream);
#line 159
  len = csv2_utf8_length(in);
#line 162
  if (len < 2) {
#line 163
    csv2_error(stream, (char *)"Invalid UTF-8 sequence");
#line 164
    return (-164);
  }
#line 169
  out = in;
#line 170
  if (len == 2) {
#line 171
    out &= 31;
  } else
#line 172
  if (len == 3) {
#line 173
    out &= 15;
  } else
#line 174
  if (len == 4) {
#line 175
    out &= 7;
  } else
#line 176
  if (len == 5) {
#line 177
    out &= 3;
  } else
#line 178
  if (len == 6) {
#line 179
    out &= 1;
  } else {
#line 181
    csv2_error(stream, (char *)"Fatal error parsing UTF-8");
#line 182
    return (-164);
  }
#line 185
  count = len;
#line 187
  while (len > 1) {
#line 188
    out <<= 6;
#line 189
    in = csv2_readchar(stream);
#line 190
    if (in == -2) {
#line 191
      csv2_error(stream, (char *)"EOF in middle of UTF-8 sequence");
#line 192
      return (-164);
    }
#line 194
    if (in < 128) {
#line 195
      csv2_error(stream, (char *)"Invalid char in UTF-8 sequence");
#line 196
      return (-164);
    } else
#line 194
    if (in >= 192) {
#line 195
      csv2_error(stream, (char *)"Invalid char in UTF-8 sequence");
#line 196
      return (-164);
    }
#line 198
    in &= 63;
#line 199
    out |= in;
#line 200
    len --;
  }
#line 205
  if (out < 128) {
#line 206
    csv2_error(stream, (char *)"UTF-8 sequence too long");
#line 207
    return (-164);
  }
#line 209
  if (out < 2048) {
#line 209
    if (count > 2) {
#line 210
      csv2_error(stream, (char *)"UTF-8 sequence too long");
#line 211
      return (-164);
    }
  }
#line 213
  if (out < 65536) {
#line 213
    if (count > 3) {
#line 214
      csv2_error(stream, (char *)"UTF-8 sequence too long");
#line 215
      return (-164);
    }
  }
#line 217
  if (out < 2097152) {
#line 217
    if (count > 4) {
#line 218
      csv2_error(stream, (char *)"UTF-8 sequence too long");
#line 219
      return (-164);
    }
  }
#line 221
  if (out < 67108864) {
#line 221
    if (count > 5) {
#line 222
      csv2_error(stream, (char *)"UTF-8 sequence too long");
#line 223
      return (-164);
    }
  }
#line 226
  csv2_set_unicode(stream, out);
#line 227
  return (out);
}
}
#line 239 "Csv2_parse.c"
int32_t csv2_read_unicode(csv2_read *stream ) 
{ int32_t out ;
  int32_t tmp ;

  {
#line 241
  out = csv2_readchar(stream);
#line 242
  if (out < 0) {
#line 243
    return (out);
  }
#line 245
  if (out > 127) {
#line 246
    tmp = csv2_get_utf8(stream);
#line 246
    return (tmp);
  }
#line 248
  return (out);
}
}
#line 261 "Csv2_parse.c"
int csv2_append_utf8(js_string *toappend , int32_t in ) 
{ int tmp ;
  int temp[6] ;
  int counter ;
  int place ;
  int32_t shift ;

  {
#line 262
  tmp = js_has_sanity(toappend);
#line 262
  if (tmp == -1) {
#line 263
    return (-1);
  }
#line 266
  if (toappend->unit_size != 1U) {
#line 267
    return (-1);
  }
#line 270
  if (in < 0) {
#line 271
    return (-1);
  }
#line 275
  if (in < 128) {
#line 276
    if (toappend->unit_count + 1U > toappend->max_count) {
#line 277
      return (-1);
    }
#line 279
    *(toappend->string + toappend->unit_count) = (unsigned char )in;
#line 280
    (toappend->unit_count) ++;
#line 281
    return (1);
  } else {
#line 289
    shift = in;
#line 290
    counter = 5;
#line 291
    while (1) {
#line 291
      if (counter >= 0) {
#line 291
        if (! (shift > 0)) {
#line 291
          break;
        }
      } else {
#line 291
        break;
      }
#line 292
      temp[counter] = shift & 63;
#line 293
      shift >>= 6;
#line 294
      counter --;
    }
#line 296
    counter ++;
#line 297
    place = counter;
#line 298
    if (counter == 0) {
#line 299
      temp[counter] |= 252;
    } else
#line 300
    if (counter == 1) {
#line 301
      temp[counter] |= 248;
    } else
#line 302
    if (counter == 2) {
#line 303
      temp[counter] |= 240;
    } else
#line 304
    if (counter == 3) {
#line 305
      temp[counter] |= 224;
    } else
#line 306
    if (counter == 4) {
#line 307
      temp[counter] |= 192;
    } else {
#line 309
      return (-1);
    }
#line 310
    counter ++;
#line 310
    while (counter < 6) {
#line 311
      temp[counter] |= 128;
#line 310
      counter ++;
    }
#line 312
    counter = place;
#line 313
    while (counter < 6) {
#line 314
      if (toappend->unit_count + 1U > toappend->max_count) {
#line 315
        return (-1);
      }
#line 317
      *(toappend->string + toappend->unit_count) = (unsigned char )temp[counter];
#line 319
      (toappend->unit_count) ++;
#line 320
      counter ++;
    }
  }
#line 323
  return (1);
}
}
#line 327 "Csv2_parse.c"
void process_comment(csv2_read *stream ) 
{ int in ;
  int q ;
  int z ;

  {
#line 329
  q = 1;
#line 331
  z = (int )stream->chars_allowed;
#line 332
  csv2_allow_tilde(stream);
#line 333
  while (1) {
#line 334
    in = csv2_readchar(stream);
#line 336
    if (in == 126) {
#line 337
      stream->tilde_seen = (char )((int )stream->tilde_seen - 1);
    }
#line 339
    q ++;
#line 340
    if (q > 5000) {
#line 341
      csv2_error(stream, (char *)"Comment too long");
#line 342
      return;
    }
#line 333
    if (in != 10) {
#line 333
      if (in != 13) {
#line 333
        if (! (in != -2)) {
#line 333
          break;
        }
      } else {
#line 333
        break;
      }
    } else {
#line 333
      break;
    }
  }
#line 345
  stream->chars_allowed = (char )z;
#line 346
  return;
}
}
#line 350 "Csv2_parse.c"
int csv2_tilde_processing(csv2_read *stream ) 
{ int permitted ;
  int seen ;

  {
#line 354
  permitted = 0;
#line 359
  seen = csv2_tilde_seen(stream);
#line 361
  if ((int )stream->tilde_handling > 100) {
#line 362
    switch ((int )stream->tilde_handling) {
    case 101: 
#line 364
    permitted = 0;
#line 365
    break;
    case 102: 
#line 367
    permitted = -2;
#line 368
    break;
    case 103: 
#line 370
    permitted = 1;
#line 371
    break;
    }
#line 373
    if (seen > 1) {
#line 374
      csv2_error(stream, (char *)"A maximum of one tilde is allowed between records.\nIf you need tildes, set csv2_tilde_handling to 0");
#line 377
      return (-1);
    }
#line 379
    if (permitted != -2) {
#line 379
      if (seen != permitted) {
#line 380
        if (permitted == 0) {
#line 381
          csv2_error(stream, (char *)"No tildes allowed between RRs");
        } else
#line 383
        if (permitted == 1) {
#line 384
          csv2_error(stream, (char *)"You must have one tilde (~) between RRs");
        }
#line 387
        return (-1);
      }
    }
#line 389
    if (permitted == -2) {
#line 390
      if (seen == 1) {
#line 391
        stream->tilde_handling = (char)103;
      } else {
#line 393
        stream->tilde_handling = (char)101;
      }
    }
#line 397
    csv2_forbid_tilde(stream);
  } else
#line 404
  if ((int )stream->tilde_handling > 0) {
#line 404
    if ((int )stream->tilde_handling < 20) {
#line 405
      stream->tilde_handling = (char )((int )stream->tilde_handling + 100);
    }
  }
#line 407
  return (1);
}
}
#line 420 "Csv2_parse.c"
int csv2_get_1st(csv2_read *stream , int (*is_ok)(int32_t in ) , int options ) 
{ int32_t in ;
  int x ;
  int lastin ;
  int pipe_already_seen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 423
  lastin = 0;
#line 424
  pipe_already_seen = 0;
#line 426
  in = csv2_justread(stream);
#line 427
  if (in > 127) {
#line 428
    in = csv2_get_unicode(stream);
  }
#line 430
  if (in > 127) {
#line 431
    in = csv2_get_unicode(stream);
  }
#line 435
  if (options != 1) {
#line 435
    tmp = (*is_ok)(in);
#line 435
    if (tmp) {
#line 436
      return (1);
    }
  }
#line 440
  if (options == 1) {
#line 440
    if (in == -328) {
#line 440
      tmp___1 = (*is_ok)(in);
#line 440
      if (tmp___1) {
#line 441
        tmp___0 = csv2_tilde_processing(stream);
#line 441
        return (tmp___0);
      }
    }
  }
#line 444
  if (options == 2) {
#line 444
    tmp___2 = (*is_ok)(in);
#line 444
    if (tmp___2) {
#line 445
      csv2_error(stream, (char *)"At least one whitespace character or | must be before this field");
#line 447
      return (-164);
    }
  }
#line 451
  if (options == 1) {
#line 451
    if (in == 46) {
#line 452
      tmp___3 = csv2_tilde_processing(stream);
#line 452
      return (tmp___3);
    }
  }
#line 458
  if (in != -328) {
#line 458
    tmp___4 = csv2_is_delimiter(in);
#line 458
    if (! tmp___4) {
#line 458
      if (in == 126) {
#line 458
        if (! ((int )stream->tilde_handling == 103)) {
#line 460
          csv2_error(stream, (char *)"Unexpected character");
#line 461
          return (-164);
        }
      } else {
#line 460
        csv2_error(stream, (char *)"Unexpected character");
#line 461
        return (-164);
      }
    }
  }
#line 464
  if (in == 124) {
#line 465
    pipe_already_seen = 1;
  }
#line 470
  if (options == 1) {
#line 471
    switch ((int )stream->tilde_handling) {
    case 101: 
#line 473
    csv2_forbid_tilde(stream);
#line 474
    break;
    case 102: 
    case 103: 
#line 477
    csv2_allow_tilde(stream);
#line 478
    break;
    }
#line 481
    csv2_reset_tilde_seen(stream);
#line 483
    if (in == 126) {
#line 484
      stream->tilde_seen = (char )((int )stream->tilde_seen + 1);
    }
  }
#line 488
  x = 0;
#line 488
  while (x < 10000) {
#line 489
    lastin = in;
#line 490
    in = csv2_read_unicode(stream);
#line 491
    if (in == -164) {
#line 492
      return (-1);
    }
#line 494
    if (in == -2) {
#line 495
      return (-2);
    }
#line 498
    if (in == 35) {
#line 499
      process_comment(stream);
#line 500
      in = '\n';
    } else
#line 502
    if (options != 1) {
#line 502
      tmp___10 = (*is_ok)(in);
#line 502
      if (tmp___10) {
#line 503
        return (1);
      } else {
#line 502
        goto _L___6;
      }
    } else
    _L___6: /* CIL Label */ 
#line 505
    if (options == 1) {
#line 505
      if (lastin == 13) {
#line 505
        goto _L___5;
      } else
#line 505
      if (lastin == 10) {
#line 505
        goto _L___5;
      } else
#line 505
      if (lastin == -328) {
        _L___5: /* CIL Label */ 
#line 505
        tmp___9 = (*is_ok)(in);
#line 505
        if (tmp___9) {
#line 508
          tmp___5 = csv2_tilde_processing(stream);
#line 508
          return (tmp___5);
        } else {
#line 505
          goto _L___4;
        }
      } else {
#line 505
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 510
    if (options == 1) {
#line 510
      tmp___8 = (*is_ok)(in);
#line 510
      if (tmp___8) {
#line 511
        csv2_error(stream, (char *)"Host name must be at the beginning of a line");
#line 513
        return (-164);
      } else {
#line 510
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 516
    if (options == 1) {
#line 516
      if (in == 46) {
#line 517
        tmp___6 = csv2_tilde_processing(stream);
#line 517
        return (tmp___6);
      } else {
#line 516
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 519
    if (in == 124) {
#line 520
      if (pipe_already_seen == 1) {
#line 521
        csv2_error(stream, (char *)"Only one pipe (|) character is allowed between fields");
#line 523
        return (-164);
      } else {
#line 525
        pipe_already_seen = 1;
      }
    } else
#line 529
    if (in == 126) {
#line 529
      if (options == 1) {
#line 529
        if ((int )stream->tilde_handling > 100) {
#line 531
          goto __Cont;
        } else {
#line 529
          goto _L___0;
        }
      } else {
#line 529
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 534
      tmp___7 = csv2_is_delimiter(in);
#line 534
      if (! tmp___7) {
#line 535
        csv2_error(stream, (char *)"Unexpected character");
#line 536
        return (-164);
      }
    }
#line 538
    if (in == -2) {
#line 539
      if (options == 1) {
#line 540
        tmp___11 = csv2_tilde_processing(stream);
#line 540
        return (tmp___11);
      }
#line 542
      return (1);
    }
    __Cont: /* CIL Label */ 
#line 488
    x ++;
  }
#line 545
  return (-1);
}
}
#line 553 "Csv2_parse.c"
js_string *process_1stchar(csv2_read *stream , int (*is_ok)(int32_t in ) , char *pre ) 
{ js_string *o ;
  int32_t look ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 559
  look = csv2_justread(stream);
#line 560
  if (look >= 192) {
#line 560
    if (look < 254) {
#line 561
      look = csv2_get_utf8(stream);
    } else {
#line 560
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 563
  if (look >= 128) {
#line 564
    look = csv2_get_unicode(stream);
  }
#line 567
  if (look == -164) {
#line 568
    return ((js_string *)0);
  }
#line 570
  tmp = (*is_ok)(look);
#line 570
  if (! tmp) {
#line 571
    csv2_error(stream, (char *)"Unexpected character");
#line 572
    return ((js_string *)0);
  }
#line 577
  o = js_create(256U, 1U);
#line 578
  if ((unsigned long )o == (unsigned long )((js_string *)0)) {
#line 579
    return ((js_string *)0);
  }
#line 581
  tmp___0 = js_set_encode(o, 2);
#line 581
  if (tmp___0 == -1) {
#line 582
    js_destroy(o);
#line 583
    return ((js_string *)0);
  }
#line 587
  if ((unsigned long )pre != (unsigned long )((char *)0)) {
#line 587
    tmp___1 = js_qstr2js(o, pre);
#line 587
    if (tmp___1 != 1) {
#line 588
      csv2_error(stream, (char *)"Error prepending pre");
#line 589
      js_destroy(o);
#line 590
      return ((js_string *)0);
    }
  }
#line 594
  tmp___2 = csv2_append_utf8(o, look);
#line 594
  if (tmp___2 < 0) {
#line 595
    csv2_error(stream, (char *)"Error appending character");
#line 596
    js_destroy(o);
#line 597
    return ((js_string *)0);
  }
#line 600
  return (o);
}
}
#line 608 "Csv2_parse.c"
js_string *process_something(csv2_read *stream , int (*is_ok)(int32_t in ) ) 
{ js_string *o ;
  int32_t look ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 614
  o = process_1stchar(stream, is_ok, (char *)0);
#line 615
  if ((unsigned long )o == (unsigned long )((js_string *)0)) {
#line 616
    return ((js_string *)0);
  }
#line 619
  while (1) {
#line 620
    look = csv2_read_unicode(stream);
#line 621
    if (look == -164) {
#line 622
      js_destroy(o);
#line 623
      return ((js_string *)0);
    }
#line 625
    if (look == 35) {
#line 626
      process_comment(stream);
#line 627
      return (o);
    }
#line 629
    tmp = (*is_ok)(look);
#line 629
    if (! tmp) {
#line 629
      tmp___0 = csv2_is_delimiter(look);
#line 629
      if (! tmp___0) {
#line 630
        csv2_error(stream, (char *)"Unexpected character");
#line 631
        js_destroy(o);
#line 632
        return ((js_string *)0);
      }
    }
#line 634
    tmp___1 = (*is_ok)(look);
#line 634
    if (tmp___1) {
#line 634
      tmp___2 = csv2_append_utf8(o, look);
#line 634
      if (tmp___2 < 0) {
#line 635
        csv2_error(stream, (char *)"Error appending character");
#line 636
        js_destroy(o);
#line 637
        return ((js_string *)0);
      }
    }
#line 619
    tmp___3 = (*is_ok)(look);
#line 619
    if (! tmp___3) {
#line 619
      break;
    }
  }
#line 641
  return (o);
}
}
#line 645 "Csv2_parse.c"
int csv2_is_alpha(int32_t in ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 646
  tmp = csv2_is_lower(in);
#line 646
  if (tmp) {
#line 646
    tmp___1 = 1;
  } else {
#line 646
    tmp___0 = csv2_is_upper(in);
#line 646
    if (tmp___0) {
#line 646
      tmp___1 = 1;
    } else {
#line 646
      tmp___1 = 0;
    }
  }
#line 646
  return (tmp___1);
}
}
#line 650 "Csv2_parse.c"
int csv2_is_alphanum(int32_t in ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 651
  tmp = csv2_is_alpha(in);
#line 651
  if (tmp) {
#line 651
    tmp___1 = 1;
  } else {
#line 651
    tmp___0 = csv2_is_number(in);
#line 651
    if (tmp___0) {
#line 651
      tmp___1 = 1;
    } else
#line 651
    if (in == 45) {
#line 651
      tmp___1 = 1;
    } else
#line 651
    if (in == 95) {
#line 651
      tmp___1 = 1;
    } else {
#line 651
      tmp___1 = 0;
    }
  }
#line 651
  return (tmp___1);
}
}
#line 656 "Csv2_parse.c"
int csv2_is_alphanum_orplus(int32_t in ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 657
  tmp = csv2_is_alphanum(in);
#line 657
  if (tmp) {
#line 657
    tmp___0 = 1;
  } else
#line 657
  if (in == 43) {
#line 657
    tmp___0 = 1;
  } else {
#line 657
    tmp___0 = 0;
  }
#line 657
  return (tmp___0);
}
}
#line 661 "Csv2_parse.c"
int csv2_is_text(int32_t in ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 662
  tmp = csv2_is_alphanum(in);
#line 662
  if (tmp) {
#line 662
    tmp___0 = 1;
  } else
#line 662
  if (in > 127) {
#line 662
    tmp___0 = 1;
  } else {
#line 662
    tmp___0 = 0;
  }
#line 662
  return (tmp___0);
}
}
#line 666 "Csv2_parse.c"
int csv2_is_dchar(int32_t in ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 667
  tmp = csv2_is_text(in);
#line 667
  if (tmp) {
#line 667
    tmp___0 = 1;
  } else
#line 667
  if (in == 37) {
#line 667
    tmp___0 = 1;
  } else {
#line 667
    tmp___0 = 0;
  }
#line 667
  return (tmp___0);
}
}
#line 671 "Csv2_parse.c"
int csv2_is_fchar(int32_t in ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 672
  tmp = csv2_is_text(in);
#line 672
  if (tmp) {
#line 672
    tmp___0 = 1;
  } else
#line 672
  if (in == 46) {
#line 672
    tmp___0 = 1;
  } else {
#line 672
    tmp___0 = 0;
  }
#line 672
  return (tmp___0);
}
}
#line 676 "Csv2_parse.c"
int csv2_is_starwhitis(int32_t in ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 677
  tmp = csv2_is_text(in);
#line 677
  if (tmp) {
#line 677
    tmp___0 = 1;
  } else
#line 677
  if (in == 42) {
#line 677
    tmp___0 = 1;
  } else
#line 677
  if (in == 37) {
#line 677
    tmp___0 = 1;
  } else {
#line 677
    tmp___0 = 0;
  }
#line 677
  return (tmp___0);
}
}
#line 681 "Csv2_parse.c"
int csv2_is_starwhitis_orslash(int32_t in ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 682
  tmp = csv2_is_text(in);
#line 682
  if (tmp) {
#line 682
    tmp___0 = 1;
  } else
#line 682
  if (in == 42) {
#line 682
    tmp___0 = 1;
  } else
#line 682
  if (in == 37) {
#line 682
    tmp___0 = 1;
  } else
#line 682
  if (in == 47) {
#line 682
    tmp___0 = 1;
  } else {
#line 682
    tmp___0 = 0;
  }
#line 682
  return (tmp___0);
}
}
#line 686 "Csv2_parse.c"
int csv2_is_starwhitis_ordot(int32_t in ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 687
  tmp = csv2_is_text(in);
#line 687
  if (tmp) {
#line 687
    tmp___0 = 1;
  } else
#line 687
  if (in == 42) {
#line 687
    tmp___0 = 1;
  } else
#line 687
  if (in == 37) {
#line 687
    tmp___0 = 1;
  } else
#line 687
  if (in == 46) {
#line 687
    tmp___0 = 1;
  } else {
#line 687
    tmp___0 = 0;
  }
#line 687
  return (tmp___0);
}
}
#line 696 "Csv2_parse.c"
js_string *process_number(csv2_read *stream ) 
{ js_string *tmp ;

  {
#line 697
  tmp = process_something(stream, & csv2_is_number);
#line 697
  return (tmp);
}
}
#line 704 "Csv2_parse.c"
js_string *process_textlabel(csv2_read *stream ) 
{ js_string *tmp ;

  {
#line 705
  tmp = process_something(stream, & csv2_is_text);
#line 705
  return (tmp);
}
}
#line 719 "Csv2_parse.c"
js_string *process_dname(csv2_read *stream , int starwhitis ) 
{ js_string *o ;
  js_string *ret ;

  {
#line 725
  o = process_1stchar(stream, & csv2_is_starwhitis_ordot, (char *)"Z");
#line 726
  if ((unsigned long )o == (unsigned long )((js_string *)0)) {
#line 727
    return ((js_string *)0);
  } else
#line 726
  if ((unsigned long )o->string == (unsigned long )((unsigned char *)0)) {
#line 727
    return ((js_string *)0);
  }
#line 730
  ret = js_append_dname(o, stream, starwhitis);
#line 731
  if ((unsigned long )ret == (unsigned long )((js_string *)0)) {
#line 732
    return ((js_string *)0);
  }
#line 735
  if (o->unit_count > 1U) {
#line 735
    if ((int )*(o->string + 1) == 46) {
#line 735
      if (o->unit_count != 2U) {
#line 736
        csv2_error(stream, (char *)"Dot can only be at beginning of hostname for root (\'.\') hostname");
#line 738
        return ((js_string *)0);
      }
    }
  }
#line 741
  if (o->unit_count == 2U) {
#line 741
    if ((int )*(o->string + 1) == 46) {
#line 742
      return (o);
    }
  }
#line 744
  return (ret);
}
}
#line 761 "Csv2_parse.c"
js_string *js_append_dname(js_string *o , csv2_read *stream , int starwhitis ) 
{ int x ;
  int32_t look ;
  int state ;
  int32_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int32_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 764
  state = 1;
#line 765
  look = csv2_justread(stream);
#line 768
  if (look == 37) {
#line 768
    if (starwhitis != 4) {
#line 768
      if (starwhitis != 5) {
#line 768
        goto _L;
      } else {
#line 768
        goto _L___1;
      }
    } else {
#line 768
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 768
  if (look == 46) {
    _L: /* CIL Label */ 
#line 770
    tmp = csv2_read_unicode(stream);
#line 770
    if (tmp == -164) {
#line 771
      js_destroy(o);
#line 772
      return ((js_string *)0);
    }
#line 774
    return (o);
  } else
#line 775
  if (look == 37) {
#line 775
    if (starwhitis == 4) {
#line 776
      csv2_error(stream, (char *)"\'%\' character not allowed");
#line 777
      js_destroy(o);
#line 778
      return ((js_string *)0);
    } else
#line 775
    if (starwhitis == 5) {
#line 776
      csv2_error(stream, (char *)"\'%\' character not allowed");
#line 777
      js_destroy(o);
#line 778
      return ((js_string *)0);
    }
  }
#line 786
  if (starwhitis != 0) {
#line 786
    if (starwhitis != 5) {
#line 787
      tmp___0 = csv2_is_text(look);
#line 787
      if (tmp___0) {
#line 788
        state = 1;
      } else
#line 790
      if (look == 42) {
#line 791
        if (starwhitis == 0) {
#line 793
          csv2_error(stream, (char *)"\'*\' character not allowed");
#line 794
          js_destroy(o);
#line 795
          return ((js_string *)0);
        } else
#line 791
        if (starwhitis == 3) {
#line 793
          csv2_error(stream, (char *)"\'*\' character not allowed");
#line 794
          js_destroy(o);
#line 795
          return ((js_string *)0);
        } else
#line 791
        if (starwhitis == 4) {
#line 793
          csv2_error(stream, (char *)"\'*\' character not allowed");
#line 794
          js_destroy(o);
#line 795
          return ((js_string *)0);
        } else
#line 791
        if (starwhitis == 5) {
#line 793
          csv2_error(stream, (char *)"\'*\' character not allowed");
#line 794
          js_destroy(o);
#line 795
          return ((js_string *)0);
        }
#line 797
        state = 2;
      } else {
#line 800
        csv2_error(stream, (char *)"Unexpected character");
#line 801
        js_destroy(o);
#line 802
        return ((js_string *)0);
      }
    } else {
#line 805
      state = 0;
    }
  } else {
#line 805
    state = 0;
  }
#line 809
  x = 0;
#line 809
  while (x < 10000) {
#line 810
    look = csv2_read_unicode(stream);
#line 811
    if (look == -164) {
#line 812
      js_destroy(o);
#line 813
      return ((js_string *)0);
    }
#line 819
    if (look == 46) {
#line 819
      if (state == 1) {
#line 820
        state = 0;
#line 824
        tmp___1 = csv2_append_utf8(o, '.');
#line 824
        if (tmp___1 < 0) {
#line 825
          csv2_error(stream, (char *)"Error appending character");
#line 826
          js_destroy(o);
#line 827
          return ((js_string *)0);
        }
      } else {
#line 819
        goto _L___17;
      }
    } else
    _L___17: /* CIL Label */ 
#line 830
    if (state == 1) {
#line 830
      tmp___13 = csv2_is_text(look);
#line 830
      if (tmp___13) {
#line 831
        tmp___2 = csv2_append_utf8(o, look);
#line 831
        if (tmp___2 < 0) {
#line 832
          csv2_error(stream, (char *)"Error appending character");
#line 833
          js_destroy(o);
#line 834
          return ((js_string *)0);
        }
      } else {
#line 830
        goto _L___16;
      }
    } else
    _L___16: /* CIL Label */ 
#line 842
    if (look == 35) {
#line 842
      if (state == 0) {
#line 842
        if (x > 0) {
#line 843
          process_comment(stream);
#line 844
          return (o);
        } else {
#line 842
          goto _L___15;
        }
      } else {
#line 842
        goto _L___15;
      }
    } else
    _L___15: /* CIL Label */ 
#line 847
    if (state == 0) {
#line 847
      if (look == 37) {
#line 847
        if (starwhitis != 4) {
#line 847
          if (starwhitis != 5) {
#line 849
            tmp___3 = csv2_append_utf8(o, look);
#line 849
            if (tmp___3 < 0) {
#line 850
              csv2_error(stream, (char *)"Error appending character");
#line 851
              js_destroy(o);
#line 852
              return ((js_string *)0);
            }
#line 858
            tmp___4 = csv2_read_unicode(stream);
#line 858
            if (tmp___4 == -164) {
#line 859
              js_destroy(o);
#line 860
              return ((js_string *)0);
            }
#line 862
            return (o);
          } else {
#line 847
            goto _L___13;
          }
        } else {
#line 847
          goto _L___13;
        }
      } else {
#line 847
        goto _L___13;
      }
    } else
    _L___13: /* CIL Label */ 
#line 867
    if (state == 0) {
#line 867
      tmp___12 = csv2_is_text(look);
#line 867
      if (tmp___12) {
#line 868
        state = 1;
#line 869
        tmp___5 = csv2_append_utf8(o, look);
#line 869
        if (tmp___5 < 0) {
#line 870
          csv2_error(stream, (char *)"Error appending character");
#line 871
          js_destroy(o);
#line 872
          return ((js_string *)0);
        }
      } else {
#line 867
        goto _L___10;
      }
    } else
    _L___10: /* CIL Label */ 
#line 878
    if (state == 0) {
#line 878
      if (starwhitis == 2) {
#line 878
        if (look == 42) {
#line 880
          state = 3;
#line 881
          tmp___6 = csv2_append_utf8(o, look);
#line 881
          if (tmp___6 < 0) {
#line 882
            csv2_error(stream, (char *)"Error appending character");
#line 883
            js_destroy(o);
#line 884
            return ((js_string *)0);
          }
        } else {
#line 878
          goto _L___9;
        }
      } else {
#line 878
        goto _L___9;
      }
    } else
    _L___9: /* CIL Label */ 
#line 888
    if (state == 0) {
#line 888
      tmp___11 = csv2_is_delimiter(look);
#line 888
      if (tmp___11) {
#line 889
        return (o);
      } else {
#line 888
        goto _L___7;
      }
    } else
    _L___7: /* CIL Label */ 
#line 895
    if (state == 2) {
#line 895
      if (look == 46) {
#line 896
        state = 0;
#line 897
        tmp___7 = csv2_append_utf8(o, look);
#line 897
        if (tmp___7 < 0) {
#line 898
          csv2_error(stream, (char *)"Error appending character");
#line 899
          js_destroy(o);
#line 900
          return ((js_string *)0);
        }
      } else {
#line 895
        goto _L___6;
      }
    } else
    _L___6: /* CIL Label */ 
#line 904
    if (state == 2) {
#line 904
      tmp___10 = csv2_is_delimiter(look);
#line 904
      if (tmp___10) {
#line 904
        if (starwhitis == 2) {
#line 906
          return (o);
        } else {
#line 904
          goto _L___5;
        }
      } else {
#line 904
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 912
    if (state == 3) {
#line 912
      tmp___9 = csv2_is_delimiter(look);
#line 912
      if (tmp___9) {
#line 914
        return (o);
      } else {
#line 912
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 917
    if (look == 35) {
#line 917
      if (state == 3) {
#line 918
        process_comment(stream);
#line 919
        return (o);
      } else {
#line 917
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
#line 921
      tmp___8 = csv2_is_delimiter(look);
#line 921
      if (tmp___8) {
#line 922
        csv2_error(stream, (char *)"Improper termination of label\nLabel must end with \'.\' or \'%\' (A \'*\' is allowed in csv2_default_zonefile)");
#line 924
        js_destroy(o);
#line 925
        return ((js_string *)0);
      } else {
#line 928
        csv2_error(stream, (char *)"Unexpected character");
#line 929
        js_destroy(o);
#line 930
        return ((js_string *)0);
      }
    }
#line 809
    x ++;
  }
#line 933
  js_destroy(o);
#line 934
  return ((js_string *)0);
}
}
#line 939 "Csv2_parse.c"
js_string *csv2_convert_percent(js_string *in , js_string *psub ) 
{ int tmp ;

  {
#line 941
  if (in->unit_size != 1U) {
#line 942
    return ((js_string *)0);
  }
#line 946
  if (in->unit_count >= 1U) {
#line 946
    if ((int )*((in->string + in->unit_count) - 1) == 37) {
#line 948
      (in->unit_count) --;
#line 949
      tmp = js_append(psub, in);
#line 949
      if (tmp == -1) {
#line 950
        return ((js_string *)0);
      }
    }
  }
#line 954
  return (in);
}
}
#line 967 "Csv2_parse.c"
js_string *csv2_get_hostname(csv2_read *stream , js_string *zonename , int starwhitis ) 
{ js_string *out ;
  js_string *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 970
  out = process_dname(stream, starwhitis);
#line 970
  if ((unsigned long )out == (unsigned long )((js_string *)0)) {
#line 971
    return ((js_string *)0);
  }
#line 975
  tmp = csv2_convert_percent(out, zonename);
#line 975
  if ((unsigned long )tmp == (unsigned long )((js_string *)0)) {
#line 976
    js_destroy(out);
#line 977
    return ((js_string *)0);
  }
#line 981
  if (starwhitis == 2) {
#line 982
    tmp___0 = hname_2rfc1035_starwhitis(out, 1);
#line 982
    if (tmp___0 < 0) {
#line 983
      js_destroy(out);
#line 984
      return ((js_string *)0);
    }
  } else {
#line 987
    tmp___1 = hname_2rfc1035_starwhitis(out, 0);
#line 987
    if (tmp___1 < 0) {
#line 988
      js_destroy(out);
#line 989
      return ((js_string *)0);
    }
  }
#line 996
  tmp___2 = starrecord_to_meta(out, 0);
#line 996
  if (tmp___2 == -1) {
#line 997
    js_destroy(out);
#line 998
    return ((js_string *)0);
  }
#line 1001
  return (out);
}
}
#line 1009 "Csv2_parse.c"
int csv2_numeric_rtype(js_string *text_rtype ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;

  {
#line 1012
  js_set_encode(text_rtype, 2);
#line 1013
  tmp = js_tolower(text_rtype);
#line 1013
  if (tmp == -1) {
#line 1014
    return (-1);
  }
#line 1017
  tmp___0 = js_qissame((char *)"in", text_rtype);
#line 1017
  if (tmp___0 == 1) {
#line 1018
    return (-2);
  }
#line 1020
  tmp___1 = js_qissame((char *)"raw", text_rtype);
#line 1020
  if (tmp___1 == 1) {
#line 1021
    return (-3);
  }
#line 1023
  tmp___2 = js_qissame((char *)"a", text_rtype);
#line 1023
  if (tmp___2 == 1) {
#line 1024
    return (1);
  }
#line 1026
  tmp___3 = js_qissame((char *)"ns", text_rtype);
#line 1026
  if (tmp___3 == 1) {
#line 1027
    return (2);
  }
#line 1029
  tmp___4 = js_qissame((char *)"cname", text_rtype);
#line 1029
  if (tmp___4 == 1) {
#line 1030
    return (5);
  }
#line 1032
  tmp___5 = js_qissame((char *)"soa", text_rtype);
#line 1032
  if (tmp___5 == 1) {
#line 1033
    return (6);
  }
#line 1035
  tmp___6 = js_qissame((char *)"ptr", text_rtype);
#line 1035
  if (tmp___6 == 1) {
#line 1036
    return (12);
  }
#line 1038
  tmp___7 = js_qissame((char *)"mx", text_rtype);
#line 1038
  if (tmp___7 == 1) {
#line 1039
    return (15);
  }
#line 1041
  tmp___8 = js_qissame((char *)"aaaa", text_rtype);
#line 1041
  if (tmp___8 == 1) {
#line 1042
    return (28);
  }
#line 1044
  tmp___9 = js_qissame((char *)"srv", text_rtype);
#line 1044
  if (tmp___9 == 1) {
#line 1045
    return (33);
  }
#line 1047
  tmp___10 = js_qissame((char *)"txt", text_rtype);
#line 1047
  if (tmp___10 == 1) {
#line 1048
    return (16);
  }
#line 1050
  tmp___11 = js_qissame((char *)"spf", text_rtype);
#line 1050
  if (tmp___11 == 1) {
#line 1051
    return (99);
  }
#line 1053
  tmp___12 = js_qissame((char *)"fqdn4", text_rtype);
#line 1053
  if (tmp___12 == 1) {
#line 1054
    return (65765);
  }
#line 1057
  tmp___13 = js_qissame((char *)"fqdn6", text_rtype);
#line 1057
  if (tmp___13 == 1) {
#line 1058
    return (65766);
  }
#line 1063
  tmp___14 = js_qissame((char *)"hinfo", text_rtype);
#line 1063
  if (tmp___14 == 1) {
#line 1064
    return (13);
  }
#line 1066
  tmp___15 = js_qissame((char *)"wks", text_rtype);
#line 1066
  if (tmp___15 == 1) {
#line 1067
    return (11);
  }
#line 1069
  tmp___16 = js_qissame((char *)"mb", text_rtype);
#line 1069
  if (tmp___16 == 1) {
#line 1070
    return (7);
  }
#line 1072
  tmp___17 = js_qissame((char *)"md", text_rtype);
#line 1072
  if (tmp___17 == 1) {
#line 1073
    return (3);
  }
#line 1075
  tmp___18 = js_qissame((char *)"mf", text_rtype);
#line 1075
  if (tmp___18 == 1) {
#line 1076
    return (4);
  }
#line 1078
  tmp___19 = js_qissame((char *)"mg", text_rtype);
#line 1078
  if (tmp___19 == 1) {
#line 1079
    return (8);
  }
#line 1081
  tmp___20 = js_qissame((char *)"mr", text_rtype);
#line 1081
  if (tmp___20 == 1) {
#line 1082
    return (9);
  }
#line 1084
  tmp___21 = js_qissame((char *)"minfo", text_rtype);
#line 1084
  if (tmp___21 == 1) {
#line 1085
    return (14);
  }
#line 1088
  tmp___22 = js_qissame((char *)"afsdb", text_rtype);
#line 1088
  if (tmp___22 == 1) {
#line 1089
    return (18);
  }
#line 1091
  tmp___23 = js_qissame((char *)"rp", text_rtype);
#line 1091
  if (tmp___23 == 1) {
#line 1092
    return (17);
  }
#line 1094
  tmp___24 = js_qissame((char *)"x25", text_rtype);
#line 1094
  if (tmp___24 == 1) {
#line 1095
    return (19);
  }
#line 1097
  tmp___25 = js_qissame((char *)"isdn", text_rtype);
#line 1097
  if (tmp___25 == 1) {
#line 1098
    return (20);
  }
#line 1100
  tmp___26 = js_qissame((char *)"rt", text_rtype);
#line 1100
  if (tmp___26 == 1) {
#line 1101
    return (21);
  }
#line 1104
  tmp___27 = js_qissame((char *)"nsap", text_rtype);
#line 1104
  if (tmp___27 == 1) {
#line 1105
    return (22);
  }
#line 1107
  tmp___28 = js_qissame((char *)"nsap-ptr", text_rtype);
#line 1107
  if (tmp___28 == 1) {
#line 1108
    return (23);
  }
#line 1111
  tmp___29 = js_qissame((char *)"px", text_rtype);
#line 1111
  if (tmp___29 == 1) {
#line 1112
    return (26);
  }
#line 1115
  tmp___30 = js_qissame((char *)"gpos", text_rtype);
#line 1115
  if (tmp___30 == 1) {
#line 1116
    return (27);
  }
#line 1119
  tmp___31 = js_qissame((char *)"loc", text_rtype);
#line 1119
  if (tmp___31 == 1) {
#line 1120
    return (29);
  }
#line 1123
  tmp___32 = js_qissame((char *)"naptr", text_rtype);
#line 1123
  if (tmp___32 == 1) {
#line 1124
    return (35);
  }
#line 1126
  return (-1);
}
}
#line 1130 "Csv2_parse.c"
int32_t csv2_get_rtype(csv2_read *stream ) 
{ js_string *r ;
  int32_t ret ;
  int tmp ;
  int tmp___0 ;

  {
#line 1134
  while (1) {
#line 1135
    tmp = csv2_get_1st(stream, & csv2_is_alpha, 0);
#line 1135
    if (tmp != 1) {
#line 1136
      return (-1);
    }
#line 1138
    r = process_textlabel(stream);
#line 1138
    if ((unsigned long )r == (unsigned long )((js_string *)0)) {
#line 1139
      return (-1);
    }
#line 1141
    ret = csv2_numeric_rtype(r);
#line 1142
    js_destroy(r);
#line 1144
    if (ret == -3) {
#line 1145
      tmp___0 = csv2_get_1st(stream, & csv2_is_number, 0);
#line 1145
      if (tmp___0 < 0) {
#line 1146
        csv2_error(stream, (char *)"RAW rr not followed by number");
#line 1148
        return (-1);
      }
#line 1150
      ret = csv2_get_num(stream);
#line 1151
      if (ret < 0) {
#line 1152
        return (-1);
      }
#line 1154
      ret += 100000;
#line 1155
      return (ret);
    }
#line 1157
    if (ret == -1) {
#line 1158
      return (-1);
    } else
#line 1157
    if (ret == 0) {
#line 1158
      return (-1);
    }
#line 1134
    if (ret <= -2) {
#line 1134
      if (! (ret >= -11)) {
#line 1134
        break;
      }
    } else {
#line 1134
      break;
    }
  }
#line 1163
  return (ret);
}
}
#line 1168 "Csv2_parse.c"
int32_t csv2_get_num(csv2_read *stream ) 
{ js_string *num ;
  int32_t ret ;
  int tmp ;
  int32_t tmp___0 ;
  int32_t tmp___1 ;
  int32_t tmp___2 ;
  int32_t tmp___3 ;
  int32_t tmp___4 ;
  int32_t tmp___5 ;
  int32_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;

  {
#line 1172
  tmp = csv2_get_1st(stream, & csv2_is_number_orslash, 0);
#line 1172
  if (tmp != 1) {
#line 1173
    return (-1);
  }
#line 1177
  tmp___8 = csv2_justread(stream);
#line 1177
  if (tmp___8 == 47) {
#line 1178
    tmp___0 = csv2_read_unicode(stream);
#line 1178
    if (tmp___0 != 115) {
#line 1179
      return (-1);
    }
#line 1181
    tmp___1 = csv2_read_unicode(stream);
#line 1181
    if (tmp___1 != 101) {
#line 1182
      return (-1);
    }
#line 1184
    tmp___2 = csv2_read_unicode(stream);
#line 1184
    if (tmp___2 != 114) {
#line 1185
      return (-1);
    }
#line 1187
    tmp___3 = csv2_read_unicode(stream);
#line 1187
    if (tmp___3 != 105) {
#line 1188
      return (-1);
    }
#line 1190
    tmp___4 = csv2_read_unicode(stream);
#line 1190
    if (tmp___4 != 97) {
#line 1191
      return (-1);
    }
#line 1193
    tmp___5 = csv2_read_unicode(stream);
#line 1193
    if (tmp___5 != 108) {
#line 1194
      return (-1);
    }
#line 1196
    tmp___6 = csv2_read_unicode(stream);
#line 1196
    tmp___7 = csv2_is_delimiter(tmp___6);
#line 1196
    if (! tmp___7) {
#line 1197
      return (-1);
    }
#line 1199
    return (-2);
  }
#line 1202
  num = process_number(stream);
#line 1202
  if ((unsigned long )num == (unsigned long )((js_string *)0)) {
#line 1203
    return (-1);
  }
#line 1206
  if ((int )*(num->string) == 48) {
#line 1206
    if (num->unit_count == 1U) {
#line 1207
      js_destroy(num);
#line 1208
      return (0);
    }
  }
#line 1210
  tmp___9 = js_atoi(num, 0);
#line 1210
  ret = (int32_t )tmp___9;
#line 1210
  if (ret == 0) {
#line 1211
    js_destroy(num);
#line 1212
    return (-1);
  }
#line 1214
  js_destroy(num);
#line 1215
  return (ret);
}
}
#line 1224 "Csv2_parse.c"
js_string *csv2_get_something(csv2_read *stream , int (*is_ok)(int32_t in ) ) 
{ js_string *o ;
  int tmp ;

  {
#line 1227
  tmp = csv2_get_1st(stream, is_ok, 0);
#line 1227
  if (tmp != 1) {
#line 1228
    return ((js_string *)0);
  }
#line 1231
  o = process_something(stream, is_ok);
#line 1231
  if ((unsigned long )o == (unsigned long )((js_string *)0)) {
#line 1232
    return ((js_string *)0);
  }
#line 1235
  return (o);
}
}
#line 1239 "Csv2_parse.c"
js_string *csv2_get_filename(csv2_read *stream ) 
{ js_string *tmp ;

  {
#line 1240
  tmp = csv2_get_something(stream, & csv2_is_fchar);
#line 1240
  return (tmp);
}
}
#line 1247 "Csv2_parse.c"
js_string *csv2_get_dname(csv2_read *stream ) 
{ int tmp ;
  js_string *tmp___0 ;

  {
#line 1251
  tmp = csv2_get_1st(stream, & csv2_is_text, 0);
#line 1251
  if (tmp != 1) {
#line 1252
    return ((js_string *)0);
  }
#line 1255
  tmp___0 = csv2_get_hostname(stream, (js_string *)0, 1);
#line 1255
  return (tmp___0);
}
}
#line 1264 "Csv2_parse.c"
js_string *csv2_get_mx(csv2_read *stream , js_string *zone , int pref ) 
{ js_string *out ;
  int num ;
  int hlabels ;
  int tmp ;
  js_string *name ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1267
  hlabels = 1;
#line 1270
  if (pref < 0) {
#line 1271
    num = csv2_get_num(stream);
#line 1271
    if (num < 0) {
#line 1272
      return ((js_string *)0);
    }
  } else {
#line 1275
    num = pref;
  }
#line 1277
  out = js_create(256U, 1U);
#line 1277
  if ((unsigned long )out == (unsigned long )((js_string *)0)) {
#line 1278
    return ((js_string *)0);
  }
#line 1280
  tmp = js_adduint16(out, num);
#line 1280
  if (tmp == -1) {
#line 1281
    js_destroy(out);
#line 1282
    return ((js_string *)0);
  }
#line 1285
  if (pref == -2) {
#line 1286
    hlabels = 2;
  }
#line 1290
  while (hlabels > 0) {
#line 1292
    tmp___0 = csv2_get_1st(stream, & csv2_is_dchar, 0);
#line 1292
    if (tmp___0 != 1) {
#line 1293
      js_destroy(out);
#line 1294
      return ((js_string *)0);
    }
#line 1296
    name = csv2_get_hostname(stream, zone, 3);
#line 1296
    if ((unsigned long )name == (unsigned long )((js_string *)0)) {
#line 1297
      js_destroy(out);
#line 1298
      return ((js_string *)0);
    }
#line 1300
    tmp___1 = js_append(name, out);
#line 1300
    if (tmp___1 == -1) {
#line 1301
      js_destroy(name);
#line 1302
      js_destroy(out);
#line 1303
      return ((js_string *)0);
    }
#line 1305
    js_destroy(name);
#line 1306
    hlabels --;
  }
#line 1309
  return (out);
}
}
#line 1315 "Csv2_parse.c"
js_string *csv2_get_srv(csv2_read *stream , js_string *zone ) 
{ js_string *out ;
  js_string *name ;
  int num ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1320
  out = js_create(256U, 1U);
#line 1320
  if ((unsigned long )out == (unsigned long )((js_string *)0)) {
#line 1321
    return ((js_string *)0);
  }
#line 1325
  c = 1;
#line 1325
  while (c <= 3) {
#line 1326
    num = csv2_get_num(stream);
#line 1326
    if (num < 0) {
#line 1327
      js_destroy(out);
#line 1328
      return ((js_string *)0);
    }
#line 1330
    tmp = js_adduint16(out, num);
#line 1330
    if (tmp == -1) {
#line 1331
      js_destroy(out);
#line 1332
      return ((js_string *)0);
    }
#line 1325
    c ++;
  }
#line 1337
  tmp___0 = csv2_get_1st(stream, & csv2_is_dchar, 0);
#line 1337
  if (tmp___0 != 1) {
#line 1338
    js_destroy(out);
#line 1339
    return ((js_string *)0);
  }
#line 1341
  name = csv2_get_hostname(stream, zone, 3);
#line 1341
  if ((unsigned long )name == (unsigned long )((js_string *)0)) {
#line 1342
    js_destroy(out);
#line 1343
    return ((js_string *)0);
  }
#line 1345
  tmp___1 = js_append(name, out);
#line 1345
  if (tmp___1 == -1) {
#line 1346
    js_destroy(name);
#line 1347
    js_destroy(out);
#line 1348
    return ((js_string *)0);
  }
#line 1351
  js_destroy(name);
#line 1352
  return (out);
}
}
#line 1361 "Csv2_parse.c"
int csv2_read_rr(csv2_add_state *state , csv2_read *stream , int32_t starwhitis ) 
{ js_string *name ;
  js_string *rddata ;
  js_string *zone ;
  int32_t ttl ;
  int32_t rtype ;
  int q ;
  int slash_command ;
  int32_t look ;
  int32_t cmd ;
  int newttl ;
  js_string *n ;
  int32_t tmp ;
  int32_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  js_string *tmp___3 ;
  js_string *n___0 ;
  csv2_origin *c ;
  csv2_origin *o ;
  int32_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  js_string *tmp___7 ;
  void *tmp___8 ;
  csv2_origin *o___0 ;
  int tmp___9 ;
  js_string *filename ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int32_t tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 1362
  name = (js_string *)0;
#line 1362
  rddata = (js_string *)0;
#line 1363
  zone = (js_string *)0;
#line 1364
  ttl = 86400;
#line 1367
  slash_command = 0;
#line 1370
  if ((unsigned long )state->bighash == (unsigned long )((mhash *)0)) {
#line 1370
    if (state->add_method == 1) {
#line 1371
      return (-1);
    }
  }
#line 1373
  if ((unsigned long )state->zone == (unsigned long )((js_string *)0)) {
#line 1374
    return (-1);
  }
#line 1376
  if ((unsigned long )state->origin == (unsigned long )((js_string *)0)) {
#line 1377
    return (-1);
  }
#line 1380
  zone = state->origin;
#line 1387
  while (1) {
#line 1388
    slash_command = 0;
#line 1392
    q = csv2_get_1st(stream, & csv2_is_starwhitis_orslash, 1);
#line 1394
    if (q == -2) {
#line 1395
      return (-2);
    }
#line 1398
    if (q == -1) {
#line 1399
      return (-1);
    }
#line 1404
    tmp___12 = csv2_justread(stream);
#line 1404
    if (tmp___12 == 47) {
#line 1406
      slash_command = 1;
#line 1407
      look = csv2_read_unicode(stream);
#line 1408
      if (look == 116) {
#line 1409
        cmd = 1;
      } else
#line 1410
      if (look == 111) {
#line 1411
        cmd = 2;
      } else
#line 1412
      if (look == 114) {
#line 1413
        cmd = 5;
      } else {
#line 1415
        csv2_error(stream, (char *)"Invalid slash command");
#line 1416
        return (-1);
      }
#line 1419
      look = csv2_read_unicode(stream);
#line 1420
      if (cmd == 2) {
#line 1420
        if (look == 112) {
#line 1421
          cmd = 3;
        } else {
#line 1420
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 1422
      if (cmd == 1) {
#line 1422
        if (look != 116) {
#line 1424
          csv2_error(stream, (char *)"Invalid slash command");
#line 1425
          return (-1);
        } else {
#line 1422
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1422
      if (cmd == 2) {
#line 1422
        if (look != 114) {
#line 1424
          csv2_error(stream, (char *)"Invalid slash command");
#line 1425
          return (-1);
        } else {
#line 1422
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1422
      if (cmd == 5) {
#line 1422
        if (look != 101) {
#line 1424
          csv2_error(stream, (char *)"Invalid slash command");
#line 1425
          return (-1);
        }
      }
#line 1428
      look = csv2_read_unicode(stream);
#line 1429
      if (cmd == 3) {
#line 1429
        if (look == 111) {
#line 1430
          cmd = 4;
        } else {
#line 1429
          goto _L___5;
        }
      } else
      _L___5: /* CIL Label */ 
#line 1431
      if (cmd == 1) {
#line 1431
        if (look != 108) {
#line 1434
          csv2_error(stream, (char *)"Invalid slash command");
#line 1435
          return (-1);
        } else {
#line 1431
          goto _L___4;
        }
      } else
      _L___4: /* CIL Label */ 
#line 1431
      if (cmd == 2) {
#line 1431
        if (look != 105) {
#line 1434
          csv2_error(stream, (char *)"Invalid slash command");
#line 1435
          return (-1);
        } else {
#line 1431
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 1431
      if (cmd == 3) {
#line 1431
        if (look != 117) {
#line 1434
          csv2_error(stream, (char *)"Invalid slash command");
#line 1435
          return (-1);
        } else {
#line 1431
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 1431
      if (cmd == 5) {
#line 1431
        if (look != 97) {
#line 1434
          csv2_error(stream, (char *)"Invalid slash command");
#line 1435
          return (-1);
        }
      }
#line 1438
      look = csv2_read_unicode(stream);
#line 1439
      if (cmd == 1) {
#line 1439
        tmp___11 = csv2_is_delimiter(look);
#line 1439
        if (tmp___11) {
#line 1441
          newttl = csv2_get_num(stream);
#line 1442
          if (newttl < 0) {
#line 1443
            csv2_error(stream, (char *)"Invalid slash command");
#line 1445
            return (-1);
          }
#line 1447
          state->default_ttl = newttl;
        } else {
#line 1439
          goto _L___9;
        }
      } else
      _L___9: /* CIL Label */ 
#line 1448
      if (cmd == 2) {
#line 1448
        if (look == 103) {
#line 1450
          tmp = csv2_read_unicode(stream);
#line 1450
          if (tmp != 105) {
#line 1451
            csv2_error(stream, (char *)"Invalid slash command");
#line 1453
            return (-1);
          }
#line 1455
          tmp___0 = csv2_read_unicode(stream);
#line 1455
          if (tmp___0 != 110) {
#line 1456
            csv2_error(stream, (char *)"Invalid slash command");
#line 1458
            return (-1);
          }
#line 1460
          look = csv2_read_unicode(stream);
#line 1461
          tmp___1 = csv2_is_delimiter(look);
#line 1461
          if (! tmp___1) {
#line 1462
            csv2_error(stream, (char *)"Invalid slash command");
#line 1464
            return (-1);
          }
#line 1466
          tmp___2 = csv2_get_1st(stream, & csv2_is_dchar, 0);
#line 1466
          if (tmp___2 != 1) {
#line 1468
            csv2_error(stream, (char *)"Invalid argument for /origin");
#line 1470
            return (-1);
          }
#line 1472
          n = process_1stchar(stream, & csv2_is_starwhitis, (char *)0);
#line 1474
          if ((unsigned long )n == (unsigned long )((js_string *)0)) {
#line 1475
            csv2_error(stream, (char *)"Error processing /origin");
#line 1477
            return (-1);
          }
#line 1479
          n = js_append_dname(n, stream, 3);
#line 1480
          if ((unsigned long )n == (unsigned long )((js_string *)0)) {
#line 1481
            csv2_error(stream, (char *)"Invalid argument for /origin");
#line 1483
            return (-1);
          }
#line 1485
          tmp___3 = csv2_convert_percent(n, state->origin);
#line 1485
          if ((unsigned long )tmp___3 == (unsigned long )((js_string *)0)) {
#line 1487
            csv2_error(stream, (char *)"Problem running convert_percent");
#line 1489
            return (-1);
          }
#line 1491
          js_destroy(state->origin);
#line 1492
          state->origin = n;
#line 1493
          zone = n;
        } else {
#line 1448
          goto _L___8;
        }
      } else
      _L___8: /* CIL Label */ 
#line 1494
      if (cmd == 3) {
#line 1494
        if (look == 115) {
#line 1497
          tmp___4 = csv2_read_unicode(stream);
#line 1497
          if (tmp___4 != 104) {
#line 1498
            csv2_error(stream, (char *)"Invalid slash command");
#line 1500
            return (-1);
          }
#line 1502
          look = csv2_read_unicode(stream);
#line 1503
          tmp___5 = csv2_is_delimiter(look);
#line 1503
          if (! tmp___5) {
#line 1504
            csv2_error(stream, (char *)"Invalid slash command");
#line 1506
            return (-1);
          }
#line 1508
          tmp___6 = csv2_get_1st(stream, & csv2_is_dchar, 0);
#line 1508
          if (tmp___6 != 1) {
#line 1510
            csv2_error(stream, (char *)"Invalid argument for /opush");
#line 1512
            return (-1);
          }
#line 1514
          n___0 = process_1stchar(stream, & csv2_is_starwhitis, (char *)0);
#line 1516
          if ((unsigned long )n___0 == (unsigned long )((js_string *)0)) {
#line 1517
            csv2_error(stream, (char *)"Error processing /opush");
#line 1519
            return (-1);
          }
#line 1521
          n___0 = js_append_dname(n___0, stream, 3);
#line 1522
          if ((unsigned long )n___0 == (unsigned long )((js_string *)0)) {
#line 1523
            csv2_error(stream, (char *)"Invalid argument for /opush");
#line 1525
            return (-1);
          }
#line 1527
          tmp___7 = csv2_convert_percent(n___0, state->origin);
#line 1527
          if ((unsigned long )tmp___7 == (unsigned long )((js_string *)0)) {
#line 1529
            csv2_error(stream, (char *)"Problem running convert_percent");
#line 1531
            return (-1);
          }
#line 1534
          if (state->ostack_height > 7) {
#line 1536
            csv2_error(stream, (char *)"origin stack too high");
#line 1538
            return (-1);
          } else
#line 1534
          if (state->ostack_height < 0) {
#line 1536
            csv2_error(stream, (char *)"origin stack too high");
#line 1538
            return (-1);
          }
#line 1543
          (state->ostack_height) ++;
#line 1544
          o = state->ostack;
#line 1545
          tmp___8 = js_alloc(1, (int )sizeof(csv2_origin ));
#line 1545
          c = (csv2_origin *)tmp___8;
#line 1546
          if ((unsigned long )c == (unsigned long )((csv2_origin *)0)) {
#line 1547
            csv2_error(stream, (char *)"js_alloc error");
#line 1549
            return (-1);
          }
#line 1551
          c->origin = state->origin;
#line 1552
          c->next = o;
#line 1553
          state->ostack = c;
#line 1554
          state->origin = n___0;
#line 1555
          zone = state->origin;
        } else {
#line 1494
          goto _L___7;
        }
      } else
      _L___7: /* CIL Label */ 
#line 1556
      if (cmd == 4) {
#line 1556
        if (look == 112) {
#line 1558
          look = csv2_read_unicode(stream);
#line 1559
          tmp___9 = csv2_is_delimiter(look);
#line 1559
          if (! tmp___9) {
#line 1560
            csv2_error(stream, (char *)"Invalid slash command");
#line 1562
            return (-1);
          }
#line 1564
          if (state->ostack_height < 1) {
#line 1566
            csv2_error(stream, (char *)"origin stack too low");
#line 1568
            return (-1);
          } else
#line 1564
          if (state->ostack_height > 8) {
#line 1566
            csv2_error(stream, (char *)"origin stack too low");
#line 1568
            return (-1);
          }
#line 1570
          if ((unsigned long )state->ostack == (unsigned long )((csv2_origin *)0)) {
#line 1571
            csv2_error(stream, (char *)"origin stack empty");
#line 1573
            return (-1);
          }
#line 1577
          o___0 = state->ostack;
#line 1578
          js_destroy(state->origin);
#line 1579
          state->ostack = o___0->next;
#line 1580
          state->origin = o___0->origin;
#line 1581
          zone = state->origin;
#line 1582
          js_dealloc((void *)o___0);
        } else {
#line 1556
          goto _L___6;
        }
      } else
      _L___6: /* CIL Label */ 
#line 1583
      if (cmd == 5) {
#line 1583
        if (look == 100) {
#line 1585
          look = csv2_read_unicode(stream);
#line 1586
          tmp___10 = csv2_is_delimiter(look);
#line 1586
          if (! tmp___10) {
#line 1587
            csv2_error(stream, (char *)"Invalid slash command");
#line 1589
            return (-1);
          }
#line 1591
          filename = csv2_get_filename(stream);
#line 1592
          csv2_push_file(stream, filename);
#line 1593
          js_destroy(filename);
        } else {
#line 1595
          csv2_error(stream, (char *)"Invalid slash command");
#line 1596
          return (-1);
        }
      } else {
#line 1595
        csv2_error(stream, (char *)"Invalid slash command");
#line 1596
        return (-1);
      }
    }
#line 1387
    if (! (slash_command == 1)) {
#line 1387
      break;
    }
  }
#line 1607
  if (starwhitis == 0) {
#line 1608
    name = csv2_get_hostname(stream, zone, 1);
#line 1608
    if ((unsigned long )name == (unsigned long )((js_string *)0)) {
#line 1609
      csv2_error(stream, (char *)"Problem getting hostname");
#line 1610
      return (-1);
    }
  } else
#line 1612
  if (starwhitis == 1) {
#line 1613
    name = csv2_get_hostname(stream, zone, 2);
#line 1613
    if ((unsigned long )name == (unsigned long )((js_string *)0)) {
#line 1614
      csv2_error(stream, (char *)"Problem getting hostname");
#line 1615
      return (-1);
    }
  } else {
#line 1618
    csv2_error(stream, (char *)"Bad starwhitis value passed to csv2_read_rr");
#line 1620
    return (-1);
  }
#line 1625
  tmp___13 = csv2_get_1st(stream, & csv2_is_alphanum_orplus, 0);
#line 1625
  if (tmp___13 < 0) {
#line 1626
    js_destroy(name);
#line 1627
    csv2_error(stream, (char *)"Unexpected character");
#line 1628
    return (-1);
  }
#line 1631
  ttl = state->default_ttl;
#line 1633
  tmp___16 = csv2_justread(stream);
#line 1633
  if (tmp___16 == 43) {
#line 1634
    tmp___14 = csv2_read_unicode(stream);
#line 1634
    if (tmp___14 < 0) {
#line 1635
      js_destroy(name);
#line 1636
      csv2_error(stream, (char *)"Unexpected char around +");
#line 1637
      return (-1);
    }
#line 1639
    ttl = csv2_get_num(stream);
#line 1639
    if (ttl < 0) {
#line 1640
      js_destroy(name);
#line 1641
      csv2_error(stream, (char *)"Problem getting TTL");
#line 1642
      return (-1);
    }
#line 1645
    tmp___15 = csv2_get_1st(stream, & csv2_is_alphanum, 0);
#line 1645
    if (tmp___15 < 0) {
#line 1646
      js_destroy(name);
#line 1647
      csv2_error(stream, (char *)"Unexpected character");
#line 1648
      return (-1);
    }
  }
#line 1655
  tmp___19 = csv2_justread(stream);
#line 1655
  tmp___20 = csv2_is_alpha(tmp___19);
#line 1655
  if (tmp___20) {
#line 1656
    rtype = csv2_get_rtype(stream);
#line 1656
    if (rtype == -1) {
#line 1657
      js_destroy(name);
#line 1658
      csv2_error(stream, (char *)"Unknown Rtype");
#line 1659
      return (-1);
    }
  } else {
#line 1664
    tmp___17 = csv2_justread(stream);
#line 1664
    tmp___18 = csv2_is_number(tmp___17);
#line 1664
    if (tmp___18) {
#line 1665
      rtype = 1;
#line 1666
      rddata = csv2_get_a(stream);
#line 1668
      csv2_add_rr(state, name, rtype, ttl, rddata);
#line 1670
      js_destroy(name);
#line 1671
      js_destroy(rddata);
#line 1672
      return (1);
    } else {
#line 1675
      js_destroy(name);
#line 1676
      csv2_error(stream, (char *)"Unexpected char (shouldn\'t get here)");
#line 1677
      return (-1);
    }
  }
#line 1683
  switch (rtype) {
  case 1: 
#line 1685
  rddata = csv2_get_a(stream);
#line 1686
  break;
  case 28: 
#line 1688
  rddata = csv2_get_aaaa(stream);
#line 1689
  break;
  case 6: 
#line 1691
  rddata = csv2_get_soa(stream, zone, state);
#line 1692
  break;
  case 15: 
  case 18: 
  case 21: 
#line 1696
  rddata = csv2_get_mx(stream, zone, -1);
#line 1697
  break;
  case 33: 
#line 1699
  rddata = csv2_get_srv(stream, zone);
#line 1700
  break;
  case 16: 
  case 19: 
  case 20: 
  case 99: 
#line 1705
  if ((int )stream->tilde_handling == 2) {
#line 1707
    csv2_error(stream, (char *)"I\'m sorry, that record can not be the first record unless csv2_tilde_handling is set.");
#line 1710
    break;
  } else
#line 1705
  if ((int )stream->tilde_handling == 102) {
#line 1707
    csv2_error(stream, (char *)"I\'m sorry, that record can not be the first record unless csv2_tilde_handling is set.");
#line 1710
    break;
  }
#line 1712
  rddata = csv2_get_txt(stream, 0);
#line 1713
  break;
  case 8: 
  case 9: 
#line 1716
  rddata = csv2_get_mbox(stream, zone, 1);
#line 1717
  break;
  case 14: 
  case 17: 
#line 1720
  rddata = csv2_get_mbox(stream, zone, 2);
#line 1721
  break;
  case 2: 
  case 5: 
  case 12: 
  case 23: 
  case 7: 
#line 1727
  tmp___21 = csv2_get_1st(stream, & csv2_is_dchar, 0);
#line 1727
  if (tmp___21 != 1) {
#line 1729
    return (-1);
  }
#line 1731
  rddata = csv2_get_hostname(stream, zone, 3);
#line 1732
  break;
  case 65765: 
#line 1736
  rddata = csv2_get_a(stream);
#line 1737
  break;
  case 65766: 
#line 1742
  rddata = csv2_get_aaaa(stream);
#line 1743
  break;
  case 13: 
#line 1747
  rddata = csv2_get_txt(stream, 2);
#line 1748
  break;
  case 11: 
#line 1750
  if ((int )stream->tilde_handling == 2) {
#line 1752
    csv2_error(stream, (char *)"I\'m sorry, that record can not be the first record unless csv2_tilde_handling is set.");
#line 1755
    break;
  } else
#line 1750
  if ((int )stream->tilde_handling == 102) {
#line 1752
    csv2_error(stream, (char *)"I\'m sorry, that record can not be the first record unless csv2_tilde_handling is set.");
#line 1755
    break;
  }
#line 1757
  rddata = csv2_get_wks(stream);
#line 1758
  break;
  case 3: 
#line 1762
  rddata = csv2_get_mx(stream, zone, 0);
#line 1763
  rtype = 15;
#line 1764
  break;
  case 4: 
#line 1768
  rddata = csv2_get_mx(stream, zone, 10);
#line 1769
  rtype = 15;
#line 1770
  break;
  case 22: 
#line 1772
  rddata = csv2_get_hex(stream);
#line 1773
  break;
  case 26: 
#line 1775
  rddata = csv2_get_mx(stream, zone, -2);
#line 1776
  break;
  case 27: 
#line 1778
  rddata = csv2_get_txt(stream, 3);
#line 1779
  break;
  case 29: 
#line 1781
  if ((int )stream->tilde_handling == 2) {
#line 1783
    csv2_error(stream, (char *)"I\'m sorry, that record can not be the first record unless csv2_tilde_handling is set.");
#line 1786
    break;
  } else
#line 1781
  if ((int )stream->tilde_handling == 102) {
#line 1783
    csv2_error(stream, (char *)"I\'m sorry, that record can not be the first record unless csv2_tilde_handling is set.");
#line 1786
    break;
  }
#line 1788
  rddata = csv2_get_loc(stream);
#line 1789
  break;
  case 35: 
#line 1791
  rddata = csv2_get_naptr(stream);
#line 1792
  break;
  default: 
#line 1795
  if (rtype >= 100000) {
#line 1795
    if (rtype <= 165535) {
#line 1796
      rtype -= 100000;
#line 1797
      if (rtype == 255) {
#line 1798
        csv2_error(stream, (char *)"ANY (255) record type isn\'t for data");
      } else
#line 1800
      if (rtype == 251) {
#line 1801
        csv2_error(stream, (char *)"IXFR (251) record type isn\'t for data");
      } else
#line 1803
      if (rtype == 252) {
#line 1804
        csv2_error(stream, (char *)"AXFR (252) record type isn\'t for data");
      } else
#line 1806
      if (rtype == 253) {
#line 1807
        csv2_error(stream, (char *)"MAILB record type isn\'t for data");
      } else
#line 1809
      if (rtype == 254) {
#line 1810
        csv2_error(stream, (char *)"MAILA record type isn\'t for data");
      } else
#line 1812
      if (rtype == 38) {
#line 1813
        csv2_error(stream, (char *)"MaraDNS doesn\'t allow A6 records");
      } else
#line 1815
      if (rtype == 39) {
#line 1816
        csv2_error(stream, (char *)"MaraDNS doesn\'t allow DNAME records");
      } else
#line 1818
      if (rtype == 41) {
#line 1819
        csv2_error(stream, (char *)"OPT record type isn\'t for zone files");
      } else {
#line 1822
        rddata = csv2_get_raw(stream);
      }
    } else {
#line 1825
      csv2_error(stream, (char *)"Unsupported RTYPE");
    }
  } else {
#line 1825
    csv2_error(stream, (char *)"Unsupported RTYPE");
  }
  }
#line 1829
  if ((unsigned long )rddata == (unsigned long )((js_string *)0)) {
#line 1830
    csv2_error(stream, (char *)"Problem getting rddata");
#line 1831
    js_destroy(name);
#line 1832
    return (-1);
  }
#line 1835
  csv2_add_rr(state, name, rtype, ttl, rddata);
#line 1837
  js_destroy(name);
#line 1838
  js_destroy(rddata);
#line 1839
  return (1);
}
}
#line 1 "Csv2_rr_soa.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-Sbv6ojwm.i","")
#line 270 "Csv2_functions.h"
int csv2_b4_at(int32_t in ) ;
#line 271
js_string *process_mbox(csv2_read *stream ) ;
#line 281
int csv2_is_alphanum_ordot(int32_t in ) ;
#line 36 "Csv2_rr_soa.c"
int csv2_b4_at(int32_t in ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 38
  tmp = csv2_is_alphanum(in);
#line 38
  if (tmp) {
#line 38
    tmp___0 = 1;
  } else
#line 38
  if (in == 43) {
#line 38
    tmp___0 = 1;
  } else
#line 38
  if (in == 37) {
#line 38
    tmp___0 = 1;
  } else
#line 38
  if (in == 33) {
#line 38
    tmp___0 = 1;
  } else
#line 38
  if (in == 94) {
#line 38
    tmp___0 = 1;
  } else
#line 38
  if (in == 61) {
#line 38
    tmp___0 = 1;
  } else {
#line 38
    tmp___0 = 0;
  }
#line 38
  return (tmp___0);
}
}
#line 44 "Csv2_rr_soa.c"
js_string *process_mbox(csv2_read *stream ) 
{ js_string *o ;
  int32_t look ;
  int x ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  js_string *tmp___5 ;

  {
#line 49
  o = process_1stchar(stream, & csv2_is_alphanum_ordot, (char *)"Z");
#line 50
  if ((unsigned long )o == (unsigned long )((js_string *)0)) {
#line 51
    return ((js_string *)0);
  }
#line 55
  x = 0;
#line 55
  while (x < 10000) {
#line 56
    look = csv2_read_unicode(stream);
#line 59
    if (x == 0) {
#line 59
      if (o->unit_count >= 2U) {
#line 59
        if ((int )*(o->string + 1) == 46) {
#line 60
          tmp = csv2_is_delimiter(look);
#line 60
          if (tmp) {
#line 61
            return (o);
          }
#line 63
          csv2_error(stream, (char *)". can only be at start of label that is just a . by itself");
#line 65
          js_destroy(o);
#line 66
          return ((js_string *)0);
        }
      }
    }
#line 68
    if (look == -164) {
#line 69
      js_destroy(o);
#line 70
      return ((js_string *)0);
    }
#line 72
    if (look == 64) {
#line 72
      goto _L;
    } else
#line 72
    if (look == 46) {
      _L: /* CIL Label */ 
#line 73
      tmp___0 = csv2_append_utf8(o, look);
#line 73
      if (tmp___0 < 0) {
#line 74
        csv2_error(stream, (char *)"Error appending character");
#line 75
        js_destroy(o);
#line 76
        return ((js_string *)0);
      }
#line 78
      if (look == 46) {
#line 79
        look = csv2_read_unicode(stream);
#line 80
        tmp___2 = csv2_is_text(look);
#line 80
        if (tmp___2) {
#line 81
          tmp___1 = csv2_append_utf8(o, look);
#line 81
          if (tmp___1 < 0) {
#line 82
            csv2_error(stream, (char *)"Error appending character");
#line 84
            js_destroy(o);
#line 85
            return ((js_string *)0);
          }
        } else {
#line 88
          csv2_error(stream, (char *)"Strange character after dot");
#line 90
          js_destroy(o);
#line 91
          return ((js_string *)0);
        }
      }
#line 94
      break;
    }
#line 96
    tmp___4 = csv2_b4_at(look);
#line 96
    if (tmp___4) {
#line 97
      tmp___3 = csv2_append_utf8(o, look);
#line 97
      if (tmp___3 < 0) {
#line 98
        csv2_error(stream, (char *)"Error appending character");
#line 99
        js_destroy(o);
#line 100
        return ((js_string *)0);
      }
    } else {
#line 104
      csv2_error(stream, (char *)"Unexpected character before @ in mbox Yes, I know RFC2822 3.4 probably allows the character in question to be there. This is MaraDNS, not some platonic ideal.");
#line 109
      js_destroy(o);
#line 110
      return ((js_string *)0);
    }
#line 55
    x ++;
  }
#line 116
  tmp___5 = js_append_dname(o, stream, 0);
#line 116
  return (tmp___5);
}
}
#line 123 "Csv2_rr_soa.c"
js_string *csv2_get_soa(csv2_read *stream , js_string *zone , csv2_add_state *state ) 
{ js_string *name ;
  js_string *out ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int32_t num ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 129
  out = js_create(512U, 1U);
#line 129
  if ((unsigned long )out == (unsigned long )((js_string *)0)) {
#line 130
    return ((js_string *)0);
  }
#line 134
  tmp = csv2_get_1st(stream, & csv2_is_dchar, 0);
#line 134
  if (tmp != 1) {
#line 135
    return ((js_string *)0);
  }
#line 137
  name = csv2_get_hostname(stream, zone, 3);
#line 137
  if ((unsigned long )name == (unsigned long )((js_string *)0)) {
#line 138
    js_destroy(out);
#line 139
    return ((js_string *)0);
  }
#line 141
  tmp___0 = js_append(name, out);
#line 141
  if (tmp___0 == -1) {
#line 142
    js_destroy(name);
#line 143
    js_destroy(out);
#line 144
    return ((js_string *)0);
  }
#line 146
  js_destroy(name);
#line 149
  name = csv2_get_mbox(stream, zone, 1);
#line 150
  tmp___1 = js_append(name, out);
#line 150
  if (tmp___1 == -1) {
#line 151
    js_destroy(name);
#line 152
    js_destroy(out);
#line 153
    return ((js_string *)0);
  }
#line 155
  js_destroy(name);
#line 158
  c = 0;
#line 158
  while (c < 5) {
#line 160
    num = csv2_get_num(stream);
#line 163
    if (num == -2) {
#line 163
      if (c == 0) {
#line 164
        tmp___2 = js_adduint32(out, (uint32_t )state->soa_serial);
#line 164
        if (tmp___2 == -1) {
#line 165
          js_destroy(out);
#line 166
          return ((js_string *)0);
        }
      } else {
#line 163
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 168
    if (num < 0) {
#line 169
      js_destroy(out);
#line 170
      return ((js_string *)0);
    } else {
#line 171
      tmp___3 = js_adduint32(out, (uint32_t )num);
#line 171
      if (tmp___3 == -1) {
#line 172
        js_destroy(out);
#line 173
        return ((js_string *)0);
      }
    }
#line 158
    c ++;
  }
#line 176
  return (out);
}
}
#line 1 "Csv2_rr_aaaa.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-12r9RSQ_.i","")
#line 264 "Csv2_functions.h"
int csv2_is_hex(int32_t in ) ;
#line 265
int csv2_is_hex_or_colon(int32_t in ) ;
#line 266
js_string *process_aaaa(csv2_read *stream ) ;
#line 30 "Csv2_rr_aaaa.c"
int csv2_is_hex(int32_t in ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 31
  tmp = csv2_is_number(in);
#line 31
  if (tmp) {
#line 31
    tmp___0 = 1;
  } else
#line 31
  if (in >= 97) {
#line 31
    if (in <= 102) {
#line 31
      tmp___0 = 1;
    } else {
#line 31
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 31
  if (in >= 65) {
#line 31
    if (in <= 70) {
#line 31
      tmp___0 = 1;
    } else {
#line 31
      tmp___0 = 0;
    }
  } else {
#line 31
    tmp___0 = 0;
  }
#line 31
  return (tmp___0);
}
}
#line 35 "Csv2_rr_aaaa.c"
int csv2_is_hex_or_colon(int32_t in ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 36
  tmp = csv2_is_hex(in);
#line 36
  if (tmp) {
#line 36
    tmp___0 = 1;
  } else
#line 36
  if (in == 58) {
#line 36
    tmp___0 = 1;
  } else {
#line 36
    tmp___0 = 0;
  }
#line 36
  return (tmp___0);
}
}
#line 42 "Csv2_rr_aaaa.c"
js_string *process_aaaa(csv2_read *stream ) 
{ js_string *tmp ;

  {
#line 43
  tmp = process_something(stream, & csv2_is_hex_or_colon);
#line 43
  return (tmp);
}
}
#line 50 "Csv2_rr_aaaa.c"
js_string *csv2_get_aaaa(csv2_read *stream ) 
{ js_string *ip6hex ;
  js_string *out ;
  int tmp ;

  {
#line 54
  tmp = csv2_get_1st(stream, & csv2_is_hex_or_colon, 0);
#line 54
  if (tmp != 1) {
#line 55
    return ((js_string *)0);
  }
#line 58
  ip6hex = process_aaaa(stream);
#line 58
  if ((unsigned long )ip6hex == (unsigned long )((js_string *)0)) {
#line 59
    return ((js_string *)0);
  }
#line 62
  out = ip6_to_raw(ip6hex);
#line 62
  if ((unsigned long )out == (unsigned long )((js_string *)0)) {
#line 63
    js_destroy(ip6hex);
#line 64
    csv2_error(stream, (char *)"Invalid IPv6 address");
#line 65
    return ((js_string *)0);
  }
#line 68
  js_destroy(ip6hex);
#line 69
  return (out);
}
}
#line 1 "Csv2_rr_a.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-mrc8f5LG.i","")
#line 267 "Csv2_functions.h"
int csv2_is_number_or_dot(int32_t in ) ;
#line 268
js_string *process_ipv4_ddip(csv2_read *stream ) ;
#line 31 "Csv2_rr_a.c"
int csv2_is_number_or_dot(int32_t in ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 32
  tmp = csv2_is_number(in);
#line 32
  if (tmp) {
#line 32
    tmp___0 = 1;
  } else
#line 32
  if (in == 46) {
#line 32
    tmp___0 = 1;
  } else {
#line 32
    tmp___0 = 0;
  }
#line 32
  return (tmp___0);
}
}
#line 38 "Csv2_rr_a.c"
js_string *process_ipv4_ddip(csv2_read *stream ) 
{ js_string *o ;
  int32_t look ;
  int num_nums ;
  int x ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 41
  num_nums = 1;
#line 44
  o = process_1stchar(stream, & csv2_is_number, (char *)0);
#line 45
  if ((unsigned long )o == (unsigned long )((js_string *)0)) {
#line 46
    return ((js_string *)0);
  }
#line 49
  x = 0;
#line 49
  while (x < 10000) {
#line 50
    look = csv2_read_unicode(stream);
#line 51
    if (look == -164) {
#line 52
      js_destroy(o);
#line 53
      return ((js_string *)0);
    }
#line 55
    if (look == 35) {
#line 55
      if (num_nums == 4) {
#line 56
        process_comment(stream);
#line 57
        return (o);
      } else {
#line 55
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 59
    if (look == 46) {
#line 59
      if (num_nums < 4) {
#line 60
        num_nums ++;
#line 61
        tmp = csv2_append_utf8(o, '.');
#line 61
        if (tmp < 0) {
#line 62
          csv2_error(stream, (char *)"Error appending character");
#line 63
          js_destroy(o);
#line 64
          return ((js_string *)0);
        }
      } else {
#line 59
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 67
    if (look == 46) {
#line 68
      csv2_error(stream, (char *)"Too many numbers in ipv4 ddip");
#line 69
      js_destroy(o);
#line 70
      return ((js_string *)0);
    } else {
#line 72
      tmp___2 = csv2_is_number(look);
#line 72
      if (tmp___2) {
#line 73
        tmp___0 = csv2_append_utf8(o, look);
#line 73
        if (tmp___0 < 0) {
#line 74
          csv2_error(stream, (char *)"Error appending character");
#line 75
          js_destroy(o);
#line 76
          return ((js_string *)0);
        }
      } else {
#line 79
        tmp___1 = csv2_is_delimiter(look);
#line 79
        if (tmp___1) {
#line 79
          if (num_nums == 4) {
#line 80
            return (o);
          } else {
#line 83
            csv2_error(stream, (char *)"Unexpected character in ddip");
#line 84
            js_destroy(o);
#line 85
            return ((js_string *)0);
          }
        } else {
#line 83
          csv2_error(stream, (char *)"Unexpected character in ddip");
#line 84
          js_destroy(o);
#line 85
          return ((js_string *)0);
        }
      }
    }
#line 49
    x ++;
  }
#line 89
  js_destroy(o);
#line 90
  return ((js_string *)0);
}
}
#line 95 "Csv2_rr_a.c"
js_string *csv2_get_a(csv2_read *stream ) 
{ js_string *ddip ;
  js_string *out ;
  int tmp ;
  int tmp___0 ;

  {
#line 99
  tmp = csv2_get_1st(stream, & csv2_is_number, 0);
#line 99
  if (tmp != 1) {
#line 100
    return ((js_string *)0);
  }
#line 103
  ddip = process_ipv4_ddip(stream);
#line 103
  if ((unsigned long )ddip == (unsigned long )((js_string *)0)) {
#line 104
    return ((js_string *)0);
  }
#line 107
  out = js_create(7U, 1U);
#line 107
  if ((unsigned long )out == (unsigned long )((js_string *)0)) {
#line 108
    js_destroy(ddip);
#line 109
    return ((js_string *)0);
  }
#line 112
  tmp___0 = ddip_2_ip(ddip, out, 0);
#line 112
  if (tmp___0 == -1) {
#line 113
    js_destroy(ddip);
#line 114
    js_destroy(out);
#line 115
    return ((js_string *)0);
  }
#line 118
  js_destroy(ddip);
#line 119
  return (out);
}
}
#line 1 "Csv2_rr_wks.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-JBolk4Ft.i","")
#line 196 "Csv2_functions.h"
int csv2_is_hash(int32_t in ) ;
#line 276
js_string *csv2_get_string(csv2_read *stream , int numchunks , int post_txt ) ;
#line 280
int csv2_is_wks(int32_t in ) ;
#line 40 "Csv2_rr_wks.c"
int csv2_is_wks(int32_t in ) 
{ int tmp ;

  {
#line 41
  if (in == 44) {
#line 41
    tmp = 1;
  } else
#line 41
  if (in == 9) {
#line 41
    tmp = 1;
  } else
#line 41
  if (in == 32) {
#line 41
    tmp = 1;
  } else {
#line 41
    tmp = 0;
  }
#line 41
  return (tmp);
}
}
#line 45 "Csv2_rr_wks.c"
int csv2_is_alphanum_ordot(int32_t in ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 46
  tmp = csv2_is_alphanum(in);
#line 46
  if (tmp) {
#line 46
    tmp___0 = 1;
  } else
#line 46
  if (in == 46) {
#line 46
    tmp___0 = 1;
  } else {
#line 46
    tmp___0 = 0;
  }
#line 46
  return (tmp___0);
}
}
#line 50 "Csv2_rr_wks.c"
int csv2_is_signed_num(int32_t in ) 
{ int tmp ;

  {
#line 51
  if (in >= 48) {
#line 51
    if (in <= 57) {
#line 51
      tmp = 1;
    } else {
#line 51
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 51
  if (in == 45) {
#line 51
    tmp = 1;
  } else {
#line 51
    tmp = 0;
  }
#line 51
  return (tmp);
}
}
#line 56 "Csv2_rr_wks.c"
js_string *csv2_get_wks(csv2_read *stream ) 
{ js_string *ddip ;
  js_string *out ;
  int protocol ;
  int ports[13] ;
  int portindex ;
  int hiport ;
  int32_t look ;
  int x ;
  int num ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int pn ;
  int q ;
  int mask ;

  {
#line 61
  portindex = 0;
#line 62
  hiport = 0;
#line 66
  tmp = csv2_get_1st(stream, & csv2_is_number, 0);
#line 66
  if (tmp != 1) {
#line 67
    return ((js_string *)0);
  }
#line 71
  ddip = process_ipv4_ddip(stream);
#line 71
  if ((unsigned long )ddip == (unsigned long )((js_string *)0)) {
#line 72
    return ((js_string *)0);
  }
#line 76
  protocol = csv2_get_num(stream);
#line 77
  if (protocol < 0) {
#line 78
    js_destroy(ddip);
#line 79
    return ((js_string *)0);
  }
#line 82
  tmp___0 = csv2_get_1st(stream, & csv2_is_number, 0);
#line 82
  if (tmp___0 != 1) {
#line 83
    js_destroy(ddip);
#line 84
    return ((js_string *)0);
  }
#line 90
  if ((int )stream->tilde_handling == 103) {
#line 91
    csv2_allow_tilde(stream);
  }
#line 93
  look = csv2_justread(stream);
#line 94
  num = 0;
#line 95
  x = 0;
#line 95
  while (x < 1000) {
#line 96
    if ((int )stream->tilde_handling != 103) {
#line 100
      if (look == -2) {
#line 101
        break;
      } else
#line 100
      if (look == 10) {
#line 101
        break;
      } else
#line 100
      if (look == 13) {
#line 101
        break;
      } else {
#line 104
        tmp___1 = csv2_is_hash(look);
#line 104
        if (tmp___1) {
#line 105
          process_comment(stream);
#line 106
          break;
        }
      }
    } else
#line 111
    if (look == 126) {
#line 112
      break;
    } else {
#line 113
      tmp___2 = csv2_is_hash(look);
#line 113
      if (tmp___2) {
#line 114
        process_comment(stream);
#line 115
        look = csv2_read_unicode(stream);
#line 116
        goto __Cont;
      }
    }
#line 120
    tmp___4 = csv2_is_number(look);
#line 120
    if (tmp___4) {
#line 121
      num *= 10;
#line 122
      num += look - 48;
#line 127
      if (num > 100000) {
#line 128
        js_destroy(ddip);
#line 129
        return ((js_string *)0);
      }
    } else {
#line 134
      tmp___3 = csv2_is_wks(look);
#line 134
      if (tmp___3) {
#line 134
        goto _L___0;
      } else
#line 134
      if ((int )stream->tilde_handling == 103) {
#line 134
        if (look == 13) {
#line 134
          goto _L___0;
        } else
#line 134
        if (look == 10) {
          _L___0: /* CIL Label */ 
#line 138
          if (portindex >= 10) {
#line 139
            js_destroy(ddip);
#line 140
            return ((js_string *)0);
          }
#line 142
          ports[portindex] = num;
#line 143
          portindex ++;
#line 144
          if (num > hiport) {
#line 145
            hiport = num;
          }
#line 147
          if (num > 1024) {
#line 148
            js_destroy(ddip);
#line 149
            return ((js_string *)0);
          }
#line 151
          num = 0;
        } else {
#line 155
          js_destroy(ddip);
#line 156
          return ((js_string *)0);
        }
      } else {
#line 155
        js_destroy(ddip);
#line 156
        return ((js_string *)0);
      }
    }
#line 158
    look = csv2_read_unicode(stream);
    __Cont: /* CIL Label */ 
#line 95
    x ++;
  }
#line 166
  if (num > 0) {
#line 166
    if (num < 1024) {
#line 167
      if (portindex >= 10) {
#line 168
        js_destroy(ddip);
#line 169
        return ((js_string *)0);
      }
#line 171
      ports[portindex] = num;
#line 172
      if (num > hiport) {
#line 173
        hiport = num;
      }
    }
  }
#line 178
  out = js_create((unsigned int )((hiport >> 3) + 6), 1U);
#line 178
  if ((unsigned long )out == (unsigned long )((js_string *)0)) {
#line 179
    js_destroy(ddip);
#line 180
    return ((js_string *)0);
  }
#line 184
  x = 0;
#line 184
  while (x < (hiport >> 3) + 6) {
#line 185
    *(out->string + x) = (unsigned char)0;
#line 184
    x ++;
  }
#line 190
  tmp___5 = ddip_2_ip(ddip, out, 0);
#line 190
  if (tmp___5 == -1) {
#line 191
    js_destroy(ddip);
#line 192
    js_destroy(out);
#line 193
    return ((js_string *)0);
  }
#line 197
  out->unit_count = (unsigned int )(6 + (hiport >> 3));
#line 200
  if (out->max_count < out->unit_count) {
#line 201
    js_destroy(ddip);
#line 202
    js_destroy(out);
#line 203
    return ((js_string *)0);
  }
#line 207
  *(out->string + 4) = (unsigned char )(protocol & 255);
#line 210
  x = 0;
#line 210
  while (x < portindex) {
#line 212
    pn = ports[x];
#line 213
    q = pn >> 3;
#line 214
    mask = 128 >> pn % 8;
#line 215
    if ((unsigned int )q >= out->unit_count) {
#line 216
      js_destroy(ddip);
#line 217
      js_destroy(out);
#line 218
      return ((js_string *)0);
    }
#line 220
    *((out->string + q) + 5) = (unsigned char )((int )*((out->string + q) + 5) | mask);
#line 210
    x ++;
  }
#line 223
  js_destroy(ddip);
#line 224
  return (out);
}
}
#line 230 "Csv2_rr_wks.c"
js_string *csv2_get_mbox(csv2_read *stream , js_string *zone , int count ) 
{ js_string *name ;
  js_string *out ;
  int c ;
  int tmp ;
  js_string *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 235
  out = js_create(512U, 1U);
#line 235
  if ((unsigned long )out == (unsigned long )((js_string *)0)) {
#line 236
    return ((js_string *)0);
  }
#line 239
  c = 0;
#line 239
  while (c < count) {
#line 241
    tmp = csv2_get_1st(stream, & csv2_is_alphanum_ordot, 0);
#line 241
    if (tmp != 1) {
#line 243
      js_destroy(out);
#line 244
      return ((js_string *)0);
    }
#line 246
    name = process_mbox(stream);
#line 246
    if ((unsigned long )name == (unsigned long )((js_string *)0)) {
#line 247
      js_destroy(out);
#line 248
      return ((js_string *)0);
    }
#line 250
    tmp___0 = csv2_convert_percent(name, zone);
#line 250
    if ((unsigned long )tmp___0 == (unsigned long )((js_string *)0)) {
#line 251
      js_destroy(name);
#line 252
      js_destroy(out);
#line 253
      return ((js_string *)0);
    }
#line 255
    tmp___1 = email_2rfc1035(name);
#line 255
    if (tmp___1 == -1) {
#line 256
      js_destroy(name);
#line 257
      js_destroy(out);
#line 258
      return ((js_string *)0);
    }
#line 260
    tmp___2 = js_append(name, out);
#line 260
    if (tmp___2 == -1) {
#line 261
      js_destroy(name);
#line 262
      js_destroy(out);
#line 263
      return ((js_string *)0);
    }
#line 265
    js_destroy(name);
#line 239
    c ++;
  }
#line 267
  return (out);
}
}
#line 272 "Csv2_rr_wks.c"
js_string *csv2_get_hex(csv2_read *stream ) 
{ js_string *out ;
  int32_t look ;
  int place ;
  int tmp ;
  int tmp___0 ;
  int32_t tmp___1 ;
  int lnybble ;
  int rnybble ;
  int chr ;
  int x ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 279
  tmp = csv2_get_1st(stream, & csv2_is_number, 0);
#line 279
  if (tmp != 1) {
#line 280
    return ((js_string *)0);
  }
#line 282
  tmp___0 = csv2_justread(stream);
#line 282
  if (tmp___0 != 48) {
#line 283
    return ((js_string *)0);
  }
#line 285
  tmp___1 = csv2_read_unicode(stream);
#line 285
  if (tmp___1 != 120) {
#line 286
    return ((js_string *)0);
  }
#line 289
  look = -1;
#line 290
  place = 0;
#line 292
  out = js_create(256U, 1U);
#line 293
  if ((unsigned long )out == (unsigned long )((js_string *)0)) {
#line 294
    return ((js_string *)0);
  }
#line 297
  while (1) {
#line 297
    if (look != -2) {
#line 297
      tmp___4 = csv2_is_delimiter(look);
#line 297
      if (tmp___4) {
#line 297
        break;
      }
    } else {
#line 297
      break;
    }
#line 301
    look = csv2_read_unicode(stream);
#line 302
    x = 0;
#line 304
    while (1) {
#line 304
      if (look == 46) {
#line 304
        if (! (x < 10000)) {
#line 304
          break;
        }
      } else {
#line 304
        break;
      }
#line 305
      look = csv2_read_unicode(stream);
#line 306
      x ++;
    }
#line 308
    if (look >= 48) {
#line 308
      if (look <= 57) {
#line 309
        lnybble = look - 48;
      } else {
#line 308
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 311
    if (look >= 97) {
#line 311
      if (look <= 102) {
#line 312
        lnybble = look - 97;
      } else {
#line 311
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 314
    if (look >= 65) {
#line 314
      if (look <= 70) {
#line 315
        lnybble = look - 65;
      } else {
#line 314
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 317
    if (look == -2) {
#line 318
      break;
    } else {
#line 317
      tmp___2 = csv2_is_delimiter(look);
#line 317
      if (tmp___2) {
#line 318
        break;
      } else {
#line 321
        csv2_error(stream, (char *)"Unexpected char");
#line 322
        js_destroy(out);
#line 323
        return ((js_string *)0);
      }
    }
#line 325
    look = csv2_read_unicode(stream);
#line 327
    if (look == 46) {
#line 328
      csv2_error(stream, (char *)"Dot not at byte boundary");
#line 329
      js_destroy(out);
#line 330
      return ((js_string *)0);
    }
#line 332
    if (look >= 48) {
#line 332
      if (look <= 57) {
#line 333
        rnybble = look - 48;
      } else {
#line 332
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 335
    if (look >= 97) {
#line 335
      if (look <= 102) {
#line 336
        rnybble = look - 97;
      } else {
#line 335
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 338
    if (look >= 65) {
#line 338
      if (look <= 70) {
#line 339
        rnybble = look - 65;
      } else {
#line 338
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 341
    if (look == -2) {
#line 342
      csv2_error(stream, (char *)"Record must end on byte boundary");
#line 343
      js_destroy(out);
#line 344
      return ((js_string *)0);
    } else {
#line 341
      tmp___3 = csv2_is_delimiter(look);
#line 341
      if (tmp___3) {
#line 342
        csv2_error(stream, (char *)"Record must end on byte boundary");
#line 343
        js_destroy(out);
#line 344
        return ((js_string *)0);
      } else {
#line 347
        csv2_error(stream, (char *)"Unexpected char");
#line 348
        js_destroy(out);
#line 349
        return ((js_string *)0);
      }
    }
#line 351
    chr = (((lnybble & 15) << 4) | (rnybble & 15)) & 255;
#line 352
    if ((unsigned int )(place + 7) > out->max_count) {
#line 353
      js_destroy(out);
#line 354
      return ((js_string *)0);
    }
#line 356
    out->unit_count = (unsigned int )(place + 1);
#line 357
    *(out->string + place) = (unsigned char )chr;
#line 358
    place ++;
  }
#line 361
  return (out);
}
}
#line 370 "Csv2_rr_wks.c"
int32_t csv2_get_int(csv2_read *stream , int mulfactor ) 
{ int out ;
  int32_t look ;
  int x ;
  int decimal ;
  int sign ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 371
  out = 0;
#line 374
  decimal = 0;
#line 375
  sign = 1;
#line 377
  if (mulfactor == 3) {
#line 378
    mulfactor = 1000;
  } else
#line 379
  if (mulfactor == 2) {
#line 380
    mulfactor = 100;
  } else
#line 381
  if (mulfactor == 1) {
#line 382
    mulfactor = 10;
  } else
#line 383
  if (mulfactor == 0) {
#line 384
    mulfactor = 1;
  } else {
#line 386
    return (0);
  }
#line 389
  look = csv2_justread(stream);
#line 390
  if (look == 45) {
#line 391
    sign = -1;
#line 392
    look = csv2_read_unicode(stream);
  }
#line 395
  x = 0;
#line 395
  while (x < 100) {
#line 396
    tmp___1 = csv2_is_number_or_dot(look);
#line 396
    if (tmp___1) {
#line 399
      tmp___0 = csv2_is_number(look);
#line 399
      if (tmp___0) {
#line 400
        out *= 10;
#line 401
        out += look - 48;
      } else
#line 403
      if (look == 46) {
#line 404
        decimal = 0;
#line 405
        out *= mulfactor;
#line 406
        look = csv2_read_unicode(stream);
#line 407
        while (1) {
#line 407
          tmp = csv2_is_number(look);
#line 407
          if (tmp) {
#line 407
            if (! (mulfactor > 1)) {
#line 407
              break;
            }
          } else {
#line 407
            break;
          }
#line 408
          mulfactor /= 10;
#line 409
          decimal += (look - 48) * mulfactor;
#line 410
          look = csv2_read_unicode(stream);
        }
#line 412
        return ((out + decimal) * sign);
      }
    } else {
#line 397
      return ((out * mulfactor) * sign);
    }
#line 414
    look = csv2_read_unicode(stream);
#line 395
    x ++;
  }
#line 416
  return (0);
}
}
#line 421 "Csv2_rr_wks.c"
uint32_t csv2_get_lon_lat(csv2_read *stream , char r1 , char r2 , char r3 , char r4 ) 
{ uint32_t out ;
  int degrees ;
  int mins ;
  int secs ;
  int32_t look ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 424
  degrees = 0;
#line 425
  mins = 0;
#line 426
  secs = 0;
#line 429
  tmp = csv2_get_1st(stream, & csv2_is_number, 0);
#line 429
  if (tmp != 1) {
#line 430
    return ((uint32_t )0);
  }
#line 433
  degrees = csv2_get_int(stream, 0);
#line 435
  tmp___0 = csv2_get_1st(stream, & csv2_is_alphanum, 0);
#line 435
  if (tmp___0 != 1) {
#line 436
    return ((uint32_t )0);
  }
#line 439
  look = csv2_justread(stream);
#line 440
  if (look == (int32_t )r1) {
#line 441
    goto process;
  } else
#line 440
  if (look == (int32_t )r2) {
#line 441
    goto process;
  } else
#line 440
  if (look == (int32_t )r3) {
#line 441
    goto process;
  } else
#line 440
  if (look == (int32_t )r4) {
#line 441
    goto process;
  } else {
#line 442
    tmp___1 = csv2_is_number(look);
#line 442
    if (tmp___1) {
#line 443
      mins = csv2_get_int(stream, 0);
    } else {
#line 445
      return ((uint32_t )0);
    }
  }
#line 448
  tmp___2 = csv2_get_1st(stream, & csv2_is_alphanum, 0);
#line 448
  if (tmp___2 != 1) {
#line 449
    return ((uint32_t )0);
  }
#line 452
  look = csv2_justread(stream);
#line 453
  if (look == (int32_t )r1) {
#line 454
    goto process;
  } else
#line 453
  if (look == (int32_t )r2) {
#line 454
    goto process;
  } else
#line 453
  if (look == (int32_t )r3) {
#line 454
    goto process;
  } else
#line 453
  if (look == (int32_t )r4) {
#line 454
    goto process;
  } else {
#line 455
    tmp___3 = csv2_is_number(look);
#line 455
    if (tmp___3) {
#line 456
      secs = csv2_get_int(stream, 3);
    } else {
#line 458
      return ((uint32_t )0);
    }
  }
#line 461
  tmp___4 = csv2_get_1st(stream, & csv2_is_alphanum, 0);
#line 461
  if (tmp___4 != 1) {
#line 462
    return ((uint32_t )0);
  }
#line 464
  look = csv2_justread(stream);
  process: 
#line 468
  if (look != (int32_t )r1) {
#line 468
    if (look != (int32_t )r2) {
#line 468
      if (look != (int32_t )r3) {
#line 468
        if (look != (int32_t )r4) {
#line 469
          return ((uint32_t )0);
        }
      }
    }
  }
#line 472
  out = 2147483648U;
#line 474
  if (look == (int32_t )r1) {
#line 475
    out += (uint32_t )((degrees * 3600000 + mins * 60000) + secs);
  } else
#line 474
  if (look == (int32_t )r2) {
#line 475
    out += (uint32_t )((degrees * 3600000 + mins * 60000) + secs);
  } else {
#line 477
    out -= (uint32_t )((degrees * 3600000 + mins * 60000) + secs);
  }
#line 482
  csv2_read_unicode(stream);
#line 484
  return (out);
}
}
#line 489 "Csv2_rr_wks.c"
js_string *csv2_get_loc(csv2_read *stream ) 
{ uint32_t lat ;
  uint32_t lon ;
  uint32_t alt ;
  int size ;
  int hpre ;
  int vpre ;
  int32_t look ;
  int32_t get ;
  int x ;
  js_string *out ;
  int tmp ;
  int q ;
  int v ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 490
  lat = (uint32_t )0;
#line 491
  lon = (uint32_t )0;
#line 492
  alt = (uint32_t )0;
#line 493
  size = -1;
#line 494
  hpre = -1;
#line 495
  vpre = -1;
#line 503
  lat = csv2_get_lon_lat(stream, (char )'N', (char )'n', (char )'S', (char )'s');
#line 504
  lon = csv2_get_lon_lat(stream, (char )'E', (char )'e', (char )'W', (char )'w');
#line 507
  tmp = csv2_get_1st(stream, & csv2_is_signed_num, 0);
#line 507
  if (tmp == 0) {
#line 508
    return ((js_string *)0);
  }
#line 510
  get = csv2_get_int(stream, 2);
#line 511
  get += 10000000;
#line 512
  if (get < 0) {
#line 513
    return ((js_string *)0);
  }
#line 515
  alt = (uint32_t )get;
#line 516
  look = csv2_read_unicode(stream);
#line 517
  if (look == 109) {
#line 518
    look = csv2_read_unicode(stream);
  }
#line 523
  get = -2;
#line 526
  if ((int )stream->tilde_handling == 103) {
#line 527
    csv2_allow_tilde(stream);
  }
#line 530
  x = 0;
#line 530
  while (x < 1000) {
#line 531
    tmp___0 = csv2_is_wks(look);
#line 531
    if (tmp___0) {
#line 531
      goto _L;
    } else
#line 531
    if (look == 13) {
#line 531
      goto _L;
    } else
#line 531
    if (look == 10) {
#line 531
      goto _L;
    } else
#line 531
    if (look == -2) {
#line 531
      goto _L;
    } else {
#line 531
      tmp___1 = csv2_is_hash(look);
#line 531
      if (tmp___1) {
        _L: /* CIL Label */ 
#line 533
        q = 1;
#line 534
        v = 0;
#line 535
        if (get != -2) {
#line 536
          if (get == -1) {
#line 537
            get = 1;
          }
#line 539
          while (1) {
#line 539
            if (get >= 10) {
#line 539
              if (! (q < 10)) {
#line 539
                break;
              }
            } else {
#line 539
              break;
            }
#line 540
            q ++;
#line 541
            get /= 10;
          }
#line 543
          q ++;
#line 544
          v = (get & 15) << 4;
#line 545
          v |= q & 15;
#line 546
          if (size == -1) {
#line 547
            size = v;
          } else
#line 549
          if (hpre == -1) {
#line 550
            hpre = v;
          } else
#line 552
          if (vpre == -1) {
#line 553
            vpre = v;
          } else {
#line 556
            printf("here\n");
#line 557
            return ((js_string *)0);
          }
#line 559
          get = -2;
        }
      }
    }
#line 563
    if ((int )stream->tilde_handling != 103) {
#line 564
      if (look == -2) {
#line 565
        break;
      } else
#line 564
      if (look == 10) {
#line 565
        break;
      } else
#line 564
      if (look == 13) {
#line 565
        break;
      } else {
#line 567
        tmp___2 = csv2_is_hash(look);
#line 567
        if (tmp___2) {
#line 568
          process_comment(stream);
#line 569
          break;
        }
      }
    } else
#line 574
    if (look == 126) {
#line 575
      break;
    } else {
#line 576
      tmp___3 = csv2_is_hash(look);
#line 576
      if (tmp___3) {
#line 577
        process_comment(stream);
#line 578
        look = csv2_read_unicode(stream);
#line 579
        goto __Cont;
      }
    }
#line 583
    tmp___5 = csv2_is_number(look);
#line 583
    if (tmp___5) {
#line 584
      if (get < 0) {
#line 585
        get = 0;
      }
#line 587
      get *= 10;
#line 588
      get += look - 48;
    } else {
#line 592
      tmp___4 = csv2_is_wks(look);
#line 592
      if (! tmp___4) {
#line 592
        if (look != 109) {
#line 592
          if ((int )stream->tilde_handling == 103) {
#line 592
            if (! (look == 13)) {
#line 592
              if (! (look == 10)) {
#line 595
                return ((js_string *)0);
              }
            }
          } else {
#line 595
            return ((js_string *)0);
          }
        }
      }
    }
#line 597
    look = csv2_read_unicode(stream);
    __Cont: /* CIL Label */ 
#line 530
    x ++;
  }
#line 600
  if (size == -1) {
#line 601
    size = 18;
  }
#line 603
  if (hpre == -1) {
#line 604
    hpre = 22;
  }
#line 606
  if (vpre == -1) {
#line 607
    vpre = 19;
  }
#line 610
  out = js_create(18U, 1U);
#line 610
  if ((unsigned long )out == (unsigned long )((js_string *)0)) {
#line 611
    return ((js_string *)0);
  }
#line 613
  *(out->string) = (unsigned char)0;
#line 615
  *(out->string + 1) = (unsigned char )(size & 255);
#line 616
  *(out->string + 2) = (unsigned char )(hpre & 255);
#line 617
  *(out->string + 3) = (unsigned char )(vpre & 255);
#line 619
  *(out->string + 4) = (unsigned char )((lat >> 24) & 255U);
#line 620
  *(out->string + 5) = (unsigned char )((lat >> 16) & 255U);
#line 621
  *(out->string + 6) = (unsigned char )((lat >> 8) & 255U);
#line 622
  *(out->string + 7) = (unsigned char )(lat & 255U);
#line 624
  *(out->string + 8) = (unsigned char )((lon >> 24) & 255U);
#line 625
  *(out->string + 9) = (unsigned char )((lon >> 16) & 255U);
#line 626
  *(out->string + 10) = (unsigned char )((lon >> 8) & 255U);
#line 627
  *(out->string + 11) = (unsigned char )(lon & 255U);
#line 629
  *(out->string + 12) = (unsigned char )((alt >> 24) & 255U);
#line 630
  *(out->string + 13) = (unsigned char )((alt >> 16) & 255U);
#line 631
  *(out->string + 14) = (unsigned char )((alt >> 8) & 255U);
#line 632
  *(out->string + 15) = (unsigned char )(alt & 255U);
#line 633
  out->unit_count = 16U;
#line 634
  return (out);
}
}
#line 640 "Csv2_rr_wks.c"
js_string *csv2_get_naptr(csv2_read *stream ) 
{ js_string *out ;
  js_string *name ;
  js_string *zone ;
  int num ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 643
  out = (js_string *)0;
#line 644
  name = (js_string *)0;
#line 645
  zone = (js_string *)0;
#line 646
  num = 0;
#line 647
  c = 0;
#line 649
  out = js_create(256U, 1U);
#line 650
  if ((unsigned long )out == (unsigned long )((js_string *)0)) {
#line 651
    return ((js_string *)0);
  }
#line 656
  c = 1;
#line 656
  while (c <= 2) {
#line 657
    num = csv2_get_num(stream);
#line 657
    if (num < 0) {
#line 658
      js_destroy(out);
#line 659
      return ((js_string *)0);
    }
#line 661
    tmp = js_adduint16(out, num);
#line 661
    if (tmp == -1) {
#line 662
      js_destroy(out);
#line 663
      return ((js_string *)0);
    }
#line 656
    c ++;
  }
#line 668
  name = csv2_get_string(stream, 3, 1);
#line 669
  if ((unsigned long )name == (unsigned long )((js_string *)0)) {
#line 670
    js_destroy(out);
#line 671
    return ((js_string *)0);
  }
#line 675
  tmp___0 = js_append(name, out);
#line 675
  if (tmp___0 == -1) {
#line 676
    js_destroy(name);
#line 677
    js_destroy(out);
#line 678
    return ((js_string *)0);
  }
#line 681
  js_destroy(name);
#line 684
  tmp___1 = csv2_get_1st(stream, & csv2_is_dchar, 0);
#line 684
  if (tmp___1 != 1) {
#line 685
    js_destroy(out);
#line 686
    return ((js_string *)0);
  }
#line 689
  zone = js_create(256U, 1U);
#line 692
  if ((unsigned long )zone == (unsigned long )((js_string *)0)) {
#line 693
    js_destroy(out);
#line 694
    return ((js_string *)0);
  }
#line 697
  name = csv2_get_hostname(stream, zone, 3);
#line 699
  js_destroy(zone);
#line 701
  if ((unsigned long )name == (unsigned long )((js_string *)0)) {
#line 702
    js_destroy(out);
#line 703
    return ((js_string *)0);
  }
#line 707
  tmp___2 = js_append(name, out);
#line 707
  if (tmp___2 == -1) {
#line 708
    js_destroy(name);
#line 709
    js_destroy(out);
#line 710
    return ((js_string *)0);
  }
#line 713
  js_destroy(name);
#line 714
  return (out);
}
}
#line 1 "Csv2_database.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-lONainuT.i","")
#line 24 "Csv2_functions.h"
int add_rr_to_bighash(mhash *bighash , js_string *query , js_string *data , uint32_t ttl ,
                      js_string *zone , uint16_t perms ) ;
#line 86
int csv2_add_rr_debug(csv2_add_state *state , js_string *query , int rtype , int32_t ttl ,
                      js_string *data ) ;
#line 95
int csv2_add_rr_bighash(csv2_add_state *state , js_string *query , int rtype , int32_t ttl ,
                        js_string *data , int32_t starwhitis ) ;
#line 104
int csv2_add_rr_zoneserver(csv2_add_state *state , js_string *query , int rtype ,
                           int32_t ttl , js_string *data ) ;
#line 111
js_string *csv2_synth_query(csv2_add_state *state ) ;
#line 114
int csv2_synthesize_soa(csv2_add_state *state ) ;
#line 121
js_string *csv2_synth_ip(csv2_add_state *state , uint32_t ip , int actually_make_record ) ;
#line 125
int csv2_make_synth_ns(csv2_add_state *state , uint32_t ip ) ;
#line 130
int csv2_is_private_ip(uint32_t ip ) ;
#line 135
int csv2_is_localhost_ip(uint32_t ip ) ;
#line 139
int csv2_synthesize_ns(csv2_add_state *state ) ;
#line 148
int csv2_push_buffer(csv2_add_state *state , js_string *query , int rtype , int32_t ttl ,
                     js_string *data ) ;
#line 155
int csv2_set_soa(csv2_add_state *state , js_string *query , js_string *data , int32_t ttl ) ;
#line 160
int csv2_is_zonetop(csv2_add_state *state , js_string *query ) ;
#line 171
js_string *csv2_copy_js(js_string *s ) ;
#line 180
int csv2_add_rr_w(csv2_add_state *state , js_string *query , int rtype , int32_t ttl ,
                  js_string *data ) ;
#line 436 "/usr/include/sys/stat.h"
extern int stat(char const   * , struct stat * )  __asm__("_stat$INODE64")  ;
#line 142 "/usr/include/time.h"
extern struct tm *gmtime_r(time_t const   * , struct tm * ) ;
#line 45 "Csv2_database.c"
js_string *show_synth_soa_origin(void) ;
#line 46
int show_synth_soa_serial(void) ;
#line 67 "Csv2_database.c"
csv2_add_state *csv2_init_add_state(js_string *zone ) 
{ js_string *nzone ;
  js_string *norigin ;
  csv2_add_state *new ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 70
  if (zone->unit_size != 1U) {
#line 71
    return ((csv2_add_state *)0);
  }
#line 73
  tmp = js_alloc(1, (int )sizeof(csv2_add_state ));
#line 73
  new = (csv2_add_state *)tmp;
#line 73
  if ((unsigned long )new == (unsigned long )((csv2_add_state *)0)) {
#line 74
    return ((csv2_add_state *)0);
  }
#line 76
  nzone = js_create(zone->unit_count + 1U, 1U);
#line 76
  if ((unsigned long )nzone == (unsigned long )((js_string *)0)) {
#line 77
    js_dealloc((void *)new);
#line 78
    return ((csv2_add_state *)0);
  }
#line 80
  norigin = js_create(zone->unit_count + 1U, 1U);
#line 80
  if ((unsigned long )norigin == (unsigned long )((js_string *)0)) {
#line 81
    js_dealloc((void *)new);
#line 82
    return ((csv2_add_state *)0);
  }
#line 84
  tmp___0 = js_copy(zone, nzone);
#line 84
  if (tmp___0 == -1) {
#line 85
    js_destroy(nzone);
#line 86
    js_dealloc((void *)new);
#line 87
    return ((csv2_add_state *)0);
  }
#line 89
  tmp___1 = js_copy(zone, norigin);
#line 89
  if (tmp___1 == -1) {
#line 90
    js_destroy(nzone);
#line 91
    js_dealloc((void *)new);
#line 92
    return ((csv2_add_state *)0);
  }
#line 94
  new->buffer = (csv2_rr *)0;
#line 95
  new->zone = nzone;
#line 96
  new->origin = norigin;
#line 97
  new->ostack = (csv2_origin *)0;
#line 99
  new->ostack_height = 0;
#line 100
  new->rrnum = 0;
#line 101
  new->bighash = (mhash *)0;
#line 102
  new->add_method = 0;
#line 103
  new->soa_serial = 1;
#line 104
  new->default_ttl = 86400;
#line 105
  new->in_ns = 1;
#line 106
  new->zone_nses_added = 0;
#line 107
  return (new);
}
}
#line 110 "Csv2_database.c"
void csv2_zap_add_state(csv2_add_state *x ) 
{ int a ;
  csv2_origin *v ;
  csv2_origin *q ;
  csv2_rr *y ;
  csv2_rr *z ;

  {
#line 111
  a = 0;
#line 116
  v = x->ostack;
#line 117
  while (1) {
#line 117
    if ((unsigned long )v != (unsigned long )((csv2_origin *)0)) {
#line 117
      if (! (a < 10000)) {
#line 117
        break;
      }
    } else {
#line 117
      break;
    }
#line 118
    js_destroy(v->origin);
#line 119
    q = v->next;
#line 120
    js_dealloc((void *)v);
#line 121
    v = q;
#line 122
    a ++;
  }
#line 124
  a = 0;
#line 127
  y = x->buffer;
#line 128
  while (1) {
#line 128
    if ((unsigned long )y != (unsigned long )((csv2_rr *)0)) {
#line 128
      if (! (a < 10000)) {
#line 128
        break;
      }
    } else {
#line 128
      break;
    }
#line 129
    js_destroy(y->query);
#line 130
    js_destroy(y->data);
#line 131
    z = y->next;
#line 132
    js_dealloc((void *)y);
#line 133
    y = z;
#line 134
    a ++;
  }
#line 136
  a = 0;
#line 139
  if ((unsigned long )x->zone != (unsigned long )((js_string *)0)) {
#line 140
    js_destroy(x->zone);
#line 141
    x->zone = (js_string *)0;
  }
#line 144
  if ((unsigned long )x->origin != (unsigned long )((js_string *)0)) {
#line 145
    js_destroy(x->origin);
#line 146
    x->origin = (js_string *)0;
  }
#line 150
  js_dealloc((void *)x);
#line 151
  return;
}
}
#line 160 "Csv2_database.c"
int csv2_set_bighash(csv2_add_state *state , mhash *bighash ) 
{ 

  {
#line 161
  if ((unsigned long )state == (unsigned long )((csv2_add_state *)0)) {
#line 162
    return (-1);
  }
#line 164
  state->bighash = bighash;
#line 165
  return (1);
}
}
#line 171 "Csv2_database.c"
int csv2_set_add_method(csv2_add_state *state , int method ) 
{ 

  {
#line 172
  if ((unsigned long )state == (unsigned long )((csv2_add_state *)0)) {
#line 173
    return (-1);
  }
#line 175
  state->add_method = method;
#line 176
  return (1);
}
}
#line 181 "Csv2_database.c"
int csv2_close_state(csv2_add_state *state ) 
{ 

  {
#line 182
  csv2_zap_add_state(state);
#line 183
  return (1);
}
}
#line 189 "Csv2_database.c"
int csv2_set_soa_serial(csv2_add_state *state , js_string *filename ) 
{ char name[256] ;
  struct stat buf ;
  time_t t ;
  int64_t q ;
  int tmp ;
  int tmp___0 ;
  struct tm bd ;
  struct tm *tmp___1 ;
  int tmp___2 ;

  {
#line 194
  tmp = js_js2str(filename, name, 200);
#line 194
  if (tmp == -1) {
#line 195
    return (-1);
  }
#line 197
  tmp___0 = stat((char const   *)(name), & buf);
#line 197
  if (tmp___0 == -1) {
#line 198
    return (-1);
  }
#line 200
  t = buf.st_mtimespec.tv_sec;
#line 202
  if (t < 290805600L) {
#line 203
    t += 2147483648L;
  }
#line 205
  tmp___2 = show_synth_soa_serial();
#line 205
  if (tmp___2 != 2) {
#line 206
    q = (int64_t )t;
#line 207
    q -= 290805600LL;
#line 208
    q /= 6LL;
  } else {
#line 214
    tmp___1 = gmtime_r((time_t const   *)(& t), & bd);
#line 214
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 215
      return (1979032815);
    }
#line 220
    q = (int64_t )(bd.tm_year + 1900);
#line 221
    q *= 100LL;
#line 222
    q += (int64_t )(bd.tm_mon + 1);
#line 223
    q *= 100LL;
#line 224
    q += (int64_t )bd.tm_mday;
#line 225
    q *= 100LL;
#line 226
    q += (int64_t )bd.tm_hour;
  }
#line 228
  state->soa_serial = (int32_t )q;
#line 229
  return (1);
}
}
#line 235 "Csv2_database.c"
js_string *csv2_zone_to_udpzone(js_string *zone ) 
{ js_string *udpzone ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 240
  udpzone = js_create(128U, 1U);
#line 240
  if ((unsigned long )udpzone == (unsigned long )((js_string *)0)) {
#line 241
    return ((js_string *)0);
  }
#line 243
  tmp = js_qstr2js(udpzone, (char *)"A");
#line 243
  if (tmp == -1) {
#line 244
    js_destroy(udpzone);
#line 245
    return ((js_string *)0);
  }
#line 247
  tmp___0 = js_append(zone, udpzone);
#line 247
  if (tmp___0 == -1) {
#line 248
    js_destroy(udpzone);
#line 249
    return ((js_string *)0);
  }
#line 251
  tmp___1 = hname_2rfc1035_starwhitis(udpzone, 1);
#line 251
  if (tmp___1 == -1) {
#line 252
    js_destroy(udpzone);
#line 256
    return ((js_string *)0);
  }
#line 258
  return (udpzone);
}
}
#line 268 "Csv2_database.c"
int csv2_add_rr_debug(csv2_add_state *state , js_string *query , int rtype , int32_t ttl ,
                      js_string *data ) 
{ 

  {
#line 270
  if ((unsigned long )state == (unsigned long )((csv2_add_state *)0)) {
#line 271
    return (-1);
  }
#line 273
  printf("Name: ");
#line 274
  show_esc_stdout(query);
#line 275
  printf("\nrtype: %d\nttl %d\n", rtype, ttl);
#line 276
  printf("rddata: ");
#line 276
  show_esc_stdout(data);
#line 276
  printf("\n\n");
#line 277
  return (1);
}
}
#line 286 "Csv2_database.c"
int csv2_add_rr_bighash(csv2_add_state *state , js_string *query , int rtype , int32_t ttl ,
                        js_string *data , int32_t starwhitis ) 
{ js_string *cquery ;
  js_string *udpzone ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 292
  if ((unsigned long )state->bighash == (unsigned long )((mhash *)0)) {
#line 293
    return (-1);
  }
#line 295
  if ((unsigned long )state->zone == (unsigned long )((js_string *)0)) {
#line 296
    return (-1);
  }
#line 298
  if ((unsigned long )state->origin == (unsigned long )((js_string *)0)) {
#line 299
    return (-1);
  }
#line 301
  tmp = js_has_sanity(query);
#line 301
  if (tmp == -1) {
#line 302
    return (-1);
  }
#line 304
  if (query->unit_size != 1U) {
#line 305
    return (-1);
  }
#line 307
  tmp___0 = js_has_sanity(data);
#line 307
  if (tmp___0 == -1) {
#line 308
    return (-1);
  }
#line 310
  if (data->unit_size != 1U) {
#line 311
    return (-1);
  }
#line 314
  if (ttl < 60) {
#line 315
    ttl = 60;
  }
#line 317
  if (ttl > 63072000) {
#line 318
    ttl = 63072000;
  }
#line 323
  cquery = js_create(query->unit_count + 3U, 1U);
#line 323
  if ((unsigned long )cquery == (unsigned long )((js_string *)0)) {
#line 324
    return (-1);
  }
#line 326
  tmp___1 = js_copy(query, cquery);
#line 326
  if (tmp___1 == -1) {
#line 327
    js_destroy(cquery);
#line 328
    return (-1);
  }
#line 330
  tmp___2 = js_adduint16(cquery, rtype);
#line 330
  if (tmp___2 == -1) {
#line 331
    js_destroy(cquery);
#line 332
    return (-1);
  }
#line 335
  udpzone = csv2_zone_to_udpzone(state->zone);
#line 335
  if ((unsigned long )udpzone == (unsigned long )((js_string *)0)) {
#line 336
    js_destroy(cquery);
#line 337
    return (-1);
  }
#line 341
  tmp___3 = js_adduint16(udpzone, 2);
#line 341
  if (tmp___3 == -1) {
#line 342
    js_destroy(cquery);
#line 343
    js_destroy(udpzone);
#line 344
    return (-1);
  }
#line 348
  add_rr_to_bighash(state->bighash, cquery, data, (uint32_t )ttl, udpzone, (uint16_t )0);
#line 349
  js_destroy(udpzone);
#line 350
  js_destroy(cquery);
#line 351
  return (1);
}
}
#line 360 "Csv2_database.c"
int csv2_add_rr_zoneserver(csv2_add_state *state , js_string *query , int rtype ,
                           int32_t ttl , js_string *data ) 
{ int ret ;
  js_string *cquery ;
  int tmp ;
  int tmp___0 ;

  {
#line 368
  if (rtype == 6) {
#line 369
    return (1);
  }
#line 375
  if (query->unit_count >= 1U) {
#line 375
    if ((int )*(query->string) == 95) {
#line 376
      cquery = js_create(query->unit_count + 2U, 1U);
#line 376
      if ((unsigned long )cquery == (unsigned long )((js_string *)0)) {
#line 377
        return (-1);
      }
#line 381
      tmp = js_qstr2js(cquery, (char *)"\001");
#line 381
      if (tmp == -1) {
#line 382
        js_destroy(cquery);
#line 383
        return (-1);
      }
#line 387
      tmp___0 = js_append(query, cquery);
#line 387
      if (tmp___0 == -1) {
#line 388
        js_destroy(cquery);
#line 389
        return (-1);
      }
#line 393
      if (cquery->unit_count < 2U) {
#line 394
        js_destroy(cquery);
#line 395
        return (-1);
      }
#line 397
      *(cquery->string + 1) = (unsigned char )'*';
#line 399
      ret = csv2_push_buffer(state, cquery, rtype, ttl, data);
#line 400
      js_destroy(cquery);
    } else {
#line 402
      ret = csv2_push_buffer(state, query, rtype, ttl, data);
    }
  } else {
#line 402
    ret = csv2_push_buffer(state, query, rtype, ttl, data);
  }
#line 404
  return (ret);
}
}
#line 411 "Csv2_database.c"
js_string *csv2_synth_query(csv2_add_state *state ) 
{ js_string *query ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 416
  query = js_create(256U, 1U);
#line 416
  if ((unsigned long )query == (unsigned long )((js_string *)0)) {
#line 417
    return ((js_string *)0);
  }
#line 419
  tmp = js_qstr2js(query, (char *)"Z");
#line 419
  if (tmp == -1) {
#line 420
    js_destroy(query);
#line 421
    return ((js_string *)0);
  }
#line 423
  tmp___0 = js_append(state->zone, query);
#line 423
  if (tmp___0 == -1) {
#line 424
    js_destroy(query);
#line 425
    return ((js_string *)0);
  }
#line 427
  tmp___1 = hname_2rfc1035(query);
#line 427
  if (tmp___1 == -1) {
#line 428
    js_destroy(query);
#line 429
    return ((js_string *)0);
  }
#line 431
  return (query);
}
}
#line 435 "Csv2_database.c"
int csv2_synthesize_soa(csv2_add_state *state ) 
{ js_string *query ;
  js_string *email ;
  js_string *data ;
  int ret ;
  int tmp ;
  js_string *tmp___0 ;
  int tmp___1 ;
  js_string *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 440
  query = csv2_synth_query(state);
#line 440
  if ((unsigned long )query == (unsigned long )((js_string *)0)) {
#line 441
    return (-1);
  }
#line 447
  data = js_create(256U, 1U);
#line 447
  if ((unsigned long )data == (unsigned long )((js_string *)0)) {
#line 448
    js_destroy(query);
#line 449
    return (-1);
  }
#line 451
  tmp___2 = show_synth_soa_origin();
#line 451
  if ((unsigned long )tmp___2 == (unsigned long )((js_string *)0)) {
#line 453
    tmp = js_copy(query, data);
#line 453
    if (tmp == -1) {
#line 454
      js_destroy(query);
#line 455
      js_destroy(data);
#line 456
      return (-1);
    }
  } else {
#line 459
    tmp___0 = show_synth_soa_origin();
#line 459
    tmp___1 = js_copy(tmp___0, data);
#line 459
    if (tmp___1 == -1) {
#line 460
      js_destroy(query);
#line 461
      js_destroy(data);
#line 462
      return (-1);
    }
  }
#line 468
  email = js_create(256U, 1U);
#line 468
  if ((unsigned long )email == (unsigned long )((js_string *)0)) {
#line 469
    js_destroy(query);
#line 470
    js_destroy(data);
#line 471
    return (-1);
  }
#line 473
  tmp___3 = js_qappend((char *)"Zhostmaster.", email);
#line 473
  if (tmp___3 == -1) {
#line 474
    js_destroy(query);
#line 475
    js_destroy(data);
#line 476
    js_destroy(email);
#line 477
    return (-1);
  }
#line 479
  tmp___4 = js_append(state->zone, email);
#line 479
  if (tmp___4 == -1) {
#line 480
    js_destroy(query);
#line 481
    js_destroy(data);
#line 482
    js_destroy(email);
#line 483
    return (-1);
  }
#line 485
  tmp___5 = hname_2rfc1035(email);
#line 485
  if (tmp___5 == -1) {
#line 486
    js_destroy(query);
#line 487
    js_destroy(data);
#line 488
    js_destroy(email);
#line 489
    return (-1);
  }
#line 491
  tmp___6 = js_append(email, data);
#line 491
  if (tmp___6 == -1) {
#line 492
    js_destroy(query);
#line 493
    js_destroy(data);
#line 494
    js_destroy(email);
#line 495
    return (-1);
  }
#line 497
  js_destroy(email);
#line 500
  tmp___7 = js_adduint32(data, (uint32_t )state->soa_serial);
#line 500
  if (tmp___7 == -1) {
#line 501
    js_destroy(query);
#line 502
    js_destroy(data);
#line 503
    return (-1);
  }
#line 507
  tmp___8 = js_adduint32(data, (uint32_t )7200);
#line 507
  if (tmp___8 == -1) {
#line 508
    js_destroy(query);
#line 509
    js_destroy(data);
#line 510
    return (-1);
  }
#line 514
  tmp___9 = js_adduint32(data, (uint32_t )3600);
#line 514
  if (tmp___9 == -1) {
#line 515
    js_destroy(query);
#line 516
    js_destroy(data);
#line 517
    return (-1);
  }
#line 521
  tmp___10 = js_adduint32(data, (uint32_t )604800);
#line 521
  if (tmp___10 == -1) {
#line 522
    js_destroy(query);
#line 523
    js_destroy(data);
#line 524
    return (-1);
  }
#line 528
  tmp___11 = js_adduint32(data, (uint32_t )3600);
#line 528
  if (tmp___11 == -1) {
#line 529
    js_destroy(query);
#line 530
    js_destroy(data);
#line 531
    return (-1);
  }
#line 534
  ret = csv2_set_soa(state, query, data, 86400);
#line 535
  js_destroy(query);
#line 536
  js_destroy(data);
#line 537
  return (ret);
}
}
#line 545 "Csv2_database.c"
js_string *csv2_synth_ip(csv2_add_state *state , uint32_t ip , int actually_make_record ) 
{ js_string *name ;
  js_string *rddata ;
  int c ;
  int32_t q ;
  int tmp ;
  int32_t x ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 554
  name = js_create(20U + (state->zone)->unit_count, 1U);
#line 554
  if ((unsigned long )name == (unsigned long )((js_string *)0)) {
#line 555
    return ((js_string *)0);
  }
#line 557
  tmp = js_qstr2js(name, (char *)"Zsynth-ip-");
#line 557
  if (tmp == 0) {
#line 558
    js_destroy(name);
#line 559
    return ((js_string *)0);
  }
#line 561
  q = (int32_t )ip;
#line 562
  c = 0;
#line 562
  while (c < 8) {
#line 564
    x = q;
#line 565
    x >>= 28;
#line 566
    x &= 15;
#line 567
    if (x < 10) {
#line 568
      tmp___0 = js_addbyte(name, (unsigned char )(48 + x));
#line 568
      if (tmp___0 == -1) {
#line 569
        js_destroy(name);
#line 570
        return ((js_string *)0);
      }
    } else {
#line 573
      tmp___1 = js_addbyte(name, (unsigned char )(97 + (x - 10)));
#line 573
      if (tmp___1 == -1) {
#line 574
        js_destroy(name);
#line 575
        return ((js_string *)0);
      }
    }
#line 578
    q <<= 4;
#line 562
    c ++;
  }
#line 580
  tmp___2 = js_qappend((char *)".", name);
#line 580
  if (tmp___2 == -1) {
#line 581
    js_destroy(name);
#line 582
    return ((js_string *)0);
  }
#line 584
  tmp___3 = js_append(state->zone, name);
#line 584
  if (tmp___3 == -1) {
#line 585
    js_destroy(name);
#line 586
    return ((js_string *)0);
  }
#line 588
  tmp___4 = hname_2rfc1035(name);
#line 588
  if (tmp___4 == -1) {
#line 589
    js_destroy(name);
#line 590
    return ((js_string *)0);
  }
#line 595
  if (actually_make_record != 1) {
#line 596
    return (name);
  }
#line 602
  rddata = js_create(5U, 1U);
#line 602
  if ((unsigned long )rddata == (unsigned long )((js_string *)0)) {
#line 603
    js_destroy(name);
#line 604
    return ((js_string *)0);
  }
#line 606
  c = 3;
#line 606
  while (c >= 0) {
#line 607
    *(rddata->string + c) = (unsigned char )(ip & 255U);
#line 608
    ip >>= 8;
#line 606
    c --;
  }
#line 610
  rddata->unit_count = 4U;
#line 611
  tmp___5 = csv2_add_rr_w(state, name, 1, 86400, rddata);
#line 611
  if (tmp___5 == -1) {
#line 612
    js_destroy(name);
#line 613
    js_destroy(rddata);
#line 614
    return ((js_string *)0);
  }
#line 616
  js_destroy(rddata);
#line 618
  return (name);
}
}
#line 623 "Csv2_database.c"
int csv2_make_synth_ns(csv2_add_state *state , uint32_t ip ) 
{ js_string *query ;
  js_string *data ;

  {
#line 631
  query = csv2_synth_query(state);
#line 631
  if ((unsigned long )query == (unsigned long )((js_string *)0)) {
#line 632
    return (-1);
  }
#line 636
  data = csv2_synth_ip(state, ip, 0);
#line 636
  if ((unsigned long )data == (unsigned long )((js_string *)0)) {
#line 637
    js_destroy(query);
#line 638
    return (-1);
  }
#line 642
  csv2_add_rr_w(state, query, 2, 86400, data);
#line 643
  js_destroy(query);
#line 644
  js_destroy(data);
#line 645
  return (1);
}
}
#line 651 "Csv2_database.c"
int csv2_is_private_ip(uint32_t ip ) 
{ int tmp ;

  {
#line 652
  if ((ip & 4278190080U) == 2130706432U) {
#line 652
    tmp = 1;
  } else
#line 652
  if ((ip & 4278190080U) == 167772160U) {
#line 652
    tmp = 1;
  } else
#line 652
  if ((ip & 4293918720U) == 2886729728U) {
#line 652
    tmp = 1;
  } else
#line 652
  if ((ip & 4294901760U) == 3232235520U) {
#line 652
    tmp = 1;
  } else {
#line 652
    tmp = 0;
  }
#line 652
  return (tmp);
}
}
#line 661 "Csv2_database.c"
int csv2_is_localhost_ip(uint32_t ip ) 
{ 

  {
#line 662
  return ((ip & 4278190080U) == 2130706432U);
}
}
#line 667 "Csv2_database.c"
int csv2_synthesize_ns(csv2_add_state *state ) 
{ ipv4pair *iplist ;
  int c ;
  int public_ips ;
  int non_localhost_ips ;
  js_string *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 671
  public_ips = 0;
#line 672
  non_localhost_ips = 0;
#line 675
  iplist = get_synthip_list();
#line 680
  c = 0;
#line 680
  while (c < 500) {
#line 681
    if ((iplist + c)->ip == 4294967295U) {
#line 682
      break;
    }
#line 684
    if ((iplist + c)->ip == 0U) {
#line 685
      printf("Warning: No NS records can be syntesized\n");
#line 686
      return (-1);
    }
#line 680
    c ++;
  }
#line 691
  c = 0;
#line 691
  while (c < 500) {
#line 692
    if ((iplist + c)->ip == 4294967295U) {
#line 693
      break;
    }
#line 695
    tmp___0 = csv2_is_private_ip((iplist + c)->ip);
#line 695
    if (! tmp___0) {
#line 696
      public_ips = 1;
#line 697
      non_localhost_ips = 1;
    }
#line 691
    c ++;
  }
#line 702
  if (public_ips != 1) {
#line 703
    c = 0;
#line 703
    while (c < 500) {
#line 704
      if ((iplist + c)->ip == 4294967295U) {
#line 705
        break;
      }
#line 707
      tmp___1 = csv2_is_localhost_ip((iplist + c)->ip);
#line 707
      if (! tmp___1) {
#line 708
        non_localhost_ips = 1;
      }
#line 703
      c ++;
    }
  }
#line 714
  if (public_ips == 1) {
#line 716
    c = 0;
#line 716
    while (c < 500) {
#line 717
      if ((iplist + c)->ip == 4294967295U) {
#line 718
        break;
      }
#line 720
      tmp___2 = csv2_is_private_ip((iplist + c)->ip);
#line 720
      if (! tmp___2) {
#line 721
        csv2_make_synth_ns(state, (iplist + c)->ip);
      }
#line 716
      c ++;
    }
#line 725
    c = 0;
#line 725
    while (c < 500) {
#line 726
      if ((iplist + c)->ip == 4294967295U) {
#line 727
        break;
      }
#line 729
      tmp___3 = csv2_is_private_ip((iplist + c)->ip);
#line 729
      if (! tmp___3) {
#line 730
        tmp = csv2_synth_ip(state, (iplist + c)->ip, 1);
#line 731
        js_destroy(tmp);
      }
#line 725
      c ++;
    }
  } else
#line 735
  if (non_localhost_ips == 1) {
#line 737
    c = 0;
#line 737
    while (c < 500) {
#line 738
      if ((iplist + c)->ip == 4294967295U) {
#line 739
        break;
      }
#line 741
      tmp___4 = csv2_is_localhost_ip((iplist + c)->ip);
#line 741
      if (! tmp___4) {
#line 742
        csv2_make_synth_ns(state, (iplist + c)->ip);
      }
#line 737
      c ++;
    }
#line 746
    c = 0;
#line 746
    while (c < 500) {
#line 747
      if ((iplist + c)->ip == 4294967295U) {
#line 748
        break;
      }
#line 750
      tmp___5 = csv2_is_localhost_ip((iplist + c)->ip);
#line 750
      if (! tmp___5) {
#line 751
        tmp = csv2_synth_ip(state, (iplist + c)->ip, 1);
#line 752
        js_destroy(tmp);
      }
#line 746
      c ++;
    }
  } else {
#line 758
    c = 0;
#line 758
    while (c < 500) {
#line 759
      if ((iplist + c)->ip == 4294967295U) {
#line 760
        break;
      }
#line 762
      csv2_make_synth_ns(state, (iplist + c)->ip);
#line 758
      c ++;
    }
#line 765
    c = 0;
#line 765
    while (c < 500) {
#line 766
      if ((iplist + c)->ip == 4294967295U) {
#line 767
        break;
      }
#line 769
      tmp = csv2_synth_ip(state, (iplist + c)->ip, 1);
#line 770
      js_destroy(tmp);
#line 765
      c ++;
    }
  }
#line 774
  return (1);
}
}
#line 779 "Csv2_database.c"
csv2_rr *copy_csv2_rr(csv2_rr *source ) 
{ csv2_rr *new ;
  js_string *q ;
  js_string *d ;
  void *tmp ;

  {
#line 783
  q = csv2_copy_js(source->query);
#line 783
  if ((unsigned long )q == (unsigned long )((js_string *)0)) {
#line 784
    return ((csv2_rr *)0);
  }
#line 786
  d = csv2_copy_js(source->data);
#line 786
  if ((unsigned long )d == (unsigned long )((js_string *)0)) {
#line 787
    js_destroy(q);
#line 788
    return ((csv2_rr *)0);
  }
#line 792
  tmp = js_alloc((int )sizeof(csv2_rr ), 1);
#line 792
  new = (csv2_rr *)tmp;
#line 792
  if ((unsigned long )new == (unsigned long )((csv2_rr *)0)) {
#line 793
    js_destroy(q);
#line 794
    js_destroy(d);
#line 795
    return ((csv2_rr *)0);
  }
#line 797
  new->query = q;
#line 798
  new->data = d;
#line 799
  new->rtype = source->rtype;
#line 800
  new->ttl = source->ttl;
#line 801
  new->next = (struct csv2_rr *)0;
#line 803
  return (new);
}
}
#line 809 "Csv2_database.c"
int csv2_push_buffer(csv2_add_state *state , js_string *query , int rtype , int32_t ttl ,
                     js_string *data ) 
{ js_string *q ;
  js_string *d ;
  csv2_rr *new ;
  csv2_rr *point ;
  int x ;
  void *tmp ;

  {
#line 816
  q = csv2_copy_js(query);
#line 816
  if ((unsigned long )q == (unsigned long )((js_string *)0)) {
#line 817
    return (-1);
  }
#line 819
  d = csv2_copy_js(data);
#line 819
  if ((unsigned long )d == (unsigned long )((js_string *)0)) {
#line 820
    js_destroy(q);
#line 821
    return (-1);
  }
#line 825
  tmp = js_alloc((int )sizeof(csv2_rr ), 1);
#line 825
  new = (csv2_rr *)tmp;
#line 825
  if ((unsigned long )new == (unsigned long )((csv2_rr *)0)) {
#line 826
    js_destroy(q);
#line 827
    js_destroy(d);
#line 828
    return (-1);
  }
#line 830
  new->query = q;
#line 831
  new->data = d;
#line 832
  new->rtype = rtype;
#line 833
  new->ttl = ttl;
#line 834
  new->next = (struct csv2_rr *)0;
#line 838
  if ((unsigned long )state->buffer == (unsigned long )((csv2_rr *)0)) {
#line 839
    state->buffer = new;
  }
#line 841
  point = state->buffer;
#line 845
  if ((unsigned long )state->buffer != (unsigned long )new) {
#line 846
    x = 0;
#line 846
    while (x < 30) {
#line 847
      if ((unsigned long )point->next == (unsigned long )((struct csv2_rr *)0)) {
#line 848
        break;
      }
#line 850
      point = point->next;
#line 846
      x ++;
    }
  }
#line 855
  if ((unsigned long )state->buffer != (unsigned long )new) {
#line 855
    if ((unsigned long )point->next != (unsigned long )((struct csv2_rr *)0)) {
#line 856
      js_destroy(q);
#line 857
      js_destroy(d);
#line 858
      js_dealloc((void *)new);
#line 859
      return (-1);
    }
  }
#line 862
  if ((unsigned long )state->buffer != (unsigned long )new) {
#line 863
    point->next = new;
  }
#line 865
  return (1);
}
}
#line 873 "Csv2_database.c"
int csv2_set_soa(csv2_add_state *state , js_string *query , js_string *data , int32_t ttl ) 
{ int tmp ;

  {
#line 876
  tmp = csv2_push_buffer(state, query, 6, ttl, data);
#line 876
  return (tmp);
}
}
#line 882 "Csv2_database.c"
int csv2_is_zonetop(csv2_add_state *state , js_string *query ) 
{ js_string *q ;
  int tmp ;

  {
#line 885
  q = csv2_zone_to_udpzone(state->zone);
#line 885
  if ((unsigned long )q == (unsigned long )((js_string *)0)) {
#line 886
    return (0);
  }
#line 888
  tmp = js_issame(q, query);
#line 888
  if (tmp == 1) {
#line 889
    js_destroy(q);
#line 890
    return (1);
  }
#line 892
  js_destroy(q);
#line 893
  return (0);
}
}
#line 898 "Csv2_database.c"
int csv2_pop_buffer(csv2_add_state *state ) 
{ csv2_rr *save ;
  int ret ;

  {
#line 901
  if ((unsigned long )state->buffer == (unsigned long )((csv2_rr *)0)) {
#line 902
    return (0);
  }
#line 905
  save = (state->buffer)->next;
#line 909
  if (state->add_method != 2) {
#line 910
    ret = csv2_add_rr_w(state, (state->buffer)->query, (state->buffer)->rtype, (state->buffer)->ttl,
                        (state->buffer)->data);
  } else {
#line 914
    ret = 1;
  }
#line 916
  if (ret != -1) {
#line 917
    js_destroy((state->buffer)->query);
#line 919
    js_destroy((state->buffer)->data);
#line 921
    js_dealloc((void *)state->buffer);
#line 922
    state->buffer = save;
  }
#line 924
  return (ret);
}
}
#line 928 "Csv2_database.c"
int csv2_add_soa(csv2_add_state *state ) 
{ int tmp ;

  {
#line 929
  if (state->in_ns != 1) {
#line 930
    return (-1);
  }
#line 932
  if ((unsigned long )state->buffer == (unsigned long )((csv2_rr *)0)) {
#line 933
    return (-1);
  } else
#line 932
  if ((state->buffer)->rtype != 6) {
#line 933
    return (-1);
  }
#line 935
  state->in_ns = 0;
#line 936
  tmp = csv2_pop_buffer(state);
#line 936
  return (tmp);
}
}
#line 941 "Csv2_database.c"
js_string *csv2_copy_js(js_string *s ) 
{ js_string *c ;
  int tmp ;

  {
#line 943
  if (s->unit_size != 1U) {
#line 944
    return ((js_string *)0);
  }
#line 946
  c = js_create(s->unit_count + 1U, 1U);
#line 946
  if ((unsigned long )c == (unsigned long )((js_string *)0)) {
#line 947
    return ((js_string *)0);
  }
#line 949
  tmp = js_copy(s, c);
#line 949
  if (tmp == -1) {
#line 950
    js_destroy(c);
#line 951
    return ((js_string *)0);
  }
#line 953
  return (c);
}
}
#line 959 "Csv2_database.c"
int csv2_add_rr(csv2_add_state *state , js_string *query , int rtype , int32_t ttl ,
                js_string *data ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 963
  (state->rrnum) ++;
#line 964
  if (state->rrnum == 1) {
#line 964
    if (rtype != 6) {
#line 964
      if (state->add_method != 3) {
#line 966
        csv2_synthesize_soa(state);
      } else {
#line 964
        goto _L___2;
      }
    } else {
#line 964
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 968
  if (state->rrnum == 1) {
#line 968
    if (rtype != 6) {
#line 968
      if (state->add_method == 3) {
#line 970
        printf("Please put an SOA record in the default zone file\n");
#line 971
        return (-1);
      } else {
#line 968
        goto _L___0;
      }
    } else {
#line 968
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 973
  if (state->rrnum == 1) {
#line 974
    tmp = csv2_set_soa(state, query, data, ttl);
#line 974
    return (tmp);
  } else
#line 976
  if (rtype == 6) {
#line 979
    printf("Warning: Only one SOA per zone file.\nThis SOA must be the first record in the zone.\nOther SOA records are ignored\n");
#line 982
    return (-1);
  }
#line 989
  if (state->zone_nses_added == 0) {
#line 989
    if (state->in_ns == 1) {
#line 989
      if (rtype == 2) {
#line 989
        tmp___0 = csv2_is_zonetop(state, query);
#line 989
        if (tmp___0) {
#line 991
          state->zone_nses_added = 1;
        }
      }
    }
  }
#line 996
  if (state->in_ns == 0) {
#line 996
    if (rtype == 2) {
#line 996
      tmp___1 = csv2_is_zonetop(state, query);
#line 996
      if (tmp___1) {
#line 998
        printf("Warning: Authoritative NSes must be immediately after SOA\nOr the first records in the zone\nOtherwise, the record is ignored\n");
#line 1002
        return (-1);
      } else {
#line 996
        goto _L___6;
      }
    } else {
#line 996
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
#line 1005
  if (state->in_ns == 0) {
#line 1005
    if (rtype == 2) {
#line 1005
      if (state->add_method == 3) {
#line 1006
        printf("Warning: Delegation NS records are not permitted in\nthe default zonefile.  This record is ignored\n");
#line 1008
        return (-1);
      } else {
#line 1005
        goto _L___4;
      }
    } else {
#line 1005
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 1011
  if (rtype == 5) {
#line 1011
    if (state->add_method == 3) {
#line 1012
      printf("Warning: CNAME records are not permitted in the\ndefault zonefile.  This record is ignored\n");
#line 1014
      return (-1);
    }
  }
#line 1022
  if (state->in_ns == 1) {
#line 1022
    if (rtype != 2) {
#line 1022
      goto _L___7;
    } else {
#line 1022
      tmp___2 = csv2_is_zonetop(state, query);
#line 1022
      if (! tmp___2) {
        _L___7: /* CIL Label */ 
#line 1027
        if (state->zone_nses_added == 0) {
#line 1027
          if (state->add_method != 3) {
#line 1029
            csv2_synthesize_ns(state);
          }
        }
#line 1031
        if (state->zone_nses_added == 0) {
#line 1031
          if (state->add_method == 3) {
#line 1033
            printf("Please include NS records in a default zone file\n");
#line 1035
            return (-1);
          }
        }
#line 1037
        if (state->add_method != 2) {
#line 1038
          csv2_add_soa(state);
        }
#line 1040
        state->in_ns = 0;
      }
    }
  }
#line 1043
  tmp___3 = csv2_add_rr_w(state, query, rtype, ttl, data);
#line 1043
  return (tmp___3);
}
}
#line 1052 "Csv2_database.c"
js_string *csv2_make_ptr_query(js_string *binary_ip ) 
{ js_string *ptr_label ;
  int len ;
  int counter ;
  int tmp ;
  char a ;
  int b ;
  int c ;
  int d ;

  {
#line 1054
  len = 0;
#line 1055
  counter = 0;
#line 1058
  tmp = js_length(binary_ip);
#line 1058
  if (tmp != 4) {
#line 1059
    return ((js_string *)0);
  }
#line 1061
  ptr_label = js_create(31U, 1U);
#line 1062
  if ((unsigned long )ptr_label == (unsigned long )((js_string *)0)) {
#line 1063
    return ((js_string *)0);
  }
#line 1068
  counter = 3;
#line 1068
  while (counter >= 0) {
#line 1071
    c = 1;
#line 1073
    a = (char )*(binary_ip->string + counter);
#line 1077
    b = (int )a;
#line 1078
    b &= 255;
#line 1080
    if (b < 0) {
#line 1081
      b += 128;
    }
#line 1083
    if (b > 99) {
#line 1084
      c ++;
    }
#line 1086
    if (b > 9) {
#line 1087
      c ++;
    }
#line 1089
    if (len <= 30) {
#line 1090
      *(ptr_label->string + len) = (unsigned char )c;
    }
#line 1091
    d = c;
#line 1092
    while (c > 0) {
#line 1093
      if (len + c <= 30) {
#line 1094
        *((ptr_label->string + len) + c) = (unsigned char )(48 + b % 10);
      }
#line 1095
      b /= 10;
#line 1096
      c --;
    }
#line 1098
    len ++;
#line 1099
    len += d;
#line 1068
    counter --;
  }
#line 1103
  if ((unsigned int )len < ptr_label->max_count) {
#line 1104
    ptr_label->unit_count = (unsigned int )len;
  }
#line 1107
  js_qappend((char *)".in-addr.arpa.", ptr_label);
#line 1108
  if (len <= 30) {
#line 1109
    *(ptr_label->string + len) = (unsigned char)7;
  }
#line 1111
  len += 8;
#line 1112
  if (len <= 30) {
#line 1113
    *(ptr_label->string + len) = (unsigned char)4;
  }
#line 1115
  len += 5;
#line 1116
  if (len <= 30) {
#line 1117
    *(ptr_label->string + len) = (unsigned char)0;
  }
#line 1120
  return (ptr_label);
}
}
#line 1129 "Csv2_database.c"
js_string *csv2_make_ptr6_query(js_string *binary_ip ) 
{ js_string *ptr_label ;
  int len ;
  int counter ;
  int tmp ;
  char a ;
  int b ;

  {
#line 1131
  len = 0;
#line 1132
  counter = 0;
#line 1135
  tmp = js_length(binary_ip);
#line 1135
  if (tmp != 16) {
#line 1136
    return ((js_string *)0);
  }
#line 1138
  ptr_label = js_create(256U, 1U);
#line 1139
  if ((unsigned long )ptr_label == (unsigned long )((js_string *)0)) {
#line 1140
    return ((js_string *)0);
  }
#line 1143
  counter = 15;
#line 1143
  while (counter >= 0) {
#line 1147
    a = (char )*(binary_ip->string + counter);
#line 1150
    *(ptr_label->string + len) = (unsigned char)1;
#line 1151
    len ++;
#line 1152
    b = (int )a & 15;
#line 1153
    if (b > 9) {
#line 1153
      b += 87;
    } else {
#line 1154
      b += 48;
    }
#line 1155
    *(ptr_label->string + len) = (unsigned char )b;
#line 1156
    len ++;
#line 1159
    *(ptr_label->string + len) = (unsigned char)1;
#line 1160
    len ++;
#line 1161
    b = ((int )a >> 4) & 15;
#line 1162
    if (b > 9) {
#line 1162
      b += 87;
    } else {
#line 1163
      b += 48;
    }
#line 1164
    *(ptr_label->string + len) = (unsigned char )b;
#line 1165
    len ++;
#line 1143
    counter --;
  }
#line 1168
  if (len <= 250) {
#line 1169
    *(ptr_label->string + len) = (unsigned char)3;
#line 1170
    *((ptr_label->string + len) + 1) = (unsigned char )'i';
#line 1171
    *((ptr_label->string + len) + 2) = (unsigned char )'p';
#line 1172
    *((ptr_label->string + len) + 3) = (unsigned char )'6';
#line 1173
    len += 4;
  }
#line 1176
  if (len <= 250) {
#line 1177
    *(ptr_label->string + len) = (unsigned char)4;
#line 1178
    *((ptr_label->string + len) + 1) = (unsigned char )'a';
#line 1179
    *((ptr_label->string + len) + 2) = (unsigned char )'r';
#line 1180
    *((ptr_label->string + len) + 3) = (unsigned char )'p';
#line 1181
    *((ptr_label->string + len) + 4) = (unsigned char )'a';
#line 1182
    len += 5;
  }
#line 1184
  if (len <= 255) {
#line 1185
    *(ptr_label->string + len) = (unsigned char)0;
#line 1186
    len ++;
  }
#line 1188
  ptr_label->unit_size = 1U;
#line 1189
  ptr_label->unit_count = (unsigned int )len;
#line 1190
  return (ptr_label);
}
}
#line 1196 "Csv2_database.c"
int csv2_add_rr_w(csv2_add_state *state , js_string *query , int rtype , int32_t ttl ,
                  js_string *data ) 
{ js_string *cquery ;
  int ret ;
  int counter ;
  int tmp ;
  js_string *pq ;
  js_string *pq___0 ;

  {
#line 1199
  ret = -1;
#line 1199
  counter = -1;
#line 1200
  if ((unsigned long )state == (unsigned long )((csv2_add_state *)0)) {
#line 1201
    return (-1);
  }
#line 1205
  cquery = js_create(query->unit_count + 1U, 1U);
#line 1205
  if ((unsigned long )cquery == (unsigned long )((js_string *)0)) {
#line 1206
    return (-1);
  }
#line 1208
  tmp = js_copy(query, cquery);
#line 1208
  if (tmp == -1) {
#line 1209
    js_destroy(cquery);
#line 1210
    return (-1);
  }
#line 1214
  counter = 0;
#line 1215
  if (cquery->unit_count < 0U) {
#line 1216
    js_destroy(cquery);
#line 1217
    return (-1);
  }
#line 1221
  while ((unsigned int )counter < cquery->unit_count) {
#line 1222
    if ((int )*(cquery->string + counter) >= 65) {
#line 1222
      if ((int )*(cquery->string + counter) <= 90) {
#line 1224
        *(cquery->string + counter) = (unsigned char )((int )*(cquery->string + counter) + 32);
      }
    }
#line 1226
    counter ++;
  }
#line 1232
  if (rtype == 65765) {
#line 1232
    if (state->add_method != 3) {
#line 1234
      rtype = 1;
#line 1235
      pq = csv2_make_ptr_query(data);
#line 1238
      csv2_add_rr_w(state, pq, 12, ttl, cquery);
#line 1239
      js_destroy(pq);
    } else {
#line 1232
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1240
  if (rtype == 65765) {
#line 1240
    if (state->add_method == 3) {
#line 1241
      printf("Warning: FQDN4 records are not permitted in the\ndefault zonefile.  This record is ignored.\n");
#line 1243
      js_destroy(cquery);
#line 1244
      return (-1);
    }
  }
#line 1247
  if (rtype == 65766) {
#line 1247
    if (state->add_method != 3) {
#line 1249
      rtype = 28;
#line 1250
      pq___0 = csv2_make_ptr6_query(data);
#line 1253
      csv2_add_rr_w(state, pq___0, 12, ttl, cquery);
#line 1254
      js_destroy(pq___0);
    } else {
#line 1247
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1255
  if (rtype == 65766) {
#line 1255
    if (state->add_method == 3) {
#line 1256
      printf("Warning: FQDN6 records are not permitted in the\ndefault zonefile.  This record is ignored.\n");
#line 1258
      js_destroy(cquery);
#line 1259
      return (-1);
    }
  }
#line 1262
  ret = -1;
#line 1263
  switch (state->add_method) {
  case 1: 
#line 1265
  ret = csv2_add_rr_bighash(state, cquery, rtype, ttl, data, 0);
#line 1267
  break;
  case 2: 
#line 1269
  ret = csv2_add_rr_zoneserver(state, cquery, rtype, ttl, data);
#line 1271
  break;
  case 3: 
#line 1276
  ret = csv2_add_rr_bighash(state, cquery, rtype, ttl, data, 1);
#line 1278
  break;
  default: 
#line 1280
  ret = csv2_add_rr_debug(state, cquery, rtype, ttl, data);
  }
#line 1283
  js_destroy(cquery);
#line 1284
  return (ret);
}
}
#line 1 "Csv2_rr_txt.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-4eNzx0Gr.i","")
#line 70 "Csv2_rr_txt.c"
int csv2_is_txtchar(int32_t in ) 
{ int tmp ;

  {
#line 71
  if (in >= 48) {
#line 71
    if (in <= 57) {
#line 71
      tmp = 1;
    } else {
#line 71
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 71
  if (in >= 97) {
#line 71
    if (in <= 122) {
#line 71
      tmp = 1;
    } else {
#line 71
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 71
  if (in >= 65) {
#line 71
    if (in <= 90) {
#line 71
      tmp = 1;
    } else {
#line 71
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 71
  if (in == 45) {
#line 71
    tmp = 1;
  } else
#line 71
  if (in == 95) {
#line 71
    tmp = 1;
  } else
#line 71
  if (in == 43) {
#line 71
    tmp = 1;
  } else
#line 71
  if (in == 37) {
#line 71
    tmp = 1;
  } else
#line 71
  if (in == 33) {
#line 71
    tmp = 1;
  } else
#line 71
  if (in == 94) {
#line 71
    tmp = 1;
  } else
#line 71
  if (in == 61) {
#line 71
    tmp = 1;
  } else
#line 71
  if (in == 59) {
#line 71
    tmp = 1;
  } else
#line 71
  if (in == 92) {
#line 71
    tmp = 1;
  } else
#line 71
  if (in == 39) {
#line 71
    tmp = 1;
  } else {
#line 71
    tmp = 0;
  }
#line 71
  return (tmp);
}
}
#line 87 "Csv2_rr_txt.c"
int csv2_is_txt_bchar(int32_t in ) 
{ int tmp ;

  {
#line 88
  if (in >= 48) {
#line 88
    if (in <= 57) {
#line 88
      tmp = 1;
    } else {
#line 88
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 88
  if (in >= 97) {
#line 88
    if (in <= 122) {
#line 88
      tmp = 1;
    } else {
#line 88
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 88
  if (in >= 65) {
#line 88
    if (in <= 90) {
#line 88
      tmp = 1;
    } else {
#line 88
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 88
  if (in == 45) {
#line 88
    tmp = 1;
  } else
#line 88
  if (in == 95) {
#line 88
    tmp = 1;
  } else
#line 88
  if (in == 43) {
#line 88
    tmp = 1;
  } else
#line 88
  if (in == 37) {
#line 88
    tmp = 1;
  } else
#line 88
  if (in == 33) {
#line 88
    tmp = 1;
  } else
#line 88
  if (in == 94) {
#line 88
    tmp = 1;
  } else
#line 88
  if (in == 61) {
#line 88
    tmp = 1;
  } else {
#line 88
    tmp = 0;
  }
#line 88
  return (tmp);
}
}
#line 101 "Csv2_rr_txt.c"
int csv2_isnt_quote(int32_t in ) 
{ 

  {
#line 102
  return (in != 39);
}
}
#line 106 "Csv2_rr_txt.c"
int csv2_is_quote(int32_t in ) 
{ 

  {
#line 107
  return (in == 39);
}
}
#line 111 "Csv2_rr_txt.c"
int csv2_is_pipe(int32_t in ) 
{ 

  {
#line 112
  return (in == 124);
}
}
#line 116 "Csv2_rr_txt.c"
int csv2_is_0123(int32_t in ) 
{ int tmp ;

  {
#line 117
  if (in >= 48) {
#line 117
    if (in <= 51) {
#line 117
      tmp = 1;
    } else {
#line 117
      tmp = 0;
    }
  } else {
#line 117
    tmp = 0;
  }
#line 117
  return (tmp);
}
}
#line 121 "Csv2_rr_txt.c"
int csv2_is_x(int32_t in ) 
{ 

  {
#line 122
  return (in == 120);
}
}
#line 126 "Csv2_rr_txt.c"
int csv2_is_hash(int32_t in ) 
{ 

  {
#line 127
  return (in == 35);
}
}
#line 131 "Csv2_rr_txt.c"
int csv2_is_octal(int32_t in ) 
{ int tmp ;

  {
#line 132
  if (in >= 48) {
#line 132
    if (in <= 55) {
#line 132
      tmp = 1;
    } else {
#line 132
      tmp = 0;
    }
  } else {
#line 132
    tmp = 0;
  }
#line 132
  return (tmp);
}
}
#line 136 "Csv2_rr_txt.c"
int csv2_is_bslash(int32_t in ) 
{ 

  {
#line 137
  return (in == 92);
}
}
#line 141 "Csv2_rr_txt.c"
int csv2_is_semicolon(int32_t in ) 
{ 

  {
#line 142
  return (in == 59);
}
}
#line 148 "Csv2_rr_txt.c"
js_string *csv2_get_txt(csv2_read *stream , int numchunks ) 
{ js_string *tmp ;

  {
#line 149
  tmp = csv2_get_string(stream, numchunks, 0);
#line 149
  return (tmp);
}
}
#line 155 "Csv2_rr_txt.c"
js_string *csv2_get_raw(csv2_read *stream ) 
{ js_string *tmp ;

  {
#line 156
  tmp = csv2_get_string(stream, -1, 0);
#line 156
  return (tmp);
}
}
#line 166 "Csv2_rr_txt.c"
int csv2_txt_append(js_string *out , int32_t chr , int *len ) 
{ int tmp ;

  {
#line 167
  tmp = csv2_append_utf8(out, chr);
#line 167
  if (tmp == -1) {
#line 168
    js_destroy(out);
#line 169
    return (0);
  }
#line 171
  if (chr < 128) {
#line 173
    (*len) ++;
  } else
#line 174
  if (chr < 2048) {
#line 175
    *len += 2;
  } else
#line 176
  if (chr < 65536) {
#line 177
    *len += 3;
  } else
#line 178
  if (chr < 2097152) {
#line 179
    *len += 4;
  } else {
#line 180
    printf("Whoo!  Unicode is huge!\n");
#line 180
    exit(1);
  }
#line 181
  return (1);
}
}
#line 187 "Csv2_rr_txt.c"
js_string *csv2_finalize_txt(csv2_read *stream , int numchunks , int chunkcount ,
                             int txt_len_place , int txt_len , js_string *out ) 
{ 

  {
#line 192
  if (numchunks != -1) {
#line 193
    if (txt_len_place < 0) {
#line 194
      js_destroy(out);
#line 195
      return ((js_string *)0);
    } else
#line 193
    if ((unsigned int )txt_len_place > out->max_count) {
#line 194
      js_destroy(out);
#line 195
      return ((js_string *)0);
    }
#line 197
    if (txt_len > 255) {
#line 198
      csv2_error(stream, (char *)"Single TXT chunk too long");
#line 199
      js_destroy(out);
#line 200
      return ((js_string *)0);
    }
#line 202
    *(out->string + txt_len_place) = (unsigned char )txt_len;
#line 203
    chunkcount ++;
  }
#line 206
  if (numchunks > 0) {
#line 206
    if (chunkcount != numchunks) {
#line 207
      csv2_error(stream, (char *)"Incorrect number of chunks for this RR");
#line 208
      js_destroy(out);
#line 209
      return ((js_string *)0);
    }
  }
#line 212
  return (out);
}
}
#line 221 "Csv2_rr_txt.c"
js_string *csv2_get_string(csv2_read *stream , int numchunks , int post_txt ) 
{ int state ;
  int out_num ;
  int txt_len_place ;
  int txt_len ;
  int chunkcount ;
  int x ;
  int32_t look ;
  js_string *out ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  js_string *tmp___10 ;
  int tmp___11 ;
  js_string *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  js_string *tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;

  {
#line 223
  out_num = 0;
#line 224
  txt_len_place = -1;
#line 226
  chunkcount = 0;
#line 231
  if ((int )stream->tilde_handling == 103) {
#line 232
    csv2_allow_tilde(stream);
  }
#line 235
  tmp = csv2_get_1st(stream, & csv2_is_txtchar, 0);
#line 235
  if (tmp != 1) {
#line 236
    return ((js_string *)0);
  }
#line 239
  look = csv2_justread(stream);
#line 240
  if (look >= 192) {
#line 240
    if (look < 254) {
#line 241
      look = csv2_get_utf8(stream);
    } else {
#line 240
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 243
  if (look >= 128) {
#line 244
    look = csv2_get_unicode(stream);
  }
#line 247
  if (look == -164) {
#line 248
    return ((js_string *)0);
  }
#line 252
  out = js_create(1513U, 1U);
#line 252
  if ((unsigned long )out == (unsigned long )((js_string *)0)) {
#line 253
    return ((js_string *)0);
  }
#line 256
  tmp___0 = js_set_encode(out, 2);
#line 256
  if (tmp___0 == -1) {
#line 257
    js_destroy(out);
#line 258
    return ((js_string *)0);
  }
#line 263
  if (numchunks != -1) {
#line 264
    txt_len_place = (int )out->unit_count;
#line 265
    txt_len = 0;
#line 266
    chunkcount = 0;
#line 267
    tmp___1 = csv2_append_utf8(out, 0);
#line 267
    if (tmp___1 == -1) {
#line 268
      js_destroy(out);
#line 269
      return ((js_string *)0);
    }
  }
#line 275
  tmp___8 = csv2_is_txt_bchar(look);
#line 275
  if (tmp___8) {
#line 277
    tmp___2 = csv2_txt_append(out, look, & txt_len);
#line 277
    if (tmp___2 != 1) {
#line 278
      csv2_error(stream, (char *)"Error appending character");
#line 279
      return ((js_string *)0);
    }
#line 281
    state = 1;
  } else {
#line 285
    tmp___7 = csv2_is_bslash(look);
#line 285
    if (tmp___7) {
#line 286
      state = 3;
    } else {
#line 290
      tmp___6 = csv2_is_quote(look);
#line 290
      if (tmp___6) {
#line 291
        state = 2;
      } else {
#line 295
        tmp___5 = csv2_is_semicolon(look);
#line 295
        if (tmp___5) {
#line 295
          if (numchunks != -1) {
#line 296
            if (txt_len_place < 0) {
#line 297
              js_destroy(out);
#line 298
              return ((js_string *)0);
            } else
#line 296
            if ((unsigned int )txt_len_place > out->max_count) {
#line 297
              js_destroy(out);
#line 298
              return ((js_string *)0);
            }
#line 300
            if (txt_len > 255) {
#line 301
              csv2_error(stream, (char *)"Single TXT chunk too long");
#line 302
              js_destroy(out);
#line 303
              return ((js_string *)0);
            }
#line 305
            *(out->string + txt_len_place) = (unsigned char )txt_len;
#line 306
            txt_len_place = (int )out->unit_count;
#line 307
            txt_len = 0;
#line 308
            chunkcount ++;
#line 309
            tmp___3 = csv2_append_utf8(out, 0);
#line 309
            if (tmp___3 == -1) {
#line 310
              js_destroy(out);
#line 311
              return ((js_string *)0);
            }
#line 313
            state = 1;
          } else {
#line 295
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 314
          tmp___4 = csv2_is_semicolon(look);
#line 314
          if (tmp___4) {
#line 315
            csv2_error(stream, (char *)"No non-quoted ; in non-TXT records");
#line 316
            js_destroy(out);
#line 317
            return ((js_string *)0);
          } else {
#line 320
            csv2_error(stream, (char *)"Unexpected char at beginning of rdata");
#line 321
            js_destroy(out);
#line 322
            return ((js_string *)0);
          }
        }
      }
    }
  }
#line 325
  x = 0;
#line 325
  while (x < 10000) {
#line 326
    look = csv2_read_unicode(stream);
#line 329
    if (look == -2) {
#line 329
      if (state != 1) {
#line 329
        if (state != 10) {
#line 331
          csv2_error(stream, (char *)"Unterminated RR");
#line 332
          js_destroy(out);
#line 333
          return ((js_string *)0);
        }
      }
    }
#line 336
    if (state == 1) {
#line 338
      tmp___20 = csv2_is_txt_bchar(look);
#line 338
      if (tmp___20) {
#line 339
        tmp___9 = csv2_txt_append(out, look, & txt_len);
#line 339
        if (tmp___9 != 1) {
#line 340
          return ((js_string *)0);
        }
      } else {
#line 343
        tmp___17 = csv2_is_delimiter(look);
#line 343
        if (tmp___17) {
#line 343
          if ((int )stream->tilde_handling != 103) {
#line 351
            tmp___10 = csv2_finalize_txt(stream, numchunks, chunkcount, txt_len_place,
                                         txt_len, out);
#line 351
            return (tmp___10);
          } else {
#line 343
            goto _L___8;
          }
        } else
        _L___8: /* CIL Label */ 
#line 343
        if (look == 126) {
#line 343
          if ((int )stream->tilde_handling == 103) {
#line 343
            if (post_txt == 0) {
#line 351
              tmp___10 = csv2_finalize_txt(stream, numchunks, chunkcount, txt_len_place,
                                           txt_len, out);
#line 351
              return (tmp___10);
            } else {
#line 343
              goto _L___7;
            }
          } else {
#line 343
            goto _L___7;
          }
        } else {
          _L___7: /* CIL Label */ 
#line 343
          tmp___18 = csv2_is_delimiter(look);
#line 343
          if (tmp___18) {
#line 343
            if (numchunks == -1) {
#line 351
              tmp___10 = csv2_finalize_txt(stream, numchunks, chunkcount, txt_len_place,
                                           txt_len, out);
#line 351
              return (tmp___10);
            } else {
#line 343
              goto _L___5;
            }
          } else {
            _L___5: /* CIL Label */ 
#line 343
            tmp___19 = csv2_is_delimiter(look);
#line 343
            if (tmp___19) {
#line 343
              if (post_txt == 1) {
#line 351
                tmp___10 = csv2_finalize_txt(stream, numchunks, chunkcount, txt_len_place,
                                             txt_len, out);
#line 351
                return (tmp___10);
              } else {
#line 343
                goto _L___4;
              }
            } else
            _L___4: /* CIL Label */ 
#line 343
            if (look == -2) {
#line 351
              tmp___10 = csv2_finalize_txt(stream, numchunks, chunkcount, txt_len_place,
                                           txt_len, out);
#line 351
              return (tmp___10);
            } else {
#line 355
              tmp___16 = csv2_is_bslash(look);
#line 355
              if (tmp___16) {
#line 356
                state = 3;
              } else {
#line 359
                tmp___15 = csv2_is_quote(look);
#line 359
                if (tmp___15) {
#line 360
                  state = 2;
                } else
#line 363
                if (look == 59) {
#line 363
                  if (numchunks != -1) {
#line 364
                    if (txt_len_place < 0) {
#line 366
                      js_destroy(out);
#line 367
                      return ((js_string *)0);
                    } else
#line 364
                    if ((unsigned int )txt_len_place > out->max_count) {
#line 366
                      js_destroy(out);
#line 367
                      return ((js_string *)0);
                    }
#line 369
                    if (txt_len > 255) {
#line 370
                      csv2_error(stream, (char *)"Single TXT chunk too long");
#line 372
                      js_destroy(out);
#line 373
                      return ((js_string *)0);
                    }
#line 375
                    *(out->string + txt_len_place) = (unsigned char )txt_len;
#line 376
                    chunkcount ++;
#line 377
                    txt_len_place = (int )out->unit_count;
#line 378
                    txt_len = 0;
#line 379
                    tmp___11 = csv2_append_utf8(out, 0);
#line 379
                    if (tmp___11 == -1) {
#line 380
                      js_destroy(out);
#line 381
                      return ((js_string *)0);
                    }
#line 383
                    state = 1;
                  } else {
#line 363
                    goto _L___3;
                  }
                } else
                _L___3: /* CIL Label */ 
#line 385
                if ((int )stream->tilde_handling == 103) {
#line 385
                  tmp___14 = csv2_is_delimiter(look);
#line 385
                  if (tmp___14) {
#line 385
                    if (look != 124) {
#line 387
                      state = 10;
                    } else {
#line 385
                      goto _L___2;
                    }
                  } else {
#line 385
                    goto _L___2;
                  }
                } else {
                  _L___2: /* CIL Label */ 
#line 390
                  tmp___13 = csv2_is_hash(look);
#line 390
                  if (tmp___13) {
#line 391
                    process_comment(stream);
#line 392
                    if ((int )stream->tilde_handling != 103) {
#line 393
                      tmp___12 = csv2_finalize_txt(stream, numchunks, chunkcount,
                                                   txt_len_place, txt_len, out);
#line 393
                      return (tmp___12);
                    }
                  } else
#line 399
                  if (numchunks != -1) {
#line 400
                    csv2_error(stream, (char *)"Syntax error in TXT/SPF RR");
#line 402
                    js_destroy(out);
#line 403
                    return ((js_string *)0);
                  } else
#line 405
                  if (numchunks == -1) {
#line 406
                    csv2_error(stream, (char *)"Syntax error in RAW");
#line 408
                    js_destroy(out);
#line 409
                    return ((js_string *)0);
                  } else {
#line 412
                    csv2_error(stream, (char *)"Something weird in csv2_rr_txt");
#line 414
                    js_destroy(out);
#line 415
                    return ((js_string *)0);
                  }
                }
              }
            }
          }
        }
      }
    } else
#line 419
    if (state == 2) {
#line 422
      tmp___23 = csv2_is_quote(look);
#line 422
      if (tmp___23) {
#line 423
        state = 1;
      } else
#line 424
      if ((int )stream->tilde_handling == 103) {
#line 425
        if (look == 35) {
#line 426
          csv2_error(stream, (char *)"The # character is not allowed in TXT records\nPlease use the \'\\x23\' escape sequence instead.");
#line 429
          return ((js_string *)0);
        } else
#line 430
        if (look == 124) {
#line 431
          csv2_error(stream, (char *)"The | character is not allowed in TXT records\nPlease use the \'\\x7c\' escape sequence instead.");
#line 434
          return ((js_string *)0);
        } else
#line 435
        if (look == 126) {
#line 436
          csv2_error(stream, (char *)"The ~ character is not allowed in TXT records\nPlease use the \'\\x7e\' escape sequence instead.");
#line 439
          return ((js_string *)0);
        } else
#line 440
        if (look == 127) {
#line 441
          csv2_error(stream, (char *)"The DEL character is not allowed in TXT records\nPlease use the \'\\x7f\' escape sequence instead.");
        } else
#line 444
        if (look < 32) {
#line 445
          csv2_error(stream, (char *)"Control characters (including newlines) are not allowed in TXT records\nPlease use the appropriate escape sequence instead.");
#line 448
          return ((js_string *)0);
        } else {
#line 449
          tmp___21 = csv2_txt_append(out, look, & txt_len);
#line 449
          if (tmp___21 != 1) {
#line 451
            return ((js_string *)0);
          }
        }
      } else {
#line 454
        tmp___22 = csv2_txt_append(out, look, & txt_len);
#line 454
        if (tmp___22 != 1) {
#line 455
          return ((js_string *)0);
        }
      }
    } else
#line 459
    if (state == 3) {
#line 461
      tmp___30 = csv2_is_quote(look);
#line 461
      if (tmp___30) {
#line 462
        tmp___24 = csv2_txt_append(out, look, & txt_len);
#line 462
        if (tmp___24 != 1) {
#line 463
          return ((js_string *)0);
        }
#line 465
        state = 1;
      } else {
#line 468
        tmp___29 = csv2_is_pipe(look);
#line 468
        if (tmp___29) {
#line 469
          csv2_error(stream, (char *)"Please don\'t backslash | characters");
#line 471
          js_destroy(out);
#line 472
          return ((js_string *)0);
        } else {
#line 475
          tmp___28 = csv2_is_hash(look);
#line 475
          if (tmp___28) {
#line 479
            process_comment(stream);
#line 480
            state = 4;
          } else {
#line 483
            tmp___27 = csv2_is_delimiter(look);
#line 483
            if (tmp___27) {
#line 484
              state = 4;
            } else {
#line 487
              tmp___26 = csv2_is_0123(look);
#line 487
              if (tmp___26) {
#line 488
                state = 5;
#line 489
                out_num = look - 48;
              } else {
#line 492
                tmp___25 = csv2_is_x(look);
#line 492
                if (tmp___25) {
#line 493
                  state = 7;
#line 494
                  out_num = 0;
                } else {
#line 497
                  csv2_error(stream, (char *)"Invalid character after backslash");
#line 499
                  js_destroy(out);
#line 500
                  return ((js_string *)0);
                }
              }
            }
          }
        }
      }
    } else
#line 503
    if (state == 4) {
#line 505
      tmp___37 = csv2_is_txt_bchar(look);
#line 505
      if (tmp___37) {
#line 506
        tmp___31 = csv2_txt_append(out, look, & txt_len);
#line 506
        if (tmp___31 != 1) {
#line 507
          js_destroy(out);
#line 508
          return ((js_string *)0);
        }
#line 510
        state = 1;
      } else {
#line 513
        tmp___36 = csv2_is_quote(look);
#line 513
        if (tmp___36) {
#line 514
          state = 2;
        } else {
#line 517
          tmp___35 = csv2_is_pipe(look);
#line 517
          if (tmp___35) {
#line 518
            csv2_error(stream, (char *)"Please don\'t have a pipe be after a backslash and whitespace");
#line 520
            js_destroy(out);
#line 521
            return ((js_string *)0);
          } else {
#line 524
            tmp___34 = csv2_is_hash(look);
#line 524
            if (tmp___34) {
#line 525
              process_comment(stream);
            } else {
#line 536
              tmp___33 = csv2_is_delimiter(look);
#line 536
              if (tmp___33) {
#line 537
                state = 4;
              } else {
#line 539
                tmp___32 = csv2_is_bslash(look);
#line 539
                if (tmp___32) {
#line 540
                  state = 3;
                } else {
#line 543
                  csv2_error(stream, (char *)"Invalid character after backslash and white space");
#line 545
                  js_destroy(out);
#line 546
                  return ((js_string *)0);
                }
              }
            }
          }
        }
      }
    } else
#line 549
    if (state == 5) {
#line 550
      tmp___38 = csv2_is_octal(look);
#line 550
      if (tmp___38) {
#line 551
        out_num *= 8;
#line 552
        out_num += look - 48;
#line 553
        state = 6;
      } else {
#line 556
        csv2_error(stream, (char *)"Invalid octal digit");
#line 557
        js_destroy(out);
#line 558
        return ((js_string *)0);
      }
    } else
#line 561
    if (state == 6) {
#line 562
      tmp___40 = csv2_is_octal(look);
#line 562
      if (tmp___40) {
#line 563
        out_num *= 8;
#line 564
        out_num += look - 48;
#line 565
        tmp___39 = js_addbyte(out, (unsigned char )out_num);
#line 565
        if (tmp___39 == -1) {
#line 566
          js_destroy(out);
#line 567
          return ((js_string *)0);
        }
#line 569
        txt_len ++;
#line 570
        out_num = 0;
#line 571
        state = 1;
      } else {
#line 574
        csv2_error(stream, (char *)"Invalid octal digit");
#line 575
        js_destroy(out);
#line 576
        return ((js_string *)0);
      }
    } else
#line 579
    if (state == 7) {
#line 580
      tmp___44 = csv2_is_hex(look);
#line 580
      if (tmp___44) {
#line 581
        out_num = 0;
#line 582
        tmp___43 = csv2_is_number(look);
#line 582
        if (tmp___43) {
#line 583
          out_num += look - 48;
        } else {
#line 585
          tmp___42 = csv2_is_upper(look);
#line 585
          if (tmp___42) {
#line 586
            out_num += (look + 10) - 65;
          } else {
#line 588
            tmp___41 = csv2_is_lower(look);
#line 588
            if (tmp___41) {
#line 589
              out_num += (look + 10) - 97;
            }
          }
        }
#line 591
        state = 8;
      } else {
#line 594
        csv2_error(stream, (char *)"Invalid hex digit");
#line 595
        js_destroy(out);
#line 596
        return ((js_string *)0);
      }
    } else
#line 599
    if (state == 8) {
#line 600
      tmp___49 = csv2_is_hex(look);
#line 600
      if (tmp___49) {
#line 601
        out_num *= 16;
#line 602
        tmp___47 = csv2_is_number(look);
#line 602
        if (tmp___47) {
#line 603
          out_num += look - 48;
        } else {
#line 605
          tmp___46 = csv2_is_upper(look);
#line 605
          if (tmp___46) {
#line 606
            out_num += (look + 10) - 65;
          } else {
#line 608
            tmp___45 = csv2_is_lower(look);
#line 608
            if (tmp___45) {
#line 609
              out_num += (look + 10) - 97;
            }
          }
        }
#line 611
        tmp___48 = js_addbyte(out, (unsigned char )out_num);
#line 611
        if (tmp___48 == -1) {
#line 612
          js_destroy(out);
#line 613
          return ((js_string *)0);
        }
#line 615
        txt_len ++;
#line 616
        out_num = 0;
#line 617
        state = 1;
      } else {
#line 620
        csv2_error(stream, (char *)"Invalid hex digit");
#line 621
        js_destroy(out);
#line 622
        return ((js_string *)0);
      }
    } else
#line 625
    if (state == 10) {
#line 627
      tmp___53 = csv2_is_hash(look);
#line 627
      if (tmp___53) {
#line 628
        process_comment(stream);
      } else
#line 630
      if (look == 126) {
#line 631
        tmp___50 = csv2_finalize_txt(stream, numchunks, chunkcount, txt_len_place,
                                     txt_len, out);
#line 631
        return (tmp___50);
      } else
#line 630
      if (look == -2) {
#line 631
        tmp___50 = csv2_finalize_txt(stream, numchunks, chunkcount, txt_len_place,
                                     txt_len, out);
#line 631
        return (tmp___50);
      } else
#line 634
      if (look == 39) {
#line 634
        goto _L___9;
      } else
#line 634
      if (look == 92) {
        _L___9: /* CIL Label */ 
#line 635
        if (txt_len_place < 0) {
#line 637
          js_destroy(out);
#line 638
          return ((js_string *)0);
        } else
#line 635
        if ((unsigned int )txt_len_place > out->max_count) {
#line 637
          js_destroy(out);
#line 638
          return ((js_string *)0);
        }
#line 640
        if (txt_len > 255) {
#line 641
          csv2_error(stream, (char *)"Single TXT chunk too long");
#line 643
          js_destroy(out);
#line 644
          return ((js_string *)0);
        }
#line 646
        *(out->string + txt_len_place) = (unsigned char )txt_len;
#line 647
        chunkcount ++;
#line 648
        txt_len_place = (int )out->unit_count;
#line 649
        txt_len = 0;
#line 650
        tmp___51 = csv2_append_utf8(out, 0);
#line 650
        if (tmp___51 == -1) {
#line 651
          js_destroy(out);
#line 652
          return ((js_string *)0);
        }
#line 654
        if (look == 39) {
#line 655
          state = 2;
        } else
#line 656
        if (look == 92) {
#line 657
          state = 3;
        } else {
#line 659
          printf("Fatal error in BETWEEN_CHUNK state!\n");
#line 661
          exit(1);
        }
      } else
#line 664
      if (look == 124) {
#line 665
        csv2_error(stream, (char *)"Pipes are not allowed between TXT chunks");
#line 667
        js_destroy(out);
#line 668
        return ((js_string *)0);
      } else {
#line 669
        tmp___52 = csv2_is_delimiter(look);
#line 669
        if (! tmp___52) {
#line 670
          csv2_error(stream, (char *)"Invalid character between chunks; this might be caused by a TXT RR not\nterminated by a ~ character");
#line 673
          js_destroy(out);
#line 674
          return ((js_string *)0);
        }
      }
    }
#line 325
    x ++;
  }
#line 681
  csv2_error(stream, (char *)"RR too long");
#line 682
  js_destroy(out);
#line 683
  return ((js_string *)0);
}
}
#line 1 "Csv2_esc_txt.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-9USBLfZK.i","")
#line 27 "Csv2_esc_txt.c"
int escape_stdout_csv2(js_string *js ) 
{ unsigned char this ;
  int inquote ;
  int counter ;
  int tmp ;

  {
#line 29
  inquote = 0;
#line 29
  counter = 0;
#line 32
  tmp = js_has_sanity(js);
#line 32
  if (tmp < 0) {
#line 33
    return (-1);
  }
#line 34
  if (js->unit_size != 1U) {
#line 35
    return (-1);
  }
#line 37
  inquote = 0;
#line 39
  while ((unsigned int )counter < js->unit_count) {
#line 40
    this = *(js->string + counter);
#line 41
    if ((int )this < 32) {
#line 41
      goto _L;
    } else
#line 41
    if ((int )this > 122) {
#line 41
      goto _L;
    } else
#line 41
    if ((int )this == 35) {
      _L: /* CIL Label */ 
#line 46
      if (inquote == 1) {
#line 47
        printf("\'");
#line 48
        inquote = 0;
      }
#line 50
      printf("\\x%02x", (int )this);
    } else
#line 52
    if ((int )this == 39) {
#line 53
      if (inquote == 1) {
#line 54
        printf("\'\\\'\'");
      } else {
#line 57
        printf("\\\'");
      }
    } else {
#line 61
      if (inquote == 0) {
#line 62
        inquote = 1;
#line 63
        printf("\'");
      }
#line 65
      printf("%c", (int )this);
    }
#line 67
    counter ++;
  }
#line 70
  if (inquote == 1) {
#line 71
    printf("\'");
  }
#line 74
  return (1);
}
}
#line 80 "Csv2_esc_txt.c"
void human_readable_dns_query(js_string *query , int hide_qtype ) 
{ unsigned char this ;
  int counter ;
  int dlen ;
  int qtype ;
  int x ;
  unsigned char *that ;
  int tmp ;

  {
#line 82
  counter = 0;
#line 82
  dlen = -1;
#line 85
  tmp = js_has_sanity(query);
#line 85
  if (tmp < 0) {
#line 86
    printf(":ERROR:\n");
#line 87
    return;
  }
#line 89
  if (query->unit_size != 1U) {
#line 90
    printf(":ERROR:\n");
#line 91
    return;
  }
#line 94
  if (query->unit_count < 2U) {
#line 95
    printf(":ERROR:\n");
  }
#line 98
  that = query->string;
#line 99
  qtype = (int )*((that + query->unit_count) - 1);
#line 100
  qtype += (int )*((that + query->unit_count) - 2) << 8;
#line 101
  if (hide_qtype != 1) {
#line 102
    printf("%d:", qtype);
  }
#line 105
  x = 0;
#line 105
  while (x < 10000) {
#line 106
    if ((unsigned int )counter > query->unit_count) {
#line 107
      printf(":ERROR:105:\n");
#line 108
      return;
    } else
#line 106
    if (counter < 0) {
#line 107
      printf(":ERROR:105:\n");
#line 108
      return;
    }
#line 110
    dlen = (int )*(query->string + counter);
#line 111
    if (dlen == 95) {
#line 112
      printf("{STAR}");
#line 113
      if (counter == 0) {
#line 113
        if (query->unit_count != 3U) {
#line 116
          counter ++;
#line 117
          goto __Cont;
        } else {
#line 119
          break;
        }
      } else {
#line 119
        break;
      }
    }
#line 122
    if (dlen > 64) {
#line 123
      printf(":ERROR:110:%d:\n", dlen);
#line 124
      return;
    } else
#line 122
    if (dlen < 0) {
#line 123
      printf(":ERROR:110:%d:\n", dlen);
#line 124
      return;
    }
#line 126
    if (dlen == 0) {
#line 127
      break;
    }
#line 129
    while (dlen > 0) {
#line 130
      counter ++;
#line 131
      if ((unsigned int )counter > query->unit_count) {
#line 132
        printf(":ERROR:119:\n");
#line 133
        return;
      } else
#line 131
      if (counter < 0) {
#line 132
        printf(":ERROR:119:\n");
#line 133
        return;
      }
#line 135
      this = *(query->string + counter);
#line 136
      if ((int )this < 32) {
#line 138
        printf("\\x%02x", (int )this);
      } else
#line 136
      if ((int )this > 127) {
#line 138
        printf("\\x%02x", (int )this);
      } else
#line 136
      if ((int )this == 46) {
#line 138
        printf("\\x%02x", (int )this);
      } else
#line 136
      if ((int )this == 58) {
#line 138
        printf("\\x%02x", (int )this);
      } else {
#line 140
        printf("%c", (int )this);
      }
#line 142
      dlen --;
    }
#line 144
    counter ++;
#line 145
    printf(".");
    __Cont: /* CIL Label */ 
#line 105
    x ++;
  }
#line 148
  if ((unsigned int )counter != query->unit_count - 3U) {
#line 149
    printf(":ERROR:%d:%d:\n", counter, query->unit_count);
  }
#line 152
  return;
}
}
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
#line 1 "timestamp.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-xVFckVQO.i","")
#line 243 "/usr/include/stdio.h"
extern int fflush(FILE * ) ;
#line 123 "/usr/include/time.h"
extern char *asctime(struct tm  const  * ) ;
#line 128
extern struct tm *gmtime(time_t const   * ) ;
#line 129
extern struct tm *localtime(time_t const   * ) ;
#line 127 "/usr/include/secure/_string.h"
__inline static char *__inline_strncpy_chk(char *__dest , char const   *__src , size_t __len ) 
{ unsigned long tmp ;
  char *tmp___0 ;

  {
#line 131
  tmp = __builtin_object_size((void *)__dest, 1);
#line 131
  tmp___0 = __builtin___strncpy_chk(__dest, __src, __len, tmp);
#line 131
  return (tmp___0);
}
}
#line 29 "timestamp.c"
int timestamp_type  =    0;
#line 44 "timestamp.c"
int set_timestamp(int type ) 
{ 

  {
#line 45
  if (type >= 0) {
#line 45
    if (type <= 128) {
#line 46
      timestamp_type = type;
#line 47
      return (1);
    }
  }
#line 49
  return (-1);
}
}
#line 58 "timestamp.c"
int show_timestamp(void) 
{ time_t tmp ;
  time_t tmp___0 ;
  struct tm *htime ;
  time_t now ;
  char *dow[7] ;
  char *moy[12] ;
  char ct[256] ;
  int count ;
  time_t now___0 ;
  struct tm *tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  struct tm *tmp___4 ;
  char *tmp___5 ;
  unsigned long tmp___6 ;
  struct tm *htime___0 ;
  time_t now___1 ;
  time_t tmp___7 ;

  {
#line 59
  fflush(__stdoutp);
#line 60
  if (timestamp_type == 0) {
#line 61
    tmp = time((time_t *)0);
#line 61
    printf("%s%d ", "Timestamp: ", (int )tmp);
  } else
#line 63
  if (timestamp_type == 1) {
#line 64
    tmp___0 = time((time_t *)0);
#line 64
    printf("%d ", (int )tmp___0);
  } else
#line 66
  if (timestamp_type == 2) {
#line 66
    goto _L___0;
  } else
#line 66
  if (timestamp_type == 3) {
    _L___0: /* CIL Label */ 
#line 70
    dow[0] = (char *)"Domingo";
#line 70
    dow[1] = (char *)"Lunes";
#line 70
    dow[2] = (char *)"Martes";
#line 70
    dow[3] = (char *)"Miercoles";
#line 70
    dow[4] = (char *)"Jueves";
#line 70
    dow[5] = (char *)"Viernes";
#line 70
    dow[6] = (char *)"Sabado";
#line 78
    moy[0] = (char *)"Enero";
#line 78
    moy[1] = (char *)"Febrero";
#line 78
    moy[2] = (char *)"Marzo";
#line 78
    moy[3] = (char *)"Abril";
#line 78
    moy[4] = (char *)"Mayo";
#line 78
    moy[5] = (char *)"Junio";
#line 78
    moy[6] = (char *)"Julio";
#line 78
    moy[7] = (char *)"Agosto";
#line 78
    moy[8] = (char *)"Septiembre";
#line 78
    moy[9] = (char *)"Octubre";
#line 78
    moy[10] = (char *)"Noviembre";
#line 78
    moy[11] = (char *)"Diciembre";
#line 91
    now = time((time_t *)0);
#line 92
    if (timestamp_type == 2) {
#line 93
      htime = gmtime((time_t const   *)(& now));
    } else {
#line 95
      htime = localtime((time_t const   *)(& now));
    }
#line 98
    if (htime->tm_mon < 0) {
#line 99
      return (-1);
    } else
#line 98
    if (htime->tm_mon > 11) {
#line 99
      return (-1);
    }
#line 100
    if (htime->tm_wday < 0) {
#line 101
      return (-1);
    } else
#line 100
    if (htime->tm_wday > 6) {
#line 101
      return (-1);
    }
#line 103
    printf("%s, %d de %s, a %02d:%02d:%02d ", dow[htime->tm_wday], htime->tm_mday,
           moy[htime->tm_mon], htime->tm_hour, htime->tm_min, htime->tm_sec);
#line 106
    if (timestamp_type == 2) {
#line 107
      printf("(UTC) ");
    }
  } else
#line 109
  if (timestamp_type == 4) {
#line 113
    now___0 = time((time_t *)0);
#line 114
    tmp___6 = __builtin_object_size((void *)(ct), 0);
#line 114
    if (tmp___6 != 0xffffffffffffffffUL) {
#line 114
      tmp___3 = __builtin_object_size((void *)(ct), 1);
#line 114
      tmp___4 = gmtime((time_t const   *)(& now___0));
#line 114
      tmp___5 = asctime((struct tm  const  *)tmp___4);
#line 114
      __builtin___strncpy_chk(ct, (char const   *)tmp___5, 100UL, tmp___3);
    } else {
#line 114
      tmp___1 = gmtime((time_t const   *)(& now___0));
#line 114
      tmp___2 = asctime((struct tm  const  *)tmp___1);
#line 114
      __inline_strncpy_chk(ct, (char const   *)tmp___2, (size_t )100);
    }
#line 115
    count = 0;
#line 115
    while (count < 100) {
#line 116
      if ((int )ct[count] < 32) {
#line 117
        ct[count] = (char)0;
#line 118
        break;
      }
#line 115
      count ++;
    }
#line 121
    printf("%s GMT ", ct);
  } else
#line 123
  if (! (timestamp_type == 5)) {
#line 125
    if (timestamp_type == 6) {
#line 125
      goto _L;
    } else
#line 125
    if (timestamp_type == 7) {
      _L: /* CIL Label */ 
#line 128
      now___1 = time((time_t *)0);
#line 129
      if (timestamp_type == 6) {
#line 130
        htime___0 = gmtime((time_t const   *)(& now___1));
      } else {
#line 132
        htime___0 = localtime((time_t const   *)(& now___1));
      }
#line 134
      printf("%d-%02d-%02d %02d:%02d:%02d ", htime___0->tm_year + 1900, htime___0->tm_mon + 1,
             htime___0->tm_mday, htime___0->tm_hour, htime___0->tm_min, htime___0->tm_sec);
    } else {
#line 143
      tmp___7 = time((time_t *)0);
#line 143
      printf("%s%d ", "Timestamp: ", (int )tmp___7);
    }
  }
#line 145
  return (1);
}
}
#line 1 "MaraBigHash.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-FbuvHhAI.i","")
#line 37 "functions_server.h"
void init_rr(rr *data ) ;
#line 62
int populate_main(mhash *maintable , js_string *error , int recursive ) ;
#line 86
int change_rtype(js_string *js , int newtype ) ;
#line 122
int add_an(mhash *bighash , js_string *error ) ;
#line 131
int answer_ip_query(int qtype , js_string *qu , js_string *ar ) ;
#line 138
int get_rtype(js_string *js ) ;
#line 224
int mhash_add_rr(mhash *hash , js_string *query , js_string *value___0 , uint32_t ttl ,
                 uint32_t authoritative , uint32_t expire , uint16_t perms ) ;
#line 235
int mhash_add_ptr(mhash *hash , js_string *query , js_string *value___0 ) ;
#line 251
int any_add_rr(mhash *hash , js_string *query , rr *data ) ;
#line 258
int any_zap_rr(mhash *hash , js_string *query , rr *data ) ;
#line 49 "MaraBigHash.c"
int log_level ;
#line 52 "MaraBigHash.c"
int cname_warnings_shown  =    0;
#line 60 "MaraBigHash.c"
int warning(js_string *msg , int line___0 ) 
{ 

  {
#line 61
  if (log_level == 0) {
#line 62
    return (1);
  }
#line 63
  printf("%s", "Warning: ");
#line 64
  js_show_stdout(msg);
#line 65
  if (line___0 != -1) {
#line 66
    printf("%s%d", " on line ", line___0);
  }
#line 67
  printf("%s", "\n");
#line 68
  return (1);
}
}
#line 80 "MaraBigHash.c"
int starrecord_to_meta(js_string *rr___0 , int recursive ) 
{ int counter ;
  int tmp ;

  {
#line 83
  tmp = js_has_sanity(rr___0);
#line 83
  if (tmp == -1) {
#line 84
    return (-1);
  }
#line 85
  if (rr___0->unit_size != 1U) {
#line 86
    return (-1);
  }
#line 89
  if (rr___0->unit_count < 2U) {
#line 90
    return (1);
  }
#line 93
  if ((int )*(rr___0->string) == 1) {
#line 93
    if ((int )*(rr___0->string + 1) == 42) {
#line 94
      *(rr___0->string) = (unsigned char )'_';
#line 95
      if (rr___0->unit_count > rr___0->max_count) {
#line 96
        return (-1);
      }
#line 97
      counter = 1;
#line 97
      while ((unsigned int )counter < rr___0->unit_count) {
#line 98
        *(rr___0->string + counter) = *((rr___0->string + counter) + 1);
#line 97
        counter ++;
      }
#line 99
      (rr___0->unit_count) --;
    }
  }
#line 105
  counter = dlabel_length(rr___0, 0U);
#line 106
  counter -= 3;
#line 107
  if (counter < 0) {
#line 108
    return (1);
  }
#line 109
  if ((int )*(rr___0->string + counter) == 1) {
#line 109
    if ((int )*((rr___0->string + counter) + 1) == 42) {
#line 110
      *(rr___0->string + counter) = (unsigned char )'_';
#line 111
      counter ++;
#line 112
      while ((unsigned int )counter < rr___0->unit_count) {
#line 113
        *(rr___0->string + counter) = *((rr___0->string + counter) + 2);
#line 112
        counter ++;
      }
#line 114
      rr___0->unit_count -= 2U;
#line 115
      if (recursive == 1) {
#line 116
        show_timestamp();
#line 117
        printf("Warning: star labels at the end can not be used when recursion is enabled\n");
      }
    }
  }
#line 122
  return (1);
}
}
#line 131 "MaraBigHash.c"
int get_rtype(js_string *js ) 
{ int rtype ;
  int tmp ;

  {
#line 136
  tmp = js_has_sanity(js);
#line 136
  if (tmp == -1) {
#line 137
    return (-1);
  }
#line 138
  if (js->unit_count < 3U) {
#line 139
    return (-1);
  }
#line 142
  rtype = ((int )*((js->string + js->unit_count) - 1) & 255) | (((int )*((js->string + js->unit_count) - 2) & 255) << 8);
#line 145
  return (rtype);
}
}
#line 154 "MaraBigHash.c"
int change_rtype(js_string *js , int newtype ) 
{ int tmp ;

  {
#line 157
  tmp = js_has_sanity(js);
#line 157
  if (tmp == -1) {
#line 158
    return (-1);
  }
#line 159
  if (js->unit_count < 3U) {
#line 160
    return (-1);
  }
#line 161
  if (newtype < 0) {
#line 162
    return (-1);
  } else
#line 161
  if (newtype > 65535) {
#line 162
    return (-1);
  }
#line 165
  *((js->string + js->unit_count) - 1) = (unsigned char )(newtype & 255);
#line 166
  *((js->string + js->unit_count) - 2) = (unsigned char )((newtype & 65280) >> 8);
#line 168
  return (1);
}
}
#line 176 "MaraBigHash.c"
void init_rr(rr *data ) 
{ uint32_t tmp ;
  uint32_t tmp___0 ;
  uint16_t tmp___1 ;
  struct rr *tmp___2 ;
  js_string *tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;

  {
#line 177
  tmp___1 = (uint16_t )0;
#line 177
  data->rr_type = tmp___1;
#line 177
  tmp___0 = (uint32_t )tmp___1;
#line 177
  data->authoritative = tmp___0;
#line 177
  tmp = tmp___0;
#line 177
  data->ttl = tmp;
#line 177
  data->expire = (int64_t )tmp;
#line 178
  tmp___2 = (struct rr *)0;
#line 178
  data->ip = tmp___2;
#line 178
  data->next = tmp___2;
#line 179
  tmp___3 = (js_string *)0;
#line 179
  data->data = tmp___3;
#line 179
  data->query = tmp___3;
#line 180
  data->ptr = (js_string *)0;
#line 181
  data->seen = (char)0;
#line 182
  data->zap = (fila *)0;
#line 183
  tmp___5 = (uint32_t )0;
#line 183
  data->authoritative = tmp___5;
#line 183
  tmp___4 = tmp___5;
#line 183
  data->ttl = tmp___4;
#line 183
  data->expire = (int64_t )tmp___4;
#line 184
  data->perms = (uint16_t )0;
#line 185
  data->list = (struct rr_list *)0;
#line 186
  data->rcode = (char)0;
#line 187
  return;
}
}
#line 196 "MaraBigHash.c"
int mhash_put_rr(mhash *hash , js_string *query , js_string *value___0 , uint32_t ttl ,
                 uint32_t authoritative , uint32_t expire , uint16_t perms ) 
{ rr *data ;
  js_string *new ;
  int ret ;
  int rrtype ;
  void *tmp ;
  int tmp___0 ;
  struct rr *tmp___1 ;
  int tmp___2 ;

  {
#line 199
  data = (rr *)0;
#line 200
  new = (js_string *)0;
#line 203
  tmp = js_alloc(1, (int )sizeof(rr ));
#line 203
  data = (rr *)tmp;
#line 203
  if ((unsigned long )data == (unsigned long )((rr *)0)) {
#line 204
    return (-1);
  }
#line 207
  init_rr(data);
#line 210
  data->expire = (int64_t )0;
#line 211
  data->ttl = ttl;
#line 212
  data->authoritative = authoritative;
#line 213
  data->perms = perms;
#line 215
  rrtype = get_rtype(query);
#line 216
  if (rrtype == -1) {
#line 217
    js_dealloc((void *)data);
#line 218
    return (-1);
  }
#line 220
  if (rrtype < 0) {
#line 221
    js_dealloc((void *)data);
#line 222
    return (-1);
  } else
#line 220
  if (rrtype > 65535) {
#line 221
    js_dealloc((void *)data);
#line 222
    return (-1);
  }
#line 224
  data->rr_type = (uint16_t )rrtype;
#line 227
  new = js_create(value___0->unit_count + 1U, value___0->unit_size);
#line 227
  if ((unsigned long )new == (unsigned long )((js_string *)0)) {
#line 228
    js_dealloc((void *)data);
#line 229
    return (-1);
  }
#line 231
  tmp___0 = js_copy(value___0, new);
#line 231
  if (tmp___0 == -1) {
#line 232
    js_dealloc((void *)data);
#line 233
    js_destroy(new);
#line 234
    return (-1);
  }
#line 237
  data->data = new;
#line 240
  tmp___1 = (struct rr *)0;
#line 240
  data->next = tmp___1;
#line 240
  data->ip = tmp___1;
#line 243
  ret = mhash_put(hash, query, (void *)data, 3);
#line 246
  tmp___2 = any_add_rr(hash, query, data);
#line 246
  if (tmp___2 == -1) {
#line 247
    return (-1);
  }
#line 251
  mhash_autogrow(hash);
#line 259
  data->query = mhash_get_immutable_key(hash, query);
#line 261
  if (ret == -1) {
#line 262
    js_dealloc((void *)data);
#line 263
    js_destroy(new);
#line 264
    return (-1);
  }
#line 267
  return (1);
}
}
#line 276 "MaraBigHash.c"
int mhash_add_rr(mhash *hash , js_string *query , js_string *value___0 , uint32_t ttl ,
                 uint32_t authoritative , uint32_t expire , uint16_t perms ) 
{ rr *data ;
  rr *point ;
  js_string *new ;
  mhash_e spot_data ;
  int rrtype ;
  void *tmp ;
  int tmp___0 ;

  {
#line 285
  tmp = js_alloc(1, (int )sizeof(rr ));
#line 285
  data = (rr *)tmp;
#line 285
  if ((unsigned long )data == (unsigned long )((rr *)0)) {
#line 286
    return (-1);
  }
#line 289
  init_rr(data);
#line 292
  data->expire = (int64_t )0;
#line 293
  data->ttl = ttl;
#line 294
  data->authoritative = authoritative;
#line 295
  data->perms = perms;
#line 298
  rrtype = get_rtype(query);
#line 299
  if (rrtype == -1) {
#line 300
    js_dealloc((void *)data);
#line 301
    return (-1);
  }
#line 303
  if (rrtype < 0) {
#line 304
    js_dealloc((void *)data);
#line 305
    return (-1);
  } else
#line 303
  if (rrtype > 65535) {
#line 304
    js_dealloc((void *)data);
#line 305
    return (-1);
  }
#line 307
  data->rr_type = (uint16_t )rrtype;
#line 310
  new = js_create(value___0->unit_count + 1U, value___0->unit_size);
#line 310
  if ((unsigned long )new == (unsigned long )((js_string *)0)) {
#line 311
    js_dealloc((void *)data);
#line 312
    return (-1);
  }
#line 314
  tmp___0 = js_copy(value___0, new);
#line 314
  if (tmp___0 == -1) {
#line 315
    js_dealloc((void *)data);
#line 316
    js_destroy(new);
#line 317
    return (-1);
  }
#line 320
  data->data = new;
#line 323
  spot_data = mhash_get(hash, query);
#line 324
  if ((unsigned long )spot_data.value == (unsigned long )((void *)0)) {
#line 325
    js_dealloc((void *)data);
#line 326
    js_destroy(new);
#line 327
    return (-1);
  }
#line 331
  if (spot_data.datatype != 3) {
#line 332
    js_dealloc((void *)data);
#line 333
    js_destroy(new);
#line 334
    return (-1);
  }
#line 341
  point = (rr *)spot_data.value;
#line 346
  data->query = point->query;
#line 349
  while (1) {
#line 349
    if ((unsigned long )point->next != (unsigned long )((struct rr *)0)) {
#line 349
      if (! ((int )(point->next)->rr_type != 2)) {
#line 349
        break;
      }
    } else {
#line 349
      break;
    }
#line 350
    point = point->next;
  }
#line 352
  data->next = point->next;
#line 353
  point->next = data;
#line 355
  return (1);
}
}
#line 368 "MaraBigHash.c"
int mhash_add_ptr(mhash *hash , js_string *query , js_string *value___0 ) 
{ rr *point ;
  js_string *new ;
  mhash_e spot_data ;
  int tmp ;

  {
#line 375
  new = js_create(value___0->unit_count + 1U, value___0->unit_size);
#line 375
  if ((unsigned long )new == (unsigned long )((js_string *)0)) {
#line 379
    return (-1);
  }
#line 381
  tmp = js_copy(value___0, new);
#line 381
  if (tmp == -1) {
#line 382
    js_destroy(new);
#line 383
    return (-1);
  }
#line 388
  spot_data = mhash_get(hash, query);
#line 389
  if ((unsigned long )spot_data.value == (unsigned long )((void *)0)) {
#line 390
    js_destroy(new);
#line 391
    return (-1);
  }
#line 395
  if (spot_data.datatype != 3) {
#line 396
    js_destroy(new);
#line 397
    return (-1);
  }
#line 403
  point = (rr *)spot_data.value;
#line 406
  if ((unsigned long )point->ptr != (unsigned long )((js_string *)0)) {
#line 407
    js_destroy(new);
#line 408
    return (1);
  }
#line 411
  point->ptr = new;
#line 412
  return (1);
}
}
#line 426 "MaraBigHash.c"
int mhash_add_ip(mhash *hash , js_string *query , js_string *value___0 ) 
{ rr *data ;
  rr *point ;
  js_string *new ;
  js_string *new_query ;
  mhash_e spot_data ;
  int rrtype ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 428
  data = (rr *)0;
#line 428
  point = (rr *)0;
#line 429
  new = (js_string *)0;
#line 429
  new_query = (js_string *)0;
#line 434
  tmp = js_alloc(1, (int )sizeof(rr ));
#line 434
  data = (rr *)tmp;
#line 434
  if ((unsigned long )data == (unsigned long )((rr *)0)) {
#line 435
    return (-1);
  }
#line 438
  init_rr(data);
#line 441
  rrtype = 1;
#line 442
  data->rr_type = (uint16_t )rrtype;
#line 445
  new = js_create(value___0->unit_count + 1U, value___0->unit_size);
#line 445
  if ((unsigned long )new == (unsigned long )((js_string *)0)) {
#line 446
    js_dealloc((void *)data);
#line 450
    return (-1);
  }
#line 452
  tmp___0 = js_copy(value___0, new);
#line 452
  if (tmp___0 == -1) {
#line 453
    js_dealloc((void *)data);
#line 454
    js_destroy(new);
#line 455
    return (-1);
  }
#line 458
  data->data = new;
#line 461
  spot_data = mhash_get(hash, query);
#line 462
  if ((unsigned long )spot_data.value == (unsigned long )((void *)0)) {
#line 463
    js_dealloc((void *)data);
#line 464
    js_destroy(new);
#line 465
    return (-1);
  }
#line 469
  if (spot_data.datatype != 3) {
#line 470
    js_dealloc((void *)data);
#line 471
    js_destroy(new);
#line 472
    return (-1);
  }
#line 479
  point = (rr *)spot_data.value;
#line 483
  if ((unsigned long )point->ip != (unsigned long )((struct rr *)0)) {
#line 484
    js_dealloc((void *)data);
#line 485
    js_destroy(new);
#line 486
    return (-1);
  }
#line 491
  new_query = js_create((point->data)->unit_count + 3U, 1U);
#line 491
  if ((unsigned long )new_query == (unsigned long )((js_string *)0)) {
#line 492
    js_dealloc((void *)data);
#line 493
    js_destroy(new);
#line 498
    return (-1);
  }
#line 500
  tmp___1 = js_copy(point->data, new_query);
#line 500
  if (tmp___1 == -1) {
#line 501
    js_dealloc((void *)data);
#line 502
    js_destroy(new);
#line 503
    js_destroy(new_query);
#line 504
    return (-1);
  }
#line 506
  tmp___2 = js_adduint16(new_query, 1);
#line 506
  if (tmp___2 == -1) {
#line 507
    js_dealloc((void *)data);
#line 508
    js_destroy(new);
#line 509
    js_destroy(new_query);
#line 510
    return (-1);
  }
#line 515
  data->query = new_query;
#line 518
  data->next = (struct rr *)0;
#line 519
  point->ip = data;
#line 521
  data->expire = point->expire;
#line 522
  data->ttl = point->ttl;
#line 523
  data->authoritative = point->authoritative;
#line 525
  return (1);
}
}
#line 534 "MaraBigHash.c"
int mhash_add_ns(mhash *hash , js_string *query , js_string *ns ) 
{ rr *point ;
  rr *ns_rr ;
  mhash_e spot_data ;
  int rrtype ;

  {
#line 541
  rrtype = get_rtype(query);
#line 542
  if (rrtype == -1) {
#line 543
    return (-1);
  }
#line 545
  if (rrtype < 0) {
#line 546
    return (-1);
  } else
#line 545
  if (rrtype > 65535) {
#line 546
    return (-1);
  }
#line 550
  if (rrtype == 2) {
#line 551
    return (1);
  }
#line 554
  rrtype = get_rtype(ns);
#line 555
  if (rrtype == -1) {
#line 556
    return (-1);
  }
#line 558
  if (rrtype < 0) {
#line 559
    return (-1);
  } else
#line 558
  if (rrtype > 65535) {
#line 559
    return (-1);
  }
#line 563
  if (rrtype != 2) {
#line 564
    return (1);
  }
#line 567
  spot_data = mhash_get(hash, query);
#line 568
  if ((unsigned long )spot_data.value == (unsigned long )((void *)0)) {
#line 569
    return (-1);
  }
#line 572
  if (spot_data.datatype != 3) {
#line 573
    return (-1);
  }
#line 576
  point = (rr *)spot_data.value;
#line 579
  spot_data = mhash_get(hash, ns);
#line 580
  if ((unsigned long )spot_data.value == (unsigned long )((void *)0)) {
#line 581
    return (1);
  }
#line 585
  if (spot_data.datatype != 3) {
#line 586
    return (-1);
  }
#line 589
  ns_rr = (rr *)spot_data.value;
#line 594
  while ((unsigned long )point->next != (unsigned long )((struct rr *)0)) {
#line 595
    point = point->next;
  }
#line 597
  point->next = ns_rr;
#line 599
  return (1);
}
}
#line 613 "MaraBigHash.c"
int parse_csv1s(mhash *maintable , js_string *error , int recursive ) 
{ mhash *csvs ;
  js_string *zone ;
  js_string *udpzone ;
  js_string *filename ;
  js_string *line___0 ;
  js_string *soaline ;
  js_string *pline ;
  js_string *query ;
  js_string *data ;
  js_file *desc ;
  uint32_t ttl ;
  int rr_type ;
  int linenum ;
  int rrnum ;
  int in_ns ;
  int result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  mhash *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  js_string *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;

  {
#line 620
  linenum = 0;
#line 620
  rrnum = 0;
#line 620
  in_ns = 1;
#line 624
  tmp = js_has_sanity(error);
#line 624
  if (tmp == -1) {
#line 625
    return (-1);
  }
#line 628
  js_qstr2js(error, (char *)"");
#line 632
  udpzone = js_create(128U, 1U);
#line 632
  if ((unsigned long )udpzone == (unsigned long )((js_string *)0)) {
#line 633
    return (-1);
  }
#line 635
  filename = js_create(256U, 1U);
#line 635
  if ((unsigned long )filename == (unsigned long )((js_string *)0)) {
#line 636
    js_destroy(udpzone);
#line 637
    return (-1);
  }
#line 639
  line___0 = js_create(428U, 1U);
#line 639
  if ((unsigned long )line___0 == (unsigned long )((js_string *)0)) {
#line 640
    js_destroy(filename);
#line 641
    js_destroy(udpzone);
#line 642
    return (-1);
  }
#line 644
  tmp___0 = js_set_encode(line___0, 3);
#line 644
  if (tmp___0 == -1) {
#line 645
    js_destroy(line___0);
#line 646
    js_destroy(filename);
#line 647
    js_destroy(udpzone);
#line 648
    return (-1);
  }
#line 650
  pline = js_create(428U, 1U);
#line 650
  if ((unsigned long )pline == (unsigned long )((js_string *)0)) {
#line 651
    js_destroy(line___0);
#line 652
    js_destroy(filename);
#line 653
    js_destroy(udpzone);
#line 654
    return (-1);
  }
#line 656
  tmp___1 = js_set_encode(pline, 3);
#line 656
  if (tmp___1 == -1) {
#line 657
    js_destroy(pline);
#line 658
    js_destroy(line___0);
#line 659
    js_destroy(filename);
#line 660
    js_destroy(udpzone);
#line 661
    return (-1);
  }
#line 663
  soaline = js_create(256U, 1U);
#line 663
  if ((unsigned long )soaline == (unsigned long )((js_string *)0)) {
#line 664
    js_destroy(pline);
#line 665
    js_destroy(line___0);
#line 666
    js_destroy(filename);
#line 667
    js_destroy(udpzone);
#line 668
    return (-1);
  }
#line 670
  tmp___2 = js_set_encode(soaline, 3);
#line 670
  if (tmp___2 == -1) {
#line 671
    js_destroy(soaline);
#line 672
    js_destroy(pline);
#line 673
    js_destroy(line___0);
#line 674
    js_destroy(filename);
#line 675
    js_destroy(udpzone);
#line 676
    return (-1);
  }
#line 678
  query = js_create(256U, 1U);
#line 678
  if ((unsigned long )query == (unsigned long )((js_string *)0)) {
#line 679
    js_destroy(soaline);
#line 680
    js_destroy(pline);
#line 681
    js_destroy(line___0);
#line 682
    js_destroy(filename);
#line 683
    js_destroy(udpzone);
#line 684
    return (-1);
  }
#line 686
  data = js_create(428U, 1U);
#line 686
  if ((unsigned long )data == (unsigned long )((js_string *)0)) {
#line 687
    js_destroy(query);
#line 688
    js_destroy(soaline);
#line 689
    js_destroy(pline);
#line 690
    js_destroy(line___0);
#line 691
    js_destroy(filename);
#line 692
    js_destroy(udpzone);
#line 693
    return (-1);
  }
#line 695
  zone = js_create(256U, 1U);
#line 695
  if ((unsigned long )zone == (unsigned long )((js_string *)0)) {
#line 696
    js_destroy(data);
#line 697
    js_destroy(query);
#line 698
    js_destroy(soaline);
#line 699
    js_destroy(pline);
#line 700
    js_destroy(line___0);
#line 701
    js_destroy(filename);
#line 702
    js_destroy(udpzone);
#line 703
    return (-1);
  }
#line 705
  tmp___3 = js_alloc(1, (int )sizeof(js_file ));
#line 705
  desc = (js_file *)tmp___3;
#line 705
  if ((unsigned long )desc == (unsigned long )((js_file *)0)) {
#line 706
    js_destroy(zone);
#line 707
    js_destroy(data);
#line 708
    js_destroy(query);
#line 709
    js_destroy(soaline);
#line 710
    js_destroy(pline);
#line 711
    js_destroy(line___0);
#line 712
    js_destroy(filename);
#line 713
    js_destroy(udpzone);
#line 714
    return (-1);
  }
#line 720
  tmp___4 = dq_keyword2n((char *)"csv1");
#line 720
  tmp___5 = dvar_raw(tmp___4);
#line 720
  csvs = tmp___5;
#line 722
  if ((unsigned long )csvs == (unsigned long )((mhash *)0)) {
#line 725
    js_destroy(udpzone);
#line 725
    js_destroy(filename);
#line 725
    js_destroy(line___0);
#line 726
    js_destroy(pline);
#line 726
    js_destroy(soaline);
#line 726
    js_destroy(query);
#line 727
    js_destroy(data);
#line 727
    js_destroy(zone);
#line 727
    js_dealloc((void *)desc);
#line 728
    return (0);
  }
#line 734
  tmp___6 = mhash_firstkey(csvs, zone);
#line 734
  if (tmp___6 == 0) {
#line 737
    js_destroy(udpzone);
#line 737
    js_destroy(filename);
#line 737
    js_destroy(line___0);
#line 738
    js_destroy(pline);
#line 738
    js_destroy(soaline);
#line 738
    js_destroy(query);
#line 739
    js_destroy(data);
#line 739
    js_destroy(zone);
#line 739
    js_dealloc((void *)desc);
#line 740
    return (0);
  }
#line 742
  while (1) {
#line 745
    if ((unsigned long )zone != (unsigned long )((js_string *)0)) {
#line 748
      tmp___7 = js_qstr2js(udpzone, (char *)"A");
#line 748
      if (tmp___7 == -1) {
#line 749
        js_destroy(udpzone);
#line 749
        js_destroy(filename);
#line 749
        js_destroy(line___0);
#line 750
        js_destroy(pline);
#line 750
        js_destroy(soaline);
#line 750
        js_destroy(query);
#line 751
        js_destroy(data);
#line 751
        js_destroy(zone);
#line 751
        js_dealloc((void *)desc);
#line 752
        return (-1);
      }
#line 754
      tmp___8 = js_append(zone, udpzone);
#line 754
      if (tmp___8 == -1) {
#line 755
        js_destroy(udpzone);
#line 755
        js_destroy(filename);
#line 755
        js_destroy(line___0);
#line 756
        js_destroy(pline);
#line 756
        js_destroy(soaline);
#line 756
        js_destroy(query);
#line 757
        js_destroy(data);
#line 757
        js_destroy(zone);
#line 757
        js_dealloc((void *)desc);
#line 758
        return (-1);
      }
#line 760
      tmp___10 = hname_2rfc1035(udpzone);
#line 760
      if (tmp___10 == -1) {
#line 761
        js_qstr2js(error, (char *)"A zone file is incorrectly named.  All zone files must end with a dot, e.g.\ncsv1[\"example.com.\"] = \"filename\".\nHere is the line in the mararc with the problem: ");
#line 762
        js_qappend((char *)"\ncsv1[\"", error);
#line 763
        js_append(zone, error);
#line 764
        js_qappend((char *)"\"] = \"", error);
#line 765
        tmp___9 = mhash_get_js(csvs, zone);
#line 765
        js_append(tmp___9, error);
#line 766
        js_qappend((char *)"\"\n", error);
#line 767
        js_destroy(udpzone);
#line 767
        js_destroy(filename);
#line 767
        js_destroy(line___0);
#line 768
        js_destroy(pline);
#line 768
        js_destroy(soaline);
#line 768
        js_destroy(query);
#line 769
        js_destroy(data);
#line 769
        js_destroy(zone);
#line 769
        js_dealloc((void *)desc);
#line 770
        return (-2);
      }
#line 774
      tmp___11 = js_addbyte(udpzone, (unsigned char)0);
#line 774
      if (tmp___11 == -1) {
#line 775
        js_destroy(udpzone);
#line 775
        js_destroy(filename);
#line 775
        js_destroy(line___0);
#line 776
        js_destroy(pline);
#line 776
        js_destroy(soaline);
#line 776
        js_destroy(query);
#line 777
        js_destroy(data);
#line 777
        js_destroy(zone);
#line 777
        js_dealloc((void *)desc);
#line 778
        return (-1);
      }
#line 780
      tmp___12 = js_addbyte(udpzone, (unsigned char)2);
#line 780
      if (tmp___12 == -1) {
#line 781
        js_destroy(udpzone);
#line 781
        js_destroy(filename);
#line 781
        js_destroy(line___0);
#line 782
        js_destroy(pline);
#line 782
        js_destroy(soaline);
#line 782
        js_destroy(query);
#line 783
        js_destroy(data);
#line 783
        js_destroy(zone);
#line 783
        js_dealloc((void *)desc);
#line 784
        return (-1);
      }
#line 788
      js_destroy(filename);
#line 789
      filename = mhash_get_js(csvs, zone);
#line 791
      tmp___13 = js_open_read(filename, desc);
#line 791
      if (tmp___13 == -1) {
#line 792
        js_qstr2js(error, (char *)"Can not open zone file for zone ");
#line 793
        js_append(zone, error);
#line 794
        warning(error, -1);
#line 795
        goto __Cont;
      }
#line 799
      rrnum = 0;
#line 799
      linenum = rrnum;
#line 800
      in_ns = 1;
#line 803
      while (1) {
#line 803
        tmp___22 = js_buf_eof(desc);
#line 803
        if (tmp___22) {
#line 803
          break;
        }
#line 806
        result = js_buf_getline(desc, line___0);
#line 807
        if (result == -1) {
#line 808
          js_destroy(udpzone);
#line 808
          js_destroy(filename);
#line 809
          js_destroy(line___0);
#line 810
          js_destroy(pline);
#line 810
          js_destroy(soaline);
#line 810
          js_destroy(query);
#line 811
          js_destroy(data);
#line 811
          js_destroy(zone);
#line 811
          js_dealloc((void *)desc);
#line 812
          return (-1);
        } else
#line 814
        if (result == -2) {
#line 815
          printf("%s%d%s", "Line number ", linenum + 1, " is too long in file ");
#line 816
          show_esc_stdout(filename);
#line 817
          printf("\n");
#line 819
          js_destroy(udpzone);
#line 819
          js_destroy(filename);
#line 820
          js_destroy(line___0);
#line 821
          js_destroy(pline);
#line 821
          js_destroy(soaline);
#line 821
          js_destroy(query);
#line 822
          js_destroy(data);
#line 822
          js_destroy(zone);
#line 822
          js_dealloc((void *)desc);
#line 823
          return (-1);
        }
#line 827
        linenum ++;
#line 831
        tmp___16 = js_buf_eof(desc);
#line 831
        if (tmp___16) {
#line 831
          if (in_ns) {
#line 831
            if (line___0->unit_count == 0U) {
#line 834
              tmp___14 = js_length(soaline);
#line 834
              if (tmp___14 == 0) {
#line 835
                continue;
              }
#line 838
              tmp___15 = parse_csv1_line(soaline, query, data, & ttl);
#line 838
              if (tmp___15 != 6) {
#line 840
                js_destroy(udpzone);
#line 840
                js_destroy(filename);
#line 841
                js_destroy(line___0);
#line 842
                js_destroy(pline);
#line 842
                js_destroy(soaline);
#line 843
                js_destroy(query);
#line 844
                js_destroy(data);
#line 844
                js_destroy(zone);
#line 844
                js_dealloc((void *)desc);
#line 845
                return (-1);
              }
#line 847
              add_rr_to_bighash(maintable, query, data, ttl, udpzone, (uint16_t )0);
#line 848
              break;
            }
          }
        }
#line 852
        tmp___17 = js_buf_eof(desc);
#line 852
        if (tmp___17) {
#line 852
          if (line___0->unit_count == 0U) {
#line 853
            break;
          }
        }
#line 856
        tmp___18 = bs_process(line___0, pline, zone);
#line 856
        if (tmp___18 == -1) {
#line 857
          js_destroy(udpzone);
#line 857
          js_destroy(filename);
#line 858
          js_destroy(line___0);
#line 859
          js_destroy(pline);
#line 859
          js_destroy(soaline);
#line 859
          js_destroy(query);
#line 860
          js_destroy(data);
#line 860
          js_destroy(zone);
#line 860
          js_dealloc((void *)desc);
#line 861
          return (-1);
        }
#line 865
        rr_type = parse_csv1_line(pline, query, data, & ttl);
#line 869
        starrecord_to_meta(query, recursive);
#line 872
        if (rr_type == -1) {
#line 873
          js_qstr2js(error, (char *)"Fatal error in zone file ");
#line 874
          js_append(zone, error);
#line 875
          js_qappend((char *)" (aborting this zone file)", error);
#line 876
          warning(error, linenum);
#line 878
          break;
        }
#line 880
        if (rr_type == -2) {
#line 881
          js_qstr2js(error, (char *)"Syntax error in zone file ");
#line 882
          js_append(zone, error);
#line 883
          js_qappend((char *)" (", error);
#line 884
          js_append(data, error);
#line 885
          js_qappend((char *)")", error);
#line 886
          warning(error, linenum);
#line 887
          continue;
        }
#line 890
        if (rr_type > 0) {
#line 891
          rrnum ++;
#line 893
          if (rrnum == 1) {
#line 893
            if (rr_type != 6) {
#line 894
              js_qstr2js(error, (char *)"First record in csv1 zone file must be SOA record.");
#line 896
              js_qappend((char *)"Zone: ", error);
#line 897
              js_append(zone, error);
#line 898
              warning(error, 1);
#line 899
              break;
            } else {
#line 893
              goto _L___1;
            }
          } else
          _L___1: /* CIL Label */ 
#line 905
          if (rrnum == 1) {
#line 906
            tmp___19 = js_copy(pline, soaline);
#line 906
            if (tmp___19 == -1) {
#line 907
              js_destroy(udpzone);
#line 907
              js_destroy(filename);
#line 908
              js_destroy(line___0);
#line 909
              js_destroy(pline);
#line 909
              js_destroy(soaline);
#line 910
              js_destroy(query);
#line 911
              js_destroy(data);
#line 911
              js_destroy(zone);
#line 912
              js_dealloc((void *)desc);
#line 913
              return (-1);
            }
          } else
#line 917
          if (rrnum != 1) {
#line 917
            if (rr_type == 6) {
#line 918
              js_qstr2js(error, (char *)"Second SOA in zone file ");
#line 919
              js_append(zone, error);
#line 920
              warning(error, linenum);
#line 921
              continue;
            } else {
#line 917
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 928
          if (rr_type != 2) {
#line 928
            goto _L;
          } else {
#line 928
            tmp___21 = js_issame(query, udpzone);
#line 928
            if (tmp___21) {
#line 966
              add_rr_to_bighash(maintable, query, data, ttl, udpzone, (uint16_t )0);
            } else
            _L: /* CIL Label */ 
#line 928
            if (in_ns) {
#line 931
              tmp___20 = parse_csv1_line(soaline, query, data, & ttl);
#line 931
              if (tmp___20 != 6) {
#line 933
                js_destroy(udpzone);
#line 933
                js_destroy(filename);
#line 934
                js_destroy(line___0);
#line 935
                js_destroy(pline);
#line 935
                js_destroy(soaline);
#line 936
                js_destroy(query);
#line 937
                js_destroy(data);
#line 937
                js_destroy(zone);
#line 938
                js_dealloc((void *)desc);
#line 939
                return (-1);
              }
#line 941
              add_rr_to_bighash(maintable, query, data, ttl, udpzone, (uint16_t )0);
#line 944
              rr_type = parse_csv1_line(pline, query, data, & ttl);
#line 945
              if (rr_type == -1) {
#line 946
                js_qstr2js(error, (char *)"Fatal error in zone file ");
#line 947
                js_append(zone, error);
#line 948
                js_qappend((char *)" (aborting zone file)", error);
#line 949
                warning(error, linenum);
#line 951
                break;
              } else
#line 953
              if (rr_type == -2) {
#line 954
                js_qstr2js(error, (char *)"Syntax error in zone file ");
#line 955
                js_append(zone, error);
#line 956
                js_qappend((char *)" (", error);
#line 957
                js_append(data, error);
#line 958
                js_qappend((char *)")", error);
#line 959
                warning(error, linenum);
#line 960
                continue;
              }
#line 962
              add_rr_to_bighash(maintable, query, data, ttl, udpzone, (uint16_t )0);
#line 963
              in_ns = 0;
            } else {
#line 966
              add_rr_to_bighash(maintable, query, data, ttl, udpzone, (uint16_t )0);
            }
          }
        }
      }
#line 969
      js_close(desc);
    }
    __Cont: /* CIL Label */ 
#line 742
    tmp___23 = mhash_nextkey(csvs, zone);
#line 742
    if (! (tmp___23 != 0)) {
#line 742
      break;
    }
  }
#line 972
  js_destroy(udpzone);
#line 972
  js_destroy(filename);
#line 972
  js_destroy(line___0);
#line 973
  js_destroy(pline);
#line 973
  js_destroy(soaline);
#line 973
  js_destroy(query);
#line 974
  js_destroy(data);
#line 974
  js_destroy(zone);
#line 974
  js_dealloc((void *)desc);
#line 975
  return (1);
}
}
#line 980 "MaraBigHash.c"
int populate_main(mhash *maintable , js_string *error , int recursive ) 
{ int tmp ;

  {
#line 982
  parse_csv1s(maintable, error, recursive);
#line 983
  csv2_parse_main_bighash(maintable, 0);
#line 986
  tmp = add_an(maintable, error);
#line 986
  return (tmp);
}
}
#line 994 "MaraBigHash.c"
int warn_ddip(js_string *query ) 
{ 

  {
#line 995
  if (log_level == 0) {
#line 996
    return (1);
  }
#line 998
  printf("%s%s", "Dotted decimal IP for NS, CNAME, or MX does not work with some DNS servers",
         "\n");
#line 999
  return (1);
}
}
#line 1010 "MaraBigHash.c"
int make_ddip(mhash *bighash , js_string *query ) 
{ unsigned char ip[4] ;
  unsigned char length ;
  unsigned char val ;
  int critter ;
  int counter ;
  int lenl ;
  int value___0 ;
  js_string *js_ip ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1016
  if (query->unit_size != 1U) {
#line 1017
    return (-1);
  }
#line 1018
  if (query->unit_count >= query->max_count) {
#line 1019
    return (-1);
  }
#line 1023
  tmp = get_rtype(query);
#line 1023
  if (tmp != 1) {
#line 1024
    return (0);
  }
#line 1026
  if (query->unit_count < 9U) {
#line 1028
    return (0);
  }
#line 1031
  lenl = 0;
#line 1032
  counter = 0;
#line 1032
  while (counter < 4) {
#line 1033
    length = *(query->string + lenl);
#line 1034
    if ((int )length < 1) {
#line 1035
      return (0);
    } else
#line 1034
    if ((int )length > 3) {
#line 1035
      return (0);
    }
#line 1036
    critter = lenl + 1;
#line 1037
    lenl += (int )length + 1;
#line 1038
    if ((unsigned int )lenl > query->unit_count) {
#line 1039
      return (-1);
    }
#line 1040
    value___0 = 0;
#line 1040
    while (critter < lenl) {
#line 1041
      val = *(query->string + critter);
#line 1042
      if ((int )val > 57) {
#line 1043
        return (0);
      } else
#line 1042
      if ((int )val < 48) {
#line 1043
        return (0);
      }
#line 1044
      value___0 *= 10;
#line 1045
      value___0 += (int )val - 48;
#line 1040
      critter ++;
    }
#line 1047
    if (value___0 < 0) {
#line 1048
      return (0);
    } else
#line 1047
    if (value___0 > 255) {
#line 1048
      return (0);
    }
#line 1049
    ip[counter] = (unsigned char )value___0;
#line 1032
    counter ++;
  }
#line 1052
  if ((int )*(query->string + lenl) != 0) {
#line 1053
    return (0);
  }
#line 1057
  js_ip = js_create(5U, 1U);
#line 1057
  if ((unsigned long )js_ip == (unsigned long )((js_string *)0)) {
#line 1058
    return (-1);
  }
#line 1060
  tmp___0 = js_str2js(js_ip, (char *)(ip), 4, 1);
#line 1060
  if (tmp___0 == -1) {
#line 1061
    js_destroy(js_ip);
#line 1062
    return (-1);
  }
#line 1065
  tmp___1 = mhash_put_rr(bighash, query, js_ip, (uint32_t )8675309, (uint32_t )1,
                         (uint32_t )0, (uint16_t )0);
#line 1065
  if (tmp___1 == -1) {
#line 1066
    js_destroy(js_ip);
#line 1067
    return (-1);
  } else {
#line 1070
    js_destroy(js_ip);
#line 1071
    return (1);
  }
}
}
#line 1085 "MaraBigHash.c"
int add_an(mhash *bighash , js_string *error ) 
{ js_string *query ;
  js_string *a_query ;
  mhash_e qdata ;
  mhash_e adata ;
  rr *record ;
  int qtype ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1088
  qdata.point = (void **)0;
#line 1088
  qdata.value = (void *)0;
#line 1088
  qdata.datatype = 0;
#line 1088
  adata.point = (void **)0;
#line 1088
  adata.value = (void *)0;
#line 1088
  adata.datatype = 0;
#line 1092
  a_query = js_create(256U, 1U);
#line 1092
  if ((unsigned long )a_query == (unsigned long )((js_string *)0)) {
#line 1093
    return (-1);
  }
#line 1094
  query = js_create(256U, 1U);
#line 1094
  if ((unsigned long )query == (unsigned long )((js_string *)0)) {
#line 1095
    js_destroy(a_query);
#line 1096
    return (-1);
  }
#line 1101
  tmp = mhash_firstkey(bighash, query);
#line 1101
  if (tmp <= 0) {
#line 1102
    js_destroy(a_query);
#line 1103
    js_destroy(query);
#line 1104
    return (0);
  }
#line 1107
  while (1) {
#line 1109
    qtype = get_rtype(query);
#line 1110
    if (qtype == -1) {
#line 1111
      goto __Cont;
    }
#line 1112
    qdata = mhash_get(bighash, query);
#line 1115
    if (qtype == 15) {
#line 1115
      goto _L___0;
    } else
#line 1115
    if (qtype == 2) {
      _L___0: /* CIL Label */ 
#line 1116
      if (qdata.datatype == 3) {
#line 1119
        record = (rr *)qdata.value;
#line 1120
        while (1) {
#line 1121
          tmp___0 = answer_ip_query(qtype, record->data, a_query);
#line 1121
          if (tmp___0 == -1) {
#line 1122
            goto __Cont___0;
          }
#line 1123
          tmp___1 = change_rtype(a_query, 1);
#line 1123
          if (tmp___1 == -1) {
#line 1124
            goto __Cont___0;
          }
#line 1125
          adata = mhash_get(bighash, a_query);
#line 1127
          if (adata.datatype == 3) {
#line 1128
            if ((unsigned long )record != (unsigned long )((rr *)0)) {
#line 1128
              if ((unsigned long )adata.value != (unsigned long )((void *)0)) {
#line 1129
                record->ip = (struct rr *)adata.value;
              }
            }
          } else {
#line 1132
            tmp___2 = make_ddip(bighash, a_query);
#line 1132
            if (tmp___2 == 1) {
#line 1133
              warn_ddip(query);
#line 1134
              adata = mhash_get(bighash, a_query);
#line 1135
              if (adata.datatype == 3) {
#line 1136
                if ((unsigned long )record != (unsigned long )((rr *)0)) {
#line 1136
                  if ((unsigned long )adata.value != (unsigned long )((void *)0)) {
#line 1137
                    record->ip = (struct rr *)adata.value;
                  }
                }
              }
            }
          }
          __Cont___0: /* CIL Label */ 
#line 1120
          record = record->next;
#line 1120
          if (! ((unsigned long )record != (unsigned long )((rr *)0))) {
#line 1120
            break;
          }
        }
      }
    } else
#line 1145
    if (qtype == 5) {
#line 1148
      record = (rr *)qdata.value;
#line 1149
      while (1) {
#line 1150
        tmp___3 = answer_ip_query(qtype, record->data, a_query);
#line 1150
        if (tmp___3 == -1) {
#line 1151
          goto __Cont___1;
        }
#line 1152
        if ((int )record->rr_type != 5) {
#line 1153
          break;
        }
#line 1154
        tmp___4 = change_rtype(a_query, 255);
#line 1154
        if (tmp___4 == -1) {
#line 1155
          goto __Cont___1;
        }
#line 1156
        adata = mhash_get(bighash, a_query);
#line 1158
        if (adata.datatype == 6) {
#line 1159
          if ((unsigned long )record != (unsigned long )((rr *)0)) {
#line 1159
            if ((unsigned long )adata.value != (unsigned long )((void *)0)) {
#line 1160
              record->list = (struct rr_list *)adata.value;
            }
          }
        } else
#line 1162
        if (no_cname_warnings == 0) {
#line 1162
          if (cname_warnings_shown < 10) {
#line 1164
            printf("Warning: The CNAME record ");
#line 1165
            human_readable_dns_query(query, 1);
#line 1166
            printf(" is a dangling CNAME record.\nPlease read the FAQ entry about FAQ entry about dangling CNAME records.\n");
#line 1168
            cname_warnings_shown ++;
          } else {
#line 1162
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 1170
        if (no_cname_warnings == 0) {
#line 1170
          if (cname_warnings_shown == 10) {
#line 1172
            printf("Warning: More dangling CNAME records exist.\n");
#line 1173
            cname_warnings_shown ++;
          }
        }
        __Cont___1: /* CIL Label */ 
#line 1149
        record = record->next;
#line 1149
        if (! ((unsigned long )record != (unsigned long )((rr *)0))) {
#line 1149
          break;
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1107
    tmp___5 = mhash_nextkey(bighash, query);
#line 1107
    if (! (tmp___5 != 0)) {
#line 1107
      break;
    }
  }
#line 1178
  js_destroy(a_query);
#line 1179
  js_destroy(query);
#line 1180
  return (1);
}
}
#line 1191 "MaraBigHash.c"
int answer_ip_query(int qtype , js_string *qu , js_string *ar ) 
{ int start ;
  int length ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1195
  tmp = js_has_sanity(qu);
#line 1195
  if (tmp == -1) {
#line 1196
    return (-1);
  }
#line 1197
  if (qu->unit_size != 1U) {
#line 1198
    return (-1);
  }
#line 1199
  tmp___0 = js_has_sanity(ar);
#line 1199
  if (tmp___0 == -1) {
#line 1200
    return (-1);
  }
#line 1201
  if (ar->unit_size != 1U) {
#line 1202
    return (-1);
  }
#line 1205
  ar->unit_count = 0U;
#line 1210
  switch (qtype) {
  case 2: 
  case 5: 
#line 1213
  start = 0;
#line 1215
  length = (int )(qu->unit_count - (unsigned int )start);
#line 1216
  break;
  case 15: 
#line 1218
  start = 2;
#line 1220
  length = (int )(qu->unit_count - (unsigned int )start);
#line 1221
  break;
  default: 
#line 1224
  return (1);
  }
#line 1228
  tmp___1 = js_substr(qu, ar, start, length);
#line 1228
  if (tmp___1 == -1) {
#line 1229
    return (-1);
  }
#line 1233
  tmp___2 = js_addbyte(ar, (unsigned char)0);
#line 1233
  if (tmp___2 == -1) {
#line 1234
    return (-1);
  }
#line 1235
  tmp___3 = js_addbyte(ar, (unsigned char)1);
#line 1235
  if (tmp___3 == -1) {
#line 1236
    return (-1);
  }
#line 1238
  return (1);
}
}
#line 1269 "MaraBigHash.c"
int add_rr_to_bighash(mhash *bighash , js_string *query , js_string *data , uint32_t ttl ,
                      js_string *zone , uint16_t perms ) 
{ int label_len ;
  int has_authority ;
  int qtype ;
  mhash_e hash_spot ;
  rr *nukeme ;
  rr *point ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 1273
  has_authority = 0;
#line 1278
  tmp = js_has_sanity(query);
#line 1278
  if (tmp == -1) {
#line 1280
    return (-1);
  } else {
#line 1278
    tmp___0 = js_has_sanity(data);
#line 1278
    if (tmp___0 == -1) {
#line 1280
      return (-1);
    } else {
#line 1278
      tmp___1 = js_has_sanity(query);
#line 1278
      if (tmp___1 == -1) {
#line 1280
        return (-1);
      }
    }
  }
#line 1281
  if (query->unit_count < 3U) {
#line 1282
    return (-1);
  } else
#line 1281
  if (zone->unit_count < 3U) {
#line 1282
    return (-1);
  }
#line 1285
  qtype = get_rtype(query);
#line 1285
  if (qtype == -1) {
#line 1286
    return (-1);
  }
#line 1289
  if (qtype == 255) {
#line 1290
    return (-1);
  }
#line 1293
  if (qtype == 251) {
#line 1294
    return (-1);
  } else
#line 1293
  if (qtype == 252) {
#line 1294
    return (-1);
  }
#line 1297
  dns_records_served ++;
#line 1301
  tmp___2 = change_rtype(zone, qtype);
#line 1301
  if (tmp___2 == -1) {
#line 1302
    change_rtype(zone, 2);
#line 1303
    return (-1);
  }
#line 1307
  tmp___5 = js_issame(zone, query);
#line 1307
  if (tmp___5) {
#line 1308
    has_authority = 1;
  } else {
#line 1314
    tmp___4 = get_rtype(query);
#line 1314
    if (tmp___4 != 2) {
#line 1316
      label_len = -1;
#line 1318
      if ((int )*(query->string) != 95) {
#line 1318
        if ((int )*(query->string) < 64) {
#line 1319
          label_len = (int )*(query->string) + 1;
        } else {
#line 1318
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1320
      if ((int )*(query->string) == 95) {
#line 1321
        label_len = 1;
      } else {
#line 1323
        change_rtype(zone, 2);
#line 1324
        return (-1);
      }
#line 1328
      if (zone->unit_count == query->unit_count - (unsigned int )label_len) {
#line 1328
        tmp___3 = js_fgrep(zone, query);
#line 1328
        if (tmp___3 == label_len) {
#line 1330
          has_authority = 1;
        }
      }
    }
  }
#line 1338
  change_rtype(zone, 2);
#line 1340
  hash_spot = mhash_get(bighash, query);
#line 1343
  if ((unsigned long )hash_spot.value == (unsigned long )((void *)0)) {
#line 1345
    tmp___6 = mhash_put_rr(bighash, query, data, ttl, (uint32_t )has_authority, (uint32_t )0,
                           perms);
#line 1345
    if (tmp___6 == -1) {
#line 1347
      return (-1);
    }
#line 1348
    tmp___7 = mhash_add_ns(bighash, query, zone);
#line 1348
    if (tmp___7 == -1) {
#line 1349
      return (-1);
    }
#line 1350
    return (1);
  }
#line 1354
  if (hash_spot.datatype != 3) {
#line 1355
    return (-1);
  }
#line 1357
  point = (rr *)hash_spot.value;
#line 1365
  if (point->authoritative == 1U) {
#line 1365
    if (has_authority == 1) {
#line 1365
      goto _L___0;
    } else {
#line 1365
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1365
  if (point->authoritative == 0U) {
#line 1365
    if (has_authority == 0) {
      _L___0: /* CIL Label */ 
#line 1367
      tmp___8 = mhash_add_rr(bighash, query, data, ttl, (uint32_t )has_authority,
                             (uint32_t )0, perms);
#line 1367
      if (tmp___8 == -1) {
#line 1369
        return (-1);
      }
#line 1370
      return (1);
    }
  }
#line 1376
  if (point->authoritative == 0U) {
#line 1376
    if (has_authority == 1) {
#line 1381
      tmp___9 = mhash_undef(bighash, query);
#line 1381
      nukeme = (rr *)tmp___9;
#line 1382
      if ((unsigned long )nukeme == (unsigned long )((rr *)0)) {
#line 1383
        return (-1);
      }
#line 1386
      tmp___10 = any_zap_rr(bighash, query, nukeme);
#line 1386
      if (tmp___10 == -1) {
#line 1387
        return (-1);
      }
#line 1390
      tmp___11 = js_dealloc((void *)nukeme);
#line 1390
      if (tmp___11 == -1) {
#line 1391
        return (-1);
      }
#line 1394
      tmp___12 = mhash_put_rr(bighash, query, data, ttl, (uint32_t )has_authority,
                              (uint32_t )0, perms);
#line 1394
      if (tmp___12 == -1) {
#line 1396
        return (-1);
      }
#line 1397
      tmp___13 = mhash_add_ns(bighash, query, zone);
#line 1397
      if (tmp___13 == -1) {
#line 1398
        return (-1);
      }
#line 1399
      return (1);
    }
  }
#line 1405
  if (point->authoritative == 1U) {
#line 1405
    if (has_authority == 0) {
#line 1406
      return (1);
    }
  }
#line 1409
  return (-1);
}
}
#line 1 "read_kvars.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-SzuCc8j0.i","")
#line 45 "read_kvars.c"
int read_numeric_kvar(char *name , int default_value ) 
{ js_string *kvar_name ;
  js_string *kvar_value ;
  int ret ;
  int status ;
  int tmp ;
  unsigned int tmp___0 ;

  {
#line 50
  kvar_name = js_create(64U, 1U);
#line 50
  if ((unsigned long )kvar_name == (unsigned long )((js_string *)0)) {
#line 51
    printf("Aieeeeeee!\n");
#line 52
    exit(1);
#line 53
    return (-1);
  }
#line 56
  kvar_value = js_create(256U, 1U);
#line 56
  if ((unsigned long )kvar_value == (unsigned long )((js_string *)0)) {
#line 57
    printf("Aieeeeeeee!\n");
#line 58
    exit(1);
#line 59
    js_destroy(kvar_name);
#line 60
    return (-1);
  }
#line 63
  js_set_encode(kvar_name, 3);
#line 64
  js_set_encode(kvar_value, 3);
#line 66
  tmp = js_qstr2js(kvar_name, name);
#line 66
  if (tmp == -1) {
#line 67
    js_destroy(kvar_name);
#line 68
    js_destroy(kvar_value);
#line 69
    harderror((char *)"Could not create kvar_query");
  }
#line 72
  status = read_kvar(kvar_name, kvar_value);
#line 74
  if (status == -1) {
#line 75
    js_destroy(kvar_name);
#line 76
    js_destroy(kvar_value);
#line 77
    show_timestamp();
#line 78
    printf("%s%s\n", "Error processing value for ", name);
#line 79
    return (default_value);
  }
#line 82
  if (status == 0) {
#line 83
    js_destroy(kvar_name);
#line 84
    js_destroy(kvar_value);
#line 85
    return (default_value);
  }
#line 88
  tmp___0 = js_atoi(kvar_value, 0);
#line 88
  ret = (int )tmp___0;
#line 90
  js_destroy(kvar_name);
#line 91
  js_destroy(kvar_value);
#line 92
  return (ret);
}
}
#line 107 "read_kvars.c"
js_string *read_string_kvar(char *name ) 
{ js_string *kvar_name ;
  js_string *kvar_value ;
  int status ;
  int tmp ;

  {
#line 112
  kvar_name = js_create(64U, 1U);
#line 112
  if ((unsigned long )kvar_name == (unsigned long )((js_string *)0)) {
#line 113
    printf("Aiiieeeeeee!\n");
#line 114
    exit(1);
#line 115
    return ((js_string *)0);
  }
#line 118
  kvar_value = js_create(256U, 1U);
#line 118
  if ((unsigned long )kvar_value == (unsigned long )((js_string *)0)) {
#line 119
    printf("Aiiieeeeeeeeee!\n");
#line 120
    exit(1);
#line 121
    js_destroy(kvar_name);
#line 122
    return ((js_string *)0);
  }
#line 125
  js_set_encode(kvar_name, 3);
#line 126
  js_set_encode(kvar_value, 3);
#line 128
  tmp = js_qstr2js(kvar_name, name);
#line 128
  if (tmp == -1) {
#line 129
    js_destroy(kvar_name);
#line 130
    js_destroy(kvar_value);
#line 131
    harderror((char *)"Could not create kvar_query");
  }
#line 134
  status = read_kvar(kvar_name, kvar_value);
#line 136
  if (status == -1) {
#line 137
    js_destroy(kvar_name);
#line 138
    js_destroy(kvar_value);
#line 139
    show_timestamp();
#line 140
    printf("%s%s\n", "Error processing value for ", name);
#line 141
    return ((js_string *)0);
  }
#line 144
  if (status == 0) {
#line 145
    js_destroy(kvar_name);
#line 146
    js_destroy(kvar_value);
#line 147
    return ((js_string *)0);
  }
#line 150
  js_destroy(kvar_name);
#line 151
  return (kvar_value);
}
}
#line 1 "MaraAnyChain.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-lUPIa7A1.i","")
#line 35 "MaraAnyChain.c"
int any_add_rr(mhash *hash , js_string *query , rr *data ) 
{ int rrtype ;
  int a ;
  js_string *copy ;
  rr_list *point ;
  rr_list *new ;
  mhash_e get ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 43
  rrtype = get_rtype(query);
#line 45
  if (rrtype == -1) {
#line 46
    return (-1);
  }
#line 48
  if (rrtype < 0) {
#line 49
    return (-1);
  } else
#line 48
  if (rrtype > 65535) {
#line 49
    return (-1);
  }
#line 54
  copy = js_create(256U, 1U);
#line 54
  if ((unsigned long )copy == (unsigned long )((js_string *)0)) {
#line 55
    return (-1);
  }
#line 57
  tmp = js_copy(query, copy);
#line 57
  if (tmp == -1) {
#line 58
    js_destroy(copy);
#line 59
    return (-1);
  }
#line 61
  tmp___0 = change_rtype(copy, 255);
#line 61
  if (tmp___0 == -1) {
#line 62
    js_destroy(copy);
#line 63
    return (-1);
  }
#line 67
  tmp___1 = js_alloc(1, (int )sizeof(rr_list ));
#line 67
  new = (rr_list *)tmp___1;
#line 68
  if ((unsigned long )new == (unsigned long )((rr_list *)0)) {
#line 69
    js_destroy(copy);
#line 70
    return (-1);
  }
#line 73
  new->rr_type = (uint16_t )rrtype;
#line 74
  new->data = data;
#line 75
  new->next = (struct rr_list *)0;
#line 78
  get = mhash_get(hash, copy);
#line 82
  if ((unsigned long )get.value == (unsigned long )((void *)0)) {
#line 82
    if (get.datatype == 0) {
#line 83
      mhash_put(hash, copy, (void *)new, 6);
#line 84
      js_destroy(copy);
#line 85
      return (1);
    }
  }
#line 88
  js_destroy(copy);
#line 92
  if (get.datatype != 6) {
#line 93
    harderror((char *)"Data not MARA_DNS_LIST in ANY query in bighash");
  }
#line 96
  point = (rr_list *)get.value;
#line 97
  if ((unsigned long )point == (unsigned long )((rr_list *)0)) {
#line 98
    return (-1);
  }
#line 102
  a = 0;
#line 102
  while (a < 65000) {
#line 104
    if ((unsigned long )point->next == (unsigned long )((struct rr_list *)0)) {
#line 105
      break;
    }
#line 107
    point = point->next;
#line 102
    a ++;
  }
#line 110
  if ((unsigned long )point->next != (unsigned long )((struct rr_list *)0)) {
#line 111
    return (-1);
  }
#line 115
  point->next = new;
#line 116
  new->next = (struct rr_list *)0;
#line 117
  new->data = data;
#line 118
  return (1);
}
}
#line 123 "MaraAnyChain.c"
int any_add_c_rr(mhash *hash , js_string *query , rr *data ) 
{ int rrtype ;
  int tmp ;

  {
#line 125
  rrtype = get_rtype(query);
#line 126
  if (rrtype == 5) {
#line 127
    return (-1);
  }
#line 129
  tmp = any_add_rr(hash, query, data);
#line 129
  return (tmp);
}
}
#line 138 "MaraAnyChain.c"
int any_zap_rr(mhash *hash , js_string *query , rr *data ) 
{ int a ;
  js_string *copy ;
  mhash_e get ;
  rr_list *point ;
  rr_list *last ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 147
  copy = js_create(256U, 1U);
#line 147
  if ((unsigned long )copy == (unsigned long )((js_string *)0)) {
#line 148
    return (-1);
  }
#line 150
  tmp = js_copy(query, copy);
#line 150
  if (tmp == -1) {
#line 151
    js_destroy(copy);
#line 152
    return (-1);
  }
#line 154
  tmp___0 = change_rtype(copy, 255);
#line 154
  if (tmp___0 == -1) {
#line 155
    js_destroy(copy);
#line 156
    return (-1);
  }
#line 160
  get = mhash_get(hash, copy);
#line 162
  if ((unsigned long )get.value == (unsigned long )((void *)0)) {
#line 163
    js_destroy(copy);
#line 164
    return (1);
  } else
#line 162
  if (get.datatype == 0) {
#line 163
    js_destroy(copy);
#line 164
    return (1);
  }
#line 167
  point = (rr_list *)get.value;
#line 168
  last = (rr_list *)0;
#line 171
  if ((unsigned long )point->data == (unsigned long )data) {
#line 171
    if ((unsigned long )point->next == (unsigned long )((struct rr_list *)0)) {
#line 172
      tmp___1 = mhash_undef(hash, copy);
#line 172
      last = (rr_list *)tmp___1;
#line 173
      if ((unsigned long )last != (unsigned long )point) {
#line 174
        harderror((char *)"Line 166; mail the mailing list");
      }
#line 176
      js_dealloc((void *)last);
#line 177
      js_destroy(copy);
#line 178
      return (1);
    }
  }
#line 182
  if ((unsigned long )point->data == (unsigned long )data) {
#line 182
    if ((unsigned long )point->next != (unsigned long )((struct rr_list *)0)) {
#line 183
      tmp___2 = mhash_undef(hash, copy);
#line 183
      last = (rr_list *)tmp___2;
#line 184
      if ((unsigned long )last != (unsigned long )point) {
#line 185
        harderror((char *)"Line 177; mail the mailing list");
      }
#line 187
      point = point->next;
#line 188
      js_dealloc((void *)last);
#line 189
      mhash_put(hash, copy, (void *)point, 6);
#line 190
      js_destroy(copy);
#line 191
      return (1);
    }
  }
#line 194
  js_destroy(copy);
#line 197
  a = 0;
#line 197
  while (a < 65000) {
#line 198
    if ((unsigned long )point->next == (unsigned long )((struct rr_list *)0)) {
#line 199
      return (-2);
    }
#line 201
    last = point;
#line 202
    point = point->next;
#line 204
    if ((unsigned long )point->data == (unsigned long )data) {
#line 205
      last->next = point->next;
#line 206
      js_dealloc((void *)point);
#line 207
      return (1);
    }
#line 197
    a ++;
  }
#line 211
  return (-1);
}
}
#line 1 "libtcp.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-KWn2GhNX.i","")
#line 27 "libtcp.c"
int log_level  =    1;
#line 29 "libtcp.c"
ipv4pair *bind_addr_list  =    (ipv4pair *)0;
#line 30 "libtcp.c"
ipv4pair *synthip_addr_list  =    (ipv4pair *)0;
#line 34 "libtcp.c"
js_string *synth_soa_origin  =    (js_string *)0;
#line 35 "libtcp.c"
int synth_soa_serial  =    1;
#line 37 "libtcp.c"
js_string *show_synth_soa_origin(void) 
{ 

  {
#line 38
  return (synth_soa_origin);
}
}
#line 40 "libtcp.c"
int show_synth_soa_serial(void) 
{ 

  {
#line 41
  return (synth_soa_serial);
}
}
#line 46 "libtcp.c"
void set_soa_origin(js_string *in ) 
{ 

  {
#line 47
  synth_soa_origin = in;
#line 48
  return;
}
}
#line 49 "libtcp.c"
void set_soa_serial(int in ) 
{ 

  {
#line 50
  synth_soa_serial = in;
#line 51
  return;
}
}
#line 58 "libtcp.c"
ipv4pair *libtcp_bind_address(int type ) 
{ js_string *bind_address ;
  js_string *ipv4_bind_address ;
  js_string *synthip ;
  js_string *q ;
  ipv4pair *out ;
  int c ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 59
  bind_address = (js_string *)0;
#line 59
  ipv4_bind_address = (js_string *)0;
#line 59
  synthip = (js_string *)0;
#line 59
  q = (js_string *)0;
#line 62
  out = (ipv4pair *)0;
#line 66
  bind_address = read_string_kvar((char *)"bind_address");
#line 67
  ipv4_bind_address = read_string_kvar((char *)"ipv4_bind_addresses");
#line 68
  if (type == 2) {
#line 69
    synthip = read_string_kvar((char *)"csv2_synthip_list");
  }
#line 71
  tmp = js_alloc((int )sizeof(ipv4pair ), 512);
#line 71
  out = (ipv4pair *)tmp;
#line 71
  if ((unsigned long )out == (unsigned long )((ipv4pair *)0)) {
#line 72
    js_destroy(bind_address);
#line 73
    js_destroy(ipv4_bind_address);
#line 74
    js_destroy(synthip);
#line 75
    return ((ipv4pair *)0);
  }
#line 78
  c = 0;
#line 78
  while (c < 512) {
#line 79
    (out + c)->ip = 4294967295U;
#line 78
    c ++;
  }
#line 82
  q = bind_address;
#line 84
  tmp___0 = js_length(ipv4_bind_address);
#line 84
  if (tmp___0 > 0) {
#line 85
    q = ipv4_bind_address;
  }
#line 87
  if (type == 2) {
#line 87
    tmp___1 = js_length(synthip);
#line 87
    if (tmp___1 > 0) {
#line 88
      q = synthip;
    }
  }
#line 91
  tmp___2 = make_ip_acl(q, out, 500, 0);
#line 91
  if (tmp___2 == -1) {
#line 92
    js_destroy(bind_address);
#line 93
    js_destroy(ipv4_bind_address);
#line 94
    js_destroy(synthip);
#line 95
    js_dealloc((void *)out);
#line 96
    return ((ipv4pair *)0);
  }
#line 99
  js_destroy(bind_address);
#line 100
  js_destroy(ipv4_bind_address);
#line 101
  js_destroy(synthip);
#line 102
  return (out);
}
}
#line 110 "libtcp.c"
int libtcp_create_bind_addrs(void) 
{ 

  {
#line 111
  bind_addr_list = libtcp_bind_address(1);
#line 112
  synthip_addr_list = libtcp_bind_address(2);
#line 113
  if ((unsigned long )bind_addr_list == (unsigned long )((ipv4pair *)0)) {
#line 114
    return (-1);
  }
#line 116
  if ((unsigned long )synthip_addr_list == (unsigned long )((ipv4pair *)0)) {
#line 117
    return (-1);
  }
#line 119
  return (1);
}
}
#line 129 "libtcp.c"
ipv4pair *get_bind_addr_list(void) 
{ 

  {
#line 130
  return (bind_addr_list);
}
}
#line 133 "libtcp.c"
ipv4pair *get_synthip_list(void) 
{ 

  {
#line 134
  return (synthip_addr_list);
}
}
#line 144 "libtcp.c"
int fold_case(js_string *js ) 
{ int counter ;
  int ret ;

  {
#line 145
  counter = 0;
#line 146
  ret = 0;
#line 148
  if (js->max_count <= js->unit_count) {
#line 149
    return (-1);
  }
#line 151
  if (js->unit_size != 1U) {
#line 152
    return (-1);
  }
#line 154
  if (js->unit_count < 2U) {
#line 155
    return (-1);
  }
#line 157
  while ((unsigned int )(counter + 2) < js->unit_count) {
#line 160
    if ((int )*(js->string + counter) >= 65) {
#line 160
      if ((int )*(js->string + counter) <= 90) {
#line 162
        *(js->string + counter) = (unsigned char )((int )*(js->string + counter) + 32);
#line 163
        ret = 1;
      }
    }
#line 165
    counter ++;
  }
#line 168
  return (ret);
}
}
#line 1 "rng-api-fst.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-BGDLNpak.i","")
#line 57 "rng-alg-fst.h"
int rngKeySetupEnc(u32 *rk , u8 const   *cipherKey , int keyBits ) ;
#line 58
void rngEncrypt(u32 const   *rk , int Nr , u8 const   *pt , u8 *ct ) ;
#line 67 "rng-api-fst.c"
int makeKey(keyInstance *key___0 , MARA_BYTE direction , int keyLen , char *keyMaterial ) 
{ int i ;
  char *keyMat ;
  u8 cipherKey[32] ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int v ;

  {
#line 72
  if ((unsigned long )key___0 == (unsigned long )((void *)0)) {
#line 73
    return (-3);
  }
#line 76
  if ((int )direction == 0) {
#line 77
    key___0->direction = direction;
  } else {
#line 79
    return (-1);
  }
#line 82
  if (keyLen == 128) {
#line 83
    key___0->keyLen = keyLen;
  } else {
#line 85
    return (-2);
  }
#line 91
  tmp___0 = __builtin_object_size((void *)(key___0->keyMaterial), 0);
#line 91
  if (tmp___0 != 0xffffffffffffffffUL) {
#line 91
    tmp = __builtin_object_size((void *)(key___0->keyMaterial), 0);
#line 91
    __builtin___memcpy_chk((void *)(key___0->keyMaterial), (void const   *)keyMaterial,
                           (unsigned long )(keyLen / 8), tmp);
  } else {
#line 91
    __inline_memcpy_chk((void *)(key___0->keyMaterial), (void const   *)keyMaterial,
                        (size_t )(keyLen / 8));
  }
#line 95
  keyMat = key___0->keyMaterial;
#line 96
  i = 0;
#line 96
  while (i < key___0->keyLen / 8) {
#line 112
    v = (int )*keyMat;
#line 113
    keyMat ++;
#line 115
    cipherKey[i] = (u8 )v;
#line 96
    i ++;
  }
#line 117
  if ((int )direction == 0) {
#line 118
    key___0->Nr = rngKeySetupEnc(key___0->rk, (u8 const   *)(cipherKey), keyLen);
  } else {
#line 120
    return (-1);
  }
#line 122
  rngKeySetupEnc(key___0->ek, (u8 const   *)(cipherKey), keyLen);
#line 123
  return (1);
}
}
#line 126 "rng-api-fst.c"
int cipherInit(cipherInstance *cipher , MARA_BYTE mode , char *IV ) 
{ unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 127
  if ((int )mode == 1) {
#line 128
    cipher->mode = mode;
  } else {
#line 130
    return (-4);
  }
#line 132
  if ((unsigned long )IV != (unsigned long )((void *)0)) {
#line 133
    return (-4);
  } else {
#line 135
    tmp___0 = __builtin_object_size((void *)(cipher->IV), 0);
#line 135
    if (tmp___0 != 0xffffffffffffffffUL) {
#line 135
      tmp = __builtin_object_size((void *)(cipher->IV), 0);
#line 135
      __builtin___memset_chk((void *)(cipher->IV), 0, 16UL, tmp);
    } else {
#line 135
      __inline_memset_chk((void *)(cipher->IV), 0, (size_t )16);
    }
  }
#line 137
  return (1);
}
}
#line 140 "rng-api-fst.c"
int blockEncrypt(cipherInstance *cipher , keyInstance *key___0 , MARA_BYTE *input ,
                 int inputLen , MARA_BYTE *outBuffer ) 
{ int i ;
  int numBlocks ;

  {
#line 144
  if ((unsigned long )cipher == (unsigned long )((void *)0)) {
#line 147
    return (-5);
  } else
#line 144
  if ((unsigned long )key___0 == (unsigned long )((void *)0)) {
#line 147
    return (-5);
  } else
#line 144
  if ((int )key___0->direction == 1) {
#line 147
    return (-5);
  }
#line 149
  if ((unsigned long )input == (unsigned long )((void *)0)) {
#line 150
    return (0);
  } else
#line 149
  if (inputLen <= 0) {
#line 150
    return (0);
  }
#line 153
  numBlocks = inputLen / 128;
#line 155
  switch ((int )cipher->mode) {
  case 1: 
#line 157
  i = numBlocks;
#line 157
  while (i > 0) {
#line 158
    rngEncrypt((u32 const   *)(key___0->rk), key___0->Nr, (u8 const   *)input, (u8 *)outBuffer);
#line 159
    input += 16;
#line 160
    outBuffer += 16;
#line 157
    i --;
  }
#line 162
  break;
  default: 
#line 165
  return (-5);
  }
#line 168
  return (128 * numBlocks);
}
}
#line 1 "rng-alg-fst.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-3wI1t9B1.i","")
#line 3 "rng-32bit-tables.h"
static u32 const   Te0[256]  = 
#line 3 "rng-32bit-tables.h"
  {      (u32 const   )3017953435U,      (u32 const   )1672792582U,      (u32 const   )2246353620U,      (u32 const   )560743938U, 
        (u32 const   )980369320U,      (u32 const   )2786508149U,      (u32 const   )323814928U,      (u32 const   )1298184604U, 
        (u32 const   )392868941U,      (u32 const   )2135030158U,      (u32 const   )3799505551U,      (u32 const   )3454798025U, 
        (u32 const   )1510608337U,      (u32 const   )453212586U,      (u32 const   )2070301651U,      (u32 const   )2715875159U, 
        (u32 const   )4205140826U,      (u32 const   )3929646389U,      (u32 const   )3315758963U,      (u32 const   )2977696056U, 
        (u32 const   )539224030U,      (u32 const   )3564185792U,      (u32 const   )2089812465U,      (u32 const   )582860413U, 
        (u32 const   )3967831755U,      (u32 const   )3107092098U,      (u32 const   )3172320479U,      (u32 const   )3385571988U, 
        (u32 const   )2760434902U,      (u32 const   )21995996U,      (u32 const   )1617244793U,      (u32 const   )4269992199U, 
        (u32 const   )1960738379U,      (u32 const   )2833328433U,      (u32 const   )69710429U,      (u32 const   )3864029394U, 
        (u32 const   )2307747635U,      (u32 const   )2458785433U,      (u32 const   )302163916U,      (u32 const   )2049567247U, 
        (u32 const   )522505207U,      (u32 const   )1682079780U,      (u32 const   )3715167910U,      (u32 const   )3200531616U, 
        (u32 const   )755338213U,      (u32 const   )368373230U,      (u32 const   )1462526442U,      (u32 const   )485831560U, 
        (u32 const   )4185170725U,      (u32 const   )1078384039U,      (u32 const   )733765659U,      (u32 const   )3735097049U, 
        (u32 const   )1121487876U,      (u32 const   )2402583757U,      (u32 const   )1600265808U,      (u32 const   )2203928874U, 
        (u32 const   )4112346818U,      (u32 const   )798741062U,      (u32 const   )3213598076U,      (u32 const   )3994949480U, 
        (u32 const   )1812791198U,      (u32 const   )371529105U,      (u32 const   )927552403U,      (u32 const   )1555293743U, 
        (u32 const   )1057434665U,      (u32 const   )1272533602U,      (u32 const   )90706817U,      (u32 const   )2416987962U, 
        (u32 const   )64092287U,      (u32 const   )1380217451U,      (u32 const   )3577645340U,      (u32 const   )2596301091U, 
        (u32 const   )1368754708U,      (u32 const   )2438983398U,      (u32 const   )3756961541U,      (u32 const   )2046300784U, 
        (u32 const   )3536372542U,      (u32 const   )968804311U,      (u32 const   )1983916008U,      (u32 const   )1208527389U, 
        (u32 const   )3480375658U,      (u32 const   )647629856U,      (u32 const   )2872103246U,      (u32 const   )3260300625U, 
        (u32 const   )1997506100U,      (u32 const   )2695845515U,      (u32 const   )668315132U,      (u32 const   )1342103615U, 
        (u32 const   )3021216441U,      (u32 const   )2363849906U,      (u32 const   )720617927U,      (u32 const   )3687390552U, 
        (u32 const   )3606016355U,      (u32 const   )1020712022U,      (u32 const   )1531292685U,      (u32 const   )1044942325U, 
        (u32 const   )841039890U,      (u32 const   )3785761520U,      (u32 const   )2609891583U,      (u32 const   )1133981144U, 
        (u32 const   )3433277717U,      (u32 const   )678271076U,      (u32 const   )837859437U,      (u32 const   )882420716U, 
        (u32 const   )1932014697U,      (u32 const   )1876756449U,      (u32 const   )1747668419U,      (u32 const   )1725749639U, 
        (u32 const   )1449377846U,      (u32 const   )1660644314U,      (u32 const   )2507693243U,      (u32 const   )3877619982U, 
        (u32 const   )1919391157U,      (u32 const   )3411403575U,      (u32 const   )1576814579U,      (u32 const   )1895418902U, 
        (u32 const   )3062514458U,      (u32 const   )2177044617U,      (u32 const   )3838718321U,      (u32 const   )220621883U, 
        (u32 const   )2898697068U,      (u32 const   )2556309632U,      (u32 const   )3666263172U,      (u32 const   )1833131586U, 
        (u32 const   )1768221727U,      (u32 const   )112847870U,      (u32 const   )2225799944U,      (u32 const   )3135475453U, 
        (u32 const   )299065267U,      (u32 const   )0U,      (u32 const   )251106372U,      (u32 const   )4226480774U, 
        (u32 const   )3148623649U,      (u32 const   )1695359480U,      (u32 const   )2925052623U,      (u32 const   )2251643563U, 
        (u32 const   )1630180261U,      (u32 const   )4099067678U,      (u32 const   )1147234298U,      (u32 const   )2272983927U, 
        (u32 const   )4087645500U,      (u32 const   )2807635113U,      (u32 const   )2111807533U,      (u32 const   )1486115954U, 
        (u32 const   )2625209053U,      (u32 const   )3625510183U,      (u32 const   )862904782U,      (u32 const   )133581346U, 
        (u32 const   )2781299978U,      (u32 const   )2156704085U,      (u32 const   )3083199174U,      (u32 const   )4015109812U, 
        (u32 const   )906424911U,      (u32 const   )4291643611U,      (u32 const   )1437743177U,      (u32 const   )1811592636U, 
        (u32 const   )1320239587U,      (u32 const   )2390435089U,      (u32 const   )1790252128U,      (u32 const   )4250079608U, 
        (u32 const   )416448981U,      (u32 const   )3548865250U,      (u32 const   )4075496672U,      (u32 const   )3390718699U, 
        (u32 const   )3695138682U,      (u32 const   )2294468335U,      (u32 const   )2376785262U,      (u32 const   )43932067U, 
        (u32 const   )429727753U,      (u32 const   )2956175588U,      (u32 const   )151117414U,      (u32 const   )208260583U, 
        (u32 const   )263730584U,      (u32 const   )4152571745U,      (u32 const   )4140603069U,      (u32 const   )2025305004U, 
        (u32 const   )1972494231U,      (u32 const   )1229392833U,      (u32 const   )3850473645U,      (u32 const   )2548434200U, 
        (u32 const   )3617640639U,      (u32 const   )1251406782U,      (u32 const   )2678618786U,      (u32 const   )3924319562U, 
        (u32 const   )195004357U,      (u32 const   )1160693286U,      (u32 const   )3160040707U,      (u32 const   )3646375163U, 
        (u32 const   )2568065372U,      (u32 const   )2527700164U,      (u32 const   )1191132761U,      (u32 const   )1278154816U, 
        (u32 const   )2486697319U,      (u32 const   )3812129619U,      (u32 const   )1033467274U,      (u32 const   )3342610128U, 
        (u32 const   )743057977U,      (u32 const   )625734751U,      (u32 const   )603070369U,      (u32 const   )441243766U, 
        (u32 const   )3495336605U,      (u32 const   )3095254878U,      (u32 const   )498766420U,      (u32 const   )955344395U, 
        (u32 const   )2721124136U,      (u32 const   )1580056460U,      (u32 const   )1202757509U,      (u32 const   )347819058U, 
        (u32 const   )2846787821U,      (u32 const   )1356475336U,      (u32 const   )604263811U,      (u32 const   )3950380265U, 
        (u32 const   )3042687845U,      (u32 const   )510356011U,      (u32 const   )2182277366U,      (u32 const   )4047166623U, 
        (u32 const   )3234489586U,      (u32 const   )139362234U,      (u32 const   )2742988532U,      (u32 const   )903285296U, 
        (u32 const   )3989827351U,      (u32 const   )3773399852U,      (u32 const   )817830321U,      (u32 const   )2665995134U, 
        (u32 const   )3903323286U,      (u32 const   )2478946117U,      (u32 const   )4229738660U,      (u32 const   )2997743943U, 
        (u32 const   )278724207U,      (u32 const   )2911451824U,      (u32 const   )2937545491U,      (u32 const   )785675162U, 
        (u32 const   )1855104573U,      (u32 const   )2637570817U,      (u32 const   )4164616953U,      (u32 const   )3329462028U, 
        (u32 const   )3246769454U,      (u32 const   )3364100936U,      (u32 const   )1737717851U,      (u32 const   )2860478610U, 
        (u32 const   )1091138683U,      (u32 const   )3273366669U,      (u32 const   )1907781066U,      (u32 const   )2333292176U, 
        (u32 const   )3508091713U,      (u32 const   )1425906069U,      (u32 const   )3303921327U,      (u32 const   )2114869330U, 
        (u32 const   )991993460U,      (u32 const   )2321323852U,      (u32 const   )4034231619U,      (u32 const   )1507587502U, 
        (u32 const   )3460165814U,      (u32 const   )1393284023U,      (u32 const   )181413401U,      (u32 const   )690108856U};
#line 69 "rng-32bit-tables.h"
static u32 const   Te1[256]  = 
#line 69
  {      (u32 const   )2612257360U,      (u32 const   )107197642U,      (u32 const   )3565544610U,      (u32 const   )35744838U, 
        (u32 const   )2822401855U,      (u32 const   )1973819069U,      (u32 const   )269700358U,      (u32 const   )2622316729U, 
        (u32 const   )1293380276U,      (u32 const   )2390704633U,      (u32 const   )2413983706U,      (u32 const   )3385715720U, 
        (u32 const   )3512338957U,      (u32 const   )2853897081U,      (u32 const   )3548079691U,      (u32 const   )1470226679U, 
        (u32 const   )1526375771U,      (u32 const   )904542629U,      (u32 const   )1942332023U,      (u32 const   )951155721U, 
        (u32 const   )3726648295U,      (u32 const   )3235148072U,      (u32 const   )4051472385U,      (u32 const   )2099428798U, 
        (u32 const   )3421274190U,      (u32 const   )2193175158U,      (u32 const   )3753711044U,      (u32 const   )2496252858U, 
        (u32 const   )3601107172U,      (u32 const   )3691073441U,      (u32 const   )2036360498U,      (u32 const   )134120169U, 
        (u32 const   )1265950334U,      (u32 const   )833151273U,      (u32 const   )1560553394U,      (u32 const   )3538309224U, 
        (u32 const   )864652655U,      (u32 const   )2576518678U,      (u32 const   )3423732391U,      (u32 const   )259664362U, 
        (u32 const   )4146013387U,      (u32 const   )610550400U,      (u32 const   )2799530230U,      (u32 const   )2696856636U, 
        (u32 const   )3844933003U,      (u32 const   )3994416365U,      (u32 const   )3931581537U,      (u32 const   )2283599155U, 
        (u32 const   )637105315U,      (u32 const   )2806007509U,      (u32 const   )455851104U,      (u32 const   )3655246094U, 
        (u32 const   )71489676U,      (u32 const   )3448714372U,      (u32 const   )1348428318U,      (u32 const   )713252169U, 
        (u32 const   )3270843758U,      (u32 const   )1177525202U,      (u32 const   )2092927901U,      (u32 const   )1760435735U, 
        (u32 const   )2657881343U,      (u32 const   )2434147605U,      (u32 const   )2469874003U,      (u32 const   )794604518U, 
        (u32 const   )691996460U,      (u32 const   )1649138002U,      (u32 const   )2164615187U,      (u32 const   )982519887U, 
        (u32 const   )2130956792U,      (u32 const   )1800553586U,      (u32 const   )483737225U,      (u32 const   )597344361U, 
        (u32 const   )340891018U,      (u32 const   )3868286958U,      (u32 const   )98561711U,      (u32 const   )1887041554U, 
        (u32 const   )1054001347U,      (u32 const   )3610885831U,      (u32 const   )3900063783U,      (u32 const   )491260074U, 
        (u32 const   )1791980113U,      (u32 const   )539400716U,      (u32 const   )1319842001U,      (u32 const   )1371690045U, 
        (u32 const   )880217990U,      (u32 const   )2342563670U,      (u32 const   )4230469037U,      (u32 const   )1062207200U, 
        (u32 const   )3115586586U,      (u32 const   )2995578236U,      (u32 const   )3341480897U,      (u32 const   )1490798877U, 
        (u32 const   )1675030385U,      (u32 const   )1446827732U,      (u32 const   )224085420U,      (u32 const   )4114499725U, 
        (u32 const   )305275200U,      (u32 const   )4041319970U,      (u32 const   )4288384968U,      (u32 const   )3628308269U, 
        (u32 const   )365732777U,      (u32 const   )1680371096U,      (u32 const   )1831989432U,      (u32 const   )3962869931U, 
        (u32 const   )1769154612U,      (u32 const   )3782204679U,      (u32 const   )3278383949U,      (u32 const   )2271665369U, 
        (u32 const   )911631296U,      (u32 const   )3663919979U,      (u32 const   )3147135068U,      (u32 const   )250027977U, 
        (u32 const   )3044173717U,      (u32 const   )936072675U,      (u32 const   )4083022919U,      (u32 const   )376502732U, 
        (u32 const   )448170563U,      (u32 const   )2306982672U,      (u32 const   )1910820401U,      (u32 const   )990717548U, 
        (u32 const   )1823262363U,      (u32 const   )2157469232U,      (u32 const   )2228913852U,      (u32 const   )1114456926U, 
        (u32 const   )527000812U,      (u32 const   )4261853675U,      (u32 const   )142912259U,      (u32 const   )4256883598U, 
        (u32 const   )3004289887U,      (u32 const   )0U,      (u32 const   )1141831572U,      (u32 const   )2264656634U, 
        (u32 const   )565947439U,      (u32 const   )4167372065U,      (u32 const   )3484309698U,      (u32 const   )2877699418U, 
        (u32 const   )2774608531U,      (u32 const   )519328463U,      (u32 const   )4198785383U,      (u32 const   )2005367547U, 
        (u32 const   )1022600325U,      (u32 const   )2846316828U,      (u32 const   )763223968U,      (u32 const   )1918407764U, 
        (u32 const   )3718019458U,      (u32 const   )668473573U,      (u32 const   )3459477217U,      (u32 const   )570947146U, 
        (u32 const   )178636613U,      (u32 const   )1434487985U,      (u32 const   )3333932514U,      (u32 const   )3035582902U, 
        (u32 const   )1328940786U,      (u32 const   )3690974536U,      (u32 const   )1230352952U,      (u32 const   )3161193141U, 
        (u32 const   )3813585217U,      (u32 const   )294550309U,      (u32 const   )1617605908U,      (u32 const   )2029867793U, 
        (u32 const   )3575173761U,      (u32 const   )3805513570U,      (u32 const   )3774016292U,      (u32 const   )3955890754U, 
        (u32 const   )2061254487U,      (u32 const   )4018717390U,      (u32 const   )1854778077U,      (u32 const   )2734857817U, 
        (u32 const   )152673568U,      (u32 const   )3836752808U,      (u32 const   )1711866334U,      (u32 const   )3876350413U, 
        (u32 const   )2551167029U,      (u32 const   )1643610935U,      (u32 const   )3187068054U,      (u32 const   )2893592499U, 
        (u32 const   )2541064671U,      (u32 const   )3242805003U,      (u32 const   )2917499280U,      (u32 const   )412608005U, 
        (u32 const   )3218579664U,      (u32 const   )3192559347U,      (u32 const   )2728372346U,      (u32 const   )1256843357U, 
        (u32 const   )3305873287U,      (u32 const   )642068166U,      (u32 const   )62675557U,      (u32 const   )4225324868U, 
        (u32 const   )1553535377U,      (u32 const   )3298208164U,      (u32 const   )1497825086U,      (u32 const   )1078734616U, 
        (u32 const   )1737766909U,      (u32 const   )1407400059U,      (u32 const   )2319292789U,      (u32 const   )3502717998U, 
        (u32 const   )959203882U,      (u32 const   )1596279796U,      (u32 const   )2703487519U,      (u32 const   )1981435096U, 
        (u32 const   )2647676570U,      (u32 const   )1589149143U,      (u32 const   )1411234450U,      (u32 const   )188281190U, 
        (u32 const   )681718031U,      (u32 const   )2354982335U,      (u32 const   )2236067999U,      (u32 const   )840219468U, 
        (u32 const   )3987320456U,      (u32 const   )3360741931U,      (u32 const   )2200175701U,      (u32 const   )3924522500U, 
        (u32 const   )1706384315U,      (u32 const   )723413866U,      (u32 const   )4135719656U,      (u32 const   )2683386588U, 
        (u32 const   )4072720996U,      (u32 const   )3121106559U,      (u32 const   )4104355502U,      (u32 const   )808834826U, 
        (u32 const   )401461231U,      (u32 const   )752937347U,      (u32 const   )2972761881U,      (u32 const   )2124343259U, 
        (u32 const   )2531829756U,      (u32 const   )1167311287U,      (u32 const   )2767985840U,      (u32 const   )1202892273U, 
        (u32 const   )1863359742U,      (u32 const   )2964162874U,      (u32 const   )330241891U,      (u32 const   )2586760307U, 
        (u32 const   )1030656678U,      (u32 const   )27080227U,      (u32 const   )4193794818U,      (u32 const   )214332303U, 
        (u32 const   )784434629U,      (u32 const   )1221100571U,      (u32 const   )1533514616U,      (u32 const   )2460647280U, 
        (u32 const   )2067859828U,      (u32 const   )2378374044U,      (u32 const   )3396449901U,      (u32 const   )2425033526U, 
        (u32 const   )1104222523U,      (u32 const   )2505375129U,      (u32 const   )2948918742U,      (u32 const   )1383992920U, 
        (u32 const   )1950032030U,      (u32 const   )1284136087U,      (u32 const   )1139832189U,      (u32 const   )2925124597U, 
        (u32 const   )3066969584U,      (u32 const   )3075673043U,      (u32 const   )420139046U,      (u32 const   )3089703481U};
#line 135 "rng-32bit-tables.h"
static u32 const   Te2[256]  = 
#line 135
  {      (u32 const   )1352381410U,      (u32 const   )3389416372U,      (u32 const   )2731836900U,      (u32 const   )1174544748U, 
        (u32 const   )1067989615U,      (u32 const   )3178604054U,      (u32 const   )101716813U,      (u32 const   )3114028384U, 
        (u32 const   )3024951146U,      (u32 const   )4186865473U,      (u32 const   )3666862711U,      (u32 const   )147443180U, 
        (u32 const   )231823882U,      (u32 const   )2041191171U,      (u32 const   )1272150886U,      (u32 const   )4149715424U, 
        (u32 const   )1532689061U,      (u32 const   )2771774009U,      (u32 const   )2004075938U,      (u32 const   )154710396U, 
        (u32 const   )3890094115U,      (u32 const   )683725937U,      (u32 const   )32603280U,      (u32 const   )3195871933U, 
        (u32 const   )1321987200U,      (u32 const   )1988278578U,      (u32 const   )3302997269U,      (u32 const   )3130313163U, 
        (u32 const   )3839272072U,      (u32 const   )2715550031U,      (u32 const   )846815333U,      (u32 const   )3909615234U, 
        (u32 const   )2118874334U,      (u32 const   )691120353U,      (u32 const   )2992440359U,      (u32 const   )1758651984U, 
        (u32 const   )1865648525U,      (u32 const   )379163278U,      (u32 const   )2815169026U,      (u32 const   )3926882857U, 
        (u32 const   )3421970212U,      (u32 const   )2149868610U,      (u32 const   )4138130800U,      (u32 const   )1017167556U, 
        (u32 const   )2347052293U,      (u32 const   )3991803380U,      (u32 const   )1642747692U,      (u32 const   )864558325U, 
        (u32 const   )2737174900U,      (u32 const   )3584507974U,      (u32 const   )1612393404U,      (u32 const   )249159329U, 
        (u32 const   )2349089496U,      (u32 const   )2228064052U,      (u32 const   )508583778U,      (u32 const   )1227522909U, 
        (u32 const   )1858270493U,      (u32 const   )3527815067U,      (u32 const   )2642198411U,      (u32 const   )392752670U, 
        (u32 const   )4288572428U,      (u32 const   )361829925U,      (u32 const   )1402156873U,      (u32 const   )3861863603U, 
        (u32 const   )740900615U,      (u32 const   )1382173657U,      (u32 const   )327222632U,      (u32 const   )1329238032U, 
        (u32 const   )4169073617U,      (u32 const   )1919636036U,      (u32 const   )2300368190U,      (u32 const   )1763941056U, 
        (u32 const   )2316587413U,      (u32 const   )4008087903U,      (u32 const   )2936397806U,      (u32 const   )309361144U, 
        (u32 const   )3275674312U,      (u32 const   )3352771006U,      (u32 const   )669546048U,      (u32 const   )2854045704U, 
        (u32 const   )1365954418U,      (u32 const   )203433626U,      (u32 const   )3511593776U,      (u32 const   )1028768340U, 
        (u32 const   )2251585295U,      (u32 const   )1451991215U,      (u32 const   )2918983637U,      (u32 const   )3762245630U, 
        (u32 const   )448377876U,      (u32 const   )2092076261U,      (u32 const   )3251055347U,      (u32 const   )492362697U, 
        (u32 const   )1902368495U,      (u32 const   )3562421462U,      (u32 const   )2886556485U,      (u32 const   )2381659720U, 
        (u32 const   )1074934305U,      (u32 const   )586211750U,      (u32 const   )3372194703U,      (u32 const   )769147799U, 
        (u32 const   )2836778147U,      (u32 const   )2556700781U,      (u32 const   )3094163952U,      (u32 const   )2884383896U, 
        (u32 const   )879325992U,      (u32 const   )132214749U,      (u32 const   )1304651819U,      (u32 const   )3649529564U, 
        (u32 const   )3224786531U,      (u32 const   )1809474299U,      (u32 const   )1555797368U,      (u32 const   )3373197087U, 
        (u32 const   )2511696487U,      (u32 const   )3812084565U,      (u32 const   )1207131644U,      (u32 const   )3424022777U, 
        (u32 const   )1125824138U,      (u32 const   )277447107U,      (u32 const   )829547726U,      (u32 const   )1815809318U, 
        (u32 const   )2607590598U,      (u32 const   )813733982U,      (u32 const   )3162823302U,      (u32 const   )1581411651U, 
        (u32 const   )3961481572U,      (u32 const   )3959293625U,      (u32 const   )50889899U,      (u32 const   )2398993123U, 
        (u32 const   )1605571027U,      (u32 const   )0U,      (u32 const   )2487488247U,      (u32 const   )4203150314U, 
        (u32 const   )790739884U,      (u32 const   )569926925U,      (u32 const   )3268390488U,      (u32 const   )1521190453U, 
        (u32 const   )2477089066U,      (u32 const   )3474912338U,      (u32 const   )1744454753U,      (u32 const   )4218914682U, 
        (u32 const   )2235364260U,      (u32 const   )480880473U,      (u32 const   )2687335903U,      (u32 const   )1416779924U, 
        (u32 const   )2195561593U,      (u32 const   )3844593688U,      (u32 const   )3788387182U,      (u32 const   )1243744246U, 
        (u32 const   )1158325703U,      (u32 const   )2975170700U,      (u32 const   )3804673989U,      (u32 const   )3065311057U, 
        (u32 const   )4065277446U,      (u32 const   )1222377421U,      (u32 const   )944330162U,      (u32 const   )3049024506U, 
        (u32 const   )1105415857U,      (u32 const   )621907579U,      (u32 const   )341863093U,      (u32 const   )293141843U, 
        (u32 const   )2178226386U,      (u32 const   )1659032455U,      (u32 const   )618722027U,      (u32 const   )1122748954U, 
        (u32 const   )1467669567U,      (u32 const   )3471804610U,      (u32 const   )3715009962U,      (u32 const   )1503855262U, 
        (u32 const   )537467293U,      (u32 const   )2833559603U,      (u32 const   )3731228929U,      (u32 const   )3454471273U, 
        (u32 const   )899157944U,      (u32 const   )929167235U,      (u32 const   )2529031884U,      (u32 const   )3014424759U, 
        (u32 const   )3751245201U,      (u32 const   )197216583U,      (u32 const   )2427315585U,      (u32 const   )85497830U, 
        (u32 const   )3502233504U,      (u32 const   )4089334422U,      (u32 const   )2057478056U,      (u32 const   )1565190632U, 
        (u32 const   )2277837727U,      (u32 const   )3324396846U,      (u32 const   )1694743642U,      (u32 const   )1157355863U, 
        (u32 const   )2438764817U,      (u32 const   )2764347049U,      (u32 const   )1046038271U,      (u32 const   )406866991U, 
        (u32 const   )4251423799U,      (u32 const   )2069095224U,      (u32 const   )1971994009U,      (u32 const   )785434428U, 
        (u32 const   )708389962U,      (u32 const   )4099876171U,      (u32 const   )530654194U,      (u32 const   )3631618636U, 
        (u32 const   )2594033750U,      (u32 const   )3613309053U,      (u32 const   )2454986170U,      (u32 const   )1712011505U, 
        (u32 const   )254321201U,      (u32 const   )3213647405U,      (u32 const   )2676311984U,      (u32 const   )1278350523U, 
        (u32 const   )2297276846U,      (u32 const   )734548186U,      (u32 const   )1434657796U,      (u32 const   )82439030U, 
        (u32 const   )3144004955U,      (u32 const   )1781210731U,      (u32 const   )3908469266U,      (u32 const   )3701469498U, 
        (u32 const   )1693630666U,      (u32 const   )2142898254U,      (u32 const   )2935268222U,      (u32 const   )170931671U, 
        (u32 const   )4011322831U,      (u32 const   )2200756457U,      (u32 const   )431042751U,      (u32 const   )3682508519U, 
        (u32 const   )4237748391U,      (u32 const   )3074790337U,      (u32 const   )2963602460U,      (u32 const   )4048007853U, 
        (u32 const   )4268691612U,      (u32 const   )984657289U,      (u32 const   )1662234391U,      (u32 const   )1939484372U, 
        (u32 const   )2789043858U,      (u32 const   )587308342U,      (u32 const   )49936443U,      (u32 const   )2399979123U, 
        (u32 const   )3308175749U,      (u32 const   )457754756U,      (u32 const   )2019256211U,      (u32 const   )1888660095U, 
        (u32 const   )1954234633U,      (u32 const   )2626536219U,      (u32 const   )1841983926U,      (u32 const   )915442451U, 
        (u32 const   )994169113U,      (u32 const   )2576700669U,      (u32 const   )3601843437U,      (u32 const   )1481801230U, 
        (u32 const   )2658417440U,      (u32 const   )2538375772U,      (u32 const   )2101604469U,      (u32 const   )4121844187U, 
        (u32 const   )4038512189U,      (u32 const   )3552006923U,      (u32 const   )639175376U,      (u32 const   )968370466U};
#line 201 "rng-32bit-tables.h"
static u32 const   Te3[256]  = 
#line 201
  {      (u32 const   )3796933555U,      (u32 const   )3033138787U,      (u32 const   )3835876485U,      (u32 const   )1816527393U, 
        (u32 const   )1866442810U,      (u32 const   )381515174U,      (u32 const   )1292242963U,      (u32 const   )1622776909U, 
        (u32 const   )1790201111U,      (u32 const   )1106873983U,      (u32 const   )2010812386U,      (u32 const   )3959998925U, 
        (u32 const   )168677722U,      (u32 const   )58305051U,      (u32 const   )1716245371U,      (u32 const   )3774306209U, 
        (u32 const   )2774227706U,      (u32 const   )967128554U,      (u32 const   )2725737413U,      (u32 const   )2080979121U, 
        (u32 const   )602398240U,      (u32 const   )1898496212U,      (u32 const   )2416046460U,      (u32 const   )3183377698U, 
        (u32 const   )2152647660U,      (u32 const   )846627513U,      (u32 const   )365223869U,      (u32 const   )3418002633U, 
        (u32 const   )2296698532U,      (u32 const   )1336007681U,      (u32 const   )1697806688U,      (u32 const   )2196310014U, 
        (u32 const   )3732818804U,      (u32 const   )3777573288U,      (u32 const   )666000644U,      (u32 const   )1349047014U, 
        (u32 const   )2372875145U,      (u32 const   )2383845778U,      (u32 const   )44551186U,      (u32 const   )703205242U, 
        (u32 const   )617346847U,      (u32 const   )1115694180U,      (u32 const   )1895212765U,      (u32 const   )3292307646U, 
        (u32 const   )93054253U,      (u32 const   )4109233685U,      (u32 const   )744614487U,      (u32 const   )4113795100U, 
        (u32 const   )1956849145U,      (u32 const   )1188407104U,      (u32 const   )3160415019U,      (u32 const   )2702105054U, 
        (u32 const   )3633054786U,      (u32 const   )881118607U,      (u32 const   )1646153823U,      (u32 const   )1565076099U, 
        (u32 const   )493798133U,      (u32 const   )2614249007U,      (u32 const   )2342354111U,      (u32 const   )504850670U, 
        (u32 const   )218078828U,      (u32 const   )622170390U,      (u32 const   )1230213943U,      (u32 const   )3018207068U, 
        (u32 const   )120334655U,      (u32 const   )3646054987U,      (u32 const   )1746108677U,      (u32 const   )273627792U, 
        (u32 const   )3522723587U,      (u32 const   )1148349266U,      (u32 const   )1049173205U,      (u32 const   )3228115866U, 
        (u32 const   )2508854353U,      (u32 const   )1609492113U,      (u32 const   )4004447711U,      (u32 const   )4161958009U, 
        (u32 const   )3368238802U,      (u32 const   )3200767801U,      (u32 const   )1076357238U,      (u32 const   )145366344U, 
        (u32 const   )1917938383U,      (u32 const   )2584485926U,      (u32 const   )819023531U,      (u32 const   )1413304770U, 
        (u32 const   )260453495U,      (u32 const   )2941684640U,      (u32 const   )3584949287U,      (u32 const   )4276109135U, 
        (u32 const   )337295796U,      (u32 const   )3850154636U,      (u32 const   )4089562922U,      (u32 const   )3374143707U, 
        (u32 const   )4017185750U,      (u32 const   )3604239932U,      (u32 const   )1168903515U,      (u32 const   )1217262910U, 
        (u32 const   )557847090U,      (u32 const   )2787307745U,      (u32 const   )2412314523U,      (u32 const   )2536364099U, 
        (u32 const   )2745767372U,      (u32 const   )1838703656U,      (u32 const   )4038618417U,      (u32 const   )2561403956U, 
        (u32 const   )674523507U,      (u32 const   )3708281199U,      (u32 const   )726516584U,      (u32 const   )3705243494U, 
        (u32 const   )1673541206U,      (u32 const   )4218149474U,      (u32 const   )2019343253U,      (u32 const   )533270247U, 
        (u32 const   )1737864562U,      (u32 const   )1440954315U,      (u32 const   )4232573789U,      (u32 const   )4190901872U, 
        (u32 const   )2319653558U,      (u32 const   )3272640897U,      (u32 const   )3459346916U,      (u32 const   )644627213U, 
        (u32 const   )3332074668U,      (u32 const   )1580236952U,      (u32 const   )2260501722U,      (u32 const   )1130250861U, 
        (u32 const   )1693196137U,      (u32 const   )3119250950U,      (u32 const   )2869102724U,      (u32 const   )3817799098U, 
        (u32 const   )3546264337U,      (u32 const   )0U,      (u32 const   )4153689102U,      (u32 const   )3942287099U, 
        (u32 const   )2888769979U,      (u32 const   )220330085U,      (u32 const   )1489162158U,      (u32 const   )895134598U, 
        (u32 const   )714319201U,      (u32 const   )1389305588U,      (u32 const   )1634204228U,      (u32 const   )2063300487U, 
        (u32 const   )2760195315U,      (u32 const   )1495050663U,      (u32 const   )3751816573U,      (u32 const   )2488562264U, 
        (u32 const   )2038619548U,      (u32 const   )417671128U,      (u32 const   )1860292147U,      (u32 const   )4132053511U, 
        (u32 const   )3343190693U,      (u32 const   )2360432000U,      (u32 const   )3319973559U,      (u32 const   )1370928367U, 
        (u32 const   )116543286U,      (u32 const   )3444104191U,      (u32 const   )2990033237U,      (u32 const   )4206214251U, 
        (u32 const   )2973885262U,      (u32 const   )2066026894U,      (u32 const   )3038011498U,      (u32 const   )1393654013U, 
        (u32 const   )3531724056U,      (u32 const   )2271404755U,      (u32 const   )3945062642U,      (u32 const   )440593354U, 
        (u32 const   )1062697692U,      (u32 const   )3268341640U,      (u32 const   )2866638477U,      (u32 const   )2656674562U, 
        (u32 const   )2636122393U,      (u32 const   )866706608U,      (u32 const   )31352329U,      (u32 const   )1775101708U, 
        (u32 const   )3090520079U,      (u32 const   )2201444855U,      (u32 const   )3432431094U,      (u32 const   )3082005624U, 
        (u32 const   )2447349621U,      (u32 const   )1191952713U,      (u32 const   )2173742565U,      (u32 const   )3859093655U, 
        (u32 const   )2698035159U,      (u32 const   )2532556362U,      (u32 const   )2826609311U,      (u32 const   )3898428137U, 
        (u32 const   )2676475147U,      (u32 const   )784737861U,      (u32 const   )1516569532U,      (u32 const   )1464138713U, 
        (u32 const   )294739097U,      (u32 const   )2846147734U,      (u32 const   )4282276166U,      (u32 const   )790118476U, 
        (u32 const   )939354004U,      (u32 const   )947606499U,      (u32 const   )2574617149U,      (u32 const   )1009701063U, 
        (u32 const   )1244281132U,      (u32 const   )1274306341U,      (u32 const   )4062159139U,      (u32 const   )1289254426U, 
        (u32 const   )1452973520U,      (u32 const   )2111266488U,      (u32 const   )3130151965U,      (u32 const   )4049996600U, 
        (u32 const   )823077026U,      (u32 const   )767528030U,      (u32 const   )2963244359U,      (u32 const   )3142332948U, 
        (u32 const   )2928209321U,      (u32 const   )3660302416U,      (u32 const   )72712996U,      (u32 const   )1980033515U, 
        (u32 const   )1539007925U,      (u32 const   )1802119966U,      (u32 const   )317257346U,      (u32 const   )987537393U, 
        (u32 const   )3395613376U,      (u32 const   )1316993544U,      (u32 const   )2125395107U,      (u32 const   )3607769141U, 
        (u32 const   )3488552941U,      (u32 const   )3917688032U,      (u32 const   )3206132016U,      (u32 const   )3889921694U, 
        (u32 const   )2818348776U,      (u32 const   )3250013587U,      (u32 const   )481338620U,      (u32 const   )2918270898U, 
        (u32 const   )2633920272U,      (u32 const   )2302324909U,      (u32 const   )392369071U,      (u32 const   )3564345902U, 
        (u32 const   )2460368238U,      (u32 const   )908263837U,      (u32 const   )990050808U,      (u32 const   )1938754758U, 
        (u32 const   )2244292289U,      (u32 const   )2216380616U,      (u32 const   )2474138471U,      (u32 const   )2138084010U, 
        (u32 const   )158628673U,      (u32 const   )463244739U,      (u32 const   )3060648561U,      (u32 const   )322343051U, 
        (u32 const   )423313873U,      (u32 const   )4254700884U,      (u32 const   )3990269892U,      (u32 const   )240669310U, 
        (u32 const   )547255355U,      (u32 const   )1553419402U,      (u32 const   )1971143664U,      (u32 const   )3690311257U, 
        (u32 const   )1039185614U,      (u32 const   )198424403U,      (u32 const   )3492157706U,      (u32 const   )574208041U};
#line 267 "rng-32bit-tables.h"
static u32 const   Te4[256]  = 
#line 267
  {      (u32 const   )404232216U,      (u32 const   )589505315U,      (u32 const   )3334915782U,      (u32 const   )3907578088U, 
        (u32 const   )2273806215U,      (u32 const   )3099113656U,      (u32 const   )16843009U,      (u32 const   )1330597711U, 
        (u32 const   )909522486U,      (u32 const   )2795939494U,      (u32 const   )3537031890U,      (u32 const   )4126537205U, 
        (u32 const   )2038004089U,      (u32 const   )1869573999U,      (u32 const   )2442236305U,      (u32 const   )1381126738U, 
        (u32 const   )1616928864U,      (u32 const   )3166485692U,      (u32 const   )2610666395U,      (u32 const   )2391707278U, 
        (u32 const   )2745410467U,      (u32 const   )202116108U,      (u32 const   )2071690107U,      (u32 const   )892679477U, 
        (u32 const   )488447261U,      (u32 const   )3772834016U,      (u32 const   )3621246935U,      (u32 const   )3267543746U, 
        (u32 const   )774778414U,      (u32 const   )1263225675U,      (u32 const   )4278124286U,      (u32 const   )1465341783U, 
        (u32 const   )353703189U,      (u32 const   )2004318071U,      (u32 const   )926365495U,      (u32 const   )3857049061U, 
        (u32 const   )2678038431U,      (u32 const   )4042322160U,      (u32 const   )1246382666U,      (u32 const   )3671775962U, 
        (u32 const   )1482184792U,      (u32 const   )3385444809U,      (u32 const   )690563369U,      (u32 const   )168430090U, 
        (u32 const   )2981212593U,      (u32 const   )2694881440U,      (u32 const   )1802201963U,      (u32 const   )2240120197U, 
        (u32 const   )3183328701U,      (u32 const   )1566399837U,      (u32 const   )269488144U,      (u32 const   )4109694196U, 
        (u32 const   )3419130827U,      (u32 const   )1044266558U,      (u32 const   )84215045U,      (u32 const   )1734829927U, 
        (u32 const   )3840206052U,      (u32 const   )656877351U,      (u32 const   )1094795585U,      (u32 const   )2341178251U, 
        (u32 const   )2812782503U,      (u32 const   )2105376125U,      (u32 const   )2509608341U,      (u32 const   )3638089944U, 
        (u32 const   )4227595259U,      (u32 const   )4008636142U,      (u32 const   )2088533116U,      (u32 const   )1717986918U, 
        (u32 const   )3722304989U,      (u32 const   )387389207U,      (u32 const   )1195853639U,      (u32 const   )2661195422U, 
        (u32 const   )3402287818U,      (u32 const   )757935405U,      (u32 const   )3217014719U,      (u32 const   )117901063U, 
        (u32 const   )2913840557U,      (u32 const   )1515870810U,      (u32 const   )2206434179U,      (u32 const   )858993459U, 
        (u32 const   )1667457891U,      (u32 const   )33686018U,      (u32 const   )2863311530U,      (u32 const   )1903260017U, 
        (u32 const   )3368601800U,      (u32 const   )421075225U,      (u32 const   )1229539657U,      (u32 const   )3654932953U, 
        (u32 const   )4076008178U,      (u32 const   )3823363043U,      (u32 const   )1532713819U,      (u32 const   )2290649224U, 
        (u32 const   )2593823386U,      (u32 const   )640034342U,      (u32 const   )842150450U,      (u32 const   )2964369584U, 
        (u32 const   )3924421097U,      (u32 const   )252645135U,      (u32 const   )3587560917U,      (u32 const   )2155905152U, 
        (u32 const   )3200171710U,      (u32 const   )3452816845U,      (u32 const   )875836468U,      (u32 const   )1212696648U, 
        (u32 const   )4294967295U,      (u32 const   )2054847098U,      (u32 const   )2425393296U,      (u32 const   )1600085855U, 
        (u32 const   )538976288U,      (u32 const   )1751672936U,      (u32 const   )437918234U,      (u32 const   )2930683566U, 
        (u32 const   )3031741620U,      (u32 const   )1414812756U,      (u32 const   )2475922323U,      (u32 const   )572662306U, 
        (u32 const   )1684300900U,      (u32 const   )4059165169U,      (u32 const   )1936946035U,      (u32 const   )303174162U, 
        (u32 const   )1077952576U,      (u32 const   )134744072U,      (u32 const   )3284386755U,      (u32 const   )3974950124U, 
        (u32 const   )3688618971U,      (u32 const   )2711724449U,      (u32 const   )2374864269U,      (u32 const   )1027423549U, 
        (u32 const   )2543294359U,      (u32 const   )0U,      (u32 const   )3486502863U,      (u32 const   )724249387U, 
        (u32 const   )1987475062U,      (u32 const   )2189591170U,      (u32 const   )3604403926U,      (u32 const   )454761243U, 
        (u32 const   )3048584629U,      (u32 const   )2947526575U,      (u32 const   )1785358954U,      (u32 const   )1347440720U, 
        (u32 const   )1162167621U,      (u32 const   )4092851187U,      (u32 const   )808464432U,      (u32 const   )4025479151U, 
        (u32 const   )1061109567U,      (u32 const   )1431655765U,      (u32 const   )2728567458U,      (u32 const   )3941264106U, 
        (u32 const   )1701143909U,      (u32 const   )3132799674U,      (u32 const   )791621423U,      (u32 const   )3233857728U, 
        (u32 const   )3739147998U,      (u32 const   )471604252U,      (u32 const   )4261281277U,      (u32 const   )1296911693U, 
        (u32 const   )2459079314U,      (u32 const   )1970632053U,      (u32 const   )101058054U,      (u32 const   )2324335242U, 
        (u32 const   )2998055602U,      (u32 const   )3873892070U,      (u32 const   )235802126U,      (u32 const   )522133279U, 
        (u32 const   )1650614882U,      (u32 const   )3570717908U,      (u32 const   )2829625512U,      (u32 const   )2526451350U, 
        (u32 const   )4193909241U,      (u32 const   )3318072773U,      (u32 const   )623191333U,      (u32 const   )1499027801U, 
        (u32 const   )2223277188U,      (u32 const   )1920103026U,      (u32 const   )960051513U,      (u32 const   )1280068684U, 
        (u32 const   )1583242846U,      (u32 const   )2021161080U,      (u32 const   )943208504U,      (u32 const   )2358021260U, 
        (u32 const   )3520188881U,      (u32 const   )2779096485U,      (u32 const   )3806520034U,      (u32 const   )1633771873U, 
        (u32 const   )3014898611U,      (u32 const   )555819297U,      (u32 const   )2627509404U,      (u32 const   )505290270U, 
        (u32 const   )1128481603U,      (u32 const   )3351758791U,      (u32 const   )4244438268U,      (u32 const   )67372036U, 
        (u32 const   )1364283729U,      (u32 const   )2576980377U,      (u32 const   )1835887981U,      (u32 const   )218959117U, 
        (u32 const   )4210752250U,      (u32 const   )3755991007U,      (u32 const   )2122219134U,      (u32 const   )606348324U, 
        (u32 const   )993737531U,      (u32 const   )2880154539U,      (u32 const   )3469659854U,      (u32 const   )286331153U, 
        (u32 const   )2408550287U,      (u32 const   )1313754702U,      (u32 const   )3082270647U,      (u32 const   )3958107115U, 
        (u32 const   )1010580540U,      (u32 const   )2172748161U,      (u32 const   )2492765332U,      (u32 const   )4160223223U, 
        (u32 const   )3115956665U,      (u32 const   )320017171U,      (u32 const   )741092396U,      (u32 const   )3553874899U, 
        (u32 const   )3890735079U,      (u32 const   )1852730990U,      (u32 const   )3301229764U,      (u32 const   )50529027U, 
        (u32 const   )1448498774U,      (u32 const   )1145324612U,      (u32 const   )2139062143U,      (u32 const   )2846468521U, 
        (u32 const   )707406378U,      (u32 const   )3149642683U,      (u32 const   )3250700737U,      (u32 const   )1397969747U, 
        (u32 const   )3705461980U,      (u32 const   )185273099U,      (u32 const   )2644352413U,      (u32 const   )1819044972U, 
        (u32 const   )825307441U,      (u32 const   )1953789044U,      (u32 const   )4143380214U,      (u32 const   )1179010630U, 
        (u32 const   )2896997548U,      (u32 const   )2307492233U,      (u32 const   )336860180U,      (u32 const   )3789677025U, 
        (u32 const   )370546198U,      (u32 const   )976894522U,      (u32 const   )1768515945U,      (u32 const   )151587081U, 
        (u32 const   )1886417008U,      (u32 const   )3065427638U,      (u32 const   )3503345872U,      (u32 const   )3991793133U, 
        (u32 const   )3435973836U,      (u32 const   )1111638594U,      (u32 const   )2560137368U,      (u32 const   )2762253476U, 
        (u32 const   )673720360U,      (u32 const   )1549556828U,      (u32 const   )4177066232U,      (u32 const   )2256963206U};
#line 53 "rng-alg-fst.c"
static u32 const   rcon[10]  = 
#line 53 "rng-alg-fst.c"
  {      (u32 const   )16777216,      (u32 const   )33554432,      (u32 const   )67108864,      (u32 const   )134217728, 
        (u32 const   )268435456,      (u32 const   )536870912,      (u32 const   )1073741824,      (u32 const   )(-0x7FFFFFFF-1), 
        (u32 const   )452984832,      (u32 const   )905969664};
#line 63 "rng-alg-fst.c"
unsigned char Sc[256]  ;
#line 64 "rng-alg-fst.c"
u32 STe0[256]  ;
#line 65 "rng-alg-fst.c"
u32 STe1[256]  ;
#line 66 "rng-alg-fst.c"
u32 STe2[256]  ;
#line 67 "rng-alg-fst.c"
u32 STe3[256]  ;
#line 68 "rng-alg-fst.c"
u32 STe4[256]  ;
#line 86 "rng-alg-fst.c"
int rngKeySetupEnc(u32 *rk , u8 const   *cipherKey , int keyBits ) 
{ int i ;
  unsigned char rbytes[512] ;
  unsigned char u8_swap ;
  u32 u32_swap ;
  u32 temp ;
  u32 *rks ;
  int q ;
  unsigned char z ;
  unsigned char x ;
  unsigned char y ;

  {
#line 87
  i = 0;
#line 94
  rks = rk;
#line 96
  *(rk + 0) = ((((u32 )*(cipherKey + 0) << 24) ^ ((u32 )*(cipherKey + 1) << 16)) ^ ((u32 )*(cipherKey + 2) << 8)) ^ (u32 )*(cipherKey + 3);
#line 97
  *(rk + 1) = ((((u32 )*((cipherKey + 4) + 0) << 24) ^ ((u32 )*((cipherKey + 4) + 1) << 16)) ^ ((u32 )*((cipherKey + 4) + 2) << 8)) ^ (u32 )*((cipherKey + 4) + 3);
#line 98
  *(rk + 2) = ((((u32 )*((cipherKey + 8) + 0) << 24) ^ ((u32 )*((cipherKey + 8) + 1) << 16)) ^ ((u32 )*((cipherKey + 8) + 2) << 8)) ^ (u32 )*((cipherKey + 8) + 3);
#line 99
  *(rk + 3) = ((((u32 )*((cipherKey + 12) + 0) << 24) ^ ((u32 )*((cipherKey + 12) + 1) << 16)) ^ ((u32 )*((cipherKey + 12) + 2) << 8)) ^ (u32 )*((cipherKey + 12) + 3);
#line 100
  if (keyBits == 128) {
#line 101
    while (1) {
#line 102
      temp = *(rk + 3);
#line 103
      *(rk + 4) = ((((*(rk + 0) ^ (unsigned int )(Te4[(temp >> 16) & 255U] & 4278190080U)) ^ (unsigned int )(Te4[(temp >> 8) & 255U] & 16711680U)) ^ (unsigned int )(Te4[temp & 255U] & 65280U)) ^ (unsigned int )(Te4[temp >> 24] & 255U)) ^ (unsigned int )rcon[i];
#line 109
      *(rk + 5) = *(rk + 1) ^ *(rk + 4);
#line 110
      *(rk + 6) = *(rk + 2) ^ *(rk + 5);
#line 111
      *(rk + 7) = *(rk + 3) ^ *(rk + 6);
#line 112
      i ++;
#line 112
      if (i == 10) {
#line 113
        break;
      }
#line 115
      rk += 4;
    }
  } else {
#line 119
    printf("Fatal error during rng setup\n");
#line 120
    exit(1);
  }
#line 123
  i = 0;
#line 123
  while (i < 256) {
#line 124
    Sc[i] = (unsigned char )i;
#line 125
    STe0[i] = (u32 )Te0[i];
#line 126
    STe1[i] = (u32 )Te1[i];
#line 127
    STe2[i] = (u32 )Te2[i];
#line 128
    STe3[i] = (u32 )Te3[i];
#line 129
    STe4[i] = (u32 )Te4[i];
#line 123
    i ++;
  }
#line 133
  i = 0;
#line 133
  while (i < 512) {
#line 134
    rbytes[i] = (unsigned char )((i * 7) % 256);
#line 135
    if (i > 255) {
#line 135
      rbytes[i] = (unsigned char )((int )rbytes[i] ^ 255);
    }
#line 133
    i ++;
  }
#line 140
  i = 0;
#line 140
  while (i < 512) {
#line 142
    rngEncrypt((u32 const   *)rks, 10, (u8 const   *)(rbytes + i), (u8 *)(rbytes + i));
#line 143
    q = 0;
#line 143
    while (q < 16) {
#line 145
      z = rbytes[i + q];
#line 150
      u8_swap = Sc[z];
#line 151
      Sc[z] = Sc[1];
#line 152
      Sc[1] = u8_swap;
#line 155
      x = Sc[z];
#line 156
      y = Sc[1];
#line 159
      u32_swap = STe0[x];
#line 160
      STe0[x] = STe0[y];
#line 161
      STe0[y] = u32_swap;
#line 163
      u32_swap = STe1[x];
#line 164
      STe1[x] = STe1[y];
#line 165
      STe1[y] = u32_swap;
#line 167
      u32_swap = STe2[x];
#line 168
      STe2[x] = STe2[y];
#line 169
      STe2[y] = u32_swap;
#line 171
      u32_swap = STe3[x];
#line 172
      STe3[x] = STe3[y];
#line 173
      STe3[y] = u32_swap;
#line 175
      u32_swap = STe4[x];
#line 176
      STe4[x] = STe4[y];
#line 177
      STe4[y] = u32_swap;
#line 143
      q ++;
    }
#line 140
    i += 16;
  }
#line 182
  return (10);
}
}
#line 185 "rng-alg-fst.c"
void rngEncrypt(u32 const   *rk , int Nr , u8 const   *pt , u8 *ct ) 
{ u32 s0 ;
  u32 s1 ;
  u32 s2 ;
  u32 s3 ;
  u32 t0 ;
  u32 t1 ;
  u32 t2 ;
  u32 t3 ;
  int r ;

  {
#line 193
  s0 = (((((u32 )*(pt + 0) << 24) ^ ((u32 )*(pt + 1) << 16)) ^ ((u32 )*(pt + 2) << 8)) ^ (u32 )*(pt + 3)) ^ (unsigned int )*(rk + 0);
#line 194
  s1 = (((((u32 )*((pt + 4) + 0) << 24) ^ ((u32 )*((pt + 4) + 1) << 16)) ^ ((u32 )*((pt + 4) + 2) << 8)) ^ (u32 )*((pt + 4) + 3)) ^ (unsigned int )*(rk + 1);
#line 195
  s2 = (((((u32 )*((pt + 8) + 0) << 24) ^ ((u32 )*((pt + 8) + 1) << 16)) ^ ((u32 )*((pt + 8) + 2) << 8)) ^ (u32 )*((pt + 8) + 3)) ^ (unsigned int )*(rk + 2);
#line 196
  s3 = (((((u32 )*((pt + 12) + 0) << 24) ^ ((u32 )*((pt + 12) + 1) << 16)) ^ ((u32 )*((pt + 12) + 2) << 8)) ^ (u32 )*((pt + 12) + 3)) ^ (unsigned int )*(rk + 3);
#line 201
  t0 = (u32 )Sc[0];
#line 202
  t1 = (u32 )Sc[32];
#line 203
  t2 = (u32 )Sc[64];
#line 204
  t3 = (u32 )Sc[96];
#line 205
  t0 = (u32 )Sc[128];
#line 206
  t1 = (u32 )Sc[160];
#line 207
  t2 = (u32 )Sc[192];
#line 208
  t3 = (u32 )Sc[224];
#line 213
  r = Nr >> 1;
#line 214
  while (1) {
#line 215
    t0 = (((STe0[Sc[s0 >> 24]] ^ STe1[Sc[(s1 >> 16) & 255U]]) ^ STe2[Sc[(s2 >> 8) & 255U]]) ^ STe3[Sc[s3 & 255U]]) ^ (unsigned int )*(rk + 4);
#line 221
    t1 = (((STe0[Sc[s1 >> 24]] ^ STe1[Sc[(s2 >> 16) & 255U]]) ^ STe2[Sc[(s3 >> 8) & 255U]]) ^ STe3[Sc[s0 & 255U]]) ^ (unsigned int )*(rk + 5);
#line 227
    t2 = (((STe0[Sc[s2 >> 24]] ^ STe1[Sc[(s3 >> 16) & 255U]]) ^ STe2[Sc[(s0 >> 8) & 255U]]) ^ STe3[Sc[s1 & 255U]]) ^ (unsigned int )*(rk + 6);
#line 233
    t3 = (((STe0[Sc[s3 >> 24]] ^ STe1[Sc[(s0 >> 16) & 255U]]) ^ STe2[Sc[(s1 >> 8) & 255U]]) ^ STe3[Sc[s2 & 255U]]) ^ (unsigned int )*(rk + 7);
#line 240
    rk += 8;
#line 241
    r --;
#line 241
    if (r == 0) {
#line 242
      break;
    }
#line 245
    s0 = (((STe0[Sc[t0 >> 24]] ^ STe1[Sc[(t1 >> 16) & 255U]]) ^ STe2[Sc[(t2 >> 8) & 255U]]) ^ STe3[Sc[t3 & 255U]]) ^ (unsigned int )*(rk + 0);
#line 251
    s1 = (((STe0[Sc[t1 >> 24]] ^ STe1[Sc[(t2 >> 16) & 255U]]) ^ STe2[Sc[(t3 >> 8) & 255U]]) ^ STe3[Sc[t0 & 255U]]) ^ (unsigned int )*(rk + 1);
#line 257
    s2 = (((STe0[Sc[t2 >> 24]] ^ STe1[Sc[(t3 >> 16) & 255U]]) ^ STe2[Sc[(t0 >> 8) & 255U]]) ^ STe3[Sc[t1 & 255U]]) ^ (unsigned int )*(rk + 2);
#line 263
    s3 = (((STe0[Sc[t3 >> 24]] ^ STe1[Sc[(t0 >> 16) & 255U]]) ^ STe2[Sc[(t1 >> 8) & 255U]]) ^ STe3[Sc[t2 & 255U]]) ^ (unsigned int )*(rk + 3);
  }
#line 274
  s0 = ((((STe4[Sc[t0 >> 24]] & 4278190080U) ^ (STe4[Sc[(t1 >> 16) & 255U]] & 16711680U)) ^ (STe4[Sc[(t2 >> 8) & 255U]] & 65280U)) ^ (STe4[Sc[t3 & 255U]] & 255U)) ^ (unsigned int )*(rk + 0);
#line 280
  *(ct + 0) = (u8 )(s0 >> 24);
#line 280
  *(ct + 1) = (u8 )(s0 >> 16);
#line 280
  *(ct + 2) = (u8 )(s0 >> 8);
#line 280
  *(ct + 3) = (u8 )s0;
#line 281
  s1 = ((((STe4[Sc[t1 >> 24]] & 4278190080U) ^ (STe4[Sc[(t2 >> 16) & 255U]] & 16711680U)) ^ (STe4[Sc[(t3 >> 8) & 255U]] & 65280U)) ^ (STe4[Sc[t0 & 255U]] & 255U)) ^ (unsigned int )*(rk + 1);
#line 287
  *((ct + 4) + 0) = (u8 )(s1 >> 24);
#line 287
  *((ct + 4) + 1) = (u8 )(s1 >> 16);
#line 287
  *((ct + 4) + 2) = (u8 )(s1 >> 8);
#line 287
  *((ct + 4) + 3) = (u8 )s1;
#line 288
  s2 = ((((STe4[Sc[t2 >> 24]] & 4278190080U) ^ (STe4[Sc[(t3 >> 16) & 255U]] & 16711680U)) ^ (STe4[Sc[(t0 >> 8) & 255U]] & 65280U)) ^ (STe4[Sc[t1 & 255U]] & 255U)) ^ (unsigned int )*(rk + 2);
#line 294
  *((ct + 8) + 0) = (u8 )(s2 >> 24);
#line 294
  *((ct + 8) + 1) = (u8 )(s2 >> 16);
#line 294
  *((ct + 8) + 2) = (u8 )(s2 >> 8);
#line 294
  *((ct + 8) + 3) = (u8 )s2;
#line 295
  s3 = ((((STe4[Sc[t3 >> 24]] & 4278190080U) ^ (STe4[Sc[(t0 >> 16) & 255U]] & 16711680U)) ^ (STe4[Sc[(t1 >> 8) & 255U]] & 65280U)) ^ (STe4[Sc[t2 & 255U]] & 255U)) ^ (unsigned int )*(rk + 3);
#line 301
  *((ct + 12) + 0) = (u8 )(s3 >> 24);
#line 301
  *((ct + 12) + 1) = (u8 )(s3 >> 16);
#line 301
  *((ct + 12) + 2) = (u8 )(s3 >> 8);
#line 301
  *((ct + 12) + 3) = (u8 )s3;
#line 302
  return;
}
}
