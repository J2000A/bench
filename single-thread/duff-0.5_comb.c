/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

#line 46 "/usr/include/i386/_types.h"
typedef long long __int64_t;
#line 90 "/usr/include/i386/_types.h"
typedef unsigned long __darwin_size_t;
#line 110 "/usr/include/sys/_types.h"
typedef __int64_t __darwin_off_t;
#line 172 "/usr/include/sys/types.h"
typedef __darwin_off_t off_t;
#line 230 "/usr/include/sys/types.h"
typedef __darwin_size_t size_t;
#line 85 "/usr/include/stdio.h"
typedef __darwin_off_t fpos_t;
#line 96 "/usr/include/stdio.h"
struct __sbuf {
   unsigned char *_base ;
   int _size ;
};
#line 102
struct __sFILEX;
#line 130 "/usr/include/stdio.h"
struct __sFILE {
   unsigned char *_p ;
   int _r ;
   int _w ;
   short _flags ;
   short _file ;
   struct __sbuf _bf ;
   int _lbfsize ;
   void *_cookie ;
   int (*_close)(void * ) ;
   int (*_read)(void * , char * , int  ) ;
   fpos_t (*_seek)(void * , fpos_t  , int  ) ;
   int (*_write)(void * , char const   * , int  ) ;
   struct __sbuf _ub ;
   struct __sFILEX *_extra ;
   int _ur ;
   unsigned char _ubuf[3] ;
   unsigned char _nbuf[1] ;
   struct __sbuf _lb ;
   int _blksize ;
   fpos_t _offset ;
};
#line 130 "/usr/include/stdio.h"
typedef struct __sFILE FILE;
#line 53 "duff.h"
enum __anonenum_SymlinkMode_10 {
    NO_SYMLINKS = 0,
    ALL_SYMLINKS = 1,
    ARG_SYMLINKS = 2
} ;
#line 53 "duff.h"
typedef enum __anonenum_SymlinkMode_10 SymlinkMode;
#line 97
enum Function {
    SHA_1 = 0,
    SHA_256 = 1,
    SHA_384 = 2,
    SHA_512 = 3
} ;
#line 41 "/usr/include/i386/_types.h"
typedef unsigned char __uint8_t;
#line 43 "/usr/include/i386/_types.h"
typedef unsigned short __uint16_t;
#line 44 "/usr/include/i386/_types.h"
typedef int __int32_t;
#line 45 "/usr/include/i386/_types.h"
typedef unsigned int __uint32_t;
#line 47 "/usr/include/i386/_types.h"
typedef unsigned long long __uint64_t;
#line 118 "/usr/include/i386/_types.h"
typedef long __darwin_time_t;
#line 67 "/usr/include/sys/_types.h"
struct _opaque_pthread_mutex_t {
   long __sig ;
   char __opaque[56] ;
};
#line 94 "/usr/include/sys/_types.h"
typedef __int64_t __darwin_blkcnt_t;
#line 95 "/usr/include/sys/_types.h"
typedef __int32_t __darwin_blksize_t;
#line 96 "/usr/include/sys/_types.h"
typedef __int32_t __darwin_dev_t;
#line 99 "/usr/include/sys/_types.h"
typedef __uint32_t __darwin_gid_t;
#line 101 "/usr/include/sys/_types.h"
typedef __uint64_t __darwin_ino64_t;
#line 103 "/usr/include/sys/_types.h"
typedef __darwin_ino64_t __darwin_ino_t;
#line 109 "/usr/include/sys/_types.h"
typedef __uint16_t __darwin_mode_t;
#line 119 "/usr/include/sys/_types.h"
typedef struct _opaque_pthread_mutex_t __darwin_pthread_mutex_t;
#line 133 "/usr/include/sys/_types.h"
typedef __uint32_t __darwin_uid_t;
#line 103 "/usr/include/sys/types.h"
typedef __darwin_dev_t dev_t;
#line 110 "/usr/include/sys/types.h"
typedef __darwin_blkcnt_t blkcnt_t;
#line 115 "/usr/include/sys/types.h"
typedef __darwin_blksize_t blksize_t;
#line 120 "/usr/include/sys/types.h"
typedef __darwin_gid_t gid_t;
#line 135 "/usr/include/sys/types.h"
typedef __darwin_ino_t ino_t;
#line 152 "/usr/include/sys/types.h"
typedef __darwin_mode_t mode_t;
#line 157 "/usr/include/sys/types.h"
typedef __uint16_t nlink_t;
#line 180 "/usr/include/sys/types.h"
typedef __darwin_uid_t uid_t;
#line 88 "/usr/include/sys/_structs.h"
struct timespec {
   __darwin_time_t tv_sec ;
   long tv_nsec ;
};
#line 225 "/usr/include/sys/stat.h"
struct stat {
   dev_t st_dev ;
   mode_t st_mode ;
   nlink_t st_nlink ;
   __darwin_ino64_t st_ino ;
   uid_t st_uid ;
   gid_t st_gid ;
   dev_t st_rdev ;
   struct timespec st_atimespec ;
   struct timespec st_mtimespec ;
   struct timespec st_ctimespec ;
   struct timespec st_birthtimespec ;
   off_t st_size ;
   blkcnt_t st_blocks ;
   blksize_t st_blksize ;
   __uint32_t st_flags ;
   __uint32_t st_gen ;
   __int32_t st_lspare ;
   __int64_t st_qspare[2] ;
};
#line 40 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 89 "/usr/include/sys/dirent.h"
#pragma pack(4)
#line 101
#pragma pack()
#line 115 "/usr/include/sys/dirent.h"
struct dirent {
   __uint64_t d_ino ;
   __uint64_t d_seekoff ;
   __uint16_t d_reclen ;
   __uint16_t d_namlen ;
   __uint8_t d_type ;
   char d_name[1024] ;
};
#line 68 "/usr/include/dirent.h"
struct _telldir;
#line 71 "/usr/include/dirent.h"
struct __anonstruct_DIR_9 {
   int __dd_fd ;
   long __dd_loc ;
   long __dd_size ;
   char *__dd_buf ;
   int __dd_len ;
   long __dd_seek ;
   long __dd_rewind ;
   int __dd_flags ;
   __darwin_pthread_mutex_t __dd_lock ;
   struct _telldir *__dd_td ;
};
#line 71 "/usr/include/dirent.h"
typedef struct __anonstruct_DIR_9 DIR;
#line 35 "duff.h"
enum __anonenum_Status_10 {
    UNTOUCHED = 0,
    INVALID = 1,
    DUPLICATE = 2,
    REPORTED = 3
} ;
#line 35 "duff.h"
typedef enum __anonenum_Status_10 Status;
#line 68
struct Entry_t;
#line 68 "duff.h"
typedef struct Entry_t Entry;
#line 69
struct Directory_t;
#line 69 "duff.h"
typedef struct Directory_t Directory;
#line 73 "duff.h"
struct Directory_t {
   Directory *next ;
   dev_t device ;
   ino_t inode ;
};
#line 82 "duff.h"
struct Entry_t {
   Entry *prev ;
   Entry *next ;
   char *path ;
   off_t size ;
   dev_t device ;
   ino_t inode ;
   Status status ;
   uint8_t *digest ;
   uint8_t *samples ;
};
#line 50 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long long uint64_t;
#line 45 "sha1.h"
union __anonunion_buffer_9 {
   uint32_t words[16] ;
   uint8_t bytes[64] ;
};
#line 45 "sha1.h"
struct _SHA1Context {
   uint64_t totalLength ;
   uint32_t hash[5] ;
   uint32_t bufferLength ;
   union __anonunion_buffer_9 buffer ;
};
#line 58 "sha1.h"
typedef struct _SHA1Context SHA1Context;
#line 45 "sha256.h"
union __anonunion_buffer_10 {
   uint32_t words[16] ;
   uint8_t bytes[64] ;
};
#line 45 "sha256.h"
struct _SHA256Context {
   uint64_t totalLength ;
   uint32_t hash[8] ;
   uint32_t bufferLength ;
   union __anonunion_buffer_10 buffer ;
};
#line 58 "sha256.h"
typedef struct _SHA256Context SHA256Context;
#line 45 "sha384.h"
union __anonunion_buffer_11 {
   uint64_t words[16] ;
   uint8_t bytes[128] ;
};
#line 45 "sha384.h"
struct _SHA384Context {
   uint64_t totalLength[2] ;
   uint64_t hash[8] ;
   uint32_t bufferLength ;
   union __anonunion_buffer_11 buffer ;
};
#line 58 "sha384.h"
typedef struct _SHA384Context SHA384Context;
#line 45 "sha512.h"
union __anonunion_buffer_12 {
   uint64_t words[16] ;
   uint8_t bytes[128] ;
};
#line 45 "sha512.h"
struct _SHA512Context {
   uint64_t totalLength[2] ;
   uint64_t hash[8] ;
   uint32_t bufferLength ;
   union __anonunion_buffer_12 buffer ;
};
#line 58 "sha512.h"
typedef struct _SHA512Context SHA512Context;
#line 70 "/usr/include/i386/_types.h"
typedef int __darwin_ct_rune_t;
#line 96 "/usr/include/i386/_types.h"
typedef __builtin_va_list __darwin_va_list;
#line 102 "/usr/include/i386/_types.h"
typedef int __darwin_wchar_t;
#line 107 "/usr/include/i386/_types.h"
typedef __darwin_wchar_t __darwin_rune_t;
#line 73 "/usr/include/stdio.h"
typedef __darwin_va_list va_list;
#line 81 "/usr/include/runetype.h"
struct __anonstruct__RuneEntry_8 {
   __darwin_rune_t __min ;
   __darwin_rune_t __max ;
   __darwin_rune_t __map ;
   __uint32_t *__types ;
};
#line 81 "/usr/include/runetype.h"
typedef struct __anonstruct__RuneEntry_8 _RuneEntry;
#line 88 "/usr/include/runetype.h"
struct __anonstruct__RuneRange_9 {
   int __nranges ;
   _RuneEntry *__ranges ;
};
#line 88 "/usr/include/runetype.h"
typedef struct __anonstruct__RuneRange_9 _RuneRange;
#line 93 "/usr/include/runetype.h"
struct __anonstruct__RuneCharClass_10 {
   char __name[14] ;
   __uint32_t __mask ;
};
#line 93 "/usr/include/runetype.h"
typedef struct __anonstruct__RuneCharClass_10 _RuneCharClass;
#line 98 "/usr/include/runetype.h"
struct __anonstruct__RuneLocale_11 {
   char __magic[8] ;
   char __encoding[32] ;
   __darwin_rune_t (*__sgetrune)(char const   * , __darwin_size_t  , char const   ** ) ;
   int (*__sputrune)(__darwin_rune_t  , char * , __darwin_size_t  , char ** ) ;
   __darwin_rune_t __invalid_rune ;
   __uint32_t __runetype[1 << 8] ;
   __darwin_rune_t __maplower[1 << 8] ;
   __darwin_rune_t __mapupper[1 << 8] ;
   _RuneRange __runetype_ext ;
   _RuneRange __maplower_ext ;
   _RuneRange __mapupper_ext ;
   void *__variable ;
   int __variable_len ;
   int __ncharclasses ;
   _RuneCharClass *__charclasses ;
};
#line 98 "/usr/include/runetype.h"
typedef struct __anonstruct__RuneLocale_11 _RuneLocale;
#line 1 "duff.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-lJjRoXmz.i","-g,-O2")
#line 75 "/usr/include/sys/errno.h"
extern int *__error(void) ;
#line 548 "/usr/include/unistd.h"
extern int getopt(int  , char * const  * , char const   * )  __asm__("_getopt")  ;
#line 550
extern char *optarg ;
#line 551
extern int optind ;
#line 164 "/usr/include/stdio.h"
extern FILE *__stdinp ;
#line 267
extern int ( /* format attribute */  printf)(char const   *  , ...) ;
#line 82 "/usr/include/strings.h"
extern int strcasecmp(char const   * , char const   * ) ;
#line 159 "/usr/include/stdlib.h"
extern  __attribute__((__noreturn__)) void exit(int  ) ;
#line 191
extern unsigned long long strtoull(char const   * , char ** , int  ) ;
#line 53 "/usr/include/locale.h"
extern char *setlocale(int  , char const   * ) ;
#line 114 "duff.h"
int read_path(FILE *stream , char *path , size_t size ) ;
#line 115
void kill_trailing_slashes(char *path ) ;
#line 117
void error(char const   *format  , ...) ;
#line 118
void warning(char const   *format  , ...) ;
#line 126
void process_path(char const   *path , int depth ) ;
#line 127
void report_clusters(void) ;
#line 85 "duff.c"
enum __anonenum_SymlinkMode_10 follow_links_mode  =    (SymlinkMode )0;
#line 89 "duff.c"
int all_files_flag  =    0;
#line 93 "duff.c"
int verbose_flag  =    0;
#line 97 "duff.c"
int recursive_flag  =    0;
#line 101 "duff.c"
int null_terminate_flag  =    0;
#line 105 "duff.c"
int quiet_flag  =    0;
#line 110 "duff.c"
int physical_flag  =    0;
#line 115 "duff.c"
int excess_flag  =    0;
#line 120 "duff.c"
int thorough_flag  =    0;
#line 124 "duff.c"
int ignore_empty_flag  =    0;
#line 129 "duff.c"
char const   *header_format  =    (char const   *)((void *)0);
#line 133 "duff.c"
off_t sample_limit  =    (off_t )1048576;
#line 137 "duff.c"
enum Function digest_function  =    (enum Function )0;
#line 141
static void version(void) ;
#line 142
static void usage(void) ;
#line 143
static void bugs(void) ;
#line 147 "duff.c"
static void version(void) 
{ 

  {
#line 149
  printf("%s\n", "duff 0.5");
#line 150
  printf("Copyright (c) 2005 Camilla Berglund <elmindreda@elmindreda.org>\n");
#line 151
  printf("%s contains shaX-asaddi\n", "duff");
#line 152
  printf("Copyright (c) 2001-2003 Allan Saddi <allan@saddi.com>\n");
#line 153
  return;
}
}
#line 159 "duff.c"
static void usage(void) 
{ 

  {
#line 161
  printf("Usage: %s [-0HLPaepqrtz] [-d function] [-f format] [-l size] [file ...]\n",
         "duff");
#line 164
  printf("       %s -h\n", "duff");
#line 165
  printf("       %s -v\n", "duff");
#line 167
  printf("Options:\n");
#line 168
  printf("  -0  read and write file names terminated by a null character\n");
#line 169
  printf("  -H  follow symbolic links on the command line\n");
#line 170
  printf("  -L  follow all symbolic links\n");
#line 171
  printf("  -P  do not follow any symbolic links (default)\n");
#line 172
  printf("  -a  include hidden files when searching recursively\n");
#line 173
  printf("  -d  the message digest function to use\n");
#line 174
  printf("  -e  excess mode; list all but one file from each cluster (no headers)\n");
#line 175
  printf("  -f  format for cluster headers\n");
#line 176
  printf("  -h  show this help\n");
#line 177
  printf("  -l  the minimum size that activates sampling\n");
#line 178
  printf("  -q  quiet; suppress warnings and error messages\n");
#line 179
  printf("  -p  physical mode; do not report multiple links as duplicates\n");
#line 180
  printf("  -r  search recursively through specified directories\n");
#line 181
  printf("  -t  thorough; force byte-by-byte comparison of files\n");
#line 182
  printf("  -v  show version information\n");
#line 183
  printf("  -z  do not report empty files\n");
#line 184
  return;
}
}
#line 188 "duff.c"
static void bugs(void) 
{ 

  {
#line 190
  printf("Report bugs to <%s>\n", "elmindreda@elmindreda.org");
#line 191
  return;
}
}
#line 196 "duff.c"
int main(int argc , char **argv ) 
{ int i ;
  int ch ;
  char *temp ;
  off_t limit ;
  char path[1024] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned long long tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;

  {
#line 203
  setlocale(0, "");
#line 207
  while (1) {
#line 207
    ch = getopt(argc, (char * const  *)argv, "0HLPad:ef:hl:pqrtvz");
#line 207
    if (! (ch != -1)) {
#line 207
      break;
    }
#line 209
    switch (ch) {
    case 48: 
#line 212
    null_terminate_flag = 1;
#line 213
    break;
    case 72: 
#line 215
    follow_links_mode = (SymlinkMode )2;
#line 216
    break;
    case 76: 
#line 218
    follow_links_mode = (SymlinkMode )1;
#line 219
    break;
    case 80: 
#line 221
    follow_links_mode = (SymlinkMode )0;
#line 222
    break;
    case 97: 
#line 224
    all_files_flag = 1;
#line 225
    break;
    case 100: 
#line 227
    tmp___2 = strcasecmp((char const   *)optarg, "sha1");
#line 227
    if (tmp___2 == 0) {
#line 228
      digest_function = (enum Function )0;
    } else {
#line 229
      tmp___1 = strcasecmp((char const   *)optarg, "sha256");
#line 229
      if (tmp___1 == 0) {
#line 230
        digest_function = (enum Function )1;
      } else {
#line 231
        tmp___0 = strcasecmp((char const   *)optarg, "sha384");
#line 231
        if (tmp___0 == 0) {
#line 232
          digest_function = (enum Function )2;
        } else {
#line 233
          tmp = strcasecmp((char const   *)optarg, "sha512");
#line 233
          if (tmp == 0) {
#line 234
            digest_function = (enum Function )3;
          } else {
#line 236
            error("%s is not a supported digest function", optarg);
          }
        }
      }
    }
#line 237
    break;
    case 101: 
#line 239
    excess_flag = 1;
#line 240
    break;
    case 102: 
#line 242
    header_format = (char const   *)optarg;
#line 243
    break;
    case 104: 
#line 245
    usage();
#line 246
    bugs();
#line 247
    exit(0);
    case 108: 
#line 249
    tmp___3 = strtoull((char const   *)optarg, & temp, 10);
#line 249
    limit = (off_t )tmp___3;
#line 250
    if ((unsigned long )temp == (unsigned long )optarg) {
#line 251
      warning("Ignoring invalid sample limit %s", optarg);
    } else {
#line 250
      tmp___4 = __error();
#line 250
      if (*tmp___4 == 34) {
#line 251
        warning("Ignoring invalid sample limit %s", optarg);
      } else {
#line 250
        tmp___5 = __error();
#line 250
        if (*tmp___5 == 22) {
#line 251
          warning("Ignoring invalid sample limit %s", optarg);
        } else
#line 254
        if (limit < 10LL) {
#line 255
          warning("Sample limit must be at least %u bytes", 10);
        } else {
#line 257
          sample_limit = limit;
        }
      }
    }
#line 259
    break;
    case 112: 
#line 261
    physical_flag = 1;
#line 262
    break;
    case 113: 
#line 264
    quiet_flag = 1;
#line 265
    break;
    case 114: 
#line 267
    recursive_flag = 1;
#line 268
    break;
    case 116: 
#line 270
    thorough_flag = 1;
#line 271
    break;
    case 118: 
#line 273
    version();
#line 274
    exit(0);
    case 122: 
#line 276
    ignore_empty_flag = 1;
#line 277
    break;
    default: 
#line 279
    usage();
#line 280
    bugs();
#line 281
    exit(1);
    }
  }
#line 285
  argc -= optind;
#line 286
  argv += optind;
#line 288
  if (! header_format) {
#line 289
    header_format = "%n files in cluster %i (%s bytes, digest %d)";
  }
#line 291
  if (argc) {
#line 294
    i = 0;
#line 294
    while (i < argc) {
#line 296
      kill_trailing_slashes(*(argv + i));
#line 297
      process_path((char const   *)*(argv + i), 0);
#line 294
      i ++;
    }
  } else {
#line 303
    while (1) {
#line 303
      tmp___6 = read_path(__stdinp, path, sizeof(path));
#line 303
      if (! (tmp___6 == 0)) {
#line 303
        break;
      }
#line 305
      kill_trailing_slashes(path);
#line 306
      process_path((char const   *)(path), 0);
    }
  }
#line 310
  report_clusters();
#line 312
  exit(0);
}
}
#line 1 "duffdriver.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-oJSDVBsb.i","-g,-O2")
#line 433 "/usr/include/sys/stat.h"
extern int lstat(char const   * , struct stat * )  __asm__("_lstat$INODE64")  ;
#line 436
extern int stat(char const   * , struct stat * )  __asm__("_stat$INODE64")  ;
#line 470 "/usr/include/unistd.h"
extern int access(char const   * , int  ) ;
#line 165 "/usr/include/stdio.h"
extern FILE *__stdoutp ;
#line 253
extern int fputc(int  , FILE * ) ;
#line 254
extern int fputs(char const   * , FILE * )  __asm__("_fputs")  ;
#line 462
extern int ( /* format attribute */  asprintf)(char ** , char const   *  , ...) ;
#line 87 "/usr/include/string.h"
extern int strcmp(char const   * , char const   * ) ;
#line 91
extern char *strerror(int  )  __asm__("_strerror")  ;
#line 160 "/usr/include/stdlib.h"
extern void free(void * ) ;
#line 169
extern void *malloc(size_t  ) ;
#line 106 "/usr/include/dirent.h"
extern int closedir(DIR * )  __asm__("_closedir")  ;
#line 120
extern DIR *opendir(char const   * )  __asm__("_opendir$INODE64")  ;
#line 124
extern struct dirent *readdir(DIR * )  __asm__("_readdir$INODE64")  ;
#line 106 "duff.h"
Entry *make_entry(char const   *path , struct stat  const  *sb ) ;
#line 107
void link_entry(Entry **head , Entry *entry ) ;
#line 108
void unlink_entry(Entry **head , Entry *entry ) ;
#line 109
void free_entry(Entry *entry ) ;
#line 110
void free_entry_list(Entry **entries ) ;
#line 111
int compare_entries(Entry *first , Entry *second ) ;
#line 119
void print_cluster_header(char const   *format , unsigned int count , unsigned int index___0 ,
                          off_t size , uint8_t const   *digest ) ;
#line 103 "duffdriver.c"
static Entry *file_entries  =    (Entry *)((void *)0);
#line 106 "duffdriver.c"
static Directory *directories  =    (Directory *)((void *)0);
#line 109 "duffdriver.c"
static size_t entry_count  =    (size_t )0;
#line 113
static int stat_path(char const   *path , struct stat *sb , int depth ) ;
#line 114
static int has_recursed_directory(dev_t device , ino_t inode ) ;
#line 115
static void recurse_directory(char const   *path , struct stat  const  *sb , int depth ) ;
#line 118
static void process_file(char const   *path , struct stat *sb ) ;
#line 119
static void report_cluster(Entry *duplicates , unsigned int number , unsigned int count ) ;
#line 125 "duffdriver.c"
static int stat_path(char const   *path , struct stat *sb , int depth ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 127
  if ((int const   )*path == 0) {
#line 128
    return (-1);
  }
#line 130
  tmp___1 = lstat(path, sb);
#line 130
  if (tmp___1 != 0) {
#line 132
    if (! quiet_flag) {
#line 133
      tmp = __error();
#line 133
      tmp___0 = strerror(*tmp);
#line 133
      warning("%s: %s", path, tmp___0);
    }
#line 135
    return (-1);
  }
#line 138
  if (((int )sb->st_mode & 61440) == 40960) {
#line 140
    if (follow_links_mode == 1) {
#line 140
      goto _L;
    } else
#line 140
    if (depth == 0) {
#line 140
      if (follow_links_mode == 2) {
        _L: /* CIL Label */ 
#line 143
        tmp___4 = stat(path, sb);
#line 143
        if (tmp___4 != 0) {
#line 145
          if (! quiet_flag) {
#line 146
            tmp___2 = __error();
#line 146
            tmp___3 = strerror(*tmp___2);
#line 146
            warning("%s: %s", path, tmp___3);
          }
#line 148
          return (-1);
        }
#line 151
        if (((int )sb->st_mode & 61440) == 16384) {
#line 152
          return (-1);
        }
      } else {
#line 155
        return (-1);
      }
    } else {
#line 155
      return (-1);
    }
  }
#line 158
  return (0);
}
}
#line 164 "duffdriver.c"
static int has_recursed_directory(dev_t device , ino_t inode ) 
{ Directory *dir ;

  {
#line 168
  dir = directories;
#line 168
  while (dir) {
#line 170
    if (dir->device == device) {
#line 170
      if (dir->inode == inode) {
#line 171
        return (1);
      }
    }
#line 168
    dir = dir->next;
  }
#line 174
  return (0);
}
}
#line 180 "duffdriver.c"
static void record_directory(dev_t device , ino_t inode ) 
{ Directory *dir ;
  void *tmp ;

  {
#line 184
  tmp = malloc(sizeof(Directory ));
#line 184
  dir = (Directory *)tmp;
#line 185
  dir->device = device;
#line 186
  dir->inode = inode;
#line 187
  dir->next = directories;
#line 188
  directories = dir;
#line 189
  return;
}
}
#line 194 "duffdriver.c"
static void recurse_directory(char const   *path , struct stat  const  *sb , int depth ) 
{ DIR *dir ;
  struct dirent *dir_entry ;
  char *child_path ;
  char const   *name ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 203
  tmp = has_recursed_directory((dev_t )sb->st_dev, (ino_t )sb->st_ino);
#line 203
  if (tmp) {
#line 204
    return;
  }
#line 206
  record_directory((dev_t )sb->st_dev, (ino_t )sb->st_ino);
#line 208
  dir = opendir(path);
#line 209
  if (! dir) {
#line 211
    if (! quiet_flag) {
#line 212
      tmp___0 = __error();
#line 212
      tmp___1 = strerror(*tmp___0);
#line 212
      warning("%s: %s", path, tmp___1);
    }
#line 214
    return;
  }
#line 217
  while (1) {
#line 217
    dir_entry = readdir(dir);
#line 217
    if (! dir_entry) {
#line 217
      break;
    }
#line 219
    name = (char const   *)(dir_entry->d_name);
#line 220
    if ((int const   )*(name + 0) == 46) {
#line 222
      if (! all_files_flag) {
#line 223
        continue;
      }
#line 225
      tmp___2 = strcmp(name, ".");
#line 225
      if (tmp___2 == 0) {
#line 226
        continue;
      } else {
#line 225
        tmp___3 = strcmp(name, "..");
#line 225
        if (tmp___3 == 0) {
#line 226
          continue;
        }
      }
    }
#line 229
    tmp___4 = asprintf(& child_path, "%s/%s", path, name);
#line 229
    if (tmp___4 > 0) {
#line 231
      process_path((char const   *)child_path, depth);
#line 232
      free((void *)child_path);
    }
  }
#line 236
  closedir(dir);
#line 237
  return;
}
}
#line 241 "duffdriver.c"
static void process_file(char const   *path , struct stat *sb ) 
{ Entry *entry ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 245
  if (sb->st_size == 0LL) {
#line 247
    if (ignore_empty_flag) {
#line 248
      return;
    }
  } else {
#line 252
    tmp___1 = access(path, 1 << 2);
#line 252
    if (tmp___1 != 0) {
#line 256
      if (! quiet_flag) {
#line 257
        tmp = __error();
#line 257
        tmp___0 = strerror(*tmp);
#line 257
        warning("%s: %s", path, tmp___0);
      }
#line 259
      return;
    }
  }
#line 265
  if (physical_flag) {
#line 269
    entry = file_entries;
#line 269
    while (entry) {
#line 271
      if (entry->device == sb->st_dev) {
#line 271
        if (entry->inode == sb->st_ino) {
#line 272
          return;
        }
      }
#line 269
      entry = entry->next;
    }
  }
#line 276
  entry = make_entry(path, (struct stat  const  *)sb);
#line 276
  if ((unsigned long )entry != (unsigned long )((void *)0)) {
#line 278
    link_entry(& file_entries, entry);
#line 279
    entry_count ++;
  }
#line 281
  return;
}
}
#line 286 "duffdriver.c"
void process_path(char const   *path , int depth ) 
{ mode_t mode ;
  struct stat sb ;
  int tmp ;

  {
#line 291
  tmp = stat_path(path, & sb, depth);
#line 291
  if (tmp != 0) {
#line 292
    return;
  }
#line 294
  mode = (mode_t )((int )sb.st_mode & 61440);
#line 295
  switch ((int )mode) {
  case 32768: 
#line 299
  process_file(path, & sb);
#line 300
  break;
  case 16384: 
#line 305
  if (recursive_flag) {
#line 307
    recurse_directory(path, (struct stat  const  *)(& sb), depth + 1);
#line 308
    break;
  }
  default: 
#line 316
  if (! quiet_flag) {
#line 318
    switch ((int )mode) {
    case 40960: 
#line 321
    warning("%s is a symbolic link; skipping", path);
#line 322
    break;
    case 4096: 
#line 324
    warning("%s is a named pipe; skipping", path);
#line 325
    break;
    case 24576: 
#line 327
    warning("%s is a block device; skipping", path);
#line 328
    break;
    case 8192: 
#line 330
    warning("%s is a character device; skipping", path);
#line 331
    break;
    case 16384: 
#line 333
    warning("%s is a directory; skipping", path);
#line 334
    break;
    case 49152: 
#line 336
    warning("%s is a socket; skipping", path);
#line 337
    break;
    default: 
#line 339
    error("This cannot happen");
    }
  }
  }
#line 344
  return;
}
}
#line 348 "duffdriver.c"
static void report_cluster(Entry *duplicates , unsigned int number , unsigned int count ) 
{ Entry *entry ;

  {
#line 354
  if (excess_flag) {
#line 357
    entry = duplicates->next;
#line 357
    while (entry) {
#line 359
      if (null_terminate_flag) {
#line 361
        fputs((char const   *)entry->path, __stdoutp);
#line 362
        fputc('\000', __stdoutp);
      } else {
#line 365
        printf("%s\n", entry->path);
      }
#line 367
      entry->status = (Status )3;
#line 357
      entry = entry->next;
    }
  } else {
#line 374
    if ((int const   )*header_format != 0) {
#line 376
      print_cluster_header(header_format, count, number, duplicates->size, (uint8_t const   *)duplicates->digest);
#line 382
      if (null_terminate_flag) {
#line 383
        fputc('\000', __stdoutp);
      } else {
#line 385
        fputc('\n', __stdoutp);
      }
    }
#line 388
    entry = duplicates;
#line 388
    while (entry) {
#line 390
      if (null_terminate_flag) {
#line 392
        fputs((char const   *)entry->path, __stdoutp);
#line 393
        fputc('\000', __stdoutp);
      } else {
#line 396
        printf("%s\n", entry->path);
      }
#line 398
      entry->status = (Status )3;
#line 388
      entry = entry->next;
    }
  }
#line 401
  return;
}
}
#line 405 "duffdriver.c"
void report_clusters(void) 
{ int number ;
  int count ;
  Entry *base ;
  Entry *entry ;
  Entry *entry_next ;
  Entry *duplicates ;
  int tmp ;

  {
#line 407
  number = 1;
#line 407
  count = 0;
#line 411
  duplicates = (Entry *)((void *)0);
#line 413
  while (1) {
#line 413
    base = file_entries;
#line 413
    if (! ((unsigned long )base != (unsigned long )((void *)0))) {
#line 413
      break;
    }
#line 415
    if ((unsigned int )base->status == 1U) {
#line 416
      continue;
    }
#line 418
    count = 0;
#line 420
    entry = base->next;
#line 420
    while (entry) {
#line 422
      entry_next = entry->next;
#line 424
      tmp = compare_entries(base, entry);
#line 424
      if (tmp == 0) {
#line 426
        if ((unsigned long )duplicates == (unsigned long )((void *)0)) {
#line 428
          unlink_entry(& file_entries, base);
#line 429
          link_entry(& duplicates, base);
#line 431
          base->status = (Status )2;
#line 432
          count ++;
        }
#line 435
        unlink_entry(& file_entries, entry);
#line 436
        link_entry(& duplicates, entry);
#line 438
        entry->status = (Status )2;
#line 439
        count ++;
      }
#line 420
      entry = entry_next;
    }
#line 443
    if (duplicates) {
#line 445
      report_cluster(duplicates, (unsigned int )number, (unsigned int )count);
#line 446
      free_entry_list(& duplicates);
#line 447
      number ++;
    } else {
#line 451
      unlink_entry(& file_entries, base);
#line 452
      free_entry(base);
    }
  }
#line 455
  return;
}
}
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#line 1 "duffentry.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-atyJx_9B.i","-g,-O2")
#line 240 "/usr/include/stdio.h"
extern int fclose(FILE * ) ;
#line 242
extern int ferror(FILE * ) ;
#line 244
extern int fgetc(FILE * ) ;
#line 250
extern FILE *fopen(char const   * , char const   * )  __asm__("_fopen")  ;
#line 255
extern size_t fread(void * , size_t  , size_t  , FILE * ) ;
#line 418
extern int fseeko(FILE * , off_t  , int  ) ;
#line 127 "/usr/include/string.h"
extern char *strdup(char const   * ) ;
#line 76 "/usr/include/assert.h"
extern  __attribute__((__noreturn__)) void __assert_rtn(char const   * , char const   * ,
                                                        int  , char const   * ) ;
#line 64 "sha1.h"
void SHA1Init(SHA1Context *sc ) ;
#line 65
void SHA1Update(SHA1Context *sc , void const   *vdata , uint32_t len ) ;
#line 66
void SHA1Final(SHA1Context *sc , uint8_t *hash ) ;
#line 64 "sha256.h"
void SHA256Init(SHA256Context *sc ) ;
#line 65
void SHA256Update(SHA256Context *sc , void const   *vdata , uint32_t len ) ;
#line 66
void SHA256Final(SHA256Context *sc , uint8_t *hash ) ;
#line 64 "sha384.h"
void SHA384Init(SHA384Context *sc ) ;
#line 65
void SHA384Update(SHA384Context *sc , void const   *vdata , uint32_t len ) ;
#line 66
void SHA384Final(SHA384Context *sc , uint8_t *hash ) ;
#line 64 "sha512.h"
void SHA512Init(SHA512Context *sc ) ;
#line 65
void SHA512Update(SHA512Context *sc , void const   *vdata , uint32_t len ) ;
#line 66
void SHA512Final(SHA512Context *sc , uint8_t *hash ) ;
#line 116 "duff.h"
size_t get_digest_size(void) ;
#line 77 "duffentry.c"
static int get_entry_samples(Entry *entry ) ;
#line 78
static int get_entry_digest(Entry *entry ) ;
#line 79
static int get_entry_digest_sha1(uint8_t **result , FILE *file ) ;
#line 80
static int get_entry_digest_sha256(uint8_t **result , FILE *file ) ;
#line 81
static int get_entry_digest_sha384(uint8_t **result , FILE *file ) ;
#line 82
static int get_entry_digest_sha512(uint8_t **result , FILE *file ) ;
#line 83
static int compare_entry_digests(Entry *first , Entry *second ) ;
#line 84
static int compare_entry_samples(Entry *first , Entry *second ) ;
#line 85
static int compare_entry_contents(Entry *first , Entry *second ) ;
#line 89 "duffentry.c"
Entry *make_entry(char const   *path , struct stat  const  *sb ) 
{ Entry *entry ;
  void *tmp ;

  {
#line 93
  tmp = malloc(sizeof(Entry ));
#line 93
  entry = (Entry *)tmp;
#line 94
  entry->prev = (Entry *)((void *)0);
#line 95
  entry->next = (Entry *)((void *)0);
#line 96
  entry->path = strdup(path);
#line 97
  entry->size = (off_t )sb->st_size;
#line 98
  entry->device = (dev_t )sb->st_dev;
#line 99
  entry->inode = (ino_t )sb->st_ino;
#line 100
  entry->status = (Status )0;
#line 101
  entry->digest = (uint8_t *)((void *)0);
#line 102
  entry->samples = (uint8_t *)((void *)0);
#line 104
  return (entry);
}
}
#line 110 "duffentry.c"
void link_entry(Entry **head , Entry *entry ) 
{ long tmp ;
  long tmp___0 ;

  {
#line 112
  tmp = __builtin_expect((long )(! ((unsigned long )entry->prev == (unsigned long )((void *)0))),
                         0L);
#line 112
  if (tmp) {
#line 112
    __assert_rtn("link_entry", "duffentry.c", 112, "entry->prev == NULL");
  }
#line 113
  tmp___0 = __builtin_expect((long )(! ((unsigned long )entry->next == (unsigned long )((void *)0))),
                             0L);
#line 113
  if (tmp___0) {
#line 113
    __assert_rtn("link_entry", "duffentry.c", 113, "entry->next == NULL");
  }
#line 115
  entry->prev = (Entry *)((void *)0);
#line 116
  entry->next = *head;
#line 118
  if ((unsigned long )*head != (unsigned long )((void *)0)) {
#line 119
    (*head)->prev = entry;
  }
#line 121
  *head = entry;
#line 122
  return;
}
}
#line 127 "duffentry.c"
void unlink_entry(Entry **head , Entry *entry ) 
{ Entry *tmp ;

  {
#line 129
  if ((unsigned long )entry->prev != (unsigned long )((void *)0)) {
#line 130
    (entry->prev)->next = entry->next;
  } else {
#line 132
    *head = entry->next;
  }
#line 134
  if ((unsigned long )entry->next != (unsigned long )((void *)0)) {
#line 135
    (entry->next)->prev = entry->prev;
  }
#line 137
  tmp = (Entry *)((void *)0);
#line 137
  entry->next = tmp;
#line 137
  entry->prev = tmp;
#line 138
  return;
}
}
#line 142 "duffentry.c"
void free_entry(Entry *entry ) 
{ long tmp ;
  long tmp___0 ;

  {
#line 144
  tmp = __builtin_expect((long )(! ((unsigned long )entry->prev == (unsigned long )((void *)0))),
                         0L);
#line 144
  if (tmp) {
#line 144
    __assert_rtn("free_entry", "duffentry.c", 144, "entry->prev == NULL");
  }
#line 145
  tmp___0 = __builtin_expect((long )(! ((unsigned long )entry->next == (unsigned long )((void *)0))),
                             0L);
#line 145
  if (tmp___0) {
#line 145
    __assert_rtn("free_entry", "duffentry.c", 145, "entry->next == NULL");
  }
#line 147
  free((void *)entry->samples);
#line 148
  free((void *)entry->digest);
#line 149
  free((void *)entry->path);
#line 150
  free((void *)entry);
#line 151
  return;
}
}
#line 156 "duffentry.c"
void free_entry_list(Entry **entries ) 
{ Entry *entry ;

  {
#line 160
  while (*entries) {
#line 162
    entry = *entries;
#line 163
    unlink_entry(entries, entry);
#line 164
    free_entry(entry);
  }
#line 166
  return;
}
}
#line 170 "duffentry.c"
static int get_entry_samples(Entry *entry ) 
{ int i ;
  FILE *file ;
  uint8_t *samples ;
  int *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;

  {
#line 176
  if ((unsigned int )entry->status == 1U) {
#line 177
    return (-1);
  }
#line 178
  if (entry->samples) {
#line 179
    return (0);
  }
#line 181
  file = fopen((char const   *)entry->path, "rb");
#line 182
  if (! file) {
#line 184
    if (! quiet_flag) {
#line 185
      tmp = __error();
#line 185
      tmp___0 = strerror(*tmp);
#line 185
      warning("%s: %s", entry->path, tmp___0);
    }
#line 187
    entry->status = (Status )1;
#line 188
    return (-1);
  }
#line 191
  tmp___1 = malloc((size_t )10);
#line 191
  samples = (uint8_t *)tmp___1;
#line 193
  i = 0;
#line 193
  while (i < 10) {
#line 195
    fseeko(file, ((off_t )i * entry->size) / 10LL, 0);
#line 197
    tmp___4 = fread((void *)(samples + i), (size_t )1, (size_t )1, file);
#line 197
    if (tmp___4 < 1UL) {
#line 199
      if (! quiet_flag) {
#line 200
        tmp___2 = __error();
#line 200
        tmp___3 = strerror(*tmp___2);
#line 200
        warning("%s: %s", entry->path, tmp___3);
      }
#line 202
      free((void *)samples);
#line 203
      fclose(file);
#line 204
      return (-1);
    }
#line 193
    i ++;
  }
#line 208
  entry->samples = samples;
#line 210
  fclose(file);
#line 211
  return (0);
}
}
#line 216 "duffentry.c"
static int get_entry_digest(Entry *entry ) 
{ FILE *file ;
  int result ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
#line 221
  if ((unsigned int )entry->status == 1U) {
#line 222
    return (-1);
  }
#line 223
  if (entry->digest) {
#line 224
    return (0);
  }
#line 226
  file = fopen((char const   *)entry->path, "rb");
#line 227
  if (! file) {
#line 229
    if (! quiet_flag) {
#line 230
      tmp = __error();
#line 230
      tmp___0 = strerror(*tmp);
#line 230
      warning("%s: %s", entry->path, tmp___0);
    }
#line 232
    entry->status = (Status )1;
#line 233
    return (-1);
  }
#line 236
  switch ((int )digest_function) {
  case 0: 
#line 239
  result = get_entry_digest_sha1(& entry->digest, file);
#line 240
  break;
  case 1: 
#line 243
  result = get_entry_digest_sha256(& entry->digest, file);
#line 244
  break;
  case 2: 
#line 247
  result = get_entry_digest_sha384(& entry->digest, file);
#line 248
  break;
  case 3: 
#line 251
  result = get_entry_digest_sha512(& entry->digest, file);
#line 252
  break;
  default: 
#line 255
  error("This cannot happen");
  }
#line 258
  fclose(file);
#line 260
  if (result) {
#line 262
    if (! quiet_flag) {
#line 263
      tmp___1 = __error();
#line 263
      tmp___2 = strerror(*tmp___1);
#line 263
      warning("%s: %s", entry->path, tmp___2);
    }
#line 265
    entry->status = (Status )1;
#line 266
    return (-1);
  }
#line 269
  return (0);
}
}
#line 274 "duffentry.c"
static int get_entry_digest_sha1(uint8_t **result , FILE *file ) 
{ size_t size ;
  char buffer[8192] ;
  SHA1Context context ;
  int tmp ;
  void *tmp___0 ;

  {
#line 280
  SHA1Init(& context);
#line 282
  while (1) {
#line 284
    size = fread((void *)(buffer), (size_t )1, sizeof(buffer), file);
#line 285
    tmp = ferror(file);
#line 285
    if (tmp) {
#line 286
      return (-1);
    }
#line 288
    if (size == 0UL) {
#line 289
      break;
    }
#line 291
    SHA1Update(& context, (void const   *)(buffer), (uint32_t )size);
  }
#line 294
  tmp___0 = malloc((size_t )20);
#line 294
  *result = (uint8_t *)tmp___0;
#line 295
  SHA1Final(& context, (uint8_t *)*result);
#line 296
  return (0);
}
}
#line 301 "duffentry.c"
static int get_entry_digest_sha256(uint8_t **result , FILE *file ) 
{ size_t size ;
  char buffer[8192] ;
  SHA256Context context ;
  int tmp ;
  void *tmp___0 ;

  {
#line 307
  SHA256Init(& context);
#line 309
  while (1) {
#line 311
    size = fread((void *)(buffer), (size_t )1, sizeof(buffer), file);
#line 312
    tmp = ferror(file);
#line 312
    if (tmp) {
#line 313
      return (-1);
    }
#line 315
    if (size == 0UL) {
#line 316
      break;
    }
#line 318
    SHA256Update(& context, (void const   *)(buffer), (uint32_t )size);
  }
#line 321
  tmp___0 = malloc((size_t )32);
#line 321
  *result = (uint8_t *)tmp___0;
#line 322
  SHA256Final(& context, (uint8_t *)*result);
#line 323
  return (0);
}
}
#line 328 "duffentry.c"
static int get_entry_digest_sha384(uint8_t **result , FILE *file ) 
{ size_t size ;
  char buffer[8192] ;
  SHA384Context context ;
  int tmp ;
  void *tmp___0 ;

  {
#line 334
  SHA384Init(& context);
#line 336
  while (1) {
#line 338
    size = fread((void *)(buffer), (size_t )1, sizeof(buffer), file);
#line 339
    tmp = ferror(file);
#line 339
    if (tmp) {
#line 340
      return (-1);
    }
#line 342
    if (size == 0UL) {
#line 343
      break;
    }
#line 345
    SHA384Update(& context, (void const   *)(buffer), (uint32_t )size);
  }
#line 348
  tmp___0 = malloc((size_t )48);
#line 348
  *result = (uint8_t *)tmp___0;
#line 349
  SHA384Final(& context, (uint8_t *)*result);
#line 350
  return (0);
}
}
#line 355 "duffentry.c"
static int get_entry_digest_sha512(uint8_t **result , FILE *file ) 
{ size_t size ;
  char buffer[8192] ;
  SHA512Context context ;
  int tmp ;
  void *tmp___0 ;

  {
#line 361
  SHA512Init(& context);
#line 363
  while (1) {
#line 365
    size = fread((void *)(buffer), (size_t )1, sizeof(buffer), file);
#line 366
    tmp = ferror(file);
#line 366
    if (tmp) {
#line 367
      return (-1);
    }
#line 369
    if (size == 0UL) {
#line 370
      break;
    }
#line 372
    SHA512Update(& context, (void const   *)(buffer), (uint32_t )size);
  }
#line 375
  tmp___0 = malloc((size_t )64);
#line 375
  *result = (uint8_t *)tmp___0;
#line 376
  SHA512Final(& context, (uint8_t *)*result);
#line 377
  return (0);
}
}
#line 385 "duffentry.c"
int compare_entries(Entry *first , Entry *second ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 387
  if (first->size != second->size) {
#line 388
    return (-1);
  }
#line 390
  if (first->size >= sample_limit) {
#line 392
    tmp = compare_entry_samples(first, second);
#line 392
    if (tmp != 0) {
#line 393
      return (-1);
    }
  }
#line 396
  if (thorough_flag) {
#line 398
    tmp___0 = compare_entry_contents(first, second);
#line 398
    if (tmp___0 != 0) {
#line 399
      return (-1);
    }
  } else {
#line 405
    tmp___1 = compare_entry_digests(first, second);
#line 405
    if (tmp___1 != 0) {
#line 406
      return (-1);
    }
  }
#line 409
  return (0);
}
}
#line 414 "duffentry.c"
static int compare_entry_digests(Entry *first , Entry *second ) 
{ int i ;
  int digest_size ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
#line 418
  tmp = get_entry_digest(first);
#line 418
  if (tmp != 0) {
#line 419
    return (-1);
  }
#line 421
  tmp___0 = get_entry_digest(second);
#line 421
  if (tmp___0 != 0) {
#line 422
    return (-1);
  }
#line 424
  tmp___1 = get_digest_size();
#line 424
  digest_size = (int )tmp___1;
#line 425
  i = 0;
#line 425
  while (i < digest_size) {
#line 426
    if ((int )*(first->digest + i) != (int )*(second->digest + i)) {
#line 427
      return (-1);
    }
#line 425
    i ++;
  }
#line 429
  return (0);
}
}
#line 434 "duffentry.c"
static int compare_entry_samples(Entry *first , Entry *second ) 
{ int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 438
  tmp = get_entry_samples(first);
#line 438
  if (tmp != 0) {
#line 439
    return (-1);
  }
#line 441
  tmp___0 = get_entry_samples(second);
#line 441
  if (tmp___0 != 0) {
#line 442
    return (-1);
  }
#line 444
  i = 0;
#line 444
  while (i < 10) {
#line 445
    if ((int )*(first->samples + i) != (int )*(second->samples + i)) {
#line 446
      return (-1);
    }
#line 444
    i ++;
  }
#line 448
  return (0);
}
}
#line 458 "duffentry.c"
static int compare_entry_contents(Entry *first , Entry *second ) 
{ int fc ;
  int sc ;
  int result ;
  FILE *first_stream ;
  FILE *second_stream ;

  {
#line 460
  result = 0;
#line 464
  if (first->size == 0LL) {
#line 465
    return (0);
  }
#line 467
  first_stream = fopen((char const   *)first->path, "rb");
#line 468
  second_stream = fopen((char const   *)second->path, "rb");
#line 470
  if (! first_stream) {
#line 470
    goto _L;
  } else
#line 470
  if (! second_stream) {
    _L: /* CIL Label */ 
#line 472
    if (first_stream) {
#line 473
      fclose(first_stream);
    }
#line 474
    if (second_stream) {
#line 475
      fclose(second_stream);
    }
#line 476
    return (-1);
  }
#line 479
  while (1) {
#line 481
    fc = fgetc(first_stream);
#line 482
    sc = fgetc(second_stream);
#line 483
    if (fc != sc) {
#line 485
      result = -1;
#line 486
      break;
    }
#line 479
    if (! (fc != -1)) {
#line 479
      break;
    }
  }
#line 491
  fclose(first_stream);
#line 492
  fclose(second_stream);
#line 493
  return (result);
}
}
#line 1 "duffstring.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-sQcbo2BO.i","-g,-O2")
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 1 "duffutil.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-s_MWd62V.i","-g,-O2")
#line 166 "/usr/include/stdio.h"
extern FILE *__stderrp ;
#line 246
extern char *fgets(char * , int  , FILE * ) ;
#line 252
extern int ( /* format attribute */  fprintf)(FILE * , char const   *  , ...) ;
#line 269
extern int putchar(int  ) ;
#line 469
extern int ( /* format attribute */  vasprintf)(char ** , char const   * , va_list  ) ;
#line 92 "/usr/include/string.h"
extern size_t strlen(char const   * ) ;
#line 97
extern char *strrchr(char const   * , int  ) ;
#line 132 "/usr/include/runetype.h"
extern _RuneLocale _DefaultRuneLocale ;
#line 151 "/usr/include/ctype.h"
__inline static int isascii(int _c ) 
{ 

  {
#line 154
  return ((_c & -128) == 0);
}
}
#line 165
extern int __maskrune(__darwin_ct_rune_t  , unsigned long  ) ;
#line 169 "/usr/include/ctype.h"
__inline static int __istype(__darwin_ct_rune_t _c , unsigned long _f ) 
{ int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 175
  tmp___3 = isascii(_c);
#line 175
  if (tmp___3) {
#line 175
    tmp___2 = ! (! ((unsigned long )_DefaultRuneLocale.__runetype[_c] & _f));
  } else {
#line 175
    tmp___0 = __maskrune(_c, _f);
#line 175
    if (tmp___0) {
#line 175
      tmp___1 = 1;
    } else {
#line 175
      tmp___1 = 0;
    }
#line 175
    tmp___2 = tmp___1;
  }
#line 175
  return (tmp___2);
}
}
#line 259 "/usr/include/ctype.h"
__inline static int isgraph(int _c ) 
{ int tmp ;

  {
#line 262
  tmp = __istype(_c, 2048UL);
#line 262
  return (tmp);
}
}
#line 283 "/usr/include/ctype.h"
__inline static int isspace(int _c ) 
{ int tmp ;

  {
#line 286
  tmp = __istype(_c, 16384UL);
#line 286
  return (tmp);
}
}
#line 72 "duffutil.c"
int read_path(FILE *stream , char *path , size_t size ) 
{ int c ;
  int i ;
  size_t length ;
  int tmp ;
  char *tmp___0 ;

  {
#line 74
  i = 0;
#line 77
  if (null_terminate_flag) {
#line 79
    while ((size_t )i < size) {
#line 81
      c = fgetc(stream);
#line 81
      if (c == -1) {
#line 82
        return (-1);
      }
#line 84
      tmp = i;
#line 84
      i ++;
#line 84
      *(path + tmp) = (char )c;
#line 85
      if (c == 0) {
#line 86
        break;
      }
    }
  } else {
#line 91
    tmp___0 = fgets(path, (int )size, stream);
#line 91
    if (! tmp___0) {
#line 92
      return (-1);
    }
#line 95
    length = strlen((char const   *)path);
#line 96
    if (length > 0UL) {
#line 96
      if ((int )*(path + (length - 1UL)) == 10) {
#line 97
        *(path + (length - 1UL)) = (char )'\000';
      }
    }
  }
#line 100
  return (0);
}
}
#line 105 "duffutil.c"
void kill_trailing_slashes(char *path ) 
{ char *temp ;

  {
#line 109
  while (1) {
#line 109
    temp = strrchr((char const   *)path, '/');
#line 109
    if (! temp) {
#line 109
      break;
    }
#line 111
    if ((unsigned long )temp == (unsigned long )path) {
#line 112
      break;
    } else
#line 111
    if ((int )*(temp + 1) != 0) {
#line 112
      break;
    }
#line 113
    *temp = (char )'\000';
  }
#line 115
  return;
}
}
#line 119 "duffutil.c"
size_t get_digest_size(void) 
{ 

  {
#line 121
  switch ((int )digest_function) {
  case 0: 
#line 124
  return ((size_t )20);
  case 1: 
#line 126
  return ((size_t )32);
  case 2: 
#line 128
  return ((size_t )48);
  case 3: 
#line 130
  return ((size_t )64);
  }
#line 133
  error("This cannot happen");
#line 134
  return (0UL);
}
}
#line 138 "duffutil.c"
void error(char const   *format  , ...) 
{ char *message ;
  int result ;
  va_list vl ;

  {
#line 144
  __builtin_va_start(vl, format);
#line 145
  result = vasprintf(& message, format, vl);
#line 146
  __builtin_va_end(vl);
#line 148
  if (result > 0) {
#line 150
    fprintf(__stderrp, "%s\n", message);
#line 151
    free((void *)message);
  }
#line 154
  exit(1);
}
}
#line 159 "duffutil.c"
void warning(char const   *format  , ...) 
{ char *message ;
  int result ;
  va_list vl ;

  {
#line 165
  __builtin_va_start(vl, format);
#line 166
  result = vasprintf(& message, format, vl);
#line 167
  __builtin_va_end(vl);
#line 169
  if (result > 0) {
#line 171
    fprintf(__stderrp, "%s\n", message);
#line 172
    free((void *)message);
  }
#line 174
  return;
}
}
#line 181 "duffutil.c"
void print_cluster_header(char const   *format , unsigned int count , unsigned int index___0 ,
                          off_t size , uint8_t const   *digest ) 
{ int i ;
  int digest_size ;
  char const   *c ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 190
  c = format;
#line 190
  while ((int const   )*c != 0) {
#line 192
    if ((int const   )*c == 37) {
#line 194
      c ++;
#line 195
      switch ((int )*c) {
      case 115: 
#line 198
      printf("%lli", size);
#line 199
      break;
      case 105: 
#line 201
      printf("%u", index___0);
#line 202
      break;
      case 110: 
#line 204
      printf("%u", count);
#line 205
      break;
      case 99: 
      case 100: 
#line 208
      tmp = get_digest_size();
#line 208
      digest_size = (int )tmp;
#line 209
      i = 0;
#line 209
      while (i < digest_size) {
#line 210
        printf("%02x", (int const   )*(digest + i));
#line 209
        i ++;
      }
#line 211
      break;
      case 37: 
#line 213
      putchar('%');
#line 214
      break;
      case 0: 
#line 216
      putchar('\n');
#line 217
      return;
      default: 
#line 223
      tmp___0 = isgraph((int )*c);
#line 223
      if (tmp___0) {
#line 225
        putchar('%');
#line 226
        putchar((int )*c);
      } else {
#line 223
        tmp___1 = isspace((int )*c);
#line 223
        if (tmp___1) {
#line 225
          putchar('%');
#line 226
          putchar((int )*c);
        }
      }
      }
    } else {
#line 231
      putchar((int )*c);
    }
#line 190
    c ++;
  }
#line 233
  return;
}
}
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
#line 1 "sha1.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-rjdb3hJa.i","-g,-O2")
#line 58 "/usr/include/secure/_string.h"
__inline static void *__inline_memcpy_chk(void *__dest , void const   *__src , size_t __len ) 
{ unsigned long tmp ;
  void *tmp___0 ;

  {
#line 61
  tmp = __builtin_object_size(__dest, 0);
#line 61
  tmp___0 = __builtin___memcpy_chk(__dest, __src, __len, tmp);
#line 61
  return (tmp___0);
}
}
#line 80 "/usr/include/secure/_string.h"
__inline static void *__inline_memset_chk(void *__dest , int __val , size_t __len ) 
{ unsigned long tmp ;
  void *tmp___0 ;

  {
#line 83
  tmp = __builtin_object_size(__dest, 0);
#line 83
  tmp___0 = __builtin___memset_chk(__dest, __val, __len, tmp);
#line 83
  return (tmp___0);
}
}
#line 96 "sha1.c"
__inline static uint64_t _byteswap64(uint64_t x ) 
{ uint32_t a ;
  uint32_t b ;

  {
#line 98
  a = (uint32_t )(x >> 32);
#line 99
  b = (uint32_t )x;
#line 100
  return (((uint64_t )(((long )((b >> 8) | (b << 24)) & 4278255360L) | ((long )((b << 8) | (b >> 24)) & 16711935L)) << 32) | (uint64_t )(((long )((a >> 8) | (a << 24)) & 4278255360L) | ((long )((a << 8) | (a >> 24)) & 16711935L)));
}
}
#line 150 "sha1.c"
static uint8_t const   padding[64]  = 
#line 150
  {      (uint8_t const   )128,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0};
#line 161 "sha1.c"
void SHA1Init(SHA1Context *sc ) 
{ 

  {
#line 168
  sc->totalLength = (uint64_t )0LL;
#line 169
  sc->hash[0] = (uint32_t )1732584193L;
#line 170
  sc->hash[1] = (uint32_t )4023233417L;
#line 171
  sc->hash[2] = (uint32_t )2562383102L;
#line 172
  sc->hash[3] = (uint32_t )271733878L;
#line 173
  sc->hash[4] = (uint32_t )3285377520L;
#line 174
  sc->bufferLength = (uint32_t )0L;
#line 175
  return;
}
}
#line 177 "sha1.c"
static void burnStack(int size ) 
{ char buf[128] ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 182
  tmp___0 = __builtin_object_size((void *)(buf), 0);
#line 182
  if (tmp___0 != 0xffffffffffffffffUL) {
#line 182
    tmp = __builtin_object_size((void *)(buf), 0);
#line 182
    __builtin___memset_chk((void *)(buf), 0, sizeof(buf), tmp);
  } else {
#line 182
    __inline_memset_chk((void *)(buf), 0, sizeof(buf));
  }
#line 183
  size = (int )((unsigned long )size - sizeof(buf));
#line 184
  if (size > 0) {
#line 185
    burnStack(size);
  }
#line 186
  return;
}
}
#line 188 "sha1.c"
static void SHA1Guts(SHA1Context *sc , uint32_t const   *cbuf ) 
{ uint32_t buf[80] ;
  uint32_t *W ;
  uint32_t *W3 ;
  uint32_t *W8 ;
  uint32_t *W14 ;
  uint32_t *W16 ;
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  uint32_t d ;
  uint32_t e ;
  uint32_t temp ;
  int i ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t *tmp___2 ;
  uint32_t *tmp___3 ;
  uint32_t *tmp___4 ;
  uint32_t *tmp___5 ;
  uint32_t *tmp___6 ;
  uint32_t *tmp___7 ;
  uint32_t *tmp___8 ;
  uint32_t *tmp___9 ;
  uint32_t *tmp___10 ;
  uint32_t *tmp___11 ;
  uint32_t *tmp___12 ;
  uint32_t *tmp___13 ;
  uint32_t *tmp___14 ;
  uint32_t *tmp___15 ;
  uint32_t *tmp___16 ;
  uint32_t *tmp___17 ;
  uint32_t *tmp___18 ;
  uint32_t *tmp___19 ;
  uint32_t *tmp___20 ;
  uint32_t *tmp___21 ;
  uint32_t *tmp___22 ;
  uint32_t *tmp___23 ;
  uint32_t *tmp___24 ;
  uint32_t *tmp___25 ;
  uint32_t *tmp___26 ;
  uint32_t *tmp___27 ;
  uint32_t *tmp___28 ;
  uint32_t *tmp___29 ;
  uint32_t *tmp___30 ;
  uint32_t *tmp___31 ;
  uint32_t *tmp___32 ;
  uint32_t *tmp___33 ;
  uint32_t *tmp___34 ;
  uint32_t *tmp___35 ;
  uint32_t *tmp___36 ;
  uint32_t *tmp___37 ;
  uint32_t *tmp___38 ;
  uint32_t *tmp___39 ;
  uint32_t *tmp___40 ;
  uint32_t *tmp___41 ;
  uint32_t *tmp___42 ;
  uint32_t *tmp___43 ;
  uint32_t *tmp___44 ;
  uint32_t *tmp___45 ;
  uint32_t *tmp___46 ;
  uint32_t *tmp___47 ;
  uint32_t *tmp___48 ;
  uint32_t *tmp___49 ;
  uint32_t *tmp___50 ;
  uint32_t *tmp___51 ;
  uint32_t *tmp___52 ;
  uint32_t *tmp___53 ;
  uint32_t *tmp___54 ;
  uint32_t *tmp___55 ;
  uint32_t *tmp___56 ;
  uint32_t *tmp___57 ;
  uint32_t *tmp___58 ;
  uint32_t *tmp___59 ;
  uint32_t *tmp___60 ;
  uint32_t *tmp___61 ;
  uint32_t *tmp___62 ;
  uint32_t *tmp___63 ;
  uint32_t *tmp___64 ;
  uint32_t *tmp___65 ;
  uint32_t *tmp___66 ;
  uint32_t *tmp___67 ;
  uint32_t *tmp___68 ;
  uint32_t *tmp___69 ;
  uint32_t *tmp___70 ;
  uint32_t *tmp___71 ;
  uint32_t *tmp___72 ;
  uint32_t *tmp___73 ;
  uint32_t *tmp___74 ;
  uint32_t *tmp___75 ;
  uint32_t *tmp___76 ;
  uint32_t *tmp___77 ;
  uint32_t *tmp___78 ;
  uint32_t *tmp___79 ;
  uint32_t *tmp___80 ;
  uint32_t *tmp___81 ;
  uint32_t *tmp___82 ;
  uint32_t *tmp___83 ;

  {
#line 196
  W = buf;
#line 198
  i = 15;
#line 198
  while (i >= 0) {
#line 199
    tmp = W;
#line 199
    W ++;
#line 199
    *tmp = (uint32_t )(((long )((*cbuf >> 8) | (*cbuf << 24)) & 4278255360L) | ((long )((*cbuf << 8) | (*cbuf >> 24)) & 16711935L));
#line 200
    cbuf ++;
#line 198
    i --;
  }
#line 203
  W16 = & buf[0];
#line 204
  W14 = & buf[2];
#line 205
  W8 = & buf[8];
#line 206
  W3 = & buf[13];
#line 208
  i = 63;
#line 208
  while (i >= 0) {
#line 209
    tmp___0 = W3;
#line 209
    W3 ++;
#line 209
    tmp___1 = W8;
#line 209
    W8 ++;
#line 209
    tmp___2 = W14;
#line 209
    W14 ++;
#line 209
    tmp___3 = W16;
#line 209
    W16 ++;
#line 209
    *W = ((*tmp___0 ^ *tmp___1) ^ *tmp___2) ^ *tmp___3;
#line 210
    *W = (*W << 1) | (*W >> 31);
#line 211
    W ++;
#line 208
    i --;
  }
#line 214
  a = sc->hash[0];
#line 215
  b = sc->hash[1];
#line 216
  c = sc->hash[2];
#line 217
  d = sc->hash[3];
#line 218
  e = sc->hash[4];
#line 220
  W = buf;
#line 371
  tmp___4 = W;
#line 371
  W ++;
#line 371
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + e) + *tmp___4) + 1518500249L);
#line 371
  e = d;
#line 371
  d = c;
#line 371
  c = (b << 30) | (b >> 2);
#line 371
  b = a;
#line 371
  a = temp;
#line 372
  tmp___5 = W;
#line 372
  W ++;
#line 372
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + e) + *tmp___5) + 1518500249L);
#line 372
  e = d;
#line 372
  d = c;
#line 372
  c = (b << 30) | (b >> 2);
#line 372
  b = a;
#line 372
  a = temp;
#line 373
  tmp___6 = W;
#line 373
  W ++;
#line 373
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + e) + *tmp___6) + 1518500249L);
#line 373
  e = d;
#line 373
  d = c;
#line 373
  c = (b << 30) | (b >> 2);
#line 373
  b = a;
#line 373
  a = temp;
#line 374
  tmp___7 = W;
#line 374
  W ++;
#line 374
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + e) + *tmp___7) + 1518500249L);
#line 374
  e = d;
#line 374
  d = c;
#line 374
  c = (b << 30) | (b >> 2);
#line 374
  b = a;
#line 374
  a = temp;
#line 375
  tmp___8 = W;
#line 375
  W ++;
#line 375
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + e) + *tmp___8) + 1518500249L);
#line 375
  e = d;
#line 375
  d = c;
#line 375
  c = (b << 30) | (b >> 2);
#line 375
  b = a;
#line 375
  a = temp;
#line 376
  tmp___9 = W;
#line 376
  W ++;
#line 376
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + e) + *tmp___9) + 1518500249L);
#line 376
  e = d;
#line 376
  d = c;
#line 376
  c = (b << 30) | (b >> 2);
#line 376
  b = a;
#line 376
  a = temp;
#line 377
  tmp___10 = W;
#line 377
  W ++;
#line 377
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + e) + *tmp___10) + 1518500249L);
#line 377
  e = d;
#line 377
  d = c;
#line 377
  c = (b << 30) | (b >> 2);
#line 377
  b = a;
#line 377
  a = temp;
#line 378
  tmp___11 = W;
#line 378
  W ++;
#line 378
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + e) + *tmp___11) + 1518500249L);
#line 378
  e = d;
#line 378
  d = c;
#line 378
  c = (b << 30) | (b >> 2);
#line 378
  b = a;
#line 378
  a = temp;
#line 379
  tmp___12 = W;
#line 379
  W ++;
#line 379
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + e) + *tmp___12) + 1518500249L);
#line 379
  e = d;
#line 379
  d = c;
#line 379
  c = (b << 30) | (b >> 2);
#line 379
  b = a;
#line 379
  a = temp;
#line 380
  tmp___13 = W;
#line 380
  W ++;
#line 380
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + e) + *tmp___13) + 1518500249L);
#line 380
  e = d;
#line 380
  d = c;
#line 380
  c = (b << 30) | (b >> 2);
#line 380
  b = a;
#line 380
  a = temp;
#line 381
  tmp___14 = W;
#line 381
  W ++;
#line 381
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + e) + *tmp___14) + 1518500249L);
#line 381
  e = d;
#line 381
  d = c;
#line 381
  c = (b << 30) | (b >> 2);
#line 381
  b = a;
#line 381
  a = temp;
#line 382
  tmp___15 = W;
#line 382
  W ++;
#line 382
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + e) + *tmp___15) + 1518500249L);
#line 382
  e = d;
#line 382
  d = c;
#line 382
  c = (b << 30) | (b >> 2);
#line 382
  b = a;
#line 382
  a = temp;
#line 383
  tmp___16 = W;
#line 383
  W ++;
#line 383
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + e) + *tmp___16) + 1518500249L);
#line 383
  e = d;
#line 383
  d = c;
#line 383
  c = (b << 30) | (b >> 2);
#line 383
  b = a;
#line 383
  a = temp;
#line 384
  tmp___17 = W;
#line 384
  W ++;
#line 384
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + e) + *tmp___17) + 1518500249L);
#line 384
  e = d;
#line 384
  d = c;
#line 384
  c = (b << 30) | (b >> 2);
#line 384
  b = a;
#line 384
  a = temp;
#line 385
  tmp___18 = W;
#line 385
  W ++;
#line 385
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + e) + *tmp___18) + 1518500249L);
#line 385
  e = d;
#line 385
  d = c;
#line 385
  c = (b << 30) | (b >> 2);
#line 385
  b = a;
#line 385
  a = temp;
#line 386
  tmp___19 = W;
#line 386
  W ++;
#line 386
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + e) + *tmp___19) + 1518500249L);
#line 386
  e = d;
#line 386
  d = c;
#line 386
  c = (b << 30) | (b >> 2);
#line 386
  b = a;
#line 386
  a = temp;
#line 387
  tmp___20 = W;
#line 387
  W ++;
#line 387
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + e) + *tmp___20) + 1518500249L);
#line 387
  e = d;
#line 387
  d = c;
#line 387
  c = (b << 30) | (b >> 2);
#line 387
  b = a;
#line 387
  a = temp;
#line 388
  tmp___21 = W;
#line 388
  W ++;
#line 388
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + e) + *tmp___21) + 1518500249L);
#line 388
  e = d;
#line 388
  d = c;
#line 388
  c = (b << 30) | (b >> 2);
#line 388
  b = a;
#line 388
  a = temp;
#line 389
  tmp___22 = W;
#line 389
  W ++;
#line 389
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + e) + *tmp___22) + 1518500249L);
#line 389
  e = d;
#line 389
  d = c;
#line 389
  c = (b << 30) | (b >> 2);
#line 389
  b = a;
#line 389
  a = temp;
#line 390
  tmp___23 = W;
#line 390
  W ++;
#line 390
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + e) + *tmp___23) + 1518500249L);
#line 390
  e = d;
#line 390
  d = c;
#line 390
  c = (b << 30) | (b >> 2);
#line 390
  b = a;
#line 390
  a = temp;
#line 392
  tmp___24 = W;
#line 392
  W ++;
#line 392
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___24) + 1859775393L);
#line 392
  e = d;
#line 392
  d = c;
#line 392
  c = (b << 30) | (b >> 2);
#line 392
  b = a;
#line 392
  a = temp;
#line 393
  tmp___25 = W;
#line 393
  W ++;
#line 393
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___25) + 1859775393L);
#line 393
  e = d;
#line 393
  d = c;
#line 393
  c = (b << 30) | (b >> 2);
#line 393
  b = a;
#line 393
  a = temp;
#line 394
  tmp___26 = W;
#line 394
  W ++;
#line 394
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___26) + 1859775393L);
#line 394
  e = d;
#line 394
  d = c;
#line 394
  c = (b << 30) | (b >> 2);
#line 394
  b = a;
#line 394
  a = temp;
#line 395
  tmp___27 = W;
#line 395
  W ++;
#line 395
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___27) + 1859775393L);
#line 395
  e = d;
#line 395
  d = c;
#line 395
  c = (b << 30) | (b >> 2);
#line 395
  b = a;
#line 395
  a = temp;
#line 396
  tmp___28 = W;
#line 396
  W ++;
#line 396
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___28) + 1859775393L);
#line 396
  e = d;
#line 396
  d = c;
#line 396
  c = (b << 30) | (b >> 2);
#line 396
  b = a;
#line 396
  a = temp;
#line 397
  tmp___29 = W;
#line 397
  W ++;
#line 397
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___29) + 1859775393L);
#line 397
  e = d;
#line 397
  d = c;
#line 397
  c = (b << 30) | (b >> 2);
#line 397
  b = a;
#line 397
  a = temp;
#line 398
  tmp___30 = W;
#line 398
  W ++;
#line 398
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___30) + 1859775393L);
#line 398
  e = d;
#line 398
  d = c;
#line 398
  c = (b << 30) | (b >> 2);
#line 398
  b = a;
#line 398
  a = temp;
#line 399
  tmp___31 = W;
#line 399
  W ++;
#line 399
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___31) + 1859775393L);
#line 399
  e = d;
#line 399
  d = c;
#line 399
  c = (b << 30) | (b >> 2);
#line 399
  b = a;
#line 399
  a = temp;
#line 400
  tmp___32 = W;
#line 400
  W ++;
#line 400
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___32) + 1859775393L);
#line 400
  e = d;
#line 400
  d = c;
#line 400
  c = (b << 30) | (b >> 2);
#line 400
  b = a;
#line 400
  a = temp;
#line 401
  tmp___33 = W;
#line 401
  W ++;
#line 401
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___33) + 1859775393L);
#line 401
  e = d;
#line 401
  d = c;
#line 401
  c = (b << 30) | (b >> 2);
#line 401
  b = a;
#line 401
  a = temp;
#line 402
  tmp___34 = W;
#line 402
  W ++;
#line 402
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___34) + 1859775393L);
#line 402
  e = d;
#line 402
  d = c;
#line 402
  c = (b << 30) | (b >> 2);
#line 402
  b = a;
#line 402
  a = temp;
#line 403
  tmp___35 = W;
#line 403
  W ++;
#line 403
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___35) + 1859775393L);
#line 403
  e = d;
#line 403
  d = c;
#line 403
  c = (b << 30) | (b >> 2);
#line 403
  b = a;
#line 403
  a = temp;
#line 404
  tmp___36 = W;
#line 404
  W ++;
#line 404
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___36) + 1859775393L);
#line 404
  e = d;
#line 404
  d = c;
#line 404
  c = (b << 30) | (b >> 2);
#line 404
  b = a;
#line 404
  a = temp;
#line 405
  tmp___37 = W;
#line 405
  W ++;
#line 405
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___37) + 1859775393L);
#line 405
  e = d;
#line 405
  d = c;
#line 405
  c = (b << 30) | (b >> 2);
#line 405
  b = a;
#line 405
  a = temp;
#line 406
  tmp___38 = W;
#line 406
  W ++;
#line 406
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___38) + 1859775393L);
#line 406
  e = d;
#line 406
  d = c;
#line 406
  c = (b << 30) | (b >> 2);
#line 406
  b = a;
#line 406
  a = temp;
#line 407
  tmp___39 = W;
#line 407
  W ++;
#line 407
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___39) + 1859775393L);
#line 407
  e = d;
#line 407
  d = c;
#line 407
  c = (b << 30) | (b >> 2);
#line 407
  b = a;
#line 407
  a = temp;
#line 408
  tmp___40 = W;
#line 408
  W ++;
#line 408
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___40) + 1859775393L);
#line 408
  e = d;
#line 408
  d = c;
#line 408
  c = (b << 30) | (b >> 2);
#line 408
  b = a;
#line 408
  a = temp;
#line 409
  tmp___41 = W;
#line 409
  W ++;
#line 409
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___41) + 1859775393L);
#line 409
  e = d;
#line 409
  d = c;
#line 409
  c = (b << 30) | (b >> 2);
#line 409
  b = a;
#line 409
  a = temp;
#line 410
  tmp___42 = W;
#line 410
  W ++;
#line 410
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___42) + 1859775393L);
#line 410
  e = d;
#line 410
  d = c;
#line 410
  c = (b << 30) | (b >> 2);
#line 410
  b = a;
#line 410
  a = temp;
#line 411
  tmp___43 = W;
#line 411
  W ++;
#line 411
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___43) + 1859775393L);
#line 411
  e = d;
#line 411
  d = c;
#line 411
  c = (b << 30) | (b >> 2);
#line 411
  b = a;
#line 411
  a = temp;
#line 413
  tmp___44 = W;
#line 413
  W ++;
#line 413
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b & (c | d)) | (c & d))) + e) + *tmp___44) + 2400959708L);
#line 413
  e = d;
#line 413
  d = c;
#line 413
  c = (b << 30) | (b >> 2);
#line 413
  b = a;
#line 413
  a = temp;
#line 414
  tmp___45 = W;
#line 414
  W ++;
#line 414
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b & (c | d)) | (c & d))) + e) + *tmp___45) + 2400959708L);
#line 414
  e = d;
#line 414
  d = c;
#line 414
  c = (b << 30) | (b >> 2);
#line 414
  b = a;
#line 414
  a = temp;
#line 415
  tmp___46 = W;
#line 415
  W ++;
#line 415
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b & (c | d)) | (c & d))) + e) + *tmp___46) + 2400959708L);
#line 415
  e = d;
#line 415
  d = c;
#line 415
  c = (b << 30) | (b >> 2);
#line 415
  b = a;
#line 415
  a = temp;
#line 416
  tmp___47 = W;
#line 416
  W ++;
#line 416
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b & (c | d)) | (c & d))) + e) + *tmp___47) + 2400959708L);
#line 416
  e = d;
#line 416
  d = c;
#line 416
  c = (b << 30) | (b >> 2);
#line 416
  b = a;
#line 416
  a = temp;
#line 417
  tmp___48 = W;
#line 417
  W ++;
#line 417
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b & (c | d)) | (c & d))) + e) + *tmp___48) + 2400959708L);
#line 417
  e = d;
#line 417
  d = c;
#line 417
  c = (b << 30) | (b >> 2);
#line 417
  b = a;
#line 417
  a = temp;
#line 418
  tmp___49 = W;
#line 418
  W ++;
#line 418
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b & (c | d)) | (c & d))) + e) + *tmp___49) + 2400959708L);
#line 418
  e = d;
#line 418
  d = c;
#line 418
  c = (b << 30) | (b >> 2);
#line 418
  b = a;
#line 418
  a = temp;
#line 419
  tmp___50 = W;
#line 419
  W ++;
#line 419
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b & (c | d)) | (c & d))) + e) + *tmp___50) + 2400959708L);
#line 419
  e = d;
#line 419
  d = c;
#line 419
  c = (b << 30) | (b >> 2);
#line 419
  b = a;
#line 419
  a = temp;
#line 420
  tmp___51 = W;
#line 420
  W ++;
#line 420
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b & (c | d)) | (c & d))) + e) + *tmp___51) + 2400959708L);
#line 420
  e = d;
#line 420
  d = c;
#line 420
  c = (b << 30) | (b >> 2);
#line 420
  b = a;
#line 420
  a = temp;
#line 421
  tmp___52 = W;
#line 421
  W ++;
#line 421
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b & (c | d)) | (c & d))) + e) + *tmp___52) + 2400959708L);
#line 421
  e = d;
#line 421
  d = c;
#line 421
  c = (b << 30) | (b >> 2);
#line 421
  b = a;
#line 421
  a = temp;
#line 422
  tmp___53 = W;
#line 422
  W ++;
#line 422
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b & (c | d)) | (c & d))) + e) + *tmp___53) + 2400959708L);
#line 422
  e = d;
#line 422
  d = c;
#line 422
  c = (b << 30) | (b >> 2);
#line 422
  b = a;
#line 422
  a = temp;
#line 423
  tmp___54 = W;
#line 423
  W ++;
#line 423
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b & (c | d)) | (c & d))) + e) + *tmp___54) + 2400959708L);
#line 423
  e = d;
#line 423
  d = c;
#line 423
  c = (b << 30) | (b >> 2);
#line 423
  b = a;
#line 423
  a = temp;
#line 424
  tmp___55 = W;
#line 424
  W ++;
#line 424
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b & (c | d)) | (c & d))) + e) + *tmp___55) + 2400959708L);
#line 424
  e = d;
#line 424
  d = c;
#line 424
  c = (b << 30) | (b >> 2);
#line 424
  b = a;
#line 424
  a = temp;
#line 425
  tmp___56 = W;
#line 425
  W ++;
#line 425
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b & (c | d)) | (c & d))) + e) + *tmp___56) + 2400959708L);
#line 425
  e = d;
#line 425
  d = c;
#line 425
  c = (b << 30) | (b >> 2);
#line 425
  b = a;
#line 425
  a = temp;
#line 426
  tmp___57 = W;
#line 426
  W ++;
#line 426
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b & (c | d)) | (c & d))) + e) + *tmp___57) + 2400959708L);
#line 426
  e = d;
#line 426
  d = c;
#line 426
  c = (b << 30) | (b >> 2);
#line 426
  b = a;
#line 426
  a = temp;
#line 427
  tmp___58 = W;
#line 427
  W ++;
#line 427
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b & (c | d)) | (c & d))) + e) + *tmp___58) + 2400959708L);
#line 427
  e = d;
#line 427
  d = c;
#line 427
  c = (b << 30) | (b >> 2);
#line 427
  b = a;
#line 427
  a = temp;
#line 428
  tmp___59 = W;
#line 428
  W ++;
#line 428
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b & (c | d)) | (c & d))) + e) + *tmp___59) + 2400959708L);
#line 428
  e = d;
#line 428
  d = c;
#line 428
  c = (b << 30) | (b >> 2);
#line 428
  b = a;
#line 428
  a = temp;
#line 429
  tmp___60 = W;
#line 429
  W ++;
#line 429
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b & (c | d)) | (c & d))) + e) + *tmp___60) + 2400959708L);
#line 429
  e = d;
#line 429
  d = c;
#line 429
  c = (b << 30) | (b >> 2);
#line 429
  b = a;
#line 429
  a = temp;
#line 430
  tmp___61 = W;
#line 430
  W ++;
#line 430
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b & (c | d)) | (c & d))) + e) + *tmp___61) + 2400959708L);
#line 430
  e = d;
#line 430
  d = c;
#line 430
  c = (b << 30) | (b >> 2);
#line 430
  b = a;
#line 430
  a = temp;
#line 431
  tmp___62 = W;
#line 431
  W ++;
#line 431
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b & (c | d)) | (c & d))) + e) + *tmp___62) + 2400959708L);
#line 431
  e = d;
#line 431
  d = c;
#line 431
  c = (b << 30) | (b >> 2);
#line 431
  b = a;
#line 431
  a = temp;
#line 432
  tmp___63 = W;
#line 432
  W ++;
#line 432
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b & (c | d)) | (c & d))) + e) + *tmp___63) + 2400959708L);
#line 432
  e = d;
#line 432
  d = c;
#line 432
  c = (b << 30) | (b >> 2);
#line 432
  b = a;
#line 432
  a = temp;
#line 434
  tmp___64 = W;
#line 434
  W ++;
#line 434
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___64) + 3395469782L);
#line 434
  e = d;
#line 434
  d = c;
#line 434
  c = (b << 30) | (b >> 2);
#line 434
  b = a;
#line 434
  a = temp;
#line 435
  tmp___65 = W;
#line 435
  W ++;
#line 435
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___65) + 3395469782L);
#line 435
  e = d;
#line 435
  d = c;
#line 435
  c = (b << 30) | (b >> 2);
#line 435
  b = a;
#line 435
  a = temp;
#line 436
  tmp___66 = W;
#line 436
  W ++;
#line 436
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___66) + 3395469782L);
#line 436
  e = d;
#line 436
  d = c;
#line 436
  c = (b << 30) | (b >> 2);
#line 436
  b = a;
#line 436
  a = temp;
#line 437
  tmp___67 = W;
#line 437
  W ++;
#line 437
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___67) + 3395469782L);
#line 437
  e = d;
#line 437
  d = c;
#line 437
  c = (b << 30) | (b >> 2);
#line 437
  b = a;
#line 437
  a = temp;
#line 438
  tmp___68 = W;
#line 438
  W ++;
#line 438
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___68) + 3395469782L);
#line 438
  e = d;
#line 438
  d = c;
#line 438
  c = (b << 30) | (b >> 2);
#line 438
  b = a;
#line 438
  a = temp;
#line 439
  tmp___69 = W;
#line 439
  W ++;
#line 439
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___69) + 3395469782L);
#line 439
  e = d;
#line 439
  d = c;
#line 439
  c = (b << 30) | (b >> 2);
#line 439
  b = a;
#line 439
  a = temp;
#line 440
  tmp___70 = W;
#line 440
  W ++;
#line 440
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___70) + 3395469782L);
#line 440
  e = d;
#line 440
  d = c;
#line 440
  c = (b << 30) | (b >> 2);
#line 440
  b = a;
#line 440
  a = temp;
#line 441
  tmp___71 = W;
#line 441
  W ++;
#line 441
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___71) + 3395469782L);
#line 441
  e = d;
#line 441
  d = c;
#line 441
  c = (b << 30) | (b >> 2);
#line 441
  b = a;
#line 441
  a = temp;
#line 442
  tmp___72 = W;
#line 442
  W ++;
#line 442
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___72) + 3395469782L);
#line 442
  e = d;
#line 442
  d = c;
#line 442
  c = (b << 30) | (b >> 2);
#line 442
  b = a;
#line 442
  a = temp;
#line 443
  tmp___73 = W;
#line 443
  W ++;
#line 443
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___73) + 3395469782L);
#line 443
  e = d;
#line 443
  d = c;
#line 443
  c = (b << 30) | (b >> 2);
#line 443
  b = a;
#line 443
  a = temp;
#line 444
  tmp___74 = W;
#line 444
  W ++;
#line 444
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___74) + 3395469782L);
#line 444
  e = d;
#line 444
  d = c;
#line 444
  c = (b << 30) | (b >> 2);
#line 444
  b = a;
#line 444
  a = temp;
#line 445
  tmp___75 = W;
#line 445
  W ++;
#line 445
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___75) + 3395469782L);
#line 445
  e = d;
#line 445
  d = c;
#line 445
  c = (b << 30) | (b >> 2);
#line 445
  b = a;
#line 445
  a = temp;
#line 446
  tmp___76 = W;
#line 446
  W ++;
#line 446
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___76) + 3395469782L);
#line 446
  e = d;
#line 446
  d = c;
#line 446
  c = (b << 30) | (b >> 2);
#line 446
  b = a;
#line 446
  a = temp;
#line 447
  tmp___77 = W;
#line 447
  W ++;
#line 447
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___77) + 3395469782L);
#line 447
  e = d;
#line 447
  d = c;
#line 447
  c = (b << 30) | (b >> 2);
#line 447
  b = a;
#line 447
  a = temp;
#line 448
  tmp___78 = W;
#line 448
  W ++;
#line 448
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___78) + 3395469782L);
#line 448
  e = d;
#line 448
  d = c;
#line 448
  c = (b << 30) | (b >> 2);
#line 448
  b = a;
#line 448
  a = temp;
#line 449
  tmp___79 = W;
#line 449
  W ++;
#line 449
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___79) + 3395469782L);
#line 449
  e = d;
#line 449
  d = c;
#line 449
  c = (b << 30) | (b >> 2);
#line 449
  b = a;
#line 449
  a = temp;
#line 450
  tmp___80 = W;
#line 450
  W ++;
#line 450
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___80) + 3395469782L);
#line 450
  e = d;
#line 450
  d = c;
#line 450
  c = (b << 30) | (b >> 2);
#line 450
  b = a;
#line 450
  a = temp;
#line 451
  tmp___81 = W;
#line 451
  W ++;
#line 451
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___81) + 3395469782L);
#line 451
  e = d;
#line 451
  d = c;
#line 451
  c = (b << 30) | (b >> 2);
#line 451
  b = a;
#line 451
  a = temp;
#line 452
  tmp___82 = W;
#line 452
  W ++;
#line 452
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___82) + 3395469782L);
#line 452
  e = d;
#line 452
  d = c;
#line 452
  c = (b << 30) | (b >> 2);
#line 452
  b = a;
#line 452
  a = temp;
#line 453
  tmp___83 = W;
#line 453
  W ++;
#line 453
  temp = (uint32_t )((long )(((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + *tmp___83) + 3395469782L);
#line 453
  e = d;
#line 453
  d = c;
#line 453
  c = (b << 30) | (b >> 2);
#line 453
  b = a;
#line 453
  a = temp;
#line 458
  sc->hash[0] += a;
#line 459
  sc->hash[1] += b;
#line 460
  sc->hash[2] += c;
#line 461
  sc->hash[3] += d;
#line 462
  sc->hash[4] += e;
#line 463
  return;
}
}
#line 465 "sha1.c"
void SHA1Update(SHA1Context *sc , void const   *vdata , uint32_t len ) 
{ uint8_t const   *data ;
  uint32_t bufferBytesLeft ;
  uint32_t bytesToCopy ;
  int needBurn ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 468
  data = (uint8_t const   *)vdata;
#line 471
  needBurn = 0;
#line 514
  while (len) {
#line 515
    bufferBytesLeft = (uint32_t )(64L - (long )sc->bufferLength);
#line 517
    bytesToCopy = bufferBytesLeft;
#line 518
    if (bytesToCopy > len) {
#line 519
      bytesToCopy = len;
    }
#line 521
    tmp___0 = __builtin_object_size((void *)(& sc->buffer.bytes[sc->bufferLength]),
                                    0);
#line 521
    if (tmp___0 != 0xffffffffffffffffUL) {
#line 521
      tmp = __builtin_object_size((void *)(& sc->buffer.bytes[sc->bufferLength]),
                                  0);
#line 521
      __builtin___memcpy_chk((void *)(& sc->buffer.bytes[sc->bufferLength]), (void const   *)data,
                             (unsigned long )bytesToCopy, tmp);
    } else {
#line 521
      __inline_memcpy_chk((void *)(& sc->buffer.bytes[sc->bufferLength]), (void const   *)data,
                          (size_t )bytesToCopy);
    }
#line 523
    sc->totalLength += (uint64_t )((long )bytesToCopy * 8L);
#line 525
    sc->bufferLength += bytesToCopy;
#line 526
    data += bytesToCopy;
#line 527
    len -= bytesToCopy;
#line 529
    if ((long )sc->bufferLength == 64L) {
#line 530
      SHA1Guts(sc, (uint32_t const   *)(sc->buffer.words));
#line 531
      needBurn = 1;
#line 532
      sc->bufferLength = (uint32_t )0L;
    }
  }
#line 537
  if (needBurn) {
#line 538
    burnStack((int )((sizeof(uint32_t [86]) + sizeof(uint32_t *[5])) + sizeof(int )));
  }
#line 539
  return;
}
}
#line 541 "sha1.c"
void SHA1Final(SHA1Context *sc , uint8_t *hash ) 
{ uint32_t bytesToPad ;
  uint64_t lengthPad ;
  int i ;

  {
#line 548
  bytesToPad = (uint32_t )(120L - (long )sc->bufferLength);
#line 549
  if ((long )bytesToPad > 64L) {
#line 550
    bytesToPad = (uint32_t )((long )bytesToPad - 64L);
  }
#line 552
  lengthPad = _byteswap64(sc->totalLength);
#line 554
  SHA1Update(sc, (void const   *)(padding), bytesToPad);
#line 555
  SHA1Update(sc, (void const   *)(& lengthPad), (uint32_t )8L);
#line 557
  if (hash) {
#line 558
    i = 0;
#line 558
    while (i < 5) {
#line 562
      *(hash + 0) = (uint8_t )(sc->hash[i] >> 24);
#line 563
      *(hash + 1) = (uint8_t )(sc->hash[i] >> 16);
#line 564
      *(hash + 2) = (uint8_t )(sc->hash[i] >> 8);
#line 565
      *(hash + 3) = (uint8_t )sc->hash[i];
#line 567
      hash += 4;
#line 558
      i ++;
    }
  }
#line 570
  return;
}
}
#line 1 "sha256.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-G7aX8j5R.i","-g,-O2")
#line 84 "sha256.c"
static uint32_t const   K[64]  = 
#line 84 "sha256.c"
  {      (uint32_t const   )1116352408L,      (uint32_t const   )1899447441L,      (uint32_t const   )3049323471L,      (uint32_t const   )3921009573L, 
        (uint32_t const   )961987163L,      (uint32_t const   )1508970993L,      (uint32_t const   )2453635748L,      (uint32_t const   )2870763221L, 
        (uint32_t const   )3624381080L,      (uint32_t const   )310598401L,      (uint32_t const   )607225278L,      (uint32_t const   )1426881987L, 
        (uint32_t const   )1925078388L,      (uint32_t const   )2162078206L,      (uint32_t const   )2614888103L,      (uint32_t const   )3248222580L, 
        (uint32_t const   )3835390401L,      (uint32_t const   )4022224774L,      (uint32_t const   )264347078L,      (uint32_t const   )604807628L, 
        (uint32_t const   )770255983L,      (uint32_t const   )1249150122L,      (uint32_t const   )1555081692L,      (uint32_t const   )1996064986L, 
        (uint32_t const   )2554220882L,      (uint32_t const   )2821834349L,      (uint32_t const   )2952996808L,      (uint32_t const   )3210313671L, 
        (uint32_t const   )3336571891L,      (uint32_t const   )3584528711L,      (uint32_t const   )113926993L,      (uint32_t const   )338241895L, 
        (uint32_t const   )666307205L,      (uint32_t const   )773529912L,      (uint32_t const   )1294757372L,      (uint32_t const   )1396182291L, 
        (uint32_t const   )1695183700L,      (uint32_t const   )1986661051L,      (uint32_t const   )2177026350L,      (uint32_t const   )2456956037L, 
        (uint32_t const   )2730485921L,      (uint32_t const   )2820302411L,      (uint32_t const   )3259730800L,      (uint32_t const   )3345764771L, 
        (uint32_t const   )3516065817L,      (uint32_t const   )3600352804L,      (uint32_t const   )4094571909L,      (uint32_t const   )275423344L, 
        (uint32_t const   )430227734L,      (uint32_t const   )506948616L,      (uint32_t const   )659060556L,      (uint32_t const   )883997877L, 
        (uint32_t const   )958139571L,      (uint32_t const   )1322822218L,      (uint32_t const   )1537002063L,      (uint32_t const   )1747873779L, 
        (uint32_t const   )1955562222L,      (uint32_t const   )2024104815L,      (uint32_t const   )2227730452L,      (uint32_t const   )2361852424L, 
        (uint32_t const   )2428436474L,      (uint32_t const   )2756734187L,      (uint32_t const   )3204031479L,      (uint32_t const   )3329325298L};
#line 170 "sha256.c"
static uint8_t const   padding___0[64]  = 
#line 170
  {      (uint8_t const   )128,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0};
#line 181 "sha256.c"
void SHA256Init(SHA256Context *sc ) 
{ 

  {
#line 188
  sc->totalLength = (uint64_t )0LL;
#line 189
  sc->hash[0] = (uint32_t )1779033703L;
#line 190
  sc->hash[1] = (uint32_t )3144134277L;
#line 191
  sc->hash[2] = (uint32_t )1013904242L;
#line 192
  sc->hash[3] = (uint32_t )2773480762L;
#line 193
  sc->hash[4] = (uint32_t )1359893119L;
#line 194
  sc->hash[5] = (uint32_t )2600822924L;
#line 195
  sc->hash[6] = (uint32_t )528734635L;
#line 196
  sc->hash[7] = (uint32_t )1541459225L;
#line 197
  sc->bufferLength = (uint32_t )0L;
#line 198
  return;
}
}
#line 200 "sha256.c"
static void burnStack___0(int size ) 
{ char buf[128] ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 205
  tmp___0 = __builtin_object_size((void *)(buf), 0);
#line 205
  if (tmp___0 != 0xffffffffffffffffUL) {
#line 205
    tmp = __builtin_object_size((void *)(buf), 0);
#line 205
    __builtin___memset_chk((void *)(buf), 0, sizeof(buf), tmp);
  } else {
#line 205
    __inline_memset_chk((void *)(buf), 0, sizeof(buf));
  }
#line 206
  size = (int )((unsigned long )size - sizeof(buf));
#line 207
  if (size > 0) {
#line 208
    burnStack___0(size);
  }
#line 209
  return;
}
}
#line 211 "sha256.c"
static void SHA256Guts(SHA256Context *sc , uint32_t const   *cbuf ) 
{ uint32_t buf[64] ;
  uint32_t *W ;
  uint32_t *W2 ;
  uint32_t *W7 ;
  uint32_t *W15 ;
  uint32_t *W16 ;
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  uint32_t d ;
  uint32_t e ;
  uint32_t f ;
  uint32_t g ;
  uint32_t h ;
  uint32_t t1 ;
  uint32_t t2 ;
  uint32_t const   *Kp ;
  int i ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t *tmp___2 ;
  uint32_t const   *tmp___3 ;
  uint32_t *tmp___4 ;

  {
#line 221
  W = buf;
#line 223
  i = 15;
#line 223
  while (i >= 0) {
#line 224
    tmp = W;
#line 224
    W ++;
#line 224
    *tmp = (uint32_t )(((long )((*cbuf >> 8) | (*cbuf << 24)) & 4278255360L) | ((long )((*cbuf << 8) | (*cbuf >> 24)) & 16711935L));
#line 225
    cbuf ++;
#line 223
    i --;
  }
#line 228
  W16 = & buf[0];
#line 229
  W15 = & buf[1];
#line 230
  W7 = & buf[9];
#line 231
  W2 = & buf[14];
#line 233
  i = 47;
#line 233
  while (i >= 0) {
#line 234
    tmp___0 = W;
#line 234
    W ++;
#line 234
    tmp___1 = W7;
#line 234
    W7 ++;
#line 234
    tmp___2 = W16;
#line 234
    W16 ++;
#line 234
    *tmp___0 = ((((((*W2 >> 17) | (*W2 << 15)) ^ ((*W2 >> 19) | (*W2 << 13))) ^ (*W2 >> 10)) + *tmp___1) + ((((*W15 >> 7) | (*W15 << 25)) ^ ((*W15 >> 18) | (*W15 << 14))) ^ (*W15 >> 3))) + *tmp___2;
#line 235
    W2 ++;
#line 236
    W15 ++;
#line 233
    i --;
  }
#line 239
  a = sc->hash[0];
#line 240
  b = sc->hash[1];
#line 241
  c = sc->hash[2];
#line 242
  d = sc->hash[3];
#line 243
  e = sc->hash[4];
#line 244
  f = sc->hash[5];
#line 245
  g = sc->hash[6];
#line 246
  h = sc->hash[7];
#line 248
  Kp = K;
#line 249
  W = buf;
#line 256
  i = 63;
#line 256
  while (i >= 0) {
#line 257
    tmp___3 = Kp;
#line 257
    Kp ++;
#line 257
    tmp___4 = W;
#line 257
    W ++;
#line 257
    t1 = (((h + ((((e >> 6) | (e << 26)) ^ ((e >> 11) | (e << 21))) ^ ((e >> 25) | (e << 7)))) + (g ^ (e & (f ^ g)))) + (uint32_t )*tmp___3) + *tmp___4;
#line 257
    t2 = ((((a >> 2) | (a << 30)) ^ ((a >> 13) | (a << 19))) ^ ((a >> 22) | (a << 10))) + ((a & (b | c)) | (b & c));
#line 257
    h = g;
#line 257
    g = f;
#line 257
    f = e;
#line 257
    e = d + t1;
#line 257
    d = c;
#line 257
    c = b;
#line 257
    b = a;
#line 257
    a = t1 + t2;
#line 256
    i --;
  }
#line 310
  sc->hash[0] += a;
#line 311
  sc->hash[1] += b;
#line 312
  sc->hash[2] += c;
#line 313
  sc->hash[3] += d;
#line 314
  sc->hash[4] += e;
#line 315
  sc->hash[5] += f;
#line 316
  sc->hash[6] += g;
#line 317
  sc->hash[7] += h;
#line 318
  return;
}
}
#line 320 "sha256.c"
void SHA256Update(SHA256Context *sc , void const   *vdata , uint32_t len ) 
{ uint8_t const   *data ;
  uint32_t bufferBytesLeft ;
  uint32_t bytesToCopy ;
  int needBurn ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 323
  data = (uint8_t const   *)vdata;
#line 326
  needBurn = 0;
#line 369
  while (len) {
#line 370
    bufferBytesLeft = (uint32_t )(64L - (long )sc->bufferLength);
#line 372
    bytesToCopy = bufferBytesLeft;
#line 373
    if (bytesToCopy > len) {
#line 374
      bytesToCopy = len;
    }
#line 376
    tmp___0 = __builtin_object_size((void *)(& sc->buffer.bytes[sc->bufferLength]),
                                    0);
#line 376
    if (tmp___0 != 0xffffffffffffffffUL) {
#line 376
      tmp = __builtin_object_size((void *)(& sc->buffer.bytes[sc->bufferLength]),
                                  0);
#line 376
      __builtin___memcpy_chk((void *)(& sc->buffer.bytes[sc->bufferLength]), (void const   *)data,
                             (unsigned long )bytesToCopy, tmp);
    } else {
#line 376
      __inline_memcpy_chk((void *)(& sc->buffer.bytes[sc->bufferLength]), (void const   *)data,
                          (size_t )bytesToCopy);
    }
#line 378
    sc->totalLength += (uint64_t )((long )bytesToCopy * 8L);
#line 380
    sc->bufferLength += bytesToCopy;
#line 381
    data += bytesToCopy;
#line 382
    len -= bytesToCopy;
#line 384
    if ((long )sc->bufferLength == 64L) {
#line 385
      SHA256Guts(sc, (uint32_t const   *)(sc->buffer.words));
#line 386
      needBurn = 1;
#line 387
      sc->bufferLength = (uint32_t )0L;
    }
  }
#line 392
  if (needBurn) {
#line 393
    burnStack___0((int )((sizeof(uint32_t [74]) + sizeof(uint32_t *[6])) + sizeof(int )));
  }
#line 394
  return;
}
}
#line 396 "sha256.c"
void SHA256Final(SHA256Context *sc , uint8_t *hash ) 
{ uint32_t bytesToPad ;
  uint64_t lengthPad ;
  int i ;

  {
#line 403
  bytesToPad = (uint32_t )(120L - (long )sc->bufferLength);
#line 404
  if ((long )bytesToPad > 64L) {
#line 405
    bytesToPad = (uint32_t )((long )bytesToPad - 64L);
  }
#line 407
  lengthPad = _byteswap64(sc->totalLength);
#line 409
  SHA256Update(sc, (void const   *)(padding___0), bytesToPad);
#line 410
  SHA256Update(sc, (void const   *)(& lengthPad), (uint32_t )8L);
#line 412
  if (hash) {
#line 413
    i = 0;
#line 413
    while (i < 8) {
#line 417
      *(hash + 0) = (uint8_t )(sc->hash[i] >> 24);
#line 418
      *(hash + 1) = (uint8_t )(sc->hash[i] >> 16);
#line 419
      *(hash + 2) = (uint8_t )(sc->hash[i] >> 8);
#line 420
      *(hash + 3) = (uint8_t )sc->hash[i];
#line 422
      hash += 4;
#line 413
      i ++;
    }
  }
#line 425
  return;
}
}
#line 1 "sha384.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-4crspnzl.i","-g,-O2")
#line 89 "sha384.c"
static uint64_t const   K___0[80]  = 
#line 89 "sha384.c"
  {      (uint64_t const   )4794697086780616226LL,      (uint64_t const   )8158064640168781261LL,      (uint64_t const   )0xb5c0fbcfec4d3b2fULL,      (uint64_t const   )0xe9b5dba58189dbbcULL, 
        (uint64_t const   )4131703408338449720LL,      (uint64_t const   )6480981068601479193LL,      (uint64_t const   )0x923f82a4af194f9bULL,      (uint64_t const   )0xab1c5ed5da6d8118ULL, 
        (uint64_t const   )0xd807aa98a3030242ULL,      (uint64_t const   )1334009975649890238LL,      (uint64_t const   )2608012711638119052LL,      (uint64_t const   )6128411473006802146LL, 
        (uint64_t const   )8268148722764581231LL,      (uint64_t const   )0x80deb1fe3b1696b1ULL,      (uint64_t const   )0x9bdc06a725c71235ULL,      (uint64_t const   )0xc19bf174cf692694ULL, 
        (uint64_t const   )0xe49b69c19ef14ad2ULL,      (uint64_t const   )0xefbe4786384f25e3ULL,      (uint64_t const   )1135362057144423861LL,      (uint64_t const   )2597628984639134821LL, 
        (uint64_t const   )3308224258029322869LL,      (uint64_t const   )5365058923640841347LL,      (uint64_t const   )6679025012923562964LL,      (uint64_t const   )8573033837759648693LL, 
        (uint64_t const   )0x983e5152ee66dfabULL,      (uint64_t const   )0xa831c66d2db43210ULL,      (uint64_t const   )0xb00327c898fb213fULL,      (uint64_t const   )0xbf597fc7beef0ee4ULL, 
        (uint64_t const   )0xc6e00bf33da88fc2ULL,      (uint64_t const   )0xd5a79147930aa725ULL,      (uint64_t const   )489312712824947311LL,      (uint64_t const   )1452737877330783856LL, 
        (uint64_t const   )2861767655752347644LL,      (uint64_t const   )3322285676063803686LL,      (uint64_t const   )5560940570517711597LL,      (uint64_t const   )5996557281743188959LL, 
        (uint64_t const   )7280758554555802590LL,      (uint64_t const   )8532644243296465576LL,      (uint64_t const   )0x81c2c92e47edaee6ULL,      (uint64_t const   )0x92722c851482353bULL, 
        (uint64_t const   )0xa2bfe8a14cf10364ULL,      (uint64_t const   )0xa81a664bbc423001ULL,      (uint64_t const   )0xc24b8b70d0f89791ULL,      (uint64_t const   )0xc76c51a30654be30ULL, 
        (uint64_t const   )0xd192e819d6ef5218ULL,      (uint64_t const   )0xd69906245565a910ULL,      (uint64_t const   )0xf40e35855771202aULL,      (uint64_t const   )1182934255886127544LL, 
        (uint64_t const   )1847814050463011016LL,      (uint64_t const   )2177327727835720531LL,      (uint64_t const   )2830643537854262169LL,      (uint64_t const   )3796741975233480872LL, 
        (uint64_t const   )4115178125766777443LL,      (uint64_t const   )5681478168544905931LL,      (uint64_t const   )6601373596472566643LL,      (uint64_t const   )7507060721942968483LL, 
        (uint64_t const   )8399075790359081724LL,      (uint64_t const   )8693463985226723168LL,      (uint64_t const   )0x84c87814a1f0ab72ULL,      (uint64_t const   )0x8cc702081a6439ecULL, 
        (uint64_t const   )0x90befffa23631e28ULL,      (uint64_t const   )0xa4506cebde82bde9ULL,      (uint64_t const   )0xbef9a3f7b2c67915ULL,      (uint64_t const   )0xc67178f2e372532bULL, 
        (uint64_t const   )0xca273eceea26619cULL,      (uint64_t const   )0xd186b8c721c0c207ULL,      (uint64_t const   )0xeada7dd6cde0eb1eULL,      (uint64_t const   )0xf57d4f7fee6ed178ULL, 
        (uint64_t const   )500013540394364858LL,      (uint64_t const   )748580250866718886LL,      (uint64_t const   )1242879168328830382LL,      (uint64_t const   )1977374033974150939LL, 
        (uint64_t const   )2944078676154940804LL,      (uint64_t const   )3659926193048069267LL,      (uint64_t const   )4368137639120453308LL,      (uint64_t const   )4836135668995329356LL, 
        (uint64_t const   )5532061633213252278LL,      (uint64_t const   )6448918945643986474LL,      (uint64_t const   )6902733635092675308LL,      (uint64_t const   )7801388544844847127LL};
#line 199 "sha384.c"
static uint8_t const   padding___1[128]  = 
#line 199
  {      (uint8_t const   )128,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0};
#line 218 "sha384.c"
void SHA384Init(SHA384Context *sc ) 
{ 

  {
#line 225
  sc->totalLength[0] = (uint64_t )0LL;
#line 226
  sc->totalLength[1] = (uint64_t )0LL;
#line 227
  sc->hash[0] = 0xcbbb9d5dc1059ed8ULL;
#line 228
  sc->hash[1] = (uint64_t )7105036623409894663LL;
#line 229
  sc->hash[2] = 0x9159015a3070dd17ULL;
#line 230
  sc->hash[3] = (uint64_t )1526699215303891257LL;
#line 231
  sc->hash[4] = (uint64_t )7436329637833083697LL;
#line 232
  sc->hash[5] = 0x8eb44a8768581511ULL;
#line 233
  sc->hash[6] = 0xdb0c2e0d64f98fa7ULL;
#line 234
  sc->hash[7] = (uint64_t )5167115440072839076LL;
#line 235
  sc->bufferLength = (uint32_t )0L;
#line 236
  return;
}
}
#line 238 "sha384.c"
static void burnStack___1(int size ) 
{ char buf[128] ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 243
  tmp___0 = __builtin_object_size((void *)(buf), 0);
#line 243
  if (tmp___0 != 0xffffffffffffffffUL) {
#line 243
    tmp = __builtin_object_size((void *)(buf), 0);
#line 243
    __builtin___memset_chk((void *)(buf), 0, sizeof(buf), tmp);
  } else {
#line 243
    __inline_memset_chk((void *)(buf), 0, sizeof(buf));
  }
#line 244
  size = (int )((unsigned long )size - sizeof(buf));
#line 245
  if (size > 0) {
#line 246
    burnStack___1(size);
  }
#line 247
  return;
}
}
#line 249 "sha384.c"
static void SHA384Guts(SHA384Context *sc , uint64_t const   *cbuf ) 
{ uint64_t buf[80] ;
  uint64_t *W ;
  uint64_t *W2 ;
  uint64_t *W7 ;
  uint64_t *W15 ;
  uint64_t *W16 ;
  uint64_t a ;
  uint64_t b ;
  uint64_t c ;
  uint64_t d ;
  uint64_t e ;
  uint64_t f ;
  uint64_t g ;
  uint64_t h ;
  uint64_t t1 ;
  uint64_t t2 ;
  uint64_t const   *Kp ;
  int i ;
  uint64_t *tmp ;
  uint64_t *tmp___0 ;
  uint64_t *tmp___1 ;
  uint64_t *tmp___2 ;
  uint64_t const   *tmp___3 ;
  uint64_t *tmp___4 ;

  {
#line 259
  W = buf;
#line 261
  i = 15;
#line 261
  while (i >= 0) {
#line 262
    tmp = W;
#line 262
    W ++;
#line 262
    *tmp = _byteswap64((uint64_t )*cbuf);
#line 263
    cbuf ++;
#line 261
    i --;
  }
#line 266
  W16 = & buf[0];
#line 267
  W15 = & buf[1];
#line 268
  W7 = & buf[9];
#line 269
  W2 = & buf[14];
#line 271
  i = 63;
#line 271
  while (i >= 0) {
#line 272
    tmp___0 = W;
#line 272
    W ++;
#line 272
    tmp___1 = W7;
#line 272
    W7 ++;
#line 272
    tmp___2 = W16;
#line 272
    W16 ++;
#line 272
    *tmp___0 = ((((((*W2 >> 19) | (*W2 << 45)) ^ ((*W2 >> 61) | (*W2 << 3))) ^ (*W2 >> 6)) + *tmp___1) + ((((*W15 >> 1) | (*W15 << 63)) ^ ((*W15 >> 8) | (*W15 << 56))) ^ (*W15 >> 7))) + *tmp___2;
#line 273
    W2 ++;
#line 274
    W15 ++;
#line 271
    i --;
  }
#line 277
  a = sc->hash[0];
#line 278
  b = sc->hash[1];
#line 279
  c = sc->hash[2];
#line 280
  d = sc->hash[3];
#line 281
  e = sc->hash[4];
#line 282
  f = sc->hash[5];
#line 283
  g = sc->hash[6];
#line 284
  h = sc->hash[7];
#line 286
  Kp = K___0;
#line 287
  W = buf;
#line 289
  i = 79;
#line 289
  while (i >= 0) {
#line 290
    tmp___3 = Kp;
#line 290
    Kp ++;
#line 290
    tmp___4 = W;
#line 290
    W ++;
#line 290
    t1 = (((h + ((((e >> 14) | (e << 50)) ^ ((e >> 18) | (e << 46))) ^ ((e >> 41) | (e << 23)))) + (g ^ (e & (f ^ g)))) + (uint64_t )*tmp___3) + *tmp___4;
#line 290
    t2 = ((((a >> 28) | (a << 36)) ^ ((a >> 34) | (a << 30))) ^ ((a >> 39) | (a << 25))) + ((a & (b | c)) | (b & c));
#line 290
    h = g;
#line 290
    g = f;
#line 290
    f = e;
#line 290
    e = d + t1;
#line 290
    d = c;
#line 290
    c = b;
#line 290
    b = a;
#line 290
    a = t1 + t2;
#line 289
    i --;
  }
#line 292
  sc->hash[0] += a;
#line 293
  sc->hash[1] += b;
#line 294
  sc->hash[2] += c;
#line 295
  sc->hash[3] += d;
#line 296
  sc->hash[4] += e;
#line 297
  sc->hash[5] += f;
#line 298
  sc->hash[6] += g;
#line 299
  sc->hash[7] += h;
#line 300
  return;
}
}
#line 302 "sha384.c"
void SHA384Update(SHA384Context *sc , void const   *vdata , uint32_t len ) 
{ uint8_t const   *data ;
  uint32_t bufferBytesLeft ;
  uint32_t bytesToCopy ;
  uint64_t carryCheck ;
  int needBurn ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 305
  data = (uint8_t const   *)vdata;
#line 309
  needBurn = 0;
#line 361
  while (len) {
#line 362
    bufferBytesLeft = (uint32_t )(128L - (long )sc->bufferLength);
#line 364
    bytesToCopy = bufferBytesLeft;
#line 365
    if (bytesToCopy > len) {
#line 366
      bytesToCopy = len;
    }
#line 368
    tmp___0 = __builtin_object_size((void *)(& sc->buffer.bytes[sc->bufferLength]),
                                    0);
#line 368
    if (tmp___0 != 0xffffffffffffffffUL) {
#line 368
      tmp = __builtin_object_size((void *)(& sc->buffer.bytes[sc->bufferLength]),
                                  0);
#line 368
      __builtin___memcpy_chk((void *)(& sc->buffer.bytes[sc->bufferLength]), (void const   *)data,
                             (unsigned long )bytesToCopy, tmp);
    } else {
#line 368
      __inline_memcpy_chk((void *)(& sc->buffer.bytes[sc->bufferLength]), (void const   *)data,
                          (size_t )bytesToCopy);
    }
#line 370
    carryCheck = sc->totalLength[1];
#line 371
    sc->totalLength[1] += (uint64_t )((long )bytesToCopy * 8L);
#line 372
    if (sc->totalLength[1] < carryCheck) {
#line 373
      (sc->totalLength[0]) ++;
    }
#line 375
    sc->bufferLength += bytesToCopy;
#line 376
    data += bytesToCopy;
#line 377
    len -= bytesToCopy;
#line 379
    if ((long )sc->bufferLength == 128L) {
#line 380
      SHA384Guts(sc, (uint64_t const   *)(sc->buffer.words));
#line 381
      needBurn = 1;
#line 382
      sc->bufferLength = (uint32_t )0L;
    }
  }
#line 387
  if (needBurn) {
#line 388
    burnStack___1((int )((sizeof(uint64_t [90]) + sizeof(uint64_t *[6])) + sizeof(int )));
  }
#line 389
  return;
}
}
#line 391 "sha384.c"
void SHA384Final(SHA384Context *sc , uint8_t *hash ) 
{ uint32_t bytesToPad ;
  uint64_t lengthPad[2] ;
  int i ;

  {
#line 398
  bytesToPad = (uint32_t )(240L - (long )sc->bufferLength);
#line 399
  if ((long )bytesToPad > 128L) {
#line 400
    bytesToPad = (uint32_t )((long )bytesToPad - 128L);
  }
#line 402
  lengthPad[0] = _byteswap64(sc->totalLength[0]);
#line 403
  lengthPad[1] = _byteswap64(sc->totalLength[1]);
#line 405
  SHA384Update(sc, (void const   *)(padding___1), bytesToPad);
#line 406
  SHA384Update(sc, (void const   *)(lengthPad), (uint32_t )16L);
#line 408
  if (hash) {
#line 409
    i = 0;
#line 409
    while (i < 6) {
#line 413
      *(hash + 0) = (uint8_t )(sc->hash[i] >> 56);
#line 414
      *(hash + 1) = (uint8_t )(sc->hash[i] >> 48);
#line 415
      *(hash + 2) = (uint8_t )(sc->hash[i] >> 40);
#line 416
      *(hash + 3) = (uint8_t )(sc->hash[i] >> 32);
#line 417
      *(hash + 4) = (uint8_t )(sc->hash[i] >> 24);
#line 418
      *(hash + 5) = (uint8_t )(sc->hash[i] >> 16);
#line 419
      *(hash + 6) = (uint8_t )(sc->hash[i] >> 8);
#line 420
      *(hash + 7) = (uint8_t )sc->hash[i];
#line 422
      hash += 8;
#line 409
      i ++;
    }
  }
#line 425
  return;
}
}
#line 1 "sha512.o"
#pragma merger(0,"/var/folders/vs/zc_l26g12wq45p4yt13_bsvw0000gn/T/cil-ZOj4Wj5k.i","-g,-O2")
#line 89 "sha512.c"
static uint64_t const   K___1[80]  = 
#line 89 "sha512.c"
  {      (uint64_t const   )4794697086780616226LL,      (uint64_t const   )8158064640168781261LL,      (uint64_t const   )0xb5c0fbcfec4d3b2fULL,      (uint64_t const   )0xe9b5dba58189dbbcULL, 
        (uint64_t const   )4131703408338449720LL,      (uint64_t const   )6480981068601479193LL,      (uint64_t const   )0x923f82a4af194f9bULL,      (uint64_t const   )0xab1c5ed5da6d8118ULL, 
        (uint64_t const   )0xd807aa98a3030242ULL,      (uint64_t const   )1334009975649890238LL,      (uint64_t const   )2608012711638119052LL,      (uint64_t const   )6128411473006802146LL, 
        (uint64_t const   )8268148722764581231LL,      (uint64_t const   )0x80deb1fe3b1696b1ULL,      (uint64_t const   )0x9bdc06a725c71235ULL,      (uint64_t const   )0xc19bf174cf692694ULL, 
        (uint64_t const   )0xe49b69c19ef14ad2ULL,      (uint64_t const   )0xefbe4786384f25e3ULL,      (uint64_t const   )1135362057144423861LL,      (uint64_t const   )2597628984639134821LL, 
        (uint64_t const   )3308224258029322869LL,      (uint64_t const   )5365058923640841347LL,      (uint64_t const   )6679025012923562964LL,      (uint64_t const   )8573033837759648693LL, 
        (uint64_t const   )0x983e5152ee66dfabULL,      (uint64_t const   )0xa831c66d2db43210ULL,      (uint64_t const   )0xb00327c898fb213fULL,      (uint64_t const   )0xbf597fc7beef0ee4ULL, 
        (uint64_t const   )0xc6e00bf33da88fc2ULL,      (uint64_t const   )0xd5a79147930aa725ULL,      (uint64_t const   )489312712824947311LL,      (uint64_t const   )1452737877330783856LL, 
        (uint64_t const   )2861767655752347644LL,      (uint64_t const   )3322285676063803686LL,      (uint64_t const   )5560940570517711597LL,      (uint64_t const   )5996557281743188959LL, 
        (uint64_t const   )7280758554555802590LL,      (uint64_t const   )8532644243296465576LL,      (uint64_t const   )0x81c2c92e47edaee6ULL,      (uint64_t const   )0x92722c851482353bULL, 
        (uint64_t const   )0xa2bfe8a14cf10364ULL,      (uint64_t const   )0xa81a664bbc423001ULL,      (uint64_t const   )0xc24b8b70d0f89791ULL,      (uint64_t const   )0xc76c51a30654be30ULL, 
        (uint64_t const   )0xd192e819d6ef5218ULL,      (uint64_t const   )0xd69906245565a910ULL,      (uint64_t const   )0xf40e35855771202aULL,      (uint64_t const   )1182934255886127544LL, 
        (uint64_t const   )1847814050463011016LL,      (uint64_t const   )2177327727835720531LL,      (uint64_t const   )2830643537854262169LL,      (uint64_t const   )3796741975233480872LL, 
        (uint64_t const   )4115178125766777443LL,      (uint64_t const   )5681478168544905931LL,      (uint64_t const   )6601373596472566643LL,      (uint64_t const   )7507060721942968483LL, 
        (uint64_t const   )8399075790359081724LL,      (uint64_t const   )8693463985226723168LL,      (uint64_t const   )0x84c87814a1f0ab72ULL,      (uint64_t const   )0x8cc702081a6439ecULL, 
        (uint64_t const   )0x90befffa23631e28ULL,      (uint64_t const   )0xa4506cebde82bde9ULL,      (uint64_t const   )0xbef9a3f7b2c67915ULL,      (uint64_t const   )0xc67178f2e372532bULL, 
        (uint64_t const   )0xca273eceea26619cULL,      (uint64_t const   )0xd186b8c721c0c207ULL,      (uint64_t const   )0xeada7dd6cde0eb1eULL,      (uint64_t const   )0xf57d4f7fee6ed178ULL, 
        (uint64_t const   )500013540394364858LL,      (uint64_t const   )748580250866718886LL,      (uint64_t const   )1242879168328830382LL,      (uint64_t const   )1977374033974150939LL, 
        (uint64_t const   )2944078676154940804LL,      (uint64_t const   )3659926193048069267LL,      (uint64_t const   )4368137639120453308LL,      (uint64_t const   )4836135668995329356LL, 
        (uint64_t const   )5532061633213252278LL,      (uint64_t const   )6448918945643986474LL,      (uint64_t const   )6902733635092675308LL,      (uint64_t const   )7801388544844847127LL};
#line 199 "sha512.c"
static uint8_t const   padding___2[128]  = 
#line 199
  {      (uint8_t const   )128,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0};
#line 218 "sha512.c"
void SHA512Init(SHA512Context *sc ) 
{ 

  {
#line 225
  sc->totalLength[0] = (uint64_t )0LL;
#line 226
  sc->totalLength[1] = (uint64_t )0LL;
#line 227
  sc->hash[0] = (uint64_t )7640891576956012808LL;
#line 228
  sc->hash[1] = 0xbb67ae8584caa73bULL;
#line 229
  sc->hash[2] = (uint64_t )4354685564936845355LL;
#line 230
  sc->hash[3] = 0xa54ff53a5f1d36f1ULL;
#line 231
  sc->hash[4] = (uint64_t )5840696475078001361LL;
#line 232
  sc->hash[5] = 0x9b05688c2b3e6c1fULL;
#line 233
  sc->hash[6] = (uint64_t )2270897969802886507LL;
#line 234
  sc->hash[7] = (uint64_t )6620516959819538809LL;
#line 235
  sc->bufferLength = (uint32_t )0L;
#line 236
  return;
}
}
#line 238 "sha512.c"
static void burnStack___2(int size ) 
{ char buf[128] ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 243
  tmp___0 = __builtin_object_size((void *)(buf), 0);
#line 243
  if (tmp___0 != 0xffffffffffffffffUL) {
#line 243
    tmp = __builtin_object_size((void *)(buf), 0);
#line 243
    __builtin___memset_chk((void *)(buf), 0, sizeof(buf), tmp);
  } else {
#line 243
    __inline_memset_chk((void *)(buf), 0, sizeof(buf));
  }
#line 244
  size = (int )((unsigned long )size - sizeof(buf));
#line 245
  if (size > 0) {
#line 246
    burnStack___2(size);
  }
#line 247
  return;
}
}
#line 249 "sha512.c"
static void SHA512Guts(SHA512Context *sc , uint64_t const   *cbuf ) 
{ uint64_t buf[80] ;
  uint64_t *W ;
  uint64_t *W2 ;
  uint64_t *W7 ;
  uint64_t *W15 ;
  uint64_t *W16 ;
  uint64_t a ;
  uint64_t b ;
  uint64_t c ;
  uint64_t d ;
  uint64_t e ;
  uint64_t f ;
  uint64_t g ;
  uint64_t h ;
  uint64_t t1 ;
  uint64_t t2 ;
  uint64_t const   *Kp ;
  int i ;
  uint64_t *tmp ;
  uint64_t *tmp___0 ;
  uint64_t *tmp___1 ;
  uint64_t *tmp___2 ;
  uint64_t const   *tmp___3 ;
  uint64_t *tmp___4 ;

  {
#line 259
  W = buf;
#line 261
  i = 15;
#line 261
  while (i >= 0) {
#line 262
    tmp = W;
#line 262
    W ++;
#line 262
    *tmp = _byteswap64((uint64_t )*cbuf);
#line 263
    cbuf ++;
#line 261
    i --;
  }
#line 266
  W16 = & buf[0];
#line 267
  W15 = & buf[1];
#line 268
  W7 = & buf[9];
#line 269
  W2 = & buf[14];
#line 271
  i = 63;
#line 271
  while (i >= 0) {
#line 272
    tmp___0 = W;
#line 272
    W ++;
#line 272
    tmp___1 = W7;
#line 272
    W7 ++;
#line 272
    tmp___2 = W16;
#line 272
    W16 ++;
#line 272
    *tmp___0 = ((((((*W2 >> 19) | (*W2 << 45)) ^ ((*W2 >> 61) | (*W2 << 3))) ^ (*W2 >> 6)) + *tmp___1) + ((((*W15 >> 1) | (*W15 << 63)) ^ ((*W15 >> 8) | (*W15 << 56))) ^ (*W15 >> 7))) + *tmp___2;
#line 273
    W2 ++;
#line 274
    W15 ++;
#line 271
    i --;
  }
#line 277
  a = sc->hash[0];
#line 278
  b = sc->hash[1];
#line 279
  c = sc->hash[2];
#line 280
  d = sc->hash[3];
#line 281
  e = sc->hash[4];
#line 282
  f = sc->hash[5];
#line 283
  g = sc->hash[6];
#line 284
  h = sc->hash[7];
#line 286
  Kp = K___1;
#line 287
  W = buf;
#line 289
  i = 79;
#line 289
  while (i >= 0) {
#line 290
    tmp___3 = Kp;
#line 290
    Kp ++;
#line 290
    tmp___4 = W;
#line 290
    W ++;
#line 290
    t1 = (((h + ((((e >> 14) | (e << 50)) ^ ((e >> 18) | (e << 46))) ^ ((e >> 41) | (e << 23)))) + (g ^ (e & (f ^ g)))) + (uint64_t )*tmp___3) + *tmp___4;
#line 290
    t2 = ((((a >> 28) | (a << 36)) ^ ((a >> 34) | (a << 30))) ^ ((a >> 39) | (a << 25))) + ((a & (b | c)) | (b & c));
#line 290
    h = g;
#line 290
    g = f;
#line 290
    f = e;
#line 290
    e = d + t1;
#line 290
    d = c;
#line 290
    c = b;
#line 290
    b = a;
#line 290
    a = t1 + t2;
#line 289
    i --;
  }
#line 292
  sc->hash[0] += a;
#line 293
  sc->hash[1] += b;
#line 294
  sc->hash[2] += c;
#line 295
  sc->hash[3] += d;
#line 296
  sc->hash[4] += e;
#line 297
  sc->hash[5] += f;
#line 298
  sc->hash[6] += g;
#line 299
  sc->hash[7] += h;
#line 300
  return;
}
}
#line 302 "sha512.c"
void SHA512Update(SHA512Context *sc , void const   *vdata , uint32_t len ) 
{ uint8_t const   *data ;
  uint32_t bufferBytesLeft ;
  uint32_t bytesToCopy ;
  uint64_t carryCheck ;
  int needBurn ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 305
  data = (uint8_t const   *)vdata;
#line 309
  needBurn = 0;
#line 361
  while (len) {
#line 362
    bufferBytesLeft = (uint32_t )(128L - (long )sc->bufferLength);
#line 364
    bytesToCopy = bufferBytesLeft;
#line 365
    if (bytesToCopy > len) {
#line 366
      bytesToCopy = len;
    }
#line 368
    tmp___0 = __builtin_object_size((void *)(& sc->buffer.bytes[sc->bufferLength]),
                                    0);
#line 368
    if (tmp___0 != 0xffffffffffffffffUL) {
#line 368
      tmp = __builtin_object_size((void *)(& sc->buffer.bytes[sc->bufferLength]),
                                  0);
#line 368
      __builtin___memcpy_chk((void *)(& sc->buffer.bytes[sc->bufferLength]), (void const   *)data,
                             (unsigned long )bytesToCopy, tmp);
    } else {
#line 368
      __inline_memcpy_chk((void *)(& sc->buffer.bytes[sc->bufferLength]), (void const   *)data,
                          (size_t )bytesToCopy);
    }
#line 370
    carryCheck = sc->totalLength[1];
#line 371
    sc->totalLength[1] += (uint64_t )((long )bytesToCopy * 8L);
#line 372
    if (sc->totalLength[1] < carryCheck) {
#line 373
      (sc->totalLength[0]) ++;
    }
#line 375
    sc->bufferLength += bytesToCopy;
#line 376
    data += bytesToCopy;
#line 377
    len -= bytesToCopy;
#line 379
    if ((long )sc->bufferLength == 128L) {
#line 380
      SHA512Guts(sc, (uint64_t const   *)(sc->buffer.words));
#line 381
      needBurn = 1;
#line 382
      sc->bufferLength = (uint32_t )0L;
    }
  }
#line 387
  if (needBurn) {
#line 388
    burnStack___2((int )((sizeof(uint64_t [90]) + sizeof(uint64_t *[6])) + sizeof(int )));
  }
#line 389
  return;
}
}
#line 391 "sha512.c"
void SHA512Final(SHA512Context *sc , uint8_t *hash ) 
{ uint32_t bytesToPad ;
  uint64_t lengthPad[2] ;
  int i ;

  {
#line 398
  bytesToPad = (uint32_t )(240L - (long )sc->bufferLength);
#line 399
  if ((long )bytesToPad > 128L) {
#line 400
    bytesToPad = (uint32_t )((long )bytesToPad - 128L);
  }
#line 402
  lengthPad[0] = _byteswap64(sc->totalLength[0]);
#line 403
  lengthPad[1] = _byteswap64(sc->totalLength[1]);
#line 405
  SHA512Update(sc, (void const   *)(padding___2), bytesToPad);
#line 406
  SHA512Update(sc, (void const   *)(lengthPad), (uint32_t )16L);
#line 408
  if (hash) {
#line 409
    i = 0;
#line 409
    while (i < 8) {
#line 413
      *(hash + 0) = (uint8_t )(sc->hash[i] >> 56);
#line 414
      *(hash + 1) = (uint8_t )(sc->hash[i] >> 48);
#line 415
      *(hash + 2) = (uint8_t )(sc->hash[i] >> 40);
#line 416
      *(hash + 3) = (uint8_t )(sc->hash[i] >> 32);
#line 417
      *(hash + 4) = (uint8_t )(sc->hash[i] >> 24);
#line 418
      *(hash + 5) = (uint8_t )(sc->hash[i] >> 16);
#line 419
      *(hash + 6) = (uint8_t )(sc->hash[i] >> 8);
#line 420
      *(hash + 7) = (uint8_t )sc->hash[i];
#line 422
      hash += 8;
#line 409
      i ++;
    }
  }
#line 425
  return;
}
}
