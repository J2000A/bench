from add_check import add_check
from add_check_annotations import add_check_annotations
from generate_ai_mutations import *
from generate_clang_mutations import *
from meta import *


# generates programs in the temp_dir
def generate_programs(source_path, temp_dir, clang_tidy_path, goblint_path, apikey_path, operators, enable_clang,
                      enable_ai, enable_precision, ai_count, ai_select, ai_interesting, ai_16k, include_paths):
    # Get Goblint executable path
    goblint_executable_path = os.path.join(goblint_path, 'goblint')
    # Clean working directory
    if os.path.isdir(temp_dir):
        shutil.rmtree(temp_dir)
    os.makedirs(temp_dir)
    # Copy the source program into the temp dir
    program_path = os.path.join(temp_dir, 'p.c')
    shutil.copy2(source_path, program_path)
    program_0_path = os.path.join(temp_dir, 'p_0.c')
    shutil.copy2(source_path, program_0_path)
    # Store filesize in meta data
    meta_add_filesize(os.path.getsize(program_0_path))
    # Prepare Program
    perf_prep = meta_start_performance(META_PERF_PREP_PROGRAM)
    _remove_goblint_check_and_assertions(program_0_path)
    _add_goblint_header_include(program_0_path)
    meta_stop_performance(perf_prep)

    # Places include files in temp directory
    for path in include_paths:
        shutil.copy(path, os.path.join(temp_dir, os.path.basename(path)))

    index = 0
    if enable_clang:
        perf_clang = meta_start_performance(META_PERF_CLANG)
        index = generate_clang_mutations(program_0_path, clang_tidy_path, goblint_path, operators, index)
        meta_stop_performance(perf_clang)

    if enable_ai:
        perf_ai = meta_start_performance(META_PERF_AI)
        index = generate_ai_mutations(program_0_path, apikey_path, ai_count, ai_select, ai_interesting, ai_16k, index)
        meta_stop_performance(perf_ai)

    # NEW_MUTATOR
    #   - generate_new_mutator(program_0_path, index, ...) -> return index
    #   - for each of the new mutations
    #       - has to generate its mutations in a newly copied file generated by util.py->make_program_copy(program_0_path, ++index)
    #       - call meta.py->meta_create_index() for each newly generated index (optionally additional: meta.py->meta_exception() )
    #   - call meta.py->meta_set_n() with the new maximum index
    #   - return the new maximum index

    # Add checks with annotations
    print_separator()
    perf_prep = meta_start_performance(META_PERF_PREP_PROGRAM)
    params = _get_params_from_file(program_0_path)
    params = _fix_params(params)
    meta_stop_performance(perf_prep)
    max_index = index
    for i in range(max_index + 1):
        file_path = os.path.join(temp_dir, f"p_{i}.c")

        # Check if initial program and programs after mutation can be compiled with gcc
        perf_mutation_gcc = meta_start_performance(META_PERF_MUTATION_GCC)
        print(f"\r[{i}/{max_index}] Step 1) Check if mutated program compiled with gcc...", end='')
        cmd = f'gcc {file_path} -c -o /dev/null {include_options(goblint_path)} -I {temp_dir} -w'
        result = subprocess.run(cmd, shell=True, text=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        if result.returncode != 0:
            if i == 0:
                print(remove_ansi_escape_sequences(result.stdout))
                print(remove_ansi_escape_sequences(result.stderr))
                print(f"{COLOR_RED}Could not compile initial program with gcc. Stopping execution!{COLOR_RESET}")
                meta_crash_and_store(META_CRASH_MESSAGE_INITIAL_EXCEPTION_GCC)
                sys.exit(RETURN_ERROR_GCC_INPUT)
            else:
                print(f"\r{COLOR_YELLOW}[{i}/{max_index}] Skipped mutation {i} as it did not compile with gcc{COLOR_RESET}{SPACE}")
                meta_exception(i, META_EXCEPTION_CAUSE_MUTATION_GCC, result)
                continue
        meta_stop_performance(perf_mutation_gcc)
        
        # Add the goblint checks
        print(f"\r{SPACE}{SPACE}{SPACE}{SPACE}", end='')
        print(f"\r[{i}/{max_index}] Step 2) Generating goblint checks...", end='')
        if meta_exception_exists(i):
            print(f"\r{COLOR_YELLOW}[{i}/{max_index}] Skipped mutation {i} as an exception occurred in a previous step{COLOR_RESET}{SPACE}")
            continue
        perf_generate_check = meta_start_performance(META_PERF_CHECKS_GENERATE)
        exception = add_check(file_path, goblint_executable_path, params, i)
        meta_stop_performance(perf_generate_check)
        if not exception:
            print(f"\r{COLOR_YELLOW}[{i}/{max_index}] Could not add checks to program with mutation.{COLOR_RESET}{SPACE}")
            continue
        file_path = os.path.join(temp_dir, f"p_{i}_check.c")

        # Check if initial program and programs after mutation can be compiled with gcc
        perf_checks_gcc = meta_start_performance(META_PERF_CHECKS_GCC)
        print(f"\r{SPACE}{SPACE}{SPACE}{SPACE}", end='')
        print(f"\r[{i}/{max_index}] Step 3) Check if program with checks compiles with gcc...", end='')
        cmd = f'gcc {file_path} -c -o /dev/null {include_options(goblint_path)} -I {temp_dir} -w'
        result = subprocess.run(cmd, shell=True, text=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        if result.returncode != 0:
            if i == 0:
                print(remove_ansi_escape_sequences(result.stdout))
                print(remove_ansi_escape_sequences(result.stderr))
                print(f"{COLOR_RED}Could not compile initial program with gcc after cil transformation. Stopping execution!{COLOR_RESET}")
                meta_crash_and_store(META_CRASH_MESSAGE_INITIAL_EXCEPTION_ADD_CHECK_GCC)
                sys.exit(RETURN_ERROR_GCC_CIL)
            else:
                print(f"\r{COLOR_YELLOW}[{i}/{max_index}] Skipped mutation {i} as it did not compile with gcc after generating the checks{COLOR_RESET}{SPACE}")
                meta_exception(i, META_EXCEPTION_CAUSE_CREATE_CHECK_GCC, result)
                continue
        meta_stop_performance(perf_checks_gcc)

        # Annotate the goblint checks for the initial program with NOFAIL / NOTINPRECISE annotations
        perf_annotate_check = meta_start_performance(META_PERF_CHECKS_VERIFY)
        if i == 0:
            if enable_precision:
                add_check_annotations(file_path, 'NOTINPRECISE')
            else:
                add_check_annotations(file_path, 'NOFAIL')
            
        # For the initial file add SUCCESS annotations
        if i != 0:
            add_check_annotations(file_path, 'SUCCESS')
        meta_stop_performance(perf_annotate_check)

        # [DEACTIVATED] Collect statistics about vars and evals
        # Set the following variable to True to collect such statistics (This decreases the performance!)
        collect_vars_and_evals_for_statistics = False
        # Run incremental procedure to get the number of variables, evaluations and narrow reuses for statistics
        if collect_vars_and_evals_for_statistics and i != 0 and not meta_exception_exists(i):
            variables = evals = narrow_reuses = -1
            print(f"\r{SPACE}{SPACE}{SPACE}{SPACE}", end='')
            print(f"\r[{i}/{max_index}] Step 4) Check number of evaluations...", end='')
            command = f'{goblint_executable_path} {os.path.join(temp_dir, f"p_{i}_check.c")} {params.strip()} --enable incremental.save -v'
            result = subprocess.run(command, text=True, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            if result.returncode == 0:
                output = remove_ansi_escape_sequences(result.stdout)
                match = re.search(r"vars = (\d+)", output)
                if match:
                    variables = int(match.group(1))
                match = re.search(r"evals = (\d+)", output)
                if match:
                    evals = int(match.group(1))
                match = re.search(r"narrow_reuses = (\d+)", output)
                if match:
                    narrow_reuses = int(match.group(1))
            else:
                print(f"\r{COLOR_RED}[{i}/{max_index}] Error running Goblint analysis (non incremental){COLOR_RESET}{SPACE}")
            meta_store_incremental_stats(variables, evals, narrow_reuses, i)

            variables = evals = narrow_reuses = -1
            command = f'{goblint_executable_path} {os.path.join(temp_dir, "p_0_check.c")} {params.strip()} --enable incremental.load -v'
            result = subprocess.run(command, text=True, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            if result.returncode == 0:
                output = remove_ansi_escape_sequences(result.stdout)

                match = re.search(r"vars = (\d+)", output)
                if match:
                    variables = int(match.group(1))
                match = re.search(r"evals = (\d+)", output)
                if match:
                    evals = int(match.group(1))
                match = re.search(r"narrow_reuses = (\d+)", output)
                if match:
                    narrow_reuses = int(match.group(1))
            else:
                print(f"\r{COLOR_RED}[{i}/{max_index}] Error running Goblint analysis (incremental){COLOR_RESET}{SPACE}")
                print(result.stdout)
                print(result.stderr)
            meta_store_evals_incremental(variables, evals, narrow_reuses, i)

    print(f"\r{COLOR_GREEN}Generating goblint checks [DONE]{SPACE}{SPACE}{COLOR_RESET}")


def _remove_goblint_check_and_assertions(program_0_path):
    with open(program_0_path, 'r') as f:
        lines = f.readlines()

    # Replace the lines containing the keywords with an empty statement
    keyword_list = ['assert(', '__goblint_check(', '__goblint_assert(']
    replaced_lines = [f'; // [REMOVED_CHECK] Removed assertions and checks from input program at line {i+1}\n' if any(keyword in line for keyword in keyword_list) else line for i, line in enumerate(lines)]

    with open(program_0_path, 'w') as f:
        f.writelines(replaced_lines)


def _add_goblint_header_include(program_0_path):
    with open(program_0_path, 'r') as file:
        lines = file.readlines()

    if any(re.match(r'^\s*#include <goblint.h>', line) for line in lines):
        return
    
    for i, line in enumerate(lines):
        stripped_line = line.lstrip()
        if stripped_line.startswith('//'):
            continue
        else:
            lines.insert(i, '#include <goblint.h>\n')
            break

    with open(program_0_path, 'w') as file:
        file.writelines(lines)


#######################################################################
############### Regex strings for removing parameters #################
REGEX_PARAMETER_REMOVAL = [
    # Do not use witness options as the witness information can not be used for the incremental analysis
    r'--set [\'"]*ana\.activated\[\+\][\'"]* [\'"]*unassume[\'"]*',
    r'--set [\'"]*witness\.yaml\.validate[\'"]* \S*',
    r'--set [\'"]*witness\.yaml\.unassume[\'"]* \S*',
    # Do not use autotune as it might change analyses that must not be changes during incremental analysis
    r'--enable [\'"]*ana\.autotune\.enabled[\'"]*',
    # Do not disable warn ssert, as then the update_suite ruby script can't check the annotations
    r'--disable [\'"]*warn\.assert[\'"]*',
    # Do not use transformation assert as it interferes with the checks generated for the tester
    r'--set [\'"]*trans\.activated\[\+\][\'"]* [\'"]*assert[\'"]*',
    # Remove apron and affeq as there is no marshaling for incremental analysis supported
    # See: https://github.com/goblint/analyzer/issues/558#issuecomment-1479475503
    r'--set [\'"]*ana\.activated\[\+\][\'"]* [\'"]*apron[\'"]*',
    r'--set [\'"]*ana\.activated\[\+\][\'"]* [\'"]*affeq[\'"]*',
    # Remove file analysis as these programs usually depend on external files which may not be accessible
    r'--set [\'"]*ana\.activated\[\+\][\'"]* [\'"]*file[\'"]*'
]
############### Regex strings for removing parameters #################
#######################################################################


def _fix_params(params):
    params_initial = params

    for regex in REGEX_PARAMETER_REMOVAL:
        params = re.sub(regex, '', params)
    
    if params_initial != params:
        print(f'{COLOR_YELLOW}[WARNING] Some parameters from the PARAM string in the input file (grey) were removed to avoid crashing the tester:{COLOR_RESET} {params} {COLOR_GREY}{params_initial}{COLOR_RESET}')

    # Always activate the analysis assert as it is needed for the update_suite ruby script to check the annotations
    params += ' --set ana.activated[+] assert'

    # Always use the top-down solver as only for this the incremental analysis is implemented
    params += ' --set solver td3'
    
    return params


def _get_params_from_file(filename):
    param_pattern = re.compile(r"\s*//.*PARAM\s*:\s*(.*)")
    with open(filename, 'r') as f:
        for line in f:
            match = param_pattern.match(line)
            if match:
                params = match.group(1).strip()
                return params
    return ""


def main():
    parser = argparse.ArgumentParser(description='Generate programs in the working directory')
    parser.add_argument('source_path', help='Path to the source program provided by the user')
    parser.add_argument('temp_dir', help='Path to the working directory')
    parser.add_argument('clang_tidy_path', help='Path to the modified clang-tidy executable')
    parser.add_argument('goblint_path', help='Path to the goblint repository')
    parser.add_argument('--apikey-path', help='Path to the API')
    parser.add_argument('--enable-clang', action='store_true', help='Enable Clang Mutations. When no operator is selected all are activated.')
    parser.add_argument('--enable-ai', action='store_true', help='Enable AI')
    parser.add_argument('--enable-precision', action='store_true', help='Enable generation for precision tests')
    parser.add_argument('--ai-count', type=int, default=DEFAULT_AI_COUNT, help='Number of AI programs to generate')
    parser.add_argument('--ai-select', type=int, default=DEFAULT_AI_SELECT, help='Number of selected lines for AI')
    parser.add_argument('--ai-interesting', default="[]", help='Lines to randomly choose the start line for selection (Default are all lines)')
    parser.add_argument('--ai-16k', action='store_true', help='Use the 16k context for AI')

    # Add mutation options
    add_clang_options(parser)

    args = parser.parse_args()

    # At least one generator has to be enabled
    if not args.enable_clang and not args.enable_ai:
        parser.error("At least one generator has to be enabled (--enable_clang, --enable-ai)")

    # If all operator options are false, set all to true
    operators = get_operators_from_args(args)
    non_str_attributes = [attr for attr in vars(operators) if not attr.endswith('_s')]
    if all(getattr(operators, attr) is False for attr in non_str_attributes):
        operators = Operators(True, True, True, True, True, True)

    # Check required parameters for optional features
    if args.enable_ai and not args.apikey_path:
        parser.error("--enable-ai requires --apikey-path")

    # Check AI interesting string
    if args.ai_interesting != "[]" and validate_interesting_lines(args.ai_interesting, None) is None:
        parser.error('Interesting lines invalid')

    generate_programs(args.source_path, args.temp_dir, args.clang_tidy_path, args.goblint_path, args.apikey_path,
                      operators, args.enable_clang, args.enable_ai, args.enable_precision, args.ai_count, args.ai_select,
                      args.ai_interesting, args.ai_16k, [])


if __name__ == '__main__':
    main()
