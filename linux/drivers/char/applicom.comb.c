/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 40 "/opt/local/lib/gcc49/gcc/x86_64-apple-darwin14/4.9.1/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/opt/local/lib/gcc49/gcc/x86_64-apple-darwin14/4.9.1/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 79 "../../../analyzer/../bench/linux-headers/include/linux/compiler.h"
struct __anonstruct____missing_field_name_2 {
   unsigned long correct ;
   unsigned long incorrect ;
};
#line 79 "../../../analyzer/../bench/linux-headers/include/linux/compiler.h"
struct __anonstruct____missing_field_name_3 {
   unsigned long miss ;
   unsigned long hit ;
};
#line 79 "../../../analyzer/../bench/linux-headers/include/linux/compiler.h"
union __anonunion____missing_field_name_1 {
   struct __anonstruct____missing_field_name_2 __annonCompField1 ;
   struct __anonstruct____missing_field_name_3 __annonCompField2 ;
   unsigned long miss_hit[2] ;
};
#line 79 "../../../analyzer/../bench/linux-headers/include/linux/compiler.h"
struct ftrace_branch_data {
   char const   *func ;
   char const   *file ;
   unsigned int line ;
   union __anonunion____missing_field_name_1 __annonCompField3 ;
};
#line 26 "../../../analyzer/../bench/linux-headers/include/linux/export.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 33
struct module;
#line 10 "../../../analyzer/../bench/linux-headers/include/linux/stddef.h"
enum __anonenum_4 {
    false = 0,
    true = 1
} ;
#line 19 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 20 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 22 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/int-ll64.h"
typedef short __s16;
#line 23 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 29 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/int-ll64.h"
typedef long long __s64;
#line 30 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 15 "../../../analyzer/../bench/linux-headers/include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 16 "../../../analyzer/../bench/linux-headers/include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 18 "../../../analyzer/../bench/linux-headers/include/asm-generic/int-ll64.h"
typedef short s16;
#line 19 "../../../analyzer/../bench/linux-headers/include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "../../../analyzer/../bench/linux-headers/include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "../../../analyzer/../bench/linux-headers/include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "../../../analyzer/../bench/linux-headers/include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "../../../analyzer/../bench/linux-headers/include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 24 "../../../analyzer/../bench/linux-headers/include/uapi/linux/posix_types.h"
struct __anonstruct___kernel_fd_set_5 {
   unsigned long fds_bits[1024UL / (8UL * sizeof(long ))] ;
};
#line 24 "../../../analyzer/../bench/linux-headers/include/uapi/linux/posix_types.h"
typedef struct __anonstruct___kernel_fd_set_5 __kernel_fd_set;
#line 29 "../../../analyzer/../bench/linux-headers/include/uapi/linux/posix_types.h"
typedef void (*__kernel_sighandler_t)(int  );
#line 32 "../../../analyzer/../bench/linux-headers/include/uapi/linux/posix_types.h"
typedef int __kernel_key_t;
#line 33 "../../../analyzer/../bench/linux-headers/include/uapi/linux/posix_types.h"
typedef int __kernel_mqd_t;
#line 10 "../../../analyzer/../bench/linux-headers/arch/x86/include/uapi/asm/posix_types_64.h"
typedef unsigned short __kernel_old_uid_t;
#line 11 "../../../analyzer/../bench/linux-headers/arch/x86/include/uapi/asm/posix_types_64.h"
typedef unsigned short __kernel_old_gid_t;
#line 14 "../../../analyzer/../bench/linux-headers/arch/x86/include/uapi/asm/posix_types_64.h"
typedef unsigned long __kernel_old_dev_t;
#line 14 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 19 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_ino_t;
#line 23 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_mode_t;
#line 27 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 31 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_ipc_pid_t;
#line 35 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid_t;
#line 36 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid_t;
#line 40 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_suseconds_t;
#line 44 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_daddr_t;
#line 48 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 73 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ptrdiff_t;
#line 78 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/posix_types.h"
struct __anonstruct___kernel_fsid_t_6 {
   int val[2] ;
};
#line 78 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/posix_types.h"
typedef struct __anonstruct___kernel_fsid_t_6 __kernel_fsid_t;
#line 86 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_off_t;
#line 87 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 92 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/posix_types.h"
typedef char *__kernel_caddr_t;
#line 93 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/posix_types.h"
typedef unsigned short __kernel_uid16_t;
#line 94 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/posix_types.h"
typedef unsigned short __kernel_gid16_t;
#line 32 "../../../analyzer/../bench/linux-headers/include/uapi/linux/types.h"
typedef __u16 __le16;
#line 33 "../../../analyzer/../bench/linux-headers/include/uapi/linux/types.h"
typedef __u16 __be16;
#line 34 "../../../analyzer/../bench/linux-headers/include/uapi/linux/types.h"
typedef __u32 __le32;
#line 35 "../../../analyzer/../bench/linux-headers/include/uapi/linux/types.h"
typedef __u32 __be32;
#line 36 "../../../analyzer/../bench/linux-headers/include/uapi/linux/types.h"
typedef __u64 __le64;
#line 37 "../../../analyzer/../bench/linux-headers/include/uapi/linux/types.h"
typedef __u64 __be64;
#line 39 "../../../analyzer/../bench/linux-headers/include/uapi/linux/types.h"
typedef __u16 __sum16;
#line 40 "../../../analyzer/../bench/linux-headers/include/uapi/linux/types.h"
typedef __u32 __wsum;
#line 12 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 14 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __kernel_fd_set fd_set;
#line 15 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 16 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __kernel_ino_t ino_t;
#line 17 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __kernel_mode_t mode_t;
#line 18 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef unsigned short umode_t;
#line 19 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __u32 nlink_t;
#line 20 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __kernel_off_t off_t;
#line 21 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 22 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __kernel_daddr_t daddr_t;
#line 23 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __kernel_key_t key_t;
#line 24 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __kernel_suseconds_t suseconds_t;
#line 25 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __kernel_timer_t timer_t;
#line 26 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 27 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __kernel_mqd_t mqd_t;
#line 29 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef _Bool bool;
#line 31 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 33 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __kernel_uid16_t uid16_t;
#line 34 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __kernel_gid16_t gid16_t;
#line 36 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef unsigned long uintptr_t;
#line 40 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __kernel_old_uid_t old_uid_t;
#line 41 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __kernel_old_gid_t old_gid_t;
#line 45 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 64 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __kernel_ptrdiff_t ptrdiff_t;
#line 69 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __kernel_time_t time_t;
#line 74 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __kernel_clock_t clock_t;
#line 79 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __kernel_caddr_t caddr_t;
#line 83 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef unsigned char u_char;
#line 84 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef unsigned short u_short;
#line 85 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef unsigned int u_int;
#line 86 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef unsigned long u_long;
#line 89 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef unsigned char unchar;
#line 90 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef unsigned short ushort;
#line 91 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef unsigned int uint;
#line 92 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef unsigned long ulong;
#line 97 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __u8 u_int8_t;
#line 98 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __s8 int8_t;
#line 99 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __u16 u_int16_t;
#line 100 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __s16 int16_t;
#line 101 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __u32 u_int32_t;
#line 102 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __s32 int32_t;
#line 106 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __u8 uint8_t;
#line 107 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __u16 uint16_t;
#line 108 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __u32 uint32_t;
#line 111 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __u64 uint64_t;
#line 112 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __u64 u_int64_t;
#line 113 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef __s64 int64_t;
#line 133 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 147 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef u64 dma_addr_t;
#line 158 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef unsigned int gfp_t;
#line 159 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef unsigned int fmode_t;
#line 160 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 163 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef u64 phys_addr_t;
#line 168 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 174 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef unsigned long irq_hw_number_t;
#line 176 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
struct __anonstruct_atomic_t_7 {
   int counter ;
};
#line 176 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef struct __anonstruct_atomic_t_7 atomic_t;
#line 181 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
struct __anonstruct_atomic64_t_8 {
   long counter ;
};
#line 181 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
typedef struct __anonstruct_atomic64_t_8 atomic64_t;
#line 186 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 190
struct hlist_node;
#line 190 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 194 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 198 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
struct ustat {
   __kernel_daddr_t f_tfree ;
   __kernel_ino_t f_tinode ;
   char f_fname[6] ;
   char f_fpack[6] ;
};
#line 210 "../../../analyzer/../bench/linux-headers/include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head *head ) ;
};
#line 33 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/ptrace.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 67
struct cpuinfo_x86;
#line 67
struct cpuinfo_x86;
#line 68
struct task_struct;
#line 68
struct task_struct;
#line 250
struct user_desc;
#line 250
struct user_desc;
#line 46 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/alternative.h"
struct alt_instr {
   s32 instr_offset ;
   s32 repl_offset ;
   u16 cpuid ;
   u8 instrlen ;
   u8 replacementlen ;
};
#line 57
struct module;
#line 213
struct paravirt_patch_site;
#line 213
struct paravirt_patch_site;
#line 135 "../../../analyzer/../bench/linux-headers/include/linux/init.h"
typedef int (*initcall_t)(void);
#line 136 "../../../analyzer/../bench/linux-headers/include/linux/init.h"
typedef void (*exitcall_t)(void);
#line 142 "../../../analyzer/../bench/linux-headers/include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 7 "../../../analyzer/../bench/linux-headers/include/uapi/linux/sysinfo.h"
struct sysinfo {
   __kernel_long_t uptime ;
   __kernel_ulong_t loads[3] ;
   __kernel_ulong_t totalram ;
   __kernel_ulong_t freeram ;
   __kernel_ulong_t sharedram ;
   __kernel_ulong_t bufferram ;
   __kernel_ulong_t totalswap ;
   __kernel_ulong_t freeswap ;
   __u16 procs ;
   __u16 pad ;
   __kernel_ulong_t totalhigh ;
   __kernel_ulong_t freehigh ;
   __u32 mem_unit ;
   char _f[(20UL - 2UL * sizeof(__kernel_ulong_t )) - sizeof(__u32 )] ;
};
#line 65 "../../../analyzer/../bench/linux-headers/include/linux/printk.h"
struct va_format {
   char const   *fmt ;
   va_list *va ;
};
#line 9 "../../../analyzer/../bench/linux-headers/include/linux/dynamic_debug.h"
struct _ddebug {
   char const   *modname ;
   char const   *function ;
   char const   *filename ;
   char const   *format ;
   unsigned int lineno : 18 ;
   unsigned int flags : 8 ;
} __attribute__((__aligned__(8))) ;
#line 403 "../../../analyzer/../bench/linux-headers/include/linux/printk.h"
struct file_operations;
#line 405
enum __anonenum_9 {
    DUMP_PREFIX_NONE = 0,
    DUMP_PREFIX_ADDRESS = 1,
    DUMP_PREFIX_OFFSET = 2
} ;
#line 153 "../../../analyzer/../bench/linux-headers/include/linux/kernel.h"
struct completion;
#line 153
struct completion;
#line 154
struct pt_regs;
#line 155
struct user;
#line 155
struct user;
#line 235
struct atomic_notifier_head;
#line 417
struct pid;
#line 417
struct pid;
#line 439
enum lockdep_ok {
    LOCKDEP_STILL_OK = 0,
    LOCKDEP_NOW_UNRELIABLE = 1
} ;
#line 451
enum system_states {
    SYSTEM_BOOTING = 0,
    SYSTEM_RUNNING = 1,
    SYSTEM_HALT = 2,
    SYSTEM_POWER_OFF = 3,
    SYSTEM_RESTART = 4
} ;
#line 528
enum ftrace_dump_mode {
    DUMP_NONE = 0,
    DUMP_ALL = 1,
    DUMP_ORIG = 2
} ;
#line 82 "../../../analyzer/../bench/linux-headers/arch/x86/include/uapi/asm/stat.h"
struct stat {
   __kernel_ulong_t st_dev ;
   __kernel_ulong_t st_ino ;
   __kernel_ulong_t st_nlink ;
   unsigned int st_mode ;
   unsigned int st_uid ;
   unsigned int st_gid ;
   unsigned int __pad0 ;
   __kernel_ulong_t st_rdev ;
   __kernel_long_t st_size ;
   __kernel_long_t st_blksize ;
   __kernel_long_t st_blocks ;
   __kernel_ulong_t st_atime ;
   __kernel_ulong_t st_atime_nsec ;
   __kernel_ulong_t st_mtime ;
   __kernel_ulong_t st_mtime_nsec ;
   __kernel_ulong_t st_ctime ;
   __kernel_ulong_t st_ctime_nsec ;
   __kernel_long_t __unused[3] ;
};
#line 116 "../../../analyzer/../bench/linux-headers/arch/x86/include/uapi/asm/stat.h"
struct __old_kernel_stat {
   unsigned short st_dev ;
   unsigned short st_ino ;
   unsigned short st_mode ;
   unsigned short st_nlink ;
   unsigned short st_uid ;
   unsigned short st_gid ;
   unsigned short st_rdev ;
   unsigned int st_size ;
   unsigned int st_atime ;
   unsigned int st_mtime ;
   unsigned int st_ctime ;
};
#line 18 "../../../analyzer/../bench/linux-headers/include/asm-generic/bug.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 7 "../../../analyzer/../bench/linux-headers/include/linux/bug.h"
enum bug_trap_type {
    BUG_TRAP_TYPE_NONE = 0,
    BUG_TRAP_TYPE_WARN = 1,
    BUG_TRAP_TYPE_BUG = 2
} ;
#line 13
struct pt_regs;
#line 13 "../../../analyzer/../bench/linux-headers/include/linux/thread_info.h"
struct timespec;
#line 13
struct timespec;
#line 14
struct compat_timespec;
#line 14
struct compat_timespec;
#line 19 "../../../analyzer/../bench/linux-headers/include/linux/thread_info.h"
struct __anonstruct_futex_11 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 19 "../../../analyzer/../bench/linux-headers/include/linux/thread_info.h"
struct __anonstruct_nanosleep_12 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
#line 19
struct pollfd;
#line 19 "../../../analyzer/../bench/linux-headers/include/linux/thread_info.h"
struct __anonstruct_poll_13 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 19 "../../../analyzer/../bench/linux-headers/include/linux/thread_info.h"
union __anonunion____missing_field_name_10 {
   struct __anonstruct_futex_11 futex ;
   struct __anonstruct_nanosleep_12 nanosleep ;
   struct __anonstruct_poll_13 poll ;
};
#line 19 "../../../analyzer/../bench/linux-headers/include/linux/thread_info.h"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_10 __annonCompField4 ;
};
#line 18 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/page.h"
struct page;
#line 18
struct page;
#line 4 "../../../analyzer/../bench/linux-headers/include/linux/range.h"
struct range {
   u64 start ;
   u64 end ;
};
#line 21 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/thread_info.h"
struct task_struct;
#line 22
struct exec_domain;
#line 22
struct exec_domain;
#line 7 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
struct task_struct;
#line 8
struct mm_struct;
#line 8
struct mm_struct;
#line 62 "../../../analyzer/../bench/linux-headers/arch/x86/include/uapi/asm/vm86.h"
struct vm86_regs {
   long ebx ;
   long ecx ;
   long edx ;
   long esi ;
   long edi ;
   long ebp ;
   long eax ;
   long __null_ds ;
   long __null_es ;
   long __null_fs ;
   long __null_gs ;
   long orig_eax ;
   long eip ;
   unsigned short cs ;
   unsigned short __csh ;
   long eflags ;
   long esp ;
   unsigned short ss ;
   unsigned short __ssh ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 92 "../../../analyzer/../bench/linux-headers/arch/x86/include/uapi/asm/vm86.h"
struct revectored_struct {
   unsigned long __map[8] ;
};
#line 96 "../../../analyzer/../bench/linux-headers/arch/x86/include/uapi/asm/vm86.h"
struct vm86_struct {
   struct vm86_regs regs ;
   unsigned long flags ;
   unsigned long screen_bitmap ;
   unsigned long cpu_type ;
   struct revectored_struct int_revectored ;
   struct revectored_struct int21_revectored ;
};
#line 110 "../../../analyzer/../bench/linux-headers/arch/x86/include/uapi/asm/vm86.h"
struct vm86plus_info_struct {
   unsigned long force_return_for_pic : 1 ;
   unsigned long vm86dbg_active : 1 ;
   unsigned long vm86dbg_TFpendig : 1 ;
   unsigned long unused : 28 ;
   unsigned long is_vm86pus : 1 ;
   unsigned char vm86dbg_intxxtab[32] ;
};
#line 118 "../../../analyzer/../bench/linux-headers/arch/x86/include/uapi/asm/vm86.h"
struct vm86plus_struct {
   struct vm86_regs regs ;
   unsigned long flags ;
   unsigned long screen_bitmap ;
   unsigned long cpu_type ;
   struct revectored_struct int_revectored ;
   struct revectored_struct int21_revectored ;
   struct vm86plus_info_struct vm86plus ;
};
#line 17 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 31 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/vm86.h"
struct kernel_vm86_struct {
   struct kernel_vm86_regs regs ;
   unsigned long flags ;
   unsigned long screen_bitmap ;
   unsigned long cpu_type ;
   struct revectored_struct int_revectored ;
   struct revectored_struct int21_revectored ;
   struct vm86plus_info_struct vm86plus ;
   struct pt_regs *regs32 ;
};
#line 11 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/math_emu.h"
union __anonunion____missing_field_name_14 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 11 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/math_emu.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_14 __annonCompField5 ;
};
#line 23 "../../../analyzer/../bench/linux-headers/arch/x86/include/uapi/asm/sigcontext.h"
struct _fpx_sw_bytes {
   __u32 magic1 ;
   __u32 extended_size ;
   __u64 xstate_bv ;
   __u32 xstate_size ;
   __u32 padding[7] ;
};
#line 136 "../../../analyzer/../bench/linux-headers/arch/x86/include/uapi/asm/sigcontext.h"
union __anonunion____missing_field_name_15 {
   __u32 reserved3[12] ;
   struct _fpx_sw_bytes sw_reserved ;
};
#line 136 "../../../analyzer/../bench/linux-headers/arch/x86/include/uapi/asm/sigcontext.h"
struct _fpstate {
   __u16 cwd ;
   __u16 swd ;
   __u16 twd ;
   __u16 fop ;
   __u64 rip ;
   __u64 rdp ;
   __u32 mxcsr ;
   __u32 mxcsr_mask ;
   __u32 st_space[32] ;
   __u32 xmm_space[64] ;
   __u32 reserved2[12] ;
   union __anonunion____missing_field_name_15 __annonCompField6 ;
};
#line 197 "../../../analyzer/../bench/linux-headers/arch/x86/include/uapi/asm/sigcontext.h"
struct _xsave_hdr {
   __u64 xstate_bv ;
   __u64 reserved1[2] ;
   __u64 reserved2[5] ;
};
#line 203 "../../../analyzer/../bench/linux-headers/arch/x86/include/uapi/asm/sigcontext.h"
struct _ymmh_state {
   __u32 ymmh_space[64] ;
};
#line 214 "../../../analyzer/../bench/linux-headers/arch/x86/include/uapi/asm/sigcontext.h"
struct _xstate {
   struct _fpstate fpstate ;
   struct _xsave_hdr xstate_hdr ;
   struct _ymmh_state ymmh ;
};
#line 40 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/sigcontext.h"
struct sigcontext {
   unsigned long r8 ;
   unsigned long r9 ;
   unsigned long r10 ;
   unsigned long r11 ;
   unsigned long r12 ;
   unsigned long r13 ;
   unsigned long r14 ;
   unsigned long r15 ;
   unsigned long di ;
   unsigned long si ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long dx ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long sp ;
   unsigned long ip ;
   unsigned long flags ;
   unsigned short cs ;
   unsigned short gs ;
   unsigned short fs ;
   unsigned short __pad0 ;
   unsigned long err ;
   unsigned long trapno ;
   unsigned long oldmask ;
   unsigned long cr2 ;
   void *fpstate ;
   unsigned long reserved1[8] ;
};
#line 8 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/current.h"
struct task_struct;
#line 12 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;
#line 13 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pmdval_t;
#line 14 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pudval_t;
#line 15 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 16 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_16 {
   pteval_t pte ;
};
#line 18 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_16 pte_t;
#line 242 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 242 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 244 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_17 {
   pgdval_t pgd ;
};
#line 244 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_17 pgd_t;
#line 262 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pud_t_18 {
   pudval_t pud ;
};
#line 262 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pud_t_18 pud_t;
#line 283 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pmd_t_19 {
   pmdval_t pmd ;
};
#line 283 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pmd_t_19 pmd_t;
#line 332 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 345
struct file;
#line 345
struct file;
#line 360
struct seq_file;
#line 360
struct seq_file;
#line 363
enum pg_level {
    PG_LEVEL_NONE = 0,
    PG_LEVEL_4K = 1,
    PG_LEVEL_2M = 2,
    PG_LEVEL_1G = 3,
    PG_LEVEL_NUM = 4
} ;
#line 14 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
struct cpumask {
   unsigned long bits[((64UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
};
#line 14 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 682 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
typedef struct cpumask cpumask_var_t[1];
#line 12 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/msr.h"
struct __anonstruct____missing_field_name_21 {
   u32 l ;
   u32 h ;
};
#line 12 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/msr.h"
union __anonunion____missing_field_name_20 {
   struct __anonstruct____missing_field_name_21 __annonCompField7 ;
   u64 q ;
};
#line 12 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/msr.h"
struct msr {
   union __anonunion____missing_field_name_20 __annonCompField8 ;
};
#line 22 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/msr.h"
struct msr_info {
   u32 msr_no ;
   struct msr reg ;
   struct msr *msrs ;
   int err ;
};
#line 29 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/msr.h"
struct msr_regs_info {
   u32 *regs ;
   int err ;
};
#line 22 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/desc_defs.h"
struct __anonstruct____missing_field_name_23 {
   unsigned int a ;
   unsigned int b ;
};
#line 22 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/desc_defs.h"
struct __anonstruct____missing_field_name_24 {
   u16 limit0 ;
   u16 base0 ;
   unsigned int base1 : 8 ;
   unsigned int type : 4 ;
   unsigned int s : 1 ;
   unsigned int dpl : 2 ;
   unsigned int p : 1 ;
   unsigned int limit : 4 ;
   unsigned int avl : 1 ;
   unsigned int l : 1 ;
   unsigned int d : 1 ;
   unsigned int g : 1 ;
   unsigned int base2 : 8 ;
};
#line 22 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/desc_defs.h"
union __anonunion____missing_field_name_22 {
   struct __anonstruct____missing_field_name_23 __annonCompField9 ;
   struct __anonstruct____missing_field_name_24 __annonCompField10 ;
};
#line 22 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/desc_defs.h"
struct desc_struct {
   union __anonunion____missing_field_name_22 __annonCompField11 ;
} __attribute__((__packed__)) ;
#line 43
enum __anonenum_25 {
    GATE_INTERRUPT = 14,
    GATE_TRAP = 15,
    GATE_CALL = 12,
    GATE_TASK = 5
} ;
#line 51 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/desc_defs.h"
struct gate_struct64 {
   u16 offset_low ;
   u16 segment ;
   unsigned int ist : 3 ;
   unsigned int zero0 : 5 ;
   unsigned int type : 5 ;
   unsigned int dpl : 2 ;
   unsigned int p : 1 ;
   u16 offset_middle ;
   u32 offset_high ;
   u32 zero1 ;
} __attribute__((__packed__)) ;
#line 64
enum __anonenum_26 {
    DESC_TSS = 9,
    DESC_LDT = 2,
    DESCTYPE_S = 16
} ;
#line 71 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/desc_defs.h"
struct ldttss_desc64 {
   u16 limit0 ;
   u16 base0 ;
   unsigned int base1 : 8 ;
   unsigned int type : 5 ;
   unsigned int dpl : 2 ;
   unsigned int p : 1 ;
   unsigned int limit1 : 4 ;
   unsigned int zero0 : 3 ;
   unsigned int g : 1 ;
   unsigned int base2 : 8 ;
   u32 base3 ;
   u32 zero1 ;
} __attribute__((__packed__)) ;
#line 81 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/desc_defs.h"
typedef struct gate_struct64 gate_desc;
#line 82 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/desc_defs.h"
typedef struct ldttss_desc64 ldt_desc;
#line 83 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/desc_defs.h"
typedef struct ldttss_desc64 tss_desc;
#line 94 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/desc_defs.h"
struct desc_ptr {
   unsigned short size ;
   unsigned long address ;
} __attribute__((__packed__)) ;
#line 10 "../../../analyzer/../bench/linux-headers/include/uapi/linux/personality.h"
enum __anonenum_27 {
    UNAME26 = 131072,
    ADDR_NO_RANDOMIZE = 262144,
    FDPIC_FUNCPTRS = 524288,
    MMAP_PAGE_ZERO = 1048576,
    ADDR_COMPAT_LAYOUT = 2097152,
    READ_IMPLIES_EXEC = 4194304,
    ADDR_LIMIT_32BIT = 8388608,
    SHORT_INODE = 16777216,
    WHOLE_SECONDS = 33554432,
    STICKY_TIMEOUTS = 67108864,
    ADDR_LIMIT_3GB = 134217728
} ;
#line 41
enum __anonenum_28 {
    PER_LINUX = 0,
    PER_LINUX_32BIT = 8388608,
    PER_LINUX_FDPIC = 524288,
    PER_SVR4 = 68157441,
    PER_SVR3 = 83886082,
    PER_SCOSVR3 = 117440515,
    PER_OSR5 = 100663299,
    PER_WYSEV386 = 83886084,
    PER_ISCR4 = 67108869,
    PER_BSD = 6,
    PER_SUNOS = 67108870,
    PER_XENIX = 83886087,
    PER_LINUX32 = 8,
    PER_LINUX32_3GB = 134217736,
    PER_IRIX32 = 67108873,
    PER_IRIXN32 = 67108874,
    PER_IRIX64 = 67108875,
    PER_RISCOS = 12,
    PER_SOLARIS = 67108877,
    PER_UW7 = 68157454,
    PER_OSF4 = 15,
    PER_HPUX = 16,
    PER_MASK = 255
} ;
#line 11 "../../../analyzer/../bench/linux-headers/include/linux/personality.h"
struct exec_domain;
#line 12
struct pt_regs;
#line 25 "../../../analyzer/../bench/linux-headers/include/linux/personality.h"
typedef void (*handler_t)(int  , struct pt_regs * );
#line 27
struct map_segment;
#line 27 "../../../analyzer/../bench/linux-headers/include/linux/personality.h"
struct exec_domain {
   char const   *name ;
   void (*handler)(int  , struct pt_regs * ) ;
   unsigned char pers_low ;
   unsigned char pers_high ;
   unsigned long *signal_map ;
   unsigned long *signal_invmap ;
   struct map_segment *err_map ;
   struct map_segment *socktype_map ;
   struct map_segment *sockopt_map ;
   struct map_segment *af_map ;
   struct module *module ;
   struct exec_domain *next ;
};
#line 63 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
enum tlb_infos {
    ENTRIES = 0,
    NR_INFO = 1
} ;
#line 82 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
struct cpuinfo_x86 {
   __u8 x86 ;
   __u8 x86_vendor ;
   __u8 x86_model ;
   __u8 x86_mask ;
   int x86_tlbsize ;
   __u8 x86_virt_bits ;
   __u8 x86_phys_bits ;
   __u8 x86_coreid_bits ;
   __u32 extended_cpuid_level ;
   int cpuid_level ;
   __u32 x86_capability[12] ;
   char x86_vendor_id[16] ;
   char x86_model_id[64] ;
   int x86_cache_size ;
   int x86_cache_alignment ;
   int x86_power ;
   unsigned long loops_per_jiffy ;
   u16 x86_max_cores ;
   u16 apicid ;
   u16 initial_apicid ;
   u16 x86_clflush_size ;
   u16 booted_cores ;
   u16 phys_proc_id ;
   u16 cpu_core_id ;
   u8 compute_unit_id ;
   u16 cpu_index ;
   u32 microcode ;
} __attribute__((__aligned__((1) <<  (6) ))) ;
#line 149
struct tss_struct;
#line 161
struct seq_operations;
#line 240 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
struct x86_hw_tss {
   u32 reserved1 ;
   u64 sp0 ;
   u64 sp1 ;
   u64 sp2 ;
   u64 reserved2 ;
   u64 ist[7] ;
   u32 reserved3 ;
   u32 reserved4 ;
   u16 reserved5 ;
   u16 io_bitmap_base ;
} __attribute__((__packed__, __aligned__((1) <<  (6) ))) ;
#line 264 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
struct tss_struct {
   struct x86_hw_tss x86_tss ;
   unsigned long io_bitmap[8192UL / sizeof(long ) + 1UL] ;
   unsigned long stack[64] ;
} __attribute__((__aligned__((1) <<  (6) ))) ;
#line 290 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
struct orig_ist {
   unsigned long ist[7] ;
};
#line 296 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20] ;
   u32 status ;
};
#line 312 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
struct __anonstruct____missing_field_name_30 {
   u64 rip ;
   u64 rdp ;
};
#line 312 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
struct __anonstruct____missing_field_name_31 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 312 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
union __anonunion____missing_field_name_29 {
   struct __anonstruct____missing_field_name_30 __annonCompField12 ;
   struct __anonstruct____missing_field_name_31 __annonCompField13 ;
};
#line 312 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
union __anonunion____missing_field_name_32 {
   u32 padding1[12] ;
   u32 sw_reserved[12] ;
};
#line 312 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_29 __annonCompField14 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32] ;
   u32 xmm_space[64] ;
   u32 padding[12] ;
   union __anonunion____missing_field_name_32 __annonCompField15 ;
} __attribute__((__aligned__(16))) ;
#line 347 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 367 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
struct ymmh_struct {
   u32 ymmh_space[64] ;
};
#line 373 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
struct lwp_struct {
   u8 reserved[128] ;
};
#line 377 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
struct bndregs_struct {
   u64 bndregs[8] ;
} __attribute__((__packed__)) ;
#line 381 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
struct bndcsr_struct {
   u64 cfg_reg_u ;
   u64 status_reg ;
} __attribute__((__packed__)) ;
#line 386 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 xcomp_bv ;
   u64 reserved[6] ;
} __attribute__((__packed__)) ;
#line 392 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
   struct lwp_struct lwp ;
   struct bndregs_struct bndregs ;
   struct bndcsr_struct bndcsr ;
} __attribute__((__packed__, __aligned__(64))) ;
#line 402 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
#line 409 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned int has_fpu ;
   union thread_xstate *state ;
};
#line 418 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
struct __anonstruct____missing_field_name_33 {
   char gs_base[40] ;
   unsigned long stack_canary ;
};
#line 418 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
union irq_stack_union {
   char irq_stack[(1UL << 12) << 2] ;
   struct __anonstruct____missing_field_name_33 __annonCompField16 ;
};
#line 464
struct kmem_cache;
#line 466
struct perf_event;
#line 466
struct perf_event;
#line 468 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   struct fpu fpu ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   unsigned char fpu_counter ;
};
#line 614 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
struct __anonstruct_mm_segment_t_34 {
   unsigned long seg ;
};
#line 614 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
typedef struct __anonstruct_mm_segment_t_34 mm_segment_t;
#line 736
enum idle_boot_override {
    IDLE_NO_OVERRIDE = 0,
    IDLE_HALT = 1,
    IDLE_NOMWAIT = 2,
    IDLE_POLL = 3
} ;
#line 23 "../../../analyzer/../bench/linux-headers/include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 26 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/thread_info.h"
struct thread_info {
   struct task_struct *task ;
   struct exec_domain *exec_domain ;
   __u32 flags ;
   __u32 status ;
   __u32 cpu ;
   int saved_preempt_count ;
   mm_segment_t addr_limit ;
   struct restart_block restart_block ;
   void *sysenter_return ;
   unsigned int sig_on_uaccess_error : 1 ;
   unsigned int uaccess_err : 1 ;
};
#line 27 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/preempt.h"
typedef int pto_T__;
#line 56 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/preempt.h"
typedef int pto_T_____0;
#line 61 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/preempt.h"
typedef int pto_T_____1;
#line 75 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/preempt.h"
typedef int pao_T__;
#line 80 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/preempt.h"
typedef int pao_T_____0;
#line 15 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/spinlock_types.h"
typedef u8 __ticket_t;
#line 16 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/spinlock_types.h"
typedef u16 __ticketpair_t;
#line 26 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/spinlock_types.h"
struct __raw_tickets {
   __ticket_t head ;
   __ticket_t tail ;
};
#line 26 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/spinlock_types.h"
union __anonunion____missing_field_name_35 {
   __ticketpair_t head_tail ;
   struct __raw_tickets tickets ;
};
#line 26 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/spinlock_types.h"
struct arch_spinlock {
   union __anonunion____missing_field_name_35 __annonCompField17 ;
};
#line 26 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/spinlock_types.h"
typedef struct arch_spinlock arch_spinlock_t;
#line 11 "../../../analyzer/../bench/linux-headers/include/asm-generic/qrwlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
#line 11 "../../../analyzer/../bench/linux-headers/include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;
#line 12 "../../../analyzer/../bench/linux-headers/include/linux/lockdep.h"
struct task_struct;
#line 13
struct lockdep_map;
#line 13
struct lockdep_map;
#line 410 "../../../analyzer/../bench/linux-headers/include/linux/lockdep.h"
struct lock_class_key {

};
#line 20 "../../../analyzer/../bench/linux-headers/include/linux/spinlock_types.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
};
#line 20 "../../../analyzer/../bench/linux-headers/include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 64 "../../../analyzer/../bench/linux-headers/include/linux/spinlock_types.h"
union __anonunion____missing_field_name_36 {
   struct raw_spinlock rlock ;
};
#line 64 "../../../analyzer/../bench/linux-headers/include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion____missing_field_name_36 __annonCompField18 ;
};
#line 64 "../../../analyzer/../bench/linux-headers/include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 11 "../../../analyzer/../bench/linux-headers/include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_37 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
};
#line 11 "../../../analyzer/../bench/linux-headers/include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_37 rwlock_t;
#line 73 "../../../analyzer/../bench/linux-headers/include/linux/jump_label.h"
struct static_key {
   atomic_t enabled ;
};
#line 78
enum jump_label_type {
    JUMP_LABEL_DISABLE = 0,
    JUMP_LABEL_ENABLE = 1
} ;
#line 83
struct module;
#line 46 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
struct seqcount {
   unsigned int sequence ;
};
#line 46 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 281 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
struct __anonstruct_seqlock_t_38 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
#line 281 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_38 seqlock_t;
#line 9 "../../../analyzer/../bench/linux-headers/include/uapi/linux/time.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 15 "../../../analyzer/../bench/linux-headers/include/uapi/linux/time.h"
struct timeval {
   __kernel_time_t tv_sec ;
   __kernel_suseconds_t tv_usec ;
};
#line 20 "../../../analyzer/../bench/linux-headers/include/uapi/linux/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 34 "../../../analyzer/../bench/linux-headers/include/uapi/linux/time.h"
struct itimerspec {
   struct timespec it_interval ;
   struct timespec it_value ;
};
#line 39 "../../../analyzer/../bench/linux-headers/include/uapi/linux/time.h"
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
#line 6 "../../../analyzer/../bench/linux-headers/include/linux/time64.h"
typedef __s64 time64_t;
#line 120 "../../../analyzer/../bench/linux-headers/include/linux/time.h"
struct itimerval;
#line 129
struct tms;
#line 129
struct tms;
#line 136 "../../../analyzer/../bench/linux-headers/include/linux/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   long tm_year ;
   int tm_wday ;
   int tm_yday ;
};
#line 17 "../../../analyzer/../bench/linux-headers/include/linux/uidgid.h"
struct user_namespace;
#line 17
struct user_namespace;
#line 20 "../../../analyzer/../bench/linux-headers/include/linux/uidgid.h"
struct __anonstruct_kuid_t_39 {
   uid_t val ;
};
#line 20 "../../../analyzer/../bench/linux-headers/include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_39 kuid_t;
#line 25 "../../../analyzer/../bench/linux-headers/include/linux/uidgid.h"
struct __anonstruct_kgid_t_40 {
   gid_t val ;
};
#line 25 "../../../analyzer/../bench/linux-headers/include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_40 kgid_t;
#line 21 "../../../analyzer/../bench/linux-headers/include/linux/stat.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 6 "../../../analyzer/../bench/linux-headers/include/linux/mmdebug.h"
struct page;
#line 12 "../../../analyzer/../bench/linux-headers/include/linux/wait.h"
struct __wait_queue;
#line 12 "../../../analyzer/../bench/linux-headers/include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;
#line 13 "../../../analyzer/../bench/linux-headers/include/linux/wait.h"
typedef int (*wait_queue_func_t)(wait_queue_t *wait , unsigned int mode , int flags ,
                                 void *key );
#line 16 "../../../analyzer/../bench/linux-headers/include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t *wait , unsigned int mode , int flags , void *key ) ;
   struct list_head task_list ;
};
#line 24 "../../../analyzer/../bench/linux-headers/include/linux/wait.h"
struct wait_bit_key {
   void *flags ;
   int bit_nr ;
   unsigned long private ;
};
#line 31 "../../../analyzer/../bench/linux-headers/include/linux/wait.h"
struct wait_bit_queue {
   struct wait_bit_key key ;
   wait_queue_t wait ;
};
#line 36 "../../../analyzer/../bench/linux-headers/include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 40 "../../../analyzer/../bench/linux-headers/include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 42
struct task_struct;
#line 145 "../../../analyzer/../bench/linux-headers/include/linux/wait.h"
typedef int wait_bit_action_f(struct wait_bit_key * );
#line 98 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
struct __anonstruct_nodemask_t_41 {
   unsigned long bits[(((unsigned long )(1 << 6) + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
};
#line 98 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_41 nodemask_t;
#line 383
enum node_states {
    N_POSSIBLE = 0,
    N_ONLINE = 1,
    N_NORMAL_MEMORY = 2,
    N_HIGH_MEMORY = 2,
    N_MEMORY = 2,
    N_CPU = 3,
    NR_NODE_STATES = 4
} ;
#line 527 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
struct nodemask_scratch {
   nodemask_t mask1 ;
   nodemask_t mask2 ;
};
#line 29 "../../../analyzer/../bench/linux-headers/include/linux/pageblock-flags.h"
enum pageblock_bits {
    PB_migrate = 0,
    PB_migrate_end = 2,
    PB_migrate_skip = 3,
    NR_PAGEBLOCK_BITS = 4
} ;
#line 66
struct page;
#line 38 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
enum __anonenum_42 {
    MIGRATE_UNMOVABLE = 0,
    MIGRATE_RECLAIMABLE = 1,
    MIGRATE_MOVABLE = 2,
    MIGRATE_PCPTYPES = 3,
    MIGRATE_RESERVE = 3,
    MIGRATE_TYPES = 4
} ;
#line 92 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
struct free_area {
   struct list_head free_list[4] ;
   unsigned long nr_free ;
};
#line 97
struct pglist_data;
#line 97
struct pglist_data;
#line 106 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
struct zone_padding {
   char x[0] ;
} __attribute__((__aligned__((1) <<  (6) ))) ;
#line 114
enum zone_stat_item {
    NR_FREE_PAGES = 0,
    NR_ALLOC_BATCH = 1,
    NR_LRU_BASE = 2,
    NR_INACTIVE_ANON = 2,
    NR_ACTIVE_ANON = 3,
    NR_INACTIVE_FILE = 4,
    NR_ACTIVE_FILE = 5,
    NR_UNEVICTABLE = 6,
    NR_MLOCK = 7,
    NR_ANON_PAGES = 8,
    NR_FILE_MAPPED = 9,
    NR_FILE_PAGES = 10,
    NR_FILE_DIRTY = 11,
    NR_WRITEBACK = 12,
    NR_SLAB_RECLAIMABLE = 13,
    NR_SLAB_UNRECLAIMABLE = 14,
    NR_PAGETABLE = 15,
    NR_KERNEL_STACK = 16,
    NR_UNSTABLE_NFS = 17,
    NR_BOUNCE = 18,
    NR_VMSCAN_WRITE = 19,
    NR_VMSCAN_IMMEDIATE = 20,
    NR_WRITEBACK_TEMP = 21,
    NR_ISOLATED_ANON = 22,
    NR_ISOLATED_FILE = 23,
    NR_SHMEM = 24,
    NR_DIRTIED = 25,
    NR_WRITTEN = 26,
    NR_PAGES_SCANNED = 27,
    NUMA_HIT = 28,
    NUMA_MISS = 29,
    NUMA_FOREIGN = 30,
    NUMA_INTERLEAVE_HIT = 31,
    NUMA_LOCAL = 32,
    NUMA_OTHER = 33,
    WORKINGSET_REFAULT = 34,
    WORKINGSET_ACTIVATE = 35,
    WORKINGSET_NODERECLAIM = 36,
    NR_ANON_TRANSPARENT_HUGEPAGES = 37,
    NR_FREE_CMA_PAGES = 38,
    NR_VM_ZONE_STAT_ITEMS = 39
} ;
#line 175
enum lru_list {
    LRU_INACTIVE_ANON = 0,
    LRU_ACTIVE_ANON = 1,
    LRU_INACTIVE_FILE = 2,
    LRU_ACTIVE_FILE = 3,
    LRU_UNEVICTABLE = 4,
    NR_LRU_LISTS = 5
} ;
#line 203 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
struct zone_reclaim_stat {
   unsigned long recent_rotated[2] ;
   unsigned long recent_scanned[2] ;
};
#line 216 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
struct lruvec {
   struct list_head lists[5] ;
   struct zone_reclaim_stat reclaim_stat ;
};
#line 239 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
typedef unsigned int isolate_mode_t;
#line 241
enum zone_watermarks {
    WMARK_MIN = 0,
    WMARK_LOW = 1,
    WMARK_HIGH = 2,
    NR_WMARK = 3
} ;
#line 252 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
struct per_cpu_pages {
   int count ;
   int high ;
   int batch ;
   struct list_head lists[3] ;
};
#line 261 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
struct per_cpu_pageset {
   struct per_cpu_pages pcp ;
   s8 expire ;
   s8 stat_threshold ;
   s8 vm_stat_diff[39] ;
};
#line 274
enum zone_type {
    ZONE_DMA = 0,
    ZONE_DMA32 = 1,
    ZONE_NORMAL = 2,
    ZONE_MOVABLE = 3,
    __MAX_NR_ZONES = 4
} ;
#line 327 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
struct zone {
   unsigned long watermark[3] ;
   long lowmem_reserve[4] ;
   int node ;
   unsigned int inactive_ratio ;
   struct pglist_data *zone_pgdat ;
   struct per_cpu_pageset *pageset ;
   unsigned long dirty_balance_reserve ;
   unsigned long min_unmapped_pages ;
   unsigned long min_slab_pages ;
   unsigned long zone_start_pfn ;
   unsigned long managed_pages ;
   unsigned long spanned_pages ;
   unsigned long present_pages ;
   char const   *name ;
   int nr_migrate_reserve_block ;
   wait_queue_head_t *wait_table ;
   unsigned long wait_table_hash_nr_entries ;
   unsigned long wait_table_bits ;
   struct zone_padding _pad1_ ;
   spinlock_t lock ;
   struct free_area free_area[11] ;
   unsigned long flags ;
   struct zone_padding _pad2_ ;
   spinlock_t lru_lock ;
   struct lruvec lruvec ;
   atomic_long_t inactive_age ;
   unsigned long percpu_drift_mark ;
   unsigned long compact_cached_free_pfn ;
   unsigned long compact_cached_migrate_pfn[2] ;
   unsigned int compact_considered ;
   unsigned int compact_defer_shift ;
   int compact_order_failed ;
   bool compact_blockskip_flush ;
   struct zone_padding _pad3_ ;
   atomic_long_t vm_stat[39] ;
} __attribute__((__aligned__((1) <<  (6) ))) ;
#line 524
enum __anonenum_zone_flags_t_43 {
    ZONE_RECLAIM_LOCKED = 0,
    ZONE_OOM_LOCKED = 1,
    ZONE_CONGESTED = 2,
    ZONE_TAIL_LRU_DIRTY = 3,
    ZONE_WRITEBACK = 4,
    ZONE_FAIR_DEPLETED = 5
} ;
#line 524 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
typedef enum __anonenum_zone_flags_t_43 zone_flags_t;
#line 686 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
struct zonelist_cache {
   unsigned short z_to_n[(1 << 6) * 4] ;
   unsigned long fullzones[(((unsigned long )((1 << 6) * 4) + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
   unsigned long last_full_zap ;
};
#line 700 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
struct zoneref {
   struct zone *zone ;
   int zone_idx ;
};
#line 722 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
struct zonelist {
   struct zonelist_cache *zlcache_ptr ;
   struct zoneref _zonerefs[(1 << 6) * 4 + 1] ;
   struct zonelist_cache zlcache ;
};
#line 731 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
struct node_active_region {
   unsigned long start_pfn ;
   unsigned long end_pfn ;
   int nid ;
};
#line 754
struct bootmem_data;
#line 754
struct bootmem_data;
#line 755 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
struct pglist_data {
   struct zone node_zones[4] ;
   struct zonelist node_zonelists[2] ;
   int nr_zones ;
   unsigned long node_start_pfn ;
   unsigned long node_present_pages ;
   unsigned long node_spanned_pages ;
   int node_id ;
   wait_queue_head_t kswapd_wait ;
   wait_queue_head_t pfmemalloc_wait ;
   struct task_struct *kswapd ;
   int kswapd_max_order ;
   enum zone_type classzone_idx ;
};
#line 755 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
typedef struct pglist_data pg_data_t;
#line 11 "../../../analyzer/../bench/linux-headers/include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};
#line 50 "../../../analyzer/../bench/linux-headers/include/linux/mutex.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   struct optimistic_spin_queue osq ;
};
#line 74 "../../../analyzer/../bench/linux-headers/include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
};
#line 21 "../../../analyzer/../bench/linux-headers/include/linux/rwsem.h"
struct rw_semaphore;
#line 21
struct rw_semaphore;
#line 27 "../../../analyzer/../bench/linux-headers/include/linux/rwsem.h"
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
};
#line 25 "../../../analyzer/../bench/linux-headers/include/linux/completion.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 7 "../../../analyzer/../bench/linux-headers/include/linux/debugobjects.h"
enum debug_obj_state {
    ODEBUG_STATE_NONE = 0,
    ODEBUG_STATE_INIT = 1,
    ODEBUG_STATE_INACTIVE = 2,
    ODEBUG_STATE_ACTIVE = 3,
    ODEBUG_STATE_DESTROYED = 4,
    ODEBUG_STATE_NOTAVAILABLE = 5,
    ODEBUG_STATE_MAX = 6
} ;
#line 17
struct debug_obj_descr;
#line 17
struct debug_obj_descr;
#line 27 "../../../analyzer/../bench/linux-headers/include/linux/debugobjects.h"
struct debug_obj {
   struct hlist_node node ;
   enum debug_obj_state state ;
   unsigned int astate ;
   void *object ;
   struct debug_obj_descr *descr ;
};
#line 52 "../../../analyzer/../bench/linux-headers/include/linux/debugobjects.h"
struct debug_obj_descr {
   char const   *name ;
   void *(*debug_hint)(void *addr ) ;
   int (*fixup_init)(void *addr , enum debug_obj_state state ) ;
   int (*fixup_activate)(void *addr , enum debug_obj_state state ) ;
   int (*fixup_destroy)(void *addr , enum debug_obj_state state ) ;
   int (*fixup_free)(void *addr , enum debug_obj_state state ) ;
   int (*fixup_assert_init)(void *addr , enum debug_obj_state state ) ;
};
#line 54 "../../../analyzer/../bench/linux-headers/include/linux/rcupdate.h"
enum rcutorture_type {
    RCU_FLAVOR = 0,
    RCU_BH_FLAVOR = 1,
    RCU_SCHED_FLAVOR = 2,
    SRCU_FLAVOR = 3,
    INVALID_RCU_FLAVOR = 4
} ;
#line 244
struct notifier_block;
#line 244
struct notifier_block;
#line 306 "../../../analyzer/../bench/linux-headers/include/linux/rcupdate.h"
typedef void call_rcu_func_t(struct callback_head *head , void (*func)(struct callback_head *head ) );
#line 64 "../../../analyzer/../bench/linux-headers/include/uapi/linux/timex.h"
struct timex {
   unsigned int modes ;
   __kernel_long_t offset ;
   __kernel_long_t freq ;
   __kernel_long_t maxerror ;
   __kernel_long_t esterror ;
   int status ;
   __kernel_long_t constant ;
   __kernel_long_t precision ;
   __kernel_long_t tolerance ;
   struct timeval time ;
   __kernel_long_t tick ;
   __kernel_long_t ppsfreq ;
   __kernel_long_t jitter ;
   int shift ;
   __kernel_long_t stabil ;
   __kernel_long_t jitcnt ;
   __kernel_long_t calcnt ;
   __kernel_long_t errcnt ;
   __kernel_long_t stbcnt ;
   int tai ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
};
#line 15 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/tsc.h"
typedef unsigned long long cycles_t;
#line 37 "../../../analyzer/../bench/linux-headers/include/linux/ktime.h"
union ktime {
   s64 tv64 ;
};
#line 41 "../../../analyzer/../bench/linux-headers/include/linux/ktime.h"
typedef union ktime ktime_t;
#line 100 "../../../analyzer/../bench/linux-headers/include/linux/timekeeping.h"
enum tk_offsets {
    TK_OFFS_REAL = 0,
    TK_OFFS_BOOT = 1,
    TK_OFFS_TAI = 2,
    TK_OFFS_MAX = 3
} ;
#line 10 "../../../analyzer/../bench/linux-headers/include/linux/timer.h"
struct tvec_base;
#line 10
struct tvec_base;
#line 12 "../../../analyzer/../bench/linux-headers/include/linux/timer.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   struct tvec_base *base ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16] ;
};
#line 254
struct hrtimer;
#line 254
struct hrtimer;
#line 255
enum hrtimer_restart;
#line 16 "../../../analyzer/../bench/linux-headers/include/linux/workqueue.h"
struct workqueue_struct;
#line 16
struct workqueue_struct;
#line 18
struct work_struct;
#line 18
struct work_struct;
#line 19 "../../../analyzer/../bench/linux-headers/include/linux/workqueue.h"
typedef void (*work_func_t)(struct work_struct *work );
#line 28
enum __anonenum_44 {
    WORK_STRUCT_PENDING_BIT = 0,
    WORK_STRUCT_DELAYED_BIT = 1,
    WORK_STRUCT_PWQ_BIT = 2,
    WORK_STRUCT_LINKED_BIT = 3,
    WORK_STRUCT_COLOR_SHIFT = 4,
    WORK_STRUCT_COLOR_BITS = 4,
    WORK_STRUCT_PENDING = 1,
    WORK_STRUCT_DELAYED = 2,
    WORK_STRUCT_PWQ = 4,
    WORK_STRUCT_LINKED = 8,
    WORK_STRUCT_STATIC = 0,
    WORK_NR_COLORS = 15,
    WORK_NO_COLOR = 15,
    WORK_CPU_UNBOUND = 64,
    WORK_STRUCT_FLAG_BITS = 8,
    WORK_OFFQ_FLAG_BASE = 4,
    WORK_OFFQ_CANCELING = 16,
    WORK_OFFQ_FLAG_BITS = 1,
    WORK_OFFQ_POOL_SHIFT = 5,
    WORK_OFFQ_LEFT = 59,
    WORK_OFFQ_POOL_BITS = 31,
    WORK_OFFQ_POOL_NONE = 2147483647,
    WORK_STRUCT_FLAG_MASK = 255,
    WORK_STRUCT_WQ_DATA_MASK = -256,
    WORK_STRUCT_NO_POOL = 68719476704L,
    WORK_BUSY_PENDING = 1,
    WORK_BUSY_RUNNING = 2,
    WORKER_DESC_LEN = 24
} ;
#line 99 "../../../analyzer/../bench/linux-headers/include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct *work ) ;
};
#line 112 "../../../analyzer/../bench/linux-headers/include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 129 "../../../analyzer/../bench/linux-headers/include/linux/workqueue.h"
struct workqueue_attrs {
   int nice ;
   cpumask_var_t cpumask ;
   bool no_numa ;
};
#line 140 "../../../analyzer/../bench/linux-headers/include/linux/workqueue.h"
struct execute_work {
   struct work_struct work ;
};
#line 280
enum __anonenum_45 {
    WQ_UNBOUND = 2,
    WQ_FREEZABLE = 4,
    WQ_MEM_RECLAIM = 8,
    WQ_HIGHPRI = 16,
    WQ_CPU_INTENSIVE = 32,
    WQ_SYSFS = 64,
    WQ_POWER_EFFICIENT = 128,
    __WQ_DRAINING = 65536,
    __WQ_ORDERED = 131072,
    WQ_MAX_ACTIVE = 512,
    WQ_MAX_UNBOUND_PER_CPU = 4,
    WQ_DFL_ACTIVE = 256
} ;
#line 36 "../../../analyzer/../bench/linux-headers/include/linux/srcu.h"
struct srcu_struct_array {
   unsigned long c[2] ;
   unsigned long seq[2] ;
};
#line 41 "../../../analyzer/../bench/linux-headers/include/linux/srcu.h"
struct rcu_batch {
   struct callback_head *head ;
   struct callback_head **tail ;
};
#line 47 "../../../analyzer/../bench/linux-headers/include/linux/srcu.h"
struct srcu_struct {
   unsigned int completed ;
   struct srcu_struct_array *per_cpu_ref ;
   spinlock_t queue_lock ;
   bool running ;
   struct rcu_batch batch_queue ;
   struct rcu_batch batch_check0 ;
   struct rcu_batch batch_check1 ;
   struct rcu_batch batch_done ;
   struct delayed_work work ;
};
#line 50 "../../../analyzer/../bench/linux-headers/include/linux/notifier.h"
typedef int (*notifier_fn_t)(struct notifier_block *nb , unsigned long action , void *data );
#line 53 "../../../analyzer/../bench/linux-headers/include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block *nb , unsigned long action , void *data ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 59 "../../../analyzer/../bench/linux-headers/include/linux/notifier.h"
struct atomic_notifier_head {
   spinlock_t lock ;
   struct notifier_block *head ;
};
#line 64 "../../../analyzer/../bench/linux-headers/include/linux/notifier.h"
struct blocking_notifier_head {
   struct rw_semaphore rwsem ;
   struct notifier_block *head ;
};
#line 69 "../../../analyzer/../bench/linux-headers/include/linux/notifier.h"
struct raw_notifier_head {
   struct notifier_block *head ;
};
#line 73 "../../../analyzer/../bench/linux-headers/include/linux/notifier.h"
struct srcu_notifier_head {
   struct mutex mutex ;
   struct srcu_struct srcu ;
   struct notifier_block *head ;
};
#line 9 "../../../analyzer/../bench/linux-headers/include/linux/memory_hotplug.h"
struct page;
#line 10
struct zone;
#line 11
struct pglist_data;
#line 12
struct mem_section;
#line 12
struct mem_section;
#line 13
struct memory_block;
#line 13
struct memory_block;
#line 835 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
enum memmap_context {
    MEMMAP_EARLY = 0,
    MEMMAP_HOTPLUG = 1
} ;
#line 922
struct ctl_table;
#line 922
struct ctl_table;
#line 21 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/mpspec_def.h"
struct mpf_intel {
   char signature[4] ;
   unsigned int physptr ;
   unsigned char length ;
   unsigned char specification ;
   unsigned char checksum ;
   unsigned char feature1 ;
   unsigned char feature2 ;
   unsigned char feature3 ;
   unsigned char feature4 ;
   unsigned char feature5 ;
};
#line 36 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/mpspec_def.h"
struct mpc_table {
   char signature[4] ;
   unsigned short length ;
   char spec ;
   char checksum ;
   char oem[8] ;
   char productid[12] ;
   unsigned int oemptr ;
   unsigned short oemsize ;
   unsigned short oemcount ;
   unsigned int lapic ;
   unsigned int reserved ;
};
#line 67 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/mpspec_def.h"
struct mpc_cpu {
   unsigned char type ;
   unsigned char apicid ;
   unsigned char apicver ;
   unsigned char cpuflag ;
   unsigned int cpufeature ;
   unsigned int featureflag ;
   unsigned int reserved[2] ;
};
#line 77 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/mpspec_def.h"
struct mpc_bus {
   unsigned char type ;
   unsigned char busid ;
   unsigned char bustype[6] ;
};
#line 105 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/mpspec_def.h"
struct mpc_ioapic {
   unsigned char type ;
   unsigned char apicid ;
   unsigned char apicver ;
   unsigned char flags ;
   unsigned int apicaddr ;
};
#line 113 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/mpspec_def.h"
struct mpc_intsrc {
   unsigned char type ;
   unsigned char irqtype ;
   unsigned short irqflag ;
   unsigned char srcbus ;
   unsigned char srcbusirq ;
   unsigned char dstapic ;
   unsigned char dstirq ;
};
#line 123
enum mp_irq_source_types {
    mp_INT = 0,
    mp_NMI = 1,
    mp_SMI = 2,
    mp_ExtINT = 3
} ;
#line 136 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/mpspec_def.h"
struct mpc_lintsrc {
   unsigned char type ;
   unsigned char irqtype ;
   unsigned short irqflag ;
   unsigned char srcbusid ;
   unsigned char srcbusirq ;
   unsigned char destapic ;
   unsigned char destapiclint ;
};
#line 148 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/mpspec_def.h"
struct mpc_oemtable {
   char signature[4] ;
   unsigned short length ;
   char rev ;
   char checksum ;
   char mpc[8] ;
};
#line 168
enum mp_bustype {
    MP_BUS_ISA = 1,
    MP_BUS_EISA = 2,
    MP_BUS_PCI = 3
} ;
#line 10 "../../../analyzer/../bench/linux-headers/include/uapi/linux/screen_info.h"
struct screen_info {
   __u8 orig_x ;
   __u8 orig_y ;
   __u16 ext_mem_k ;
   __u16 orig_video_page ;
   __u8 orig_video_mode ;
   __u8 orig_video_cols ;
   __u8 flags ;
   __u8 unused2 ;
   __u16 orig_video_ega_bx ;
   __u16 unused3 ;
   __u8 orig_video_lines ;
   __u8 orig_video_isVGA ;
   __u16 orig_video_points ;
   __u16 lfb_width ;
   __u16 lfb_height ;
   __u16 lfb_depth ;
   __u32 lfb_base ;
   __u32 lfb_size ;
   __u16 cl_magic ;
   __u16 cl_offset ;
   __u16 lfb_linelength ;
   __u8 red_size ;
   __u8 red_pos ;
   __u8 green_size ;
   __u8 green_pos ;
   __u8 blue_size ;
   __u8 blue_pos ;
   __u8 rsvd_size ;
   __u8 rsvd_pos ;
   __u16 vesapm_seg ;
   __u16 vesapm_off ;
   __u16 pages ;
   __u16 vesa_attributes ;
   __u32 capabilities ;
   __u8 _reserved[6] ;
} __attribute__((__packed__)) ;
#line 21 "../../../analyzer/../bench/linux-headers/include/uapi/linux/apm_bios.h"
typedef unsigned short apm_event_t;
#line 22 "../../../analyzer/../bench/linux-headers/include/uapi/linux/apm_bios.h"
typedef unsigned short apm_eventinfo_t;
#line 24 "../../../analyzer/../bench/linux-headers/include/uapi/linux/apm_bios.h"
struct apm_bios_info {
   __u16 version ;
   __u16 cseg ;
   __u32 offset ;
   __u16 cseg_16 ;
   __u16 dseg ;
   __u16 flags ;
   __u16 cseg_len ;
   __u16 cseg_16_len ;
   __u16 dseg_len ;
};
#line 35 "../../../analyzer/../bench/linux-headers/include/linux/apm_bios.h"
struct apm_info {
   struct apm_bios_info bios ;
   unsigned short connection_version ;
   int get_power_status_broken ;
   int get_power_status_swabinminutes ;
   int allow_ints ;
   int forbid_idle ;
   int realmode_power_off ;
   int disabled ;
};
#line 71 "../../../analyzer/../bench/linux-headers/include/uapi/linux/edd.h"
struct __anonstruct_isa_47 {
   __u16 base_address ;
   __u16 reserved1 ;
   __u32 reserved2 ;
} __attribute__((__packed__)) ;
#line 71 "../../../analyzer/../bench/linux-headers/include/uapi/linux/edd.h"
struct __anonstruct_pci_48 {
   __u8 bus ;
   __u8 slot ;
   __u8 function ;
   __u8 channel ;
   __u32 reserved ;
} __attribute__((__packed__)) ;
#line 71 "../../../analyzer/../bench/linux-headers/include/uapi/linux/edd.h"
struct __anonstruct_ibnd_49 {
   __u64 reserved ;
} __attribute__((__packed__)) ;
#line 71 "../../../analyzer/../bench/linux-headers/include/uapi/linux/edd.h"
struct __anonstruct_xprs_50 {
   __u64 reserved ;
} __attribute__((__packed__)) ;
#line 71 "../../../analyzer/../bench/linux-headers/include/uapi/linux/edd.h"
struct __anonstruct_htpt_51 {
   __u64 reserved ;
} __attribute__((__packed__)) ;
#line 71 "../../../analyzer/../bench/linux-headers/include/uapi/linux/edd.h"
struct __anonstruct_unknown_52 {
   __u64 reserved ;
} __attribute__((__packed__)) ;
#line 71 "../../../analyzer/../bench/linux-headers/include/uapi/linux/edd.h"
union __anonunion_interface_path_46 {
   struct __anonstruct_isa_47 isa ;
   struct __anonstruct_pci_48 pci ;
   struct __anonstruct_ibnd_49 ibnd ;
   struct __anonstruct_xprs_50 xprs ;
   struct __anonstruct_htpt_51 htpt ;
   struct __anonstruct_unknown_52 unknown ;
};
#line 71 "../../../analyzer/../bench/linux-headers/include/uapi/linux/edd.h"
struct __anonstruct_ata_54 {
   __u8 device ;
   __u8 reserved1 ;
   __u16 reserved2 ;
   __u32 reserved3 ;
   __u64 reserved4 ;
} __attribute__((__packed__)) ;
#line 71 "../../../analyzer/../bench/linux-headers/include/uapi/linux/edd.h"
struct __anonstruct_atapi_55 {
   __u8 device ;
   __u8 lun ;
   __u8 reserved1 ;
   __u8 reserved2 ;
   __u32 reserved3 ;
   __u64 reserved4 ;
} __attribute__((__packed__)) ;
#line 71 "../../../analyzer/../bench/linux-headers/include/uapi/linux/edd.h"
struct __anonstruct_scsi_56 {
   __u16 id ;
   __u64 lun ;
   __u16 reserved1 ;
   __u32 reserved2 ;
} __attribute__((__packed__)) ;
#line 71 "../../../analyzer/../bench/linux-headers/include/uapi/linux/edd.h"
struct __anonstruct_usb_57 {
   __u64 serial_number ;
   __u64 reserved ;
} __attribute__((__packed__)) ;
#line 71 "../../../analyzer/../bench/linux-headers/include/uapi/linux/edd.h"
struct __anonstruct_i1394_58 {
   __u64 eui ;
   __u64 reserved ;
} __attribute__((__packed__)) ;
#line 71 "../../../analyzer/../bench/linux-headers/include/uapi/linux/edd.h"
struct __anonstruct_fibre_59 {
   __u64 wwid ;
   __u64 lun ;
} __attribute__((__packed__)) ;
#line 71 "../../../analyzer/../bench/linux-headers/include/uapi/linux/edd.h"
struct __anonstruct_i2o_60 {
   __u64 identity_tag ;
   __u64 reserved ;
} __attribute__((__packed__)) ;
#line 71 "../../../analyzer/../bench/linux-headers/include/uapi/linux/edd.h"
struct __anonstruct_raid_61 {
   __u32 array_number ;
   __u32 reserved1 ;
   __u64 reserved2 ;
} __attribute__((__packed__)) ;
#line 71 "../../../analyzer/../bench/linux-headers/include/uapi/linux/edd.h"
struct __anonstruct_sata_62 {
   __u8 device ;
   __u8 reserved1 ;
   __u16 reserved2 ;
   __u32 reserved3 ;
   __u64 reserved4 ;
} __attribute__((__packed__)) ;
#line 71 "../../../analyzer/../bench/linux-headers/include/uapi/linux/edd.h"
struct __anonstruct_unknown_63 {
   __u64 reserved1 ;
   __u64 reserved2 ;
} __attribute__((__packed__)) ;
#line 71 "../../../analyzer/../bench/linux-headers/include/uapi/linux/edd.h"
union __anonunion_device_path_53 {
   struct __anonstruct_ata_54 ata ;
   struct __anonstruct_atapi_55 atapi ;
   struct __anonstruct_scsi_56 scsi ;
   struct __anonstruct_usb_57 usb ;
   struct __anonstruct_i1394_58 i1394 ;
   struct __anonstruct_fibre_59 fibre ;
   struct __anonstruct_i2o_60 i2o ;
   struct __anonstruct_raid_61 raid ;
   struct __anonstruct_sata_62 sata ;
   struct __anonstruct_unknown_63 unknown ;
};
#line 71 "../../../analyzer/../bench/linux-headers/include/uapi/linux/edd.h"
struct edd_device_params {
   __u16 length ;
   __u16 info_flags ;
   __u32 num_default_cylinders ;
   __u32 num_default_heads ;
   __u32 sectors_per_track ;
   __u64 number_of_sectors ;
   __u16 bytes_per_sector ;
   __u32 dpte_ptr ;
   __u16 key ;
   __u8 device_path_info_length ;
   __u8 reserved2 ;
   __u16 reserved3 ;
   __u8 host_bus_type[4] ;
   __u8 interface_type[8] ;
   union __anonunion_interface_path_46 interface_path ;
   union __anonunion_device_path_53 device_path ;
   __u8 reserved4 ;
   __u8 checksum ;
} __attribute__((__packed__)) ;
#line 172 "../../../analyzer/../bench/linux-headers/include/uapi/linux/edd.h"
struct edd_info {
   __u8 device ;
   __u8 version ;
   __u16 interface_support ;
   __u16 legacy_max_cylinder ;
   __u8 legacy_max_head ;
   __u8 legacy_sectors_per_track ;
   struct edd_device_params params ;
} __attribute__((__packed__)) ;
#line 182 "../../../analyzer/../bench/linux-headers/include/uapi/linux/edd.h"
struct edd {
   unsigned int mbr_signature[16] ;
   struct edd_info edd_info[6] ;
   unsigned char mbr_signature_nr ;
   unsigned char edd_info_nr ;
};
#line 52 "../../../analyzer/../bench/linux-headers/arch/x86/include/uapi/asm/e820.h"
struct e820entry {
   __u64 addr ;
   __u64 size ;
   __u32 type ;
} __attribute__((__packed__)) ;
#line 58 "../../../analyzer/../bench/linux-headers/arch/x86/include/uapi/asm/e820.h"
struct e820map {
   __u32 nr_map ;
   struct e820entry map[128 + 3 * (1 << 6)] ;
};
#line 31 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/e820.h"
struct setup_data;
#line 31
struct setup_data;
#line 18 "../../../analyzer/../bench/linux-headers/include/linux/ioport.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 217
struct device;
#line 217
struct device;
#line 22 "../../../analyzer/../bench/linux-headers/arch/x86/include/uapi/asm/ist.h"
struct ist_info {
   __u32 signature ;
   __u32 command ;
   __u32 event ;
   __u32 perf_level ;
};
#line 4 "../../../analyzer/../bench/linux-headers/include/uapi/video/edid.h"
struct edid_info {
   unsigned char dummy[128] ;
};
#line 40 "../../../analyzer/../bench/linux-headers/arch/x86/include/uapi/asm/bootparam.h"
struct setup_data {
   __u64 next ;
   __u32 type ;
   __u32 len ;
   __u8 data[0] ;
};
#line 47 "../../../analyzer/../bench/linux-headers/arch/x86/include/uapi/asm/bootparam.h"
struct setup_header {
   __u8 setup_sects ;
   __u16 root_flags ;
   __u32 syssize ;
   __u16 ram_size ;
   __u16 vid_mode ;
   __u16 root_dev ;
   __u16 boot_flag ;
   __u16 jump ;
   __u32 header ;
   __u16 version ;
   __u32 realmode_swtch ;
   __u16 start_sys ;
   __u16 kernel_version ;
   __u8 type_of_loader ;
   __u8 loadflags ;
   __u16 setup_move_size ;
   __u32 code32_start ;
   __u32 ramdisk_image ;
   __u32 ramdisk_size ;
   __u32 bootsect_kludge ;
   __u16 heap_end_ptr ;
   __u8 ext_loader_ver ;
   __u8 ext_loader_type ;
   __u32 cmd_line_ptr ;
   __u32 initrd_addr_max ;
   __u32 kernel_alignment ;
   __u8 relocatable_kernel ;
   __u8 min_alignment ;
   __u16 xloadflags ;
   __u32 cmdline_size ;
   __u32 hardware_subarch ;
   __u64 hardware_subarch_data ;
   __u32 payload_offset ;
   __u32 payload_length ;
   __u64 setup_data ;
   __u64 pref_address ;
   __u32 init_size ;
   __u32 handover_offset ;
} __attribute__((__packed__)) ;
#line 88 "../../../analyzer/../bench/linux-headers/arch/x86/include/uapi/asm/bootparam.h"
struct sys_desc_table {
   __u16 length ;
   __u8 table[14] ;
};
#line 94 "../../../analyzer/../bench/linux-headers/arch/x86/include/uapi/asm/bootparam.h"
struct olpc_ofw_header {
   __u32 ofw_magic ;
   __u32 ofw_version ;
   __u32 cif_handler ;
   __u32 irq_desc_table ;
} __attribute__((__packed__)) ;
#line 101 "../../../analyzer/../bench/linux-headers/arch/x86/include/uapi/asm/bootparam.h"
struct efi_info {
   __u32 efi_loader_signature ;
   __u32 efi_systab ;
   __u32 efi_memdesc_size ;
   __u32 efi_memdesc_version ;
   __u32 efi_memmap ;
   __u32 efi_memmap_size ;
   __u32 efi_systab_hi ;
   __u32 efi_memmap_hi ;
};
#line 113 "../../../analyzer/../bench/linux-headers/arch/x86/include/uapi/asm/bootparam.h"
struct boot_params {
   struct screen_info screen_info ;
   struct apm_bios_info apm_bios_info ;
   __u8 _pad2[4] ;
   __u64 tboot_addr ;
   struct ist_info ist_info ;
   __u8 _pad3[16] ;
   __u8 hd0_info[16] ;
   __u8 hd1_info[16] ;
   struct sys_desc_table sys_desc_table ;
   struct olpc_ofw_header olpc_ofw_header ;
   __u32 ext_ramdisk_image ;
   __u32 ext_ramdisk_size ;
   __u32 ext_cmd_line_ptr ;
   __u8 _pad4[116] ;
   struct edid_info edid_info ;
   struct efi_info efi_info ;
   __u32 alt_mem_k ;
   __u32 scratch ;
   __u8 e820_entries ;
   __u8 eddbuf_entries ;
   __u8 edd_mbr_sig_buf_entries ;
   __u8 kbd_status ;
   __u8 _pad5[3] ;
   __u8 sentinel ;
   __u8 _pad6[1] ;
   struct setup_header hdr ;
   __u8 _pad7[159UL - sizeof(struct setup_header )] ;
   __u32 edd_mbr_sig_buffer[16] ;
   struct e820entry e820_map[128] ;
   __u8 _pad8[48] ;
   struct edd_info eddbuf[6] ;
   __u8 _pad9[276] ;
} __attribute__((__packed__)) ;
#line 159
enum __anonenum_64 {
    X86_SUBARCH_PC = 0,
    X86_SUBARCH_LGUEST = 1,
    X86_SUBARCH_XEN = 2,
    X86_SUBARCH_INTEL_MID = 3,
    X86_SUBARCH_CE4100 = 4,
    X86_NR_SUBARCHS = 5
} ;
#line 7 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/x86_init.h"
struct mpc_bus;
#line 8
struct mpc_cpu;
#line 9
struct mpc_table;
#line 10
struct cpuinfo_x86;
#line 23 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/x86_init.h"
struct x86_init_mpparse {
   void (*mpc_record)(unsigned int mode ) ;
   void (*setup_ioapic_ids)(void) ;
   int (*mpc_apic_id)(struct mpc_cpu *m ) ;
   void (*smp_read_mpc_oem)(struct mpc_table *mpc ) ;
   void (*mpc_oem_pci_bus)(struct mpc_bus *m ) ;
   void (*mpc_oem_bus_info)(struct mpc_bus *m , char *name ) ;
   void (*find_smp_config)(void) ;
   void (*get_smp_config)(unsigned int early ) ;
};
#line 42 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/x86_init.h"
struct x86_init_resources {
   void (*probe_roms)(void) ;
   void (*reserve_resources)(void) ;
   char *(*memory_setup)(void) ;
};
#line 55 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/x86_init.h"
struct x86_init_irqs {
   void (*pre_vector_init)(void) ;
   void (*intr_init)(void) ;
   void (*trap_init)(void) ;
};
#line 66 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/x86_init.h"
struct x86_init_oem {
   void (*arch_setup)(void) ;
   void (*banner)(void) ;
};
#line 78 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/x86_init.h"
struct x86_init_paging {
   void (*pagetable_init)(void) ;
};
#line 90 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/x86_init.h"
struct x86_init_timers {
   void (*setup_percpu_clockev)(void) ;
   void (*tsc_pre_init)(void) ;
   void (*timer_init)(void) ;
   void (*wallclock_init)(void) ;
};
#line 101 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/x86_init.h"
struct x86_init_iommu {
   int (*iommu_init)(void) ;
};
#line 112 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/x86_init.h"
struct x86_init_pci {
   int (*arch_init)(void) ;
   int (*init)(void) ;
   void (*init_irq)(void) ;
   void (*fixup_irqs)(void) ;
};
#line 123 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/x86_init.h"
struct x86_init_ops {
   struct x86_init_resources resources ;
   struct x86_init_mpparse mpparse ;
   struct x86_init_irqs irqs ;
   struct x86_init_oem oem ;
   struct x86_init_paging paging ;
   struct x86_init_timers timers ;
   struct x86_init_iommu iommu ;
   struct x86_init_pci pci ;
};
#line 139 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/x86_init.h"
struct x86_cpuinit_ops {
   void (*setup_percpu_clockev)(void) ;
   void (*early_percpu_clock_init)(void) ;
   void (*fixup_cpu_id)(struct cpuinfo_x86 *c , int node ) ;
};
#line 145
struct timespec;
#line 159 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/x86_init.h"
struct x86_platform_ops {
   unsigned long (*calibrate_tsc)(void) ;
   void (*get_wallclock)(struct timespec *ts ) ;
   int (*set_wallclock)(struct timespec  const  *ts ) ;
   void (*iommu_shutdown)(void) ;
   bool (*is_untracked_pat_range)(u64 start , u64 end ) ;
   void (*nmi_init)(void) ;
   unsigned char (*get_nmi_reason)(void) ;
   int (*i8042_detect)(void) ;
   void (*save_sched_clock_state)(void) ;
   void (*restore_sched_clock_state)(void) ;
   void (*apic_post_init)(void) ;
};
#line 173
struct pci_dev;
#line 173
struct pci_dev;
#line 174
struct msi_msg;
#line 174
struct msi_msg;
#line 175
struct msi_desc;
#line 175
struct msi_desc;
#line 177 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/x86_init.h"
struct x86_msi_ops {
   int (*setup_msi_irqs)(struct pci_dev *dev , int nvec , int type ) ;
   void (*compose_msi_msg)(struct pci_dev *dev , unsigned int irq , unsigned int dest ,
                           struct msi_msg *msg , u8 hpet_id ) ;
   void (*teardown_msi_irq)(unsigned int irq ) ;
   void (*teardown_msi_irqs)(struct pci_dev *dev ) ;
   void (*restore_msi_irqs)(struct pci_dev *dev ) ;
   int (*setup_hpet_msi)(unsigned int irq , unsigned int id ) ;
   u32 (*msi_mask_irq)(struct msi_desc *desc , u32 mask , u32 flag ) ;
   u32 (*msix_mask_irq)(struct msi_desc *desc , u32 flag ) ;
};
#line 190
struct IO_APIC_route_entry;
#line 190
struct IO_APIC_route_entry;
#line 191
struct io_apic_irq_attr;
#line 191
struct io_apic_irq_attr;
#line 192
struct irq_data;
#line 192
struct irq_data;
#line 193
struct cpumask;
#line 195 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/x86_init.h"
struct x86_io_apic_ops {
   void (*init)(void) ;
   unsigned int (*read)(unsigned int apic , unsigned int reg ) ;
   void (*write)(unsigned int apic , unsigned int reg , unsigned int value ) ;
   void (*modify)(unsigned int apic , unsigned int reg , unsigned int value ) ;
   void (*disable)(void) ;
   void (*print_entries)(unsigned int apic , unsigned int nr_entries ) ;
   int (*set_affinity)(struct irq_data *data , struct cpumask  const  *mask , bool force ) ;
   int (*setup_entry)(int irq , struct IO_APIC_route_entry *entry , unsigned int destination ,
                      int vector , struct io_apic_irq_attr *attr ) ;
   void (*eoi_ioapic_pin)(int apic , int pin , int vector ) ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_01_65 {
   unsigned int __reserved[4] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_02_66 {
   unsigned int __reserved[4] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_id_67 {
   unsigned int __reserved_1 : 24 ;
   unsigned int phys_apic_id : 4 ;
   unsigned int __reserved_2 : 4 ;
   unsigned int __reserved[3] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_version_68 {
   unsigned int version : 8 ;
   unsigned int __reserved_1 : 8 ;
   unsigned int max_lvt : 8 ;
   unsigned int __reserved_2 : 8 ;
   unsigned int __reserved[3] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_03_69 {
   unsigned int __reserved[4] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_04_70 {
   unsigned int __reserved[4] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_05_71 {
   unsigned int __reserved[4] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_06_72 {
   unsigned int __reserved[4] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_tpr_73 {
   unsigned int priority : 8 ;
   unsigned int __reserved_1 : 24 ;
   unsigned int __reserved_2[3] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_apr_74 {
   unsigned int priority : 8 ;
   unsigned int __reserved_1 : 24 ;
   unsigned int __reserved_2[3] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_ppr_75 {
   unsigned int priority : 8 ;
   unsigned int __reserved_1 : 24 ;
   unsigned int __reserved_2[3] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_eoi_76 {
   unsigned int eoi ;
   unsigned int __reserved[3] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_07_77 {
   unsigned int __reserved[4] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_ldr_78 {
   unsigned int __reserved_1 : 24 ;
   unsigned int logical_dest : 8 ;
   unsigned int __reserved_2[3] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_dfr_79 {
   unsigned int __reserved_1 : 28 ;
   unsigned int model : 4 ;
   unsigned int __reserved_2[3] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_svr_80 {
   unsigned int spurious_vector : 8 ;
   unsigned int apic_enabled : 1 ;
   unsigned int focus_cpu : 1 ;
   unsigned int __reserved_2 : 22 ;
   unsigned int __reserved_3[3] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_isr_81 {
   unsigned int bitfield ;
   unsigned int __reserved[3] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_tmr_82 {
   unsigned int bitfield ;
   unsigned int __reserved[3] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_irr_83 {
   unsigned int bitfield ;
   unsigned int __reserved[3] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_error_bits_85 {
   unsigned int send_cs_error : 1 ;
   unsigned int receive_cs_error : 1 ;
   unsigned int send_accept_error : 1 ;
   unsigned int receive_accept_error : 1 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int send_illegal_vector : 1 ;
   unsigned int receive_illegal_vector : 1 ;
   unsigned int illegal_register_address : 1 ;
   unsigned int __reserved_2 : 24 ;
   unsigned int __reserved_3[3] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_all_errors_86 {
   unsigned int errors ;
   unsigned int __reserved_3[3] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
union __anonunion_esr_84 {
   struct __anonstruct_error_bits_85 error_bits ;
   struct __anonstruct_all_errors_86 all_errors ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_08_87 {
   unsigned int __reserved[4] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_09_88 {
   unsigned int __reserved[4] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_10_89 {
   unsigned int __reserved[4] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_11_90 {
   unsigned int __reserved[4] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_12_91 {
   unsigned int __reserved[4] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_13_92 {
   unsigned int __reserved[4] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_14_93 {
   unsigned int __reserved[4] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_icr1_94 {
   unsigned int vector : 8 ;
   unsigned int delivery_mode : 3 ;
   unsigned int destination_mode : 1 ;
   unsigned int delivery_status : 1 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int level : 1 ;
   unsigned int trigger : 1 ;
   unsigned int __reserved_2 : 2 ;
   unsigned int shorthand : 2 ;
   unsigned int __reserved_3 : 12 ;
   unsigned int __reserved_4[3] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
union __anonunion_dest_96 {
   unsigned int __reserved_1 : 24 ;
   unsigned int phys_dest : 4 ;
   unsigned int __reserved_2 : 4 ;
   unsigned int __reserved_3 : 24 ;
   unsigned int logical_dest : 8 ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_icr2_95 {
   union __anonunion_dest_96 dest ;
   unsigned int __reserved_4[3] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_lvt_timer_97 {
   unsigned int vector : 8 ;
   unsigned int __reserved_1 : 4 ;
   unsigned int delivery_status : 1 ;
   unsigned int __reserved_2 : 3 ;
   unsigned int mask : 1 ;
   unsigned int timer_mode : 1 ;
   unsigned int __reserved_3 : 14 ;
   unsigned int __reserved_4[3] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_lvt_thermal_98 {
   unsigned int vector : 8 ;
   unsigned int delivery_mode : 3 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int delivery_status : 1 ;
   unsigned int __reserved_2 : 3 ;
   unsigned int mask : 1 ;
   unsigned int __reserved_3 : 15 ;
   unsigned int __reserved_4[3] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_lvt_pc_99 {
   unsigned int vector : 8 ;
   unsigned int delivery_mode : 3 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int delivery_status : 1 ;
   unsigned int __reserved_2 : 3 ;
   unsigned int mask : 1 ;
   unsigned int __reserved_3 : 15 ;
   unsigned int __reserved_4[3] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_lvt_lint0_100 {
   unsigned int vector : 8 ;
   unsigned int delivery_mode : 3 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int delivery_status : 1 ;
   unsigned int polarity : 1 ;
   unsigned int remote_irr : 1 ;
   unsigned int trigger : 1 ;
   unsigned int mask : 1 ;
   unsigned int __reserved_2 : 15 ;
   unsigned int __reserved_3[3] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_lvt_lint1_101 {
   unsigned int vector : 8 ;
   unsigned int delivery_mode : 3 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int delivery_status : 1 ;
   unsigned int polarity : 1 ;
   unsigned int remote_irr : 1 ;
   unsigned int trigger : 1 ;
   unsigned int mask : 1 ;
   unsigned int __reserved_2 : 15 ;
   unsigned int __reserved_3[3] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_lvt_error_102 {
   unsigned int vector : 8 ;
   unsigned int __reserved_1 : 4 ;
   unsigned int delivery_status : 1 ;
   unsigned int __reserved_2 : 3 ;
   unsigned int mask : 1 ;
   unsigned int __reserved_3 : 15 ;
   unsigned int __reserved_4[3] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_timer_icr_103 {
   unsigned int initial_count ;
   unsigned int __reserved_2[3] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_timer_ccr_104 {
   unsigned int curr_count ;
   unsigned int __reserved_2[3] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_16_105 {
   unsigned int __reserved[4] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_17_106 {
   unsigned int __reserved[4] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_18_107 {
   unsigned int __reserved[4] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_19_108 {
   unsigned int __reserved[4] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_timer_dcr_109 {
   unsigned int divisor : 4 ;
   unsigned int __reserved_1 : 28 ;
   unsigned int __reserved_2[3] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_20_110 {
   unsigned int __reserved[4] ;
};
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apicdef.h"
struct local_apic {
   struct __anonstruct___reserved_01_65 __reserved_01 ;
   struct __anonstruct___reserved_02_66 __reserved_02 ;
   struct __anonstruct_id_67 id ;
   struct __anonstruct_version_68  const  version ;
   struct __anonstruct___reserved_03_69 __reserved_03 ;
   struct __anonstruct___reserved_04_70 __reserved_04 ;
   struct __anonstruct___reserved_05_71 __reserved_05 ;
   struct __anonstruct___reserved_06_72 __reserved_06 ;
   struct __anonstruct_tpr_73 tpr ;
   struct __anonstruct_apr_74  const  apr ;
   struct __anonstruct_ppr_75  const  ppr ;
   struct __anonstruct_eoi_76 eoi ;
   struct __anonstruct___reserved_07_77 __reserved_07 ;
   struct __anonstruct_ldr_78 ldr ;
   struct __anonstruct_dfr_79 dfr ;
   struct __anonstruct_svr_80 svr ;
   struct __anonstruct_isr_81 isr[8] ;
   struct __anonstruct_tmr_82 tmr[8] ;
   struct __anonstruct_irr_83 irr[8] ;
   union __anonunion_esr_84 esr ;
   struct __anonstruct___reserved_08_87 __reserved_08 ;
   struct __anonstruct___reserved_09_88 __reserved_09 ;
   struct __anonstruct___reserved_10_89 __reserved_10 ;
   struct __anonstruct___reserved_11_90 __reserved_11 ;
   struct __anonstruct___reserved_12_91 __reserved_12 ;
   struct __anonstruct___reserved_13_92 __reserved_13 ;
   struct __anonstruct___reserved_14_93 __reserved_14 ;
   struct __anonstruct_icr1_94 icr1 ;
   struct __anonstruct_icr2_95 icr2 ;
   struct __anonstruct_lvt_timer_97 lvt_timer ;
   struct __anonstruct_lvt_thermal_98 lvt_thermal ;
   struct __anonstruct_lvt_pc_99 lvt_pc ;
   struct __anonstruct_lvt_lint0_100 lvt_lint0 ;
   struct __anonstruct_lvt_lint1_101 lvt_lint1 ;
   struct __anonstruct_lvt_error_102 lvt_error ;
   struct __anonstruct_timer_icr_103 timer_icr ;
   struct __anonstruct_timer_ccr_104  const  timer_ccr ;
   struct __anonstruct___reserved_16_105 __reserved_16 ;
   struct __anonstruct___reserved_17_106 __reserved_17 ;
   struct __anonstruct___reserved_18_107 __reserved_18 ;
   struct __anonstruct___reserved_19_108 __reserved_19 ;
   struct __anonstruct_timer_dcr_109 timer_dcr ;
   struct __anonstruct___reserved_20_110 __reserved_20 ;
} __attribute__((__packed__)) ;
#line 434
enum ioapic_irq_destination_types {
    dest_Fixed = 0,
    dest_LowestPrio = 1,
    dest_SMI = 2,
    dest__reserved_1 = 3,
    dest_NMI = 4,
    dest_INIT = 5,
    dest__reserved_2 = 6,
    dest_ExtINT = 7
} ;
#line 92 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/mpspec.h"
struct physid_mask {
   unsigned long mask[((32768UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
};
#line 96 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/mpspec.h"
typedef struct physid_mask physid_mask_t;
#line 37 "../../../analyzer/../bench/linux-headers/include/linux/pm.h"
struct device;
#line 54
struct device;
#line 62 "../../../analyzer/../bench/linux-headers/include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 62 "../../../analyzer/../bench/linux-headers/include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 295 "../../../analyzer/../bench/linux-headers/include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device *dev ) ;
   void (*complete)(struct device *dev ) ;
   int (*suspend)(struct device *dev ) ;
   int (*resume)(struct device *dev ) ;
   int (*freeze)(struct device *dev ) ;
   int (*thaw)(struct device *dev ) ;
   int (*poweroff)(struct device *dev ) ;
   int (*restore)(struct device *dev ) ;
   int (*suspend_late)(struct device *dev ) ;
   int (*resume_early)(struct device *dev ) ;
   int (*freeze_late)(struct device *dev ) ;
   int (*thaw_early)(struct device *dev ) ;
   int (*poweroff_late)(struct device *dev ) ;
   int (*restore_early)(struct device *dev ) ;
   int (*suspend_noirq)(struct device *dev ) ;
   int (*resume_noirq)(struct device *dev ) ;
   int (*freeze_noirq)(struct device *dev ) ;
   int (*thaw_noirq)(struct device *dev ) ;
   int (*poweroff_noirq)(struct device *dev ) ;
   int (*restore_noirq)(struct device *dev ) ;
   int (*runtime_suspend)(struct device *dev ) ;
   int (*runtime_resume)(struct device *dev ) ;
   int (*runtime_idle)(struct device *dev ) ;
};
#line 510
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 532
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 540
struct wakeup_source;
#line 540
struct wakeup_source;
#line 542 "../../../analyzer/../bench/linux-headers/include/linux/pm.h"
struct pm_domain_data {
   struct list_head list_node ;
   struct device *dev ;
};
#line 547 "../../../analyzer/../bench/linux-headers/include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
};
#line 558
struct dev_pm_qos;
#line 558 "../../../analyzer/../bench/linux-headers/include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int can_wakeup : 1 ;
   unsigned int async_suspend : 1 ;
   bool is_prepared : 1 ;
   bool is_suspended : 1 ;
   bool is_noirq_suspended : 1 ;
   bool is_late_suspended : 1 ;
   bool ignore_children : 1 ;
   bool early_init : 1 ;
   bool direct_complete : 1 ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path : 1 ;
   bool syscore : 1 ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32  ) ;
   struct dev_pm_qos *qos ;
};
#line 620 "../../../analyzer/../bench/linux-headers/include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
};
#line 766
enum dpm_order {
    DPM_ORDER_NONE = 0,
    DPM_ORDER_DEV_AFTER_PARENT = 1,
    DPM_ORDER_PARENT_BEFORE_DEV = 2,
    DPM_ORDER_DEV_LAST = 3
} ;
#line 134 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/topology.h"
struct pci_bus;
#line 134
struct pci_bus;
#line 11 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_111 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
};
#line 11 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_111 mm_context_t;
#line 71 "../../../analyzer/../bench/linux-headers/include/asm-generic/iomap.h"
struct pci_dev;
#line 14 "../../../analyzer/../bench/linux-headers/include/asm-generic/pci_iomap.h"
struct pci_dev;
#line 35 "../../../analyzer/../bench/linux-headers/include/linux/rbtree.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
} __attribute__((__aligned__(sizeof(long )))) ;
#line 42 "../../../analyzer/../bench/linux-headers/include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 10 "../../../analyzer/../bench/linux-headers/include/linux/vmalloc.h"
struct vm_area_struct;
#line 10
struct vm_area_struct;
#line 29 "../../../analyzer/../bench/linux-headers/include/linux/vmalloc.h"
struct vm_struct {
   struct vm_struct *next ;
   void *addr ;
   unsigned long size ;
   unsigned long flags ;
   struct page **pages ;
   unsigned int nr_pages ;
   phys_addr_t phys_addr ;
   void const   *caller ;
};
#line 40 "../../../analyzer/../bench/linux-headers/include/linux/vmalloc.h"
struct vmap_area {
   unsigned long va_start ;
   unsigned long va_end ;
   unsigned long flags ;
   struct rb_node rb_node ;
   struct list_head list ;
   struct list_head purge_list ;
   struct vm_struct *vm ;
   struct callback_head callback_head ;
};
#line 177 "../../../analyzer/../bench/linux-headers/include/linux/vmalloc.h"
struct vmalloc_info {
   unsigned long used ;
   unsigned long largest_chunk ;
};
#line 8 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/realmode.h"
struct real_mode_header {
   u32 text_start ;
   u32 ro_end ;
   u32 trampoline_start ;
   u32 trampoline_status ;
   u32 trampoline_header ;
   u32 trampoline_pgd ;
   u32 wakeup_start ;
   u32 wakeup_header ;
   u32 machine_real_restart_asm ;
   u32 machine_real_restart_seg ;
};
#line 31 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/realmode.h"
struct trampoline_header {
   u64 start ;
   u64 efer ;
   u32 cr4 ;
};
#line 22 "../../../analyzer/../bench/linux-headers/include/linux/clocksource.h"
typedef u64 cycle_t;
#line 23
struct clocksource;
#line 23
struct clocksource;
#line 24
struct module;
#line 11 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/clocksource.h"
struct arch_clocksource_data {
   int vclock_mode ;
};
#line 44 "../../../analyzer/../bench/linux-headers/include/linux/clocksource.h"
struct cyclecounter {
   cycle_t (*read)(struct cyclecounter  const  *cc ) ;
   cycle_t mask ;
   u32 mult ;
   u32 shift ;
};
#line 67 "../../../analyzer/../bench/linux-headers/include/linux/clocksource.h"
struct timecounter {
   struct cyclecounter  const  *cc ;
   cycle_t cycle_last ;
   u64 nsec ;
};
#line 167 "../../../analyzer/../bench/linux-headers/include/linux/clocksource.h"
struct clocksource {
   cycle_t (*read)(struct clocksource *cs ) ;
   cycle_t mask ;
   u32 mult ;
   u32 shift ;
   u64 max_idle_ns ;
   u32 maxadj ;
   struct arch_clocksource_data archdata ;
   char const   *name ;
   struct list_head list ;
   int rating ;
   int (*enable)(struct clocksource *cs ) ;
   void (*disable)(struct clocksource *cs ) ;
   unsigned long flags ;
   void (*suspend)(struct clocksource *cs ) ;
   void (*resume)(struct clocksource *cs ) ;
   struct list_head wd_list ;
   cycle_t cs_last ;
   cycle_t wd_last ;
   struct module *owner ;
} __attribute__((__aligned__((1) <<  (6) ))) ;
#line 25 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pvclock-abi.h"
struct pvclock_vcpu_time_info {
   u32 version ;
   u32 pad0 ;
   u64 tsc_timestamp ;
   u64 system_time ;
   u32 tsc_to_system_mul ;
   s8 tsc_shift ;
   u8 flags ;
   u8 pad[2] ;
} __attribute__((__packed__)) ;
#line 36 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pvclock-abi.h"
struct pvclock_wall_clock {
   u32 version ;
   u32 sec ;
   u32 nsec ;
} __attribute__((__packed__)) ;
#line 96 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pvclock.h"
struct pvclock_vsyscall_time_info {
   struct pvclock_vcpu_time_info pvti ;
} __attribute__((__aligned__((1) <<  (6) ))) ;
#line 4 "../../../analyzer/../bench/linux-headers/arch/x86/include/uapi/asm/vsyscall.h"
enum vsyscall_num {
    __NR_vgettimeofday = 0,
    __NR_vtime = 1,
    __NR_vgetcpu = 2
} ;
#line 68 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/fixmap.h"
enum fixed_addresses {
    VSYSCALL_PAGE = 511,
    FIX_DBGP_BASE = 512,
    FIX_EARLYCON_MEM_BASE = 513,
    FIX_OHCI1394_BASE = 514,
    FIX_APIC_BASE = 515,
    FIX_IO_APIC_BASE_0 = 516,
    FIX_IO_APIC_BASE_END = 643,
    FIX_RO_IDT = 644,
    FIX_TEXT_POKE1 = 645,
    FIX_TEXT_POKE0 = 646,
    __end_of_permanent_fixed_addresses = 647,
    FIX_BTMAP_END = 1024,
    FIX_BTMAP_BEGIN = 1535,
    __end_of_fixed_addresses = 1536
} ;
#line 7 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/idle.h"
struct notifier_block;
#line 278 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apic.h"
struct apic {
   char *name ;
   int (*probe)(void) ;
   int (*acpi_madt_oem_check)(char *oem_id , char *oem_table_id ) ;
   int (*apic_id_valid)(int apicid ) ;
   int (*apic_id_registered)(void) ;
   u32 irq_delivery_mode ;
   u32 irq_dest_mode ;
   struct cpumask  const  *(*target_cpus)(void) ;
   int disable_esr ;
   int dest_logical ;
   unsigned long (*check_apicid_used)(physid_mask_t *map , int apicid ) ;
   void (*vector_allocation_domain)(int cpu , struct cpumask *retmask , struct cpumask  const  *mask ) ;
   void (*init_apic_ldr)(void) ;
   void (*ioapic_phys_id_map)(physid_mask_t *phys_map , physid_mask_t *retmap ) ;
   void (*setup_apic_routing)(void) ;
   int (*cpu_present_to_apicid)(int mps_cpu ) ;
   void (*apicid_to_cpu_present)(int phys_apicid , physid_mask_t *retmap ) ;
   int (*check_phys_apicid_present)(int phys_apicid ) ;
   int (*phys_pkg_id)(int cpuid_apic , int index_msb ) ;
   unsigned int (*get_apic_id)(unsigned long x ) ;
   unsigned long (*set_apic_id)(unsigned int id ) ;
   unsigned long apic_id_mask ;
   int (*cpu_mask_to_apicid_and)(struct cpumask  const  *cpumask , struct cpumask  const  *andmask ,
                                 unsigned int *apicid ) ;
   void (*send_IPI_mask)(struct cpumask  const  *mask , int vector ) ;
   void (*send_IPI_mask_allbutself)(struct cpumask  const  *mask , int vector ) ;
   void (*send_IPI_allbutself)(int vector ) ;
   void (*send_IPI_all)(int vector ) ;
   void (*send_IPI_self)(int vector ) ;
   int (*wakeup_secondary_cpu)(int apicid , unsigned long start_eip ) ;
   bool wait_for_init_deassert ;
   void (*inquire_remote_apic)(int apicid ) ;
   u32 (*read)(u32 reg ) ;
   void (*write)(u32 reg , u32 v ) ;
   void (*eoi_write)(u32 reg , u32 v ) ;
   u64 (*icr_read)(void) ;
   void (*icr_write)(u32 low , u32 high ) ;
   void (*wait_icr_idle)(void) ;
   u32 (*safe_wait_icr_idle)(void) ;
};
#line 27 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io_apic.h"
struct __anonstruct_bits_112 {
   u32 __reserved_2 : 14 ;
   u32 LTS : 1 ;
   u32 delivery_type : 1 ;
   u32 __reserved_1 : 8 ;
   u32 ID : 8 ;
} __attribute__((__packed__)) ;
#line 27 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io_apic.h"
union IO_APIC_reg_00 {
   u32 raw ;
   struct __anonstruct_bits_112 bits ;
};
#line 38 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io_apic.h"
struct __anonstruct_bits_113 {
   u32 version : 8 ;
   u32 __reserved_2 : 7 ;
   u32 PRQ : 1 ;
   u32 entries : 8 ;
   u32 __reserved_1 : 8 ;
} __attribute__((__packed__)) ;
#line 38 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io_apic.h"
union IO_APIC_reg_01 {
   u32 raw ;
   struct __anonstruct_bits_113 bits ;
};
#line 49 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io_apic.h"
struct __anonstruct_bits_114 {
   u32 __reserved_2 : 24 ;
   u32 arbitration : 4 ;
   u32 __reserved_1 : 4 ;
} __attribute__((__packed__)) ;
#line 49 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io_apic.h"
union IO_APIC_reg_02 {
   u32 raw ;
   struct __anonstruct_bits_114 bits ;
};
#line 58 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io_apic.h"
struct __anonstruct_bits_115 {
   u32 boot_DT : 1 ;
   u32 __reserved_1 : 31 ;
} __attribute__((__packed__)) ;
#line 58 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io_apic.h"
union IO_APIC_reg_03 {
   u32 raw ;
   struct __anonstruct_bits_115 bits ;
};
#line 66 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io_apic.h"
struct IO_APIC_route_entry {
   __u32 vector : 8 ;
   __u32 delivery_mode : 3 ;
   __u32 dest_mode : 1 ;
   __u32 delivery_status : 1 ;
   __u32 polarity : 1 ;
   __u32 irr : 1 ;
   __u32 trigger : 1 ;
   __u32 mask : 1 ;
   __u32 __reserved_2 : 15 ;
   __u32 __reserved_3 : 24 ;
   __u32 dest : 8 ;
} __attribute__((__packed__)) ;
#line 84 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io_apic.h"
struct IR_IO_APIC_route_entry {
   __u64 vector : 8 ;
   __u64 zero : 3 ;
   __u64 index2 : 1 ;
   __u64 delivery_status : 1 ;
   __u64 polarity : 1 ;
   __u64 irr : 1 ;
   __u64 trigger : 1 ;
   __u64 mask : 1 ;
   __u64 reserved : 31 ;
   __u64 format : 1 ;
   __u64 index : 15 ;
} __attribute__((__packed__)) ;
#line 113
struct mp_ioapic_gsi;
#line 142
struct io_apic_irq_attr;
#line 143
struct irq_cfg;
#line 143
struct irq_cfg;
#line 163
enum ioapic_domain_type {
    IOAPIC_DOMAIN_INVALID = 0,
    IOAPIC_DOMAIN_LEGACY = 1,
    IOAPIC_DOMAIN_STRICT = 2,
    IOAPIC_DOMAIN_DYNAMIC = 3
} ;
#line 170
struct device_node;
#line 170
struct device_node;
#line 171
struct irq_domain;
#line 171
struct irq_domain;
#line 172
struct irq_domain_ops;
#line 172
struct irq_domain_ops;
#line 174 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io_apic.h"
struct ioapic_domain_cfg {
   enum ioapic_domain_type type ;
   struct irq_domain_ops  const  *ops ;
   struct device_node *dev ;
};
#line 180 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io_apic.h"
struct mp_ioapic_gsi {
   u32 gsi_base ;
   u32 gsi_end ;
};
#line 64 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/smp.h"
struct task_struct;
#line 66 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/smp.h"
struct smp_ops {
   void (*smp_prepare_boot_cpu)(void) ;
   void (*smp_prepare_cpus)(unsigned int max_cpus ) ;
   void (*smp_cpus_done)(unsigned int max_cpus ) ;
   void (*stop_other_cpus)(int wait ) ;
   void (*smp_send_reschedule)(int cpu ) ;
   int (*cpu_up)(unsigned int cpu , struct task_struct *tidle ) ;
   int (*cpu_disable)(void) ;
   void (*cpu_die)(unsigned int cpu ) ;
   void (*play_dead)(void) ;
   void (*send_call_func_ipi)(struct cpumask  const  *mask ) ;
   void (*send_call_func_single_ipi)(int cpu ) ;
};
#line 1116 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
struct page;
#line 1117
struct page_cgroup;
#line 1117
struct page_cgroup;
#line 1118 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
struct mem_section {
   unsigned long section_mem_map ;
   unsigned long *pageblock_flags ;
};
#line 61 "../../../analyzer/../bench/linux-headers/include/linux/llist.h"
struct llist_node;
#line 61 "../../../analyzer/../bench/linux-headers/include/linux/llist.h"
struct llist_head {
   struct llist_node *first ;
};
#line 65 "../../../analyzer/../bench/linux-headers/include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 16 "../../../analyzer/../bench/linux-headers/include/linux/smp.h"
typedef void (*smp_call_func_t)(void *info );
#line 17 "../../../analyzer/../bench/linux-headers/include/linux/smp.h"
struct call_single_data {
   struct llist_node llist ;
   void (*func)(void *info ) ;
   void *info ;
   u16 flags ;
};
#line 59 "../../../analyzer/../bench/linux-headers/include/linux/percpu.h"
struct pcpu_group_info {
   int nr_units ;
   unsigned long base_offset ;
   unsigned int *cpu_map ;
};
#line 66 "../../../analyzer/../bench/linux-headers/include/linux/percpu.h"
struct pcpu_alloc_info {
   size_t static_size ;
   size_t reserved_size ;
   size_t dyn_size ;
   size_t unit_size ;
   size_t atom_size ;
   size_t alloc_size ;
   size_t __ai_size ;
   int nr_groups ;
   struct pcpu_group_info groups[] ;
};
#line 78
enum pcpu_fc {
    PCPU_FC_AUTO = 0,
    PCPU_FC_EMBED = 1,
    PCPU_FC_PAGE = 2,
    PCPU_FC_NR = 3
} ;
#line 89 "../../../analyzer/../bench/linux-headers/include/linux/percpu.h"
typedef void *(*pcpu_fc_alloc_fn_t)(unsigned int cpu , size_t size , size_t align );
#line 91 "../../../analyzer/../bench/linux-headers/include/linux/percpu.h"
typedef void (*pcpu_fc_free_fn_t)(void *ptr , size_t size );
#line 92 "../../../analyzer/../bench/linux-headers/include/linux/percpu.h"
typedef void (*pcpu_fc_populate_pte_fn_t)(unsigned long addr );
#line 93 "../../../analyzer/../bench/linux-headers/include/linux/percpu.h"
typedef int pcpu_fc_cpu_distance_fn_t(unsigned int from , unsigned int to );
#line 91 "../../../analyzer/../bench/linux-headers/include/linux/topology.h"
typedef int pto_T_____2;
#line 91 "../../../analyzer/../bench/linux-headers/include/linux/topology.h"
typedef int pto_T_____3;
#line 91 "../../../analyzer/../bench/linux-headers/include/linux/topology.h"
typedef int pto_T_____4;
#line 91 "../../../analyzer/../bench/linux-headers/include/linux/topology.h"
typedef int pto_T_____5;
#line 10 "../../../analyzer/../bench/linux-headers/include/linux/gfp.h"
struct vm_area_struct;
#line 29 "../../../analyzer/../bench/linux-headers/include/uapi/linux/sysctl.h"
struct completion;
#line 36 "../../../analyzer/../bench/linux-headers/include/uapi/linux/sysctl.h"
struct __sysctl_args {
   int *name ;
   int nlen ;
   void *oldval ;
   size_t *oldlenp ;
   void *newval ;
   size_t newlen ;
   unsigned long __unused[4] ;
};
#line 50
enum __anonenum_116 {
    CTL_KERN = 1,
    CTL_VM = 2,
    CTL_NET = 3,
    CTL_PROC = 4,
    CTL_FS = 5,
    CTL_DEBUG = 6,
    CTL_DEV = 7,
    CTL_BUS = 8,
    CTL_ABI = 9,
    CTL_CPU = 10,
    CTL_ARLAN = 254,
    CTL_S390DBF = 5677,
    CTL_SUNRPC = 7249,
    CTL_PM = 9899,
    CTL_FRV = 9898
} ;
#line 70
enum __anonenum_117 {
    CTL_BUS_ISA = 1
} ;
#line 76
enum __anonenum_118 {
    INOTIFY_MAX_USER_INSTANCES = 1,
    INOTIFY_MAX_USER_WATCHES = 2,
    INOTIFY_MAX_QUEUED_EVENTS = 3
} ;
#line 84
enum __anonenum_119 {
    KERN_OSTYPE = 1,
    KERN_OSRELEASE = 2,
    KERN_OSREV = 3,
    KERN_VERSION = 4,
    KERN_SECUREMASK = 5,
    KERN_PROF = 6,
    KERN_NODENAME = 7,
    KERN_DOMAINNAME = 8,
    KERN_PANIC = 15,
    KERN_REALROOTDEV = 16,
    KERN_SPARC_REBOOT = 21,
    KERN_CTLALTDEL = 22,
    KERN_PRINTK = 23,
    KERN_NAMETRANS = 24,
    KERN_PPC_HTABRECLAIM = 25,
    KERN_PPC_ZEROPAGED = 26,
    KERN_PPC_POWERSAVE_NAP = 27,
    KERN_MODPROBE = 28,
    KERN_SG_BIG_BUFF = 29,
    KERN_ACCT = 30,
    KERN_PPC_L2CR = 31,
    KERN_RTSIGNR = 32,
    KERN_RTSIGMAX = 33,
    KERN_SHMMAX = 34,
    KERN_MSGMAX = 35,
    KERN_MSGMNB = 36,
    KERN_MSGPOOL = 37,
    KERN_SYSRQ = 38,
    KERN_MAX_THREADS = 39,
    KERN_RANDOM = 40,
    KERN_SHMALL = 41,
    KERN_MSGMNI = 42,
    KERN_SEM = 43,
    KERN_SPARC_STOP_A = 44,
    KERN_SHMMNI = 45,
    KERN_OVERFLOWUID = 46,
    KERN_OVERFLOWGID = 47,
    KERN_SHMPATH = 48,
    KERN_HOTPLUG = 49,
    KERN_IEEE_EMULATION_WARNINGS = 50,
    KERN_S390_USER_DEBUG_LOGGING = 51,
    KERN_CORE_USES_PID = 52,
    KERN_TAINTED = 53,
    KERN_CADPID = 54,
    KERN_PIDMAX = 55,
    KERN_CORE_PATTERN = 56,
    KERN_PANIC_ON_OOPS = 57,
    KERN_HPPA_PWRSW = 58,
    KERN_HPPA_UNALIGNED = 59,
    KERN_PRINTK_RATELIMIT = 60,
    KERN_PRINTK_RATELIMIT_BURST = 61,
    KERN_PTY = 62,
    KERN_NGROUPS_MAX = 63,
    KERN_SPARC_SCONS_PWROFF = 64,
    KERN_HZ_TIMER = 65,
    KERN_UNKNOWN_NMI_PANIC = 66,
    KERN_BOOTLOADER_TYPE = 67,
    KERN_RANDOMIZE = 68,
    KERN_SETUID_DUMPABLE = 69,
    KERN_SPIN_RETRY = 70,
    KERN_ACPI_VIDEO_FLAGS = 71,
    KERN_IA64_UNALIGNED = 72,
    KERN_COMPAT_LOG = 73,
    KERN_MAX_LOCK_DEPTH = 74,
    KERN_NMI_WATCHDOG = 75,
    KERN_PANIC_ON_NMI = 76
} ;
#line 161
enum __anonenum_120 {
    VM_UNUSED1 = 1,
    VM_UNUSED2 = 2,
    VM_UNUSED3 = 3,
    VM_UNUSED4 = 4,
    VM_OVERCOMMIT_MEMORY = 5,
    VM_UNUSED5 = 6,
    VM_UNUSED7 = 7,
    VM_UNUSED8 = 8,
    VM_UNUSED9 = 9,
    VM_PAGE_CLUSTER = 10,
    VM_DIRTY_BACKGROUND = 11,
    VM_DIRTY_RATIO = 12,
    VM_DIRTY_WB_CS = 13,
    VM_DIRTY_EXPIRE_CS = 14,
    VM_NR_PDFLUSH_THREADS = 15,
    VM_OVERCOMMIT_RATIO = 16,
    VM_PAGEBUF = 17,
    VM_HUGETLB_PAGES = 18,
    VM_SWAPPINESS = 19,
    VM_LOWMEM_RESERVE_RATIO = 20,
    VM_MIN_FREE_KBYTES = 21,
    VM_MAX_MAP_COUNT = 22,
    VM_LAPTOP_MODE = 23,
    VM_BLOCK_DUMP = 24,
    VM_HUGETLB_GROUP = 25,
    VM_VFS_CACHE_PRESSURE = 26,
    VM_LEGACY_VA_LAYOUT = 27,
    VM_SWAP_TOKEN_TIMEOUT = 28,
    VM_DROP_PAGECACHE = 29,
    VM_PERCPU_PAGELIST_FRACTION = 30,
    VM_ZONE_RECLAIM_MODE = 31,
    VM_MIN_UNMAPPED = 32,
    VM_PANIC_ON_OOM = 33,
    VM_VDSO_ENABLED = 34,
    VM_MIN_SLAB = 35
} ;
#line 202
enum __anonenum_121 {
    NET_CORE = 1,
    NET_ETHER = 2,
    NET_802 = 3,
    NET_UNIX = 4,
    NET_IPV4 = 5,
    NET_IPX = 6,
    NET_ATALK = 7,
    NET_NETROM = 8,
    NET_AX25 = 9,
    NET_BRIDGE = 10,
    NET_ROSE = 11,
    NET_IPV6 = 12,
    NET_X25 = 13,
    NET_TR = 14,
    NET_DECNET = 15,
    NET_ECONET = 16,
    NET_SCTP = 17,
    NET_LLC = 18,
    NET_NETFILTER = 19,
    NET_DCCP = 20,
    NET_IRDA = 412
} ;
#line 228
enum __anonenum_122 {
    RANDOM_POOLSIZE = 1,
    RANDOM_ENTROPY_COUNT = 2,
    RANDOM_READ_THRESH = 3,
    RANDOM_WRITE_THRESH = 4,
    RANDOM_BOOT_ID = 5,
    RANDOM_UUID = 6
} ;
#line 239
enum __anonenum_123 {
    PTY_MAX = 1,
    PTY_NR = 2
} ;
#line 246
enum __anonenum_124 {
    BUS_ISA_MEM_BASE = 1,
    BUS_ISA_PORT_BASE = 2,
    BUS_ISA_PORT_SHIFT = 3
} ;
#line 254
enum __anonenum_125 {
    NET_CORE_WMEM_MAX = 1,
    NET_CORE_RMEM_MAX = 2,
    NET_CORE_WMEM_DEFAULT = 3,
    NET_CORE_RMEM_DEFAULT = 4,
    NET_CORE_MAX_BACKLOG = 6,
    NET_CORE_FASTROUTE = 7,
    NET_CORE_MSG_COST = 8,
    NET_CORE_MSG_BURST = 9,
    NET_CORE_OPTMEM_MAX = 10,
    NET_CORE_HOT_LIST_LENGTH = 11,
    NET_CORE_DIVERT_VERSION = 12,
    NET_CORE_NO_CONG_THRESH = 13,
    NET_CORE_NO_CONG = 14,
    NET_CORE_LO_CONG = 15,
    NET_CORE_MOD_CONG = 16,
    NET_CORE_DEV_WEIGHT = 17,
    NET_CORE_SOMAXCONN = 18,
    NET_CORE_BUDGET = 19,
    NET_CORE_AEVENT_ETIME = 20,
    NET_CORE_AEVENT_RSEQTH = 21,
    NET_CORE_WARNINGS = 22
} ;
#line 286
enum __anonenum_126 {
    NET_UNIX_DESTROY_DELAY = 1,
    NET_UNIX_DELETE_DELAY = 2,
    NET_UNIX_MAX_DGRAM_QLEN = 3
} ;
#line 294
enum __anonenum_127 {
    NET_NF_CONNTRACK_MAX = 1,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT = 2,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV = 3,
    NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED = 4,
    NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT = 5,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT = 6,
    NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK = 7,
    NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT = 8,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE = 9,
    NET_NF_CONNTRACK_UDP_TIMEOUT = 10,
    NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM = 11,
    NET_NF_CONNTRACK_ICMP_TIMEOUT = 12,
    NET_NF_CONNTRACK_GENERIC_TIMEOUT = 13,
    NET_NF_CONNTRACK_BUCKETS = 14,
    NET_NF_CONNTRACK_LOG_INVALID = 15,
    NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS = 16,
    NET_NF_CONNTRACK_TCP_LOOSE = 17,
    NET_NF_CONNTRACK_TCP_BE_LIBERAL = 18,
    NET_NF_CONNTRACK_TCP_MAX_RETRANS = 19,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED = 20,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT = 21,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED = 22,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED = 23,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT = 24,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD = 25,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT = 26,
    NET_NF_CONNTRACK_COUNT = 27,
    NET_NF_CONNTRACK_ICMPV6_TIMEOUT = 28,
    NET_NF_CONNTRACK_FRAG6_TIMEOUT = 29,
    NET_NF_CONNTRACK_FRAG6_LOW_THRESH = 30,
    NET_NF_CONNTRACK_FRAG6_HIGH_THRESH = 31,
    NET_NF_CONNTRACK_CHECKSUM = 32
} ;
#line 331
enum __anonenum_128 {
    NET_IPV4_FORWARD = 8,
    NET_IPV4_DYNADDR = 9,
    NET_IPV4_CONF = 16,
    NET_IPV4_NEIGH = 17,
    NET_IPV4_ROUTE = 18,
    NET_IPV4_FIB_HASH = 19,
    NET_IPV4_NETFILTER = 20,
    NET_IPV4_TCP_TIMESTAMPS = 33,
    NET_IPV4_TCP_WINDOW_SCALING = 34,
    NET_IPV4_TCP_SACK = 35,
    NET_IPV4_TCP_RETRANS_COLLAPSE = 36,
    NET_IPV4_DEFAULT_TTL = 37,
    NET_IPV4_AUTOCONFIG = 38,
    NET_IPV4_NO_PMTU_DISC = 39,
    NET_IPV4_TCP_SYN_RETRIES = 40,
    NET_IPV4_IPFRAG_HIGH_THRESH = 41,
    NET_IPV4_IPFRAG_LOW_THRESH = 42,
    NET_IPV4_IPFRAG_TIME = 43,
    NET_IPV4_TCP_MAX_KA_PROBES = 44,
    NET_IPV4_TCP_KEEPALIVE_TIME = 45,
    NET_IPV4_TCP_KEEPALIVE_PROBES = 46,
    NET_IPV4_TCP_RETRIES1 = 47,
    NET_IPV4_TCP_RETRIES2 = 48,
    NET_IPV4_TCP_FIN_TIMEOUT = 49,
    NET_IPV4_IP_MASQ_DEBUG = 50,
    NET_TCP_SYNCOOKIES = 51,
    NET_TCP_STDURG = 52,
    NET_TCP_RFC1337 = 53,
    NET_TCP_SYN_TAILDROP = 54,
    NET_TCP_MAX_SYN_BACKLOG = 55,
    NET_IPV4_LOCAL_PORT_RANGE = 56,
    NET_IPV4_ICMP_ECHO_IGNORE_ALL = 57,
    NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS = 58,
    NET_IPV4_ICMP_SOURCEQUENCH_RATE = 59,
    NET_IPV4_ICMP_DESTUNREACH_RATE = 60,
    NET_IPV4_ICMP_TIMEEXCEED_RATE = 61,
    NET_IPV4_ICMP_PARAMPROB_RATE = 62,
    NET_IPV4_ICMP_ECHOREPLY_RATE = 63,
    NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES = 64,
    NET_IPV4_IGMP_MAX_MEMBERSHIPS = 65,
    NET_TCP_TW_RECYCLE = 66,
    NET_IPV4_ALWAYS_DEFRAG = 67,
    NET_IPV4_TCP_KEEPALIVE_INTVL = 68,
    NET_IPV4_INET_PEER_THRESHOLD = 69,
    NET_IPV4_INET_PEER_MINTTL = 70,
    NET_IPV4_INET_PEER_MAXTTL = 71,
    NET_IPV4_INET_PEER_GC_MINTIME = 72,
    NET_IPV4_INET_PEER_GC_MAXTIME = 73,
    NET_TCP_ORPHAN_RETRIES = 74,
    NET_TCP_ABORT_ON_OVERFLOW = 75,
    NET_TCP_SYNACK_RETRIES = 76,
    NET_TCP_MAX_ORPHANS = 77,
    NET_TCP_MAX_TW_BUCKETS = 78,
    NET_TCP_FACK = 79,
    NET_TCP_REORDERING = 80,
    NET_TCP_ECN = 81,
    NET_TCP_DSACK = 82,
    NET_TCP_MEM = 83,
    NET_TCP_WMEM = 84,
    NET_TCP_RMEM = 85,
    NET_TCP_APP_WIN = 86,
    NET_TCP_ADV_WIN_SCALE = 87,
    NET_IPV4_NONLOCAL_BIND = 88,
    NET_IPV4_ICMP_RATELIMIT = 89,
    NET_IPV4_ICMP_RATEMASK = 90,
    NET_TCP_TW_REUSE = 91,
    NET_TCP_FRTO = 92,
    NET_TCP_LOW_LATENCY = 93,
    NET_IPV4_IPFRAG_SECRET_INTERVAL = 94,
    NET_IPV4_IGMP_MAX_MSF = 96,
    NET_TCP_NO_METRICS_SAVE = 97,
    NET_TCP_DEFAULT_WIN_SCALE = 105,
    NET_TCP_MODERATE_RCVBUF = 106,
    NET_TCP_TSO_WIN_DIVISOR = 107,
    NET_TCP_BIC_BETA = 108,
    NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR = 109,
    NET_TCP_CONG_CONTROL = 110,
    NET_TCP_ABC = 111,
    NET_IPV4_IPFRAG_MAX_DIST = 112,
    NET_TCP_MTU_PROBING = 113,
    NET_TCP_BASE_MSS = 114,
    NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS = 115,
    NET_TCP_DMA_COPYBREAK = 116,
    NET_TCP_SLOW_START_AFTER_IDLE = 117,
    NET_CIPSOV4_CACHE_ENABLE = 118,
    NET_CIPSOV4_CACHE_BUCKET_SIZE = 119,
    NET_CIPSOV4_RBM_OPTFMT = 120,
    NET_CIPSOV4_RBM_STRICTVALID = 121,
    NET_TCP_AVAIL_CONG_CONTROL = 122,
    NET_TCP_ALLOWED_CONG_CONTROL = 123,
    NET_TCP_MAX_SSTHRESH = 124,
    NET_TCP_FRTO_RESPONSE = 125
} ;
#line 430
enum __anonenum_129 {
    NET_IPV4_ROUTE_FLUSH = 1,
    NET_IPV4_ROUTE_MIN_DELAY = 2,
    NET_IPV4_ROUTE_MAX_DELAY = 3,
    NET_IPV4_ROUTE_GC_THRESH = 4,
    NET_IPV4_ROUTE_MAX_SIZE = 5,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL = 6,
    NET_IPV4_ROUTE_GC_TIMEOUT = 7,
    NET_IPV4_ROUTE_GC_INTERVAL = 8,
    NET_IPV4_ROUTE_REDIRECT_LOAD = 9,
    NET_IPV4_ROUTE_REDIRECT_NUMBER = 10,
    NET_IPV4_ROUTE_REDIRECT_SILENCE = 11,
    NET_IPV4_ROUTE_ERROR_COST = 12,
    NET_IPV4_ROUTE_ERROR_BURST = 13,
    NET_IPV4_ROUTE_GC_ELASTICITY = 14,
    NET_IPV4_ROUTE_MTU_EXPIRES = 15,
    NET_IPV4_ROUTE_MIN_PMTU = 16,
    NET_IPV4_ROUTE_MIN_ADVMSS = 17,
    NET_IPV4_ROUTE_SECRET_INTERVAL = 18,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS = 19
} ;
#line 452
enum __anonenum_130 {
    NET_PROTO_CONF_ALL = -2,
    NET_PROTO_CONF_DEFAULT = -3
} ;
#line 460
enum __anonenum_131 {
    NET_IPV4_CONF_FORWARDING = 1,
    NET_IPV4_CONF_MC_FORWARDING = 2,
    NET_IPV4_CONF_PROXY_ARP = 3,
    NET_IPV4_CONF_ACCEPT_REDIRECTS = 4,
    NET_IPV4_CONF_SECURE_REDIRECTS = 5,
    NET_IPV4_CONF_SEND_REDIRECTS = 6,
    NET_IPV4_CONF_SHARED_MEDIA = 7,
    NET_IPV4_CONF_RP_FILTER = 8,
    NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE = 9,
    NET_IPV4_CONF_BOOTP_RELAY = 10,
    NET_IPV4_CONF_LOG_MARTIANS = 11,
    NET_IPV4_CONF_TAG = 12,
    NET_IPV4_CONF_ARPFILTER = 13,
    NET_IPV4_CONF_MEDIUM_ID = 14,
    NET_IPV4_CONF_NOXFRM = 15,
    NET_IPV4_CONF_NOPOLICY = 16,
    NET_IPV4_CONF_FORCE_IGMP_VERSION = 17,
    NET_IPV4_CONF_ARP_ANNOUNCE = 18,
    NET_IPV4_CONF_ARP_IGNORE = 19,
    NET_IPV4_CONF_PROMOTE_SECONDARIES = 20,
    NET_IPV4_CONF_ARP_ACCEPT = 21,
    NET_IPV4_CONF_ARP_NOTIFY = 22
} ;
#line 487
enum __anonenum_132 {
    NET_IPV4_NF_CONNTRACK_MAX = 1,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT = 2,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV = 3,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED = 4,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT = 5,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT = 6,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK = 7,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT = 8,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE = 9,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT = 10,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM = 11,
    NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT = 12,
    NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT = 13,
    NET_IPV4_NF_CONNTRACK_BUCKETS = 14,
    NET_IPV4_NF_CONNTRACK_LOG_INVALID = 15,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS = 16,
    NET_IPV4_NF_CONNTRACK_TCP_LOOSE = 17,
    NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL = 18,
    NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS = 19,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED = 20,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT = 21,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED = 22,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED = 23,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT = 24,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD = 25,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT = 26,
    NET_IPV4_NF_CONNTRACK_COUNT = 27,
    NET_IPV4_NF_CONNTRACK_CHECKSUM = 28
} ;
#line 520
enum __anonenum_133 {
    NET_IPV6_CONF = 16,
    NET_IPV6_NEIGH = 17,
    NET_IPV6_ROUTE = 18,
    NET_IPV6_ICMP = 19,
    NET_IPV6_BINDV6ONLY = 20,
    NET_IPV6_IP6FRAG_HIGH_THRESH = 21,
    NET_IPV6_IP6FRAG_LOW_THRESH = 22,
    NET_IPV6_IP6FRAG_TIME = 23,
    NET_IPV6_IP6FRAG_SECRET_INTERVAL = 24,
    NET_IPV6_MLD_MAX_MSF = 25
} ;
#line 533
enum __anonenum_134 {
    NET_IPV6_ROUTE_FLUSH = 1,
    NET_IPV6_ROUTE_GC_THRESH = 2,
    NET_IPV6_ROUTE_MAX_SIZE = 3,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL = 4,
    NET_IPV6_ROUTE_GC_TIMEOUT = 5,
    NET_IPV6_ROUTE_GC_INTERVAL = 6,
    NET_IPV6_ROUTE_GC_ELASTICITY = 7,
    NET_IPV6_ROUTE_MTU_EXPIRES = 8,
    NET_IPV6_ROUTE_MIN_ADVMSS = 9,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS = 10
} ;
#line 546
enum __anonenum_135 {
    NET_IPV6_FORWARDING = 1,
    NET_IPV6_HOP_LIMIT = 2,
    NET_IPV6_MTU = 3,
    NET_IPV6_ACCEPT_RA = 4,
    NET_IPV6_ACCEPT_REDIRECTS = 5,
    NET_IPV6_AUTOCONF = 6,
    NET_IPV6_DAD_TRANSMITS = 7,
    NET_IPV6_RTR_SOLICITS = 8,
    NET_IPV6_RTR_SOLICIT_INTERVAL = 9,
    NET_IPV6_RTR_SOLICIT_DELAY = 10,
    NET_IPV6_USE_TEMPADDR = 11,
    NET_IPV6_TEMP_VALID_LFT = 12,
    NET_IPV6_TEMP_PREFERED_LFT = 13,
    NET_IPV6_REGEN_MAX_RETRY = 14,
    NET_IPV6_MAX_DESYNC_FACTOR = 15,
    NET_IPV6_MAX_ADDRESSES = 16,
    NET_IPV6_FORCE_MLD_VERSION = 17,
    NET_IPV6_ACCEPT_RA_DEFRTR = 18,
    NET_IPV6_ACCEPT_RA_PINFO = 19,
    NET_IPV6_ACCEPT_RA_RTR_PREF = 20,
    NET_IPV6_RTR_PROBE_INTERVAL = 21,
    NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN = 22,
    NET_IPV6_PROXY_NDP = 23,
    NET_IPV6_ACCEPT_SOURCE_ROUTE = 25,
    NET_IPV6_ACCEPT_RA_FROM_LOCAL = 26,
    __NET_IPV6_MAX = 27
} ;
#line 576
enum __anonenum_136 {
    NET_IPV6_ICMP_RATELIMIT = 1
} ;
#line 581
enum __anonenum_137 {
    NET_NEIGH_MCAST_SOLICIT = 1,
    NET_NEIGH_UCAST_SOLICIT = 2,
    NET_NEIGH_APP_SOLICIT = 3,
    NET_NEIGH_RETRANS_TIME = 4,
    NET_NEIGH_REACHABLE_TIME = 5,
    NET_NEIGH_DELAY_PROBE_TIME = 6,
    NET_NEIGH_GC_STALE_TIME = 7,
    NET_NEIGH_UNRES_QLEN = 8,
    NET_NEIGH_PROXY_QLEN = 9,
    NET_NEIGH_ANYCAST_DELAY = 10,
    NET_NEIGH_PROXY_DELAY = 11,
    NET_NEIGH_LOCKTIME = 12,
    NET_NEIGH_GC_INTERVAL = 13,
    NET_NEIGH_GC_THRESH1 = 14,
    NET_NEIGH_GC_THRESH2 = 15,
    NET_NEIGH_GC_THRESH3 = 16,
    NET_NEIGH_RETRANS_TIME_MS = 17,
    NET_NEIGH_REACHABLE_TIME_MS = 18
} ;
#line 603
enum __anonenum_138 {
    NET_DCCP_DEFAULT = 1
} ;
#line 608
enum __anonenum_139 {
    NET_IPX_PPROP_BROADCASTING = 1,
    NET_IPX_FORWARDING = 2
} ;
#line 614
enum __anonenum_140 {
    NET_LLC2 = 1,
    NET_LLC_STATION = 2
} ;
#line 620
enum __anonenum_141 {
    NET_LLC2_TIMEOUT = 1
} ;
#line 625
enum __anonenum_142 {
    NET_LLC_STATION_ACK_TIMEOUT = 1
} ;
#line 630
enum __anonenum_143 {
    NET_LLC2_ACK_TIMEOUT = 1,
    NET_LLC2_P_TIMEOUT = 2,
    NET_LLC2_REJ_TIMEOUT = 3,
    NET_LLC2_BUSY_TIMEOUT = 4
} ;
#line 638
enum __anonenum_144 {
    NET_ATALK_AARP_EXPIRY_TIME = 1,
    NET_ATALK_AARP_TICK_TIME = 2,
    NET_ATALK_AARP_RETRANSMIT_LIMIT = 3,
    NET_ATALK_AARP_RESOLVE_TIME = 4
} ;
#line 647
enum __anonenum_145 {
    NET_NETROM_DEFAULT_PATH_QUALITY = 1,
    NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER = 2,
    NET_NETROM_NETWORK_TTL_INITIALISER = 3,
    NET_NETROM_TRANSPORT_TIMEOUT = 4,
    NET_NETROM_TRANSPORT_MAXIMUM_TRIES = 5,
    NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY = 6,
    NET_NETROM_TRANSPORT_BUSY_DELAY = 7,
    NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE = 8,
    NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT = 9,
    NET_NETROM_ROUTING_CONTROL = 10,
    NET_NETROM_LINK_FAILS_COUNT = 11,
    NET_NETROM_RESET = 12
} ;
#line 663
enum __anonenum_146 {
    NET_AX25_IP_DEFAULT_MODE = 1,
    NET_AX25_DEFAULT_MODE = 2,
    NET_AX25_BACKOFF_TYPE = 3,
    NET_AX25_CONNECT_MODE = 4,
    NET_AX25_STANDARD_WINDOW = 5,
    NET_AX25_EXTENDED_WINDOW = 6,
    NET_AX25_T1_TIMEOUT = 7,
    NET_AX25_T2_TIMEOUT = 8,
    NET_AX25_T3_TIMEOUT = 9,
    NET_AX25_IDLE_TIMEOUT = 10,
    NET_AX25_N2 = 11,
    NET_AX25_PACLEN = 12,
    NET_AX25_PROTOCOL = 13,
    NET_AX25_DAMA_SLAVE_TIMEOUT = 14
} ;
#line 681
enum __anonenum_147 {
    NET_ROSE_RESTART_REQUEST_TIMEOUT = 1,
    NET_ROSE_CALL_REQUEST_TIMEOUT = 2,
    NET_ROSE_RESET_REQUEST_TIMEOUT = 3,
    NET_ROSE_CLEAR_REQUEST_TIMEOUT = 4,
    NET_ROSE_ACK_HOLD_BACK_TIMEOUT = 5,
    NET_ROSE_ROUTING_CONTROL = 6,
    NET_ROSE_LINK_FAIL_TIMEOUT = 7,
    NET_ROSE_MAX_VCS = 8,
    NET_ROSE_WINDOW_SIZE = 9,
    NET_ROSE_NO_ACTIVITY_TIMEOUT = 10
} ;
#line 695
enum __anonenum_148 {
    NET_X25_RESTART_REQUEST_TIMEOUT = 1,
    NET_X25_CALL_REQUEST_TIMEOUT = 2,
    NET_X25_RESET_REQUEST_TIMEOUT = 3,
    NET_X25_CLEAR_REQUEST_TIMEOUT = 4,
    NET_X25_ACK_HOLD_BACK_TIMEOUT = 5,
    NET_X25_FORWARD = 6
} ;
#line 705
enum __anonenum_149 {
    NET_TR_RIF_TIMEOUT = 1
} ;
#line 711
enum __anonenum_150 {
    NET_DECNET_NODE_TYPE = 1,
    NET_DECNET_NODE_ADDRESS = 2,
    NET_DECNET_NODE_NAME = 3,
    NET_DECNET_DEFAULT_DEVICE = 4,
    NET_DECNET_TIME_WAIT = 5,
    NET_DECNET_DN_COUNT = 6,
    NET_DECNET_DI_COUNT = 7,
    NET_DECNET_DR_COUNT = 8,
    NET_DECNET_DST_GC_INTERVAL = 9,
    NET_DECNET_CONF = 10,
    NET_DECNET_NO_FC_MAX_CWND = 11,
    NET_DECNET_MEM = 12,
    NET_DECNET_RMEM = 13,
    NET_DECNET_WMEM = 14,
    NET_DECNET_DEBUG_LEVEL = 255
} ;
#line 730
enum __anonenum_151 {
    NET_DECNET_CONF_LOOPBACK = -2,
    NET_DECNET_CONF_DDCMP = -3,
    NET_DECNET_CONF_PPP = -4,
    NET_DECNET_CONF_X25 = -5,
    NET_DECNET_CONF_GRE = -6,
    NET_DECNET_CONF_ETHER = -7
} ;
#line 742
enum __anonenum_152 {
    NET_DECNET_CONF_DEV_PRIORITY = 1,
    NET_DECNET_CONF_DEV_T1 = 2,
    NET_DECNET_CONF_DEV_T2 = 3,
    NET_DECNET_CONF_DEV_T3 = 4,
    NET_DECNET_CONF_DEV_FORWARDING = 5,
    NET_DECNET_CONF_DEV_BLKSIZE = 6,
    NET_DECNET_CONF_DEV_STATE = 7
} ;
#line 753
enum __anonenum_153 {
    NET_SCTP_RTO_INITIAL = 1,
    NET_SCTP_RTO_MIN = 2,
    NET_SCTP_RTO_MAX = 3,
    NET_SCTP_RTO_ALPHA = 4,
    NET_SCTP_RTO_BETA = 5,
    NET_SCTP_VALID_COOKIE_LIFE = 6,
    NET_SCTP_ASSOCIATION_MAX_RETRANS = 7,
    NET_SCTP_PATH_MAX_RETRANS = 8,
    NET_SCTP_MAX_INIT_RETRANSMITS = 9,
    NET_SCTP_HB_INTERVAL = 10,
    NET_SCTP_PRESERVE_ENABLE = 11,
    NET_SCTP_MAX_BURST = 12,
    NET_SCTP_ADDIP_ENABLE = 13,
    NET_SCTP_PRSCTP_ENABLE = 14,
    NET_SCTP_SNDBUF_POLICY = 15,
    NET_SCTP_SACK_TIMEOUT = 16,
    NET_SCTP_RCVBUF_POLICY = 17
} ;
#line 774
enum __anonenum_154 {
    NET_BRIDGE_NF_CALL_ARPTABLES = 1,
    NET_BRIDGE_NF_CALL_IPTABLES = 2,
    NET_BRIDGE_NF_CALL_IP6TABLES = 3,
    NET_BRIDGE_NF_FILTER_VLAN_TAGGED = 4,
    NET_BRIDGE_NF_FILTER_PPPOE_TAGGED = 5
} ;
#line 783
enum __anonenum_155 {
    NET_IRDA_DISCOVERY = 1,
    NET_IRDA_DEVNAME = 2,
    NET_IRDA_DEBUG = 3,
    NET_IRDA_FAST_POLL = 4,
    NET_IRDA_DISCOVERY_SLOTS = 5,
    NET_IRDA_DISCOVERY_TIMEOUT = 6,
    NET_IRDA_SLOT_TIMEOUT = 7,
    NET_IRDA_MAX_BAUD_RATE = 8,
    NET_IRDA_MIN_TX_TURN_TIME = 9,
    NET_IRDA_MAX_TX_DATA_SIZE = 10,
    NET_IRDA_MAX_TX_WINDOW = 11,
    NET_IRDA_MAX_NOREPLY_TIME = 12,
    NET_IRDA_WARN_NOREPLY_TIME = 13,
    NET_IRDA_LAP_KEEPALIVE_TIME = 14
} ;
#line 802
enum __anonenum_156 {
    FS_NRINODE = 1,
    FS_STATINODE = 2,
    FS_MAXINODE = 3,
    FS_NRDQUOT = 4,
    FS_MAXDQUOT = 5,
    FS_NRFILE = 6,
    FS_MAXFILE = 7,
    FS_DENTRY = 8,
    FS_NRSUPER = 9,
    FS_MAXSUPER = 10,
    FS_OVERFLOWUID = 11,
    FS_OVERFLOWGID = 12,
    FS_LEASES = 13,
    FS_DIR_NOTIFY = 14,
    FS_LEASE_TIME = 15,
    FS_DQSTATS = 16,
    FS_XFS = 17,
    FS_AIO_NR = 18,
    FS_AIO_MAX_NR = 19,
    FS_INOTIFY = 20,
    FS_OCFS2 = 988
} ;
#line 828
enum __anonenum_157 {
    FS_DQ_LOOKUPS = 1,
    FS_DQ_DROPS = 2,
    FS_DQ_READS = 3,
    FS_DQ_WRITES = 4,
    FS_DQ_CACHE_HITS = 5,
    FS_DQ_ALLOCATED = 6,
    FS_DQ_FREE = 7,
    FS_DQ_SYNCS = 8,
    FS_DQ_WARNINGS = 9
} ;
#line 843
enum __anonenum_158 {
    DEV_CDROM = 1,
    DEV_HWMON = 2,
    DEV_PARPORT = 3,
    DEV_RAID = 4,
    DEV_MAC_HID = 5,
    DEV_SCSI = 6,
    DEV_IPMI = 7
} ;
#line 854
enum __anonenum_159 {
    DEV_CDROM_INFO = 1,
    DEV_CDROM_AUTOCLOSE = 2,
    DEV_CDROM_AUTOEJECT = 3,
    DEV_CDROM_DEBUG = 4,
    DEV_CDROM_LOCK = 5,
    DEV_CDROM_CHECK_MEDIA = 6
} ;
#line 864
enum __anonenum_160 {
    DEV_PARPORT_DEFAULT = -3
} ;
#line 869
enum __anonenum_161 {
    DEV_RAID_SPEED_LIMIT_MIN = 1,
    DEV_RAID_SPEED_LIMIT_MAX = 2
} ;
#line 875
enum __anonenum_162 {
    DEV_PARPORT_DEFAULT_TIMESLICE = 1,
    DEV_PARPORT_DEFAULT_SPINTIME = 2
} ;
#line 881
enum __anonenum_163 {
    DEV_PARPORT_SPINTIME = 1,
    DEV_PARPORT_BASE_ADDR = 2,
    DEV_PARPORT_IRQ = 3,
    DEV_PARPORT_DMA = 4,
    DEV_PARPORT_MODES = 5,
    DEV_PARPORT_DEVICES = 6,
    DEV_PARPORT_AUTOPROBE = 16
} ;
#line 892
enum __anonenum_164 {
    DEV_PARPORT_DEVICES_ACTIVE = -3
} ;
#line 897
enum __anonenum_165 {
    DEV_PARPORT_DEVICE_TIMESLICE = 1
} ;
#line 902
enum __anonenum_166 {
    DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES = 1,
    DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES = 2,
    DEV_MAC_HID_MOUSE_BUTTON_EMULATION = 3,
    DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE = 4,
    DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE = 5,
    DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES = 6
} ;
#line 912
enum __anonenum_167 {
    DEV_SCSI_LOGGING_LEVEL = 1
} ;
#line 917
enum __anonenum_168 {
    DEV_IPMI_POWEROFF_POWERCYCLE = 1
} ;
#line 922
enum __anonenum_169 {
    ABI_DEFHANDLER_COFF = 1,
    ABI_DEFHANDLER_ELF = 2,
    ABI_DEFHANDLER_LCALL7 = 3,
    ABI_DEFHANDLER_LIBCSO = 4,
    ABI_TRACE = 5,
    ABI_FAKE_UTSNAME = 6
} ;
#line 31 "../../../analyzer/../bench/linux-headers/include/linux/sysctl.h"
struct ctl_table;
#line 32
struct nsproxy;
#line 32
struct nsproxy;
#line 33
struct ctl_table_root;
#line 33
struct ctl_table_root;
#line 34
struct ctl_table_header;
#line 34
struct ctl_table_header;
#line 35
struct ctl_dir;
#line 35
struct ctl_dir;
#line 37 "../../../analyzer/../bench/linux-headers/include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table *ctl , int write , void *buffer , size_t *lenp ,
                         loff_t *ppos );
#line 87 "../../../analyzer/../bench/linux-headers/include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};
#line 105 "../../../analyzer/../bench/linux-headers/include/linux/sysctl.h"
struct ctl_table {
   char const   *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};
#line 118 "../../../analyzer/../bench/linux-headers/include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};
#line 125 "../../../analyzer/../bench/linux-headers/include/linux/sysctl.h"
struct __anonstruct____missing_field_name_171 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};
#line 125 "../../../analyzer/../bench/linux-headers/include/linux/sysctl.h"
union __anonunion____missing_field_name_170 {
   struct __anonstruct____missing_field_name_171 __annonCompField19 ;
   struct callback_head rcu ;
};
#line 125
struct ctl_table_set;
#line 125 "../../../analyzer/../bench/linux-headers/include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion____missing_field_name_170 __annonCompField20 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};
#line 144 "../../../analyzer/../bench/linux-headers/include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};
#line 150 "../../../analyzer/../bench/linux-headers/include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set * ) ;
   struct ctl_dir dir ;
};
#line 155 "../../../analyzer/../bench/linux-headers/include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root *root , struct nsproxy *namespaces ) ;
   int (*permissions)(struct ctl_table_header *head , struct ctl_table *table ) ;
};
#line 163 "../../../analyzer/../bench/linux-headers/include/linux/sysctl.h"
struct ctl_path {
   char const   *procname ;
};
#line 48 "../../../analyzer/../bench/linux-headers/include/linux/kmod.h"
struct cred;
#line 48
struct cred;
#line 49
struct file;
#line 56 "../../../analyzer/../bench/linux-headers/include/linux/kmod.h"
struct subprocess_info {
   struct work_struct work ;
   struct completion *complete ;
   char *path ;
   char **argv ;
   char **envp ;
   int wait ;
   int retval ;
   int (*init)(struct subprocess_info *info , struct cred *new ) ;
   void (*cleanup)(struct subprocess_info *info ) ;
   void *data ;
};
#line 82
enum umh_disable_depth {
    UMH_ENABLED = 0,
    UMH_FREEZING = 1,
    UMH_DISABLED = 2
} ;
#line 50 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/user_64.h"
struct user_i387_struct {
   unsigned short cwd ;
   unsigned short swd ;
   unsigned short twd ;
   unsigned short fop ;
   __u64 rip ;
   __u64 rdp ;
   __u32 mxcsr ;
   __u32 mxcsr_mask ;
   __u32 st_space[32] ;
   __u32 xmm_space[64] ;
   __u32 padding[24] ;
};
#line 68 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/user_64.h"
struct user_regs_struct {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
   unsigned long fs_base ;
   unsigned long gs_base ;
   unsigned long ds ;
   unsigned long es ;
   unsigned long fs ;
   unsigned long gs ;
};
#line 102 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/user_64.h"
struct user {
   struct user_regs_struct regs ;
   int u_fpvalid ;
   int pad0 ;
   struct user_i387_struct i387 ;
   unsigned long u_tsize ;
   unsigned long u_dsize ;
   unsigned long u_ssize ;
   unsigned long start_code ;
   unsigned long start_stack ;
   long signal ;
   int reserved ;
   int pad1 ;
   unsigned long u_ar0 ;
   struct user_i387_struct *u_fpstate ;
   unsigned long magic ;
   char u_comm[32] ;
   unsigned long u_debugreg[8] ;
   unsigned long error_code ;
   unsigned long fault_address ;
};
#line 12 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/user.h"
struct user_ymmh_regs {
   __u32 ymmh_space[64] ;
};
#line 17 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/user.h"
struct user_xsave_hdr {
   __u64 xstate_bv ;
   __u64 reserved1[2] ;
   __u64 reserved2[5] ;
};
#line 53 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/user.h"
struct __anonstruct_i387_172 {
   __u64 fpx_space[58] ;
   __u64 xstate_fx_sw[6] ;
};
#line 53 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/user.h"
struct user_xstateregs {
   struct __anonstruct_i387_172 i387 ;
   struct user_xsave_hdr xsave_hdr ;
   struct user_ymmh_regs ymmh ;
};
#line 13 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/elf.h"
typedef unsigned long elf_greg_t;
#line 16 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/elf.h"
typedef elf_greg_t elf_gregset_t[sizeof(struct user_regs_struct ) / sizeof(elf_greg_t )];
#line 18 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/elf.h"
typedef struct user_i387_struct elf_fpregset_t;
#line 14 "../../../analyzer/../bench/linux-headers/include/linux/page-debug-flags.h"
enum page_debug_flags {
    PAGE_DEBUG_FLAG_POISON = 0,
    PAGE_DEBUG_FLAG_GUARD = 1
} ;
#line 31 "../../../analyzer/../bench/linux-headers/include/linux/uprobes.h"
struct vm_area_struct;
#line 32
struct mm_struct;
#line 33
struct inode;
#line 33
struct inode;
#line 34
struct notifier_block;
#line 35
struct page;
#line 42
enum uprobe_filter_ctx {
    UPROBE_FILTER_REGISTER = 0,
    UPROBE_FILTER_UNREGISTER = 1,
    UPROBE_FILTER_MMAP = 2
} ;
#line 48 "../../../analyzer/../bench/linux-headers/include/linux/uprobes.h"
struct uprobe_consumer {
   int (*handler)(struct uprobe_consumer *self , struct pt_regs *regs ) ;
   int (*ret_handler)(struct uprobe_consumer *self , unsigned long func , struct pt_regs *regs ) ;
   bool (*filter)(struct uprobe_consumer *self , enum uprobe_filter_ctx ctx , struct mm_struct *mm ) ;
   struct uprobe_consumer *next ;
};
#line 135 "../../../analyzer/../bench/linux-headers/include/linux/uprobes.h"
struct uprobes_state {

};
#line 24 "../../../analyzer/../bench/linux-headers/include/linux/mm_types.h"
struct address_space;
#line 24
struct address_space;
#line 44 "../../../analyzer/../bench/linux-headers/include/linux/mm_types.h"
union __anonunion____missing_field_name_173 {
   struct address_space *mapping ;
   void *s_mem ;
};
#line 44 "../../../analyzer/../bench/linux-headers/include/linux/mm_types.h"
union __anonunion____missing_field_name_175 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 44 "../../../analyzer/../bench/linux-headers/include/linux/mm_types.h"
struct __anonstruct____missing_field_name_179 {
   unsigned int inuse : 16 ;
   unsigned int objects : 15 ;
   unsigned int frozen : 1 ;
};
#line 44 "../../../analyzer/../bench/linux-headers/include/linux/mm_types.h"
union __anonunion____missing_field_name_178 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_179 __annonCompField23 ;
   int units ;
};
#line 44 "../../../analyzer/../bench/linux-headers/include/linux/mm_types.h"
struct __anonstruct____missing_field_name_177 {
   union __anonunion____missing_field_name_178 __annonCompField24 ;
   atomic_t _count ;
};
#line 44 "../../../analyzer/../bench/linux-headers/include/linux/mm_types.h"
union __anonunion____missing_field_name_176 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_177 __annonCompField25 ;
   unsigned int active ;
};
#line 44 "../../../analyzer/../bench/linux-headers/include/linux/mm_types.h"
struct __anonstruct____missing_field_name_174 {
   union __anonunion____missing_field_name_175 __annonCompField22 ;
   union __anonunion____missing_field_name_176 __annonCompField26 ;
};
#line 44 "../../../analyzer/../bench/linux-headers/include/linux/mm_types.h"
struct __anonstruct____missing_field_name_181 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 44
struct slab;
#line 44 "../../../analyzer/../bench/linux-headers/include/linux/mm_types.h"
union __anonunion____missing_field_name_180 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_181 __annonCompField28 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
};
#line 44 "../../../analyzer/../bench/linux-headers/include/linux/mm_types.h"
union __anonunion____missing_field_name_182 {
   unsigned long private ;
   spinlock_t ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 44 "../../../analyzer/../bench/linux-headers/include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   union __anonunion____missing_field_name_173 __annonCompField21 ;
   struct __anonstruct____missing_field_name_174 __annonCompField27 ;
   union __anonunion____missing_field_name_180 __annonCompField29 ;
   union __anonunion____missing_field_name_182 __annonCompField30 ;
} __attribute__((__aligned__((2) *  (sizeof(unsigned long )) ))) ;
#line 209 "../../../analyzer/../bench/linux-headers/include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 220 "../../../analyzer/../bench/linux-headers/include/linux/mm_types.h"
typedef unsigned long vm_flags_t;
#line 227 "../../../analyzer/../bench/linux-headers/include/linux/mm_types.h"
struct vm_region {
   struct rb_node vm_rb ;
   vm_flags_t vm_flags ;
   unsigned long vm_start ;
   unsigned long vm_end ;
   unsigned long vm_top ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   int vm_usage ;
   bool vm_icache_flushed : 1 ;
};
#line 247 "../../../analyzer/../bench/linux-headers/include/linux/mm_types.h"
struct __anonstruct_linear_184 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 247 "../../../analyzer/../bench/linux-headers/include/linux/mm_types.h"
union __anonunion_shared_183 {
   struct __anonstruct_linear_184 linear ;
   struct list_head nonlinear ;
};
#line 247
struct anon_vma;
#line 247
struct vm_operations_struct;
#line 247
struct mempolicy;
#line 247 "../../../analyzer/../bench/linux-headers/include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   union __anonunion_shared_183 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 313 "../../../analyzer/../bench/linux-headers/include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 318 "../../../analyzer/../bench/linux-headers/include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 324
enum __anonenum_185 {
    MM_FILEPAGES = 0,
    MM_ANONPAGES = 1,
    MM_SWAPENTS = 2,
    NR_MM_COUNTERS = 3
} ;
#line 334 "../../../analyzer/../bench/linux-headers/include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3] ;
};
#line 340 "../../../analyzer/../bench/linux-headers/include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3] ;
};
#line 344
struct kioctx_table;
#line 344
struct kioctx_table;
#line 345
struct linux_binfmt;
#line 345 "../../../analyzer/../bench/linux-headers/include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file *filp , unsigned long addr , unsigned long len ,
                                      unsigned long pgoff , unsigned long flags ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct file *exe_file ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
};
#line 514 "../../../analyzer/../bench/linux-headers/include/linux/mm_types.h"
struct vm_special_mapping {
   char const   *name ;
   struct page **pages ;
};
#line 520
enum tlb_flush_reason {
    TLB_FLUSH_ON_TASK_SWITCH = 0,
    TLB_REMOTE_SHOOTDOWN = 1,
    TLB_LOCAL_SHOOTDOWN = 2,
    TLB_LOCAL_MM_SHOOTDOWN = 3,
    NR_TLB_FLUSH_REASONS = 4
} ;
#line 12 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/vdso.h"
struct vdso_image {
   void *data ;
   unsigned long size ;
   struct vm_special_mapping text_mapping ;
   unsigned long alt ;
   unsigned long alt_len ;
   long sym_vvar_start ;
   long sym_vvar_page ;
   long sym_hpet_page ;
   long sym_VDSO32_NOTE_MASK ;
   long sym___kernel_sigreturn ;
   long sym___kernel_rt_sigreturn ;
   long sym___kernel_vsyscall ;
   long sym_VDSO32_SYSENTER_RETURN ;
};
#line 275 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/elf.h"
struct task_struct;
#line 331
struct linux_binprm;
#line 331
struct linux_binprm;
#line 359
enum align_flags {
    ALIGN_VA_32 = 1,
    ALIGN_VA_64 = 2
} ;
#line 364 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/elf.h"
struct va_alignment {
   int flags ;
   unsigned long mask ;
} __attribute__((__aligned__((1) <<  (6) ))) ;
#line 8 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
typedef __u32 Elf32_Addr;
#line 9 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
typedef __u16 Elf32_Half;
#line 10 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
typedef __u32 Elf32_Off;
#line 11 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
typedef __s32 Elf32_Sword;
#line 12 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
typedef __u32 Elf32_Word;
#line 15 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 17 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
typedef __s16 Elf64_SHalf;
#line 18 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
typedef __u64 Elf64_Off;
#line 19 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
typedef __s32 Elf64_Sword;
#line 20 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 22 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
typedef __s64 Elf64_Sxword;
#line 137 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
union __anonunion_d_un_186 {
   Elf32_Sword d_val ;
   Elf32_Addr d_ptr ;
};
#line 137 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
struct dynamic {
   Elf32_Sword d_tag ;
   union __anonunion_d_un_186 d_un ;
};
#line 137 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
typedef struct dynamic Elf32_Dyn;
#line 145 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
union __anonunion_d_un_188 {
   Elf64_Xword d_val ;
   Elf64_Addr d_ptr ;
};
#line 145 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
struct __anonstruct_Elf64_Dyn_187 {
   Elf64_Sxword d_tag ;
   union __anonunion_d_un_188 d_un ;
};
#line 145 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
typedef struct __anonstruct_Elf64_Dyn_187 Elf64_Dyn;
#line 160 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
struct elf32_rel {
   Elf32_Addr r_offset ;
   Elf32_Word r_info ;
};
#line 160 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
typedef struct elf32_rel Elf32_Rel;
#line 165 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
struct elf64_rel {
   Elf64_Addr r_offset ;
   Elf64_Xword r_info ;
};
#line 165 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
typedef struct elf64_rel Elf64_Rel;
#line 170 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
struct elf32_rela {
   Elf32_Addr r_offset ;
   Elf32_Word r_info ;
   Elf32_Sword r_addend ;
};
#line 170 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
typedef struct elf32_rela Elf32_Rela;
#line 176 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
struct elf64_rela {
   Elf64_Addr r_offset ;
   Elf64_Xword r_info ;
   Elf64_Sxword r_addend ;
};
#line 176 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
typedef struct elf64_rela Elf64_Rela;
#line 182 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
struct elf32_sym {
   Elf32_Word st_name ;
   Elf32_Addr st_value ;
   Elf32_Word st_size ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf32_Half st_shndx ;
};
#line 182 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
typedef struct elf32_sym Elf32_Sym;
#line 191 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 191 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 203 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
struct elf32_hdr {
   unsigned char e_ident[16] ;
   Elf32_Half e_type ;
   Elf32_Half e_machine ;
   Elf32_Word e_version ;
   Elf32_Addr e_entry ;
   Elf32_Off e_phoff ;
   Elf32_Off e_shoff ;
   Elf32_Word e_flags ;
   Elf32_Half e_ehsize ;
   Elf32_Half e_phentsize ;
   Elf32_Half e_phnum ;
   Elf32_Half e_shentsize ;
   Elf32_Half e_shnum ;
   Elf32_Half e_shstrndx ;
};
#line 203 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
typedef struct elf32_hdr Elf32_Ehdr;
#line 220 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
struct elf64_hdr {
   unsigned char e_ident[16] ;
   Elf64_Half e_type ;
   Elf64_Half e_machine ;
   Elf64_Word e_version ;
   Elf64_Addr e_entry ;
   Elf64_Off e_phoff ;
   Elf64_Off e_shoff ;
   Elf64_Word e_flags ;
   Elf64_Half e_ehsize ;
   Elf64_Half e_phentsize ;
   Elf64_Half e_phnum ;
   Elf64_Half e_shentsize ;
   Elf64_Half e_shnum ;
   Elf64_Half e_shstrndx ;
};
#line 220 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
typedef struct elf64_hdr Elf64_Ehdr;
#line 243 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
struct elf32_phdr {
   Elf32_Word p_type ;
   Elf32_Off p_offset ;
   Elf32_Addr p_vaddr ;
   Elf32_Addr p_paddr ;
   Elf32_Word p_filesz ;
   Elf32_Word p_memsz ;
   Elf32_Word p_flags ;
   Elf32_Word p_align ;
};
#line 243 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
typedef struct elf32_phdr Elf32_Phdr;
#line 254 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
struct elf64_phdr {
   Elf64_Word p_type ;
   Elf64_Word p_flags ;
   Elf64_Off p_offset ;
   Elf64_Addr p_vaddr ;
   Elf64_Addr p_paddr ;
   Elf64_Xword p_filesz ;
   Elf64_Xword p_memsz ;
   Elf64_Xword p_align ;
};
#line 254 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
typedef struct elf64_phdr Elf64_Phdr;
#line 299 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
struct elf32_shdr {
   Elf32_Word sh_name ;
   Elf32_Word sh_type ;
   Elf32_Word sh_flags ;
   Elf32_Addr sh_addr ;
   Elf32_Off sh_offset ;
   Elf32_Word sh_size ;
   Elf32_Word sh_link ;
   Elf32_Word sh_info ;
   Elf32_Word sh_addralign ;
   Elf32_Word sh_entsize ;
};
#line 299 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
typedef struct elf32_shdr Elf32_Shdr;
#line 312 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
struct elf64_shdr {
   Elf64_Word sh_name ;
   Elf64_Word sh_type ;
   Elf64_Xword sh_flags ;
   Elf64_Addr sh_addr ;
   Elf64_Off sh_offset ;
   Elf64_Xword sh_size ;
   Elf64_Word sh_link ;
   Elf64_Word sh_info ;
   Elf64_Xword sh_addralign ;
   Elf64_Xword sh_entsize ;
};
#line 312 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
typedef struct elf64_shdr Elf64_Shdr;
#line 404 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
struct elf32_note {
   Elf32_Word n_namesz ;
   Elf32_Word n_descsz ;
   Elf32_Word n_type ;
};
#line 404 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
typedef struct elf32_note Elf32_Nhdr;
#line 411 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
struct elf64_note {
   Elf64_Word n_namesz ;
   Elf64_Word n_descsz ;
   Elf64_Word n_type ;
};
#line 411 "../../../analyzer/../bench/linux-headers/include/uapi/linux/elf.h"
typedef struct elf64_note Elf64_Nhdr;
#line 41 "../../../analyzer/../bench/linux-headers/include/linux/elf.h"
struct file;
#line 42
struct coredump_params;
#line 42
struct coredump_params;
#line 30 "../../../analyzer/../bench/linux-headers/include/linux/idr.h"
union __anonunion____missing_field_name_189 {
   unsigned long bitmap[(((unsigned long )(1 << 8) + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
   struct callback_head callback_head ;
};
#line 30 "../../../analyzer/../bench/linux-headers/include/linux/idr.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[1 << 8] ;
   int count ;
   union __anonunion____missing_field_name_189 __annonCompField31 ;
};
#line 42 "../../../analyzer/../bench/linux-headers/include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};
#line 149 "../../../analyzer/../bench/linux-headers/include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[128UL / sizeof(long ) - 1UL] ;
};
#line 154 "../../../analyzer/../bench/linux-headers/include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 20 "../../../analyzer/../bench/linux-headers/include/linux/kernfs.h"
struct file;
#line 21
struct dentry;
#line 21
struct dentry;
#line 22
struct iattr;
#line 22
struct iattr;
#line 23
struct seq_file;
#line 24
struct vm_area_struct;
#line 25
struct super_block;
#line 25
struct super_block;
#line 26
struct file_system_type;
#line 26
struct file_system_type;
#line 28
struct kernfs_open_node;
#line 28
struct kernfs_open_node;
#line 29
struct kernfs_iattrs;
#line 29
struct kernfs_iattrs;
#line 31
enum kernfs_node_type {
    KERNFS_DIR = 1,
    KERNFS_FILE = 2,
    KERNFS_LINK = 4
} ;
#line 40
enum kernfs_node_flag {
    KERNFS_ACTIVATED = 16,
    KERNFS_NS = 32,
    KERNFS_HAS_SEQ_SHOW = 64,
    KERNFS_HAS_MMAP = 128,
    KERNFS_LOCKDEP = 256,
    KERNFS_STATIC_NAME = 512,
    KERNFS_SUICIDAL = 1024,
    KERNFS_SUICIDED = 2048
} ;
#line 52
enum kernfs_root_flag {
    KERNFS_ROOT_CREATE_DEACTIVATED = 1,
    KERNFS_ROOT_EXTRA_OPEN_PERM_CHECK = 2
} ;
#line 74
struct kernfs_root;
#line 74 "../../../analyzer/../bench/linux-headers/include/linux/kernfs.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
#line 86
struct kernfs_node;
#line 86 "../../../analyzer/../bench/linux-headers/include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
#line 90
struct kernfs_ops;
#line 90 "../../../analyzer/../bench/linux-headers/include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};
#line 106 "../../../analyzer/../bench/linux-headers/include/linux/kernfs.h"
union __anonunion____missing_field_name_190 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
#line 106 "../../../analyzer/../bench/linux-headers/include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   void const   *ns ;
   unsigned int hash ;
   union __anonunion____missing_field_name_190 __annonCompField32 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};
#line 146 "../../../analyzer/../bench/linux-headers/include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root *root , int *flags , char *data ) ;
   int (*show_options)(struct seq_file *sf , struct kernfs_root *root ) ;
   int (*mkdir)(struct kernfs_node *parent , char const   *name , umode_t mode ) ;
   int (*rmdir)(struct kernfs_node *kn ) ;
   int (*rename)(struct kernfs_node *kn , struct kernfs_node *new_parent , char const   *new_name ) ;
};
#line 157 "../../../analyzer/../bench/linux-headers/include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
#line 172 "../../../analyzer/../bench/linux-headers/include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 188 "../../../analyzer/../bench/linux-headers/include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file *sf , void *v ) ;
   void *(*seq_start)(struct seq_file *sf , loff_t *ppos ) ;
   void *(*seq_next)(struct seq_file *sf , void *v , loff_t *ppos ) ;
   void (*seq_stop)(struct seq_file *sf , void *v ) ;
   ssize_t (*read)(struct kernfs_open_file *of , char *buf , size_t bytes , loff_t off ) ;
   size_t atomic_write_len ;
   ssize_t (*write)(struct kernfs_open_file *of , char *buf , size_t bytes , loff_t off ) ;
   int (*mmap)(struct kernfs_open_file *of , struct vm_area_struct *vma ) ;
};
#line 20 "../../../analyzer/../bench/linux-headers/include/linux/kobject_ns.h"
struct sock;
#line 20
struct sock;
#line 21
struct kobject;
#line 21
struct kobject;
#line 27
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 40 "../../../analyzer/../bench/linux-headers/include/linux/kobject_ns.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock *sk ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 24 "../../../analyzer/../bench/linux-headers/include/linux/sysfs.h"
struct kobject;
#line 25
struct module;
#line 26
struct bin_attribute;
#line 26
struct bin_attribute;
#line 27
enum kobj_ns_type;
#line 29 "../../../analyzer/../bench/linux-headers/include/linux/sysfs.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
};
#line 60 "../../../analyzer/../bench/linux-headers/include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 118
struct file;
#line 119
struct vm_area_struct;
#line 121 "../../../analyzer/../bench/linux-headers/include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute *attr , struct vm_area_struct *vma ) ;
};
#line 175 "../../../analyzer/../bench/linux-headers/include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 24 "../../../analyzer/../bench/linux-headers/include/linux/kref.h"
struct kref {
   atomic_t refcount ;
};
#line 53 "../../../analyzer/../bench/linux-headers/include/linux/kobject.h"
enum kobject_action {
    KOBJ_ADD = 0,
    KOBJ_REMOVE = 1,
    KOBJ_CHANGE = 2,
    KOBJ_MOVE = 3,
    KOBJ_ONLINE = 4,
    KOBJ_OFFLINE = 5,
    KOBJ_MAX = 6
} ;
#line 63
struct kset;
#line 63
struct kobj_type;
#line 63 "../../../analyzer/../bench/linux-headers/include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   unsigned int state_initialized : 1 ;
   unsigned int state_in_sysfs : 1 ;
   unsigned int state_add_uevent_sent : 1 ;
   unsigned int state_remove_uevent_sent : 1 ;
   unsigned int uevent_suppress : 1 ;
};
#line 115 "../../../analyzer/../bench/linux-headers/include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject *kobj ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject *kobj ) ;
   void const   *(*namespace)(struct kobject *kobj ) ;
};
#line 123 "../../../analyzer/../bench/linux-headers/include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3] ;
   char *envp[32] ;
   int envp_idx ;
   char buf[2048] ;
   int buflen ;
};
#line 131 "../../../analyzer/../bench/linux-headers/include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset *kset , struct kobject *kobj ) ;
   char const   *(* const  name)(struct kset *kset , struct kobject *kobj ) ;
   int (* const  uevent)(struct kset *kset , struct kobject *kobj , struct kobj_uevent_env *env ) ;
};
#line 138 "../../../analyzer/../bench/linux-headers/include/linux/kobject.h"
struct kobj_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct kobject *kobj , struct kobj_attribute *attr , char *buf ) ;
   ssize_t (*store)(struct kobject *kobj , struct kobj_attribute *attr , char const   *buf ,
                    size_t count ) ;
};
#line 148
struct sock;
#line 167 "../../../analyzer/../bench/linux-headers/include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 37 "../../../analyzer/../bench/linux-headers/include/linux/moduleparam.h"
struct kernel_param;
#line 37
struct kernel_param;
#line 44
enum __anonenum_191 {
    KERNEL_PARAM_FL_NOARG = 1
} ;
#line 48 "../../../analyzer/../bench/linux-headers/include/linux/moduleparam.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   *val , struct kernel_param  const  *kp ) ;
   int (*get)(char *buffer , struct kernel_param  const  *kp ) ;
   void (*free)(void *arg ) ;
};
#line 59
struct kparam_string;
#line 59
struct kparam_array;
#line 59 "../../../analyzer/../bench/linux-headers/include/linux/moduleparam.h"
union __anonunion____missing_field_name_192 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 59 "../../../analyzer/../bench/linux-headers/include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct kernel_param_ops  const  *ops ;
   u16 perm ;
   s16 level ;
   union __anonunion____missing_field_name_192 __annonCompField33 ;
};
#line 72 "../../../analyzer/../bench/linux-headers/include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 78 "../../../analyzer/../bench/linux-headers/include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 458
struct module;
#line 9 "../../../analyzer/../bench/linux-headers/include/asm-generic/module.h"
struct mod_arch_specific {

};
#line 32 "../../../analyzer/../bench/linux-headers/include/linux/module.h"
struct modversion_info {
   unsigned long crc ;
   char name[64UL - sizeof(unsigned long )] ;
};
#line 37
struct module;
#line 39
struct module_param_attrs;
#line 39 "../../../analyzer/../bench/linux-headers/include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
#line 47 "../../../analyzer/../bench/linux-headers/include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t count ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 58 "../../../analyzer/../bench/linux-headers/include/linux/module.h"
struct module_version_attribute {
   struct module_attribute mattr ;
   char const   *module_name ;
   char const   *version ;
} __attribute__((__aligned__(sizeof(void *)))) ;
#line 74
struct exception_table_entry;
#line 74
struct exception_table_entry;
#line 189
struct notifier_block;
#line 200 "../../../analyzer/../bench/linux-headers/include/linux/module.h"
struct module_use {
   struct list_head source_list ;
   struct list_head target_list ;
   struct module *source ;
   struct module *target ;
};
#line 206
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 222 "../../../analyzer/../bench/linux-headers/include/linux/module.h"
struct module_ref {
   unsigned long incs ;
   unsigned long decs ;
} __attribute__((__aligned__((2) *  (sizeof(unsigned long )) ))) ;
#line 227
struct module_sect_attrs;
#line 227
struct module_notes_attrs;
#line 227
struct tracepoint;
#line 227
struct ftrace_event_call;
#line 227 "../../../analyzer/../bench/linux-headers/include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[64UL - sizeof(unsigned long )] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct ftrace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   struct module_ref *refptr ;
};
#line 421
enum __anonenum_licence_193 {
    NOT_GPL_ONLY = 0,
    GPL_ONLY = 1,
    WILL_BE_GPL_ONLY = 2
} ;
#line 421 "../../../analyzer/../bench/linux-headers/include/linux/module.h"
struct symsearch {
   struct kernel_symbol  const  *start ;
   struct kernel_symbol  const  *stop ;
   unsigned long const   *crcs ;
   enum __anonenum_licence_193 licence ;
   bool unused ;
};
#line 10 "../../../analyzer/../bench/linux-headers/include/linux/irqreturn.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "../../../analyzer/../bench/linux-headers/include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 8 "../../../analyzer/../bench/linux-headers/include/linux/irqnr.h"
struct irq_desc;
#line 7 "../../../analyzer/../bench/linux-headers/include/linux/context_tracking_state.h"
enum ctx_state {
    IN_KERNEL = 0,
    IN_USER = 1
} ;
#line 7 "../../../analyzer/../bench/linux-headers/include/linux/context_tracking_state.h"
struct context_tracking {
   bool active ;
   enum ctx_state state ;
};
#line 10 "../../../analyzer/../bench/linux-headers/include/linux/vtime.h"
struct task_struct;
#line 26 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/irq_regs.h"
typedef struct pt_regs *pto_T_____6;
#line 26 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/irq_regs.h"
typedef struct pt_regs *pto_T_____7;
#line 26 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/irq_regs.h"
typedef struct pt_regs *pto_T_____8;
#line 26 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/irq_regs.h"
typedef struct pt_regs *pto_T_____9;
#line 28 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
struct seq_file;
#line 29
struct module;
#line 30
struct irq_desc;
#line 31
struct irq_data;
#line 32 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
typedef void (*irq_flow_handler_t)(unsigned int irq , struct irq_desc *desc );
#line 34 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
typedef void (*irq_preflow_handler_t)(struct irq_data *data );
#line 77
enum __anonenum_194 {
    IRQ_TYPE_NONE = 0,
    IRQ_TYPE_EDGE_RISING = 1,
    IRQ_TYPE_EDGE_FALLING = 2,
    IRQ_TYPE_EDGE_BOTH = 3,
    IRQ_TYPE_LEVEL_HIGH = 4,
    IRQ_TYPE_LEVEL_LOW = 8,
    IRQ_TYPE_LEVEL_MASK = 12,
    IRQ_TYPE_SENSE_MASK = 15,
    IRQ_TYPE_DEFAULT = 15,
    IRQ_TYPE_PROBE = 16,
    IRQ_LEVEL = 256,
    IRQ_PER_CPU = 512,
    IRQ_NOPROBE = 1024,
    IRQ_NOREQUEST = 2048,
    IRQ_NOAUTOEN = 4096,
    IRQ_NO_BALANCING = 8192,
    IRQ_MOVE_PCNTXT = 16384,
    IRQ_NESTED_THREAD = 32768,
    IRQ_NOTHREAD = 65536,
    IRQ_PER_CPU_DEVID = 131072,
    IRQ_IS_POLLED = 262144
} ;
#line 117
enum __anonenum_195 {
    IRQ_SET_MASK_OK = 0,
    IRQ_SET_MASK_OK_NOCOPY = 1
} ;
#line 122
struct msi_desc;
#line 123
struct irq_domain;
#line 146
struct irq_chip;
#line 146 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
struct irq_data {
   u32 mask ;
   unsigned int irq ;
   unsigned long hwirq ;
   unsigned int node ;
   unsigned int state_use_accessors ;
   struct irq_chip *chip ;
   struct irq_domain *domain ;
   void *handler_data ;
   void *chip_data ;
   struct msi_desc *msi_desc ;
   cpumask_var_t affinity ;
};
#line 177
enum __anonenum_196 {
    IRQD_TRIGGER_MASK = 15,
    IRQD_SETAFFINITY_PENDING = 256,
    IRQD_NO_BALANCING = 1024,
    IRQD_PER_CPU = 2048,
    IRQD_AFFINITY_SET = 4096,
    IRQD_LEVEL = 8192,
    IRQD_WAKEUP_STATE = 16384,
    IRQD_MOVE_PCNTXT = 32768,
    IRQD_IRQ_DISABLED = 65536,
    IRQD_IRQ_MASKED = 131072,
    IRQD_IRQ_INPROGRESS = 262144
} ;
#line 312 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
struct irq_chip {
   char const   *name ;
   unsigned int (*irq_startup)(struct irq_data *data ) ;
   void (*irq_shutdown)(struct irq_data *data ) ;
   void (*irq_enable)(struct irq_data *data ) ;
   void (*irq_disable)(struct irq_data *data ) ;
   void (*irq_ack)(struct irq_data *data ) ;
   void (*irq_mask)(struct irq_data *data ) ;
   void (*irq_mask_ack)(struct irq_data *data ) ;
   void (*irq_unmask)(struct irq_data *data ) ;
   void (*irq_eoi)(struct irq_data *data ) ;
   int (*irq_set_affinity)(struct irq_data *data , struct cpumask  const  *dest ,
                           bool force ) ;
   int (*irq_retrigger)(struct irq_data *data ) ;
   int (*irq_set_type)(struct irq_data *data , unsigned int flow_type ) ;
   int (*irq_set_wake)(struct irq_data *data , unsigned int on ) ;
   void (*irq_bus_lock)(struct irq_data *data ) ;
   void (*irq_bus_sync_unlock)(struct irq_data *data ) ;
   void (*irq_cpu_online)(struct irq_data *data ) ;
   void (*irq_cpu_offline)(struct irq_data *data ) ;
   void (*irq_suspend)(struct irq_data *data ) ;
   void (*irq_resume)(struct irq_data *data ) ;
   void (*irq_pm_shutdown)(struct irq_data *data ) ;
   void (*irq_calc_mask)(struct irq_data *data ) ;
   void (*irq_print_chip)(struct irq_data *data , struct seq_file *p ) ;
   int (*irq_request_resources)(struct irq_data *data ) ;
   void (*irq_release_resources)(struct irq_data *data ) ;
   unsigned long flags ;
};
#line 361
enum __anonenum_197 {
    IRQCHIP_SET_TYPE_MASKED = 1,
    IRQCHIP_EOI_IF_HANDLED = 2,
    IRQCHIP_MASK_ON_SUSPEND = 4,
    IRQCHIP_ONOFFLINE_ENABLED = 8,
    IRQCHIP_SKIP_SET_WAKE = 16,
    IRQCHIP_ONESHOT_SAFE = 32,
    IRQCHIP_EOI_THREADED = 64
} ;
#line 11 "../../../analyzer/../bench/linux-headers/include/linux/irqdesc.h"
struct irq_affinity_notify;
#line 11
struct irq_affinity_notify;
#line 12
struct proc_dir_entry;
#line 12
struct proc_dir_entry;
#line 13
struct module;
#line 14
struct irq_desc;
#line 42
struct irqaction;
#line 42 "../../../analyzer/../bench/linux-headers/include/linux/irqdesc.h"
struct irq_desc {
   struct irq_data irq_data ;
   unsigned int *kstat_irqs ;
   void (*handle_irq)(unsigned int irq , struct irq_desc *desc ) ;
   struct irqaction *action ;
   unsigned int status_use_accessors ;
   unsigned int core_internal_state__do_not_mess_with_it ;
   unsigned int depth ;
   unsigned int wake_depth ;
   unsigned int irq_count ;
   unsigned long last_unhandled ;
   unsigned int irqs_unhandled ;
   atomic_t threads_handled ;
   int threads_handled_last ;
   raw_spinlock_t lock ;
   struct cpumask *percpu_enabled ;
   struct cpumask  const  *affinity_hint ;
   struct irq_affinity_notify *affinity_notify ;
   cpumask_var_t pending_mask ;
   unsigned long threads_oneshot ;
   atomic_t threads_active ;
   wait_queue_head_t wait_for_threads ;
   struct proc_dir_entry *dir ;
   int parent_irq ;
   struct module *owner ;
   char const   *name ;
} __attribute__((__aligned__((1) <<  (6) ))) ;
#line 16 "../../../analyzer/../bench/linux-headers/include/linux/profile.h"
struct proc_dir_entry;
#line 17
struct pt_regs;
#line 18
struct notifier_block;
#line 34
enum profile_type {
    PROFILE_TASK_EXIT = 0,
    PROFILE_MUNMAP = 1
} ;
#line 66
struct task_struct;
#line 67
struct mm_struct;
#line 86
struct pt_regs;
#line 105 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 414 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/uaccess.h"
struct __large_struct {
   unsigned long buf[100] ;
};
#line 104 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/hw_irq.h"
struct io_apic_irq_attr {
   int ioapic ;
   int ioapic_pin ;
   int trigger ;
   int polarity ;
};
#line 122
struct intel_iommu;
#line 122 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/hw_irq.h"
struct irq_2_iommu {
   struct intel_iommu *iommu ;
   u16 irte_index ;
   u16 sub_handle ;
   u8 irte_mask ;
};
#line 130 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/hw_irq.h"
struct irq_2_irte {
   u16 devid ;
   u16 index ;
};
#line 140
struct irq_pin_list;
#line 140 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/hw_irq.h"
struct irq_cfg {
   struct irq_pin_list *irq_2_pin ;
   cpumask_var_t domain ;
   cpumask_var_t old_domain ;
   u8 vector ;
   u8 move_in_progress : 1 ;
};
#line 158
struct irq_data;
#line 196 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/hw_irq.h"
typedef int vector_irq_t[256];
#line 389 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
struct irqaction;
#line 651 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
struct irq_chip_regs {
   unsigned long enable ;
   unsigned long disable ;
   unsigned long mask ;
   unsigned long ack ;
   unsigned long eoi ;
   unsigned long type ;
   unsigned long polarity ;
};
#line 674 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
struct irq_chip_type {
   struct irq_chip chip ;
   struct irq_chip_regs regs ;
   void (*handler)(unsigned int irq , struct irq_desc *desc ) ;
   u32 type ;
   u32 mask_cache_priv ;
   u32 *mask_cache ;
};
#line 708 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
struct irq_chip_generic {
   raw_spinlock_t lock ;
   void *reg_base ;
   unsigned int irq_base ;
   unsigned int irq_cnt ;
   u32 mask_cache ;
   u32 type_cache ;
   u32 polarity_cache ;
   u32 wake_enabled ;
   u32 wake_active ;
   unsigned int num_ct ;
   void *private ;
   unsigned long installed ;
   unsigned long unused ;
   struct irq_domain *domain ;
   struct list_head list ;
   struct irq_chip_type chip_types[0] ;
};
#line 736
enum irq_gc_flags {
    IRQ_GC_INIT_MASK_CACHE = 1,
    IRQ_GC_INIT_NESTED_LOCK = 2,
    IRQ_GC_MASK_CACHE_PER_TYPE = 4,
    IRQ_GC_NO_MASK = 8
} ;
#line 752 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
struct irq_domain_chip_generic {
   unsigned int irqs_per_chip ;
   unsigned int num_chips ;
   unsigned int irq_flags_to_clear ;
   unsigned int irq_flags_to_set ;
   enum irq_gc_flags gc_flags ;
   struct irq_chip_generic *gc[0] ;
};
#line 7 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/hardirq.h"
struct __anonstruct_irq_cpustat_t_198 {
   unsigned int __softirq_pending ;
   unsigned int __nmi_count ;
   unsigned int apic_timer_irqs ;
   unsigned int irq_spurious_count ;
   unsigned int icr_read_retry_count ;
   unsigned int kvm_posted_intr_ipis ;
   unsigned int x86_platform_ipis ;
   unsigned int apic_perf_irqs ;
   unsigned int apic_irq_work_irqs ;
   unsigned int irq_resched_count ;
   unsigned int irq_call_count ;
   unsigned int irq_tlb_count ;
   unsigned int irq_thermal_count ;
   unsigned int irq_threshold_count ;
} __attribute__((__aligned__((1) <<  (6) ))) ;
#line 7 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/hardirq.h"
typedef struct __anonstruct_irq_cpustat_t_198 irq_cpustat_t;
#line 8 "../../../analyzer/../bench/linux-headers/include/linux/timerqueue.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 13 "../../../analyzer/../bench/linux-headers/include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 27 "../../../analyzer/../bench/linux-headers/include/linux/hrtimer.h"
struct hrtimer_clock_base;
#line 27
struct hrtimer_clock_base;
#line 28
struct hrtimer_cpu_base;
#line 28
struct hrtimer_cpu_base;
#line 33
enum hrtimer_mode {
    HRTIMER_MODE_ABS = 0,
    HRTIMER_MODE_REL = 1,
    HRTIMER_MODE_PINNED = 2,
    HRTIMER_MODE_ABS_PINNED = 2,
    HRTIMER_MODE_REL_PINNED = 3
} ;
#line 44
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 108 "../../../analyzer/../bench/linux-headers/include/linux/hrtimer.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16] ;
};
#line 128 "../../../analyzer/../bench/linux-headers/include/linux/hrtimer.h"
struct hrtimer_sleeper {
   struct hrtimer timer ;
   struct task_struct *task ;
};
#line 145 "../../../analyzer/../bench/linux-headers/include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
#line 156
enum hrtimer_base_type {
    HRTIMER_BASE_MONOTONIC = 0,
    HRTIMER_BASE_REALTIME = 1,
    HRTIMER_BASE_BOOTTIME = 2,
    HRTIMER_BASE_TAI = 3,
    HRTIMER_MAX_CLOCK_BASES = 4
} ;
#line 181 "../../../analyzer/../bench/linux-headers/include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set ;
   ktime_t expires_next ;
   int hres_active ;
   int hang_detected ;
   unsigned long nr_events ;
   unsigned long nr_retries ;
   unsigned long nr_hangs ;
   ktime_t max_hang_time ;
   struct hrtimer_clock_base clock_base[4] ;
};
#line 264
struct clock_event_device;
#line 264
struct clock_event_device;
#line 329
struct tick_device;
#line 83 "../../../analyzer/../bench/linux-headers/include/linux/interrupt.h"
enum __anonenum_199 {
    IRQC_IS_HARDIRQ = 0,
    IRQC_IS_NESTED = 1
} ;
#line 88 "../../../analyzer/../bench/linux-headers/include/linux/interrupt.h"
typedef irqreturn_t (*irq_handler_t)(int  , void * );
#line 105 "../../../analyzer/../bench/linux-headers/include/linux/interrupt.h"
struct irqaction {
   irqreturn_t (*handler)(int  , void * ) ;
   void *dev_id ;
   void *percpu_dev_id ;
   struct irqaction *next ;
   irqreturn_t (*thread_fn)(int  , void * ) ;
   struct task_struct *thread ;
   unsigned int irq ;
   unsigned int flags ;
   unsigned long thread_flags ;
   unsigned long thread_mask ;
   char const   *name ;
   struct proc_dir_entry *dir ;
} __attribute__((__aligned__((1) <<  (6) ))) ;
#line 145
struct device;
#line 214 "../../../analyzer/../bench/linux-headers/include/linux/interrupt.h"
struct irq_affinity_notify {
   unsigned int irq ;
   struct kref kref ;
   struct work_struct work ;
   void (*notify)(struct irq_affinity_notify * , cpumask_t const   *mask ) ;
   void (*release)(struct kref *ref ) ;
};
#line 392
enum __anonenum_200 {
    HI_SOFTIRQ = 0,
    TIMER_SOFTIRQ = 1,
    NET_TX_SOFTIRQ = 2,
    NET_RX_SOFTIRQ = 3,
    BLOCK_SOFTIRQ = 4,
    BLOCK_IOPOLL_SOFTIRQ = 5,
    TASKLET_SOFTIRQ = 6,
    SCHED_SOFTIRQ = 7,
    HRTIMER_SOFTIRQ = 8,
    RCU_SOFTIRQ = 9,
    NR_SOFTIRQS = 10
} ;
#line 419 "../../../analyzer/../bench/linux-headers/include/linux/interrupt.h"
struct softirq_action {
   void (*action)(struct softirq_action * ) ;
};
#line 470 "../../../analyzer/../bench/linux-headers/include/linux/interrupt.h"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
};
#line 486
enum __anonenum_201 {
    TASKLET_STATE_SCHED = 0,
    TASKLET_STATE_RUN = 1
} ;
#line 575 "../../../analyzer/../bench/linux-headers/include/linux/interrupt.h"
struct tasklet_hrtimer {
   struct hrtimer timer ;
   struct tasklet_struct tasklet ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
};
#line 656
struct seq_file;
#line 9 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
struct sched_param {
   int sched_priority ;
};
#line 18 "../../../analyzer/../bench/linux-headers/include/uapi/linux/capability.h"
struct task_struct;
#line 40 "../../../analyzer/../bench/linux-headers/include/uapi/linux/capability.h"
struct __user_cap_header_struct {
   __u32 version ;
   int pid ;
};
#line 40 "../../../analyzer/../bench/linux-headers/include/uapi/linux/capability.h"
typedef struct __user_cap_header_struct *cap_user_header_t;
#line 45 "../../../analyzer/../bench/linux-headers/include/uapi/linux/capability.h"
struct __user_cap_data_struct {
   __u32 effective ;
   __u32 permitted ;
   __u32 inheritable ;
};
#line 45 "../../../analyzer/../bench/linux-headers/include/uapi/linux/capability.h"
typedef struct __user_cap_data_struct *cap_user_data_t;
#line 69 "../../../analyzer/../bench/linux-headers/include/uapi/linux/capability.h"
struct __anonstruct_data_202 {
   __le32 permitted ;
   __le32 inheritable ;
};
#line 69 "../../../analyzer/../bench/linux-headers/include/uapi/linux/capability.h"
struct vfs_cap_data {
   __le32 magic_etc ;
   struct __anonstruct_data_202 data[2] ;
};
#line 23 "../../../analyzer/../bench/linux-headers/include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2] ;
};
#line 23 "../../../analyzer/../bench/linux-headers/include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 28 "../../../analyzer/../bench/linux-headers/include/linux/capability.h"
struct cpu_vfs_cap_data {
   __u32 magic_etc ;
   kernel_cap_t permitted ;
   kernel_cap_t inheritable ;
};
#line 38
struct file;
#line 39
struct inode;
#line 40
struct dentry;
#line 41
struct user_namespace;
#line 81 "../../../analyzer/../bench/linux-headers/include/linux/plist.h"
struct plist_head {
   struct list_head node_list ;
};
#line 85 "../../../analyzer/../bench/linux-headers/include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 4 "../../../analyzer/../bench/linux-headers/include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;
#line 11 "../../../analyzer/../bench/linux-headers/include/asm-generic/cputime_jiffies.h"
typedef u64 cputime64_t;
#line 9 "../../../analyzer/../bench/linux-headers/include/uapi/linux/ipc.h"
struct ipc_perm {
   __kernel_key_t key ;
   __kernel_uid_t uid ;
   __kernel_gid_t gid ;
   __kernel_uid_t cuid ;
   __kernel_gid_t cgid ;
   __kernel_mode_t mode ;
   unsigned short seq ;
};
#line 19 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/ipcbuf.h"
struct ipc64_perm {
   __kernel_key_t key ;
   __kernel_uid32_t uid ;
   __kernel_gid32_t gid ;
   __kernel_uid32_t cuid ;
   __kernel_gid32_t cgid ;
   __kernel_mode_t mode ;
   unsigned char __pad1[4UL - sizeof(__kernel_mode_t )] ;
   unsigned short seq ;
   unsigned short __pad2 ;
   __kernel_ulong_t __unused1 ;
   __kernel_ulong_t __unused2 ;
};
#line 57 "../../../analyzer/../bench/linux-headers/include/uapi/linux/ipc.h"
struct msgbuf;
#line 57 "../../../analyzer/../bench/linux-headers/include/uapi/linux/ipc.h"
struct ipc_kludge {
   struct msgbuf *msgp ;
   long msgtyp ;
};
#line 11 "../../../analyzer/../bench/linux-headers/include/linux/ipc.h"
struct kern_ipc_perm {
   spinlock_t lock ;
   bool deleted ;
   int id ;
   key_t key ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t cuid ;
   kgid_t cgid ;
   umode_t mode ;
   unsigned long seq ;
   void *security ;
};
#line 23 "../../../analyzer/../bench/linux-headers/include/uapi/linux/sem.h"
struct sem;
#line 23
struct sem_queue;
#line 23
struct sem_undo;
#line 23 "../../../analyzer/../bench/linux-headers/include/uapi/linux/sem.h"
struct semid_ds {
   struct ipc_perm sem_perm ;
   __kernel_time_t sem_otime ;
   __kernel_time_t sem_ctime ;
   struct sem *sem_base ;
   struct sem_queue *sem_pending ;
   struct sem_queue **sem_pending_last ;
   struct sem_undo *undo ;
   unsigned short sem_nsems ;
};
#line 13 "../../../analyzer/../bench/linux-headers/arch/x86/include/uapi/asm/sembuf.h"
struct semid64_ds {
   struct ipc64_perm sem_perm ;
   __kernel_time_t sem_otime ;
   __kernel_ulong_t __unused1 ;
   __kernel_time_t sem_ctime ;
   __kernel_ulong_t __unused2 ;
   __kernel_ulong_t sem_nsems ;
   __kernel_ulong_t __unused3 ;
   __kernel_ulong_t __unused4 ;
};
#line 38 "../../../analyzer/../bench/linux-headers/include/uapi/linux/sem.h"
struct sembuf {
   unsigned short sem_num ;
   short sem_op ;
   short sem_flg ;
};
#line 45
struct seminfo;
#line 45 "../../../analyzer/../bench/linux-headers/include/uapi/linux/sem.h"
union semun {
   int val ;
   struct semid_ds *buf ;
   unsigned short *array ;
   struct seminfo *__buf ;
   void *__pad ;
};
#line 53 "../../../analyzer/../bench/linux-headers/include/uapi/linux/sem.h"
struct seminfo {
   int semmap ;
   int semmni ;
   int semmns ;
   int semmnu ;
   int semmsl ;
   int semopm ;
   int semume ;
   int semusz ;
   int semvmx ;
   int semaem ;
};
#line 9 "../../../analyzer/../bench/linux-headers/include/linux/sem.h"
struct task_struct;
#line 12 "../../../analyzer/../bench/linux-headers/include/linux/sem.h"
struct sem_array {
   struct kern_ipc_perm  __attribute__((__aligned__((1) <<  (6) ))) sem_perm ;
   time_t sem_ctime ;
   struct sem *sem_base ;
   struct list_head pending_alter ;
   struct list_head pending_const ;
   struct list_head list_id ;
   int sem_nsems ;
   int complex_count ;
};
#line 28
struct sem_undo_list;
#line 28 "../../../analyzer/../bench/linux-headers/include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 26 "../../../analyzer/../bench/linux-headers/include/uapi/linux/shm.h"
struct shmid_ds {
   struct ipc_perm shm_perm ;
   int shm_segsz ;
   __kernel_time_t shm_atime ;
   __kernel_time_t shm_dtime ;
   __kernel_time_t shm_ctime ;
   __kernel_ipc_pid_t shm_cpid ;
   __kernel_ipc_pid_t shm_lpid ;
   unsigned short shm_nattch ;
   unsigned short shm_unused ;
   void *shm_unused2 ;
   void *shm_unused3 ;
};
#line 25 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/shmbuf.h"
struct shmid64_ds {
   struct ipc64_perm shm_perm ;
   size_t shm_segsz ;
   __kernel_time_t shm_atime ;
   __kernel_time_t shm_dtime ;
   __kernel_time_t shm_ctime ;
   __kernel_pid_t shm_cpid ;
   __kernel_pid_t shm_lpid ;
   __kernel_ulong_t shm_nattch ;
   __kernel_ulong_t __unused4 ;
   __kernel_ulong_t __unused5 ;
};
#line 47 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/shmbuf.h"
struct shminfo64 {
   __kernel_ulong_t shmmax ;
   __kernel_ulong_t shmmin ;
   __kernel_ulong_t shmmni ;
   __kernel_ulong_t shmseg ;
   __kernel_ulong_t shmall ;
   __kernel_ulong_t __unused1 ;
   __kernel_ulong_t __unused2 ;
   __kernel_ulong_t __unused3 ;
   __kernel_ulong_t __unused4 ;
};
#line 62 "../../../analyzer/../bench/linux-headers/include/uapi/linux/shm.h"
struct shminfo {
   int shmmax ;
   int shmmin ;
   int shmmni ;
   int shmseg ;
   int shmall ;
};
#line 70 "../../../analyzer/../bench/linux-headers/include/uapi/linux/shm.h"
struct shm_info {
   int used_ids ;
   __kernel_ulong_t shm_tot ;
   __kernel_ulong_t shm_rss ;
   __kernel_ulong_t shm_swp ;
   __kernel_ulong_t swap_attempts ;
   __kernel_ulong_t swap_successes ;
};
#line 9 "../../../analyzer/../bench/linux-headers/include/linux/shm.h"
struct user_struct;
#line 9 "../../../analyzer/../bench/linux-headers/include/linux/shm.h"
struct shmid_kernel {
   struct kern_ipc_perm shm_perm ;
   struct file *shm_file ;
   unsigned long shm_nattch ;
   unsigned long shm_segsz ;
   time_t shm_atim ;
   time_t shm_dtim ;
   time_t shm_ctim ;
   pid_t shm_cprid ;
   pid_t shm_lprid ;
   struct user_struct *mlock_user ;
   struct task_struct *shm_creator ;
   struct list_head shm_clist ;
};
#line 49 "../../../analyzer/../bench/linux-headers/include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};
#line 20 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/signal.h"
typedef unsigned long old_sigset_t;
#line 22 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_203 {
   unsigned long sig[1] ;
};
#line 22 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_203 sigset_t;
#line 10 "../../../analyzer/../bench/linux-headers/arch/x86/include/uapi/asm/signal.h"
struct siginfo;
#line 10
struct siginfo;
#line 17 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 127 "../../../analyzer/../bench/linux-headers/arch/x86/include/uapi/asm/signal.h"
struct sigaltstack {
   void *ss_sp ;
   int ss_flags ;
   size_t ss_size ;
};
#line 127 "../../../analyzer/../bench/linux-headers/arch/x86/include/uapi/asm/signal.h"
typedef struct sigaltstack stack_t;
#line 7 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 7 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 48 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_205 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 48 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_206 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[sizeof(__kernel_uid32_t ) - sizeof(int )] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 48 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_207 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 48 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_208 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 48 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_209 {
   void *_addr ;
   short _addr_lsb ;
};
#line 48 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_210 {
   long _band ;
   int _fd ;
};
#line 48 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_211 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 48 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_204 {
   int _pad[(128UL - 4UL * sizeof(int )) / sizeof(int )] ;
   struct __anonstruct__kill_205 _kill ;
   struct __anonstruct__timer_206 _timer ;
   struct __anonstruct__rt_207 _rt ;
   struct __anonstruct__sigchld_208 _sigchld ;
   struct __anonstruct__sigfault_209 _sigfault ;
   struct __anonstruct__sigpoll_210 _sigpoll ;
   struct __anonstruct__sigsys_211 _sigsys ;
};
#line 48 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_204 _sifields ;
};
#line 48 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 278 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigev_thread_213 {
   void (*_function)(sigval_t  ) ;
   void *_attribute ;
};
#line 278 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/siginfo.h"
union __anonunion__sigev_un_212 {
   int _pad[(64UL - (sizeof(int ) * 2UL + sizeof(sigval_t ))) / sizeof(int )] ;
   int _tid ;
   struct __anonstruct__sigev_thread_213 _sigev_thread ;
};
#line 278 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/siginfo.h"
struct sigevent {
   sigval_t sigev_value ;
   int sigev_signo ;
   int sigev_notify ;
   union __anonunion__sigev_un_212 _sigev_un ;
};
#line 278 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/siginfo.h"
typedef struct sigevent sigevent_t;
#line 17 "../../../analyzer/../bench/linux-headers/include/asm-generic/siginfo.h"
struct siginfo;
#line 7 "../../../analyzer/../bench/linux-headers/include/linux/signal.h"
struct task_struct;
#line 15 "../../../analyzer/../bench/linux-headers/include/linux/signal.h"
struct sigqueue {
   struct list_head list ;
   int flags ;
   siginfo_t info ;
   struct user_struct *user ;
};
#line 25 "../../../analyzer/../bench/linux-headers/include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 231
struct timespec;
#line 232
struct pt_regs;
#line 247 "../../../analyzer/../bench/linux-headers/include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 261 "../../../analyzer/../bench/linux-headers/include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 277 "../../../analyzer/../bench/linux-headers/include/linux/signal.h"
struct ksignal {
   struct k_sigaction ka ;
   siginfo_t info ;
   int sig ;
};
#line 444
struct seq_file;
#line 6 "../../../analyzer/../bench/linux-headers/include/linux/pid.h"
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 50
struct pid_namespace;
#line 50 "../../../analyzer/../bench/linux-headers/include/linux/pid.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 57 "../../../analyzer/../bench/linux-headers/include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3] ;
   struct callback_head rcu ;
   struct upid numbers[1] ;
};
#line 69 "../../../analyzer/../bench/linux-headers/include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 98
struct pid_namespace;
#line 18 "../../../analyzer/../bench/linux-headers/include/linux/percpu_counter.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 16 "../../../analyzer/../bench/linux-headers/include/linux/proportions.h"
struct prop_global {
   int shift ;
   struct percpu_counter events ;
};
#line 37 "../../../analyzer/../bench/linux-headers/include/linux/proportions.h"
struct prop_descriptor {
   int index ;
   struct prop_global pg[2] ;
   struct mutex mutex ;
};
#line 50 "../../../analyzer/../bench/linux-headers/include/linux/proportions.h"
struct prop_local_percpu {
   struct percpu_counter events ;
   int shift ;
   unsigned long period ;
   raw_spinlock_t lock ;
};
#line 101 "../../../analyzer/../bench/linux-headers/include/linux/proportions.h"
struct prop_local_single {
   unsigned long events ;
   unsigned long period ;
   int shift ;
   raw_spinlock_t lock ;
};
#line 47 "../../../analyzer/../bench/linux-headers/include/uapi/linux/seccomp.h"
struct seccomp_data {
   int nr ;
   __u32 arch ;
   __u64 instruction_pointer ;
   __u64 args[6] ;
};
#line 13 "../../../analyzer/../bench/linux-headers/include/linux/seccomp.h"
struct seccomp_filter;
#line 13
struct seccomp_filter;
#line 25 "../../../analyzer/../bench/linux-headers/include/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 29 "../../../analyzer/../bench/linux-headers/include/linux/rtmutex.h"
struct rt_mutex {
   raw_spinlock_t wait_lock ;
   struct rb_root waiters ;
   struct rb_node *waiters_leftmost ;
   struct task_struct *owner ;
};
#line 42
struct rt_mutex_waiter;
#line 42
struct rt_mutex_waiter;
#line 43
struct hrtimer_sleeper;
#line 23 "../../../analyzer/../bench/linux-headers/include/uapi/linux/resource.h"
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   __kernel_long_t ru_maxrss ;
   __kernel_long_t ru_ixrss ;
   __kernel_long_t ru_idrss ;
   __kernel_long_t ru_isrss ;
   __kernel_long_t ru_minflt ;
   __kernel_long_t ru_majflt ;
   __kernel_long_t ru_nswap ;
   __kernel_long_t ru_inblock ;
   __kernel_long_t ru_oublock ;
   __kernel_long_t ru_msgsnd ;
   __kernel_long_t ru_msgrcv ;
   __kernel_long_t ru_nsignals ;
   __kernel_long_t ru_nvcsw ;
   __kernel_long_t ru_nivcsw ;
};
#line 42 "../../../analyzer/../bench/linux-headers/include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
#line 49 "../../../analyzer/../bench/linux-headers/include/uapi/linux/resource.h"
struct rlimit64 {
   __u64 rlim_cur ;
   __u64 rlim_max ;
};
#line 7 "../../../analyzer/../bench/linux-headers/include/linux/resource.h"
struct task_struct;
#line 11 "../../../analyzer/../bench/linux-headers/include/linux/task_io_accounting.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 13 "../../../analyzer/../bench/linux-headers/include/linux/latencytop.h"
struct task_struct;
#line 26 "../../../analyzer/../bench/linux-headers/include/linux/assoc_array.h"
struct assoc_array_ptr;
#line 26 "../../../analyzer/../bench/linux-headers/include/linux/assoc_array.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
#line 34 "../../../analyzer/../bench/linux-headers/include/linux/assoc_array.h"
struct assoc_array_ops {
   unsigned long (*get_key_chunk)(void const   *index_key , int level ) ;
   unsigned long (*get_object_key_chunk)(void const   *object , int level ) ;
   bool (*compare_object)(void const   *object , void const   *index_key ) ;
   int (*diff_objects)(void const   *object , void const   *index_key ) ;
   void (*free_object)(void *object ) ;
};
#line 56
struct assoc_array_edit;
#line 56
struct assoc_array_edit;
#line 31 "../../../analyzer/../bench/linux-headers/include/linux/key.h"
typedef int32_t key_serial_t;
#line 34 "../../../analyzer/../bench/linux-headers/include/linux/key.h"
typedef uint32_t key_perm_t;
#line 36
struct key;
#line 36
struct key;
#line 76
struct seq_file;
#line 77
struct user_struct;
#line 78
struct signal_struct;
#line 78
struct signal_struct;
#line 79
struct cred;
#line 81
struct key_type;
#line 81
struct key_type;
#line 82
struct key_owner;
#line 82
struct key_owner;
#line 83
struct keyring_list;
#line 83
struct keyring_list;
#line 84
struct keyring_name;
#line 84
struct keyring_name;
#line 86 "../../../analyzer/../bench/linux-headers/include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
#line 106
struct __key_reference_with_attributes;
#line 106 "../../../analyzer/../bench/linux-headers/include/linux/key.h"
typedef struct __key_reference_with_attributes *key_ref_t;
#line 132 "../../../analyzer/../bench/linux-headers/include/linux/key.h"
union __anonunion____missing_field_name_214 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 132
struct key_user;
#line 132 "../../../analyzer/../bench/linux-headers/include/linux/key.h"
union __anonunion____missing_field_name_215 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 132 "../../../analyzer/../bench/linux-headers/include/linux/key.h"
struct __anonstruct____missing_field_name_217 {
   struct key_type *type ;
   char *description ;
};
#line 132 "../../../analyzer/../bench/linux-headers/include/linux/key.h"
union __anonunion____missing_field_name_216 {
   struct keyring_index_key index_key ;
   struct __anonstruct____missing_field_name_217 __annonCompField36 ;
};
#line 132 "../../../analyzer/../bench/linux-headers/include/linux/key.h"
union __anonunion_type_data_218 {
   struct list_head link ;
   unsigned long x[2] ;
   void *p[2] ;
   int reject_error ;
};
#line 132 "../../../analyzer/../bench/linux-headers/include/linux/key.h"
union __anonunion_payload_220 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2] ;
};
#line 132 "../../../analyzer/../bench/linux-headers/include/linux/key.h"
union __anonunion____missing_field_name_219 {
   union __anonunion_payload_220 payload ;
   struct assoc_array keys ;
};
#line 132 "../../../analyzer/../bench/linux-headers/include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion____missing_field_name_214 __annonCompField34 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion____missing_field_name_215 __annonCompField35 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion____missing_field_name_216 __annonCompField37 ;
   union __anonunion_type_data_218 type_data ;
   union __anonunion____missing_field_name_219 __annonCompField38 ;
};
#line 17 "../../../analyzer/../bench/linux-headers/include/linux/selinux.h"
struct selinux_audit_rule;
#line 17
struct selinux_audit_rule;
#line 18
struct audit_context;
#line 18
struct audit_context;
#line 19
struct kern_ipc_perm;
#line 22 "../../../analyzer/../bench/linux-headers/include/linux/cred.h"
struct user_struct;
#line 23
struct cred;
#line 24
struct inode;
#line 32 "../../../analyzer/../bench/linux-headers/include/linux/cred.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32] ;
   kgid_t *blocks[0] ;
};
#line 102 "../../../analyzer/../bench/linux-headers/include/linux/cred.h"
struct cred {
   atomic_t usage ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 109 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
struct sched_attr {
   u32 size ;
   u32 sched_policy ;
   u64 sched_flags ;
   s32 sched_nice ;
   u32 sched_priority ;
   u64 sched_runtime ;
   u64 sched_deadline ;
   u64 sched_period ;
};
#line 127
struct exec_domain;
#line 128
struct futex_pi_state;
#line 128
struct futex_pi_state;
#line 129
struct robust_list_head;
#line 129
struct robust_list_head;
#line 130
struct bio_list;
#line 130
struct bio_list;
#line 131
struct fs_struct;
#line 131
struct fs_struct;
#line 132
struct perf_event_context;
#line 132
struct perf_event_context;
#line 133
struct blk_plug;
#line 133
struct blk_plug;
#line 134
struct filename;
#line 134
struct filename;
#line 181
struct seq_file;
#line 182
struct cfs_rq;
#line 182
struct cfs_rq;
#line 183
struct task_group;
#line 183
struct task_group;
#line 279
struct task_struct;
#line 384
struct nsproxy;
#line 385
struct user_namespace;
#line 459 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 466 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 474 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 488 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 507 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 549 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   raw_spinlock_t lock ;
};
#line 556
struct autogroup;
#line 556
struct autogroup;
#line 565
struct tty_struct;
#line 565
struct taskstats;
#line 565
struct tty_audit_buf;
#line 565 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned int is_child_subreaper : 1 ;
   unsigned int has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 739 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 781
struct backing_dev_info;
#line 781
struct backing_dev_info;
#line 782
struct reclaim_state;
#line 782
struct reclaim_state;
#line 785 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 797 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 842
enum cpu_idle_type {
    CPU_IDLE = 0,
    CPU_NOT_IDLE = 1,
    CPU_NEWLY_IDLE = 2,
    CPU_MAX_IDLE_TYPES = 3
} ;
#line 895 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
struct sched_domain_attr {
   int relax_domain_level ;
};
#line 905
struct sched_group;
#line 905
struct sched_group;
#line 907 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
union __anonunion____missing_field_name_221 {
   void *private ;
   struct callback_head rcu ;
};
#line 907 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
struct sched_domain {
   struct sched_domain *parent ;
   struct sched_domain *child ;
   struct sched_group *groups ;
   unsigned long min_interval ;
   unsigned long max_interval ;
   unsigned int busy_factor ;
   unsigned int imbalance_pct ;
   unsigned int cache_nice_tries ;
   unsigned int busy_idx ;
   unsigned int idle_idx ;
   unsigned int newidle_idx ;
   unsigned int wake_idx ;
   unsigned int forkexec_idx ;
   unsigned int smt_gain ;
   int nohz_idle ;
   int flags ;
   int level ;
   unsigned long last_balance ;
   unsigned int balance_interval ;
   unsigned int nr_balance_failed ;
   u64 max_newidle_lb_cost ;
   unsigned long next_decay_max_lb_cost ;
   unsigned int lb_count[3] ;
   unsigned int lb_failed[3] ;
   unsigned int lb_balanced[3] ;
   unsigned int lb_imbalance[3] ;
   unsigned int lb_gained[3] ;
   unsigned int lb_hot_gained[3] ;
   unsigned int lb_nobusyg[3] ;
   unsigned int lb_nobusyq[3] ;
   unsigned int alb_count ;
   unsigned int alb_failed ;
   unsigned int alb_pushed ;
   unsigned int sbe_count ;
   unsigned int sbe_balanced ;
   unsigned int sbe_pushed ;
   unsigned int sbf_count ;
   unsigned int sbf_balanced ;
   unsigned int sbf_pushed ;
   unsigned int ttwu_wake_remote ;
   unsigned int ttwu_move_affine ;
   unsigned int ttwu_move_balance ;
   union __anonunion____missing_field_name_221 __annonCompField39 ;
   unsigned int span_weight ;
   unsigned long span[0] ;
};
#line 1001 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
typedef struct cpumask  const  *(*sched_domain_mask_f)(int cpu );
#line 1002 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
typedef int (*sched_domain_flags_f)(void);
#line 1006
struct sched_group_capacity;
#line 1006 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
struct sd_data {
   struct sched_domain **sd ;
   struct sched_group **sg ;
   struct sched_group_capacity **sgc ;
};
#line 1012 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
struct sched_domain_topology_level {
   struct cpumask  const  *(*mask)(int cpu ) ;
   int (*sd_flags)(void) ;
   int flags ;
   int numa_level ;
   struct sd_data data ;
};
#line 1051
struct io_context;
#line 1051
struct io_context;
#line 1060
struct audit_context;
#line 1061
struct mempolicy;
#line 1062
struct pipe_inode_info;
#line 1062
struct pipe_inode_info;
#line 1063
struct uts_namespace;
#line 1063
struct uts_namespace;
#line 1065 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
#line 1070 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
struct sched_avg {
   u32 runnable_avg_sum ;
   u32 runnable_avg_period ;
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
};
#line 1083 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1118 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1150 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
};
#line 1166 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};
#line 1215
struct rcu_node;
#line 1215
struct rcu_node;
#line 1217
enum perf_event_task_context {
    perf_invalid_context = -1,
    perf_hw_context = 0,
    perf_sw_context = 1,
    perf_nr_task_contexts = 2
} ;
#line 1224
struct sched_class;
#line 1224
struct files_struct;
#line 1224
struct css_set;
#line 1224
struct compat_robust_list_head;
#line 1224 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[1U << 2] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int jobctl ;
   unsigned int personality ;
   unsigned int in_execve : 1 ;
   unsigned int in_iowait : 1 ;
   unsigned int sched_reset_on_fork : 1 ;
   unsigned int sched_contributes_to_load : 1 ;
   unsigned long atomic_flags ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void *priv ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned long trace ;
   unsigned long trace_recursion ;
};
#line 1711
struct pid_namespace;
#line 2230 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
union thread_union {
   struct thread_info thread_info ;
   unsigned long stack[((1UL << 12) << 2) / sizeof(long )] ;
};
#line 108 "../../../analyzer/../bench/linux-headers/include/linux/slab.h"
struct mem_cgroup;
#line 108
struct mem_cgroup;
#line 11 "../../../analyzer/../bench/linux-headers/include/linux/slub_def.h"
enum stat_item {
    ALLOC_FASTPATH = 0,
    ALLOC_SLOWPATH = 1,
    FREE_FASTPATH = 2,
    FREE_SLOWPATH = 3,
    FREE_FROZEN = 4,
    FREE_ADD_PARTIAL = 5,
    FREE_REMOVE_PARTIAL = 6,
    ALLOC_FROM_PARTIAL = 7,
    ALLOC_SLAB = 8,
    ALLOC_REFILL = 9,
    ALLOC_NODE_MISMATCH = 10,
    FREE_SLAB = 11,
    CPUSLAB_FLUSH = 12,
    DEACTIVATE_FULL = 13,
    DEACTIVATE_EMPTY = 14,
    DEACTIVATE_TO_HEAD = 15,
    DEACTIVATE_TO_TAIL = 16,
    DEACTIVATE_REMOTE_FREES = 17,
    DEACTIVATE_BYPASS = 18,
    ORDER_FALLBACK = 19,
    CMPXCHG_DOUBLE_CPU_FAIL = 20,
    CMPXCHG_DOUBLE_FAIL = 21,
    CPU_PARTIAL_ALLOC = 22,
    CPU_PARTIAL_FREE = 23,
    CPU_PARTIAL_NODE = 24,
    CPU_PARTIAL_DRAIN = 25,
    NR_SLUB_STAT_ITEMS = 26
} ;
#line 40 "../../../analyzer/../bench/linux-headers/include/linux/slub_def.h"
struct kmem_cache_cpu {
   void **freelist ;
   unsigned long tid ;
   struct page *page ;
   struct page *partial ;
};
#line 55 "../../../analyzer/../bench/linux-headers/include/linux/slub_def.h"
struct kmem_cache_order_objects {
   unsigned long x ;
};
#line 62
struct kmem_cache_node;
#line 62 "../../../analyzer/../bench/linux-headers/include/linux/slub_def.h"
struct kmem_cache {
   struct kmem_cache_cpu *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int object_size ;
   int offset ;
   int cpu_partial ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1 << 6] ;
};
#line 531 "../../../analyzer/../bench/linux-headers/include/linux/slab.h"
struct __anonstruct____missing_field_name_223 {
   struct callback_head callback_head ;
   struct kmem_cache *memcg_caches[0] ;
};
#line 531 "../../../analyzer/../bench/linux-headers/include/linux/slab.h"
struct __anonstruct____missing_field_name_224 {
   struct mem_cgroup *memcg ;
   struct list_head list ;
   struct kmem_cache *root_cache ;
   atomic_t nr_pages ;
};
#line 531 "../../../analyzer/../bench/linux-headers/include/linux/slab.h"
union __anonunion____missing_field_name_222 {
   struct __anonstruct____missing_field_name_223 __annonCompField40 ;
   struct __anonstruct____missing_field_name_224 __annonCompField41 ;
};
#line 531 "../../../analyzer/../bench/linux-headers/include/linux/slab.h"
struct memcg_cache_params {
   bool is_root_cache ;
   union __anonunion____missing_field_name_222 __annonCompField42 ;
};
#line 549
struct seq_file;
#line 54 "../../../analyzer/../bench/linux-headers/include/linux/miscdevice.h"
struct device;
#line 56 "../../../analyzer/../bench/linux-headers/include/linux/miscdevice.h"
struct miscdevice {
   int minor ;
   char const   *name ;
   struct file_operations  const  *fops ;
   struct list_head list ;
   struct device *parent ;
   struct device *this_device ;
   char const   *nodename ;
   umode_t mode ;
};
#line 27 "../../../analyzer/../bench/linux-headers/include/uapi/linux/uuid.h"
struct __anonstruct_uuid_le_225 {
   __u8 b[16] ;
};
#line 27 "../../../analyzer/../bench/linux-headers/include/uapi/linux/uuid.h"
typedef struct __anonstruct_uuid_le_225 uuid_le;
#line 31 "../../../analyzer/../bench/linux-headers/include/uapi/linux/uuid.h"
struct __anonstruct_uuid_be_226 {
   __u8 b[16] ;
};
#line 31 "../../../analyzer/../bench/linux-headers/include/uapi/linux/uuid.h"
typedef struct __anonstruct_uuid_be_226 uuid_be;
#line 13 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 18 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 31 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct ieee1394_device_id {
   __u32 match_flags ;
   __u32 vendor_id ;
   __u32 model_id ;
   __u32 specifier_id ;
   __u32 version ;
   kernel_ulong_t driver_data ;
};
#line 101 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct usb_device_id {
   __u16 match_flags ;
   __u16 idVendor ;
   __u16 idProduct ;
   __u16 bcdDevice_lo ;
   __u16 bcdDevice_hi ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bInterfaceClass ;
   __u8 bInterfaceSubClass ;
   __u8 bInterfaceProtocol ;
   __u8 bInterfaceNumber ;
   kernel_ulong_t driver_info  __attribute__((__aligned__(sizeof(kernel_ulong_t )))) ;
};
#line 146 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct hid_device_id {
   __u16 bus ;
   __u16 group ;
   __u32 vendor ;
   __u32 product ;
   kernel_ulong_t driver_data ;
};
#line 155 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct ccw_device_id {
   __u16 match_flags ;
   __u16 cu_type ;
   __u16 dev_type ;
   __u8 cu_model ;
   __u8 dev_model ;
   kernel_ulong_t driver_info ;
};
#line 172 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct ap_device_id {
   __u16 match_flags ;
   __u8 dev_type ;
   kernel_ulong_t driver_info ;
};
#line 181 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct css_device_id {
   __u8 match_flags ;
   __u8 type ;
   kernel_ulong_t driver_data ;
};
#line 189 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9] ;
   kernel_ulong_t driver_data ;
};
#line 197 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct pnp_device_id {
   __u8 id[8] ;
   kernel_ulong_t driver_data ;
};
#line 202 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct __anonstruct_devs_227 {
   __u8 id[8] ;
};
#line 202 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct pnp_card_device_id {
   __u8 id[8] ;
   kernel_ulong_t driver_data ;
   struct __anonstruct_devs_227 devs[8] ;
};
#line 213 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct serio_device_id {
   __u8 type ;
   __u8 extra ;
   __u8 id ;
   __u8 proto ;
};
#line 223 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32] ;
   char type[32] ;
   char compatible[128] ;
   void const   *data ;
};
#line 232 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct vio_device_id {
   char type[32] ;
   char compat[32] ;
};
#line 239 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct pcmcia_device_id {
   __u16 match_flags ;
   __u16 manf_id ;
   __u16 card_id ;
   __u8 func_id ;
   __u8 function ;
   __u8 device_no ;
   __u32 prod_id_hash[4] ;
   char const   *prod_id[4] ;
   kernel_ulong_t driver_info ;
   char *cisfile ;
};
#line 302 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct input_device_id {
   kernel_ulong_t flags ;
   __u16 bustype ;
   __u16 vendor ;
   __u16 product ;
   __u16 version ;
   kernel_ulong_t evbit[1] ;
   kernel_ulong_t keybit[12] ;
   kernel_ulong_t relbit[1] ;
   kernel_ulong_t absbit[1] ;
   kernel_ulong_t mscbit[1] ;
   kernel_ulong_t ledbit[1] ;
   kernel_ulong_t sndbit[1] ;
   kernel_ulong_t ffbit[2] ;
   kernel_ulong_t swbit[1] ;
   kernel_ulong_t driver_info ;
};
#line 329 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct eisa_device_id {
   char sig[8] ;
   kernel_ulong_t driver_data ;
};
#line 336 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct parisc_device_id {
   __u8 hw_type ;
   __u8 hversion_rev ;
   __u16 hversion ;
   __u32 sversion ;
};
#line 352 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct sdio_device_id {
   __u8 class ;
   __u16 vendor ;
   __u16 device ;
   kernel_ulong_t driver_data ;
};
#line 360 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct ssb_device_id {
   __u16 vendor ;
   __u16 coreid ;
   __u8 revision ;
   __u8 __pad ;
} __attribute__((__packed__, __aligned__(2))) ;
#line 376 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct bcma_device_id {
   __u16 manuf ;
   __u16 id ;
   __u8 rev ;
   __u8 class ;
} __attribute__((__packed__, __aligned__(2))) ;
#line 392 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct virtio_device_id {
   __u32 device ;
   __u32 vendor ;
};
#line 401 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct hv_vmbus_device_id {
   __u8 guid[16] ;
   kernel_ulong_t driver_data ;
};
#line 411 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct rpmsg_device_id {
   char name[32] ;
};
#line 420 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct i2c_device_id {
   char name[20] ;
   kernel_ulong_t driver_data ;
};
#line 430 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct spi_device_id {
   char name[32] ;
   kernel_ulong_t driver_data ;
};
#line 438 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct spmi_device_id {
   char name[32] ;
   kernel_ulong_t driver_data ;
};
#line 444
enum dmi_field {
    DMI_NONE = 0,
    DMI_BIOS_VENDOR = 1,
    DMI_BIOS_VERSION = 2,
    DMI_BIOS_DATE = 3,
    DMI_SYS_VENDOR = 4,
    DMI_PRODUCT_NAME = 5,
    DMI_PRODUCT_VERSION = 6,
    DMI_PRODUCT_SERIAL = 7,
    DMI_PRODUCT_UUID = 8,
    DMI_BOARD_VENDOR = 9,
    DMI_BOARD_NAME = 10,
    DMI_BOARD_VERSION = 11,
    DMI_BOARD_SERIAL = 12,
    DMI_BOARD_ASSET_TAG = 13,
    DMI_CHASSIS_VENDOR = 14,
    DMI_CHASSIS_TYPE = 15,
    DMI_CHASSIS_VERSION = 16,
    DMI_CHASSIS_SERIAL = 17,
    DMI_CHASSIS_ASSET_TAG = 18,
    DMI_STRING_MAX = 19
} ;
#line 467 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct dmi_strmatch {
   unsigned char slot : 7 ;
   unsigned char exact_match : 1 ;
   char substr[79] ;
};
#line 473 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct dmi_system_id {
   int (*callback)(struct dmi_system_id  const  * ) ;
   char const   *ident ;
   struct dmi_strmatch matches[4] ;
   void *driver_data ;
};
#line 493 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct platform_device_id {
   char name[20] ;
   kernel_ulong_t driver_data ;
};
#line 519 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct mdio_device_id {
   __u32 phy_id ;
   __u32 phy_id_mask ;
};
#line 524 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct zorro_device_id {
   __u32 id ;
   kernel_ulong_t driver_data ;
};
#line 534 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct isapnp_device_id {
   unsigned short card_vendor ;
   unsigned short card_device ;
   unsigned short vendor ;
   unsigned short function ;
   kernel_ulong_t driver_data ;
};
#line 548 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct amba_id {
   unsigned int id ;
   unsigned int mask ;
   void *data ;
};
#line 564 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct x86_cpu_id {
   __u16 vendor ;
   __u16 family ;
   __u16 model ;
   __u16 feature ;
   kernel_ulong_t driver_data ;
};
#line 585 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct cpu_feature {
   __u16 feature ;
};
#line 591 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct ipack_device_id {
   __u8 format ;
   __u32 vendor ;
   __u32 device ;
};
#line 600 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct mei_cl_device_id {
   char name[32] ;
   kernel_ulong_t driver_info ;
};
#line 619 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct rio_device_id {
   __u16 did ;
   __u16 vid ;
   __u16 asm_did ;
   __u16 asm_vid ;
};
#line 624 "../../../analyzer/../bench/linux-headers/include/linux/mod_devicetable.h"
struct mcb_device_id {
   __u16 device ;
   kernel_ulong_t driver_data ;
};
#line 19 "../../../analyzer/../bench/linux-headers/include/linux/klist.h"
struct klist_node;
#line 19
struct klist_node;
#line 20 "../../../analyzer/../bench/linux-headers/include/linux/klist.h"
struct klist {
   spinlock_t k_lock ;
   struct list_head k_list ;
   void (*get)(struct klist_node * ) ;
   void (*put)(struct klist_node * ) ;
} __attribute__((__aligned__(sizeof(void *)))) ;
#line 39 "../../../analyzer/../bench/linux-headers/include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 56 "../../../analyzer/../bench/linux-headers/include/linux/klist.h"
struct klist_iter {
   struct klist *i_klist ;
   struct klist_node *i_cur ;
};
#line 10 "../../../analyzer/../bench/linux-headers/include/linux/ratelimit.h"
struct ratelimit_state {
   raw_spinlock_t lock ;
   int interval ;
   int burst ;
   int printed ;
   int missed ;
   unsigned long begin ;
};
#line 4 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/device.h"
struct dma_map_ops;
#line 4 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/device.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 13 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/device.h"
struct pdev_archdata {

};
#line 32 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
struct device;
#line 33
struct device_private;
#line 33
struct device_private;
#line 34
struct device_driver;
#line 34
struct device_driver;
#line 35
struct driver_private;
#line 35
struct driver_private;
#line 36
struct module;
#line 37
struct class;
#line 37
struct class;
#line 38
struct subsys_private;
#line 38
struct subsys_private;
#line 39
struct bus_type;
#line 39
struct bus_type;
#line 40
struct device_node;
#line 41
struct iommu_ops;
#line 41
struct iommu_ops;
#line 42
struct iommu_group;
#line 42
struct iommu_group;
#line 44 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type *bus , char *buf ) ;
   ssize_t (*store)(struct bus_type *bus , char const   *buf , size_t count ) ;
};
#line 104
struct device_attribute;
#line 104 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device *dev , struct device_driver *drv ) ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*online)(struct device *dev ) ;
   int (*offline)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops  const  *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 140
struct device_type;
#line 140 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
struct subsys_dev_iter {
   struct klist_iter ki ;
   struct device_type  const  *type ;
};
#line 172
struct notifier_block;
#line 228 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 264 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver *driver , char *buf ) ;
   ssize_t (*store)(struct device_driver *driver , char const   *buf , size_t count ) ;
};
#line 307 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
struct subsys_interface {
   char const   *name ;
   struct bus_type *subsys ;
   struct list_head node ;
   int (*add_dev)(struct device *dev , struct subsys_interface *sif ) ;
   int (*remove_dev)(struct device *dev , struct subsys_interface *sif ) ;
};
#line 351
struct class_attribute;
#line 351 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   char *(*devnode)(struct device *dev , umode_t *mode ) ;
   void (*class_release)(struct class *class ) ;
   void (*dev_release)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device *dev ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 376 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
struct class_dev_iter {
   struct klist_iter ki ;
   struct device_type  const  *type ;
};
#line 395
struct class_compat;
#line 395
struct class_compat;
#line 417 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class *class , struct class_attribute *attr , char *buf ) ;
   ssize_t (*store)(struct class *class , struct class_attribute *attr , char const   *buf ,
                    size_t count ) ;
};
#line 452 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
struct class_attribute_string {
   struct class_attribute attr ;
   char *str ;
};
#line 467 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
struct class_interface {
   struct list_head node ;
   struct class *class ;
   int (*add_dev)(struct device * , struct class_interface * ) ;
   void (*remove_dev)(struct device * , struct class_interface * ) ;
};
#line 500 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   char *(*devnode)(struct device *dev , umode_t *mode , kuid_t *uid , kgid_t *gid ) ;
   void (*release)(struct device *dev ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 512 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device *dev , struct device_attribute *attr , char *buf ) ;
   ssize_t (*store)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                    size_t count ) ;
};
#line 520 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
struct dev_ext_attribute {
   struct device_attribute attr ;
   void *var ;
};
#line 571 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
typedef void (*dr_release_t)(struct device *dev , void *res );
#line 572 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
typedef int (*dr_match_t)(struct device *dev , void *res , void *match_data );
#line 643 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 652
struct acpi_device;
#line 652
struct acpi_device;
#line 654 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
struct acpi_dev_node {
   struct acpi_device *companion ;
};
#line 729
struct dma_coherent_mem;
#line 729 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct acpi_dev_node acpi_node ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device *dev ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled : 1 ;
   bool offline : 1 ;
};
#line 46 "../../../analyzer/../bench/linux-headers/include/linux/pm_wakeup.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active : 1 ;
   bool autosleep_enabled : 1 ;
};
#line 25 "../../../analyzer/../bench/linux-headers/include/linux/io.h"
struct device;
#line 53 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
struct hotplug_slot;
#line 53 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
#line 67
enum pci_mmap_state {
    pci_mmap_io = 0,
    pci_mmap_mem = 1
} ;
#line 81
enum __anonenum_228 {
    PCI_STD_RESOURCES = 0,
    PCI_STD_RESOURCE_END = 5,
    PCI_ROM_RESOURCE = 6,
    PCI_BRIDGE_RESOURCES = 7,
    PCI_BRIDGE_RESOURCE_END = 10,
    PCI_NUM_RESOURCES = 11,
    DEVICE_COUNT_RESOURCE = 11
} ;
#line 109 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
typedef int pci_power_t;
#line 136 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
typedef unsigned int pci_channel_state_t;
#line 138
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
#line 149 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
typedef unsigned int pcie_reset_state_t;
#line 151
enum pcie_reset_state {
    pcie_deassert_reset = 1,
    pcie_warm_reset = 2,
    pcie_hot_reset = 3
} ;
#line 162 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;
#line 163
enum pci_dev_flags {
    PCI_DEV_FLAGS_MSI_INTX_DISABLE_BUG = 1,
    PCI_DEV_FLAGS_NO_D3 = 2,
    PCI_DEV_FLAGS_ASSIGNED = 4,
    PCI_DEV_FLAGS_ACS_ENABLED_QUIRK = 8,
    PCI_DEV_FLAGS_DMA_ALIAS_DEVFN = 16,
    PCI_DEV_FLAG_PCIE_BRIDGE_ALIAS = 32
} ;
#line 180
enum pci_irq_reroute_variant {
    INTEL_IRQ_REROUTE_VARIANT = 1,
    MAX_IRQ_REROUTE_VARIANTS = 3
} ;
#line 185 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;
#line 186
enum pci_bus_flags {
    PCI_BUS_FLAGS_NO_MSI = 1,
    PCI_BUS_FLAGS_NO_MMRBC = 2
} ;
#line 192
enum pcie_link_width {
    PCIE_LNK_WIDTH_RESRV = 0,
    PCIE_LNK_X1 = 1,
    PCIE_LNK_X2 = 2,
    PCIE_LNK_X4 = 4,
    PCIE_LNK_X8 = 8,
    PCIE_LNK_X12 = 12,
    PCIE_LNK_X16 = 16,
    PCIE_LNK_X32 = 32,
    PCIE_LNK_WIDTH_UNKNOWN = 255
} ;
#line 205
enum pci_bus_speed {
    PCI_SPEED_33MHz = 0,
    PCI_SPEED_66MHz = 1,
    PCI_SPEED_66MHz_PCIX = 2,
    PCI_SPEED_100MHz_PCIX = 3,
    PCI_SPEED_133MHz_PCIX = 4,
    PCI_SPEED_66MHz_PCIX_ECC = 5,
    PCI_SPEED_100MHz_PCIX_ECC = 6,
    PCI_SPEED_133MHz_PCIX_ECC = 7,
    PCI_SPEED_66MHz_PCIX_266 = 9,
    PCI_SPEED_100MHz_PCIX_266 = 10,
    PCI_SPEED_133MHz_PCIX_266 = 11,
    AGP_UNKNOWN = 12,
    AGP_1X = 13,
    AGP_2X = 14,
    AGP_4X = 15,
    AGP_8X = 16,
    PCI_SPEED_66MHz_PCIX_533 = 17,
    PCI_SPEED_100MHz_PCIX_533 = 18,
    PCI_SPEED_133MHz_PCIX_533 = 19,
    PCIE_SPEED_2_5GT = 20,
    PCIE_SPEED_5_0GT = 21,
    PCIE_SPEED_8_0GT = 22,
    PCI_SPEED_UNKNOWN = 255
} ;
#line 231 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
struct pci_cap_saved_data {
   u16 cap_nr ;
   bool cap_extended ;
   unsigned int size ;
   u32 data[0] ;
};
#line 238 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
struct pci_cap_saved_state {
   struct hlist_node next ;
   struct pci_cap_saved_data cap ;
};
#line 243
struct pcie_link_state;
#line 243
struct pcie_link_state;
#line 244
struct pci_vpd;
#line 244
struct pci_vpd;
#line 245
struct pci_sriov;
#line 245
struct pci_sriov;
#line 246
struct pci_ats;
#line 246
struct pci_ats;
#line 251
struct pci_driver;
#line 251 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
union __anonunion____missing_field_name_229 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
#line 251 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   u8 msi_cap ;
   u8 msix_cap ;
   u8 pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   u8 dma_alias_devfn ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   u8 pm_cap ;
   unsigned int pme_support : 5 ;
   unsigned int pme_interrupt : 1 ;
   unsigned int pme_poll : 1 ;
   unsigned int d1_support : 1 ;
   unsigned int d2_support : 1 ;
   unsigned int no_d1d2 : 1 ;
   unsigned int no_d3cold : 1 ;
   unsigned int d3cold_allowed : 1 ;
   unsigned int mmio_always_on : 1 ;
   unsigned int wakeup_prepared : 1 ;
   unsigned int runtime_d3cold : 1 ;
   unsigned int ignore_hotplug : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[11] ;
   bool match_driver ;
   unsigned int transparent : 1 ;
   unsigned int multifunction : 1 ;
   unsigned int is_added : 1 ;
   unsigned int is_busmaster : 1 ;
   unsigned int no_msi : 1 ;
   unsigned int block_cfg_access : 1 ;
   unsigned int broken_parity_status : 1 ;
   unsigned int irq_reroute_variant : 2 ;
   unsigned int msi_enabled : 1 ;
   unsigned int msix_enabled : 1 ;
   unsigned int ari_enabled : 1 ;
   unsigned int is_managed : 1 ;
   unsigned int needs_freset : 1 ;
   unsigned int state_saved : 1 ;
   unsigned int is_physfn : 1 ;
   unsigned int is_virtfn : 1 ;
   unsigned int reset_fn : 1 ;
   unsigned int is_hotplug_bridge : 1 ;
   unsigned int __aer_firmware_first_valid : 1 ;
   unsigned int __aer_firmware_first : 1 ;
   unsigned int broken_intx_masking : 1 ;
   unsigned int io_window_1k : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[11] ;
   struct bin_attribute *res_attr_wc[11] ;
   struct list_head msi_list ;
   struct attribute_group  const  **msi_irq_groups ;
   struct pci_vpd *vpd ;
   union __anonunion____missing_field_name_229 __annonCompField43 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
   char *driver_override ;
};
#line 396 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
struct pci_host_bridge_window {
   struct list_head list ;
   struct resource *res ;
   resource_size_t offset ;
};
#line 402 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
struct pci_host_bridge {
   struct device dev ;
   struct pci_bus *bus ;
   struct list_head windows ;
   void (*release_fn)(struct pci_host_bridge * ) ;
   void *release_data ;
};
#line 432 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
struct pci_bus_resource {
   struct list_head list ;
   struct resource *res ;
   unsigned int flags ;
};
#line 440
struct pci_ops;
#line 440
struct msi_chip;
#line 440 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   struct msi_chip *msi ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned int is_added : 1 ;
};
#line 557 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
struct pci_ops {
   int (*read)(struct pci_bus *bus , unsigned int devfn , int where , int size , u32 *val ) ;
   int (*write)(struct pci_bus *bus , unsigned int devfn , int where , int size ,
                u32 val ) ;
};
#line 571 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
struct pci_bus_region {
   dma_addr_t start ;
   dma_addr_t end ;
};
#line 576 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 589 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
typedef unsigned int pci_ers_result_t;
#line 591
enum pci_ers_result {
    PCI_ERS_RESULT_NONE = 1,
    PCI_ERS_RESULT_CAN_RECOVER = 2,
    PCI_ERS_RESULT_NEED_RESET = 3,
    PCI_ERS_RESULT_DISCONNECT = 4,
    PCI_ERS_RESULT_RECOVERED = 5,
    PCI_ERS_RESULT_NO_AER_DRIVER = 6
} ;
#line 612 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev *dev , enum pci_channel_state error ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev *dev ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev *dev ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev *dev ) ;
   void (*reset_notify)(struct pci_dev *dev , bool prepare ) ;
   void (*resume)(struct pci_dev *dev ) ;
};
#line 634
struct module;
#line 635 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char const   *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev *dev , struct pci_device_id  const  *id ) ;
   void (*remove)(struct pci_dev *dev ) ;
   int (*suspend)(struct pci_dev *dev , pm_message_t state ) ;
   int (*suspend_late)(struct pci_dev *dev , pm_message_t state ) ;
   int (*resume_early)(struct pci_dev *dev ) ;
   int (*resume)(struct pci_dev *dev ) ;
   void (*shutdown)(struct pci_dev *dev ) ;
   int (*sriov_configure)(struct pci_dev *dev , int num_vfs ) ;
   struct pci_error_handlers  const  *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
#line 724
enum pcie_bus_config_types {
    PCIE_BUS_TUNE_OFF = 0,
    PCIE_BUS_SAFE = 1,
    PCIE_BUS_PERFORMANCE = 2,
    PCIE_BUS_PEER2PEER = 3
} ;
#line 812
enum pci_lost_interrupt_reason {
    PCI_LOST_IRQ_NO_INFORMATION = 0,
    PCI_LOST_IRQ_DISABLE_MSI = 1,
    PCI_LOST_IRQ_DISABLE_MSIX = 2,
    PCI_LOST_IRQ_DISABLE_ACPI = 3
} ;
#line 1002
struct pci_saved_state;
#line 6 "../../../analyzer/../bench/linux-headers/include/asm-generic/scatterlist.h"
struct scatterlist {
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 17 "../../../analyzer/../bench/linux-headers/include/linux/dmapool.h"
struct dma_pool;
#line 1174 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
enum pci_dma_burst_strategy {
    PCI_DMA_BURST_INFINITY = 0,
    PCI_DMA_BURST_BOUNDARY = 1,
    PCI_DMA_BURST_MULTIPLE = 2
} ;
#line 1183 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
struct msix_entry {
   u32 vector ;
   u16 entry ;
};
#line 1298 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
typedef int (*arch_set_vga_state_t)(struct pci_dev *pdev , bool decode , unsigned int command_bits ,
                                    u32 flags );
#line 8 "../../../analyzer/../bench/linux-headers/include/linux/debug_locks.h"
struct task_struct;
#line 48
struct task_struct;
#line 11 "../../../analyzer/../bench/linux-headers/include/linux/shrinker.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   nodemask_t nodes_to_scan ;
   int nid ;
};
#line 48 "../../../analyzer/../bench/linux-headers/include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control *sc ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control *sc ) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
#line 22 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
struct mempolicy;
#line 23
struct anon_vma;
#line 24
struct anon_vma_chain;
#line 24
struct anon_vma_chain;
#line 25
struct file_ra_state;
#line 25
struct file_ra_state;
#line 26
struct user_struct;
#line 27
struct writeback_control;
#line 27
struct writeback_control;
#line 42 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_64.h"
struct mm_struct;
#line 739 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
struct vm_area_struct;
#line 206 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};
#line 227 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct *area ) ;
   void (*close)(struct vm_area_struct *area ) ;
   int (*fault)(struct vm_area_struct *vma , struct vm_fault *vmf ) ;
   void (*map_pages)(struct vm_area_struct *vma , struct vm_fault *vmf ) ;
   int (*page_mkwrite)(struct vm_area_struct *vma , struct vm_fault *vmf ) ;
   int (*access)(struct vm_area_struct *vma , unsigned long addr , void *buf , int len ,
                 int write ) ;
   char const   *(*name)(struct vm_area_struct *vma ) ;
   int (*set_policy)(struct vm_area_struct *vma , struct mempolicy *new ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct *vma , unsigned long addr ) ;
   int (*migrate)(struct vm_area_struct *vma , nodemask_t const   *from , nodemask_t const   *to ,
                  unsigned long flags ) ;
   int (*remap_pages)(struct vm_area_struct *vma , unsigned long addr , unsigned long size ,
                      unsigned long pgoff ) ;
};
#line 278
struct mmu_gather;
#line 278
struct mmu_gather;
#line 279
struct inode;
#line 74 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
enum pageflags {
    PG_locked = 0,
    PG_error = 1,
    PG_referenced = 2,
    PG_uptodate = 3,
    PG_dirty = 4,
    PG_lru = 5,
    PG_active = 6,
    PG_slab = 7,
    PG_owner_priv_1 = 8,
    PG_arch_1 = 9,
    PG_reserved = 10,
    PG_private = 11,
    PG_private_2 = 12,
    PG_writeback = 13,
    PG_head = 14,
    PG_tail = 15,
    PG_swapcache = 16,
    PG_mappedtodisk = 17,
    PG_reclaim = 18,
    PG_swapbacked = 19,
    PG_unevictable = 20,
    PG_mlocked = 21,
    PG_uncached = 22,
    __NR_PAGEFLAGS = 23,
    PG_checked = 8,
    PG_fscache = 12,
    PG_pinned = 8,
    PG_savepinned = 4,
    PG_slob_free = 11
} ;
#line 204
struct page;
#line 37 "../../../analyzer/../bench/linux-headers/include/linux/huge_mm.h"
enum transparent_hugepage_flag {
    TRANSPARENT_HUGEPAGE_FLAG = 0,
    TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG = 1,
    TRANSPARENT_HUGEPAGE_DEFRAG_FLAG = 2,
    TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG = 3,
    TRANSPARENT_HUGEPAGE_DEFRAG_KHUGEPAGED_FLAG = 4,
    TRANSPARENT_HUGEPAGE_USE_ZERO_PAGE_FLAG = 5
} ;
#line 49
enum page_check_address_pmd_flag {
    PAGE_CHECK_ADDRESS_PMD_FLAG = 0,
    PAGE_CHECK_ADDRESS_PMD_NOTSPLITTING_FLAG = 1,
    PAGE_CHECK_ADDRESS_PMD_SPLITTING_FLAG = 2
} ;
#line 567 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
typedef void compound_page_dtor(struct page * );
#line 24 "../../../analyzer/../bench/linux-headers/include/linux/vm_event_item.h"
enum vm_event_item {
    PGPGIN = 0,
    PGPGOUT = 1,
    PSWPIN = 2,
    PSWPOUT = 3,
    PGALLOC_DMA = 4,
    PGALLOC_DMA32 = 5,
    PGALLOC_NORMAL = 6,
    PGALLOC_MOVABLE = 7,
    PGFREE = 8,
    PGACTIVATE = 9,
    PGDEACTIVATE = 10,
    PGFAULT = 11,
    PGMAJFAULT = 12,
    PGREFILL_DMA = 13,
    PGREFILL_DMA32 = 14,
    PGREFILL_NORMAL = 15,
    PGREFILL_MOVABLE = 16,
    PGSTEAL_KSWAPD_DMA = 17,
    PGSTEAL_KSWAPD_DMA32 = 18,
    PGSTEAL_KSWAPD_NORMAL = 19,
    PGSTEAL_KSWAPD_MOVABLE = 20,
    PGSTEAL_DIRECT_DMA = 21,
    PGSTEAL_DIRECT_DMA32 = 22,
    PGSTEAL_DIRECT_NORMAL = 23,
    PGSTEAL_DIRECT_MOVABLE = 24,
    PGSCAN_KSWAPD_DMA = 25,
    PGSCAN_KSWAPD_DMA32 = 26,
    PGSCAN_KSWAPD_NORMAL = 27,
    PGSCAN_KSWAPD_MOVABLE = 28,
    PGSCAN_DIRECT_DMA = 29,
    PGSCAN_DIRECT_DMA32 = 30,
    PGSCAN_DIRECT_NORMAL = 31,
    PGSCAN_DIRECT_MOVABLE = 32,
    PGSCAN_DIRECT_THROTTLE = 33,
    PGSCAN_ZONE_RECLAIM_FAILED = 34,
    PGINODESTEAL = 35,
    SLABS_SCANNED = 36,
    KSWAPD_INODESTEAL = 37,
    KSWAPD_LOW_WMARK_HIT_QUICKLY = 38,
    KSWAPD_HIGH_WMARK_HIT_QUICKLY = 39,
    PAGEOUTRUN = 40,
    ALLOCSTALL = 41,
    PGROTATED = 42,
    DROP_PAGECACHE = 43,
    DROP_SLAB = 44,
    PGMIGRATE_SUCCESS = 45,
    PGMIGRATE_FAIL = 46,
    COMPACTMIGRATE_SCANNED = 47,
    COMPACTFREE_SCANNED = 48,
    COMPACTISOLATED = 49,
    COMPACTSTALL = 50,
    COMPACTFAIL = 51,
    COMPACTSUCCESS = 52,
    HTLB_BUDDY_PGALLOC = 53,
    HTLB_BUDDY_PGALLOC_FAIL = 54,
    UNEVICTABLE_PGCULLED = 55,
    UNEVICTABLE_PGSCANNED = 56,
    UNEVICTABLE_PGRESCUED = 57,
    UNEVICTABLE_PGMLOCKED = 58,
    UNEVICTABLE_PGMUNLOCKED = 59,
    UNEVICTABLE_PGCLEARED = 60,
    UNEVICTABLE_PGSTRANDED = 61,
    NR_VM_EVENT_ITEMS = 62
} ;
#line 24 "../../../analyzer/../bench/linux-headers/include/linux/vmstat.h"
struct vm_event_state {
   unsigned long event[62] ;
};
#line 36 "../../../analyzer/../bench/linux-headers/include/linux/vmstat.h"
typedef unsigned long pao_T_____1;
#line 36 "../../../analyzer/../bench/linux-headers/include/linux/vmstat.h"
typedef unsigned long pao_T_____2;
#line 36 "../../../analyzer/../bench/linux-headers/include/linux/vmstat.h"
typedef unsigned long pao_T_____3;
#line 36 "../../../analyzer/../bench/linux-headers/include/linux/vmstat.h"
typedef unsigned long pao_T_____4;
#line 41 "../../../analyzer/../bench/linux-headers/include/linux/vmstat.h"
typedef unsigned long pao_T_____5;
#line 41 "../../../analyzer/../bench/linux-headers/include/linux/vmstat.h"
typedef unsigned long pao_T_____6;
#line 41 "../../../analyzer/../bench/linux-headers/include/linux/vmstat.h"
typedef unsigned long pao_T_____7;
#line 41 "../../../analyzer/../bench/linux-headers/include/linux/vmstat.h"
typedef unsigned long pao_T_____8;
#line 46 "../../../analyzer/../bench/linux-headers/include/linux/vmstat.h"
typedef unsigned long pao_T_____9;
#line 46 "../../../analyzer/../bench/linux-headers/include/linux/vmstat.h"
typedef unsigned long pao_T_____10;
#line 46 "../../../analyzer/../bench/linux-headers/include/linux/vmstat.h"
typedef unsigned long pao_T_____11;
#line 46 "../../../analyzer/../bench/linux-headers/include/linux/vmstat.h"
typedef unsigned long pao_T_____12;
#line 51 "../../../analyzer/../bench/linux-headers/include/linux/vmstat.h"
typedef unsigned long pao_T_____13;
#line 51 "../../../analyzer/../bench/linux-headers/include/linux/vmstat.h"
typedef unsigned long pao_T_____14;
#line 51 "../../../analyzer/../bench/linux-headers/include/linux/vmstat.h"
typedef unsigned long pao_T_____15;
#line 51 "../../../analyzer/../bench/linux-headers/include/linux/vmstat.h"
typedef unsigned long pao_T_____16;
#line 1084 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
struct zap_details {
   struct vm_area_struct *nonlinear_vma ;
   struct address_space *check_mapping ;
   unsigned long first_index ;
   unsigned long last_index ;
};
#line 1117 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
struct mm_walk {
   int (*pgd_entry)(pgd_t *pgd , unsigned long addr , unsigned long next , struct mm_walk *walk ) ;
   int (*pud_entry)(pud_t *pud , unsigned long addr , unsigned long next , struct mm_walk *walk ) ;
   int (*pmd_entry)(pmd_t *pmd , unsigned long addr , unsigned long next , struct mm_walk *walk ) ;
   int (*pte_entry)(pte_t *pte , unsigned long addr , unsigned long next , struct mm_walk *walk ) ;
   int (*pte_hole)(unsigned long addr , unsigned long next , struct mm_walk *walk ) ;
   int (*hugetlb_entry)(pte_t *pte , unsigned long hmask , unsigned long addr , unsigned long next ,
                        struct mm_walk *walk ) ;
   struct mm_struct *mm ;
   void *private ;
};
#line 1201
struct kvec;
#line 1201
struct kvec;
#line 1827 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
struct vm_unmapped_area_info {
   unsigned long flags ;
   unsigned long length ;
   unsigned long low_limit ;
   unsigned long high_limit ;
   unsigned long align_mask ;
   unsigned long align_offset ;
};
#line 1989 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
typedef int (*pte_fn_t)(pte_t *pte , pgtable_t token , unsigned long addr , void *data );
#line 2076
enum mf_flags {
    MF_COUNT_INCREASED = 1,
    MF_ACTION_REQUIRED = 2,
    MF_MUST_KILL = 4,
    MF_SOFT_OFFLINE = 8
} ;
#line 14 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pci.h"
struct pci_sysdata {
   int domain ;
   int node ;
   struct acpi_device *companion ;
   void *iommu ;
};
#line 71
struct irq_routing_table;
#line 98
struct msi_desc;
#line 13 "../../../analyzer/../bench/linux-headers/include/linux/dma-attrs.h"
enum dma_attr {
    DMA_ATTR_WRITE_BARRIER = 0,
    DMA_ATTR_WEAK_ORDERING = 1,
    DMA_ATTR_WRITE_COMBINE = 2,
    DMA_ATTR_NON_CONSISTENT = 3,
    DMA_ATTR_NO_KERNEL_MAPPING = 4,
    DMA_ATTR_SKIP_CPU_SYNC = 5,
    DMA_ATTR_FORCE_CONTIGUOUS = 6,
    DMA_ATTR_MAX = 7
} ;
#line 30 "../../../analyzer/../bench/linux-headers/include/linux/dma-attrs.h"
struct dma_attrs {
   unsigned long flags[((7UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
};
#line 7 "../../../analyzer/../bench/linux-headers/include/linux/dma-direction.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 12 "../../../analyzer/../bench/linux-headers/include/linux/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 229 "../../../analyzer/../bench/linux-headers/include/linux/scatterlist.h"
typedef struct scatterlist *sg_alloc_fn(unsigned int  , gfp_t  );
#line 230 "../../../analyzer/../bench/linux-headers/include/linux/scatterlist.h"
typedef void sg_free_fn(struct scatterlist * , unsigned int  );
#line 268 "../../../analyzer/../bench/linux-headers/include/linux/scatterlist.h"
struct sg_page_iter {
   struct scatterlist *sg ;
   unsigned int sg_pgoffset ;
   unsigned int __nents ;
   int __pg_advance ;
};
#line 332 "../../../analyzer/../bench/linux-headers/include/linux/scatterlist.h"
struct sg_mapping_iter {
   struct page *page ;
   void *addr ;
   size_t length ;
   size_t consumed ;
   struct sg_page_iter piter ;
   unsigned int __offset ;
   unsigned int __remaining ;
   unsigned int __flags ;
};
#line 17 "../../../analyzer/../bench/linux-headers/include/linux/dma-mapping.h"
struct dma_map_ops {
   void *(*alloc)(struct device *dev , size_t size , dma_addr_t *dma_handle , gfp_t gfp ,
                  struct dma_attrs *attrs ) ;
   void (*free)(struct device *dev , size_t size , void *vaddr , dma_addr_t dma_handle ,
                struct dma_attrs *attrs ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs *attrs ) ;
   int (*get_sgtable)(struct device *dev , struct sg_table *sgt , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs *attrs ) ;
   dma_addr_t (*map_page)(struct device *dev , struct page *page , unsigned long offset ,
                          size_t size , enum dma_data_direction dir , struct dma_attrs *attrs ) ;
   void (*unmap_page)(struct device *dev , dma_addr_t dma_handle , size_t size , enum dma_data_direction dir ,
                      struct dma_attrs *attrs ) ;
   int (*map_sg)(struct device *dev , struct scatterlist *sg , int nents , enum dma_data_direction dir ,
                 struct dma_attrs *attrs ) ;
   void (*unmap_sg)(struct device *dev , struct scatterlist *sg , int nents , enum dma_data_direction dir ,
                    struct dma_attrs *attrs ) ;
   void (*sync_single_for_cpu)(struct device *dev , dma_addr_t dma_handle , size_t size ,
                               enum dma_data_direction dir ) ;
   void (*sync_single_for_device)(struct device *dev , dma_addr_t dma_handle , size_t size ,
                                  enum dma_data_direction dir ) ;
   void (*sync_sg_for_cpu)(struct device *dev , struct scatterlist *sg , int nents ,
                           enum dma_data_direction dir ) ;
   void (*sync_sg_for_device)(struct device *dev , struct scatterlist *sg , int nents ,
                              enum dma_data_direction dir ) ;
   int (*mapping_error)(struct device *dev , dma_addr_t dma_addr ) ;
   int (*dma_supported)(struct device *dev , u64 mask ) ;
   int (*set_dma_mask)(struct device *dev , u64 mask ) ;
   int is_phys ;
};
#line 25 "../../../analyzer/../bench/linux-headers/include/linux/dma-debug.h"
struct device;
#line 26
struct scatterlist;
#line 27
struct bus_type;
#line 6 "../../../analyzer/../bench/linux-headers/include/linux/swiotlb.h"
struct device;
#line 7
struct dma_attrs;
#line 8
struct scatterlist;
#line 34
enum dma_sync_target {
    SYNC_FOR_CPU = 0,
    SYNC_FOR_DEVICE = 1
} ;
#line 58 "../../../analyzer/../bench/linux-headers/include/linux/dma-contiguous.h"
struct cma;
#line 58
struct cma;
#line 59
struct page;
#line 143 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pci.h"
struct pci_setup_rom {
   struct setup_data data ;
   uint16_t vendor ;
   uint16_t devid ;
   uint64_t pcilen ;
   unsigned long segment ;
   unsigned long bus ;
   unsigned long device ;
   unsigned long function ;
   uint8_t romdata[0] ;
};
#line 1472 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
struct pci_fixup {
   u16 vendor ;
   u16 device ;
   u32 class ;
   unsigned int class_shift ;
   void (*hook)(struct pci_dev *dev ) ;
};
#line 1480
enum pci_fixup_pass {
    pci_fixup_early = 0,
    pci_fixup_header = 1,
    pci_fixup_final = 2,
    pci_fixup_enable = 3,
    pci_fixup_resume = 4,
    pci_fixup_suspend = 5,
    pci_fixup_resume_early = 6,
    pci_fixup_suspend_late = 7
} ;
#line 33 "../../../analyzer/../bench/linux-headers/include/linux/list_bl.h"
struct hlist_bl_node;
#line 33 "../../../analyzer/../bench/linux-headers/include/linux/list_bl.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 37 "../../../analyzer/../bench/linux-headers/include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 24 "../../../analyzer/../bench/linux-headers/include/linux/lockref.h"
struct __anonstruct____missing_field_name_231 {
   spinlock_t lock ;
   unsigned int count ;
};
#line 24 "../../../analyzer/../bench/linux-headers/include/linux/lockref.h"
union __anonunion____missing_field_name_230 {
   __u64 __attribute__((__aligned__(8)))  lock_count ;
   struct __anonstruct____missing_field_name_231 __annonCompField44 ;
};
#line 24 "../../../analyzer/../bench/linux-headers/include/linux/lockref.h"
struct lockref {
   union __anonunion____missing_field_name_230 __annonCompField45 ;
};
#line 14 "../../../analyzer/../bench/linux-headers/include/linux/dcache.h"
struct nameidata;
#line 14
struct nameidata;
#line 15
struct path;
#line 15
struct path;
#line 16
struct vfsmount;
#line 16
struct vfsmount;
#line 45 "../../../analyzer/../bench/linux-headers/include/linux/dcache.h"
struct __anonstruct____missing_field_name_233 {
   u32 hash ;
   u32 len ;
};
#line 45 "../../../analyzer/../bench/linux-headers/include/linux/dcache.h"
union __anonunion____missing_field_name_232 {
   struct __anonstruct____missing_field_name_233 __annonCompField46 ;
   u64 hash_len ;
};
#line 45 "../../../analyzer/../bench/linux-headers/include/linux/dcache.h"
struct qstr {
   union __anonunion____missing_field_name_232 __annonCompField47 ;
   unsigned char const   *name ;
};
#line 60 "../../../analyzer/../bench/linux-headers/include/linux/dcache.h"
struct dentry_stat_t {
   long nr_dentry ;
   long nr_unused ;
   long age_limit ;
   long want_pages ;
   long dummy[2] ;
};
#line 109
struct dentry_operations;
#line 109 "../../../analyzer/../bench/linux-headers/include/linux/dcache.h"
union __anonunion_d_u_234 {
   struct list_head d_child ;
   struct callback_head d_rcu ;
};
#line 109 "../../../analyzer/../bench/linux-headers/include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   union __anonunion_d_u_234 d_u ;
   struct list_head d_subdirs ;
   struct hlist_node d_alias ;
};
#line 145
enum dentry_d_lock_class {
    DENTRY_D_LOCK_NORMAL = 0,
    DENTRY_D_LOCK_NESTED = 1
} ;
#line 151 "../../../analyzer/../bench/linux-headers/include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
} __attribute__((__aligned__((1) <<  (6) ))) ;
#line 4 "../../../analyzer/../bench/linux-headers/include/linux/path.h"
struct dentry;
#line 5
struct vfsmount;
#line 7 "../../../analyzer/../bench/linux-headers/include/linux/path.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 14 "../../../analyzer/../bench/linux-headers/include/linux/list_lru.h"
enum lru_status {
    LRU_REMOVED = 0,
    LRU_REMOVED_RETRY = 1,
    LRU_ROTATE = 2,
    LRU_SKIP = 3,
    LRU_RETRY = 4
} ;
#line 24 "../../../analyzer/../bench/linux-headers/include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_head list ;
   long nr_items ;
} __attribute__((__aligned__((1) <<  (6) ))) ;
#line 31 "../../../analyzer/../bench/linux-headers/include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   nodemask_t active_nodes ;
};
#line 95 "../../../analyzer/../bench/linux-headers/include/linux/list_lru.h"
typedef enum lru_status (*list_lru_walk_cb)(struct list_head *item , spinlock_t *lock ,
                                            void *cb_arg );
#line 87 "../../../analyzer/../bench/linux-headers/include/linux/radix-tree.h"
struct __anonstruct____missing_field_name_236 {
   struct radix_tree_node *parent ;
   void *private_data ;
};
#line 87 "../../../analyzer/../bench/linux-headers/include/linux/radix-tree.h"
union __anonunion____missing_field_name_235 {
   struct __anonstruct____missing_field_name_236 __annonCompField48 ;
   struct callback_head callback_head ;
};
#line 87 "../../../analyzer/../bench/linux-headers/include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion____missing_field_name_235 __annonCompField49 ;
   struct list_head private_list ;
   void *slots[1UL << 6] ;
   unsigned long tags[3][(((1UL << 6) + 64UL) - 1UL) / 64UL] ;
};
#line 107 "../../../analyzer/../bench/linux-headers/include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 323 "../../../analyzer/../bench/linux-headers/include/linux/radix-tree.h"
struct radix_tree_iter {
   unsigned long index ;
   unsigned long next_index ;
   unsigned long tags ;
};
#line 16 "../../../analyzer/../bench/linux-headers/include/linux/semaphore.h"
struct semaphore {
   raw_spinlock_t lock ;
   unsigned int count ;
   struct list_head wait_list ;
};
#line 16 "../../../analyzer/../bench/linux-headers/include/uapi/linux/fiemap.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3] ;
};
#line 27 "../../../analyzer/../bench/linux-headers/include/uapi/linux/fiemap.h"
struct fiemap {
   __u64 fm_start ;
   __u64 fm_length ;
   __u32 fm_flags ;
   __u32 fm_mapped_extents ;
   __u32 fm_extent_count ;
   __u32 fm_reserved ;
   struct fiemap_extent fm_extents[0] ;
};
#line 10 "../../../analyzer/../bench/linux-headers/include/linux/migrate_mode.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 10 "../../../analyzer/../bench/linux-headers/include/linux/percpu-rwsem.h"
struct percpu_rw_semaphore {
   unsigned int *fast_read_ctr ;
   atomic_t write_ctr ;
   struct rw_semaphore rw_sem ;
   atomic_t slow_read_ctr ;
   wait_queue_head_t write_waitq ;
};
#line 10 "../../../analyzer/../bench/linux-headers/include/linux/blk_types.h"
struct bio_set;
#line 10
struct bio_set;
#line 11
struct bio;
#line 11
struct bio;
#line 12
struct bio_integrity_payload;
#line 12
struct bio_integrity_payload;
#line 13
struct page;
#line 14
struct block_device;
#line 14
struct block_device;
#line 15
struct io_context;
#line 16
struct cgroup_subsys_state;
#line 16
struct cgroup_subsys_state;
#line 17 "../../../analyzer/../bench/linux-headers/include/linux/blk_types.h"
typedef void bio_end_io_t(struct bio * , int  );
#line 18 "../../../analyzer/../bench/linux-headers/include/linux/blk_types.h"
typedef void bio_destructor_t(struct bio * );
#line 23 "../../../analyzer/../bench/linux-headers/include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
#line 31 "../../../analyzer/../bench/linux-headers/include/linux/blk_types.h"
struct bvec_iter {
   sector_t bi_sector ;
   unsigned int bi_size ;
   unsigned int bi_idx ;
   unsigned int bi_bvec_done ;
};
#line 46 "../../../analyzer/../bench/linux-headers/include/linux/blk_types.h"
struct bio {
   struct bio *bi_next ;
   struct block_device *bi_bdev ;
   unsigned long bi_flags ;
   unsigned long bi_rw ;
   struct bvec_iter bi_iter ;
   unsigned int bi_phys_segments ;
   unsigned int bi_seg_front_size ;
   unsigned int bi_seg_back_size ;
   atomic_t bi_remaining ;
   bio_end_io_t *bi_end_io ;
   void *bi_private ;
   unsigned short bi_vcnt ;
   unsigned short bi_max_vecs ;
   atomic_t bi_cnt ;
   struct bio_vec *bi_io_vec ;
   struct bio_set *bi_pool ;
   struct bio_vec bi_inline_vecs[0] ;
};
#line 150
enum rq_flag_bits {
    __REQ_WRITE = 0,
    __REQ_FAILFAST_DEV = 1,
    __REQ_FAILFAST_TRANSPORT = 2,
    __REQ_FAILFAST_DRIVER = 3,
    __REQ_SYNC = 4,
    __REQ_META = 5,
    __REQ_PRIO = 6,
    __REQ_DISCARD = 7,
    __REQ_SECURE = 8,
    __REQ_WRITE_SAME = 9,
    __REQ_NOIDLE = 10,
    __REQ_FUA = 11,
    __REQ_FLUSH = 12,
    __REQ_RAHEAD = 13,
    __REQ_THROTTLED = 14,
    __REQ_SORTED = 15,
    __REQ_SOFTBARRIER = 16,
    __REQ_NOMERGE = 17,
    __REQ_STARTED = 18,
    __REQ_DONTPREP = 19,
    __REQ_QUEUED = 20,
    __REQ_ELVPRIV = 21,
    __REQ_FAILED = 22,
    __REQ_QUIET = 23,
    __REQ_PREEMPT = 24,
    __REQ_ALLOCED = 25,
    __REQ_COPY_USER = 26,
    __REQ_FLUSH_SEQ = 27,
    __REQ_IO_STAT = 28,
    __REQ_MIXED_MERGE = 29,
    __REQ_KERNEL = 30,
    __REQ_PM = 31,
    __REQ_END = 32,
    __REQ_HASHED = 33,
    __REQ_MQ_INFLIGHT = 34,
    __REQ_NR_BITS = 35
} ;
#line 41 "../../../analyzer/../bench/linux-headers/include/uapi/linux/fs.h"
struct fstrim_range {
   __u64 start ;
   __u64 len ;
   __u64 minlen ;
};
#line 48 "../../../analyzer/../bench/linux-headers/include/uapi/linux/fs.h"
struct files_stat_struct {
   unsigned long nr_files ;
   unsigned long nr_free_files ;
   unsigned long max_files ;
};
#line 54 "../../../analyzer/../bench/linux-headers/include/uapi/linux/fs.h"
struct inodes_stat_t {
   long nr_inodes ;
   long nr_unused ;
   long dummy[5] ;
};
#line 36 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
struct export_operations;
#line 36
struct export_operations;
#line 37
struct hd_geometry;
#line 37
struct hd_geometry;
#line 38
struct iovec;
#line 38
struct iovec;
#line 39
struct nameidata;
#line 40
struct kiocb;
#line 40
struct kiocb;
#line 41
struct kobject;
#line 42
struct pipe_inode_info;
#line 43
struct poll_table_struct;
#line 43
struct poll_table_struct;
#line 44
struct kstatfs;
#line 44
struct kstatfs;
#line 45
struct vm_area_struct;
#line 46
struct vfsmount;
#line 47
struct cred;
#line 48
struct swap_info_struct;
#line 48
struct swap_info_struct;
#line 49
struct seq_file;
#line 50
struct workqueue_struct;
#line 51
struct iov_iter;
#line 51
struct iov_iter;
#line 65
struct buffer_head;
#line 65
struct buffer_head;
#line 66 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
typedef int get_block_t(struct inode *inode , sector_t iblock , struct buffer_head *bh_result ,
                        int create );
#line 68 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
typedef void dio_iodone_t(struct kiocb *iocb , loff_t offset , ssize_t bytes , void *private );
#line 236 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 51 "../../../analyzer/../bench/linux-headers/include/uapi/linux/dqblk_xfs.h"
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8] ;
};
#line 51 "../../../analyzer/../bench/linux-headers/include/uapi/linux/dqblk_xfs.h"
typedef struct fs_disk_quota fs_disk_quota_t;
#line 147 "../../../analyzer/../bench/linux-headers/include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
#line 147 "../../../analyzer/../bench/linux-headers/include/uapi/linux/dqblk_xfs.h"
typedef struct fs_qfilestat fs_qfilestat_t;
#line 153 "../../../analyzer/../bench/linux-headers/include/uapi/linux/dqblk_xfs.h"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
#line 153 "../../../analyzer/../bench/linux-headers/include/uapi/linux/dqblk_xfs.h"
typedef struct fs_quota_stat fs_quota_stat_t;
#line 190 "../../../analyzer/../bench/linux-headers/include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestatv {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
   __u32 qfs_pad ;
};
#line 197 "../../../analyzer/../bench/linux-headers/include/uapi/linux/dqblk_xfs.h"
struct fs_quota_statv {
   __s8 qs_version ;
   __u8 qs_pad1 ;
   __u16 qs_flags ;
   __u32 qs_incoredqs ;
   struct fs_qfilestatv qs_uquota ;
   struct fs_qfilestatv qs_gquota ;
   struct fs_qfilestatv qs_pquota ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
   __u64 qs_pad2[8] ;
};
#line 17 "../../../analyzer/../bench/linux-headers/include/linux/dqblk_qtree.h"
struct dquot;
#line 17
struct dquot;
#line 20 "../../../analyzer/../bench/linux-headers/include/linux/dqblk_qtree.h"
struct qtree_fmt_operations {
   void (*mem2disk_dqblk)(void *disk , struct dquot *dquot ) ;
   void (*disk2mem_dqblk)(struct dquot *dquot , void *disk ) ;
   int (*is_id)(void *disk , struct dquot *dquot ) ;
};
#line 27 "../../../analyzer/../bench/linux-headers/include/linux/dqblk_qtree.h"
struct qtree_mem_dqinfo {
   struct super_block *dqi_sb ;
   int dqi_type ;
   unsigned int dqi_blocks ;
   unsigned int dqi_free_blk ;
   unsigned int dqi_free_entry ;
   unsigned int dqi_blocksize_bits ;
   unsigned int dqi_entry_size ;
   unsigned int dqi_usable_bs ;
   unsigned int dqi_qtree_depth ;
   struct qtree_fmt_operations *dqi_ops ;
};
#line 16 "../../../analyzer/../bench/linux-headers/include/linux/projid.h"
struct user_namespace;
#line 19 "../../../analyzer/../bench/linux-headers/include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 21 "../../../analyzer/../bench/linux-headers/include/linux/projid.h"
struct __anonstruct_kprojid_t_237 {
   projid_t val ;
};
#line 21 "../../../analyzer/../bench/linux-headers/include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_237 kprojid_t;
#line 88 "../../../analyzer/../bench/linux-headers/include/uapi/linux/quota.h"
enum __anonenum_238 {
    QIF_BLIMITS_B = 0,
    QIF_SPACE_B = 1,
    QIF_ILIMITS_B = 2,
    QIF_INODES_B = 3,
    QIF_BTIME_B = 4,
    QIF_ITIME_B = 5
} ;
#line 108 "../../../analyzer/../bench/linux-headers/include/uapi/linux/quota.h"
struct if_dqblk {
   __u64 dqb_bhardlimit ;
   __u64 dqb_bsoftlimit ;
   __u64 dqb_curspace ;
   __u64 dqb_ihardlimit ;
   __u64 dqb_isoftlimit ;
   __u64 dqb_curinodes ;
   __u64 dqb_btime ;
   __u64 dqb_itime ;
   __u32 dqb_valid ;
};
#line 129 "../../../analyzer/../bench/linux-headers/include/uapi/linux/quota.h"
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
#line 151
enum __anonenum_239 {
    QUOTA_NL_C_UNSPEC = 0,
    QUOTA_NL_C_WARNING = 1,
    __QUOTA_NL_C_MAX = 2
} ;
#line 158
enum __anonenum_240 {
    QUOTA_NL_A_UNSPEC = 0,
    QUOTA_NL_A_QTYPE = 1,
    QUOTA_NL_A_EXCESS_ID = 2,
    QUOTA_NL_A_WARNING = 3,
    QUOTA_NL_A_DEV_MAJOR = 4,
    QUOTA_NL_A_DEV_MINOR = 5,
    QUOTA_NL_A_CAUSED_ID = 6,
    __QUOTA_NL_A_MAX = 7
} ;
#line 53 "../../../analyzer/../bench/linux-headers/include/linux/quota.h"
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 59 "../../../analyzer/../bench/linux-headers/include/linux/quota.h"
typedef __kernel_uid32_t qid_t;
#line 60 "../../../analyzer/../bench/linux-headers/include/linux/quota.h"
typedef long long qsize_t;
#line 62 "../../../analyzer/../bench/linux-headers/include/linux/quota.h"
union __anonunion____missing_field_name_241 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 62 "../../../analyzer/../bench/linux-headers/include/linux/quota.h"
struct kqid {
   union __anonunion____missing_field_name_241 __annonCompField50 ;
   enum quota_type type ;
};
#line 189 "../../../analyzer/../bench/linux-headers/include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 204
struct quota_format_type;
#line 204
struct quota_format_type;
#line 206 "../../../analyzer/../bench/linux-headers/include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
#line 219
struct super_block;
#line 235
enum __anonenum_242 {
    DQST_LOOKUPS = 0,
    DQST_DROPS = 1,
    DQST_READS = 2,
    DQST_WRITES = 3,
    DQST_CACHE_HITS = 4,
    DQST_ALLOC_DQUOTS = 5,
    DQST_FREE_DQUOTS = 6,
    DQST_SYNCS = 7,
    _DQST_DQSTAT_LAST = 8
} ;
#line 247 "../../../analyzer/../bench/linux-headers/include/linux/quota.h"
struct dqstats {
   int stat[8] ;
   struct percpu_counter counter[8] ;
};
#line 277 "../../../analyzer/../bench/linux-headers/include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 293 "../../../analyzer/../bench/linux-headers/include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block *sb , int type ) ;
   int (*read_file_info)(struct super_block *sb , int type ) ;
   int (*write_file_info)(struct super_block *sb , int type ) ;
   int (*free_file_info)(struct super_block *sb , int type ) ;
   int (*read_dqblk)(struct dquot *dquot ) ;
   int (*commit_dqblk)(struct dquot *dquot ) ;
   int (*release_dqblk)(struct dquot *dquot ) ;
};
#line 304 "../../../analyzer/../bench/linux-headers/include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
};
#line 317
struct path;
#line 320 "../../../analyzer/../bench/linux-headers/include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_on_meta)(struct super_block * , int  , int  ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct fs_disk_quota * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct fs_disk_quota * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
   int (*get_xstatev)(struct super_block * , struct fs_quota_statv * ) ;
   int (*rm_xquota)(struct super_block * , unsigned int  ) ;
};
#line 335 "../../../analyzer/../bench/linux-headers/include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 343
enum __anonenum_243 {
    _DQUOT_USAGE_ENABLED = 0,
    _DQUOT_LIMITS_ENABLED = 1,
    _DQUOT_SUSPENDED = 2,
    _DQUOT_STATE_FLAGS = 3
} ;
#line 389 "../../../analyzer/../bench/linux-headers/include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[2] ;
   struct mem_dqinfo info[2] ;
   struct quota_format_ops  const  *ops[2] ;
};
#line 401 "../../../analyzer/../bench/linux-headers/include/linux/quota.h"
struct quota_module_name {
   int qm_fmt_id ;
   char *qm_mod_name ;
};
#line 285 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
enum positive_aop_returns {
    AOP_WRITEPAGE_ACTIVATE = 524288,
    AOP_TRUNCATED_PAGE = 524289
} ;
#line 299
struct page;
#line 300
struct address_space;
#line 301
struct writeback_control;
#line 312 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
union __anonunion_arg_245 {
   char *buf ;
   void *data ;
};
#line 312 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
struct __anonstruct_read_descriptor_t_244 {
   size_t written ;
   size_t count ;
   union __anonunion_arg_245 arg ;
   int error ;
};
#line 312 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
typedef struct __anonstruct_read_descriptor_t_244 read_descriptor_t;
#line 322 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
typedef int (*read_actor_t)(read_descriptor_t * , struct page * , unsigned long  ,
                            unsigned long  );
#line 325 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page *page , struct writeback_control *wbc ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page *page ) ;
   int (*readpages)(struct file *filp , struct address_space *mapping , struct list_head *pages ,
                    unsigned int nr_pages ) ;
   int (*write_begin)(struct file * , struct address_space *mapping , loff_t pos ,
                      unsigned int len , unsigned int flags , struct page **pagep ,
                      void **fsdata ) ;
   int (*write_end)(struct file * , struct address_space *mapping , loff_t pos , unsigned int len ,
                    unsigned int copied , struct page *page , void *fsdata ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iov_iter *iter , loff_t offset ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long  , int  , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , unsigned long  , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct *sis , struct file *file , sector_t *span ) ;
   void (*swap_deactivate)(struct file *file ) ;
};
#line 385
struct backing_dev_info;
#line 386 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   struct mutex i_mmap_mutex ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
} __attribute__((__aligned__(sizeof(long )))) ;
#line 410
struct request_queue;
#line 410
struct request_queue;
#line 412
struct hd_struct;
#line 412
struct gendisk;
#line 412 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 515
struct posix_acl;
#line 515
struct posix_acl;
#line 527
struct inode_operations;
#line 527 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
union __anonunion____missing_field_name_246 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 527 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
union __anonunion____missing_field_name_247 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 527
struct file_lock;
#line 527
struct cdev;
#line 527 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
union __anonunion____missing_field_name_248 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
#line 527 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion____missing_field_name_246 __annonCompField51 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion____missing_field_name_247 __annonCompField52 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   struct file_operations  const  *i_fop ;
   struct file_lock *i_flock ;
   struct address_space i_data ;
   struct dquot *i_dquot[2] ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_248 __annonCompField53 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};
#line 637
enum inode_i_mutex_lock_class {
    I_MUTEX_NORMAL = 0,
    I_MUTEX_PARENT = 1,
    I_MUTEX_CHILD = 2,
    I_MUTEX_XATTR = 3,
    I_MUTEX_NONDIR2 = 4
} ;
#line 741 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 752 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 772 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
union __anonunion_f_u_249 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
#line 772 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
struct file {
   union __anonunion_f_u_249 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
} __attribute__((__aligned__(4))) ;
#line 811 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
struct file_handle {
   __u32 handle_bytes ;
   int handle_type ;
   unsigned char f_handle[0] ;
};
#line 861 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
typedef void *fl_owner_t;
#line 863 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 868 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , struct file_lock * , int  ) ;
   void (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock ** , int  ) ;
};
#line 877 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
struct lock_manager {
   struct list_head list ;
};
#line 881
struct net;
#line 881
struct net;
#line 4 "../../../analyzer/../bench/linux-headers/include/linux/nfs_fs_i.h"
struct nlm_lockowner;
#line 4
struct nlm_lockowner;
#line 9 "../../../analyzer/../bench/linux-headers/include/linux/nfs_fs_i.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 15
struct nfs4_lock_state;
#line 15
struct nfs4_lock_state;
#line 16 "../../../analyzer/../bench/linux-headers/include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 907 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
struct fasync_struct;
#line 907 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
struct __anonstruct_afs_251 {
   struct list_head link ;
   int state ;
};
#line 907 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
union __anonunion_fl_u_250 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_251 afs ;
};
#line 907 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_250 fl_u ;
};
#line 155 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/fcntl.h"
struct f_owner_ex {
   int type ;
   __kernel_pid_t pid ;
};
#line 195 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __kernel_off_t l_start ;
   __kernel_off_t l_len ;
   __kernel_pid_t l_pid ;
};
#line 210 "../../../analyzer/../bench/linux-headers/include/uapi/asm-generic/fcntl.h"
struct flock64 {
   short l_type ;
   short l_whence ;
   __kernel_loff_t l_start ;
   __kernel_loff_t l_len ;
   __kernel_pid_t l_pid ;
};
#line 1133 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1160
struct mm_struct;
#line 1176
enum __anonenum_252 {
    SB_UNFROZEN = 0,
    SB_FREEZE_WRITE = 1,
    SB_FREEZE_PAGEFAULT = 2,
    SB_FREEZE_FS = 3,
    SB_FREEZE_COMPLETE = 4
} ;
#line 1187 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
};
#line 1200
struct super_operations;
#line 1200
struct xattr_handler;
#line 1200
struct mtd_info;
#line 1200 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32] ;
   u8 s_uuid[16] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru  __attribute__((__aligned__((1) <<  (6) ))) ;
   struct list_lru s_inode_lru  __attribute__((__aligned__((1) <<  (6) ))) ;
   struct callback_head rcu ;
};
#line 1433 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1466 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
typedef int (*filldir_t)(void * , char const   * , int  , loff_t  , u64  , unsigned int  );
#line 1467 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
struct dir_context {
   int (* const  actor)(void * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
#line 1472
struct block_device_operations;
#line 1472
struct block_device_operations;
#line 1480
struct iov_iter;
#line 1482 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   ssize_t (*read_iter)(struct kiocb * , struct iov_iter * ) ;
   ssize_t (*write_iter)(struct kiocb * , struct iov_iter * ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t id ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int datasync ) ;
   int (*aio_fsync)(struct kiocb * , int datasync ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** ) ;
   long (*fallocate)(struct file *file , int mode , loff_t offset , loff_t len ) ;
   int (*show_fdinfo)(struct seq_file *m , struct file *f ) ;
};
#line 1515 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*rename2)(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                  unsigned int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount *mnt , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64 start , u64 len ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int open_flag ,
                      umode_t create_mode , int *opened ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int  ) ;
} __attribute__((__aligned__((1) <<  (6) ))) ;
#line 1563 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block *sb ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int flags ) ;
   int (*write_inode)(struct inode * , struct writeback_control *wbc ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block *sb , int wait ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , int  ) ;
   long (*free_cached_objects)(struct super_block * , long  , int  ) ;
};
#line 1759
enum file_time_flags {
    S_ATIME = 1,
    S_MTIME = 2,
    S_CTIME = 4,
    S_VERSION = 8
} ;
#line 1776 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 2041
struct audit_names;
#line 2041
struct audit_names;
#line 2042 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
struct filename {
   char const   *name ;
   char const   *uptr ;
   struct audit_names *aname ;
   bool separate ;
};
#line 2066
enum __anonenum_253 {
    FILE_CREATED = 1,
    FILE_OPENED = 2
} ;
#line 2501 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
typedef void dio_submit_t(int rw , struct bio *bio , struct inode *inode , loff_t file_offset );
#line 2504
enum __anonenum_254 {
    DIO_LOCKING = 1,
    DIO_SKIP_HOLES = 2,
    DIO_ASYNC_EXTEND = 4
} ;
#line 2620 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
struct tree_descr {
   char *name ;
   struct file_operations  const  *ops ;
   int mode ;
};
#line 2674 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
struct simple_transaction_argresp {
   ssize_t size ;
   char data[0] ;
};
#line 2735
struct ctl_table;
#line 33 "applicom.h"
struct mailbox {
   u16 stjb_codef ;
   s16 stjb_status ;
   u16 stjb_ticuser_root ;
   u8 stjb_piduser[4] ;
   u16 stjb_mode ;
   u16 stjb_time ;
   u16 stjb_stop ;
   u16 stjb_nfonc ;
   u16 stjb_ncard ;
   u16 stjb_nchan ;
   u16 stjb_nes ;
   u16 stjb_nb ;
   u16 stjb_typvar ;
   u32 stjb_adr ;
   u16 stjb_ticuser_dispcyc ;
   u16 stjb_ticuser_protocol ;
   u8 stjb_filler[12] ;
   u8 stjb_data[256] ;
};
#line 54 "applicom.h"
struct st_ram_io {
   unsigned char data_to_pc_ready ;
   unsigned char tic_owner_to_pc ;
   unsigned char numcard_owner_to_pc ;
   unsigned char tic_des_to_pc ;
   unsigned char numcard_des_to_pc ;
   unsigned char data_from_pc_ready ;
   unsigned char tic_owner_from_pc ;
   unsigned char numcard_owner_from_pc ;
   unsigned char tic_des_from_pc ;
   unsigned char numcard_des_from_pc ;
   unsigned char ack_to_pc_ready ;
   unsigned char tic_ack_to_pc ;
   unsigned char numcard_ack_to_pc ;
   unsigned char typ_ack_to_pc ;
   unsigned char ack_from_pc_ready ;
   unsigned char tic_ack_from_pc ;
   unsigned char numcard_ack_from_pc ;
   unsigned char typ_ack_from_pc ;
   unsigned char conf_end_test[4] ;
   unsigned char error_code[2] ;
   unsigned char parameter_error[4] ;
   unsigned char time_base ;
   unsigned char nul_inc ;
   unsigned char vers ;
   unsigned char num_card ;
   unsigned char reserv1[32] ;
};
#line 86 "applicom.c"
struct applicom_board {
   unsigned long PhysIO ;
   void *RamIO ;
   wait_queue_head_t FlagSleepSend ;
   long irq ;
   spinlock_t mutex ;
};
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
/* compiler builtin: 
   double __builtin_huge_val(void) ;  */
/* compiler builtin: 
   int __builtin_clzl(unsigned long  ) ;  */
/* compiler builtin: 
   float __builtin_frexpf(float  , int * ) ;  */
/* compiler builtin: 
   long double __builtin_fmodl(long double  ) ;  */
/* compiler builtin: 
   double __builtin_atan(double  ) ;  */
/* compiler builtin: 
   int __builtin___fprintf_chk(void * , int  , char const   *  , ...) ;  */
/* compiler builtin: 
   float __builtin_ceilf(float  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_and_and_fetch(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_or(...) ;  */
/* compiler builtin: 
   void __builtin_return(void const   * ) ;  */
/* compiler builtin: 
   int __builtin_popcountll(unsigned long long  ) ;  */
/* compiler builtin: 
   long double __builtin_asinl(long double  ) ;  */
/* compiler builtin: 
   float __builtin_atanf(float  ) ;  */
/* compiler builtin: 
   int __builtin_ffsll(unsigned long long  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_addps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   unsigned long __builtin_strcspn(char const   * , char const   * ) ;  */
/* compiler builtin: 
   float __builtin_asinf(float  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_maxps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_unpckhps(float __attribute__((____vector_size____(16)))   ,
                                                                           float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   double __builtin_acos(double  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
/* compiler builtin: 
   double __builtin_powi(double  , int  ) ;  */
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
/* compiler builtin: 
   char *__builtin___strncat_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_huge_vall(void) ;  */
/* compiler builtin: 
   int __builtin_ffsl(unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin___vprintf_chk(int  , char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_unpcklps(float __attribute__((____vector_size____(16)))   ,
                                                                           float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   char *__builtin_strncat(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin_ctzll(unsigned long long  ) ;  */
/* compiler builtin: 
   double __builtin_cosh(double  ) ;  */
/* compiler builtin: 
   void __builtin_stdarg_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   float __builtin_tanhf(float  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_xor(...) ;  */
/* compiler builtin: 
   void *__builtin_mempcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_frexpl(long double  , int * ) ;  */
/* compiler builtin: 
   float __builtin_tanf(float  ) ;  */
/* compiler builtin: 
   long double __builtin_logl(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_sqrtl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_parity(unsigned int  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   long double __builtin_coshl(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_cosl(long double  ) ;  */
/* compiler builtin: 
   float __builtin_cosf(float  ) ;  */
/* compiler builtin: 
   int __builtin___printf_chk(int  , char const   *  , ...) ;  */
/* compiler builtin: 
   void __sync_synchronize(...) ;  */
/* compiler builtin: 
   long double __builtin_acosl(long double  ) ;  */
/* compiler builtin: 
   int __builtin___vfprintf_chk(void * , int  , char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   void *__builtin___mempcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_or_and_fetch(...) ;  */
/* compiler builtin: 
   void __builtin_prefetch(void const   *  , ...) ;  */
/* compiler builtin: 
   long double __builtin_nansl(char const   * ) ;  */
/* compiler builtin: 
   double __builtin_fmod(double  ) ;  */
/* compiler builtin: 
   int __builtin_clz(unsigned int  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_val_compare_and_swap(...) ;  */
/* compiler builtin: 
   double __builtin_log10(double  ) ;  */
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_tanh(double  ) ;  */
/* compiler builtin: 
   float __builtin_modff(float  , float * ) ;  */
/* compiler builtin: 
   double __builtin_sin(double  ) ;  */
/* compiler builtin: 
   double __builtin_frexp(double  , int * ) ;  */
/* compiler builtin: 
   float __builtin_acosf(float  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_add_and_fetch(...) ;  */
/* compiler builtin: 
   long double __builtin_sinhl(long double  ) ;  */
/* compiler builtin: 
   char *__builtin___stpcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_ldexpl(long double  , int  ) ;  */
/* compiler builtin: 
   double __builtin_fabs(double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_nand(...) ;  */
/* compiler builtin: 
   void *__builtin_apply(void (*)() , void * , unsigned long  ) ;  */
/* compiler builtin: 
   float __builtin_sinf(float  ) ;  */
/* compiler builtin: 
   double __builtin_ceil(double  ) ;  */
/* compiler builtin: 
   long double __builtin_powil(long double  , int  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   long double __builtin_expl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_constant_p(int  ) ;  */
/* compiler builtin: 
   double __builtin_log(double  ) ;  */
/* compiler builtin: 
   float __builtin_expf(float  ) ;  */
/* compiler builtin: 
   int __builtin_types_compatible_p(unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin_ctz(unsigned int  ) ;  */
/* compiler builtin: 
   long double __builtin_atan2l(long double  , long double  ) ;  */
/* compiler builtin: 
   void *__builtin_apply_args(void) ;  */
/* compiler builtin: 
   char *__builtin_strpbrk(char const   * , char const   * ) ;  */
/* compiler builtin: 
   char *__builtin_strcpy(char * , char const   * ) ;  */
/* compiler builtin: 
   double __builtin_sqrt(double  ) ;  */
/* compiler builtin: 
   __builtin_va_list __builtin_next_arg(void) ;  */
/* compiler builtin: 
   float __builtin_logf(float  ) ;  */
/* compiler builtin: 
   float __builtin_log10f(float  ) ;  */
/* compiler builtin: 
   long double __builtin_fabsl(long double  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_strlen(char const   * ) ;  */
/* compiler builtin: 
   long double __builtin_floorl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_ffs(unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_inf(void) ;  */
/* compiler builtin: 
   float __builtin_floorf(float  ) ;  */
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_sub_and_fetch(...) ;  */
/* compiler builtin: 
   int __builtin_parityl(unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_nand_and_fetch(...) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_subps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_lock_test_and_set(...) ;  */
/* compiler builtin: 
   unsigned long __builtin_strspn(char const   * , char const   * ) ;  */
/* compiler builtin: 
   void __builtin_varargs_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   int __builtin_parityll(unsigned long long  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_bzero(void * , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin_strncmp(char const   * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_nan(char const   * ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_xor_and_fetch(...) ;  */
/* compiler builtin: 
   int __builtin___vsprintf_chk(char * , int  , unsigned long  , char const   * ,
                                __builtin_va_list  ) ;  */
/* compiler builtin: 
   int __builtin___snprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                char const   *  , ...) ;  */
/* compiler builtin: 
   float __builtin_sqrtf(float  ) ;  */
/* compiler builtin: 
   double __builtin_nans(char const   * ) ;  */
/* compiler builtin: 
   long double __builtin_atanl(long double  ) ;  */
/* compiler builtin: 
   double __builtin_exp(double  ) ;  */
/* compiler builtin: 
   int __builtin_clzll(unsigned long long  ) ;  */
/* compiler builtin: 
   float __builtin_huge_valf(void) ;  */
/* compiler builtin: 
   float __builtin_coshf(float  ) ;  */
/* compiler builtin: 
   float __builtin_nansf(char const   * ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_add(...) ;  */
/* compiler builtin: 
   int __builtin___vsnprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                 char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __builtin_nanf(char const   * ) ;  */
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
/* compiler builtin: 
   _Bool __sync_bool_compare_and_swap(...) ;  */
/* compiler builtin: 
   float __builtin_ldexpf(float  , int  ) ;  */
/* compiler builtin: 
   double __builtin_atan2(double  , double  ) ;  */
/* compiler builtin: 
   int __builtin_popcountl(unsigned long  ) ;  */
/* compiler builtin: 
   float __builtin_powif(float  , int  ) ;  */
/* compiler builtin: 
   long double __builtin_ceill(long double  ) ;  */
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_log10l(long double  ) ;  */
/* compiler builtin: 
   void *__builtin___memmove_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_and(...) ;  */
/* compiler builtin: 
   void *__builtin_return_address(unsigned int  ) ;  */
/* compiler builtin: 
   float __builtin_fabsf(float  ) ;  */
/* compiler builtin: 
   double __builtin_floor(double  ) ;  */
/* compiler builtin: 
   double __builtin_cos(double  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_sub(...) ;  */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* compiler builtin: 
   void *__builtin_memset(void * , int  , int  ) ;  */
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_nanl(char const   * ) ;  */
/* compiler builtin: 
   float __builtin_atan2f(float  , float  ) ;  */
/* compiler builtin: 
   int __builtin_popcount(unsigned int  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack_len(void) ;  */
/* compiler builtin: 
   long double __builtin_tanl(long double  ) ;  */
/* compiler builtin: 
   double __builtin_sinh(double  ) ;  */
/* compiler builtin: 
   void __builtin_bcopy(void const   * , void * , unsigned long  ) ;  */
/* compiler builtin: 
   void __sync_lock_release(...) ;  */
/* compiler builtin: 
   long double __builtin_modfl(long double  , long double * ) ;  */
/* compiler builtin: 
   char *__builtin_stpcpy(char * , char const   * ) ;  */
/* compiler builtin: 
   long double __builtin_sinl(long double  ) ;  */
/* compiler builtin: 
   double __builtin_asin(double  ) ;  */
/* compiler builtin: 
   float __builtin_sinhf(float  ) ;  */
/* compiler builtin: 
   int __builtin_ctzl(unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_tanhl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_bswap32(int  ) ;  */
/* compiler builtin: 
   double __builtin_ldexp(double  , int  ) ;  */
/* compiler builtin: 
   long double __builtin_infl(void) ;  */
/* compiler builtin: 
   long __builtin_bswap64(long  ) ;  */
/* compiler builtin: 
   float __builtin_fmodf(float  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_mulps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   double __builtin_tan(double  ) ;  */
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   float __builtin_inff(void) ;  */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   void *__builtin_frame_address(unsigned int  ) ;  */
#line 33 "../../../analyzer/../bench/linux-headers/include/linux/export.h"
extern struct module __this_module ;
#line 24 "../../../analyzer/../bench/linux-headers/include/linux/bitops.h"
extern unsigned int __sw_hweight8(unsigned int w ) ;
#line 25
extern unsigned int __sw_hweight16(unsigned int w ) ;
#line 26
extern unsigned int __sw_hweight32(unsigned int w ) ;
#line 27
extern unsigned long __sw_hweight64(__u64 w ) ;
#line 216 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/segment.h"
extern char const   early_idt_handlers[32][9] ;
#line 267
__inline static unsigned long get_limit(unsigned long segment )  __attribute__((__no_instrument_function__)) ;
#line 267 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/segment.h"
__inline static unsigned long get_limit(unsigned long segment ) 
{ 
  unsigned long __limit ;

  {
  {
#line 270
  __asm__  ("lsll %1,%0": "=r" (__limit): "r" (segment));
  }
#line 271
  return (__limit + 1UL);
}
}
#line 49 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/page_types.h"
extern int devmem_is_allowed(unsigned long pagenr ) ;
#line 51
extern unsigned long max_low_pfn_mapped ;
#line 52
extern unsigned long max_pfn_mapped ;
#line 54
__inline static phys_addr_t get_max_mapped(void)  __attribute__((__no_instrument_function__)) ;
#line 54 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/page_types.h"
__inline static phys_addr_t get_max_mapped(void) 
{ 


  {
#line 56
  return ((phys_addr_t )max_pfn_mapped << 12);
}
}
#line 59
extern bool pfn_range_is_mapped(unsigned long start_pfn , unsigned long end_pfn ) ;
#line 61
extern unsigned long init_memory_mapping(unsigned long start , unsigned long end ) ;
#line 64
extern void initmem_init(void) ;
#line 70 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/ptrace.h"
extern unsigned long profile_pc(struct pt_regs *regs ) ;
#line 73
extern unsigned long convert_ip_to_linear(struct task_struct *child , struct pt_regs *regs ) ;
#line 75
extern void send_sigtrap(struct task_struct *tsk , struct pt_regs *regs , int error_code ,
                         int si_code ) ;
#line 78
extern long syscall_trace_enter(struct pt_regs * ) ;
#line 79
extern void syscall_trace_leave(struct pt_regs * ) ;
#line 81
__inline static unsigned long regs_return_value(struct pt_regs *regs )  __attribute__((__no_instrument_function__)) ;
#line 81 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/ptrace.h"
__inline static unsigned long regs_return_value(struct pt_regs *regs ) 
{ 


  {
#line 83
  return (regs->ax);
}
}
#line 93
__inline static int user_mode(struct pt_regs *regs )  __attribute__((__no_instrument_function__)) ;
#line 93 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/ptrace.h"
__inline static int user_mode(struct pt_regs *regs ) 
{ 


  {
#line 98
  return (! (! (regs->cs & 3UL)));
}
}
#line 102
__inline static int user_mode_vm(struct pt_regs *regs )  __attribute__((__no_instrument_function__)) ;
#line 102 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/ptrace.h"
__inline static int user_mode_vm(struct pt_regs *regs ) 
{ 
  int tmp ;

  {
  {
#line 108
  tmp = user_mode(regs);
  }
#line 108
  return (tmp);
}
}
#line 112
__inline static int v8086_mode(struct pt_regs *regs )  __attribute__((__no_instrument_function__)) ;
#line 112 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/ptrace.h"
__inline static int v8086_mode(struct pt_regs *regs ) 
{ 


  {
#line 117
  return (0);
}
}
#line 122
__inline static bool user_64bit_mode(struct pt_regs *regs )  __attribute__((__no_instrument_function__)) ;
#line 122 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/ptrace.h"
__inline static bool user_64bit_mode(struct pt_regs *regs ) 
{ 


  {
#line 129
  return ((bool )(regs->cs == 51UL));
}
}
#line 147
__inline static unsigned long kernel_stack_pointer(struct pt_regs *regs )  __attribute__((__no_instrument_function__)) ;
#line 147 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/ptrace.h"
__inline static unsigned long kernel_stack_pointer(struct pt_regs *regs ) 
{ 


  {
#line 149
  return (regs->sp);
}
}
#line 22 "../../../analyzer/../bench/linux-headers/include/asm-generic/ptrace.h"
__inline static unsigned long instruction_pointer(struct pt_regs *regs )  __attribute__((__no_instrument_function__)) ;
#line 22 "../../../analyzer/../bench/linux-headers/include/asm-generic/ptrace.h"
__inline static unsigned long instruction_pointer(struct pt_regs *regs ) 
{ 


  {
#line 24
  return (regs->ip);
}
}
#line 26
__inline static void instruction_pointer_set(struct pt_regs *regs , unsigned long val )  __attribute__((__no_instrument_function__)) ;
#line 26 "../../../analyzer/../bench/linux-headers/include/asm-generic/ptrace.h"
__inline static void instruction_pointer_set(struct pt_regs *regs , unsigned long val ) 
{ 


  {
  {
#line 29
  regs->ip = val;
  }
#line 30
  return;
}
}
#line 44
__inline static unsigned long user_stack_pointer(struct pt_regs *regs )  __attribute__((__no_instrument_function__)) ;
#line 44 "../../../analyzer/../bench/linux-headers/include/asm-generic/ptrace.h"
__inline static unsigned long user_stack_pointer(struct pt_regs *regs ) 
{ 


  {
#line 46
  return (regs->sp);
}
}
#line 48
__inline static void user_stack_pointer_set(struct pt_regs *regs , unsigned long val )  __attribute__((__no_instrument_function__)) ;
#line 48 "../../../analyzer/../bench/linux-headers/include/asm-generic/ptrace.h"
__inline static void user_stack_pointer_set(struct pt_regs *regs , unsigned long val ) 
{ 


  {
  {
#line 51
  regs->sp = val;
  }
#line 52
  return;
}
}
#line 62
__inline static unsigned long frame_pointer(struct pt_regs *regs )  __attribute__((__no_instrument_function__)) ;
#line 62 "../../../analyzer/../bench/linux-headers/include/asm-generic/ptrace.h"
__inline static unsigned long frame_pointer(struct pt_regs *regs ) 
{ 


  {
#line 64
  return (regs->bp);
}
}
#line 66
__inline static void frame_pointer_set(struct pt_regs *regs , unsigned long val )  __attribute__((__no_instrument_function__)) ;
#line 66 "../../../analyzer/../bench/linux-headers/include/asm-generic/ptrace.h"
__inline static void frame_pointer_set(struct pt_regs *regs , unsigned long val ) 
{ 


  {
  {
#line 69
  regs->bp = val;
  }
#line 70
  return;
}
}
#line 160 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/ptrace.h"
extern int regs_query_register_offset(char const   *name ) ;
#line 161
extern char const   *regs_query_register_name(unsigned int offset ) ;
#line 173
__inline static unsigned long regs_get_register(struct pt_regs *regs , unsigned int offset )  __attribute__((__no_instrument_function__)) ;
#line 173 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/ptrace.h"
__inline static unsigned long regs_get_register(struct pt_regs *regs , unsigned int offset ) 
{ 
  long tmp ;

  {
  {
#line 176
  tmp = __builtin_expect((long )(! (! ((unsigned long )offset > (unsigned long )(& ((struct pt_regs *)0)->ss)))),
                         0L);
  }
#line 176
  if (tmp) {
#line 177
    return (0UL);
  }
#line 187
  return (*((unsigned long *)((unsigned long )regs + (unsigned long )offset)));
}
}
#line 198
__inline static int regs_within_kernel_stack(struct pt_regs *regs , unsigned long addr )  __attribute__((__no_instrument_function__)) ;
#line 198 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/ptrace.h"
__inline static int regs_within_kernel_stack(struct pt_regs *regs , unsigned long addr ) 
{ 
  unsigned long tmp ;

  {
  {
#line 201
  tmp = kernel_stack_pointer(regs);
  }
#line 201
  return ((addr & ~ (((1UL << 12) << 2) - 1UL)) == (tmp & ~ (((1UL << 12) << 2) - 1UL)));
}
}
#line 214
__inline static unsigned long regs_get_kernel_stack_nth(struct pt_regs *regs , unsigned int n )  __attribute__((__no_instrument_function__)) ;
#line 214 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/ptrace.h"
__inline static unsigned long regs_get_kernel_stack_nth(struct pt_regs *regs , unsigned int n ) 
{ 
  unsigned long *addr ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
#line 217
  tmp = kernel_stack_pointer(regs);
#line 217
  addr = (unsigned long *)tmp;
#line 218
  addr += n;
#line 219
  tmp___0 = regs_within_kernel_stack(regs, (unsigned long )addr);
  }
#line 219
  if (tmp___0) {
#line 220
    return (*addr);
  } else {
#line 222
    return (0UL);
  }
}
}
#line 251
extern int do_get_thread_area(struct task_struct *p , int idx , struct user_desc *info ) ;
#line 253
extern int do_set_thread_area(struct task_struct *p , int idx , struct user_desc *info ,
                              int can_allocate ) ;
#line 54 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/alternative.h"
extern void alternative_instructions(void) ;
#line 55
extern void apply_alternatives(struct alt_instr *start , struct alt_instr *end ) ;
#line 60
extern void alternatives_smp_module_add(struct module *mod , char *name , void *locks ,
                                        void *locks_end , void *text , void *text_end ) ;
#line 63
extern void alternatives_smp_module_del(struct module *mod ) ;
#line 64
extern void alternatives_enable_smp(void) ;
#line 65
extern int alternatives_text_reserved(void *start , void *end ) ;
#line 66
extern bool skip_smp_alternatives ;
#line 253 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/cpufeature.h"
extern char const   * const  x86_cap_flags[352] ;
#line 254
extern char const   * const  x86_power_flags[32] ;
#line 260
extern char const   * const  x86_bug_flags[32] ;
#line 376
extern void warn_pre_alternatives(void) ;
#line 377
extern bool __static_cpu_has_safe(u16 bit ) ;
#line 384
__inline static bool __attribute__((__pure__))  ( __attribute__((__always_inline__)) __static_cpu_has)(u16 bit )  __attribute__((__no_instrument_function__)) ;
#line 384 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/cpufeature.h"
__inline static bool __attribute__((__pure__))  ( __attribute__((__always_inline__)) __static_cpu_has)(u16 bit ) 
{ 
  u8 flag ;

  {
  {
#line 433
  __asm__  volatile   ("1: movb $0,%0\n"
                       "2:\n"
                       ".section .altinstructions,\"a\"\n"
                       " .long 1b - .\n"
                       " .long 3f - .\n"
                       " .word %P1\n"
                       " .byte 2b - 1b\n"
                       " .byte 4f - 3f\n"
                       ".previous\n"
                       ".section .discard,\"aw\",@progbits\n"
                       " .byte 0xff + (4f-3f) - (2b-1b)\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "3: movb $1,%0\n"
                       "4:\n"
                       ".previous\n": "=qm" (flag): "i" (bit));
  }
#line 450
  return ((bool __attribute__((__pure__))  )flag);
}
}
#line 464
__inline static bool __attribute__((__pure__))  ( __attribute__((__always_inline__)) _static_cpu_has_safe)(u16 bit )  __attribute__((__no_instrument_function__)) ;
#line 464 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/cpufeature.h"
__inline static bool __attribute__((__pure__))  ( __attribute__((__always_inline__)) _static_cpu_has_safe)(u16 bit ) 
{ 
  u8 flag ;
  bool tmp ;
  int tmp___0 ;

  {
  {
#line 503
  __asm__  volatile   ("1: movb $2,%0\n"
                       "2:\n"
                       ".section .altinstructions,\"a\"\n"
                       " .long 1b - .\n"
                       " .long 3f - .\n"
                       " .word %P2\n"
                       " .byte 2b - 1b\n"
                       " .byte 4f - 3f\n"
                       ".previous\n"
                       ".section .discard,\"aw\",@progbits\n"
                       " .byte 0xff + (4f-3f) - (2b-1b)\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "3: movb $0,%0\n"
                       "4:\n"
                       ".previous\n"
                       ".section .altinstructions,\"a\"\n"
                       " .long 1b - .\n"
                       " .long 5f - .\n"
                       " .word %P1\n"
                       " .byte 4b - 3b\n"
                       " .byte 6f - 5f\n"
                       ".previous\n"
                       ".section .discard,\"aw\",@progbits\n"
                       " .byte 0xff + (6f-5f) - (4b-3b)\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "5: movb $1,%0\n"
                       "6:\n"
                       ".previous\n": "=qm" (flag): "i" (bit), "i" (117));
  }
#line 535
  if ((int )flag == 2) {
    {
#line 535
    tmp = __static_cpu_has_safe(bit);
#line 535
    tmp___0 = (int )tmp;
    }
  } else {
    {
#line 535
    tmp___0 = (int )flag;
    }
  }
#line 535
  return ((bool __attribute__((__pure__))  )tmp___0);
}
}
#line 218 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/alternative.h"
__inline static void apply_paravirt(struct paravirt_patch_site *start , struct paravirt_patch_site *end )  __attribute__((__no_instrument_function__)) ;
#line 218 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/alternative.h"
__inline static void apply_paravirt(struct paravirt_patch_site *start , struct paravirt_patch_site *end ) 
{ 


  {
#line 220
  return;
}
}
#line 225
extern void *text_poke_early(void *addr , void const   *opcode , size_t len ) ;
#line 241
extern void *text_poke(void *addr , void const   *opcode , size_t len ) ;
#line 242
extern int poke_int3_handler(struct pt_regs *regs ) ;
#line 243
extern void *text_poke_bp(void *addr , void const   *opcode , size_t len , void *handler ) ;
#line 142 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/nops.h"
extern unsigned char const   * const  *ideal_nops ;
#line 143
extern void arch_init_ideal_nops(void) ;
#line 151 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/barrier.h"
__inline static void ( __attribute__((__always_inline__)) rdtsc_barrier)(void)  __attribute__((__no_instrument_function__)) ;
#line 151 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/barrier.h"
__inline static void ( __attribute__((__always_inline__)) rdtsc_barrier)(void) 
{ 


  {
  {
#line 153
  __asm__  volatile   ("661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 3*32+17)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       "mfence"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection": : : "memory");
#line 154
  __asm__  volatile   ("661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 3*32+18)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       "lfence"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection": : : "memory");
  }
#line 155
  return;
}
}
#line 71 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/bitops.h"
__inline static void ( __attribute__((__always_inline__)) set_bit)(long nr , unsigned long volatile   *addr )  __attribute__((__no_instrument_function__)) ;
#line 71 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/bitops.h"
__inline static void ( __attribute__((__always_inline__)) set_bit)(long nr , unsigned long volatile   *addr ) 
{ 


  {
  {
#line 80
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
  }
#line 83
  return;
}
}
#line 94
__inline static void __set_bit(long nr , unsigned long volatile   *addr )  __attribute__((__no_instrument_function__)) ;
#line 94 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/bitops.h"
__inline static void __set_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
  {
#line 96
  __asm__  volatile   ("bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
  }
#line 97
  return;
}
}
#line 109
__inline static void ( __attribute__((__always_inline__)) clear_bit)(long nr , unsigned long volatile   *addr )  __attribute__((__no_instrument_function__)) ;
#line 109 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/bitops.h"
__inline static void ( __attribute__((__always_inline__)) clear_bit)(long nr , unsigned long volatile   *addr ) 
{ 


  {
  {
#line 117
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
  }
#line 121
  return;
}
}
#line 131
__inline static void clear_bit_unlock(long nr , unsigned long volatile   *addr )  __attribute__((__no_instrument_function__)) ;
#line 131 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/bitops.h"
__inline static void clear_bit_unlock(long nr , unsigned long volatile   *addr ) 
{ 


  {
  {
#line 133
  __asm__  volatile   ("": : : "memory");
#line 134
  clear_bit(nr, addr);
  }
#line 135
  return;
}
}
#line 137
__inline static void __clear_bit(long nr , unsigned long volatile   *addr )  __attribute__((__no_instrument_function__)) ;
#line 137 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/bitops.h"
__inline static void __clear_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
  {
#line 139
  __asm__  volatile   ("btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
  }
#line 140
  return;
}
}
#line 154
__inline static void __clear_bit_unlock(long nr , unsigned long volatile   *addr )  __attribute__((__no_instrument_function__)) ;
#line 154 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/bitops.h"
__inline static void __clear_bit_unlock(long nr , unsigned long volatile   *addr ) 
{ 


  {
  {
#line 156
  __asm__  volatile   ("": : : "memory");
#line 157
  __clear_bit(nr, addr);
  }
#line 158
  return;
}
}
#line 169
__inline static void __change_bit(long nr , unsigned long volatile   *addr )  __attribute__((__no_instrument_function__)) ;
#line 169 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/bitops.h"
__inline static void __change_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
  {
#line 171
  __asm__  volatile   ("btc %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
  }
#line 172
  return;
}
}
#line 183
__inline static void change_bit(long nr , unsigned long volatile   *addr )  __attribute__((__no_instrument_function__)) ;
#line 183 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/bitops.h"
__inline static void change_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
  {
#line 190
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "btc %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
  }
#line 194
  return;
}
}
#line 204
__inline static int test_and_set_bit(long nr , unsigned long volatile   *addr )  __attribute__((__no_instrument_function__)) ;
#line 204 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(long nr , unsigned long volatile   *addr ) 
{ 
  char c ;

  {
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 206
    __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                         ".balign 4\n"
                         ".long 671f - .\n"
                         ".popsection\n"
                         "671:"
                         "\n\tlock; "
                         "bts"
                         " %2, "
                         "%0"
                         "; set"
                         "c"
                         " %1": "+m" (*addr), "=qm" (c): "Ir" (nr): "memory");
    }
#line 206
    return ((int )c != 0);
#line 206
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 207
  return (0);
}
}
#line 216
__inline static int ( __attribute__((__always_inline__)) test_and_set_bit_lock)(long nr ,
                                                                                unsigned long volatile   *addr )  __attribute__((__no_instrument_function__)) ;
#line 216 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/bitops.h"
__inline static int ( __attribute__((__always_inline__)) test_and_set_bit_lock)(long nr ,
                                                                                unsigned long volatile   *addr ) 
{ 
  int tmp ;

  {
  {
#line 219
  tmp = test_and_set_bit(nr, addr);
  }
#line 219
  return (tmp);
}
}
#line 231
__inline static int __test_and_set_bit(long nr , unsigned long volatile   *addr )  __attribute__((__no_instrument_function__)) ;
#line 231 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/bitops.h"
__inline static int __test_and_set_bit(long nr , unsigned long volatile   *addr ) 
{ 
  int oldbit ;

  {
  {
#line 235
  __asm__  ("bts %2,%1\n\t"
            "sbb %0,%0": "=r" (oldbit), "+m" (*((long volatile   *)addr)): "Ir" (nr));
  }
#line 239
  return (oldbit);
}
}
#line 250
__inline static int test_and_clear_bit(long nr , unsigned long volatile   *addr )  __attribute__((__no_instrument_function__)) ;
#line 250 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/bitops.h"
__inline static int test_and_clear_bit(long nr , unsigned long volatile   *addr ) 
{ 
  char c ;

  {
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 252
    __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                         ".balign 4\n"
                         ".long 671f - .\n"
                         ".popsection\n"
                         "671:"
                         "\n\tlock; "
                         "btr"
                         " %2, "
                         "%0"
                         "; set"
                         "c"
                         " %1": "+m" (*addr), "=qm" (c): "Ir" (nr): "memory");
    }
#line 252
    return ((int )c != 0);
#line 252
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  return (0);
}
}
#line 271
__inline static int __test_and_clear_bit(long nr , unsigned long volatile   *addr )  __attribute__((__no_instrument_function__)) ;
#line 271 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/bitops.h"
__inline static int __test_and_clear_bit(long nr , unsigned long volatile   *addr ) 
{ 
  int oldbit ;

  {
  {
#line 275
  __asm__  volatile   ("btr %2,%1\n\t"
                       "sbb %0,%0": "=r" (oldbit), "+m" (*((long volatile   *)addr)): "Ir" (nr));
  }
#line 279
  return (oldbit);
}
}
#line 283
__inline static int __test_and_change_bit(long nr , unsigned long volatile   *addr )  __attribute__((__no_instrument_function__)) ;
#line 283 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/bitops.h"
__inline static int __test_and_change_bit(long nr , unsigned long volatile   *addr ) 
{ 
  int oldbit ;

  {
  {
#line 287
  __asm__  volatile   ("btc %2,%1\n\t"
                       "sbb %0,%0": "=r" (oldbit), "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
  }
#line 292
  return (oldbit);
}
}
#line 303
__inline static int test_and_change_bit(long nr , unsigned long volatile   *addr )  __attribute__((__no_instrument_function__)) ;
#line 303 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/bitops.h"
__inline static int test_and_change_bit(long nr , unsigned long volatile   *addr ) 
{ 
  char c ;

  {
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 305
    __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                         ".balign 4\n"
                         ".long 671f - .\n"
                         ".popsection\n"
                         "671:"
                         "\n\tlock; "
                         "btc"
                         " %2, "
                         "%0"
                         "; set"
                         "c"
                         " %1": "+m" (*addr), "=qm" (c): "Ir" (nr): "memory");
    }
#line 305
    return ((int )c != 0);
#line 305
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  return (0);
}
}
#line 308
__inline static int ( __attribute__((__always_inline__)) constant_test_bit)(long nr ,
                                                                            unsigned long const volatile   *addr )  __attribute__((__no_instrument_function__)) ;
#line 308 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/bitops.h"
__inline static int ( __attribute__((__always_inline__)) constant_test_bit)(long nr ,
                                                                            unsigned long const volatile   *addr ) 
{ 


  {
#line 310
  return (((1UL << (nr & 63L)) & (unsigned long )*(addr + (nr >> 6))) != 0UL);
}
}
#line 314
__inline static int variable_test_bit(long nr , unsigned long const volatile   *addr )  __attribute__((__no_instrument_function__)) ;
#line 314 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 
  int oldbit ;

  {
  {
#line 318
  __asm__  volatile   ("bt %2,%1\n\t"
                       "sbb %0,%0": "=r" (oldbit): "m" (*((unsigned long *)addr)),
                       "Ir" (nr));
  }
#line 323
  return (oldbit);
}
}
#line 346
__inline static unsigned long __ffs(unsigned long word )  __attribute__((__no_instrument_function__)) ;
#line 346 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/bitops.h"
__inline static unsigned long __ffs(unsigned long word ) 
{ 


  {
  {
#line 348
  __asm__  ("rep; bsf %1,%0": "=r" (word): "rm" (word));
  }
#line 351
  return (word);
}
}
#line 360
__inline static unsigned long ffz(unsigned long word )  __attribute__((__no_instrument_function__)) ;
#line 360 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/bitops.h"
__inline static unsigned long ffz(unsigned long word ) 
{ 


  {
  {
#line 362
  __asm__  ("rep; bsf %1,%0": "=r" (word): "r" (~ word));
  }
#line 365
  return (word);
}
}
#line 374
__inline static unsigned long __fls(unsigned long word )  __attribute__((__no_instrument_function__)) ;
#line 374 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/bitops.h"
__inline static unsigned long __fls(unsigned long word ) 
{ 


  {
  {
#line 376
  __asm__  ("bsr %1,%0": "=r" (word): "rm" (word));
  }
#line 379
  return (word);
}
}
#line 396
__inline static int ffs(int x )  __attribute__((__no_instrument_function__)) ;
#line 396 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/bitops.h"
__inline static int ffs(int x ) 
{ 
  int r ;

  {
  {
#line 410
  __asm__  ("bsfl %1,%0": "=r" (r): "rm" (x), "0" (-1));
  }
#line 423
  return (r + 1);
}
}
#line 437
__inline static int fls(int x )  __attribute__((__no_instrument_function__)) ;
#line 437 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/bitops.h"
__inline static int fls(int x ) 
{ 
  int r ;

  {
  {
#line 451
  __asm__  ("bsrl %1,%0": "=r" (r): "rm" (x), "0" (-1));
  }
#line 464
  return (r + 1);
}
}
#line 479
__inline static int ( __attribute__((__always_inline__)) fls64)(__u64 x )  __attribute__((__no_instrument_function__)) ;
#line 479 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/bitops.h"
__inline static int ( __attribute__((__always_inline__)) fls64)(__u64 x ) 
{ 
  int bitpos ;

  {
  {
#line 481
  bitpos = -1;
#line 487
  __asm__  ("bsrq %1,%q0": "+r" (bitpos): "rm" (x));
  }
#line 490
  return (bitpos + 1);
}
}
#line 14 "../../../analyzer/../bench/linux-headers/include/asm-generic/bitops/find.h"
extern unsigned long find_next_bit(unsigned long const   *addr , unsigned long size ,
                                   unsigned long offset ) ;
#line 28
extern unsigned long find_next_zero_bit(unsigned long const   *addr , unsigned long size ,
                                        unsigned long offset ) ;
#line 42
extern unsigned long find_first_bit(unsigned long const   *addr , unsigned long size ) ;
#line 53
extern unsigned long find_first_zero_bit(unsigned long const   *addr , unsigned long size ) ;
#line 12 "../../../analyzer/../bench/linux-headers/include/asm-generic/bitops/sched.h"
__inline static int sched_find_first_bit(unsigned long const   *b )  __attribute__((__no_instrument_function__)) ;
#line 12 "../../../analyzer/../bench/linux-headers/include/asm-generic/bitops/sched.h"
__inline static int sched_find_first_bit(unsigned long const   *b ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 15
  if (*(b + 0)) {
    {
#line 16
    tmp = __ffs((unsigned long )*(b + 0));
    }
#line 16
    return ((int )tmp);
  }
  {
#line 17
  tmp___0 = __ffs((unsigned long )*(b + 1));
  }
#line 17
  return ((int )(tmp___0 + 64UL));
}
}
#line 24 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/arch_hweight.h"
__inline static unsigned int __arch_hweight32(unsigned int w )  __attribute__((__no_instrument_function__)) ;
#line 24 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/arch_hweight.h"
__inline static unsigned int __arch_hweight32(unsigned int w ) 
{ 
  unsigned int res ;

  {
  {
#line 26
  res = 0U;
#line 28
  __asm__  ("661:\n\t"
            "call __sw_hweight32"
            "\n662:\n"
            ".pushsection .altinstructions,\"a\"\n"
            " .long 661b - .\n"
            " .long "
            "663"
            "1"
            "f - .\n"
            " .word "
            "( 4*32+23)"
            "\n"
            " .byte "
            "662b-661b"
            "\n"
            " .byte "
            "664"
            "1"
            "f-"
            "663"
            "1"
            "f"
            "\n"
            ".popsection\n"
            ".pushsection .discard,\"aw\",@progbits\n"
            " .byte 0xff + ("
            "664"
            "1"
            "f-"
            "663"
            "1"
            "f"
            ") - ("
            "662b-661b"
            ")\n"
            ".popsection\n"
            ".pushsection .altinstr_replacement, \"ax\"\n"
            "663"
            "1"
            ":\n\t"
            ".byte 0xf3,0x40,0x0f,0xb8,0xc7"
            "\n"
            "664"
            "1"
            ":\n\t"
            ".popsection": "=a" (res): "D" (w));
  }
#line 32
  return (res);
}
}
#line 35
__inline static unsigned int __arch_hweight16(unsigned int w )  __attribute__((__no_instrument_function__)) ;
#line 35 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/arch_hweight.h"
__inline static unsigned int __arch_hweight16(unsigned int w ) 
{ 
  unsigned int tmp ;

  {
  {
#line 37
  tmp = __arch_hweight32(w & 65535U);
  }
#line 37
  return (tmp);
}
}
#line 40
__inline static unsigned int __arch_hweight8(unsigned int w )  __attribute__((__no_instrument_function__)) ;
#line 40 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/arch_hweight.h"
__inline static unsigned int __arch_hweight8(unsigned int w ) 
{ 
  unsigned int tmp ;

  {
  {
#line 42
  tmp = __arch_hweight32(w & 255U);
  }
#line 42
  return (tmp);
}
}
#line 45
__inline static unsigned long __arch_hweight64(__u64 w )  __attribute__((__no_instrument_function__)) ;
#line 45 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/arch_hweight.h"
__inline static unsigned long __arch_hweight64(__u64 w ) 
{ 
  unsigned long res ;

  {
  {
#line 47
  res = 0UL;
#line 53
  __asm__  ("661:\n\t"
            "call __sw_hweight64"
            "\n662:\n"
            ".pushsection .altinstructions,\"a\"\n"
            " .long 661b - .\n"
            " .long "
            "663"
            "1"
            "f - .\n"
            " .word "
            "( 4*32+23)"
            "\n"
            " .byte "
            "662b-661b"
            "\n"
            " .byte "
            "664"
            "1"
            "f-"
            "663"
            "1"
            "f"
            "\n"
            ".popsection\n"
            ".pushsection .discard,\"aw\",@progbits\n"
            " .byte 0xff + ("
            "664"
            "1"
            "f-"
            "663"
            "1"
            "f"
            ") - ("
            "662b-661b"
            ")\n"
            ".popsection\n"
            ".pushsection .altinstr_replacement, \"ax\"\n"
            "663"
            "1"
            ":\n\t"
            ".byte 0xf3,0x48,0x0f,0xb8,0xc7"
            "\n"
            "664"
            "1"
            ":\n\t"
            ".popsection": "=a" (res): "D" (w));
  }
#line 58
  return (res);
}
}
#line 7 "../../../analyzer/../bench/linux-headers/arch/x86/include/uapi/asm/swab.h"
__inline static __u32 __arch_swab32(__u32 val )  __attribute__((__no_instrument_function__,
__const__)) ;
#line 7 "../../../analyzer/../bench/linux-headers/arch/x86/include/uapi/asm/swab.h"
__inline static __u32 __arch_swab32(__u32 val ) 
{ 


  {
  {
#line 9
  __asm__  ("bswapl %0": "=r" (val): "0" (val));
  }
#line 10
  return (val);
}
}
#line 14
__inline static __u64 __arch_swab64(__u64 val )  __attribute__((__no_instrument_function__,
__const__)) ;
#line 14 "../../../analyzer/../bench/linux-headers/arch/x86/include/uapi/asm/swab.h"
__inline static __u64 __arch_swab64(__u64 val ) 
{ 


  {
  {
#line 30
  __asm__  ("bswapq %0": "=r" (val): "0" (val));
  }
#line 31
  return (val);
}
}
#line 49 "../../../analyzer/../bench/linux-headers/include/uapi/linux/swab.h"
extern int ( /* missing proto */  __builtin_bswap16)() ;
#line 46
__inline static __u16 __fswab16(__u16 val )  __attribute__((__no_instrument_function__,
__const__)) ;
#line 46 "../../../analyzer/../bench/linux-headers/include/uapi/linux/swab.h"
__inline static __u16 __fswab16(__u16 val ) 
{ 
  int tmp ;

  {
  {
#line 49
  tmp = __builtin_bswap16((int )val);
  }
#line 49
  return ((__u16 )tmp);
}
}
#line 57
__inline static __u32 __fswab32(__u32 val )  __attribute__((__no_instrument_function__,
__const__)) ;
#line 57 "../../../analyzer/../bench/linux-headers/include/uapi/linux/swab.h"
__inline static __u32 __fswab32(__u32 val ) 
{ 
  int tmp ;

  {
  {
#line 60
  tmp = __builtin_bswap32((int )val);
  }
#line 60
  return ((__u32 )tmp);
}
}
#line 68
__inline static __u64 __fswab64(__u64 val )  __attribute__((__no_instrument_function__,
__const__)) ;
#line 68 "../../../analyzer/../bench/linux-headers/include/uapi/linux/swab.h"
__inline static __u64 __fswab64(__u64 val ) 
{ 
  long tmp ;

  {
  {
#line 71
  tmp = __builtin_bswap64((long )val);
  }
#line 71
  return ((__u64 )tmp);
}
}
#line 83
__inline static __u32 __fswahw32(__u32 val )  __attribute__((__no_instrument_function__,
__const__)) ;
#line 83 "../../../analyzer/../bench/linux-headers/include/uapi/linux/swab.h"
__inline static __u32 __fswahw32(__u32 val ) 
{ 


  {
#line 88
  return (((val & 65535U) << 16) | ((val & 4294901760U) >> 16));
}
}
#line 92
__inline static __u32 __fswahb32(__u32 val )  __attribute__((__no_instrument_function__,
__const__)) ;
#line 92 "../../../analyzer/../bench/linux-headers/include/uapi/linux/swab.h"
__inline static __u32 __fswahb32(__u32 val ) 
{ 


  {
#line 97
  return (((val & 16711935U) << 8) | ((val & 4278255360U) >> 8));
}
}
#line 154
__inline static __u16 __swab16p(__u16 const   *p )  __attribute__((__no_instrument_function__)) ;
#line 154 "../../../analyzer/../bench/linux-headers/include/uapi/linux/swab.h"
__inline static __u16 __swab16p(__u16 const   *p ) 
{ 
  __u16 tmp ;

  {
  {
#line 159
  tmp = __fswab16((__u16 )*p);
  }
#line 159
  return ((__u16 )((int )tmp));
}
}
#line 167
__inline static __u32 __swab32p(__u32 const   *p )  __attribute__((__no_instrument_function__)) ;
#line 167 "../../../analyzer/../bench/linux-headers/include/uapi/linux/swab.h"
__inline static __u32 __swab32p(__u32 const   *p ) 
{ 
  __u32 tmp ;

  {
  {
#line 172
  tmp = __fswab32((__u32 )*p);
  }
#line 172
  return (tmp);
}
}
#line 180
__inline static __u64 __swab64p(__u64 const   *p )  __attribute__((__no_instrument_function__)) ;
#line 180 "../../../analyzer/../bench/linux-headers/include/uapi/linux/swab.h"
__inline static __u64 __swab64p(__u64 const   *p ) 
{ 
  __u64 tmp ;

  {
  {
#line 185
  tmp = __fswab64((__u64 )*p);
  }
#line 185
  return (tmp);
}
}
#line 195
__inline static __u32 __swahw32p(__u32 const   *p )  __attribute__((__no_instrument_function__)) ;
#line 195 "../../../analyzer/../bench/linux-headers/include/uapi/linux/swab.h"
__inline static __u32 __swahw32p(__u32 const   *p ) 
{ 
  __u32 tmp ;

  {
  {
#line 200
  tmp = __fswahw32((__u32 )*p);
  }
#line 200
  return (tmp);
}
}
#line 210
__inline static __u32 __swahb32p(__u32 const   *p )  __attribute__((__no_instrument_function__)) ;
#line 210 "../../../analyzer/../bench/linux-headers/include/uapi/linux/swab.h"
__inline static __u32 __swahb32p(__u32 const   *p ) 
{ 
  __u32 tmp ;

  {
  {
#line 215
  tmp = __fswahb32((__u32 )*p);
  }
#line 215
  return (tmp);
}
}
#line 223
__inline static void __swab16s(__u16 *p )  __attribute__((__no_instrument_function__)) ;
#line 223 "../../../analyzer/../bench/linux-headers/include/uapi/linux/swab.h"
__inline static void __swab16s(__u16 *p ) 
{ 


  {
  {
#line 228
  *p = __swab16p((__u16 const   *)p);
  }
#line 230
  return;
}
}
#line 235
__inline static void __swab32s(__u32 *p )  __attribute__((__no_instrument_function__)) ;
#line 235 "../../../analyzer/../bench/linux-headers/include/uapi/linux/swab.h"
__inline static void __swab32s(__u32 *p ) 
{ 


  {
  {
#line 240
  *p = __swab32p((__u32 const   *)p);
  }
#line 242
  return;
}
}
#line 248
__inline static void __swab64s(__u64 *p )  __attribute__((__no_instrument_function__)) ;
#line 248 "../../../analyzer/../bench/linux-headers/include/uapi/linux/swab.h"
__inline static void __swab64s(__u64 *p ) 
{ 


  {
  {
#line 253
  *p = __swab64p((__u64 const   *)p);
  }
#line 255
  return;
}
}
#line 263
__inline static void __swahw32s(__u32 *p )  __attribute__((__no_instrument_function__)) ;
#line 263 "../../../analyzer/../bench/linux-headers/include/uapi/linux/swab.h"
__inline static void __swahw32s(__u32 *p ) 
{ 


  {
  {
#line 268
  *p = __swahw32p((__u32 const   *)p);
  }
#line 270
  return;
}
}
#line 278
__inline static void __swahb32s(__u32 *p )  __attribute__((__no_instrument_function__)) ;
#line 278 "../../../analyzer/../bench/linux-headers/include/uapi/linux/swab.h"
__inline static void __swahb32s(__u32 *p ) 
{ 


  {
  {
#line 283
  *p = __swahb32p((__u32 const   *)p);
  }
#line 285
  return;
}
}
#line 43 "../../../analyzer/../bench/linux-headers/include/uapi/linux/byteorder/little_endian.h"
__inline static __le64 __cpu_to_le64p(__u64 const   *p )  __attribute__((__no_instrument_function__)) ;
#line 43 "../../../analyzer/../bench/linux-headers/include/uapi/linux/byteorder/little_endian.h"
__inline static __le64 __cpu_to_le64p(__u64 const   *p ) 
{ 


  {
#line 45
  return ((__le64 )*p);
}
}
#line 47
__inline static __u64 __le64_to_cpup(__le64 const   *p )  __attribute__((__no_instrument_function__)) ;
#line 47 "../../../analyzer/../bench/linux-headers/include/uapi/linux/byteorder/little_endian.h"
__inline static __u64 __le64_to_cpup(__le64 const   *p ) 
{ 


  {
#line 49
  return ((__u64 )*p);
}
}
#line 51
__inline static __le32 __cpu_to_le32p(__u32 const   *p )  __attribute__((__no_instrument_function__)) ;
#line 51 "../../../analyzer/../bench/linux-headers/include/uapi/linux/byteorder/little_endian.h"
__inline static __le32 __cpu_to_le32p(__u32 const   *p ) 
{ 


  {
#line 53
  return ((__le32 )*p);
}
}
#line 55
__inline static __u32 __le32_to_cpup(__le32 const   *p )  __attribute__((__no_instrument_function__)) ;
#line 55 "../../../analyzer/../bench/linux-headers/include/uapi/linux/byteorder/little_endian.h"
__inline static __u32 __le32_to_cpup(__le32 const   *p ) 
{ 


  {
#line 57
  return ((__u32 )*p);
}
}
#line 59
__inline static __le16 __cpu_to_le16p(__u16 const   *p )  __attribute__((__no_instrument_function__)) ;
#line 59 "../../../analyzer/../bench/linux-headers/include/uapi/linux/byteorder/little_endian.h"
__inline static __le16 __cpu_to_le16p(__u16 const   *p ) 
{ 


  {
#line 61
  return ((__le16 )*p);
}
}
#line 63
__inline static __u16 __le16_to_cpup(__le16 const   *p )  __attribute__((__no_instrument_function__)) ;
#line 63 "../../../analyzer/../bench/linux-headers/include/uapi/linux/byteorder/little_endian.h"
__inline static __u16 __le16_to_cpup(__le16 const   *p ) 
{ 


  {
#line 65
  return ((__u16 )*p);
}
}
#line 67
__inline static __be64 __cpu_to_be64p(__u64 const   *p )  __attribute__((__no_instrument_function__)) ;
#line 67 "../../../analyzer/../bench/linux-headers/include/uapi/linux/byteorder/little_endian.h"
__inline static __be64 __cpu_to_be64p(__u64 const   *p ) 
{ 
  __u64 tmp ;

  {
  {
#line 69
  tmp = __swab64p(p);
  }
#line 69
  return (tmp);
}
}
#line 71
__inline static __u64 __be64_to_cpup(__be64 const   *p )  __attribute__((__no_instrument_function__)) ;
#line 71 "../../../analyzer/../bench/linux-headers/include/uapi/linux/byteorder/little_endian.h"
__inline static __u64 __be64_to_cpup(__be64 const   *p ) 
{ 
  __u64 tmp ;

  {
  {
#line 73
  tmp = __swab64p((__u64 const   *)((__u64 *)p));
  }
#line 73
  return (tmp);
}
}
#line 75
__inline static __be32 __cpu_to_be32p(__u32 const   *p )  __attribute__((__no_instrument_function__)) ;
#line 75 "../../../analyzer/../bench/linux-headers/include/uapi/linux/byteorder/little_endian.h"
__inline static __be32 __cpu_to_be32p(__u32 const   *p ) 
{ 
  __u32 tmp ;

  {
  {
#line 77
  tmp = __swab32p(p);
  }
#line 77
  return (tmp);
}
}
#line 79
__inline static __u32 __be32_to_cpup(__be32 const   *p )  __attribute__((__no_instrument_function__)) ;
#line 79 "../../../analyzer/../bench/linux-headers/include/uapi/linux/byteorder/little_endian.h"
__inline static __u32 __be32_to_cpup(__be32 const   *p ) 
{ 
  __u32 tmp ;

  {
  {
#line 81
  tmp = __swab32p((__u32 const   *)((__u32 *)p));
  }
#line 81
  return (tmp);
}
}
#line 83
__inline static __be16 __cpu_to_be16p(__u16 const   *p )  __attribute__((__no_instrument_function__)) ;
#line 83 "../../../analyzer/../bench/linux-headers/include/uapi/linux/byteorder/little_endian.h"
__inline static __be16 __cpu_to_be16p(__u16 const   *p ) 
{ 
  __u16 tmp ;

  {
  {
#line 85
  tmp = __swab16p(p);
  }
#line 85
  return (tmp);
}
}
#line 87
__inline static __u16 __be16_to_cpup(__be16 const   *p )  __attribute__((__no_instrument_function__)) ;
#line 87 "../../../analyzer/../bench/linux-headers/include/uapi/linux/byteorder/little_endian.h"
__inline static __u16 __be16_to_cpup(__be16 const   *p ) 
{ 
  __u16 tmp ;

  {
  {
#line 89
  tmp = __swab16p((__u16 const   *)((__u16 *)p));
  }
#line 89
  return (tmp);
}
}
#line 143 "../../../analyzer/../bench/linux-headers/include/linux/byteorder/generic.h"
__inline static void le16_add_cpu(__le16 *var , u16 val )  __attribute__((__no_instrument_function__)) ;
#line 143 "../../../analyzer/../bench/linux-headers/include/linux/byteorder/generic.h"
__inline static void le16_add_cpu(__le16 *var , u16 val ) 
{ 


  {
  {
#line 145
  *var = (__u16 )((int )*var + (int )val);
  }
#line 146
  return;
}
}
#line 148
__inline static void le32_add_cpu(__le32 *var , u32 val )  __attribute__((__no_instrument_function__)) ;
#line 148 "../../../analyzer/../bench/linux-headers/include/linux/byteorder/generic.h"
__inline static void le32_add_cpu(__le32 *var , u32 val ) 
{ 


  {
  {
#line 150
  *var += val;
  }
#line 151
  return;
}
}
#line 153
__inline static void le64_add_cpu(__le64 *var , u64 val )  __attribute__((__no_instrument_function__)) ;
#line 153 "../../../analyzer/../bench/linux-headers/include/linux/byteorder/generic.h"
__inline static void le64_add_cpu(__le64 *var , u64 val ) 
{ 


  {
  {
#line 155
  *var += val;
  }
#line 156
  return;
}
}
#line 158
__inline static void be16_add_cpu(__be16 *var , u16 val )  __attribute__((__no_instrument_function__)) ;
#line 158 "../../../analyzer/../bench/linux-headers/include/linux/byteorder/generic.h"
__inline static void be16_add_cpu(__be16 *var , u16 val ) 
{ 
  __u16 tmp ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;
  __u16 tmp___2 ;
  __u16 tmp___3 ;

  {
  {
#line 160
  tmp___2 = __fswab16(*var);
#line 160
  tmp___3 = __fswab16((__u16 )((int )tmp___2 + (int )val));
#line 160
  *var = (__be16 )((int )tmp___3);
  }
#line 161
  return;
}
}
#line 163
__inline static void be32_add_cpu(__be32 *var , u32 val )  __attribute__((__no_instrument_function__)) ;
#line 163 "../../../analyzer/../bench/linux-headers/include/linux/byteorder/generic.h"
__inline static void be32_add_cpu(__be32 *var , u32 val ) 
{ 
  __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;

  {
  {
#line 165
  tmp___4 = __fswab32(*var);
#line 165
  tmp___5 = __fswab32(tmp___4 + val);
#line 165
  *var = tmp___5;
  }
#line 166
  return;
}
}
#line 168
__inline static void be64_add_cpu(__be64 *var , u64 val )  __attribute__((__no_instrument_function__)) ;
#line 168 "../../../analyzer/../bench/linux-headers/include/linux/byteorder/generic.h"
__inline static void be64_add_cpu(__be64 *var , u64 val ) 
{ 
  __u64 tmp ;
  __u64 tmp___0 ;
  __u64 tmp___1 ;
  __u64 tmp___2 ;
  __u64 tmp___3 ;
  __u64 tmp___4 ;
  __u64 tmp___5 ;
  __u64 tmp___6 ;
  __u64 tmp___7 ;
  __u64 tmp___8 ;
  __u64 tmp___9 ;

  {
  {
#line 170
  tmp___8 = __fswab64(*var);
#line 170
  tmp___9 = __fswab64(tmp___8 + val);
#line 170
  *var = tmp___9;
  }
#line 171
  return;
}
}
#line 11 "../../../analyzer/../bench/linux-headers/include/asm-generic/bitops/le.h"
__inline static unsigned long find_next_zero_bit_le(void const   *addr , unsigned long size ,
                                                    unsigned long offset )  __attribute__((__no_instrument_function__)) ;
#line 11 "../../../analyzer/../bench/linux-headers/include/asm-generic/bitops/le.h"
__inline static unsigned long find_next_zero_bit_le(void const   *addr , unsigned long size ,
                                                    unsigned long offset ) 
{ 
  unsigned long tmp ;

  {
  {
#line 14
  tmp = find_next_zero_bit((unsigned long const   *)addr, size, offset);
  }
#line 14
  return (tmp);
}
}
#line 17
__inline static unsigned long find_next_bit_le(void const   *addr , unsigned long size ,
                                               unsigned long offset )  __attribute__((__no_instrument_function__)) ;
#line 17 "../../../analyzer/../bench/linux-headers/include/asm-generic/bitops/le.h"
__inline static unsigned long find_next_bit_le(void const   *addr , unsigned long size ,
                                               unsigned long offset ) 
{ 
  unsigned long tmp ;

  {
  {
#line 20
  tmp = find_next_bit((unsigned long const   *)addr, size, offset);
  }
#line 20
  return (tmp);
}
}
#line 23
__inline static unsigned long find_first_zero_bit_le(void const   *addr , unsigned long size )  __attribute__((__no_instrument_function__)) ;
#line 23 "../../../analyzer/../bench/linux-headers/include/asm-generic/bitops/le.h"
__inline static unsigned long find_first_zero_bit_le(void const   *addr , unsigned long size ) 
{ 
  unsigned long tmp ;

  {
  {
#line 26
  tmp = find_first_zero_bit((unsigned long const   *)addr, size);
  }
#line 26
  return (tmp);
}
}
#line 52
__inline static int test_bit_le(int nr , void const   *addr )  __attribute__((__no_instrument_function__)) ;
#line 52 "../../../analyzer/../bench/linux-headers/include/asm-generic/bitops/le.h"
__inline static int test_bit_le(int nr , void const   *addr ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 54
  tmp___0 = variable_test_bit((long )nr, (unsigned long const volatile   *)addr);
  }
#line 54
  return (tmp___0);
}
}
#line 57
__inline static void set_bit_le(int nr , void *addr )  __attribute__((__no_instrument_function__)) ;
#line 57 "../../../analyzer/../bench/linux-headers/include/asm-generic/bitops/le.h"
__inline static void set_bit_le(int nr , void *addr ) 
{ 


  {
  {
#line 59
  set_bit((long )nr, (unsigned long volatile   *)addr);
  }
#line 60
  return;
}
}
#line 62
__inline static void clear_bit_le(int nr , void *addr )  __attribute__((__no_instrument_function__)) ;
#line 62 "../../../analyzer/../bench/linux-headers/include/asm-generic/bitops/le.h"
__inline static void clear_bit_le(int nr , void *addr ) 
{ 


  {
  {
#line 64
  clear_bit((long )nr, (unsigned long volatile   *)addr);
  }
#line 65
  return;
}
}
#line 67
__inline static void __set_bit_le(int nr , void *addr )  __attribute__((__no_instrument_function__)) ;
#line 67 "../../../analyzer/../bench/linux-headers/include/asm-generic/bitops/le.h"
__inline static void __set_bit_le(int nr , void *addr ) 
{ 


  {
  {
#line 69
  __set_bit((long )nr, (unsigned long volatile   *)addr);
  }
#line 70
  return;
}
}
#line 72
__inline static void __clear_bit_le(int nr , void *addr )  __attribute__((__no_instrument_function__)) ;
#line 72 "../../../analyzer/../bench/linux-headers/include/asm-generic/bitops/le.h"
__inline static void __clear_bit_le(int nr , void *addr ) 
{ 


  {
  {
#line 74
  __clear_bit((long )nr, (unsigned long volatile   *)addr);
  }
#line 75
  return;
}
}
#line 77
__inline static int test_and_set_bit_le(int nr , void *addr )  __attribute__((__no_instrument_function__)) ;
#line 77 "../../../analyzer/../bench/linux-headers/include/asm-generic/bitops/le.h"
__inline static int test_and_set_bit_le(int nr , void *addr ) 
{ 
  int tmp ;

  {
  {
#line 79
  tmp = test_and_set_bit((long )nr, (unsigned long volatile   *)addr);
  }
#line 79
  return (tmp);
}
}
#line 82
__inline static int test_and_clear_bit_le(int nr , void *addr )  __attribute__((__no_instrument_function__)) ;
#line 82 "../../../analyzer/../bench/linux-headers/include/asm-generic/bitops/le.h"
__inline static int test_and_clear_bit_le(int nr , void *addr ) 
{ 
  int tmp ;

  {
  {
#line 84
  tmp = test_and_clear_bit((long )nr, (unsigned long volatile   *)addr);
  }
#line 84
  return (tmp);
}
}
#line 87
__inline static int __test_and_set_bit_le(int nr , void *addr )  __attribute__((__no_instrument_function__)) ;
#line 87 "../../../analyzer/../bench/linux-headers/include/asm-generic/bitops/le.h"
__inline static int __test_and_set_bit_le(int nr , void *addr ) 
{ 
  int tmp ;

  {
  {
#line 89
  tmp = __test_and_set_bit((long )nr, (unsigned long volatile   *)addr);
  }
#line 89
  return (tmp);
}
}
#line 92
__inline static int __test_and_clear_bit_le(int nr , void *addr )  __attribute__((__no_instrument_function__)) ;
#line 92 "../../../analyzer/../bench/linux-headers/include/asm-generic/bitops/le.h"
__inline static int __test_and_clear_bit_le(int nr , void *addr ) 
{ 
  int tmp ;

  {
  {
#line 94
  tmp = __test_and_clear_bit((long )nr, (unsigned long volatile   *)addr);
  }
#line 94
  return (tmp);
}
}
#line 42 "../../../analyzer/../bench/linux-headers/include/linux/bitops.h"
extern void __smp_mb__before_atomic(void) ;
#line 40
__inline static void smp_mb__before_clear_bit(void)  __attribute__((__no_instrument_function__)) ;
#line 40 "../../../analyzer/../bench/linux-headers/include/linux/bitops.h"
__inline static void smp_mb__before_clear_bit(void) 
{ 


  {
  {
#line 43
  __smp_mb__before_atomic();
  }
#line 44
  return;
}
}
#line 50
extern void __smp_mb__after_atomic(void) ;
#line 48
__inline static void smp_mb__after_clear_bit(void)  __attribute__((__no_instrument_function__)) ;
#line 48 "../../../analyzer/../bench/linux-headers/include/linux/bitops.h"
__inline static void smp_mb__after_clear_bit(void) 
{ 


  {
  {
#line 51
  __smp_mb__after_atomic();
  }
#line 52
  return;
}
}
#line 77
__inline static int get_bitmask_order(unsigned int count )  __attribute__((__no_instrument_function__)) ;
#line 77 "../../../analyzer/../bench/linux-headers/include/linux/bitops.h"
__inline static int get_bitmask_order(unsigned int count ) 
{ 
  int order ;

  {
  {
#line 81
  order = fls((int )count);
  }
#line 82
  return (order);
}
}
#line 85
__inline static int get_count_order(unsigned int count )  __attribute__((__no_instrument_function__)) ;
#line 85 "../../../analyzer/../bench/linux-headers/include/linux/bitops.h"
__inline static int get_count_order(unsigned int count ) 
{ 
  int order ;
  int tmp ;

  {
  {
#line 89
  tmp = fls((int )count);
#line 89
  order = tmp - 1;
  }
#line 90
  if (count & (count - 1U)) {
    {
#line 91
    order ++;
    }
  }
#line 92
  return (order);
}
}
#line 95
__inline static unsigned long hweight_long(unsigned long w )  __attribute__((__no_instrument_function__)) ;
#line 95 "../../../analyzer/../bench/linux-headers/include/linux/bitops.h"
__inline static unsigned long hweight_long(unsigned long w ) 
{ 
  unsigned int tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 97
  if (sizeof(w) == 4UL) {
    {
#line 97
    tmp = __arch_hweight32((unsigned int )w);
#line 97
    tmp___1 = (unsigned long )tmp;
    }
  } else {
    {
#line 97
    tmp___0 = __arch_hweight64((__u64 )w);
#line 97
    tmp___1 = tmp___0;
    }
  }
#line 97
  return (tmp___1);
}
}
#line 105
__inline static __u64 rol64(__u64 word , unsigned int shift )  __attribute__((__no_instrument_function__)) ;
#line 105 "../../../analyzer/../bench/linux-headers/include/linux/bitops.h"
__inline static __u64 rol64(__u64 word , unsigned int shift ) 
{ 


  {
#line 107
  return ((word << shift) | (word >> (64U - shift)));
}
}
#line 115
__inline static __u64 ror64(__u64 word , unsigned int shift )  __attribute__((__no_instrument_function__)) ;
#line 115 "../../../analyzer/../bench/linux-headers/include/linux/bitops.h"
__inline static __u64 ror64(__u64 word , unsigned int shift ) 
{ 


  {
#line 117
  return ((word >> shift) | (word << (64U - shift)));
}
}
#line 125
__inline static __u32 rol32(__u32 word , unsigned int shift )  __attribute__((__no_instrument_function__)) ;
#line 125 "../../../analyzer/../bench/linux-headers/include/linux/bitops.h"
__inline static __u32 rol32(__u32 word , unsigned int shift ) 
{ 


  {
#line 127
  return ((word << shift) | (word >> (32U - shift)));
}
}
#line 135
__inline static __u32 ror32(__u32 word , unsigned int shift )  __attribute__((__no_instrument_function__)) ;
#line 135 "../../../analyzer/../bench/linux-headers/include/linux/bitops.h"
__inline static __u32 ror32(__u32 word , unsigned int shift ) 
{ 


  {
#line 137
  return ((word >> shift) | (word << (32U - shift)));
}
}
#line 145
__inline static __u16 rol16(__u16 word , unsigned int shift )  __attribute__((__no_instrument_function__)) ;
#line 145 "../../../analyzer/../bench/linux-headers/include/linux/bitops.h"
__inline static __u16 rol16(__u16 word , unsigned int shift ) 
{ 


  {
#line 147
  return ((__u16 )(((int )word << shift) | ((int )word >> (16U - shift))));
}
}
#line 155
__inline static __u16 ror16(__u16 word , unsigned int shift )  __attribute__((__no_instrument_function__)) ;
#line 155 "../../../analyzer/../bench/linux-headers/include/linux/bitops.h"
__inline static __u16 ror16(__u16 word , unsigned int shift ) 
{ 


  {
#line 157
  return ((__u16 )(((int )word >> shift) | ((int )word << (16U - shift))));
}
}
#line 165
__inline static __u8 rol8(__u8 word , unsigned int shift )  __attribute__((__no_instrument_function__)) ;
#line 165 "../../../analyzer/../bench/linux-headers/include/linux/bitops.h"
__inline static __u8 rol8(__u8 word , unsigned int shift ) 
{ 


  {
#line 167
  return ((__u8 )(((int )word << shift) | ((int )word >> (8U - shift))));
}
}
#line 175
__inline static __u8 ror8(__u8 word , unsigned int shift )  __attribute__((__no_instrument_function__)) ;
#line 175 "../../../analyzer/../bench/linux-headers/include/linux/bitops.h"
__inline static __u8 ror8(__u8 word , unsigned int shift ) 
{ 


  {
#line 177
  return ((__u8 )(((int )word >> shift) | ((int )word << (8U - shift))));
}
}
#line 185
__inline static __s32 sign_extend32(__u32 value , int index )  __attribute__((__no_instrument_function__)) ;
#line 185 "../../../analyzer/../bench/linux-headers/include/linux/bitops.h"
__inline static __s32 sign_extend32(__u32 value , int index ) 
{ 
  __u8 shift ;

  {
  {
#line 187
  shift = (__u8 )(31 - index);
  }
#line 188
  return ((__s32 )(value << (int )shift) >> (int )shift);
}
}
#line 191
__inline static unsigned int fls_long(unsigned long l )  __attribute__((__no_instrument_function__)) ;
#line 191 "../../../analyzer/../bench/linux-headers/include/linux/bitops.h"
__inline static unsigned int fls_long(unsigned long l ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 193
  if (sizeof(l) == 4UL) {
    {
#line 194
    tmp = fls((int )l);
    }
#line 194
    return ((unsigned int )tmp);
  }
  {
#line 195
  tmp___0 = fls64((__u64 )l);
  }
#line 195
  return ((unsigned int )tmp___0);
}
}
#line 206
__inline static unsigned long __ffs64(u64 word )  __attribute__((__no_instrument_function__)) ;
#line 206 "../../../analyzer/../bench/linux-headers/include/linux/bitops.h"
__inline static unsigned long __ffs64(u64 word ) 
{ 
  unsigned long tmp ;

  {
  {
#line 214
  tmp = __ffs((unsigned long )word);
  }
#line 214
  return (tmp);
}
}
#line 242
extern unsigned long find_last_bit(unsigned long const   *addr , unsigned long size ) ;
#line 21 "../../../analyzer/../bench/linux-headers/include/linux/log2.h"
extern  __attribute__((__noreturn__)) int ____ilog2_NaN(void)  __attribute__((__const__)) ;
#line 31
__inline static int __ilog2_u32(u32 n )  __attribute__((__no_instrument_function__,
__const__)) ;
#line 31 "../../../analyzer/../bench/linux-headers/include/linux/log2.h"
__inline static int __ilog2_u32(u32 n ) 
{ 
  int tmp ;

  {
  {
#line 34
  tmp = fls((int )n);
  }
#line 34
  return (tmp - 1);
}
}
#line 39
__inline static int __ilog2_u64(u64 n )  __attribute__((__no_instrument_function__,
__const__)) ;
#line 39 "../../../analyzer/../bench/linux-headers/include/linux/log2.h"
__inline static int __ilog2_u64(u64 n ) 
{ 
  int tmp ;

  {
  {
#line 42
  tmp = fls64(n);
  }
#line 42
  return (tmp - 1);
}
}
#line 51
__inline static bool is_power_of_2(unsigned long n )  __attribute__((__no_instrument_function__,
__const__)) ;
#line 51 "../../../analyzer/../bench/linux-headers/include/linux/log2.h"
__inline static bool is_power_of_2(unsigned long n ) 
{ 
  int tmp ;

  {
#line 54
  if (n != 0UL) {
#line 54
    if ((n & (n - 1UL)) == 0UL) {
      {
#line 54
      tmp = 1;
      }
    } else {
      {
#line 54
      tmp = 0;
      }
    }
  } else {
    {
#line 54
    tmp = 0;
    }
  }
#line 54
  return ((bool )tmp);
}
}
#line 60
__inline static unsigned long __roundup_pow_of_two(unsigned long n )  __attribute__((__no_instrument_function__,
__const__)) ;
#line 60 "../../../analyzer/../bench/linux-headers/include/linux/log2.h"
__inline static unsigned long __roundup_pow_of_two(unsigned long n ) 
{ 
  unsigned int tmp ;

  {
  {
#line 63
  tmp = fls_long(n - 1UL);
  }
#line 63
  return (1UL << tmp);
}
}
#line 69
__inline static unsigned long __rounddown_pow_of_two(unsigned long n )  __attribute__((__no_instrument_function__,
__const__)) ;
#line 69 "../../../analyzer/../bench/linux-headers/include/linux/log2.h"
__inline static unsigned long __rounddown_pow_of_two(unsigned long n ) 
{ 
  unsigned int tmp ;

  {
  {
#line 72
  tmp = fls_long(n);
  }
#line 72
  return (1UL << (tmp - 1U));
}
}
#line 138 "../../../analyzer/../bench/linux-headers/include/linux/init.h"
extern initcall_t __con_initcall_start[] ;
#line 138
extern initcall_t __con_initcall_end[] ;
#line 139
extern initcall_t __security_initcall_start[] ;
#line 139
extern initcall_t __security_initcall_end[] ;
#line 145
extern int do_one_initcall(int (*fn)(void) ) ;
#line 146
extern char boot_command_line[]  __attribute__((__section__(".init.data"))) ;
#line 147
extern char *saved_command_line ;
#line 148
extern unsigned int reset_devices ;
#line 151
extern void setup_arch(char ** ) ;
#line 152
extern void prepare_namespace(void) ;
#line 153
extern void __attribute__((__cold__))  load_default_modules(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 154
extern int __attribute__((__cold__))  init_rootfs(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 156
extern void (*late_time_init)(void) ;
#line 158
extern bool initcall_debug ;
#line 10 "../../../analyzer/../bench/linux-headers/include/linux/printk.h"
extern char const   linux_banner[] ;
#line 11
extern char const   linux_proc_banner[] ;
#line 13
extern char *log_buf_addr_get(void) ;
#line 14
extern u32 log_buf_len_get(void) ;
#line 16
__inline static int printk_get_level(char const   *buffer )  __attribute__((__no_instrument_function__)) ;
#line 16 "../../../analyzer/../bench/linux-headers/include/linux/printk.h"
__inline static int printk_get_level(char const   *buffer ) 
{ 


  {
#line 18
  if ((int const   )*(buffer + 0) == 1) {
#line 18
    if (*(buffer + 1)) {
      {
#line 21
      if ((int const   )*(buffer + 1) == 100) {
#line 21
        goto case_100;
      }
#line 21
      if ((int const   )*(buffer + 1) == 48) {
#line 21
        goto case_100;
      }
#line 21
      if ((int const   )*(buffer + 1) == 49) {
#line 21
        goto case_100;
      }
#line 21
      if ((int const   )*(buffer + 1) == 50) {
#line 21
        goto case_100;
      }
#line 21
      if ((int const   )*(buffer + 1) == 51) {
#line 21
        goto case_100;
      }
#line 21
      if ((int const   )*(buffer + 1) == 52) {
#line 21
        goto case_100;
      }
#line 21
      if ((int const   )*(buffer + 1) == 53) {
#line 21
        goto case_100;
      }
#line 21
      if ((int const   )*(buffer + 1) == 54) {
#line 21
        goto case_100;
      }
#line 21
      if ((int const   )*(buffer + 1) == 55) {
#line 21
        goto case_100;
      }
#line 19
      goto switch_break;
      case_100: /* CIL Label */ 
      case_48: /* CIL Label */ 
      case_49: /* CIL Label */ 
      case_50: /* CIL Label */ 
      case_51: /* CIL Label */ 
      case_52: /* CIL Label */ 
      case_53: /* CIL Label */ 
      case_54: /* CIL Label */ 
      case_55: /* CIL Label */ 
#line 22
      return ((int )*(buffer + 1));
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 25
  return (0);
}
}
#line 28
__inline static char const   *printk_skip_level(char const   *buffer )  __attribute__((__no_instrument_function__)) ;
#line 28 "../../../analyzer/../bench/linux-headers/include/linux/printk.h"
__inline static char const   *printk_skip_level(char const   *buffer ) 
{ 
  int tmp ;

  {
  {
#line 30
  tmp = printk_get_level(buffer);
  }
#line 30
  if (tmp) {
#line 31
    return (buffer + 2);
  }
#line 33
  return (buffer);
}
}
#line 47
extern int console_printk[] ;
#line 54
__inline static void console_silent(void)  __attribute__((__no_instrument_function__)) ;
#line 54 "../../../analyzer/../bench/linux-headers/include/linux/printk.h"
__inline static void console_silent(void) 
{ 


  {
  {
#line 56
  console_printk[0] = 0;
  }
#line 57
  return;
}
}
#line 59
__inline static void console_verbose(void)  __attribute__((__no_instrument_function__)) ;
#line 59 "../../../analyzer/../bench/linux-headers/include/linux/printk.h"
__inline static void console_verbose(void) 
{ 


  {
#line 61
  if (console_printk[0]) {
    {
#line 62
    console_printk[0] = 15;
    }
  }
#line 63
  return;
}
}
#line 112
__inline static int ( /* format attribute */  no_printk)(char const   *fmt  , ...)  __attribute__((__no_instrument_function__)) ;
#line 112 "../../../analyzer/../bench/linux-headers/include/linux/printk.h"
__inline static int ( /* format attribute */  no_printk)(char const   *fmt  , ...) 
{ 


  {
#line 115
  return (0);
}
}
#line 119
extern void ( /* format attribute */  early_printk)(char const   *fmt  , ...) ;
#line 121
extern void early_vprintk(char const   *fmt , va_list ap ) ;
#line 128
extern int ( /* format attribute */  vprintk_emit)(int facility , int level , char const   *dict ,
                                                   size_t dictlen , char const   *fmt ,
                                                   va_list args ) ;
#line 133
extern int ( /* format attribute */  vprintk)(char const   *fmt , va_list args ) ;
#line 136
extern int __attribute__((__cold__))  ( /* format attribute */  printk_emit)(int facility ,
                                                                             int level ,
                                                                             char const   *dict ,
                                                                             size_t dictlen ,
                                                                             char const   *fmt 
                                                                             , ...) ;
#line 141
extern int __attribute__((__cold__))  ( /* format attribute */  printk)(char const   *fmt 
                                                                        , ...) ;
#line 147
extern int __attribute__((__cold__))  ( /* format attribute */  printk_deferred)(char const   *fmt 
                                                                                 , ...) ;
#line 154
extern int __printk_ratelimit(char const   *func ) ;
#line 156
extern bool printk_timed_ratelimit(unsigned long *caller_jiffies , unsigned int interval_msec ) ;
#line 159
extern int printk_delay_msec ;
#line 160
extern int dmesg_restrict ;
#line 161
extern int kptr_restrict ;
#line 163
extern void wake_up_klogd(void) ;
#line 165
extern void log_buf_kexec_setup(void) ;
#line 166
extern void __attribute__((__cold__))  setup_log_buf(int early )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 167
extern void dump_stack_set_arch_desc(char const   *fmt  , ...) ;
#line 168
extern void dump_stack_print_info(char const   *log_lvl ) ;
#line 169
extern void show_regs_print_info(char const   *log_lvl ) ;
#line 221
extern void dump_stack(void)  __attribute__((__cold__)) ;
#line 39 "../../../analyzer/../bench/linux-headers/include/linux/dynamic_debug.h"
extern int ddebug_add_module(struct _ddebug *tab , unsigned int n , char const   *modname ) ;
#line 11 "../../../analyzer/../bench/linux-headers/include/linux/string.h"
extern char *strndup_user(char const   * , long  ) ;
#line 12
extern void *memdup_user(void const   * , size_t  ) ;
#line 9 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/string_64.h"
__inline static void *( __attribute__((__always_inline__)) __inline_memcpy)(void *to ,
                                                                            void const   *from ,
                                                                            size_t n )  __attribute__((__no_instrument_function__)) ;
#line 9 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/string_64.h"
__inline static void *( __attribute__((__always_inline__)) __inline_memcpy)(void *to ,
                                                                            void const   *from ,
                                                                            size_t n ) 
{ 
  unsigned long d0 ;
  unsigned long d1 ;
  unsigned long d2 ;

  {
  {
#line 12
  __asm__  volatile   ("rep ; movsl\n\t"
                       "testb $2,%b4\n\t"
                       "je 1f\n\t"
                       "movsw\n"
                       "1:\ttestb $1,%b4\n\t"
                       "je 2f\n\t"
                       "movsb\n"
                       "2:": "=&c" (d0), "=&D" (d1), "=&S" (d2): "0" (n / 4UL), "q" (n),
                       "1" ((long )to), "2" ((long )from): "memory");
  }
#line 23
  return (to);
}
}
#line 32
extern void *memcpy(void *to , void const   *from , size_t len ) ;
#line 55
extern void *memset(void *s , int c , size_t n ) ;
#line 58
extern void *memmove(void *dest , void const   *src , size_t count ) ;
#line 60
extern int memcmp(void const   *cs , void const   *ct , unsigned long count ) ;
#line 61
extern unsigned long strlen(char const   *s ) ;
#line 62
extern char *strcpy(char *dest , char const   *src ) ;
#line 63
extern char *strcat(char *dest , char const   *src ) ;
#line 64
extern int strcmp(char const   *cs , char const   *ct ) ;
#line 23 "../../../analyzer/../bench/linux-headers/include/linux/string.h"
extern char *strncpy(char * , char const   * , __kernel_size_t  ) ;
#line 26
extern size_t strlcpy(char * , char const   * , size_t  ) ;
#line 32
extern char *strncat(char * , char const   * , __kernel_size_t  ) ;
#line 35
extern size_t strlcat(char * , char const   * , __kernel_size_t  ) ;
#line 41
extern int strncmp(char const   * , char const   * , __kernel_size_t  ) ;
#line 44
extern int strnicmp(char const   * , char const   * , __kernel_size_t  ) ;
#line 47
extern int strcasecmp(char const   *s1 , char const   *s2 ) ;
#line 50
extern int strncasecmp(char const   *s1 , char const   *s2 , size_t n ) ;
#line 53
extern char *strchr(char const   * , int  ) ;
#line 56
extern char *strchrnul(char const   * , int  ) ;
#line 59
extern char *strnchr(char const   * , size_t  , int  ) ;
#line 62
extern char *strrchr(char const   * , int  ) ;
#line 64
extern char *( __attribute__((__warn_unused_result__)) skip_spaces)(char const   * ) ;
#line 66
extern char *strim(char * ) ;
#line 68
__inline static char *( __attribute__((__warn_unused_result__)) strstrip)(char *str )  __attribute__((__no_instrument_function__)) ;
#line 68 "../../../analyzer/../bench/linux-headers/include/linux/string.h"
__inline static char *( __attribute__((__warn_unused_result__)) strstrip)(char *str ) 
{ 
  char *tmp ;

  {
  {
#line 70
  tmp = strim(str);
  }
#line 70
  return (tmp);
}
}
#line 74
extern char *strstr(char const   * , char const   * ) ;
#line 77
extern char *strnstr(char const   * , char const   * , size_t  ) ;
#line 83
extern __kernel_size_t strnlen(char const   * , __kernel_size_t  ) ;
#line 86
extern char *strpbrk(char const   * , char const   * ) ;
#line 89
extern char *strsep(char ** , char const   * ) ;
#line 92
extern __kernel_size_t strspn(char const   * , char const   * ) ;
#line 95
extern __kernel_size_t strcspn(char const   * , char const   * ) ;
#line 108
extern void *memscan(void * , int  , __kernel_size_t  ) ;
#line 114
extern void *memchr(void const   * , int  , __kernel_size_t  ) ;
#line 116
extern void *memchr_inv(void const   *s , int c , size_t n ) ;
#line 118
extern char *kstrdup(char const   *s , gfp_t gfp ) ;
#line 119
extern char *kstrndup(char const   *s , size_t len , gfp_t gfp ) ;
#line 120
extern void *kmemdup(void const   *src , size_t len , gfp_t gfp ) ;
#line 122
extern char **argv_split(gfp_t gfp , char const   *str , int *argcp ) ;
#line 123
extern void argv_free(char **argv ) ;
#line 125
extern bool sysfs_streq(char const   *s1 , char const   *s2 ) ;
#line 126
extern int strtobool(char const   *s , bool *res ) ;
#line 129
extern int vbin_printf(u32 *bin_buf , size_t size , char const   *fmt , va_list args ) ;
#line 130
extern int bstr_printf(char *buf , size_t size , char const   *fmt , u32 const   *bin_buf ) ;
#line 131
extern int ( /* format attribute */  bprintf)(u32 *bin_buf , size_t size , char const   *fmt 
                                              , ...) ;
#line 134
extern ssize_t memory_read_from_buffer(void *to , size_t count , loff_t *ppos , void const   *from ,
                                       size_t available ) ;
#line 142
__inline static bool strstarts(char const   *str , char const   *prefix )  __attribute__((__no_instrument_function__)) ;
#line 142 "../../../analyzer/../bench/linux-headers/include/linux/string.h"
__inline static bool strstarts(char const   *str , char const   *prefix ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
#line 144
  tmp = strlen(prefix);
#line 144
  tmp___0 = strncmp(str, prefix, tmp);
  }
#line 144
  return ((bool )(tmp___0 == 0));
}
}
#line 147
extern size_t memweight(void const   *ptr , size_t bytes ) ;
#line 154
__inline static char const   *kbasename(char const   *path )  __attribute__((__no_instrument_function__)) ;
#line 154 "../../../analyzer/../bench/linux-headers/include/linux/string.h"
__inline static char const   *kbasename(char const   *path ) 
{ 
  char const   *tail ;
  char *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 156
  tmp = strrchr(path, '/');
#line 156
  tail = (char const   *)tmp;
  }
#line 157
  if (tail) {
    {
#line 157
    tmp___0 = tail + 1;
    }
  } else {
    {
#line 157
    tmp___0 = path;
    }
  }
#line 157
  return (tmp___0);
}
}
#line 114 "../../../analyzer/../bench/linux-headers/include/linux/dynamic_debug.h"
__inline static int ddebug_remove_module(char const   *mod )  __attribute__((__no_instrument_function__)) ;
#line 114 "../../../analyzer/../bench/linux-headers/include/linux/dynamic_debug.h"
__inline static int ddebug_remove_module(char const   *mod ) 
{ 


  {
#line 116
  return (0);
}
}
#line 119
__inline static int ddebug_dyndbg_module_param_cb(char *param , char *val , char const   *modname )  __attribute__((__no_instrument_function__)) ;
#line 119 "../../../analyzer/../bench/linux-headers/include/linux/dynamic_debug.h"
__inline static int ddebug_dyndbg_module_param_cb(char *param , char *val , char const   *modname ) 
{ 
  char *tmp ;

  {
  {
#line 122
  tmp = strstr((char const   *)param, "dyndbg");
  }
#line 122
  if (tmp) {
    {
#line 124
    printk("\0014dyndbg param is supported only in CONFIG_DYNAMIC_DEBUG builds\n");
    }
#line 126
    return (0);
  }
#line 128
  return (-22);
}
}
#line 403 "../../../analyzer/../bench/linux-headers/include/linux/printk.h"
extern struct file_operations  const  kmsg_fops ;
#line 410
extern void hex_dump_to_buffer(void const   *buf , size_t len , int rowsize , int groupsize ,
                               char *linebuf , size_t linebuflen , bool ascii ) ;
#line 414
extern void print_hex_dump(char const   *level , char const   *prefix_str , int prefix_type ,
                           int rowsize , int groupsize , void const   *buf , size_t len ,
                           bool ascii ) ;
#line 421
extern void print_hex_dump_bytes(char const   *prefix_str , int prefix_type , void const   *buf ,
                                 size_t len ) ;
#line 158 "../../../analyzer/../bench/linux-headers/include/linux/kernel.h"
extern int _cond_resched(void) ;
#line 179
__inline static void __might_sleep(char const   *file , int line , int preempt_offset )  __attribute__((__no_instrument_function__)) ;
#line 179 "../../../analyzer/../bench/linux-headers/include/linux/kernel.h"
__inline static void __might_sleep(char const   *file , int line , int preempt_offset ) 
{ 


  {
#line 180
  return;
}
}
#line 223
__inline static u32 reciprocal_scale(u32 val , u32 ep_ro )  __attribute__((__no_instrument_function__)) ;
#line 223 "../../../analyzer/../bench/linux-headers/include/linux/kernel.h"
__inline static u32 reciprocal_scale(u32 val , u32 ep_ro ) 
{ 


  {
#line 225
  return ((u32 )((u64 )val * (u64 )ep_ro >> 32));
}
}
#line 232
__inline static void might_fault(void)  __attribute__((__no_instrument_function__)) ;
#line 232 "../../../analyzer/../bench/linux-headers/include/linux/kernel.h"
__inline static void might_fault(void) 
{ 


  {
#line 232
  return;
}
}
#line 235
extern struct atomic_notifier_head panic_notifier_list ;
#line 236
extern long (*panic_blink)(int state ) ;
#line 237
extern  __attribute__((__noreturn__)) void ( /* format attribute */  panic)(char const   *fmt 
                                                                            , ...)  __attribute__((__cold__)) ;
#line 240
extern void oops_enter(void) ;
#line 241
extern void oops_exit(void) ;
#line 242
extern void print_oops_end_marker(void) ;
#line 243
extern int oops_may_print(void) ;
#line 244
extern  __attribute__((__noreturn__)) void do_exit(long error_code ) ;
#line 246
extern  __attribute__((__noreturn__)) void complete_and_exit(struct completion * ,
                                                             long  ) ;
#line 250
extern int ( __attribute__((__warn_unused_result__)) _kstrtoul)(char const   *s ,
                                                                unsigned int base ,
                                                                unsigned long *res ) ;
#line 251
extern int ( __attribute__((__warn_unused_result__)) _kstrtol)(char const   *s , unsigned int base ,
                                                               long *res ) ;
#line 253
extern int ( __attribute__((__warn_unused_result__)) kstrtoull)(char const   *s ,
                                                                unsigned int base ,
                                                                unsigned long long *res ) ;
#line 254
extern int ( __attribute__((__warn_unused_result__)) kstrtoll)(char const   *s , unsigned int base ,
                                                               long long *res ) ;
#line 272
__inline static int ( __attribute__((__warn_unused_result__)) kstrtoul)(char const   *s ,
                                                                        unsigned int base ,
                                                                        unsigned long *res )  __attribute__((__no_instrument_function__)) ;
#line 272 "../../../analyzer/../bench/linux-headers/include/linux/kernel.h"
__inline static int ( __attribute__((__warn_unused_result__)) kstrtoul)(char const   *s ,
                                                                        unsigned int base ,
                                                                        unsigned long *res ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 278
  if (sizeof(unsigned long ) == sizeof(unsigned long long )) {
#line 278
    if (__alignof__(unsigned long ) == __alignof__(unsigned long long )) {
      {
#line 280
      tmp = kstrtoull(s, base, (unsigned long long *)res);
      }
#line 280
      return (tmp);
    } else {
      {
#line 282
      tmp___0 = _kstrtoul(s, base, res);
      }
#line 282
      return (tmp___0);
    }
  } else {
    {
#line 282
    tmp___0 = _kstrtoul(s, base, res);
    }
#line 282
    return (tmp___0);
  }
}
}
#line 301
__inline static int ( __attribute__((__warn_unused_result__)) kstrtol)(char const   *s ,
                                                                       unsigned int base ,
                                                                       long *res )  __attribute__((__no_instrument_function__)) ;
#line 301 "../../../analyzer/../bench/linux-headers/include/linux/kernel.h"
__inline static int ( __attribute__((__warn_unused_result__)) kstrtol)(char const   *s ,
                                                                       unsigned int base ,
                                                                       long *res ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 307
  if (sizeof(long ) == sizeof(long long )) {
#line 307
    if (__alignof__(long ) == __alignof__(long long )) {
      {
#line 309
      tmp = kstrtoll(s, base, (long long *)res);
      }
#line 309
      return (tmp);
    } else {
      {
#line 311
      tmp___0 = _kstrtol(s, base, res);
      }
#line 311
      return (tmp___0);
    }
  } else {
    {
#line 311
    tmp___0 = _kstrtol(s, base, res);
    }
#line 311
    return (tmp___0);
  }
}
}
#line 314
extern int ( __attribute__((__warn_unused_result__)) kstrtouint)(char const   *s ,
                                                                 unsigned int base ,
                                                                 unsigned int *res ) ;
#line 315
extern int ( __attribute__((__warn_unused_result__)) kstrtoint)(char const   *s ,
                                                                unsigned int base ,
                                                                int *res ) ;
#line 317
__inline static int ( __attribute__((__warn_unused_result__)) kstrtou64)(char const   *s ,
                                                                         unsigned int base ,
                                                                         u64 *res )  __attribute__((__no_instrument_function__)) ;
#line 317 "../../../analyzer/../bench/linux-headers/include/linux/kernel.h"
__inline static int ( __attribute__((__warn_unused_result__)) kstrtou64)(char const   *s ,
                                                                         unsigned int base ,
                                                                         u64 *res ) 
{ 
  int tmp ;

  {
  {
#line 319
  tmp = kstrtoull(s, base, res);
  }
#line 319
  return (tmp);
}
}
#line 322
__inline static int ( __attribute__((__warn_unused_result__)) kstrtos64)(char const   *s ,
                                                                         unsigned int base ,
                                                                         s64 *res )  __attribute__((__no_instrument_function__)) ;
#line 322 "../../../analyzer/../bench/linux-headers/include/linux/kernel.h"
__inline static int ( __attribute__((__warn_unused_result__)) kstrtos64)(char const   *s ,
                                                                         unsigned int base ,
                                                                         s64 *res ) 
{ 
  int tmp ;

  {
  {
#line 324
  tmp = kstrtoll(s, base, res);
  }
#line 324
  return (tmp);
}
}
#line 327
__inline static int ( __attribute__((__warn_unused_result__)) kstrtou32)(char const   *s ,
                                                                         unsigned int base ,
                                                                         u32 *res )  __attribute__((__no_instrument_function__)) ;
#line 327 "../../../analyzer/../bench/linux-headers/include/linux/kernel.h"
__inline static int ( __attribute__((__warn_unused_result__)) kstrtou32)(char const   *s ,
                                                                         unsigned int base ,
                                                                         u32 *res ) 
{ 
  int tmp ;

  {
  {
#line 329
  tmp = kstrtouint(s, base, res);
  }
#line 329
  return (tmp);
}
}
#line 332
__inline static int ( __attribute__((__warn_unused_result__)) kstrtos32)(char const   *s ,
                                                                         unsigned int base ,
                                                                         s32 *res )  __attribute__((__no_instrument_function__)) ;
#line 332 "../../../analyzer/../bench/linux-headers/include/linux/kernel.h"
__inline static int ( __attribute__((__warn_unused_result__)) kstrtos32)(char const   *s ,
                                                                         unsigned int base ,
                                                                         s32 *res ) 
{ 
  int tmp ;

  {
  {
#line 334
  tmp = kstrtoint(s, base, res);
  }
#line 334
  return (tmp);
}
}
#line 337
extern int ( __attribute__((__warn_unused_result__)) kstrtou16)(char const   *s ,
                                                                unsigned int base ,
                                                                u16 *res ) ;
#line 338
extern int ( __attribute__((__warn_unused_result__)) kstrtos16)(char const   *s ,
                                                                unsigned int base ,
                                                                s16 *res ) ;
#line 339
extern int ( __attribute__((__warn_unused_result__)) kstrtou8)(char const   *s , unsigned int base ,
                                                               u8 *res ) ;
#line 340
extern int ( __attribute__((__warn_unused_result__)) kstrtos8)(char const   *s , unsigned int base ,
                                                               s8 *res ) ;
#line 342
extern int ( __attribute__((__warn_unused_result__)) kstrtoull_from_user)(char const   *s ,
                                                                          size_t count ,
                                                                          unsigned int base ,
                                                                          unsigned long long *res ) ;
#line 343
extern int ( __attribute__((__warn_unused_result__)) kstrtoll_from_user)(char const   *s ,
                                                                         size_t count ,
                                                                         unsigned int base ,
                                                                         long long *res ) ;
#line 344
extern int ( __attribute__((__warn_unused_result__)) kstrtoul_from_user)(char const   *s ,
                                                                         size_t count ,
                                                                         unsigned int base ,
                                                                         unsigned long *res ) ;
#line 345
extern int ( __attribute__((__warn_unused_result__)) kstrtol_from_user)(char const   *s ,
                                                                        size_t count ,
                                                                        unsigned int base ,
                                                                        long *res ) ;
#line 346
extern int ( __attribute__((__warn_unused_result__)) kstrtouint_from_user)(char const   *s ,
                                                                           size_t count ,
                                                                           unsigned int base ,
                                                                           unsigned int *res ) ;
#line 347
extern int ( __attribute__((__warn_unused_result__)) kstrtoint_from_user)(char const   *s ,
                                                                          size_t count ,
                                                                          unsigned int base ,
                                                                          int *res ) ;
#line 348
extern int ( __attribute__((__warn_unused_result__)) kstrtou16_from_user)(char const   *s ,
                                                                          size_t count ,
                                                                          unsigned int base ,
                                                                          u16 *res ) ;
#line 349
extern int ( __attribute__((__warn_unused_result__)) kstrtos16_from_user)(char const   *s ,
                                                                          size_t count ,
                                                                          unsigned int base ,
                                                                          s16 *res ) ;
#line 350
extern int ( __attribute__((__warn_unused_result__)) kstrtou8_from_user)(char const   *s ,
                                                                         size_t count ,
                                                                         unsigned int base ,
                                                                         u8 *res ) ;
#line 351
extern int ( __attribute__((__warn_unused_result__)) kstrtos8_from_user)(char const   *s ,
                                                                         size_t count ,
                                                                         unsigned int base ,
                                                                         s8 *res ) ;
#line 353
__inline static int ( __attribute__((__warn_unused_result__)) kstrtou64_from_user)(char const   *s ,
                                                                                   size_t count ,
                                                                                   unsigned int base ,
                                                                                   u64 *res )  __attribute__((__no_instrument_function__)) ;
#line 353 "../../../analyzer/../bench/linux-headers/include/linux/kernel.h"
__inline static int ( __attribute__((__warn_unused_result__)) kstrtou64_from_user)(char const   *s ,
                                                                                   size_t count ,
                                                                                   unsigned int base ,
                                                                                   u64 *res ) 
{ 
  int tmp ;

  {
  {
#line 355
  tmp = kstrtoull_from_user(s, count, base, res);
  }
#line 355
  return (tmp);
}
}
#line 358
__inline static int ( __attribute__((__warn_unused_result__)) kstrtos64_from_user)(char const   *s ,
                                                                                   size_t count ,
                                                                                   unsigned int base ,
                                                                                   s64 *res )  __attribute__((__no_instrument_function__)) ;
#line 358 "../../../analyzer/../bench/linux-headers/include/linux/kernel.h"
__inline static int ( __attribute__((__warn_unused_result__)) kstrtos64_from_user)(char const   *s ,
                                                                                   size_t count ,
                                                                                   unsigned int base ,
                                                                                   s64 *res ) 
{ 
  int tmp ;

  {
  {
#line 360
  tmp = kstrtoll_from_user(s, count, base, res);
  }
#line 360
  return (tmp);
}
}
#line 363
__inline static int ( __attribute__((__warn_unused_result__)) kstrtou32_from_user)(char const   *s ,
                                                                                   size_t count ,
                                                                                   unsigned int base ,
                                                                                   u32 *res )  __attribute__((__no_instrument_function__)) ;
#line 363 "../../../analyzer/../bench/linux-headers/include/linux/kernel.h"
__inline static int ( __attribute__((__warn_unused_result__)) kstrtou32_from_user)(char const   *s ,
                                                                                   size_t count ,
                                                                                   unsigned int base ,
                                                                                   u32 *res ) 
{ 
  int tmp ;

  {
  {
#line 365
  tmp = kstrtouint_from_user(s, count, base, res);
  }
#line 365
  return (tmp);
}
}
#line 368
__inline static int ( __attribute__((__warn_unused_result__)) kstrtos32_from_user)(char const   *s ,
                                                                                   size_t count ,
                                                                                   unsigned int base ,
                                                                                   s32 *res )  __attribute__((__no_instrument_function__)) ;
#line 368 "../../../analyzer/../bench/linux-headers/include/linux/kernel.h"
__inline static int ( __attribute__((__warn_unused_result__)) kstrtos32_from_user)(char const   *s ,
                                                                                   size_t count ,
                                                                                   unsigned int base ,
                                                                                   s32 *res ) 
{ 
  int tmp ;

  {
  {
#line 370
  tmp = kstrtoint_from_user(s, count, base, res);
  }
#line 370
  return (tmp);
}
}
#line 375
extern unsigned long simple_strtoul(char const   * , char ** , unsigned int  ) ;
#line 376
extern long simple_strtol(char const   * , char ** , unsigned int  ) ;
#line 377
extern unsigned long long simple_strtoull(char const   * , char ** , unsigned int  ) ;
#line 378
extern long long simple_strtoll(char const   * , char ** , unsigned int  ) ;
#line 384
extern int num_to_str(char *buf , int size , unsigned long long num ) ;
#line 388
extern int ( /* format attribute */  sprintf)(char *buf , char const   *fmt  , ...) ;
#line 389
extern int ( /* format attribute */  vsprintf)(char *buf , char const   * , va_list  ) ;
#line 390
extern int ( /* format attribute */  snprintf)(char *buf , size_t size , char const   *fmt 
                                               , ...) ;
#line 392
extern int ( /* format attribute */  vsnprintf)(char *buf , size_t size , char const   *fmt ,
                                                va_list args ) ;
#line 394
extern int ( /* format attribute */  scnprintf)(char *buf , size_t size , char const   *fmt 
                                                , ...) ;
#line 396
extern int ( /* format attribute */  vscnprintf)(char *buf , size_t size , char const   *fmt ,
                                                 va_list args ) ;
#line 398
extern char *( /* format attribute */  kasprintf)(gfp_t gfp , char const   *fmt  , ...) ;
#line 400
extern char *kvasprintf(gfp_t gfp , char const   *fmt , va_list args ) ;
#line 402
extern int ( /* format attribute */  sscanf)(char const   * , char const   *  , ...) ;
#line 404
extern int ( /* format attribute */  vsscanf)(char const   * , char const   * , va_list  ) ;
#line 407
extern int get_option(char **str , int *pint ) ;
#line 408
extern char *get_options(char const   *str , int nints , int *ints ) ;
#line 409
extern unsigned long long memparse(char const   *ptr , char **retptr ) ;
#line 411
extern int core_kernel_text(unsigned long addr ) ;
#line 412
extern int core_kernel_data(unsigned long addr ) ;
#line 413
extern int __kernel_text_address(unsigned long addr ) ;
#line 414
extern int kernel_text_address(unsigned long addr ) ;
#line 415
extern int func_ptr_is_kernel_text(void *ptr ) ;
#line 418
extern struct pid *session_of_pgrp(struct pid *pgrp ) ;
#line 420
extern unsigned long int_sqrt(unsigned long  ) ;
#line 422
extern void bust_spinlocks(int yes ) ;
#line 423
extern int oops_in_progress ;
#line 424
extern int panic_timeout ;
#line 425
extern int panic_on_oops ;
#line 426
extern int panic_on_unrecovered_nmi ;
#line 427
extern int panic_on_io_nmi ;
#line 428
extern int sysctl_panic_on_stackoverflow ;
#line 433
__inline static void set_arch_panic_timeout(int timeout , int arch_default_timeout )  __attribute__((__no_instrument_function__)) ;
#line 433 "../../../analyzer/../bench/linux-headers/include/linux/kernel.h"
__inline static void set_arch_panic_timeout(int timeout , int arch_default_timeout ) 
{ 


  {
#line 435
  if (panic_timeout == arch_default_timeout) {
    {
#line 436
    panic_timeout = timeout;
    }
  }
#line 437
  return;
}
}
#line 438
extern char const   *print_tainted(void) ;
#line 443
extern void add_taint(unsigned int flag , enum lockdep_ok  ) ;
#line 444
extern int test_taint(unsigned int flag ) ;
#line 445
extern unsigned long get_taint(void) ;
#line 446
extern int root_mountflags ;
#line 448
extern bool early_boot_irqs_disabled ;
#line 451
extern enum system_states system_state ;
#line 475
extern char const   hex_asc[] ;
#line 479
__inline static char *hex_byte_pack(char *buf , u8 byte )  __attribute__((__no_instrument_function__)) ;
#line 479 "../../../analyzer/../bench/linux-headers/include/linux/kernel.h"
__inline static char *hex_byte_pack(char *buf , u8 byte ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 481
  tmp = buf;
#line 481
  buf ++;
#line 481
  *tmp = (char )hex_asc[((int )byte & 240) >> 4];
#line 482
  tmp___0 = buf;
#line 482
  buf ++;
#line 482
  *tmp___0 = (char )hex_asc[(int )byte & 15];
  }
#line 483
  return (buf);
}
}
#line 486
extern char const   hex_asc_upper[] ;
#line 490
__inline static char *hex_byte_pack_upper(char *buf , u8 byte )  __attribute__((__no_instrument_function__)) ;
#line 490 "../../../analyzer/../bench/linux-headers/include/linux/kernel.h"
__inline static char *hex_byte_pack_upper(char *buf , u8 byte ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 492
  tmp = buf;
#line 492
  buf ++;
#line 492
  *tmp = (char )hex_asc_upper[((int )byte & 240) >> 4];
#line 493
  tmp___0 = buf;
#line 493
  buf ++;
#line 493
  *tmp___0 = (char )hex_asc_upper[(int )byte & 15];
  }
#line 494
  return (buf);
}
}
#line 497
extern int hex_to_bin(char ch ) ;
#line 498
extern int ( __attribute__((__warn_unused_result__)) hex2bin)(u8 *dst , char const   *src ,
                                                              size_t count ) ;
#line 500
extern bool mac_pton(char const   *s , u8 *mac ) ;
#line 523
extern void tracing_off_permanent(void) ;
#line 535
extern void tracing_on(void) ;
#line 536
extern void tracing_off(void) ;
#line 537
extern int tracing_is_on(void) ;
#line 538
extern void tracing_snapshot(void) ;
#line 539
extern void tracing_snapshot_alloc(void) ;
#line 541
extern void tracing_start(void) ;
#line 542
extern void tracing_stop(void) ;
#line 544
__inline static void ( /* format attribute */  ____trace_printk_check_format)(char const   *fmt 
                                                                              , ...)  __attribute__((__no_instrument_function__)) ;
#line 544 "../../../analyzer/../bench/linux-headers/include/linux/kernel.h"
__inline static void ( /* format attribute */  ____trace_printk_check_format)(char const   *fmt 
                                                                              , ...) 
{ 


  {
#line 547
  return;
}
}
#line 607
extern int ( /* format attribute */  __trace_bprintk)(unsigned long ip , char const   *fmt 
                                                      , ...) ;
#line 610
extern int ( /* format attribute */  __trace_printk)(unsigned long ip , char const   *fmt 
                                                     , ...) ;
#line 648
extern int __trace_bputs(unsigned long ip , char const   *str ) ;
#line 649
extern int __trace_puts(unsigned long ip , char const   *str , int size ) ;
#line 651
extern void trace_dump_stack(int skip ) ;
#line 670
extern int __ftrace_vbprintk(unsigned long ip , char const   *fmt , va_list ap ) ;
#line 673
extern int __ftrace_vprintk(unsigned long ip , char const   *fmt , va_list ap ) ;
#line 676
extern void ftrace_dump(enum ftrace_dump_mode oops_dump_mode ) ;
#line 24 "../../../analyzer/../bench/linux-headers/include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list )  __attribute__((__no_instrument_function__)) ;
#line 24 "../../../analyzer/../bench/linux-headers/include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
  {
#line 26
  list->next = list;
#line 27
  list->prev = list;
  }
#line 28
  return;
}
}
#line 37
__inline static void __list_add(struct list_head *new , struct list_head *prev , struct list_head *next )  __attribute__((__no_instrument_function__)) ;
#line 37 "../../../analyzer/../bench/linux-headers/include/linux/list.h"
__inline static void __list_add(struct list_head *new , struct list_head *prev , struct list_head *next ) 
{ 


  {
  {
#line 41
  next->prev = new;
#line 42
  new->next = next;
#line 43
  new->prev = prev;
#line 44
  prev->next = new;
  }
#line 45
  return;
}
}
#line 60
__inline static void list_add(struct list_head *new , struct list_head *head )  __attribute__((__no_instrument_function__)) ;
#line 60 "../../../analyzer/../bench/linux-headers/include/linux/list.h"
__inline static void list_add(struct list_head *new , struct list_head *head ) 
{ 


  {
  {
#line 62
  __list_add(new, head, head->next);
  }
#line 63
  return;
}
}
#line 74
__inline static void list_add_tail(struct list_head *new , struct list_head *head )  __attribute__((__no_instrument_function__)) ;
#line 74 "../../../analyzer/../bench/linux-headers/include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 


  {
  {
#line 76
  __list_add(new, head->prev, head);
  }
#line 77
  return;
}
}
#line 86
__inline static void __list_del(struct list_head *prev , struct list_head *next )  __attribute__((__no_instrument_function__)) ;
#line 86 "../../../analyzer/../bench/linux-headers/include/linux/list.h"
__inline static void __list_del(struct list_head *prev , struct list_head *next ) 
{ 


  {
  {
#line 88
  next->prev = prev;
#line 89
  prev->next = next;
  }
#line 90
  return;
}
}
#line 99
__inline static void __list_del_entry(struct list_head *entry )  __attribute__((__no_instrument_function__)) ;
#line 99 "../../../analyzer/../bench/linux-headers/include/linux/list.h"
__inline static void __list_del_entry(struct list_head *entry ) 
{ 


  {
  {
#line 101
  __list_del(entry->prev, entry->next);
  }
#line 102
  return;
}
}
#line 104
__inline static void list_del(struct list_head *entry )  __attribute__((__no_instrument_function__)) ;
#line 104 "../../../analyzer/../bench/linux-headers/include/linux/list.h"
__inline static void list_del(struct list_head *entry ) 
{ 


  {
  {
#line 106
  __list_del(entry->prev, entry->next);
#line 107
  entry->next = (struct list_head *)((void *)1048832 + 0xdead000000000000UL);
#line 108
  entry->prev = (struct list_head *)((void *)2097664 + 0xdead000000000000UL);
  }
#line 109
  return;
}
}
#line 122
__inline static void list_replace(struct list_head *old , struct list_head *new )  __attribute__((__no_instrument_function__)) ;
#line 122 "../../../analyzer/../bench/linux-headers/include/linux/list.h"
__inline static void list_replace(struct list_head *old , struct list_head *new ) 
{ 


  {
  {
#line 125
  new->next = old->next;
#line 126
  (new->next)->prev = new;
#line 127
  new->prev = old->prev;
#line 128
  (new->prev)->next = new;
  }
#line 129
  return;
}
}
#line 131
__inline static void list_replace_init(struct list_head *old , struct list_head *new )  __attribute__((__no_instrument_function__)) ;
#line 131 "../../../analyzer/../bench/linux-headers/include/linux/list.h"
__inline static void list_replace_init(struct list_head *old , struct list_head *new ) 
{ 


  {
  {
#line 134
  list_replace(old, new);
#line 135
  INIT_LIST_HEAD(old);
  }
#line 136
  return;
}
}
#line 142
__inline static void list_del_init(struct list_head *entry )  __attribute__((__no_instrument_function__)) ;
#line 142 "../../../analyzer/../bench/linux-headers/include/linux/list.h"
__inline static void list_del_init(struct list_head *entry ) 
{ 


  {
  {
#line 144
  __list_del_entry(entry);
#line 145
  INIT_LIST_HEAD(entry);
  }
#line 146
  return;
}
}
#line 153
__inline static void list_move(struct list_head *list , struct list_head *head )  __attribute__((__no_instrument_function__)) ;
#line 153 "../../../analyzer/../bench/linux-headers/include/linux/list.h"
__inline static void list_move(struct list_head *list , struct list_head *head ) 
{ 


  {
  {
#line 155
  __list_del_entry(list);
#line 156
  list_add(list, head);
  }
#line 157
  return;
}
}
#line 164
__inline static void list_move_tail(struct list_head *list , struct list_head *head )  __attribute__((__no_instrument_function__)) ;
#line 164 "../../../analyzer/../bench/linux-headers/include/linux/list.h"
__inline static void list_move_tail(struct list_head *list , struct list_head *head ) 
{ 


  {
  {
#line 167
  __list_del_entry(list);
#line 168
  list_add_tail(list, head);
  }
#line 169
  return;
}
}
#line 176
__inline static int list_is_last(struct list_head  const  *list , struct list_head  const  *head )  __attribute__((__no_instrument_function__)) ;
#line 176 "../../../analyzer/../bench/linux-headers/include/linux/list.h"
__inline static int list_is_last(struct list_head  const  *list , struct list_head  const  *head ) 
{ 


  {
#line 179
  return ((unsigned long )list->next == (unsigned long )head);
}
}
#line 186
__inline static int list_empty(struct list_head  const  *head )  __attribute__((__no_instrument_function__)) ;
#line 186 "../../../analyzer/../bench/linux-headers/include/linux/list.h"
__inline static int list_empty(struct list_head  const  *head ) 
{ 


  {
#line 188
  return ((unsigned long )head->next == (unsigned long )head);
}
}
#line 204
__inline static int list_empty_careful(struct list_head  const  *head )  __attribute__((__no_instrument_function__)) ;
#line 204 "../../../analyzer/../bench/linux-headers/include/linux/list.h"
__inline static int list_empty_careful(struct list_head  const  *head ) 
{ 
  struct list_head *next ;
  int tmp ;

  {
  {
#line 206
  next = (struct list_head *)head->next;
  }
#line 207
  if ((unsigned long )next == (unsigned long )head) {
#line 207
    if ((unsigned long )next == (unsigned long )head->prev) {
      {
#line 207
      tmp = 1;
      }
    } else {
      {
#line 207
      tmp = 0;
      }
    }
  } else {
    {
#line 207
    tmp = 0;
    }
  }
#line 207
  return (tmp);
}
}
#line 214
__inline static void list_rotate_left(struct list_head *head )  __attribute__((__no_instrument_function__)) ;
#line 214 "../../../analyzer/../bench/linux-headers/include/linux/list.h"
__inline static void list_rotate_left(struct list_head *head ) 
{ 
  struct list_head *first ;
  int tmp ;

  {
  {
#line 218
  tmp = list_empty((struct list_head  const  *)head);
  }
#line 218
  if (! tmp) {
    {
#line 219
    first = head->next;
#line 220
    list_move_tail(first, head);
    }
  }
#line 222
  return;
}
}
#line 228
__inline static int list_is_singular(struct list_head  const  *head )  __attribute__((__no_instrument_function__)) ;
#line 228 "../../../analyzer/../bench/linux-headers/include/linux/list.h"
__inline static int list_is_singular(struct list_head  const  *head ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 230
  tmp = list_empty(head);
  }
#line 230
  if (tmp) {
    {
#line 230
    tmp___0 = 0;
    }
  } else
#line 230
  if ((unsigned long )head->next == (unsigned long )head->prev) {
    {
#line 230
    tmp___0 = 1;
    }
  } else {
    {
#line 230
    tmp___0 = 0;
    }
  }
#line 230
  return (tmp___0);
}
}
#line 233
__inline static void __list_cut_position(struct list_head *list , struct list_head *head ,
                                         struct list_head *entry )  __attribute__((__no_instrument_function__)) ;
#line 233 "../../../analyzer/../bench/linux-headers/include/linux/list.h"
__inline static void __list_cut_position(struct list_head *list , struct list_head *head ,
                                         struct list_head *entry ) 
{ 
  struct list_head *new_first ;

  {
  {
#line 236
  new_first = entry->next;
#line 237
  list->next = head->next;
#line 238
  (list->next)->prev = list;
#line 239
  list->prev = entry;
#line 240
  entry->next = list;
#line 241
  head->next = new_first;
#line 242
  new_first->prev = head;
  }
#line 243
  return;
}
}
#line 259
__inline static void list_cut_position(struct list_head *list , struct list_head *head ,
                                       struct list_head *entry )  __attribute__((__no_instrument_function__)) ;
#line 259 "../../../analyzer/../bench/linux-headers/include/linux/list.h"
__inline static void list_cut_position(struct list_head *list , struct list_head *head ,
                                       struct list_head *entry ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 262
  tmp = list_empty((struct list_head  const  *)head);
  }
#line 262
  if (tmp) {
#line 263
    return;
  }
  {
#line 264
  tmp___0 = list_is_singular((struct list_head  const  *)head);
  }
#line 264
  if (tmp___0) {
#line 264
    if ((unsigned long )head->next != (unsigned long )entry) {
#line 264
      if ((unsigned long )head != (unsigned long )entry) {
#line 266
        return;
      }
    }
  }
#line 267
  if ((unsigned long )entry == (unsigned long )head) {
    {
#line 268
    INIT_LIST_HEAD(list);
    }
  } else {
    {
#line 270
    __list_cut_position(list, head, entry);
    }
  }
#line 271
  return;
}
}
#line 273
__inline static void __list_splice(struct list_head  const  *list , struct list_head *prev ,
                                   struct list_head *next )  __attribute__((__no_instrument_function__)) ;
#line 273 "../../../analyzer/../bench/linux-headers/include/linux/list.h"
__inline static void __list_splice(struct list_head  const  *list , struct list_head *prev ,
                                   struct list_head *next ) 
{ 
  struct list_head *first ;
  struct list_head *last ;

  {
  {
#line 277
  first = (struct list_head *)list->next;
#line 278
  last = (struct list_head *)list->prev;
#line 280
  first->prev = prev;
#line 281
  prev->next = first;
#line 283
  last->next = next;
#line 284
  next->prev = last;
  }
#line 285
  return;
}
}
#line 292
__inline static void list_splice(struct list_head  const  *list , struct list_head *head )  __attribute__((__no_instrument_function__)) ;
#line 292 "../../../analyzer/../bench/linux-headers/include/linux/list.h"
__inline static void list_splice(struct list_head  const  *list , struct list_head *head ) 
{ 
  int tmp ;

  {
  {
#line 295
  tmp = list_empty(list);
  }
#line 295
  if (! tmp) {
    {
#line 296
    __list_splice(list, head, head->next);
    }
  }
#line 297
  return;
}
}
#line 304
__inline static void list_splice_tail(struct list_head *list , struct list_head *head )  __attribute__((__no_instrument_function__)) ;
#line 304 "../../../analyzer/../bench/linux-headers/include/linux/list.h"
__inline static void list_splice_tail(struct list_head *list , struct list_head *head ) 
{ 
  int tmp ;

  {
  {
#line 307
  tmp = list_empty((struct list_head  const  *)list);
  }
#line 307
  if (! tmp) {
    {
#line 308
    __list_splice((struct list_head  const  *)list, head->prev, head);
    }
  }
#line 309
  return;
}
}
#line 318
__inline static void list_splice_init(struct list_head *list , struct list_head *head )  __attribute__((__no_instrument_function__)) ;
#line 318 "../../../analyzer/../bench/linux-headers/include/linux/list.h"
__inline static void list_splice_init(struct list_head *list , struct list_head *head ) 
{ 
  int tmp ;

  {
  {
#line 321
  tmp = list_empty((struct list_head  const  *)list);
  }
#line 321
  if (! tmp) {
    {
#line 322
    __list_splice((struct list_head  const  *)list, head, head->next);
#line 323
    INIT_LIST_HEAD(list);
    }
  }
#line 325
  return;
}
}
#line 335
__inline static void list_splice_tail_init(struct list_head *list , struct list_head *head )  __attribute__((__no_instrument_function__)) ;
#line 335 "../../../analyzer/../bench/linux-headers/include/linux/list.h"
__inline static void list_splice_tail_init(struct list_head *list , struct list_head *head ) 
{ 
  int tmp ;

  {
  {
#line 338
  tmp = list_empty((struct list_head  const  *)list);
  }
#line 338
  if (! tmp) {
    {
#line 339
    __list_splice((struct list_head  const  *)list, head->prev, head);
#line 340
    INIT_LIST_HEAD(list);
    }
  }
#line 342
  return;
}
}
#line 597
__inline static void INIT_HLIST_NODE(struct hlist_node *h )  __attribute__((__no_instrument_function__)) ;
#line 597 "../../../analyzer/../bench/linux-headers/include/linux/list.h"
__inline static void INIT_HLIST_NODE(struct hlist_node *h ) 
{ 


  {
  {
#line 599
  h->next = (struct hlist_node *)((void *)0);
#line 600
  h->pprev = (struct hlist_node **)((void *)0);
  }
#line 601
  return;
}
}
#line 603
__inline static int hlist_unhashed(struct hlist_node  const  *h )  __attribute__((__no_instrument_function__)) ;
#line 603 "../../../analyzer/../bench/linux-headers/include/linux/list.h"
__inline static int hlist_unhashed(struct hlist_node  const  *h ) 
{ 


  {
#line 605
  return (! h->pprev);
}
}
#line 608
__inline static int hlist_empty(struct hlist_head  const  *h )  __attribute__((__no_instrument_function__)) ;
#line 608 "../../../analyzer/../bench/linux-headers/include/linux/list.h"
__inline static int hlist_empty(struct hlist_head  const  *h ) 
{ 


  {
#line 610
  return (! h->first);
}
}
#line 613
__inline static void __hlist_del(struct hlist_node *n )  __attribute__((__no_instrument_function__)) ;
#line 613 "../../../analyzer/../bench/linux-headers/include/linux/list.h"
__inline static void __hlist_del(struct hlist_node *n ) 
{ 
  struct hlist_node *next ;
  struct hlist_node **pprev ;

  {
  {
#line 615
  next = n->next;
#line 616
  pprev = n->pprev;
#line 617
  *pprev = next;
  }
#line 618
  if (next) {
    {
#line 619
    next->pprev = pprev;
    }
  }
#line 620
  return;
}
}
#line 622
__inline static void hlist_del(struct hlist_node *n )  __attribute__((__no_instrument_function__)) ;
#line 622 "../../../analyzer/../bench/linux-headers/include/linux/list.h"
__inline static void hlist_del(struct hlist_node *n ) 
{ 


  {
  {
#line 624
  __hlist_del(n);
#line 625
  n->next = (struct hlist_node *)((void *)1048832 + 0xdead000000000000UL);
#line 626
  n->pprev = (struct hlist_node **)((void *)2097664 + 0xdead000000000000UL);
  }
#line 627
  return;
}
}
#line 629
__inline static void hlist_del_init(struct hlist_node *n )  __attribute__((__no_instrument_function__)) ;
#line 629 "../../../analyzer/../bench/linux-headers/include/linux/list.h"
__inline static void hlist_del_init(struct hlist_node *n ) 
{ 
  int tmp ;

  {
  {
#line 631
  tmp = hlist_unhashed((struct hlist_node  const  *)n);
  }
#line 631
  if (! tmp) {
    {
#line 632
    __hlist_del(n);
#line 633
    INIT_HLIST_NODE(n);
    }
  }
#line 635
  return;
}
}
#line 637
__inline static void hlist_add_head(struct hlist_node *n , struct hlist_head *h )  __attribute__((__no_instrument_function__)) ;
#line 637 "../../../analyzer/../bench/linux-headers/include/linux/list.h"
__inline static void hlist_add_head(struct hlist_node *n , struct hlist_head *h ) 
{ 
  struct hlist_node *first ;

  {
  {
#line 639
  first = h->first;
#line 640
  n->next = first;
  }
#line 641
  if (first) {
    {
#line 642
    first->pprev = & n->next;
    }
  }
  {
#line 643
  h->first = n;
#line 644
  n->pprev = & h->first;
  }
#line 645
  return;
}
}
#line 648
__inline static void hlist_add_before(struct hlist_node *n , struct hlist_node *next )  __attribute__((__no_instrument_function__)) ;
#line 648 "../../../analyzer/../bench/linux-headers/include/linux/list.h"
__inline static void hlist_add_before(struct hlist_node *n , struct hlist_node *next ) 
{ 


  {
  {
#line 651
  n->pprev = next->pprev;
#line 652
  n->next = next;
#line 653
  next->pprev = & n->next;
#line 654
  *(n->pprev) = n;
  }
#line 655
  return;
}
}
#line 657
__inline static void hlist_add_behind(struct hlist_node *n , struct hlist_node *prev )  __attribute__((__no_instrument_function__)) ;
#line 657 "../../../analyzer/../bench/linux-headers/include/linux/list.h"
__inline static void hlist_add_behind(struct hlist_node *n , struct hlist_node *prev ) 
{ 


  {
  {
#line 660
  n->next = prev->next;
#line 661
  prev->next = n;
#line 662
  n->pprev = & prev->next;
  }
#line 664
  if (n->next) {
    {
#line 665
    (n->next)->pprev = & n->next;
    }
  }
#line 666
  return;
}
}
#line 669
__inline static void hlist_add_fake(struct hlist_node *n )  __attribute__((__no_instrument_function__)) ;
#line 669 "../../../analyzer/../bench/linux-headers/include/linux/list.h"
__inline static void hlist_add_fake(struct hlist_node *n ) 
{ 


  {
  {
#line 671
  n->pprev = & n->next;
  }
#line 672
  return;
}
}
#line 678
__inline static void hlist_move_list(struct hlist_head *old , struct hlist_head *new )  __attribute__((__no_instrument_function__)) ;
#line 678 "../../../analyzer/../bench/linux-headers/include/linux/list.h"
__inline static void hlist_move_list(struct hlist_head *old , struct hlist_head *new ) 
{ 


  {
  {
#line 681
  new->first = old->first;
  }
#line 682
  if (new->first) {
    {
#line 683
    (new->first)->pprev = & new->first;
    }
  }
  {
#line 684
  old->first = (struct hlist_node *)((void *)0);
  }
#line 685
  return;
}
}
#line 87 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 491
__inline static int ( __attribute__((__always_inline__)) x86_this_cpu_constant_test_bit)(unsigned int nr ,
                                                                                         unsigned long const   *addr )  __attribute__((__no_instrument_function__)) ;
#line 491 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/percpu.h"
__inline static int ( __attribute__((__always_inline__)) x86_this_cpu_constant_test_bit)(unsigned int nr ,
                                                                                         unsigned long const   *addr ) 
{ 
  unsigned long *a ;
  unsigned long pfo_ret__ ;

  {
  {
#line 494
  a = (unsigned long *)addr + nr / 64U;
  }
  {
#line 497
  if (sizeof(*a) == 1UL) {
#line 497
    goto case_1;
  }
#line 497
  if (sizeof(*a) == 2UL) {
#line 497
    goto case_2;
  }
#line 497
  if (sizeof(*a) == 4UL) {
#line 497
    goto case_4;
  }
#line 497
  if (sizeof(*a) == 8UL) {
#line 497
    goto case_8;
  }
#line 497
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 497
  __asm__  ("mov"
            "b "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=q" (pfo_ret__): "m" (*a));
  }
#line 497
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 497
  __asm__  ("mov"
            "w "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret__): "m" (*a));
  }
#line 497
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 497
  __asm__  ("mov"
            "l "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret__): "m" (*a));
  }
#line 497
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 497
  __asm__  ("mov"
            "q "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret__): "m" (*a));
  }
#line 497
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 497
  __bad_percpu_size();
  }
  switch_break: /* CIL Label */ ;
  }
#line 497
  return (((1UL << nr % 64U) & pfo_ret__) != 0UL);
}
}
#line 503
__inline static int x86_this_cpu_variable_test_bit(int nr , unsigned long const   *addr )  __attribute__((__no_instrument_function__)) ;
#line 503 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/percpu.h"
__inline static int x86_this_cpu_variable_test_bit(int nr , unsigned long const   *addr ) 
{ 
  int oldbit ;

  {
  {
#line 508
  __asm__  volatile   ("bt "
                       "%%"
                       "gs"
                       ":"
                       "%P"
                       "2"
                       ",%1\n\t"
                       "sbb %0,%0": "=r" (oldbit): "m" (*((unsigned long *)addr)),
                       "Ir" (nr));
  }
#line 513
  return (oldbit);
}
}
#line 300 "../../../analyzer/../bench/linux-headers/include/linux/percpu-defs.h"
extern void __bad_size_call_parameter(void) ;
#line 305
__inline static void __this_cpu_preempt_check(char const   *op )  __attribute__((__no_instrument_function__)) ;
#line 305 "../../../analyzer/../bench/linux-headers/include/linux/percpu-defs.h"
__inline static void __this_cpu_preempt_check(char const   *op ) 
{ 


  {
#line 305
  return;
}
}
#line 18 "../../../analyzer/../bench/linux-headers/include/asm-generic/percpu.h"
extern unsigned long __per_cpu_offset[64] ;
#line 47
extern void setup_per_cpu_areas(void) ;
#line 525 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/percpu.h"
extern unsigned long this_cpu_off  __attribute__((__section__(".data..percpu"))) ;
#line 65 "../../../analyzer/../bench/linux-headers/include/asm-generic/bug.h"
extern void ( /* format attribute */  warn_slowpath_fmt)(char const   *file , int const   line ,
                                                         char const   *fmt  , ...) ;
#line 68
extern void ( /* format attribute */  warn_slowpath_fmt_taint)(char const   *file ,
                                                               int const   line ,
                                                               unsigned int taint ,
                                                               char const   *fmt 
                                                               , ...) ;
#line 71
extern void warn_slowpath_null(char const   *file , int const   line ) ;
#line 91 "../../../analyzer/../bench/linux-headers/include/linux/bug.h"
__inline static int is_warning_bug(struct bug_entry  const  *bug )  __attribute__((__no_instrument_function__)) ;
#line 91 "../../../analyzer/../bench/linux-headers/include/linux/bug.h"
__inline static int is_warning_bug(struct bug_entry  const  *bug ) 
{ 


  {
#line 93
  return ((int )((int const   )bug->flags & 1));
}
}
#line 96
extern struct bug_entry  const  *find_bug(unsigned long bugaddr ) ;
#line 98
extern enum bug_trap_type report_bug(unsigned long bug_addr , struct pt_regs *regs ) ;
#line 101
extern int is_valid_bugaddr(unsigned long addr ) ;
#line 51 "../../../analyzer/../bench/linux-headers/include/linux/thread_info.h"
extern long do_no_restart_syscall(struct restart_block *parm ) ;
#line 9 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/page_64.h"
extern unsigned long max_pfn ;
#line 10
extern unsigned long phys_base ;
#line 12
__inline static unsigned long __phys_addr_nodebug(unsigned long x )  __attribute__((__no_instrument_function__)) ;
#line 12 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/page_64.h"
__inline static unsigned long __phys_addr_nodebug(unsigned long x ) 
{ 
  unsigned long y ;
  unsigned long tmp ;

  {
  {
#line 14
  y = x - 0xffffffff80000000UL;
  }
#line 17
  if (x > y) {
    {
#line 17
    tmp = phys_base;
    }
  } else {
    {
#line 17
    tmp = 131939247849472UL;
    }
  }
  {
#line 17
  x = y + tmp;
  }
#line 19
  return (x);
}
}
#line 37
extern void clear_page(void *page ) ;
#line 38
extern void copy_page(void *to , void *from ) ;
#line 9 "../../../analyzer/../bench/linux-headers/include/linux/range.h"
extern int add_range(struct range *range , int az , int nr_range , u64 start , u64 end ) ;
#line 13
extern int add_range_with_merge(struct range *range , int az , int nr_range , u64 start ,
                                u64 end ) ;
#line 16
extern void subtract_range(struct range *range , int az , u64 start , u64 end ) ;
#line 18
extern int clean_sort_range(struct range *range , int az ) ;
#line 20
extern void sort_range(struct range *range , int nr_range ) ;
#line 23
__inline static resource_size_t cap_resource(u64 val )  __attribute__((__no_instrument_function__)) ;
#line 23 "../../../analyzer/../bench/linux-headers/include/linux/range.h"
__inline static resource_size_t cap_resource(u64 val ) 
{ 


  {
#line 25
  if (val > 0xffffffffffffffffULL) {
#line 26
    return ((resource_size_t )(~ 0));
  }
#line 28
  return (val);
}
}
#line 21 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/page.h"
extern struct range pfn_mapped[] ;
#line 22
extern int nr_pfn_mapped ;
#line 24
__inline static void clear_user_page(void *page , unsigned long vaddr , struct page *pg )  __attribute__((__no_instrument_function__)) ;
#line 24 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/page.h"
__inline static void clear_user_page(void *page , unsigned long vaddr , struct page *pg ) 
{ 


  {
  {
#line 27
  clear_page(page);
  }
#line 28
  return;
}
}
#line 30
__inline static void copy_user_page(void *to , void *from , unsigned long vaddr ,
                                    struct page *topage )  __attribute__((__no_instrument_function__)) ;
#line 30 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/page.h"
__inline static void copy_user_page(void *to , void *from , unsigned long vaddr ,
                                    struct page *topage ) 
{ 


  {
  {
#line 33
  copy_page(to, from);
  }
#line 34
  return;
}
}
#line 65
extern bool __virt_addr_valid(unsigned long kaddr ) ;
#line 12 "../../../analyzer/../bench/linux-headers/include/asm-generic/getorder.h"
__inline static int __get_order(unsigned long size )  __attribute__((__no_instrument_function__,
__const__)) ;
#line 12 "../../../analyzer/../bench/linux-headers/include/asm-generic/getorder.h"
__inline static int __get_order(unsigned long size ) 
{ 
  int order ;

  {
  {
#line 17
  size --;
#line 18
  size >>= 12;
#line 22
  order = fls64((__u64 )size);
  }
#line 24
  return (order);
}
}
#line 75 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/vm86.h"
__inline static int handle_vm86_trap(struct kernel_vm86_regs *a , long b , int c )  __attribute__((__no_instrument_function__)) ;
#line 75 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/vm86.h"
__inline static int handle_vm86_trap(struct kernel_vm86_regs *a , long b , int c ) 
{ 


  {
#line 77
  return (0);
}
}
#line 10 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/current.h"
extern struct task_struct *current_task  __attribute__((__section__(".data..percpu"))) ;
#line 12
__inline static struct task_struct *( __attribute__((__always_inline__)) get_current)(void)  __attribute__((__no_instrument_function__)) ;
#line 12 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/current.h"
__inline static struct task_struct *( __attribute__((__always_inline__)) get_current)(void) 
{ 
  struct task_struct *pfo_ret__ ;

  {
  {
#line 14
  if (sizeof(current_task) == 1UL) {
#line 14
    goto case_1;
  }
#line 14
  if (sizeof(current_task) == 2UL) {
#line 14
    goto case_2;
  }
#line 14
  if (sizeof(current_task) == 4UL) {
#line 14
    goto case_4;
  }
#line 14
  if (sizeof(current_task) == 8UL) {
#line 14
    goto case_8;
  }
#line 14
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 14
  __asm__  ("mov"
            "b "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=q" (pfo_ret__): "p" (& current_task));
  }
#line 14
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 14
  __asm__  ("mov"
            "w "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret__): "p" (& current_task));
  }
#line 14
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 14
  __asm__  ("mov"
            "l "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret__): "p" (& current_task));
  }
#line 14
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 14
  __asm__  ("mov"
            "q "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret__): "p" (& current_task));
  }
#line 14
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 14
  __bad_percpu_size();
  }
  switch_break: /* CIL Label */ ;
  }
#line 14
  return (pfo_ret__);
}
}
#line 246 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_types.h"
__inline static pgd_t native_make_pgd(pgdval_t val )  __attribute__((__no_instrument_function__)) ;
#line 246 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_types.h"
__inline static pgd_t native_make_pgd(pgdval_t val ) 
{ 
  pgd_t __constr_expr_0 ;

  {
  {
#line 248
  __constr_expr_0.pgd = val;
  }
#line 248
  return (__constr_expr_0);
}
}
#line 251
__inline static pgdval_t native_pgd_val(pgd_t pgd )  __attribute__((__no_instrument_function__)) ;
#line 251 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_types.h"
__inline static pgdval_t native_pgd_val(pgd_t pgd ) 
{ 


  {
#line 253
  return (pgd.pgd);
}
}
#line 256
__inline static pgdval_t pgd_flags(pgd_t pgd )  __attribute__((__no_instrument_function__)) ;
#line 256 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_types.h"
__inline static pgdval_t pgd_flags(pgd_t pgd ) 
{ 
  pgdval_t tmp ;

  {
  {
#line 258
  tmp = native_pgd_val(pgd);
  }
#line 258
  return (tmp & ~ ((pteval_t )((unsigned long long )((long )(~ ((1UL << 12) - 1UL))) & ((1ULL << 46) - 1ULL))));
}
}
#line 264
__inline static pud_t native_make_pud(pmdval_t val )  __attribute__((__no_instrument_function__)) ;
#line 264 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_types.h"
__inline static pud_t native_make_pud(pmdval_t val ) 
{ 
  pud_t __constr_expr_1 ;

  {
  {
#line 266
  __constr_expr_1.pud = val;
  }
#line 266
  return (__constr_expr_1);
}
}
#line 269
__inline static pudval_t native_pud_val(pud_t pud )  __attribute__((__no_instrument_function__)) ;
#line 269 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_types.h"
__inline static pudval_t native_pud_val(pud_t pud ) 
{ 


  {
#line 271
  return (pud.pud);
}
}
#line 285
__inline static pmd_t native_make_pmd(pmdval_t val )  __attribute__((__no_instrument_function__)) ;
#line 285 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_types.h"
__inline static pmd_t native_make_pmd(pmdval_t val ) 
{ 
  pmd_t __constr_expr_2 ;

  {
  {
#line 287
  __constr_expr_2.pmd = val;
  }
#line 287
  return (__constr_expr_2);
}
}
#line 290
__inline static pmdval_t native_pmd_val(pmd_t pmd )  __attribute__((__no_instrument_function__)) ;
#line 290 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_types.h"
__inline static pmdval_t native_pmd_val(pmd_t pmd ) 
{ 


  {
#line 292
  return (pmd.pmd);
}
}
#line 303
__inline static pudval_t pud_flags(pud_t pud )  __attribute__((__no_instrument_function__)) ;
#line 303 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_types.h"
__inline static pudval_t pud_flags(pud_t pud ) 
{ 
  pudval_t tmp ;

  {
  {
#line 305
  tmp = native_pud_val(pud);
  }
#line 305
  return (tmp & ~ ((pteval_t )((unsigned long long )((long )(~ ((1UL << 12) - 1UL))) & ((1ULL << 46) - 1ULL))));
}
}
#line 308
__inline static pmdval_t pmd_flags(pmd_t pmd )  __attribute__((__no_instrument_function__)) ;
#line 308 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_types.h"
__inline static pmdval_t pmd_flags(pmd_t pmd ) 
{ 
  pmdval_t tmp ;

  {
  {
#line 310
  tmp = native_pmd_val(pmd);
  }
#line 310
  return (tmp & ~ ((pteval_t )((unsigned long long )((long )(~ ((1UL << 12) - 1UL))) & ((1ULL << 46) - 1ULL))));
}
}
#line 313
__inline static pte_t native_make_pte(pteval_t val )  __attribute__((__no_instrument_function__)) ;
#line 313 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_types.h"
__inline static pte_t native_make_pte(pteval_t val ) 
{ 
  pte_t __constr_expr_3 ;

  {
  {
#line 315
  __constr_expr_3.pte = val;
  }
#line 315
  return (__constr_expr_3);
}
}
#line 318
__inline static pteval_t native_pte_val(pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 318 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_types.h"
__inline static pteval_t native_pte_val(pte_t pte ) 
{ 


  {
#line 320
  return (pte.pte);
}
}
#line 323
__inline static pteval_t pte_flags(pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 323 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_types.h"
__inline static pteval_t pte_flags(pte_t pte ) 
{ 
  pteval_t tmp ;

  {
  {
#line 325
  tmp = native_pte_val(pte);
  }
#line 325
  return (tmp & ~ ((pteval_t )((unsigned long long )((long )(~ ((1UL << 12) - 1UL))) & ((1ULL << 46) - 1ULL))));
}
}
#line 334
extern pteval_t __supported_pte_mask ;
#line 335
extern void set_nx(void) ;
#line 336
extern int nx_enabled ;
#line 339
extern pgprot_t pgprot_writecombine(pgprot_t prot ) ;
#line 346
extern pgprot_t phys_mem_access_prot(struct file *file , unsigned long pfn , unsigned long size ,
                                     pgprot_t vma_prot ) ;
#line 348
extern int phys_mem_access_prot_allowed(struct file *file , unsigned long pfn , unsigned long size ,
                                        pgprot_t *vma_prot ) ;
#line 352
extern void set_pte_vaddr(unsigned long vaddr , pte_t pte ) ;
#line 361
extern void arch_report_meminfo(struct seq_file *m ) ;
#line 372
extern void update_page_count(int level , unsigned long pages ) ;
#line 383
extern pte_t *lookup_address(unsigned long address , unsigned int *level ) ;
#line 384
extern pte_t *lookup_address_in_pgd(pgd_t *pgd , unsigned long address , unsigned int *level ) ;
#line 386
extern phys_addr_t slow_virt_to_phys(void *__address ) ;
#line 387
extern int kernel_map_pages_in_pgd(pgd_t *pgd , u64 pfn , unsigned long address ,
                                   unsigned int numpages , unsigned long page_flags ) ;
#line 389
extern void kernel_unmap_pages_in_pgd(pgd_t *root , unsigned long address , unsigned int numpages ) ;
#line 10 "../../../analyzer/../bench/linux-headers/include/asm-generic/ioctl.h"
extern unsigned int __invalid_size_argument_for_IOC ;
#line 91 "../../../analyzer/../bench/linux-headers/include/linux/bitmap.h"
extern int __bitmap_empty(unsigned long const   *bitmap , unsigned int nbits ) ;
#line 92
extern int __bitmap_full(unsigned long const   *bitmap , unsigned int nbits ) ;
#line 93
extern int __bitmap_equal(unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                          unsigned int nbits ) ;
#line 95
extern void __bitmap_complement(unsigned long *dst , unsigned long const   *src ,
                                unsigned int nbits ) ;
#line 97
extern void __bitmap_shift_right(unsigned long *dst , unsigned long const   *src ,
                                 int shift , int bits ) ;
#line 99
extern void __bitmap_shift_left(unsigned long *dst , unsigned long const   *src ,
                                int shift , int bits ) ;
#line 101
extern int __bitmap_and(unsigned long *dst , unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                        unsigned int nbits ) ;
#line 103
extern void __bitmap_or(unsigned long *dst , unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                        unsigned int nbits ) ;
#line 105
extern void __bitmap_xor(unsigned long *dst , unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                         unsigned int nbits ) ;
#line 107
extern int __bitmap_andnot(unsigned long *dst , unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                           unsigned int nbits ) ;
#line 109
extern int __bitmap_intersects(unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                               unsigned int nbits ) ;
#line 111
extern int __bitmap_subset(unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                           unsigned int nbits ) ;
#line 113
extern int __bitmap_weight(unsigned long const   *bitmap , unsigned int nbits ) ;
#line 115
extern void bitmap_set(unsigned long *map , unsigned int start , int len ) ;
#line 116
extern void bitmap_clear(unsigned long *map , unsigned int start , int len ) ;
#line 117
extern unsigned long bitmap_find_next_zero_area(unsigned long *map , unsigned long size ,
                                                unsigned long start , unsigned int nr ,
                                                unsigned long align_mask ) ;
#line 123
extern int bitmap_scnprintf(char *buf , unsigned int len , unsigned long const   *src ,
                            int nbits ) ;
#line 125
extern int __bitmap_parse(char const   *buf , unsigned int buflen , int is_user ,
                          unsigned long *dst , int nbits ) ;
#line 127
extern int bitmap_parse_user(char const   *ubuf , unsigned int ulen , unsigned long *dst ,
                             int nbits ) ;
#line 129
extern int bitmap_scnlistprintf(char *buf , unsigned int len , unsigned long const   *src ,
                                int nbits ) ;
#line 131
extern int bitmap_parselist(char const   *buf , unsigned long *maskp , int nmaskbits ) ;
#line 133
extern int bitmap_parselist_user(char const   *ubuf , unsigned int ulen , unsigned long *dst ,
                                 int nbits ) ;
#line 135
extern void bitmap_remap(unsigned long *dst , unsigned long const   *src , unsigned long const   *old ,
                         unsigned long const   *new , int bits ) ;
#line 137
extern int bitmap_bitremap(int oldbit , unsigned long const   *old , unsigned long const   *new ,
                           int bits ) ;
#line 139
extern void bitmap_onto(unsigned long *dst , unsigned long const   *orig , unsigned long const   *relmap ,
                        int bits ) ;
#line 141
extern void bitmap_fold(unsigned long *dst , unsigned long const   *orig , int sz ,
                        int bits ) ;
#line 143
extern int bitmap_find_free_region(unsigned long *bitmap , unsigned int bits , int order ) ;
#line 144
extern void bitmap_release_region(unsigned long *bitmap , unsigned int pos , int order ) ;
#line 145
extern int bitmap_allocate_region(unsigned long *bitmap , unsigned int pos , int order ) ;
#line 146
extern void bitmap_copy_le(void *dst , unsigned long const   *src , int nbits ) ;
#line 147
extern int bitmap_ord_to_pos(unsigned long const   *bitmap , int n , int bits ) ;
#line 159
__inline static void bitmap_zero(unsigned long *dst , int nbits )  __attribute__((__no_instrument_function__)) ;
#line 159 "../../../analyzer/../bench/linux-headers/include/linux/bitmap.h"
__inline static void bitmap_zero(unsigned long *dst , int nbits ) 
{ 
  int len ;

  {
  {
#line 164
  len = (int )(((((unsigned long )nbits + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) * sizeof(unsigned long ));
#line 165
  memset((void *)dst, 0, (size_t )len);
  }
#line 167
  return;
}
}
#line 169
__inline static void bitmap_fill(unsigned long *dst , int nbits )  __attribute__((__no_instrument_function__)) ;
#line 169 "../../../analyzer/../bench/linux-headers/include/linux/bitmap.h"
__inline static void bitmap_fill(unsigned long *dst , int nbits ) 
{ 
  size_t nlongs ;
  int len ;

  {
  {
#line 171
  nlongs = (((unsigned long )nbits + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ));
#line 173
  len = (int )((nlongs - 1UL) * sizeof(unsigned long ));
#line 174
  memset((void *)dst, 255, (size_t )len);
  }
#line 176
  if (nbits % 64) {
    {
#line 176
    *(dst + (nlongs - 1UL)) = (1UL << nbits % 64) - 1UL;
    }
  } else {
    {
#line 176
    *(dst + (nlongs - 1UL)) = ~ 0UL;
    }
  }
#line 177
  return;
}
}
#line 179
__inline static void bitmap_copy(unsigned long *dst , unsigned long const   *src ,
                                 int nbits )  __attribute__((__no_instrument_function__)) ;
#line 179 "../../../analyzer/../bench/linux-headers/include/linux/bitmap.h"
__inline static void bitmap_copy(unsigned long *dst , unsigned long const   *src ,
                                 int nbits ) 
{ 
  int len ;

  {
  {
#line 185
  len = (int )(((((unsigned long )nbits + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) * sizeof(unsigned long ));
#line 186
  memcpy((void *)dst, (void const   *)src, (size_t )len);
  }
#line 188
  return;
}
}
#line 190
__inline static int bitmap_and(unsigned long *dst , unsigned long const   *src1 ,
                               unsigned long const   *src2 , unsigned int nbits )  __attribute__((__no_instrument_function__)) ;
#line 190 "../../../analyzer/../bench/linux-headers/include/linux/bitmap.h"
__inline static int bitmap_and(unsigned long *dst , unsigned long const   *src1 ,
                               unsigned long const   *src2 , unsigned int nbits ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 195
  tmp___1 = __bitmap_and(dst, src1, src2, nbits);
  }
#line 195
  return (tmp___1);
}
}
#line 198
__inline static void bitmap_or(unsigned long *dst , unsigned long const   *src1 ,
                               unsigned long const   *src2 , unsigned int nbits )  __attribute__((__no_instrument_function__)) ;
#line 198 "../../../analyzer/../bench/linux-headers/include/linux/bitmap.h"
__inline static void bitmap_or(unsigned long *dst , unsigned long const   *src1 ,
                               unsigned long const   *src2 , unsigned int nbits ) 
{ 


  {
  {
#line 204
  __bitmap_or(dst, src1, src2, nbits);
  }
#line 205
  return;
}
}
#line 207
__inline static void bitmap_xor(unsigned long *dst , unsigned long const   *src1 ,
                                unsigned long const   *src2 , unsigned int nbits )  __attribute__((__no_instrument_function__)) ;
#line 207 "../../../analyzer/../bench/linux-headers/include/linux/bitmap.h"
__inline static void bitmap_xor(unsigned long *dst , unsigned long const   *src1 ,
                                unsigned long const   *src2 , unsigned int nbits ) 
{ 


  {
  {
#line 213
  __bitmap_xor(dst, src1, src2, nbits);
  }
#line 214
  return;
}
}
#line 216
__inline static int bitmap_andnot(unsigned long *dst , unsigned long const   *src1 ,
                                  unsigned long const   *src2 , unsigned int nbits )  __attribute__((__no_instrument_function__)) ;
#line 216 "../../../analyzer/../bench/linux-headers/include/linux/bitmap.h"
__inline static int bitmap_andnot(unsigned long *dst , unsigned long const   *src1 ,
                                  unsigned long const   *src2 , unsigned int nbits ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 221
  tmp___1 = __bitmap_andnot(dst, src1, src2, nbits);
  }
#line 221
  return (tmp___1);
}
}
#line 224
__inline static void bitmap_complement(unsigned long *dst , unsigned long const   *src ,
                                       unsigned int nbits )  __attribute__((__no_instrument_function__)) ;
#line 224 "../../../analyzer/../bench/linux-headers/include/linux/bitmap.h"
__inline static void bitmap_complement(unsigned long *dst , unsigned long const   *src ,
                                       unsigned int nbits ) 
{ 


  {
  {
#line 230
  __bitmap_complement(dst, src, nbits);
  }
#line 231
  return;
}
}
#line 233
__inline static int bitmap_equal(unsigned long const   *src1 , unsigned long const   *src2 ,
                                 unsigned int nbits )  __attribute__((__no_instrument_function__)) ;
#line 233 "../../../analyzer/../bench/linux-headers/include/linux/bitmap.h"
__inline static int bitmap_equal(unsigned long const   *src1 , unsigned long const   *src2 ,
                                 unsigned int nbits ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 239
  tmp___1 = __bitmap_equal(src1, src2, nbits);
  }
#line 239
  return (tmp___1);
}
}
#line 242
__inline static int bitmap_intersects(unsigned long const   *src1 , unsigned long const   *src2 ,
                                      unsigned int nbits )  __attribute__((__no_instrument_function__)) ;
#line 242 "../../../analyzer/../bench/linux-headers/include/linux/bitmap.h"
__inline static int bitmap_intersects(unsigned long const   *src1 , unsigned long const   *src2 ,
                                      unsigned int nbits ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
#line 248
  tmp___0 = __bitmap_intersects(src1, src2, nbits);
  }
#line 248
  return (tmp___0);
}
}
#line 251
__inline static int bitmap_subset(unsigned long const   *src1 , unsigned long const   *src2 ,
                                  unsigned int nbits )  __attribute__((__no_instrument_function__)) ;
#line 251 "../../../analyzer/../bench/linux-headers/include/linux/bitmap.h"
__inline static int bitmap_subset(unsigned long const   *src1 , unsigned long const   *src2 ,
                                  unsigned int nbits ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 257
  tmp___1 = __bitmap_subset(src1, src2, nbits);
  }
#line 257
  return (tmp___1);
}
}
#line 260
__inline static int bitmap_empty(unsigned long const   *src , unsigned int nbits )  __attribute__((__no_instrument_function__)) ;
#line 260 "../../../analyzer/../bench/linux-headers/include/linux/bitmap.h"
__inline static int bitmap_empty(unsigned long const   *src , unsigned int nbits ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 265
  tmp___1 = __bitmap_empty(src, nbits);
  }
#line 265
  return (tmp___1);
}
}
#line 268
__inline static int bitmap_full(unsigned long const   *src , unsigned int nbits )  __attribute__((__no_instrument_function__)) ;
#line 268 "../../../analyzer/../bench/linux-headers/include/linux/bitmap.h"
__inline static int bitmap_full(unsigned long const   *src , unsigned int nbits ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 273
  tmp___1 = __bitmap_full(src, nbits);
  }
#line 273
  return (tmp___1);
}
}
#line 276
__inline static int bitmap_weight(unsigned long const   *src , unsigned int nbits )  __attribute__((__no_instrument_function__)) ;
#line 276 "../../../analyzer/../bench/linux-headers/include/linux/bitmap.h"
__inline static int bitmap_weight(unsigned long const   *src , unsigned int nbits ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 280
  tmp___1 = __bitmap_weight(src, nbits);
  }
#line 280
  return (tmp___1);
}
}
#line 283
__inline static void bitmap_shift_right(unsigned long *dst , unsigned long const   *src ,
                                        int n , int nbits )  __attribute__((__no_instrument_function__)) ;
#line 283 "../../../analyzer/../bench/linux-headers/include/linux/bitmap.h"
__inline static void bitmap_shift_right(unsigned long *dst , unsigned long const   *src ,
                                        int n , int nbits ) 
{ 
  unsigned long tmp ;

  {
  {
#line 289
  __bitmap_shift_right(dst, src, n, nbits);
  }
#line 290
  return;
}
}
#line 292
__inline static void bitmap_shift_left(unsigned long *dst , unsigned long const   *src ,
                                       int n , int nbits )  __attribute__((__no_instrument_function__)) ;
#line 292 "../../../analyzer/../bench/linux-headers/include/linux/bitmap.h"
__inline static void bitmap_shift_left(unsigned long *dst , unsigned long const   *src ,
                                       int n , int nbits ) 
{ 
  unsigned long tmp ;

  {
  {
#line 298
  __bitmap_shift_left(dst, src, n, nbits);
  }
#line 299
  return;
}
}
#line 301
__inline static int bitmap_parse(char const   *buf , unsigned int buflen , unsigned long *maskp ,
                                 int nmaskbits )  __attribute__((__no_instrument_function__)) ;
#line 301 "../../../analyzer/../bench/linux-headers/include/linux/bitmap.h"
__inline static int bitmap_parse(char const   *buf , unsigned int buflen , unsigned long *maskp ,
                                 int nmaskbits ) 
{ 
  int tmp ;

  {
  {
#line 304
  tmp = __bitmap_parse(buf, buflen, 0, maskp, nmaskbits);
  }
#line 304
  return (tmp);
}
}
#line 28 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
extern int nr_cpu_ids ;
#line 79
extern struct cpumask  const  * const  cpu_possible_mask ;
#line 80
extern struct cpumask  const  * const  cpu_online_mask ;
#line 81
extern struct cpumask  const  * const  cpu_present_mask ;
#line 82
extern struct cpumask  const  * const  cpu_active_mask ;
#line 105
__inline static unsigned int cpumask_check(unsigned int cpu )  __attribute__((__no_instrument_function__)) ;
#line 105 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static unsigned int cpumask_check(unsigned int cpu ) 
{ 


  {
#line 110
  return (cpu);
}
}
#line 165
__inline static unsigned int cpumask_first(struct cpumask  const  *srcp )  __attribute__((__no_instrument_function__)) ;
#line 165 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static unsigned int cpumask_first(struct cpumask  const  *srcp ) 
{ 
  unsigned long tmp ;

  {
  {
#line 167
  tmp = find_first_bit((unsigned long const   *)(srcp->bits), 64UL);
  }
#line 167
  return ((unsigned int )tmp);
}
}
#line 177
__inline static unsigned int cpumask_next(int n , struct cpumask  const  *srcp )  __attribute__((__no_instrument_function__)) ;
#line 177 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static unsigned int cpumask_next(int n , struct cpumask  const  *srcp ) 
{ 
  unsigned long tmp ;

  {
#line 180
  if (n != -1) {
    {
#line 181
    cpumask_check((unsigned int )n);
    }
  }
  {
#line 182
  tmp = find_next_bit((unsigned long const   *)(srcp->bits), 64UL, (unsigned long )(n + 1));
  }
#line 182
  return ((unsigned int )tmp);
}
}
#line 192
__inline static unsigned int cpumask_next_zero(int n , struct cpumask  const  *srcp )  __attribute__((__no_instrument_function__)) ;
#line 192 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static unsigned int cpumask_next_zero(int n , struct cpumask  const  *srcp ) 
{ 
  unsigned long tmp ;

  {
#line 195
  if (n != -1) {
    {
#line 196
    cpumask_check((unsigned int )n);
    }
  }
  {
#line 197
  tmp = find_next_zero_bit((unsigned long const   *)(srcp->bits), 64UL, (unsigned long )(n + 1));
  }
#line 197
  return ((unsigned int )tmp);
}
}
#line 200
extern int cpumask_next_and(int n , struct cpumask  const  * , struct cpumask  const  * ) ;
#line 201
extern int cpumask_any_but(struct cpumask  const  *mask , unsigned int cpu ) ;
#line 202
extern int cpumask_set_cpu_local_first(int i , int numa_node , cpumask_t *dstp ) ;
#line 263
__inline static void cpumask_set_cpu(unsigned int cpu , struct cpumask *dstp )  __attribute__((__no_instrument_function__)) ;
#line 263 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static void cpumask_set_cpu(unsigned int cpu , struct cpumask *dstp ) 
{ 
  unsigned int tmp ;

  {
  {
#line 265
  tmp = cpumask_check(cpu);
#line 265
  set_bit((long )tmp, (unsigned long volatile   *)(dstp->bits));
  }
#line 266
  return;
}
}
#line 273
__inline static void cpumask_clear_cpu(int cpu , struct cpumask *dstp )  __attribute__((__no_instrument_function__)) ;
#line 273 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static void cpumask_clear_cpu(int cpu , struct cpumask *dstp ) 
{ 
  unsigned int tmp ;

  {
  {
#line 275
  tmp = cpumask_check((unsigned int )cpu);
#line 275
  clear_bit((long )tmp, (unsigned long volatile   *)(dstp->bits));
  }
#line 276
  return;
}
}
#line 299
__inline static int cpumask_test_and_set_cpu(int cpu , struct cpumask *cpumask )  __attribute__((__no_instrument_function__)) ;
#line 299 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static int cpumask_test_and_set_cpu(int cpu , struct cpumask *cpumask ) 
{ 
  unsigned int tmp ;
  int tmp___0 ;

  {
  {
#line 301
  tmp = cpumask_check((unsigned int )cpu);
#line 301
  tmp___0 = test_and_set_bit((long )tmp, (unsigned long volatile   *)(cpumask->bits));
  }
#line 301
  return (tmp___0);
}
}
#line 313
__inline static int cpumask_test_and_clear_cpu(int cpu , struct cpumask *cpumask )  __attribute__((__no_instrument_function__)) ;
#line 313 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static int cpumask_test_and_clear_cpu(int cpu , struct cpumask *cpumask ) 
{ 
  unsigned int tmp ;
  int tmp___0 ;

  {
  {
#line 315
  tmp = cpumask_check((unsigned int )cpu);
#line 315
  tmp___0 = test_and_clear_bit((long )tmp, (unsigned long volatile   *)(cpumask->bits));
  }
#line 315
  return (tmp___0);
}
}
#line 322
__inline static void cpumask_setall(struct cpumask *dstp )  __attribute__((__no_instrument_function__)) ;
#line 322 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static void cpumask_setall(struct cpumask *dstp ) 
{ 


  {
  {
#line 324
  bitmap_fill(dstp->bits, 64);
  }
#line 325
  return;
}
}
#line 331
__inline static void cpumask_clear(struct cpumask *dstp )  __attribute__((__no_instrument_function__)) ;
#line 331 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static void cpumask_clear(struct cpumask *dstp ) 
{ 


  {
  {
#line 333
  bitmap_zero(dstp->bits, 64);
  }
#line 334
  return;
}
}
#line 344
__inline static int cpumask_and(struct cpumask *dstp , struct cpumask  const  *src1p ,
                                struct cpumask  const  *src2p )  __attribute__((__no_instrument_function__)) ;
#line 344 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static int cpumask_and(struct cpumask *dstp , struct cpumask  const  *src1p ,
                                struct cpumask  const  *src2p ) 
{ 
  int tmp ;

  {
  {
#line 348
  tmp = bitmap_and(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                   64U);
  }
#line 348
  return (tmp);
}
}
#line 358
__inline static void cpumask_or(struct cpumask *dstp , struct cpumask  const  *src1p ,
                                struct cpumask  const  *src2p )  __attribute__((__no_instrument_function__)) ;
#line 358 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static void cpumask_or(struct cpumask *dstp , struct cpumask  const  *src1p ,
                                struct cpumask  const  *src2p ) 
{ 


  {
  {
#line 361
  bitmap_or(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
            64U);
  }
#line 363
  return;
}
}
#line 371
__inline static void cpumask_xor(struct cpumask *dstp , struct cpumask  const  *src1p ,
                                 struct cpumask  const  *src2p )  __attribute__((__no_instrument_function__)) ;
#line 371 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static void cpumask_xor(struct cpumask *dstp , struct cpumask  const  *src1p ,
                                 struct cpumask  const  *src2p ) 
{ 


  {
  {
#line 375
  bitmap_xor(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
             64U);
  }
#line 377
  return;
}
}
#line 387
__inline static int cpumask_andnot(struct cpumask *dstp , struct cpumask  const  *src1p ,
                                   struct cpumask  const  *src2p )  __attribute__((__no_instrument_function__)) ;
#line 387 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static int cpumask_andnot(struct cpumask *dstp , struct cpumask  const  *src1p ,
                                   struct cpumask  const  *src2p ) 
{ 
  int tmp ;

  {
  {
#line 391
  tmp = bitmap_andnot(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                      64U);
  }
#line 391
  return (tmp);
}
}
#line 400
__inline static void cpumask_complement(struct cpumask *dstp , struct cpumask  const  *srcp )  __attribute__((__no_instrument_function__)) ;
#line 400 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static void cpumask_complement(struct cpumask *dstp , struct cpumask  const  *srcp ) 
{ 


  {
  {
#line 403
  bitmap_complement(dstp->bits, (unsigned long const   *)(srcp->bits), 64U);
  }
#line 405
  return;
}
}
#line 412
__inline static bool cpumask_equal(struct cpumask  const  *src1p , struct cpumask  const  *src2p )  __attribute__((__no_instrument_function__)) ;
#line 412 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static bool cpumask_equal(struct cpumask  const  *src1p , struct cpumask  const  *src2p ) 
{ 
  int tmp ;

  {
  {
#line 415
  tmp = bitmap_equal((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                     64U);
  }
#line 415
  return ((bool )tmp);
}
}
#line 424
__inline static bool cpumask_intersects(struct cpumask  const  *src1p , struct cpumask  const  *src2p )  __attribute__((__no_instrument_function__)) ;
#line 424 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static bool cpumask_intersects(struct cpumask  const  *src1p , struct cpumask  const  *src2p ) 
{ 
  int tmp ;

  {
  {
#line 427
  tmp = bitmap_intersects((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                          64U);
  }
#line 427
  return ((bool )tmp);
}
}
#line 438
__inline static int cpumask_subset(struct cpumask  const  *src1p , struct cpumask  const  *src2p )  __attribute__((__no_instrument_function__)) ;
#line 438 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static int cpumask_subset(struct cpumask  const  *src1p , struct cpumask  const  *src2p ) 
{ 
  int tmp ;

  {
  {
#line 441
  tmp = bitmap_subset((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                      64U);
  }
#line 441
  return (tmp);
}
}
#line 449
__inline static bool cpumask_empty(struct cpumask  const  *srcp )  __attribute__((__no_instrument_function__)) ;
#line 449 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static bool cpumask_empty(struct cpumask  const  *srcp ) 
{ 
  int tmp ;

  {
  {
#line 451
  tmp = bitmap_empty((unsigned long const   *)(srcp->bits), 64U);
  }
#line 451
  return ((bool )tmp);
}
}
#line 458
__inline static bool cpumask_full(struct cpumask  const  *srcp )  __attribute__((__no_instrument_function__)) ;
#line 458 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static bool cpumask_full(struct cpumask  const  *srcp ) 
{ 
  int tmp ;

  {
  {
#line 460
  tmp = bitmap_full((unsigned long const   *)(srcp->bits), 64U);
  }
#line 460
  return ((bool )tmp);
}
}
#line 467
__inline static unsigned int cpumask_weight(struct cpumask  const  *srcp )  __attribute__((__no_instrument_function__)) ;
#line 467 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static unsigned int cpumask_weight(struct cpumask  const  *srcp ) 
{ 
  int tmp ;

  {
  {
#line 469
  tmp = bitmap_weight((unsigned long const   *)(srcp->bits), 64U);
  }
#line 469
  return ((unsigned int )tmp);
}
}
#line 478
__inline static void cpumask_shift_right(struct cpumask *dstp , struct cpumask  const  *srcp ,
                                         int n )  __attribute__((__no_instrument_function__)) ;
#line 478 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static void cpumask_shift_right(struct cpumask *dstp , struct cpumask  const  *srcp ,
                                         int n ) 
{ 


  {
  {
#line 481
  bitmap_shift_right(dstp->bits, (unsigned long const   *)(srcp->bits), n, 64);
  }
#line 483
  return;
}
}
#line 491
__inline static void cpumask_shift_left(struct cpumask *dstp , struct cpumask  const  *srcp ,
                                        int n )  __attribute__((__no_instrument_function__)) ;
#line 491 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static void cpumask_shift_left(struct cpumask *dstp , struct cpumask  const  *srcp ,
                                        int n ) 
{ 


  {
  {
#line 494
  bitmap_shift_left(dstp->bits, (unsigned long const   *)(srcp->bits), n, 64);
  }
#line 496
  return;
}
}
#line 503
__inline static void cpumask_copy(struct cpumask *dstp , struct cpumask  const  *srcp )  __attribute__((__no_instrument_function__)) ;
#line 503 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static void cpumask_copy(struct cpumask *dstp , struct cpumask  const  *srcp ) 
{ 


  {
  {
#line 506
  bitmap_copy(dstp->bits, (unsigned long const   *)(srcp->bits), 64);
  }
#line 507
  return;
}
}
#line 550
__inline static int cpumask_scnprintf(char *buf , int len , struct cpumask  const  *srcp )  __attribute__((__no_instrument_function__)) ;
#line 550 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static int cpumask_scnprintf(char *buf , int len , struct cpumask  const  *srcp ) 
{ 
  int tmp ;

  {
  {
#line 553
  tmp = bitmap_scnprintf(buf, (unsigned int )len, (unsigned long const   *)(srcp->bits),
                         64);
  }
#line 553
  return (tmp);
}
}
#line 564
__inline static int cpumask_parse_user(char const   *buf , int len , struct cpumask *dstp )  __attribute__((__no_instrument_function__)) ;
#line 564 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static int cpumask_parse_user(char const   *buf , int len , struct cpumask *dstp ) 
{ 
  int tmp ;

  {
  {
#line 567
  tmp = bitmap_parse_user(buf, (unsigned int )len, dstp->bits, 64);
  }
#line 567
  return (tmp);
}
}
#line 578
__inline static int cpumask_parselist_user(char const   *buf , int len , struct cpumask *dstp )  __attribute__((__no_instrument_function__)) ;
#line 578 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static int cpumask_parselist_user(char const   *buf , int len , struct cpumask *dstp ) 
{ 
  int tmp ;

  {
  {
#line 581
  tmp = bitmap_parselist_user(buf, (unsigned int )len, dstp->bits, 64);
  }
#line 581
  return (tmp);
}
}
#line 594
__inline static int cpulist_scnprintf(char *buf , int len , struct cpumask  const  *srcp )  __attribute__((__no_instrument_function__)) ;
#line 594 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static int cpulist_scnprintf(char *buf , int len , struct cpumask  const  *srcp ) 
{ 
  int tmp ;

  {
  {
#line 597
  tmp = bitmap_scnlistprintf(buf, (unsigned int )len, (unsigned long const   *)(srcp->bits),
                             64);
  }
#line 597
  return (tmp);
}
}
#line 608
__inline static int cpumask_parse(char const   *buf , struct cpumask *dstp )  __attribute__((__no_instrument_function__)) ;
#line 608 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static int cpumask_parse(char const   *buf , struct cpumask *dstp ) 
{ 
  char *nl ;
  char *tmp ;
  unsigned int len ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
  {
#line 610
  tmp = strchr(buf, '\n');
#line 610
  nl = tmp;
  }
#line 611
  if (nl) {
    {
#line 611
    tmp___1 = (unsigned long )((unsigned int )(nl - (char *)buf));
    }
  } else {
    {
#line 611
    tmp___0 = strlen(buf);
#line 611
    tmp___1 = tmp___0;
    }
  }
  {
#line 611
  len = (unsigned int )tmp___1;
#line 613
  tmp___2 = bitmap_parse(buf, len, dstp->bits, 64);
  }
#line 613
  return (tmp___2);
}
}
#line 623
__inline static int cpulist_parse(char const   *buf , struct cpumask *dstp )  __attribute__((__no_instrument_function__)) ;
#line 623 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static int cpulist_parse(char const   *buf , struct cpumask *dstp ) 
{ 
  int tmp ;

  {
  {
#line 625
  tmp = bitmap_parselist(buf, dstp->bits, 64);
  }
#line 625
  return (tmp);
}
}
#line 633
__inline static size_t cpumask_size(void)  __attribute__((__no_instrument_function__)) ;
#line 633 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static size_t cpumask_size(void) 
{ 


  {
#line 637
  return ((((64UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) * sizeof(long ));
}
}
#line 684
__inline static bool alloc_cpumask_var(cpumask_var_t *mask , gfp_t flags )  __attribute__((__no_instrument_function__)) ;
#line 684 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static bool alloc_cpumask_var(cpumask_var_t *mask , gfp_t flags ) 
{ 


  {
#line 686
  return ((bool )1);
}
}
#line 689
__inline static bool alloc_cpumask_var_node(cpumask_var_t *mask , gfp_t flags , int node )  __attribute__((__no_instrument_function__)) ;
#line 689 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static bool alloc_cpumask_var_node(cpumask_var_t *mask , gfp_t flags , int node ) 
{ 


  {
#line 692
  return ((bool )1);
}
}
#line 695
__inline static bool zalloc_cpumask_var(cpumask_var_t *mask , gfp_t flags )  __attribute__((__no_instrument_function__)) ;
#line 695 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static bool zalloc_cpumask_var(cpumask_var_t *mask , gfp_t flags ) 
{ 


  {
  {
#line 697
  cpumask_clear(*mask);
  }
#line 698
  return ((bool )1);
}
}
#line 701
__inline static bool zalloc_cpumask_var_node(cpumask_var_t *mask , gfp_t flags , int node )  __attribute__((__no_instrument_function__)) ;
#line 701 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static bool zalloc_cpumask_var_node(cpumask_var_t *mask , gfp_t flags , int node ) 
{ 


  {
  {
#line 704
  cpumask_clear(*mask);
  }
#line 705
  return ((bool )1);
}
}
#line 708
__inline static void alloc_bootmem_cpumask_var(cpumask_var_t *mask )  __attribute__((__no_instrument_function__)) ;
#line 708 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static void alloc_bootmem_cpumask_var(cpumask_var_t *mask ) 
{ 


  {
#line 710
  return;
}
}
#line 712
__inline static void free_cpumask_var(struct cpumask *mask )  __attribute__((__no_instrument_function__)) ;
#line 712 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static void free_cpumask_var(struct cpumask *mask ) 
{ 


  {
#line 714
  return;
}
}
#line 716
__inline static void free_bootmem_cpumask_var(struct cpumask *mask )  __attribute__((__no_instrument_function__)) ;
#line 716 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static void free_bootmem_cpumask_var(struct cpumask *mask ) 
{ 


  {
#line 718
  return;
}
}
#line 723
extern unsigned long const   cpu_all_bits[((64UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
#line 734
extern void set_cpu_possible(unsigned int cpu , bool possible ) ;
#line 735
extern void set_cpu_present(unsigned int cpu , bool present ) ;
#line 736
extern void set_cpu_online(unsigned int cpu , bool online ) ;
#line 737
extern void set_cpu_active(unsigned int cpu , bool active ) ;
#line 738
extern void init_cpu_present(struct cpumask  const  *src ) ;
#line 739
extern void init_cpu_possible(struct cpumask  const  *src ) ;
#line 740
extern void init_cpu_online(struct cpumask  const  *src ) ;
#line 756
__inline static int __check_is_bitmap(unsigned long const   *bitmap )  __attribute__((__no_instrument_function__)) ;
#line 756 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static int __check_is_bitmap(unsigned long const   *bitmap ) 
{ 


  {
#line 758
  return (1);
}
}
#line 768
extern unsigned long const   cpu_bit_bitmap[65][((64UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
#line 771
__inline static struct cpumask  const  *get_cpu_mask(unsigned int cpu )  __attribute__((__no_instrument_function__)) ;
#line 771 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static struct cpumask  const  *get_cpu_mask(unsigned int cpu ) 
{ 
  unsigned long const   *p ;
  int tmp ;

  {
  {
#line 773
  p = cpu_bit_bitmap[1U + cpu % 64U];
#line 774
  p -= cpu / 64U;
  }
#line 775
  return ((struct cpumask  const  *)((struct cpumask *)p));
}
}
#line 839
extern int __first_cpu(cpumask_t const   *srcp ) ;
#line 840
extern int __next_cpu(int n , cpumask_t const   *srcp ) ;
#line 868
__inline static void __cpu_set(int cpu , cpumask_t volatile   *dstp )  __attribute__((__no_instrument_function__)) ;
#line 868 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static void __cpu_set(int cpu , cpumask_t volatile   *dstp ) 
{ 


  {
  {
#line 870
  set_bit((long )cpu, (unsigned long volatile   *)(dstp->bits));
  }
#line 871
  return;
}
}
#line 874
__inline static void __cpu_clear(int cpu , cpumask_t volatile   *dstp )  __attribute__((__no_instrument_function__)) ;
#line 874 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static void __cpu_clear(int cpu , cpumask_t volatile   *dstp ) 
{ 


  {
  {
#line 876
  clear_bit((long )cpu, (unsigned long volatile   *)(dstp->bits));
  }
#line 877
  return;
}
}
#line 880
__inline static void __cpus_setall(cpumask_t *dstp , int nbits )  __attribute__((__no_instrument_function__)) ;
#line 880 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static void __cpus_setall(cpumask_t *dstp , int nbits ) 
{ 


  {
  {
#line 882
  bitmap_fill(dstp->bits, nbits);
  }
#line 883
  return;
}
}
#line 886
__inline static void __cpus_clear(cpumask_t *dstp , int nbits )  __attribute__((__no_instrument_function__)) ;
#line 886 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static void __cpus_clear(cpumask_t *dstp , int nbits ) 
{ 


  {
  {
#line 888
  bitmap_zero(dstp->bits, nbits);
  }
#line 889
  return;
}
}
#line 895
__inline static int __cpu_test_and_set(int cpu , cpumask_t *addr )  __attribute__((__no_instrument_function__)) ;
#line 895 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static int __cpu_test_and_set(int cpu , cpumask_t *addr ) 
{ 
  int tmp ;

  {
  {
#line 897
  tmp = test_and_set_bit((long )cpu, (unsigned long volatile   *)(addr->bits));
  }
#line 897
  return (tmp);
}
}
#line 901
__inline static int __cpus_and(cpumask_t *dstp , cpumask_t const   *src1p , cpumask_t const   *src2p ,
                               int nbits )  __attribute__((__no_instrument_function__)) ;
#line 901 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static int __cpus_and(cpumask_t *dstp , cpumask_t const   *src1p , cpumask_t const   *src2p ,
                               int nbits ) 
{ 
  int tmp ;

  {
  {
#line 904
  tmp = bitmap_and(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                   (unsigned int )nbits);
  }
#line 904
  return (tmp);
}
}
#line 908
__inline static void __cpus_or(cpumask_t *dstp , cpumask_t const   *src1p , cpumask_t const   *src2p ,
                               int nbits )  __attribute__((__no_instrument_function__)) ;
#line 908 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static void __cpus_or(cpumask_t *dstp , cpumask_t const   *src1p , cpumask_t const   *src2p ,
                               int nbits ) 
{ 


  {
  {
#line 911
  bitmap_or(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
            (unsigned int )nbits);
  }
#line 912
  return;
}
}
#line 915
__inline static void __cpus_xor(cpumask_t *dstp , cpumask_t const   *src1p , cpumask_t const   *src2p ,
                                int nbits )  __attribute__((__no_instrument_function__)) ;
#line 915 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static void __cpus_xor(cpumask_t *dstp , cpumask_t const   *src1p , cpumask_t const   *src2p ,
                                int nbits ) 
{ 


  {
  {
#line 918
  bitmap_xor(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
             (unsigned int )nbits);
  }
#line 919
  return;
}
}
#line 923
__inline static int __cpus_andnot(cpumask_t *dstp , cpumask_t const   *src1p , cpumask_t const   *src2p ,
                                  int nbits )  __attribute__((__no_instrument_function__)) ;
#line 923 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static int __cpus_andnot(cpumask_t *dstp , cpumask_t const   *src1p , cpumask_t const   *src2p ,
                                  int nbits ) 
{ 
  int tmp ;

  {
  {
#line 926
  tmp = bitmap_andnot(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                      (unsigned int )nbits);
  }
#line 926
  return (tmp);
}
}
#line 930
__inline static int __cpus_equal(cpumask_t const   *src1p , cpumask_t const   *src2p ,
                                 int nbits )  __attribute__((__no_instrument_function__)) ;
#line 930 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static int __cpus_equal(cpumask_t const   *src1p , cpumask_t const   *src2p ,
                                 int nbits ) 
{ 
  int tmp ;

  {
  {
#line 933
  tmp = bitmap_equal((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                     (unsigned int )nbits);
  }
#line 933
  return (tmp);
}
}
#line 937
__inline static int __cpus_intersects(cpumask_t const   *src1p , cpumask_t const   *src2p ,
                                      int nbits )  __attribute__((__no_instrument_function__)) ;
#line 937 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static int __cpus_intersects(cpumask_t const   *src1p , cpumask_t const   *src2p ,
                                      int nbits ) 
{ 
  int tmp ;

  {
  {
#line 940
  tmp = bitmap_intersects((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                          (unsigned int )nbits);
  }
#line 940
  return (tmp);
}
}
#line 944
__inline static int __cpus_subset(cpumask_t const   *src1p , cpumask_t const   *src2p ,
                                  int nbits )  __attribute__((__no_instrument_function__)) ;
#line 944 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static int __cpus_subset(cpumask_t const   *src1p , cpumask_t const   *src2p ,
                                  int nbits ) 
{ 
  int tmp ;

  {
  {
#line 947
  tmp = bitmap_subset((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                      (unsigned int )nbits);
  }
#line 947
  return (tmp);
}
}
#line 951
__inline static int __cpus_empty(cpumask_t const   *srcp , int nbits )  __attribute__((__no_instrument_function__)) ;
#line 951 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static int __cpus_empty(cpumask_t const   *srcp , int nbits ) 
{ 
  int tmp ;

  {
  {
#line 953
  tmp = bitmap_empty((unsigned long const   *)(srcp->bits), (unsigned int )nbits);
  }
#line 953
  return (tmp);
}
}
#line 957
__inline static int __cpus_weight(cpumask_t const   *srcp , int nbits )  __attribute__((__no_instrument_function__)) ;
#line 957 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static int __cpus_weight(cpumask_t const   *srcp , int nbits ) 
{ 
  int tmp ;

  {
  {
#line 959
  tmp = bitmap_weight((unsigned long const   *)(srcp->bits), (unsigned int )nbits);
  }
#line 959
  return (tmp);
}
}
#line 964
__inline static void __cpus_shift_left(cpumask_t *dstp , cpumask_t const   *srcp ,
                                       int n , int nbits )  __attribute__((__no_instrument_function__)) ;
#line 964 "../../../analyzer/../bench/linux-headers/include/linux/cpumask.h"
__inline static void __cpus_shift_left(cpumask_t *dstp , cpumask_t const   *srcp ,
                                       int n , int nbits ) 
{ 


  {
  {
#line 967
  bitmap_shift_left(dstp->bits, (unsigned long const   *)(srcp->bits), n, nbits);
  }
#line 968
  return;
}
}
#line 6 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/cpumask.h"
extern cpumask_var_t cpu_callin_mask ;
#line 7
extern cpumask_var_t cpu_callout_mask ;
#line 8
extern cpumask_var_t cpu_initialized_mask ;
#line 9
extern cpumask_var_t cpu_sibling_setup_mask ;
#line 11
extern void setup_cpu_local_masks(void) ;
#line 34 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/msr.h"
__inline static unsigned long long native_read_tscp(unsigned int *aux )  __attribute__((__no_instrument_function__)) ;
#line 34 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/msr.h"
__inline static unsigned long long native_read_tscp(unsigned int *aux ) 
{ 
  unsigned long low ;
  unsigned long high ;

  {
  {
#line 37
  __asm__  volatile   (".byte 0x0f,0x01,0xf9": "=a" (low), "=d" (high), "=c" (*aux));
  }
#line 39
  return ((unsigned long long )low | ((u64 )high << 32));
}
}
#line 60
__inline static unsigned long long native_read_msr(unsigned int msr )  __attribute__((__no_instrument_function__)) ;
#line 60 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/msr.h"
__inline static unsigned long long native_read_msr(unsigned int msr ) 
{ 
  unsigned int low ;
  unsigned int high ;

  {
  {
#line 64
  __asm__  volatile   ("rdmsr": "=a" (low), "=d" (high): "c" (msr));
  }
#line 65
  return ((unsigned long long )low | ((u64 )high << 32));
}
}
#line 68
__inline static unsigned long long native_read_msr_safe(unsigned int msr , int *err )  __attribute__((__no_instrument_function__)) ;
#line 68 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/msr.h"
__inline static unsigned long long native_read_msr_safe(unsigned int msr , int *err ) 
{ 
  unsigned int low ;
  unsigned int high ;

  {
  {
#line 73
  __asm__  volatile   ("2: rdmsr ; xor %[err],%[err]\n"
                       "1:\n\t"
                       ".section .fixup,\"ax\"\n\t"
                       "3:  mov %[fault],%[err] ; jmp 1b\n\t"
                       ".previous\n\t"
                       " .pushsection \"__ex_table\",\"a\"\n"
                       " .balign 8\n"
                       " .long ("
                       "2b"
                       ") - .\n"
                       " .long ("
                       "3b"
                       ") - .\n"
                       " .popsection\n": [err] "=r" (*err), "=a" (low), "=d" (high): "c" (msr),
                       [fault] "i" (-5));
  }
#line 81
  return ((unsigned long long )low | ((u64 )high << 32));
}
}
#line 84
__inline static void native_write_msr(unsigned int msr , unsigned int low , unsigned int high )  __attribute__((__no_instrument_function__)) ;
#line 84 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/msr.h"
__inline static void native_write_msr(unsigned int msr , unsigned int low , unsigned int high ) 
{ 


  {
  {
#line 87
  __asm__  volatile   ("wrmsr": : "c" (msr), "a" (low), "d" (high): "memory");
  }
#line 88
  return;
}
}
#line 91
__inline static int native_write_msr_safe(unsigned int msr , unsigned int low , unsigned int high )  __attribute__((__no_instrument_function__)) ;
#line 91 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/msr.h"
__inline static int native_write_msr_safe(unsigned int msr , unsigned int low , unsigned int high ) 
{ 
  int err ;

  {
  {
#line 95
  __asm__  volatile   ("2: wrmsr ; xor %[err],%[err]\n"
                       "1:\n\t"
                       ".section .fixup,\"ax\"\n\t"
                       "3:  mov %[fault],%[err] ; jmp 1b\n\t"
                       ".previous\n\t"
                       " .pushsection \"__ex_table\",\"a\"\n"
                       " .balign 8\n"
                       " .long ("
                       "2b"
                       ") - .\n"
                       " .long ("
                       "3b"
                       ") - .\n"
                       " .popsection\n": [err] "=a" (err): "c" (msr), "0" (low), "d" (high),
                       [fault] "i" (-5): "memory");
  }
#line 105
  return (err);
}
}
#line 108
extern unsigned long long native_read_tsc(void) ;
#line 110
extern int rdmsr_safe_regs(u32 *regs ) ;
#line 111
extern int wrmsr_safe_regs(u32 *regs ) ;
#line 113
__inline static unsigned long long ( __attribute__((__always_inline__)) __native_read_tsc)(void)  __attribute__((__no_instrument_function__)) ;
#line 113 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/msr.h"
__inline static unsigned long long ( __attribute__((__always_inline__)) __native_read_tsc)(void) 
{ 
  unsigned int low ;
  unsigned int high ;

  {
  {
#line 117
  __asm__  volatile   ("rdtsc": "=a" (low), "=d" (high));
  }
#line 119
  return ((unsigned long long )low | ((u64 )high << 32));
}
}
#line 122
__inline static unsigned long long native_read_pmc(int counter )  __attribute__((__no_instrument_function__)) ;
#line 122 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/msr.h"
__inline static unsigned long long native_read_pmc(int counter ) 
{ 
  unsigned int low ;
  unsigned int high ;

  {
  {
#line 126
  __asm__  volatile   ("rdpmc": "=a" (low), "=d" (high): "c" (counter));
  }
#line 127
  return ((unsigned long long )low | ((u64 )high << 32));
}
}
#line 147
__inline static void wrmsr(unsigned int msr , unsigned int low , unsigned int high )  __attribute__((__no_instrument_function__)) ;
#line 147 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/msr.h"
__inline static void wrmsr(unsigned int msr , unsigned int low , unsigned int high ) 
{ 


  {
  {
#line 149
  native_write_msr(msr, low, high);
  }
#line 150
  return;
}
}
#line 159
__inline static int wrmsr_safe(unsigned int msr , unsigned int low , unsigned int high )  __attribute__((__no_instrument_function__)) ;
#line 159 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/msr.h"
__inline static int wrmsr_safe(unsigned int msr , unsigned int low , unsigned int high ) 
{ 
  int tmp ;

  {
  {
#line 161
  tmp = native_write_msr_safe(msr, low, high);
  }
#line 161
  return (tmp);
}
}
#line 174
__inline static int rdmsrl_safe(unsigned int msr , unsigned long long *p )  __attribute__((__no_instrument_function__)) ;
#line 174 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/msr.h"
__inline static int rdmsrl_safe(unsigned int msr , unsigned long long *p ) 
{ 
  int err ;

  {
  {
#line 178
  *p = native_read_msr_safe(msr, & err);
  }
#line 179
  return (err);
}
}
#line 215
extern struct msr *msrs_alloc(void) ;
#line 216
extern void msrs_free(struct msr *msrs ) ;
#line 217
extern int msr_set_bit(u32 msr , u8 bit ) ;
#line 218
extern int msr_clear_bit(u32 msr , u8 bit ) ;
#line 221
extern int rdmsr_on_cpu(unsigned int cpu , u32 msr_no , u32 *l , u32 *h ) ;
#line 222
extern int wrmsr_on_cpu(unsigned int cpu , u32 msr_no , u32 l , u32 h ) ;
#line 223
extern int rdmsrl_on_cpu(unsigned int cpu , u32 msr_no , u64 *q ) ;
#line 224
extern int wrmsrl_on_cpu(unsigned int cpu , u32 msr_no , u64 q ) ;
#line 225
extern void rdmsr_on_cpus(struct cpumask  const  *mask , u32 msr_no , struct msr *msrs ) ;
#line 226
extern void wrmsr_on_cpus(struct cpumask  const  *mask , u32 msr_no , struct msr *msrs ) ;
#line 227
extern int rdmsr_safe_on_cpu(unsigned int cpu , u32 msr_no , u32 *l , u32 *h ) ;
#line 228
extern int wrmsr_safe_on_cpu(unsigned int cpu , u32 msr_no , u32 l , u32 h ) ;
#line 229
extern int rdmsrl_safe_on_cpu(unsigned int cpu , u32 msr_no , u64 *q ) ;
#line 230
extern int wrmsrl_safe_on_cpu(unsigned int cpu , u32 msr_no , u64 q ) ;
#line 231
extern int rdmsr_safe_regs_on_cpu(unsigned int cpu , u32 *regs ) ;
#line 232
extern int wrmsr_safe_regs_on_cpu(unsigned int cpu , u32 *regs ) ;
#line 7 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/special_insns.h"
__inline static void native_clts(void)  __attribute__((__no_instrument_function__)) ;
#line 7 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/special_insns.h"
__inline static void native_clts(void) 
{ 


  {
  {
#line 9
  __asm__  volatile   ("clts":);
  }
#line 10
  return;
}
}
#line 19
extern unsigned long __force_order ;
#line 21
__inline static unsigned long native_read_cr0(void)  __attribute__((__no_instrument_function__)) ;
#line 21 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/special_insns.h"
__inline static unsigned long native_read_cr0(void) 
{ 
  unsigned long val ;

  {
  {
#line 24
  __asm__  volatile   ("mov %%cr0,%0\n\t": "=r" (val), "=m" (__force_order));
  }
#line 25
  return (val);
}
}
#line 28
__inline static void native_write_cr0(unsigned long val )  __attribute__((__no_instrument_function__)) ;
#line 28 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/special_insns.h"
__inline static void native_write_cr0(unsigned long val ) 
{ 


  {
  {
#line 30
  __asm__  volatile   ("mov %0,%%cr0": : "r" (val), "m" (__force_order));
  }
#line 31
  return;
}
}
#line 33
__inline static unsigned long native_read_cr2(void)  __attribute__((__no_instrument_function__)) ;
#line 33 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/special_insns.h"
__inline static unsigned long native_read_cr2(void) 
{ 
  unsigned long val ;

  {
  {
#line 36
  __asm__  volatile   ("mov %%cr2,%0\n\t": "=r" (val), "=m" (__force_order));
  }
#line 37
  return (val);
}
}
#line 40
__inline static void native_write_cr2(unsigned long val )  __attribute__((__no_instrument_function__)) ;
#line 40 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/special_insns.h"
__inline static void native_write_cr2(unsigned long val ) 
{ 


  {
  {
#line 42
  __asm__  volatile   ("mov %0,%%cr2": : "r" (val), "m" (__force_order));
  }
#line 43
  return;
}
}
#line 45
__inline static unsigned long native_read_cr3(void)  __attribute__((__no_instrument_function__)) ;
#line 45 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/special_insns.h"
__inline static unsigned long native_read_cr3(void) 
{ 
  unsigned long val ;

  {
  {
#line 48
  __asm__  volatile   ("mov %%cr3,%0\n\t": "=r" (val), "=m" (__force_order));
  }
#line 49
  return (val);
}
}
#line 52
__inline static void native_write_cr3(unsigned long val )  __attribute__((__no_instrument_function__)) ;
#line 52 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/special_insns.h"
__inline static void native_write_cr3(unsigned long val ) 
{ 


  {
  {
#line 54
  __asm__  volatile   ("mov %0,%%cr3": : "r" (val), "m" (__force_order));
  }
#line 55
  return;
}
}
#line 57
__inline static unsigned long native_read_cr4(void)  __attribute__((__no_instrument_function__)) ;
#line 57 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/special_insns.h"
__inline static unsigned long native_read_cr4(void) 
{ 
  unsigned long val ;

  {
  {
#line 60
  __asm__  volatile   ("mov %%cr4,%0\n\t": "=r" (val), "=m" (__force_order));
  }
#line 61
  return (val);
}
}
#line 64
__inline static unsigned long native_read_cr4_safe(void)  __attribute__((__no_instrument_function__)) ;
#line 64 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/special_insns.h"
__inline static unsigned long native_read_cr4_safe(void) 
{ 
  unsigned long val ;

  {
  {
#line 75
  val = native_read_cr4();
  }
#line 77
  return (val);
}
}
#line 80
__inline static void native_write_cr4(unsigned long val )  __attribute__((__no_instrument_function__)) ;
#line 80 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/special_insns.h"
__inline static void native_write_cr4(unsigned long val ) 
{ 


  {
  {
#line 82
  __asm__  volatile   ("mov %0,%%cr4": : "r" (val), "m" (__force_order));
  }
#line 83
  return;
}
}
#line 86
__inline static unsigned long native_read_cr8(void)  __attribute__((__no_instrument_function__)) ;
#line 86 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/special_insns.h"
__inline static unsigned long native_read_cr8(void) 
{ 
  unsigned long cr8 ;

  {
  {
#line 89
  __asm__  volatile   ("movq %%cr8,%0": "=r" (cr8));
  }
#line 90
  return (cr8);
}
}
#line 93
__inline static void native_write_cr8(unsigned long val )  __attribute__((__no_instrument_function__)) ;
#line 93 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/special_insns.h"
__inline static void native_write_cr8(unsigned long val ) 
{ 


  {
  {
#line 95
  __asm__  volatile   ("movq %0,%%cr8": : "r" (val): "memory");
  }
#line 96
  return;
}
}
#line 99
__inline static void native_wbinvd(void)  __attribute__((__no_instrument_function__)) ;
#line 99 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/special_insns.h"
__inline static void native_wbinvd(void) 
{ 


  {
  {
#line 101
  __asm__  volatile   ("wbinvd": : : "memory");
  }
#line 102
  return;
}
}
#line 104
extern void native_load_gs_index(unsigned int  ) ;
#line 110
__inline static unsigned long read_cr0(void)  __attribute__((__no_instrument_function__)) ;
#line 110 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/special_insns.h"
__inline static unsigned long read_cr0(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 112
  tmp = native_read_cr0();
  }
#line 112
  return (tmp);
}
}
#line 115
__inline static void write_cr0(unsigned long x )  __attribute__((__no_instrument_function__)) ;
#line 115 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/special_insns.h"
__inline static void write_cr0(unsigned long x ) 
{ 


  {
  {
#line 117
  native_write_cr0(x);
  }
#line 118
  return;
}
}
#line 120
__inline static unsigned long read_cr2(void)  __attribute__((__no_instrument_function__)) ;
#line 120 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/special_insns.h"
__inline static unsigned long read_cr2(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 122
  tmp = native_read_cr2();
  }
#line 122
  return (tmp);
}
}
#line 125
__inline static void write_cr2(unsigned long x )  __attribute__((__no_instrument_function__)) ;
#line 125 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/special_insns.h"
__inline static void write_cr2(unsigned long x ) 
{ 


  {
  {
#line 127
  native_write_cr2(x);
  }
#line 128
  return;
}
}
#line 130
__inline static unsigned long read_cr3(void)  __attribute__((__no_instrument_function__)) ;
#line 130 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/special_insns.h"
__inline static unsigned long read_cr3(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 132
  tmp = native_read_cr3();
  }
#line 132
  return (tmp);
}
}
#line 135
__inline static void write_cr3(unsigned long x )  __attribute__((__no_instrument_function__)) ;
#line 135 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/special_insns.h"
__inline static void write_cr3(unsigned long x ) 
{ 


  {
  {
#line 137
  native_write_cr3(x);
  }
#line 138
  return;
}
}
#line 140
__inline static unsigned long read_cr4(void)  __attribute__((__no_instrument_function__)) ;
#line 140 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/special_insns.h"
__inline static unsigned long read_cr4(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 142
  tmp = native_read_cr4();
  }
#line 142
  return (tmp);
}
}
#line 145
__inline static unsigned long read_cr4_safe(void)  __attribute__((__no_instrument_function__)) ;
#line 145 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/special_insns.h"
__inline static unsigned long read_cr4_safe(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 147
  tmp = native_read_cr4_safe();
  }
#line 147
  return (tmp);
}
}
#line 150
__inline static void write_cr4(unsigned long x )  __attribute__((__no_instrument_function__)) ;
#line 150 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/special_insns.h"
__inline static void write_cr4(unsigned long x ) 
{ 


  {
  {
#line 152
  native_write_cr4(x);
  }
#line 153
  return;
}
}
#line 155
__inline static void wbinvd(void)  __attribute__((__no_instrument_function__)) ;
#line 155 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/special_insns.h"
__inline static void wbinvd(void) 
{ 


  {
  {
#line 157
  native_wbinvd();
  }
#line 158
  return;
}
}
#line 162
__inline static unsigned long read_cr8(void)  __attribute__((__no_instrument_function__)) ;
#line 162 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/special_insns.h"
__inline static unsigned long read_cr8(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 164
  tmp = native_read_cr8();
  }
#line 164
  return (tmp);
}
}
#line 167
__inline static void write_cr8(unsigned long x )  __attribute__((__no_instrument_function__)) ;
#line 167 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/special_insns.h"
__inline static void write_cr8(unsigned long x ) 
{ 


  {
  {
#line 169
  native_write_cr8(x);
  }
#line 170
  return;
}
}
#line 172
__inline static void load_gs_index(unsigned int selector )  __attribute__((__no_instrument_function__)) ;
#line 172 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/special_insns.h"
__inline static void load_gs_index(unsigned int selector ) 
{ 


  {
  {
#line 174
  native_load_gs_index(selector);
  }
#line 175
  return;
}
}
#line 180
__inline static void clts(void)  __attribute__((__no_instrument_function__)) ;
#line 180 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/special_insns.h"
__inline static void clts(void) 
{ 


  {
  {
#line 182
  native_clts();
  }
#line 183
  return;
}
}
#line 189
__inline static void clflush(void volatile   *__p )  __attribute__((__no_instrument_function__)) ;
#line 189 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/special_insns.h"
__inline static void clflush(void volatile   *__p ) 
{ 


  {
  {
#line 191
  __asm__  volatile   ("clflush %0": "+m" (*((char volatile   *)__p)));
  }
#line 192
  return;
}
}
#line 194
__inline static void clflushopt(void volatile   *__p )  __attribute__((__no_instrument_function__)) ;
#line 194 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/special_insns.h"
__inline static void clflushopt(void volatile   *__p ) 
{ 


  {
  {
#line 196
  __asm__  volatile   ("661:\n\t"
                       ".byte "
                       "0x3e"
                       "; clflush %P0"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+23)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x66; clflush %P0"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection": "+m" (*((char volatile   *)__p)): "i" (0));
  }
#line 200
  return;
}
}
#line 14 "../../../analyzer/../bench/linux-headers/include/linux/personality.h"
extern int register_exec_domain(struct exec_domain * ) ;
#line 15
extern int unregister_exec_domain(struct exec_domain * ) ;
#line 16
extern int __set_personality(unsigned int  ) ;
#line 18 "../../../analyzer/../bench/linux-headers/include/linux/math64.h"
__inline static u64 div_u64_rem(u64 dividend , u32 divisor , u32 *remainder )  __attribute__((__no_instrument_function__)) ;
#line 18 "../../../analyzer/../bench/linux-headers/include/linux/math64.h"
__inline static u64 div_u64_rem(u64 dividend , u32 divisor , u32 *remainder ) 
{ 


  {
  {
#line 20
  *remainder = (u32 )(dividend % (unsigned long long )divisor);
  }
#line 21
  return (dividend / (u64 )divisor);
}
}
#line 27
__inline static s64 div_s64_rem(s64 dividend , s32 divisor , s32 *remainder )  __attribute__((__no_instrument_function__)) ;
#line 27 "../../../analyzer/../bench/linux-headers/include/linux/math64.h"
__inline static s64 div_s64_rem(s64 dividend , s32 divisor , s32 *remainder ) 
{ 


  {
  {
#line 29
  *remainder = (s32 )(dividend % (long long )divisor);
  }
#line 30
  return (dividend / (s64 )divisor);
}
}
#line 36
__inline static u64 div64_u64_rem(u64 dividend , u64 divisor , u64 *remainder )  __attribute__((__no_instrument_function__)) ;
#line 36 "../../../analyzer/../bench/linux-headers/include/linux/math64.h"
__inline static u64 div64_u64_rem(u64 dividend , u64 divisor , u64 *remainder ) 
{ 


  {
  {
#line 38
  *remainder = dividend % divisor;
  }
#line 39
  return (dividend / divisor);
}
}
#line 45
__inline static u64 div64_u64(u64 dividend , u64 divisor )  __attribute__((__no_instrument_function__)) ;
#line 45 "../../../analyzer/../bench/linux-headers/include/linux/math64.h"
__inline static u64 div64_u64(u64 dividend , u64 divisor ) 
{ 


  {
#line 47
  return (dividend / divisor);
}
}
#line 53
__inline static s64 div64_s64(s64 dividend , s64 divisor )  __attribute__((__no_instrument_function__)) ;
#line 53 "../../../analyzer/../bench/linux-headers/include/linux/math64.h"
__inline static s64 div64_s64(s64 dividend , s64 divisor ) 
{ 


  {
#line 55
  return (dividend / divisor);
}
}
#line 97
__inline static u64 div_u64(u64 dividend , u32 divisor )  __attribute__((__no_instrument_function__)) ;
#line 97 "../../../analyzer/../bench/linux-headers/include/linux/math64.h"
__inline static u64 div_u64(u64 dividend , u32 divisor ) 
{ 
  u32 remainder ;
  u64 tmp ;

  {
  {
#line 100
  tmp = div_u64_rem(dividend, divisor, & remainder);
  }
#line 100
  return (tmp);
}
}
#line 108
__inline static s64 div_s64(s64 dividend , s32 divisor )  __attribute__((__no_instrument_function__)) ;
#line 108 "../../../analyzer/../bench/linux-headers/include/linux/math64.h"
__inline static s64 div_s64(s64 dividend , s32 divisor ) 
{ 
  s32 remainder ;
  s64 tmp ;

  {
  {
#line 111
  tmp = div_s64_rem(dividend, divisor, & remainder);
  }
#line 111
  return (tmp);
}
}
#line 115
extern u32 iter_div_u64_rem(u64 dividend , u32 divisor , u64 *remainder ) ;
#line 117
__inline static u32 ( __attribute__((__always_inline__)) __iter_div_u64_rem)(u64 dividend ,
                                                                             u32 divisor ,
                                                                             u64 *remainder )  __attribute__((__no_instrument_function__)) ;
#line 117 "../../../analyzer/../bench/linux-headers/include/linux/math64.h"
__inline static u32 ( __attribute__((__always_inline__)) __iter_div_u64_rem)(u64 dividend ,
                                                                             u32 divisor ,
                                                                             u64 *remainder ) 
{ 
  u32 ret ;

  {
  {
#line 120
  ret = (u32 )0;
  }
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (! (dividend >= (u64 )divisor)) {
#line 122
      goto while_break;
    }
    {
#line 125
    __asm__  ("": "+rm" (dividend));
#line 127
    dividend -= (u64 )divisor;
#line 128
    ret ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 131
  *remainder = dividend;
  }
#line 133
  return (ret);
}
}
#line 148
__inline static u64 mul_u64_u32_shr(u64 a , u32 mul , unsigned int shift )  __attribute__((__no_instrument_function__)) ;
#line 148 "../../../analyzer/../bench/linux-headers/include/linux/math64.h"
__inline static u64 mul_u64_u32_shr(u64 a , u32 mul , unsigned int shift ) 
{ 
  u32 ah ;
  u32 al ;
  u64 ret ;

  {
  {
#line 153
  al = (u32 )a;
#line 154
  ah = (u32 )(a >> 32);
#line 156
  ret = (u64 )al * (u64 )mul >> shift;
  }
#line 157
  if (ah) {
    {
#line 158
    ret += (u64 )ah * (u64 )mul << (32U - shift);
    }
  }
#line 160
  return (ret);
}
}
#line 23 "../../../analyzer/../bench/linux-headers/include/linux/err.h"
__inline static void *( __attribute__((__warn_unused_result__)) ERR_PTR)(long error )  __attribute__((__no_instrument_function__)) ;
#line 23 "../../../analyzer/../bench/linux-headers/include/linux/err.h"
__inline static void *( __attribute__((__warn_unused_result__)) ERR_PTR)(long error ) 
{ 


  {
#line 25
  return ((void *)error);
}
}
#line 28
__inline static long ( __attribute__((__warn_unused_result__)) PTR_ERR)(void const   *ptr )  __attribute__((__no_instrument_function__)) ;
#line 28 "../../../analyzer/../bench/linux-headers/include/linux/err.h"
__inline static long ( __attribute__((__warn_unused_result__)) PTR_ERR)(void const   *ptr ) 
{ 


  {
#line 30
  return ((long )ptr);
}
}
#line 33
__inline static bool ( __attribute__((__warn_unused_result__)) IS_ERR)(void const   *ptr )  __attribute__((__no_instrument_function__)) ;
#line 33 "../../../analyzer/../bench/linux-headers/include/linux/err.h"
__inline static bool ( __attribute__((__warn_unused_result__)) IS_ERR)(void const   *ptr ) 
{ 
  long tmp ;

  {
  {
#line 35
  tmp = __builtin_expect((long )(! (! ((unsigned long )ptr >= 0xfffffffffffff001UL))),
                         0L);
  }
#line 35
  return ((bool )tmp);
}
}
#line 38
__inline static bool ( __attribute__((__warn_unused_result__)) IS_ERR_OR_NULL)(void const   *ptr )  __attribute__((__no_instrument_function__)) ;
#line 38 "../../../analyzer/../bench/linux-headers/include/linux/err.h"
__inline static bool ( __attribute__((__warn_unused_result__)) IS_ERR_OR_NULL)(void const   *ptr ) 
{ 
  long tmp ;
  int tmp___0 ;

  {
#line 40
  if (! ptr) {
    {
#line 40
    tmp___0 = 1;
    }
  } else {
    {
#line 40
    tmp = __builtin_expect((long )(! (! ((unsigned long )ptr >= 0xfffffffffffff001UL))),
                           0L);
    }
#line 40
    if (tmp) {
      {
#line 40
      tmp___0 = 1;
      }
    } else {
      {
#line 40
      tmp___0 = 0;
      }
    }
  }
#line 40
  return ((bool )tmp___0);
}
}
#line 50
__inline static void *( __attribute__((__warn_unused_result__)) ERR_CAST)(void const   *ptr )  __attribute__((__no_instrument_function__)) ;
#line 50 "../../../analyzer/../bench/linux-headers/include/linux/err.h"
__inline static void *( __attribute__((__warn_unused_result__)) ERR_CAST)(void const   *ptr ) 
{ 


  {
#line 53
  return ((void *)ptr);
}
}
#line 56
__inline static int ( __attribute__((__warn_unused_result__)) PTR_ERR_OR_ZERO)(void const   *ptr )  __attribute__((__no_instrument_function__)) ;
#line 56 "../../../analyzer/../bench/linux-headers/include/linux/err.h"
__inline static int ( __attribute__((__warn_unused_result__)) PTR_ERR_OR_ZERO)(void const   *ptr ) 
{ 
  long tmp ;
  bool tmp___0 ;

  {
  {
#line 58
  tmp___0 = IS_ERR(ptr);
  }
#line 58
  if (tmp___0) {
    {
#line 59
    tmp = PTR_ERR(ptr);
    }
#line 59
    return ((int )tmp);
  } else {
#line 61
    return (0);
  }
}
}
#line 11 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/irqflags.h"
__inline static unsigned long native_save_fl(void)  __attribute__((__no_instrument_function__)) ;
#line 11 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/irqflags.h"
__inline static unsigned long native_save_fl(void) 
{ 
  unsigned long flags ;

  {
  {
#line 20
  __asm__  volatile   ("# __raw_save_flags\n\t"
                       "pushf ; pop %0": "=rm" (flags): : "memory");
  }
#line 26
  return (flags);
}
}
#line 29
__inline static void native_restore_fl(unsigned long flags )  __attribute__((__no_instrument_function__)) ;
#line 29 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/irqflags.h"
__inline static void native_restore_fl(unsigned long flags ) 
{ 


  {
  {
#line 31
  __asm__  volatile   ("push %0 ; popf": : "g" (flags): "memory", "cc");
  }
#line 35
  return;
}
}
#line 37
__inline static void native_irq_disable(void)  __attribute__((__no_instrument_function__)) ;
#line 37 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/irqflags.h"
__inline static void native_irq_disable(void) 
{ 


  {
  {
#line 39
  __asm__  volatile   ("cli": : : "memory");
  }
#line 40
  return;
}
}
#line 42
__inline static void native_irq_enable(void)  __attribute__((__no_instrument_function__)) ;
#line 42 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/irqflags.h"
__inline static void native_irq_enable(void) 
{ 


  {
  {
#line 44
  __asm__  volatile   ("sti": : : "memory");
  }
#line 45
  return;
}
}
#line 47
__inline static void native_safe_halt(void)  __attribute__((__no_instrument_function__)) ;
#line 47 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/irqflags.h"
__inline static void native_safe_halt(void) 
{ 


  {
  {
#line 49
  __asm__  volatile   ("sti; hlt": : : "memory");
  }
#line 50
  return;
}
}
#line 52
__inline static void native_halt(void)  __attribute__((__no_instrument_function__)) ;
#line 52 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/irqflags.h"
__inline static void native_halt(void) 
{ 


  {
  {
#line 54
  __asm__  volatile   ("hlt": : : "memory");
  }
#line 55
  return;
}
}
#line 65
__inline static unsigned long arch_local_save_flags(void)  __attribute__((__no_instrument_function__)) ;
#line 65 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/irqflags.h"
__inline static unsigned long arch_local_save_flags(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 67
  tmp = native_save_fl();
  }
#line 67
  return (tmp);
}
}
#line 70
__inline static void arch_local_irq_restore(unsigned long flags )  __attribute__((__no_instrument_function__)) ;
#line 70 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/irqflags.h"
__inline static void arch_local_irq_restore(unsigned long flags ) 
{ 


  {
  {
#line 72
  native_restore_fl(flags);
  }
#line 73
  return;
}
}
#line 75
__inline static void arch_local_irq_disable(void)  __attribute__((__no_instrument_function__)) ;
#line 75 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/irqflags.h"
__inline static void arch_local_irq_disable(void) 
{ 


  {
  {
#line 77
  native_irq_disable();
  }
#line 78
  return;
}
}
#line 80
__inline static void arch_local_irq_enable(void)  __attribute__((__no_instrument_function__)) ;
#line 80 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/irqflags.h"
__inline static void arch_local_irq_enable(void) 
{ 


  {
  {
#line 82
  native_irq_enable();
  }
#line 83
  return;
}
}
#line 89
__inline static void arch_safe_halt(void)  __attribute__((__no_instrument_function__)) ;
#line 89 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/irqflags.h"
__inline static void arch_safe_halt(void) 
{ 


  {
  {
#line 91
  native_safe_halt();
  }
#line 92
  return;
}
}
#line 98
__inline static void halt(void)  __attribute__((__no_instrument_function__)) ;
#line 98 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/irqflags.h"
__inline static void halt(void) 
{ 


  {
  {
#line 100
  native_halt();
  }
#line 101
  return;
}
}
#line 106
__inline static unsigned long arch_local_irq_save(void)  __attribute__((__no_instrument_function__)) ;
#line 106 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/irqflags.h"
__inline static unsigned long arch_local_irq_save(void) 
{ 
  unsigned long flags ;
  unsigned long tmp ;

  {
  {
#line 108
  tmp = arch_local_save_flags();
#line 108
  flags = tmp;
#line 109
  arch_local_irq_disable();
  }
#line 110
  return (flags);
}
}
#line 155
__inline static int arch_irqs_disabled_flags(unsigned long flags )  __attribute__((__no_instrument_function__)) ;
#line 155 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/irqflags.h"
__inline static int arch_irqs_disabled_flags(unsigned long flags ) 
{ 


  {
#line 157
  return (! (flags & (1UL << 9)));
}
}
#line 160
__inline static int arch_irqs_disabled(void)  __attribute__((__no_instrument_function__)) ;
#line 160 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/irqflags.h"
__inline static int arch_irqs_disabled(void) 
{ 
  unsigned long flags ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
#line 162
  tmp = arch_local_save_flags();
#line 162
  flags = tmp;
#line 164
  tmp___0 = arch_irqs_disabled_flags(flags);
  }
#line 164
  return (tmp___0);
}
}
#line 46 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
__inline static void *current_text_addr(void)  __attribute__((__no_instrument_function__)) ;
#line 46 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
__inline static void *current_text_addr(void) 
{ 
  void *pc ;

  {
  {
#line 50
  __asm__  volatile   ("mov $1f, %0; 1:": "=r" (pc));
  }
#line 52
  return (pc);
}
}
#line 68
extern u16 tlb_lli_4k[1]  __attribute__((__section__(".data..read_mostly"))) ;
#line 69
extern u16 tlb_lli_2m[1]  __attribute__((__section__(".data..read_mostly"))) ;
#line 70
extern u16 tlb_lli_4m[1]  __attribute__((__section__(".data..read_mostly"))) ;
#line 71
extern u16 tlb_lld_4k[1]  __attribute__((__section__(".data..read_mostly"))) ;
#line 72
extern u16 tlb_lld_2m[1]  __attribute__((__section__(".data..read_mostly"))) ;
#line 73
extern u16 tlb_lld_4m[1]  __attribute__((__section__(".data..read_mostly"))) ;
#line 74
extern u16 tlb_lld_1g[1]  __attribute__((__section__(".data..read_mostly"))) ;
#line 146
extern struct cpuinfo_x86 boot_cpu_data ;
#line 147
extern struct cpuinfo_x86 new_cpu_data ;
#line 149
extern struct tss_struct doublefault_tss ;
#line 150
extern __u32 cpu_caps_cleared[11] ;
#line 151
extern __u32 cpu_caps_set[11] ;
#line 154
extern struct cpuinfo_x86 cpu_info  __attribute__((__section__(".data..percpu"), __aligned__((1) <<
                                                                                              (6) ))) ;
#line 161
extern struct seq_operations  const  cpuinfo_op ;
#line 165
extern void cpu_detect(struct cpuinfo_x86 *c ) ;
#line 166
extern void fpu_detect(struct cpuinfo_x86 *c ) ;
#line 168
extern void early_cpu_init(void) ;
#line 169
extern void identify_boot_cpu(void) ;
#line 170
extern void identify_secondary_cpu(struct cpuinfo_x86 * ) ;
#line 171
extern void print_cpu_info(struct cpuinfo_x86 * ) ;
#line 172
extern void print_cpu_msr(struct cpuinfo_x86 * ) ;
#line 173
extern void init_scattered_cpuid_features(struct cpuinfo_x86 *c ) ;
#line 174
extern unsigned int init_intel_cacheinfo(struct cpuinfo_x86 *c ) ;
#line 175
extern void init_amd_cacheinfo(struct cpuinfo_x86 *c ) ;
#line 177
extern void detect_extended_topology(struct cpuinfo_x86 *c ) ;
#line 178
extern void detect_ht(struct cpuinfo_x86 *c ) ;
#line 183
__inline static int have_cpuid_p(void)  __attribute__((__no_instrument_function__)) ;
#line 183 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
__inline static int have_cpuid_p(void) 
{ 


  {
#line 185
  return (1);
}
}
#line 188
__inline static void native_cpuid(unsigned int *eax , unsigned int *ebx , unsigned int *ecx ,
                                  unsigned int *edx )  __attribute__((__no_instrument_function__)) ;
#line 188 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
__inline static void native_cpuid(unsigned int *eax , unsigned int *ebx , unsigned int *ecx ,
                                  unsigned int *edx ) 
{ 


  {
  {
#line 192
  __asm__  volatile   ("cpuid": "=a" (*eax), "=b" (*ebx), "=c" (*ecx), "=d" (*edx): "0" (*eax),
                       "2" (*ecx): "memory");
  }
#line 199
  return;
}
}
#line 201
__inline static void load_cr3(pgd_t *pgdir )  __attribute__((__no_instrument_function__)) ;
#line 201 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
__inline static void load_cr3(pgd_t *pgdir ) 
{ 
  unsigned long tmp ;

  {
  {
#line 203
  tmp = __phys_addr_nodebug((unsigned long )pgdir);
#line 203
  write_cr3(tmp);
  }
#line 204
  return;
}
}
#line 285
extern struct tss_struct init_tss  __attribute__((__section__(".data..percpu"), __aligned__((1) <<
                                                                                             (6) ))) ;
#line 416
extern struct orig_ist orig_ist  __attribute__((__section__(".data..percpu"))) ;
#line 431
extern union irq_stack_union irq_stack_union  __attribute__((__section__(".data..percpu..first"),
__externally_visible__)) ;
#line 432
extern union irq_stack_union init_per_cpu__irq_stack_union ;
#line 434
extern char *irq_stack_ptr  __attribute__((__section__(".data..percpu"))) ;
#line 435
extern unsigned int irq_count  __attribute__((__section__(".data..percpu"))) ;
#line 436
extern void ignore_sysret(void) ;
#line 462
extern unsigned int xstate_size ;
#line 463
extern void free_thread_xstate(struct task_struct * ) ;
#line 464
extern struct kmem_cache *task_xstate_cachep ;
#line 530
__inline static void native_set_iopl_mask(unsigned int mask )  __attribute__((__no_instrument_function__)) ;
#line 530 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
__inline static void native_set_iopl_mask(unsigned int mask ) 
{ 


  {
#line 544
  return;
}
}
#line 546
__inline static void native_load_sp0(struct tss_struct *tss , struct thread_struct *thread )  __attribute__((__no_instrument_function__)) ;
#line 546 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
__inline static void native_load_sp0(struct tss_struct *tss , struct thread_struct *thread ) 
{ 


  {
  {
#line 549
  tss->x86_tss.sp0 = (u64 )thread->sp0;
  }
#line 557
  return;
}
}
#line 559
__inline static void native_swapgs(void)  __attribute__((__no_instrument_function__)) ;
#line 559 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
__inline static void native_swapgs(void) 
{ 


  {
  {
#line 562
  __asm__  volatile   ("swapgs": : : "memory");
  }
#line 564
  return;
}
}
#line 572
__inline static void load_sp0(struct tss_struct *tss , struct thread_struct *thread )  __attribute__((__no_instrument_function__)) ;
#line 572 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
__inline static void load_sp0(struct tss_struct *tss , struct thread_struct *thread ) 
{ 


  {
  {
#line 575
  native_load_sp0(tss, thread);
  }
#line 576
  return;
}
}
#line 587
extern unsigned long mmu_cr4_features ;
#line 588
extern u32 *trampoline_cr4_features ;
#line 590
__inline static void set_in_cr4(unsigned long mask )  __attribute__((__no_instrument_function__)) ;
#line 590 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
__inline static void set_in_cr4(unsigned long mask ) 
{ 
  unsigned long cr4 ;

  {
  {
#line 594
  mmu_cr4_features |= mask;
  }
#line 595
  if (trampoline_cr4_features) {
    {
#line 596
    *trampoline_cr4_features = (u32 )mmu_cr4_features;
    }
  }
  {
#line 597
  cr4 = read_cr4();
#line 598
  cr4 |= mask;
#line 599
  write_cr4(cr4);
  }
#line 600
  return;
}
}
#line 602
__inline static void clear_in_cr4(unsigned long mask )  __attribute__((__no_instrument_function__)) ;
#line 602 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
__inline static void clear_in_cr4(unsigned long mask ) 
{ 
  unsigned long cr4 ;

  {
  {
#line 606
  mmu_cr4_features &= ~ mask;
  }
#line 607
  if (trampoline_cr4_features) {
    {
#line 608
    *trampoline_cr4_features = (u32 )mmu_cr4_features;
    }
  }
  {
#line 609
  cr4 = read_cr4();
#line 610
  cr4 &= ~ mask;
#line 611
  write_cr4(cr4);
  }
#line 612
  return;
}
}
#line 620
extern void release_thread(struct task_struct * ) ;
#line 622
extern unsigned long get_wchan(struct task_struct *p ) ;
#line 629
__inline static void cpuid(unsigned int op , unsigned int *eax , unsigned int *ebx ,
                           unsigned int *ecx , unsigned int *edx )  __attribute__((__no_instrument_function__)) ;
#line 629 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
__inline static void cpuid(unsigned int op , unsigned int *eax , unsigned int *ebx ,
                           unsigned int *ecx , unsigned int *edx ) 
{ 


  {
  {
#line 633
  *eax = op;
#line 634
  *ecx = 0U;
#line 635
  native_cpuid(eax, ebx, ecx, edx);
  }
#line 636
  return;
}
}
#line 639
__inline static void cpuid_count(unsigned int op , int count , unsigned int *eax ,
                                 unsigned int *ebx , unsigned int *ecx , unsigned int *edx )  __attribute__((__no_instrument_function__)) ;
#line 639 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
__inline static void cpuid_count(unsigned int op , int count , unsigned int *eax ,
                                 unsigned int *ebx , unsigned int *ecx , unsigned int *edx ) 
{ 


  {
  {
#line 643
  *eax = op;
#line 644
  *ecx = (unsigned int )count;
#line 645
  native_cpuid(eax, ebx, ecx, edx);
  }
#line 646
  return;
}
}
#line 651
__inline static unsigned int cpuid_eax(unsigned int op )  __attribute__((__no_instrument_function__)) ;
#line 651 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
__inline static unsigned int cpuid_eax(unsigned int op ) 
{ 
  unsigned int eax ;
  unsigned int ebx ;
  unsigned int ecx ;
  unsigned int edx ;

  {
  {
#line 655
  cpuid(op, & eax, & ebx, & ecx, & edx);
  }
#line 657
  return (eax);
}
}
#line 660
__inline static unsigned int cpuid_ebx(unsigned int op )  __attribute__((__no_instrument_function__)) ;
#line 660 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
__inline static unsigned int cpuid_ebx(unsigned int op ) 
{ 
  unsigned int eax ;
  unsigned int ebx ;
  unsigned int ecx ;
  unsigned int edx ;

  {
  {
#line 664
  cpuid(op, & eax, & ebx, & ecx, & edx);
  }
#line 666
  return (ebx);
}
}
#line 669
__inline static unsigned int cpuid_ecx(unsigned int op )  __attribute__((__no_instrument_function__)) ;
#line 669 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
__inline static unsigned int cpuid_ecx(unsigned int op ) 
{ 
  unsigned int eax ;
  unsigned int ebx ;
  unsigned int ecx ;
  unsigned int edx ;

  {
  {
#line 673
  cpuid(op, & eax, & ebx, & ecx, & edx);
  }
#line 675
  return (ecx);
}
}
#line 678
__inline static unsigned int cpuid_edx(unsigned int op )  __attribute__((__no_instrument_function__)) ;
#line 678 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
__inline static unsigned int cpuid_edx(unsigned int op ) 
{ 
  unsigned int eax ;
  unsigned int ebx ;
  unsigned int ecx ;
  unsigned int edx ;

  {
  {
#line 682
  cpuid(op, & eax, & ebx, & ecx, & edx);
  }
#line 684
  return (edx);
}
}
#line 688
__inline static void rep_nop(void)  __attribute__((__no_instrument_function__)) ;
#line 688 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
__inline static void rep_nop(void) 
{ 


  {
  {
#line 690
  __asm__  volatile   ("rep; nop": : : "memory");
  }
#line 691
  return;
}
}
#line 693
__inline static void cpu_relax(void)  __attribute__((__no_instrument_function__)) ;
#line 693 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
__inline static void cpu_relax(void) 
{ 


  {
  {
#line 695
  rep_nop();
  }
#line 696
  return;
}
}
#line 701
__inline static void sync_core(void)  __attribute__((__no_instrument_function__)) ;
#line 701 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
__inline static void sync_core(void) 
{ 
  int tmp ;

  {
  {
#line 723
  __asm__  volatile   ("cpuid": "=a" (tmp): "0" (1): "ebx", "ecx", "edx", "memory");
  }
#line 728
  return;
}
}
#line 730
extern void select_idle_routine(struct cpuinfo_x86  const  *c ) ;
#line 731
extern void init_amd_e400_c1e_mask(void) ;
#line 733
extern unsigned long boot_option_idle_override ;
#line 734
extern bool amd_e400_c1e_detected ;
#line 739
extern void enable_sep_cpu(void) ;
#line 740
extern int sysenter_setup(void) ;
#line 742
extern void early_trap_init(void) ;
#line 743
extern void early_trap_pf_init(void) ;
#line 746
extern struct desc_ptr early_gdt_descr ;
#line 748
extern void cpu_set_gdt(int  ) ;
#line 749
extern void switch_to_new_gdt(int  ) ;
#line 750
extern void load_percpu_segment(int  ) ;
#line 751
extern void cpu_init(void) ;
#line 753
__inline static unsigned long get_debugctlmsr(void)  __attribute__((__no_instrument_function__)) ;
#line 753 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
__inline static unsigned long get_debugctlmsr(void) 
{ 
  unsigned long debugctlmsr ;
  unsigned long long tmp ;

  {
  {
#line 755
  debugctlmsr = 0UL;
#line 761
  tmp = native_read_msr(473U);
#line 761
  debugctlmsr = (unsigned long )tmp;
  }
#line 763
  return (debugctlmsr);
}
}
#line 766
__inline static void update_debugctlmsr(unsigned long debugctlmsr )  __attribute__((__no_instrument_function__)) ;
#line 766 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
__inline static void update_debugctlmsr(unsigned long debugctlmsr ) 
{ 


  {
  {
#line 772
  native_write_msr(473U, (u32 )((u64 )debugctlmsr), (u32 )((u64 )debugctlmsr >> 32));
  }
#line 773
  return;
}
}
#line 775
extern void set_task_blockstep(struct task_struct *task , bool on ) ;
#line 781
extern unsigned int machine_id ;
#line 782
extern unsigned int machine_submodel_id ;
#line 783
extern unsigned int BIOS_revision ;
#line 786
extern int bootloader_type ;
#line 787
extern int bootloader_version ;
#line 789
extern char ignore_fpu_irq ;
#line 808
__inline static void prefetch(void const   *x )  __attribute__((__no_instrument_function__)) ;
#line 808 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
__inline static void prefetch(void const   *x ) 
{ 


  {
  {
#line 810
  __asm__  volatile   ("661:\n\t"
                       "prefetcht0 (%1)"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 0*32+25)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       "prefetchnta (%1)"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection": : "i" (0), "r" (x));
  }
#line 814
  return;
}
}
#line 821
__inline static void prefetchw(void const   *x )  __attribute__((__no_instrument_function__)) ;
#line 821 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
__inline static void prefetchw(void const   *x ) 
{ 


  {
  {
#line 823
  __asm__  volatile   ("661:\n\t"
                       "prefetcht0 (%1)"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 1*32+31)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       "prefetchw (%1)"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection": : "i" (0), "r" (x));
  }
#line 827
  return;
}
}
#line 829
__inline static void spin_lock_prefetch(void const   *x )  __attribute__((__no_instrument_function__)) ;
#line 829 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
__inline static void spin_lock_prefetch(void const   *x ) 
{ 


  {
  {
#line 831
  prefetchw(x);
  }
#line 832
  return;
}
}
#line 929
extern unsigned long KSTK_ESP(struct task_struct *task ) ;
#line 934
extern unsigned long old_rsp  __attribute__((__section__(".data..percpu"))) ;
#line 938
extern void start_thread(struct pt_regs *regs , unsigned long new_ip , unsigned long new_sp ) ;
#line 953
extern int get_tsc_mode(unsigned long adr ) ;
#line 954
extern int set_tsc_mode(unsigned int val ) ;
#line 956
extern u16 amd_get_nb_id(int cpu ) ;
#line 958
__inline static uint32_t hypervisor_cpuid_base(char const   *sig , uint32_t leaves )  __attribute__((__no_instrument_function__)) ;
#line 958 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/processor.h"
__inline static uint32_t hypervisor_cpuid_base(char const   *sig , uint32_t leaves ) 
{ 
  uint32_t base ;
  uint32_t eax ;
  uint32_t signature[3] ;
  int tmp ;

  {
  {
#line 962
  base = (uint32_t )1073741824;
  }
  {
#line 962
  while (1) {
    while_continue: /* CIL Label */ ;
#line 962
    if (! (base < 1073807360U)) {
#line 962
      goto while_break;
    }
    {
#line 963
    cpuid(base, & eax, & signature[0], & signature[1], & signature[2]);
#line 965
    tmp = memcmp((void const   *)sig, (void const   *)(signature), 12UL);
    }
#line 965
    if (! tmp) {
#line 965
      if (leaves == 0U) {
#line 967
        return (base);
      } else
#line 965
      if (eax - base >= leaves) {
#line 967
        return (base);
      }
    }
    {
#line 962
    base += 256U;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 970
  return ((uint32_t )0);
}
}
#line 973
extern unsigned long arch_align_stack(unsigned long sp ) ;
#line 974
extern void free_init_pages(char *what , unsigned long begin , unsigned long end ) ;
#line 976
extern void default_idle(void) ;
#line 983
extern void stop_this_cpu(void *dummy ) ;
#line 984
extern void df_debug(struct pt_regs *regs , long error_code ) ;
#line 13 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/cmpxchg.h"
extern void __xchg_wrong_size(void)  __attribute__((__error__("Bad argument size for xchg"))) ;
#line 15
extern void __cmpxchg_wrong_size(void)  __attribute__((__error__("Bad argument size for cmpxchg"))) ;
#line 17
extern void __xadd_wrong_size(void)  __attribute__((__error__("Bad argument size for xadd"))) ;
#line 19
extern void __add_wrong_size(void)  __attribute__((__error__("Bad argument size for add"))) ;
#line 4 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/cmpxchg_64.h"
__inline static void set_64bit(u64 volatile   *ptr , u64 val )  __attribute__((__no_instrument_function__)) ;
#line 4 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/cmpxchg_64.h"
__inline static void set_64bit(u64 volatile   *ptr , u64 val ) 
{ 


  {
  {
#line 6
  *ptr = (u64 volatile   )val;
  }
#line 7
  return;
}
}
#line 25 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const   *v )  __attribute__((__no_instrument_function__)) ;
#line 25 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const   *v ) 
{ 


  {
#line 27
  return ((int )*((int volatile   *)(& v->counter)));
}
}
#line 37
__inline static void atomic_set(atomic_t *v , int i )  __attribute__((__no_instrument_function__)) ;
#line 37 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/atomic.h"
__inline static void atomic_set(atomic_t *v , int i ) 
{ 


  {
  {
#line 39
  v->counter = i;
  }
#line 40
  return;
}
}
#line 49
__inline static void atomic_add(int i , atomic_t *v )  __attribute__((__no_instrument_function__)) ;
#line 49 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/atomic.h"
__inline static void atomic_add(int i , atomic_t *v ) 
{ 


  {
  {
#line 51
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "addl %1,%0": "+m" (v->counter): "ir" (i));
  }
#line 54
  return;
}
}
#line 63
__inline static void atomic_sub(int i , atomic_t *v )  __attribute__((__no_instrument_function__)) ;
#line 63 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/atomic.h"
__inline static void atomic_sub(int i , atomic_t *v ) 
{ 


  {
  {
#line 65
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "subl %1,%0": "+m" (v->counter): "ir" (i));
  }
#line 68
  return;
}
}
#line 79
__inline static int atomic_sub_and_test(int i , atomic_t *v )  __attribute__((__no_instrument_function__)) ;
#line 79 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/atomic.h"
__inline static int atomic_sub_and_test(int i , atomic_t *v ) 
{ 
  char c ;

  {
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 81
    __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                         ".balign 4\n"
                         ".long 671f - .\n"
                         ".popsection\n"
                         "671:"
                         "\n\tlock; "
                         "subl"
                         " %2, "
                         "%0"
                         "; set"
                         "e"
                         " %1": "+m" (v->counter), "=qm" (c): "er" (i): "memory");
    }
#line 81
    return ((int )c != 0);
#line 81
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return (0);
}
}
#line 90
__inline static void atomic_inc(atomic_t *v )  __attribute__((__no_instrument_function__)) ;
#line 90 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/atomic.h"
__inline static void atomic_inc(atomic_t *v ) 
{ 


  {
  {
#line 92
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "incl %0": "+m" (v->counter));
  }
#line 94
  return;
}
}
#line 102
__inline static void atomic_dec(atomic_t *v )  __attribute__((__no_instrument_function__)) ;
#line 102 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/atomic.h"
__inline static void atomic_dec(atomic_t *v ) 
{ 


  {
  {
#line 104
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "decl %0": "+m" (v->counter));
  }
#line 106
  return;
}
}
#line 116
__inline static int atomic_dec_and_test(atomic_t *v )  __attribute__((__no_instrument_function__)) ;
#line 116 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/atomic.h"
__inline static int atomic_dec_and_test(atomic_t *v ) 
{ 
  char c ;

  {
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 118
    __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                         ".balign 4\n"
                         ".long 671f - .\n"
                         ".popsection\n"
                         "671:"
                         "\n\tlock; "
                         "decl"
                         " "
                         "%0"
                         "; set"
                         "e"
                         " %1": "+m" (v->counter), "=qm" (c): : "memory");
    }
#line 118
    return ((int )c != 0);
#line 118
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  return (0);
}
}
#line 129
__inline static int atomic_inc_and_test(atomic_t *v )  __attribute__((__no_instrument_function__)) ;
#line 129 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/atomic.h"
__inline static int atomic_inc_and_test(atomic_t *v ) 
{ 
  char c ;

  {
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 131
    __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                         ".balign 4\n"
                         ".long 671f - .\n"
                         ".popsection\n"
                         "671:"
                         "\n\tlock; "
                         "incl"
                         " "
                         "%0"
                         "; set"
                         "e"
                         " %1": "+m" (v->counter), "=qm" (c): : "memory");
    }
#line 131
    return ((int )c != 0);
#line 131
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  return (0);
}
}
#line 143
__inline static int atomic_add_negative(int i , atomic_t *v )  __attribute__((__no_instrument_function__)) ;
#line 143 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/atomic.h"
__inline static int atomic_add_negative(int i , atomic_t *v ) 
{ 
  char c ;

  {
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 145
    __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                         ".balign 4\n"
                         ".long 671f - .\n"
                         ".popsection\n"
                         "671:"
                         "\n\tlock; "
                         "addl"
                         " %2, "
                         "%0"
                         "; set"
                         "s"
                         " %1": "+m" (v->counter), "=qm" (c): "er" (i): "memory");
    }
#line 145
    return ((int )c != 0);
#line 145
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  return (0);
}
}
#line 155
__inline static int atomic_add_return(int i , atomic_t *v )  __attribute__((__no_instrument_function__)) ;
#line 155 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/atomic.h"
__inline static int atomic_add_return(int i , atomic_t *v ) 
{ 
  int __ret ;

  {
  {
#line 157
  __ret = i;
  }
  {
#line 157
  if (sizeof(v->counter) == 1UL) {
#line 157
    goto case_1;
  }
#line 157
  if (sizeof(v->counter) == 2UL) {
#line 157
    goto case_2;
  }
#line 157
  if (sizeof(v->counter) == 4UL) {
#line 157
    goto case_4;
  }
#line 157
  if (sizeof(v->counter) == 8UL) {
#line 157
    goto case_8;
  }
#line 157
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "xadd"
                       "b %b0, %1\n": "+q" (__ret), "+m" (v->counter): : "memory",
                       "cc");
  }
#line 157
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "xadd"
                       "w %w0, %1\n": "+r" (__ret), "+m" (v->counter): : "memory",
                       "cc");
  }
#line 157
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "xadd"
                       "l %0, %1\n": "+r" (__ret), "+m" (v->counter): : "memory",
                       "cc");
  }
#line 157
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "xadd"
                       "q %q0, %1\n": "+r" (__ret), "+m" (v->counter): : "memory",
                       "cc");
  }
#line 157
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 157
  __xadd_wrong_size();
  }
  switch_break: /* CIL Label */ ;
  }
#line 157
  return (i + __ret);
}
}
#line 167
__inline static int atomic_sub_return(int i , atomic_t *v )  __attribute__((__no_instrument_function__)) ;
#line 167 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/atomic.h"
__inline static int atomic_sub_return(int i , atomic_t *v ) 
{ 
  int tmp ;

  {
  {
#line 169
  tmp = atomic_add_return(- i, v);
  }
#line 169
  return (tmp);
}
}
#line 175
__inline static int atomic_cmpxchg(atomic_t *v , int old , int new )  __attribute__((__no_instrument_function__)) ;
#line 175 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/atomic.h"
__inline static int atomic_cmpxchg(atomic_t *v , int old , int new ) 
{ 
  int __ret ;
  int __old ;
  int __new ;
  u8 volatile   *__ptr ;
  u16 volatile   *__ptr___0 ;
  u32 volatile   *__ptr___1 ;
  u64 volatile   *__ptr___2 ;

  {
  {
#line 177
  __old = old;
#line 177
  __new = new;
  }
  {
#line 177
  if (sizeof(v->counter) == 1UL) {
#line 177
    goto case_1;
  }
#line 177
  if (sizeof(v->counter) == 2UL) {
#line 177
    goto case_2;
  }
#line 177
  if (sizeof(v->counter) == 4UL) {
#line 177
    goto case_4;
  }
#line 177
  if (sizeof(v->counter) == 8UL) {
#line 177
    goto case_8;
  }
#line 177
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 177
  __ptr = (u8 volatile   *)(& v->counter);
#line 177
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "cmpxchgb %2,%1": "=a" (__ret), "+m" (*__ptr): "q" (__new),
                       "0" (__old): "memory");
  }
#line 177
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 177
  __ptr___0 = (u16 volatile   *)(& v->counter);
#line 177
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "cmpxchgw %2,%1": "=a" (__ret), "+m" (*__ptr___0): "r" (__new),
                       "0" (__old): "memory");
  }
#line 177
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 177
  __ptr___1 = (u32 volatile   *)(& v->counter);
#line 177
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "cmpxchgl %2,%1": "=a" (__ret), "+m" (*__ptr___1): "r" (__new),
                       "0" (__old): "memory");
  }
#line 177
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 177
  __ptr___2 = (u64 volatile   *)(& v->counter);
#line 177
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "cmpxchgq %2,%1": "=a" (__ret), "+m" (*__ptr___2): "r" (__new),
                       "0" (__old): "memory");
  }
#line 177
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 177
  __cmpxchg_wrong_size();
  }
  switch_break: /* CIL Label */ ;
  }
#line 177
  return (__ret);
}
}
#line 180
__inline static int atomic_xchg(atomic_t *v , int new )  __attribute__((__no_instrument_function__)) ;
#line 180 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/atomic.h"
__inline static int atomic_xchg(atomic_t *v , int new ) 
{ 
  int __ret ;

  {
  {
#line 182
  __ret = new;
  }
  {
#line 182
  if (sizeof(v->counter) == 1UL) {
#line 182
    goto case_1;
  }
#line 182
  if (sizeof(v->counter) == 2UL) {
#line 182
    goto case_2;
  }
#line 182
  if (sizeof(v->counter) == 4UL) {
#line 182
    goto case_4;
  }
#line 182
  if (sizeof(v->counter) == 8UL) {
#line 182
    goto case_8;
  }
#line 182
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 182
  __asm__  volatile   (""
                       "xchg"
                       "b %b0, %1\n": "+q" (__ret), "+m" (v->counter): : "memory",
                       "cc");
  }
#line 182
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 182
  __asm__  volatile   (""
                       "xchg"
                       "w %w0, %1\n": "+r" (__ret), "+m" (v->counter): : "memory",
                       "cc");
  }
#line 182
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 182
  __asm__  volatile   (""
                       "xchg"
                       "l %0, %1\n": "+r" (__ret), "+m" (v->counter): : "memory",
                       "cc");
  }
#line 182
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 182
  __asm__  volatile   (""
                       "xchg"
                       "q %q0, %1\n": "+r" (__ret), "+m" (v->counter): : "memory",
                       "cc");
  }
#line 182
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 182
  __xchg_wrong_size();
  }
  switch_break: /* CIL Label */ ;
  }
#line 182
  return (__ret);
}
}
#line 194
__inline static int __atomic_add_unless(atomic_t *v , int a , int u )  __attribute__((__no_instrument_function__)) ;
#line 194 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/atomic.h"
__inline static int __atomic_add_unless(atomic_t *v , int a , int u ) 
{ 
  int c ;
  int old ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 197
  c = atomic_read((atomic_t const   *)v);
  }
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 199
    tmp = __builtin_expect((long )(! (! (c == u))), 0L);
    }
#line 199
    if (tmp) {
#line 200
      goto while_break;
    }
    {
#line 201
    old = atomic_cmpxchg(v, c, c + a);
#line 202
    tmp___0 = __builtin_expect((long )(! (! (old == c))), 1L);
    }
#line 202
    if (tmp___0) {
#line 203
      goto while_break;
    }
    {
#line 204
    c = old;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 206
  return (c);
}
}
#line 216
__inline static short atomic_inc_short(short *v )  __attribute__((__no_instrument_function__)) ;
#line 216 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/atomic.h"
__inline static short atomic_inc_short(short *v ) 
{ 


  {
  {
#line 218
  __asm__  (".pushsection .smp_locks,\"a\"\n"
            ".balign 4\n"
            ".long 671f - .\n"
            ".popsection\n"
            "671:"
            "\n\tlock; "
            "addw $1, %0": "+m" (*v));
  }
#line 219
  return (*v);
}
}
#line 231
__inline static void atomic_or_long(unsigned long *v1 , unsigned long v2 )  __attribute__((__no_instrument_function__)) ;
#line 231 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/atomic.h"
__inline static void atomic_or_long(unsigned long *v1 , unsigned long v2 ) 
{ 


  {
  {
#line 233
  __asm__  (".pushsection .smp_locks,\"a\"\n"
            ".balign 4\n"
            ".long 671f - .\n"
            ".popsection\n"
            "671:"
            "\n\tlock; "
            "orq %1, %0": "+m" (*v1): "r" (v2));
  }
#line 234
  return;
}
}
#line 19 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/atomic64_64.h"
__inline static long atomic64_read(atomic64_t const   *v )  __attribute__((__no_instrument_function__)) ;
#line 19 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/atomic64_64.h"
__inline static long atomic64_read(atomic64_t const   *v ) 
{ 


  {
#line 21
  return ((long )*((long volatile   *)(& v->counter)));
}
}
#line 31
__inline static void atomic64_set(atomic64_t *v , long i )  __attribute__((__no_instrument_function__)) ;
#line 31 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/atomic64_64.h"
__inline static void atomic64_set(atomic64_t *v , long i ) 
{ 


  {
  {
#line 33
  v->counter = i;
  }
#line 34
  return;
}
}
#line 43
__inline static void atomic64_add(long i , atomic64_t *v )  __attribute__((__no_instrument_function__)) ;
#line 43 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/atomic64_64.h"
__inline static void atomic64_add(long i , atomic64_t *v ) 
{ 


  {
  {
#line 45
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "addq %1,%0": "=m" (v->counter): "er" (i), "m" (v->counter));
  }
#line 48
  return;
}
}
#line 57
__inline static void atomic64_sub(long i , atomic64_t *v )  __attribute__((__no_instrument_function__)) ;
#line 57 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/atomic64_64.h"
__inline static void atomic64_sub(long i , atomic64_t *v ) 
{ 


  {
  {
#line 59
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "subq %1,%0": "=m" (v->counter): "er" (i), "m" (v->counter));
  }
#line 62
  return;
}
}
#line 73
__inline static int atomic64_sub_and_test(long i , atomic64_t *v )  __attribute__((__no_instrument_function__)) ;
#line 73 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/atomic64_64.h"
__inline static int atomic64_sub_and_test(long i , atomic64_t *v ) 
{ 
  char c ;

  {
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 75
    __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                         ".balign 4\n"
                         ".long 671f - .\n"
                         ".popsection\n"
                         "671:"
                         "\n\tlock; "
                         "subq"
                         " %2, "
                         "%0"
                         "; set"
                         "e"
                         " %1": "+m" (v->counter), "=qm" (c): "er" (i): "memory");
    }
#line 75
    return ((int )c != 0);
#line 75
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  return (0);
}
}
#line 84
__inline static void atomic64_inc(atomic64_t *v )  __attribute__((__no_instrument_function__)) ;
#line 84 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/atomic64_64.h"
__inline static void atomic64_inc(atomic64_t *v ) 
{ 


  {
  {
#line 86
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "incq %0": "=m" (v->counter): "m" (v->counter));
  }
#line 89
  return;
}
}
#line 97
__inline static void atomic64_dec(atomic64_t *v )  __attribute__((__no_instrument_function__)) ;
#line 97 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/atomic64_64.h"
__inline static void atomic64_dec(atomic64_t *v ) 
{ 


  {
  {
#line 99
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "decq %0": "=m" (v->counter): "m" (v->counter));
  }
#line 102
  return;
}
}
#line 112
__inline static int atomic64_dec_and_test(atomic64_t *v )  __attribute__((__no_instrument_function__)) ;
#line 112 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/atomic64_64.h"
__inline static int atomic64_dec_and_test(atomic64_t *v ) 
{ 
  char c ;

  {
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 114
    __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                         ".balign 4\n"
                         ".long 671f - .\n"
                         ".popsection\n"
                         "671:"
                         "\n\tlock; "
                         "decq"
                         " "
                         "%0"
                         "; set"
                         "e"
                         " %1": "+m" (v->counter), "=qm" (c): : "memory");
    }
#line 114
    return ((int )c != 0);
#line 114
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  return (0);
}
}
#line 125
__inline static int atomic64_inc_and_test(atomic64_t *v )  __attribute__((__no_instrument_function__)) ;
#line 125 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/atomic64_64.h"
__inline static int atomic64_inc_and_test(atomic64_t *v ) 
{ 
  char c ;

  {
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 127
    __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                         ".balign 4\n"
                         ".long 671f - .\n"
                         ".popsection\n"
                         "671:"
                         "\n\tlock; "
                         "incq"
                         " "
                         "%0"
                         "; set"
                         "e"
                         " %1": "+m" (v->counter), "=qm" (c): : "memory");
    }
#line 127
    return ((int )c != 0);
#line 127
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  return (0);
}
}
#line 139
__inline static int atomic64_add_negative(long i , atomic64_t *v )  __attribute__((__no_instrument_function__)) ;
#line 139 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/atomic64_64.h"
__inline static int atomic64_add_negative(long i , atomic64_t *v ) 
{ 
  char c ;

  {
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 141
    __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                         ".balign 4\n"
                         ".long 671f - .\n"
                         ".popsection\n"
                         "671:"
                         "\n\tlock; "
                         "addq"
                         " %2, "
                         "%0"
                         "; set"
                         "s"
                         " %1": "+m" (v->counter), "=qm" (c): "er" (i): "memory");
    }
#line 141
    return ((int )c != 0);
#line 141
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  return (0);
}
}
#line 151
__inline static long atomic64_add_return(long i , atomic64_t *v )  __attribute__((__no_instrument_function__)) ;
#line 151 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/atomic64_64.h"
__inline static long atomic64_add_return(long i , atomic64_t *v ) 
{ 
  long __ret ;

  {
  {
#line 153
  __ret = i;
  }
  {
#line 153
  if (sizeof(v->counter) == 1UL) {
#line 153
    goto case_1;
  }
#line 153
  if (sizeof(v->counter) == 2UL) {
#line 153
    goto case_2;
  }
#line 153
  if (sizeof(v->counter) == 4UL) {
#line 153
    goto case_4;
  }
#line 153
  if (sizeof(v->counter) == 8UL) {
#line 153
    goto case_8;
  }
#line 153
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 153
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "xadd"
                       "b %b0, %1\n": "+q" (__ret), "+m" (v->counter): : "memory",
                       "cc");
  }
#line 153
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 153
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "xadd"
                       "w %w0, %1\n": "+r" (__ret), "+m" (v->counter): : "memory",
                       "cc");
  }
#line 153
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 153
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "xadd"
                       "l %0, %1\n": "+r" (__ret), "+m" (v->counter): : "memory",
                       "cc");
  }
#line 153
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 153
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "xadd"
                       "q %q0, %1\n": "+r" (__ret), "+m" (v->counter): : "memory",
                       "cc");
  }
#line 153
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 153
  __xadd_wrong_size();
  }
  switch_break: /* CIL Label */ ;
  }
#line 153
  return (i + __ret);
}
}
#line 156
__inline static long atomic64_sub_return(long i , atomic64_t *v )  __attribute__((__no_instrument_function__)) ;
#line 156 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/atomic64_64.h"
__inline static long atomic64_sub_return(long i , atomic64_t *v ) 
{ 
  long tmp ;

  {
  {
#line 158
  tmp = atomic64_add_return(- i, v);
  }
#line 158
  return (tmp);
}
}
#line 164
__inline static long atomic64_cmpxchg(atomic64_t *v , long old , long new )  __attribute__((__no_instrument_function__)) ;
#line 164 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/atomic64_64.h"
__inline static long atomic64_cmpxchg(atomic64_t *v , long old , long new ) 
{ 
  long __ret ;
  long __old ;
  long __new ;
  u8 volatile   *__ptr ;
  u16 volatile   *__ptr___0 ;
  u32 volatile   *__ptr___1 ;
  u64 volatile   *__ptr___2 ;

  {
  {
#line 166
  __old = old;
#line 166
  __new = new;
  }
  {
#line 166
  if (sizeof(v->counter) == 1UL) {
#line 166
    goto case_1;
  }
#line 166
  if (sizeof(v->counter) == 2UL) {
#line 166
    goto case_2;
  }
#line 166
  if (sizeof(v->counter) == 4UL) {
#line 166
    goto case_4;
  }
#line 166
  if (sizeof(v->counter) == 8UL) {
#line 166
    goto case_8;
  }
#line 166
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 166
  __ptr = (u8 volatile   *)(& v->counter);
#line 166
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "cmpxchgb %2,%1": "=a" (__ret), "+m" (*__ptr): "q" (__new),
                       "0" (__old): "memory");
  }
#line 166
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 166
  __ptr___0 = (u16 volatile   *)(& v->counter);
#line 166
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "cmpxchgw %2,%1": "=a" (__ret), "+m" (*__ptr___0): "r" (__new),
                       "0" (__old): "memory");
  }
#line 166
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 166
  __ptr___1 = (u32 volatile   *)(& v->counter);
#line 166
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "cmpxchgl %2,%1": "=a" (__ret), "+m" (*__ptr___1): "r" (__new),
                       "0" (__old): "memory");
  }
#line 166
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 166
  __ptr___2 = (u64 volatile   *)(& v->counter);
#line 166
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "cmpxchgq %2,%1": "=a" (__ret), "+m" (*__ptr___2): "r" (__new),
                       "0" (__old): "memory");
  }
#line 166
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 166
  __cmpxchg_wrong_size();
  }
  switch_break: /* CIL Label */ ;
  }
#line 166
  return (__ret);
}
}
#line 169
__inline static long atomic64_xchg(atomic64_t *v , long new )  __attribute__((__no_instrument_function__)) ;
#line 169 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/atomic64_64.h"
__inline static long atomic64_xchg(atomic64_t *v , long new ) 
{ 
  long __ret ;

  {
  {
#line 171
  __ret = new;
  }
  {
#line 171
  if (sizeof(v->counter) == 1UL) {
#line 171
    goto case_1;
  }
#line 171
  if (sizeof(v->counter) == 2UL) {
#line 171
    goto case_2;
  }
#line 171
  if (sizeof(v->counter) == 4UL) {
#line 171
    goto case_4;
  }
#line 171
  if (sizeof(v->counter) == 8UL) {
#line 171
    goto case_8;
  }
#line 171
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 171
  __asm__  volatile   (""
                       "xchg"
                       "b %b0, %1\n": "+q" (__ret), "+m" (v->counter): : "memory",
                       "cc");
  }
#line 171
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 171
  __asm__  volatile   (""
                       "xchg"
                       "w %w0, %1\n": "+r" (__ret), "+m" (v->counter): : "memory",
                       "cc");
  }
#line 171
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 171
  __asm__  volatile   (""
                       "xchg"
                       "l %0, %1\n": "+r" (__ret), "+m" (v->counter): : "memory",
                       "cc");
  }
#line 171
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 171
  __asm__  volatile   (""
                       "xchg"
                       "q %q0, %1\n": "+r" (__ret), "+m" (v->counter): : "memory",
                       "cc");
  }
#line 171
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 171
  __xchg_wrong_size();
  }
  switch_break: /* CIL Label */ ;
  }
#line 171
  return (__ret);
}
}
#line 183
__inline static int atomic64_add_unless(atomic64_t *v , long a , long u )  __attribute__((__no_instrument_function__)) ;
#line 183 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/atomic64_64.h"
__inline static int atomic64_add_unless(atomic64_t *v , long a , long u ) 
{ 
  long c ;
  long old ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 186
  c = atomic64_read((atomic64_t const   *)v);
  }
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 188
    tmp = __builtin_expect((long )(! (! (c == u))), 0L);
    }
#line 188
    if (tmp) {
#line 189
      goto while_break;
    }
    {
#line 190
    old = atomic64_cmpxchg(v, c, c + a);
#line 191
    tmp___0 = __builtin_expect((long )(! (! (old == c))), 1L);
    }
#line 191
    if (tmp___0) {
#line 192
      goto while_break;
    }
    {
#line 193
    c = old;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  return (c != u);
}
}
#line 207
__inline static long atomic64_dec_if_positive(atomic64_t *v )  __attribute__((__no_instrument_function__)) ;
#line 207 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/atomic64_64.h"
__inline static long atomic64_dec_if_positive(atomic64_t *v ) 
{ 
  long c ;
  long old ;
  long dec ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 210
  c = atomic64_read((atomic64_t const   *)v);
  }
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 212
    dec = c - 1L;
#line 213
    tmp = __builtin_expect((long )(! (! (dec < 0L))), 0L);
    }
#line 213
    if (tmp) {
#line 214
      goto while_break;
    }
    {
#line 215
    old = atomic64_cmpxchg(v, c, dec);
#line 216
    tmp___0 = __builtin_expect((long )(! (! (old == c))), 1L);
    }
#line 216
    if (tmp___0) {
#line 217
      goto while_break;
    }
    {
#line 218
    c = old;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  return (dec);
}
}
#line 11 "../../../analyzer/../bench/linux-headers/include/linux/atomic.h"
__inline static void smp_mb__before_atomic_inc(void)  __attribute__((__no_instrument_function__)) ;
#line 11 "../../../analyzer/../bench/linux-headers/include/linux/atomic.h"
__inline static void smp_mb__before_atomic_inc(void) 
{ 


  {
  {
#line 14
  __smp_mb__before_atomic();
  }
#line 15
  return;
}
}
#line 19
__inline static void smp_mb__after_atomic_inc(void)  __attribute__((__no_instrument_function__)) ;
#line 19 "../../../analyzer/../bench/linux-headers/include/linux/atomic.h"
__inline static void smp_mb__after_atomic_inc(void) 
{ 


  {
  {
#line 22
  __smp_mb__after_atomic();
  }
#line 23
  return;
}
}
#line 27
__inline static void smp_mb__before_atomic_dec(void)  __attribute__((__no_instrument_function__)) ;
#line 27 "../../../analyzer/../bench/linux-headers/include/linux/atomic.h"
__inline static void smp_mb__before_atomic_dec(void) 
{ 


  {
  {
#line 30
  __smp_mb__before_atomic();
  }
#line 31
  return;
}
}
#line 35
__inline static void smp_mb__after_atomic_dec(void)  __attribute__((__no_instrument_function__)) ;
#line 35 "../../../analyzer/../bench/linux-headers/include/linux/atomic.h"
__inline static void smp_mb__after_atomic_dec(void) 
{ 


  {
  {
#line 38
  __smp_mb__after_atomic();
  }
#line 39
  return;
}
}
#line 51
__inline static int atomic_add_unless(atomic_t *v , int a , int u )  __attribute__((__no_instrument_function__)) ;
#line 51 "../../../analyzer/../bench/linux-headers/include/linux/atomic.h"
__inline static int atomic_add_unless(atomic_t *v , int a , int u ) 
{ 
  int tmp ;

  {
  {
#line 53
  tmp = __atomic_add_unless(v, a, u);
  }
#line 53
  return (tmp != u);
}
}
#line 80
__inline static int atomic_inc_not_zero_hint(atomic_t *v , int hint )  __attribute__((__no_instrument_function__)) ;
#line 80 "../../../analyzer/../bench/linux-headers/include/linux/atomic.h"
__inline static int atomic_inc_not_zero_hint(atomic_t *v , int hint ) 
{ 
  int val ;
  int c ;
  int tmp ;

  {
  {
#line 82
  c = hint;
  }
#line 85
  if (! hint) {
    {
#line 86
    tmp = atomic_add_unless(v, 1, 0);
    }
#line 86
    return (tmp);
  }
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 89
    val = atomic_cmpxchg(v, c, c + 1);
    }
#line 90
    if (val == c) {
#line 91
      return (1);
    }
    {
#line 92
    c = val;
    }
#line 88
    if (! c) {
#line 88
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  return (0);
}
}
#line 100
__inline static int atomic_inc_unless_negative(atomic_t *p )  __attribute__((__no_instrument_function__)) ;
#line 100 "../../../analyzer/../bench/linux-headers/include/linux/atomic.h"
__inline static int atomic_inc_unless_negative(atomic_t *p ) 
{ 
  int v ;
  int v1 ;
  long tmp ;

  {
  {
#line 103
  v = 0;
  }
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! (v >= 0)) {
#line 103
      goto while_break;
    }
    {
#line 104
    v1 = atomic_cmpxchg(p, v, v + 1);
#line 105
    tmp = __builtin_expect((long )(! (! (v1 == v))), 1L);
    }
#line 105
    if (tmp) {
#line 106
      return (1);
    }
    {
#line 103
    v = v1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  return (0);
}
}
#line 113
__inline static int atomic_dec_unless_positive(atomic_t *p )  __attribute__((__no_instrument_function__)) ;
#line 113 "../../../analyzer/../bench/linux-headers/include/linux/atomic.h"
__inline static int atomic_dec_unless_positive(atomic_t *p ) 
{ 
  int v ;
  int v1 ;
  long tmp ;

  {
  {
#line 116
  v = 0;
  }
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! (v <= 0)) {
#line 116
      goto while_break;
    }
    {
#line 117
    v1 = atomic_cmpxchg(p, v, v - 1);
#line 118
    tmp = __builtin_expect((long )(! (! (v1 == v))), 1L);
    }
#line 118
    if (tmp) {
#line 119
      return (1);
    }
    {
#line 116
    v = v1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  return (0);
}
}
#line 133
__inline static int atomic_dec_if_positive(atomic_t *v )  __attribute__((__no_instrument_function__)) ;
#line 133 "../../../analyzer/../bench/linux-headers/include/linux/atomic.h"
__inline static int atomic_dec_if_positive(atomic_t *v ) 
{ 
  int c ;
  int old ;
  int dec ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 136
  c = atomic_read((atomic_t const   *)v);
  }
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 138
    dec = c - 1;
#line 139
    tmp = __builtin_expect((long )(! (! (dec < 0))), 0L);
    }
#line 139
    if (tmp) {
#line 140
      goto while_break;
    }
    {
#line 141
    old = atomic_cmpxchg(v, c, dec);
#line 142
    tmp___0 = __builtin_expect((long )(! (! (old == c))), 1L);
    }
#line 142
    if (tmp___0) {
#line 143
      goto while_break;
    }
    {
#line 144
    c = old;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  return (dec);
}
}
#line 151
__inline static void atomic_or(int i , atomic_t *v )  __attribute__((__no_instrument_function__)) ;
#line 151 "../../../analyzer/../bench/linux-headers/include/linux/atomic.h"
__inline static void atomic_or(int i , atomic_t *v ) 
{ 
  int old ;
  int new ;
  int tmp ;

  {
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 157
    old = atomic_read((atomic_t const   *)v);
#line 158
    new = old | i;
#line 156
    tmp = atomic_cmpxchg(v, old, new);
    }
#line 156
    if (! (tmp != old)) {
#line 156
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  return;
}
}
#line 27 "../../../analyzer/../bench/linux-headers/include/asm-generic/atomic-long.h"
__inline static long atomic_long_read(atomic_long_t *l )  __attribute__((__no_instrument_function__)) ;
#line 27 "../../../analyzer/../bench/linux-headers/include/asm-generic/atomic-long.h"
__inline static long atomic_long_read(atomic_long_t *l ) 
{ 
  atomic64_t *v ;
  long tmp ;

  {
  {
#line 29
  v = l;
#line 31
  tmp = atomic64_read((atomic64_t const   *)v);
  }
#line 31
  return (tmp);
}
}
#line 34
__inline static void atomic_long_set(atomic_long_t *l , long i )  __attribute__((__no_instrument_function__)) ;
#line 34 "../../../analyzer/../bench/linux-headers/include/asm-generic/atomic-long.h"
__inline static void atomic_long_set(atomic_long_t *l , long i ) 
{ 
  atomic64_t *v ;

  {
  {
#line 36
  v = l;
#line 38
  atomic64_set(v, i);
  }
#line 39
  return;
}
}
#line 41
__inline static void atomic_long_inc(atomic_long_t *l )  __attribute__((__no_instrument_function__)) ;
#line 41 "../../../analyzer/../bench/linux-headers/include/asm-generic/atomic-long.h"
__inline static void atomic_long_inc(atomic_long_t *l ) 
{ 
  atomic64_t *v ;

  {
  {
#line 43
  v = l;
#line 45
  atomic64_inc(v);
  }
#line 46
  return;
}
}
#line 48
__inline static void atomic_long_dec(atomic_long_t *l )  __attribute__((__no_instrument_function__)) ;
#line 48 "../../../analyzer/../bench/linux-headers/include/asm-generic/atomic-long.h"
__inline static void atomic_long_dec(atomic_long_t *l ) 
{ 
  atomic64_t *v ;

  {
  {
#line 50
  v = l;
#line 52
  atomic64_dec(v);
  }
#line 53
  return;
}
}
#line 55
__inline static void atomic_long_add(long i , atomic_long_t *l )  __attribute__((__no_instrument_function__)) ;
#line 55 "../../../analyzer/../bench/linux-headers/include/asm-generic/atomic-long.h"
__inline static void atomic_long_add(long i , atomic_long_t *l ) 
{ 
  atomic64_t *v ;

  {
  {
#line 57
  v = l;
#line 59
  atomic64_add(i, v);
  }
#line 60
  return;
}
}
#line 62
__inline static void atomic_long_sub(long i , atomic_long_t *l )  __attribute__((__no_instrument_function__)) ;
#line 62 "../../../analyzer/../bench/linux-headers/include/asm-generic/atomic-long.h"
__inline static void atomic_long_sub(long i , atomic_long_t *l ) 
{ 
  atomic64_t *v ;

  {
  {
#line 64
  v = l;
#line 66
  atomic64_sub(i, v);
  }
#line 67
  return;
}
}
#line 69
__inline static int atomic_long_sub_and_test(long i , atomic_long_t *l )  __attribute__((__no_instrument_function__)) ;
#line 69 "../../../analyzer/../bench/linux-headers/include/asm-generic/atomic-long.h"
__inline static int atomic_long_sub_and_test(long i , atomic_long_t *l ) 
{ 
  atomic64_t *v ;
  int tmp ;

  {
  {
#line 71
  v = l;
#line 73
  tmp = atomic64_sub_and_test(i, v);
  }
#line 73
  return (tmp);
}
}
#line 76
__inline static int atomic_long_dec_and_test(atomic_long_t *l )  __attribute__((__no_instrument_function__)) ;
#line 76 "../../../analyzer/../bench/linux-headers/include/asm-generic/atomic-long.h"
__inline static int atomic_long_dec_and_test(atomic_long_t *l ) 
{ 
  atomic64_t *v ;
  int tmp ;

  {
  {
#line 78
  v = l;
#line 80
  tmp = atomic64_dec_and_test(v);
  }
#line 80
  return (tmp);
}
}
#line 83
__inline static int atomic_long_inc_and_test(atomic_long_t *l )  __attribute__((__no_instrument_function__)) ;
#line 83 "../../../analyzer/../bench/linux-headers/include/asm-generic/atomic-long.h"
__inline static int atomic_long_inc_and_test(atomic_long_t *l ) 
{ 
  atomic64_t *v ;
  int tmp ;

  {
  {
#line 85
  v = l;
#line 87
  tmp = atomic64_inc_and_test(v);
  }
#line 87
  return (tmp);
}
}
#line 90
__inline static int atomic_long_add_negative(long i , atomic_long_t *l )  __attribute__((__no_instrument_function__)) ;
#line 90 "../../../analyzer/../bench/linux-headers/include/asm-generic/atomic-long.h"
__inline static int atomic_long_add_negative(long i , atomic_long_t *l ) 
{ 
  atomic64_t *v ;
  int tmp ;

  {
  {
#line 92
  v = l;
#line 94
  tmp = atomic64_add_negative(i, v);
  }
#line 94
  return (tmp);
}
}
#line 97
__inline static long atomic_long_add_return(long i , atomic_long_t *l )  __attribute__((__no_instrument_function__)) ;
#line 97 "../../../analyzer/../bench/linux-headers/include/asm-generic/atomic-long.h"
__inline static long atomic_long_add_return(long i , atomic_long_t *l ) 
{ 
  atomic64_t *v ;
  long tmp ;

  {
  {
#line 99
  v = l;
#line 101
  tmp = atomic64_add_return(i, v);
  }
#line 101
  return (tmp);
}
}
#line 104
__inline static long atomic_long_sub_return(long i , atomic_long_t *l )  __attribute__((__no_instrument_function__)) ;
#line 104 "../../../analyzer/../bench/linux-headers/include/asm-generic/atomic-long.h"
__inline static long atomic_long_sub_return(long i , atomic_long_t *l ) 
{ 
  atomic64_t *v ;
  long tmp ;

  {
  {
#line 106
  v = l;
#line 108
  tmp = atomic64_sub_return(i, v);
  }
#line 108
  return (tmp);
}
}
#line 111
__inline static long atomic_long_inc_return(atomic_long_t *l )  __attribute__((__no_instrument_function__)) ;
#line 111 "../../../analyzer/../bench/linux-headers/include/asm-generic/atomic-long.h"
__inline static long atomic_long_inc_return(atomic_long_t *l ) 
{ 
  atomic64_t *v ;
  long tmp ;

  {
  {
#line 113
  v = l;
#line 115
  tmp = atomic64_add_return(1L, v);
  }
#line 115
  return (tmp);
}
}
#line 118
__inline static long atomic_long_dec_return(atomic_long_t *l )  __attribute__((__no_instrument_function__)) ;
#line 118 "../../../analyzer/../bench/linux-headers/include/asm-generic/atomic-long.h"
__inline static long atomic_long_dec_return(atomic_long_t *l ) 
{ 
  atomic64_t *v ;
  long tmp ;

  {
  {
#line 120
  v = l;
#line 122
  tmp = atomic64_sub_return(1L, v);
  }
#line 122
  return (tmp);
}
}
#line 125
__inline static long atomic_long_add_unless(atomic_long_t *l , long a , long u )  __attribute__((__no_instrument_function__)) ;
#line 125 "../../../analyzer/../bench/linux-headers/include/asm-generic/atomic-long.h"
__inline static long atomic_long_add_unless(atomic_long_t *l , long a , long u ) 
{ 
  atomic64_t *v ;
  int tmp ;

  {
  {
#line 127
  v = l;
#line 129
  tmp = atomic64_add_unless(v, a, u);
  }
#line 129
  return ((long )tmp);
}
}
#line 163 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/thread_info.h"
extern unsigned long kernel_stack  __attribute__((__section__(".data..percpu"))) ;
#line 165
__inline static struct thread_info *current_thread_info(void)  __attribute__((__no_instrument_function__)) ;
#line 165 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/thread_info.h"
__inline static struct thread_info *current_thread_info(void) 
{ 
  struct thread_info *ti ;
  unsigned long pfo_ret__ ;

  {
  {
#line 168
  if (sizeof(kernel_stack) == 1UL) {
#line 168
    goto case_1;
  }
#line 168
  if (sizeof(kernel_stack) == 2UL) {
#line 168
    goto case_2;
  }
#line 168
  if (sizeof(kernel_stack) == 4UL) {
#line 168
    goto case_4;
  }
#line 168
  if (sizeof(kernel_stack) == 8UL) {
#line 168
    goto case_8;
  }
#line 168
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 168
  __asm__  ("mov"
            "b "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=q" (pfo_ret__): "p" (& kernel_stack));
  }
#line 168
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 168
  __asm__  ("mov"
            "w "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret__): "p" (& kernel_stack));
  }
#line 168
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 168
  __asm__  ("mov"
            "l "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret__): "p" (& kernel_stack));
  }
#line 168
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 168
  __asm__  ("mov"
            "q "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret__): "p" (& kernel_stack));
  }
#line 168
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 168
  __bad_percpu_size();
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 168
  ti = (struct thread_info *)((void *)((pfo_ret__ + 40UL) - ((1UL << 12) << 2)));
  }
#line 170
  return (ti);
}
}
#line 200
__inline static void set_restore_sigmask(void)  __attribute__((__no_instrument_function__)) ;
#line 200 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/thread_info.h"
__inline static void set_restore_sigmask(void) 
{ 
  struct thread_info *ti ;
  struct thread_info *tmp ;
  int __ret_warn_on ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  {
#line 202
  tmp = current_thread_info();
#line 202
  ti = tmp;
#line 203
  ti->status |= 8U;
#line 204
  tmp___0 = constant_test_bit(2L, (unsigned long const volatile   *)((unsigned long *)(& ti->flags)));
  }
#line 204
  if (tmp___0) {
    {
#line 204
    tmp___2 = 0;
    }
  } else {
    {
#line 204
    tmp___2 = 1;
    }
  }
  {
#line 204
  __ret_warn_on = tmp___2;
#line 204
  tmp___3 = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
  }
#line 204
  if (tmp___3) {
    {
#line 204
    warn_slowpath_null("../../../analyzer/../bench/linux-headers/arch/x86/include/asm/thread_info.h",
                       (int const   )204);
    }
  }
  {
#line 204
  __builtin_expect((long )(! (! __ret_warn_on)), 0L);
  }
#line 205
  return;
}
}
#line 206
__inline static void clear_restore_sigmask(void)  __attribute__((__no_instrument_function__)) ;
#line 206 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/thread_info.h"
__inline static void clear_restore_sigmask(void) 
{ 
  struct thread_info *tmp ;

  {
  {
#line 208
  tmp = current_thread_info();
#line 208
  tmp->status &= 4294967287U;
  }
#line 209
  return;
}
}
#line 210
__inline static bool test_restore_sigmask(void)  __attribute__((__no_instrument_function__)) ;
#line 210 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/thread_info.h"
__inline static bool test_restore_sigmask(void) 
{ 
  struct thread_info *tmp ;

  {
  {
#line 212
  tmp = current_thread_info();
  }
#line 212
  return ((bool )(tmp->status & 8U));
}
}
#line 214
__inline static bool test_and_clear_restore_sigmask(void)  __attribute__((__no_instrument_function__)) ;
#line 214 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/thread_info.h"
__inline static bool test_and_clear_restore_sigmask(void) 
{ 
  struct thread_info *ti ;
  struct thread_info *tmp ;

  {
  {
#line 216
  tmp = current_thread_info();
#line 216
  ti = tmp;
  }
#line 217
  if (! (ti->status & 8U)) {
#line 218
    return ((bool )0);
  }
  {
#line 219
  ti->status &= 4294967287U;
  }
#line 220
  return ((bool )1);
}
}
#line 223
__inline static bool is_ia32_task(void)  __attribute__((__no_instrument_function__)) ;
#line 223 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/thread_info.h"
__inline static bool is_ia32_task(void) 
{ 
  struct thread_info *tmp ;

  {
  {
#line 229
  tmp = current_thread_info();
  }
#line 229
  if (tmp->status & 2U) {
#line 230
    return ((bool )1);
  }
#line 232
  return ((bool )0);
}
}
#line 237
extern void arch_task_cache_init(void) ;
#line 238
extern int arch_dup_task_struct(struct task_struct *dst , struct task_struct *src ) ;
#line 239
extern void arch_release_task_struct(struct task_struct *tsk ) ;
#line 69 "../../../analyzer/../bench/linux-headers/include/linux/thread_info.h"
__inline static void set_ti_thread_flag(struct thread_info *ti , int flag )  __attribute__((__no_instrument_function__)) ;
#line 69 "../../../analyzer/../bench/linux-headers/include/linux/thread_info.h"
__inline static void set_ti_thread_flag(struct thread_info *ti , int flag ) 
{ 


  {
  {
#line 71
  set_bit((long )flag, (unsigned long volatile   *)((unsigned long *)(& ti->flags)));
  }
#line 72
  return;
}
}
#line 74
__inline static void clear_ti_thread_flag(struct thread_info *ti , int flag )  __attribute__((__no_instrument_function__)) ;
#line 74 "../../../analyzer/../bench/linux-headers/include/linux/thread_info.h"
__inline static void clear_ti_thread_flag(struct thread_info *ti , int flag ) 
{ 


  {
  {
#line 76
  clear_bit((long )flag, (unsigned long volatile   *)((unsigned long *)(& ti->flags)));
  }
#line 77
  return;
}
}
#line 79
__inline static int test_and_set_ti_thread_flag(struct thread_info *ti , int flag )  __attribute__((__no_instrument_function__)) ;
#line 79 "../../../analyzer/../bench/linux-headers/include/linux/thread_info.h"
__inline static int test_and_set_ti_thread_flag(struct thread_info *ti , int flag ) 
{ 
  int tmp ;

  {
  {
#line 81
  tmp = test_and_set_bit((long )flag, (unsigned long volatile   *)((unsigned long *)(& ti->flags)));
  }
#line 81
  return (tmp);
}
}
#line 84
__inline static int test_and_clear_ti_thread_flag(struct thread_info *ti , int flag )  __attribute__((__no_instrument_function__)) ;
#line 84 "../../../analyzer/../bench/linux-headers/include/linux/thread_info.h"
__inline static int test_and_clear_ti_thread_flag(struct thread_info *ti , int flag ) 
{ 
  int tmp ;

  {
  {
#line 86
  tmp = test_and_clear_bit((long )flag, (unsigned long volatile   *)((unsigned long *)(& ti->flags)));
  }
#line 86
  return (tmp);
}
}
#line 89
__inline static int test_ti_thread_flag(struct thread_info *ti , int flag )  __attribute__((__no_instrument_function__)) ;
#line 89 "../../../analyzer/../bench/linux-headers/include/linux/thread_info.h"
__inline static int test_ti_thread_flag(struct thread_info *ti , int flag ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 91
  tmp___0 = variable_test_bit((long )flag, (unsigned long const volatile   *)((unsigned long *)(& ti->flags)));
  }
#line 91
  return (tmp___0);
}
}
#line 8 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/preempt.h"
extern int __preempt_count  __attribute__((__section__(".data..percpu"))) ;
#line 20
__inline static int ( __attribute__((__always_inline__)) preempt_count)(void)  __attribute__((__no_instrument_function__)) ;
#line 20 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/preempt.h"
__inline static int ( __attribute__((__always_inline__)) preempt_count)(void) 
{ 
  int pfo_ret__ ;

  {
  {
#line 22
  if (sizeof(__preempt_count) == 1UL) {
#line 22
    goto case_1;
  }
#line 22
  if (sizeof(__preempt_count) == 2UL) {
#line 22
    goto case_2;
  }
#line 22
  if (sizeof(__preempt_count) == 4UL) {
#line 22
    goto case_4;
  }
#line 22
  if (sizeof(__preempt_count) == 8UL) {
#line 22
    goto case_8;
  }
#line 22
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 22
  __asm__  ("mov"
            "b "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=q" (pfo_ret__): "m" (__preempt_count));
  }
#line 22
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 22
  __asm__  ("mov"
            "w "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret__): "m" (__preempt_count));
  }
#line 22
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 22
  __asm__  ("mov"
            "l "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret__): "m" (__preempt_count));
  }
#line 22
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 22
  __asm__  ("mov"
            "q "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret__): "m" (__preempt_count));
  }
#line 22
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 22
  __bad_percpu_size();
  }
  switch_break: /* CIL Label */ ;
  }
#line 22
  return ((int )((unsigned int )pfo_ret__ & 2147483647U));
}
}
#line 25
__inline static void ( __attribute__((__always_inline__)) preempt_count_set)(int pc )  __attribute__((__no_instrument_function__)) ;
#line 25 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/preempt.h"
__inline static void ( __attribute__((__always_inline__)) preempt_count_set)(int pc ) 
{ 
  pto_T__ pto_tmp__ ;

  {
  {
#line 27
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 27
    if (sizeof(__preempt_count) == 1UL) {
#line 27
      goto case_1;
    }
#line 27
    if (sizeof(__preempt_count) == 2UL) {
#line 27
      goto case_2;
    }
#line 27
    if (sizeof(__preempt_count) == 4UL) {
#line 27
      goto case_4;
    }
#line 27
    if (sizeof(__preempt_count) == 8UL) {
#line 27
      goto case_8;
    }
#line 27
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 27
    __asm__  ("mov"
              "b %1,"
              "%%"
              "gs"
              ":"
              "%P"
              "0": "+m" (__preempt_count): "qi" (pc));
    }
#line 27
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 27
    __asm__  ("mov"
              "w %1,"
              "%%"
              "gs"
              ":"
              "%P"
              "0": "+m" (__preempt_count): "ri" (pc));
    }
#line 27
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 27
    __asm__  ("mov"
              "l %1,"
              "%%"
              "gs"
              ":"
              "%P"
              "0": "+m" (__preempt_count): "ri" (pc));
    }
#line 27
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 27
    __asm__  ("mov"
              "q %1,"
              "%%"
              "gs"
              ":"
              "%P"
              "0": "+m" (__preempt_count): "re" (pc));
    }
#line 27
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 27
    __bad_percpu_size();
    }
    switch_break: /* CIL Label */ ;
    }
#line 27
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 28
  return;
}
}
#line 54
__inline static void ( __attribute__((__always_inline__)) set_preempt_need_resched)(void)  __attribute__((__no_instrument_function__)) ;
#line 54 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/preempt.h"
__inline static void ( __attribute__((__always_inline__)) set_preempt_need_resched)(void) 
{ 
  pto_T_____0 pto_tmp__ ;

  {
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 56
    if (sizeof(__preempt_count) == 1UL) {
#line 56
      goto case_1;
    }
#line 56
    if (sizeof(__preempt_count) == 2UL) {
#line 56
      goto case_2;
    }
#line 56
    if (sizeof(__preempt_count) == 4UL) {
#line 56
      goto case_4;
    }
#line 56
    if (sizeof(__preempt_count) == 8UL) {
#line 56
      goto case_8;
    }
#line 56
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 56
    __asm__  ("and"
              "b %1,"
              "%%"
              "gs"
              ":"
              "%P"
              "0": "+m" (__preempt_count): "qi" ((pto_T_____0 )(~ 2147483648U)));
    }
#line 56
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 56
    __asm__  ("and"
              "w %1,"
              "%%"
              "gs"
              ":"
              "%P"
              "0": "+m" (__preempt_count): "ri" ((pto_T_____0 )(~ 2147483648U)));
    }
#line 56
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 56
    __asm__  ("and"
              "l %1,"
              "%%"
              "gs"
              ":"
              "%P"
              "0": "+m" (__preempt_count): "ri" ((pto_T_____0 )(~ 2147483648U)));
    }
#line 56
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 56
    __asm__  ("and"
              "q %1,"
              "%%"
              "gs"
              ":"
              "%P"
              "0": "+m" (__preempt_count): "re" ((pto_T_____0 )(~ 2147483648U)));
    }
#line 56
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 56
    __bad_percpu_size();
    }
    switch_break: /* CIL Label */ ;
    }
#line 56
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 57
  return;
}
}
#line 59
__inline static void ( __attribute__((__always_inline__)) clear_preempt_need_resched)(void)  __attribute__((__no_instrument_function__)) ;
#line 59 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/preempt.h"
__inline static void ( __attribute__((__always_inline__)) clear_preempt_need_resched)(void) 
{ 
  pto_T_____1 pto_tmp__ ;

  {
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 61
    if (sizeof(__preempt_count) == 1UL) {
#line 61
      goto case_1;
    }
#line 61
    if (sizeof(__preempt_count) == 2UL) {
#line 61
      goto case_2;
    }
#line 61
    if (sizeof(__preempt_count) == 4UL) {
#line 61
      goto case_4;
    }
#line 61
    if (sizeof(__preempt_count) == 8UL) {
#line 61
      goto case_8;
    }
#line 61
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 61
    __asm__  ("or"
              "b %1,"
              "%%"
              "gs"
              ":"
              "%P"
              "0": "+m" (__preempt_count): "qi" ((pto_T_____1 )2147483648U));
    }
#line 61
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 61
    __asm__  ("or"
              "w %1,"
              "%%"
              "gs"
              ":"
              "%P"
              "0": "+m" (__preempt_count): "ri" ((pto_T_____1 )2147483648U));
    }
#line 61
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 61
    __asm__  ("or"
              "l %1,"
              "%%"
              "gs"
              ":"
              "%P"
              "0": "+m" (__preempt_count): "ri" ((pto_T_____1 )2147483648U));
    }
#line 61
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 61
    __asm__  ("or"
              "q %1,"
              "%%"
              "gs"
              ":"
              "%P"
              "0": "+m" (__preempt_count): "re" ((pto_T_____1 )2147483648U));
    }
#line 61
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 61
    __bad_percpu_size();
    }
    switch_break: /* CIL Label */ ;
    }
#line 61
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 62
  return;
}
}
#line 64
__inline static bool ( __attribute__((__always_inline__)) test_preempt_need_resched)(void)  __attribute__((__no_instrument_function__)) ;
#line 64 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/preempt.h"
__inline static bool ( __attribute__((__always_inline__)) test_preempt_need_resched)(void) 
{ 
  int pfo_ret__ ;
  int tmp ;

  {
  {
#line 66
  if (sizeof(__preempt_count) == 1UL) {
#line 66
    goto case_1;
  }
#line 66
  if (sizeof(__preempt_count) == 2UL) {
#line 66
    goto case_2;
  }
#line 66
  if (sizeof(__preempt_count) == 4UL) {
#line 66
    goto case_4;
  }
#line 66
  if (sizeof(__preempt_count) == 8UL) {
#line 66
    goto case_8;
  }
#line 66
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 66
  __asm__  ("mov"
            "b "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=q" (pfo_ret__): "m" (__preempt_count));
  }
#line 66
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 66
  __asm__  ("mov"
            "w "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret__): "m" (__preempt_count));
  }
#line 66
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 66
  __asm__  ("mov"
            "l "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret__): "m" (__preempt_count));
  }
#line 66
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 66
  __asm__  ("mov"
            "q "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret__): "m" (__preempt_count));
  }
#line 66
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 66
  __bad_percpu_size();
  }
  switch_break: /* CIL Label */ ;
  }
#line 66
  if ((unsigned int )pfo_ret__ & 2147483648U) {
    {
#line 66
    tmp = 0;
    }
  } else {
    {
#line 66
    tmp = 1;
    }
  }
#line 66
  return ((bool )tmp);
}
}
#line 73
__inline static void ( __attribute__((__always_inline__)) __preempt_count_add)(int val )  __attribute__((__no_instrument_function__)) ;
#line 73 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/preempt.h"
__inline static void ( __attribute__((__always_inline__)) __preempt_count_add)(int val ) 
{ 
  int pao_ID__ ;
  pao_T__ pao_tmp__ ;

  {
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 75
    pao_ID__ = 0;
    }
    {
#line 75
    if (sizeof(__preempt_count) == 1UL) {
#line 75
      goto case_1;
    }
#line 75
    if (sizeof(__preempt_count) == 2UL) {
#line 75
      goto case_2;
    }
#line 75
    if (sizeof(__preempt_count) == 4UL) {
#line 75
      goto case_4;
    }
#line 75
    if (sizeof(__preempt_count) == 8UL) {
#line 75
      goto case_8;
    }
#line 75
    goto switch_default;
    case_1: /* CIL Label */ 
#line 75
    if (pao_ID__ == 1) {
      {
#line 75
      __asm__  ("incb "
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (__preempt_count));
      }
    } else
#line 75
    if (pao_ID__ == -1) {
      {
#line 75
      __asm__  ("decb "
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (__preempt_count));
      }
    } else {
      {
#line 75
      __asm__  ("addb %1, "
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (__preempt_count): "qi" (val));
      }
    }
#line 75
    goto switch_break;
    case_2: /* CIL Label */ 
#line 75
    if (pao_ID__ == 1) {
      {
#line 75
      __asm__  ("incw "
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (__preempt_count));
      }
    } else
#line 75
    if (pao_ID__ == -1) {
      {
#line 75
      __asm__  ("decw "
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (__preempt_count));
      }
    } else {
      {
#line 75
      __asm__  ("addw %1, "
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (__preempt_count): "ri" (val));
      }
    }
#line 75
    goto switch_break;
    case_4: /* CIL Label */ 
#line 75
    if (pao_ID__ == 1) {
      {
#line 75
      __asm__  ("incl "
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (__preempt_count));
      }
    } else
#line 75
    if (pao_ID__ == -1) {
      {
#line 75
      __asm__  ("decl "
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (__preempt_count));
      }
    } else {
      {
#line 75
      __asm__  ("addl %1, "
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (__preempt_count): "ri" (val));
      }
    }
#line 75
    goto switch_break;
    case_8: /* CIL Label */ 
#line 75
    if (pao_ID__ == 1) {
      {
#line 75
      __asm__  ("incq "
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (__preempt_count));
      }
    } else
#line 75
    if (pao_ID__ == -1) {
      {
#line 75
      __asm__  ("decq "
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (__preempt_count));
      }
    } else {
      {
#line 75
      __asm__  ("addq %1, "
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (__preempt_count): "re" (val));
      }
    }
#line 75
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 75
    __bad_percpu_size();
    }
    switch_break: /* CIL Label */ ;
    }
#line 75
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  return;
}
}
#line 78
__inline static void ( __attribute__((__always_inline__)) __preempt_count_sub)(int val )  __attribute__((__no_instrument_function__)) ;
#line 78 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/preempt.h"
__inline static void ( __attribute__((__always_inline__)) __preempt_count_sub)(int val ) 
{ 
  int pao_ID__ ;
  pao_T_____0 pao_tmp__ ;

  {
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 80
    pao_ID__ = 0;
    }
    {
#line 80
    if (sizeof(__preempt_count) == 1UL) {
#line 80
      goto case_1;
    }
#line 80
    if (sizeof(__preempt_count) == 2UL) {
#line 80
      goto case_2;
    }
#line 80
    if (sizeof(__preempt_count) == 4UL) {
#line 80
      goto case_4;
    }
#line 80
    if (sizeof(__preempt_count) == 8UL) {
#line 80
      goto case_8;
    }
#line 80
    goto switch_default;
    case_1: /* CIL Label */ 
#line 80
    if (pao_ID__ == 1) {
      {
#line 80
      __asm__  ("incb "
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (__preempt_count));
      }
    } else
#line 80
    if (pao_ID__ == -1) {
      {
#line 80
      __asm__  ("decb "
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (__preempt_count));
      }
    } else {
      {
#line 80
      __asm__  ("addb %1, "
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (__preempt_count): "qi" (- val));
      }
    }
#line 80
    goto switch_break;
    case_2: /* CIL Label */ 
#line 80
    if (pao_ID__ == 1) {
      {
#line 80
      __asm__  ("incw "
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (__preempt_count));
      }
    } else
#line 80
    if (pao_ID__ == -1) {
      {
#line 80
      __asm__  ("decw "
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (__preempt_count));
      }
    } else {
      {
#line 80
      __asm__  ("addw %1, "
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (__preempt_count): "ri" (- val));
      }
    }
#line 80
    goto switch_break;
    case_4: /* CIL Label */ 
#line 80
    if (pao_ID__ == 1) {
      {
#line 80
      __asm__  ("incl "
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (__preempt_count));
      }
    } else
#line 80
    if (pao_ID__ == -1) {
      {
#line 80
      __asm__  ("decl "
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (__preempt_count));
      }
    } else {
      {
#line 80
      __asm__  ("addl %1, "
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (__preempt_count): "ri" (- val));
      }
    }
#line 80
    goto switch_break;
    case_8: /* CIL Label */ 
#line 80
    if (pao_ID__ == 1) {
      {
#line 80
      __asm__  ("incq "
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (__preempt_count));
      }
    } else
#line 80
    if (pao_ID__ == -1) {
      {
#line 80
      __asm__  ("decq "
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (__preempt_count));
      }
    } else {
      {
#line 80
      __asm__  ("addq %1, "
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (__preempt_count): "re" (- val));
      }
    }
#line 80
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 80
    __bad_percpu_size();
    }
    switch_break: /* CIL Label */ ;
    }
#line 80
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  return;
}
}
#line 88
__inline static bool ( __attribute__((__always_inline__)) __preempt_count_dec_and_test)(void)  __attribute__((__no_instrument_function__)) ;
#line 88 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/preempt.h"
__inline static bool ( __attribute__((__always_inline__)) __preempt_count_dec_and_test)(void) 
{ 
  char c ;

  {
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 90
    __asm__  volatile   ("decl"
                         " "
                         "%%"
                         "gs"
                         ":"
                         "%P"
                         "0"
                         "; set"
                         "e"
                         " %1": "+m" (__preempt_count), "=qm" (c): : "memory");
    }
#line 90
    return ((bool )((int )c != 0));
#line 90
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  return ((_Bool)0);
}
}
#line 96
__inline static bool ( __attribute__((__always_inline__)) should_resched)(void)  __attribute__((__no_instrument_function__)) ;
#line 96 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/preempt.h"
__inline static bool ( __attribute__((__always_inline__)) should_resched)(void) 
{ 
  int pfo_ret__ ;
  int tmp ;
  long tmp___0 ;

  {
  {
#line 98
  if (sizeof(__preempt_count) == 1UL) {
#line 98
    goto case_1;
  }
#line 98
  if (sizeof(__preempt_count) == 2UL) {
#line 98
    goto case_2;
  }
#line 98
  if (sizeof(__preempt_count) == 4UL) {
#line 98
    goto case_4;
  }
#line 98
  if (sizeof(__preempt_count) == 8UL) {
#line 98
    goto case_8;
  }
#line 98
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 98
  __asm__  ("mov"
            "b "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=q" (pfo_ret__): "m" (__preempt_count));
  }
#line 98
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 98
  __asm__  ("mov"
            "w "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret__): "m" (__preempt_count));
  }
#line 98
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 98
  __asm__  ("mov"
            "l "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret__): "m" (__preempt_count));
  }
#line 98
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 98
  __asm__  ("mov"
            "q "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret__): "m" (__preempt_count));
  }
#line 98
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 98
  __bad_percpu_size();
  }
  switch_break: /* CIL Label */ ;
  }
#line 98
  if (pfo_ret__) {
    {
#line 98
    tmp = 0;
    }
  } else {
    {
#line 98
    tmp = 1;
    }
  }
  {
#line 98
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
#line 98
  return ((bool )tmp___0);
}
}
#line 10 "../../../analyzer/../bench/linux-headers/include/linux/bottom_half.h"
__inline static void ( __attribute__((__always_inline__)) __local_bh_disable_ip)(unsigned long ip ,
                                                                                 unsigned int cnt )  __attribute__((__no_instrument_function__)) ;
#line 10 "../../../analyzer/../bench/linux-headers/include/linux/bottom_half.h"
__inline static void ( __attribute__((__always_inline__)) __local_bh_disable_ip)(unsigned long ip ,
                                                                                 unsigned int cnt ) 
{ 


  {
  {
#line 12
  __preempt_count_add((int )cnt);
#line 13
  __asm__  volatile   ("": : : "memory");
  }
#line 14
  return;
}
}
#line 17
__inline static void local_bh_disable(void)  __attribute__((__no_instrument_function__)) ;
#line 17 "../../../analyzer/../bench/linux-headers/include/linux/bottom_half.h"
__inline static void local_bh_disable(void) 
{ 


  {
  __here___0: 
  {
#line 19
  __local_bh_disable_ip((unsigned long )((void *)0), (unsigned int )(2UL * (1UL << 8)));
  }
#line 20
  return;
}
}
#line 22
extern void _local_bh_enable(void) ;
#line 23
extern void __local_bh_enable_ip(unsigned long ip , unsigned int cnt ) ;
#line 25
__inline static void local_bh_enable_ip(unsigned long ip )  __attribute__((__no_instrument_function__)) ;
#line 25 "../../../analyzer/../bench/linux-headers/include/linux/bottom_half.h"
__inline static void local_bh_enable_ip(unsigned long ip ) 
{ 


  {
  {
#line 27
  __local_bh_enable_ip(ip, (unsigned int )(2UL * (1UL << 8)));
  }
#line 28
  return;
}
}
#line 30
__inline static void local_bh_enable(void)  __attribute__((__no_instrument_function__)) ;
#line 30 "../../../analyzer/../bench/linux-headers/include/linux/bottom_half.h"
__inline static void local_bh_enable(void) 
{ 


  {
  __here___0: 
  {
#line 32
  __local_bh_enable_ip((unsigned long )((void *)0), (unsigned int )(2UL * (1UL << 8)));
  }
#line 33
  return;
}
}
#line 16 "../../../analyzer/../bench/linux-headers/include/linux/lockdep.h"
extern int prove_locking ;
#line 17
extern int lock_stat ;
#line 369
__inline static void lockdep_off(void)  __attribute__((__no_instrument_function__)) ;
#line 369 "../../../analyzer/../bench/linux-headers/include/linux/lockdep.h"
__inline static void lockdep_off(void) 
{ 


  {
#line 371
  return;
}
}
#line 373
__inline static void lockdep_on(void)  __attribute__((__no_instrument_function__)) ;
#line 373 "../../../analyzer/../bench/linux-headers/include/linux/lockdep.h"
__inline static void lockdep_on(void) 
{ 


  {
#line 375
  return;
}
}
#line 464
__inline static void print_irqtrace_events(struct task_struct *curr )  __attribute__((__no_instrument_function__)) ;
#line 464 "../../../analyzer/../bench/linux-headers/include/linux/lockdep.h"
__inline static void print_irqtrace_events(struct task_struct *curr ) 
{ 


  {
#line 466
  return;
}
}
#line 53 "../../../analyzer/../bench/linux-headers/include/linux/jump_label.h"
extern bool static_key_initialized ;
#line 87
__inline static int static_key_count(struct static_key *key )  __attribute__((__no_instrument_function__)) ;
#line 87 "../../../analyzer/../bench/linux-headers/include/linux/jump_label.h"
__inline static int static_key_count(struct static_key *key ) 
{ 
  int tmp ;

  {
  {
#line 89
  tmp = atomic_read((atomic_t const   *)(& key->enabled));
  }
#line 89
  return (tmp);
}
}
#line 147
__inline static void ( __attribute__((__always_inline__)) jump_label_init)(void)  __attribute__((__no_instrument_function__)) ;
#line 147 "../../../analyzer/../bench/linux-headers/include/linux/jump_label.h"
__inline static void ( __attribute__((__always_inline__)) jump_label_init)(void) 
{ 


  {
  {
#line 149
  static_key_initialized = (bool )1;
  }
#line 150
  return;
}
}
#line 152
__inline static bool ( __attribute__((__always_inline__)) static_key_false)(struct static_key *key )  __attribute__((__no_instrument_function__)) ;
#line 152 "../../../analyzer/../bench/linux-headers/include/linux/jump_label.h"
__inline static bool ( __attribute__((__always_inline__)) static_key_false)(struct static_key *key ) 
{ 
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 154
  tmp = static_key_count(key);
  }
#line 154
  if (tmp > 0) {
    {
#line 154
    tmp___0 = 1;
    }
  } else {
    {
#line 154
    tmp___0 = 0;
    }
  }
  {
#line 154
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
#line 154
  if (tmp___1) {
#line 155
    return ((bool )1);
  }
#line 156
  return ((bool )0);
}
}
#line 159
__inline static bool ( __attribute__((__always_inline__)) static_key_true)(struct static_key *key )  __attribute__((__no_instrument_function__)) ;
#line 159 "../../../analyzer/../bench/linux-headers/include/linux/jump_label.h"
__inline static bool ( __attribute__((__always_inline__)) static_key_true)(struct static_key *key ) 
{ 
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 161
  tmp = static_key_count(key);
  }
#line 161
  if (tmp > 0) {
    {
#line 161
    tmp___0 = 1;
    }
  } else {
    {
#line 161
    tmp___0 = 0;
    }
  }
  {
#line 161
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  }
#line 161
  if (tmp___1) {
#line 162
    return ((bool )1);
  }
#line 163
  return ((bool )0);
}
}
#line 166
__inline static void static_key_slow_inc(struct static_key *key )  __attribute__((__no_instrument_function__)) ;
#line 166 "../../../analyzer/../bench/linux-headers/include/linux/jump_label.h"
__inline static void static_key_slow_inc(struct static_key *key ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
  {
#line 168
  __ret_warn_on = ! (! (! static_key_initialized));
#line 168
  tmp = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
  }
#line 168
  if (tmp) {
    {
#line 168
    warn_slowpath_fmt("../../../analyzer/../bench/linux-headers/include/linux/jump_label.h",
                      (int const   )168, "%s used before call to jump_label_init",
                      "static_key_slow_inc");
    }
  }
  {
#line 168
  __builtin_expect((long )(! (! __ret_warn_on)), 0L);
#line 169
  atomic_inc(& key->enabled);
  }
#line 170
  return;
}
}
#line 172
__inline static void static_key_slow_dec(struct static_key *key )  __attribute__((__no_instrument_function__)) ;
#line 172 "../../../analyzer/../bench/linux-headers/include/linux/jump_label.h"
__inline static void static_key_slow_dec(struct static_key *key ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
  {
#line 174
  __ret_warn_on = ! (! (! static_key_initialized));
#line 174
  tmp = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
  }
#line 174
  if (tmp) {
    {
#line 174
    warn_slowpath_fmt("../../../analyzer/../bench/linux-headers/include/linux/jump_label.h",
                      (int const   )174, "%s used before call to jump_label_init",
                      "static_key_slow_dec");
    }
  }
  {
#line 174
  __builtin_expect((long )(! (! __ret_warn_on)), 0L);
#line 175
  atomic_dec(& key->enabled);
  }
#line 176
  return;
}
}
#line 178
__inline static int jump_label_text_reserved(void *start , void *end )  __attribute__((__no_instrument_function__)) ;
#line 178 "../../../analyzer/../bench/linux-headers/include/linux/jump_label.h"
__inline static int jump_label_text_reserved(void *start , void *end ) 
{ 


  {
#line 180
  return (0);
}
}
#line 183
__inline static void jump_label_lock(void)  __attribute__((__no_instrument_function__)) ;
#line 183 "../../../analyzer/../bench/linux-headers/include/linux/jump_label.h"
__inline static void jump_label_lock(void) 
{ 


  {
#line 183
  return;
}
}
#line 184
__inline static void jump_label_unlock(void)  __attribute__((__no_instrument_function__)) ;
#line 184 "../../../analyzer/../bench/linux-headers/include/linux/jump_label.h"
__inline static void jump_label_unlock(void) 
{ 


  {
#line 184
  return;
}
}
#line 186
__inline static int jump_label_apply_nops(struct module *mod )  __attribute__((__no_instrument_function__)) ;
#line 186 "../../../analyzer/../bench/linux-headers/include/linux/jump_label.h"
__inline static int jump_label_apply_nops(struct module *mod ) 
{ 


  {
#line 188
  return (0);
}
}
#line 201
__inline static bool static_key_enabled(struct static_key *key )  __attribute__((__no_instrument_function__)) ;
#line 201 "../../../analyzer/../bench/linux-headers/include/linux/jump_label.h"
__inline static bool static_key_enabled(struct static_key *key ) 
{ 
  int tmp ;

  {
  {
#line 203
  tmp = static_key_count(key);
  }
#line 203
  return ((bool )(tmp > 0));
}
}
#line 42 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/spinlock.h"
extern struct static_key paravirt_ticketlocks_enabled ;
#line 53
__inline static void ( __attribute__((__always_inline__)) __ticket_lock_spinning)(arch_spinlock_t *lock ,
                                                                                  __ticket_t ticket )  __attribute__((__no_instrument_function__)) ;
#line 53 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/spinlock.h"
__inline static void ( __attribute__((__always_inline__)) __ticket_lock_spinning)(arch_spinlock_t *lock ,
                                                                                  __ticket_t ticket ) 
{ 


  {
#line 56
  return;
}
}
#line 57
__inline static void __ticket_unlock_kick(arch_spinlock_t *lock , __ticket_t ticket )  __attribute__((__no_instrument_function__)) ;
#line 57 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/spinlock.h"
__inline static void __ticket_unlock_kick(arch_spinlock_t *lock , __ticket_t ticket ) 
{ 


  {
#line 60
  return;
}
}
#line 64
__inline static int ( __attribute__((__always_inline__)) arch_spin_value_unlocked)(arch_spinlock_t lock )  __attribute__((__no_instrument_function__)) ;
#line 64 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/spinlock.h"
__inline static int ( __attribute__((__always_inline__)) arch_spin_value_unlocked)(arch_spinlock_t lock ) 
{ 


  {
#line 66
  return ((int )lock.__annonCompField17.tickets.head == (int )lock.__annonCompField17.tickets.tail);
}
}
#line 82
__inline static void ( __attribute__((__always_inline__)) arch_spin_lock)(arch_spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 82 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/spinlock.h"
__inline static void ( __attribute__((__always_inline__)) arch_spin_lock)(arch_spinlock_t *lock ) 
{ 
  register struct __raw_tickets inc ;
  struct __raw_tickets __ret ;
  long tmp ;
  unsigned int count ;

  {
  {
#line 84
  inc.head = (unsigned char)0;
#line 84
  inc.tail = (__ticket_t )1;
#line 86
  __ret = inc;
  }
  {
#line 86
  if (sizeof(lock->__annonCompField17.tickets) == 1UL) {
#line 86
    goto case_1;
  }
#line 86
  if (sizeof(lock->__annonCompField17.tickets) == 2UL) {
#line 86
    goto case_2;
  }
#line 86
  if (sizeof(lock->__annonCompField17.tickets) == 4UL) {
#line 86
    goto case_4;
  }
#line 86
  if (sizeof(lock->__annonCompField17.tickets) == 8UL) {
#line 86
    goto case_8;
  }
#line 86
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 86
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "xadd"
                       "b %b0, %1\n": "+q" (__ret), "+m" (lock->__annonCompField17.tickets): : "memory",
                       "cc");
  }
#line 86
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 86
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "xadd"
                       "w %w0, %1\n": "+r" (__ret), "+m" (lock->__annonCompField17.tickets): : "memory",
                       "cc");
  }
#line 86
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 86
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "xadd"
                       "l %0, %1\n": "+r" (__ret), "+m" (lock->__annonCompField17.tickets): : "memory",
                       "cc");
  }
#line 86
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 86
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "xadd"
                       "q %q0, %1\n": "+r" (__ret), "+m" (lock->__annonCompField17.tickets): : "memory",
                       "cc");
  }
#line 86
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 86
  __xadd_wrong_size();
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 86
  inc = __ret;
#line 87
  tmp = __builtin_expect((long )(! (! ((int )inc.head == (int )inc.tail))), 1L);
  }
#line 87
  if (tmp) {
#line 88
    goto out;
  }
  {
#line 90
  inc.tail = (__ticket_t )((int )inc.tail & -1);
  }
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 92
    count = (unsigned int )(1 << 15);
    }
    {
#line 94
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 95
      if ((int volatile   )*((__ticket_t volatile   *)(& lock->__annonCompField17.tickets.head)) == (int volatile   )inc.tail) {
#line 96
        goto out;
      }
      {
#line 97
      cpu_relax();
#line 94
      count --;
      }
#line 94
      if (! count) {
#line 94
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 99
    __ticket_lock_spinning(lock, inc.tail);
    }
  }
  while_break: /* CIL Label */ ;
  }
  out: 
  {
#line 101
  __asm__  volatile   ("": : : "memory");
  }
#line 102
  return;
}
}
#line 104
__inline static int ( __attribute__((__always_inline__)) arch_spin_trylock)(arch_spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 104 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/spinlock.h"
__inline static int ( __attribute__((__always_inline__)) arch_spin_trylock)(arch_spinlock_t *lock ) 
{ 
  arch_spinlock_t old ;
  arch_spinlock_t new ;
  __ticketpair_t __ret ;
  __ticketpair_t __old ;
  __ticketpair_t __new ;
  u8 volatile   *__ptr ;
  u16 volatile   *__ptr___0 ;
  u32 volatile   *__ptr___1 ;
  u64 volatile   *__ptr___2 ;

  {
  {
#line 108
  old.__annonCompField17.tickets = (struct __raw_tickets )*((struct __raw_tickets  volatile  *)(& lock->__annonCompField17.tickets));
  }
#line 109
  if ((int )old.__annonCompField17.tickets.head != ((int )old.__annonCompField17.tickets.tail & -1)) {
#line 110
    return (0);
  }
  {
#line 112
  new.__annonCompField17.head_tail = (__ticketpair_t )((int )old.__annonCompField17.head_tail + (1 << sizeof(__ticket_t ) * 8UL));
#line 115
  __old = old.__annonCompField17.head_tail;
#line 115
  __new = new.__annonCompField17.head_tail;
  }
  {
#line 115
  if (sizeof(lock->__annonCompField17.head_tail) == 1UL) {
#line 115
    goto case_1;
  }
#line 115
  if (sizeof(lock->__annonCompField17.head_tail) == 2UL) {
#line 115
    goto case_2;
  }
#line 115
  if (sizeof(lock->__annonCompField17.head_tail) == 4UL) {
#line 115
    goto case_4;
  }
#line 115
  if (sizeof(lock->__annonCompField17.head_tail) == 8UL) {
#line 115
    goto case_8;
  }
#line 115
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 115
  __ptr = (u8 volatile   *)(& lock->__annonCompField17.head_tail);
#line 115
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "cmpxchgb %2,%1": "=a" (__ret), "+m" (*__ptr): "q" (__new),
                       "0" (__old): "memory");
  }
#line 115
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 115
  __ptr___0 = (u16 volatile   *)(& lock->__annonCompField17.head_tail);
#line 115
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "cmpxchgw %2,%1": "=a" (__ret), "+m" (*__ptr___0): "r" (__new),
                       "0" (__old): "memory");
  }
#line 115
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 115
  __ptr___1 = (u32 volatile   *)(& lock->__annonCompField17.head_tail);
#line 115
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "cmpxchgl %2,%1": "=a" (__ret), "+m" (*__ptr___1): "r" (__new),
                       "0" (__old): "memory");
  }
#line 115
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 115
  __ptr___2 = (u64 volatile   *)(& lock->__annonCompField17.head_tail);
#line 115
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "cmpxchgq %2,%1": "=a" (__ret), "+m" (*__ptr___2): "r" (__new),
                       "0" (__old): "memory");
  }
#line 115
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 115
  __cmpxchg_wrong_size();
  }
  switch_break: /* CIL Label */ ;
  }
#line 115
  return ((int )__ret == (int )old.__annonCompField17.head_tail);
}
}
#line 118
__inline static void __ticket_unlock_slowpath(arch_spinlock_t *lock , arch_spinlock_t old )  __attribute__((__no_instrument_function__)) ;
#line 118 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/spinlock.h"
__inline static void __ticket_unlock_slowpath(arch_spinlock_t *lock , arch_spinlock_t old ) 
{ 
  arch_spinlock_t new ;
  __ticketpair_t __ret ;
  __ticketpair_t __old ;
  __ticketpair_t __new ;
  u8 volatile   *__ptr ;
  u16 volatile   *__ptr___0 ;
  u32 volatile   *__ptr___1 ;
  u64 volatile   *__ptr___2 ;

  {
  {
#line 126
  old.__annonCompField17.tickets.head = (__ticket_t )((int )old.__annonCompField17.tickets.head + 1);
#line 129
  new.__annonCompField17.head_tail = (__ticketpair_t )((int )old.__annonCompField17.head_tail & -1);
  }
#line 136
  if ((int )new.__annonCompField17.tickets.head != (int )new.__annonCompField17.tickets.tail) {
    {
#line 142
    __ticket_unlock_kick(lock, old.__annonCompField17.tickets.head);
    }
  } else {
    {
#line 136
    __old = old.__annonCompField17.head_tail;
#line 136
    __new = new.__annonCompField17.head_tail;
    }
    {
#line 136
    if (sizeof(lock->__annonCompField17.head_tail) == 1UL) {
#line 136
      goto case_1;
    }
#line 136
    if (sizeof(lock->__annonCompField17.head_tail) == 2UL) {
#line 136
      goto case_2;
    }
#line 136
    if (sizeof(lock->__annonCompField17.head_tail) == 4UL) {
#line 136
      goto case_4;
    }
#line 136
    if (sizeof(lock->__annonCompField17.head_tail) == 8UL) {
#line 136
      goto case_8;
    }
#line 136
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 136
    __ptr = (u8 volatile   *)(& lock->__annonCompField17.head_tail);
#line 136
    __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                         ".balign 4\n"
                         ".long 671f - .\n"
                         ".popsection\n"
                         "671:"
                         "\n\tlock; "
                         "cmpxchgb %2,%1": "=a" (__ret), "+m" (*__ptr): "q" (__new),
                         "0" (__old): "memory");
    }
#line 136
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 136
    __ptr___0 = (u16 volatile   *)(& lock->__annonCompField17.head_tail);
#line 136
    __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                         ".balign 4\n"
                         ".long 671f - .\n"
                         ".popsection\n"
                         "671:"
                         "\n\tlock; "
                         "cmpxchgw %2,%1": "=a" (__ret), "+m" (*__ptr___0): "r" (__new),
                         "0" (__old): "memory");
    }
#line 136
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 136
    __ptr___1 = (u32 volatile   *)(& lock->__annonCompField17.head_tail);
#line 136
    __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                         ".balign 4\n"
                         ".long 671f - .\n"
                         ".popsection\n"
                         "671:"
                         "\n\tlock; "
                         "cmpxchgl %2,%1": "=a" (__ret), "+m" (*__ptr___1): "r" (__new),
                         "0" (__old): "memory");
    }
#line 136
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 136
    __ptr___2 = (u64 volatile   *)(& lock->__annonCompField17.head_tail);
#line 136
    __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                         ".balign 4\n"
                         ".long 671f - .\n"
                         ".popsection\n"
                         "671:"
                         "\n\tlock; "
                         "cmpxchgq %2,%1": "=a" (__ret), "+m" (*__ptr___2): "r" (__new),
                         "0" (__old): "memory");
    }
#line 136
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 136
    __cmpxchg_wrong_size();
    }
    switch_break: /* CIL Label */ ;
    }
#line 136
    if ((int )__ret != (int )old.__annonCompField17.head_tail) {
      {
#line 142
      __ticket_unlock_kick(lock, old.__annonCompField17.tickets.head);
      }
    }
  }
#line 144
  return;
}
}
#line 146
__inline static void ( __attribute__((__always_inline__)) arch_spin_unlock)(arch_spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 146 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/spinlock.h"
__inline static void ( __attribute__((__always_inline__)) arch_spin_unlock)(arch_spinlock_t *lock ) 
{ 
  arch_spinlock_t prev ;
  __ticket_t __ret ;
  long tmp ;
  __ticket_t __ret___0 ;
  bool tmp___0 ;

  {
#line 148
  if ((unsigned char)0) {
    {
#line 152
    prev = *lock;
#line 153
    __ret = (__ticket_t )1;
    }
    {
#line 153
    if (sizeof(lock->__annonCompField17.tickets.head) == 1UL) {
#line 153
      goto case_1;
    }
#line 153
    if (sizeof(lock->__annonCompField17.tickets.head) == 2UL) {
#line 153
      goto case_2;
    }
#line 153
    if (sizeof(lock->__annonCompField17.tickets.head) == 4UL) {
#line 153
      goto case_4;
    }
#line 153
    if (sizeof(lock->__annonCompField17.tickets.head) == 8UL) {
#line 153
      goto case_8;
    }
#line 153
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 153
    __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                         ".balign 4\n"
                         ".long 671f - .\n"
                         ".popsection\n"
                         "671:"
                         "\n\tlock; "
                         "addb %b1, %0\n": "+m" (lock->__annonCompField17.tickets.head): "qi" ((__ticket_t )1): "memory",
                         "cc");
    }
#line 153
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 153
    __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                         ".balign 4\n"
                         ".long 671f - .\n"
                         ".popsection\n"
                         "671:"
                         "\n\tlock; "
                         "addw %w1, %0\n": "+m" (lock->__annonCompField17.tickets.head): "ri" ((__ticket_t )1): "memory",
                         "cc");
    }
#line 153
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 153
    __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                         ".balign 4\n"
                         ".long 671f - .\n"
                         ".popsection\n"
                         "671:"
                         "\n\tlock; "
                         "addl %1, %0\n": "+m" (lock->__annonCompField17.tickets.head): "ri" ((__ticket_t )1): "memory",
                         "cc");
    }
#line 153
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 153
    __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                         ".balign 4\n"
                         ".long 671f - .\n"
                         ".popsection\n"
                         "671:"
                         "\n\tlock; "
                         "addq %1, %0\n": "+m" (lock->__annonCompField17.tickets.head): "ri" ((__ticket_t )1): "memory",
                         "cc");
    }
#line 153
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 153
    __add_wrong_size();
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 157
    tmp = __builtin_expect(0L, 0L);
    }
#line 157
    if (tmp) {
      {
#line 158
      __ticket_unlock_slowpath(lock, prev);
      }
    }
  } else {
    {
#line 160
    __ret___0 = (__ticket_t )1;
    }
    {
#line 160
    if (sizeof(lock->__annonCompField17.tickets.head) == 1UL) {
#line 160
      goto case_1___0;
    }
#line 160
    if (sizeof(lock->__annonCompField17.tickets.head) == 2UL) {
#line 160
      goto case_2___0;
    }
#line 160
    if (sizeof(lock->__annonCompField17.tickets.head) == 4UL) {
#line 160
      goto case_4___0;
    }
#line 160
    if (sizeof(lock->__annonCompField17.tickets.head) == 8UL) {
#line 160
      goto case_8___0;
    }
#line 160
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
    {
#line 160
    __asm__  volatile   ("addb %b1, %0\n": "+m" (lock->__annonCompField17.tickets.head): "qi" ((__ticket_t )1): "memory",
                         "cc");
    }
#line 160
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 160
    __asm__  volatile   ("addw %w1, %0\n": "+m" (lock->__annonCompField17.tickets.head): "ri" ((__ticket_t )1): "memory",
                         "cc");
    }
#line 160
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
    {
#line 160
    __asm__  volatile   ("addl %1, %0\n": "+m" (lock->__annonCompField17.tickets.head): "ri" ((__ticket_t )1): "memory",
                         "cc");
    }
#line 160
    goto switch_break___0;
    case_8___0: /* CIL Label */ 
    {
#line 160
    __asm__  volatile   ("addq %1, %0\n": "+m" (lock->__annonCompField17.tickets.head): "ri" ((__ticket_t )1): "memory",
                         "cc");
    }
#line 160
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 160
    __add_wrong_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 161
  return;
}
}
#line 163
__inline static int arch_spin_is_locked(arch_spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 163 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/spinlock.h"
__inline static int arch_spin_is_locked(arch_spinlock_t *lock ) 
{ 
  struct __raw_tickets tmp ;

  {
  {
#line 165
  tmp = *((struct __raw_tickets  volatile  *)(& lock->__annonCompField17.tickets));
  }
#line 167
  return ((int )tmp.tail != (int )tmp.head);
}
}
#line 170
__inline static int arch_spin_is_contended(arch_spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 170 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/spinlock.h"
__inline static int arch_spin_is_contended(arch_spinlock_t *lock ) 
{ 
  struct __raw_tickets tmp ;

  {
  {
#line 172
  tmp = *((struct __raw_tickets  volatile  *)(& lock->__annonCompField17.tickets));
  }
#line 174
  return ((int )((__ticket_t )((int )tmp.tail - (int )tmp.head)) > 1);
}
}
#line 178
__inline static void ( __attribute__((__always_inline__)) arch_spin_lock_flags)(arch_spinlock_t *lock ,
                                                                                unsigned long flags )  __attribute__((__no_instrument_function__)) ;
#line 178 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/spinlock.h"
__inline static void ( __attribute__((__always_inline__)) arch_spin_lock_flags)(arch_spinlock_t *lock ,
                                                                                unsigned long flags ) 
{ 


  {
  {
#line 181
  arch_spin_lock(lock);
  }
#line 182
  return;
}
}
#line 184
__inline static void arch_spin_unlock_wait(arch_spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 184 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/spinlock.h"
__inline static void arch_spin_unlock_wait(arch_spinlock_t *lock ) 
{ 
  int tmp ;

  {
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 186
    tmp = arch_spin_is_locked(lock);
    }
#line 186
    if (! tmp) {
#line 186
      goto while_break;
    }
    {
#line 187
    cpu_relax();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  return;
}
}
#line 8 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/qrwlock.h"
__inline static void queue_write_unlock(struct qrwlock *lock )  __attribute__((__no_instrument_function__)) ;
#line 8 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/qrwlock.h"
__inline static void queue_write_unlock(struct qrwlock *lock ) 
{ 


  {
  {
#line 10
  __asm__  volatile   ("": : : "memory");
#line 11
  *((u8 volatile   *)((u8 *)(& lock->cnts))) = (u8 volatile   )0;
  }
#line 12
  return;
}
}
#line 39 "../../../analyzer/../bench/linux-headers/include/asm-generic/qrwlock.h"
extern void queue_read_lock_slowpath(struct qrwlock *lock ) ;
#line 40
extern void queue_write_lock_slowpath(struct qrwlock *lock ) ;
#line 46
__inline static int queue_read_can_lock(struct qrwlock *lock )  __attribute__((__no_instrument_function__)) ;
#line 46 "../../../analyzer/../bench/linux-headers/include/asm-generic/qrwlock.h"
__inline static int queue_read_can_lock(struct qrwlock *lock ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 48
  tmp = atomic_read((atomic_t const   *)(& lock->cnts));
  }
#line 48
  if (tmp & 255) {
    {
#line 48
    tmp___0 = 0;
    }
  } else {
    {
#line 48
    tmp___0 = 1;
    }
  }
#line 48
  return (tmp___0);
}
}
#line 55
__inline static int queue_write_can_lock(struct qrwlock *lock )  __attribute__((__no_instrument_function__)) ;
#line 55 "../../../analyzer/../bench/linux-headers/include/asm-generic/qrwlock.h"
__inline static int queue_write_can_lock(struct qrwlock *lock ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 57
  tmp = atomic_read((atomic_t const   *)(& lock->cnts));
  }
#line 57
  if (tmp) {
    {
#line 57
    tmp___0 = 0;
    }
  } else {
    {
#line 57
    tmp___0 = 1;
    }
  }
#line 57
  return (tmp___0);
}
}
#line 65
__inline static int queue_read_trylock(struct qrwlock *lock )  __attribute__((__no_instrument_function__)) ;
#line 65 "../../../analyzer/../bench/linux-headers/include/asm-generic/qrwlock.h"
__inline static int queue_read_trylock(struct qrwlock *lock ) 
{ 
  u32 cnts ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  {
#line 69
  tmp = atomic_read((atomic_t const   *)(& lock->cnts));
#line 69
  cnts = (u32 )tmp;
#line 70
  tmp___2 = __builtin_expect((long )(! (! (! (cnts & 255U)))), 1L);
  }
#line 70
  if (tmp___2) {
    {
#line 71
    tmp___0 = atomic_add_return((int )(1U << 8), & lock->cnts);
#line 71
    cnts = (u32 )tmp___0;
#line 72
    tmp___1 = __builtin_expect((long )(! (! (! (cnts & 255U)))), 1L);
    }
#line 72
    if (tmp___1) {
#line 73
      return (1);
    }
    {
#line 74
    atomic_sub((int )(1U << 8), & lock->cnts);
    }
  }
#line 76
  return (0);
}
}
#line 84
__inline static int queue_write_trylock(struct qrwlock *lock )  __attribute__((__no_instrument_function__)) ;
#line 84 "../../../analyzer/../bench/linux-headers/include/asm-generic/qrwlock.h"
__inline static int queue_write_trylock(struct qrwlock *lock ) 
{ 
  u32 cnts ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  {
#line 88
  tmp = atomic_read((atomic_t const   *)(& lock->cnts));
#line 88
  cnts = (u32 )tmp;
#line 89
  tmp___0 = __builtin_expect((long )(! (! cnts)), 0L);
  }
#line 89
  if (tmp___0) {
#line 90
    return (0);
  }
  {
#line 92
  tmp___1 = atomic_cmpxchg(& lock->cnts, (int )cnts, (int )(cnts | 255U));
  }
#line 92
  if ((u32 )tmp___1 == cnts) {
    {
#line 92
    tmp___2 = 1;
    }
  } else {
    {
#line 92
    tmp___2 = 0;
    }
  }
  {
#line 92
  tmp___3 = __builtin_expect((long )tmp___2, 1L);
  }
#line 92
  return ((int )tmp___3);
}
}
#line 99
__inline static void queue_read_lock(struct qrwlock *lock )  __attribute__((__no_instrument_function__)) ;
#line 99 "../../../analyzer/../bench/linux-headers/include/asm-generic/qrwlock.h"
__inline static void queue_read_lock(struct qrwlock *lock ) 
{ 
  u32 cnts ;
  int tmp ;
  long tmp___0 ;

  {
  {
#line 103
  tmp = atomic_add_return((int )(1U << 8), & lock->cnts);
#line 103
  cnts = (u32 )tmp;
#line 104
  tmp___0 = __builtin_expect((long )(! (! (! (cnts & 255U)))), 1L);
  }
#line 104
  if (tmp___0) {
#line 105
    return;
  }
  {
#line 108
  queue_read_lock_slowpath(lock);
  }
#line 109
  return;
}
}
#line 115
__inline static void queue_write_lock(struct qrwlock *lock )  __attribute__((__no_instrument_function__)) ;
#line 115 "../../../analyzer/../bench/linux-headers/include/asm-generic/qrwlock.h"
__inline static void queue_write_lock(struct qrwlock *lock ) 
{ 
  int tmp ;

  {
  {
#line 118
  tmp = atomic_cmpxchg(& lock->cnts, 0, 255);
  }
#line 118
  if (tmp == 0) {
#line 119
    return;
  }
  {
#line 121
  queue_write_lock_slowpath(lock);
  }
#line 122
  return;
}
}
#line 128
__inline static void queue_read_unlock(struct qrwlock *lock )  __attribute__((__no_instrument_function__)) ;
#line 128 "../../../analyzer/../bench/linux-headers/include/asm-generic/qrwlock.h"
__inline static void queue_read_unlock(struct qrwlock *lock ) 
{ 


  {
  {
#line 133
  __asm__  volatile   ("": : : "memory");
#line 134
  atomic_sub((int )(1U << 8), & lock->cnts);
  }
#line 135
  return;
}
}
#line 93 "../../../analyzer/../bench/linux-headers/include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t *lock , char const   *name , struct lock_class_key *key ) ;
#line 150
extern void do_raw_spin_lock(raw_spinlock_t *lock ) ;
#line 152
extern int do_raw_spin_trylock(raw_spinlock_t *lock ) ;
#line 153
extern void do_raw_spin_unlock(raw_spinlock_t *lock ) ;
#line 18 "../../../analyzer/../bench/linux-headers/include/linux/rwlock.h"
extern void __rwlock_init(rwlock_t *lock , char const   *name , struct lock_class_key *key ) ;
#line 32
extern void do_raw_read_lock(rwlock_t *lock ) ;
#line 34
extern int do_raw_read_trylock(rwlock_t *lock ) ;
#line 35
extern void do_raw_read_unlock(rwlock_t *lock ) ;
#line 36
extern void do_raw_write_lock(rwlock_t *lock ) ;
#line 38
extern int do_raw_write_trylock(rwlock_t *lock ) ;
#line 39
extern void do_raw_write_unlock(rwlock_t *lock ) ;
#line 18 "../../../analyzer/../bench/linux-headers/include/linux/spinlock_api_smp.h"
extern int in_lock_functions(unsigned long addr ) ;
#line 22
extern void _raw_spin_lock(raw_spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 23
extern void _raw_spin_lock_nested(raw_spinlock_t *lock , int subclass )  __attribute__((__section__(".spinlock.text"))) ;
#line 25
extern void _raw_spin_lock_nest_lock(raw_spinlock_t *lock , struct lockdep_map *map )  __attribute__((__section__(".spinlock.text"))) ;
#line 28
extern void _raw_spin_lock_bh(raw_spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 29
extern void _raw_spin_lock_irq(raw_spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 32
extern unsigned long _raw_spin_lock_irqsave(raw_spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 34
extern unsigned long _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock , int subclass )  __attribute__((__section__(".spinlock.text"))) ;
#line 37
extern int _raw_spin_trylock(raw_spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 38
extern int _raw_spin_trylock_bh(raw_spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 39
extern void _raw_spin_unlock(raw_spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 40
extern void _raw_spin_unlock_bh(raw_spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 41
extern void _raw_spin_unlock_irq(raw_spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 42
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t *lock , unsigned long flags )  __attribute__((__section__(".spinlock.text"))) ;
#line 86
__inline static int __raw_spin_trylock(raw_spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 86 "../../../analyzer/../bench/linux-headers/include/linux/spinlock_api_smp.h"
__inline static int __raw_spin_trylock(raw_spinlock_t *lock ) 
{ 
  int tmp ;

  {
  {
#line 88
  __asm__  volatile   ("": : : "memory");
#line 89
  tmp = do_raw_spin_trylock(lock);
  }
#line 89
  if (tmp) {
    {
#line 90
    while (1) {
      while_continue: /* CIL Label */ ;
#line 90
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 91
    return (1);
  }
  {
#line 93
  __asm__  volatile   ("": : : "memory");
  }
#line 94
  return (0);
}
}
#line 104
__inline static unsigned long __raw_spin_lock_irqsave(raw_spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 104 "../../../analyzer/../bench/linux-headers/include/linux/spinlock_api_smp.h"
__inline static unsigned long __raw_spin_lock_irqsave(raw_spinlock_t *lock ) 
{ 
  unsigned long flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;

  {
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 108
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 108
      flags = arch_local_irq_save();
      }
#line 108
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 108
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 108
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 108
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 109
  __asm__  volatile   ("": : : "memory");
  }
  {
#line 110
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 110
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 119
  do_raw_spin_lock(lock);
  }
#line 121
  return (flags);
}
}
#line 124
__inline static void __raw_spin_lock_irq(raw_spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 124 "../../../analyzer/../bench/linux-headers/include/linux/spinlock_api_smp.h"
__inline static void __raw_spin_lock_irq(raw_spinlock_t *lock ) 
{ 


  {
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 126
    arch_local_irq_disable();
    }
    {
#line 126
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 126
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 126
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 127
  __asm__  volatile   ("": : : "memory");
  }
  {
#line 128
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 128
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 129
  do_raw_spin_lock(lock);
  }
#line 130
  return;
}
}
#line 132
__inline static void __raw_spin_lock_bh(raw_spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 132 "../../../analyzer/../bench/linux-headers/include/linux/spinlock_api_smp.h"
__inline static void __raw_spin_lock_bh(raw_spinlock_t *lock ) 
{ 
  void *tmp ;

  {
  {
#line 134
  tmp = __builtin_return_address(0U);
#line 134
  __local_bh_disable_ip((unsigned long )tmp, (unsigned int )(2UL * (1UL << 8)));
  }
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 136
  do_raw_spin_lock(lock);
  }
#line 137
  return;
}
}
#line 139
__inline static void __raw_spin_lock(raw_spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 139 "../../../analyzer/../bench/linux-headers/include/linux/spinlock_api_smp.h"
__inline static void __raw_spin_lock(raw_spinlock_t *lock ) 
{ 


  {
  {
#line 141
  __asm__  volatile   ("": : : "memory");
  }
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 143
  do_raw_spin_lock(lock);
  }
#line 144
  return;
}
}
#line 148
__inline static void __raw_spin_unlock(raw_spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 148 "../../../analyzer/../bench/linux-headers/include/linux/spinlock_api_smp.h"
__inline static void __raw_spin_unlock(raw_spinlock_t *lock ) 
{ 


  {
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 151
  do_raw_spin_unlock(lock);
#line 152
  __asm__  volatile   ("": : : "memory");
  }
#line 153
  return;
}
}
#line 155
__inline static void __raw_spin_unlock_irqrestore(raw_spinlock_t *lock , unsigned long flags )  __attribute__((__no_instrument_function__)) ;
#line 155 "../../../analyzer/../bench/linux-headers/include/linux/spinlock_api_smp.h"
__inline static void __raw_spin_unlock_irqrestore(raw_spinlock_t *lock , unsigned long flags ) 
{ 
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;
  unsigned long __dummy___1 ;
  unsigned long __dummy2___1 ;
  int tmp ;

  {
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 159
  do_raw_spin_unlock(lock);
  }
  {
#line 160
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 160
    tmp = arch_irqs_disabled_flags(flags);
    }
#line 160
    if (tmp) {
      {
#line 160
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 160
        arch_local_irq_restore(flags);
        }
#line 160
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 160
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 160
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 160
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 160
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 160
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 160
        arch_local_irq_restore(flags);
        }
#line 160
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 160
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 161
  __asm__  volatile   ("": : : "memory");
  }
#line 162
  return;
}
}
#line 164
__inline static void __raw_spin_unlock_irq(raw_spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 164 "../../../analyzer/../bench/linux-headers/include/linux/spinlock_api_smp.h"
__inline static void __raw_spin_unlock_irq(raw_spinlock_t *lock ) 
{ 


  {
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 167
  do_raw_spin_unlock(lock);
  }
  {
#line 168
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 168
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 168
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 168
    arch_local_irq_enable();
    }
#line 168
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 169
  __asm__  volatile   ("": : : "memory");
  }
#line 170
  return;
}
}
#line 172
__inline static void __raw_spin_unlock_bh(raw_spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 172 "../../../analyzer/../bench/linux-headers/include/linux/spinlock_api_smp.h"
__inline static void __raw_spin_unlock_bh(raw_spinlock_t *lock ) 
{ 
  void *tmp ;

  {
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 175
  do_raw_spin_unlock(lock);
#line 176
  tmp = __builtin_return_address(0U);
#line 176
  __local_bh_enable_ip((unsigned long )tmp, (unsigned int )(2UL * (1UL << 8)));
  }
#line 177
  return;
}
}
#line 179
__inline static int __raw_spin_trylock_bh(raw_spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 179 "../../../analyzer/../bench/linux-headers/include/linux/spinlock_api_smp.h"
__inline static int __raw_spin_trylock_bh(raw_spinlock_t *lock ) 
{ 
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 181
  tmp = __builtin_return_address(0U);
#line 181
  __local_bh_disable_ip((unsigned long )tmp, (unsigned int )(2UL * (1UL << 8)));
#line 182
  tmp___0 = do_raw_spin_trylock(lock);
  }
#line 182
  if (tmp___0) {
    {
#line 183
    while (1) {
      while_continue: /* CIL Label */ ;
#line 183
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 184
    return (1);
  }
  {
#line 186
  tmp___1 = __builtin_return_address(0U);
#line 186
  __local_bh_enable_ip((unsigned long )tmp___1, (unsigned int )(2UL * (1UL << 8)));
  }
#line 187
  return (0);
}
}
#line 18 "../../../analyzer/../bench/linux-headers/include/linux/rwlock_api_smp.h"
extern void _raw_read_lock(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 19
extern void _raw_write_lock(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 20
extern void _raw_read_lock_bh(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 21
extern void _raw_write_lock_bh(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 22
extern void _raw_read_lock_irq(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 23
extern void _raw_write_lock_irq(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 24
extern unsigned long _raw_read_lock_irqsave(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 26
extern unsigned long _raw_write_lock_irqsave(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 28
extern int _raw_read_trylock(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 29
extern int _raw_write_trylock(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 30
extern void _raw_read_unlock(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 31
extern void _raw_write_unlock(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 32
extern void _raw_read_unlock_bh(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 33
extern void _raw_write_unlock_bh(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 34
extern void _raw_read_unlock_irq(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 35
extern void _raw_write_unlock_irq(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 36
extern void _raw_read_unlock_irqrestore(rwlock_t *lock , unsigned long flags )  __attribute__((__section__(".spinlock.text"))) ;
#line 39
extern void _raw_write_unlock_irqrestore(rwlock_t *lock , unsigned long flags )  __attribute__((__section__(".spinlock.text"))) ;
#line 117
__inline static int __raw_read_trylock(rwlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 117 "../../../analyzer/../bench/linux-headers/include/linux/rwlock_api_smp.h"
__inline static int __raw_read_trylock(rwlock_t *lock ) 
{ 
  int tmp ;

  {
  {
#line 119
  __asm__  volatile   ("": : : "memory");
#line 120
  tmp = do_raw_read_trylock(lock);
  }
#line 120
  if (tmp) {
    {
#line 121
    while (1) {
      while_continue: /* CIL Label */ ;
#line 121
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 122
    return (1);
  }
  {
#line 124
  __asm__  volatile   ("": : : "memory");
  }
#line 125
  return (0);
}
}
#line 128
__inline static int __raw_write_trylock(rwlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 128 "../../../analyzer/../bench/linux-headers/include/linux/rwlock_api_smp.h"
__inline static int __raw_write_trylock(rwlock_t *lock ) 
{ 
  int tmp ;

  {
  {
#line 130
  __asm__  volatile   ("": : : "memory");
#line 131
  tmp = do_raw_write_trylock(lock);
  }
#line 131
  if (tmp) {
    {
#line 132
    while (1) {
      while_continue: /* CIL Label */ ;
#line 132
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 133
    return (1);
  }
  {
#line 135
  __asm__  volatile   ("": : : "memory");
  }
#line 136
  return (0);
}
}
#line 146
__inline static void __raw_read_lock(rwlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 146 "../../../analyzer/../bench/linux-headers/include/linux/rwlock_api_smp.h"
__inline static void __raw_read_lock(rwlock_t *lock ) 
{ 


  {
  {
#line 148
  __asm__  volatile   ("": : : "memory");
  }
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 150
  do_raw_read_lock(lock);
  }
#line 151
  return;
}
}
#line 153
__inline static unsigned long __raw_read_lock_irqsave(rwlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 153 "../../../analyzer/../bench/linux-headers/include/linux/rwlock_api_smp.h"
__inline static unsigned long __raw_read_lock_irqsave(rwlock_t *lock ) 
{ 
  unsigned long flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;

  {
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 157
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 157
      flags = arch_local_irq_save();
      }
#line 157
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 157
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 157
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 157
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 158
  __asm__  volatile   ("": : : "memory");
  }
  {
#line 159
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 159
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 160
  do_raw_read_lock(lock);
  }
#line 162
  return (flags);
}
}
#line 165
__inline static void __raw_read_lock_irq(rwlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 165 "../../../analyzer/../bench/linux-headers/include/linux/rwlock_api_smp.h"
__inline static void __raw_read_lock_irq(rwlock_t *lock ) 
{ 


  {
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 167
    arch_local_irq_disable();
    }
    {
#line 167
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 167
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 167
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 168
  __asm__  volatile   ("": : : "memory");
  }
  {
#line 169
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 169
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 170
  do_raw_read_lock(lock);
  }
#line 171
  return;
}
}
#line 173
__inline static void __raw_read_lock_bh(rwlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 173 "../../../analyzer/../bench/linux-headers/include/linux/rwlock_api_smp.h"
__inline static void __raw_read_lock_bh(rwlock_t *lock ) 
{ 
  void *tmp ;

  {
  {
#line 175
  tmp = __builtin_return_address(0U);
#line 175
  __local_bh_disable_ip((unsigned long )tmp, (unsigned int )(2UL * (1UL << 8)));
  }
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 177
  do_raw_read_lock(lock);
  }
#line 178
  return;
}
}
#line 180
__inline static unsigned long __raw_write_lock_irqsave(rwlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 180 "../../../analyzer/../bench/linux-headers/include/linux/rwlock_api_smp.h"
__inline static unsigned long __raw_write_lock_irqsave(rwlock_t *lock ) 
{ 
  unsigned long flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;

  {
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 184
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 184
      flags = arch_local_irq_save();
      }
#line 184
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 184
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 184
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 184
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 185
  __asm__  volatile   ("": : : "memory");
  }
  {
#line 186
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 186
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 187
  do_raw_write_lock(lock);
  }
#line 189
  return (flags);
}
}
#line 192
__inline static void __raw_write_lock_irq(rwlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 192 "../../../analyzer/../bench/linux-headers/include/linux/rwlock_api_smp.h"
__inline static void __raw_write_lock_irq(rwlock_t *lock ) 
{ 


  {
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 194
    arch_local_irq_disable();
    }
    {
#line 194
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 194
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 194
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 195
  __asm__  volatile   ("": : : "memory");
  }
  {
#line 196
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 196
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 197
  do_raw_write_lock(lock);
  }
#line 198
  return;
}
}
#line 200
__inline static void __raw_write_lock_bh(rwlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 200 "../../../analyzer/../bench/linux-headers/include/linux/rwlock_api_smp.h"
__inline static void __raw_write_lock_bh(rwlock_t *lock ) 
{ 
  void *tmp ;

  {
  {
#line 202
  tmp = __builtin_return_address(0U);
#line 202
  __local_bh_disable_ip((unsigned long )tmp, (unsigned int )(2UL * (1UL << 8)));
  }
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 204
  do_raw_write_lock(lock);
  }
#line 205
  return;
}
}
#line 207
__inline static void __raw_write_lock(rwlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 207 "../../../analyzer/../bench/linux-headers/include/linux/rwlock_api_smp.h"
__inline static void __raw_write_lock(rwlock_t *lock ) 
{ 


  {
  {
#line 209
  __asm__  volatile   ("": : : "memory");
  }
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 210
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 211
  do_raw_write_lock(lock);
  }
#line 212
  return;
}
}
#line 216
__inline static void __raw_write_unlock(rwlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 216 "../../../analyzer/../bench/linux-headers/include/linux/rwlock_api_smp.h"
__inline static void __raw_write_unlock(rwlock_t *lock ) 
{ 


  {
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 218
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 219
  do_raw_write_unlock(lock);
#line 220
  __asm__  volatile   ("": : : "memory");
  }
#line 221
  return;
}
}
#line 223
__inline static void __raw_read_unlock(rwlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 223 "../../../analyzer/../bench/linux-headers/include/linux/rwlock_api_smp.h"
__inline static void __raw_read_unlock(rwlock_t *lock ) 
{ 


  {
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 225
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 226
  do_raw_read_unlock(lock);
#line 227
  __asm__  volatile   ("": : : "memory");
  }
#line 228
  return;
}
}
#line 230
__inline static void __raw_read_unlock_irqrestore(rwlock_t *lock , unsigned long flags )  __attribute__((__no_instrument_function__)) ;
#line 230 "../../../analyzer/../bench/linux-headers/include/linux/rwlock_api_smp.h"
__inline static void __raw_read_unlock_irqrestore(rwlock_t *lock , unsigned long flags ) 
{ 
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;
  unsigned long __dummy___1 ;
  unsigned long __dummy2___1 ;
  int tmp ;

  {
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 233
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 234
  do_raw_read_unlock(lock);
  }
  {
#line 235
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 235
    tmp = arch_irqs_disabled_flags(flags);
    }
#line 235
    if (tmp) {
      {
#line 235
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 235
        arch_local_irq_restore(flags);
        }
#line 235
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 235
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 235
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 235
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 235
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 235
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 235
        arch_local_irq_restore(flags);
        }
#line 235
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 235
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 236
  __asm__  volatile   ("": : : "memory");
  }
#line 237
  return;
}
}
#line 239
__inline static void __raw_read_unlock_irq(rwlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 239 "../../../analyzer/../bench/linux-headers/include/linux/rwlock_api_smp.h"
__inline static void __raw_read_unlock_irq(rwlock_t *lock ) 
{ 


  {
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 241
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 242
  do_raw_read_unlock(lock);
  }
  {
#line 243
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 243
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 243
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 243
    arch_local_irq_enable();
    }
#line 243
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 244
  __asm__  volatile   ("": : : "memory");
  }
#line 245
  return;
}
}
#line 247
__inline static void __raw_read_unlock_bh(rwlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 247 "../../../analyzer/../bench/linux-headers/include/linux/rwlock_api_smp.h"
__inline static void __raw_read_unlock_bh(rwlock_t *lock ) 
{ 
  void *tmp ;

  {
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 250
  do_raw_read_unlock(lock);
#line 251
  tmp = __builtin_return_address(0U);
#line 251
  __local_bh_enable_ip((unsigned long )tmp, (unsigned int )(2UL * (1UL << 8)));
  }
#line 252
  return;
}
}
#line 254
__inline static void __raw_write_unlock_irqrestore(rwlock_t *lock , unsigned long flags )  __attribute__((__no_instrument_function__)) ;
#line 254 "../../../analyzer/../bench/linux-headers/include/linux/rwlock_api_smp.h"
__inline static void __raw_write_unlock_irqrestore(rwlock_t *lock , unsigned long flags ) 
{ 
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;
  unsigned long __dummy___1 ;
  unsigned long __dummy2___1 ;
  int tmp ;

  {
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;
#line 257
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 258
  do_raw_write_unlock(lock);
  }
  {
#line 259
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 259
    tmp = arch_irqs_disabled_flags(flags);
    }
#line 259
    if (tmp) {
      {
#line 259
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 259
        arch_local_irq_restore(flags);
        }
#line 259
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 259
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 259
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 259
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 259
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 259
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 259
        arch_local_irq_restore(flags);
        }
#line 259
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 259
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 260
  __asm__  volatile   ("": : : "memory");
  }
#line 261
  return;
}
}
#line 263
__inline static void __raw_write_unlock_irq(rwlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 263 "../../../analyzer/../bench/linux-headers/include/linux/rwlock_api_smp.h"
__inline static void __raw_write_unlock_irq(rwlock_t *lock ) 
{ 


  {
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 265
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 266
  do_raw_write_unlock(lock);
  }
  {
#line 267
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 267
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 267
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 267
    arch_local_irq_enable();
    }
#line 267
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 268
  __asm__  volatile   ("": : : "memory");
  }
#line 269
  return;
}
}
#line 271
__inline static void __raw_write_unlock_bh(rwlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 271 "../../../analyzer/../bench/linux-headers/include/linux/rwlock_api_smp.h"
__inline static void __raw_write_unlock_bh(rwlock_t *lock ) 
{ 
  void *tmp ;

  {
  {
#line 273
  while (1) {
    while_continue: /* CIL Label */ ;
#line 273
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 274
  do_raw_write_unlock(lock);
#line 275
  tmp = __builtin_return_address(0U);
#line 275
  __local_bh_enable_ip((unsigned long )tmp, (unsigned int )(2UL * (1UL << 8)));
  }
#line 276
  return;
}
}
#line 290 "../../../analyzer/../bench/linux-headers/include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 290 "../../../analyzer/../bench/linux-headers/include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 292
  return (& lock->__annonCompField18.rlock);
}
}
#line 301
__inline static void spin_lock(spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 301 "../../../analyzer/../bench/linux-headers/include/linux/spinlock.h"
__inline static void spin_lock(spinlock_t *lock ) 
{ 


  {
  {
#line 303
  _raw_spin_lock(& lock->__annonCompField18.rlock);
  }
#line 304
  return;
}
}
#line 306
__inline static void spin_lock_bh(spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 306 "../../../analyzer/../bench/linux-headers/include/linux/spinlock.h"
__inline static void spin_lock_bh(spinlock_t *lock ) 
{ 


  {
  {
#line 308
  _raw_spin_lock_bh(& lock->__annonCompField18.rlock);
  }
#line 309
  return;
}
}
#line 311
__inline static int spin_trylock(spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 311 "../../../analyzer/../bench/linux-headers/include/linux/spinlock.h"
__inline static int spin_trylock(spinlock_t *lock ) 
{ 
  int tmp ;

  {
  {
#line 313
  tmp = _raw_spin_trylock(& lock->__annonCompField18.rlock);
  }
#line 313
  return (tmp);
}
}
#line 326
__inline static void spin_lock_irq(spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 326 "../../../analyzer/../bench/linux-headers/include/linux/spinlock.h"
__inline static void spin_lock_irq(spinlock_t *lock ) 
{ 


  {
  {
#line 328
  _raw_spin_lock_irq(& lock->__annonCompField18.rlock);
  }
#line 329
  return;
}
}
#line 341
__inline static void spin_unlock(spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 341 "../../../analyzer/../bench/linux-headers/include/linux/spinlock.h"
__inline static void spin_unlock(spinlock_t *lock ) 
{ 


  {
  {
#line 343
  __raw_spin_unlock(& lock->__annonCompField18.rlock);
  }
#line 344
  return;
}
}
#line 346
__inline static void spin_unlock_bh(spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 346 "../../../analyzer/../bench/linux-headers/include/linux/spinlock.h"
__inline static void spin_unlock_bh(spinlock_t *lock ) 
{ 


  {
  {
#line 348
  _raw_spin_unlock_bh(& lock->__annonCompField18.rlock);
  }
#line 349
  return;
}
}
#line 351
__inline static void spin_unlock_irq(spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 351 "../../../analyzer/../bench/linux-headers/include/linux/spinlock.h"
__inline static void spin_unlock_irq(spinlock_t *lock ) 
{ 


  {
  {
#line 353
  __raw_spin_unlock_irq(& lock->__annonCompField18.rlock);
  }
#line 354
  return;
}
}
#line 356
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags )  __attribute__((__no_instrument_function__)) ;
#line 356 "../../../analyzer/../bench/linux-headers/include/linux/spinlock.h"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 
  unsigned long __dummy ;
  unsigned long __dummy2 ;

  {
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 358
    _raw_spin_unlock_irqrestore(& lock->__annonCompField18.rlock, flags);
    }
#line 358
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 359
  return;
}
}
#line 361
__inline static int spin_trylock_bh(spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 361 "../../../analyzer/../bench/linux-headers/include/linux/spinlock.h"
__inline static int spin_trylock_bh(spinlock_t *lock ) 
{ 
  int tmp ;

  {
  {
#line 363
  tmp = _raw_spin_trylock_bh(& lock->__annonCompField18.rlock);
  }
#line 363
  return (tmp);
}
}
#line 366
__inline static int spin_trylock_irq(spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 366 "../../../analyzer/../bench/linux-headers/include/linux/spinlock.h"
__inline static int spin_trylock_irq(spinlock_t *lock ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 368
    arch_local_irq_disable();
    }
    {
#line 368
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 368
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 368
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 368
  tmp___1 = _raw_spin_trylock(& lock->__annonCompField18.rlock);
  }
#line 368
  if (tmp___1) {
    {
#line 368
    tmp___0 = 1;
    }
  } else {
    {
#line 368
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 368
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 368
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 368
      arch_local_irq_enable();
      }
#line 368
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 368
    tmp___0 = 0;
    }
  }
#line 368
  return (tmp___0);
}
}
#line 376
__inline static void spin_unlock_wait(spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 376 "../../../analyzer/../bench/linux-headers/include/linux/spinlock.h"
__inline static void spin_unlock_wait(spinlock_t *lock ) 
{ 


  {
  {
#line 378
  arch_spin_unlock_wait(& lock->__annonCompField18.rlock.raw_lock);
  }
#line 379
  return;
}
}
#line 381
__inline static int spin_is_locked(spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 381 "../../../analyzer/../bench/linux-headers/include/linux/spinlock.h"
__inline static int spin_is_locked(spinlock_t *lock ) 
{ 
  int tmp ;

  {
  {
#line 383
  tmp = arch_spin_is_locked(& lock->__annonCompField18.rlock.raw_lock);
  }
#line 383
  return (tmp);
}
}
#line 386
__inline static int spin_is_contended(spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 386 "../../../analyzer/../bench/linux-headers/include/linux/spinlock.h"
__inline static int spin_is_contended(spinlock_t *lock ) 
{ 
  int tmp ;

  {
  {
#line 388
  tmp = arch_spin_is_contended(& lock->__annonCompField18.rlock.raw_lock);
  }
#line 388
  return (tmp);
}
}
#line 391
__inline static int spin_can_lock(spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 391 "../../../analyzer/../bench/linux-headers/include/linux/spinlock.h"
__inline static int spin_can_lock(spinlock_t *lock ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 393
  tmp = arch_spin_is_locked(& lock->__annonCompField18.rlock.raw_lock);
  }
#line 393
  if (tmp) {
    {
#line 393
    tmp___0 = 0;
    }
  } else {
    {
#line 393
    tmp___0 = 1;
    }
  }
#line 393
  return (tmp___0);
}
}
#line 411
extern int _atomic_dec_and_lock(atomic_t *atomic , spinlock_t *lock ) ;
#line 53 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
__inline static void __seqcount_init(seqcount_t *s , char const   *name , struct lock_class_key *key )  __attribute__((__no_instrument_function__)) ;
#line 53 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
__inline static void __seqcount_init(seqcount_t *s , char const   *name , struct lock_class_key *key ) 
{ 


  {
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 60
  s->sequence = 0U;
  }
#line 61
  return;
}
}
#line 106
__inline static unsigned int __read_seqcount_begin(seqcount_t const   *s )  __attribute__((__no_instrument_function__)) ;
#line 106 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
__inline static unsigned int __read_seqcount_begin(seqcount_t const   *s ) 
{ 
  unsigned int ret ;
  long tmp ;

  {
  repeat: 
  {
#line 111
  ret = (unsigned int )*((unsigned int const volatile   *)(& s->sequence));
#line 112
  tmp = __builtin_expect((long )(! (! (ret & 1U))), 0L);
  }
#line 112
  if (tmp) {
    {
#line 113
    cpu_relax();
    }
#line 114
    goto repeat;
  }
#line 116
  return (ret);
}
}
#line 128
__inline static unsigned int raw_read_seqcount(seqcount_t const   *s )  __attribute__((__no_instrument_function__)) ;
#line 128 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
__inline static unsigned int raw_read_seqcount(seqcount_t const   *s ) 
{ 
  unsigned int ret ;

  {
  {
#line 130
  ret = (unsigned int )*((unsigned int const volatile   *)(& s->sequence));
#line 131
  __asm__  volatile   ("": : : "memory");
  }
#line 132
  return (ret);
}
}
#line 144
__inline static unsigned int raw_read_seqcount_begin(seqcount_t const   *s )  __attribute__((__no_instrument_function__)) ;
#line 144 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
__inline static unsigned int raw_read_seqcount_begin(seqcount_t const   *s ) 
{ 
  unsigned int ret ;
  unsigned int tmp ;

  {
  {
#line 146
  tmp = __read_seqcount_begin(s);
#line 146
  ret = tmp;
#line 147
  __asm__  volatile   ("": : : "memory");
  }
#line 148
  return (ret);
}
}
#line 160
__inline static unsigned int read_seqcount_begin(seqcount_t const   *s )  __attribute__((__no_instrument_function__)) ;
#line 160 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
__inline static unsigned int read_seqcount_begin(seqcount_t const   *s ) 
{ 
  unsigned int tmp ;

  {
  {
#line 163
  tmp = raw_read_seqcount_begin(s);
  }
#line 163
  return (tmp);
}
}
#line 180
__inline static unsigned int raw_seqcount_begin(seqcount_t const   *s )  __attribute__((__no_instrument_function__)) ;
#line 180 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
__inline static unsigned int raw_seqcount_begin(seqcount_t const   *s ) 
{ 
  unsigned int ret ;

  {
  {
#line 182
  ret = (unsigned int )*((unsigned int const volatile   *)(& s->sequence));
#line 183
  __asm__  volatile   ("": : : "memory");
  }
#line 184
  return (ret & 4294967294U);
}
}
#line 201
__inline static int __read_seqcount_retry(seqcount_t const   *s , unsigned int start )  __attribute__((__no_instrument_function__)) ;
#line 201 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
__inline static int __read_seqcount_retry(seqcount_t const   *s , unsigned int start ) 
{ 
  long tmp ;

  {
  {
#line 203
  tmp = __builtin_expect((long )(! (! (s->sequence != (unsigned int const   )start))),
                         0L);
  }
#line 203
  return ((int )tmp);
}
}
#line 216
__inline static int read_seqcount_retry(seqcount_t const   *s , unsigned int start )  __attribute__((__no_instrument_function__)) ;
#line 216 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
__inline static int read_seqcount_retry(seqcount_t const   *s , unsigned int start ) 
{ 
  int tmp ;

  {
  {
#line 218
  __asm__  volatile   ("": : : "memory");
#line 219
  tmp = __read_seqcount_retry(s, start);
  }
#line 219
  return (tmp);
}
}
#line 224
__inline static void raw_write_seqcount_begin(seqcount_t *s )  __attribute__((__no_instrument_function__)) ;
#line 224 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
__inline static void raw_write_seqcount_begin(seqcount_t *s ) 
{ 


  {
  {
#line 226
  (s->sequence) ++;
#line 227
  __asm__  volatile   ("": : : "memory");
  }
#line 228
  return;
}
}
#line 230
__inline static void raw_write_seqcount_end(seqcount_t *s )  __attribute__((__no_instrument_function__)) ;
#line 230 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
__inline static void raw_write_seqcount_end(seqcount_t *s ) 
{ 


  {
  {
#line 232
  __asm__  volatile   ("": : : "memory");
#line 233
  (s->sequence) ++;
  }
#line 234
  return;
}
}
#line 240
__inline static void raw_write_seqcount_latch(seqcount_t *s )  __attribute__((__no_instrument_function__)) ;
#line 240 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
__inline static void raw_write_seqcount_latch(seqcount_t *s ) 
{ 


  {
  {
#line 242
  __asm__  volatile   ("": : : "memory");
#line 243
  (s->sequence) ++;
#line 244
  __asm__  volatile   ("": : : "memory");
  }
#line 245
  return;
}
}
#line 251
__inline static void write_seqcount_begin_nested(seqcount_t *s , int subclass )  __attribute__((__no_instrument_function__)) ;
#line 251 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
__inline static void write_seqcount_begin_nested(seqcount_t *s , int subclass ) 
{ 


  {
  {
#line 253
  raw_write_seqcount_begin(s);
  }
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;
#line 254
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  return;
}
}
#line 257
__inline static void write_seqcount_begin(seqcount_t *s )  __attribute__((__no_instrument_function__)) ;
#line 257 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
__inline static void write_seqcount_begin(seqcount_t *s ) 
{ 


  {
  {
#line 259
  write_seqcount_begin_nested(s, 0);
  }
#line 260
  return;
}
}
#line 262
__inline static void write_seqcount_end(seqcount_t *s )  __attribute__((__no_instrument_function__)) ;
#line 262 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
__inline static void write_seqcount_end(seqcount_t *s ) 
{ 


  {
  {
#line 264
  while (1) {
    while_continue: /* CIL Label */ ;
#line 264
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 265
  raw_write_seqcount_end(s);
  }
#line 266
  return;
}
}
#line 275
__inline static void write_seqcount_barrier(seqcount_t *s )  __attribute__((__no_instrument_function__)) ;
#line 275 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
__inline static void write_seqcount_barrier(seqcount_t *s ) 
{ 


  {
  {
#line 277
  __asm__  volatile   ("": : : "memory");
#line 278
  s->sequence += 2U;
  }
#line 279
  return;
}
}
#line 308
__inline static unsigned int read_seqbegin(seqlock_t const   *sl )  __attribute__((__no_instrument_function__)) ;
#line 308 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
__inline static unsigned int read_seqbegin(seqlock_t const   *sl ) 
{ 
  unsigned int tmp ;

  {
  {
#line 310
  tmp = read_seqcount_begin(& sl->seqcount);
  }
#line 310
  return (tmp);
}
}
#line 313
__inline static unsigned int read_seqretry(seqlock_t const   *sl , unsigned int start )  __attribute__((__no_instrument_function__)) ;
#line 313 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
__inline static unsigned int read_seqretry(seqlock_t const   *sl , unsigned int start ) 
{ 
  int tmp ;

  {
  {
#line 315
  tmp = read_seqcount_retry(& sl->seqcount, start);
  }
#line 315
  return ((unsigned int )tmp);
}
}
#line 323
__inline static void write_seqlock(seqlock_t *sl )  __attribute__((__no_instrument_function__)) ;
#line 323 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
__inline static void write_seqlock(seqlock_t *sl ) 
{ 


  {
  {
#line 325
  spin_lock(& sl->lock);
#line 326
  write_seqcount_begin(& sl->seqcount);
  }
#line 327
  return;
}
}
#line 329
__inline static void write_sequnlock(seqlock_t *sl )  __attribute__((__no_instrument_function__)) ;
#line 329 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
__inline static void write_sequnlock(seqlock_t *sl ) 
{ 


  {
  {
#line 331
  write_seqcount_end(& sl->seqcount);
#line 332
  spin_unlock(& sl->lock);
  }
#line 333
  return;
}
}
#line 335
__inline static void write_seqlock_bh(seqlock_t *sl )  __attribute__((__no_instrument_function__)) ;
#line 335 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
__inline static void write_seqlock_bh(seqlock_t *sl ) 
{ 


  {
  {
#line 337
  spin_lock_bh(& sl->lock);
#line 338
  write_seqcount_begin(& sl->seqcount);
  }
#line 339
  return;
}
}
#line 341
__inline static void write_sequnlock_bh(seqlock_t *sl )  __attribute__((__no_instrument_function__)) ;
#line 341 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
__inline static void write_sequnlock_bh(seqlock_t *sl ) 
{ 


  {
  {
#line 343
  write_seqcount_end(& sl->seqcount);
#line 344
  spin_unlock_bh(& sl->lock);
  }
#line 345
  return;
}
}
#line 347
__inline static void write_seqlock_irq(seqlock_t *sl )  __attribute__((__no_instrument_function__)) ;
#line 347 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
__inline static void write_seqlock_irq(seqlock_t *sl ) 
{ 


  {
  {
#line 349
  spin_lock_irq(& sl->lock);
#line 350
  write_seqcount_begin(& sl->seqcount);
  }
#line 351
  return;
}
}
#line 353
__inline static void write_sequnlock_irq(seqlock_t *sl )  __attribute__((__no_instrument_function__)) ;
#line 353 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
__inline static void write_sequnlock_irq(seqlock_t *sl ) 
{ 


  {
  {
#line 355
  write_seqcount_end(& sl->seqcount);
#line 356
  spin_unlock_irq(& sl->lock);
  }
#line 357
  return;
}
}
#line 359
__inline static unsigned long __write_seqlock_irqsave(seqlock_t *sl )  __attribute__((__no_instrument_function__)) ;
#line 359 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
__inline static unsigned long __write_seqlock_irqsave(seqlock_t *sl ) 
{ 
  unsigned long flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  raw_spinlock_t *tmp ;

  {
  {
#line 363
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 363
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 363
      tmp = spinlock_check(& sl->lock);
#line 363
      flags = _raw_spin_lock_irqsave(tmp);
      }
#line 363
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 363
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 364
  write_seqcount_begin(& sl->seqcount);
  }
#line 365
  return (flags);
}
}
#line 371
__inline static void write_sequnlock_irqrestore(seqlock_t *sl , unsigned long flags )  __attribute__((__no_instrument_function__)) ;
#line 371 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
__inline static void write_sequnlock_irqrestore(seqlock_t *sl , unsigned long flags ) 
{ 


  {
  {
#line 374
  write_seqcount_end(& sl->seqcount);
#line 375
  spin_unlock_irqrestore(& sl->lock, flags);
  }
#line 376
  return;
}
}
#line 383
__inline static void read_seqlock_excl(seqlock_t *sl )  __attribute__((__no_instrument_function__)) ;
#line 383 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
__inline static void read_seqlock_excl(seqlock_t *sl ) 
{ 


  {
  {
#line 385
  spin_lock(& sl->lock);
  }
#line 386
  return;
}
}
#line 388
__inline static void read_sequnlock_excl(seqlock_t *sl )  __attribute__((__no_instrument_function__)) ;
#line 388 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
__inline static void read_sequnlock_excl(seqlock_t *sl ) 
{ 


  {
  {
#line 390
  spin_unlock(& sl->lock);
  }
#line 391
  return;
}
}
#line 403
__inline static void read_seqbegin_or_lock(seqlock_t *lock , int *seq )  __attribute__((__no_instrument_function__)) ;
#line 403 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
__inline static void read_seqbegin_or_lock(seqlock_t *lock , int *seq ) 
{ 
  unsigned int tmp ;

  {
#line 405
  if (! (*seq & 1)) {
    {
#line 406
    tmp = read_seqbegin((seqlock_t const   *)lock);
#line 406
    *seq = (int )tmp;
    }
  } else {
    {
#line 408
    read_seqlock_excl(lock);
    }
  }
#line 409
  return;
}
}
#line 411
__inline static int need_seqretry(seqlock_t *lock , int seq )  __attribute__((__no_instrument_function__)) ;
#line 411 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
__inline static int need_seqretry(seqlock_t *lock , int seq ) 
{ 
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 413
  if (! (seq & 1)) {
    {
#line 413
    tmp = read_seqretry((seqlock_t const   *)lock, (unsigned int )seq);
    }
#line 413
    if (tmp) {
      {
#line 413
      tmp___0 = 1;
      }
    } else {
      {
#line 413
      tmp___0 = 0;
      }
    }
  } else {
    {
#line 413
    tmp___0 = 0;
    }
  }
#line 413
  return (tmp___0);
}
}
#line 416
__inline static void done_seqretry(seqlock_t *lock , int seq )  __attribute__((__no_instrument_function__)) ;
#line 416 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
__inline static void done_seqretry(seqlock_t *lock , int seq ) 
{ 


  {
#line 418
  if (seq & 1) {
    {
#line 419
    read_sequnlock_excl(lock);
    }
  }
#line 420
  return;
}
}
#line 422
__inline static void read_seqlock_excl_bh(seqlock_t *sl )  __attribute__((__no_instrument_function__)) ;
#line 422 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
__inline static void read_seqlock_excl_bh(seqlock_t *sl ) 
{ 


  {
  {
#line 424
  spin_lock_bh(& sl->lock);
  }
#line 425
  return;
}
}
#line 427
__inline static void read_sequnlock_excl_bh(seqlock_t *sl )  __attribute__((__no_instrument_function__)) ;
#line 427 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
__inline static void read_sequnlock_excl_bh(seqlock_t *sl ) 
{ 


  {
  {
#line 429
  spin_unlock_bh(& sl->lock);
  }
#line 430
  return;
}
}
#line 432
__inline static void read_seqlock_excl_irq(seqlock_t *sl )  __attribute__((__no_instrument_function__)) ;
#line 432 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
__inline static void read_seqlock_excl_irq(seqlock_t *sl ) 
{ 


  {
  {
#line 434
  spin_lock_irq(& sl->lock);
  }
#line 435
  return;
}
}
#line 437
__inline static void read_sequnlock_excl_irq(seqlock_t *sl )  __attribute__((__no_instrument_function__)) ;
#line 437 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
__inline static void read_sequnlock_excl_irq(seqlock_t *sl ) 
{ 


  {
  {
#line 439
  spin_unlock_irq(& sl->lock);
  }
#line 440
  return;
}
}
#line 442
__inline static unsigned long __read_seqlock_excl_irqsave(seqlock_t *sl )  __attribute__((__no_instrument_function__)) ;
#line 442 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
__inline static unsigned long __read_seqlock_excl_irqsave(seqlock_t *sl ) 
{ 
  unsigned long flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  raw_spinlock_t *tmp ;

  {
  {
#line 446
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 446
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 446
      tmp = spinlock_check(& sl->lock);
#line 446
      flags = _raw_spin_lock_irqsave(tmp);
      }
#line 446
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 446
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 447
  return (flags);
}
}
#line 453
__inline static void read_sequnlock_excl_irqrestore(seqlock_t *sl , unsigned long flags )  __attribute__((__no_instrument_function__)) ;
#line 453 "../../../analyzer/../bench/linux-headers/include/linux/seqlock.h"
__inline static void read_sequnlock_excl_irqrestore(seqlock_t *sl , unsigned long flags ) 
{ 


  {
  {
#line 456
  spin_unlock_irqrestore(& sl->lock, flags);
  }
#line 457
  return;
}
}
#line 36 "../../../analyzer/../bench/linux-headers/include/linux/time64.h"
__inline static struct timespec timespec64_to_timespec(struct timespec  const  ts64 )  __attribute__((__no_instrument_function__)) ;
#line 36 "../../../analyzer/../bench/linux-headers/include/linux/time64.h"
__inline static struct timespec timespec64_to_timespec(struct timespec  const  ts64 ) 
{ 


  {
#line 38
  return ((struct timespec )ts64);
}
}
#line 41
__inline static struct timespec timespec_to_timespec64(struct timespec  const  ts )  __attribute__((__no_instrument_function__)) ;
#line 41 "../../../analyzer/../bench/linux-headers/include/linux/time64.h"
__inline static struct timespec timespec_to_timespec64(struct timespec  const  ts ) 
{ 


  {
#line 43
  return ((struct timespec )ts);
}
}
#line 9 "../../../analyzer/../bench/linux-headers/include/linux/time.h"
extern struct timezone sys_tz ;
#line 13
__inline static int timespec_equal(struct timespec  const  *a , struct timespec  const  *b )  __attribute__((__no_instrument_function__)) ;
#line 13 "../../../analyzer/../bench/linux-headers/include/linux/time.h"
__inline static int timespec_equal(struct timespec  const  *a , struct timespec  const  *b ) 
{ 
  int tmp ;

  {
#line 16
  if (a->tv_sec == b->tv_sec) {
#line 16
    if (a->tv_nsec == b->tv_nsec) {
      {
#line 16
      tmp = 1;
      }
    } else {
      {
#line 16
      tmp = 0;
      }
    }
  } else {
    {
#line 16
    tmp = 0;
    }
  }
#line 16
  return (tmp);
}
}
#line 24
__inline static int timespec_compare(struct timespec  const  *lhs , struct timespec  const  *rhs )  __attribute__((__no_instrument_function__)) ;
#line 24 "../../../analyzer/../bench/linux-headers/include/linux/time.h"
__inline static int timespec_compare(struct timespec  const  *lhs , struct timespec  const  *rhs ) 
{ 


  {
#line 26
  if (lhs->tv_sec < rhs->tv_sec) {
#line 27
    return (-1);
  }
#line 28
  if (lhs->tv_sec > rhs->tv_sec) {
#line 29
    return (1);
  }
#line 30
  return ((int )(lhs->tv_nsec - rhs->tv_nsec));
}
}
#line 33
__inline static int timeval_compare(struct timeval  const  *lhs , struct timeval  const  *rhs )  __attribute__((__no_instrument_function__)) ;
#line 33 "../../../analyzer/../bench/linux-headers/include/linux/time.h"
__inline static int timeval_compare(struct timeval  const  *lhs , struct timeval  const  *rhs ) 
{ 


  {
#line 35
  if (lhs->tv_sec < rhs->tv_sec) {
#line 36
    return (-1);
  }
#line 37
  if (lhs->tv_sec > rhs->tv_sec) {
#line 38
    return (1);
  }
#line 39
  return ((int )(lhs->tv_usec - rhs->tv_usec));
}
}
#line 42
extern unsigned long mktime(unsigned int const   year , unsigned int const   mon ,
                            unsigned int const   day , unsigned int const   hour ,
                            unsigned int const   min , unsigned int const   sec ) ;
#line 46
extern void set_normalized_timespec(struct timespec *ts , time_t sec , s64 nsec ) ;
#line 53
extern struct timespec timespec_add_safe(struct timespec  const  lhs , struct timespec  const  rhs ) ;
#line 57
__inline static struct timespec timespec_add(struct timespec lhs , struct timespec rhs )  __attribute__((__no_instrument_function__)) ;
#line 57 "../../../analyzer/../bench/linux-headers/include/linux/time.h"
__inline static struct timespec timespec_add(struct timespec lhs , struct timespec rhs ) 
{ 
  struct timespec ts_delta ;

  {
  {
#line 61
  set_normalized_timespec(& ts_delta, lhs.tv_sec + rhs.tv_sec, (s64 )(lhs.tv_nsec + rhs.tv_nsec));
  }
#line 63
  return (ts_delta);
}
}
#line 69
__inline static struct timespec timespec_sub(struct timespec lhs , struct timespec rhs )  __attribute__((__no_instrument_function__)) ;
#line 69 "../../../analyzer/../bench/linux-headers/include/linux/time.h"
__inline static struct timespec timespec_sub(struct timespec lhs , struct timespec rhs ) 
{ 
  struct timespec ts_delta ;

  {
  {
#line 73
  set_normalized_timespec(& ts_delta, lhs.tv_sec - rhs.tv_sec, (s64 )(lhs.tv_nsec - rhs.tv_nsec));
  }
#line 75
  return (ts_delta);
}
}
#line 81
__inline static bool timespec_valid(struct timespec  const  *ts )  __attribute__((__no_instrument_function__)) ;
#line 81 "../../../analyzer/../bench/linux-headers/include/linux/time.h"
__inline static bool timespec_valid(struct timespec  const  *ts ) 
{ 


  {
#line 84
  if (ts->tv_sec < 0L) {
#line 85
    return ((bool )0);
  }
#line 87
  if ((unsigned long )ts->tv_nsec >= 1000000000UL) {
#line 88
    return ((bool )0);
  }
#line 89
  return ((bool )1);
}
}
#line 92
__inline static bool timespec_valid_strict(struct timespec  const  *ts )  __attribute__((__no_instrument_function__)) ;
#line 92 "../../../analyzer/../bench/linux-headers/include/linux/time.h"
__inline static bool timespec_valid_strict(struct timespec  const  *ts ) 
{ 
  bool tmp ;

  {
  {
#line 94
  tmp = timespec_valid(ts);
  }
#line 94
  if (! tmp) {
#line 95
    return ((bool )0);
  }
#line 97
  if ((unsigned long long )ts->tv_sec >= (unsigned long long )((s64 )(~ (1ULL << 63)) / 1000000000LL)) {
#line 98
    return ((bool )0);
  }
#line 99
  return ((bool )1);
}
}
#line 102
extern struct timespec timespec_trunc(struct timespec t , unsigned int gran ) ;
#line 121
extern int do_setitimer(int which , struct itimerval *value , struct itimerval *ovalue ) ;
#line 123
extern int do_getitimer(int which , struct itimerval *value ) ;
#line 125
extern unsigned int alarm_setitimer(unsigned int seconds ) ;
#line 127
extern long do_utimes(int dfd , char const   *filename , struct timespec *times ,
                      int flags ) ;
#line 130
extern void do_sys_times(struct tms * ) ;
#line 158
extern void time_to_tm(time_t totalsecs , int offset , struct tm *result ) ;
#line 167
__inline static s64 timespec_to_ns(struct timespec  const  *ts )  __attribute__((__no_instrument_function__)) ;
#line 167 "../../../analyzer/../bench/linux-headers/include/linux/time.h"
__inline static s64 timespec_to_ns(struct timespec  const  *ts ) 
{ 


  {
#line 169
  return ((s64 )ts->tv_sec * 1000000000LL + (s64 )ts->tv_nsec);
}
}
#line 179
__inline static s64 timeval_to_ns(struct timeval  const  *tv )  __attribute__((__no_instrument_function__)) ;
#line 179 "../../../analyzer/../bench/linux-headers/include/linux/time.h"
__inline static s64 timeval_to_ns(struct timeval  const  *tv ) 
{ 


  {
#line 181
  return ((s64 )tv->tv_sec * 1000000000LL + (s64 )(tv->tv_usec * 1000L));
}
}
#line 191
extern struct timespec ns_to_timespec(s64 const   nsec ) ;
#line 199
extern struct timeval ns_to_timeval(s64 const   nsec ) ;
#line 209
__inline static void ( __attribute__((__always_inline__)) timespec_add_ns)(struct timespec *a ,
                                                                           u64 ns )  __attribute__((__no_instrument_function__)) ;
#line 209 "../../../analyzer/../bench/linux-headers/include/linux/time.h"
__inline static void ( __attribute__((__always_inline__)) timespec_add_ns)(struct timespec *a ,
                                                                           u64 ns ) 
{ 
  u32 tmp ;

  {
  {
#line 211
  tmp = __iter_div_u64_rem((u64 )a->tv_nsec + ns, (u32 )1000000000L, & ns);
#line 211
  a->tv_sec += (__kernel_time_t )tmp;
#line 212
  a->tv_nsec = (long )ns;
  }
#line 213
  return;
}
}
#line 34 "../../../analyzer/../bench/linux-headers/include/linux/highuid.h"
extern int overflowuid ;
#line 35
extern int overflowgid ;
#line 37
extern void __bad_uid(void) ;
#line 38
extern void __bad_gid(void) ;
#line 81
extern int fs_overflowuid ;
#line 82
extern int fs_overflowgid ;
#line 18 "../../../analyzer/../bench/linux-headers/include/linux/uidgid.h"
extern struct user_namespace init_user_ns ;
#line 32
__inline static uid_t __kuid_val(kuid_t uid )  __attribute__((__no_instrument_function__)) ;
#line 32 "../../../analyzer/../bench/linux-headers/include/linux/uidgid.h"
__inline static uid_t __kuid_val(kuid_t uid ) 
{ 


  {
#line 34
  return (uid.val);
}
}
#line 37
__inline static gid_t __kgid_val(kgid_t gid )  __attribute__((__no_instrument_function__)) ;
#line 37 "../../../analyzer/../bench/linux-headers/include/linux/uidgid.h"
__inline static gid_t __kgid_val(kgid_t gid ) 
{ 


  {
#line 39
  return (gid.val);
}
}
#line 48
__inline static bool uid_eq(kuid_t left , kuid_t right )  __attribute__((__no_instrument_function__)) ;
#line 48 "../../../analyzer/../bench/linux-headers/include/linux/uidgid.h"
__inline static bool uid_eq(kuid_t left , kuid_t right ) 
{ 
  uid_t tmp ;
  uid_t tmp___0 ;

  {
  {
#line 50
  tmp = __kuid_val(left);
#line 50
  tmp___0 = __kuid_val(right);
  }
#line 50
  return ((bool )(tmp == tmp___0));
}
}
#line 53
__inline static bool gid_eq(kgid_t left , kgid_t right )  __attribute__((__no_instrument_function__)) ;
#line 53 "../../../analyzer/../bench/linux-headers/include/linux/uidgid.h"
__inline static bool gid_eq(kgid_t left , kgid_t right ) 
{ 
  gid_t tmp ;
  gid_t tmp___0 ;

  {
  {
#line 55
  tmp = __kgid_val(left);
#line 55
  tmp___0 = __kgid_val(right);
  }
#line 55
  return ((bool )(tmp == tmp___0));
}
}
#line 58
__inline static bool uid_gt(kuid_t left , kuid_t right )  __attribute__((__no_instrument_function__)) ;
#line 58 "../../../analyzer/../bench/linux-headers/include/linux/uidgid.h"
__inline static bool uid_gt(kuid_t left , kuid_t right ) 
{ 
  uid_t tmp ;
  uid_t tmp___0 ;

  {
  {
#line 60
  tmp = __kuid_val(left);
#line 60
  tmp___0 = __kuid_val(right);
  }
#line 60
  return ((bool )(tmp > tmp___0));
}
}
#line 63
__inline static bool gid_gt(kgid_t left , kgid_t right )  __attribute__((__no_instrument_function__)) ;
#line 63 "../../../analyzer/../bench/linux-headers/include/linux/uidgid.h"
__inline static bool gid_gt(kgid_t left , kgid_t right ) 
{ 
  gid_t tmp ;
  gid_t tmp___0 ;

  {
  {
#line 65
  tmp = __kgid_val(left);
#line 65
  tmp___0 = __kgid_val(right);
  }
#line 65
  return ((bool )(tmp > tmp___0));
}
}
#line 68
__inline static bool uid_gte(kuid_t left , kuid_t right )  __attribute__((__no_instrument_function__)) ;
#line 68 "../../../analyzer/../bench/linux-headers/include/linux/uidgid.h"
__inline static bool uid_gte(kuid_t left , kuid_t right ) 
{ 
  uid_t tmp ;
  uid_t tmp___0 ;

  {
  {
#line 70
  tmp = __kuid_val(left);
#line 70
  tmp___0 = __kuid_val(right);
  }
#line 70
  return ((bool )(tmp >= tmp___0));
}
}
#line 73
__inline static bool gid_gte(kgid_t left , kgid_t right )  __attribute__((__no_instrument_function__)) ;
#line 73 "../../../analyzer/../bench/linux-headers/include/linux/uidgid.h"
__inline static bool gid_gte(kgid_t left , kgid_t right ) 
{ 
  gid_t tmp ;
  gid_t tmp___0 ;

  {
  {
#line 75
  tmp = __kgid_val(left);
#line 75
  tmp___0 = __kgid_val(right);
  }
#line 75
  return ((bool )(tmp >= tmp___0));
}
}
#line 78
__inline static bool uid_lt(kuid_t left , kuid_t right )  __attribute__((__no_instrument_function__)) ;
#line 78 "../../../analyzer/../bench/linux-headers/include/linux/uidgid.h"
__inline static bool uid_lt(kuid_t left , kuid_t right ) 
{ 
  uid_t tmp ;
  uid_t tmp___0 ;

  {
  {
#line 80
  tmp = __kuid_val(left);
#line 80
  tmp___0 = __kuid_val(right);
  }
#line 80
  return ((bool )(tmp < tmp___0));
}
}
#line 83
__inline static bool gid_lt(kgid_t left , kgid_t right )  __attribute__((__no_instrument_function__)) ;
#line 83 "../../../analyzer/../bench/linux-headers/include/linux/uidgid.h"
__inline static bool gid_lt(kgid_t left , kgid_t right ) 
{ 
  gid_t tmp ;
  gid_t tmp___0 ;

  {
  {
#line 85
  tmp = __kgid_val(left);
#line 85
  tmp___0 = __kgid_val(right);
  }
#line 85
  return ((bool )(tmp < tmp___0));
}
}
#line 88
__inline static bool uid_lte(kuid_t left , kuid_t right )  __attribute__((__no_instrument_function__)) ;
#line 88 "../../../analyzer/../bench/linux-headers/include/linux/uidgid.h"
__inline static bool uid_lte(kuid_t left , kuid_t right ) 
{ 
  uid_t tmp ;
  uid_t tmp___0 ;

  {
  {
#line 90
  tmp = __kuid_val(left);
#line 90
  tmp___0 = __kuid_val(right);
  }
#line 90
  return ((bool )(tmp <= tmp___0));
}
}
#line 93
__inline static bool gid_lte(kgid_t left , kgid_t right )  __attribute__((__no_instrument_function__)) ;
#line 93 "../../../analyzer/../bench/linux-headers/include/linux/uidgid.h"
__inline static bool gid_lte(kgid_t left , kgid_t right ) 
{ 
  gid_t tmp ;
  gid_t tmp___0 ;

  {
  {
#line 95
  tmp = __kgid_val(left);
#line 95
  tmp___0 = __kgid_val(right);
  }
#line 95
  return ((bool )(tmp <= tmp___0));
}
}
#line 98
__inline static bool uid_valid(kuid_t uid )  __attribute__((__no_instrument_function__)) ;
#line 98 "../../../analyzer/../bench/linux-headers/include/linux/uidgid.h"
__inline static bool uid_valid(kuid_t uid ) 
{ 
  kuid_t __constr_expr_4 ;
  bool tmp ;
  int tmp___0 ;

  {
  {
#line 100
  __constr_expr_4.val = (uid_t )-1;
#line 100
  tmp = uid_eq(uid, __constr_expr_4);
  }
#line 100
  if (tmp) {
    {
#line 100
    tmp___0 = 0;
    }
  } else {
    {
#line 100
    tmp___0 = 1;
    }
  }
#line 100
  return ((bool )tmp___0);
}
}
#line 103
__inline static bool gid_valid(kgid_t gid )  __attribute__((__no_instrument_function__)) ;
#line 103 "../../../analyzer/../bench/linux-headers/include/linux/uidgid.h"
__inline static bool gid_valid(kgid_t gid ) 
{ 
  kgid_t __constr_expr_5 ;
  bool tmp ;
  int tmp___0 ;

  {
  {
#line 105
  __constr_expr_5.val = (gid_t )-1;
#line 105
  tmp = gid_eq(gid, __constr_expr_5);
  }
#line 105
  if (tmp) {
    {
#line 105
    tmp___0 = 0;
    }
  } else {
    {
#line 105
    tmp___0 = 1;
    }
  }
#line 105
  return ((bool )tmp___0);
}
}
#line 130
__inline static kuid_t make_kuid(struct user_namespace *from , uid_t uid )  __attribute__((__no_instrument_function__)) ;
#line 130 "../../../analyzer/../bench/linux-headers/include/linux/uidgid.h"
__inline static kuid_t make_kuid(struct user_namespace *from , uid_t uid ) 
{ 
  kuid_t __constr_expr_6 ;

  {
  {
#line 132
  __constr_expr_6.val = uid;
  }
#line 132
  return (__constr_expr_6);
}
}
#line 135
__inline static kgid_t make_kgid(struct user_namespace *from , gid_t gid )  __attribute__((__no_instrument_function__)) ;
#line 135 "../../../analyzer/../bench/linux-headers/include/linux/uidgid.h"
__inline static kgid_t make_kgid(struct user_namespace *from , gid_t gid ) 
{ 
  kgid_t __constr_expr_7 ;

  {
  {
#line 137
  __constr_expr_7.val = gid;
  }
#line 137
  return (__constr_expr_7);
}
}
#line 140
__inline static uid_t from_kuid(struct user_namespace *to , kuid_t kuid )  __attribute__((__no_instrument_function__)) ;
#line 140 "../../../analyzer/../bench/linux-headers/include/linux/uidgid.h"
__inline static uid_t from_kuid(struct user_namespace *to , kuid_t kuid ) 
{ 
  uid_t tmp ;

  {
  {
#line 142
  tmp = __kuid_val(kuid);
  }
#line 142
  return (tmp);
}
}
#line 145
__inline static gid_t from_kgid(struct user_namespace *to , kgid_t kgid )  __attribute__((__no_instrument_function__)) ;
#line 145 "../../../analyzer/../bench/linux-headers/include/linux/uidgid.h"
__inline static gid_t from_kgid(struct user_namespace *to , kgid_t kgid ) 
{ 
  gid_t tmp ;

  {
  {
#line 147
  tmp = __kgid_val(kgid);
  }
#line 147
  return (tmp);
}
}
#line 150
__inline static uid_t from_kuid_munged(struct user_namespace *to , kuid_t kuid )  __attribute__((__no_instrument_function__)) ;
#line 150 "../../../analyzer/../bench/linux-headers/include/linux/uidgid.h"
__inline static uid_t from_kuid_munged(struct user_namespace *to , kuid_t kuid ) 
{ 
  uid_t uid ;
  uid_t tmp ;

  {
  {
#line 152
  tmp = from_kuid(to, kuid);
#line 152
  uid = tmp;
  }
#line 153
  if (uid == 4294967295U) {
    {
#line 154
    uid = (uid_t )overflowuid;
    }
  }
#line 155
  return (uid);
}
}
#line 158
__inline static gid_t from_kgid_munged(struct user_namespace *to , kgid_t kgid )  __attribute__((__no_instrument_function__)) ;
#line 158 "../../../analyzer/../bench/linux-headers/include/linux/uidgid.h"
__inline static gid_t from_kgid_munged(struct user_namespace *to , kgid_t kgid ) 
{ 
  gid_t gid ;
  gid_t tmp ;

  {
  {
#line 160
  tmp = from_kgid(to, kgid);
#line 160
  gid = tmp;
  }
#line 161
  if (gid == 4294967295U) {
    {
#line 162
    gid = (gid_t )overflowgid;
    }
  }
#line 163
  return (gid);
}
}
#line 166
__inline static bool kuid_has_mapping(struct user_namespace *ns , kuid_t uid )  __attribute__((__no_instrument_function__)) ;
#line 166 "../../../analyzer/../bench/linux-headers/include/linux/uidgid.h"
__inline static bool kuid_has_mapping(struct user_namespace *ns , kuid_t uid ) 
{ 


  {
#line 168
  return ((bool )1);
}
}
#line 171
__inline static bool kgid_has_mapping(struct user_namespace *ns , kgid_t gid )  __attribute__((__no_instrument_function__)) ;
#line 171 "../../../analyzer/../bench/linux-headers/include/linux/uidgid.h"
__inline static bool kgid_has_mapping(struct user_namespace *ns , kgid_t gid ) 
{ 


  {
#line 173
  return ((bool )1);
}
}
#line 8 "../../../analyzer/../bench/linux-headers/include/linux/mmdebug.h"
extern void dump_page(struct page *page , char const   *reason ) ;
#line 9
extern void dump_page_badflags(struct page *page , char const   *reason , unsigned long badflags ) ;
#line 14 "../../../analyzer/../bench/linux-headers/include/linux/wait.h"
extern int default_wake_function(wait_queue_t *wait , unsigned int mode , int flags ,
                                 void *key ) ;
#line 69
extern void __init_waitqueue_head(wait_queue_head_t *q , char const   *name , struct lock_class_key * ) ;
#line 87
__inline static void init_waitqueue_entry(wait_queue_t *q , struct task_struct *p )  __attribute__((__no_instrument_function__)) ;
#line 87 "../../../analyzer/../bench/linux-headers/include/linux/wait.h"
__inline static void init_waitqueue_entry(wait_queue_t *q , struct task_struct *p ) 
{ 


  {
  {
#line 89
  q->flags = 0U;
#line 90
  q->private = (void *)p;
#line 91
  q->func = & default_wake_function;
  }
#line 92
  return;
}
}
#line 94
__inline static void init_waitqueue_func_entry(wait_queue_t *q , int (*func)(wait_queue_t *wait ,
                                                                             unsigned int mode ,
                                                                             int flags ,
                                                                             void *key ) )  __attribute__((__no_instrument_function__)) ;
#line 94 "../../../analyzer/../bench/linux-headers/include/linux/wait.h"
__inline static void init_waitqueue_func_entry(wait_queue_t *q , int (*func)(wait_queue_t *wait ,
                                                                             unsigned int mode ,
                                                                             int flags ,
                                                                             void *key ) ) 
{ 


  {
  {
#line 97
  q->flags = 0U;
#line 98
  q->private = (void *)0;
#line 99
  q->func = func;
  }
#line 100
  return;
}
}
#line 102
__inline static int waitqueue_active(wait_queue_head_t *q )  __attribute__((__no_instrument_function__)) ;
#line 102 "../../../analyzer/../bench/linux-headers/include/linux/wait.h"
__inline static int waitqueue_active(wait_queue_head_t *q ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 104
  tmp = list_empty((struct list_head  const  *)(& q->task_list));
  }
#line 104
  if (tmp) {
    {
#line 104
    tmp___0 = 0;
    }
  } else {
    {
#line 104
    tmp___0 = 1;
    }
  }
#line 104
  return (tmp___0);
}
}
#line 107
extern void add_wait_queue(wait_queue_head_t *q , wait_queue_t *wait ) ;
#line 108
extern void add_wait_queue_exclusive(wait_queue_head_t *q , wait_queue_t *wait ) ;
#line 109
extern void remove_wait_queue(wait_queue_head_t *q , wait_queue_t *wait ) ;
#line 111
__inline static void __add_wait_queue(wait_queue_head_t *head , wait_queue_t *new )  __attribute__((__no_instrument_function__)) ;
#line 111 "../../../analyzer/../bench/linux-headers/include/linux/wait.h"
__inline static void __add_wait_queue(wait_queue_head_t *head , wait_queue_t *new ) 
{ 


  {
  {
#line 113
  list_add(& new->task_list, & head->task_list);
  }
#line 114
  return;
}
}
#line 119
__inline static void __add_wait_queue_exclusive(wait_queue_head_t *q , wait_queue_t *wait )  __attribute__((__no_instrument_function__)) ;
#line 119 "../../../analyzer/../bench/linux-headers/include/linux/wait.h"
__inline static void __add_wait_queue_exclusive(wait_queue_head_t *q , wait_queue_t *wait ) 
{ 


  {
  {
#line 122
  wait->flags |= 1U;
#line 123
  __add_wait_queue(q, wait);
  }
#line 124
  return;
}
}
#line 126
__inline static void __add_wait_queue_tail(wait_queue_head_t *head , wait_queue_t *new )  __attribute__((__no_instrument_function__)) ;
#line 126 "../../../analyzer/../bench/linux-headers/include/linux/wait.h"
__inline static void __add_wait_queue_tail(wait_queue_head_t *head , wait_queue_t *new ) 
{ 


  {
  {
#line 129
  list_add_tail(& new->task_list, & head->task_list);
  }
#line 130
  return;
}
}
#line 132
__inline static void __add_wait_queue_tail_exclusive(wait_queue_head_t *q , wait_queue_t *wait )  __attribute__((__no_instrument_function__)) ;
#line 132 "../../../analyzer/../bench/linux-headers/include/linux/wait.h"
__inline static void __add_wait_queue_tail_exclusive(wait_queue_head_t *q , wait_queue_t *wait ) 
{ 


  {
  {
#line 135
  wait->flags |= 1U;
#line 136
  __add_wait_queue_tail(q, wait);
  }
#line 137
  return;
}
}
#line 139
__inline static void __remove_wait_queue(wait_queue_head_t *head , wait_queue_t *old )  __attribute__((__no_instrument_function__)) ;
#line 139 "../../../analyzer/../bench/linux-headers/include/linux/wait.h"
__inline static void __remove_wait_queue(wait_queue_head_t *head , wait_queue_t *old ) 
{ 


  {
  {
#line 142
  list_del(& old->task_list);
  }
#line 143
  return;
}
}
#line 146
extern void __wake_up(wait_queue_head_t *q , unsigned int mode , int nr , void *key ) ;
#line 147
extern void __wake_up_locked_key(wait_queue_head_t *q , unsigned int mode , void *key ) ;
#line 148
extern void __wake_up_sync_key(wait_queue_head_t *q , unsigned int mode , int nr ,
                               void *key ) ;
#line 149
extern void __wake_up_locked(wait_queue_head_t *q , unsigned int mode , int nr ) ;
#line 150
extern void __wake_up_sync(wait_queue_head_t *q , unsigned int mode , int nr ) ;
#line 151
extern void __wake_up_bit(wait_queue_head_t * , void * , int  ) ;
#line 152
extern int __wait_on_bit(wait_queue_head_t * , struct wait_bit_queue * , wait_bit_action_f * ,
                         unsigned int  ) ;
#line 153
extern int __wait_on_bit_lock(wait_queue_head_t * , struct wait_bit_queue * , wait_bit_action_f * ,
                              unsigned int  ) ;
#line 154
extern void wake_up_bit(void * , int  ) ;
#line 155
extern void wake_up_atomic_t(atomic_t * ) ;
#line 156
extern int out_of_line_wait_on_bit(void * , int  , wait_bit_action_f * , unsigned int  ) ;
#line 157
extern int out_of_line_wait_on_bit_lock(void * , int  , wait_bit_action_f * , unsigned int  ) ;
#line 158
extern int out_of_line_wait_on_atomic_t(atomic_t * , int (*)(atomic_t * ) , unsigned int  ) ;
#line 159
extern wait_queue_head_t *bit_waitqueue(void * , int  ) ;
#line 823
extern void prepare_to_wait(wait_queue_head_t *q , wait_queue_t *wait , int state ) ;
#line 824
extern void prepare_to_wait_exclusive(wait_queue_head_t *q , wait_queue_t *wait ,
                                      int state ) ;
#line 825
extern long prepare_to_wait_event(wait_queue_head_t *q , wait_queue_t *wait , int state ) ;
#line 826
extern void finish_wait(wait_queue_head_t *q , wait_queue_t *wait ) ;
#line 827
extern void abort_exclusive_wait(wait_queue_head_t *q , wait_queue_t *wait , unsigned int mode ,
                                 void *key ) ;
#line 828
extern int autoremove_wake_function(wait_queue_t *wait , unsigned int mode , int sync ,
                                    void *key ) ;
#line 829
extern int wake_bit_function(wait_queue_t *wait , unsigned int mode , int sync , void *key ) ;
#line 860
extern int bit_wait(struct wait_bit_key * ) ;
#line 861
extern int bit_wait_io(struct wait_bit_key * ) ;
#line 879
__inline static int wait_on_bit(void *word , int bit , unsigned int mode )  __attribute__((__no_instrument_function__)) ;
#line 879 "../../../analyzer/../bench/linux-headers/include/linux/wait.h"
__inline static int wait_on_bit(void *word , int bit , unsigned int mode ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 882
  tmp___0 = variable_test_bit((long )bit, (unsigned long const volatile   *)word);
  }
#line 882
  if (! tmp___0) {
#line 883
    return (0);
  }
  {
#line 884
  tmp___1 = out_of_line_wait_on_bit(word, bit, & bit_wait, mode);
  }
#line 884
  return (tmp___1);
}
}
#line 903
__inline static int wait_on_bit_io(void *word , int bit , unsigned int mode )  __attribute__((__no_instrument_function__)) ;
#line 903 "../../../analyzer/../bench/linux-headers/include/linux/wait.h"
__inline static int wait_on_bit_io(void *word , int bit , unsigned int mode ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 906
  tmp___0 = variable_test_bit((long )bit, (unsigned long const volatile   *)word);
  }
#line 906
  if (! tmp___0) {
#line 907
    return (0);
  }
  {
#line 908
  tmp___1 = out_of_line_wait_on_bit(word, bit, & bit_wait_io, mode);
  }
#line 908
  return (tmp___1);
}
}
#line 929
__inline static int wait_on_bit_action(void *word , int bit , wait_bit_action_f *action ,
                                       unsigned int mode )  __attribute__((__no_instrument_function__)) ;
#line 929 "../../../analyzer/../bench/linux-headers/include/linux/wait.h"
__inline static int wait_on_bit_action(void *word , int bit , wait_bit_action_f *action ,
                                       unsigned int mode ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 932
  tmp___0 = variable_test_bit((long )bit, (unsigned long const volatile   *)word);
  }
#line 932
  if (! tmp___0) {
#line 933
    return (0);
  }
  {
#line 934
  tmp___1 = out_of_line_wait_on_bit(word, bit, action, mode);
  }
#line 934
  return (tmp___1);
}
}
#line 956
__inline static int wait_on_bit_lock(void *word , int bit , unsigned int mode )  __attribute__((__no_instrument_function__)) ;
#line 956 "../../../analyzer/../bench/linux-headers/include/linux/wait.h"
__inline static int wait_on_bit_lock(void *word , int bit , unsigned int mode ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 959
  tmp = test_and_set_bit((long )bit, (unsigned long volatile   *)word);
  }
#line 959
  if (! tmp) {
#line 960
    return (0);
  }
  {
#line 961
  tmp___0 = out_of_line_wait_on_bit_lock(word, bit, & bit_wait, mode);
  }
#line 961
  return (tmp___0);
}
}
#line 979
__inline static int wait_on_bit_lock_io(void *word , int bit , unsigned int mode )  __attribute__((__no_instrument_function__)) ;
#line 979 "../../../analyzer/../bench/linux-headers/include/linux/wait.h"
__inline static int wait_on_bit_lock_io(void *word , int bit , unsigned int mode ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 982
  tmp = test_and_set_bit((long )bit, (unsigned long volatile   *)word);
  }
#line 982
  if (! tmp) {
#line 983
    return (0);
  }
  {
#line 984
  tmp___0 = out_of_line_wait_on_bit_lock(word, bit, & bit_wait_io, mode);
  }
#line 984
  return (tmp___0);
}
}
#line 1004
__inline static int wait_on_bit_lock_action(void *word , int bit , wait_bit_action_f *action ,
                                            unsigned int mode )  __attribute__((__no_instrument_function__)) ;
#line 1004 "../../../analyzer/../bench/linux-headers/include/linux/wait.h"
__inline static int wait_on_bit_lock_action(void *word , int bit , wait_bit_action_f *action ,
                                            unsigned int mode ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1007
  tmp = test_and_set_bit((long )bit, (unsigned long volatile   *)word);
  }
#line 1007
  if (! tmp) {
#line 1008
    return (0);
  }
  {
#line 1009
  tmp___0 = out_of_line_wait_on_bit_lock(word, bit, action, mode);
  }
#line 1009
  return (tmp___0);
}
}
#line 1022
__inline static int wait_on_atomic_t(atomic_t *val , int (*action)(atomic_t * ) ,
                                     unsigned int mode )  __attribute__((__no_instrument_function__)) ;
#line 1022 "../../../analyzer/../bench/linux-headers/include/linux/wait.h"
__inline static int wait_on_atomic_t(atomic_t *val , int (*action)(atomic_t * ) ,
                                     unsigned int mode ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1025
  tmp = atomic_read((atomic_t const   *)val);
  }
#line 1025
  if (tmp == 0) {
#line 1026
    return (0);
  }
  {
#line 1027
  tmp___0 = out_of_line_wait_on_atomic_t(val, action, mode);
  }
#line 1027
  return (tmp___0);
}
}
#line 99 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
extern nodemask_t _unused_nodemask_arg_ ;
#line 111
__inline static void ( __attribute__((__always_inline__)) __node_set)(int node , nodemask_t volatile   *dstp )  __attribute__((__no_instrument_function__)) ;
#line 111 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
__inline static void ( __attribute__((__always_inline__)) __node_set)(int node , nodemask_t volatile   *dstp ) 
{ 


  {
  {
#line 113
  set_bit((long )node, (unsigned long volatile   *)(dstp->bits));
  }
#line 114
  return;
}
}
#line 117
__inline static void __node_clear(int node , nodemask_t volatile   *dstp )  __attribute__((__no_instrument_function__)) ;
#line 117 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
__inline static void __node_clear(int node , nodemask_t volatile   *dstp ) 
{ 


  {
  {
#line 119
  clear_bit((long )node, (unsigned long volatile   *)(dstp->bits));
  }
#line 120
  return;
}
}
#line 123
__inline static void __nodes_setall(nodemask_t *dstp , int nbits )  __attribute__((__no_instrument_function__)) ;
#line 123 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
__inline static void __nodes_setall(nodemask_t *dstp , int nbits ) 
{ 


  {
  {
#line 125
  bitmap_fill(dstp->bits, nbits);
  }
#line 126
  return;
}
}
#line 129
__inline static void __nodes_clear(nodemask_t *dstp , int nbits )  __attribute__((__no_instrument_function__)) ;
#line 129 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
__inline static void __nodes_clear(nodemask_t *dstp , int nbits ) 
{ 


  {
  {
#line 131
  bitmap_zero(dstp->bits, nbits);
  }
#line 132
  return;
}
}
#line 139
__inline static int __node_test_and_set(int node , nodemask_t *addr )  __attribute__((__no_instrument_function__)) ;
#line 139 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
__inline static int __node_test_and_set(int node , nodemask_t *addr ) 
{ 
  int tmp ;

  {
  {
#line 141
  tmp = test_and_set_bit((long )node, (unsigned long volatile   *)(addr->bits));
  }
#line 141
  return (tmp);
}
}
#line 146
__inline static void __nodes_and(nodemask_t *dstp , nodemask_t const   *src1p , nodemask_t const   *src2p ,
                                 int nbits )  __attribute__((__no_instrument_function__)) ;
#line 146 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
__inline static void __nodes_and(nodemask_t *dstp , nodemask_t const   *src1p , nodemask_t const   *src2p ,
                                 int nbits ) 
{ 


  {
  {
#line 149
  bitmap_and(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
             (unsigned int )nbits);
  }
#line 150
  return;
}
}
#line 154
__inline static void __nodes_or(nodemask_t *dstp , nodemask_t const   *src1p , nodemask_t const   *src2p ,
                                int nbits )  __attribute__((__no_instrument_function__)) ;
#line 154 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
__inline static void __nodes_or(nodemask_t *dstp , nodemask_t const   *src1p , nodemask_t const   *src2p ,
                                int nbits ) 
{ 


  {
  {
#line 157
  bitmap_or(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
            (unsigned int )nbits);
  }
#line 158
  return;
}
}
#line 162
__inline static void __nodes_xor(nodemask_t *dstp , nodemask_t const   *src1p , nodemask_t const   *src2p ,
                                 int nbits )  __attribute__((__no_instrument_function__)) ;
#line 162 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
__inline static void __nodes_xor(nodemask_t *dstp , nodemask_t const   *src1p , nodemask_t const   *src2p ,
                                 int nbits ) 
{ 


  {
  {
#line 165
  bitmap_xor(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
             (unsigned int )nbits);
  }
#line 166
  return;
}
}
#line 170
__inline static void __nodes_andnot(nodemask_t *dstp , nodemask_t const   *src1p ,
                                    nodemask_t const   *src2p , int nbits )  __attribute__((__no_instrument_function__)) ;
#line 170 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
__inline static void __nodes_andnot(nodemask_t *dstp , nodemask_t const   *src1p ,
                                    nodemask_t const   *src2p , int nbits ) 
{ 


  {
  {
#line 173
  bitmap_andnot(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                (unsigned int )nbits);
  }
#line 174
  return;
}
}
#line 178
__inline static void __nodes_complement(nodemask_t *dstp , nodemask_t const   *srcp ,
                                        int nbits )  __attribute__((__no_instrument_function__)) ;
#line 178 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
__inline static void __nodes_complement(nodemask_t *dstp , nodemask_t const   *srcp ,
                                        int nbits ) 
{ 


  {
  {
#line 181
  bitmap_complement(dstp->bits, (unsigned long const   *)(srcp->bits), (unsigned int )nbits);
  }
#line 182
  return;
}
}
#line 186
__inline static int __nodes_equal(nodemask_t const   *src1p , nodemask_t const   *src2p ,
                                  int nbits )  __attribute__((__no_instrument_function__)) ;
#line 186 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
__inline static int __nodes_equal(nodemask_t const   *src1p , nodemask_t const   *src2p ,
                                  int nbits ) 
{ 
  int tmp ;

  {
  {
#line 189
  tmp = bitmap_equal((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                     (unsigned int )nbits);
  }
#line 189
  return (tmp);
}
}
#line 194
__inline static int __nodes_intersects(nodemask_t const   *src1p , nodemask_t const   *src2p ,
                                       int nbits )  __attribute__((__no_instrument_function__)) ;
#line 194 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
__inline static int __nodes_intersects(nodemask_t const   *src1p , nodemask_t const   *src2p ,
                                       int nbits ) 
{ 
  int tmp ;

  {
  {
#line 197
  tmp = bitmap_intersects((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                          (unsigned int )nbits);
  }
#line 197
  return (tmp);
}
}
#line 202
__inline static int __nodes_subset(nodemask_t const   *src1p , nodemask_t const   *src2p ,
                                   int nbits )  __attribute__((__no_instrument_function__)) ;
#line 202 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
__inline static int __nodes_subset(nodemask_t const   *src1p , nodemask_t const   *src2p ,
                                   int nbits ) 
{ 
  int tmp ;

  {
  {
#line 205
  tmp = bitmap_subset((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                      (unsigned int )nbits);
  }
#line 205
  return (tmp);
}
}
#line 209
__inline static int __nodes_empty(nodemask_t const   *srcp , int nbits )  __attribute__((__no_instrument_function__)) ;
#line 209 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
__inline static int __nodes_empty(nodemask_t const   *srcp , int nbits ) 
{ 
  int tmp ;

  {
  {
#line 211
  tmp = bitmap_empty((unsigned long const   *)(srcp->bits), (unsigned int )nbits);
  }
#line 211
  return (tmp);
}
}
#line 215
__inline static int __nodes_full(nodemask_t const   *srcp , int nbits )  __attribute__((__no_instrument_function__)) ;
#line 215 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
__inline static int __nodes_full(nodemask_t const   *srcp , int nbits ) 
{ 
  int tmp ;

  {
  {
#line 217
  tmp = bitmap_full((unsigned long const   *)(srcp->bits), (unsigned int )nbits);
  }
#line 217
  return (tmp);
}
}
#line 221
__inline static int __nodes_weight(nodemask_t const   *srcp , int nbits )  __attribute__((__no_instrument_function__)) ;
#line 221 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
__inline static int __nodes_weight(nodemask_t const   *srcp , int nbits ) 
{ 
  int tmp ;

  {
  {
#line 223
  tmp = bitmap_weight((unsigned long const   *)(srcp->bits), (unsigned int )nbits);
  }
#line 223
  return (tmp);
}
}
#line 228
__inline static void __nodes_shift_right(nodemask_t *dstp , nodemask_t const   *srcp ,
                                         int n , int nbits )  __attribute__((__no_instrument_function__)) ;
#line 228 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
__inline static void __nodes_shift_right(nodemask_t *dstp , nodemask_t const   *srcp ,
                                         int n , int nbits ) 
{ 


  {
  {
#line 231
  bitmap_shift_right(dstp->bits, (unsigned long const   *)(srcp->bits), n, nbits);
  }
#line 232
  return;
}
}
#line 236
__inline static void __nodes_shift_left(nodemask_t *dstp , nodemask_t const   *srcp ,
                                        int n , int nbits )  __attribute__((__no_instrument_function__)) ;
#line 236 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
__inline static void __nodes_shift_left(nodemask_t *dstp , nodemask_t const   *srcp ,
                                        int n , int nbits ) 
{ 


  {
  {
#line 239
  bitmap_shift_left(dstp->bits, (unsigned long const   *)(srcp->bits), n, nbits);
  }
#line 240
  return;
}
}
#line 246
__inline static int __first_node(nodemask_t const   *srcp )  __attribute__((__no_instrument_function__)) ;
#line 246 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
__inline static int __first_node(nodemask_t const   *srcp ) 
{ 
  int __min1 ;
  int __min2 ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
#line 248
  __min1 = 1 << 6;
#line 248
  tmp = find_first_bit((unsigned long const   *)(srcp->bits), (unsigned long )(1 << 6));
#line 248
  __min2 = (int )tmp;
  }
#line 248
  if (__min1 < __min2) {
    {
#line 248
    tmp___0 = __min1;
    }
  } else {
    {
#line 248
    tmp___0 = __min2;
    }
  }
#line 248
  return (tmp___0);
}
}
#line 252
__inline static int __next_node(int n , nodemask_t const   *srcp )  __attribute__((__no_instrument_function__)) ;
#line 252 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
__inline static int __next_node(int n , nodemask_t const   *srcp ) 
{ 
  int __min1 ;
  int __min2 ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
#line 254
  __min1 = 1 << 6;
#line 254
  tmp = find_next_bit((unsigned long const   *)(srcp->bits), (unsigned long )(1 << 6),
                      (unsigned long )(n + 1));
#line 254
  __min2 = (int )tmp;
  }
#line 254
  if (__min1 < __min2) {
    {
#line 254
    tmp___0 = __min1;
    }
  } else {
    {
#line 254
    tmp___0 = __min2;
    }
  }
#line 254
  return (tmp___0);
}
}
#line 257
__inline static void init_nodemask_of_node(nodemask_t *mask , int node )  __attribute__((__no_instrument_function__)) ;
#line 257 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
__inline static void init_nodemask_of_node(nodemask_t *mask , int node ) 
{ 


  {
  {
#line 259
  __nodes_clear(mask, 1 << 6);
#line 260
  __node_set(node, (nodemask_t volatile   *)mask);
  }
#line 261
  return;
}
}
#line 275
__inline static int __first_unset_node(nodemask_t const   *maskp )  __attribute__((__no_instrument_function__)) ;
#line 275 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
__inline static int __first_unset_node(nodemask_t const   *maskp ) 
{ 
  int __min1 ;
  int __min2 ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
#line 277
  __min1 = 1 << 6;
#line 277
  tmp = find_first_zero_bit((unsigned long const   *)(maskp->bits), (unsigned long )(1 << 6));
#line 277
  __min2 = (int )tmp;
  }
#line 277
  if (__min1 < __min2) {
    {
#line 277
    tmp___0 = __min1;
    }
  } else {
    {
#line 277
    tmp___0 = __min2;
    }
  }
#line 277
  return (tmp___0);
}
}
#line 309
__inline static int __nodemask_scnprintf(char *buf , int len , nodemask_t const   *srcp ,
                                         int nbits )  __attribute__((__no_instrument_function__)) ;
#line 309 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
__inline static int __nodemask_scnprintf(char *buf , int len , nodemask_t const   *srcp ,
                                         int nbits ) 
{ 
  int tmp ;

  {
  {
#line 312
  tmp = bitmap_scnprintf(buf, (unsigned int )len, (unsigned long const   *)(srcp->bits),
                         nbits);
  }
#line 312
  return (tmp);
}
}
#line 317
__inline static int __nodemask_parse_user(char const   *buf , int len , nodemask_t *dstp ,
                                          int nbits )  __attribute__((__no_instrument_function__)) ;
#line 317 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
__inline static int __nodemask_parse_user(char const   *buf , int len , nodemask_t *dstp ,
                                          int nbits ) 
{ 
  int tmp ;

  {
  {
#line 320
  tmp = bitmap_parse_user(buf, (unsigned int )len, dstp->bits, nbits);
  }
#line 320
  return (tmp);
}
}
#line 325
__inline static int __nodelist_scnprintf(char *buf , int len , nodemask_t const   *srcp ,
                                         int nbits )  __attribute__((__no_instrument_function__)) ;
#line 325 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
__inline static int __nodelist_scnprintf(char *buf , int len , nodemask_t const   *srcp ,
                                         int nbits ) 
{ 
  int tmp ;

  {
  {
#line 328
  tmp = bitmap_scnlistprintf(buf, (unsigned int )len, (unsigned long const   *)(srcp->bits),
                             nbits);
  }
#line 328
  return (tmp);
}
}
#line 332
__inline static int __nodelist_parse(char const   *buf , nodemask_t *dstp , int nbits )  __attribute__((__no_instrument_function__)) ;
#line 332 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
__inline static int __nodelist_parse(char const   *buf , nodemask_t *dstp , int nbits ) 
{ 
  int tmp ;

  {
  {
#line 334
  tmp = bitmap_parselist(buf, dstp->bits, nbits);
  }
#line 334
  return (tmp);
}
}
#line 339
__inline static int __node_remap(int oldbit , nodemask_t const   *oldp , nodemask_t const   *newp ,
                                 int nbits )  __attribute__((__no_instrument_function__)) ;
#line 339 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
__inline static int __node_remap(int oldbit , nodemask_t const   *oldp , nodemask_t const   *newp ,
                                 int nbits ) 
{ 
  int tmp ;

  {
  {
#line 342
  tmp = bitmap_bitremap(oldbit, (unsigned long const   *)(oldp->bits), (unsigned long const   *)(newp->bits),
                        nbits);
  }
#line 342
  return (tmp);
}
}
#line 347
__inline static void __nodes_remap(nodemask_t *dstp , nodemask_t const   *srcp , nodemask_t const   *oldp ,
                                   nodemask_t const   *newp , int nbits )  __attribute__((__no_instrument_function__)) ;
#line 347 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
__inline static void __nodes_remap(nodemask_t *dstp , nodemask_t const   *srcp , nodemask_t const   *oldp ,
                                   nodemask_t const   *newp , int nbits ) 
{ 


  {
  {
#line 350
  bitmap_remap(dstp->bits, (unsigned long const   *)(srcp->bits), (unsigned long const   *)(oldp->bits),
               (unsigned long const   *)(newp->bits), nbits);
  }
#line 351
  return;
}
}
#line 355
__inline static void __nodes_onto(nodemask_t *dstp , nodemask_t const   *origp , nodemask_t const   *relmapp ,
                                  int nbits )  __attribute__((__no_instrument_function__)) ;
#line 355 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
__inline static void __nodes_onto(nodemask_t *dstp , nodemask_t const   *origp , nodemask_t const   *relmapp ,
                                  int nbits ) 
{ 


  {
  {
#line 358
  bitmap_onto(dstp->bits, (unsigned long const   *)(origp->bits), (unsigned long const   *)(relmapp->bits),
              nbits);
  }
#line 359
  return;
}
}
#line 363
__inline static void __nodes_fold(nodemask_t *dstp , nodemask_t const   *origp , int sz ,
                                  int nbits )  __attribute__((__no_instrument_function__)) ;
#line 363 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
__inline static void __nodes_fold(nodemask_t *dstp , nodemask_t const   *origp , int sz ,
                                  int nbits ) 
{ 


  {
  {
#line 366
  bitmap_fold(dstp->bits, (unsigned long const   *)(origp->bits), sz, nbits);
  }
#line 367
  return;
}
}
#line 406
extern nodemask_t node_states[4] ;
#line 409
__inline static int node_state(int node , enum node_states state )  __attribute__((__no_instrument_function__)) ;
#line 409 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
__inline static int node_state(int node , enum node_states state ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 411
  tmp___0 = variable_test_bit((long )node, (unsigned long const volatile   *)(node_states[state].bits));
  }
#line 411
  return (tmp___0);
}
}
#line 414
__inline static void node_set_state(int node , enum node_states state )  __attribute__((__no_instrument_function__)) ;
#line 414 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
__inline static void node_set_state(int node , enum node_states state ) 
{ 


  {
  {
#line 416
  __node_set(node, (nodemask_t volatile   *)(& node_states[state]));
  }
#line 417
  return;
}
}
#line 419
__inline static void node_clear_state(int node , enum node_states state )  __attribute__((__no_instrument_function__)) ;
#line 419 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
__inline static void node_clear_state(int node , enum node_states state ) 
{ 


  {
  {
#line 421
  __node_clear(node, (nodemask_t volatile   *)(& node_states[state]));
  }
#line 422
  return;
}
}
#line 424
__inline static int num_node_state(enum node_states state )  __attribute__((__no_instrument_function__)) ;
#line 424 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
__inline static int num_node_state(enum node_states state ) 
{ 
  int tmp ;

  {
  {
#line 426
  tmp = __nodes_weight((nodemask_t const   *)(& node_states[state]), 1 << 6);
  }
#line 426
  return (tmp);
}
}
#line 434
__inline static int next_online_node(int nid )  __attribute__((__no_instrument_function__)) ;
#line 434 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
__inline static int next_online_node(int nid ) 
{ 
  int tmp ;

  {
  {
#line 436
  tmp = __next_node(nid, (nodemask_t const   *)(& node_states[1]));
  }
#line 436
  return (tmp);
}
}
#line 438
__inline static int next_memory_node(int nid )  __attribute__((__no_instrument_function__)) ;
#line 438 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
__inline static int next_memory_node(int nid ) 
{ 
  int tmp ;

  {
  {
#line 440
  tmp = __next_node(nid, (nodemask_t const   *)(& node_states[2]));
  }
#line 440
  return (tmp);
}
}
#line 443
extern int nr_node_ids ;
#line 444
extern int nr_online_nodes ;
#line 446
__inline static void node_set_online(int nid )  __attribute__((__no_instrument_function__)) ;
#line 446 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
__inline static void node_set_online(int nid ) 
{ 


  {
  {
#line 448
  node_set_state(nid, (enum node_states )1);
#line 449
  nr_online_nodes = num_node_state((enum node_states )1);
  }
#line 450
  return;
}
}
#line 452
__inline static void node_set_offline(int nid )  __attribute__((__no_instrument_function__)) ;
#line 452 "../../../analyzer/../bench/linux-headers/include/linux/nodemask.h"
__inline static void node_set_offline(int nid ) 
{ 


  {
  {
#line 454
  node_clear_state(nid, (enum node_states )1);
#line 455
  nr_online_nodes = num_node_state((enum node_states )1);
  }
#line 456
  return;
}
}
#line 493
extern int node_random(nodemask_t const   *maskp ) ;
#line 68 "../../../analyzer/../bench/linux-headers/include/linux/pageblock-flags.h"
extern unsigned long get_pfnblock_flags_mask(struct page *page , unsigned long pfn ,
                                             unsigned long end_bitidx , unsigned long mask ) ;
#line 73
extern void set_pfnblock_flags_mask(struct page *page , unsigned long flags , unsigned long pfn ,
                                    unsigned long end_bitidx , unsigned long mask ) ;
#line 76 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
extern int page_group_by_mobility_disabled ;
#line 85
__inline static int get_pfnblock_migratetype(struct page *page , unsigned long pfn )  __attribute__((__no_instrument_function__)) ;
#line 85 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static int get_pfnblock_migratetype(struct page *page , unsigned long pfn ) 
{ 
  unsigned long tmp ;

  {
  {
#line 88
  tmp = get_pfnblock_flags_mask(page, pfn, 2UL, (1UL << 3) - 1UL);
  }
#line 88
  return ((int )tmp);
}
}
#line 188
__inline static int is_file_lru(enum lru_list lru )  __attribute__((__no_instrument_function__)) ;
#line 188 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static int is_file_lru(enum lru_list lru ) 
{ 
  int tmp ;

  {
#line 190
  if ((unsigned int )lru == 2U) {
    {
#line 190
    tmp = 1;
    }
  } else
#line 190
  if ((unsigned int )lru == 3U) {
    {
#line 190
    tmp = 1;
    }
  } else {
    {
#line 190
    tmp = 0;
    }
  }
#line 190
  return (tmp);
}
}
#line 193
__inline static int is_active_lru(enum lru_list lru )  __attribute__((__no_instrument_function__)) ;
#line 193 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static int is_active_lru(enum lru_list lru ) 
{ 
  int tmp ;

  {
#line 195
  if ((unsigned int )lru == 1U) {
    {
#line 195
    tmp = 1;
    }
  } else
#line 195
  if ((unsigned int )lru == 3U) {
    {
#line 195
    tmp = 1;
    }
  } else {
    {
#line 195
    tmp = 0;
    }
  }
#line 195
  return (tmp);
}
}
#line 198
__inline static int is_unevictable_lru(enum lru_list lru )  __attribute__((__no_instrument_function__)) ;
#line 198 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static int is_unevictable_lru(enum lru_list lru ) 
{ 


  {
#line 200
  return ((unsigned int )lru == 4U);
}
}
#line 540
__inline static void zone_set_flag(struct zone *zone , zone_flags_t flag )  __attribute__((__no_instrument_function__)) ;
#line 540 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static void zone_set_flag(struct zone *zone , zone_flags_t flag ) 
{ 


  {
  {
#line 542
  set_bit((long )flag, (unsigned long volatile   *)(& zone->flags));
  }
#line 543
  return;
}
}
#line 545
__inline static int zone_test_and_set_flag(struct zone *zone , zone_flags_t flag )  __attribute__((__no_instrument_function__)) ;
#line 545 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static int zone_test_and_set_flag(struct zone *zone , zone_flags_t flag ) 
{ 
  int tmp ;

  {
  {
#line 547
  tmp = test_and_set_bit((long )flag, (unsigned long volatile   *)(& zone->flags));
  }
#line 547
  return (tmp);
}
}
#line 550
__inline static void zone_clear_flag(struct zone *zone , zone_flags_t flag )  __attribute__((__no_instrument_function__)) ;
#line 550 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static void zone_clear_flag(struct zone *zone , zone_flags_t flag ) 
{ 


  {
  {
#line 552
  clear_bit((long )flag, (unsigned long volatile   *)(& zone->flags));
  }
#line 553
  return;
}
}
#line 555
__inline static int zone_is_reclaim_congested(struct zone  const  *zone )  __attribute__((__no_instrument_function__)) ;
#line 555 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static int zone_is_reclaim_congested(struct zone  const  *zone ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 557
  tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& zone->flags));
  }
#line 557
  return (tmp);
}
}
#line 560
__inline static int zone_is_reclaim_dirty(struct zone  const  *zone )  __attribute__((__no_instrument_function__)) ;
#line 560 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static int zone_is_reclaim_dirty(struct zone  const  *zone ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 562
  tmp = constant_test_bit(3L, (unsigned long const volatile   *)(& zone->flags));
  }
#line 562
  return (tmp);
}
}
#line 565
__inline static int zone_is_reclaim_writeback(struct zone  const  *zone )  __attribute__((__no_instrument_function__)) ;
#line 565 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static int zone_is_reclaim_writeback(struct zone  const  *zone ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 567
  tmp = constant_test_bit(4L, (unsigned long const volatile   *)(& zone->flags));
  }
#line 567
  return (tmp);
}
}
#line 570
__inline static int zone_is_reclaim_locked(struct zone  const  *zone )  __attribute__((__no_instrument_function__)) ;
#line 570 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static int zone_is_reclaim_locked(struct zone  const  *zone ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 572
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& zone->flags));
  }
#line 572
  return (tmp);
}
}
#line 575
__inline static int zone_is_fair_depleted(struct zone  const  *zone )  __attribute__((__no_instrument_function__)) ;
#line 575 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static int zone_is_fair_depleted(struct zone  const  *zone ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 577
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& zone->flags));
  }
#line 577
  return (tmp);
}
}
#line 580
__inline static int zone_is_oom_locked(struct zone  const  *zone )  __attribute__((__no_instrument_function__)) ;
#line 580 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static int zone_is_oom_locked(struct zone  const  *zone ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 582
  tmp = constant_test_bit(1L, (unsigned long const volatile   *)(& zone->flags));
  }
#line 582
  return (tmp);
}
}
#line 585
__inline static unsigned long zone_end_pfn(struct zone  const  *zone )  __attribute__((__no_instrument_function__)) ;
#line 585 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static unsigned long zone_end_pfn(struct zone  const  *zone ) 
{ 


  {
#line 587
  return ((unsigned long )(zone->zone_start_pfn + zone->spanned_pages));
}
}
#line 590
__inline static bool zone_spans_pfn(struct zone  const  *zone , unsigned long pfn )  __attribute__((__no_instrument_function__)) ;
#line 590 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static bool zone_spans_pfn(struct zone  const  *zone , unsigned long pfn ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 592
  if (zone->zone_start_pfn <= (unsigned long const   )pfn) {
    {
#line 592
    tmp = zone_end_pfn(zone);
    }
#line 592
    if (pfn < tmp) {
      {
#line 592
      tmp___0 = 1;
      }
    } else {
      {
#line 592
      tmp___0 = 0;
      }
    }
  } else {
    {
#line 592
    tmp___0 = 0;
    }
  }
#line 592
  return ((bool )tmp___0);
}
}
#line 595
__inline static bool zone_is_initialized(struct zone *zone )  __attribute__((__no_instrument_function__)) ;
#line 595 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static bool zone_is_initialized(struct zone *zone ) 
{ 


  {
#line 597
  return ((bool )(! (! zone->wait_table)));
}
}
#line 600
__inline static bool zone_is_empty(struct zone *zone )  __attribute__((__no_instrument_function__)) ;
#line 600 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static bool zone_is_empty(struct zone *zone ) 
{ 


  {
#line 602
  return ((bool )(zone->spanned_pages == 0UL));
}
}
#line 740
extern struct page *mem_map ;
#line 816
__inline static unsigned long pgdat_end_pfn(pg_data_t *pgdat )  __attribute__((__no_instrument_function__)) ;
#line 816 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static unsigned long pgdat_end_pfn(pg_data_t *pgdat ) 
{ 


  {
#line 818
  return (pgdat->node_start_pfn + pgdat->node_spanned_pages);
}
}
#line 821
__inline static bool pgdat_is_empty(pg_data_t *pgdat )  __attribute__((__no_instrument_function__)) ;
#line 821 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static bool pgdat_is_empty(pg_data_t *pgdat ) 
{ 
  int tmp ;

  {
#line 823
  if (! pgdat->node_start_pfn) {
#line 823
    if (! pgdat->node_spanned_pages) {
      {
#line 823
      tmp = 1;
      }
    } else {
      {
#line 823
      tmp = 0;
      }
    }
  } else {
    {
#line 823
    tmp = 0;
    }
  }
#line 823
  return ((bool )tmp);
}
}
#line 22 "../../../analyzer/../bench/linux-headers/include/linux/osq_lock.h"
__inline static void osq_lock_init(struct optimistic_spin_queue *lock )  __attribute__((__no_instrument_function__)) ;
#line 22 "../../../analyzer/../bench/linux-headers/include/linux/osq_lock.h"
__inline static void osq_lock_init(struct optimistic_spin_queue *lock ) 
{ 


  {
  {
#line 24
  atomic_set(& lock->tail, 0);
  }
#line 25
  return;
}
}
#line 100 "../../../analyzer/../bench/linux-headers/include/linux/mutex.h"
__inline static void mutex_destroy(struct mutex *lock )  __attribute__((__no_instrument_function__)) ;
#line 100 "../../../analyzer/../bench/linux-headers/include/linux/mutex.h"
__inline static void mutex_destroy(struct mutex *lock ) 
{ 


  {
#line 100
  return;
}
}
#line 120
extern void __mutex_init(struct mutex *lock , char const   *name , struct lock_class_key *key ) ;
#line 129
__inline static int mutex_is_locked(struct mutex *lock )  __attribute__((__no_instrument_function__)) ;
#line 129 "../../../analyzer/../bench/linux-headers/include/linux/mutex.h"
__inline static int mutex_is_locked(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 131
  tmp = atomic_read((atomic_t const   *)(& lock->count));
  }
#line 131
  return (tmp != 1);
}
}
#line 158
extern void mutex_lock(struct mutex *lock ) ;
#line 159
extern int ( __attribute__((__warn_unused_result__)) mutex_lock_interruptible)(struct mutex *lock ) ;
#line 160
extern int ( __attribute__((__warn_unused_result__)) mutex_lock_killable)(struct mutex *lock ) ;
#line 174
extern int mutex_trylock(struct mutex *lock ) ;
#line 175
extern void mutex_unlock(struct mutex *lock ) ;
#line 177
extern int atomic_dec_and_mutex_lock(atomic_t *cnt , struct mutex *lock ) ;
#line 44 "../../../analyzer/../bench/linux-headers/include/linux/rwsem.h"
extern struct rw_semaphore *rwsem_down_read_failed(struct rw_semaphore *sem ) ;
#line 45
extern struct rw_semaphore *rwsem_down_write_failed(struct rw_semaphore *sem ) ;
#line 46
extern struct rw_semaphore *rwsem_wake(struct rw_semaphore * ) ;
#line 47
extern struct rw_semaphore *rwsem_downgrade_wake(struct rw_semaphore *sem ) ;
#line 63 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/rwsem.h"
__inline static void __down_read(struct rw_semaphore *sem )  __attribute__((__no_instrument_function__)) ;
#line 63 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/rwsem.h"
__inline static void __down_read(struct rw_semaphore *sem ) 
{ 


  {
  {
#line 65
  __asm__  volatile   ("# beginning down_read\n\t"
                       ".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       " "
                       "incq"
                       " "
                       "(%1)\n\t"
                       "  jns        1f\n"
                       "  call call_rwsem_down_read_failed\n"
                       "1:\n\t"
                       "# ending down_read\n\t": "+m" (sem->count): "a" (sem): "memory",
                       "cc");
  }
#line 75
  return;
}
}
#line 80
__inline static int __down_read_trylock(struct rw_semaphore *sem )  __attribute__((__no_instrument_function__)) ;
#line 80 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/rwsem.h"
__inline static int __down_read_trylock(struct rw_semaphore *sem ) 
{ 
  long result ;
  long tmp ;
  int tmp___0 ;

  {
  {
#line 83
  __asm__  volatile   ("# beginning __down_read_trylock\n\t"
                       "  mov          %0,%1\n\t"
                       "1:\n\t"
                       "  mov          %1,%2\n\t"
                       "  add          %3,%2\n\t"
                       "  jle\t     2f\n\t"
                       ".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "  cmpxchg  %2,%0\n\t"
                       "  jnz\t     1b\n\t"
                       "2:\n\t"
                       "# ending __down_read_trylock\n\t": "+m" (sem->count), "=&a" (result),
                       "=&r" (tmp): "i" (1L): "memory", "cc");
  }
#line 96
  if (result >= 0L) {
    {
#line 96
    tmp___0 = 1;
    }
  } else {
    {
#line 96
    tmp___0 = 0;
    }
  }
#line 96
  return (tmp___0);
}
}
#line 102
__inline static void __down_write_nested(struct rw_semaphore *sem , int subclass )  __attribute__((__no_instrument_function__)) ;
#line 102 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/rwsem.h"
__inline static void __down_write_nested(struct rw_semaphore *sem , int subclass ) 
{ 
  long tmp ;

  {
  {
#line 105
  __asm__  volatile   ("# beginning down_write\n\t"
                       ".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "  xadd      %1,(%2)\n\t"
                       "  test "
                       " "
                       "%k1"
                       " "
                       ","
                       " "
                       "%k1"
                       " "
                       "\n\t"
                       "  jz        1f\n"
                       "  call call_rwsem_down_write_failed\n"
                       "1:\n"
                       "# ending down_write": "+m" (sem->count), "=d" (tmp): "a" (sem),
                       "1" (-4294967295L): "memory", "cc");
  }
#line 117
  return;
}
}
#line 119
__inline static void __down_write(struct rw_semaphore *sem )  __attribute__((__no_instrument_function__)) ;
#line 119 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/rwsem.h"
__inline static void __down_write(struct rw_semaphore *sem ) 
{ 


  {
  {
#line 121
  __down_write_nested(sem, 0);
  }
#line 122
  return;
}
}
#line 127
__inline static int __down_write_trylock(struct rw_semaphore *sem )  __attribute__((__no_instrument_function__)) ;
#line 127 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/rwsem.h"
__inline static int __down_write_trylock(struct rw_semaphore *sem ) 
{ 
  long result ;
  long tmp ;

  {
  {
#line 130
  __asm__  volatile   ("# beginning __down_write_trylock\n\t"
                       "  mov          %0,%1\n\t"
                       "1:\n\t"
                       "  test "
                       " "
                       "%k1"
                       " "
                       ","
                       " "
                       "%k1"
                       " "
                       "\n\t"
                       "  jnz          2f\n\t"
                       "  mov          %1,%2\n\t"
                       "  add          %3,%2\n\t"
                       ".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "  cmpxchg  %2,%0\n\t"
                       "  jnz\t     1b\n\t"
                       "2:\n\t"
                       "  sete         %b1\n\t"
                       "  movzbl       %b1, %k1\n\t"
                       "# ending __down_write_trylock\n\t": "+m" (sem->count), "=&a" (result),
                       "=&r" (tmp): "er" (-4294967295L): "memory", "cc");
  }
#line 147
  return ((int )result);
}
}
#line 153
__inline static void __up_read(struct rw_semaphore *sem )  __attribute__((__no_instrument_function__)) ;
#line 153 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/rwsem.h"
__inline static void __up_read(struct rw_semaphore *sem ) 
{ 
  long tmp ;

  {
  {
#line 156
  __asm__  volatile   ("# beginning __up_read\n\t"
                       ".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "  xadd      %1,(%2)\n\t"
                       "  jns        1f\n\t"
                       "  call call_rwsem_wake\n"
                       "1:\n"
                       "# ending __up_read\n": "+m" (sem->count), "=d" (tmp): "a" (sem),
                       "1" (-1L): "memory", "cc");
  }
#line 166
  return;
}
}
#line 171
__inline static void __up_write(struct rw_semaphore *sem )  __attribute__((__no_instrument_function__)) ;
#line 171 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/rwsem.h"
__inline static void __up_write(struct rw_semaphore *sem ) 
{ 
  long tmp ;

  {
  {
#line 174
  __asm__  volatile   ("# beginning __up_write\n\t"
                       ".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "  xadd      %1,(%2)\n\t"
                       "  jns        1f\n\t"
                       "  call call_rwsem_wake\n"
                       "1:\n\t"
                       "# ending __up_write\n": "+m" (sem->count), "=d" (tmp): "a" (sem),
                       "1" (4294967295L): "memory", "cc");
  }
#line 184
  return;
}
}
#line 189
__inline static void __downgrade_write(struct rw_semaphore *sem )  __attribute__((__no_instrument_function__)) ;
#line 189 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/rwsem.h"
__inline static void __downgrade_write(struct rw_semaphore *sem ) 
{ 


  {
  {
#line 191
  __asm__  volatile   ("# beginning __downgrade_write\n\t"
                       ".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       " "
                       "addq"
                       " "
                       "%2,(%1)\n\t"
                       "  jns       1f\n\t"
                       "  call call_rwsem_downgrade_wake\n"
                       "1:\n\t"
                       "# ending __downgrade_write\n": "+m" (sem->count): "a" (sem),
                       "er" (4294967296L): "memory", "cc");
  }
#line 204
  return;
}
}
#line 209
__inline static void rwsem_atomic_add(long delta , struct rw_semaphore *sem )  __attribute__((__no_instrument_function__)) ;
#line 209 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/rwsem.h"
__inline static void rwsem_atomic_add(long delta , struct rw_semaphore *sem ) 
{ 


  {
  {
#line 211
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       " "
                       "addq"
                       " "
                       "%1,%0": "+m" (sem->count): "er" (delta));
  }
#line 214
  return;
}
}
#line 219
__inline static long rwsem_atomic_update(long delta , struct rw_semaphore *sem )  __attribute__((__no_instrument_function__)) ;
#line 219 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/rwsem.h"
__inline static long rwsem_atomic_update(long delta , struct rw_semaphore *sem ) 
{ 
  long __ret ;

  {
  {
#line 221
  __ret = delta;
  }
  {
#line 221
  if (sizeof(sem->count) == 1UL) {
#line 221
    goto case_1;
  }
#line 221
  if (sizeof(sem->count) == 2UL) {
#line 221
    goto case_2;
  }
#line 221
  if (sizeof(sem->count) == 4UL) {
#line 221
    goto case_4;
  }
#line 221
  if (sizeof(sem->count) == 8UL) {
#line 221
    goto case_8;
  }
#line 221
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 221
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "xadd"
                       "b %b0, %1\n": "+q" (__ret), "+m" (sem->count): : "memory",
                       "cc");
  }
#line 221
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 221
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "xadd"
                       "w %w0, %1\n": "+r" (__ret), "+m" (sem->count): : "memory",
                       "cc");
  }
#line 221
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 221
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "xadd"
                       "l %0, %1\n": "+r" (__ret), "+m" (sem->count): : "memory",
                       "cc");
  }
#line 221
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 221
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n"
                       ".balign 4\n"
                       ".long 671f - .\n"
                       ".popsection\n"
                       "671:"
                       "\n\tlock; "
                       "xadd"
                       "q %q0, %1\n": "+r" (__ret), "+m" (sem->count): : "memory",
                       "cc");
  }
#line 221
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 221
  __xadd_wrong_size();
  }
  switch_break: /* CIL Label */ ;
  }
#line 221
  return (delta + __ret);
}
}
#line 53 "../../../analyzer/../bench/linux-headers/include/linux/rwsem.h"
__inline static int rwsem_is_locked(struct rw_semaphore *sem )  __attribute__((__no_instrument_function__)) ;
#line 53 "../../../analyzer/../bench/linux-headers/include/linux/rwsem.h"
__inline static int rwsem_is_locked(struct rw_semaphore *sem ) 
{ 


  {
#line 55
  return (sem->count != 0L);
}
}
#line 84
extern void __init_rwsem(struct rw_semaphore *sem , char const   *name , struct lock_class_key *key ) ;
#line 100
__inline static int rwsem_is_contended(struct rw_semaphore *sem )  __attribute__((__no_instrument_function__)) ;
#line 100 "../../../analyzer/../bench/linux-headers/include/linux/rwsem.h"
__inline static int rwsem_is_contended(struct rw_semaphore *sem ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 102
  tmp = list_empty((struct list_head  const  *)(& sem->wait_list));
  }
#line 102
  if (tmp) {
    {
#line 102
    tmp___0 = 0;
    }
  } else {
    {
#line 102
    tmp___0 = 1;
    }
  }
#line 102
  return (tmp___0);
}
}
#line 108
extern void down_read(struct rw_semaphore *sem ) ;
#line 113
extern int down_read_trylock(struct rw_semaphore *sem ) ;
#line 118
extern void down_write(struct rw_semaphore *sem ) ;
#line 123
extern int down_write_trylock(struct rw_semaphore *sem ) ;
#line 128
extern void up_read(struct rw_semaphore *sem ) ;
#line 133
extern void up_write(struct rw_semaphore *sem ) ;
#line 138
extern void downgrade_write(struct rw_semaphore *sem ) ;
#line 76 "../../../analyzer/../bench/linux-headers/include/linux/completion.h"
static struct lock_class_key __key  ;
#line 73
__inline static void init_completion(struct completion *x )  __attribute__((__no_instrument_function__)) ;
#line 73 "../../../analyzer/../bench/linux-headers/include/linux/completion.h"
__inline static void init_completion(struct completion *x ) 
{ 


  {
  {
#line 75
  x->done = 0U;
  }
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 76
    __init_waitqueue_head(& x->wait, "&x->wait", & __key);
    }
#line 76
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  return;
}
}
#line 86
__inline static void reinit_completion(struct completion *x )  __attribute__((__no_instrument_function__)) ;
#line 86 "../../../analyzer/../bench/linux-headers/include/linux/completion.h"
__inline static void reinit_completion(struct completion *x ) 
{ 


  {
  {
#line 88
  x->done = 0U;
  }
#line 89
  return;
}
}
#line 91
extern void wait_for_completion(struct completion * ) ;
#line 92
extern void wait_for_completion_io(struct completion * ) ;
#line 93
extern int wait_for_completion_interruptible(struct completion *x ) ;
#line 94
extern int wait_for_completion_killable(struct completion *x ) ;
#line 95
extern unsigned long wait_for_completion_timeout(struct completion *x , unsigned long timeout ) ;
#line 97
extern unsigned long wait_for_completion_io_timeout(struct completion *x , unsigned long timeout ) ;
#line 99
extern long wait_for_completion_interruptible_timeout(struct completion *x , unsigned long timeout ) ;
#line 101
extern long wait_for_completion_killable_timeout(struct completion *x , unsigned long timeout ) ;
#line 103
extern bool try_wait_for_completion(struct completion *x ) ;
#line 104
extern bool completion_done(struct completion *x ) ;
#line 106
extern void complete(struct completion * ) ;
#line 107
extern void complete_all(struct completion * ) ;
#line 84 "../../../analyzer/../bench/linux-headers/include/linux/debugobjects.h"
__inline static void debug_object_init(void *addr , struct debug_obj_descr *descr )  __attribute__((__no_instrument_function__)) ;
#line 84 "../../../analyzer/../bench/linux-headers/include/linux/debugobjects.h"
__inline static void debug_object_init(void *addr , struct debug_obj_descr *descr ) 
{ 


  {
#line 85
  return;
}
}
#line 86
__inline static void debug_object_init_on_stack(void *addr , struct debug_obj_descr *descr )  __attribute__((__no_instrument_function__)) ;
#line 86 "../../../analyzer/../bench/linux-headers/include/linux/debugobjects.h"
__inline static void debug_object_init_on_stack(void *addr , struct debug_obj_descr *descr ) 
{ 


  {
#line 87
  return;
}
}
#line 88
__inline static int debug_object_activate(void *addr , struct debug_obj_descr *descr )  __attribute__((__no_instrument_function__)) ;
#line 88 "../../../analyzer/../bench/linux-headers/include/linux/debugobjects.h"
__inline static int debug_object_activate(void *addr , struct debug_obj_descr *descr ) 
{ 


  {
#line 89
  return (0);
}
}
#line 90
__inline static void debug_object_deactivate(void *addr , struct debug_obj_descr *descr )  __attribute__((__no_instrument_function__)) ;
#line 90 "../../../analyzer/../bench/linux-headers/include/linux/debugobjects.h"
__inline static void debug_object_deactivate(void *addr , struct debug_obj_descr *descr ) 
{ 


  {
#line 91
  return;
}
}
#line 92
__inline static void debug_object_destroy(void *addr , struct debug_obj_descr *descr )  __attribute__((__no_instrument_function__)) ;
#line 92 "../../../analyzer/../bench/linux-headers/include/linux/debugobjects.h"
__inline static void debug_object_destroy(void *addr , struct debug_obj_descr *descr ) 
{ 


  {
#line 93
  return;
}
}
#line 94
__inline static void debug_object_free(void *addr , struct debug_obj_descr *descr )  __attribute__((__no_instrument_function__)) ;
#line 94 "../../../analyzer/../bench/linux-headers/include/linux/debugobjects.h"
__inline static void debug_object_free(void *addr , struct debug_obj_descr *descr ) 
{ 


  {
#line 95
  return;
}
}
#line 96
__inline static void debug_object_assert_init(void *addr , struct debug_obj_descr *descr )  __attribute__((__no_instrument_function__)) ;
#line 96 "../../../analyzer/../bench/linux-headers/include/linux/debugobjects.h"
__inline static void debug_object_assert_init(void *addr , struct debug_obj_descr *descr ) 
{ 


  {
#line 97
  return;
}
}
#line 99
__inline static void debug_objects_early_init(void)  __attribute__((__no_instrument_function__)) ;
#line 99 "../../../analyzer/../bench/linux-headers/include/linux/debugobjects.h"
__inline static void debug_objects_early_init(void) 
{ 


  {
#line 99
  return;
}
}
#line 100
__inline static void debug_objects_mem_init(void)  __attribute__((__no_instrument_function__)) ;
#line 100 "../../../analyzer/../bench/linux-headers/include/linux/debugobjects.h"
__inline static void debug_objects_mem_init(void) 
{ 


  {
#line 100
  return;
}
}
#line 106
__inline static void debug_check_no_obj_freed(void const   *address , unsigned long size )  __attribute__((__no_instrument_function__)) ;
#line 106 "../../../analyzer/../bench/linux-headers/include/linux/debugobjects.h"
__inline static void debug_check_no_obj_freed(void const   *address , unsigned long size ) 
{ 


  {
#line 107
  return;
}
}
#line 49 "../../../analyzer/../bench/linux-headers/include/linux/rcupdate.h"
extern int rcu_expedited ;
#line 63
extern void rcutorture_get_gp_data(enum rcutorture_type test_type , int *flags , unsigned long *gpnum ,
                                   unsigned long *completed ) ;
#line 65
extern void rcutorture_record_test_transition(void) ;
#line 66
extern void rcutorture_record_progress(unsigned long vernum ) ;
#line 67
extern void do_trace_rcu_torture_read(char const   *rcutorturename , struct callback_head *rhp ,
                                      unsigned long secs , unsigned long c_old , unsigned long c ) ;
#line 173
extern void call_rcu_bh(struct callback_head *head , void (*func)(struct callback_head *head ) ) ;
#line 195
extern void call_rcu_sched(struct callback_head *head , void (*func)(struct callback_head *rcu ) ) ;
#line 198
extern void synchronize_sched(void) ;
#line 217
__inline static void __rcu_read_lock(void)  __attribute__((__no_instrument_function__)) ;
#line 217 "../../../analyzer/../bench/linux-headers/include/linux/rcupdate.h"
__inline static void __rcu_read_lock(void) 
{ 


  {
  {
#line 219
  __asm__  volatile   ("": : : "memory");
  }
#line 220
  return;
}
}
#line 222
__inline static void __rcu_read_unlock(void)  __attribute__((__no_instrument_function__)) ;
#line 222 "../../../analyzer/../bench/linux-headers/include/linux/rcupdate.h"
__inline static void __rcu_read_unlock(void) 
{ 


  {
  {
#line 224
  __asm__  volatile   ("": : : "memory");
  }
#line 225
  return;
}
}
#line 227
__inline static void synchronize_rcu(void)  __attribute__((__no_instrument_function__)) ;
#line 227 "../../../analyzer/../bench/linux-headers/include/linux/rcupdate.h"
__inline static void synchronize_rcu(void) 
{ 


  {
  {
#line 229
  synchronize_sched();
  }
#line 230
  return;
}
}
#line 232
__inline static int rcu_preempt_depth(void)  __attribute__((__no_instrument_function__)) ;
#line 232 "../../../analyzer/../bench/linux-headers/include/linux/rcupdate.h"
__inline static int rcu_preempt_depth(void) 
{ 


  {
#line 234
  return (0);
}
}
#line 240
extern void rcu_init(void) ;
#line 241
extern void rcu_sched_qs(int cpu ) ;
#line 242
extern void rcu_bh_qs(int cpu ) ;
#line 243
extern void rcu_check_callbacks(int cpu , int user ) ;
#line 245
extern void rcu_idle_enter(void) ;
#line 246
extern void rcu_idle_exit(void) ;
#line 247
extern void rcu_irq_enter(void) ;
#line 248
extern void rcu_irq_exit(void) ;
#line 251
extern void rcu_sysrq_start(void) ;
#line 252
extern void rcu_sysrq_end(void) ;
#line 266
__inline static void rcu_user_enter(void)  __attribute__((__no_instrument_function__)) ;
#line 266 "../../../analyzer/../bench/linux-headers/include/linux/rcupdate.h"
__inline static void rcu_user_enter(void) 
{ 


  {
#line 266
  return;
}
}
#line 267
__inline static void rcu_user_exit(void)  __attribute__((__no_instrument_function__)) ;
#line 267 "../../../analyzer/../bench/linux-headers/include/linux/rcupdate.h"
__inline static void rcu_user_exit(void) 
{ 


  {
#line 267
  return;
}
}
#line 268
__inline static void rcu_user_hooks_switch(struct task_struct *prev , struct task_struct *next )  __attribute__((__no_instrument_function__)) ;
#line 268 "../../../analyzer/../bench/linux-headers/include/linux/rcupdate.h"
__inline static void rcu_user_hooks_switch(struct task_struct *prev , struct task_struct *next ) 
{ 


  {
#line 269
  return;
}
}
#line 298
extern bool __rcu_is_watching(void) ;
#line 308
extern void wait_rcu_gp(call_rcu_func_t *crf ) ;
#line 33 "../../../analyzer/../bench/linux-headers/include/linux/rcutree.h"
extern void rcu_note_context_switch(int cpu ) ;
#line 35
extern int rcu_needs_cpu(int cpu , unsigned long *delta_jiffies ) ;
#line 37
extern void rcu_cpu_stall_reset(void) ;
#line 44
__inline static void rcu_virt_note_context_switch(int cpu )  __attribute__((__no_instrument_function__)) ;
#line 44 "../../../analyzer/../bench/linux-headers/include/linux/rcutree.h"
__inline static void rcu_virt_note_context_switch(int cpu ) 
{ 


  {
  {
#line 46
  rcu_note_context_switch(cpu);
  }
#line 47
  return;
}
}
#line 49
extern void synchronize_rcu_bh(void) ;
#line 50
extern void synchronize_sched_expedited(void) ;
#line 51
extern void synchronize_rcu_expedited(void) ;
#line 53
extern void kfree_call_rcu(struct callback_head *head , void (*func)(struct callback_head *rcu ) ) ;
#line 71
__inline static void synchronize_rcu_bh_expedited(void)  __attribute__((__no_instrument_function__)) ;
#line 71 "../../../analyzer/../bench/linux-headers/include/linux/rcutree.h"
__inline static void synchronize_rcu_bh_expedited(void) 
{ 


  {
  {
#line 73
  synchronize_sched_expedited();
  }
#line 74
  return;
}
}
#line 76
extern void rcu_barrier(void) ;
#line 77
extern void rcu_barrier_bh(void) ;
#line 78
extern void rcu_barrier_sched(void) ;
#line 79
extern unsigned long get_state_synchronize_rcu(void) ;
#line 80
extern void cond_synchronize_rcu(unsigned long oldstate ) ;
#line 82
extern unsigned long rcutorture_testseq ;
#line 83
extern unsigned long rcutorture_vernum ;
#line 84
extern long rcu_batches_completed(void) ;
#line 85
extern long rcu_batches_completed_bh(void) ;
#line 86
extern long rcu_batches_completed_sched(void) ;
#line 87
extern void show_rcu_gp_kthreads(void) ;
#line 89
extern void rcu_force_quiescent_state(void) ;
#line 90
extern void rcu_bh_force_quiescent_state(void) ;
#line 91
extern void rcu_sched_force_quiescent_state(void) ;
#line 93
extern void exit_rcu(void) ;
#line 95
extern void rcu_scheduler_starting(void) ;
#line 96
extern int rcu_scheduler_active  __attribute__((__section__(".data..read_mostly"))) ;
#line 98
extern bool rcu_is_watching(void) ;
#line 330 "../../../analyzer/../bench/linux-headers/include/linux/rcupdate.h"
__inline static void init_rcu_head(struct callback_head *head )  __attribute__((__no_instrument_function__)) ;
#line 330 "../../../analyzer/../bench/linux-headers/include/linux/rcupdate.h"
__inline static void init_rcu_head(struct callback_head *head ) 
{ 


  {
#line 332
  return;
}
}
#line 334
__inline static void destroy_rcu_head(struct callback_head *head )  __attribute__((__no_instrument_function__)) ;
#line 334 "../../../analyzer/../bench/linux-headers/include/linux/rcupdate.h"
__inline static void destroy_rcu_head(struct callback_head *head ) 
{ 


  {
#line 336
  return;
}
}
#line 338
__inline static void init_rcu_head_on_stack(struct callback_head *head )  __attribute__((__no_instrument_function__)) ;
#line 338 "../../../analyzer/../bench/linux-headers/include/linux/rcupdate.h"
__inline static void init_rcu_head_on_stack(struct callback_head *head ) 
{ 


  {
#line 340
  return;
}
}
#line 342
__inline static void destroy_rcu_head_on_stack(struct callback_head *head )  __attribute__((__no_instrument_function__)) ;
#line 342 "../../../analyzer/../bench/linux-headers/include/linux/rcupdate.h"
__inline static void destroy_rcu_head_on_stack(struct callback_head *head ) 
{ 


  {
#line 344
  return;
}
}
#line 350
__inline static bool rcu_lockdep_current_cpu_online(void)  __attribute__((__no_instrument_function__)) ;
#line 350 "../../../analyzer/../bench/linux-headers/include/linux/rcupdate.h"
__inline static bool rcu_lockdep_current_cpu_online(void) 
{ 


  {
#line 352
  return ((bool )1);
}
}
#line 469
__inline static int rcu_read_lock_held(void)  __attribute__((__no_instrument_function__)) ;
#line 469 "../../../analyzer/../bench/linux-headers/include/linux/rcupdate.h"
__inline static int rcu_read_lock_held(void) 
{ 


  {
#line 471
  return (1);
}
}
#line 474
__inline static int rcu_read_lock_bh_held(void)  __attribute__((__no_instrument_function__)) ;
#line 474 "../../../analyzer/../bench/linux-headers/include/linux/rcupdate.h"
__inline static int rcu_read_lock_bh_held(void) 
{ 


  {
#line 476
  return (1);
}
}
#line 485
__inline static int rcu_read_lock_sched_held(void)  __attribute__((__no_instrument_function__)) ;
#line 485 "../../../analyzer/../bench/linux-headers/include/linux/rcupdate.h"
__inline static int rcu_read_lock_sched_held(void) 
{ 


  {
#line 487
  return (1);
}
}
#line 838
__inline static void rcu_read_lock(void)  __attribute__((__no_instrument_function__)) ;
#line 838 "../../../analyzer/../bench/linux-headers/include/linux/rcupdate.h"
__inline static void rcu_read_lock(void) 
{ 


  {
  {
#line 840
  __rcu_read_lock();
  }
  {
#line 842
  while (1) {
    while_continue: /* CIL Label */ ;
#line 842
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 843
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 843
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 845
  return;
}
}
#line 890
__inline static void rcu_read_unlock(void)  __attribute__((__no_instrument_function__)) ;
#line 890 "../../../analyzer/../bench/linux-headers/include/linux/rcupdate.h"
__inline static void rcu_read_unlock(void) 
{ 


  {
  {
#line 892
  while (1) {
    while_continue: /* CIL Label */ ;
#line 892
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 894
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 894
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 896
  __rcu_read_unlock();
  }
#line 897
  return;
}
}
#line 916
__inline static void rcu_read_lock_bh(void)  __attribute__((__no_instrument_function__)) ;
#line 916 "../../../analyzer/../bench/linux-headers/include/linux/rcupdate.h"
__inline static void rcu_read_lock_bh(void) 
{ 


  {
  {
#line 918
  local_bh_disable();
  }
  {
#line 920
  while (1) {
    while_continue: /* CIL Label */ ;
#line 920
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 921
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 921
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 923
  return;
}
}
#line 930
__inline static void rcu_read_unlock_bh(void)  __attribute__((__no_instrument_function__)) ;
#line 930 "../../../analyzer/../bench/linux-headers/include/linux/rcupdate.h"
__inline static void rcu_read_unlock_bh(void) 
{ 


  {
  {
#line 932
  while (1) {
    while_continue: /* CIL Label */ ;
#line 932
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 934
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 934
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 936
  local_bh_enable();
  }
#line 937
  return;
}
}
#line 952
__inline static void rcu_read_lock_sched(void)  __attribute__((__no_instrument_function__)) ;
#line 952 "../../../analyzer/../bench/linux-headers/include/linux/rcupdate.h"
__inline static void rcu_read_lock_sched(void) 
{ 


  {
  {
#line 954
  __asm__  volatile   ("": : : "memory");
  }
  {
#line 956
  while (1) {
    while_continue: /* CIL Label */ ;
#line 956
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 957
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 957
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 959
  return;
}
}
#line 962
__inline static void rcu_read_lock_sched_notrace(void)  __attribute__((__no_instrument_function__)) ;
#line 962 "../../../analyzer/../bench/linux-headers/include/linux/rcupdate.h"
__inline static void rcu_read_lock_sched_notrace(void) 
{ 


  {
  {
#line 964
  __asm__  volatile   ("": : : "memory");
  }
#line 966
  return;
}
}
#line 973
__inline static void rcu_read_unlock_sched(void)  __attribute__((__no_instrument_function__)) ;
#line 973 "../../../analyzer/../bench/linux-headers/include/linux/rcupdate.h"
__inline static void rcu_read_unlock_sched(void) 
{ 


  {
  {
#line 975
  while (1) {
    while_continue: /* CIL Label */ ;
#line 975
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 977
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 977
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 979
  __asm__  volatile   ("": : : "memory");
  }
#line 980
  return;
}
}
#line 983
__inline static void rcu_read_unlock_sched_notrace(void)  __attribute__((__no_instrument_function__)) ;
#line 983 "../../../analyzer/../bench/linux-headers/include/linux/rcupdate.h"
__inline static void rcu_read_unlock_sched_notrace(void) 
{ 


  {
  {
#line 986
  __asm__  volatile   ("": : : "memory");
  }
#line 987
  return;
}
}
#line 1094
__inline static bool rcu_is_nocb_cpu(int cpu )  __attribute__((__no_instrument_function__)) ;
#line 1094 "../../../analyzer/../bench/linux-headers/include/linux/rcupdate.h"
__inline static bool rcu_is_nocb_cpu(int cpu ) 
{ 


  {
#line 1094
  return ((bool )0);
}
}
#line 1104
__inline static bool rcu_sys_is_idle(void)  __attribute__((__no_instrument_function__)) ;
#line 1104 "../../../analyzer/../bench/linux-headers/include/linux/rcupdate.h"
__inline static bool rcu_sys_is_idle(void) 
{ 


  {
#line 1106
  return ((bool )0);
}
}
#line 1109
__inline static void rcu_sysidle_force_exit(void)  __attribute__((__no_instrument_function__)) ;
#line 1109 "../../../analyzer/../bench/linux-headers/include/linux/rcupdate.h"
__inline static void rcu_sysidle_force_exit(void) 
{ 


  {
#line 1111
  return;
}
}
#line 17 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/tsc.h"
extern unsigned int cpu_khz ;
#line 18
extern unsigned int tsc_khz ;
#line 20
extern void disable_TSC(void) ;
#line 22
__inline static cycles_t get_cycles(void)  __attribute__((__no_instrument_function__)) ;
#line 22 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/tsc.h"
__inline static cycles_t get_cycles(void) 
{ 
  unsigned long long ret ;

  {
  {
#line 24
  ret = 0ULL;
#line 30
  ret = __native_read_tsc();
  }
#line 32
  return (ret);
}
}
#line 35
__inline static cycles_t ( __attribute__((__always_inline__)) vget_cycles)(void)  __attribute__((__no_instrument_function__)) ;
#line 35 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/tsc.h"
__inline static cycles_t ( __attribute__((__always_inline__)) vget_cycles)(void) 
{ 
  unsigned long long tmp ;

  {
  {
#line 45
  tmp = __native_read_tsc();
  }
#line 45
  return (tmp);
}
}
#line 48
extern void tsc_init(void) ;
#line 49
extern void mark_tsc_unstable(char *reason ) ;
#line 50
extern int unsynchronized_tsc(void) ;
#line 51
extern int check_tsc_unstable(void) ;
#line 52
extern int check_tsc_disabled(void) ;
#line 53
extern unsigned long native_calibrate_tsc(void) ;
#line 55
extern int tsc_clocksource_reliable ;
#line 61
extern void check_tsc_sync_source(int cpu ) ;
#line 62
extern void check_tsc_sync_target(void) ;
#line 64
extern int notsc_setup(char * ) ;
#line 65
extern void tsc_save_sched_clock_state(void) ;
#line 66
extern void tsc_restore_sched_clock_state(void) ;
#line 69
extern unsigned long try_msr_calibrate_tsc(void) ;
#line 139 "../../../analyzer/../bench/linux-headers/include/linux/timex.h"
extern unsigned long tick_usec ;
#line 140
extern unsigned long tick_nsec ;
#line 154
extern int do_adjtimex(struct timex * ) ;
#line 155
extern void hardpps(struct timespec  const  * , struct timespec  const  * ) ;
#line 157
extern int read_current_timer(unsigned long *timer_val ) ;
#line 158
extern void ntp_notify_cmos_timer(void) ;
#line 57 "../../../analyzer/../bench/linux-headers/include/linux/jiffies.h"
extern int register_refined_jiffies(long clock_tick_rate ) ;
#line 76
extern u64 jiffies_64  __attribute__((__section__(".data"))) ;
#line 77
extern unsigned long volatile   jiffies  __attribute__((__section__(".data"))) ;
#line 82
__inline static u64 get_jiffies_64(void)  __attribute__((__no_instrument_function__)) ;
#line 82 "../../../analyzer/../bench/linux-headers/include/linux/jiffies.h"
__inline static u64 get_jiffies_64(void) 
{ 


  {
#line 84
  return ((u64 )jiffies);
}
}
#line 182
extern unsigned long preset_lpj ;
#line 283
extern unsigned int jiffies_to_msecs(unsigned long const   j ) ;
#line 284
extern unsigned int jiffies_to_usecs(unsigned long const   j ) ;
#line 286
__inline static u64 jiffies_to_nsecs(unsigned long const   j )  __attribute__((__no_instrument_function__)) ;
#line 286 "../../../analyzer/../bench/linux-headers/include/linux/jiffies.h"
__inline static u64 jiffies_to_nsecs(unsigned long const   j ) 
{ 
  unsigned int tmp ;

  {
  {
#line 288
  tmp = jiffies_to_usecs(j);
  }
#line 288
  return ((u64 )tmp * 1000ULL);
}
}
#line 291
extern unsigned long msecs_to_jiffies(unsigned int const   m ) ;
#line 292
extern unsigned long usecs_to_jiffies(unsigned int const   u ) ;
#line 293
extern unsigned long timespec_to_jiffies(struct timespec  const  *value ) ;
#line 294
extern void jiffies_to_timespec(unsigned long const   jiffies , struct timespec *value ) ;
#line 296
extern unsigned long timeval_to_jiffies(struct timeval  const  *value ) ;
#line 297
extern void jiffies_to_timeval(unsigned long const   jiffies , struct timeval *value ) ;
#line 300
extern clock_t jiffies_to_clock_t(unsigned long x ) ;
#line 301
__inline static clock_t jiffies_delta_to_clock_t(long delta )  __attribute__((__no_instrument_function__)) ;
#line 301 "../../../analyzer/../bench/linux-headers/include/linux/jiffies.h"
__inline static clock_t jiffies_delta_to_clock_t(long delta ) 
{ 
  long _max1 ;
  long _max2 ;
  long tmp ;
  clock_t tmp___0 ;

  {
  {
#line 303
  _max1 = 0L;
#line 303
  _max2 = delta;
  }
#line 303
  if (_max1 > _max2) {
    {
#line 303
    tmp = _max1;
    }
  } else {
    {
#line 303
    tmp = _max2;
    }
  }
  {
#line 303
  tmp___0 = jiffies_to_clock_t((unsigned long )tmp);
  }
#line 303
  return (tmp___0);
}
}
#line 306
extern unsigned long clock_t_to_jiffies(unsigned long x ) ;
#line 307
extern u64 jiffies_64_to_clock_t(u64 x ) ;
#line 308
extern u64 nsec_to_clock_t(u64 x ) ;
#line 309
extern u64 nsecs_to_jiffies64(u64 n ) ;
#line 310
extern unsigned long nsecs_to_jiffies(u64 n ) ;
#line 50 "../../../analyzer/../bench/linux-headers/include/linux/ktime.h"
__inline static ktime_t ktime_set(s64 const   secs , unsigned long const   nsecs )  __attribute__((__no_instrument_function__)) ;
#line 50 "../../../analyzer/../bench/linux-headers/include/linux/ktime.h"
__inline static ktime_t ktime_set(s64 const   secs , unsigned long const   nsecs ) 
{ 
  ktime_t __constr_expr_8 ;
  long tmp ;
  ktime_t __constr_expr_9 ;

  {
  {
#line 52
  tmp = __builtin_expect((long )(! (! (secs >= (s64 const   )((s64 )(~ (1ULL << 63)) / 1000000000LL)))),
                         0L);
  }
#line 52
  if (tmp) {
    {
#line 53
    __constr_expr_8.tv64 = (s64 )(~ (1ULL << 63));
    }
#line 53
    return (__constr_expr_8);
  }
  {
#line 55
  __constr_expr_9.tv64 = (s64 )(secs * 1000000000LL + (s64 const   )((s64 )nsecs));
  }
#line 55
  return (__constr_expr_9);
}
}
#line 81
__inline static ktime_t timespec_to_ktime(struct timespec ts )  __attribute__((__no_instrument_function__)) ;
#line 81 "../../../analyzer/../bench/linux-headers/include/linux/ktime.h"
__inline static ktime_t timespec_to_ktime(struct timespec ts ) 
{ 
  ktime_t tmp ;

  {
  {
#line 83
  tmp = ktime_set((s64 const   )ts.tv_sec, (unsigned long const   )ts.tv_nsec);
  }
#line 83
  return (tmp);
}
}
#line 87
__inline static ktime_t timespec64_to_ktime(struct timespec ts )  __attribute__((__no_instrument_function__)) ;
#line 87 "../../../analyzer/../bench/linux-headers/include/linux/ktime.h"
__inline static ktime_t timespec64_to_ktime(struct timespec ts ) 
{ 
  ktime_t tmp ;

  {
  {
#line 89
  tmp = ktime_set((s64 const   )ts.tv_sec, (unsigned long const   )ts.tv_nsec);
  }
#line 89
  return (tmp);
}
}
#line 93
__inline static ktime_t timeval_to_ktime(struct timeval tv )  __attribute__((__no_instrument_function__)) ;
#line 93 "../../../analyzer/../bench/linux-headers/include/linux/ktime.h"
__inline static ktime_t timeval_to_ktime(struct timeval tv ) 
{ 
  ktime_t tmp ;

  {
  {
#line 95
  tmp = ktime_set((s64 const   )tv.tv_sec, (unsigned long const   )(tv.tv_usec * 1000L));
  }
#line 95
  return (tmp);
}
}
#line 120
__inline static int ktime_equal(ktime_t const   cmp1 , ktime_t const   cmp2 )  __attribute__((__no_instrument_function__)) ;
#line 120 "../../../analyzer/../bench/linux-headers/include/linux/ktime.h"
__inline static int ktime_equal(ktime_t const   cmp1 , ktime_t const   cmp2 ) 
{ 


  {
#line 122
  return (cmp1.tv64 == cmp2.tv64);
}
}
#line 135
__inline static int ktime_compare(ktime_t const   cmp1 , ktime_t const   cmp2 )  __attribute__((__no_instrument_function__)) ;
#line 135 "../../../analyzer/../bench/linux-headers/include/linux/ktime.h"
__inline static int ktime_compare(ktime_t const   cmp1 , ktime_t const   cmp2 ) 
{ 


  {
#line 137
  if (cmp1.tv64 < cmp2.tv64) {
#line 138
    return (-1);
  }
#line 139
  if (cmp1.tv64 > cmp2.tv64) {
#line 140
    return (1);
  }
#line 141
  return (0);
}
}
#line 151
__inline static bool ktime_after(ktime_t const   cmp1 , ktime_t const   cmp2 )  __attribute__((__no_instrument_function__)) ;
#line 151 "../../../analyzer/../bench/linux-headers/include/linux/ktime.h"
__inline static bool ktime_after(ktime_t const   cmp1 , ktime_t const   cmp2 ) 
{ 
  int tmp ;

  {
  {
#line 153
  tmp = ktime_compare(cmp1, cmp2);
  }
#line 153
  return ((bool )(tmp > 0));
}
}
#line 163
__inline static bool ktime_before(ktime_t const   cmp1 , ktime_t const   cmp2 )  __attribute__((__no_instrument_function__)) ;
#line 163 "../../../analyzer/../bench/linux-headers/include/linux/ktime.h"
__inline static bool ktime_before(ktime_t const   cmp1 , ktime_t const   cmp2 ) 
{ 
  int tmp ;

  {
  {
#line 165
  tmp = ktime_compare(cmp1, cmp2);
  }
#line 165
  return ((bool )(tmp < 0));
}
}
#line 174
__inline static s64 ktime_to_us(ktime_t const   kt )  __attribute__((__no_instrument_function__)) ;
#line 174 "../../../analyzer/../bench/linux-headers/include/linux/ktime.h"
__inline static s64 ktime_to_us(ktime_t const   kt ) 
{ 


  {
#line 176
  return ((s64 )((u64 )(kt.tv64 / 1000LL)));
}
}
#line 179
__inline static s64 ktime_to_ms(ktime_t const   kt )  __attribute__((__no_instrument_function__)) ;
#line 179 "../../../analyzer/../bench/linux-headers/include/linux/ktime.h"
__inline static s64 ktime_to_ms(ktime_t const   kt ) 
{ 


  {
#line 181
  return ((s64 )((u64 )(kt.tv64 / 1000000LL)));
}
}
#line 184
__inline static s64 ktime_us_delta(ktime_t const   later , ktime_t const   earlier )  __attribute__((__no_instrument_function__)) ;
#line 184 "../../../analyzer/../bench/linux-headers/include/linux/ktime.h"
__inline static s64 ktime_us_delta(ktime_t const   later , ktime_t const   earlier ) 
{ 
  ktime_t __constr_expr_10 ;
  s64 tmp ;

  {
  {
#line 186
  __constr_expr_10.tv64 = (s64 )(later.tv64 - earlier.tv64);
#line 186
  tmp = ktime_to_us((ktime_t const   )__constr_expr_10);
  }
#line 186
  return (tmp);
}
}
#line 189
__inline static ktime_t ktime_add_us(ktime_t const   kt , u64 const   usec )  __attribute__((__no_instrument_function__)) ;
#line 189 "../../../analyzer/../bench/linux-headers/include/linux/ktime.h"
__inline static ktime_t ktime_add_us(ktime_t const   kt , u64 const   usec ) 
{ 
  ktime_t __constr_expr_11 ;

  {
  {
#line 191
  __constr_expr_11.tv64 = (s64 )((u64 const   )kt.tv64 + usec * 1000ULL);
  }
#line 191
  return (__constr_expr_11);
}
}
#line 194
__inline static ktime_t ktime_add_ms(ktime_t const   kt , u64 const   msec )  __attribute__((__no_instrument_function__)) ;
#line 194 "../../../analyzer/../bench/linux-headers/include/linux/ktime.h"
__inline static ktime_t ktime_add_ms(ktime_t const   kt , u64 const   msec ) 
{ 
  ktime_t __constr_expr_12 ;

  {
  {
#line 196
  __constr_expr_12.tv64 = (s64 )((u64 const   )kt.tv64 + msec * 1000000ULL);
  }
#line 196
  return (__constr_expr_12);
}
}
#line 199
__inline static ktime_t ktime_sub_us(ktime_t const   kt , u64 const   usec )  __attribute__((__no_instrument_function__)) ;
#line 199 "../../../analyzer/../bench/linux-headers/include/linux/ktime.h"
__inline static ktime_t ktime_sub_us(ktime_t const   kt , u64 const   usec ) 
{ 
  ktime_t __constr_expr_13 ;

  {
  {
#line 201
  __constr_expr_13.tv64 = (s64 )((u64 const   )kt.tv64 - usec * 1000ULL);
  }
#line 201
  return (__constr_expr_13);
}
}
#line 204
extern ktime_t ktime_add_safe(ktime_t const   lhs , ktime_t const   rhs ) ;
#line 214
__inline static bool ( __attribute__((__warn_unused_result__)) ktime_to_timespec_cond)(ktime_t const   kt ,
                                                                                       struct timespec *ts )  __attribute__((__no_instrument_function__)) ;
#line 214 "../../../analyzer/../bench/linux-headers/include/linux/ktime.h"
__inline static bool ( __attribute__((__warn_unused_result__)) ktime_to_timespec_cond)(ktime_t const   kt ,
                                                                                       struct timespec *ts ) 
{ 


  {
#line 217
  if (kt.tv64) {
    {
#line 218
    *ts = ns_to_timespec(kt.tv64);
    }
#line 219
    return ((bool )1);
  } else {
#line 221
    return ((bool )0);
  }
}
}
#line 233
__inline static bool ( __attribute__((__warn_unused_result__)) ktime_to_timespec64_cond)(ktime_t const   kt ,
                                                                                         struct timespec *ts )  __attribute__((__no_instrument_function__)) ;
#line 233 "../../../analyzer/../bench/linux-headers/include/linux/ktime.h"
__inline static bool ( __attribute__((__warn_unused_result__)) ktime_to_timespec64_cond)(ktime_t const   kt ,
                                                                                         struct timespec *ts ) 
{ 


  {
#line 236
  if (kt.tv64) {
    {
#line 237
    *ts = ns_to_timespec(kt.tv64);
    }
#line 238
    return ((bool )1);
  } else {
#line 240
    return ((bool )0);
  }
}
}
#line 255
__inline static ktime_t ns_to_ktime(u64 ns )  __attribute__((__no_instrument_function__)) ;
#line 255 "../../../analyzer/../bench/linux-headers/include/linux/ktime.h"
static union ktime  const  ktime_zero  =    {(s64 )0};
#line 253
__inline static ktime_t ns_to_ktime(u64 ns )  __attribute__((__no_instrument_function__)) ;
#line 253 "../../../analyzer/../bench/linux-headers/include/linux/ktime.h"
__inline static ktime_t ns_to_ktime(u64 ns ) 
{ 
  ktime_t __constr_expr_14 ;

  {
  {
#line 257
  __constr_expr_14.tv64 = (s64 )((u64 )ktime_zero.tv64 + ns);
  }
#line 257
  return (__constr_expr_14);
}
}
#line 262
__inline static ktime_t ms_to_ktime(u64 ms )  __attribute__((__no_instrument_function__)) ;
#line 262 "../../../analyzer/../bench/linux-headers/include/linux/ktime.h"
static union ktime  const  ktime_zero___0  =    {(s64 )0};
#line 260
__inline static ktime_t ms_to_ktime(u64 ms )  __attribute__((__no_instrument_function__)) ;
#line 260 "../../../analyzer/../bench/linux-headers/include/linux/ktime.h"
__inline static ktime_t ms_to_ktime(u64 ms ) 
{ 
  ktime_t tmp ;

  {
  {
#line 264
  tmp = ktime_add_ms(ktime_zero___0, (u64 const   )ms);
  }
#line 264
  return (tmp);
}
}
#line 6 "../../../analyzer/../bench/linux-headers/include/linux/timekeeping.h"
extern void timekeeping_init(void) ;
#line 7
extern int timekeeping_suspended ;
#line 12
extern void do_gettimeofday(struct timeval *tv ) ;
#line 13
extern int do_settimeofday(struct timespec  const  *tv ) ;
#line 14
extern int do_sys_settimeofday(struct timespec  const  *tv , struct timezone  const  *tz ) ;
#line 20
extern unsigned long get_seconds(void) ;
#line 21
extern struct timespec current_kernel_time(void) ;
#line 23
extern struct timespec __current_kernel_time(void) ;
#line 28
extern struct timespec get_monotonic_coarse(void) ;
#line 29
extern void getrawmonotonic(struct timespec *ts ) ;
#line 30
extern void ktime_get_ts64(struct timespec *ts ) ;
#line 32
extern int __getnstimeofday64(struct timespec *tv ) ;
#line 33
extern void getnstimeofday64(struct timespec *tv ) ;
#line 36
__inline static int __getnstimeofday(struct timespec *ts )  __attribute__((__no_instrument_function__)) ;
#line 36 "../../../analyzer/../bench/linux-headers/include/linux/timekeeping.h"
__inline static int __getnstimeofday(struct timespec *ts ) 
{ 
  int tmp ;

  {
  {
#line 38
  tmp = __getnstimeofday64(ts);
  }
#line 38
  return (tmp);
}
}
#line 41
__inline static void getnstimeofday(struct timespec *ts )  __attribute__((__no_instrument_function__)) ;
#line 41 "../../../analyzer/../bench/linux-headers/include/linux/timekeeping.h"
__inline static void getnstimeofday(struct timespec *ts ) 
{ 


  {
  {
#line 43
  getnstimeofday64(ts);
  }
#line 44
  return;
}
}
#line 46
__inline static void ktime_get_ts(struct timespec *ts )  __attribute__((__no_instrument_function__)) ;
#line 46 "../../../analyzer/../bench/linux-headers/include/linux/timekeeping.h"
__inline static void ktime_get_ts(struct timespec *ts ) 
{ 


  {
  {
#line 48
  ktime_get_ts64(ts);
  }
#line 49
  return;
}
}
#line 51
__inline static void ktime_get_real_ts(struct timespec *ts )  __attribute__((__no_instrument_function__)) ;
#line 51 "../../../analyzer/../bench/linux-headers/include/linux/timekeeping.h"
__inline static void ktime_get_real_ts(struct timespec *ts ) 
{ 


  {
  {
#line 53
  getnstimeofday64(ts);
  }
#line 54
  return;
}
}
#line 91
extern void getboottime(struct timespec *ts ) ;
#line 107
extern ktime_t ktime_get(void) ;
#line 108
extern ktime_t ktime_get_with_offset(enum tk_offsets offs ) ;
#line 109
extern ktime_t ktime_mono_to_any(ktime_t tmono , enum tk_offsets offs ) ;
#line 110
extern ktime_t ktime_get_raw(void) ;
#line 115
__inline static ktime_t ktime_get_real(void)  __attribute__((__no_instrument_function__)) ;
#line 115 "../../../analyzer/../bench/linux-headers/include/linux/timekeeping.h"
__inline static ktime_t ktime_get_real(void) 
{ 
  ktime_t tmp ;

  {
  {
#line 117
  tmp = ktime_get_with_offset((enum tk_offsets )0);
  }
#line 117
  return (tmp);
}
}
#line 126
__inline static ktime_t ktime_get_boottime(void)  __attribute__((__no_instrument_function__)) ;
#line 126 "../../../analyzer/../bench/linux-headers/include/linux/timekeeping.h"
__inline static ktime_t ktime_get_boottime(void) 
{ 
  ktime_t tmp ;

  {
  {
#line 128
  tmp = ktime_get_with_offset((enum tk_offsets )1);
  }
#line 128
  return (tmp);
}
}
#line 134
__inline static ktime_t ktime_get_clocktai(void)  __attribute__((__no_instrument_function__)) ;
#line 134 "../../../analyzer/../bench/linux-headers/include/linux/timekeeping.h"
__inline static ktime_t ktime_get_clocktai(void) 
{ 
  ktime_t tmp ;

  {
  {
#line 136
  tmp = ktime_get_with_offset((enum tk_offsets )2);
  }
#line 136
  return (tmp);
}
}
#line 142
__inline static ktime_t ktime_mono_to_real(ktime_t mono )  __attribute__((__no_instrument_function__)) ;
#line 142 "../../../analyzer/../bench/linux-headers/include/linux/timekeeping.h"
__inline static ktime_t ktime_mono_to_real(ktime_t mono ) 
{ 
  ktime_t tmp ;

  {
  {
#line 144
  tmp = ktime_mono_to_any(mono, (enum tk_offsets )0);
  }
#line 144
  return (tmp);
}
}
#line 147
__inline static u64 ktime_get_ns(void)  __attribute__((__no_instrument_function__)) ;
#line 147 "../../../analyzer/../bench/linux-headers/include/linux/timekeeping.h"
__inline static u64 ktime_get_ns(void) 
{ 
  ktime_t tmp ;

  {
  {
#line 149
  tmp = ktime_get();
  }
#line 149
  return ((u64 )tmp.tv64);
}
}
#line 152
__inline static u64 ktime_get_real_ns(void)  __attribute__((__no_instrument_function__)) ;
#line 152 "../../../analyzer/../bench/linux-headers/include/linux/timekeeping.h"
__inline static u64 ktime_get_real_ns(void) 
{ 
  ktime_t tmp ;

  {
  {
#line 154
  tmp = ktime_get_real();
  }
#line 154
  return ((u64 )tmp.tv64);
}
}
#line 157
__inline static u64 ktime_get_boot_ns(void)  __attribute__((__no_instrument_function__)) ;
#line 157 "../../../analyzer/../bench/linux-headers/include/linux/timekeeping.h"
__inline static u64 ktime_get_boot_ns(void) 
{ 
  ktime_t tmp ;

  {
  {
#line 159
  tmp = ktime_get_boottime();
  }
#line 159
  return ((u64 )tmp.tv64);
}
}
#line 162
__inline static u64 ktime_get_raw_ns(void)  __attribute__((__no_instrument_function__)) ;
#line 162 "../../../analyzer/../bench/linux-headers/include/linux/timekeeping.h"
__inline static u64 ktime_get_raw_ns(void) 
{ 
  ktime_t tmp ;

  {
  {
#line 164
  tmp = ktime_get_raw();
  }
#line 164
  return ((u64 )tmp.tv64);
}
}
#line 167
extern u64 ktime_get_mono_fast_ns(void) ;
#line 172
__inline static void get_monotonic_boottime(struct timespec *ts )  __attribute__((__no_instrument_function__)) ;
#line 172 "../../../analyzer/../bench/linux-headers/include/linux/timekeeping.h"
__inline static void get_monotonic_boottime(struct timespec *ts ) 
{ 
  ktime_t tmp ;

  {
  {
#line 174
  tmp = ktime_get_boottime();
#line 174
  *ts = ns_to_timespec((s64 const   )tmp.tv64);
  }
#line 175
  return;
}
}
#line 177
__inline static void timekeeping_clocktai(struct timespec *ts )  __attribute__((__no_instrument_function__)) ;
#line 177 "../../../analyzer/../bench/linux-headers/include/linux/timekeeping.h"
__inline static void timekeeping_clocktai(struct timespec *ts ) 
{ 
  ktime_t tmp ;

  {
  {
#line 179
  tmp = ktime_get_clocktai();
#line 179
  *ts = ns_to_timespec((s64 const   )tmp.tv64);
  }
#line 180
  return;
}
}
#line 185
extern void timekeeping_inject_sleeptime(struct timespec *delta ) ;
#line 190
extern void getnstime_raw_and_real(struct timespec *ts_raw , struct timespec *ts_real ) ;
#line 196
extern bool persistent_clock_exist ;
#line 197
extern int persistent_clock_is_local ;
#line 199
__inline static bool has_persistent_clock(void)  __attribute__((__no_instrument_function__)) ;
#line 199 "../../../analyzer/../bench/linux-headers/include/linux/timekeeping.h"
__inline static bool has_persistent_clock(void) 
{ 


  {
#line 201
  return (persistent_clock_exist);
}
}
#line 204
extern void read_persistent_clock(struct timespec *ts ) ;
#line 205
extern void read_boot_clock(struct timespec *ts ) ;
#line 206
extern int update_persistent_clock(struct timespec now ) ;
#line 36 "../../../analyzer/../bench/linux-headers/include/linux/timer.h"
extern struct tvec_base boot_tvec_bases ;
#line 94
extern void init_timer_key(struct timer_list *timer , unsigned int flags , char const   *name ,
                           struct lock_class_key *key ) ;
#line 103
__inline static void destroy_timer_on_stack(struct timer_list *timer )  __attribute__((__no_instrument_function__)) ;
#line 103 "../../../analyzer/../bench/linux-headers/include/linux/timer.h"
__inline static void destroy_timer_on_stack(struct timer_list *timer ) 
{ 


  {
#line 103
  return;
}
}
#line 104
__inline static void init_timer_on_stack_key(struct timer_list *timer , unsigned int flags ,
                                             char const   *name , struct lock_class_key *key )  __attribute__((__no_instrument_function__)) ;
#line 104 "../../../analyzer/../bench/linux-headers/include/linux/timer.h"
__inline static void init_timer_on_stack_key(struct timer_list *timer , unsigned int flags ,
                                             char const   *name , struct lock_class_key *key ) 
{ 


  {
  {
#line 108
  init_timer_key(timer, flags, name, key);
  }
#line 109
  return;
}
}
#line 169
__inline static int timer_pending(struct timer_list  const  *timer )  __attribute__((__no_instrument_function__)) ;
#line 169 "../../../analyzer/../bench/linux-headers/include/linux/timer.h"
__inline static int timer_pending(struct timer_list  const  *timer ) 
{ 


  {
#line 171
  return ((unsigned long )timer->entry.next != (unsigned long )((void *)0));
}
}
#line 174
extern void add_timer_on(struct timer_list *timer , int cpu ) ;
#line 175
extern int del_timer(struct timer_list *timer ) ;
#line 176
extern int mod_timer(struct timer_list *timer , unsigned long expires ) ;
#line 177
extern int mod_timer_pending(struct timer_list *timer , unsigned long expires ) ;
#line 178
extern int mod_timer_pinned(struct timer_list *timer , unsigned long expires ) ;
#line 180
extern void set_timer_slack(struct timer_list *time , int slack_hz ) ;
#line 195
extern unsigned long get_next_timer_interrupt(unsigned long now ) ;
#line 202
extern int timer_stats_active ;
#line 206
extern void init_timer_stats(void) ;
#line 208
extern void timer_stats_update_stats(void *timer , pid_t pid , void *startf , void *timerf ,
                                     char *comm , unsigned int timer_flag ) ;
#line 212
extern void __timer_stats_timer_set_start_info(struct timer_list *timer , void *addr ) ;
#line 215
__inline static void timer_stats_timer_set_start_info(struct timer_list *timer )  __attribute__((__no_instrument_function__)) ;
#line 215 "../../../analyzer/../bench/linux-headers/include/linux/timer.h"
__inline static void timer_stats_timer_set_start_info(struct timer_list *timer ) 
{ 
  long tmp ;
  void *tmp___0 ;

  {
  {
#line 217
  tmp = __builtin_expect((long )(! (! (! timer_stats_active))), 1L);
  }
#line 217
  if (tmp) {
#line 218
    return;
  }
  {
#line 219
  tmp___0 = __builtin_return_address(0U);
#line 219
  __timer_stats_timer_set_start_info(timer, tmp___0);
  }
#line 220
  return;
}
}
#line 222
__inline static void timer_stats_timer_clear_start_info(struct timer_list *timer )  __attribute__((__no_instrument_function__)) ;
#line 222 "../../../analyzer/../bench/linux-headers/include/linux/timer.h"
__inline static void timer_stats_timer_clear_start_info(struct timer_list *timer ) 
{ 


  {
  {
#line 224
  timer->start_site = (void *)0;
  }
#line 225
  return;
}
}
#line 240
extern void add_timer(struct timer_list *timer ) ;
#line 242
extern int try_to_del_timer_sync(struct timer_list *timer ) ;
#line 245
extern int del_timer_sync(struct timer_list *timer ) ;
#line 252
extern void init_timers(void) ;
#line 253
extern void run_local_timers(void) ;
#line 255
extern enum hrtimer_restart it_real_fn(struct hrtimer * ) ;
#line 257
extern unsigned long __round_jiffies(unsigned long j , int cpu ) ;
#line 258
extern unsigned long __round_jiffies_relative(unsigned long j , int cpu ) ;
#line 259
extern unsigned long round_jiffies(unsigned long j ) ;
#line 260
extern unsigned long round_jiffies_relative(unsigned long j ) ;
#line 262
extern unsigned long __round_jiffies_up(unsigned long j , int cpu ) ;
#line 263
extern unsigned long __round_jiffies_up_relative(unsigned long j , int cpu ) ;
#line 264
extern unsigned long round_jiffies_up(unsigned long j ) ;
#line 265
extern unsigned long round_jiffies_up_relative(unsigned long j ) ;
#line 20 "../../../analyzer/../bench/linux-headers/include/linux/workqueue.h"
extern void delayed_work_timer_fn(unsigned long __data ) ;
#line 135
__inline static struct delayed_work *to_delayed_work(struct work_struct *work )  __attribute__((__no_instrument_function__)) ;
#line 135 "../../../analyzer/../bench/linux-headers/include/linux/workqueue.h"
__inline static struct delayed_work *to_delayed_work(struct work_struct *work ) 
{ 
  struct work_struct  const  *__mptr ;

  {
  {
#line 137
  __mptr = (struct work_struct  const  *)work;
  }
#line 137
  return ((struct delayed_work *)((char *)__mptr - (unsigned long )(& ((struct delayed_work *)0)->work)));
}
}
#line 188
__inline static void __init_work(struct work_struct *work , int onstack )  __attribute__((__no_instrument_function__)) ;
#line 188 "../../../analyzer/../bench/linux-headers/include/linux/workqueue.h"
__inline static void __init_work(struct work_struct *work , int onstack ) 
{ 


  {
#line 188
  return;
}
}
#line 189
__inline static void destroy_work_on_stack(struct work_struct *work )  __attribute__((__no_instrument_function__)) ;
#line 189 "../../../analyzer/../bench/linux-headers/include/linux/workqueue.h"
__inline static void destroy_work_on_stack(struct work_struct *work ) 
{ 


  {
#line 189
  return;
}
}
#line 190
__inline static void destroy_delayed_work_on_stack(struct delayed_work *work )  __attribute__((__no_instrument_function__)) ;
#line 190 "../../../analyzer/../bench/linux-headers/include/linux/workqueue.h"
__inline static void destroy_delayed_work_on_stack(struct delayed_work *work ) 
{ 


  {
#line 190
  return;
}
}
#line 191
__inline static unsigned int work_static(struct work_struct *work )  __attribute__((__no_instrument_function__)) ;
#line 191 "../../../analyzer/../bench/linux-headers/include/linux/workqueue.h"
__inline static unsigned int work_static(struct work_struct *work ) 
{ 


  {
#line 191
  return (0U);
}
}
#line 355
extern struct workqueue_struct *system_wq ;
#line 356
extern struct workqueue_struct *system_highpri_wq ;
#line 357
extern struct workqueue_struct *system_long_wq ;
#line 358
extern struct workqueue_struct *system_unbound_wq ;
#line 359
extern struct workqueue_struct *system_freezable_wq ;
#line 360
extern struct workqueue_struct *system_power_efficient_wq ;
#line 361
extern struct workqueue_struct *system_freezable_power_efficient_wq ;
#line 363
extern struct workqueue_struct *( /* format attribute */  __alloc_workqueue_key)(char const   *fmt ,
                                                                                 unsigned int flags ,
                                                                                 int max_active ,
                                                                                 struct lock_class_key *key ,
                                                                                 char const   *lock_name 
                                                                                 , ...) ;
#line 424
extern void destroy_workqueue(struct workqueue_struct *wq ) ;
#line 426
extern struct workqueue_attrs *alloc_workqueue_attrs(gfp_t gfp_mask ) ;
#line 427
extern void free_workqueue_attrs(struct workqueue_attrs *attrs ) ;
#line 428
extern int apply_workqueue_attrs(struct workqueue_struct *wq , struct workqueue_attrs  const  *attrs ) ;
#line 431
extern bool queue_work_on(int cpu , struct workqueue_struct *wq , struct work_struct *work ) ;
#line 433
extern bool queue_delayed_work_on(int cpu , struct workqueue_struct *wq , struct delayed_work *work ,
                                  unsigned long delay ) ;
#line 435
extern bool mod_delayed_work_on(int cpu , struct workqueue_struct *wq , struct delayed_work *dwork ,
                                unsigned long delay ) ;
#line 438
extern void flush_workqueue(struct workqueue_struct *wq ) ;
#line 439
extern void drain_workqueue(struct workqueue_struct *wq ) ;
#line 440
extern void flush_scheduled_work(void) ;
#line 442
extern int schedule_on_each_cpu(void (*func)(struct work_struct *work ) ) ;
#line 444
extern int execute_in_process_context(void (*fn)(struct work_struct *work ) , struct execute_work * ) ;
#line 446
extern bool flush_work(struct work_struct *work ) ;
#line 447
extern bool cancel_work_sync(struct work_struct *work ) ;
#line 449
extern bool flush_delayed_work(struct delayed_work *dwork ) ;
#line 450
extern bool cancel_delayed_work(struct delayed_work *dwork ) ;
#line 451
extern bool cancel_delayed_work_sync(struct delayed_work *dwork ) ;
#line 453
extern void workqueue_set_max_active(struct workqueue_struct *wq , int max_active ) ;
#line 455
extern bool current_is_workqueue_rescuer(void) ;
#line 456
extern bool workqueue_congested(int cpu , struct workqueue_struct *wq ) ;
#line 457
extern unsigned int work_busy(struct work_struct *work ) ;
#line 458
extern void ( /* format attribute */  set_worker_desc)(char const   *fmt  , ...) ;
#line 459
extern void print_worker_info(char const   *log_lvl , struct task_struct *task ) ;
#line 471
__inline static bool queue_work(struct workqueue_struct *wq , struct work_struct *work )  __attribute__((__no_instrument_function__)) ;
#line 471 "../../../analyzer/../bench/linux-headers/include/linux/workqueue.h"
__inline static bool queue_work(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
  {
#line 474
  tmp = queue_work_on(64, wq, work);
  }
#line 474
  return (tmp);
}
}
#line 485
__inline static bool queue_delayed_work(struct workqueue_struct *wq , struct delayed_work *dwork ,
                                        unsigned long delay )  __attribute__((__no_instrument_function__)) ;
#line 485 "../../../analyzer/../bench/linux-headers/include/linux/workqueue.h"
__inline static bool queue_delayed_work(struct workqueue_struct *wq , struct delayed_work *dwork ,
                                        unsigned long delay ) 
{ 
  bool tmp ;

  {
  {
#line 489
  tmp = queue_delayed_work_on(64, wq, dwork, delay);
  }
#line 489
  return (tmp);
}
}
#line 500
__inline static bool mod_delayed_work(struct workqueue_struct *wq , struct delayed_work *dwork ,
                                      unsigned long delay )  __attribute__((__no_instrument_function__)) ;
#line 500 "../../../analyzer/../bench/linux-headers/include/linux/workqueue.h"
__inline static bool mod_delayed_work(struct workqueue_struct *wq , struct delayed_work *dwork ,
                                      unsigned long delay ) 
{ 
  bool tmp ;

  {
  {
#line 504
  tmp = mod_delayed_work_on(64, wq, dwork, delay);
  }
#line 504
  return (tmp);
}
}
#line 514
__inline static bool schedule_work_on(int cpu , struct work_struct *work )  __attribute__((__no_instrument_function__)) ;
#line 514 "../../../analyzer/../bench/linux-headers/include/linux/workqueue.h"
__inline static bool schedule_work_on(int cpu , struct work_struct *work ) 
{ 
  bool tmp ;

  {
  {
#line 516
  tmp = queue_work_on(cpu, system_wq, work);
  }
#line 516
  return (tmp);
}
}
#line 530
__inline static bool schedule_work(struct work_struct *work )  __attribute__((__no_instrument_function__)) ;
#line 530 "../../../analyzer/../bench/linux-headers/include/linux/workqueue.h"
__inline static bool schedule_work(struct work_struct *work ) 
{ 
  bool tmp ;

  {
  {
#line 532
  tmp = queue_work(system_wq, work);
  }
#line 532
  return (tmp);
}
}
#line 544
__inline static bool schedule_delayed_work_on(int cpu , struct delayed_work *dwork ,
                                              unsigned long delay )  __attribute__((__no_instrument_function__)) ;
#line 544 "../../../analyzer/../bench/linux-headers/include/linux/workqueue.h"
__inline static bool schedule_delayed_work_on(int cpu , struct delayed_work *dwork ,
                                              unsigned long delay ) 
{ 
  bool tmp ;

  {
  {
#line 547
  tmp = queue_delayed_work_on(cpu, system_wq, dwork, delay);
  }
#line 547
  return (tmp);
}
}
#line 558
__inline static bool schedule_delayed_work(struct delayed_work *dwork , unsigned long delay )  __attribute__((__no_instrument_function__)) ;
#line 558 "../../../analyzer/../bench/linux-headers/include/linux/workqueue.h"
__inline static bool schedule_delayed_work(struct delayed_work *dwork , unsigned long delay ) 
{ 
  bool tmp ;

  {
  {
#line 561
  tmp = queue_delayed_work(system_wq, dwork, delay);
  }
#line 561
  return (tmp);
}
}
#line 567
__inline static bool keventd_up(void)  __attribute__((__no_instrument_function__)) ;
#line 567 "../../../analyzer/../bench/linux-headers/include/linux/workqueue.h"
__inline static bool keventd_up(void) 
{ 


  {
#line 569
  return ((bool )((unsigned long )system_wq != (unsigned long )((void *)0)));
}
}
#line 578
extern long work_on_cpu(int cpu , long (*fn)(void * ) , void *arg ) ;
#line 582
extern void freeze_workqueues_begin(void) ;
#line 583
extern bool freeze_workqueues_busy(void) ;
#line 584
extern void thaw_workqueues(void) ;
#line 588
extern int workqueue_sysfs_register(struct workqueue_struct *wq ) ;
#line 80 "../../../analyzer/../bench/linux-headers/include/linux/srcu.h"
extern int init_srcu_struct(struct srcu_struct *sp ) ;
#line 85
extern void process_srcu(struct work_struct *work ) ;
#line 130
extern void call_srcu(struct srcu_struct *sp , struct callback_head *head , void (*func)(struct callback_head *head ) ) ;
#line 133
extern void cleanup_srcu_struct(struct srcu_struct *sp ) ;
#line 134
extern int __srcu_read_lock(struct srcu_struct *sp ) ;
#line 135
extern void __srcu_read_unlock(struct srcu_struct *sp , int idx ) ;
#line 136
extern void synchronize_srcu(struct srcu_struct *sp ) ;
#line 137
extern void synchronize_srcu_expedited(struct srcu_struct *sp ) ;
#line 138
extern long srcu_batches_completed(struct srcu_struct *sp ) ;
#line 139
extern void srcu_barrier(struct srcu_struct *sp ) ;
#line 167
__inline static int srcu_read_lock_held(struct srcu_struct *sp )  __attribute__((__no_instrument_function__)) ;
#line 167 "../../../analyzer/../bench/linux-headers/include/linux/srcu.h"
__inline static int srcu_read_lock_held(struct srcu_struct *sp ) 
{ 


  {
#line 169
  return (1);
}
}
#line 218
__inline static int srcu_read_lock(struct srcu_struct *sp )  __attribute__((__no_instrument_function__)) ;
#line 218 "../../../analyzer/../bench/linux-headers/include/linux/srcu.h"
__inline static int srcu_read_lock(struct srcu_struct *sp ) 
{ 
  int retval ;
  int tmp ;

  {
  {
#line 220
  tmp = __srcu_read_lock(sp);
#line 220
  retval = tmp;
  }
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 222
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  return (retval);
}
}
#line 233
__inline static void srcu_read_unlock(struct srcu_struct *sp , int idx )  __attribute__((__no_instrument_function__)) ;
#line 233 "../../../analyzer/../bench/linux-headers/include/linux/srcu.h"
__inline static void srcu_read_unlock(struct srcu_struct *sp , int idx ) 
{ 


  {
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 237
  __srcu_read_unlock(sp, idx);
  }
#line 238
  return;
}
}
#line 249
__inline static void smp_mb__after_srcu_read_unlock(void)  __attribute__((__no_instrument_function__)) ;
#line 249 "../../../analyzer/../bench/linux-headers/include/linux/srcu.h"
__inline static void smp_mb__after_srcu_read_unlock(void) 
{ 


  {
#line 252
  return;
}
}
#line 92 "../../../analyzer/../bench/linux-headers/include/linux/notifier.h"
extern void srcu_init_notifier_head(struct srcu_notifier_head *nh ) ;
#line 118
extern int atomic_notifier_chain_register(struct atomic_notifier_head *nh , struct notifier_block *nb ) ;
#line 120
extern int blocking_notifier_chain_register(struct blocking_notifier_head *nh , struct notifier_block *nb ) ;
#line 122
extern int raw_notifier_chain_register(struct raw_notifier_head *nh , struct notifier_block *nb ) ;
#line 124
extern int srcu_notifier_chain_register(struct srcu_notifier_head *nh , struct notifier_block *nb ) ;
#line 127
extern int blocking_notifier_chain_cond_register(struct blocking_notifier_head *nh ,
                                                 struct notifier_block *nb ) ;
#line 131
extern int atomic_notifier_chain_unregister(struct atomic_notifier_head *nh , struct notifier_block *nb ) ;
#line 133
extern int blocking_notifier_chain_unregister(struct blocking_notifier_head *nh ,
                                              struct notifier_block *nb ) ;
#line 135
extern int raw_notifier_chain_unregister(struct raw_notifier_head *nh , struct notifier_block *nb ) ;
#line 137
extern int srcu_notifier_chain_unregister(struct srcu_notifier_head *nh , struct notifier_block *nb ) ;
#line 140
extern int atomic_notifier_call_chain(struct atomic_notifier_head *nh , unsigned long val ,
                                      void *v ) ;
#line 142
extern int __atomic_notifier_call_chain(struct atomic_notifier_head *nh , unsigned long val ,
                                        void *v , int nr_to_call , int *nr_calls ) ;
#line 144
extern int blocking_notifier_call_chain(struct blocking_notifier_head *nh , unsigned long val ,
                                        void *v ) ;
#line 146
extern int __blocking_notifier_call_chain(struct blocking_notifier_head *nh , unsigned long val ,
                                          void *v , int nr_to_call , int *nr_calls ) ;
#line 148
extern int raw_notifier_call_chain(struct raw_notifier_head *nh , unsigned long val ,
                                   void *v ) ;
#line 150
extern int __raw_notifier_call_chain(struct raw_notifier_head *nh , unsigned long val ,
                                     void *v , int nr_to_call , int *nr_calls ) ;
#line 152
extern int srcu_notifier_call_chain(struct srcu_notifier_head *nh , unsigned long val ,
                                    void *v ) ;
#line 154
extern int __srcu_notifier_call_chain(struct srcu_notifier_head *nh , unsigned long val ,
                                      void *v , int nr_to_call , int *nr_calls ) ;
#line 168
__inline static int notifier_from_errno(int err )  __attribute__((__no_instrument_function__)) ;
#line 168 "../../../analyzer/../bench/linux-headers/include/linux/notifier.h"
__inline static int notifier_from_errno(int err ) 
{ 


  {
#line 170
  if (err) {
#line 171
    return (32768 | (1 - err));
  }
#line 173
  return (1);
}
}
#line 177
__inline static int notifier_to_errno(int ret )  __attribute__((__no_instrument_function__)) ;
#line 177 "../../../analyzer/../bench/linux-headers/include/linux/notifier.h"
__inline static int notifier_to_errno(int ret ) 
{ 
  int tmp ;

  {
  {
#line 179
  ret &= -32769;
  }
#line 180
  if (ret > 1) {
    {
#line 180
    tmp = 1 - ret;
    }
  } else {
    {
#line 180
    tmp = 0;
    }
  }
#line 180
  return (tmp);
}
}
#line 212
extern struct blocking_notifier_head reboot_notifier_list ;
#line 198 "../../../analyzer/../bench/linux-headers/include/linux/memory_hotplug.h"
__inline static void pgdat_resize_lock(struct pglist_data *p , unsigned long *f )  __attribute__((__no_instrument_function__)) ;
#line 198 "../../../analyzer/../bench/linux-headers/include/linux/memory_hotplug.h"
__inline static void pgdat_resize_lock(struct pglist_data *p , unsigned long *f ) 
{ 


  {
#line 198
  return;
}
}
#line 199
__inline static void pgdat_resize_unlock(struct pglist_data *p , unsigned long *f )  __attribute__((__no_instrument_function__)) ;
#line 199 "../../../analyzer/../bench/linux-headers/include/linux/memory_hotplug.h"
__inline static void pgdat_resize_unlock(struct pglist_data *p , unsigned long *f ) 
{ 


  {
#line 199
  return;
}
}
#line 200
__inline static void pgdat_resize_init(struct pglist_data *pgdat )  __attribute__((__no_instrument_function__)) ;
#line 200 "../../../analyzer/../bench/linux-headers/include/linux/memory_hotplug.h"
__inline static void pgdat_resize_init(struct pglist_data *pgdat ) 
{ 


  {
#line 200
  return;
}
}
#line 202
__inline static unsigned int zone_span_seqbegin(struct zone *zone )  __attribute__((__no_instrument_function__)) ;
#line 202 "../../../analyzer/../bench/linux-headers/include/linux/memory_hotplug.h"
__inline static unsigned int zone_span_seqbegin(struct zone *zone ) 
{ 


  {
#line 204
  return (0U);
}
}
#line 206
__inline static int zone_span_seqretry(struct zone *zone , unsigned int iv )  __attribute__((__no_instrument_function__)) ;
#line 206 "../../../analyzer/../bench/linux-headers/include/linux/memory_hotplug.h"
__inline static int zone_span_seqretry(struct zone *zone , unsigned int iv ) 
{ 


  {
#line 208
  return (0);
}
}
#line 210
__inline static void zone_span_writelock(struct zone *zone )  __attribute__((__no_instrument_function__)) ;
#line 210 "../../../analyzer/../bench/linux-headers/include/linux/memory_hotplug.h"
__inline static void zone_span_writelock(struct zone *zone ) 
{ 


  {
#line 210
  return;
}
}
#line 211
__inline static void zone_span_writeunlock(struct zone *zone )  __attribute__((__no_instrument_function__)) ;
#line 211 "../../../analyzer/../bench/linux-headers/include/linux/memory_hotplug.h"
__inline static void zone_span_writeunlock(struct zone *zone ) 
{ 


  {
#line 211
  return;
}
}
#line 212
__inline static void zone_seqlock_init(struct zone *zone )  __attribute__((__no_instrument_function__)) ;
#line 212 "../../../analyzer/../bench/linux-headers/include/linux/memory_hotplug.h"
__inline static void zone_seqlock_init(struct zone *zone ) 
{ 


  {
#line 212
  return;
}
}
#line 214
__inline static int mhp_notimplemented(char const   *func )  __attribute__((__no_instrument_function__)) ;
#line 214 "../../../analyzer/../bench/linux-headers/include/linux/memory_hotplug.h"
__inline static int mhp_notimplemented(char const   *func ) 
{ 


  {
  {
#line 216
  printk("\0014%s() called, with CONFIG_MEMORY_HOTPLUG disabled\n", func);
#line 217
  dump_stack();
  }
#line 218
  return (-38);
}
}
#line 221
__inline static void register_page_bootmem_info_node(struct pglist_data *pgdat )  __attribute__((__no_instrument_function__)) ;
#line 221 "../../../analyzer/../bench/linux-headers/include/linux/memory_hotplug.h"
__inline static void register_page_bootmem_info_node(struct pglist_data *pgdat ) 
{ 


  {
#line 223
  return;
}
}
#line 225
__inline static int try_online_node(int nid )  __attribute__((__no_instrument_function__)) ;
#line 225 "../../../analyzer/../bench/linux-headers/include/linux/memory_hotplug.h"
__inline static int try_online_node(int nid ) 
{ 


  {
#line 227
  return (0);
}
}
#line 230
__inline static void get_online_mems(void)  __attribute__((__no_instrument_function__)) ;
#line 230 "../../../analyzer/../bench/linux-headers/include/linux/memory_hotplug.h"
__inline static void get_online_mems(void) 
{ 


  {
#line 230
  return;
}
}
#line 231
__inline static void put_online_mems(void)  __attribute__((__no_instrument_function__)) ;
#line 231 "../../../analyzer/../bench/linux-headers/include/linux/memory_hotplug.h"
__inline static void put_online_mems(void) 
{ 


  {
#line 231
  return;
}
}
#line 243
__inline static int is_mem_section_removable(unsigned long pfn , unsigned long nr_pages )  __attribute__((__no_instrument_function__)) ;
#line 243 "../../../analyzer/../bench/linux-headers/include/linux/memory_hotplug.h"
__inline static int is_mem_section_removable(unsigned long pfn , unsigned long nr_pages ) 
{ 


  {
#line 246
  return (0);
}
}
#line 249
__inline static void try_offline_node(int nid )  __attribute__((__no_instrument_function__)) ;
#line 249 "../../../analyzer/../bench/linux-headers/include/linux/memory_hotplug.h"
__inline static void try_offline_node(int nid ) 
{ 


  {
#line 249
  return;
}
}
#line 251
__inline static int offline_pages(unsigned long start_pfn , unsigned long nr_pages )  __attribute__((__no_instrument_function__)) ;
#line 251 "../../../analyzer/../bench/linux-headers/include/linux/memory_hotplug.h"
__inline static int offline_pages(unsigned long start_pfn , unsigned long nr_pages ) 
{ 


  {
#line 253
  return (-22);
}
}
#line 256
__inline static void remove_memory(int nid , u64 start , u64 size )  __attribute__((__no_instrument_function__)) ;
#line 256 "../../../analyzer/../bench/linux-headers/include/linux/memory_hotplug.h"
__inline static void remove_memory(int nid , u64 start , u64 size ) 
{ 


  {
#line 256
  return;
}
}
#line 259
extern int walk_memory_range(unsigned long start_pfn , unsigned long end_pfn , void *arg ,
                             int (*func)(struct memory_block * , void * ) ) ;
#line 261
extern int add_memory(int nid , u64 start , u64 size ) ;
#line 262
extern int zone_for_memory(int nid , u64 start , u64 size , int zone_default ) ;
#line 263
extern int arch_add_memory(int nid , u64 start , u64 size ) ;
#line 265
extern bool is_memblock_offlined(struct memory_block *mem ) ;
#line 267
extern int sparse_add_one_section(struct zone *zone , unsigned long start_pfn ) ;
#line 268
extern void sparse_remove_one_section(struct zone *zone , struct mem_section *ms ) ;
#line 269
extern struct page *sparse_decode_mem_map(unsigned long coded_mem_map , unsigned long pnum ) ;
#line 828 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
extern struct mutex zonelists_mutex ;
#line 829
extern void build_all_zonelists(pg_data_t *pgdat , struct zone *zone ) ;
#line 830
extern void wakeup_kswapd(struct zone *zone , int order , enum zone_type classzone_idx ) ;
#line 831
extern bool zone_watermark_ok(struct zone *z , unsigned int order , unsigned long mark ,
                              int classzone_idx , int alloc_flags ) ;
#line 833
extern bool zone_watermark_ok_safe(struct zone *z , unsigned int order , unsigned long mark ,
                                   int classzone_idx , int alloc_flags ) ;
#line 839
extern int init_currently_empty_zone(struct zone *zone , unsigned long start_pfn ,
                                     unsigned long size , enum memmap_context context ) ;
#line 843
extern void lruvec_init(struct lruvec *lruvec ) ;
#line 845
__inline static struct zone *lruvec_zone(struct lruvec *lruvec )  __attribute__((__no_instrument_function__)) ;
#line 845 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static struct zone *lruvec_zone(struct lruvec *lruvec ) 
{ 
  struct lruvec  const  *__mptr ;

  {
  {
#line 850
  __mptr = (struct lruvec  const  *)lruvec;
  }
#line 850
  return ((struct zone *)((char *)__mptr - (unsigned long )(& ((struct zone *)0)->lruvec)));
}
}
#line 855
extern void memory_present(int nid , unsigned long start , unsigned long end ) ;
#line 863
__inline static int local_memory_node(int node_id )  __attribute__((__no_instrument_function__)) ;
#line 863 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static int local_memory_node(int node_id ) 
{ 


  {
#line 863
  return (node_id);
}
}
#line 875
__inline static int populated_zone(struct zone *zone )  __attribute__((__no_instrument_function__)) ;
#line 875 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static int populated_zone(struct zone *zone ) 
{ 


  {
#line 877
  return (! (! zone->present_pages));
}
}
#line 880
extern int movable_zone ;
#line 882
__inline static int zone_movable_is_highmem(void)  __attribute__((__no_instrument_function__)) ;
#line 882 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static int zone_movable_is_highmem(void) 
{ 


  {
#line 889
  return (0);
}
}
#line 893
__inline static int is_highmem_idx(enum zone_type idx )  __attribute__((__no_instrument_function__)) ;
#line 893 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static int is_highmem_idx(enum zone_type idx ) 
{ 


  {
#line 899
  return (0);
}
}
#line 909
__inline static int is_highmem(struct zone *zone )  __attribute__((__no_instrument_function__)) ;
#line 909 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static int is_highmem(struct zone *zone ) 
{ 


  {
#line 917
  return (0);
}
}
#line 923
extern int min_free_kbytes_sysctl_handler(struct ctl_table * , int  , void * , size_t * ,
                                          loff_t * ) ;
#line 925
extern int sysctl_lowmem_reserve_ratio[3] ;
#line 926
extern int lowmem_reserve_ratio_sysctl_handler(struct ctl_table * , int  , void * ,
                                               size_t * , loff_t * ) ;
#line 928
extern int percpu_pagelist_fraction_sysctl_handler(struct ctl_table * , int  , void * ,
                                                   size_t * , loff_t * ) ;
#line 930
extern int sysctl_min_unmapped_ratio_sysctl_handler(struct ctl_table * , int  , void * ,
                                                    size_t * , loff_t * ) ;
#line 932
extern int sysctl_min_slab_ratio_sysctl_handler(struct ctl_table * , int  , void * ,
                                                size_t * , loff_t * ) ;
#line 935
extern int numa_zonelist_order_handler(struct ctl_table * , int  , void * , size_t * ,
                                       loff_t * ) ;
#line 937
extern char numa_zonelist_order[] ;
#line 6 "../../../analyzer/../bench/linux-headers/include/linux/screen_info.h"
extern struct screen_info screen_info ;
#line 94 "../../../analyzer/../bench/linux-headers/include/linux/apm_bios.h"
extern struct apm_info apm_info ;
#line 36 "../../../analyzer/../bench/linux-headers/include/linux/edd.h"
extern struct edd edd ;
#line 13 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/e820.h"
extern struct e820map e820 ;
#line 14
extern struct e820map e820_saved ;
#line 16
extern unsigned long pci_mem_start ;
#line 17
extern int e820_any_mapped(u64 start , u64 end , unsigned int type ) ;
#line 18
extern int e820_all_mapped(u64 start , u64 end , unsigned int type ) ;
#line 19
extern void e820_add_region(u64 start , u64 size , int type ) ;
#line 20
extern void e820_print_map(char *who ) ;
#line 21
extern int sanitize_e820_map(struct e820entry *biosmap , int max_nr_map , u32 *pnr_map ) ;
#line 23
extern u64 e820_update_range(u64 start , u64 size , unsigned int old_type , unsigned int new_type ) ;
#line 25
extern u64 e820_remove_range(u64 start , u64 size , unsigned int old_type , int checktype ) ;
#line 27
extern void update_e820(void) ;
#line 28
extern void e820_setup_gap(void) ;
#line 29
extern int e820_search_gap(unsigned long *gapstart , unsigned long *gapsize , unsigned long start_addr ,
                           unsigned long long end_addr ) ;
#line 32
extern void parse_e820_ext(u64 phys_addr , u32 data_len ) ;
#line 36
extern void e820_mark_nosave_regions(unsigned long limit_pfn ) ;
#line 46
__inline static void early_memtest(unsigned long start , unsigned long end )  __attribute__((__no_instrument_function__)) ;
#line 46 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/e820.h"
__inline static void early_memtest(unsigned long start , unsigned long end ) 
{ 


  {
#line 48
  return;
}
}
#line 51
extern unsigned long e820_end_of_ram_pfn(void) ;
#line 52
extern unsigned long e820_end_of_low_ram_pfn(void) ;
#line 53
extern u64 early_reserve_e820(u64 sizet , u64 align ) ;
#line 55
extern void memblock_x86_fill(void) ;
#line 56
extern void memblock_find_dma_reserve(void) ;
#line 58
extern void finish_e820_parsing(void) ;
#line 59
extern void e820_reserve_resources(void) ;
#line 60
extern void e820_reserve_resources_late(void) ;
#line 61
extern void setup_memory_map(void) ;
#line 62
extern char *default_machine_specific_memory_setup(void) ;
#line 68
__inline static bool is_ISA_range(u64 s , u64 e )  __attribute__((__no_instrument_function__)) ;
#line 68 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/e820.h"
__inline static bool is_ISA_range(u64 s , u64 e ) 
{ 
  int tmp ;

  {
#line 70
  if (s >= 655360ULL) {
#line 70
    if (e <= 1048576ULL) {
      {
#line 70
      tmp = 1;
      }
    } else {
      {
#line 70
      tmp = 0;
      }
    }
  } else {
    {
#line 70
    tmp = 0;
    }
  }
#line 70
  return ((bool )tmp);
}
}
#line 138 "../../../analyzer/../bench/linux-headers/include/linux/ioport.h"
extern struct resource ioport_resource ;
#line 139
extern struct resource iomem_resource ;
#line 141
extern struct resource *request_resource_conflict(struct resource *root , struct resource *new ) ;
#line 142
extern int request_resource(struct resource *root , struct resource *new ) ;
#line 143
extern int release_resource(struct resource *new ) ;
#line 144
extern void release_child_resources(struct resource *new ) ;
#line 145
extern void reserve_region_with_split(struct resource *root , resource_size_t start ,
                                      resource_size_t end , char const   *name ) ;
#line 148
extern struct resource *insert_resource_conflict(struct resource *parent , struct resource *new ) ;
#line 149
extern int insert_resource(struct resource *parent , struct resource *new ) ;
#line 150
extern void insert_resource_expand_to_fit(struct resource *root , struct resource *new ) ;
#line 151
extern void arch_remove_reservations(struct resource *avail ) ;
#line 152
extern int allocate_resource(struct resource *root , struct resource *new , resource_size_t size ,
                             resource_size_t min , resource_size_t max , resource_size_t align ,
                             resource_size_t (*alignf)(void * , struct resource  const  * ,
                                                       resource_size_t  , resource_size_t  ) ,
                             void *alignf_data ) ;
#line 160
extern struct resource *lookup_resource(struct resource *root , resource_size_t start ) ;
#line 161
extern int adjust_resource(struct resource *res , resource_size_t start , resource_size_t size ) ;
#line 163
extern resource_size_t resource_alignment(struct resource *res ) ;
#line 164
__inline static resource_size_t resource_size(struct resource  const  *res )  __attribute__((__no_instrument_function__)) ;
#line 164 "../../../analyzer/../bench/linux-headers/include/linux/ioport.h"
__inline static resource_size_t resource_size(struct resource  const  *res ) 
{ 


  {
#line 166
  return ((resource_size_t )((res->end - res->start) + 1ULL));
}
}
#line 168
__inline static unsigned long resource_type(struct resource  const  *res )  __attribute__((__no_instrument_function__)) ;
#line 168 "../../../analyzer/../bench/linux-headers/include/linux/ioport.h"
__inline static unsigned long resource_type(struct resource  const  *res ) 
{ 


  {
#line 170
  return ((unsigned long )(res->flags & 7936UL));
}
}
#line 173
__inline static bool resource_contains(struct resource *r1 , struct resource *r2 )  __attribute__((__no_instrument_function__)) ;
#line 173 "../../../analyzer/../bench/linux-headers/include/linux/ioport.h"
__inline static bool resource_contains(struct resource *r1 , struct resource *r2 ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 175
  tmp = resource_type((struct resource  const  *)r1);
#line 175
  tmp___0 = resource_type((struct resource  const  *)r2);
  }
#line 175
  if (tmp != tmp___0) {
#line 176
    return ((bool )0);
  }
#line 177
  if (r1->flags & 536870912UL) {
#line 178
    return ((bool )0);
  } else
#line 177
  if (r2->flags & 536870912UL) {
#line 178
    return ((bool )0);
  }
#line 179
  if (r1->start <= r2->start) {
#line 179
    if (r1->end >= r2->end) {
      {
#line 179
      tmp___1 = 1;
      }
    } else {
      {
#line 179
      tmp___1 = 0;
      }
    }
  } else {
    {
#line 179
    tmp___1 = 0;
    }
  }
#line 179
  return ((bool )tmp___1);
}
}
#line 192
extern struct resource *__request_region(struct resource * , resource_size_t start ,
                                         resource_size_t n , char const   *name ,
                                         int flags ) ;
#line 202
extern int __check_region(struct resource * , resource_size_t  , resource_size_t  ) ;
#line 203
extern void __release_region(struct resource * , resource_size_t  , resource_size_t  ) ;
#line 210
__inline static int check_region(resource_size_t s , resource_size_t n )  __attribute__((__no_instrument_function__)) ;
#line 210 "../../../analyzer/../bench/linux-headers/include/linux/ioport.h"
__inline static int check_region(resource_size_t s , resource_size_t n ) 
{ 
  int tmp ;

  {
  {
#line 213
  tmp = __check_region(& ioport_resource, s, n);
  }
#line 213
  return (tmp);
}
}
#line 223
extern struct resource *__devm_request_region(struct device *dev , struct resource *parent ,
                                              resource_size_t start , resource_size_t n ,
                                              char const   *name ) ;
#line 232
extern void __devm_release_region(struct device *dev , struct resource *parent , resource_size_t start ,
                                  resource_size_t n ) ;
#line 234
extern int iomem_map_sanity_check(resource_size_t addr , unsigned long size ) ;
#line 235
extern int iomem_is_exclusive(u64 addr ) ;
#line 237
extern int walk_system_ram_range(unsigned long start_pfn , unsigned long nr_pages ,
                                 void *arg , int (*func)(unsigned long  , unsigned long  ,
                                                         void * ) ) ;
#line 240
extern int walk_system_ram_res(u64 start , u64 end , void *arg , int (*func)(u64  ,
                                                                             u64  ,
                                                                             void * ) ) ;
#line 243
extern int walk_iomem_res(char *name , unsigned long flags , u64 start , u64 end ,
                          void *arg , int (*func)(u64  , u64  , void * ) ) ;
#line 248
__inline static bool resource_overlaps(struct resource *r1 , struct resource *r2 )  __attribute__((__no_instrument_function__)) ;
#line 248 "../../../analyzer/../bench/linux-headers/include/linux/ioport.h"
__inline static bool resource_overlaps(struct resource *r1 , struct resource *r2 ) 
{ 
  int tmp ;

  {
#line 250
  if (r1->start <= r2->end) {
#line 250
    if (r1->end >= r2->start) {
      {
#line 250
      tmp = 1;
      }
    } else {
      {
#line 250
      tmp = 0;
      }
    }
  } else {
    {
#line 250
    tmp = 0;
    }
  }
#line 250
  return ((bool )tmp);
}
}
#line 21 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/ist.h"
extern struct ist_info ist_info ;
#line 7 "../../../analyzer/../bench/linux-headers/include/video/edid.h"
extern struct edid_info edid_info ;
#line 211 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/x86_init.h"
extern struct x86_init_ops x86_init ;
#line 212
extern struct x86_cpuinit_ops x86_cpuinit ;
#line 213
extern struct x86_platform_ops x86_platform ;
#line 214
extern struct x86_msi_ops x86_msi ;
#line 215
extern struct x86_io_apic_ops x86_io_apic_ops ;
#line 216
extern void x86_init_noop(void) ;
#line 217
extern void x86_init_uint_noop(unsigned int unused ) ;
#line 9 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/mpspec.h"
extern int apic_version[] ;
#line 10
extern int pic_mode ;
#line 40
extern unsigned long mp_bus_not_pci[((256UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
#line 42
extern unsigned int boot_cpu_physical_apicid ;
#line 43
extern unsigned long mp_lapic_addr ;
#line 46
extern int smp_found_config ;
#line 51
__inline static void get_smp_config(void)  __attribute__((__no_instrument_function__)) ;
#line 51 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/mpspec.h"
__inline static void get_smp_config(void) 
{ 


  {
  {
#line 53
  (*(x86_init.mpparse.get_smp_config))(0U);
  }
#line 54
  return;
}
}
#line 56
__inline static void early_get_smp_config(void)  __attribute__((__no_instrument_function__)) ;
#line 56 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/mpspec.h"
__inline static void early_get_smp_config(void) 
{ 


  {
  {
#line 58
  (*(x86_init.mpparse.get_smp_config))(1U);
  }
#line 59
  return;
}
}
#line 61
__inline static void find_smp_config(void)  __attribute__((__no_instrument_function__)) ;
#line 61 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/mpspec.h"
__inline static void find_smp_config(void) 
{ 


  {
  {
#line 63
  (*(x86_init.mpparse.find_smp_config))();
  }
#line 64
  return;
}
}
#line 67
extern void early_reserve_e820_mpc_new(void) ;
#line 68
extern int enable_update_mptable ;
#line 69
extern int default_mpc_apic_id(struct mpc_cpu *m ) ;
#line 70
extern void default_smp_read_mpc_oem(struct mpc_table *mpc ) ;
#line 72
extern void default_mpc_oem_bus_info(struct mpc_bus *m , char *str ) ;
#line 76
extern void default_find_smp_config(void) ;
#line 77
extern void default_get_smp_config(unsigned int early ) ;
#line 88
extern int generic_processor_info(int apicid , int version ) ;
#line 131
__inline static unsigned long physids_coerce(physid_mask_t *map )  __attribute__((__no_instrument_function__)) ;
#line 131 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/mpspec.h"
__inline static unsigned long physids_coerce(physid_mask_t *map ) 
{ 


  {
#line 133
  return (map->mask[0]);
}
}
#line 136
__inline static void physids_promote(unsigned long physids , physid_mask_t *map )  __attribute__((__no_instrument_function__)) ;
#line 136 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/mpspec.h"
__inline static void physids_promote(unsigned long physids , physid_mask_t *map ) 
{ 


  {
  {
#line 138
  bitmap_zero(map->mask, 32768);
#line 139
  map->mask[0] = physids;
  }
#line 140
  return;
}
}
#line 142
__inline static void physid_set_mask_of_physid(int physid , physid_mask_t *map )  __attribute__((__no_instrument_function__)) ;
#line 142 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/mpspec.h"
__inline static void physid_set_mask_of_physid(int physid , physid_mask_t *map ) 
{ 


  {
  {
#line 144
  bitmap_zero(map->mask, 32768);
#line 145
  set_bit((long )physid, (unsigned long volatile   *)(map->mask));
  }
#line 146
  return;
}
}
#line 151
extern physid_mask_t phys_cpu_present_map ;
#line 34 "../../../analyzer/../bench/linux-headers/include/linux/pm.h"
extern void (*pm_power_off)(void) ;
#line 35
extern void (*pm_power_off_prepare)(void) ;
#line 39
extern void pm_vt_switch_required(struct device *dev , bool required ) ;
#line 40
extern void pm_vt_switch_unregister(struct device *dev ) ;
#line 57
extern char const   power_group_name[] ;
#line 611
extern void update_pm_runtime_accounting(struct device *dev ) ;
#line 612
extern int dev_pm_get_subsys_data(struct device *dev ) ;
#line 613
extern int dev_pm_put_subsys_data(struct device *dev ) ;
#line 679
extern void device_pm_lock(void) ;
#line 680
extern void dpm_resume_start(pm_message_t state ) ;
#line 681
extern void dpm_resume_end(pm_message_t state ) ;
#line 682
extern void dpm_resume(pm_message_t state ) ;
#line 683
extern void dpm_complete(pm_message_t state ) ;
#line 685
extern void device_pm_unlock(void) ;
#line 686
extern int dpm_suspend_end(pm_message_t state ) ;
#line 687
extern int dpm_suspend_start(pm_message_t state ) ;
#line 688
extern int dpm_suspend(pm_message_t state ) ;
#line 689
extern int dpm_prepare(pm_message_t state ) ;
#line 691
extern void __suspend_report_result(char const   *function , void *fn , int ret ) ;
#line 698
extern int device_pm_wait_for_dev(struct device *sub , struct device *dev ) ;
#line 699
extern void dpm_for_each_dev(void *data , void (*fn)(struct device * , void * ) ) ;
#line 701
extern int pm_generic_prepare(struct device *dev ) ;
#line 702
extern int pm_generic_suspend_late(struct device *dev ) ;
#line 703
extern int pm_generic_suspend_noirq(struct device *dev ) ;
#line 704
extern int pm_generic_suspend(struct device *dev ) ;
#line 705
extern int pm_generic_resume_early(struct device *dev ) ;
#line 706
extern int pm_generic_resume_noirq(struct device *dev ) ;
#line 707
extern int pm_generic_resume(struct device *dev ) ;
#line 708
extern int pm_generic_freeze_noirq(struct device *dev ) ;
#line 709
extern int pm_generic_freeze_late(struct device *dev ) ;
#line 710
extern int pm_generic_freeze(struct device *dev ) ;
#line 711
extern int pm_generic_thaw_noirq(struct device *dev ) ;
#line 712
extern int pm_generic_thaw_early(struct device *dev ) ;
#line 713
extern int pm_generic_thaw(struct device *dev ) ;
#line 714
extern int pm_generic_restore_noirq(struct device *dev ) ;
#line 715
extern int pm_generic_restore_early(struct device *dev ) ;
#line 716
extern int pm_generic_restore(struct device *dev ) ;
#line 717
extern int pm_generic_poweroff_noirq(struct device *dev ) ;
#line 718
extern int pm_generic_poweroff_late(struct device *dev ) ;
#line 719
extern int pm_generic_poweroff(struct device *dev ) ;
#line 720
extern void pm_generic_complete(struct device *dev ) ;
#line 51 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/topology.h"
extern int x86_cpu_to_node_map  __attribute__((__section__(".data..percpu"))) ;
#line 51
extern int *x86_cpu_to_node_map_early_ptr ;
#line 51
extern int x86_cpu_to_node_map_early_map[] ;
#line 65
__inline static int early_cpu_to_node(int cpu )  __attribute__((__no_instrument_function__)) ;
#line 65 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/topology.h"
__inline static int early_cpu_to_node(int cpu ) 
{ 
  void const   *__vpp_verify ;
  unsigned long __ptr ;
  int *tmp ;

  {
#line 67
  if (x86_cpu_to_node_map_early_ptr) {
    {
#line 67
    tmp = x86_cpu_to_node_map_early_ptr + cpu;
    }
  } else {
    {
#line 67
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 67
      __vpp_verify = (void const   *)((int *)((void *)0));
      }
#line 67
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 67
    __asm__  ("": "=r" (__ptr): "0" (& x86_cpu_to_node_map));
#line 67
    tmp = (int *)(__ptr + __per_cpu_offset[cpu]);
    }
  }
#line 67
  return (*tmp);
}
}
#line 73
extern cpumask_var_t node_to_cpumask_map[1 << 6] ;
#line 79
__inline static struct cpumask  const  *cpumask_of_node(int node )  __attribute__((__no_instrument_function__)) ;
#line 79 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/topology.h"
__inline static struct cpumask  const  *cpumask_of_node(int node ) 
{ 


  {
#line 81
  return ((struct cpumask  const  *)(node_to_cpumask_map[node]));
}
}
#line 85
extern void setup_node_to_cpumask_map(void) ;
#line 95
extern int __node_distance(int  , int  ) ;
#line 120
extern struct cpumask  const  *cpu_coregroup_mask(int cpu ) ;
#line 130
__inline static void arch_fix_phys_package_id(int num , u32 slot )  __attribute__((__no_instrument_function__)) ;
#line 130 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/topology.h"
__inline static void arch_fix_phys_package_id(int num , u32 slot ) 
{ 


  {
#line 132
  return;
}
}
#line 135
extern int x86_pci_root_bus_node(int bus ) ;
#line 136
extern void x86_pci_root_bus_resources(int bus , struct list_head *resources ) ;
#line 21 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/numa.h"
extern int numa_off ;
#line 31
extern s16 __apicid_to_node[32768] ;
#line 32
extern nodemask_t numa_nodes_parsed  __attribute__((__section__(".init.data"))) ;
#line 34
extern int __attribute__((__cold__))  numa_add_memblk(int nodeid , u64 start , u64 end )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 35
extern void __attribute__((__cold__))  numa_set_distance(int from , int to , int distance )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 37
__inline static void set_apicid_to_node(int apicid , s16 node )  __attribute__((__no_instrument_function__)) ;
#line 37 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/numa.h"
__inline static void set_apicid_to_node(int apicid , s16 node ) 
{ 


  {
  {
#line 39
  __apicid_to_node[apicid] = node;
  }
#line 40
  return;
}
}
#line 42
extern int numa_cpu_node(int cpu ) ;
#line 60
extern void numa_set_node(int cpu , int node ) ;
#line 61
extern void numa_clear_node(int cpu ) ;
#line 62
extern void __attribute__((__cold__))  init_cpu_to_node(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 63
extern void numa_add_cpu(int cpu ) ;
#line 64
extern void numa_remove_cpu(int cpu ) ;
#line 25 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/mmu.h"
extern void leave_mm(int cpu ) ;
#line 10 "../../../analyzer/../bench/linux-headers/include/asm-generic/early_ioremap.h"
extern void *early_ioremap(resource_size_t phys_addr , unsigned long size ) ;
#line 12
extern void *early_memremap(resource_size_t phys_addr , unsigned long size ) ;
#line 14
extern void early_iounmap(void *addr , unsigned long size ) ;
#line 15
extern void early_memunmap(void *addr , unsigned long size ) ;
#line 21
extern void early_ioremap_shutdown(void) ;
#line 25
extern void early_ioremap_init(void) ;
#line 28
extern void early_ioremap_setup(void) ;
#line 34
extern void early_ioremap_reset(void) ;
#line 54 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static unsigned char readb(void const volatile   *addr )  __attribute__((__no_instrument_function__)) ;
#line 54 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static unsigned char readb(void const volatile   *addr ) 
{ 
  unsigned char ret ;

  {
  {
#line 54
  __asm__  volatile   ("mov"
                       "b"
                       " %1,%0": "=q" (ret): "m" (*((unsigned char volatile   *)addr)): "memory");
  }
#line 54
  return (ret);
}
}
#line 55
__inline static unsigned short readw(void const volatile   *addr )  __attribute__((__no_instrument_function__)) ;
#line 55 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static unsigned short readw(void const volatile   *addr ) 
{ 
  unsigned short ret ;

  {
  {
#line 55
  __asm__  volatile   ("mov"
                       "w"
                       " %1,%0": "=r" (ret): "m" (*((unsigned short volatile   *)addr)): "memory");
  }
#line 55
  return (ret);
}
}
#line 56
__inline static unsigned int readl(void const volatile   *addr )  __attribute__((__no_instrument_function__)) ;
#line 56 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static unsigned int readl(void const volatile   *addr ) 
{ 
  unsigned int ret ;

  {
  {
#line 56
  __asm__  volatile   ("mov"
                       "l"
                       " %1,%0": "=r" (ret): "m" (*((unsigned int volatile   *)addr)): "memory");
  }
#line 56
  return (ret);
}
}
#line 58
__inline static unsigned char __readb(void const volatile   *addr )  __attribute__((__no_instrument_function__)) ;
#line 58 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static unsigned char __readb(void const volatile   *addr ) 
{ 
  unsigned char ret ;

  {
  {
#line 58
  __asm__  volatile   ("mov"
                       "b"
                       " %1,%0": "=q" (ret): "m" (*((unsigned char volatile   *)addr)));
  }
#line 58
  return (ret);
}
}
#line 59
__inline static unsigned short __readw(void const volatile   *addr )  __attribute__((__no_instrument_function__)) ;
#line 59 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static unsigned short __readw(void const volatile   *addr ) 
{ 
  unsigned short ret ;

  {
  {
#line 59
  __asm__  volatile   ("mov"
                       "w"
                       " %1,%0": "=r" (ret): "m" (*((unsigned short volatile   *)addr)));
  }
#line 59
  return (ret);
}
}
#line 60
__inline static unsigned int __readl(void const volatile   *addr )  __attribute__((__no_instrument_function__)) ;
#line 60 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static unsigned int __readl(void const volatile   *addr ) 
{ 
  unsigned int ret ;

  {
  {
#line 60
  __asm__  volatile   ("mov"
                       "l"
                       " %1,%0": "=r" (ret): "m" (*((unsigned int volatile   *)addr)));
  }
#line 60
  return (ret);
}
}
#line 62
__inline static void writeb(unsigned char val , void volatile   *addr )  __attribute__((__no_instrument_function__)) ;
#line 62 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static void writeb(unsigned char val , void volatile   *addr ) 
{ 


  {
  {
#line 62
  __asm__  volatile   ("mov"
                       "b"
                       " %0,%1": : "q" (val), "m" (*((unsigned char volatile   *)addr)): "memory");
  }
#line 62
  return;
}
}
#line 63
__inline static void writew(unsigned short val , void volatile   *addr )  __attribute__((__no_instrument_function__)) ;
#line 63 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static void writew(unsigned short val , void volatile   *addr ) 
{ 


  {
  {
#line 63
  __asm__  volatile   ("mov"
                       "w"
                       " %0,%1": : "r" (val), "m" (*((unsigned short volatile   *)addr)): "memory");
  }
#line 63
  return;
}
}
#line 64
__inline static void writel(unsigned int val , void volatile   *addr )  __attribute__((__no_instrument_function__)) ;
#line 64 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static void writel(unsigned int val , void volatile   *addr ) 
{ 


  {
  {
#line 64
  __asm__  volatile   ("mov"
                       "l"
                       " %0,%1": : "r" (val), "m" (*((unsigned int volatile   *)addr)): "memory");
  }
#line 64
  return;
}
}
#line 66
__inline static void __writeb(unsigned char val , void volatile   *addr )  __attribute__((__no_instrument_function__)) ;
#line 66 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static void __writeb(unsigned char val , void volatile   *addr ) 
{ 


  {
  {
#line 66
  __asm__  volatile   ("mov"
                       "b"
                       " %0,%1": : "q" (val), "m" (*((unsigned char volatile   *)addr)));
  }
#line 66
  return;
}
}
#line 67
__inline static void __writew(unsigned short val , void volatile   *addr )  __attribute__((__no_instrument_function__)) ;
#line 67 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static void __writew(unsigned short val , void volatile   *addr ) 
{ 


  {
  {
#line 67
  __asm__  volatile   ("mov"
                       "w"
                       " %0,%1": : "r" (val), "m" (*((unsigned short volatile   *)addr)));
  }
#line 67
  return;
}
}
#line 68
__inline static void __writel(unsigned int val , void volatile   *addr )  __attribute__((__no_instrument_function__)) ;
#line 68 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static void __writel(unsigned int val , void volatile   *addr ) 
{ 


  {
  {
#line 68
  __asm__  volatile   ("mov"
                       "l"
                       " %0,%1": : "r" (val), "m" (*((unsigned int volatile   *)addr)));
  }
#line 68
  return;
}
}
#line 85
__inline static unsigned long readq(void const volatile   *addr )  __attribute__((__no_instrument_function__)) ;
#line 85 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static unsigned long readq(void const volatile   *addr ) 
{ 
  unsigned long ret ;

  {
  {
#line 85
  __asm__  volatile   ("mov"
                       "q"
                       " %1,%0": "=r" (ret): "m" (*((unsigned long volatile   *)addr)): "memory");
  }
#line 85
  return (ret);
}
}
#line 86
__inline static void writeq(unsigned long val , void volatile   *addr )  __attribute__((__no_instrument_function__)) ;
#line 86 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static void writeq(unsigned long val , void volatile   *addr ) 
{ 


  {
  {
#line 86
  __asm__  volatile   ("mov"
                       "q"
                       " %0,%1": : "r" (val), "m" (*((unsigned long volatile   *)addr)): "memory");
  }
#line 86
  return;
}
}
#line 112
__inline static phys_addr_t virt_to_phys(void volatile   *address )  __attribute__((__no_instrument_function__)) ;
#line 112 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static phys_addr_t virt_to_phys(void volatile   *address ) 
{ 
  unsigned long tmp ;

  {
  {
#line 114
  tmp = __phys_addr_nodebug((unsigned long )address);
  }
#line 114
  return ((phys_addr_t )tmp);
}
}
#line 130
__inline static void *phys_to_virt(phys_addr_t address )  __attribute__((__no_instrument_function__)) ;
#line 130 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static void *phys_to_virt(phys_addr_t address ) 
{ 


  {
#line 132
  return ((void *)((unsigned long )address + 0xffff880000000000UL));
}
}
#line 145
__inline static unsigned int isa_virt_to_bus(void volatile   *address )  __attribute__((__no_instrument_function__)) ;
#line 145 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static unsigned int isa_virt_to_bus(void volatile   *address ) 
{ 
  phys_addr_t tmp ;

  {
  {
#line 147
  tmp = virt_to_phys(address);
  }
#line 147
  return ((unsigned int )tmp);
}
}
#line 175
extern void *ioremap_nocache(resource_size_t offset , unsigned long size ) ;
#line 176
extern void *ioremap_cache(resource_size_t offset , unsigned long size ) ;
#line 177
extern void *ioremap_prot(resource_size_t offset , unsigned long size , unsigned long prot_val ) ;
#line 183
__inline static void *ioremap(resource_size_t offset , unsigned long size )  __attribute__((__no_instrument_function__)) ;
#line 183 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static void *ioremap(resource_size_t offset , unsigned long size ) 
{ 
  void *tmp ;

  {
  {
#line 185
  tmp = ioremap_nocache(offset, size);
  }
#line 185
  return (tmp);
}
}
#line 188
extern void iounmap(void volatile   *addr ) ;
#line 190
extern void set_iounmap_nonlazy(void) ;
#line 28 "../../../analyzer/../bench/linux-headers/include/asm-generic/iomap.h"
extern unsigned int ioread8(void * ) ;
#line 29
extern unsigned int ioread16(void * ) ;
#line 30
extern unsigned int ioread16be(void * ) ;
#line 31
extern unsigned int ioread32(void * ) ;
#line 32
extern unsigned int ioread32be(void * ) ;
#line 34
extern void iowrite8(u8  , void * ) ;
#line 35
extern void iowrite16(u16  , void * ) ;
#line 36
extern void iowrite16be(u16  , void * ) ;
#line 37
extern void iowrite32(u32  , void * ) ;
#line 38
extern void iowrite32be(u32  , void * ) ;
#line 51
extern void ioread8_rep(void *port , void *buf , unsigned long count ) ;
#line 52
extern void ioread16_rep(void *port , void *buf , unsigned long count ) ;
#line 53
extern void ioread32_rep(void *port , void *buf , unsigned long count ) ;
#line 55
extern void iowrite8_rep(void *port , void const   *buf , unsigned long count ) ;
#line 56
extern void iowrite16_rep(void *port , void const   *buf , unsigned long count ) ;
#line 57
extern void iowrite32_rep(void *port , void const   *buf , unsigned long count ) ;
#line 61
extern void *ioport_map(unsigned long port , unsigned int nr ) ;
#line 62
extern void ioport_unmap(void * ) ;
#line 72
extern void pci_iounmap(struct pci_dev *dev , void * ) ;
#line 17 "../../../analyzer/../bench/linux-headers/include/asm-generic/pci_iomap.h"
extern void *pci_iomap(struct pci_dev *dev , int bar , unsigned long max ) ;
#line 61 "../../../analyzer/../bench/linux-headers/include/linux/rbtree.h"
extern void rb_insert_color(struct rb_node * , struct rb_root * ) ;
#line 62
extern void rb_erase(struct rb_node * , struct rb_root * ) ;
#line 66
extern struct rb_node *rb_next(struct rb_node  const  * ) ;
#line 67
extern struct rb_node *rb_prev(struct rb_node  const  * ) ;
#line 68
extern struct rb_node *rb_first(struct rb_root  const  * ) ;
#line 69
extern struct rb_node *rb_last(struct rb_root  const  * ) ;
#line 72
extern struct rb_node *rb_first_postorder(struct rb_root  const  * ) ;
#line 73
extern struct rb_node *rb_next_postorder(struct rb_node  const  * ) ;
#line 76
extern void rb_replace_node(struct rb_node *victim , struct rb_node *new , struct rb_root *root ) ;
#line 79
__inline static void rb_link_node(struct rb_node *node , struct rb_node *parent ,
                                  struct rb_node **rb_link )  __attribute__((__no_instrument_function__)) ;
#line 79 "../../../analyzer/../bench/linux-headers/include/linux/rbtree.h"
__inline static void rb_link_node(struct rb_node *node , struct rb_node *parent ,
                                  struct rb_node **rb_link ) 
{ 
  struct rb_node *tmp ;

  {
  {
#line 82
  node->__rb_parent_color = (unsigned long )parent;
#line 83
  tmp = (struct rb_node *)((void *)0);
#line 83
  node->rb_right = tmp;
#line 83
  node->rb_left = tmp;
#line 85
  *rb_link = node;
  }
#line 86
  return;
}
}
#line 54 "../../../analyzer/../bench/linux-headers/include/linux/vmalloc.h"
extern void vm_unmap_ram(void const   *mem , unsigned int count ) ;
#line 55
extern void *vm_map_ram(struct page **pages , unsigned int count , int node , pgprot_t prot ) ;
#line 57
extern void vm_unmap_aliases(void) ;
#line 60
extern void __attribute__((__cold__))  vmalloc_init(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 67
extern void *vmalloc(unsigned long size ) ;
#line 68
extern void *vzalloc(unsigned long size ) ;
#line 69
extern void *vmalloc_user(unsigned long size ) ;
#line 70
extern void *vmalloc_node(unsigned long size , int node ) ;
#line 71
extern void *vzalloc_node(unsigned long size , int node ) ;
#line 72
extern void *vmalloc_exec(unsigned long size ) ;
#line 73
extern void *vmalloc_32(unsigned long size ) ;
#line 74
extern void *vmalloc_32_user(unsigned long size ) ;
#line 75
extern void *__vmalloc(unsigned long size , gfp_t gfp_mask , pgprot_t prot ) ;
#line 76
extern void *__vmalloc_node_range(unsigned long size , unsigned long align , unsigned long start ,
                                  unsigned long end , gfp_t gfp_mask , pgprot_t prot ,
                                  int node , void const   *caller ) ;
#line 79
extern void vfree(void const   *addr ) ;
#line 81
extern void *vmap(struct page **pages , unsigned int count , unsigned long flags ,
                  pgprot_t prot ) ;
#line 83
extern void vunmap(void const   *addr ) ;
#line 85
extern int remap_vmalloc_range_partial(struct vm_area_struct *vma , unsigned long uaddr ,
                                       void *kaddr , unsigned long size ) ;
#line 89
extern int remap_vmalloc_range(struct vm_area_struct *vma , void *addr , unsigned long pgoff ) ;
#line 91
extern void vmalloc_sync_all(void) ;
#line 97
__inline static size_t get_vm_area_size(struct vm_struct  const  *area )  __attribute__((__no_instrument_function__)) ;
#line 97 "../../../analyzer/../bench/linux-headers/include/linux/vmalloc.h"
__inline static size_t get_vm_area_size(struct vm_struct  const  *area ) 
{ 


  {
#line 100
  return ((size_t )(area->size - (unsigned long const   )(1UL << 12)));
}
}
#line 103
extern struct vm_struct *get_vm_area(unsigned long size , unsigned long flags ) ;
#line 104
extern struct vm_struct *get_vm_area_caller(unsigned long size , unsigned long flags ,
                                            void const   *caller ) ;
#line 106
extern struct vm_struct *__get_vm_area(unsigned long size , unsigned long flags ,
                                       unsigned long start , unsigned long end ) ;
#line 108
extern struct vm_struct *__get_vm_area_caller(unsigned long size , unsigned long flags ,
                                              unsigned long start , unsigned long end ,
                                              void const   *caller ) ;
#line 112
extern struct vm_struct *remove_vm_area(void const   *addr ) ;
#line 113
extern struct vm_struct *find_vm_area(void const   *addr ) ;
#line 115
extern int map_vm_area(struct vm_struct *area , pgprot_t prot , struct page **pages ) ;
#line 118
extern int map_kernel_range_noflush(unsigned long start , unsigned long size , pgprot_t prot ,
                                    struct page **pages ) ;
#line 120
extern void unmap_kernel_range_noflush(unsigned long addr , unsigned long size ) ;
#line 121
extern void unmap_kernel_range(unsigned long addr , unsigned long size ) ;
#line 140
extern struct vm_struct *alloc_vm_area(size_t size , pte_t **ptes ) ;
#line 141
extern void free_vm_area(struct vm_struct *area ) ;
#line 144
extern long vread(char *buf , char *addr , unsigned long count ) ;
#line 145
extern long vwrite(char *buf , char *addr , unsigned long count ) ;
#line 150
extern struct list_head vmap_area_list ;
#line 151
extern void __attribute__((__cold__))  vm_area_add_early(struct vm_struct *vm )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 152
extern void __attribute__((__cold__))  vm_area_register_early(struct vm_struct *vm ,
                                                              size_t align )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 156
extern struct vm_struct **pcpu_get_vm_areas(unsigned long const   *offsets , size_t const   *sizes ,
                                            int nr_vms , size_t align ) ;
#line 160
extern void pcpu_free_vm_areas(struct vm_struct **vms , int nr_vms ) ;
#line 184
extern void get_vmalloc_info(struct vmalloc_info *vmi ) ;
#line 203 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static void memset_io(void volatile   *addr , unsigned char val , size_t count )  __attribute__((__no_instrument_function__)) ;
#line 203 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static void memset_io(void volatile   *addr , unsigned char val , size_t count ) 
{ 


  {
  {
#line 206
  memset((void *)addr, (int )val, count);
  }
#line 207
  return;
}
}
#line 209
__inline static void memcpy_fromio(void *dst , void const volatile   *src , size_t count )  __attribute__((__no_instrument_function__)) ;
#line 209 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static void memcpy_fromio(void *dst , void const volatile   *src , size_t count ) 
{ 


  {
  {
#line 212
  memcpy(dst, (void const   *)src, count);
  }
#line 213
  return;
}
}
#line 215
__inline static void memcpy_toio(void volatile   *dst , void const   *src , size_t count )  __attribute__((__no_instrument_function__)) ;
#line 215 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static void memcpy_toio(void volatile   *dst , void const   *src , size_t count ) 
{ 


  {
  {
#line 218
  memcpy((void *)dst, src, count);
  }
#line 219
  return;
}
}
#line 239
__inline static void flush_write_buffers(void)  __attribute__((__no_instrument_function__)) ;
#line 239 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static void flush_write_buffers(void) 
{ 


  {
#line 244
  return;
}
}
#line 248
extern void native_io_delay(void) ;
#line 250
extern int io_delay_type ;
#line 251
extern void io_delay_init(void) ;
#line 257
__inline static void slow_down_io(void)  __attribute__((__no_instrument_function__)) ;
#line 257 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static void slow_down_io(void) 
{ 


  {
  {
#line 259
  native_io_delay();
  }
#line 265
  return;
}
}
#line 309
__inline static void outb(unsigned char value , int port )  __attribute__((__no_instrument_function__)) ;
#line 309 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static void outb(unsigned char value , int port ) 
{ 


  {
  {
#line 309
  __asm__  volatile   ("out"
                       "b"
                       " %"
                       "b"
                       "0, %w1": : "a" (value), "Nd" (port));
  }
#line 309
  return;
}
}
#line 309
__inline static unsigned char inb(int port )  __attribute__((__no_instrument_function__)) ;
#line 309 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static unsigned char inb(int port ) 
{ 
  unsigned char value ;

  {
  {
#line 309
  __asm__  volatile   ("in"
                       "b"
                       " %w1, %"
                       "b"
                       "0": "=a" (value): "Nd" (port));
  }
#line 309
  return (value);
}
}
#line 309
__inline static void outb_p(unsigned char value , int port )  __attribute__((__no_instrument_function__)) ;
#line 309 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static void outb_p(unsigned char value , int port ) 
{ 


  {
  {
#line 309
  outb(value, port);
#line 309
  slow_down_io();
  }
#line 309
  return;
}
}
#line 309
__inline static unsigned char inb_p(int port )  __attribute__((__no_instrument_function__)) ;
#line 309 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static unsigned char inb_p(int port ) 
{ 
  unsigned char value ;
  unsigned char tmp ;

  {
  {
#line 309
  tmp = inb(port);
#line 309
  value = tmp;
#line 309
  slow_down_io();
  }
#line 309
  return (value);
}
}
#line 309
__inline static void outsb(int port , void const   *addr , unsigned long count )  __attribute__((__no_instrument_function__)) ;
#line 309 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static void outsb(int port , void const   *addr , unsigned long count ) 
{ 


  {
  {
#line 309
  __asm__  volatile   ("rep; outs"
                       "b": "+S" (addr), "+c" (count): "d" (port));
  }
#line 309
  return;
}
}
#line 309
__inline static void insb(int port , void *addr , unsigned long count )  __attribute__((__no_instrument_function__)) ;
#line 309 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static void insb(int port , void *addr , unsigned long count ) 
{ 


  {
  {
#line 309
  __asm__  volatile   ("rep; ins"
                       "b": "+D" (addr), "+c" (count): "d" (port));
  }
#line 309
  return;
}
}
#line 310
__inline static void outw(unsigned short value , int port )  __attribute__((__no_instrument_function__)) ;
#line 310 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static void outw(unsigned short value , int port ) 
{ 


  {
  {
#line 310
  __asm__  volatile   ("out"
                       "w"
                       " %"
                       "w"
                       "0, %w1": : "a" (value), "Nd" (port));
  }
#line 310
  return;
}
}
#line 310
__inline static unsigned short inw(int port )  __attribute__((__no_instrument_function__)) ;
#line 310 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static unsigned short inw(int port ) 
{ 
  unsigned short value ;

  {
  {
#line 310
  __asm__  volatile   ("in"
                       "w"
                       " %w1, %"
                       "w"
                       "0": "=a" (value): "Nd" (port));
  }
#line 310
  return (value);
}
}
#line 310
__inline static void outw_p(unsigned short value , int port )  __attribute__((__no_instrument_function__)) ;
#line 310 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static void outw_p(unsigned short value , int port ) 
{ 


  {
  {
#line 310
  outw(value, port);
#line 310
  slow_down_io();
  }
#line 310
  return;
}
}
#line 310
__inline static unsigned short inw_p(int port )  __attribute__((__no_instrument_function__)) ;
#line 310 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static unsigned short inw_p(int port ) 
{ 
  unsigned short value ;
  unsigned short tmp ;

  {
  {
#line 310
  tmp = inw(port);
#line 310
  value = tmp;
#line 310
  slow_down_io();
  }
#line 310
  return (value);
}
}
#line 310
__inline static void outsw(int port , void const   *addr , unsigned long count )  __attribute__((__no_instrument_function__)) ;
#line 310 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static void outsw(int port , void const   *addr , unsigned long count ) 
{ 


  {
  {
#line 310
  __asm__  volatile   ("rep; outs"
                       "w": "+S" (addr), "+c" (count): "d" (port));
  }
#line 310
  return;
}
}
#line 310
__inline static void insw(int port , void *addr , unsigned long count )  __attribute__((__no_instrument_function__)) ;
#line 310 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static void insw(int port , void *addr , unsigned long count ) 
{ 


  {
  {
#line 310
  __asm__  volatile   ("rep; ins"
                       "w": "+D" (addr), "+c" (count): "d" (port));
  }
#line 310
  return;
}
}
#line 311
__inline static void outl(unsigned int value , int port )  __attribute__((__no_instrument_function__)) ;
#line 311 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static void outl(unsigned int value , int port ) 
{ 


  {
  {
#line 311
  __asm__  volatile   ("out"
                       "l"
                       " %"
                       ""
                       "0, %w1": : "a" (value), "Nd" (port));
  }
#line 311
  return;
}
}
#line 311
__inline static unsigned int inl(int port )  __attribute__((__no_instrument_function__)) ;
#line 311 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static unsigned int inl(int port ) 
{ 
  unsigned int value ;

  {
  {
#line 311
  __asm__  volatile   ("in"
                       "l"
                       " %w1, %"
                       ""
                       "0": "=a" (value): "Nd" (port));
  }
#line 311
  return (value);
}
}
#line 311
__inline static void outl_p(unsigned int value , int port )  __attribute__((__no_instrument_function__)) ;
#line 311 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static void outl_p(unsigned int value , int port ) 
{ 


  {
  {
#line 311
  outl(value, port);
#line 311
  slow_down_io();
  }
#line 311
  return;
}
}
#line 311
__inline static unsigned int inl_p(int port )  __attribute__((__no_instrument_function__)) ;
#line 311 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static unsigned int inl_p(int port ) 
{ 
  unsigned int value ;
  unsigned int tmp ;

  {
  {
#line 311
  tmp = inl(port);
#line 311
  value = tmp;
#line 311
  slow_down_io();
  }
#line 311
  return (value);
}
}
#line 311
__inline static void outsl(int port , void const   *addr , unsigned long count )  __attribute__((__no_instrument_function__)) ;
#line 311 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static void outsl(int port , void const   *addr , unsigned long count ) 
{ 


  {
  {
#line 311
  __asm__  volatile   ("rep; outs"
                       "l": "+S" (addr), "+c" (count): "d" (port));
  }
#line 311
  return;
}
}
#line 311
__inline static void insl(int port , void *addr , unsigned long count )  __attribute__((__no_instrument_function__)) ;
#line 311 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io.h"
__inline static void insl(int port , void *addr , unsigned long count ) 
{ 


  {
  {
#line 311
  __asm__  volatile   ("rep; ins"
                       "l": "+D" (addr), "+c" (count): "d" (port));
  }
#line 311
  return;
}
}
#line 313
extern void *xlate_dev_mem_ptr(unsigned long phys ) ;
#line 314
extern void unxlate_dev_mem_ptr(unsigned long phys , void *addr ) ;
#line 316
extern int ioremap_change_attr(unsigned long vaddr , unsigned long size , unsigned long prot_val ) ;
#line 318
extern void *ioremap_wc(resource_size_t offset , unsigned long size ) ;
#line 320
extern bool is_early_ioremap_ptep(pte_t *ptep ) ;
#line 337
extern int ( __attribute__((__warn_unused_result__)) arch_phys_wc_add)(unsigned long base ,
                                                                       unsigned long size ) ;
#line 339
extern void arch_phys_wc_del(int handle ) ;
#line 44 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/realmode.h"
extern struct real_mode_header *real_mode_header ;
#line 45
extern unsigned char real_mode_blob_end[] ;
#line 47
extern unsigned long init_rsp ;
#line 48
extern unsigned long initial_code ;
#line 49
extern unsigned long initial_gs ;
#line 51
extern unsigned char real_mode_blob[] ;
#line 52
extern unsigned char real_mode_relocs[] ;
#line 58
extern unsigned char secondary_startup_64[] ;
#line 61
extern void reserve_real_mode(void) ;
#line 62
extern void setup_real_mode(void) ;
#line 36 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/acpi.h"
extern int acpi_lapic ;
#line 37
extern int acpi_ioapic ;
#line 38
extern int acpi_noirq ;
#line 39
extern int acpi_strict ;
#line 40
extern int acpi_disabled ;
#line 41
extern int acpi_pci_disabled ;
#line 42
extern int acpi_skip_timer_override ;
#line 43
extern int acpi_use_timer_override ;
#line 44
extern int acpi_fix_pin2_polarity ;
#line 45
extern int acpi_disable_cmcff ;
#line 47
extern u8 acpi_sci_flags ;
#line 48
extern int acpi_sci_override_gsi ;
#line 49
extern void acpi_pic_sci_set_trigger(unsigned int  , u16  ) ;
#line 51
extern int (*__acpi_register_gsi)(struct device *dev , u32 gsi , int trigger , int polarity ) ;
#line 54
__inline static void disable_acpi(void)  __attribute__((__no_instrument_function__)) ;
#line 54 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/acpi.h"
__inline static void disable_acpi(void) 
{ 


  {
  {
#line 56
  acpi_disabled = 1;
#line 57
  acpi_pci_disabled = 1;
#line 58
  acpi_noirq = 1;
  }
#line 59
  return;
}
}
#line 61
extern int acpi_gsi_to_irq(u32 gsi , unsigned int *irq ) ;
#line 63
__inline static void acpi_noirq_set(void)  __attribute__((__no_instrument_function__)) ;
#line 63 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/acpi.h"
__inline static void acpi_noirq_set(void) 
{ 


  {
  {
#line 63
  acpi_noirq = 1;
  }
#line 63
  return;
}
}
#line 64
__inline static void acpi_disable_pci(void)  __attribute__((__no_instrument_function__)) ;
#line 64 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/acpi.h"
__inline static void acpi_disable_pci(void) 
{ 


  {
  {
#line 66
  acpi_pci_disabled = 1;
#line 67
  acpi_noirq_set();
  }
#line 68
  return;
}
}
#line 71
extern int (*acpi_suspend_lowlevel)(void) ;
#line 79
__inline static unsigned int acpi_processor_cstate_check(unsigned int max_cstate )  __attribute__((__no_instrument_function__)) ;
#line 79 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/acpi.h"
__inline static unsigned int acpi_processor_cstate_check(unsigned int max_cstate ) 
{ 


  {
#line 87
  if ((int )boot_cpu_data.x86 == 15) {
#line 87
    if ((int )boot_cpu_data.x86_vendor == 2) {
#line 87
      if ((int )boot_cpu_data.x86_model <= 5) {
#line 87
        if ((int )boot_cpu_data.x86_mask < 10) {
#line 91
          return (1U);
        } else {
#line 87
          goto _L___1;
        }
      } else {
#line 87
        goto _L___1;
      }
    } else {
#line 87
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
  _L___0: /* CIL Label */ 
  _L: /* CIL Label */ 
#line 92
  if (amd_e400_c1e_detected) {
#line 93
    return (1U);
  } else {
#line 95
    return (max_cstate);
  }
}
}
#line 98
__inline static bool arch_has_acpi_pdc(void)  __attribute__((__no_instrument_function__)) ;
#line 98 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/acpi.h"
__inline static bool arch_has_acpi_pdc(void) 
{ 
  struct cpuinfo_x86 *c ;
  void const   *__vpp_verify ;
  unsigned long __ptr ;
  int tmp ;

  {
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 100
    __vpp_verify = (void const   *)((struct cpuinfo_x86 *)((void *)0));
    }
#line 100
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 100
  __asm__  ("": "=r" (__ptr): "0" (& cpu_info));
#line 100
  c = (struct cpuinfo_x86 *)(__ptr + __per_cpu_offset[0]);
  }
#line 101
  if ((int )c->x86_vendor == 0) {
    {
#line 101
    tmp = 1;
    }
  } else
#line 101
  if ((int )c->x86_vendor == 5) {
    {
#line 101
    tmp = 1;
    }
  } else {
    {
#line 101
    tmp = 0;
    }
  }
#line 101
  return ((bool )tmp);
}
}
#line 105
__inline static void arch_acpi_set_pdc_bits(u32 *buf )  __attribute__((__no_instrument_function__)) ;
#line 105 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/acpi.h"
__inline static void arch_acpi_set_pdc_bits(u32 *buf ) 
{ 
  struct cpuinfo_x86 *c ;
  void const   *__vpp_verify ;
  unsigned long __ptr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 107
    __vpp_verify = (void const   *)((struct cpuinfo_x86 *)((void *)0));
    }
#line 107
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 107
  __asm__  ("": "=r" (__ptr): "0" (& cpu_info));
#line 107
  c = (struct cpuinfo_x86 *)(__ptr + __per_cpu_offset[0]);
#line 109
  *(buf + 2) |= 794U;
  }
#line 111
  if (135 >> 5 == 0) {
#line 111
    if ((1UL << 7) & (unsigned long )(((((((((1 | ((1 << 3) & 31)) | (1 << 5)) | (1 << 6)) | (1 << 8)) | ((1 << 13) & 31)) | (1 << 24)) | (1 << 15)) | (1 << 25)) | (1 << 26))) {
      {
#line 111
      tmp___1 = 1;
      }
    } else {
#line 111
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
#line 111
  if (135 >> 5 == 1) {
#line 111
    if ((1UL << 7) & (unsigned long )(1 << 29)) {
      {
#line 111
      tmp___1 = 1;
      }
    } else {
#line 111
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
#line 111
  if (135 >> 5 == 2) {
#line 111
    goto _L___5;
  } else
  _L___5: /* CIL Label */ 
#line 111
  if (135 >> 5 == 3) {
#line 111
    if ((1UL << 7) & (unsigned long )(1 << 20)) {
      {
#line 111
      tmp___1 = 1;
      }
    } else {
#line 111
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 111
  if (135 >> 5 == 4) {
#line 111
    goto _L___3;
  } else
  _L___3: /* CIL Label */ 
#line 111
  if (135 >> 5 == 5) {
#line 111
    goto _L___2;
  } else
  _L___2: /* CIL Label */ 
#line 111
  if (135 >> 5 == 6) {
#line 111
    goto _L___1;
  } else
  _L___1: /* CIL Label */ 
#line 111
  if (135 >> 5 == 7) {
#line 111
    goto _L___0;
  } else
  _L___0: /* CIL Label */ 
#line 111
  if (135 >> 5 == 8) {
#line 111
    goto _L;
  } else
  _L: /* CIL Label */ 
#line 111
  if (135 >> 5 == 9) {
    {
#line 111
    tmp = constant_test_bit(135L, (unsigned long const volatile   *)((unsigned long *)(c->x86_capability)));
#line 111
    tmp___1 = tmp;
    }
  } else {
    {
#line 111
    tmp = constant_test_bit(135L, (unsigned long const volatile   *)((unsigned long *)(c->x86_capability)));
#line 111
    tmp___1 = tmp;
    }
  }
#line 111
  if (tmp___1) {
    {
#line 112
    *(buf + 2) |= 2091U;
    }
  }
#line 114
  if (22 >> 5 == 0) {
#line 114
    if ((1UL << 22) & (unsigned long )(((((((((1 | ((1 << 3) & 31)) | (1 << 5)) | (1 << 6)) | (1 << 8)) | ((1 << 13) & 31)) | (1 << 24)) | (1 << 15)) | (1 << 25)) | (1 << 26))) {
      {
#line 114
      tmp___4 = 1;
      }
    } else {
#line 114
      goto _L___16;
    }
  } else
  _L___16: /* CIL Label */ 
#line 114
  if (22 >> 5 == 1) {
#line 114
    if ((1UL << 22) & (unsigned long )(1 << 29)) {
      {
#line 114
      tmp___4 = 1;
      }
    } else {
#line 114
      goto _L___15;
    }
  } else
  _L___15: /* CIL Label */ 
#line 114
  if (22 >> 5 == 2) {
#line 114
    goto _L___14;
  } else
  _L___14: /* CIL Label */ 
#line 114
  if (22 >> 5 == 3) {
#line 114
    if ((1UL << 22) & (unsigned long )(1 << 20)) {
      {
#line 114
      tmp___4 = 1;
      }
    } else {
#line 114
      goto _L___13;
    }
  } else
  _L___13: /* CIL Label */ 
#line 114
  if (22 >> 5 == 4) {
#line 114
    goto _L___12;
  } else
  _L___12: /* CIL Label */ 
#line 114
  if (22 >> 5 == 5) {
#line 114
    goto _L___11;
  } else
  _L___11: /* CIL Label */ 
#line 114
  if (22 >> 5 == 6) {
#line 114
    goto _L___10;
  } else
  _L___10: /* CIL Label */ 
#line 114
  if (22 >> 5 == 7) {
#line 114
    goto _L___9;
  } else
  _L___9: /* CIL Label */ 
#line 114
  if (22 >> 5 == 8) {
#line 114
    goto _L___8;
  } else
  _L___8: /* CIL Label */ 
#line 114
  if (22 >> 5 == 9) {
    {
#line 114
    tmp___2 = constant_test_bit(22L, (unsigned long const volatile   *)((unsigned long *)(c->x86_capability)));
#line 114
    tmp___4 = tmp___2;
    }
  } else {
    {
#line 114
    tmp___2 = constant_test_bit(22L, (unsigned long const volatile   *)((unsigned long *)(c->x86_capability)));
#line 114
    tmp___4 = tmp___2;
    }
  }
#line 114
  if (tmp___4) {
    {
#line 115
    *(buf + 2) |= 4U;
    }
  }
#line 120
  if (131 >> 5 == 0) {
#line 120
    if ((1UL << 3) & (unsigned long )(((((((((1 | ((1 << 3) & 31)) | (1 << 5)) | (1 << 6)) | (1 << 8)) | ((1 << 13) & 31)) | (1 << 24)) | (1 << 15)) | (1 << 25)) | (1 << 26))) {
      {
#line 120
      tmp___7 = 1;
      }
    } else {
#line 120
      goto _L___25;
    }
  } else
  _L___25: /* CIL Label */ 
#line 120
  if (131 >> 5 == 1) {
#line 120
    if ((1UL << 3) & (unsigned long )(1 << 29)) {
      {
#line 120
      tmp___7 = 1;
      }
    } else {
#line 120
      goto _L___24;
    }
  } else
  _L___24: /* CIL Label */ 
#line 120
  if (131 >> 5 == 2) {
#line 120
    goto _L___23;
  } else
  _L___23: /* CIL Label */ 
#line 120
  if (131 >> 5 == 3) {
#line 120
    if ((1UL << 3) & (unsigned long )(1 << 20)) {
      {
#line 120
      tmp___7 = 1;
      }
    } else {
#line 120
      goto _L___22;
    }
  } else
  _L___22: /* CIL Label */ 
#line 120
  if (131 >> 5 == 4) {
#line 120
    goto _L___21;
  } else
  _L___21: /* CIL Label */ 
#line 120
  if (131 >> 5 == 5) {
#line 120
    goto _L___20;
  } else
  _L___20: /* CIL Label */ 
#line 120
  if (131 >> 5 == 6) {
#line 120
    goto _L___19;
  } else
  _L___19: /* CIL Label */ 
#line 120
  if (131 >> 5 == 7) {
#line 120
    goto _L___18;
  } else
  _L___18: /* CIL Label */ 
#line 120
  if (131 >> 5 == 8) {
#line 120
    goto _L___17;
  } else
  _L___17: /* CIL Label */ 
#line 120
  if (131 >> 5 == 9) {
    {
#line 120
    tmp___5 = constant_test_bit(131L, (unsigned long const volatile   *)((unsigned long *)(c->x86_capability)));
#line 120
    tmp___7 = tmp___5;
    }
  } else {
    {
#line 120
    tmp___5 = constant_test_bit(131L, (unsigned long const volatile   *)((unsigned long *)(c->x86_capability)));
#line 120
    tmp___7 = tmp___5;
    }
  }
#line 120
  if (! tmp___7) {
    {
#line 121
    *(buf + 2) &= 4294966783U;
    }
  }
#line 122
  return;
}
}
#line 124
__inline static bool acpi_has_cpu_in_madt(void)  __attribute__((__no_instrument_function__)) ;
#line 124 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/acpi.h"
__inline static bool acpi_has_cpu_in_madt(void) 
{ 


  {
#line 126
  return ((bool )(! (! acpi_lapic)));
}
}
#line 143
extern int acpi_numa ;
#line 144
extern int x86_acpi_numa_init(void) ;
#line 81 "../../../analyzer/../bench/linux-headers/include/linux/clocksource.h"
__inline static u64 cyclecounter_cyc2ns(struct cyclecounter  const  *cc , cycle_t cycles )  __attribute__((__no_instrument_function__)) ;
#line 81 "../../../analyzer/../bench/linux-headers/include/linux/clocksource.h"
__inline static u64 cyclecounter_cyc2ns(struct cyclecounter  const  *cc , cycle_t cycles ) 
{ 
  u64 ret ;

  {
  {
#line 84
  ret = cycles;
#line 85
  ret = ret * (u64 )cc->mult >> cc->shift;
  }
#line 86
  return (ret);
}
}
#line 99
extern void timecounter_init(struct timecounter *tc , struct cyclecounter  const  *cc ,
                             u64 start_tstamp ) ;
#line 111
extern u64 timecounter_read(struct timecounter *tc ) ;
#line 127
extern u64 timecounter_cyc2time(struct timecounter *tc , cycle_t cycle_tstamp ) ;
#line 224
__inline static u32 clocksource_khz2mult(u32 khz , u32 shift_constant )  __attribute__((__no_instrument_function__)) ;
#line 224 "../../../analyzer/../bench/linux-headers/include/linux/clocksource.h"
__inline static u32 clocksource_khz2mult(u32 khz , u32 shift_constant ) 
{ 
  u64 tmp ;
  uint32_t __base ;
  uint32_t __rem ;

  {
  {
#line 233
  tmp = 1000000ULL << shift_constant;
#line 235
  tmp += (u64 )(khz / 2U);
#line 236
  __base = khz;
#line 236
  __rem = (uint32_t )(tmp % (unsigned long long )__base);
#line 236
  tmp /= (uint64_t )__base;
  }
#line 238
  return ((u32 )tmp);
}
}
#line 250
__inline static u32 clocksource_hz2mult(u32 hz , u32 shift_constant )  __attribute__((__no_instrument_function__)) ;
#line 250 "../../../analyzer/../bench/linux-headers/include/linux/clocksource.h"
__inline static u32 clocksource_hz2mult(u32 hz , u32 shift_constant ) 
{ 
  u64 tmp ;
  uint32_t __base ;
  uint32_t __rem ;

  {
  {
#line 259
  tmp = 1000000000ULL << shift_constant;
#line 261
  tmp += (u64 )(hz / 2U);
#line 262
  __base = hz;
#line 262
  __rem = (uint32_t )(tmp % (unsigned long long )__base);
#line 262
  tmp /= (uint64_t )__base;
  }
#line 264
  return ((u32 )tmp);
}
}
#line 277
__inline static s64 clocksource_cyc2ns(cycle_t cycles , u32 mult , u32 shift )  __attribute__((__no_instrument_function__)) ;
#line 277 "../../../analyzer/../bench/linux-headers/include/linux/clocksource.h"
__inline static s64 clocksource_cyc2ns(cycle_t cycles , u32 mult , u32 shift ) 
{ 


  {
#line 279
  return ((s64 )(cycles * (u64 )mult >> shift));
}
}
#line 283
extern int clocksource_register(struct clocksource * ) ;
#line 284
extern int clocksource_unregister(struct clocksource * ) ;
#line 285
extern void clocksource_touch_watchdog(void) ;
#line 286
extern struct clocksource *clocksource_get_next(void) ;
#line 287
extern void clocksource_change_rating(struct clocksource *cs , int rating ) ;
#line 288
extern void clocksource_suspend(void) ;
#line 289
extern void clocksource_resume(void) ;
#line 290
extern struct clocksource * __attribute__((__cold__)) clocksource_default_clock(void)  __attribute__((__weak__,
__section__(".init.text"), __no_instrument_function__)) ;
#line 291
extern void clocksource_mark_unstable(struct clocksource *cs ) ;
#line 293
extern u64 clocks_calc_max_nsecs(u32 mult , u32 shift , u32 maxadj , u64 mask ) ;
#line 295
extern void clocks_calc_mult_shift(u32 *mult , u32 *shift , u32 from , u32 to , u32 minsec ) ;
#line 302
extern int __clocksource_register_scale(struct clocksource *cs , u32 scale , u32 freq ) ;
#line 304
extern void __clocksource_updatefreq_scale(struct clocksource *cs , u32 scale , u32 freq ) ;
#line 307
__inline static int clocksource_register_hz(struct clocksource *cs , u32 hz )  __attribute__((__no_instrument_function__)) ;
#line 307 "../../../analyzer/../bench/linux-headers/include/linux/clocksource.h"
__inline static int clocksource_register_hz(struct clocksource *cs , u32 hz ) 
{ 
  int tmp ;

  {
  {
#line 309
  tmp = __clocksource_register_scale(cs, (u32 )1, hz);
  }
#line 309
  return (tmp);
}
}
#line 312
__inline static int clocksource_register_khz(struct clocksource *cs , u32 khz )  __attribute__((__no_instrument_function__)) ;
#line 312 "../../../analyzer/../bench/linux-headers/include/linux/clocksource.h"
__inline static int clocksource_register_khz(struct clocksource *cs , u32 khz ) 
{ 
  int tmp ;

  {
  {
#line 314
  tmp = __clocksource_register_scale(cs, (u32 )1000, khz);
  }
#line 314
  return (tmp);
}
}
#line 317
__inline static void __clocksource_updatefreq_hz(struct clocksource *cs , u32 hz )  __attribute__((__no_instrument_function__)) ;
#line 317 "../../../analyzer/../bench/linux-headers/include/linux/clocksource.h"
__inline static void __clocksource_updatefreq_hz(struct clocksource *cs , u32 hz ) 
{ 


  {
  {
#line 319
  __clocksource_updatefreq_scale(cs, (u32 )1, hz);
  }
#line 320
  return;
}
}
#line 322
__inline static void __clocksource_updatefreq_khz(struct clocksource *cs , u32 khz )  __attribute__((__no_instrument_function__)) ;
#line 322 "../../../analyzer/../bench/linux-headers/include/linux/clocksource.h"
__inline static void __clocksource_updatefreq_khz(struct clocksource *cs , u32 khz ) 
{ 


  {
  {
#line 324
  __clocksource_updatefreq_scale(cs, (u32 )1000, khz);
  }
#line 325
  return;
}
}
#line 328
extern int timekeeping_notify(struct clocksource *clock ) ;
#line 330
extern cycle_t clocksource_mmio_readl_up(struct clocksource * ) ;
#line 331
extern cycle_t clocksource_mmio_readl_down(struct clocksource * ) ;
#line 332
extern cycle_t clocksource_mmio_readw_up(struct clocksource * ) ;
#line 333
extern cycle_t clocksource_mmio_readw_down(struct clocksource * ) ;
#line 335
extern int clocksource_mmio_init(void * , char const   * , unsigned long  , int  ,
                                 unsigned int  , cycle_t (*)(struct clocksource * ) ) ;
#line 338
extern int clocksource_i8253_init(void) ;
#line 346
__inline static void clocksource_of_init(void)  __attribute__((__no_instrument_function__)) ;
#line 346 "../../../analyzer/../bench/linux-headers/include/linux/clocksource.h"
__inline static void clocksource_of_init(void) 
{ 


  {
#line 346
  return;
}
}
#line 8 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pvclock.h"
extern cycle_t pvclock_clocksource_read(struct pvclock_vcpu_time_info *src ) ;
#line 9
extern u8 pvclock_read_flags(struct pvclock_vcpu_time_info *src ) ;
#line 10
extern void pvclock_set_flags(u8 flags ) ;
#line 11
extern unsigned long pvclock_tsc_khz(struct pvclock_vcpu_time_info *src ) ;
#line 12
extern void pvclock_read_wallclock(struct pvclock_wall_clock *wall , struct pvclock_vcpu_time_info *vcpu ,
                                   struct timespec *ts ) ;
#line 15
extern void pvclock_resume(void) ;
#line 17
extern void pvclock_touch_watchdogs(void) ;
#line 23
__inline static u64 pvclock_scale_delta(u64 delta , u32 mul_frac , int shift )  __attribute__((__no_instrument_function__)) ;
#line 23 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pvclock.h"
__inline static u64 pvclock_scale_delta(u64 delta , u32 mul_frac , int shift ) 
{ 
  u64 product ;
  ulong tmp ;

  {
#line 32
  if (shift < 0) {
    {
#line 33
    delta >>= - shift;
    }
  } else {
    {
#line 35
    delta <<= shift;
    }
  }
  {
#line 49
  __asm__  ("mulq %[mul_frac] ; shrd $32, %[hi], %[lo]": [lo] "=a" (product), [hi] "=d" (tmp): "0" (delta),
            [mul_frac] "rm" ((u64 )mul_frac));
  }
#line 59
  return (product);
}
}
#line 62
__inline static u64 ( __attribute__((__always_inline__)) pvclock_get_nsec_offset)(struct pvclock_vcpu_time_info  const  *src )  __attribute__((__no_instrument_function__)) ;
#line 62 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pvclock.h"
__inline static u64 ( __attribute__((__always_inline__)) pvclock_get_nsec_offset)(struct pvclock_vcpu_time_info  const  *src ) 
{ 
  u64 delta ;
  unsigned long long tmp ;
  u64 tmp___0 ;

  {
  {
#line 65
  tmp = __native_read_tsc();
#line 65
  delta = tmp - (unsigned long long )src->tsc_timestamp;
#line 66
  tmp___0 = pvclock_scale_delta(delta, (u32 )src->tsc_to_system_mul, (int )src->tsc_shift);
  }
#line 66
  return (tmp___0);
}
}
#line 70
__inline static unsigned int ( __attribute__((__always_inline__)) __pvclock_read_cycles)(struct pvclock_vcpu_time_info  const  *src ,
                                                                                         cycle_t *cycles ,
                                                                                         u8 *flags )  __attribute__((__no_instrument_function__)) ;
#line 70 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pvclock.h"
__inline static unsigned int ( __attribute__((__always_inline__)) __pvclock_read_cycles)(struct pvclock_vcpu_time_info  const  *src ,
                                                                                         cycle_t *cycles ,
                                                                                         u8 *flags ) 
{ 
  unsigned int version ;
  cycle_t ret ;
  cycle_t offset ;
  u8 ret_flags ;

  {
  {
#line 78
  version = (unsigned int )src->version;
#line 85
  rdtsc_barrier();
#line 86
  offset = pvclock_get_nsec_offset(src);
#line 87
  ret = (cycle_t )(src->system_time + (u64 const   )offset);
#line 88
  ret_flags = (u8 )src->flags;
#line 89
  rdtsc_barrier();
#line 91
  *cycles = ret;
#line 92
  *flags = ret_flags;
  }
#line 93
  return (version);
}
}
#line 103
extern int __attribute__((__cold__))  pvclock_init_vsyscall(struct pvclock_vsyscall_time_info *i ,
                                                            int size )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 105
extern struct pvclock_vcpu_time_info *pvclock_get_vsyscall_time_info(int cpu ) ;
#line 136 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/fixmap.h"
extern void reserve_top_address(unsigned long reserve ) ;
#line 143
extern int fixmaps_set ;
#line 145
extern pte_t *kmap_pte ;
#line 146
extern pgprot_t kmap_prot ;
#line 147
extern pte_t *pkmap_page_table ;
#line 149
extern void __native_set_fixmap(enum fixed_addresses idx , pte_t pte ) ;
#line 150
extern void native_set_fixmap(enum fixed_addresses idx , phys_addr_t phys , pgprot_t flags ) ;
#line 154
__inline static void __set_fixmap(enum fixed_addresses idx , phys_addr_t phys , pgprot_t flags )  __attribute__((__no_instrument_function__)) ;
#line 154 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/fixmap.h"
__inline static void __set_fixmap(enum fixed_addresses idx , phys_addr_t phys , pgprot_t flags ) 
{ 


  {
  {
#line 157
  native_set_fixmap(idx, phys, flags);
  }
#line 158
  return;
}
}
#line 29 "../../../analyzer/../bench/linux-headers/include/asm-generic/fixmap.h"
__inline static unsigned long ( __attribute__((__always_inline__)) fix_to_virt)(unsigned int const   idx )  __attribute__((__no_instrument_function__)) ;
#line 29 "../../../analyzer/../bench/linux-headers/include/asm-generic/fixmap.h"
__inline static unsigned long ( __attribute__((__always_inline__)) fix_to_virt)(unsigned int const   idx ) 
{ 


  {
#line 32
  return (((((((0xfffffffffffffff6UL << 20) + (1UL << 12)) - 1UL) | (unsigned long )((1 << 21) - 1)) + 1UL) - (1UL << 12)) - (unsigned long )(idx << 12));
}
}
#line 37
extern int ( /* missing proto */  __builtin_unreachable)() ;
#line 35
__inline static unsigned long virt_to_fix(unsigned long const   vaddr )  __attribute__((__no_instrument_function__)) ;
#line 35 "../../../analyzer/../bench/linux-headers/include/asm-generic/fixmap.h"
__inline static unsigned long virt_to_fix(unsigned long const   vaddr ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (vaddr >= (unsigned long const   )((((((0xfffffffffffffff6UL << 20) + (1UL << 12)) - 1UL) | (unsigned long )((1 << 21) - 1)) + 1UL) - (1UL << 12))) {
      {
#line 37
      tmp = 1;
      }
    } else
#line 37
    if (vaddr < (unsigned long const   )(((((((0xfffffffffffffff6UL << 20) + (1UL << 12)) - 1UL) | (unsigned long )((1 << 21) - 1)) + 1UL) - (1UL << 12)) - (unsigned long )(647 << 12))) {
      {
#line 37
      tmp = 1;
      }
    } else {
      {
#line 37
      tmp = 0;
      }
    }
    {
#line 37
    tmp___0 = __builtin_expect((long )tmp, 0L);
    }
#line 37
    if (tmp___0) {
      {
#line 37
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 37
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("../../../analyzer/../bench/linux-headers/include/asm-generic/fixmap.h"),
                             "i" (37), "i" (sizeof(struct bug_entry )));
#line 37
        __builtin_unreachable();
        }
#line 37
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 37
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 38
  return ((((((((0xfffffffffffffff6UL << 20) + (1UL << 12)) - 1UL) | (unsigned long )((1 << 21) - 1)) + 1UL) - (1UL << 12)) - (unsigned long )(vaddr & (unsigned long const   )(~ ((1UL << 12) - 1UL)))) >> 12);
}
}
#line 166 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/fixmap.h"
extern void __early_set_fixmap(enum fixed_addresses idx , phys_addr_t phys , pgprot_t flags ) ;
#line 8 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/idle.h"
extern void idle_notifier_register(struct notifier_block *n ) ;
#line 9
extern void idle_notifier_unregister(struct notifier_block *n ) ;
#line 12
extern void enter_idle(void) ;
#line 13
extern void exit_idle(void) ;
#line 20
extern void amd_e400_remove_cpu(int cpu ) ;
#line 41 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apic.h"
__inline static void generic_apic_probe(void)  __attribute__((__no_instrument_function__)) ;
#line 41 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apic.h"
__inline static void generic_apic_probe(void) 
{ 


  {
#line 43
  return;
}
}
#line 48
extern unsigned int apic_verbosity ;
#line 49
extern int local_apic_timer_c2_ok ;
#line 51
extern int disable_apic ;
#line 52
extern unsigned int lapic_timer_frequency ;
#line 55
extern void __inquire_remote_apic(int apicid ) ;
#line 62
__inline static void default_inquire_remote_apic(int apicid )  __attribute__((__no_instrument_function__)) ;
#line 62 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apic.h"
__inline static void default_inquire_remote_apic(int apicid ) 
{ 


  {
#line 64
  if (apic_verbosity >= 2U) {
    {
#line 65
    __inquire_remote_apic(apicid);
    }
  }
#line 66
  return;
}
}
#line 76
__inline static bool apic_from_smp_config(void)  __attribute__((__no_instrument_function__)) ;
#line 76 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apic.h"
__inline static bool apic_from_smp_config(void) 
{ 
  int tmp ;

  {
#line 78
  if (smp_found_config) {
#line 78
    if (! disable_apic) {
      {
#line 78
      tmp = 1;
      }
    } else {
      {
#line 78
      tmp = 0;
      }
    }
  } else {
    {
#line 78
    tmp = 0;
    }
  }
#line 78
  return ((bool )tmp);
}
}
#line 88
extern int setup_profiling_timer(unsigned int multiplier ) ;
#line 90
__inline static void native_apic_mem_write(u32 reg , u32 v )  __attribute__((__no_instrument_function__)) ;
#line 90 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apic.h"
__inline static void native_apic_mem_write(u32 reg , u32 v ) 
{ 
  u32 volatile   *addr ;
  unsigned long tmp ;

  {
  {
#line 92
  tmp = fix_to_virt((unsigned int const   )515);
#line 92
  addr = (u32 volatile   *)(tmp + (unsigned long )reg);
#line 94
  __asm__  volatile   ("661:\n\t"
                       "movl %0, %1"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "(11*32 + (5))"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       "xchgl %0, %1"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection": "=r" (v), "=m" (*addr): "i" (0), "0" (v), "m" (*addr));
  }
#line 97
  return;
}
}
#line 99
__inline static u32 native_apic_mem_read(u32 reg )  __attribute__((__no_instrument_function__)) ;
#line 99 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apic.h"
__inline static u32 native_apic_mem_read(u32 reg ) 
{ 
  unsigned long tmp ;

  {
  {
#line 101
  tmp = fix_to_virt((unsigned int const   )515);
  }
#line 101
  return ((u32 )*((u32 volatile   *)(tmp + (unsigned long )reg)));
}
}
#line 104
extern void native_apic_wait_icr_idle(void) ;
#line 105
extern u32 native_safe_apic_wait_icr_idle(void) ;
#line 106
extern void native_apic_icr_write(u32 low , u32 id ) ;
#line 107
extern u64 native_apic_icr_read(void) ;
#line 109
extern int x2apic_mode ;
#line 195
__inline static void disable_x2apic(void)  __attribute__((__no_instrument_function__)) ;
#line 195 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apic.h"
__inline static void disable_x2apic(void) 
{ 


  {
#line 197
  return;
}
}
#line 198
__inline static void check_x2apic(void)  __attribute__((__no_instrument_function__)) ;
#line 198 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apic.h"
__inline static void check_x2apic(void) 
{ 


  {
#line 200
  return;
}
}
#line 201
__inline static void enable_x2apic(void)  __attribute__((__no_instrument_function__)) ;
#line 201 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apic.h"
__inline static void enable_x2apic(void) 
{ 


  {
#line 203
  return;
}
}
#line 204
__inline static int x2apic_enabled(void)  __attribute__((__no_instrument_function__)) ;
#line 204 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apic.h"
__inline static int x2apic_enabled(void) 
{ 


  {
#line 206
  return (0);
}
}
#line 208
__inline static void x2apic_force_phys(void)  __attribute__((__no_instrument_function__)) ;
#line 208 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apic.h"
__inline static void x2apic_force_phys(void) 
{ 


  {
#line 210
  return;
}
}
#line 216
extern void enable_IR_x2apic(void) ;
#line 218
extern int get_physical_broadcast(void) ;
#line 220
extern int lapic_get_maxlvt(void) ;
#line 221
extern void clear_local_APIC(void) ;
#line 222
extern void connect_bsp_APIC(void) ;
#line 223
extern void disconnect_bsp_APIC(int virt_wire_setup ) ;
#line 224
extern void disable_local_APIC(void) ;
#line 225
extern void lapic_shutdown(void) ;
#line 226
extern int verify_local_APIC(void) ;
#line 227
extern void sync_Arb_IDs(void) ;
#line 228
extern void init_bsp_APIC(void) ;
#line 229
extern void setup_local_APIC(void) ;
#line 230
extern void end_local_APIC_setup(void) ;
#line 231
extern void bsp_end_local_APIC_setup(void) ;
#line 232
extern void init_apic_mappings(void) ;
#line 233
extern void register_lapic_address(unsigned long address ) ;
#line 234
extern void setup_boot_APIC_clock(void) ;
#line 235
extern void setup_secondary_APIC_clock(void) ;
#line 236
extern int APIC_init_uniprocessor(void) ;
#line 237
extern int apic_force_enable(unsigned long addr ) ;
#line 243
extern int apic_is_clustered_box(void) ;
#line 251
extern int setup_APIC_eilvt(u8 lvt_off , u8 vector , u8 msg_type , u8 mask ) ;
#line 366
extern struct apic *apic ;
#line 386
extern struct apic *__apicdrivers[] ;
#line 386
extern struct apic *__apicdrivers_end[] ;
#line 392
extern atomic_t init_deasserted ;
#line 393
extern int wakeup_secondary_cpu_via_nmi(int apicid , unsigned long start_eip ) ;
#line 398
__inline static u32 apic_read(u32 reg )  __attribute__((__no_instrument_function__)) ;
#line 398 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apic.h"
__inline static u32 apic_read(u32 reg ) 
{ 
  u32 tmp ;

  {
  {
#line 400
  tmp = (*(apic->read))(reg);
  }
#line 400
  return (tmp);
}
}
#line 403
__inline static void apic_write(u32 reg , u32 val )  __attribute__((__no_instrument_function__)) ;
#line 403 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apic.h"
__inline static void apic_write(u32 reg , u32 val ) 
{ 


  {
  {
#line 405
  (*(apic->write))(reg, val);
  }
#line 406
  return;
}
}
#line 408
__inline static void apic_eoi(void)  __attribute__((__no_instrument_function__)) ;
#line 408 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apic.h"
__inline static void apic_eoi(void) 
{ 


  {
  {
#line 410
  (*(apic->eoi_write))((u32 )176, (u32 )0);
  }
#line 411
  return;
}
}
#line 413
__inline static u64 apic_icr_read(void)  __attribute__((__no_instrument_function__)) ;
#line 413 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apic.h"
__inline static u64 apic_icr_read(void) 
{ 
  u64 tmp ;

  {
  {
#line 415
  tmp = (*(apic->icr_read))();
  }
#line 415
  return (tmp);
}
}
#line 418
__inline static void apic_icr_write(u32 low , u32 high )  __attribute__((__no_instrument_function__)) ;
#line 418 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apic.h"
__inline static void apic_icr_write(u32 low , u32 high ) 
{ 


  {
  {
#line 420
  (*(apic->icr_write))(low, high);
  }
#line 421
  return;
}
}
#line 423
__inline static void apic_wait_icr_idle(void)  __attribute__((__no_instrument_function__)) ;
#line 423 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apic.h"
__inline static void apic_wait_icr_idle(void) 
{ 


  {
  {
#line 425
  (*(apic->wait_icr_idle))();
  }
#line 426
  return;
}
}
#line 428
__inline static u32 safe_apic_wait_icr_idle(void)  __attribute__((__no_instrument_function__)) ;
#line 428 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apic.h"
__inline static u32 safe_apic_wait_icr_idle(void) 
{ 
  u32 tmp ;

  {
  {
#line 430
  tmp = (*(apic->safe_wait_icr_idle))();
  }
#line 430
  return (tmp);
}
}
#line 433
extern void __attribute__((__cold__))  apic_set_eoi_write(void (*eoi_write)(u32 reg ,
                                                                            u32 v ) )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 448
__inline static void ack_APIC_irq(void)  __attribute__((__no_instrument_function__)) ;
#line 448 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apic.h"
__inline static void ack_APIC_irq(void) 
{ 


  {
  {
#line 454
  apic_eoi();
  }
#line 455
  return;
}
}
#line 457
__inline static unsigned int default_get_apic_id(unsigned long x )  __attribute__((__no_instrument_function__)) ;
#line 457 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apic.h"
__inline static unsigned int default_get_apic_id(unsigned long x ) 
{ 
  unsigned int ver ;
  u32 tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 459
  tmp = apic_read((u32 )48);
#line 459
  ver = tmp & 255U;
  }
#line 461
  if (ver >= 20U) {
#line 462
    return ((unsigned int )((x >> 24) & 255UL));
  } else {
#line 461
    if (122 >> 5 == 0) {
#line 461
      if ((1UL << 26) & (unsigned long )(((((((((1 | ((1 << 3) & 31)) | (1 << 5)) | (1 << 6)) | (1 << 8)) | ((1 << 13) & 31)) | (1 << 24)) | (1 << 15)) | (1 << 25)) | (1 << 26))) {
        {
#line 461
        tmp___2 = 1;
        }
      } else {
#line 461
        goto _L___7;
      }
    } else
    _L___7: /* CIL Label */ 
#line 461
    if (122 >> 5 == 1) {
#line 461
      if ((1UL << 26) & (unsigned long )(1 << 29)) {
        {
#line 461
        tmp___2 = 1;
        }
      } else {
#line 461
        goto _L___6;
      }
    } else
    _L___6: /* CIL Label */ 
#line 461
    if (122 >> 5 == 2) {
#line 461
      goto _L___5;
    } else
    _L___5: /* CIL Label */ 
#line 461
    if (122 >> 5 == 3) {
#line 461
      if ((1UL << 26) & (unsigned long )(1 << 20)) {
        {
#line 461
        tmp___2 = 1;
        }
      } else {
#line 461
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 461
    if (122 >> 5 == 4) {
#line 461
      goto _L___3;
    } else
    _L___3: /* CIL Label */ 
#line 461
    if (122 >> 5 == 5) {
#line 461
      goto _L___2;
    } else
    _L___2: /* CIL Label */ 
#line 461
    if (122 >> 5 == 6) {
#line 461
      goto _L___1;
    } else
    _L___1: /* CIL Label */ 
#line 461
    if (122 >> 5 == 7) {
#line 461
      goto _L___0;
    } else
    _L___0: /* CIL Label */ 
#line 461
    if (122 >> 5 == 8) {
#line 461
      goto _L;
    } else
    _L: /* CIL Label */ 
#line 461
    if (122 >> 5 == 9) {
      {
#line 461
      tmp___0 = constant_test_bit(122L, (unsigned long const volatile   *)((unsigned long *)(boot_cpu_data.x86_capability)));
#line 461
      tmp___2 = tmp___0;
      }
    } else {
      {
#line 461
      tmp___0 = constant_test_bit(122L, (unsigned long const volatile   *)((unsigned long *)(boot_cpu_data.x86_capability)));
#line 461
      tmp___2 = tmp___0;
      }
    }
#line 461
    if (tmp___2) {
#line 462
      return ((unsigned int )((x >> 24) & 255UL));
    } else {
#line 464
      return ((unsigned int )((x >> 24) & 15UL));
    }
  }
}
}
#line 474
extern void apic_send_IPI_self(int vector ) ;
#line 476
extern int x2apic_extra_bits  __attribute__((__section__(".data..percpu"))) ;
#line 478
extern int default_cpu_present_to_apicid(int mps_cpu ) ;
#line 479
extern int default_check_phys_apicid_present(int phys_apicid ) ;
#line 482
extern void generic_bigsmp_probe(void) ;
#line 491
__inline static struct cpumask  const  *default_target_cpus(void)  __attribute__((__no_instrument_function__)) ;
#line 491 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apic.h"
__inline static struct cpumask  const  *default_target_cpus(void) 
{ 


  {
#line 494
  return ((struct cpumask  const  *)cpu_online_mask);
}
}
#line 500
__inline static struct cpumask  const  *online_target_cpus(void)  __attribute__((__no_instrument_function__)) ;
#line 500 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apic.h"
__inline static struct cpumask  const  *online_target_cpus(void) 
{ 


  {
#line 502
  return ((struct cpumask  const  *)cpu_online_mask);
}
}
#line 505
extern u16 x86_bios_cpu_apicid  __attribute__((__section__(".data..percpu..read_mostly"))) ;
#line 505
extern u16 *x86_bios_cpu_apicid_early_ptr ;
#line 505
extern u16 x86_bios_cpu_apicid_early_map[] ;
#line 508
__inline static unsigned int read_apic_id(void)  __attribute__((__no_instrument_function__)) ;
#line 508 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apic.h"
__inline static unsigned int read_apic_id(void) 
{ 
  unsigned int reg ;
  unsigned int tmp ;

  {
  {
#line 512
  reg = apic_read((u32 )32);
#line 514
  tmp = (*(apic->get_apic_id))((unsigned long )reg);
  }
#line 514
  return (tmp);
}
}
#line 517
__inline static int default_apic_id_valid(int apicid )  __attribute__((__no_instrument_function__)) ;
#line 517 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apic.h"
__inline static int default_apic_id_valid(int apicid ) 
{ 


  {
#line 519
  return (apicid < 255);
}
}
#line 522
extern int default_acpi_madt_oem_check(char * , char * ) ;
#line 524
extern void default_setup_apic_routing(void) ;
#line 526
extern struct apic apic_noop ;
#line 556
__inline static int flat_cpu_mask_to_apicid_and(struct cpumask  const  *cpumask ,
                                                struct cpumask  const  *andmask ,
                                                unsigned int *apicid )  __attribute__((__no_instrument_function__)) ;
#line 556 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apic.h"
__inline static int flat_cpu_mask_to_apicid_and(struct cpumask  const  *cpumask ,
                                                struct cpumask  const  *andmask ,
                                                unsigned int *apicid ) 
{ 
  unsigned long cpu_mask ;
  long tmp ;

  {
  {
#line 561
  cpu_mask = ((cpumask->bits[0] & andmask->bits[0]) & cpu_online_mask->bits[0]) & 255UL;
#line 566
  tmp = __builtin_expect((long )(! (! cpu_mask)), 1L);
  }
#line 566
  if (tmp) {
    {
#line 567
    *apicid = (unsigned int )cpu_mask;
    }
#line 568
    return (0);
  } else {
#line 570
    return (-22);
  }
}
}
#line 574
extern int default_cpu_mask_to_apicid_and(struct cpumask  const  *cpumask , struct cpumask  const  *andmask ,
                                          unsigned int *apicid ) ;
#line 579
__inline static void flat_vector_allocation_domain(int cpu , struct cpumask *retmask ,
                                                   struct cpumask  const  *mask )  __attribute__((__no_instrument_function__)) ;
#line 579 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apic.h"
__inline static void flat_vector_allocation_domain(int cpu , struct cpumask *retmask ,
                                                   struct cpumask  const  *mask ) 
{ 


  {
  {
#line 591
  cpumask_clear(retmask);
#line 592
  retmask->bits[0] = 255UL;
  }
#line 593
  return;
}
}
#line 595
__inline static void default_vector_allocation_domain(int cpu , struct cpumask *retmask ,
                                                      struct cpumask  const  *mask )  __attribute__((__no_instrument_function__)) ;
#line 595 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apic.h"
__inline static void default_vector_allocation_domain(int cpu , struct cpumask *retmask ,
                                                      struct cpumask  const  *mask ) 
{ 
  struct cpumask  const  *tmp ;

  {
  {
#line 599
  tmp = get_cpu_mask((unsigned int )cpu);
#line 599
  cpumask_copy(retmask, tmp);
  }
#line 600
  return;
}
}
#line 602
__inline static unsigned long default_check_apicid_used(physid_mask_t *map , int apicid )  __attribute__((__no_instrument_function__)) ;
#line 602 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apic.h"
__inline static unsigned long default_check_apicid_used(physid_mask_t *map , int apicid ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 604
  tmp___0 = variable_test_bit((long )apicid, (unsigned long const volatile   *)(map->mask));
  }
#line 604
  return ((unsigned long )tmp___0);
}
}
#line 607
__inline static void default_ioapic_phys_id_map(physid_mask_t *phys_map , physid_mask_t *retmap )  __attribute__((__no_instrument_function__)) ;
#line 607 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apic.h"
__inline static void default_ioapic_phys_id_map(physid_mask_t *phys_map , physid_mask_t *retmap ) 
{ 


  {
  {
#line 609
  *retmap = *phys_map;
  }
#line 610
  return;
}
}
#line 612
__inline static int __default_cpu_present_to_apicid(int mps_cpu )  __attribute__((__no_instrument_function__)) ;
#line 612 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apic.h"
__inline static int __default_cpu_present_to_apicid(int mps_cpu ) 
{ 
  void const   *__vpp_verify ;
  unsigned long __ptr ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;

  {
#line 614
  if (mps_cpu < nr_cpu_ids) {
    {
#line 614
    tmp___2 = cpumask_check((unsigned int )mps_cpu);
#line 614
    tmp___3 = variable_test_bit((long )tmp___2, (unsigned long const volatile   *)(cpu_present_mask->bits));
    }
#line 614
    if (tmp___3) {
      {
#line 615
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 615
        __vpp_verify = (void const   *)((u16 *)((void *)0));
        }
#line 615
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 615
      __asm__  ("": "=r" (__ptr): "0" (& x86_bios_cpu_apicid));
      }
#line 615
      return ((int )*((u16 *)(__ptr + __per_cpu_offset[mps_cpu])));
    } else {
#line 617
      return (65535);
    }
  } else {
#line 617
    return (65535);
  }
}
}
#line 620
__inline static int __default_check_phys_apicid_present(int phys_apicid )  __attribute__((__no_instrument_function__)) ;
#line 620 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apic.h"
__inline static int __default_check_phys_apicid_present(int phys_apicid ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 623
  tmp___0 = variable_test_bit((long )phys_apicid, (unsigned long const volatile   *)(phys_cpu_present_map.mask));
  }
#line 623
  return (tmp___0);
}
}
#line 643
extern void irq_enter(void) ;
#line 644
extern void irq_exit(void) ;
#line 646
__inline static void entering_irq(void)  __attribute__((__no_instrument_function__)) ;
#line 646 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apic.h"
__inline static void entering_irq(void) 
{ 


  {
  {
#line 648
  irq_enter();
#line 649
  exit_idle();
  }
#line 650
  return;
}
}
#line 652
__inline static void entering_ack_irq(void)  __attribute__((__no_instrument_function__)) ;
#line 652 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apic.h"
__inline static void entering_ack_irq(void) 
{ 


  {
  {
#line 654
  ack_APIC_irq();
#line 655
  entering_irq();
  }
#line 656
  return;
}
}
#line 658
__inline static void exiting_irq(void)  __attribute__((__no_instrument_function__)) ;
#line 658 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apic.h"
__inline static void exiting_irq(void) 
{ 


  {
  {
#line 660
  irq_exit();
  }
#line 661
  return;
}
}
#line 663
__inline static void exiting_ack_irq(void)  __attribute__((__no_instrument_function__)) ;
#line 663 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/apic.h"
__inline static void exiting_ack_irq(void) 
{ 


  {
  {
#line 665
  irq_exit();
#line 667
  ack_APIC_irq();
  }
#line 668
  return;
}
}
#line 670
extern void ioapic_zap_locks(void) ;
#line 135 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/irq_vectors.h"
__inline static int invalid_vm86_irq(int irq )  __attribute__((__no_instrument_function__)) ;
#line 135 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/irq_vectors.h"
__inline static int invalid_vm86_irq(int irq ) 
{ 
  int tmp ;

  {
#line 137
  if (irq < 3) {
    {
#line 137
    tmp = 1;
    }
  } else
#line 137
  if (irq > 15) {
    {
#line 137
    tmp = 1;
    }
  } else {
    {
#line 137
    tmp = 0;
    }
  }
#line 137
  return (tmp);
}
}
#line 109 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io_apic.h"
extern int nr_ioapics ;
#line 111
extern int mpc_ioapic_id(int ioapic ) ;
#line 112
extern unsigned int mpc_ioapic_addr(int ioapic ) ;
#line 113
extern struct mp_ioapic_gsi *mp_ioapic_gsi_routing(int ioapic ) ;
#line 118
extern int mp_irq_entries ;
#line 121
extern struct mpc_intsrc mp_irqs[1024] ;
#line 124
extern int sis_apic_bug ;
#line 127
extern int skip_ioapic_setup ;
#line 130
extern int noioapicquirk ;
#line 133
extern int noioapicreroute ;
#line 144
extern void ioapic_insert_resources(void) ;
#line 146
extern int native_setup_ioapic_entry(int  , struct IO_APIC_route_entry * , unsigned int  ,
                                     int  , struct io_apic_irq_attr * ) ;
#line 149
extern void eoi_ioapic_irq(unsigned int irq , struct irq_cfg *cfg ) ;
#line 151
extern void native_compose_msi_msg(struct pci_dev *pdev , unsigned int irq , unsigned int dest ,
                                   struct msi_msg *msg , u8 hpet_id ) ;
#line 154
extern void native_eoi_ioapic_pin(int apic , int pin , int vector ) ;
#line 156
extern int save_ioapic_entries(void) ;
#line 157
extern void mask_ioapic_entries(void) ;
#line 158
extern int restore_ioapic_entries(void) ;
#line 160
extern void setup_ioapic_ids_from_mpc(void) ;
#line 161
extern void setup_ioapic_ids_from_mpc_nocheck(void) ;
#line 184
extern u32 gsi_top ;
#line 186
extern int mp_find_ioapic(u32 gsi ) ;
#line 187
extern int mp_find_ioapic_pin(int ioapic , u32 gsi ) ;
#line 188
extern u32 mp_pin_to_gsi(int ioapic , int pin ) ;
#line 189
extern int mp_map_gsi_to_irq(u32 gsi , unsigned int flags ) ;
#line 190
extern void mp_unmap_irq(int irq ) ;
#line 191
extern void __attribute__((__cold__))  mp_register_ioapic(int id , u32 address , u32 gsi_base ,
                                                          struct ioapic_domain_cfg *cfg )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 193
extern int mp_irqdomain_map(struct irq_domain *domain , unsigned int virq , irq_hw_number_t hwirq ) ;
#line 195
extern void mp_irqdomain_unmap(struct irq_domain *domain , unsigned int virq ) ;
#line 196
extern int mp_set_gsi_attr(u32 gsi , int trigger , int polarity , int node ) ;
#line 197
extern void __attribute__((__cold__))  pre_init_apic_IRQ0(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 199
extern void mp_save_irq(struct mpc_intsrc *m ) ;
#line 201
extern void disable_ioapic_support(void) ;
#line 203
extern void __attribute__((__cold__))  native_io_apic_init_mappings(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 204
extern unsigned int native_io_apic_read(unsigned int apic , unsigned int reg ) ;
#line 205
extern void native_io_apic_write(unsigned int apic , unsigned int reg , unsigned int val ) ;
#line 206
extern void native_io_apic_modify(unsigned int apic , unsigned int reg , unsigned int val ) ;
#line 207
extern void native_disable_io_apic(void) ;
#line 208
extern void native_io_apic_print_entries(unsigned int apic , unsigned int nr_entries ) ;
#line 209
extern void intel_ir_io_apic_print_entries(unsigned int apic , unsigned int nr_entries ) ;
#line 210
extern int native_ioapic_set_affinity(struct irq_data * , struct cpumask  const  * ,
                                      bool  ) ;
#line 214
__inline static unsigned int io_apic_read(unsigned int apic___0 , unsigned int reg )  __attribute__((__no_instrument_function__)) ;
#line 214 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io_apic.h"
__inline static unsigned int io_apic_read(unsigned int apic___0 , unsigned int reg ) 
{ 
  unsigned int tmp ;

  {
  {
#line 216
  tmp = (*(x86_io_apic_ops.read))(apic___0, reg);
  }
#line 216
  return (tmp);
}
}
#line 219
__inline static void io_apic_write(unsigned int apic___0 , unsigned int reg , unsigned int value )  __attribute__((__no_instrument_function__)) ;
#line 219 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io_apic.h"
__inline static void io_apic_write(unsigned int apic___0 , unsigned int reg , unsigned int value ) 
{ 


  {
  {
#line 221
  (*(x86_io_apic_ops.write))(apic___0, reg, value);
  }
#line 222
  return;
}
}
#line 223
__inline static void io_apic_modify(unsigned int apic___0 , unsigned int reg , unsigned int value )  __attribute__((__no_instrument_function__)) ;
#line 223 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/io_apic.h"
__inline static void io_apic_modify(unsigned int apic___0 , unsigned int reg , unsigned int value ) 
{ 


  {
  {
#line 225
  (*(x86_io_apic_ops.modify))(apic___0, reg, value);
  }
#line 226
  return;
}
}
#line 228
extern void io_apic_eoi(unsigned int apic , unsigned int vector ) ;
#line 230
extern bool mp_should_keep_irq(struct device *dev ) ;
#line 21 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/smp.h"
extern int smp_num_siblings ;
#line 22
extern unsigned int num_processors ;
#line 24
__inline static bool cpu_has_ht_siblings(void)  __attribute__((__no_instrument_function__)) ;
#line 24 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/smp.h"
__inline static bool cpu_has_ht_siblings(void) 
{ 
  bool has_siblings ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 26
  has_siblings = (bool )0;
  }
#line 28
  if (28 >> 5 == 0) {
#line 28
    if ((1UL << 28) & (unsigned long )(((((((((1 | ((1 << 3) & 31)) | (1 << 5)) | (1 << 6)) | (1 << 8)) | ((1 << 13) & 31)) | (1 << 24)) | (1 << 15)) | (1 << 25)) | (1 << 26))) {
      {
#line 28
      tmp___1 = 1;
      }
    } else {
#line 28
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
#line 28
  if (28 >> 5 == 1) {
#line 28
    if ((1UL << 28) & (unsigned long )(1 << 29)) {
      {
#line 28
      tmp___1 = 1;
      }
    } else {
#line 28
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
#line 28
  if (28 >> 5 == 2) {
#line 28
    goto _L___5;
  } else
  _L___5: /* CIL Label */ 
#line 28
  if (28 >> 5 == 3) {
#line 28
    if ((1UL << 28) & (unsigned long )(1 << 20)) {
      {
#line 28
      tmp___1 = 1;
      }
    } else {
#line 28
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 28
  if (28 >> 5 == 4) {
#line 28
    goto _L___3;
  } else
  _L___3: /* CIL Label */ 
#line 28
  if (28 >> 5 == 5) {
#line 28
    goto _L___2;
  } else
  _L___2: /* CIL Label */ 
#line 28
  if (28 >> 5 == 6) {
#line 28
    goto _L___1;
  } else
  _L___1: /* CIL Label */ 
#line 28
  if (28 >> 5 == 7) {
#line 28
    goto _L___0;
  } else
  _L___0: /* CIL Label */ 
#line 28
  if (28 >> 5 == 8) {
#line 28
    goto _L;
  } else
  _L: /* CIL Label */ 
#line 28
  if (28 >> 5 == 9) {
    {
#line 28
    tmp = constant_test_bit(28L, (unsigned long const volatile   *)((unsigned long *)(boot_cpu_data.x86_capability)));
#line 28
    tmp___1 = tmp;
    }
  } else {
    {
#line 28
    tmp = constant_test_bit(28L, (unsigned long const volatile   *)((unsigned long *)(boot_cpu_data.x86_capability)));
#line 28
    tmp___1 = tmp;
    }
  }
#line 28
  if (tmp___1) {
#line 28
    if (smp_num_siblings > 1) {
      {
#line 28
      tmp___2 = 1;
      }
    } else {
      {
#line 28
      tmp___2 = 0;
      }
    }
  } else {
    {
#line 28
    tmp___2 = 0;
    }
  }
  {
#line 28
  has_siblings = (bool )tmp___2;
  }
#line 30
  return (has_siblings);
}
}
#line 33
extern cpumask_var_t cpu_sibling_map  __attribute__((__section__(".data..percpu..read_mostly"))) ;
#line 34
extern cpumask_var_t cpu_core_map  __attribute__((__section__(".data..percpu..read_mostly"))) ;
#line 36
extern cpumask_var_t cpu_llc_shared_map  __attribute__((__section__(".data..percpu..read_mostly"))) ;
#line 37
extern u16 cpu_llc_id  __attribute__((__section__(".data..percpu..read_mostly"))) ;
#line 38
extern int cpu_number  __attribute__((__section__(".data..percpu..read_mostly"))) ;
#line 40
__inline static struct cpumask *cpu_sibling_mask(int cpu )  __attribute__((__no_instrument_function__)) ;
#line 40 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/smp.h"
__inline static struct cpumask *cpu_sibling_mask(int cpu ) 
{ 
  void const   *__vpp_verify ;
  unsigned long __ptr ;

  {
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 42
    __vpp_verify = (void const   *)((cpumask_var_t *)((void *)0));
    }
#line 42
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 42
  __asm__  ("": "=r" (__ptr): "0" (& cpu_sibling_map));
  }
#line 42
  return (*((cpumask_var_t *)(__ptr + __per_cpu_offset[cpu])));
}
}
#line 45
__inline static struct cpumask *cpu_core_mask(int cpu )  __attribute__((__no_instrument_function__)) ;
#line 45 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/smp.h"
__inline static struct cpumask *cpu_core_mask(int cpu ) 
{ 
  void const   *__vpp_verify ;
  unsigned long __ptr ;

  {
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 47
    __vpp_verify = (void const   *)((cpumask_var_t *)((void *)0));
    }
#line 47
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 47
  __asm__  ("": "=r" (__ptr): "0" (& cpu_core_map));
  }
#line 47
  return (*((cpumask_var_t *)(__ptr + __per_cpu_offset[cpu])));
}
}
#line 50
__inline static struct cpumask *cpu_llc_shared_mask(int cpu )  __attribute__((__no_instrument_function__)) ;
#line 50 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/smp.h"
__inline static struct cpumask *cpu_llc_shared_mask(int cpu ) 
{ 
  void const   *__vpp_verify ;
  unsigned long __ptr ;

  {
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 52
    __vpp_verify = (void const   *)((cpumask_var_t *)((void *)0));
    }
#line 52
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 52
  __asm__  ("": "=r" (__ptr): "0" (& cpu_llc_shared_map));
  }
#line 52
  return (*((cpumask_var_t *)(__ptr + __per_cpu_offset[cpu])));
}
}
#line 55
extern u16 x86_cpu_to_apicid  __attribute__((__section__(".data..percpu..read_mostly"))) ;
#line 55
extern u16 *x86_cpu_to_apicid_early_ptr ;
#line 55
extern u16 x86_cpu_to_apicid_early_map[] ;
#line 62
extern unsigned long stack_start ;
#line 84
extern void set_cpu_sibling_map(int cpu ) ;
#line 90
extern struct smp_ops smp_ops ;
#line 92
__inline static void smp_send_stop(void)  __attribute__((__no_instrument_function__)) ;
#line 92 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/smp.h"
__inline static void smp_send_stop(void) 
{ 


  {
  {
#line 94
  (*(smp_ops.stop_other_cpus))(0);
  }
#line 95
  return;
}
}
#line 97
__inline static void stop_other_cpus(void)  __attribute__((__no_instrument_function__)) ;
#line 97 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/smp.h"
__inline static void stop_other_cpus(void) 
{ 


  {
  {
#line 99
  (*(smp_ops.stop_other_cpus))(1);
  }
#line 100
  return;
}
}
#line 102
__inline static void smp_prepare_boot_cpu(void)  __attribute__((__no_instrument_function__)) ;
#line 102 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/smp.h"
__inline static void smp_prepare_boot_cpu(void) 
{ 


  {
  {
#line 104
  (*(smp_ops.smp_prepare_boot_cpu))();
  }
#line 105
  return;
}
}
#line 107
__inline static void smp_prepare_cpus(unsigned int max_cpus )  __attribute__((__no_instrument_function__)) ;
#line 107 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/smp.h"
__inline static void smp_prepare_cpus(unsigned int max_cpus ) 
{ 


  {
  {
#line 109
  (*(smp_ops.smp_prepare_cpus))(max_cpus);
  }
#line 110
  return;
}
}
#line 112
__inline static void smp_cpus_done(unsigned int max_cpus )  __attribute__((__no_instrument_function__)) ;
#line 112 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/smp.h"
__inline static void smp_cpus_done(unsigned int max_cpus ) 
{ 


  {
  {
#line 114
  (*(smp_ops.smp_cpus_done))(max_cpus);
  }
#line 115
  return;
}
}
#line 117
__inline static int __cpu_up(unsigned int cpu , struct task_struct *tidle )  __attribute__((__no_instrument_function__)) ;
#line 117 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/smp.h"
__inline static int __cpu_up(unsigned int cpu , struct task_struct *tidle ) 
{ 
  int tmp ;

  {
  {
#line 119
  tmp = (*(smp_ops.cpu_up))(cpu, tidle);
  }
#line 119
  return (tmp);
}
}
#line 122
__inline static int __cpu_disable(void)  __attribute__((__no_instrument_function__)) ;
#line 122 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/smp.h"
__inline static int __cpu_disable(void) 
{ 
  int tmp ;

  {
  {
#line 124
  tmp = (*(smp_ops.cpu_disable))();
  }
#line 124
  return (tmp);
}
}
#line 127
__inline static void __cpu_die(unsigned int cpu )  __attribute__((__no_instrument_function__)) ;
#line 127 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/smp.h"
__inline static void __cpu_die(unsigned int cpu ) 
{ 


  {
  {
#line 129
  (*(smp_ops.cpu_die))(cpu);
  }
#line 130
  return;
}
}
#line 132
__inline static void play_dead(void)  __attribute__((__no_instrument_function__)) ;
#line 132 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/smp.h"
__inline static void play_dead(void) 
{ 


  {
  {
#line 134
  (*(smp_ops.play_dead))();
  }
#line 135
  return;
}
}
#line 137
__inline static void smp_send_reschedule(int cpu )  __attribute__((__no_instrument_function__)) ;
#line 137 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/smp.h"
__inline static void smp_send_reschedule(int cpu ) 
{ 


  {
  {
#line 139
  (*(smp_ops.smp_send_reschedule))(cpu);
  }
#line 140
  return;
}
}
#line 142
__inline static void arch_send_call_function_single_ipi(int cpu )  __attribute__((__no_instrument_function__)) ;
#line 142 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/smp.h"
__inline static void arch_send_call_function_single_ipi(int cpu ) 
{ 


  {
  {
#line 144
  (*(smp_ops.send_call_func_single_ipi))(cpu);
  }
#line 145
  return;
}
}
#line 147
__inline static void arch_send_call_function_ipi_mask(struct cpumask  const  *mask )  __attribute__((__no_instrument_function__)) ;
#line 147 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/smp.h"
__inline static void arch_send_call_function_ipi_mask(struct cpumask  const  *mask ) 
{ 


  {
  {
#line 149
  (*(smp_ops.send_call_func_ipi))(mask);
  }
#line 150
  return;
}
}
#line 152
extern void cpu_disable_common(void) ;
#line 153
extern void native_smp_prepare_boot_cpu(void) ;
#line 154
extern void native_smp_prepare_cpus(unsigned int max_cpus ) ;
#line 155
extern void native_smp_cpus_done(unsigned int max_cpus ) ;
#line 156
extern int native_cpu_up(unsigned int cpunum , struct task_struct *tidle ) ;
#line 157
extern int native_cpu_disable(void) ;
#line 158
extern void native_cpu_die(unsigned int cpu ) ;
#line 159
extern void native_play_dead(void) ;
#line 160
extern void play_dead_common(void) ;
#line 161
extern void wbinvd_on_cpu(int cpu ) ;
#line 162
extern int wbinvd_on_all_cpus(void) ;
#line 164
extern void native_send_call_func_ipi(struct cpumask  const  *mask ) ;
#line 165
extern void native_send_call_func_single_ipi(int cpu ) ;
#line 166
extern void x86_idle_thread_init(unsigned int cpu , struct task_struct *idle ) ;
#line 168
extern void smp_store_boot_cpu_info(void) ;
#line 169
extern void smp_store_cpu_info(int id ) ;
#line 181
extern unsigned int disabled_cpus ;
#line 216
extern int hard_smp_processor_id(void) ;
#line 12 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/mmzone_64.h"
extern struct pglist_data *node_data[] ;
#line 952 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
extern struct pglist_data *first_online_pgdat(void) ;
#line 953
extern struct pglist_data *next_online_pgdat(struct pglist_data *pgdat ) ;
#line 954
extern struct zone *next_zone(struct zone *zone ) ;
#line 984
__inline static struct zone *zonelist_zone(struct zoneref *zoneref )  __attribute__((__no_instrument_function__)) ;
#line 984 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static struct zone *zonelist_zone(struct zoneref *zoneref ) 
{ 


  {
#line 986
  return (zoneref->zone);
}
}
#line 989
__inline static int zonelist_zone_idx(struct zoneref *zoneref )  __attribute__((__no_instrument_function__)) ;
#line 989 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static int zonelist_zone_idx(struct zoneref *zoneref ) 
{ 


  {
#line 991
  return (zoneref->zone_idx);
}
}
#line 994
__inline static int zonelist_node_idx(struct zoneref *zoneref )  __attribute__((__no_instrument_function__)) ;
#line 994 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static int zonelist_node_idx(struct zoneref *zoneref ) 
{ 


  {
#line 998
  return ((zoneref->zone)->node);
}
}
#line 1017
extern struct zoneref *next_zones_zonelist(struct zoneref *z , enum zone_type highest_zoneidx ,
                                           nodemask_t *nodes , struct zone **zone ) ;
#line 1034
__inline static struct zoneref *first_zones_zonelist(struct zonelist *zonelist , enum zone_type highest_zoneidx ,
                                                     nodemask_t *nodes , struct zone **zone )  __attribute__((__no_instrument_function__)) ;
#line 1034 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static struct zoneref *first_zones_zonelist(struct zonelist *zonelist , enum zone_type highest_zoneidx ,
                                                     nodemask_t *nodes , struct zone **zone ) 
{ 
  struct zoneref *tmp ;

  {
  {
#line 1039
  tmp = next_zones_zonelist(zonelist->_zonerefs, highest_zoneidx, nodes, zone);
  }
#line 1039
  return (tmp);
}
}
#line 1160
extern struct mem_section *mem_section[(((1UL << 19) + (1UL << 12) / sizeof(struct mem_section )) - 1UL) / ((1UL << 12) / sizeof(struct mem_section ))] ;
#line 1165
__inline static struct mem_section *__nr_to_section(unsigned long nr )  __attribute__((__no_instrument_function__)) ;
#line 1165 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static struct mem_section *__nr_to_section(unsigned long nr ) 
{ 


  {
#line 1167
  if (! mem_section[nr / ((1UL << 12) / sizeof(struct mem_section ))]) {
#line 1168
    return ((struct mem_section *)((void *)0));
  }
#line 1169
  return (mem_section[nr / ((1UL << 12) / sizeof(struct mem_section ))] + (nr & ((1UL << 12) / sizeof(struct mem_section ) - 1UL)));
}
}
#line 1171
extern int __section_nr(struct mem_section *ms ) ;
#line 1172
extern unsigned long usemap_size(void) ;
#line 1185
__inline static struct page *__section_mem_map_addr(struct mem_section *section )  __attribute__((__no_instrument_function__)) ;
#line 1185 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static struct page *__section_mem_map_addr(struct mem_section *section ) 
{ 
  unsigned long map ;

  {
  {
#line 1187
  map = section->section_mem_map;
#line 1188
  map &= ~ ((1UL << 2) - 1UL);
  }
#line 1189
  return ((struct page *)map);
}
}
#line 1192
__inline static int present_section(struct mem_section *section )  __attribute__((__no_instrument_function__)) ;
#line 1192 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static int present_section(struct mem_section *section ) 
{ 
  int tmp ;

  {
#line 1194
  if (section) {
#line 1194
    if (section->section_mem_map & 1UL) {
      {
#line 1194
      tmp = 1;
      }
    } else {
      {
#line 1194
      tmp = 0;
      }
    }
  } else {
    {
#line 1194
    tmp = 0;
    }
  }
#line 1194
  return (tmp);
}
}
#line 1197
__inline static int present_section_nr(unsigned long nr )  __attribute__((__no_instrument_function__)) ;
#line 1197 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static int present_section_nr(unsigned long nr ) 
{ 
  struct mem_section *tmp ;
  int tmp___0 ;

  {
  {
#line 1199
  tmp = __nr_to_section(nr);
#line 1199
  tmp___0 = present_section(tmp);
  }
#line 1199
  return (tmp___0);
}
}
#line 1202
__inline static int valid_section(struct mem_section *section )  __attribute__((__no_instrument_function__)) ;
#line 1202 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static int valid_section(struct mem_section *section ) 
{ 
  int tmp ;

  {
#line 1204
  if (section) {
#line 1204
    if (section->section_mem_map & (1UL << 1)) {
      {
#line 1204
      tmp = 1;
      }
    } else {
      {
#line 1204
      tmp = 0;
      }
    }
  } else {
    {
#line 1204
    tmp = 0;
    }
  }
#line 1204
  return (tmp);
}
}
#line 1207
__inline static int valid_section_nr(unsigned long nr )  __attribute__((__no_instrument_function__)) ;
#line 1207 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static int valid_section_nr(unsigned long nr ) 
{ 
  struct mem_section *tmp ;
  int tmp___0 ;

  {
  {
#line 1209
  tmp = __nr_to_section(nr);
#line 1209
  tmp___0 = valid_section(tmp);
  }
#line 1209
  return (tmp___0);
}
}
#line 1212
__inline static struct mem_section *__pfn_to_section(unsigned long pfn )  __attribute__((__no_instrument_function__)) ;
#line 1212 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static struct mem_section *__pfn_to_section(unsigned long pfn ) 
{ 
  struct mem_section *tmp ;

  {
  {
#line 1214
  tmp = __nr_to_section(pfn >> 15);
  }
#line 1214
  return (tmp);
}
}
#line 1218
__inline static int pfn_valid(unsigned long pfn )  __attribute__((__no_instrument_function__)) ;
#line 1218 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static int pfn_valid(unsigned long pfn ) 
{ 
  struct mem_section *tmp ;
  int tmp___0 ;

  {
#line 1220
  if (pfn >> 15 >= 1UL << 19) {
#line 1221
    return (0);
  }
  {
#line 1222
  tmp = __nr_to_section(pfn >> 15);
#line 1222
  tmp___0 = valid_section(tmp);
  }
#line 1222
  return (tmp___0);
}
}
#line 1226
__inline static int pfn_present(unsigned long pfn )  __attribute__((__no_instrument_function__)) ;
#line 1226 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static int pfn_present(unsigned long pfn ) 
{ 
  struct mem_section *tmp ;
  int tmp___0 ;

  {
#line 1228
  if (pfn >> 15 >= 1UL << 19) {
#line 1229
    return (0);
  }
  {
#line 1230
  tmp = __nr_to_section(pfn >> 15);
#line 1230
  tmp___0 = present_section(tmp);
  }
#line 1230
  return (tmp___0);
}
}
#line 1249
extern void sparse_init(void) ;
#line 1256
extern bool early_pfn_in_nid(unsigned long pfn , int nid ) ;
#line 1266
extern unsigned long __attribute__((__cold__))  node_memmap_size_bytes(int  , unsigned long  ,
                                                                       unsigned long  )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 1299
__inline static int memmap_valid_within(unsigned long pfn , struct page *page , struct zone *zone )  __attribute__((__no_instrument_function__)) ;
#line 1299 "../../../analyzer/../bench/linux-headers/include/linux/mmzone.h"
__inline static int memmap_valid_within(unsigned long pfn , struct page *page , struct zone *zone ) 
{ 


  {
#line 1302
  return (1);
}
}
#line 76 "../../../analyzer/../bench/linux-headers/include/linux/llist.h"
__inline static void init_llist_head(struct llist_head *list )  __attribute__((__no_instrument_function__)) ;
#line 76 "../../../analyzer/../bench/linux-headers/include/linux/llist.h"
__inline static void init_llist_head(struct llist_head *list ) 
{ 


  {
  {
#line 78
  list->first = (struct llist_node *)((void *)0);
  }
#line 79
  return;
}
}
#line 158
__inline static bool llist_empty(struct llist_head  const  *head )  __attribute__((__no_instrument_function__)) ;
#line 158 "../../../analyzer/../bench/linux-headers/include/linux/llist.h"
__inline static bool llist_empty(struct llist_head  const  *head ) 
{ 


  {
#line 160
  return ((bool )((unsigned long )*((struct llist_node * const volatile  *)(& head->first)) == (unsigned long )((void *)0)));
}
}
#line 163
__inline static struct llist_node *llist_next(struct llist_node *node )  __attribute__((__no_instrument_function__)) ;
#line 163 "../../../analyzer/../bench/linux-headers/include/linux/llist.h"
__inline static struct llist_node *llist_next(struct llist_node *node ) 
{ 


  {
#line 165
  return (node->next);
}
}
#line 168
extern bool llist_add_batch(struct llist_node *new_first , struct llist_node *new_last ,
                            struct llist_head *head ) ;
#line 178
__inline static bool llist_add(struct llist_node *new , struct llist_head *head )  __attribute__((__no_instrument_function__)) ;
#line 178 "../../../analyzer/../bench/linux-headers/include/linux/llist.h"
__inline static bool llist_add(struct llist_node *new , struct llist_head *head ) 
{ 
  bool tmp ;

  {
  {
#line 180
  tmp = llist_add_batch(new, new, head);
  }
#line 180
  return (tmp);
}
}
#line 191
__inline static struct llist_node *llist_del_all(struct llist_head *head )  __attribute__((__no_instrument_function__)) ;
#line 191 "../../../analyzer/../bench/linux-headers/include/linux/llist.h"
__inline static struct llist_node *llist_del_all(struct llist_head *head ) 
{ 
  struct llist_node *__ret ;

  {
  {
#line 193
  __ret = (struct llist_node *)((void *)0);
  }
  {
#line 193
  if (sizeof(head->first) == 1UL) {
#line 193
    goto case_1;
  }
#line 193
  if (sizeof(head->first) == 2UL) {
#line 193
    goto case_2;
  }
#line 193
  if (sizeof(head->first) == 4UL) {
#line 193
    goto case_4;
  }
#line 193
  if (sizeof(head->first) == 8UL) {
#line 193
    goto case_8;
  }
#line 193
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 193
  __asm__  volatile   (""
                       "xchg"
                       "b %b0, %1\n": "+q" (__ret), "+m" (head->first): : "memory",
                       "cc");
  }
#line 193
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 193
  __asm__  volatile   (""
                       "xchg"
                       "w %w0, %1\n": "+r" (__ret), "+m" (head->first): : "memory",
                       "cc");
  }
#line 193
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 193
  __asm__  volatile   (""
                       "xchg"
                       "l %0, %1\n": "+r" (__ret), "+m" (head->first): : "memory",
                       "cc");
  }
#line 193
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 193
  __asm__  volatile   (""
                       "xchg"
                       "q %q0, %1\n": "+r" (__ret), "+m" (head->first): : "memory",
                       "cc");
  }
#line 193
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 193
  __xchg_wrong_size();
  }
  switch_break: /* CIL Label */ ;
  }
#line 193
  return (__ret);
}
}
#line 196
extern struct llist_node *llist_del_first(struct llist_head *head ) ;
#line 198
extern struct llist_node *llist_reverse_order(struct llist_node *head ) ;
#line 25 "../../../analyzer/../bench/linux-headers/include/linux/smp.h"
extern unsigned int total_cpus ;
#line 27
extern int smp_call_function_single(int cpuid , void (*func)(void *info ) , void *info ,
                                    int wait ) ;
#line 33
extern int on_each_cpu(void (*func)(void *info ) , void *info , int wait ) ;
#line 39
extern void on_each_cpu_mask(struct cpumask  const  *mask , void (*func)(void *info ) ,
                             void *info , bool wait ) ;
#line 47
extern void on_each_cpu_cond(bool (*cond_func)(int cpu , void *info ) , void (*func)(void *info ) ,
                             void *info , bool wait , gfp_t gfp_flags ) ;
#line 51
extern int smp_call_function_single_async(int cpu , struct call_single_data *csd ) ;
#line 95
extern int smp_call_function(void (*func)(void *info ) , void *info , int wait ) ;
#line 96
extern void smp_call_function_many(struct cpumask  const  *mask , void (*func)(void *info ) ,
                                   void *info , bool wait ) ;
#line 99
extern int smp_call_function_any(struct cpumask  const  *mask , void (*func)(void *info ) ,
                                 void *info , int wait ) ;
#line 102
extern void kick_all_cpus_sync(void) ;
#line 107
extern void __attribute__((__cold__))  call_function_init(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 108
extern void generic_smp_call_function_single_interrupt(void) ;
#line 118
extern unsigned int setup_max_cpus ;
#line 119
extern void __attribute__((__cold__))  setup_nr_cpu_ids(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 120
extern void __attribute__((__cold__))  smp_init(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 183
extern void arch_disable_smp_support(void) ;
#line 185
extern void arch_enable_nonboot_cpus_begin(void) ;
#line 186
extern void arch_enable_nonboot_cpus_end(void) ;
#line 188
extern void smp_setup_processor_id(void) ;
#line 56 "../../../analyzer/../bench/linux-headers/include/linux/percpu.h"
extern void *pcpu_base_addr ;
#line 57
extern unsigned long const   *pcpu_unit_offsets ;
#line 85
extern char const   * const  pcpu_fc_names[3] ;
#line 87
extern enum pcpu_fc pcpu_chosen_fc ;
#line 95
extern struct pcpu_alloc_info * __attribute__((__cold__)) pcpu_alloc_alloc_info(int nr_groups ,
                                                                                int nr_units )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 97
extern void __attribute__((__cold__))  pcpu_free_alloc_info(struct pcpu_alloc_info *ai )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 99
extern int __attribute__((__cold__))  pcpu_setup_first_chunk(struct pcpu_alloc_info  const  *ai ,
                                                             void *base_addr )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 103
extern int __attribute__((__cold__))  pcpu_embed_first_chunk(size_t reserved_size ,
                                                             size_t dyn_size , size_t atom_size ,
                                                             pcpu_fc_cpu_distance_fn_t *cpu_distance_fn ,
                                                             void *(*alloc_fn)(unsigned int cpu ,
                                                                               size_t size ,
                                                                               size_t align ) ,
                                                             void (*free_fn)(void *ptr ,
                                                                             size_t size ) )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 111
extern int __attribute__((__cold__))  pcpu_page_first_chunk(size_t reserved_size ,
                                                            void *(*alloc_fn)(unsigned int cpu ,
                                                                              size_t size ,
                                                                              size_t align ) ,
                                                            void (*free_fn)(void *ptr ,
                                                                            size_t size ) ,
                                                            void (*populate_pte_fn)(unsigned long addr ) )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 117
extern void *__alloc_reserved_percpu(size_t size , size_t align ) ;
#line 118
extern bool is_kernel_percpu_address(unsigned long addr ) ;
#line 123
extern void __attribute__((__cold__))  percpu_init_late(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 125
extern void *__alloc_percpu(size_t size , size_t align ) ;
#line 126
extern void free_percpu(void *__pdata ) ;
#line 127
extern phys_addr_t per_cpu_ptr_to_phys(void *addr ) ;
#line 49 "../../../analyzer/../bench/linux-headers/include/linux/topology.h"
extern int arch_update_cpu_topology(void) ;
#line 71
extern int numa_node  __attribute__((__section__(".data..percpu"))) ;
#line 75
__inline static int numa_node_id(void)  __attribute__((__no_instrument_function__)) ;
#line 75 "../../../analyzer/../bench/linux-headers/include/linux/topology.h"
__inline static int numa_node_id(void) 
{ 
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 77
    __vpp_verify = (void const   *)((int *)((void *)0));
    }
#line 77
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 77
  if (sizeof(numa_node) == 1UL) {
#line 77
    goto case_1;
  }
#line 77
  if (sizeof(numa_node) == 2UL) {
#line 77
    goto case_2___0;
  }
#line 77
  if (sizeof(numa_node) == 4UL) {
#line 77
    goto case_4___1;
  }
#line 77
  if (sizeof(numa_node) == 8UL) {
#line 77
    goto case_8___2;
  }
#line 77
  goto switch_default___3;
  case_1: /* CIL Label */ 
  {
#line 77
  if (sizeof(numa_node) == 1UL) {
#line 77
    goto case_1___0;
  }
#line 77
  if (sizeof(numa_node) == 2UL) {
#line 77
    goto case_2;
  }
#line 77
  if (sizeof(numa_node) == 4UL) {
#line 77
    goto case_4;
  }
#line 77
  if (sizeof(numa_node) == 8UL) {
#line 77
    goto case_8;
  }
#line 77
  goto switch_default;
  case_1___0: /* CIL Label */ 
  {
#line 77
  __asm__  ("mov"
            "b "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=q" (pfo_ret__): "m" (numa_node));
  }
#line 77
  goto switch_break___0;
  case_2: /* CIL Label */ 
  {
#line 77
  __asm__  ("mov"
            "w "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret__): "m" (numa_node));
  }
#line 77
  goto switch_break___0;
  case_4: /* CIL Label */ 
  {
#line 77
  __asm__  ("mov"
            "l "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret__): "m" (numa_node));
  }
#line 77
  goto switch_break___0;
  case_8: /* CIL Label */ 
  {
#line 77
  __asm__  ("mov"
            "q "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret__): "m" (numa_node));
  }
#line 77
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 77
  __bad_percpu_size();
  }
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 77
  pscr_ret__ = pfo_ret__;
  }
#line 77
  goto switch_break;
  case_2___0: /* CIL Label */ 
  {
#line 77
  if (sizeof(numa_node) == 1UL) {
#line 77
    goto case_1___1;
  }
#line 77
  if (sizeof(numa_node) == 2UL) {
#line 77
    goto case_2___1;
  }
#line 77
  if (sizeof(numa_node) == 4UL) {
#line 77
    goto case_4___0;
  }
#line 77
  if (sizeof(numa_node) == 8UL) {
#line 77
    goto case_8___0;
  }
#line 77
  goto switch_default___0;
  case_1___1: /* CIL Label */ 
  {
#line 77
  __asm__  ("mov"
            "b "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=q" (pfo_ret_____0): "m" (numa_node));
  }
#line 77
  goto switch_break___1;
  case_2___1: /* CIL Label */ 
  {
#line 77
  __asm__  ("mov"
            "w "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret_____0): "m" (numa_node));
  }
#line 77
  goto switch_break___1;
  case_4___0: /* CIL Label */ 
  {
#line 77
  __asm__  ("mov"
            "l "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret_____0): "m" (numa_node));
  }
#line 77
  goto switch_break___1;
  case_8___0: /* CIL Label */ 
  {
#line 77
  __asm__  ("mov"
            "q "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret_____0): "m" (numa_node));
  }
#line 77
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
  {
#line 77
  __bad_percpu_size();
  }
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 77
  pscr_ret__ = pfo_ret_____0;
  }
#line 77
  goto switch_break;
  case_4___1: /* CIL Label */ 
  {
#line 77
  if (sizeof(numa_node) == 1UL) {
#line 77
    goto case_1___2;
  }
#line 77
  if (sizeof(numa_node) == 2UL) {
#line 77
    goto case_2___2;
  }
#line 77
  if (sizeof(numa_node) == 4UL) {
#line 77
    goto case_4___2;
  }
#line 77
  if (sizeof(numa_node) == 8UL) {
#line 77
    goto case_8___1;
  }
#line 77
  goto switch_default___1;
  case_1___2: /* CIL Label */ 
  {
#line 77
  __asm__  ("mov"
            "b "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=q" (pfo_ret_____1): "m" (numa_node));
  }
#line 77
  goto switch_break___2;
  case_2___2: /* CIL Label */ 
  {
#line 77
  __asm__  ("mov"
            "w "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret_____1): "m" (numa_node));
  }
#line 77
  goto switch_break___2;
  case_4___2: /* CIL Label */ 
  {
#line 77
  __asm__  ("mov"
            "l "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret_____1): "m" (numa_node));
  }
#line 77
  goto switch_break___2;
  case_8___1: /* CIL Label */ 
  {
#line 77
  __asm__  ("mov"
            "q "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret_____1): "m" (numa_node));
  }
#line 77
  goto switch_break___2;
  switch_default___1: /* CIL Label */ 
  {
#line 77
  __bad_percpu_size();
  }
  switch_break___2: /* CIL Label */ ;
  }
  {
#line 77
  pscr_ret__ = pfo_ret_____1;
  }
#line 77
  goto switch_break;
  case_8___2: /* CIL Label */ 
  {
#line 77
  if (sizeof(numa_node) == 1UL) {
#line 77
    goto case_1___3;
  }
#line 77
  if (sizeof(numa_node) == 2UL) {
#line 77
    goto case_2___3;
  }
#line 77
  if (sizeof(numa_node) == 4UL) {
#line 77
    goto case_4___3;
  }
#line 77
  if (sizeof(numa_node) == 8UL) {
#line 77
    goto case_8___3;
  }
#line 77
  goto switch_default___2;
  case_1___3: /* CIL Label */ 
  {
#line 77
  __asm__  ("mov"
            "b "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=q" (pfo_ret_____2): "m" (numa_node));
  }
#line 77
  goto switch_break___3;
  case_2___3: /* CIL Label */ 
  {
#line 77
  __asm__  ("mov"
            "w "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret_____2): "m" (numa_node));
  }
#line 77
  goto switch_break___3;
  case_4___3: /* CIL Label */ 
  {
#line 77
  __asm__  ("mov"
            "l "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret_____2): "m" (numa_node));
  }
#line 77
  goto switch_break___3;
  case_8___3: /* CIL Label */ 
  {
#line 77
  __asm__  ("mov"
            "q "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret_____2): "m" (numa_node));
  }
#line 77
  goto switch_break___3;
  switch_default___2: /* CIL Label */ 
  {
#line 77
  __bad_percpu_size();
  }
  switch_break___3: /* CIL Label */ ;
  }
  {
#line 77
  pscr_ret__ = pfo_ret_____2;
  }
#line 77
  goto switch_break;
  switch_default___3: /* CIL Label */ 
  {
#line 77
  __bad_size_call_parameter();
  }
#line 77
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 77
  return (pscr_ret__);
}
}
#line 82
__inline static int cpu_to_node(int cpu )  __attribute__((__no_instrument_function__)) ;
#line 82 "../../../analyzer/../bench/linux-headers/include/linux/topology.h"
__inline static int cpu_to_node(int cpu ) 
{ 
  void const   *__vpp_verify ;
  unsigned long __ptr ;

  {
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 84
    __vpp_verify = (void const   *)((int *)((void *)0));
    }
#line 84
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 84
  __asm__  ("": "=r" (__ptr): "0" (& numa_node));
  }
#line 84
  return (*((int *)(__ptr + __per_cpu_offset[cpu])));
}
}
#line 89
__inline static void set_numa_node(int node )  __attribute__((__no_instrument_function__)) ;
#line 89 "../../../analyzer/../bench/linux-headers/include/linux/topology.h"
__inline static void set_numa_node(int node ) 
{ 
  void const   *__vpp_verify ;
  pto_T_____2 pto_tmp__ ;
  pto_T_____3 pto_tmp_____0 ;
  pto_T_____4 pto_tmp_____1 ;
  pto_T_____5 pto_tmp_____2 ;

  {
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 91
      __vpp_verify = (void const   *)((int *)((void *)0));
      }
#line 91
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 91
    if (sizeof(numa_node) == 1UL) {
#line 91
      goto case_1;
    }
#line 91
    if (sizeof(numa_node) == 2UL) {
#line 91
      goto case_2___0;
    }
#line 91
    if (sizeof(numa_node) == 4UL) {
#line 91
      goto case_4___1;
    }
#line 91
    if (sizeof(numa_node) == 8UL) {
#line 91
      goto case_8___2;
    }
#line 91
    goto switch_default___3;
    case_1: /* CIL Label */ 
    {
#line 91
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 91
      if (sizeof(numa_node) == 1UL) {
#line 91
        goto case_1___0;
      }
#line 91
      if (sizeof(numa_node) == 2UL) {
#line 91
        goto case_2;
      }
#line 91
      if (sizeof(numa_node) == 4UL) {
#line 91
        goto case_4;
      }
#line 91
      if (sizeof(numa_node) == 8UL) {
#line 91
        goto case_8;
      }
#line 91
      goto switch_default;
      case_1___0: /* CIL Label */ 
      {
#line 91
      __asm__  ("mov"
                "b %1,"
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (numa_node): "qi" (node));
      }
#line 91
      goto switch_break___0;
      case_2: /* CIL Label */ 
      {
#line 91
      __asm__  ("mov"
                "w %1,"
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (numa_node): "ri" (node));
      }
#line 91
      goto switch_break___0;
      case_4: /* CIL Label */ 
      {
#line 91
      __asm__  ("mov"
                "l %1,"
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (numa_node): "ri" (node));
      }
#line 91
      goto switch_break___0;
      case_8: /* CIL Label */ 
      {
#line 91
      __asm__  ("mov"
                "q %1,"
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (numa_node): "re" (node));
      }
#line 91
      goto switch_break___0;
      switch_default: /* CIL Label */ 
      {
#line 91
      __bad_percpu_size();
      }
      switch_break___0: /* CIL Label */ ;
      }
#line 91
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 91
    goto switch_break;
    case_2___0: /* CIL Label */ 
    {
#line 91
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 91
      if (sizeof(numa_node) == 1UL) {
#line 91
        goto case_1___1;
      }
#line 91
      if (sizeof(numa_node) == 2UL) {
#line 91
        goto case_2___1;
      }
#line 91
      if (sizeof(numa_node) == 4UL) {
#line 91
        goto case_4___0;
      }
#line 91
      if (sizeof(numa_node) == 8UL) {
#line 91
        goto case_8___0;
      }
#line 91
      goto switch_default___0;
      case_1___1: /* CIL Label */ 
      {
#line 91
      __asm__  ("mov"
                "b %1,"
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (numa_node): "qi" (node));
      }
#line 91
      goto switch_break___1;
      case_2___1: /* CIL Label */ 
      {
#line 91
      __asm__  ("mov"
                "w %1,"
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (numa_node): "ri" (node));
      }
#line 91
      goto switch_break___1;
      case_4___0: /* CIL Label */ 
      {
#line 91
      __asm__  ("mov"
                "l %1,"
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (numa_node): "ri" (node));
      }
#line 91
      goto switch_break___1;
      case_8___0: /* CIL Label */ 
      {
#line 91
      __asm__  ("mov"
                "q %1,"
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (numa_node): "re" (node));
      }
#line 91
      goto switch_break___1;
      switch_default___0: /* CIL Label */ 
      {
#line 91
      __bad_percpu_size();
      }
      switch_break___1: /* CIL Label */ ;
      }
#line 91
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 91
    goto switch_break;
    case_4___1: /* CIL Label */ 
    {
#line 91
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 91
      if (sizeof(numa_node) == 1UL) {
#line 91
        goto case_1___2;
      }
#line 91
      if (sizeof(numa_node) == 2UL) {
#line 91
        goto case_2___2;
      }
#line 91
      if (sizeof(numa_node) == 4UL) {
#line 91
        goto case_4___2;
      }
#line 91
      if (sizeof(numa_node) == 8UL) {
#line 91
        goto case_8___1;
      }
#line 91
      goto switch_default___1;
      case_1___2: /* CIL Label */ 
      {
#line 91
      __asm__  ("mov"
                "b %1,"
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (numa_node): "qi" (node));
      }
#line 91
      goto switch_break___2;
      case_2___2: /* CIL Label */ 
      {
#line 91
      __asm__  ("mov"
                "w %1,"
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (numa_node): "ri" (node));
      }
#line 91
      goto switch_break___2;
      case_4___2: /* CIL Label */ 
      {
#line 91
      __asm__  ("mov"
                "l %1,"
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (numa_node): "ri" (node));
      }
#line 91
      goto switch_break___2;
      case_8___1: /* CIL Label */ 
      {
#line 91
      __asm__  ("mov"
                "q %1,"
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (numa_node): "re" (node));
      }
#line 91
      goto switch_break___2;
      switch_default___1: /* CIL Label */ 
      {
#line 91
      __bad_percpu_size();
      }
      switch_break___2: /* CIL Label */ ;
      }
#line 91
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 91
    goto switch_break;
    case_8___2: /* CIL Label */ 
    {
#line 91
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 91
      if (sizeof(numa_node) == 1UL) {
#line 91
        goto case_1___3;
      }
#line 91
      if (sizeof(numa_node) == 2UL) {
#line 91
        goto case_2___3;
      }
#line 91
      if (sizeof(numa_node) == 4UL) {
#line 91
        goto case_4___3;
      }
#line 91
      if (sizeof(numa_node) == 8UL) {
#line 91
        goto case_8___3;
      }
#line 91
      goto switch_default___2;
      case_1___3: /* CIL Label */ 
      {
#line 91
      __asm__  ("mov"
                "b %1,"
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (numa_node): "qi" (node));
      }
#line 91
      goto switch_break___3;
      case_2___3: /* CIL Label */ 
      {
#line 91
      __asm__  ("mov"
                "w %1,"
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (numa_node): "ri" (node));
      }
#line 91
      goto switch_break___3;
      case_4___3: /* CIL Label */ 
      {
#line 91
      __asm__  ("mov"
                "l %1,"
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (numa_node): "ri" (node));
      }
#line 91
      goto switch_break___3;
      case_8___3: /* CIL Label */ 
      {
#line 91
      __asm__  ("mov"
                "q %1,"
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (numa_node): "re" (node));
      }
#line 91
      goto switch_break___3;
      switch_default___2: /* CIL Label */ 
      {
#line 91
      __bad_percpu_size();
      }
      switch_break___3: /* CIL Label */ ;
      }
#line 91
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 91
    goto switch_break;
    switch_default___3: /* CIL Label */ 
    {
#line 91
    __bad_size_call_parameter();
    }
#line 91
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 91
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  return;
}
}
#line 96
__inline static void set_cpu_numa_node(int cpu , int node )  __attribute__((__no_instrument_function__)) ;
#line 96 "../../../analyzer/../bench/linux-headers/include/linux/topology.h"
__inline static void set_cpu_numa_node(int cpu , int node ) 
{ 
  void const   *__vpp_verify ;
  unsigned long __ptr ;

  {
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 98
    __vpp_verify = (void const   *)((int *)((void *)0));
    }
#line 98
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 98
  __asm__  ("": "=r" (__ptr): "0" (& numa_node));
#line 98
  *((int *)(__ptr + __per_cpu_offset[cpu])) = node;
  }
#line 99
  return;
}
}
#line 156
__inline static int numa_mem_id(void)  __attribute__((__no_instrument_function__)) ;
#line 156 "../../../analyzer/../bench/linux-headers/include/linux/topology.h"
__inline static int numa_mem_id(void) 
{ 
  int tmp ;

  {
  {
#line 158
  tmp = numa_node_id();
  }
#line 158
  return (tmp);
}
}
#line 163
__inline static int cpu_to_mem(int cpu )  __attribute__((__no_instrument_function__)) ;
#line 163 "../../../analyzer/../bench/linux-headers/include/linux/topology.h"
__inline static int cpu_to_mem(int cpu ) 
{ 
  int tmp ;

  {
  {
#line 165
  tmp = cpu_to_node(cpu);
  }
#line 165
  return (tmp);
}
}
#line 185
__inline static struct cpumask  const  *cpu_smt_mask(int cpu )  __attribute__((__no_instrument_function__)) ;
#line 185 "../../../analyzer/../bench/linux-headers/include/linux/topology.h"
__inline static struct cpumask  const  *cpu_smt_mask(int cpu ) 
{ 
  void const   *__vpp_verify ;
  unsigned long __ptr ;

  {
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 187
    __vpp_verify = (void const   *)((cpumask_var_t *)((void *)0));
    }
#line 187
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 187
  __asm__  ("": "=r" (__ptr): "0" (& cpu_sibling_map));
  }
#line 187
  return ((struct cpumask  const  *)(*((cpumask_var_t *)(__ptr + __per_cpu_offset[cpu]))));
}
}
#line 191
__inline static struct cpumask  const  *cpu_cpu_mask(int cpu )  __attribute__((__no_instrument_function__)) ;
#line 191 "../../../analyzer/../bench/linux-headers/include/linux/topology.h"
__inline static struct cpumask  const  *cpu_cpu_mask(int cpu ) 
{ 
  int tmp ;
  struct cpumask  const  *tmp___0 ;

  {
  {
#line 193
  tmp = cpu_to_node(cpu);
#line 193
  tmp___0 = cpumask_of_node(tmp);
  }
#line 193
  return (tmp___0);
}
}
#line 159 "../../../analyzer/../bench/linux-headers/include/linux/gfp.h"
__inline static int allocflags_to_migratetype(gfp_t gfp_flags )  __attribute__((__no_instrument_function__)) ;
#line 159 "../../../analyzer/../bench/linux-headers/include/linux/gfp.h"
__inline static int allocflags_to_migratetype(gfp_t gfp_flags ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 161
  __ret_warn_on = ! (! ((gfp_flags & 524296U) == 524296U));
#line 161
  tmp = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
  }
#line 161
  if (tmp) {
    {
#line 161
    warn_slowpath_null("../../../analyzer/../bench/linux-headers/include/linux/gfp.h",
                       (int const   )161);
    }
  }
  {
#line 161
  __builtin_expect((long )(! (! __ret_warn_on)), 0L);
#line 163
  tmp___0 = __builtin_expect((long )(! (! page_group_by_mobility_disabled)), 0L);
  }
#line 163
  if (tmp___0) {
#line 164
    return (0);
  }
#line 167
  return ((((gfp_flags & 8U) != 0U) << 1) | ((gfp_flags & 524288U) != 0U));
}
}
#line 254
__inline static enum zone_type gfp_zone(gfp_t flags )  __attribute__((__no_instrument_function__)) ;
#line 254 "../../../analyzer/../bench/linux-headers/include/linux/gfp.h"
__inline static enum zone_type gfp_zone(gfp_t flags ) 
{ 
  enum zone_type z ;
  int bit ;

  {
  {
#line 257
  bit = (int )(flags & 15U);
#line 259
  z = (enum zone_type )(((((((2 | (2 << 4U)) | (1 << 8U)) | (2 << 16U)) | (3 << 20U)) | (1 << 24U)) >> bit * 2) & ((1 << 2) - 1));
  }
#line 262
  return (z);
}
}
#line 272
__inline static int gfp_zonelist(gfp_t flags )  __attribute__((__no_instrument_function__)) ;
#line 272 "../../../analyzer/../bench/linux-headers/include/linux/gfp.h"
__inline static int gfp_zonelist(gfp_t flags ) 
{ 
  long tmp ;

  {
  {
#line 274
  tmp = __builtin_expect((long )(! (! (flags & 262144U))), 0L);
  }
#line 274
  if (tmp) {
#line 275
    return (1);
  }
#line 277
  return (0);
}
}
#line 289
__inline static struct zonelist *node_zonelist(int nid , gfp_t flags )  __attribute__((__no_instrument_function__)) ;
#line 289 "../../../analyzer/../bench/linux-headers/include/linux/gfp.h"
__inline static struct zonelist *node_zonelist(int nid , gfp_t flags ) 
{ 
  int tmp ;

  {
  {
#line 291
  tmp = gfp_zonelist(flags);
  }
#line 291
  return ((node_data[nid])->node_zonelists + tmp);
}
}
#line 295
__inline static void arch_free_page(struct page *page , int order )  __attribute__((__no_instrument_function__)) ;
#line 295 "../../../analyzer/../bench/linux-headers/include/linux/gfp.h"
__inline static void arch_free_page(struct page *page , int order ) 
{ 


  {
#line 295
  return;
}
}
#line 298
__inline static void arch_alloc_page(struct page *page , int order )  __attribute__((__no_instrument_function__)) ;
#line 298 "../../../analyzer/../bench/linux-headers/include/linux/gfp.h"
__inline static void arch_alloc_page(struct page *page , int order ) 
{ 


  {
#line 298
  return;
}
}
#line 301
extern struct page *__alloc_pages_nodemask(gfp_t gfp_mask , unsigned int order , struct zonelist *zonelist ,
                                           nodemask_t *nodemask ) ;
#line 305
__inline static struct page *__alloc_pages(gfp_t gfp_mask , unsigned int order , struct zonelist *zonelist )  __attribute__((__no_instrument_function__)) ;
#line 305 "../../../analyzer/../bench/linux-headers/include/linux/gfp.h"
__inline static struct page *__alloc_pages(gfp_t gfp_mask , unsigned int order , struct zonelist *zonelist ) 
{ 
  struct page *tmp ;

  {
  {
#line 309
  tmp = __alloc_pages_nodemask(gfp_mask, order, zonelist, (nodemask_t *)((void *)0));
  }
#line 309
  return (tmp);
}
}
#line 312
__inline static struct page *alloc_pages_node(int nid , gfp_t gfp_mask , unsigned int order )  __attribute__((__no_instrument_function__)) ;
#line 312 "../../../analyzer/../bench/linux-headers/include/linux/gfp.h"
__inline static struct page *alloc_pages_node(int nid , gfp_t gfp_mask , unsigned int order ) 
{ 
  struct zonelist *tmp ;
  struct page *tmp___0 ;

  {
#line 316
  if (nid < 0) {
    {
#line 317
    nid = numa_node_id();
    }
  }
  {
#line 319
  tmp = node_zonelist(nid, gfp_mask);
#line 319
  tmp___0 = __alloc_pages(gfp_mask, order, tmp);
  }
#line 319
  return (tmp___0);
}
}
#line 322
__inline static struct page *alloc_pages_exact_node(int nid , gfp_t gfp_mask , unsigned int order )  __attribute__((__no_instrument_function__)) ;
#line 322 "../../../analyzer/../bench/linux-headers/include/linux/gfp.h"
__inline static struct page *alloc_pages_exact_node(int nid , gfp_t gfp_mask , unsigned int order ) 
{ 
  struct zonelist *tmp ;
  struct page *tmp___0 ;

  {
  {
#line 327
  tmp = node_zonelist(nid, gfp_mask);
#line 327
  tmp___0 = __alloc_pages(gfp_mask, order, tmp);
  }
#line 327
  return (tmp___0);
}
}
#line 331
extern struct page *alloc_pages_current(gfp_t gfp_mask , unsigned int order ) ;
#line 333
__inline static struct page *alloc_pages(gfp_t gfp_mask , unsigned int order )  __attribute__((__no_instrument_function__)) ;
#line 333 "../../../analyzer/../bench/linux-headers/include/linux/gfp.h"
__inline static struct page *alloc_pages(gfp_t gfp_mask , unsigned int order ) 
{ 
  struct page *tmp ;

  {
  {
#line 336
  tmp = alloc_pages_current(gfp_mask, order);
  }
#line 336
  return (tmp);
}
}
#line 338
extern struct page *alloc_pages_vma(gfp_t gfp_mask , int order , struct vm_area_struct *vma ,
                                    unsigned long addr , int node ) ;
#line 353
extern struct page *alloc_kmem_pages(gfp_t gfp_mask , unsigned int order ) ;
#line 354
extern struct page *alloc_kmem_pages_node(int nid , gfp_t gfp_mask , unsigned int order ) ;
#line 357
extern unsigned long __get_free_pages(gfp_t gfp_mask , unsigned int order ) ;
#line 358
extern unsigned long get_zeroed_page(gfp_t gfp_mask ) ;
#line 360
extern void *alloc_pages_exact(size_t size , gfp_t gfp_mask ) ;
#line 361
extern void free_pages_exact(void *virt , size_t size ) ;
#line 363
extern void * __attribute__((__cold__)) alloc_pages_exact_nid(int nid , size_t size ,
                                                              gfp_t gfp_mask )  __attribute__((__section__(".meminit.text"),
__no_instrument_function__)) ;
#line 371
extern void __free_pages(struct page *page , unsigned int order ) ;
#line 372
extern void free_pages(unsigned long addr , unsigned int order ) ;
#line 373
extern void free_hot_cold_page(struct page *page , bool cold ) ;
#line 374
extern void free_hot_cold_page_list(struct list_head *list , bool cold ) ;
#line 376
extern void __free_kmem_pages(struct page *page , unsigned int order ) ;
#line 377
extern void free_kmem_pages(unsigned long addr , unsigned int order ) ;
#line 382
extern void page_alloc_init(void) ;
#line 383
extern void drain_zone_pages(struct zone *zone , struct per_cpu_pages *pcp ) ;
#line 384
extern void drain_all_pages(void) ;
#line 385
extern void drain_local_pages(void *dummy ) ;
#line 394
extern gfp_t gfp_allowed_mask ;
#line 397
extern bool gfp_pfmemalloc_allowed(gfp_t gfp_mask ) ;
#line 399
extern void pm_restrict_gfp_mask(void) ;
#line 400
extern void pm_restore_gfp_mask(void) ;
#line 403
extern bool pm_suspended_storage(void) ;
#line 40 "../../../analyzer/../bench/linux-headers/include/linux/sysctl.h"
extern int proc_dostring(struct ctl_table * , int  , void * , size_t * , loff_t * ) ;
#line 42
extern int proc_dointvec(struct ctl_table * , int  , void * , size_t * , loff_t * ) ;
#line 44
extern int proc_dointvec_minmax(struct ctl_table * , int  , void * , size_t * , loff_t * ) ;
#line 46
extern int proc_dointvec_jiffies(struct ctl_table * , int  , void * , size_t * , loff_t * ) ;
#line 48
extern int proc_dointvec_userhz_jiffies(struct ctl_table * , int  , void * , size_t * ,
                                        loff_t * ) ;
#line 50
extern int proc_dointvec_ms_jiffies(struct ctl_table * , int  , void * , size_t * ,
                                    loff_t * ) ;
#line 52
extern int proc_doulongvec_minmax(struct ctl_table * , int  , void * , size_t * ,
                                  loff_t * ) ;
#line 54
extern int proc_doulongvec_ms_jiffies_minmax(struct ctl_table *table , int  , void * ,
                                             size_t * , loff_t * ) ;
#line 56
extern int proc_do_large_bitmap(struct ctl_table * , int  , void * , size_t * , loff_t * ) ;
#line 92
__inline static void *proc_sys_poll_event(struct ctl_table_poll *poll )  __attribute__((__no_instrument_function__)) ;
#line 92 "../../../analyzer/../bench/linux-headers/include/linux/sysctl.h"
__inline static void *proc_sys_poll_event(struct ctl_table_poll *poll ) 
{ 
  int tmp ;

  {
  {
#line 94
  tmp = atomic_read((atomic_t const   *)(& poll->event));
  }
#line 94
  return ((void *)((unsigned long )tmp));
}
}
#line 169
extern void proc_sys_poll_notify(struct ctl_table_poll *poll ) ;
#line 171
extern void setup_sysctl_set(struct ctl_table_set *p , struct ctl_table_root *root ,
                             int (*is_seen)(struct ctl_table_set * ) ) ;
#line 174
extern void retire_sysctl_set(struct ctl_table_set *set ) ;
#line 176
extern void register_sysctl_root(struct ctl_table_root *root ) ;
#line 177
extern struct ctl_table_header *__register_sysctl_table(struct ctl_table_set *set ,
                                                        char const   *path , struct ctl_table *table ) ;
#line 180
extern struct ctl_table_header *__register_sysctl_paths(struct ctl_table_set *set ,
                                                        struct ctl_path  const  *path ,
                                                        struct ctl_table *table ) ;
#line 183
extern struct ctl_table_header *register_sysctl(char const   *path , struct ctl_table *table ) ;
#line 184
extern struct ctl_table_header *register_sysctl_table(struct ctl_table *table ) ;
#line 185
extern struct ctl_table_header *register_sysctl_paths(struct ctl_path  const  *path ,
                                                      struct ctl_table *table ) ;
#line 188
extern void unregister_sysctl_table(struct ctl_table_header *table ) ;
#line 190
extern int sysctl_init(void) ;
#line 32 "../../../analyzer/../bench/linux-headers/include/linux/kmod.h"
extern char modprobe_path[] ;
#line 35
extern int ( /* format attribute */  __request_module)(bool wait , char const   *name 
                                                       , ...) ;
#line 69
extern int call_usermodehelper(char *path , char **argv , char **envp , int wait ) ;
#line 72
extern struct subprocess_info *call_usermodehelper_setup(char *path , char **argv ,
                                                         char **envp , gfp_t gfp_mask ,
                                                         int (*init)(struct subprocess_info *info ,
                                                                     struct cred *new ) ,
                                                         void (*cleanup)(struct subprocess_info * ) ,
                                                         void *data ) ;
#line 77
extern int call_usermodehelper_exec(struct subprocess_info *info , int wait ) ;
#line 80
extern struct ctl_table usermodehelper_table[] ;
#line 88
extern void usermodehelper_init(void) ;
#line 90
extern int __usermodehelper_disable(enum umh_disable_depth depth ) ;
#line 91
extern void __usermodehelper_set_disable_depth(enum umh_disable_depth depth ) ;
#line 93
__inline static int usermodehelper_disable(void)  __attribute__((__no_instrument_function__)) ;
#line 93 "../../../analyzer/../bench/linux-headers/include/linux/kmod.h"
__inline static int usermodehelper_disable(void) 
{ 
  int tmp ;

  {
  {
#line 95
  tmp = __usermodehelper_disable((enum umh_disable_depth )2);
  }
#line 95
  return (tmp);
}
}
#line 98
__inline static void usermodehelper_enable(void)  __attribute__((__no_instrument_function__)) ;
#line 98 "../../../analyzer/../bench/linux-headers/include/linux/kmod.h"
__inline static void usermodehelper_enable(void) 
{ 


  {
  {
#line 100
  __usermodehelper_set_disable_depth((enum umh_disable_depth )0);
  }
#line 101
  return;
}
}
#line 103
extern int usermodehelper_read_trylock(void) ;
#line 104
extern long usermodehelper_read_lock_wait(long timeout ) ;
#line 105
extern void usermodehelper_read_unlock(void) ;
#line 140 "../../../analyzer/../bench/linux-headers/include/linux/uprobes.h"
__inline static int uprobe_register(struct inode *inode , loff_t offset , struct uprobe_consumer *uc )  __attribute__((__no_instrument_function__)) ;
#line 140 "../../../analyzer/../bench/linux-headers/include/linux/uprobes.h"
__inline static int uprobe_register(struct inode *inode , loff_t offset , struct uprobe_consumer *uc ) 
{ 


  {
#line 143
  return (-38);
}
}
#line 145
__inline static int uprobe_apply(struct inode *inode , loff_t offset , struct uprobe_consumer *uc ,
                                 bool add )  __attribute__((__no_instrument_function__)) ;
#line 145 "../../../analyzer/../bench/linux-headers/include/linux/uprobes.h"
__inline static int uprobe_apply(struct inode *inode , loff_t offset , struct uprobe_consumer *uc ,
                                 bool add ) 
{ 


  {
#line 148
  return (-38);
}
}
#line 150
__inline static void uprobe_unregister(struct inode *inode , loff_t offset , struct uprobe_consumer *uc )  __attribute__((__no_instrument_function__)) ;
#line 150 "../../../analyzer/../bench/linux-headers/include/linux/uprobes.h"
__inline static void uprobe_unregister(struct inode *inode , loff_t offset , struct uprobe_consumer *uc ) 
{ 


  {
#line 153
  return;
}
}
#line 154
__inline static int uprobe_mmap(struct vm_area_struct *vma )  __attribute__((__no_instrument_function__)) ;
#line 154 "../../../analyzer/../bench/linux-headers/include/linux/uprobes.h"
__inline static int uprobe_mmap(struct vm_area_struct *vma ) 
{ 


  {
#line 156
  return (0);
}
}
#line 158
__inline static void uprobe_munmap(struct vm_area_struct *vma , unsigned long start ,
                                   unsigned long end )  __attribute__((__no_instrument_function__)) ;
#line 158 "../../../analyzer/../bench/linux-headers/include/linux/uprobes.h"
__inline static void uprobe_munmap(struct vm_area_struct *vma , unsigned long start ,
                                   unsigned long end ) 
{ 


  {
#line 161
  return;
}
}
#line 162
__inline static void uprobe_start_dup_mmap(void)  __attribute__((__no_instrument_function__)) ;
#line 162 "../../../analyzer/../bench/linux-headers/include/linux/uprobes.h"
__inline static void uprobe_start_dup_mmap(void) 
{ 


  {
#line 164
  return;
}
}
#line 165
__inline static void uprobe_end_dup_mmap(void)  __attribute__((__no_instrument_function__)) ;
#line 165 "../../../analyzer/../bench/linux-headers/include/linux/uprobes.h"
__inline static void uprobe_end_dup_mmap(void) 
{ 


  {
#line 167
  return;
}
}
#line 168
__inline static void uprobe_dup_mmap(struct mm_struct *oldmm , struct mm_struct *newmm )  __attribute__((__no_instrument_function__)) ;
#line 168 "../../../analyzer/../bench/linux-headers/include/linux/uprobes.h"
__inline static void uprobe_dup_mmap(struct mm_struct *oldmm , struct mm_struct *newmm ) 
{ 


  {
#line 171
  return;
}
}
#line 172
__inline static void uprobe_notify_resume(struct pt_regs *regs )  __attribute__((__no_instrument_function__)) ;
#line 172 "../../../analyzer/../bench/linux-headers/include/linux/uprobes.h"
__inline static void uprobe_notify_resume(struct pt_regs *regs ) 
{ 


  {
#line 174
  return;
}
}
#line 175
__inline static bool uprobe_deny_signal(void)  __attribute__((__no_instrument_function__)) ;
#line 175 "../../../analyzer/../bench/linux-headers/include/linux/uprobes.h"
__inline static bool uprobe_deny_signal(void) 
{ 


  {
#line 177
  return ((bool )0);
}
}
#line 179
__inline static void uprobe_free_utask(struct task_struct *t )  __attribute__((__no_instrument_function__)) ;
#line 179 "../../../analyzer/../bench/linux-headers/include/linux/uprobes.h"
__inline static void uprobe_free_utask(struct task_struct *t ) 
{ 


  {
#line 181
  return;
}
}
#line 182
__inline static void uprobe_copy_process(struct task_struct *t , unsigned long flags )  __attribute__((__no_instrument_function__)) ;
#line 182 "../../../analyzer/../bench/linux-headers/include/linux/uprobes.h"
__inline static void uprobe_copy_process(struct task_struct *t , unsigned long flags ) 
{ 


  {
#line 184
  return;
}
}
#line 185
__inline static void uprobe_clear_state(struct mm_struct *mm )  __attribute__((__no_instrument_function__)) ;
#line 185 "../../../analyzer/../bench/linux-headers/include/linux/uprobes.h"
__inline static void uprobe_clear_state(struct mm_struct *mm ) 
{ 


  {
#line 187
  return;
}
}
#line 459 "../../../analyzer/../bench/linux-headers/include/linux/mm_types.h"
__inline static void mm_init_cpumask(struct mm_struct *mm )  __attribute__((__no_instrument_function__)) ;
#line 459 "../../../analyzer/../bench/linux-headers/include/linux/mm_types.h"
__inline static void mm_init_cpumask(struct mm_struct *mm ) 
{ 


  {
  {
#line 464
  cpumask_clear(mm->cpu_vm_mask_var);
  }
#line 465
  return;
}
}
#line 468
__inline static cpumask_t *mm_cpumask(struct mm_struct *mm )  __attribute__((__no_instrument_function__)) ;
#line 468 "../../../analyzer/../bench/linux-headers/include/linux/mm_types.h"
__inline static cpumask_t *mm_cpumask(struct mm_struct *mm ) 
{ 


  {
#line 470
  return (mm->cpu_vm_mask_var);
}
}
#line 480
__inline static bool mm_tlb_flush_pending(struct mm_struct *mm )  __attribute__((__no_instrument_function__)) ;
#line 480 "../../../analyzer/../bench/linux-headers/include/linux/mm_types.h"
__inline static bool mm_tlb_flush_pending(struct mm_struct *mm ) 
{ 


  {
  {
#line 482
  __asm__  volatile   ("": : : "memory");
  }
#line 483
  return (mm->tlb_flush_pending);
}
}
#line 485
__inline static void set_tlb_flush_pending(struct mm_struct *mm )  __attribute__((__no_instrument_function__)) ;
#line 485 "../../../analyzer/../bench/linux-headers/include/linux/mm_types.h"
__inline static void set_tlb_flush_pending(struct mm_struct *mm ) 
{ 


  {
  {
#line 487
  mm->tlb_flush_pending = (bool )1;
#line 493
  __asm__  volatile   ("": : : "memory");
  }
#line 494
  return;
}
}
#line 496
__inline static void clear_tlb_flush_pending(struct mm_struct *mm )  __attribute__((__no_instrument_function__)) ;
#line 496 "../../../analyzer/../bench/linux-headers/include/linux/mm_types.h"
__inline static void clear_tlb_flush_pending(struct mm_struct *mm ) 
{ 


  {
  {
#line 498
  __asm__  volatile   ("": : : "memory");
#line 499
  mm->tlb_flush_pending = (bool )0;
  }
#line 500
  return;
}
}
#line 33 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/vdso.h"
extern struct vdso_image  const  vdso_image_64 ;
#line 41
extern struct vdso_image  const  vdso_image_32_int80 ;
#line 43
extern struct vdso_image  const  vdso_image_32_syscall ;
#line 45
extern struct vdso_image  const  vdso_image_32_sysenter ;
#line 47
extern struct vdso_image  const  *selected_vdso32 ;
#line 50
extern void __attribute__((__cold__))  init_vdso_image(struct vdso_image  const  *image )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 79 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/elf.h"
extern unsigned int vdso64_enabled ;
#line 82
extern unsigned int vdso32_enabled ;
#line 170
__inline static void elf_common_init(struct thread_struct *t , struct pt_regs *regs ,
                                     u16 const   ds )  __attribute__((__no_instrument_function__)) ;
#line 170 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/elf.h"
__inline static void elf_common_init(struct thread_struct *t , struct pt_regs *regs ,
                                     u16 const   ds ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___10 ;
  unsigned short tmp___11 ;
  unsigned short tmp___12 ;

  {
  {
#line 173
  tmp___1 = 0UL;
#line 173
  regs->dx = tmp___1;
#line 173
  tmp___0 = tmp___1;
#line 173
  regs->cx = tmp___0;
#line 173
  tmp = tmp___0;
#line 173
  regs->bx = tmp;
#line 173
  regs->ax = tmp;
#line 174
  tmp___3 = 0UL;
#line 174
  regs->bp = tmp___3;
#line 174
  tmp___2 = tmp___3;
#line 174
  regs->di = tmp___2;
#line 174
  regs->si = tmp___2;
#line 175
  tmp___6 = 0UL;
#line 175
  regs->r11 = tmp___6;
#line 175
  tmp___5 = tmp___6;
#line 175
  regs->r10 = tmp___5;
#line 175
  tmp___4 = tmp___5;
#line 175
  regs->r9 = tmp___4;
#line 175
  regs->r8 = tmp___4;
#line 176
  tmp___9 = 0UL;
#line 176
  regs->r15 = tmp___9;
#line 176
  tmp___8 = tmp___9;
#line 176
  regs->r14 = tmp___8;
#line 176
  tmp___7 = tmp___8;
#line 176
  regs->r13 = tmp___7;
#line 176
  regs->r12 = tmp___7;
#line 177
  tmp___10 = 0UL;
#line 177
  t->gs = tmp___10;
#line 177
  t->fs = tmp___10;
#line 178
  tmp___11 = (unsigned short)0;
#line 178
  t->gsindex = tmp___11;
#line 178
  t->fsindex = tmp___11;
#line 179
  tmp___12 = (unsigned short )ds;
#line 179
  t->es = tmp___12;
#line 179
  t->ds = tmp___12;
  }
#line 180
  return;
}
}
#line 188
extern void start_thread_ia32(struct pt_regs *regs , u32 new_ip , u32 new_sp ) ;
#line 191
extern void set_personality_ia32(bool  ) ;
#line 237
extern void set_personality_64bit(void) ;
#line 238
extern unsigned int sysctl_vsyscall32 ;
#line 239
extern int force_personality32 ;
#line 334
extern int arch_setup_additional_pages(struct linux_binprm *bprm , int uses_interp ) ;
#line 336
extern int compat_arch_setup_additional_pages(struct linux_binprm *bprm , int uses_interp ) ;
#line 340
extern unsigned long arch_randomize_brk(struct mm_struct *mm ) ;
#line 346
__inline static int mmap_is_ia32(void)  __attribute__((__no_instrument_function__)) ;
#line 346 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/elf.h"
__inline static int mmap_is_ia32(void) 
{ 
  struct thread_info *tmp ;
  int tmp___0 ;

  {
  {
#line 352
  tmp = current_thread_info();
#line 352
  tmp___0 = test_ti_thread_flag(tmp, 29);
  }
#line 352
  if (tmp___0) {
#line 353
    return (1);
  }
#line 355
  return (0);
}
}
#line 369
extern struct va_alignment va_align ;
#line 370
extern unsigned long align_vdso_addr(unsigned long  ) ;
#line 30 "../../../analyzer/../bench/linux-headers/include/linux/elf.h"
extern Elf64_Dyn _DYNAMIC[] ;
#line 45
__inline static int elf_coredump_extra_notes_size(void)  __attribute__((__no_instrument_function__)) ;
#line 45 "../../../analyzer/../bench/linux-headers/include/linux/elf.h"
__inline static int elf_coredump_extra_notes_size(void) 
{ 


  {
#line 45
  return (0);
}
}
#line 46
__inline static int elf_coredump_extra_notes_write(struct coredump_params *cprm )  __attribute__((__no_instrument_function__)) ;
#line 46 "../../../analyzer/../bench/linux-headers/include/linux/elf.h"
__inline static int elf_coredump_extra_notes_write(struct coredump_params *cprm ) 
{ 


  {
#line 46
  return (0);
}
}
#line 79 "../../../analyzer/../bench/linux-headers/include/linux/idr.h"
extern void *idr_find_slowpath(struct idr *idp , int id ) ;
#line 80
extern void idr_preload(gfp_t gfp_mask ) ;
#line 81
extern int idr_alloc(struct idr *idp , void *ptr , int start , int end , gfp_t gfp_mask ) ;
#line 82
extern int idr_alloc_cyclic(struct idr *idr , void *ptr , int start , int end , gfp_t gfp_mask ) ;
#line 83
extern int idr_for_each(struct idr *idp , int (*fn)(int id , void *p , void *data ) ,
                        void *data ) ;
#line 85
extern void *idr_get_next(struct idr *idp , int *nextid ) ;
#line 86
extern void *idr_replace(struct idr *idp , void *ptr , int id ) ;
#line 87
extern void idr_remove(struct idr *idp , int id ) ;
#line 88
extern void idr_destroy(struct idr *idp ) ;
#line 89
extern void idr_init(struct idr *idp ) ;
#line 90
extern bool idr_is_empty(struct idr *idp ) ;
#line 98
__inline static void idr_preload_end(void)  __attribute__((__no_instrument_function__)) ;
#line 98 "../../../analyzer/../bench/linux-headers/include/linux/idr.h"
__inline static void idr_preload_end(void) 
{ 


  {
  {
#line 100
  __asm__  volatile   ("": : : "memory");
  }
#line 101
  return;
}
}
#line 115
__inline static void *idr_find(struct idr *idr , int id )  __attribute__((__no_instrument_function__)) ;
#line 115 "../../../analyzer/../bench/linux-headers/include/linux/idr.h"
__inline static void *idr_find(struct idr *idr , int id ) 
{ 
  struct idr_layer *hint ;
  struct idr_layer *_________p1 ;
  struct idr_layer *_________p1___0 ;
  void *tmp ;

  {
  {
#line 117
  _________p1 = (struct idr_layer *)*((struct idr_layer * volatile  *)(& idr->hint));
  }
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 117
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 117
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 117
  hint = _________p1;
  }
#line 119
  if (hint) {
#line 119
    if ((id & ~ ((1 << 8) - 1)) == hint->prefix) {
      {
#line 120
      _________p1___0 = (struct idr_layer *)*((struct idr_layer * volatile  *)(& hint->ary[id & ((1 << 8) - 1)]));
      }
      {
#line 120
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 120
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 120
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 120
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 120
      return ((void *)_________p1___0);
    }
  }
  {
#line 122
  tmp = idr_find_slowpath(idr, id);
  }
#line 122
  return (tmp);
}
}
#line 162
extern int ida_pre_get(struct ida *ida , gfp_t gfp_mask ) ;
#line 163
extern int ida_get_new_above(struct ida *ida , int starting_id , int *p_id ) ;
#line 164
extern void ida_remove(struct ida *ida , int id ) ;
#line 165
extern void ida_destroy(struct ida *ida ) ;
#line 166
extern void ida_init(struct ida *ida ) ;
#line 168
extern int ida_simple_get(struct ida *ida , unsigned int start , unsigned int end ,
                          gfp_t gfp_mask ) ;
#line 170
extern void ida_simple_remove(struct ida *ida , unsigned int id ) ;
#line 179
__inline static int ida_get_new(struct ida *ida , int *p_id )  __attribute__((__no_instrument_function__)) ;
#line 179 "../../../analyzer/../bench/linux-headers/include/linux/idr.h"
__inline static int ida_get_new(struct ida *ida , int *p_id ) 
{ 
  int tmp ;

  {
  {
#line 181
  tmp = ida_get_new_above(ida, 0, p_id);
  }
#line 181
  return (tmp);
}
}
#line 184
extern void __attribute__((__cold__))  idr_init_cache(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 229 "../../../analyzer/../bench/linux-headers/include/linux/kernfs.h"
__inline static enum kernfs_node_type kernfs_type(struct kernfs_node *kn )  __attribute__((__no_instrument_function__)) ;
#line 229 "../../../analyzer/../bench/linux-headers/include/linux/kernfs.h"
__inline static enum kernfs_node_type kernfs_type(struct kernfs_node *kn ) 
{ 


  {
#line 231
  return ((enum kernfs_node_type )((int )kn->flags & 15));
}
}
#line 244 "../../../analyzer/../bench/linux-headers/include/linux/kernfs.h"
static bool __warned  __attribute__((__section__(".data.unlikely")))  ;
#line 245 "../../../analyzer/../bench/linux-headers/include/linux/kernfs.h"
static bool __warned___0  __attribute__((__section__(".data.unlikely")))  ;
#line 242
__inline static void kernfs_enable_ns(struct kernfs_node *kn )  __attribute__((__no_instrument_function__)) ;
#line 242 "../../../analyzer/../bench/linux-headers/include/linux/kernfs.h"
__inline static void kernfs_enable_ns(struct kernfs_node *kn ) 
{ 
  int __ret_warn_once ;
  enum kernfs_node_type tmp ;
  int tmp___0 ;
  int __ret_warn_on ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  int __ret_warn_once___0 ;
  int __ret_warn_on___0 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;

  {
  {
#line 244
  tmp = kernfs_type(kn);
  }
#line 244
  if ((unsigned int )tmp != 1U) {
    {
#line 244
    tmp___0 = 1;
    }
  } else {
    {
#line 244
    tmp___0 = 0;
    }
  }
  {
#line 244
  __ret_warn_once = tmp___0;
#line 244
  tmp___3 = __builtin_expect((long )(! (! __ret_warn_once)), 0L);
  }
#line 244
  if (tmp___3) {
    {
#line 244
    __ret_warn_on = ! (! (! __warned));
#line 244
    tmp___1 = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
    }
#line 244
    if (tmp___1) {
      {
#line 244
      warn_slowpath_null("../../../analyzer/../bench/linux-headers/include/linux/kernfs.h",
                         (int const   )244);
      }
    }
    {
#line 244
    tmp___2 = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
    }
#line 244
    if (tmp___2) {
      {
#line 244
      __warned = (bool )1;
      }
    }
  }
  {
#line 244
  __builtin_expect((long )(! (! __ret_warn_once)), 0L);
#line 245
  __ret_warn_once___0 = ! (! (! ((unsigned long )kn->__annonCompField32.dir.children.rb_node == (unsigned long )((void *)0))));
#line 245
  tmp___6 = __builtin_expect((long )(! (! __ret_warn_once___0)), 0L);
  }
#line 245
  if (tmp___6) {
    {
#line 245
    __ret_warn_on___0 = ! (! (! __warned___0));
#line 245
    tmp___4 = __builtin_expect((long )(! (! __ret_warn_on___0)), 0L);
    }
#line 245
    if (tmp___4) {
      {
#line 245
      warn_slowpath_null("../../../analyzer/../bench/linux-headers/include/linux/kernfs.h",
                         (int const   )245);
      }
    }
    {
#line 245
    tmp___5 = __builtin_expect((long )(! (! __ret_warn_on___0)), 0L);
    }
#line 245
    if (tmp___5) {
      {
#line 245
      __warned___0 = (bool )1;
      }
    }
  }
  {
#line 245
  __builtin_expect((long )(! (! __ret_warn_once___0)), 0L);
#line 246
  kn->flags = (unsigned short )((int )kn->flags | 32);
  }
#line 247
  return;
}
}
#line 255
__inline static bool kernfs_ns_enabled(struct kernfs_node *kn )  __attribute__((__no_instrument_function__)) ;
#line 255 "../../../analyzer/../bench/linux-headers/include/linux/kernfs.h"
__inline static bool kernfs_ns_enabled(struct kernfs_node *kn ) 
{ 


  {
#line 257
  return ((bool )((int )kn->flags & 32));
}
}
#line 260
extern int kernfs_name(struct kernfs_node *kn , char *buf , size_t buflen ) ;
#line 261
extern char *( __attribute__((__warn_unused_result__)) kernfs_path)(struct kernfs_node *kn ,
                                                                    char *buf , size_t buflen ) ;
#line 263
extern void pr_cont_kernfs_name(struct kernfs_node *kn ) ;
#line 264
extern void pr_cont_kernfs_path(struct kernfs_node *kn ) ;
#line 265
extern struct kernfs_node *kernfs_get_parent(struct kernfs_node *kn ) ;
#line 266
extern struct kernfs_node *kernfs_find_and_get_ns(struct kernfs_node *parent , char const   *name ,
                                                  void const   *ns ) ;
#line 268
extern void kernfs_get(struct kernfs_node *kn ) ;
#line 269
extern void kernfs_put(struct kernfs_node *kn ) ;
#line 271
extern struct kernfs_node *kernfs_node_from_dentry(struct dentry *dentry ) ;
#line 272
extern struct kernfs_root *kernfs_root_from_sb(struct super_block *sb ) ;
#line 274
extern struct kernfs_root *kernfs_create_root(struct kernfs_syscall_ops *scops , unsigned int flags ,
                                              void *priv ) ;
#line 276
extern void kernfs_destroy_root(struct kernfs_root *root ) ;
#line 278
extern struct kernfs_node *kernfs_create_dir_ns(struct kernfs_node *parent , char const   *name ,
                                                umode_t mode , void *priv , void const   *ns ) ;
#line 281
extern struct kernfs_node *__kernfs_create_file(struct kernfs_node *parent , char const   *name ,
                                                umode_t mode , loff_t size , struct kernfs_ops  const  *ops ,
                                                void *priv , void const   *ns , bool name_is_static ,
                                                struct lock_class_key *key ) ;
#line 288
extern struct kernfs_node *kernfs_create_link(struct kernfs_node *parent , char const   *name ,
                                              struct kernfs_node *target ) ;
#line 291
extern void kernfs_activate(struct kernfs_node *kn ) ;
#line 292
extern void kernfs_remove(struct kernfs_node *kn ) ;
#line 293
extern void kernfs_break_active_protection(struct kernfs_node *kn ) ;
#line 294
extern void kernfs_unbreak_active_protection(struct kernfs_node *kn ) ;
#line 295
extern bool kernfs_remove_self(struct kernfs_node *kn ) ;
#line 296
extern int kernfs_remove_by_name_ns(struct kernfs_node *parent , char const   *name ,
                                    void const   *ns ) ;
#line 298
extern int kernfs_rename_ns(struct kernfs_node *kn , struct kernfs_node *new_parent ,
                            char const   *new_name , void const   *new_ns ) ;
#line 300
extern int kernfs_setattr(struct kernfs_node *kn , struct iattr  const  *iattr ) ;
#line 301
extern void kernfs_notify(struct kernfs_node *kn ) ;
#line 303
extern void const   *kernfs_super_ns(struct super_block *sb ) ;
#line 304
extern struct dentry *kernfs_mount_ns(struct file_system_type *fs_type , int flags ,
                                      struct kernfs_root *root , unsigned long magic ,
                                      bool *new_sb_created , void const   *ns ) ;
#line 307
extern void kernfs_kill_sb(struct super_block *sb ) ;
#line 308
extern struct super_block *kernfs_pin_sb(struct kernfs_root *root , void const   *ns ) ;
#line 310
extern void kernfs_init(void) ;
#line 410
__inline static struct kernfs_node *kernfs_find_and_get(struct kernfs_node *kn , char const   *name )  __attribute__((__no_instrument_function__)) ;
#line 410 "../../../analyzer/../bench/linux-headers/include/linux/kernfs.h"
__inline static struct kernfs_node *kernfs_find_and_get(struct kernfs_node *kn , char const   *name ) 
{ 
  struct kernfs_node *tmp ;

  {
  {
#line 413
  tmp = kernfs_find_and_get_ns(kn, name, (void const   *)((void *)0));
  }
#line 413
  return (tmp);
}
}
#line 416
__inline static struct kernfs_node *kernfs_create_dir(struct kernfs_node *parent ,
                                                      char const   *name , umode_t mode ,
                                                      void *priv )  __attribute__((__no_instrument_function__)) ;
#line 416 "../../../analyzer/../bench/linux-headers/include/linux/kernfs.h"
__inline static struct kernfs_node *kernfs_create_dir(struct kernfs_node *parent ,
                                                      char const   *name , umode_t mode ,
                                                      void *priv ) 
{ 
  struct kernfs_node *tmp ;

  {
  {
#line 420
  tmp = kernfs_create_dir_ns(parent, name, mode, priv, (void const   *)((void *)0));
  }
#line 420
  return (tmp);
}
}
#line 423
__inline static struct kernfs_node *kernfs_create_file_ns(struct kernfs_node *parent ,
                                                          char const   *name , umode_t mode ,
                                                          loff_t size , struct kernfs_ops  const  *ops ,
                                                          void *priv , void const   *ns )  __attribute__((__no_instrument_function__)) ;
#line 423 "../../../analyzer/../bench/linux-headers/include/linux/kernfs.h"
__inline static struct kernfs_node *kernfs_create_file_ns(struct kernfs_node *parent ,
                                                          char const   *name , umode_t mode ,
                                                          loff_t size , struct kernfs_ops  const  *ops ,
                                                          void *priv , void const   *ns ) 
{ 
  struct lock_class_key *key ;
  struct kernfs_node *tmp ;

  {
  {
#line 428
  key = (struct lock_class_key *)((void *)0);
#line 433
  tmp = __kernfs_create_file(parent, name, mode, size, ops, priv, ns, (bool )0, key);
  }
#line 433
  return (tmp);
}
}
#line 437
__inline static struct kernfs_node *kernfs_create_file(struct kernfs_node *parent ,
                                                       char const   *name , umode_t mode ,
                                                       loff_t size , struct kernfs_ops  const  *ops ,
                                                       void *priv )  __attribute__((__no_instrument_function__)) ;
#line 437 "../../../analyzer/../bench/linux-headers/include/linux/kernfs.h"
__inline static struct kernfs_node *kernfs_create_file(struct kernfs_node *parent ,
                                                       char const   *name , umode_t mode ,
                                                       loff_t size , struct kernfs_ops  const  *ops ,
                                                       void *priv ) 
{ 
  struct kernfs_node *tmp ;

  {
  {
#line 441
  tmp = kernfs_create_file_ns(parent, name, mode, size, ops, priv, (void const   *)((void *)0));
  }
#line 441
  return (tmp);
}
}
#line 444
__inline static int kernfs_remove_by_name(struct kernfs_node *parent , char const   *name )  __attribute__((__no_instrument_function__)) ;
#line 444 "../../../analyzer/../bench/linux-headers/include/linux/kernfs.h"
__inline static int kernfs_remove_by_name(struct kernfs_node *parent , char const   *name ) 
{ 
  int tmp ;

  {
  {
#line 447
  tmp = kernfs_remove_by_name_ns(parent, name, (void const   *)((void *)0));
  }
#line 447
  return (tmp);
}
}
#line 450
__inline static int kernfs_rename(struct kernfs_node *kn , struct kernfs_node *new_parent ,
                                  char const   *new_name )  __attribute__((__no_instrument_function__)) ;
#line 450 "../../../analyzer/../bench/linux-headers/include/linux/kernfs.h"
__inline static int kernfs_rename(struct kernfs_node *kn , struct kernfs_node *new_parent ,
                                  char const   *new_name ) 
{ 
  int tmp ;

  {
  {
#line 454
  tmp = kernfs_rename_ns(kn, new_parent, new_name, (void const   *)((void *)0));
  }
#line 454
  return (tmp);
}
}
#line 457
__inline static struct dentry *kernfs_mount(struct file_system_type *fs_type , int flags ,
                                            struct kernfs_root *root , unsigned long magic ,
                                            bool *new_sb_created )  __attribute__((__no_instrument_function__)) ;
#line 457 "../../../analyzer/../bench/linux-headers/include/linux/kernfs.h"
__inline static struct dentry *kernfs_mount(struct file_system_type *fs_type , int flags ,
                                            struct kernfs_root *root , unsigned long magic ,
                                            bool *new_sb_created ) 
{ 
  struct dentry *tmp ;

  {
  {
#line 462
  tmp = kernfs_mount_ns(fs_type, flags, root, magic, new_sb_created, (void const   *)((void *)0));
  }
#line 462
  return (tmp);
}
}
#line 49 "../../../analyzer/../bench/linux-headers/include/linux/kobject_ns.h"
extern int kobj_ns_type_register(struct kobj_ns_type_operations  const  *ops ) ;
#line 50
extern int kobj_ns_type_registered(enum kobj_ns_type type ) ;
#line 51
extern struct kobj_ns_type_operations  const  *kobj_child_ns_ops(struct kobject *parent ) ;
#line 52
extern struct kobj_ns_type_operations  const  *kobj_ns_ops(struct kobject *kobj ) ;
#line 54
extern bool kobj_ns_current_may_mount(enum kobj_ns_type type ) ;
#line 55
extern void *kobj_ns_grab_current(enum kobj_ns_type type ) ;
#line 56
extern void const   *kobj_ns_netlink(enum kobj_ns_type type , struct sock *sk ) ;
#line 57
extern void const   *kobj_ns_initial(enum kobj_ns_type type ) ;
#line 58
extern void kobj_ns_drop(enum kobj_ns_type type , void *ns ) ;
#line 182 "../../../analyzer/../bench/linux-headers/include/linux/sysfs.h"
extern int ( __attribute__((__warn_unused_result__)) sysfs_create_dir_ns)(struct kobject *kobj ,
                                                                          void const   *ns ) ;
#line 183
extern void sysfs_remove_dir(struct kobject *kobj ) ;
#line 184
extern int ( __attribute__((__warn_unused_result__)) sysfs_rename_dir_ns)(struct kobject *kobj ,
                                                                          char const   *new_name ,
                                                                          void const   *new_ns ) ;
#line 186
extern int ( __attribute__((__warn_unused_result__)) sysfs_move_dir_ns)(struct kobject *kobj ,
                                                                        struct kobject *new_parent_kobj ,
                                                                        void const   *new_ns ) ;
#line 190
extern int ( __attribute__((__warn_unused_result__)) sysfs_create_file_ns)(struct kobject *kobj ,
                                                                           struct attribute  const  *attr ,
                                                                           void const   *ns ) ;
#line 193
extern int ( __attribute__((__warn_unused_result__)) sysfs_create_files)(struct kobject *kobj ,
                                                                         struct attribute  const  **attr ) ;
#line 195
extern int ( __attribute__((__warn_unused_result__)) sysfs_chmod_file)(struct kobject *kobj ,
                                                                       struct attribute  const  *attr ,
                                                                       umode_t mode ) ;
#line 197
extern void sysfs_remove_file_ns(struct kobject *kobj , struct attribute  const  *attr ,
                                 void const   *ns ) ;
#line 199
extern bool sysfs_remove_file_self(struct kobject *kobj , struct attribute  const  *attr ) ;
#line 200
extern void sysfs_remove_files(struct kobject *kobj , struct attribute  const  **attr ) ;
#line 202
extern int ( __attribute__((__warn_unused_result__)) sysfs_create_bin_file)(struct kobject *kobj ,
                                                                            struct bin_attribute  const  *attr ) ;
#line 204
extern void sysfs_remove_bin_file(struct kobject *kobj , struct bin_attribute  const  *attr ) ;
#line 207
extern int ( __attribute__((__warn_unused_result__)) sysfs_create_link)(struct kobject *kobj ,
                                                                        struct kobject *target ,
                                                                        char const   *name ) ;
#line 209
extern int ( __attribute__((__warn_unused_result__)) sysfs_create_link_nowarn)(struct kobject *kobj ,
                                                                               struct kobject *target ,
                                                                               char const   *name ) ;
#line 212
extern void sysfs_remove_link(struct kobject *kobj , char const   *name ) ;
#line 214
extern int sysfs_rename_link_ns(struct kobject *kobj , struct kobject *target , char const   *old_name ,
                                char const   *new_name , void const   *new_ns ) ;
#line 218
extern void sysfs_delete_link(struct kobject *dir , struct kobject *targ , char const   *name ) ;
#line 221
extern int ( __attribute__((__warn_unused_result__)) sysfs_create_group)(struct kobject *kobj ,
                                                                         struct attribute_group  const  *grp ) ;
#line 223
extern int ( __attribute__((__warn_unused_result__)) sysfs_create_groups)(struct kobject *kobj ,
                                                                          struct attribute_group  const  **groups ) ;
#line 225
extern int sysfs_update_group(struct kobject *kobj , struct attribute_group  const  *grp ) ;
#line 227
extern void sysfs_remove_group(struct kobject *kobj , struct attribute_group  const  *grp ) ;
#line 229
extern void sysfs_remove_groups(struct kobject *kobj , struct attribute_group  const  **groups ) ;
#line 231
extern int sysfs_add_file_to_group(struct kobject *kobj , struct attribute  const  *attr ,
                                   char const   *group ) ;
#line 233
extern void sysfs_remove_file_from_group(struct kobject *kobj , struct attribute  const  *attr ,
                                         char const   *group ) ;
#line 235
extern int sysfs_merge_group(struct kobject *kobj , struct attribute_group  const  *grp ) ;
#line 237
extern void sysfs_unmerge_group(struct kobject *kobj , struct attribute_group  const  *grp ) ;
#line 239
extern int sysfs_add_link_to_group(struct kobject *kobj , char const   *group_name ,
                                   struct kobject *target , char const   *link_name ) ;
#line 241
extern void sysfs_remove_link_from_group(struct kobject *kobj , char const   *group_name ,
                                         char const   *link_name ) ;
#line 244
extern void sysfs_notify(struct kobject *kobj , char const   *dir , char const   *attr ) ;
#line 246
extern int ( __attribute__((__warn_unused_result__)) sysfs_init)(void) ;
#line 248
__inline static void sysfs_enable_ns(struct kernfs_node *kn )  __attribute__((__no_instrument_function__)) ;
#line 248 "../../../analyzer/../bench/linux-headers/include/linux/sysfs.h"
__inline static void sysfs_enable_ns(struct kernfs_node *kn ) 
{ 


  {
  {
#line 250
  kernfs_enable_ns(kn);
  }
#line 250
  return;
}
}
#line 431
__inline static int ( __attribute__((__warn_unused_result__)) sysfs_create_file)(struct kobject *kobj ,
                                                                                 struct attribute  const  *attr )  __attribute__((__no_instrument_function__)) ;
#line 431 "../../../analyzer/../bench/linux-headers/include/linux/sysfs.h"
__inline static int ( __attribute__((__warn_unused_result__)) sysfs_create_file)(struct kobject *kobj ,
                                                                                 struct attribute  const  *attr ) 
{ 
  int tmp ;

  {
  {
#line 434
  tmp = sysfs_create_file_ns(kobj, attr, (void const   *)((void *)0));
  }
#line 434
  return (tmp);
}
}
#line 437
__inline static void sysfs_remove_file(struct kobject *kobj , struct attribute  const  *attr )  __attribute__((__no_instrument_function__)) ;
#line 437 "../../../analyzer/../bench/linux-headers/include/linux/sysfs.h"
__inline static void sysfs_remove_file(struct kobject *kobj , struct attribute  const  *attr ) 
{ 


  {
  {
#line 440
  sysfs_remove_file_ns(kobj, attr, (void const   *)((void *)0));
  }
#line 441
  return;
}
}
#line 443
__inline static int sysfs_rename_link(struct kobject *kobj , struct kobject *target ,
                                      char const   *old_name , char const   *new_name )  __attribute__((__no_instrument_function__)) ;
#line 443 "../../../analyzer/../bench/linux-headers/include/linux/sysfs.h"
__inline static int sysfs_rename_link(struct kobject *kobj , struct kobject *target ,
                                      char const   *old_name , char const   *new_name ) 
{ 
  int tmp ;

  {
  {
#line 446
  tmp = sysfs_rename_link_ns(kobj, target, old_name, new_name, (void const   *)((void *)0));
  }
#line 446
  return (tmp);
}
}
#line 449
__inline static void sysfs_notify_dirent(struct kernfs_node *kn )  __attribute__((__no_instrument_function__)) ;
#line 449 "../../../analyzer/../bench/linux-headers/include/linux/sysfs.h"
__inline static void sysfs_notify_dirent(struct kernfs_node *kn ) 
{ 


  {
  {
#line 451
  kernfs_notify(kn);
  }
#line 452
  return;
}
}
#line 454
__inline static struct kernfs_node *sysfs_get_dirent(struct kernfs_node *parent ,
                                                     unsigned char const   *name )  __attribute__((__no_instrument_function__)) ;
#line 454 "../../../analyzer/../bench/linux-headers/include/linux/sysfs.h"
__inline static struct kernfs_node *sysfs_get_dirent(struct kernfs_node *parent ,
                                                     unsigned char const   *name ) 
{ 
  struct kernfs_node *tmp ;

  {
  {
#line 457
  tmp = kernfs_find_and_get(parent, (char const   *)name);
  }
#line 457
  return (tmp);
}
}
#line 460
__inline static struct kernfs_node *sysfs_get(struct kernfs_node *kn )  __attribute__((__no_instrument_function__)) ;
#line 460 "../../../analyzer/../bench/linux-headers/include/linux/sysfs.h"
__inline static struct kernfs_node *sysfs_get(struct kernfs_node *kn ) 
{ 


  {
  {
#line 462
  kernfs_get(kn);
  }
#line 463
  return (kn);
}
}
#line 466
__inline static void sysfs_put(struct kernfs_node *kn )  __attribute__((__no_instrument_function__)) ;
#line 466 "../../../analyzer/../bench/linux-headers/include/linux/sysfs.h"
__inline static void sysfs_put(struct kernfs_node *kn ) 
{ 


  {
  {
#line 468
  kernfs_put(kn);
  }
#line 469
  return;
}
}
#line 32 "../../../analyzer/../bench/linux-headers/include/linux/kref.h"
__inline static void kref_init(struct kref *kref )  __attribute__((__no_instrument_function__)) ;
#line 32 "../../../analyzer/../bench/linux-headers/include/linux/kref.h"
__inline static void kref_init(struct kref *kref ) 
{ 


  {
  {
#line 34
  atomic_set(& kref->refcount, 1);
  }
#line 35
  return;
}
}
#line 47 "../../../analyzer/../bench/linux-headers/include/linux/kref.h"
static bool __warned___1  __attribute__((__section__(".data.unlikely")))  ;
#line 41
__inline static void kref_get(struct kref *kref )  __attribute__((__no_instrument_function__)) ;
#line 41 "../../../analyzer/../bench/linux-headers/include/linux/kref.h"
__inline static void kref_get(struct kref *kref ) 
{ 
  int __ret_warn_once ;
  int tmp ;
  int tmp___0 ;
  int __ret_warn_on ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  {
#line 47
  tmp = atomic_add_return(1, & kref->refcount);
  }
#line 47
  if (tmp < 2) {
    {
#line 47
    tmp___0 = 1;
    }
  } else {
    {
#line 47
    tmp___0 = 0;
    }
  }
  {
#line 47
  __ret_warn_once = tmp___0;
#line 47
  tmp___3 = __builtin_expect((long )(! (! __ret_warn_once)), 0L);
  }
#line 47
  if (tmp___3) {
    {
#line 47
    __ret_warn_on = ! (! (! __warned___1));
#line 47
    tmp___1 = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
    }
#line 47
    if (tmp___1) {
      {
#line 47
      warn_slowpath_null("../../../analyzer/../bench/linux-headers/include/linux/kref.h",
                         (int const   )47);
      }
    }
    {
#line 47
    tmp___2 = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
    }
#line 47
    if (tmp___2) {
      {
#line 47
      __warned___1 = (bool )1;
      }
    }
  }
  {
#line 47
  __builtin_expect((long )(! (! __ret_warn_once)), 0L);
  }
#line 48
  return;
}
}
#line 68
__inline static int kref_sub(struct kref *kref , unsigned int count , void (*release)(struct kref *kref ) )  __attribute__((__no_instrument_function__)) ;
#line 68 "../../../analyzer/../bench/linux-headers/include/linux/kref.h"
__inline static int kref_sub(struct kref *kref , unsigned int count , void (*release)(struct kref *kref ) ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  int tmp___0 ;

  {
  {
#line 71
  __ret_warn_on = ! (! ((unsigned long )release == (unsigned long )((void *)0)));
#line 71
  tmp = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
  }
#line 71
  if (tmp) {
    {
#line 71
    warn_slowpath_null("../../../analyzer/../bench/linux-headers/include/linux/kref.h",
                       (int const   )71);
    }
  }
  {
#line 71
  __builtin_expect((long )(! (! __ret_warn_on)), 0L);
#line 73
  tmp___0 = atomic_sub_and_test((int )count, & kref->refcount);
  }
#line 73
  if (tmp___0) {
    {
#line 74
    (*release)(kref);
    }
#line 75
    return (1);
  }
#line 77
  return (0);
}
}
#line 97
__inline static int kref_put(struct kref *kref , void (*release)(struct kref *kref ) )  __attribute__((__no_instrument_function__)) ;
#line 97 "../../../analyzer/../bench/linux-headers/include/linux/kref.h"
__inline static int kref_put(struct kref *kref , void (*release)(struct kref *kref ) ) 
{ 
  int tmp ;

  {
  {
#line 99
  tmp = kref_sub(kref, 1U, release);
  }
#line 99
  return (tmp);
}
}
#line 115
__inline static int kref_put_spinlock_irqsave(struct kref *kref , void (*release)(struct kref *kref ) ,
                                              spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 115 "../../../analyzer/../bench/linux-headers/include/linux/kref.h"
__inline static int kref_put_spinlock_irqsave(struct kref *kref , void (*release)(struct kref *kref ) ,
                                              spinlock_t *lock ) 
{ 
  unsigned long flags ;
  int __ret_warn_on ;
  long tmp ;
  int tmp___0 ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  raw_spinlock_t *tmp___1 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;
  unsigned long __dummy___1 ;
  unsigned long __dummy2___1 ;
  unsigned long __dummy___2 ;
  unsigned long __dummy2___2 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 121
  __ret_warn_on = ! (! ((unsigned long )release == (unsigned long )((void *)0)));
#line 121
  tmp = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
  }
#line 121
  if (tmp) {
    {
#line 121
    warn_slowpath_null("../../../analyzer/../bench/linux-headers/include/linux/kref.h",
                       (int const   )121);
    }
  }
  {
#line 121
  __builtin_expect((long )(! (! __ret_warn_on)), 0L);
#line 122
  tmp___0 = atomic_add_unless(& kref->refcount, -1, 1);
  }
#line 122
  if (tmp___0) {
#line 123
    return (0);
  }
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 124
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 124
      tmp___1 = spinlock_check(lock);
#line 124
      flags = _raw_spin_lock_irqsave(tmp___1);
      }
#line 124
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 124
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 125
  tmp___3 = atomic_dec_and_test(& kref->refcount);
  }
#line 125
  if (tmp___3) {
    {
#line 126
    (*release)(kref);
    }
    {
#line 127
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 127
      tmp___2 = arch_irqs_disabled_flags(flags);
      }
#line 127
      if (tmp___2) {
        {
#line 127
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 127
          arch_local_irq_restore(flags);
          }
#line 127
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 127
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 127
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else {
        {
#line 127
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 127
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 127
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 127
          arch_local_irq_restore(flags);
          }
#line 127
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
#line 127
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 128
    return (1);
  }
  {
#line 130
  spin_unlock_irqrestore(lock, flags);
  }
#line 131
  return (0);
}
}
#line 134
__inline static int kref_put_mutex(struct kref *kref , void (*release)(struct kref *kref ) ,
                                   struct mutex *lock )  __attribute__((__no_instrument_function__)) ;
#line 134 "../../../analyzer/../bench/linux-headers/include/linux/kref.h"
__inline static int kref_put_mutex(struct kref *kref , void (*release)(struct kref *kref ) ,
                                   struct mutex *lock ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;

  {
  {
#line 138
  __ret_warn_on = ! (! ((unsigned long )release == (unsigned long )((void *)0)));
#line 138
  tmp = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
  }
#line 138
  if (tmp) {
    {
#line 138
    warn_slowpath_null("../../../analyzer/../bench/linux-headers/include/linux/kref.h",
                       (int const   )138);
    }
  }
  {
#line 138
  __builtin_expect((long )(! (! __ret_warn_on)), 0L);
#line 139
  tmp___3 = atomic_add_unless(& kref->refcount, -1, 1);
  }
#line 139
  if (tmp___3) {
    {
#line 139
    tmp___4 = 0;
    }
  } else {
    {
#line 139
    tmp___4 = 1;
    }
  }
  {
#line 139
  tmp___5 = __builtin_expect((long )tmp___4, 0L);
  }
#line 139
  if (tmp___5) {
    {
#line 140
    mutex_lock(lock);
#line 141
    tmp___0 = atomic_dec_and_test(& kref->refcount);
    }
#line 141
    if (tmp___0) {
      {
#line 141
      tmp___1 = 0;
      }
    } else {
      {
#line 141
      tmp___1 = 1;
      }
    }
    {
#line 141
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
#line 141
    if (tmp___2) {
      {
#line 142
      mutex_unlock(lock);
      }
#line 143
      return (0);
    }
    {
#line 145
    (*release)(kref);
    }
#line 146
    return (1);
  }
#line 148
  return (0);
}
}
#line 167
__inline static int ( __attribute__((__warn_unused_result__)) kref_get_unless_zero)(struct kref *kref )  __attribute__((__no_instrument_function__)) ;
#line 167 "../../../analyzer/../bench/linux-headers/include/linux/kref.h"
__inline static int ( __attribute__((__warn_unused_result__)) kref_get_unless_zero)(struct kref *kref ) 
{ 
  int tmp ;

  {
  {
#line 169
  tmp = atomic_add_unless(& kref->refcount, 1, 0);
  }
#line 169
  return (tmp);
}
}
#line 37 "../../../analyzer/../bench/linux-headers/include/linux/kobject.h"
extern char uevent_helper[] ;
#line 41
extern u64 uevent_seqnum ;
#line 81
extern int ( /* format attribute */  kobject_set_name)(struct kobject *kobj , char const   *name 
                                                       , ...) ;
#line 83
extern int kobject_set_name_vargs(struct kobject *kobj , char const   *fmt , va_list vargs ) ;
#line 86
__inline static char const   *kobject_name(struct kobject  const  *kobj )  __attribute__((__no_instrument_function__)) ;
#line 86 "../../../analyzer/../bench/linux-headers/include/linux/kobject.h"
__inline static char const   *kobject_name(struct kobject  const  *kobj ) 
{ 


  {
#line 88
  return ((char const   *)kobj->name);
}
}
#line 91
extern void kobject_init(struct kobject *kobj , struct kobj_type *ktype ) ;
#line 92
extern int ( /* format attribute */ __attribute__((__warn_unused_result__)) kobject_add)(struct kobject *kobj ,
                                                                                         struct kobject *parent ,
                                                                                         char const   *fmt 
                                                                                         , ...) ;
#line 95
extern int ( /* format attribute */ __attribute__((__warn_unused_result__)) kobject_init_and_add)(struct kobject *kobj ,
                                                                                                  struct kobj_type *ktype ,
                                                                                                  struct kobject *parent ,
                                                                                                  char const   *fmt 
                                                                                                  , ...) ;
#line 100
extern void kobject_del(struct kobject *kobj ) ;
#line 102
extern struct kobject *( __attribute__((__warn_unused_result__)) kobject_create)(void) ;
#line 103
extern struct kobject *( __attribute__((__warn_unused_result__)) kobject_create_and_add)(char const   *name ,
                                                                                         struct kobject *parent ) ;
#line 106
extern int ( __attribute__((__warn_unused_result__)) kobject_rename)(struct kobject * ,
                                                                     char const   *new_name ) ;
#line 107
extern int ( __attribute__((__warn_unused_result__)) kobject_move)(struct kobject * ,
                                                                   struct kobject * ) ;
#line 109
extern struct kobject *kobject_get(struct kobject *kobj ) ;
#line 110
extern void kobject_put(struct kobject *kobj ) ;
#line 112
extern void const   *kobject_namespace(struct kobject *kobj ) ;
#line 113
extern char *kobject_get_path(struct kobject *kobj , gfp_t flag ) ;
#line 146
extern struct sysfs_ops  const  kobj_sysfs_ops ;
#line 174
extern void kset_init(struct kset *kset ) ;
#line 175
extern int ( __attribute__((__warn_unused_result__)) kset_register)(struct kset *kset ) ;
#line 176
extern void kset_unregister(struct kset *kset ) ;
#line 177
extern struct kset *( __attribute__((__warn_unused_result__)) kset_create_and_add)(char const   *name ,
                                                                                   struct kset_uevent_ops  const  *u ,
                                                                                   struct kobject *parent_kobj ) ;
#line 181
__inline static struct kset *to_kset(struct kobject *kobj )  __attribute__((__no_instrument_function__)) ;
#line 181 "../../../analyzer/../bench/linux-headers/include/linux/kobject.h"
__inline static struct kset *to_kset(struct kobject *kobj ) 
{ 
  struct kobject  const  *__mptr ;
  struct kset *tmp ;

  {
#line 183
  if (kobj) {
    {
#line 183
    __mptr = (struct kobject  const  *)kobj;
#line 183
    tmp = (struct kset *)((char *)__mptr - (unsigned long )(& ((struct kset *)0)->kobj));
    }
  } else {
    {
#line 183
    tmp = (struct kset *)((void *)0);
    }
  }
#line 183
  return (tmp);
}
}
#line 186
__inline static struct kset *kset_get(struct kset *k )  __attribute__((__no_instrument_function__)) ;
#line 186 "../../../analyzer/../bench/linux-headers/include/linux/kobject.h"
__inline static struct kset *kset_get(struct kset *k ) 
{ 
  struct kobject *tmp ;
  struct kset *tmp___0 ;
  struct kset *tmp___1 ;

  {
#line 188
  if (k) {
    {
#line 188
    tmp = kobject_get(& k->kobj);
#line 188
    tmp___0 = to_kset(tmp);
#line 188
    tmp___1 = tmp___0;
    }
  } else {
    {
#line 188
    tmp___1 = (struct kset *)((void *)0);
    }
  }
#line 188
  return (tmp___1);
}
}
#line 191
__inline static void kset_put(struct kset *k )  __attribute__((__no_instrument_function__)) ;
#line 191 "../../../analyzer/../bench/linux-headers/include/linux/kobject.h"
__inline static void kset_put(struct kset *k ) 
{ 


  {
  {
#line 193
  kobject_put(& k->kobj);
  }
#line 194
  return;
}
}
#line 196
__inline static struct kobj_type *get_ktype(struct kobject *kobj )  __attribute__((__no_instrument_function__)) ;
#line 196 "../../../analyzer/../bench/linux-headers/include/linux/kobject.h"
__inline static struct kobj_type *get_ktype(struct kobject *kobj ) 
{ 


  {
#line 198
  return (kobj->ktype);
}
}
#line 201
extern struct kobject *kset_find_obj(struct kset * , char const   * ) ;
#line 204
extern struct kobject *kernel_kobj ;
#line 206
extern struct kobject *mm_kobj ;
#line 208
extern struct kobject *hypervisor_kobj ;
#line 210
extern struct kobject *power_kobj ;
#line 212
extern struct kobject *firmware_kobj ;
#line 214
extern int kobject_uevent(struct kobject *kobj , enum kobject_action action ) ;
#line 215
extern int kobject_uevent_env(struct kobject *kobj , enum kobject_action action ,
                              char **envp ) ;
#line 218
extern int ( /* format attribute */  add_uevent_var)(struct kobj_uevent_env *env ,
                                                     char const   *format  , ...) ;
#line 221
extern int kobject_action_type(char const   *buf , size_t count , enum kobject_action *type ) ;
#line 205 "../../../analyzer/../bench/linux-headers/include/linux/moduleparam.h"
__inline static int __check_old_set_param(int (*oldset)(char const   * , struct kernel_param * ) )  __attribute__((__no_instrument_function__)) ;
#line 205 "../../../analyzer/../bench/linux-headers/include/linux/moduleparam.h"
__inline static int __check_old_set_param(int (*oldset)(char const   * , struct kernel_param * ) ) 
{ 


  {
#line 208
  return (0);
}
}
#line 256
extern void __kernel_param_lock(void) ;
#line 257
extern void __kernel_param_unlock(void) ;
#line 311
extern bool parameq(char const   *name1 , char const   *name2 ) ;
#line 321
extern bool parameqn(char const   *name1 , char const   *name2 , size_t n ) ;
#line 324
extern char *parse_args(char const   *name , char *args , struct kernel_param  const  *params ,
                        unsigned int num , s16 level_min , s16 level_max , int (*unknown)(char *param ,
                                                                                          char *val ,
                                                                                          char const   *doing ) ) ;
#line 335
extern void destroy_params(struct kernel_param  const  *params , unsigned int num ) ;
#line 349
extern struct kernel_param_ops param_ops_byte ;
#line 350
extern int param_set_byte(char const   *val , struct kernel_param  const  *kp ) ;
#line 351
extern int param_get_byte(char *buffer , struct kernel_param  const  *kp ) ;
#line 354
extern struct kernel_param_ops param_ops_short ;
#line 355
extern int param_set_short(char const   *val , struct kernel_param  const  *kp ) ;
#line 356
extern int param_get_short(char *buffer , struct kernel_param  const  *kp ) ;
#line 359
extern struct kernel_param_ops param_ops_ushort ;
#line 360
extern int param_set_ushort(char const   *val , struct kernel_param  const  *kp ) ;
#line 361
extern int param_get_ushort(char *buffer , struct kernel_param  const  *kp ) ;
#line 364
extern struct kernel_param_ops param_ops_int ;
#line 365
extern int param_set_int(char const   *val , struct kernel_param  const  *kp ) ;
#line 366
extern int param_get_int(char *buffer , struct kernel_param  const  *kp ) ;
#line 369
extern struct kernel_param_ops param_ops_uint ;
#line 370
extern int param_set_uint(char const   *val , struct kernel_param  const  *kp ) ;
#line 371
extern int param_get_uint(char *buffer , struct kernel_param  const  *kp ) ;
#line 374
extern struct kernel_param_ops param_ops_long ;
#line 375
extern int param_set_long(char const   *val , struct kernel_param  const  *kp ) ;
#line 376
extern int param_get_long(char *buffer , struct kernel_param  const  *kp ) ;
#line 379
extern struct kernel_param_ops param_ops_ulong ;
#line 380
extern int param_set_ulong(char const   *val , struct kernel_param  const  *kp ) ;
#line 381
extern int param_get_ulong(char *buffer , struct kernel_param  const  *kp ) ;
#line 384
extern struct kernel_param_ops param_ops_ullong ;
#line 385
extern int param_set_ullong(char const   *val , struct kernel_param  const  *kp ) ;
#line 386
extern int param_get_ullong(char *buffer , struct kernel_param  const  *kp ) ;
#line 389
extern struct kernel_param_ops param_ops_charp ;
#line 390
extern int param_set_charp(char const   *val , struct kernel_param  const  *kp ) ;
#line 391
extern int param_get_charp(char *buffer , struct kernel_param  const  *kp ) ;
#line 395
extern struct kernel_param_ops param_ops_bool ;
#line 396
extern int param_set_bool(char const   *val , struct kernel_param  const  *kp ) ;
#line 397
extern int param_get_bool(char *buffer , struct kernel_param  const  *kp ) ;
#line 400
extern struct kernel_param_ops param_ops_invbool ;
#line 401
extern int param_set_invbool(char const   *val , struct kernel_param  const  *kp ) ;
#line 402
extern int param_get_invbool(char *buffer , struct kernel_param  const  *kp ) ;
#line 406
extern struct kernel_param_ops param_ops_bint ;
#line 407
extern int param_set_bint(char const   *val , struct kernel_param  const  *kp ) ;
#line 450
extern struct kernel_param_ops param_array_ops ;
#line 452
extern struct kernel_param_ops param_ops_string ;
#line 453
extern int param_set_copystring(char const   *val , struct kernel_param  const  * ) ;
#line 454
extern int param_get_string(char *buffer , struct kernel_param  const  *kp ) ;
#line 461
extern int module_param_sysfs_setup(struct module *mod , struct kernel_param  const  *kparam ,
                                    unsigned int num_params ) ;
#line 465
extern void module_param_sysfs_remove(struct module *mod ) ;
#line 64 "../../../analyzer/../bench/linux-headers/include/linux/module.h"
extern ssize_t __modver_version_show(struct module_attribute * , struct module_kobject * ,
                                     char * ) ;
#line 67
extern struct module_attribute module_uevent ;
#line 70
int init_module(void) ;
#line 71
void cleanup_module(void) ;
#line 76
extern struct exception_table_entry  const  *search_extable(struct exception_table_entry  const  *first ,
                                                            struct exception_table_entry  const  *last ,
                                                            unsigned long value ) ;
#line 80
extern void sort_extable(struct exception_table_entry *start , struct exception_table_entry *finish ) ;
#line 82
extern void sort_main_extable(void) ;
#line 83
extern void trim_init_extable(struct module *m ) ;
#line 187
extern struct exception_table_entry  const  *search_exception_tables(unsigned long add ) ;
#line 193
extern int modules_disabled ;
#line 195
extern void *__symbol_get(char const   *symbol ) ;
#line 196
extern void *__symbol_get_gpl(char const   *symbol ) ;
#line 383
extern struct mutex module_mutex ;
#line 388
__inline static int module_is_live(struct module *mod )  __attribute__((__no_instrument_function__)) ;
#line 388 "../../../analyzer/../bench/linux-headers/include/linux/module.h"
__inline static int module_is_live(struct module *mod ) 
{ 


  {
#line 390
  return ((unsigned int )mod->state != 2U);
}
}
#line 393
extern struct module *__module_text_address(unsigned long addr ) ;
#line 394
extern struct module *__module_address(unsigned long addr ) ;
#line 395
extern bool is_module_address(unsigned long addr ) ;
#line 396
extern bool is_module_percpu_address(unsigned long addr ) ;
#line 397
extern bool is_module_text_address(unsigned long addr ) ;
#line 399
__inline static bool within_module_core(unsigned long addr , struct module  const  *mod )  __attribute__((__no_instrument_function__)) ;
#line 399 "../../../analyzer/../bench/linux-headers/include/linux/module.h"
__inline static bool within_module_core(unsigned long addr , struct module  const  *mod ) 
{ 
  int tmp ;

  {
#line 402
  if ((unsigned long )mod->module_core <= addr) {
#line 402
    if (addr < (unsigned long )mod->module_core + (unsigned long )mod->core_size) {
      {
#line 402
      tmp = 1;
      }
    } else {
      {
#line 402
      tmp = 0;
      }
    }
  } else {
    {
#line 402
    tmp = 0;
    }
  }
#line 402
  return ((bool )tmp);
}
}
#line 406
__inline static bool within_module_init(unsigned long addr , struct module  const  *mod )  __attribute__((__no_instrument_function__)) ;
#line 406 "../../../analyzer/../bench/linux-headers/include/linux/module.h"
__inline static bool within_module_init(unsigned long addr , struct module  const  *mod ) 
{ 
  int tmp ;

  {
#line 409
  if ((unsigned long )mod->module_init <= addr) {
#line 409
    if (addr < (unsigned long )mod->module_init + (unsigned long )mod->init_size) {
      {
#line 409
      tmp = 1;
      }
    } else {
      {
#line 409
      tmp = 0;
      }
    }
  } else {
    {
#line 409
    tmp = 0;
    }
  }
#line 409
  return ((bool )tmp);
}
}
#line 413
__inline static bool within_module(unsigned long addr , struct module  const  *mod )  __attribute__((__no_instrument_function__)) ;
#line 413 "../../../analyzer/../bench/linux-headers/include/linux/module.h"
__inline static bool within_module(unsigned long addr , struct module  const  *mod ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
  {
#line 415
  tmp = within_module_init(addr, mod);
  }
#line 415
  if (tmp) {
    {
#line 415
    tmp___1 = 1;
    }
  } else {
    {
#line 415
    tmp___0 = within_module_core(addr, mod);
    }
#line 415
    if (tmp___0) {
      {
#line 415
      tmp___1 = 1;
      }
    } else {
      {
#line 415
      tmp___1 = 0;
      }
    }
  }
#line 415
  return ((bool )tmp___1);
}
}
#line 419
extern struct module *find_module(char const   *name ) ;
#line 433
extern struct kernel_symbol  const  *find_symbol(char const   *name , struct module **owner ,
                                                 unsigned long const   **crc , bool gplok ,
                                                 bool warn ) ;
#line 440
extern bool each_symbol_section(bool (*fn)(struct symsearch  const  *arr , struct module *owner ,
                                           void *data ) , void *data ) ;
#line 446
extern int module_get_kallsym(unsigned int symnum , unsigned long *value , char *type ,
                              char *name , char *module_name , int *exported ) ;
#line 450
extern unsigned long module_kallsyms_lookup_name(char const   *name ) ;
#line 452
extern int module_kallsyms_on_each_symbol(int (*fn)(void * , char const   * , struct module * ,
                                                    unsigned long  ) , void *data ) ;
#line 456
extern  __attribute__((__noreturn__)) void __module_put_and_exit(struct module *mod ,
                                                                 long code ) ;
#line 461
extern unsigned long module_refcount(struct module *mod ) ;
#line 462
extern void __symbol_put(char const   *symbol ) ;
#line 464
extern void symbol_put_addr(void *addr ) ;
#line 468
extern void __module_get(struct module *module ) ;
#line 472
extern bool try_module_get(struct module *module ) ;
#line 474
extern void module_put(struct module *module ) ;
#line 491
extern int ref_module(struct module *a , struct module *b ) ;
#line 503
extern char const   *module_address_lookup(unsigned long addr , unsigned long *symbolsize ,
                                           unsigned long *offset , char **modname ,
                                           char *namebuf ) ;
#line 508
extern int lookup_module_symbol_name(unsigned long addr , char *symname ) ;
#line 509
extern int lookup_module_symbol_attrs(unsigned long addr , unsigned long *size , unsigned long *offset ,
                                      char *modname , char *name ) ;
#line 512
extern struct exception_table_entry  const  *search_module_extables(unsigned long addr ) ;
#line 514
extern int register_module_notifier(struct notifier_block *nb ) ;
#line 515
extern int unregister_module_notifier(struct notifier_block *nb ) ;
#line 517
extern void print_modules(void) ;
#line 632
extern struct kset *module_kset ;
#line 633
extern struct kobj_type module_ktype ;
#line 634
extern int module_sysfs_initialized ;
#line 647
__inline static void set_all_modules_text_rw(void)  __attribute__((__no_instrument_function__)) ;
#line 647 "../../../analyzer/../bench/linux-headers/include/linux/module.h"
__inline static void set_all_modules_text_rw(void) 
{ 


  {
#line 647
  return;
}
}
#line 648
__inline static void set_all_modules_text_ro(void)  __attribute__((__no_instrument_function__)) ;
#line 648 "../../../analyzer/../bench/linux-headers/include/linux/module.h"
__inline static void set_all_modules_text_ro(void) 
{ 


  {
#line 648
  return;
}
}
#line 652
extern void module_bug_finalize(Elf64_Ehdr const   * , Elf64_Shdr const   * , struct module * ) ;
#line 654
extern void module_bug_cleanup(struct module * ) ;
#line 7 "../../../analyzer/../bench/linux-headers/include/linux/irqnr.h"
extern int nr_irqs ;
#line 8
extern struct irq_desc *irq_to_desc(unsigned int irq ) ;
#line 9
extern unsigned int irq_get_next_irq(unsigned int offset ) ;
#line 9 "../../../analyzer/../bench/linux-headers/include/linux/ftrace_irq.h"
__inline static void ftrace_nmi_enter(void)  __attribute__((__no_instrument_function__)) ;
#line 9 "../../../analyzer/../bench/linux-headers/include/linux/ftrace_irq.h"
__inline static void ftrace_nmi_enter(void) 
{ 


  {
#line 9
  return;
}
}
#line 10
__inline static void ftrace_nmi_exit(void)  __attribute__((__no_instrument_function__)) ;
#line 10 "../../../analyzer/../bench/linux-headers/include/linux/ftrace_irq.h"
__inline static void ftrace_nmi_exit(void) 
{ 


  {
#line 10
  return;
}
}
#line 40 "../../../analyzer/../bench/linux-headers/include/linux/context_tracking_state.h"
__inline static bool context_tracking_in_user(void)  __attribute__((__no_instrument_function__)) ;
#line 40 "../../../analyzer/../bench/linux-headers/include/linux/context_tracking_state.h"
__inline static bool context_tracking_in_user(void) 
{ 


  {
#line 40
  return ((bool )0);
}
}
#line 41
__inline static bool context_tracking_active(void)  __attribute__((__no_instrument_function__)) ;
#line 41 "../../../analyzer/../bench/linux-headers/include/linux/context_tracking_state.h"
__inline static bool context_tracking_active(void) 
{ 


  {
#line 41
  return ((bool )0);
}
}
#line 32 "../../../analyzer/../bench/linux-headers/include/linux/vtime.h"
__inline static bool vtime_accounting_enabled(void)  __attribute__((__no_instrument_function__)) ;
#line 32 "../../../analyzer/../bench/linux-headers/include/linux/vtime.h"
__inline static bool vtime_accounting_enabled(void) 
{ 


  {
#line 32
  return ((bool )0);
}
}
#line 69
__inline static void vtime_task_switch(struct task_struct *prev )  __attribute__((__no_instrument_function__)) ;
#line 69 "../../../analyzer/../bench/linux-headers/include/linux/vtime.h"
__inline static void vtime_task_switch(struct task_struct *prev ) 
{ 


  {
#line 69
  return;
}
}
#line 70
__inline static void vtime_account_system(struct task_struct *tsk )  __attribute__((__no_instrument_function__)) ;
#line 70 "../../../analyzer/../bench/linux-headers/include/linux/vtime.h"
__inline static void vtime_account_system(struct task_struct *tsk ) 
{ 


  {
#line 70
  return;
}
}
#line 71
__inline static void vtime_account_user(struct task_struct *tsk )  __attribute__((__no_instrument_function__)) ;
#line 71 "../../../analyzer/../bench/linux-headers/include/linux/vtime.h"
__inline static void vtime_account_user(struct task_struct *tsk ) 
{ 


  {
#line 71
  return;
}
}
#line 72
__inline static void vtime_account_irq_enter(struct task_struct *tsk )  __attribute__((__no_instrument_function__)) ;
#line 72 "../../../analyzer/../bench/linux-headers/include/linux/vtime.h"
__inline static void vtime_account_irq_enter(struct task_struct *tsk ) 
{ 


  {
#line 72
  return;
}
}
#line 95
__inline static void vtime_account_irq_exit(struct task_struct *tsk )  __attribute__((__no_instrument_function__)) ;
#line 95 "../../../analyzer/../bench/linux-headers/include/linux/vtime.h"
__inline static void vtime_account_irq_exit(struct task_struct *tsk ) 
{ 


  {
  {
#line 98
  vtime_account_system(tsk);
  }
#line 99
  return;
}
}
#line 100
__inline static void vtime_user_enter(struct task_struct *tsk )  __attribute__((__no_instrument_function__)) ;
#line 100 "../../../analyzer/../bench/linux-headers/include/linux/vtime.h"
__inline static void vtime_user_enter(struct task_struct *tsk ) 
{ 


  {
#line 100
  return;
}
}
#line 101
__inline static void vtime_user_exit(struct task_struct *tsk )  __attribute__((__no_instrument_function__)) ;
#line 101 "../../../analyzer/../bench/linux-headers/include/linux/vtime.h"
__inline static void vtime_user_exit(struct task_struct *tsk ) 
{ 


  {
#line 101
  return;
}
}
#line 102
__inline static void vtime_guest_enter(struct task_struct *tsk )  __attribute__((__no_instrument_function__)) ;
#line 102 "../../../analyzer/../bench/linux-headers/include/linux/vtime.h"
__inline static void vtime_guest_enter(struct task_struct *tsk ) 
{ 


  {
#line 102
  return;
}
}
#line 103
__inline static void vtime_guest_exit(struct task_struct *tsk )  __attribute__((__no_instrument_function__)) ;
#line 103 "../../../analyzer/../bench/linux-headers/include/linux/vtime.h"
__inline static void vtime_guest_exit(struct task_struct *tsk ) 
{ 


  {
#line 103
  return;
}
}
#line 104
__inline static void vtime_init_idle(struct task_struct *tsk , int cpu )  __attribute__((__no_instrument_function__)) ;
#line 104 "../../../analyzer/../bench/linux-headers/include/linux/vtime.h"
__inline static void vtime_init_idle(struct task_struct *tsk , int cpu ) 
{ 


  {
#line 104
  return;
}
}
#line 110
__inline static void irqtime_account_irq(struct task_struct *tsk )  __attribute__((__no_instrument_function__)) ;
#line 110 "../../../analyzer/../bench/linux-headers/include/linux/vtime.h"
__inline static void irqtime_account_irq(struct task_struct *tsk ) 
{ 


  {
#line 110
  return;
}
}
#line 113
__inline static void account_irq_enter_time(struct task_struct *tsk )  __attribute__((__no_instrument_function__)) ;
#line 113 "../../../analyzer/../bench/linux-headers/include/linux/vtime.h"
__inline static void account_irq_enter_time(struct task_struct *tsk ) 
{ 


  {
  {
#line 115
  vtime_account_irq_enter(tsk);
#line 116
  irqtime_account_irq(tsk);
  }
#line 117
  return;
}
}
#line 119
__inline static void account_irq_exit_time(struct task_struct *tsk )  __attribute__((__no_instrument_function__)) ;
#line 119 "../../../analyzer/../bench/linux-headers/include/linux/vtime.h"
__inline static void account_irq_exit_time(struct task_struct *tsk ) 
{ 


  {
  {
#line 121
  vtime_account_irq_exit(tsk);
#line 122
  irqtime_account_irq(tsk);
  }
#line 123
  return;
}
}
#line 13 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/irq.h"
__inline static int irq_canonicalize(int irq )  __attribute__((__no_instrument_function__)) ;
#line 13 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/irq.h"
__inline static int irq_canonicalize(int irq ) 
{ 
  int tmp ;

  {
#line 15
  if (irq == 2) {
    {
#line 15
    tmp = 9;
    }
  } else {
    {
#line 15
    tmp = irq;
    }
  }
#line 15
  return (tmp);
}
}
#line 28
extern int check_irq_vectors_for_cpu_disable(void) ;
#line 29
extern void fixup_irqs(void) ;
#line 30
extern void irq_force_complete_move(int  ) ;
#line 33
extern void (*x86_platform_ipi_callback)(void) ;
#line 34
extern void native_init_IRQ(void) ;
#line 35
extern bool handle_irq(unsigned int irq , struct pt_regs *regs ) ;
#line 37
extern unsigned int __attribute__((__externally_visible__))  do_IRQ(struct pt_regs *regs ) ;
#line 40
extern unsigned long used_vectors[((256UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
#line 41
extern int vector_used_by_percpu_irq(unsigned int vector ) ;
#line 43
extern void init_ISA_irqs(void) ;
#line 46
extern void arch_trigger_all_cpu_backtrace(bool  ) ;
#line 14 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/irq_regs.h"
extern struct pt_regs *irq_regs  __attribute__((__section__(".data..percpu"))) ;
#line 16
__inline static struct pt_regs *get_irq_regs(void)  __attribute__((__no_instrument_function__)) ;
#line 16 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/irq_regs.h"
__inline static struct pt_regs *get_irq_regs(void) 
{ 
  struct pt_regs *pscr_ret__ ;
  void const   *__vpp_verify ;
  struct pt_regs *pfo_ret__ ;
  struct pt_regs *pfo_ret_____0 ;
  struct pt_regs *pfo_ret_____1 ;
  struct pt_regs *pfo_ret_____2 ;

  {
  {
#line 18
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 18
    __vpp_verify = (void const   *)((struct pt_regs **)((void *)0));
    }
#line 18
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 18
  if (sizeof(irq_regs) == 1UL) {
#line 18
    goto case_1;
  }
#line 18
  if (sizeof(irq_regs) == 2UL) {
#line 18
    goto case_2___0;
  }
#line 18
  if (sizeof(irq_regs) == 4UL) {
#line 18
    goto case_4___1;
  }
#line 18
  if (sizeof(irq_regs) == 8UL) {
#line 18
    goto case_8___2;
  }
#line 18
  goto switch_default___3;
  case_1: /* CIL Label */ 
  {
#line 18
  if (sizeof(irq_regs) == 1UL) {
#line 18
    goto case_1___0;
  }
#line 18
  if (sizeof(irq_regs) == 2UL) {
#line 18
    goto case_2;
  }
#line 18
  if (sizeof(irq_regs) == 4UL) {
#line 18
    goto case_4;
  }
#line 18
  if (sizeof(irq_regs) == 8UL) {
#line 18
    goto case_8;
  }
#line 18
  goto switch_default;
  case_1___0: /* CIL Label */ 
  {
#line 18
  __asm__  ("mov"
            "b "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=q" (pfo_ret__): "m" (irq_regs));
  }
#line 18
  goto switch_break___0;
  case_2: /* CIL Label */ 
  {
#line 18
  __asm__  ("mov"
            "w "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret__): "m" (irq_regs));
  }
#line 18
  goto switch_break___0;
  case_4: /* CIL Label */ 
  {
#line 18
  __asm__  ("mov"
            "l "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret__): "m" (irq_regs));
  }
#line 18
  goto switch_break___0;
  case_8: /* CIL Label */ 
  {
#line 18
  __asm__  ("mov"
            "q "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret__): "m" (irq_regs));
  }
#line 18
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 18
  __bad_percpu_size();
  }
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 18
  pscr_ret__ = pfo_ret__;
  }
#line 18
  goto switch_break;
  case_2___0: /* CIL Label */ 
  {
#line 18
  if (sizeof(irq_regs) == 1UL) {
#line 18
    goto case_1___1;
  }
#line 18
  if (sizeof(irq_regs) == 2UL) {
#line 18
    goto case_2___1;
  }
#line 18
  if (sizeof(irq_regs) == 4UL) {
#line 18
    goto case_4___0;
  }
#line 18
  if (sizeof(irq_regs) == 8UL) {
#line 18
    goto case_8___0;
  }
#line 18
  goto switch_default___0;
  case_1___1: /* CIL Label */ 
  {
#line 18
  __asm__  ("mov"
            "b "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=q" (pfo_ret_____0): "m" (irq_regs));
  }
#line 18
  goto switch_break___1;
  case_2___1: /* CIL Label */ 
  {
#line 18
  __asm__  ("mov"
            "w "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret_____0): "m" (irq_regs));
  }
#line 18
  goto switch_break___1;
  case_4___0: /* CIL Label */ 
  {
#line 18
  __asm__  ("mov"
            "l "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret_____0): "m" (irq_regs));
  }
#line 18
  goto switch_break___1;
  case_8___0: /* CIL Label */ 
  {
#line 18
  __asm__  ("mov"
            "q "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret_____0): "m" (irq_regs));
  }
#line 18
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
  {
#line 18
  __bad_percpu_size();
  }
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 18
  pscr_ret__ = pfo_ret_____0;
  }
#line 18
  goto switch_break;
  case_4___1: /* CIL Label */ 
  {
#line 18
  if (sizeof(irq_regs) == 1UL) {
#line 18
    goto case_1___2;
  }
#line 18
  if (sizeof(irq_regs) == 2UL) {
#line 18
    goto case_2___2;
  }
#line 18
  if (sizeof(irq_regs) == 4UL) {
#line 18
    goto case_4___2;
  }
#line 18
  if (sizeof(irq_regs) == 8UL) {
#line 18
    goto case_8___1;
  }
#line 18
  goto switch_default___1;
  case_1___2: /* CIL Label */ 
  {
#line 18
  __asm__  ("mov"
            "b "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=q" (pfo_ret_____1): "m" (irq_regs));
  }
#line 18
  goto switch_break___2;
  case_2___2: /* CIL Label */ 
  {
#line 18
  __asm__  ("mov"
            "w "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret_____1): "m" (irq_regs));
  }
#line 18
  goto switch_break___2;
  case_4___2: /* CIL Label */ 
  {
#line 18
  __asm__  ("mov"
            "l "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret_____1): "m" (irq_regs));
  }
#line 18
  goto switch_break___2;
  case_8___1: /* CIL Label */ 
  {
#line 18
  __asm__  ("mov"
            "q "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret_____1): "m" (irq_regs));
  }
#line 18
  goto switch_break___2;
  switch_default___1: /* CIL Label */ 
  {
#line 18
  __bad_percpu_size();
  }
  switch_break___2: /* CIL Label */ ;
  }
  {
#line 18
  pscr_ret__ = pfo_ret_____1;
  }
#line 18
  goto switch_break;
  case_8___2: /* CIL Label */ 
  {
#line 18
  if (sizeof(irq_regs) == 1UL) {
#line 18
    goto case_1___3;
  }
#line 18
  if (sizeof(irq_regs) == 2UL) {
#line 18
    goto case_2___3;
  }
#line 18
  if (sizeof(irq_regs) == 4UL) {
#line 18
    goto case_4___3;
  }
#line 18
  if (sizeof(irq_regs) == 8UL) {
#line 18
    goto case_8___3;
  }
#line 18
  goto switch_default___2;
  case_1___3: /* CIL Label */ 
  {
#line 18
  __asm__  ("mov"
            "b "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=q" (pfo_ret_____2): "m" (irq_regs));
  }
#line 18
  goto switch_break___3;
  case_2___3: /* CIL Label */ 
  {
#line 18
  __asm__  ("mov"
            "w "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret_____2): "m" (irq_regs));
  }
#line 18
  goto switch_break___3;
  case_4___3: /* CIL Label */ 
  {
#line 18
  __asm__  ("mov"
            "l "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret_____2): "m" (irq_regs));
  }
#line 18
  goto switch_break___3;
  case_8___3: /* CIL Label */ 
  {
#line 18
  __asm__  ("mov"
            "q "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret_____2): "m" (irq_regs));
  }
#line 18
  goto switch_break___3;
  switch_default___2: /* CIL Label */ 
  {
#line 18
  __bad_percpu_size();
  }
  switch_break___3: /* CIL Label */ ;
  }
  {
#line 18
  pscr_ret__ = pfo_ret_____2;
  }
#line 18
  goto switch_break;
  switch_default___3: /* CIL Label */ 
  {
#line 18
  __bad_size_call_parameter();
  }
#line 18
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 18
  return (pscr_ret__);
}
}
#line 21
__inline static struct pt_regs *set_irq_regs(struct pt_regs *new_regs )  __attribute__((__no_instrument_function__)) ;
#line 21 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/irq_regs.h"
__inline static struct pt_regs *set_irq_regs(struct pt_regs *new_regs ) 
{ 
  struct pt_regs *old_regs ;
  void const   *__vpp_verify ;
  pto_T_____6 pto_tmp__ ;
  pto_T_____7 pto_tmp_____0 ;
  pto_T_____8 pto_tmp_____1 ;
  pto_T_____9 pto_tmp_____2 ;

  {
  {
#line 25
  old_regs = get_irq_regs();
  }
  {
#line 26
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 26
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 26
      __vpp_verify = (void const   *)((struct pt_regs **)((void *)0));
      }
#line 26
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 26
    if (sizeof(irq_regs) == 1UL) {
#line 26
      goto case_1;
    }
#line 26
    if (sizeof(irq_regs) == 2UL) {
#line 26
      goto case_2___0;
    }
#line 26
    if (sizeof(irq_regs) == 4UL) {
#line 26
      goto case_4___1;
    }
#line 26
    if (sizeof(irq_regs) == 8UL) {
#line 26
      goto case_8___2;
    }
#line 26
    goto switch_default___3;
    case_1: /* CIL Label */ 
    {
#line 26
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 26
      if (sizeof(irq_regs) == 1UL) {
#line 26
        goto case_1___0;
      }
#line 26
      if (sizeof(irq_regs) == 2UL) {
#line 26
        goto case_2;
      }
#line 26
      if (sizeof(irq_regs) == 4UL) {
#line 26
        goto case_4;
      }
#line 26
      if (sizeof(irq_regs) == 8UL) {
#line 26
        goto case_8;
      }
#line 26
      goto switch_default;
      case_1___0: /* CIL Label */ 
      {
#line 26
      __asm__  ("mov"
                "b %1,"
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (irq_regs): "qi" (new_regs));
      }
#line 26
      goto switch_break___0;
      case_2: /* CIL Label */ 
      {
#line 26
      __asm__  ("mov"
                "w %1,"
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (irq_regs): "ri" (new_regs));
      }
#line 26
      goto switch_break___0;
      case_4: /* CIL Label */ 
      {
#line 26
      __asm__  ("mov"
                "l %1,"
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (irq_regs): "ri" (new_regs));
      }
#line 26
      goto switch_break___0;
      case_8: /* CIL Label */ 
      {
#line 26
      __asm__  ("mov"
                "q %1,"
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (irq_regs): "re" (new_regs));
      }
#line 26
      goto switch_break___0;
      switch_default: /* CIL Label */ 
      {
#line 26
      __bad_percpu_size();
      }
      switch_break___0: /* CIL Label */ ;
      }
#line 26
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 26
    goto switch_break;
    case_2___0: /* CIL Label */ 
    {
#line 26
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 26
      if (sizeof(irq_regs) == 1UL) {
#line 26
        goto case_1___1;
      }
#line 26
      if (sizeof(irq_regs) == 2UL) {
#line 26
        goto case_2___1;
      }
#line 26
      if (sizeof(irq_regs) == 4UL) {
#line 26
        goto case_4___0;
      }
#line 26
      if (sizeof(irq_regs) == 8UL) {
#line 26
        goto case_8___0;
      }
#line 26
      goto switch_default___0;
      case_1___1: /* CIL Label */ 
      {
#line 26
      __asm__  ("mov"
                "b %1,"
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (irq_regs): "qi" (new_regs));
      }
#line 26
      goto switch_break___1;
      case_2___1: /* CIL Label */ 
      {
#line 26
      __asm__  ("mov"
                "w %1,"
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (irq_regs): "ri" (new_regs));
      }
#line 26
      goto switch_break___1;
      case_4___0: /* CIL Label */ 
      {
#line 26
      __asm__  ("mov"
                "l %1,"
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (irq_regs): "ri" (new_regs));
      }
#line 26
      goto switch_break___1;
      case_8___0: /* CIL Label */ 
      {
#line 26
      __asm__  ("mov"
                "q %1,"
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (irq_regs): "re" (new_regs));
      }
#line 26
      goto switch_break___1;
      switch_default___0: /* CIL Label */ 
      {
#line 26
      __bad_percpu_size();
      }
      switch_break___1: /* CIL Label */ ;
      }
#line 26
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 26
    goto switch_break;
    case_4___1: /* CIL Label */ 
    {
#line 26
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 26
      if (sizeof(irq_regs) == 1UL) {
#line 26
        goto case_1___2;
      }
#line 26
      if (sizeof(irq_regs) == 2UL) {
#line 26
        goto case_2___2;
      }
#line 26
      if (sizeof(irq_regs) == 4UL) {
#line 26
        goto case_4___2;
      }
#line 26
      if (sizeof(irq_regs) == 8UL) {
#line 26
        goto case_8___1;
      }
#line 26
      goto switch_default___1;
      case_1___2: /* CIL Label */ 
      {
#line 26
      __asm__  ("mov"
                "b %1,"
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (irq_regs): "qi" (new_regs));
      }
#line 26
      goto switch_break___2;
      case_2___2: /* CIL Label */ 
      {
#line 26
      __asm__  ("mov"
                "w %1,"
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (irq_regs): "ri" (new_regs));
      }
#line 26
      goto switch_break___2;
      case_4___2: /* CIL Label */ 
      {
#line 26
      __asm__  ("mov"
                "l %1,"
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (irq_regs): "ri" (new_regs));
      }
#line 26
      goto switch_break___2;
      case_8___1: /* CIL Label */ 
      {
#line 26
      __asm__  ("mov"
                "q %1,"
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (irq_regs): "re" (new_regs));
      }
#line 26
      goto switch_break___2;
      switch_default___1: /* CIL Label */ 
      {
#line 26
      __bad_percpu_size();
      }
      switch_break___2: /* CIL Label */ ;
      }
#line 26
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 26
    goto switch_break;
    case_8___2: /* CIL Label */ 
    {
#line 26
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 26
      if (sizeof(irq_regs) == 1UL) {
#line 26
        goto case_1___3;
      }
#line 26
      if (sizeof(irq_regs) == 2UL) {
#line 26
        goto case_2___3;
      }
#line 26
      if (sizeof(irq_regs) == 4UL) {
#line 26
        goto case_4___3;
      }
#line 26
      if (sizeof(irq_regs) == 8UL) {
#line 26
        goto case_8___3;
      }
#line 26
      goto switch_default___2;
      case_1___3: /* CIL Label */ 
      {
#line 26
      __asm__  ("mov"
                "b %1,"
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (irq_regs): "qi" (new_regs));
      }
#line 26
      goto switch_break___3;
      case_2___3: /* CIL Label */ 
      {
#line 26
      __asm__  ("mov"
                "w %1,"
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (irq_regs): "ri" (new_regs));
      }
#line 26
      goto switch_break___3;
      case_4___3: /* CIL Label */ 
      {
#line 26
      __asm__  ("mov"
                "l %1,"
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (irq_regs): "ri" (new_regs));
      }
#line 26
      goto switch_break___3;
      case_8___3: /* CIL Label */ 
      {
#line 26
      __asm__  ("mov"
                "q %1,"
                "%%"
                "gs"
                ":"
                "%P"
                "0": "+m" (irq_regs): "re" (new_regs));
      }
#line 26
      goto switch_break___3;
      switch_default___2: /* CIL Label */ 
      {
#line 26
      __bad_percpu_size();
      }
      switch_break___3: /* CIL Label */ ;
      }
#line 26
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 26
    goto switch_break;
    switch_default___3: /* CIL Label */ 
    {
#line 26
    __bad_size_call_parameter();
    }
#line 26
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 26
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 28
  return (old_regs);
}
}
#line 191 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static bool irqd_is_setaffinity_pending(struct irq_data *d )  __attribute__((__no_instrument_function__)) ;
#line 191 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static bool irqd_is_setaffinity_pending(struct irq_data *d ) 
{ 


  {
#line 193
  return ((bool )(d->state_use_accessors & 256U));
}
}
#line 196
__inline static bool irqd_is_per_cpu(struct irq_data *d )  __attribute__((__no_instrument_function__)) ;
#line 196 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static bool irqd_is_per_cpu(struct irq_data *d ) 
{ 


  {
#line 198
  return ((bool )(d->state_use_accessors & 2048U));
}
}
#line 201
__inline static bool irqd_can_balance(struct irq_data *d )  __attribute__((__no_instrument_function__)) ;
#line 201 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static bool irqd_can_balance(struct irq_data *d ) 
{ 


  {
#line 203
  return ((bool )(! (d->state_use_accessors & 3072U)));
}
}
#line 206
__inline static bool irqd_affinity_was_set(struct irq_data *d )  __attribute__((__no_instrument_function__)) ;
#line 206 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static bool irqd_affinity_was_set(struct irq_data *d ) 
{ 


  {
#line 208
  return ((bool )(d->state_use_accessors & 4096U));
}
}
#line 211
__inline static void irqd_mark_affinity_was_set(struct irq_data *d )  __attribute__((__no_instrument_function__)) ;
#line 211 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static void irqd_mark_affinity_was_set(struct irq_data *d ) 
{ 


  {
  {
#line 213
  d->state_use_accessors |= 4096U;
  }
#line 214
  return;
}
}
#line 216
__inline static u32 irqd_get_trigger_type(struct irq_data *d )  __attribute__((__no_instrument_function__)) ;
#line 216 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static u32 irqd_get_trigger_type(struct irq_data *d ) 
{ 


  {
#line 218
  return (d->state_use_accessors & 15U);
}
}
#line 224
__inline static void irqd_set_trigger_type(struct irq_data *d , u32 type )  __attribute__((__no_instrument_function__)) ;
#line 224 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static void irqd_set_trigger_type(struct irq_data *d , u32 type ) 
{ 


  {
  {
#line 226
  d->state_use_accessors &= 4294967280U;
#line 227
  d->state_use_accessors |= type & 15U;
  }
#line 228
  return;
}
}
#line 230
__inline static bool irqd_is_level_type(struct irq_data *d )  __attribute__((__no_instrument_function__)) ;
#line 230 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static bool irqd_is_level_type(struct irq_data *d ) 
{ 


  {
#line 232
  return ((bool )(d->state_use_accessors & 8192U));
}
}
#line 235
__inline static bool irqd_is_wakeup_set(struct irq_data *d )  __attribute__((__no_instrument_function__)) ;
#line 235 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static bool irqd_is_wakeup_set(struct irq_data *d ) 
{ 


  {
#line 237
  return ((bool )(d->state_use_accessors & 16384U));
}
}
#line 240
__inline static bool irqd_can_move_in_process_context(struct irq_data *d )  __attribute__((__no_instrument_function__)) ;
#line 240 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static bool irqd_can_move_in_process_context(struct irq_data *d ) 
{ 


  {
#line 242
  return ((bool )(d->state_use_accessors & 32768U));
}
}
#line 245
__inline static bool irqd_irq_disabled(struct irq_data *d )  __attribute__((__no_instrument_function__)) ;
#line 245 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static bool irqd_irq_disabled(struct irq_data *d ) 
{ 


  {
#line 247
  return ((bool )(d->state_use_accessors & 65536U));
}
}
#line 250
__inline static bool irqd_irq_masked(struct irq_data *d )  __attribute__((__no_instrument_function__)) ;
#line 250 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static bool irqd_irq_masked(struct irq_data *d ) 
{ 


  {
#line 252
  return ((bool )(d->state_use_accessors & 131072U));
}
}
#line 255
__inline static bool irqd_irq_inprogress(struct irq_data *d )  __attribute__((__no_instrument_function__)) ;
#line 255 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static bool irqd_irq_inprogress(struct irq_data *d ) 
{ 


  {
#line 257
  return ((bool )(d->state_use_accessors & 262144U));
}
}
#line 265
__inline static void irqd_set_chained_irq_inprogress(struct irq_data *d )  __attribute__((__no_instrument_function__)) ;
#line 265 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static void irqd_set_chained_irq_inprogress(struct irq_data *d ) 
{ 


  {
  {
#line 267
  d->state_use_accessors |= 262144U;
  }
#line 268
  return;
}
}
#line 270
__inline static void irqd_clr_chained_irq_inprogress(struct irq_data *d )  __attribute__((__no_instrument_function__)) ;
#line 270 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static void irqd_clr_chained_irq_inprogress(struct irq_data *d ) 
{ 


  {
  {
#line 272
  d->state_use_accessors &= 4294705151U;
  }
#line 273
  return;
}
}
#line 275
__inline static irq_hw_number_t irqd_to_hwirq(struct irq_data *d )  __attribute__((__no_instrument_function__)) ;
#line 275 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static irq_hw_number_t irqd_to_hwirq(struct irq_data *d ) 
{ 


  {
#line 277
  return (d->hwirq);
}
}
#line 83 "../../../analyzer/../bench/linux-headers/include/linux/irqdesc.h"
__inline static struct irq_data *irq_desc_get_irq_data(struct irq_desc *desc )  __attribute__((__no_instrument_function__)) ;
#line 83 "../../../analyzer/../bench/linux-headers/include/linux/irqdesc.h"
__inline static struct irq_data *irq_desc_get_irq_data(struct irq_desc *desc ) 
{ 


  {
#line 85
  return (& desc->irq_data);
}
}
#line 88
__inline static struct irq_chip *irq_desc_get_chip(struct irq_desc *desc )  __attribute__((__no_instrument_function__)) ;
#line 88 "../../../analyzer/../bench/linux-headers/include/linux/irqdesc.h"
__inline static struct irq_chip *irq_desc_get_chip(struct irq_desc *desc ) 
{ 


  {
#line 90
  return (desc->irq_data.chip);
}
}
#line 93
__inline static void *irq_desc_get_chip_data(struct irq_desc *desc )  __attribute__((__no_instrument_function__)) ;
#line 93 "../../../analyzer/../bench/linux-headers/include/linux/irqdesc.h"
__inline static void *irq_desc_get_chip_data(struct irq_desc *desc ) 
{ 


  {
#line 95
  return (desc->irq_data.chip_data);
}
}
#line 98
__inline static void *irq_desc_get_handler_data(struct irq_desc *desc )  __attribute__((__no_instrument_function__)) ;
#line 98 "../../../analyzer/../bench/linux-headers/include/linux/irqdesc.h"
__inline static void *irq_desc_get_handler_data(struct irq_desc *desc ) 
{ 


  {
#line 100
  return (desc->irq_data.handler_data);
}
}
#line 103
__inline static struct msi_desc *irq_desc_get_msi_desc(struct irq_desc *desc )  __attribute__((__no_instrument_function__)) ;
#line 103 "../../../analyzer/../bench/linux-headers/include/linux/irqdesc.h"
__inline static struct msi_desc *irq_desc_get_msi_desc(struct irq_desc *desc ) 
{ 


  {
#line 105
  return (desc->irq_data.msi_desc);
}
}
#line 114
__inline static void generic_handle_irq_desc(unsigned int irq , struct irq_desc *desc )  __attribute__((__no_instrument_function__)) ;
#line 114 "../../../analyzer/../bench/linux-headers/include/linux/irqdesc.h"
__inline static void generic_handle_irq_desc(unsigned int irq , struct irq_desc *desc ) 
{ 


  {
  {
#line 116
  (*(desc->handle_irq))(irq, desc);
  }
#line 117
  return;
}
}
#line 119
extern int generic_handle_irq(unsigned int irq ) ;
#line 122
__inline static int irq_has_action(unsigned int irq )  __attribute__((__no_instrument_function__)) ;
#line 122 "../../../analyzer/../bench/linux-headers/include/linux/irqdesc.h"
__inline static int irq_has_action(unsigned int irq ) 
{ 
  struct irq_desc *desc ;
  struct irq_desc *tmp ;

  {
  {
#line 124
  tmp = irq_to_desc(irq);
#line 124
  desc = tmp;
  }
#line 125
  return ((unsigned long )desc->action != (unsigned long )((void *)0));
}
}
#line 129
__inline static void __irq_set_handler_locked(unsigned int irq , void (*handler)(unsigned int irq ,
                                                                                 struct irq_desc *desc ) )  __attribute__((__no_instrument_function__)) ;
#line 129 "../../../analyzer/../bench/linux-headers/include/linux/irqdesc.h"
__inline static void __irq_set_handler_locked(unsigned int irq , void (*handler)(unsigned int irq ,
                                                                                 struct irq_desc *desc ) ) 
{ 
  struct irq_desc *desc ;

  {
  {
#line 134
  desc = irq_to_desc(irq);
#line 135
  desc->handle_irq = handler;
  }
#line 136
  return;
}
}
#line 139
__inline static void __irq_set_chip_handler_name_locked(unsigned int irq , struct irq_chip *chip ,
                                                        void (*handler)(unsigned int irq ,
                                                                        struct irq_desc *desc ) ,
                                                        char const   *name )  __attribute__((__no_instrument_function__)) ;
#line 139 "../../../analyzer/../bench/linux-headers/include/linux/irqdesc.h"
__inline static void __irq_set_chip_handler_name_locked(unsigned int irq , struct irq_chip *chip ,
                                                        void (*handler)(unsigned int irq ,
                                                                        struct irq_desc *desc ) ,
                                                        char const   *name ) 
{ 
  struct irq_desc *desc ;
  struct irq_data *tmp ;

  {
  {
#line 145
  desc = irq_to_desc(irq);
#line 146
  tmp = irq_desc_get_irq_data(desc);
#line 146
  tmp->chip = chip;
#line 147
  desc->handle_irq = handler;
#line 148
  desc->name = name;
  }
#line 149
  return;
}
}
#line 151
__inline static int irq_balancing_disabled(unsigned int irq )  __attribute__((__no_instrument_function__)) ;
#line 151 "../../../analyzer/../bench/linux-headers/include/linux/irqdesc.h"
__inline static int irq_balancing_disabled(unsigned int irq ) 
{ 
  struct irq_desc *desc ;

  {
  {
#line 155
  desc = irq_to_desc(irq);
  }
#line 156
  return ((int )(desc->status_use_accessors & 8704U));
}
}
#line 159
__inline static int irq_is_percpu(unsigned int irq )  __attribute__((__no_instrument_function__)) ;
#line 159 "../../../analyzer/../bench/linux-headers/include/linux/irqdesc.h"
__inline static int irq_is_percpu(unsigned int irq ) 
{ 
  struct irq_desc *desc ;

  {
  {
#line 163
  desc = irq_to_desc(irq);
  }
#line 164
  return ((int )(desc->status_use_accessors & 512U));
}
}
#line 167
__inline static void irq_set_lockdep_class(unsigned int irq , struct lock_class_key *class )  __attribute__((__no_instrument_function__)) ;
#line 167 "../../../analyzer/../bench/linux-headers/include/linux/irqdesc.h"
__inline static void irq_set_lockdep_class(unsigned int irq , struct lock_class_key *class ) 
{ 
  struct irq_desc *desc ;
  struct irq_desc *tmp ;

  {
  {
#line 170
  tmp = irq_to_desc(irq);
#line 170
  desc = tmp;
  }
#line 172
  if (desc) {
    {
#line 173
    while (1) {
      while_continue: /* CIL Label */ ;
#line 173
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 174
  return;
}
}
#line 21 "../../../analyzer/../bench/linux-headers/include/linux/profile.h"
extern void create_prof_cpu_mask(void) ;
#line 22
extern int create_proc_profile(void) ;
#line 41
extern int prof_on  __attribute__((__section__(".data..read_mostly"))) ;
#line 44
extern int profile_init(void) ;
#line 45
extern int profile_setup(char *str ) ;
#line 46
extern void profile_tick(int type ) ;
#line 52
extern void profile_hits(int type , void *ip , unsigned int nr_hits ) ;
#line 57
__inline static void profile_hit(int type , void *ip )  __attribute__((__no_instrument_function__)) ;
#line 57 "../../../analyzer/../bench/linux-headers/include/linux/profile.h"
__inline static void profile_hit(int type , void *ip ) 
{ 
  long tmp ;

  {
  {
#line 62
  tmp = __builtin_expect((long )(! (! (prof_on == type))), 0L);
  }
#line 62
  if (tmp) {
    {
#line 63
    profile_hits(type, ip, 1U);
    }
  }
#line 64
  return;
}
}
#line 70
extern void profile_task_exit(struct task_struct *task ) ;
#line 75
extern int profile_handoff_task(struct task_struct *task ) ;
#line 78
extern void profile_munmap(unsigned long addr ) ;
#line 80
extern int task_handoff_register(struct notifier_block *n ) ;
#line 81
extern int task_handoff_unregister(struct notifier_block *n ) ;
#line 83
extern int profile_event_register(enum profile_type  , struct notifier_block *n ) ;
#line 84
extern int profile_event_unregister(enum profile_type  , struct notifier_block *n ) ;
#line 26 "../../../analyzer/../bench/linux-headers/include/asm-generic/sections.h"
extern char _text[] ;
#line 26
extern char _stext[] ;
#line 26
extern char _etext[] ;
#line 27
extern char _data[] ;
#line 27
extern char _sdata[] ;
#line 27
extern char _edata[] ;
#line 28
extern char __bss_start[] ;
#line 28
extern char __bss_stop[] ;
#line 29
extern char __init_begin[] ;
#line 29
extern char __init_end[] ;
#line 30
extern char _sinittext[] ;
#line 30
extern char _einittext[] ;
#line 31
extern char _end[] ;
#line 32
extern char __per_cpu_load[] ;
#line 32
extern char __per_cpu_start[] ;
#line 32
extern char __per_cpu_end[] ;
#line 33
extern char __kprobes_text_start[] ;
#line 33
extern char __kprobes_text_end[] ;
#line 34
extern char __entry_text_start[] ;
#line 34
extern char __entry_text_end[] ;
#line 35
extern char __start_rodata[] ;
#line 35
extern char __end_rodata[] ;
#line 38
extern char __ctors_start[] ;
#line 38
extern char __ctors_end[] ;
#line 49
__inline static int arch_is_kernel_text(unsigned long addr )  __attribute__((__no_instrument_function__)) ;
#line 49 "../../../analyzer/../bench/linux-headers/include/asm-generic/sections.h"
__inline static int arch_is_kernel_text(unsigned long addr ) 
{ 


  {
#line 51
  return (0);
}
}
#line 56
__inline static int arch_is_kernel_data(unsigned long addr )  __attribute__((__no_instrument_function__)) ;
#line 56 "../../../analyzer/../bench/linux-headers/include/asm-generic/sections.h"
__inline static int arch_is_kernel_data(unsigned long addr ) 
{ 


  {
#line 58
  return (0);
}
}
#line 61 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/smap.h"
__inline static void ( __attribute__((__always_inline__)) clac)(void)  __attribute__((__no_instrument_function__)) ;
#line 61 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/smap.h"
__inline static void ( __attribute__((__always_inline__)) clac)(void) 
{ 


  {
  {
#line 64
  __asm__  volatile   ("661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xca"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection": : : "memory");
  }
#line 65
  return;
}
}
#line 67
__inline static void ( __attribute__((__always_inline__)) stac)(void)  __attribute__((__no_instrument_function__)) ;
#line 67 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/smap.h"
__inline static void ( __attribute__((__always_inline__)) stac)(void) 
{ 


  {
  {
#line 70
  __asm__  volatile   ("661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xcb"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection": : : "memory");
  }
#line 71
  return;
}
}
#line 44 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/uaccess.h"
__inline static bool __chk_range_not_ok(unsigned long addr , unsigned long size ,
                                        unsigned long limit )  __attribute__((__no_instrument_function__)) ;
#line 44 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/uaccess.h"
__inline static bool __chk_range_not_ok(unsigned long addr , unsigned long size ,
                                        unsigned long limit ) 
{ 


  {
  {
#line 57
  addr += size;
  }
#line 58
  if (addr < size) {
#line 59
    return ((bool )1);
  }
#line 60
  return ((bool )(addr > limit));
}
}
#line 112
extern int fixup_exception(struct pt_regs *regs ) ;
#line 113
extern int early_fixup_exception(unsigned long *ip ) ;
#line 130
extern int __get_user_1(void) ;
#line 131
extern int __get_user_2(void) ;
#line 132
extern int __get_user_4(void) ;
#line 133
extern int __get_user_8(void) ;
#line 134
extern int __get_user_bad(void) ;
#line 227
extern void __put_user_bad(void) ;
#line 233
extern void __put_user_1(void) ;
#line 234
extern void __put_user_2(void) ;
#line 235
extern void __put_user_4(void) ;
#line 236
extern void __put_user_8(void) ;
#line 525
extern unsigned long copy_from_user_nmi(void *to , void const   *from , unsigned long n ) ;
#line 527
extern long ( __attribute__((__warn_unused_result__)) strncpy_from_user)(char *dst ,
                                                                         char const   *src ,
                                                                         long count ) ;
#line 530
extern long ( __attribute__((__warn_unused_result__)) strlen_user)(char const   *str ) ;
#line 531
extern long ( __attribute__((__warn_unused_result__)) strnlen_user)(char const   *str ,
                                                                    long n ) ;
#line 533
extern unsigned long ( __attribute__((__warn_unused_result__)) clear_user)(void *mem ,
                                                                           unsigned long len ) ;
#line 534
extern unsigned long ( __attribute__((__warn_unused_result__)) __clear_user)(void *mem ,
                                                                             unsigned long len ) ;
#line 19 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/uaccess_64.h"
extern unsigned long ( __attribute__((__warn_unused_result__)) copy_user_enhanced_fast_string)(void *to ,
                                                                                               void const   *from ,
                                                                                               unsigned int len ) ;
#line 21
extern unsigned long ( __attribute__((__warn_unused_result__)) copy_user_generic_string)(void *to ,
                                                                                         void const   *from ,
                                                                                         unsigned int len ) ;
#line 23
extern unsigned long ( __attribute__((__warn_unused_result__)) copy_user_generic_unrolled)(void *to ,
                                                                                           void const   *from ,
                                                                                           unsigned int len ) ;
#line 26
__inline static unsigned long ( __attribute__((__warn_unused_result__, __always_inline__)) copy_user_generic)(void *to ,
                                                                                                              void const   *from ,
                                                                                                              unsigned int len )  __attribute__((__no_instrument_function__)) ;
#line 26 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/uaccess_64.h"
__inline static unsigned long ( __attribute__((__warn_unused_result__, __always_inline__)) copy_user_generic)(void *to ,
                                                                                                              void const   *from ,
                                                                                                              unsigned int len ) 
{ 
  unsigned int ret ;

  {
  {
#line 36
  __asm__  volatile   ("661:\n\t"
                       "call %P[old]"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 3*32+16)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "2"
                       "f - .\n"
                       " .word "
                       "( 9*32+ 9)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "2"
                       "f-"
                       "663"
                       "2"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       " .byte 0xff + ("
                       "664"
                       "2"
                       "f-"
                       "663"
                       "2"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       "call %P[new1]"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       "663"
                       "2"
                       ":\n\t"
                       "call %P[new2]"
                       "\n"
                       "664"
                       "2"
                       ":\n\t"
                       ".popsection": "=a" (ret), "=D" (to), "=S" (from), "=d" (len): [old] "i" (& copy_user_generic_unrolled),
                       [new1] "i" (& copy_user_generic_string), [new2] "i" (& copy_user_enhanced_fast_string),
                       "1" (to), "2" (from), "3" (len): "memory", "rcx", "r8", "r9",
                       "r10", "r11");
  }
#line 45
  return ((unsigned long )ret);
}
}
#line 48
extern unsigned long ( __attribute__((__warn_unused_result__)) copy_in_user)(void *to ,
                                                                             void const   *from ,
                                                                             unsigned int len ) ;
#line 51
__inline static int ( __attribute__((__warn_unused_result__, __always_inline__)) __copy_from_user_nocheck)(void *dst ,
                                                                                                           void const   *src ,
                                                                                                           unsigned int size )  __attribute__((__no_instrument_function__)) ;
#line 51 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/uaccess_64.h"
__inline static int ( __attribute__((__warn_unused_result__, __always_inline__)) __copy_from_user_nocheck)(void *dst ,
                                                                                                           void const   *src ,
                                                                                                           unsigned int size ) 
{ 
  int ret ;
  unsigned long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  unsigned long tmp___2 ;

  {
  {
#line 54
  ret = 0;
#line 57
  tmp = copy_user_generic(dst, (void const   *)((void *)src), size);
  }
#line 57
  return ((int )tmp);
  {
#line 59
  if (size == 1U) {
#line 59
    goto case_1;
  }
#line 62
  if (size == 2U) {
#line 62
    goto case_2;
  }
#line 65
  if (size == 4U) {
#line 65
    goto case_4;
  }
#line 68
  if (size == 8U) {
#line 68
    goto case_8;
  }
#line 71
  if (size == 10U) {
#line 71
    goto case_10;
  }
#line 80
  if (size == 16U) {
#line 80
    goto case_16;
  }
#line 89
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 59
  __asm__  volatile   ("661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xcb"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       "1:\tmov"
                       "b"
                       " %2,%"
                       "b"
                       "1\n"
                       "2: "
                       "661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xca"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       ".section .fixup,\"ax\"\n"
                       "3:\tmov %3,%0\n"
                       "\txor"
                       "b"
                       " %"
                       "b"
                       "1,%"
                       "b"
                       "1\n"
                       "\tjmp 2b\n"
                       ".previous\n"
                       " .pushsection \"__ex_table\",\"a\"\n"
                       " .balign 8\n"
                       " .long ("
                       "1b"
                       ") - .\n"
                       " .long ("
                       "3b"
                       ") - .\n"
                       " .popsection\n": "=r" (ret), "=q" (*((u8 *)dst)): "m" (*((struct __large_struct *)((u8 *)src))),
                       "i" (1), "0" (ret));
  }
#line 61
  return (ret);
  case_2: /* CIL Label */ 
  {
#line 62
  __asm__  volatile   ("661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xcb"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       "1:\tmov"
                       "w"
                       " %2,%"
                       "w"
                       "1\n"
                       "2: "
                       "661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xca"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       ".section .fixup,\"ax\"\n"
                       "3:\tmov %3,%0\n"
                       "\txor"
                       "w"
                       " %"
                       "w"
                       "1,%"
                       "w"
                       "1\n"
                       "\tjmp 2b\n"
                       ".previous\n"
                       " .pushsection \"__ex_table\",\"a\"\n"
                       " .balign 8\n"
                       " .long ("
                       "1b"
                       ") - .\n"
                       " .long ("
                       "3b"
                       ") - .\n"
                       " .popsection\n": "=r" (ret), "=r" (*((u16 *)dst)): "m" (*((struct __large_struct *)((u16 *)src))),
                       "i" (2), "0" (ret));
  }
#line 64
  return (ret);
  case_4: /* CIL Label */ 
  {
#line 65
  __asm__  volatile   ("661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xcb"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       "1:\tmov"
                       "l"
                       " %2,%"
                       "k"
                       "1\n"
                       "2: "
                       "661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xca"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       ".section .fixup,\"ax\"\n"
                       "3:\tmov %3,%0\n"
                       "\txor"
                       "l"
                       " %"
                       "k"
                       "1,%"
                       "k"
                       "1\n"
                       "\tjmp 2b\n"
                       ".previous\n"
                       " .pushsection \"__ex_table\",\"a\"\n"
                       " .balign 8\n"
                       " .long ("
                       "1b"
                       ") - .\n"
                       " .long ("
                       "3b"
                       ") - .\n"
                       " .popsection\n": "=r" (ret), "=r" (*((u32 *)dst)): "m" (*((struct __large_struct *)((u32 *)src))),
                       "i" (4), "0" (ret));
  }
#line 67
  return (ret);
  case_8: /* CIL Label */ 
  {
#line 68
  __asm__  volatile   ("661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xcb"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       "1:\tmov"
                       "q"
                       " %2,%"
                       ""
                       "1\n"
                       "2: "
                       "661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xca"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       ".section .fixup,\"ax\"\n"
                       "3:\tmov %3,%0\n"
                       "\txor"
                       "q"
                       " %"
                       ""
                       "1,%"
                       ""
                       "1\n"
                       "\tjmp 2b\n"
                       ".previous\n"
                       " .pushsection \"__ex_table\",\"a\"\n"
                       " .balign 8\n"
                       " .long ("
                       "1b"
                       ") - .\n"
                       " .long ("
                       "3b"
                       ") - .\n"
                       " .popsection\n": "=r" (ret), "=r" (*((u64 *)dst)): "m" (*((struct __large_struct *)((u64 *)src))),
                       "i" (8), "0" (ret));
  }
#line 70
  return (ret);
  case_10: /* CIL Label */ 
  {
#line 72
  __asm__  volatile   ("661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xcb"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       "1:\tmov"
                       "q"
                       " %2,%"
                       ""
                       "1\n"
                       "2: "
                       "661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xca"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       ".section .fixup,\"ax\"\n"
                       "3:\tmov %3,%0\n"
                       "\txor"
                       "q"
                       " %"
                       ""
                       "1,%"
                       ""
                       "1\n"
                       "\tjmp 2b\n"
                       ".previous\n"
                       " .pushsection \"__ex_table\",\"a\"\n"
                       " .balign 8\n"
                       " .long ("
                       "1b"
                       ") - .\n"
                       " .long ("
                       "3b"
                       ") - .\n"
                       " .popsection\n": "=r" (ret), "=r" (*((u64 *)dst)): "m" (*((struct __large_struct *)((u64 *)src))),
                       "i" (10), "0" (ret));
#line 74
  tmp___0 = __builtin_expect((long )(! (! ret)), 0L);
  }
#line 74
  if (tmp___0) {
#line 75
    return (ret);
  }
  {
#line 76
  __asm__  volatile   ("661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xcb"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       "1:\tmov"
                       "w"
                       " %2,%"
                       "w"
                       "1\n"
                       "2: "
                       "661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xca"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       ".section .fixup,\"ax\"\n"
                       "3:\tmov %3,%0\n"
                       "\txor"
                       "w"
                       " %"
                       "w"
                       "1,%"
                       "w"
                       "1\n"
                       "\tjmp 2b\n"
                       ".previous\n"
                       " .pushsection \"__ex_table\",\"a\"\n"
                       " .balign 8\n"
                       " .long ("
                       "1b"
                       ") - .\n"
                       " .long ("
                       "3b"
                       ") - .\n"
                       " .popsection\n": "=r" (ret), "=r" (*((u16 *)((char *)dst + 8))): "m" (*((struct __large_struct *)((u16 *)((char *)src + 8)))),
                       "i" (2), "0" (ret));
  }
#line 79
  return (ret);
  case_16: /* CIL Label */ 
  {
#line 81
  __asm__  volatile   ("661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xcb"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       "1:\tmov"
                       "q"
                       " %2,%"
                       ""
                       "1\n"
                       "2: "
                       "661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xca"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       ".section .fixup,\"ax\"\n"
                       "3:\tmov %3,%0\n"
                       "\txor"
                       "q"
                       " %"
                       ""
                       "1,%"
                       ""
                       "1\n"
                       "\tjmp 2b\n"
                       ".previous\n"
                       " .pushsection \"__ex_table\",\"a\"\n"
                       " .balign 8\n"
                       " .long ("
                       "1b"
                       ") - .\n"
                       " .long ("
                       "3b"
                       ") - .\n"
                       " .popsection\n": "=r" (ret), "=r" (*((u64 *)dst)): "m" (*((struct __large_struct *)((u64 *)src))),
                       "i" (16), "0" (ret));
#line 83
  tmp___1 = __builtin_expect((long )(! (! ret)), 0L);
  }
#line 83
  if (tmp___1) {
#line 84
    return (ret);
  }
  {
#line 85
  __asm__  volatile   ("661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xcb"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       "1:\tmov"
                       "q"
                       " %2,%"
                       ""
                       "1\n"
                       "2: "
                       "661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xca"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       ".section .fixup,\"ax\"\n"
                       "3:\tmov %3,%0\n"
                       "\txor"
                       "q"
                       " %"
                       ""
                       "1,%"
                       ""
                       "1\n"
                       "\tjmp 2b\n"
                       ".previous\n"
                       " .pushsection \"__ex_table\",\"a\"\n"
                       " .balign 8\n"
                       " .long ("
                       "1b"
                       ") - .\n"
                       " .long ("
                       "3b"
                       ") - .\n"
                       " .popsection\n": "=r" (ret), "=r" (*((u64 *)((char *)dst + 8))): "m" (*((struct __large_struct *)((u64 *)((char *)src + 8)))),
                       "i" (8), "0" (ret));
  }
#line 88
  return (ret);
  switch_default: /* CIL Label */ 
  {
#line 90
  tmp___2 = copy_user_generic(dst, (void const   *)((void *)src), size);
  }
#line 90
  return ((int )tmp___2);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 94
__inline static int ( __attribute__((__warn_unused_result__, __always_inline__)) __copy_from_user)(void *dst ,
                                                                                                   void const   *src ,
                                                                                                   unsigned int size )  __attribute__((__no_instrument_function__)) ;
#line 94 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/uaccess_64.h"
__inline static int ( __attribute__((__warn_unused_result__, __always_inline__)) __copy_from_user)(void *dst ,
                                                                                                   void const   *src ,
                                                                                                   unsigned int size ) 
{ 
  int tmp ;

  {
  {
#line 97
  might_fault();
#line 98
  tmp = __copy_from_user_nocheck(dst, src, size);
  }
#line 98
  return (tmp);
}
}
#line 101
__inline static int ( __attribute__((__warn_unused_result__, __always_inline__)) __copy_to_user_nocheck)(void *dst ,
                                                                                                         void const   *src ,
                                                                                                         unsigned int size )  __attribute__((__no_instrument_function__)) ;
#line 101 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/uaccess_64.h"
__inline static int ( __attribute__((__warn_unused_result__, __always_inline__)) __copy_to_user_nocheck)(void *dst ,
                                                                                                         void const   *src ,
                                                                                                         unsigned int size ) 
{ 
  int ret ;
  unsigned long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  unsigned long tmp___2 ;

  {
  {
#line 104
  ret = 0;
#line 107
  tmp = copy_user_generic(dst, src, size);
  }
#line 107
  return ((int )tmp);
  {
#line 109
  if (size == 1U) {
#line 109
    goto case_1;
  }
#line 112
  if (size == 2U) {
#line 112
    goto case_2;
  }
#line 115
  if (size == 4U) {
#line 115
    goto case_4;
  }
#line 118
  if (size == 8U) {
#line 118
    goto case_8;
  }
#line 121
  if (size == 10U) {
#line 121
    goto case_10;
  }
#line 130
  if (size == 16U) {
#line 130
    goto case_16;
  }
#line 139
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 109
  __asm__  volatile   ("661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xcb"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       "1:\tmov"
                       "b"
                       " %"
                       "b"
                       "1,%2\n"
                       "2: "
                       "661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xca"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       ".section .fixup,\"ax\"\n"
                       "3:\tmov %3,%0\n"
                       "\tjmp 2b\n"
                       ".previous\n"
                       " .pushsection \"__ex_table\",\"a\"\n"
                       " .balign 8\n"
                       " .long ("
                       "1b"
                       ") - .\n"
                       " .long ("
                       "3b"
                       ") - .\n"
                       " .popsection\n": "=r" (ret): "iq" (*((u8 *)src)), "m" (*((struct __large_struct *)((u8 *)dst))),
                       "i" (1), "0" (ret));
  }
#line 111
  return (ret);
  case_2: /* CIL Label */ 
  {
#line 112
  __asm__  volatile   ("661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xcb"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       "1:\tmov"
                       "w"
                       " %"
                       "w"
                       "1,%2\n"
                       "2: "
                       "661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xca"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       ".section .fixup,\"ax\"\n"
                       "3:\tmov %3,%0\n"
                       "\tjmp 2b\n"
                       ".previous\n"
                       " .pushsection \"__ex_table\",\"a\"\n"
                       " .balign 8\n"
                       " .long ("
                       "1b"
                       ") - .\n"
                       " .long ("
                       "3b"
                       ") - .\n"
                       " .popsection\n": "=r" (ret): "ir" (*((u16 *)src)), "m" (*((struct __large_struct *)((u16 *)dst))),
                       "i" (2), "0" (ret));
  }
#line 114
  return (ret);
  case_4: /* CIL Label */ 
  {
#line 115
  __asm__  volatile   ("661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xcb"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       "1:\tmov"
                       "l"
                       " %"
                       "k"
                       "1,%2\n"
                       "2: "
                       "661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xca"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       ".section .fixup,\"ax\"\n"
                       "3:\tmov %3,%0\n"
                       "\tjmp 2b\n"
                       ".previous\n"
                       " .pushsection \"__ex_table\",\"a\"\n"
                       " .balign 8\n"
                       " .long ("
                       "1b"
                       ") - .\n"
                       " .long ("
                       "3b"
                       ") - .\n"
                       " .popsection\n": "=r" (ret): "ir" (*((u32 *)src)), "m" (*((struct __large_struct *)((u32 *)dst))),
                       "i" (4), "0" (ret));
  }
#line 117
  return (ret);
  case_8: /* CIL Label */ 
  {
#line 118
  __asm__  volatile   ("661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xcb"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       "1:\tmov"
                       "q"
                       " %"
                       ""
                       "1,%2\n"
                       "2: "
                       "661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xca"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       ".section .fixup,\"ax\"\n"
                       "3:\tmov %3,%0\n"
                       "\tjmp 2b\n"
                       ".previous\n"
                       " .pushsection \"__ex_table\",\"a\"\n"
                       " .balign 8\n"
                       " .long ("
                       "1b"
                       ") - .\n"
                       " .long ("
                       "3b"
                       ") - .\n"
                       " .popsection\n": "=r" (ret): "er" (*((u64 *)src)), "m" (*((struct __large_struct *)((u64 *)dst))),
                       "i" (8), "0" (ret));
  }
#line 120
  return (ret);
  case_10: /* CIL Label */ 
  {
#line 122
  __asm__  volatile   ("661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xcb"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       "1:\tmov"
                       "q"
                       " %"
                       ""
                       "1,%2\n"
                       "2: "
                       "661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xca"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       ".section .fixup,\"ax\"\n"
                       "3:\tmov %3,%0\n"
                       "\tjmp 2b\n"
                       ".previous\n"
                       " .pushsection \"__ex_table\",\"a\"\n"
                       " .balign 8\n"
                       " .long ("
                       "1b"
                       ") - .\n"
                       " .long ("
                       "3b"
                       ") - .\n"
                       " .popsection\n": "=r" (ret): "er" (*((u64 *)src)), "m" (*((struct __large_struct *)((u64 *)dst))),
                       "i" (10), "0" (ret));
#line 124
  tmp___0 = __builtin_expect((long )(! (! ret)), 0L);
  }
#line 124
  if (tmp___0) {
#line 125
    return (ret);
  }
  {
#line 126
  __asm__  ("": : : "memory");
#line 127
  __asm__  volatile   ("661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xcb"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       "1:\tmov"
                       "w"
                       " %"
                       "w"
                       "1,%2\n"
                       "2: "
                       "661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xca"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       ".section .fixup,\"ax\"\n"
                       "3:\tmov %3,%0\n"
                       "\tjmp 2b\n"
                       ".previous\n"
                       " .pushsection \"__ex_table\",\"a\"\n"
                       " .balign 8\n"
                       " .long ("
                       "1b"
                       ") - .\n"
                       " .long ("
                       "3b"
                       ") - .\n"
                       " .popsection\n": "=r" (ret): "ir" (*((u16 *)src + 4)), "m" (*((struct __large_struct *)((u16 *)dst + 4))),
                       "i" (2), "0" (ret));
  }
#line 129
  return (ret);
  case_16: /* CIL Label */ 
  {
#line 131
  __asm__  volatile   ("661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xcb"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       "1:\tmov"
                       "q"
                       " %"
                       ""
                       "1,%2\n"
                       "2: "
                       "661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xca"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       ".section .fixup,\"ax\"\n"
                       "3:\tmov %3,%0\n"
                       "\tjmp 2b\n"
                       ".previous\n"
                       " .pushsection \"__ex_table\",\"a\"\n"
                       " .balign 8\n"
                       " .long ("
                       "1b"
                       ") - .\n"
                       " .long ("
                       "3b"
                       ") - .\n"
                       " .popsection\n": "=r" (ret): "er" (*((u64 *)src)), "m" (*((struct __large_struct *)((u64 *)dst))),
                       "i" (16), "0" (ret));
#line 133
  tmp___1 = __builtin_expect((long )(! (! ret)), 0L);
  }
#line 133
  if (tmp___1) {
#line 134
    return (ret);
  }
  {
#line 135
  __asm__  ("": : : "memory");
#line 136
  __asm__  volatile   ("661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xcb"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       "1:\tmov"
                       "q"
                       " %"
                       ""
                       "1,%2\n"
                       "2: "
                       "661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xca"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       ".section .fixup,\"ax\"\n"
                       "3:\tmov %3,%0\n"
                       "\tjmp 2b\n"
                       ".previous\n"
                       " .pushsection \"__ex_table\",\"a\"\n"
                       " .balign 8\n"
                       " .long ("
                       "1b"
                       ") - .\n"
                       " .long ("
                       "3b"
                       ") - .\n"
                       " .popsection\n": "=r" (ret): "er" (*((u64 *)src + 1)), "m" (*((struct __large_struct *)((u64 *)dst + 1))),
                       "i" (8), "0" (ret));
  }
#line 138
  return (ret);
  switch_default: /* CIL Label */ 
  {
#line 140
  tmp___2 = copy_user_generic(dst, src, size);
  }
#line 140
  return ((int )tmp___2);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 144
__inline static int ( __attribute__((__warn_unused_result__, __always_inline__)) __copy_to_user)(void *dst ,
                                                                                                 void const   *src ,
                                                                                                 unsigned int size )  __attribute__((__no_instrument_function__)) ;
#line 144 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/uaccess_64.h"
__inline static int ( __attribute__((__warn_unused_result__, __always_inline__)) __copy_to_user)(void *dst ,
                                                                                                 void const   *src ,
                                                                                                 unsigned int size ) 
{ 
  int tmp ;

  {
  {
#line 147
  might_fault();
#line 148
  tmp = __copy_to_user_nocheck(dst, src, size);
  }
#line 148
  return (tmp);
}
}
#line 151
__inline static int ( __attribute__((__warn_unused_result__, __always_inline__)) __copy_in_user)(void *dst ,
                                                                                                 void const   *src ,
                                                                                                 unsigned int size )  __attribute__((__no_instrument_function__)) ;
#line 151 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/uaccess_64.h"
__inline static int ( __attribute__((__warn_unused_result__, __always_inline__)) __copy_in_user)(void *dst ,
                                                                                                 void const   *src ,
                                                                                                 unsigned int size ) 
{ 
  int ret ;
  unsigned long tmp ;
  u8 tmp___0 ;
  long tmp___1 ;
  u16 tmp___2 ;
  long tmp___3 ;
  u32 tmp___4 ;
  long tmp___5 ;
  u64 tmp___6 ;
  long tmp___7 ;
  unsigned long tmp___8 ;

  {
  {
#line 154
  ret = 0;
#line 156
  might_fault();
#line 158
  tmp = copy_user_generic(dst, (void const   *)((void *)src), size);
  }
#line 158
  return ((int )tmp);
  {
#line 161
  if (size == 1U) {
#line 161
    goto case_1;
  }
#line 170
  if (size == 2U) {
#line 170
    goto case_2;
  }
#line 180
  if (size == 4U) {
#line 180
    goto case_4;
  }
#line 189
  if (size == 8U) {
#line 189
    goto case_8;
  }
#line 198
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 163
  __asm__  volatile   ("661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xcb"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       "1:\tmov"
                       "b"
                       " %2,%"
                       "b"
                       "1\n"
                       "2: "
                       "661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xca"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       ".section .fixup,\"ax\"\n"
                       "3:\tmov %3,%0\n"
                       "\txor"
                       "b"
                       " %"
                       "b"
                       "1,%"
                       "b"
                       "1\n"
                       "\tjmp 2b\n"
                       ".previous\n"
                       " .pushsection \"__ex_table\",\"a\"\n"
                       " .balign 8\n"
                       " .long ("
                       "1b"
                       ") - .\n"
                       " .long ("
                       "3b"
                       ") - .\n"
                       " .popsection\n": "=r" (ret), "=q" (tmp___0): "m" (*((struct __large_struct *)((u8 *)src))),
                       "i" (1), "0" (ret));
#line 165
  tmp___1 = __builtin_expect((long )(! (! (! ret))), 1L);
  }
#line 165
  if (tmp___1) {
    {
#line 166
    __asm__  volatile   ("661:\n\t"
                         ".byte "
                         "0x66,0x66,0x90"
                         "\n"
                         "\n662:\n"
                         ".pushsection .altinstructions,\"a\"\n"
                         " .long 661b - .\n"
                         " .long "
                         "663"
                         "1"
                         "f - .\n"
                         " .word "
                         "( 9*32+20)"
                         "\n"
                         " .byte "
                         "662b-661b"
                         "\n"
                         " .byte "
                         "664"
                         "1"
                         "f-"
                         "663"
                         "1"
                         "f"
                         "\n"
                         ".popsection\n"
                         ".pushsection .discard,\"aw\",@progbits\n"
                         " .byte 0xff + ("
                         "664"
                         "1"
                         "f-"
                         "663"
                         "1"
                         "f"
                         ") - ("
                         "662b-661b"
                         ")\n"
                         ".popsection\n"
                         ".pushsection .altinstr_replacement, \"ax\"\n"
                         "663"
                         "1"
                         ":\n\t"
                         ".byte 0x0f,0x01,0xcb"
                         "\n"
                         "664"
                         "1"
                         ":\n\t"
                         ".popsection"
                         "\n"
                         "1:\tmov"
                         "b"
                         " %"
                         "b"
                         "1,%2\n"
                         "2: "
                         "661:\n\t"
                         ".byte "
                         "0x66,0x66,0x90"
                         "\n"
                         "\n662:\n"
                         ".pushsection .altinstructions,\"a\"\n"
                         " .long 661b - .\n"
                         " .long "
                         "663"
                         "1"
                         "f - .\n"
                         " .word "
                         "( 9*32+20)"
                         "\n"
                         " .byte "
                         "662b-661b"
                         "\n"
                         " .byte "
                         "664"
                         "1"
                         "f-"
                         "663"
                         "1"
                         "f"
                         "\n"
                         ".popsection\n"
                         ".pushsection .discard,\"aw\",@progbits\n"
                         " .byte 0xff + ("
                         "664"
                         "1"
                         "f-"
                         "663"
                         "1"
                         "f"
                         ") - ("
                         "662b-661b"
                         ")\n"
                         ".popsection\n"
                         ".pushsection .altinstr_replacement, \"ax\"\n"
                         "663"
                         "1"
                         ":\n\t"
                         ".byte 0x0f,0x01,0xca"
                         "\n"
                         "664"
                         "1"
                         ":\n\t"
                         ".popsection"
                         "\n"
                         ".section .fixup,\"ax\"\n"
                         "3:\tmov %3,%0\n"
                         "\tjmp 2b\n"
                         ".previous\n"
                         " .pushsection \"__ex_table\",\"a\"\n"
                         " .balign 8\n"
                         " .long ("
                         "1b"
                         ") - .\n"
                         " .long ("
                         "3b"
                         ") - .\n"
                         " .popsection\n": "=r" (ret): "iq" (tmp___0), "m" (*((struct __large_struct *)((u8 *)dst))),
                         "i" (1), "0" (ret));
    }
  }
#line 168
  return (ret);
  case_2: /* CIL Label */ 
  {
#line 172
  __asm__  volatile   ("661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xcb"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       "1:\tmov"
                       "w"
                       " %2,%"
                       "w"
                       "1\n"
                       "2: "
                       "661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xca"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       ".section .fixup,\"ax\"\n"
                       "3:\tmov %3,%0\n"
                       "\txor"
                       "w"
                       " %"
                       "w"
                       "1,%"
                       "w"
                       "1\n"
                       "\tjmp 2b\n"
                       ".previous\n"
                       " .pushsection \"__ex_table\",\"a\"\n"
                       " .balign 8\n"
                       " .long ("
                       "1b"
                       ") - .\n"
                       " .long ("
                       "3b"
                       ") - .\n"
                       " .popsection\n": "=r" (ret), "=r" (tmp___2): "m" (*((struct __large_struct *)((u16 *)src))),
                       "i" (2), "0" (ret));
#line 174
  tmp___3 = __builtin_expect((long )(! (! (! ret))), 1L);
  }
#line 174
  if (tmp___3) {
    {
#line 175
    __asm__  volatile   ("661:\n\t"
                         ".byte "
                         "0x66,0x66,0x90"
                         "\n"
                         "\n662:\n"
                         ".pushsection .altinstructions,\"a\"\n"
                         " .long 661b - .\n"
                         " .long "
                         "663"
                         "1"
                         "f - .\n"
                         " .word "
                         "( 9*32+20)"
                         "\n"
                         " .byte "
                         "662b-661b"
                         "\n"
                         " .byte "
                         "664"
                         "1"
                         "f-"
                         "663"
                         "1"
                         "f"
                         "\n"
                         ".popsection\n"
                         ".pushsection .discard,\"aw\",@progbits\n"
                         " .byte 0xff + ("
                         "664"
                         "1"
                         "f-"
                         "663"
                         "1"
                         "f"
                         ") - ("
                         "662b-661b"
                         ")\n"
                         ".popsection\n"
                         ".pushsection .altinstr_replacement, \"ax\"\n"
                         "663"
                         "1"
                         ":\n\t"
                         ".byte 0x0f,0x01,0xcb"
                         "\n"
                         "664"
                         "1"
                         ":\n\t"
                         ".popsection"
                         "\n"
                         "1:\tmov"
                         "w"
                         " %"
                         "w"
                         "1,%2\n"
                         "2: "
                         "661:\n\t"
                         ".byte "
                         "0x66,0x66,0x90"
                         "\n"
                         "\n662:\n"
                         ".pushsection .altinstructions,\"a\"\n"
                         " .long 661b - .\n"
                         " .long "
                         "663"
                         "1"
                         "f - .\n"
                         " .word "
                         "( 9*32+20)"
                         "\n"
                         " .byte "
                         "662b-661b"
                         "\n"
                         " .byte "
                         "664"
                         "1"
                         "f-"
                         "663"
                         "1"
                         "f"
                         "\n"
                         ".popsection\n"
                         ".pushsection .discard,\"aw\",@progbits\n"
                         " .byte 0xff + ("
                         "664"
                         "1"
                         "f-"
                         "663"
                         "1"
                         "f"
                         ") - ("
                         "662b-661b"
                         ")\n"
                         ".popsection\n"
                         ".pushsection .altinstr_replacement, \"ax\"\n"
                         "663"
                         "1"
                         ":\n\t"
                         ".byte 0x0f,0x01,0xca"
                         "\n"
                         "664"
                         "1"
                         ":\n\t"
                         ".popsection"
                         "\n"
                         ".section .fixup,\"ax\"\n"
                         "3:\tmov %3,%0\n"
                         "\tjmp 2b\n"
                         ".previous\n"
                         " .pushsection \"__ex_table\",\"a\"\n"
                         " .balign 8\n"
                         " .long ("
                         "1b"
                         ") - .\n"
                         " .long ("
                         "3b"
                         ") - .\n"
                         " .popsection\n": "=r" (ret): "ir" (tmp___2), "m" (*((struct __large_struct *)((u16 *)dst))),
                         "i" (2), "0" (ret));
    }
  }
#line 177
  return (ret);
  case_4: /* CIL Label */ 
  {
#line 182
  __asm__  volatile   ("661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xcb"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       "1:\tmov"
                       "l"
                       " %2,%"
                       "k"
                       "1\n"
                       "2: "
                       "661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xca"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       ".section .fixup,\"ax\"\n"
                       "3:\tmov %3,%0\n"
                       "\txor"
                       "l"
                       " %"
                       "k"
                       "1,%"
                       "k"
                       "1\n"
                       "\tjmp 2b\n"
                       ".previous\n"
                       " .pushsection \"__ex_table\",\"a\"\n"
                       " .balign 8\n"
                       " .long ("
                       "1b"
                       ") - .\n"
                       " .long ("
                       "3b"
                       ") - .\n"
                       " .popsection\n": "=r" (ret), "=r" (tmp___4): "m" (*((struct __large_struct *)((u32 *)src))),
                       "i" (4), "0" (ret));
#line 184
  tmp___5 = __builtin_expect((long )(! (! (! ret))), 1L);
  }
#line 184
  if (tmp___5) {
    {
#line 185
    __asm__  volatile   ("661:\n\t"
                         ".byte "
                         "0x66,0x66,0x90"
                         "\n"
                         "\n662:\n"
                         ".pushsection .altinstructions,\"a\"\n"
                         " .long 661b - .\n"
                         " .long "
                         "663"
                         "1"
                         "f - .\n"
                         " .word "
                         "( 9*32+20)"
                         "\n"
                         " .byte "
                         "662b-661b"
                         "\n"
                         " .byte "
                         "664"
                         "1"
                         "f-"
                         "663"
                         "1"
                         "f"
                         "\n"
                         ".popsection\n"
                         ".pushsection .discard,\"aw\",@progbits\n"
                         " .byte 0xff + ("
                         "664"
                         "1"
                         "f-"
                         "663"
                         "1"
                         "f"
                         ") - ("
                         "662b-661b"
                         ")\n"
                         ".popsection\n"
                         ".pushsection .altinstr_replacement, \"ax\"\n"
                         "663"
                         "1"
                         ":\n\t"
                         ".byte 0x0f,0x01,0xcb"
                         "\n"
                         "664"
                         "1"
                         ":\n\t"
                         ".popsection"
                         "\n"
                         "1:\tmov"
                         "l"
                         " %"
                         "k"
                         "1,%2\n"
                         "2: "
                         "661:\n\t"
                         ".byte "
                         "0x66,0x66,0x90"
                         "\n"
                         "\n662:\n"
                         ".pushsection .altinstructions,\"a\"\n"
                         " .long 661b - .\n"
                         " .long "
                         "663"
                         "1"
                         "f - .\n"
                         " .word "
                         "( 9*32+20)"
                         "\n"
                         " .byte "
                         "662b-661b"
                         "\n"
                         " .byte "
                         "664"
                         "1"
                         "f-"
                         "663"
                         "1"
                         "f"
                         "\n"
                         ".popsection\n"
                         ".pushsection .discard,\"aw\",@progbits\n"
                         " .byte 0xff + ("
                         "664"
                         "1"
                         "f-"
                         "663"
                         "1"
                         "f"
                         ") - ("
                         "662b-661b"
                         ")\n"
                         ".popsection\n"
                         ".pushsection .altinstr_replacement, \"ax\"\n"
                         "663"
                         "1"
                         ":\n\t"
                         ".byte 0x0f,0x01,0xca"
                         "\n"
                         "664"
                         "1"
                         ":\n\t"
                         ".popsection"
                         "\n"
                         ".section .fixup,\"ax\"\n"
                         "3:\tmov %3,%0\n"
                         "\tjmp 2b\n"
                         ".previous\n"
                         " .pushsection \"__ex_table\",\"a\"\n"
                         " .balign 8\n"
                         " .long ("
                         "1b"
                         ") - .\n"
                         " .long ("
                         "3b"
                         ") - .\n"
                         " .popsection\n": "=r" (ret): "ir" (tmp___4), "m" (*((struct __large_struct *)((u32 *)dst))),
                         "i" (4), "0" (ret));
    }
  }
#line 187
  return (ret);
  case_8: /* CIL Label */ 
  {
#line 191
  __asm__  volatile   ("661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xcb"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       "1:\tmov"
                       "q"
                       " %2,%"
                       ""
                       "1\n"
                       "2: "
                       "661:\n\t"
                       ".byte "
                       "0x66,0x66,0x90"
                       "\n"
                       "\n662:\n"
                       ".pushsection .altinstructions,\"a\"\n"
                       " .long 661b - .\n"
                       " .long "
                       "663"
                       "1"
                       "f - .\n"
                       " .word "
                       "( 9*32+20)"
                       "\n"
                       " .byte "
                       "662b-661b"
                       "\n"
                       " .byte "
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       "\n"
                       ".popsection\n"
                       ".pushsection .discard,\"aw\",@progbits\n"
                       " .byte 0xff + ("
                       "664"
                       "1"
                       "f-"
                       "663"
                       "1"
                       "f"
                       ") - ("
                       "662b-661b"
                       ")\n"
                       ".popsection\n"
                       ".pushsection .altinstr_replacement, \"ax\"\n"
                       "663"
                       "1"
                       ":\n\t"
                       ".byte 0x0f,0x01,0xca"
                       "\n"
                       "664"
                       "1"
                       ":\n\t"
                       ".popsection"
                       "\n"
                       ".section .fixup,\"ax\"\n"
                       "3:\tmov %3,%0\n"
                       "\txor"
                       "q"
                       " %"
                       ""
                       "1,%"
                       ""
                       "1\n"
                       "\tjmp 2b\n"
                       ".previous\n"
                       " .pushsection \"__ex_table\",\"a\"\n"
                       " .balign 8\n"
                       " .long ("
                       "1b"
                       ") - .\n"
                       " .long ("
                       "3b"
                       ") - .\n"
                       " .popsection\n": "=r" (ret), "=r" (tmp___6): "m" (*((struct __large_struct *)((u64 *)src))),
                       "i" (8), "0" (ret));
#line 193
  tmp___7 = __builtin_expect((long )(! (! (! ret))), 1L);
  }
#line 193
  if (tmp___7) {
    {
#line 194
    __asm__  volatile   ("661:\n\t"
                         ".byte "
                         "0x66,0x66,0x90"
                         "\n"
                         "\n662:\n"
                         ".pushsection .altinstructions,\"a\"\n"
                         " .long 661b - .\n"
                         " .long "
                         "663"
                         "1"
                         "f - .\n"
                         " .word "
                         "( 9*32+20)"
                         "\n"
                         " .byte "
                         "662b-661b"
                         "\n"
                         " .byte "
                         "664"
                         "1"
                         "f-"
                         "663"
                         "1"
                         "f"
                         "\n"
                         ".popsection\n"
                         ".pushsection .discard,\"aw\",@progbits\n"
                         " .byte 0xff + ("
                         "664"
                         "1"
                         "f-"
                         "663"
                         "1"
                         "f"
                         ") - ("
                         "662b-661b"
                         ")\n"
                         ".popsection\n"
                         ".pushsection .altinstr_replacement, \"ax\"\n"
                         "663"
                         "1"
                         ":\n\t"
                         ".byte 0x0f,0x01,0xcb"
                         "\n"
                         "664"
                         "1"
                         ":\n\t"
                         ".popsection"
                         "\n"
                         "1:\tmov"
                         "q"
                         " %"
                         ""
                         "1,%2\n"
                         "2: "
                         "661:\n\t"
                         ".byte "
                         "0x66,0x66,0x90"
                         "\n"
                         "\n662:\n"
                         ".pushsection .altinstructions,\"a\"\n"
                         " .long 661b - .\n"
                         " .long "
                         "663"
                         "1"
                         "f - .\n"
                         " .word "
                         "( 9*32+20)"
                         "\n"
                         " .byte "
                         "662b-661b"
                         "\n"
                         " .byte "
                         "664"
                         "1"
                         "f-"
                         "663"
                         "1"
                         "f"
                         "\n"
                         ".popsection\n"
                         ".pushsection .discard,\"aw\",@progbits\n"
                         " .byte 0xff + ("
                         "664"
                         "1"
                         "f-"
                         "663"
                         "1"
                         "f"
                         ") - ("
                         "662b-661b"
                         ")\n"
                         ".popsection\n"
                         ".pushsection .altinstr_replacement, \"ax\"\n"
                         "663"
                         "1"
                         ":\n\t"
                         ".byte 0x0f,0x01,0xca"
                         "\n"
                         "664"
                         "1"
                         ":\n\t"
                         ".popsection"
                         "\n"
                         ".section .fixup,\"ax\"\n"
                         "3:\tmov %3,%0\n"
                         "\tjmp 2b\n"
                         ".previous\n"
                         " .pushsection \"__ex_table\",\"a\"\n"
                         " .balign 8\n"
                         " .long ("
                         "1b"
                         ") - .\n"
                         " .long ("
                         "3b"
                         ") - .\n"
                         " .popsection\n": "=r" (ret): "er" (tmp___6), "m" (*((struct __large_struct *)((u64 *)dst))),
                         "i" (8), "0" (ret));
    }
  }
#line 196
  return (ret);
  switch_default: /* CIL Label */ 
  {
#line 199
  tmp___8 = copy_user_generic(dst, (void const   *)((void *)src), size);
  }
#line 199
  return ((int )tmp___8);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 204
__inline static int ( __attribute__((__warn_unused_result__, __always_inline__)) __copy_from_user_inatomic)(void *dst ,
                                                                                                            void const   *src ,
                                                                                                            unsigned int size )  __attribute__((__no_instrument_function__)) ;
#line 204 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/uaccess_64.h"
__inline static int ( __attribute__((__warn_unused_result__, __always_inline__)) __copy_from_user_inatomic)(void *dst ,
                                                                                                            void const   *src ,
                                                                                                            unsigned int size ) 
{ 
  int tmp ;

  {
  {
#line 207
  tmp = __copy_from_user_nocheck(dst, src, size);
  }
#line 207
  return (tmp);
}
}
#line 210
__inline static int ( __attribute__((__warn_unused_result__, __always_inline__)) __copy_to_user_inatomic)(void *dst ,
                                                                                                          void const   *src ,
                                                                                                          unsigned int size )  __attribute__((__no_instrument_function__)) ;
#line 210 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/uaccess_64.h"
__inline static int ( __attribute__((__warn_unused_result__, __always_inline__)) __copy_to_user_inatomic)(void *dst ,
                                                                                                          void const   *src ,
                                                                                                          unsigned int size ) 
{ 
  int tmp ;

  {
  {
#line 213
  tmp = __copy_to_user_nocheck(dst, src, size);
  }
#line 213
  return (tmp);
}
}
#line 216
extern long __copy_user_nocache(void *dst , void const   *src , unsigned int size ,
                                int zerorest ) ;
#line 219
__inline static int __copy_from_user_nocache(void *dst , void const   *src , unsigned int size )  __attribute__((__no_instrument_function__)) ;
#line 219 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/uaccess_64.h"
__inline static int __copy_from_user_nocache(void *dst , void const   *src , unsigned int size ) 
{ 
  long tmp ;

  {
  {
#line 222
  might_fault();
#line 223
  tmp = __copy_user_nocache(dst, src, size, 1);
  }
#line 223
  return ((int )tmp);
}
}
#line 226
__inline static int __copy_from_user_inatomic_nocache(void *dst , void const   *src ,
                                                      unsigned int size )  __attribute__((__no_instrument_function__)) ;
#line 226 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/uaccess_64.h"
__inline static int __copy_from_user_inatomic_nocache(void *dst , void const   *src ,
                                                      unsigned int size ) 
{ 
  long tmp ;

  {
  {
#line 230
  tmp = __copy_user_nocache(dst, src, size, 0);
  }
#line 230
  return ((int )tmp);
}
}
#line 233
extern unsigned long copy_user_handle_tail(char *to , char *from , unsigned int len ,
                                           unsigned int zerorest ) ;
#line 645 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/uaccess.h"
extern unsigned long ( __attribute__((__warn_unused_result__)) _copy_from_user)(void *to ,
                                                                                void const   *from ,
                                                                                unsigned int n ) ;
#line 647
extern unsigned long ( __attribute__((__warn_unused_result__)) _copy_to_user)(void *to ,
                                                                              void const   *from ,
                                                                              unsigned int n ) ;
#line 656
extern void __attribute__((__warning__("copy_from_user() buffer size is too small")))  copy_from_user_overflow(void) ;
#line 658
extern void __attribute__((__warning__("copy_to_user() buffer size is too small")))  copy_to_user_overflow(void)  __asm__("copy_from_user_overflow")  ;
#line 677
__inline static void __copy_from_user_overflow(int size , unsigned long count )  __attribute__((__no_instrument_function__)) ;
#line 677 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/uaccess.h"
__inline static void __copy_from_user_overflow(int size , unsigned long count ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
  {
#line 680
  __ret_warn_on = 1;
#line 680
  tmp = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
  }
#line 680
  if (tmp) {
    {
#line 680
    warn_slowpath_fmt("../../../analyzer/../bench/linux-headers/arch/x86/include/asm/uaccess.h",
                      (int const   )680, "Buffer overflow detected (%d < %lu)!\n",
                      size, count);
    }
  }
  {
#line 680
  __builtin_expect((long )(! (! __ret_warn_on)), 0L);
  }
#line 681
  return;
}
}
#line 687
__inline static unsigned long ( __attribute__((__warn_unused_result__)) copy_from_user)(void *to ,
                                                                                        void const   *from ,
                                                                                        unsigned long n )  __attribute__((__no_instrument_function__)) ;
#line 687 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/uaccess.h"
__inline static unsigned long ( __attribute__((__warn_unused_result__)) copy_from_user)(void *to ,
                                                                                        void const   *from ,
                                                                                        unsigned long n ) 
{ 
  int sz ;
  int tmp ;
  long tmp___0 ;

  {
  {
#line 690
  sz = -1;
#line 692
  might_fault();
  }
#line 712
  if (sz < 0) {
    {
#line 712
    tmp = 1;
    }
  } else
#line 712
  if ((unsigned long )sz >= n) {
    {
#line 712
    tmp = 1;
    }
  } else {
    {
#line 712
    tmp = 0;
    }
  }
  {
#line 712
  tmp___0 = __builtin_expect((long )tmp, 1L);
  }
#line 712
  if (tmp___0) {
    {
#line 713
    n = _copy_from_user(to, from, (unsigned int )n);
    }
  } else {
    {
#line 717
    __copy_from_user_overflow(sz, n);
    }
  }
#line 719
  return (n);
}
}
#line 722
__inline static unsigned long ( __attribute__((__warn_unused_result__)) copy_to_user)(void *to ,
                                                                                      void const   *from ,
                                                                                      unsigned long n )  __attribute__((__no_instrument_function__)) ;
#line 722 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/uaccess.h"
__inline static unsigned long ( __attribute__((__warn_unused_result__)) copy_to_user)(void *to ,
                                                                                      void const   *from ,
                                                                                      unsigned long n ) 
{ 
  int sz ;
  int tmp ;
  long tmp___0 ;

  {
  {
#line 725
  sz = -1;
#line 727
  might_fault();
  }
#line 730
  if (sz < 0) {
    {
#line 730
    tmp = 1;
    }
  } else
#line 730
  if ((unsigned long )sz >= n) {
    {
#line 730
    tmp = 1;
    }
  } else {
    {
#line 730
    tmp = 0;
    }
  }
  {
#line 730
  tmp___0 = __builtin_expect((long )tmp, 1L);
  }
#line 730
  if (tmp___0) {
    {
#line 731
    n = _copy_to_user(to, from, (unsigned int )n);
    }
  } else {
    {
#line 735
    __copy_from_user_overflow(sz, n);
    }
  }
#line 737
  return (n);
}
}
#line 7 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/sections.h"
extern char __brk_base[] ;
#line 7
extern char __brk_limit[] ;
#line 8
extern struct exception_table_entry __stop___ex_table[] ;
#line 11
extern char __end_rodata_hpage_align[] ;
#line 29 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/hw_irq.h"
extern void apic_timer_interrupt(void) ;
#line 30
extern void x86_platform_ipi(void) ;
#line 31
extern void kvm_posted_intr_ipi(void) ;
#line 32
extern void error_interrupt(void) ;
#line 33
extern void irq_work_interrupt(void) ;
#line 35
extern void spurious_interrupt(void) ;
#line 36
extern void thermal_interrupt(void) ;
#line 37
extern void reschedule_interrupt(void) ;
#line 39
extern void invalidate_interrupt(void) ;
#line 40
extern void invalidate_interrupt0(void) ;
#line 41
extern void invalidate_interrupt1(void) ;
#line 42
extern void invalidate_interrupt2(void) ;
#line 43
extern void invalidate_interrupt3(void) ;
#line 44
extern void invalidate_interrupt4(void) ;
#line 45
extern void invalidate_interrupt5(void) ;
#line 46
extern void invalidate_interrupt6(void) ;
#line 47
extern void invalidate_interrupt7(void) ;
#line 48
extern void invalidate_interrupt8(void) ;
#line 49
extern void invalidate_interrupt9(void) ;
#line 50
extern void invalidate_interrupt10(void) ;
#line 51
extern void invalidate_interrupt11(void) ;
#line 52
extern void invalidate_interrupt12(void) ;
#line 53
extern void invalidate_interrupt13(void) ;
#line 54
extern void invalidate_interrupt14(void) ;
#line 55
extern void invalidate_interrupt15(void) ;
#line 56
extern void invalidate_interrupt16(void) ;
#line 57
extern void invalidate_interrupt17(void) ;
#line 58
extern void invalidate_interrupt18(void) ;
#line 59
extern void invalidate_interrupt19(void) ;
#line 60
extern void invalidate_interrupt20(void) ;
#line 61
extern void invalidate_interrupt21(void) ;
#line 62
extern void invalidate_interrupt22(void) ;
#line 63
extern void invalidate_interrupt23(void) ;
#line 64
extern void invalidate_interrupt24(void) ;
#line 65
extern void invalidate_interrupt25(void) ;
#line 66
extern void invalidate_interrupt26(void) ;
#line 67
extern void invalidate_interrupt27(void) ;
#line 68
extern void invalidate_interrupt28(void) ;
#line 69
extern void invalidate_interrupt29(void) ;
#line 70
extern void invalidate_interrupt30(void) ;
#line 71
extern void invalidate_interrupt31(void) ;
#line 73
extern void irq_move_cleanup_interrupt(void) ;
#line 74
extern void reboot_interrupt(void) ;
#line 75
extern void threshold_interrupt(void) ;
#line 77
extern void call_function_interrupt(void) ;
#line 78
extern void call_function_single_interrupt(void) ;
#line 82
extern void trace_apic_timer_interrupt(void) ;
#line 83
extern void trace_x86_platform_ipi(void) ;
#line 84
extern void trace_error_interrupt(void) ;
#line 85
extern void trace_irq_work_interrupt(void) ;
#line 86
extern void trace_spurious_interrupt(void) ;
#line 87
extern void trace_thermal_interrupt(void) ;
#line 88
extern void trace_reschedule_interrupt(void) ;
#line 89
extern void trace_threshold_interrupt(void) ;
#line 90
extern void trace_call_function_interrupt(void) ;
#line 91
extern void trace_call_function_single_interrupt(void) ;
#line 99
extern unsigned long io_apic_irqs ;
#line 101
extern void setup_IO_APIC(void) ;
#line 102
extern void disable_IO_APIC(void) ;
#line 111
__inline static void set_io_apic_irq_attr(struct io_apic_irq_attr *irq_attr , int ioapic ,
                                          int ioapic_pin , int trigger , int polarity )  __attribute__((__no_instrument_function__)) ;
#line 111 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/hw_irq.h"
__inline static void set_io_apic_irq_attr(struct io_apic_irq_attr *irq_attr , int ioapic ,
                                          int ioapic_pin , int trigger , int polarity ) 
{ 


  {
  {
#line 115
  irq_attr->ioapic = ioapic;
#line 116
  irq_attr->ioapic_pin = ioapic_pin;
#line 117
  irq_attr->trigger = trigger;
#line 118
  irq_attr->polarity = polarity;
  }
#line 119
  return;
}
}
#line 155
extern int assign_irq_vector(int  , struct irq_cfg * , struct cpumask  const  * ) ;
#line 156
extern void send_cleanup_vector(struct irq_cfg * ) ;
#line 159
extern int __ioapic_set_affinity(struct irq_data * , struct cpumask  const  * , unsigned int *dest_id ) ;
#line 161
extern int IO_APIC_get_PCI_irq_vector(int bus , int devfn , int pin , struct io_apic_irq_attr *irq_attr ) ;
#line 162
extern void setup_ioapic_dest(void) ;
#line 164
extern void enable_IO_APIC(void) ;
#line 167
extern atomic_t irq_err_count ;
#line 168
extern atomic_t irq_mis_count ;
#line 171
extern void eisa_set_level_irq(unsigned int irq ) ;
#line 174
extern void __attribute__((__externally_visible__))  smp_apic_timer_interrupt(struct pt_regs * ) ;
#line 175
extern void __attribute__((__externally_visible__))  smp_spurious_interrupt(struct pt_regs * ) ;
#line 176
extern void __attribute__((__externally_visible__))  smp_x86_platform_ipi(struct pt_regs * ) ;
#line 177
extern void __attribute__((__externally_visible__))  smp_error_interrupt(struct pt_regs * ) ;
#line 179
extern void smp_irq_move_cleanup_interrupt(void) ;
#line 182
extern void __attribute__((__externally_visible__))  smp_reschedule_interrupt(struct pt_regs * ) ;
#line 183
extern void __attribute__((__externally_visible__))  smp_call_function_interrupt(struct pt_regs * ) ;
#line 184
extern void __attribute__((__externally_visible__))  smp_call_function_single_interrupt(struct pt_regs * ) ;
#line 185
extern void __attribute__((__externally_visible__))  smp_invalidate_interrupt(struct pt_regs * ) ;
#line 188
extern void (*interrupt[224])(void)  __attribute__((__section__(".init.rodata"))) ;
#line 197
extern vector_irq_t vector_irq  __attribute__((__section__(".data..percpu"))) ;
#line 198
extern void setup_vector_irq(int cpu ) ;
#line 201
extern void lock_vector_lock(void) ;
#line 202
extern void unlock_vector_lock(void) ;
#line 203
extern void __setup_vector_irq(int cpu ) ;
#line 390 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
extern int setup_irq(unsigned int irq , struct irqaction *new ) ;
#line 391
extern void remove_irq(unsigned int irq , struct irqaction *act ) ;
#line 392
extern int setup_percpu_irq(unsigned int irq , struct irqaction *new ) ;
#line 393
extern void remove_percpu_irq(unsigned int irq , struct irqaction *act ) ;
#line 395
extern void irq_cpu_online(void) ;
#line 396
extern void irq_cpu_offline(void) ;
#line 397
extern int irq_set_affinity_locked(struct irq_data *data , struct cpumask  const  *cpumask ,
                                   bool force ) ;
#line 401
extern void irq_move_irq(struct irq_data *data ) ;
#line 402
extern void irq_move_masked_irq(struct irq_data *data ) ;
#line 408
extern int no_irq_affinity ;
#line 413
__inline static int irq_set_parent(int irq , int parent_irq )  __attribute__((__no_instrument_function__)) ;
#line 413 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static int irq_set_parent(int irq , int parent_irq ) 
{ 


  {
#line 415
  return (0);
}
}
#line 423
extern void handle_level_irq(unsigned int irq , struct irq_desc *desc ) ;
#line 424
extern void handle_fasteoi_irq(unsigned int irq , struct irq_desc *desc ) ;
#line 425
extern void handle_edge_irq(unsigned int irq , struct irq_desc *desc ) ;
#line 426
extern void handle_edge_eoi_irq(unsigned int irq , struct irq_desc *desc ) ;
#line 427
extern void handle_simple_irq(unsigned int irq , struct irq_desc *desc ) ;
#line 428
extern void handle_percpu_irq(unsigned int irq , struct irq_desc *desc ) ;
#line 429
extern void handle_percpu_devid_irq(unsigned int irq , struct irq_desc *desc ) ;
#line 430
extern void handle_bad_irq(unsigned int irq , struct irq_desc *desc ) ;
#line 431
extern void handle_nested_irq(unsigned int irq ) ;
#line 434
extern void note_interrupt(unsigned int irq , struct irq_desc *desc , irqreturn_t action_ret ) ;
#line 439
extern int noirqdebug_setup(char *str ) ;
#line 442
extern int can_request_irq(unsigned int irq , unsigned long irqflags ) ;
#line 445
extern struct irq_chip no_irq_chip ;
#line 446
extern struct irq_chip dummy_irq_chip ;
#line 448
extern void irq_set_chip_and_handler_name(unsigned int irq , struct irq_chip *chip ,
                                          void (*handle)(unsigned int irq , struct irq_desc *desc ) ,
                                          char const   *name ) ;
#line 452
__inline static void irq_set_chip_and_handler(unsigned int irq , struct irq_chip *chip ,
                                              void (*handle)(unsigned int irq , struct irq_desc *desc ) )  __attribute__((__no_instrument_function__)) ;
#line 452 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static void irq_set_chip_and_handler(unsigned int irq , struct irq_chip *chip ,
                                              void (*handle)(unsigned int irq , struct irq_desc *desc ) ) 
{ 


  {
  {
#line 455
  irq_set_chip_and_handler_name(irq, chip, handle, (char const   *)((void *)0));
  }
#line 456
  return;
}
}
#line 458
extern int irq_set_percpu_devid(unsigned int irq ) ;
#line 460
extern void __irq_set_handler(unsigned int irq , void (*handle)(unsigned int irq ,
                                                                struct irq_desc *desc ) ,
                              int is_chained , char const   *name ) ;
#line 464
__inline static void irq_set_handler(unsigned int irq , void (*handle)(unsigned int irq ,
                                                                       struct irq_desc *desc ) )  __attribute__((__no_instrument_function__)) ;
#line 464 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static void irq_set_handler(unsigned int irq , void (*handle)(unsigned int irq ,
                                                                       struct irq_desc *desc ) ) 
{ 


  {
  {
#line 467
  __irq_set_handler(irq, handle, 0, (char const   *)((void *)0));
  }
#line 468
  return;
}
}
#line 475
__inline static void irq_set_chained_handler(unsigned int irq , void (*handle)(unsigned int irq ,
                                                                               struct irq_desc *desc ) )  __attribute__((__no_instrument_function__)) ;
#line 475 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static void irq_set_chained_handler(unsigned int irq , void (*handle)(unsigned int irq ,
                                                                               struct irq_desc *desc ) ) 
{ 


  {
  {
#line 478
  __irq_set_handler(irq, handle, 1, (char const   *)((void *)0));
  }
#line 479
  return;
}
}
#line 481
extern void irq_modify_status(unsigned int irq , unsigned long clr , unsigned long set ) ;
#line 483
__inline static void irq_set_status_flags(unsigned int irq , unsigned long set )  __attribute__((__no_instrument_function__)) ;
#line 483 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static void irq_set_status_flags(unsigned int irq , unsigned long set ) 
{ 


  {
  {
#line 485
  irq_modify_status(irq, 0UL, set);
  }
#line 486
  return;
}
}
#line 488
__inline static void irq_clear_status_flags(unsigned int irq , unsigned long clr )  __attribute__((__no_instrument_function__)) ;
#line 488 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static void irq_clear_status_flags(unsigned int irq , unsigned long clr ) 
{ 


  {
  {
#line 490
  irq_modify_status(irq, clr, 0UL);
  }
#line 491
  return;
}
}
#line 493
__inline static void irq_set_noprobe(unsigned int irq )  __attribute__((__no_instrument_function__)) ;
#line 493 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static void irq_set_noprobe(unsigned int irq ) 
{ 


  {
  {
#line 495
  irq_modify_status(irq, 0UL, 1024UL);
  }
#line 496
  return;
}
}
#line 498
__inline static void irq_set_probe(unsigned int irq )  __attribute__((__no_instrument_function__)) ;
#line 498 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static void irq_set_probe(unsigned int irq ) 
{ 


  {
  {
#line 500
  irq_modify_status(irq, 1024UL, 0UL);
  }
#line 501
  return;
}
}
#line 503
__inline static void irq_set_nothread(unsigned int irq )  __attribute__((__no_instrument_function__)) ;
#line 503 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static void irq_set_nothread(unsigned int irq ) 
{ 


  {
  {
#line 505
  irq_modify_status(irq, 0UL, 65536UL);
  }
#line 506
  return;
}
}
#line 508
__inline static void irq_set_thread(unsigned int irq )  __attribute__((__no_instrument_function__)) ;
#line 508 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static void irq_set_thread(unsigned int irq ) 
{ 


  {
  {
#line 510
  irq_modify_status(irq, 65536UL, 0UL);
  }
#line 511
  return;
}
}
#line 513
__inline static void irq_set_nested_thread(unsigned int irq , bool nest )  __attribute__((__no_instrument_function__)) ;
#line 513 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static void irq_set_nested_thread(unsigned int irq , bool nest ) 
{ 


  {
#line 515
  if (nest) {
    {
#line 516
    irq_set_status_flags(irq, 32768UL);
    }
  } else {
    {
#line 518
    irq_clear_status_flags(irq, 32768UL);
    }
  }
#line 519
  return;
}
}
#line 521
__inline static void irq_set_percpu_devid_flags(unsigned int irq )  __attribute__((__no_instrument_function__)) ;
#line 521 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static void irq_set_percpu_devid_flags(unsigned int irq ) 
{ 


  {
  {
#line 523
  irq_set_status_flags(irq, 202240UL);
  }
#line 526
  return;
}
}
#line 529
extern int irq_set_chip(unsigned int irq , struct irq_chip *chip ) ;
#line 530
extern int irq_set_handler_data(unsigned int irq , void *data ) ;
#line 531
extern int irq_set_chip_data(unsigned int irq , void *data ) ;
#line 532
extern int irq_set_irq_type(unsigned int irq , unsigned int type ) ;
#line 533
extern int irq_set_msi_desc(unsigned int irq , struct msi_desc *entry ) ;
#line 534
extern int irq_set_msi_desc_off(unsigned int irq_base , unsigned int irq_offset ,
                                struct msi_desc *entry ) ;
#line 536
extern struct irq_data *irq_get_irq_data(unsigned int irq ) ;
#line 538
__inline static struct irq_chip *irq_get_chip(unsigned int irq )  __attribute__((__no_instrument_function__)) ;
#line 538 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static struct irq_chip *irq_get_chip(unsigned int irq ) 
{ 
  struct irq_data *d ;
  struct irq_data *tmp ;
  struct irq_chip *tmp___0 ;

  {
  {
#line 540
  tmp = irq_get_irq_data(irq);
#line 540
  d = tmp;
  }
#line 541
  if (d) {
    {
#line 541
    tmp___0 = d->chip;
    }
  } else {
    {
#line 541
    tmp___0 = (struct irq_chip *)((void *)0);
    }
  }
#line 541
  return (tmp___0);
}
}
#line 544
__inline static struct irq_chip *irq_data_get_irq_chip(struct irq_data *d )  __attribute__((__no_instrument_function__)) ;
#line 544 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static struct irq_chip *irq_data_get_irq_chip(struct irq_data *d ) 
{ 


  {
#line 546
  return (d->chip);
}
}
#line 549
__inline static void *irq_get_chip_data(unsigned int irq )  __attribute__((__no_instrument_function__)) ;
#line 549 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static void *irq_get_chip_data(unsigned int irq ) 
{ 
  struct irq_data *d ;
  struct irq_data *tmp ;
  void *tmp___0 ;

  {
  {
#line 551
  tmp = irq_get_irq_data(irq);
#line 551
  d = tmp;
  }
#line 552
  if (d) {
    {
#line 552
    tmp___0 = d->chip_data;
    }
  } else {
    {
#line 552
    tmp___0 = (void *)0;
    }
  }
#line 552
  return (tmp___0);
}
}
#line 555
__inline static void *irq_data_get_irq_chip_data(struct irq_data *d )  __attribute__((__no_instrument_function__)) ;
#line 555 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static void *irq_data_get_irq_chip_data(struct irq_data *d ) 
{ 


  {
#line 557
  return (d->chip_data);
}
}
#line 560
__inline static void *irq_get_handler_data(unsigned int irq )  __attribute__((__no_instrument_function__)) ;
#line 560 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static void *irq_get_handler_data(unsigned int irq ) 
{ 
  struct irq_data *d ;
  struct irq_data *tmp ;
  void *tmp___0 ;

  {
  {
#line 562
  tmp = irq_get_irq_data(irq);
#line 562
  d = tmp;
  }
#line 563
  if (d) {
    {
#line 563
    tmp___0 = d->handler_data;
    }
  } else {
    {
#line 563
    tmp___0 = (void *)0;
    }
  }
#line 563
  return (tmp___0);
}
}
#line 566
__inline static void *irq_data_get_irq_handler_data(struct irq_data *d )  __attribute__((__no_instrument_function__)) ;
#line 566 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static void *irq_data_get_irq_handler_data(struct irq_data *d ) 
{ 


  {
#line 568
  return (d->handler_data);
}
}
#line 571
__inline static struct msi_desc *irq_get_msi_desc(unsigned int irq )  __attribute__((__no_instrument_function__)) ;
#line 571 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static struct msi_desc *irq_get_msi_desc(unsigned int irq ) 
{ 
  struct irq_data *d ;
  struct irq_data *tmp ;
  struct msi_desc *tmp___0 ;

  {
  {
#line 573
  tmp = irq_get_irq_data(irq);
#line 573
  d = tmp;
  }
#line 574
  if (d) {
    {
#line 574
    tmp___0 = d->msi_desc;
    }
  } else {
    {
#line 574
    tmp___0 = (struct msi_desc *)((void *)0);
    }
  }
#line 574
  return (tmp___0);
}
}
#line 577
__inline static struct msi_desc *irq_data_get_msi(struct irq_data *d )  __attribute__((__no_instrument_function__)) ;
#line 577 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static struct msi_desc *irq_data_get_msi(struct irq_data *d ) 
{ 


  {
#line 579
  return (d->msi_desc);
}
}
#line 582
__inline static u32 irq_get_trigger_type(unsigned int irq )  __attribute__((__no_instrument_function__)) ;
#line 582 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static u32 irq_get_trigger_type(unsigned int irq ) 
{ 
  struct irq_data *d ;
  struct irq_data *tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;

  {
  {
#line 584
  tmp = irq_get_irq_data(irq);
#line 584
  d = tmp;
  }
#line 585
  if (d) {
    {
#line 585
    tmp___0 = irqd_get_trigger_type(d);
#line 585
    tmp___1 = tmp___0;
    }
  } else {
    {
#line 585
    tmp___1 = (u32 )0;
    }
  }
#line 585
  return (tmp___1);
}
}
#line 588
extern unsigned int arch_dynirq_lower_bound(unsigned int from ) ;
#line 590
extern int __irq_alloc_descs(int irq , unsigned int from , unsigned int cnt , int node ,
                             struct module *owner ) ;
#line 609
extern void irq_free_descs(unsigned int irq , unsigned int cnt ) ;
#line 610
__inline static void irq_free_desc(unsigned int irq )  __attribute__((__no_instrument_function__)) ;
#line 610 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static void irq_free_desc(unsigned int irq ) 
{ 


  {
  {
#line 612
  irq_free_descs(irq, 1U);
  }
#line 613
  return;
}
}
#line 616
extern unsigned int irq_alloc_hwirqs(int cnt , int node ) ;
#line 617
__inline static unsigned int irq_alloc_hwirq(int node )  __attribute__((__no_instrument_function__)) ;
#line 617 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static unsigned int irq_alloc_hwirq(int node ) 
{ 
  unsigned int tmp ;

  {
  {
#line 619
  tmp = irq_alloc_hwirqs(1, node);
  }
#line 619
  return (tmp);
}
}
#line 621
extern void irq_free_hwirqs(unsigned int from , int cnt ) ;
#line 622
__inline static void irq_free_hwirq(unsigned int irq )  __attribute__((__no_instrument_function__)) ;
#line 622 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static void irq_free_hwirq(unsigned int irq ) 
{ 


  {
  {
#line 624
  irq_free_hwirqs(irq, 1);
  }
#line 624
  return;
}
}
#line 626
extern int arch_setup_hwirq(unsigned int irq , int node ) ;
#line 627
extern void arch_teardown_hwirq(unsigned int irq ) ;
#line 762
extern void irq_gc_noop(struct irq_data *d ) ;
#line 763
extern void irq_gc_mask_disable_reg(struct irq_data *d ) ;
#line 764
extern void irq_gc_mask_set_bit(struct irq_data *d ) ;
#line 765
extern void irq_gc_mask_clr_bit(struct irq_data *d ) ;
#line 766
extern void irq_gc_unmask_enable_reg(struct irq_data *d ) ;
#line 767
extern void irq_gc_ack_set_bit(struct irq_data *d ) ;
#line 768
extern void irq_gc_ack_clr_bit(struct irq_data *d ) ;
#line 769
extern void irq_gc_mask_disable_reg_and_ack(struct irq_data *d ) ;
#line 770
extern void irq_gc_eoi(struct irq_data *d ) ;
#line 771
extern int irq_gc_set_wake(struct irq_data *d , unsigned int on ) ;
#line 774
extern int irq_map_generic_chip(struct irq_domain *d , unsigned int virq , irq_hw_number_t hw_irq ) ;
#line 776
extern struct irq_chip_generic *irq_alloc_generic_chip(char const   *name , int nr_ct ,
                                                       unsigned int irq_base , void *reg_base ,
                                                       void (*handler)(unsigned int irq ,
                                                                       struct irq_desc *desc ) ) ;
#line 779
extern void irq_setup_generic_chip(struct irq_chip_generic *gc , u32 msk , enum irq_gc_flags flags ,
                                   unsigned int clr , unsigned int set ) ;
#line 782
extern int irq_setup_alt_chip(struct irq_data *d , unsigned int type ) ;
#line 783
extern void irq_remove_generic_chip(struct irq_chip_generic *gc , u32 msk , unsigned int clr ,
                                    unsigned int set ) ;
#line 786
extern struct irq_chip_generic *irq_get_domain_generic_chip(struct irq_domain *d ,
                                                            unsigned int hw_irq ) ;
#line 787
extern int irq_alloc_domain_generic_chips(struct irq_domain *d , int irqs_per_chip ,
                                          int num_ct , char const   *name , void (*handler)(unsigned int irq ,
                                                                                            struct irq_desc *desc ) ,
                                          unsigned int clr , unsigned int set , enum irq_gc_flags flags ) ;
#line 794
__inline static struct irq_chip_type *irq_data_get_chip_type(struct irq_data *d )  __attribute__((__no_instrument_function__)) ;
#line 794 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static struct irq_chip_type *irq_data_get_chip_type(struct irq_data *d ) 
{ 
  struct irq_chip  const  *__mptr ;

  {
  {
#line 796
  __mptr = (struct irq_chip  const  *)d->chip;
  }
#line 796
  return ((struct irq_chip_type *)((char *)__mptr - (unsigned long )(& ((struct irq_chip_type *)0)->chip)));
}
}
#line 802
__inline static void irq_gc_lock(struct irq_chip_generic *gc )  __attribute__((__no_instrument_function__)) ;
#line 802 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static void irq_gc_lock(struct irq_chip_generic *gc ) 
{ 


  {
  {
#line 804
  _raw_spin_lock(& gc->lock);
  }
#line 805
  return;
}
}
#line 807
__inline static void irq_gc_unlock(struct irq_chip_generic *gc )  __attribute__((__no_instrument_function__)) ;
#line 807 "../../../analyzer/../bench/linux-headers/include/linux/irq.h"
__inline static void irq_gc_unlock(struct irq_chip_generic *gc ) 
{ 


  {
  {
#line 809
  __raw_spin_unlock(& gc->lock);
  }
#line 810
  return;
}
}
#line 41 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/hardirq.h"
extern irq_cpustat_t irq_stat  __attribute__((__section__(".data..percpu"), __aligned__((1) <<
                                                                                         (6) ))) ;
#line 55
extern void ack_bad_irq(unsigned int irq ) ;
#line 57
extern u64 arch_irq_stat_cpu(unsigned int cpu ) ;
#line 60
extern u64 arch_irq_stat(void) ;
#line 11 "../../../analyzer/../bench/linux-headers/include/linux/hardirq.h"
extern void synchronize_irq(unsigned int irq ) ;
#line 12
extern void synchronize_hardirq(unsigned int irq ) ;
#line 25
extern void rcu_nmi_enter(void) ;
#line 26
extern void rcu_nmi_exit(void) ;
#line 19 "../../../analyzer/../bench/linux-headers/include/linux/timerqueue.h"
extern void timerqueue_add(struct timerqueue_head *head , struct timerqueue_node *node ) ;
#line 21
extern void timerqueue_del(struct timerqueue_head *head , struct timerqueue_node *node ) ;
#line 23
extern struct timerqueue_node *timerqueue_iterate_next(struct timerqueue_node *node ) ;
#line 34
__inline static struct timerqueue_node *timerqueue_getnext(struct timerqueue_head *head )  __attribute__((__no_instrument_function__)) ;
#line 34 "../../../analyzer/../bench/linux-headers/include/linux/timerqueue.h"
__inline static struct timerqueue_node *timerqueue_getnext(struct timerqueue_head *head ) 
{ 


  {
#line 37
  return (head->next);
}
}
#line 40
__inline static void timerqueue_init(struct timerqueue_node *node )  __attribute__((__no_instrument_function__)) ;
#line 40 "../../../analyzer/../bench/linux-headers/include/linux/timerqueue.h"
__inline static void timerqueue_init(struct timerqueue_node *node ) 
{ 


  {
  {
#line 42
  node->node.__rb_parent_color = (unsigned long )(& node->node);
  }
#line 43
  return;
}
}
#line 45
__inline static void timerqueue_init_head(struct timerqueue_head *head )  __attribute__((__no_instrument_function__)) ;
#line 45 "../../../analyzer/../bench/linux-headers/include/linux/timerqueue.h"
__inline static void timerqueue_init_head(struct timerqueue_head *head ) 
{ 
  struct rb_root __constr_expr_15 ;

  {
  {
#line 47
  __constr_expr_15.rb_node = (struct rb_node *)((void *)0);
#line 47
  head->head = __constr_expr_15;
#line 48
  head->next = (struct timerqueue_node *)((void *)0);
  }
#line 49
  return;
}
}
#line 198 "../../../analyzer/../bench/linux-headers/include/linux/hrtimer.h"
__inline static void hrtimer_set_expires(struct hrtimer *timer , ktime_t time )  __attribute__((__no_instrument_function__)) ;
#line 198 "../../../analyzer/../bench/linux-headers/include/linux/hrtimer.h"
__inline static void hrtimer_set_expires(struct hrtimer *timer , ktime_t time ) 
{ 


  {
  {
#line 200
  timer->node.expires = time;
#line 201
  timer->_softexpires = time;
  }
#line 202
  return;
}
}
#line 204
__inline static void hrtimer_set_expires_range(struct hrtimer *timer , ktime_t time ,
                                               ktime_t delta )  __attribute__((__no_instrument_function__)) ;
#line 204 "../../../analyzer/../bench/linux-headers/include/linux/hrtimer.h"
__inline static void hrtimer_set_expires_range(struct hrtimer *timer , ktime_t time ,
                                               ktime_t delta ) 
{ 


  {
  {
#line 206
  timer->_softexpires = time;
#line 207
  timer->node.expires = ktime_add_safe((ktime_t const   )time, (ktime_t const   )delta);
  }
#line 208
  return;
}
}
#line 210
__inline static void hrtimer_set_expires_range_ns(struct hrtimer *timer , ktime_t time ,
                                                  unsigned long delta )  __attribute__((__no_instrument_function__)) ;
#line 210 "../../../analyzer/../bench/linux-headers/include/linux/hrtimer.h"
__inline static void hrtimer_set_expires_range_ns(struct hrtimer *timer , ktime_t time ,
                                                  unsigned long delta ) 
{ 
  ktime_t tmp ;

  {
  {
#line 212
  timer->_softexpires = time;
#line 213
  tmp = ns_to_ktime((u64 )delta);
#line 213
  timer->node.expires = ktime_add_safe((ktime_t const   )time, (ktime_t const   )tmp);
  }
#line 214
  return;
}
}
#line 216
__inline static void hrtimer_set_expires_tv64(struct hrtimer *timer , s64 tv64 )  __attribute__((__no_instrument_function__)) ;
#line 216 "../../../analyzer/../bench/linux-headers/include/linux/hrtimer.h"
__inline static void hrtimer_set_expires_tv64(struct hrtimer *timer , s64 tv64 ) 
{ 


  {
  {
#line 218
  timer->node.expires.tv64 = tv64;
#line 219
  timer->_softexpires.tv64 = tv64;
  }
#line 220
  return;
}
}
#line 222
__inline static void hrtimer_add_expires(struct hrtimer *timer , ktime_t time )  __attribute__((__no_instrument_function__)) ;
#line 222 "../../../analyzer/../bench/linux-headers/include/linux/hrtimer.h"
__inline static void hrtimer_add_expires(struct hrtimer *timer , ktime_t time ) 
{ 


  {
  {
#line 224
  timer->node.expires = ktime_add_safe((ktime_t const   )timer->node.expires, (ktime_t const   )time);
#line 225
  timer->_softexpires = ktime_add_safe((ktime_t const   )timer->_softexpires, (ktime_t const   )time);
  }
#line 226
  return;
}
}
#line 228
__inline static void hrtimer_add_expires_ns(struct hrtimer *timer , u64 ns )  __attribute__((__no_instrument_function__)) ;
#line 228 "../../../analyzer/../bench/linux-headers/include/linux/hrtimer.h"
__inline static void hrtimer_add_expires_ns(struct hrtimer *timer , u64 ns ) 
{ 
  ktime_t __constr_expr_16 ;
  ktime_t __constr_expr_17 ;

  {
  {
#line 230
  __constr_expr_16.tv64 = (s64 )((u64 )timer->node.expires.tv64 + ns);
#line 230
  timer->node.expires = __constr_expr_16;
#line 231
  __constr_expr_17.tv64 = (s64 )((u64 )timer->_softexpires.tv64 + ns);
#line 231
  timer->_softexpires = __constr_expr_17;
  }
#line 232
  return;
}
}
#line 234
__inline static ktime_t hrtimer_get_expires(struct hrtimer  const  *timer )  __attribute__((__no_instrument_function__)) ;
#line 234 "../../../analyzer/../bench/linux-headers/include/linux/hrtimer.h"
__inline static ktime_t hrtimer_get_expires(struct hrtimer  const  *timer ) 
{ 


  {
#line 236
  return ((ktime_t )timer->node.expires);
}
}
#line 239
__inline static ktime_t hrtimer_get_softexpires(struct hrtimer  const  *timer )  __attribute__((__no_instrument_function__)) ;
#line 239 "../../../analyzer/../bench/linux-headers/include/linux/hrtimer.h"
__inline static ktime_t hrtimer_get_softexpires(struct hrtimer  const  *timer ) 
{ 


  {
#line 241
  return ((ktime_t )timer->_softexpires);
}
}
#line 244
__inline static s64 hrtimer_get_expires_tv64(struct hrtimer  const  *timer )  __attribute__((__no_instrument_function__)) ;
#line 244 "../../../analyzer/../bench/linux-headers/include/linux/hrtimer.h"
__inline static s64 hrtimer_get_expires_tv64(struct hrtimer  const  *timer ) 
{ 


  {
#line 246
  return ((s64 )timer->node.expires.tv64);
}
}
#line 248
__inline static s64 hrtimer_get_softexpires_tv64(struct hrtimer  const  *timer )  __attribute__((__no_instrument_function__)) ;
#line 248 "../../../analyzer/../bench/linux-headers/include/linux/hrtimer.h"
__inline static s64 hrtimer_get_softexpires_tv64(struct hrtimer  const  *timer ) 
{ 


  {
#line 250
  return ((s64 )timer->_softexpires.tv64);
}
}
#line 253
__inline static s64 hrtimer_get_expires_ns(struct hrtimer  const  *timer )  __attribute__((__no_instrument_function__)) ;
#line 253 "../../../analyzer/../bench/linux-headers/include/linux/hrtimer.h"
__inline static s64 hrtimer_get_expires_ns(struct hrtimer  const  *timer ) 
{ 


  {
#line 255
  return ((s64 )timer->node.expires.tv64);
}
}
#line 258
__inline static ktime_t hrtimer_expires_remaining(struct hrtimer  const  *timer )  __attribute__((__no_instrument_function__)) ;
#line 258 "../../../analyzer/../bench/linux-headers/include/linux/hrtimer.h"
__inline static ktime_t hrtimer_expires_remaining(struct hrtimer  const  *timer ) 
{ 
  ktime_t __constr_expr_18 ;
  ktime_t tmp ;

  {
  {
#line 260
  tmp = (*((timer->base)->get_time))();
#line 260
  __constr_expr_18.tv64 = (s64 )(timer->node.expires.tv64 - (s64 const   )tmp.tv64);
  }
#line 260
  return (__constr_expr_18);
}
}
#line 266
extern void hrtimer_interrupt(struct clock_event_device *dev ) ;
#line 271
__inline static ktime_t hrtimer_cb_get_time(struct hrtimer *timer )  __attribute__((__no_instrument_function__)) ;
#line 271 "../../../analyzer/../bench/linux-headers/include/linux/hrtimer.h"
__inline static ktime_t hrtimer_cb_get_time(struct hrtimer *timer ) 
{ 
  ktime_t tmp ;

  {
  {
#line 273
  tmp = (*((timer->base)->get_time))();
  }
#line 273
  return (tmp);
}
}
#line 276
__inline static int hrtimer_is_hres_active(struct hrtimer *timer )  __attribute__((__no_instrument_function__)) ;
#line 276 "../../../analyzer/../bench/linux-headers/include/linux/hrtimer.h"
__inline static int hrtimer_is_hres_active(struct hrtimer *timer ) 
{ 


  {
#line 278
  return (((timer->base)->cpu_base)->hres_active);
}
}
#line 281
extern void hrtimer_peek_ahead_timers(void) ;
#line 294
extern void clock_was_set_delayed(void) ;
#line 321
extern void clock_was_set(void) ;
#line 323
extern void timerfd_clock_was_set(void) ;
#line 327
extern void hrtimers_resume(void) ;
#line 329
extern struct tick_device tick_cpu_device  __attribute__((__section__(".data..percpu"))) ;
#line 335
extern void hrtimer_init(struct hrtimer *timer , clockid_t which_clock , enum hrtimer_mode mode ) ;
#line 344
__inline static void hrtimer_init_on_stack(struct hrtimer *timer , clockid_t which_clock ,
                                           enum hrtimer_mode mode )  __attribute__((__no_instrument_function__)) ;
#line 344 "../../../analyzer/../bench/linux-headers/include/linux/hrtimer.h"
__inline static void hrtimer_init_on_stack(struct hrtimer *timer , clockid_t which_clock ,
                                           enum hrtimer_mode mode ) 
{ 


  {
  {
#line 348
  hrtimer_init(timer, which_clock, mode);
  }
#line 349
  return;
}
}
#line 350
__inline static void destroy_hrtimer_on_stack(struct hrtimer *timer )  __attribute__((__no_instrument_function__)) ;
#line 350 "../../../analyzer/../bench/linux-headers/include/linux/hrtimer.h"
__inline static void destroy_hrtimer_on_stack(struct hrtimer *timer ) 
{ 


  {
#line 350
  return;
}
}
#line 354
extern int hrtimer_start(struct hrtimer *timer , ktime_t tim , enum hrtimer_mode  const  mode ) ;
#line 356
extern int hrtimer_start_range_ns(struct hrtimer *timer , ktime_t tim , unsigned long range_ns ,
                                  enum hrtimer_mode  const  mode ) ;
#line 358
extern int __hrtimer_start_range_ns(struct hrtimer *timer , ktime_t tim , unsigned long delta_ns ,
                                    enum hrtimer_mode  const  mode , int wakeup ) ;
#line 363
extern int hrtimer_cancel(struct hrtimer *timer ) ;
#line 364
extern int hrtimer_try_to_cancel(struct hrtimer *timer ) ;
#line 366
__inline static int hrtimer_start_expires(struct hrtimer *timer , enum hrtimer_mode mode )  __attribute__((__no_instrument_function__)) ;
#line 366 "../../../analyzer/../bench/linux-headers/include/linux/hrtimer.h"
__inline static int hrtimer_start_expires(struct hrtimer *timer , enum hrtimer_mode mode ) 
{ 
  unsigned long delta ;
  ktime_t soft ;
  ktime_t hard ;
  ktime_t __constr_expr_19 ;
  int tmp ;

  {
  {
#line 371
  soft = hrtimer_get_softexpires((struct hrtimer  const  *)timer);
#line 372
  hard = hrtimer_get_expires((struct hrtimer  const  *)timer);
#line 373
  __constr_expr_19.tv64 = hard.tv64 - soft.tv64;
#line 373
  delta = (unsigned long )__constr_expr_19.tv64;
#line 374
  tmp = hrtimer_start_range_ns(timer, soft, delta, (enum hrtimer_mode  const  )mode);
  }
#line 374
  return (tmp);
}
}
#line 377
__inline static int hrtimer_restart(struct hrtimer *timer )  __attribute__((__no_instrument_function__)) ;
#line 377 "../../../analyzer/../bench/linux-headers/include/linux/hrtimer.h"
__inline static int hrtimer_restart(struct hrtimer *timer ) 
{ 
  int tmp ;

  {
  {
#line 379
  tmp = hrtimer_start_expires(timer, (enum hrtimer_mode )0);
  }
#line 379
  return (tmp);
}
}
#line 383
extern ktime_t hrtimer_get_remaining(struct hrtimer  const  *timer ) ;
#line 384
extern int hrtimer_get_res(clockid_t const   which_clock , struct timespec *tp ) ;
#line 386
extern ktime_t hrtimer_get_next_event(void) ;
#line 393
__inline static int hrtimer_active(struct hrtimer  const  *timer )  __attribute__((__no_instrument_function__)) ;
#line 393 "../../../analyzer/../bench/linux-headers/include/linux/hrtimer.h"
__inline static int hrtimer_active(struct hrtimer  const  *timer ) 
{ 


  {
#line 395
  return (timer->state != 0UL);
}
}
#line 401
__inline static int hrtimer_is_queued(struct hrtimer *timer )  __attribute__((__no_instrument_function__)) ;
#line 401 "../../../analyzer/../bench/linux-headers/include/linux/hrtimer.h"
__inline static int hrtimer_is_queued(struct hrtimer *timer ) 
{ 


  {
#line 403
  return ((int )(timer->state & 1UL));
}
}
#line 410
__inline static int hrtimer_callback_running(struct hrtimer *timer )  __attribute__((__no_instrument_function__)) ;
#line 410 "../../../analyzer/../bench/linux-headers/include/linux/hrtimer.h"
__inline static int hrtimer_callback_running(struct hrtimer *timer ) 
{ 


  {
#line 412
  return ((int )(timer->state & 2UL));
}
}
#line 416
extern u64 hrtimer_forward(struct hrtimer *timer , ktime_t now , ktime_t interval ) ;
#line 420
__inline static u64 hrtimer_forward_now(struct hrtimer *timer , ktime_t interval )  __attribute__((__no_instrument_function__)) ;
#line 420 "../../../analyzer/../bench/linux-headers/include/linux/hrtimer.h"
__inline static u64 hrtimer_forward_now(struct hrtimer *timer , ktime_t interval ) 
{ 
  ktime_t tmp ;
  u64 tmp___0 ;

  {
  {
#line 423
  tmp = (*((timer->base)->get_time))();
#line 423
  tmp___0 = hrtimer_forward(timer, tmp, interval);
  }
#line 423
  return (tmp___0);
}
}
#line 427
extern long hrtimer_nanosleep(struct timespec *rqtp , struct timespec *rmtp , enum hrtimer_mode  const  mode ,
                              clockid_t const   clockid ) ;
#line 431
extern long hrtimer_nanosleep_restart(struct restart_block *restart_block ) ;
#line 433
extern void hrtimer_init_sleeper(struct hrtimer_sleeper *sl , struct task_struct *tsk ) ;
#line 436
extern int schedule_hrtimeout_range(ktime_t *expires , unsigned long delta , enum hrtimer_mode  const  mode ) ;
#line 438
extern int schedule_hrtimeout_range_clock(ktime_t *expires , unsigned long delta ,
                                          enum hrtimer_mode  const  mode , int clock ) ;
#line 440
extern int schedule_hrtimeout(ktime_t *expires , enum hrtimer_mode  const  mode ) ;
#line 443
extern void hrtimer_run_queues(void) ;
#line 444
extern void hrtimer_run_pending(void) ;
#line 447
extern void __attribute__((__cold__))  hrtimers_init(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 450
extern void sysrq_timer_list_show(void) ;
#line 120 "../../../analyzer/../bench/linux-headers/include/linux/interrupt.h"
extern irqreturn_t no_action(int cpl , void *dev_id ) ;
#line 122
extern int ( __attribute__((__warn_unused_result__)) request_threaded_irq)(unsigned int irq ,
                                                                           irqreturn_t (*handler)(int  ,
                                                                                                  void * ) ,
                                                                           irqreturn_t (*thread_fn)(int  ,
                                                                                                    void * ) ,
                                                                           unsigned long flags ,
                                                                           char const   *name ,
                                                                           void *dev ) ;
#line 127
__inline static int ( __attribute__((__warn_unused_result__)) request_irq)(unsigned int irq ,
                                                                           irqreturn_t (*handler)(int  ,
                                                                                                  void * ) ,
                                                                           unsigned long flags ,
                                                                           char const   *name ,
                                                                           void *dev )  __attribute__((__no_instrument_function__)) ;
#line 127 "../../../analyzer/../bench/linux-headers/include/linux/interrupt.h"
__inline static int ( __attribute__((__warn_unused_result__)) request_irq)(unsigned int irq ,
                                                                           irqreturn_t (*handler)(int  ,
                                                                                                  void * ) ,
                                                                           unsigned long flags ,
                                                                           char const   *name ,
                                                                           void *dev ) 
{ 
  int tmp ;

  {
  {
#line 131
  tmp = request_threaded_irq(irq, handler, (irqreturn_t (*)(int  , void * ))((void *)0),
                             flags, name, dev);
  }
#line 131
  return (tmp);
}
}
#line 134
extern int ( __attribute__((__warn_unused_result__)) request_any_context_irq)(unsigned int irq ,
                                                                              irqreturn_t (*handler)(int  ,
                                                                                                     void * ) ,
                                                                              unsigned long flags ,
                                                                              char const   *name ,
                                                                              void *dev_id ) ;
#line 138
extern int ( __attribute__((__warn_unused_result__)) request_percpu_irq)(unsigned int irq ,
                                                                         irqreturn_t (*handler)(int  ,
                                                                                                void * ) ,
                                                                         char const   *devname ,
                                                                         void *percpu_dev_id ) ;
#line 142
extern void free_irq(unsigned int  , void * ) ;
#line 143
extern void free_percpu_irq(unsigned int  , void * ) ;
#line 147
extern int ( __attribute__((__warn_unused_result__)) devm_request_threaded_irq)(struct device *dev ,
                                                                                unsigned int irq ,
                                                                                irqreturn_t (*handler)(int  ,
                                                                                                       void * ) ,
                                                                                irqreturn_t (*thread_fn)(int  ,
                                                                                                         void * ) ,
                                                                                unsigned long irqflags ,
                                                                                char const   *devname ,
                                                                                void *dev_id ) ;
#line 153
__inline static int ( __attribute__((__warn_unused_result__)) devm_request_irq)(struct device *dev ,
                                                                                unsigned int irq ,
                                                                                irqreturn_t (*handler)(int  ,
                                                                                                       void * ) ,
                                                                                unsigned long irqflags ,
                                                                                char const   *devname ,
                                                                                void *dev_id )  __attribute__((__no_instrument_function__)) ;
#line 153 "../../../analyzer/../bench/linux-headers/include/linux/interrupt.h"
__inline static int ( __attribute__((__warn_unused_result__)) devm_request_irq)(struct device *dev ,
                                                                                unsigned int irq ,
                                                                                irqreturn_t (*handler)(int  ,
                                                                                                       void * ) ,
                                                                                unsigned long irqflags ,
                                                                                char const   *devname ,
                                                                                void *dev_id ) 
{ 
  int tmp ;

  {
  {
#line 157
  tmp = devm_request_threaded_irq(dev, irq, handler, (irqreturn_t (*)(int  , void * ))((void *)0),
                                  irqflags, devname, dev_id);
  }
#line 157
  return (tmp);
}
}
#line 161
extern int ( __attribute__((__warn_unused_result__)) devm_request_any_context_irq)(struct device *dev ,
                                                                                   unsigned int irq ,
                                                                                   irqreturn_t (*handler)(int  ,
                                                                                                          void * ) ,
                                                                                   unsigned long irqflags ,
                                                                                   char const   *devname ,
                                                                                   void *dev_id ) ;
#line 166
extern void devm_free_irq(struct device *dev , unsigned int irq , void *dev_id ) ;
#line 186
extern void disable_irq_nosync(unsigned int irq ) ;
#line 187
extern void disable_irq(unsigned int irq ) ;
#line 188
extern void disable_percpu_irq(unsigned int irq ) ;
#line 189
extern void enable_irq(unsigned int irq ) ;
#line 190
extern void enable_percpu_irq(unsigned int irq , unsigned int type ) ;
#line 191
extern void irq_wake_thread(unsigned int irq , void *dev_id ) ;
#line 194
extern void suspend_device_irqs(void) ;
#line 195
extern void resume_device_irqs(void) ;
#line 197
extern int check_wakeup_irqs(void) ;
#line 224
extern cpumask_var_t irq_default_affinity ;
#line 227
extern int __irq_set_affinity(unsigned int irq , struct cpumask  const  *cpumask ,
                              bool force ) ;
#line 237
__inline static int irq_set_affinity(unsigned int irq , struct cpumask  const  *cpumask )  __attribute__((__no_instrument_function__)) ;
#line 237 "../../../analyzer/../bench/linux-headers/include/linux/interrupt.h"
__inline static int irq_set_affinity(unsigned int irq , struct cpumask  const  *cpumask ) 
{ 
  int tmp ;

  {
  {
#line 240
  tmp = __irq_set_affinity(irq, cpumask, (bool )0);
  }
#line 240
  return (tmp);
}
}
#line 254
__inline static int irq_force_affinity(unsigned int irq , struct cpumask  const  *cpumask )  __attribute__((__no_instrument_function__)) ;
#line 254 "../../../analyzer/../bench/linux-headers/include/linux/interrupt.h"
__inline static int irq_force_affinity(unsigned int irq , struct cpumask  const  *cpumask ) 
{ 
  int tmp ;

  {
  {
#line 257
  tmp = __irq_set_affinity(irq, cpumask, (bool )1);
  }
#line 257
  return (tmp);
}
}
#line 260
extern int irq_can_set_affinity(unsigned int irq ) ;
#line 261
extern int irq_select_affinity(unsigned int irq ) ;
#line 263
extern int irq_set_affinity_hint(unsigned int irq , struct cpumask  const  *m ) ;
#line 265
extern int irq_set_affinity_notifier(unsigned int irq , struct irq_affinity_notify *notify ) ;
#line 311
__inline static void disable_irq_nosync_lockdep(unsigned int irq )  __attribute__((__no_instrument_function__)) ;
#line 311 "../../../analyzer/../bench/linux-headers/include/linux/interrupt.h"
__inline static void disable_irq_nosync_lockdep(unsigned int irq ) 
{ 


  {
  {
#line 313
  disable_irq_nosync(irq);
  }
#line 317
  return;
}
}
#line 319
__inline static void disable_irq_nosync_lockdep_irqsave(unsigned int irq , unsigned long *flags )  __attribute__((__no_instrument_function__)) ;
#line 319 "../../../analyzer/../bench/linux-headers/include/linux/interrupt.h"
__inline static void disable_irq_nosync_lockdep_irqsave(unsigned int irq , unsigned long *flags ) 
{ 


  {
  {
#line 321
  disable_irq_nosync(irq);
  }
#line 325
  return;
}
}
#line 327
__inline static void disable_irq_lockdep(unsigned int irq )  __attribute__((__no_instrument_function__)) ;
#line 327 "../../../analyzer/../bench/linux-headers/include/linux/interrupt.h"
__inline static void disable_irq_lockdep(unsigned int irq ) 
{ 


  {
  {
#line 329
  disable_irq(irq);
  }
#line 333
  return;
}
}
#line 335
__inline static void enable_irq_lockdep(unsigned int irq )  __attribute__((__no_instrument_function__)) ;
#line 335 "../../../analyzer/../bench/linux-headers/include/linux/interrupt.h"
__inline static void enable_irq_lockdep(unsigned int irq ) 
{ 


  {
  {
#line 340
  enable_irq(irq);
  }
#line 341
  return;
}
}
#line 343
__inline static void enable_irq_lockdep_irqrestore(unsigned int irq , unsigned long *flags )  __attribute__((__no_instrument_function__)) ;
#line 343 "../../../analyzer/../bench/linux-headers/include/linux/interrupt.h"
__inline static void enable_irq_lockdep_irqrestore(unsigned int irq , unsigned long *flags ) 
{ 


  {
  {
#line 348
  enable_irq(irq);
  }
#line 349
  return;
}
}
#line 352
extern int irq_set_irq_wake(unsigned int irq , unsigned int on ) ;
#line 354
__inline static int enable_irq_wake(unsigned int irq )  __attribute__((__no_instrument_function__)) ;
#line 354 "../../../analyzer/../bench/linux-headers/include/linux/interrupt.h"
__inline static int enable_irq_wake(unsigned int irq ) 
{ 
  int tmp ;

  {
  {
#line 356
  tmp = irq_set_irq_wake(irq, 1U);
  }
#line 356
  return (tmp);
}
}
#line 359
__inline static int disable_irq_wake(unsigned int irq )  __attribute__((__no_instrument_function__)) ;
#line 359 "../../../analyzer/../bench/linux-headers/include/linux/interrupt.h"
__inline static int disable_irq_wake(unsigned int irq ) 
{ 
  int tmp ;

  {
  {
#line 361
  tmp = irq_set_irq_wake(irq, 0U);
  }
#line 361
  return (tmp);
}
}
#line 366
extern bool force_irqthreads ;
#line 413
extern char const   * const  softirq_to_name[10] ;
#line 424
extern void do_softirq(void) ;
#line 425
extern void __do_softirq(void) ;
#line 428
extern void do_softirq_own_stack(void) ;
#line 436
extern void open_softirq(int nr , void (*action)(struct softirq_action * ) ) ;
#line 437
extern void softirq_init(void) ;
#line 438
extern void __raise_softirq_irqoff(unsigned int nr ) ;
#line 440
extern void raise_softirq_irqoff(unsigned int nr ) ;
#line 441
extern void raise_softirq(unsigned int nr ) ;
#line 443
extern struct task_struct *ksoftirqd  __attribute__((__section__(".data..percpu"))) ;
#line 445
__inline static struct task_struct *this_cpu_ksoftirqd(void)  __attribute__((__no_instrument_function__)) ;
#line 445 "../../../analyzer/../bench/linux-headers/include/linux/interrupt.h"
__inline static struct task_struct *this_cpu_ksoftirqd(void) 
{ 
  struct task_struct *pscr_ret__ ;
  void const   *__vpp_verify ;
  struct task_struct *pfo_ret__ ;
  struct task_struct *pfo_ret_____0 ;
  struct task_struct *pfo_ret_____1 ;
  struct task_struct *pfo_ret_____2 ;

  {
  {
#line 447
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 447
    __vpp_verify = (void const   *)((struct task_struct **)((void *)0));
    }
#line 447
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 447
  if (sizeof(ksoftirqd) == 1UL) {
#line 447
    goto case_1;
  }
#line 447
  if (sizeof(ksoftirqd) == 2UL) {
#line 447
    goto case_2___0;
  }
#line 447
  if (sizeof(ksoftirqd) == 4UL) {
#line 447
    goto case_4___1;
  }
#line 447
  if (sizeof(ksoftirqd) == 8UL) {
#line 447
    goto case_8___2;
  }
#line 447
  goto switch_default___3;
  case_1: /* CIL Label */ 
  {
#line 447
  if (sizeof(ksoftirqd) == 1UL) {
#line 447
    goto case_1___0;
  }
#line 447
  if (sizeof(ksoftirqd) == 2UL) {
#line 447
    goto case_2;
  }
#line 447
  if (sizeof(ksoftirqd) == 4UL) {
#line 447
    goto case_4;
  }
#line 447
  if (sizeof(ksoftirqd) == 8UL) {
#line 447
    goto case_8;
  }
#line 447
  goto switch_default;
  case_1___0: /* CIL Label */ 
  {
#line 447
  __asm__  ("mov"
            "b "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=q" (pfo_ret__): "m" (ksoftirqd));
  }
#line 447
  goto switch_break___0;
  case_2: /* CIL Label */ 
  {
#line 447
  __asm__  ("mov"
            "w "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret__): "m" (ksoftirqd));
  }
#line 447
  goto switch_break___0;
  case_4: /* CIL Label */ 
  {
#line 447
  __asm__  ("mov"
            "l "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret__): "m" (ksoftirqd));
  }
#line 447
  goto switch_break___0;
  case_8: /* CIL Label */ 
  {
#line 447
  __asm__  ("mov"
            "q "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret__): "m" (ksoftirqd));
  }
#line 447
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 447
  __bad_percpu_size();
  }
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 447
  pscr_ret__ = pfo_ret__;
  }
#line 447
  goto switch_break;
  case_2___0: /* CIL Label */ 
  {
#line 447
  if (sizeof(ksoftirqd) == 1UL) {
#line 447
    goto case_1___1;
  }
#line 447
  if (sizeof(ksoftirqd) == 2UL) {
#line 447
    goto case_2___1;
  }
#line 447
  if (sizeof(ksoftirqd) == 4UL) {
#line 447
    goto case_4___0;
  }
#line 447
  if (sizeof(ksoftirqd) == 8UL) {
#line 447
    goto case_8___0;
  }
#line 447
  goto switch_default___0;
  case_1___1: /* CIL Label */ 
  {
#line 447
  __asm__  ("mov"
            "b "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=q" (pfo_ret_____0): "m" (ksoftirqd));
  }
#line 447
  goto switch_break___1;
  case_2___1: /* CIL Label */ 
  {
#line 447
  __asm__  ("mov"
            "w "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret_____0): "m" (ksoftirqd));
  }
#line 447
  goto switch_break___1;
  case_4___0: /* CIL Label */ 
  {
#line 447
  __asm__  ("mov"
            "l "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret_____0): "m" (ksoftirqd));
  }
#line 447
  goto switch_break___1;
  case_8___0: /* CIL Label */ 
  {
#line 447
  __asm__  ("mov"
            "q "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret_____0): "m" (ksoftirqd));
  }
#line 447
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
  {
#line 447
  __bad_percpu_size();
  }
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 447
  pscr_ret__ = pfo_ret_____0;
  }
#line 447
  goto switch_break;
  case_4___1: /* CIL Label */ 
  {
#line 447
  if (sizeof(ksoftirqd) == 1UL) {
#line 447
    goto case_1___2;
  }
#line 447
  if (sizeof(ksoftirqd) == 2UL) {
#line 447
    goto case_2___2;
  }
#line 447
  if (sizeof(ksoftirqd) == 4UL) {
#line 447
    goto case_4___2;
  }
#line 447
  if (sizeof(ksoftirqd) == 8UL) {
#line 447
    goto case_8___1;
  }
#line 447
  goto switch_default___1;
  case_1___2: /* CIL Label */ 
  {
#line 447
  __asm__  ("mov"
            "b "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=q" (pfo_ret_____1): "m" (ksoftirqd));
  }
#line 447
  goto switch_break___2;
  case_2___2: /* CIL Label */ 
  {
#line 447
  __asm__  ("mov"
            "w "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret_____1): "m" (ksoftirqd));
  }
#line 447
  goto switch_break___2;
  case_4___2: /* CIL Label */ 
  {
#line 447
  __asm__  ("mov"
            "l "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret_____1): "m" (ksoftirqd));
  }
#line 447
  goto switch_break___2;
  case_8___1: /* CIL Label */ 
  {
#line 447
  __asm__  ("mov"
            "q "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret_____1): "m" (ksoftirqd));
  }
#line 447
  goto switch_break___2;
  switch_default___1: /* CIL Label */ 
  {
#line 447
  __bad_percpu_size();
  }
  switch_break___2: /* CIL Label */ ;
  }
  {
#line 447
  pscr_ret__ = pfo_ret_____1;
  }
#line 447
  goto switch_break;
  case_8___2: /* CIL Label */ 
  {
#line 447
  if (sizeof(ksoftirqd) == 1UL) {
#line 447
    goto case_1___3;
  }
#line 447
  if (sizeof(ksoftirqd) == 2UL) {
#line 447
    goto case_2___3;
  }
#line 447
  if (sizeof(ksoftirqd) == 4UL) {
#line 447
    goto case_4___3;
  }
#line 447
  if (sizeof(ksoftirqd) == 8UL) {
#line 447
    goto case_8___3;
  }
#line 447
  goto switch_default___2;
  case_1___3: /* CIL Label */ 
  {
#line 447
  __asm__  ("mov"
            "b "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=q" (pfo_ret_____2): "m" (ksoftirqd));
  }
#line 447
  goto switch_break___3;
  case_2___3: /* CIL Label */ 
  {
#line 447
  __asm__  ("mov"
            "w "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret_____2): "m" (ksoftirqd));
  }
#line 447
  goto switch_break___3;
  case_4___3: /* CIL Label */ 
  {
#line 447
  __asm__  ("mov"
            "l "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret_____2): "m" (ksoftirqd));
  }
#line 447
  goto switch_break___3;
  case_8___3: /* CIL Label */ 
  {
#line 447
  __asm__  ("mov"
            "q "
            "%%"
            "gs"
            ":"
            "%P"
            "1"
            ",%0": "=r" (pfo_ret_____2): "m" (ksoftirqd));
  }
#line 447
  goto switch_break___3;
  switch_default___2: /* CIL Label */ 
  {
#line 447
  __bad_percpu_size();
  }
  switch_break___3: /* CIL Label */ ;
  }
  {
#line 447
  pscr_ret__ = pfo_ret_____2;
  }
#line 447
  goto switch_break;
  switch_default___3: /* CIL Label */ 
  {
#line 447
  __bad_size_call_parameter();
  }
#line 447
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 447
  return (pscr_ret__);
}
}
#line 493
__inline static int tasklet_trylock(struct tasklet_struct *t )  __attribute__((__no_instrument_function__)) ;
#line 493 "../../../analyzer/../bench/linux-headers/include/linux/interrupt.h"
__inline static int tasklet_trylock(struct tasklet_struct *t ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 495
  tmp = test_and_set_bit(1L, (unsigned long volatile   *)(& t->state));
  }
#line 495
  if (tmp) {
    {
#line 495
    tmp___0 = 0;
    }
  } else {
    {
#line 495
    tmp___0 = 1;
    }
  }
#line 495
  return (tmp___0);
}
}
#line 498
__inline static void tasklet_unlock(struct tasklet_struct *t )  __attribute__((__no_instrument_function__)) ;
#line 498 "../../../analyzer/../bench/linux-headers/include/linux/interrupt.h"
__inline static void tasklet_unlock(struct tasklet_struct *t ) 
{ 


  {
  {
#line 500
  __asm__  volatile   ("": : : "memory");
#line 501
  clear_bit(1L, (unsigned long volatile   *)(& t->state));
  }
#line 502
  return;
}
}
#line 504
__inline static void tasklet_unlock_wait(struct tasklet_struct *t )  __attribute__((__no_instrument_function__)) ;
#line 504 "../../../analyzer/../bench/linux-headers/include/linux/interrupt.h"
__inline static void tasklet_unlock_wait(struct tasklet_struct *t ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 506
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 506
    tmp = constant_test_bit(1L, (unsigned long const volatile   *)(& t->state));
    }
#line 506
    if (! tmp) {
#line 506
      goto while_break;
    }
    {
#line 506
    __asm__  volatile   ("": : : "memory");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 507
  return;
}
}
#line 514
extern void __tasklet_schedule(struct tasklet_struct *t ) ;
#line 516
__inline static void tasklet_schedule(struct tasklet_struct *t )  __attribute__((__no_instrument_function__)) ;
#line 516 "../../../analyzer/../bench/linux-headers/include/linux/interrupt.h"
__inline static void tasklet_schedule(struct tasklet_struct *t ) 
{ 
  int tmp ;

  {
  {
#line 518
  tmp = test_and_set_bit(0L, (unsigned long volatile   *)(& t->state));
  }
#line 518
  if (! tmp) {
    {
#line 519
    __tasklet_schedule(t);
    }
  }
#line 520
  return;
}
}
#line 522
extern void __tasklet_hi_schedule(struct tasklet_struct *t ) ;
#line 524
__inline static void tasklet_hi_schedule(struct tasklet_struct *t )  __attribute__((__no_instrument_function__)) ;
#line 524 "../../../analyzer/../bench/linux-headers/include/linux/interrupt.h"
__inline static void tasklet_hi_schedule(struct tasklet_struct *t ) 
{ 
  int tmp ;

  {
  {
#line 526
  tmp = test_and_set_bit(0L, (unsigned long volatile   *)(& t->state));
  }
#line 526
  if (! tmp) {
    {
#line 527
    __tasklet_hi_schedule(t);
    }
  }
#line 528
  return;
}
}
#line 530
extern void __tasklet_hi_schedule_first(struct tasklet_struct *t ) ;
#line 538
__inline static void tasklet_hi_schedule_first(struct tasklet_struct *t )  __attribute__((__no_instrument_function__)) ;
#line 538 "../../../analyzer/../bench/linux-headers/include/linux/interrupt.h"
__inline static void tasklet_hi_schedule_first(struct tasklet_struct *t ) 
{ 
  int tmp ;

  {
  {
#line 540
  tmp = test_and_set_bit(0L, (unsigned long volatile   *)(& t->state));
  }
#line 540
  if (! tmp) {
    {
#line 541
    __tasklet_hi_schedule_first(t);
    }
  }
#line 542
  return;
}
}
#line 545
__inline static void tasklet_disable_nosync(struct tasklet_struct *t )  __attribute__((__no_instrument_function__)) ;
#line 545 "../../../analyzer/../bench/linux-headers/include/linux/interrupt.h"
__inline static void tasklet_disable_nosync(struct tasklet_struct *t ) 
{ 


  {
  {
#line 547
  atomic_inc(& t->count);
#line 548
  __asm__  volatile   ("": : : "memory");
  }
#line 549
  return;
}
}
#line 551
__inline static void tasklet_disable(struct tasklet_struct *t )  __attribute__((__no_instrument_function__)) ;
#line 551 "../../../analyzer/../bench/linux-headers/include/linux/interrupt.h"
__inline static void tasklet_disable(struct tasklet_struct *t ) 
{ 


  {
  {
#line 553
  tasklet_disable_nosync(t);
#line 554
  tasklet_unlock_wait(t);
#line 555
  __asm__  volatile   ("mfence": : : "memory");
  }
#line 556
  return;
}
}
#line 558
__inline static void tasklet_enable(struct tasklet_struct *t )  __attribute__((__no_instrument_function__)) ;
#line 558 "../../../analyzer/../bench/linux-headers/include/linux/interrupt.h"
__inline static void tasklet_enable(struct tasklet_struct *t ) 
{ 


  {
  {
#line 560
  __asm__  volatile   ("": : : "memory");
#line 561
  atomic_dec(& t->count);
  }
#line 562
  return;
}
}
#line 564
__inline static void tasklet_hi_enable(struct tasklet_struct *t )  __attribute__((__no_instrument_function__)) ;
#line 564 "../../../analyzer/../bench/linux-headers/include/linux/interrupt.h"
__inline static void tasklet_hi_enable(struct tasklet_struct *t ) 
{ 


  {
  {
#line 566
  __asm__  volatile   ("": : : "memory");
#line 567
  atomic_dec(& t->count);
  }
#line 568
  return;
}
}
#line 570
extern void tasklet_kill(struct tasklet_struct *t ) ;
#line 571
extern void tasklet_kill_immediate(struct tasklet_struct *t , unsigned int cpu ) ;
#line 572
extern void tasklet_init(struct tasklet_struct *t , void (*func)(unsigned long  ) ,
                         unsigned long data ) ;
#line 581
extern void tasklet_hrtimer_init(struct tasklet_hrtimer *ttimer , enum hrtimer_restart (*function)(struct hrtimer * ) ,
                                 clockid_t which_clock , enum hrtimer_mode mode ) ;
#line 586
__inline static int tasklet_hrtimer_start(struct tasklet_hrtimer *ttimer , ktime_t time ,
                                          enum hrtimer_mode  const  mode )  __attribute__((__no_instrument_function__)) ;
#line 586 "../../../analyzer/../bench/linux-headers/include/linux/interrupt.h"
__inline static int tasklet_hrtimer_start(struct tasklet_hrtimer *ttimer , ktime_t time ,
                                          enum hrtimer_mode  const  mode ) 
{ 
  int tmp ;

  {
  {
#line 590
  tmp = hrtimer_start(& ttimer->timer, time, mode);
  }
#line 590
  return (tmp);
}
}
#line 593
__inline static void tasklet_hrtimer_cancel(struct tasklet_hrtimer *ttimer )  __attribute__((__no_instrument_function__)) ;
#line 593 "../../../analyzer/../bench/linux-headers/include/linux/interrupt.h"
__inline static void tasklet_hrtimer_cancel(struct tasklet_hrtimer *ttimer ) 
{ 


  {
  {
#line 596
  hrtimer_cancel(& ttimer->timer);
#line 597
  tasklet_kill(& ttimer->tasklet);
  }
#line 598
  return;
}
}
#line 642
extern unsigned long probe_irq_on(void) ;
#line 643
extern int probe_irq_off(unsigned long  ) ;
#line 644
extern unsigned int probe_irq_mask(unsigned long  ) ;
#line 649
extern void init_irq_proc(void) ;
#line 657
extern int show_interrupts(struct seq_file *p , void *v ) ;
#line 658
extern int arch_show_interrupts(struct seq_file *p , int prec ) ;
#line 660
extern int early_irq_init(void) ;
#line 661
extern int arch_probe_nr_irqs(void) ;
#line 662
extern int arch_early_irq_init(void) ;
#line 47 "../../../analyzer/../bench/linux-headers/include/linux/sched/prio.h"
__inline static long nice_to_rlimit(long nice )  __attribute__((__no_instrument_function__)) ;
#line 47 "../../../analyzer/../bench/linux-headers/include/linux/sched/prio.h"
__inline static long nice_to_rlimit(long nice ) 
{ 


  {
#line 49
  return ((19L - nice) + 1L);
}
}
#line 55
__inline static long rlimit_to_nice(long prio )  __attribute__((__no_instrument_function__)) ;
#line 55 "../../../analyzer/../bench/linux-headers/include/linux/sched/prio.h"
__inline static long rlimit_to_nice(long prio ) 
{ 


  {
#line 57
  return ((19L - prio) + 1L);
}
}
#line 21 "../../../analyzer/../bench/linux-headers/include/linux/capability.h"
extern int file_caps_enabled ;
#line 43
extern struct user_namespace *current_user_ns(void) ;
#line 45
extern kernel_cap_t const   __cap_empty_set ;
#line 46
extern kernel_cap_t const   __cap_init_eff_set ;
#line 117
__inline static kernel_cap_t cap_combine(kernel_cap_t const   a , kernel_cap_t const   b )  __attribute__((__no_instrument_function__)) ;
#line 117 "../../../analyzer/../bench/linux-headers/include/linux/capability.h"
__inline static kernel_cap_t cap_combine(kernel_cap_t const   a , kernel_cap_t const   b ) 
{ 
  kernel_cap_t dest ;
  unsigned int __capi ;

  {
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 121
    __capi = 0U;
    }
    {
#line 121
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 121
      if (! (__capi < 2U)) {
#line 121
        goto while_break___0;
      }
      {
#line 121
      dest.cap[__capi] = a.cap[__capi] | b.cap[__capi];
#line 121
      __capi ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 121
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  return (dest);
}
}
#line 125
__inline static kernel_cap_t cap_intersect(kernel_cap_t const   a , kernel_cap_t const   b )  __attribute__((__no_instrument_function__)) ;
#line 125 "../../../analyzer/../bench/linux-headers/include/linux/capability.h"
__inline static kernel_cap_t cap_intersect(kernel_cap_t const   a , kernel_cap_t const   b ) 
{ 
  kernel_cap_t dest ;
  unsigned int __capi ;

  {
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 129
    __capi = 0U;
    }
    {
#line 129
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 129
      if (! (__capi < 2U)) {
#line 129
        goto while_break___0;
      }
      {
#line 129
      dest.cap[__capi] = a.cap[__capi] & b.cap[__capi];
#line 129
      __capi ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 129
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  return (dest);
}
}
#line 133
__inline static kernel_cap_t cap_drop(kernel_cap_t const   a , kernel_cap_t const   drop )  __attribute__((__no_instrument_function__)) ;
#line 133 "../../../analyzer/../bench/linux-headers/include/linux/capability.h"
__inline static kernel_cap_t cap_drop(kernel_cap_t const   a , kernel_cap_t const   drop ) 
{ 
  kernel_cap_t dest ;
  unsigned int __capi ;

  {
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 137
    __capi = 0U;
    }
    {
#line 137
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 137
      if (! (__capi < 2U)) {
#line 137
        goto while_break___0;
      }
      {
#line 137
      dest.cap[__capi] = a.cap[__capi] & ~ drop.cap[__capi];
#line 137
      __capi ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 137
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 138
  return (dest);
}
}
#line 141
__inline static kernel_cap_t cap_invert(kernel_cap_t const   c )  __attribute__((__no_instrument_function__)) ;
#line 141 "../../../analyzer/../bench/linux-headers/include/linux/capability.h"
__inline static kernel_cap_t cap_invert(kernel_cap_t const   c ) 
{ 
  kernel_cap_t dest ;
  unsigned int __capi ;

  {
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 144
    __capi = 0U;
    }
    {
#line 144
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 144
      if (! (__capi < 2U)) {
#line 144
        goto while_break___0;
      }
      {
#line 144
      dest.cap[__capi] = ~ c.cap[__capi];
#line 144
      __capi ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 144
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  return (dest);
}
}
#line 148
__inline static int cap_isclear(kernel_cap_t const   a )  __attribute__((__no_instrument_function__)) ;
#line 148 "../../../analyzer/../bench/linux-headers/include/linux/capability.h"
__inline static int cap_isclear(kernel_cap_t const   a ) 
{ 
  unsigned int __capi ;

  {
  {
#line 151
  __capi = 0U;
  }
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (! (__capi < 2U)) {
#line 151
      goto while_break;
    }
#line 152
    if (a.cap[__capi] != 0U) {
#line 153
      return (0);
    }
    {
#line 151
    __capi ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 155
  return (1);
}
}
#line 165
__inline static int cap_issubset(kernel_cap_t const   a , kernel_cap_t const   set )  __attribute__((__no_instrument_function__)) ;
#line 165 "../../../analyzer/../bench/linux-headers/include/linux/capability.h"
__inline static int cap_issubset(kernel_cap_t const   a , kernel_cap_t const   set ) 
{ 
  kernel_cap_t dest ;
  int tmp ;

  {
  {
#line 168
  dest = cap_drop(a, set);
#line 169
  tmp = cap_isclear((kernel_cap_t const   )dest);
  }
#line 169
  return (tmp);
}
}
#line 174
__inline static int cap_is_fs_cap(int cap )  __attribute__((__no_instrument_function__)) ;
#line 174 "../../../analyzer/../bench/linux-headers/include/linux/capability.h"
__inline static int cap_is_fs_cap(int cap ) 
{ 
  kernel_cap_t __cap_fs_set ;

  {
  {
#line 176
  __cap_fs_set.cap[0] = (__u32 )((((((1 | (1 << 27)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 9));
#line 176
  __cap_fs_set.cap[1] = (__u32 )1;
  }
#line 177
  return (! (! ((unsigned int )(1 << (cap & 31)) & __cap_fs_set.cap[cap >> 5])));
}
}
#line 180
__inline static kernel_cap_t cap_drop_fs_set(kernel_cap_t const   a )  __attribute__((__no_instrument_function__)) ;
#line 180 "../../../analyzer/../bench/linux-headers/include/linux/capability.h"
__inline static kernel_cap_t cap_drop_fs_set(kernel_cap_t const   a ) 
{ 
  kernel_cap_t __cap_fs_set ;
  kernel_cap_t tmp ;

  {
  {
#line 182
  __cap_fs_set.cap[0] = (__u32 )((((((1 | (1 << 27)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 9));
#line 182
  __cap_fs_set.cap[1] = (__u32 )1;
#line 183
  tmp = cap_drop(a, (kernel_cap_t const   )__cap_fs_set);
  }
#line 183
  return (tmp);
}
}
#line 186
__inline static kernel_cap_t cap_raise_fs_set(kernel_cap_t const   a , kernel_cap_t const   permitted )  __attribute__((__no_instrument_function__)) ;
#line 186 "../../../analyzer/../bench/linux-headers/include/linux/capability.h"
__inline static kernel_cap_t cap_raise_fs_set(kernel_cap_t const   a , kernel_cap_t const   permitted ) 
{ 
  kernel_cap_t __cap_fs_set ;
  kernel_cap_t tmp ;
  kernel_cap_t tmp___0 ;

  {
  {
#line 189
  __cap_fs_set.cap[0] = (__u32 )((((((1 | (1 << 27)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 9));
#line 189
  __cap_fs_set.cap[1] = (__u32 )1;
#line 190
  tmp = cap_intersect(permitted, (kernel_cap_t const   )__cap_fs_set);
#line 190
  tmp___0 = cap_combine(a, (kernel_cap_t const   )tmp);
  }
#line 190
  return (tmp___0);
}
}
#line 194
__inline static kernel_cap_t cap_drop_nfsd_set(kernel_cap_t const   a )  __attribute__((__no_instrument_function__)) ;
#line 194 "../../../analyzer/../bench/linux-headers/include/linux/capability.h"
__inline static kernel_cap_t cap_drop_nfsd_set(kernel_cap_t const   a ) 
{ 
  kernel_cap_t __cap_fs_set ;
  kernel_cap_t tmp ;

  {
  {
#line 196
  __cap_fs_set.cap[0] = (__u32 )((((((1 | (1 << 27)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 24));
#line 196
  __cap_fs_set.cap[1] = (__u32 )1;
#line 197
  tmp = cap_drop(a, (kernel_cap_t const   )__cap_fs_set);
  }
#line 197
  return (tmp);
}
}
#line 200
__inline static kernel_cap_t cap_raise_nfsd_set(kernel_cap_t const   a , kernel_cap_t const   permitted )  __attribute__((__no_instrument_function__)) ;
#line 200 "../../../analyzer/../bench/linux-headers/include/linux/capability.h"
__inline static kernel_cap_t cap_raise_nfsd_set(kernel_cap_t const   a , kernel_cap_t const   permitted ) 
{ 
  kernel_cap_t __cap_nfsd_set ;
  kernel_cap_t tmp ;
  kernel_cap_t tmp___0 ;

  {
  {
#line 203
  __cap_nfsd_set.cap[0] = (__u32 )((((((1 | (1 << 27)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 24));
#line 203
  __cap_nfsd_set.cap[1] = (__u32 )1;
#line 204
  tmp = cap_intersect(permitted, (kernel_cap_t const   )__cap_nfsd_set);
#line 204
  tmp___0 = cap_combine(a, (kernel_cap_t const   )tmp);
  }
#line 204
  return (tmp___0);
}
}
#line 208
extern bool has_capability(struct task_struct *t , int cap ) ;
#line 209
extern bool has_ns_capability(struct task_struct *t , struct user_namespace *ns ,
                              int cap ) ;
#line 211
extern bool has_capability_noaudit(struct task_struct *t , int cap ) ;
#line 212
extern bool has_ns_capability_noaudit(struct task_struct *t , struct user_namespace *ns ,
                                      int cap ) ;
#line 214
extern bool capable(int cap ) ;
#line 215
extern bool ns_capable(struct user_namespace *ns , int cap ) ;
#line 216
extern bool capable_wrt_inode_uidgid(struct inode  const  *inode , int cap ) ;
#line 217
extern bool file_ns_capable(struct file  const  *file , struct user_namespace *ns ,
                            int cap ) ;
#line 220
extern int get_vfs_caps_from_disk(struct dentry  const  *dentry , struct cpu_vfs_cap_data *cpu_caps ) ;
#line 123 "../../../analyzer/../bench/linux-headers/include/linux/plist.h"
__inline static void plist_head_init(struct plist_head *head )  __attribute__((__no_instrument_function__)) ;
#line 123 "../../../analyzer/../bench/linux-headers/include/linux/plist.h"
__inline static void plist_head_init(struct plist_head *head ) 
{ 


  {
  {
#line 126
  INIT_LIST_HEAD(& head->node_list);
  }
#line 127
  return;
}
}
#line 134
__inline static void plist_node_init(struct plist_node *node , int prio )  __attribute__((__no_instrument_function__)) ;
#line 134 "../../../analyzer/../bench/linux-headers/include/linux/plist.h"
__inline static void plist_node_init(struct plist_node *node , int prio ) 
{ 


  {
  {
#line 136
  node->prio = prio;
#line 137
  INIT_LIST_HEAD(& node->prio_list);
#line 138
  INIT_LIST_HEAD(& node->node_list);
  }
#line 139
  return;
}
}
#line 141
extern void plist_add(struct plist_node *node , struct plist_head *head ) ;
#line 142
extern void plist_del(struct plist_node *node , struct plist_head *head ) ;
#line 144
extern void plist_requeue(struct plist_node *node , struct plist_head *head ) ;
#line 212
__inline static int plist_head_empty(struct plist_head  const  *head )  __attribute__((__no_instrument_function__)) ;
#line 212 "../../../analyzer/../bench/linux-headers/include/linux/plist.h"
__inline static int plist_head_empty(struct plist_head  const  *head ) 
{ 
  int tmp ;

  {
  {
#line 214
  tmp = list_empty(& head->node_list);
  }
#line 214
  return (tmp);
}
}
#line 221
__inline static int plist_node_empty(struct plist_node  const  *node )  __attribute__((__no_instrument_function__)) ;
#line 221 "../../../analyzer/../bench/linux-headers/include/linux/plist.h"
__inline static int plist_node_empty(struct plist_node  const  *node ) 
{ 
  int tmp ;

  {
  {
#line 223
  tmp = list_empty(& node->node_list);
  }
#line 223
  return (tmp);
}
}
#line 282
__inline static struct plist_node *plist_first(struct plist_head  const  *head )  __attribute__((__no_instrument_function__)) ;
#line 282 "../../../analyzer/../bench/linux-headers/include/linux/plist.h"
__inline static struct plist_node *plist_first(struct plist_head  const  *head ) 
{ 
  struct list_head  const  *__mptr ;

  {
  {
#line 284
  __mptr = (struct list_head  const  *)head->node_list.next;
  }
#line 284
  return ((struct plist_node *)((char *)__mptr - (unsigned long )(& ((struct plist_node *)0)->node_list)));
}
}
#line 294
__inline static struct plist_node *plist_last(struct plist_head  const  *head )  __attribute__((__no_instrument_function__)) ;
#line 294 "../../../analyzer/../bench/linux-headers/include/linux/plist.h"
__inline static struct plist_node *plist_last(struct plist_head  const  *head ) 
{ 
  struct list_head  const  *__mptr ;

  {
  {
#line 296
  __mptr = (struct list_head  const  *)head->node_list.prev;
  }
#line 296
  return ((struct plist_node *)((char *)__mptr - (unsigned long )(& ((struct plist_node *)0)->node_list)));
}
}
#line 32 "../../../analyzer/../bench/linux-headers/include/linux/sem.h"
extern int copy_semundo(unsigned long clone_flags , struct task_struct *tsk ) ;
#line 33
extern void exit_sem(struct task_struct *tsk ) ;
#line 53 "../../../analyzer/../bench/linux-headers/include/linux/shm.h"
extern long do_shmat(int shmid , char *shmaddr , int shmflg , unsigned long *addr ,
                     unsigned long shmlba ) ;
#line 55
extern int is_file_shm_hugepages(struct file *file ) ;
#line 56
extern void exit_shm(struct task_struct *task ) ;
#line 33 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/signal.h"
extern void do_notify_resume(struct pt_regs * , void * , __u32  ) ;
#line 18 "../../../analyzer/../bench/linux-headers/include/asm-generic/siginfo.h"
extern void do_schedule_next_timer(struct siginfo *info ) ;
#line 24
__inline static void copy_siginfo(struct siginfo *to , struct siginfo *from )  __attribute__((__no_instrument_function__)) ;
#line 24 "../../../analyzer/../bench/linux-headers/include/asm-generic/siginfo.h"
__inline static void copy_siginfo(struct siginfo *to , struct siginfo *from ) 
{ 


  {
#line 26
  if (from->si_code < 0) {
    {
#line 27
    memcpy((void *)to, (void const   *)from, sizeof(*to));
    }
  } else {
    {
#line 30
    memcpy((void *)to, (void const   *)from, 4UL * sizeof(int ) + sizeof(from->_sifields._sigchld));
    }
  }
#line 31
  return;
}
}
#line 35
extern int copy_siginfo_to_user(struct siginfo *to , struct siginfo  const  *from ) ;
#line 10 "../../../analyzer/../bench/linux-headers/include/linux/signal.h"
extern int print_fatal_signals ;
#line 39
__inline static void sigaddset(sigset_t *set , int _sig )  __attribute__((__no_instrument_function__)) ;
#line 39 "../../../analyzer/../bench/linux-headers/include/linux/signal.h"
__inline static void sigaddset(sigset_t *set , int _sig ) 
{ 
  unsigned long sig ;

  {
  {
#line 41
  sig = (unsigned long )(_sig - 1);
#line 43
  set->sig[0] |= 1UL << sig;
  }
#line 46
  return;
}
}
#line 48
__inline static void sigdelset(sigset_t *set , int _sig )  __attribute__((__no_instrument_function__)) ;
#line 48 "../../../analyzer/../bench/linux-headers/include/linux/signal.h"
__inline static void sigdelset(sigset_t *set , int _sig ) 
{ 
  unsigned long sig ;

  {
  {
#line 50
  sig = (unsigned long )(_sig - 1);
#line 52
  set->sig[0] &= ~ (1UL << sig);
  }
#line 55
  return;
}
}
#line 57
__inline static int sigismember(sigset_t *set , int _sig )  __attribute__((__no_instrument_function__)) ;
#line 57 "../../../analyzer/../bench/linux-headers/include/linux/signal.h"
__inline static int sigismember(sigset_t *set , int _sig ) 
{ 
  unsigned long sig ;

  {
  {
#line 59
  sig = (unsigned long )(_sig - 1);
  }
#line 61
  return ((int )(1UL & (set->sig[0] >> sig)));
}
}
#line 70
extern void _NSIG_WORDS_is_unsupported_size(void) ;
#line 68
__inline static int sigisemptyset(sigset_t *set )  __attribute__((__no_instrument_function__)) ;
#line 68 "../../../analyzer/../bench/linux-headers/include/linux/signal.h"
__inline static int sigisemptyset(sigset_t *set ) 
{ 


  {
  {
#line 72
  if (1 == 4) {
#line 72
    goto case_4;
  }
#line 75
  if (1 == 2) {
#line 75
    goto case_2;
  }
#line 77
  if (1 == 1) {
#line 77
    goto case_1;
  }
#line 79
  goto switch_default;
  case_4: /* CIL Label */ 
#line 73
  return ((((set->sig[3] | set->sig[2]) | set->sig[1]) | set->sig[0]) == 0UL);
  case_2: /* CIL Label */ 
#line 76
  return ((set->sig[1] | set->sig[0]) == 0UL);
  case_1: /* CIL Label */ 
#line 78
  return (set->sig[0] == 0UL);
  switch_default: /* CIL Label */ 
  {
#line 80
  _NSIG_WORDS_is_unsupported_size();
  }
#line 81
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 115
__inline static void sigorsets(sigset_t *r , sigset_t const   *a , sigset_t const   *b )  __attribute__((__no_instrument_function__)) ;
#line 115 "../../../analyzer/../bench/linux-headers/include/linux/signal.h"
__inline static void sigorsets(sigset_t *r , sigset_t const   *a , sigset_t const   *b ) 
{ 
  unsigned long a0 ;
  unsigned long a1 ;
  unsigned long a2 ;
  unsigned long a3 ;
  unsigned long b0 ;
  unsigned long b1 ;
  unsigned long b2 ;
  unsigned long b3 ;

  {
  {
#line 115
  if (1 == 4) {
#line 115
    goto case_4;
  }
#line 115
  if (1 == 2) {
#line 115
    goto case_2;
  }
#line 115
  if (1 == 1) {
#line 115
    goto case_1;
  }
#line 115
  goto switch_default;
  case_4: /* CIL Label */ 
  {
#line 115
  a3 = a->sig[3];
#line 115
  a2 = a->sig[2];
#line 115
  b3 = b->sig[3];
#line 115
  b2 = b->sig[2];
#line 115
  r->sig[3] = a3 | b3;
#line 115
  r->sig[2] = a2 | b2;
  }
  case_2: /* CIL Label */ 
  {
#line 115
  a1 = a->sig[1];
#line 115
  b1 = b->sig[1];
#line 115
  r->sig[1] = a1 | b1;
  }
  case_1: /* CIL Label */ 
  {
#line 115
  a0 = a->sig[0];
#line 115
  b0 = b->sig[0];
#line 115
  r->sig[0] = a0 | b0;
  }
#line 115
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 115
  _NSIG_WORDS_is_unsupported_size();
  }
  switch_break: /* CIL Label */ ;
  }
#line 115
  return;
}
}
#line 118
__inline static void sigandsets(sigset_t *r , sigset_t const   *a , sigset_t const   *b )  __attribute__((__no_instrument_function__)) ;
#line 118 "../../../analyzer/../bench/linux-headers/include/linux/signal.h"
__inline static void sigandsets(sigset_t *r , sigset_t const   *a , sigset_t const   *b ) 
{ 
  unsigned long a0 ;
  unsigned long a1 ;
  unsigned long a2 ;
  unsigned long a3 ;
  unsigned long b0 ;
  unsigned long b1 ;
  unsigned long b2 ;
  unsigned long b3 ;

  {
  {
#line 118
  if (1 == 4) {
#line 118
    goto case_4;
  }
#line 118
  if (1 == 2) {
#line 118
    goto case_2;
  }
#line 118
  if (1 == 1) {
#line 118
    goto case_1;
  }
#line 118
  goto switch_default;
  case_4: /* CIL Label */ 
  {
#line 118
  a3 = a->sig[3];
#line 118
  a2 = a->sig[2];
#line 118
  b3 = b->sig[3];
#line 118
  b2 = b->sig[2];
#line 118
  r->sig[3] = a3 & b3;
#line 118
  r->sig[2] = a2 & b2;
  }
  case_2: /* CIL Label */ 
  {
#line 118
  a1 = a->sig[1];
#line 118
  b1 = b->sig[1];
#line 118
  r->sig[1] = a1 & b1;
  }
  case_1: /* CIL Label */ 
  {
#line 118
  a0 = a->sig[0];
#line 118
  b0 = b->sig[0];
#line 118
  r->sig[0] = a0 & b0;
  }
#line 118
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 118
  _NSIG_WORDS_is_unsupported_size();
  }
  switch_break: /* CIL Label */ ;
  }
#line 118
  return;
}
}
#line 121
__inline static void sigandnsets(sigset_t *r , sigset_t const   *a , sigset_t const   *b )  __attribute__((__no_instrument_function__)) ;
#line 121 "../../../analyzer/../bench/linux-headers/include/linux/signal.h"
__inline static void sigandnsets(sigset_t *r , sigset_t const   *a , sigset_t const   *b ) 
{ 
  unsigned long a0 ;
  unsigned long a1 ;
  unsigned long a2 ;
  unsigned long a3 ;
  unsigned long b0 ;
  unsigned long b1 ;
  unsigned long b2 ;
  unsigned long b3 ;

  {
  {
#line 121
  if (1 == 4) {
#line 121
    goto case_4;
  }
#line 121
  if (1 == 2) {
#line 121
    goto case_2;
  }
#line 121
  if (1 == 1) {
#line 121
    goto case_1;
  }
#line 121
  goto switch_default;
  case_4: /* CIL Label */ 
  {
#line 121
  a3 = a->sig[3];
#line 121
  a2 = a->sig[2];
#line 121
  b3 = b->sig[3];
#line 121
  b2 = b->sig[2];
#line 121
  r->sig[3] = a3 & ~ b3;
#line 121
  r->sig[2] = a2 & ~ b2;
  }
  case_2: /* CIL Label */ 
  {
#line 121
  a1 = a->sig[1];
#line 121
  b1 = b->sig[1];
#line 121
  r->sig[1] = a1 & ~ b1;
  }
  case_1: /* CIL Label */ 
  {
#line 121
  a0 = a->sig[0];
#line 121
  b0 = b->sig[0];
#line 121
  r->sig[0] = a0 & ~ b0;
  }
#line 121
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 121
  _NSIG_WORDS_is_unsupported_size();
  }
  switch_break: /* CIL Label */ ;
  }
#line 121
  return;
}
}
#line 145
__inline static void signotset(sigset_t *set )  __attribute__((__no_instrument_function__)) ;
#line 145 "../../../analyzer/../bench/linux-headers/include/linux/signal.h"
__inline static void signotset(sigset_t *set ) 
{ 


  {
  {
#line 145
  if (1 == 4) {
#line 145
    goto case_4;
  }
#line 145
  if (1 == 2) {
#line 145
    goto case_2;
  }
#line 145
  if (1 == 1) {
#line 145
    goto case_1;
  }
#line 145
  goto switch_default;
  case_4: /* CIL Label */ 
  {
#line 145
  set->sig[3] = ~ set->sig[3];
#line 145
  set->sig[2] = ~ set->sig[2];
  }
  case_2: /* CIL Label */ 
  {
#line 145
  set->sig[1] = ~ set->sig[1];
  }
  case_1: /* CIL Label */ 
  {
#line 145
  set->sig[0] = ~ set->sig[0];
  }
#line 145
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 145
  _NSIG_WORDS_is_unsupported_size();
  }
  switch_break: /* CIL Label */ ;
  }
#line 145
  return;
}
}
#line 150
__inline static void sigemptyset(sigset_t *set )  __attribute__((__no_instrument_function__)) ;
#line 150 "../../../analyzer/../bench/linux-headers/include/linux/signal.h"
__inline static void sigemptyset(sigset_t *set ) 
{ 


  {
  {
#line 156
  if (1 == 2) {
#line 156
    goto case_2;
  }
#line 157
  if (1 == 1) {
#line 157
    goto case_1;
  }
#line 153
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 154
  memset((void *)set, 0, sizeof(sigset_t ));
  }
#line 155
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 156
  set->sig[1] = 0UL;
  }
  case_1: /* CIL Label */ 
  {
#line 157
  set->sig[0] = 0UL;
  }
#line 158
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 160
  return;
}
}
#line 162
__inline static void sigfillset(sigset_t *set )  __attribute__((__no_instrument_function__)) ;
#line 162 "../../../analyzer/../bench/linux-headers/include/linux/signal.h"
__inline static void sigfillset(sigset_t *set ) 
{ 


  {
  {
#line 168
  if (1 == 2) {
#line 168
    goto case_2;
  }
#line 169
  if (1 == 1) {
#line 169
    goto case_1;
  }
#line 165
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 166
  memset((void *)set, -1, sizeof(sigset_t ));
  }
#line 167
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 168
  set->sig[1] = 0xffffffffffffffffUL;
  }
  case_1: /* CIL Label */ 
  {
#line 169
  set->sig[0] = 0xffffffffffffffffUL;
  }
#line 170
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 172
  return;
}
}
#line 176
__inline static void sigaddsetmask(sigset_t *set , unsigned long mask )  __attribute__((__no_instrument_function__)) ;
#line 176 "../../../analyzer/../bench/linux-headers/include/linux/signal.h"
__inline static void sigaddsetmask(sigset_t *set , unsigned long mask ) 
{ 


  {
  {
#line 178
  set->sig[0] |= mask;
  }
#line 179
  return;
}
}
#line 181
__inline static void sigdelsetmask(sigset_t *set , unsigned long mask )  __attribute__((__no_instrument_function__)) ;
#line 181 "../../../analyzer/../bench/linux-headers/include/linux/signal.h"
__inline static void sigdelsetmask(sigset_t *set , unsigned long mask ) 
{ 


  {
  {
#line 183
  set->sig[0] &= ~ mask;
  }
#line 184
  return;
}
}
#line 186
__inline static int sigtestsetmask(sigset_t *set , unsigned long mask )  __attribute__((__no_instrument_function__)) ;
#line 186 "../../../analyzer/../bench/linux-headers/include/linux/signal.h"
__inline static int sigtestsetmask(sigset_t *set , unsigned long mask ) 
{ 


  {
#line 188
  return ((set->sig[0] & mask) != 0UL);
}
}
#line 191
__inline static void siginitset(sigset_t *set , unsigned long mask )  __attribute__((__no_instrument_function__)) ;
#line 191 "../../../analyzer/../bench/linux-headers/include/linux/signal.h"
__inline static void siginitset(sigset_t *set , unsigned long mask ) 
{ 


  {
  {
#line 193
  set->sig[0] = mask;
  }
  {
#line 198
  if (1 == 2) {
#line 198
    goto case_2;
  }
#line 199
  if (1 == 1) {
#line 199
    goto case_1;
  }
#line 195
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 196
  memset((void *)(& set->sig[1]), 0, 0UL);
  }
#line 197
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 198
  set->sig[1] = 0UL;
  }
  case_1: /* CIL Label */ 
  {

  }
  switch_break: /* CIL Label */ ;
  }
#line 201
  return;
}
}
#line 203
__inline static void siginitsetinv(sigset_t *set , unsigned long mask )  __attribute__((__no_instrument_function__)) ;
#line 203 "../../../analyzer/../bench/linux-headers/include/linux/signal.h"
__inline static void siginitsetinv(sigset_t *set , unsigned long mask ) 
{ 


  {
  {
#line 205
  set->sig[0] = ~ mask;
  }
  {
#line 210
  if (1 == 2) {
#line 210
    goto case_2;
  }
#line 211
  if (1 == 1) {
#line 211
    goto case_1;
  }
#line 207
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 208
  memset((void *)(& set->sig[1]), -1, 0UL);
  }
#line 209
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 210
  set->sig[1] = 0xffffffffffffffffUL;
  }
  case_1: /* CIL Label */ 
  {

  }
  switch_break: /* CIL Label */ ;
  }
#line 213
  return;
}
}
#line 217
__inline static void init_sigpending(struct sigpending *sig )  __attribute__((__no_instrument_function__)) ;
#line 217 "../../../analyzer/../bench/linux-headers/include/linux/signal.h"
__inline static void init_sigpending(struct sigpending *sig ) 
{ 


  {
  {
#line 219
  sigemptyset(& sig->signal);
#line 220
  INIT_LIST_HEAD(& sig->list);
  }
#line 221
  return;
}
}
#line 223
extern void flush_sigqueue(struct sigpending *queue ) ;
#line 226
__inline static int valid_signal(unsigned long sig )  __attribute__((__no_instrument_function__)) ;
#line 226 "../../../analyzer/../bench/linux-headers/include/linux/signal.h"
__inline static int valid_signal(unsigned long sig ) 
{ 
  int tmp ;

  {
#line 228
  if (sig <= 64UL) {
    {
#line 228
    tmp = 1;
    }
  } else {
    {
#line 228
    tmp = 0;
    }
  }
#line 228
  return (tmp);
}
}
#line 234
extern int next_signal(struct sigpending *pending , sigset_t *mask ) ;
#line 235
extern int do_send_sig_info(int sig , struct siginfo *info , struct task_struct *p ,
                            bool group ) ;
#line 237
extern int group_send_sig_info(int sig , struct siginfo *info , struct task_struct *p ) ;
#line 238
extern int __group_send_sig_info(int  , struct siginfo * , struct task_struct * ) ;
#line 239
extern int do_sigtimedwait(sigset_t const   * , siginfo_t * , struct timespec  const  * ) ;
#line 241
extern int sigprocmask(int  , sigset_t * , sigset_t * ) ;
#line 242
extern void set_current_blocked(sigset_t * ) ;
#line 243
extern void __set_current_blocked(sigset_t const   * ) ;
#line 244
extern int show_unhandled_signals ;
#line 245
extern int sigsuspend(sigset_t * ) ;
#line 283
extern int get_signal(struct ksignal *ksig ) ;
#line 284
extern void signal_setup_done(int failed , struct ksignal *ksig , int stepping ) ;
#line 285
extern void exit_signals(struct task_struct *tsk ) ;
#line 286
extern void kernel_sigaction(int  , __sighandler_t  ) ;
#line 288
__inline static void allow_signal(int sig )  __attribute__((__no_instrument_function__)) ;
#line 288 "../../../analyzer/../bench/linux-headers/include/linux/signal.h"
__inline static void allow_signal(int sig ) 
{ 


  {
  {
#line 295
  kernel_sigaction(sig, (__sighandler_t )2);
  }
#line 296
  return;
}
}
#line 298
__inline static void disallow_signal(int sig )  __attribute__((__no_instrument_function__)) ;
#line 298 "../../../analyzer/../bench/linux-headers/include/linux/signal.h"
__inline static void disallow_signal(int sig ) 
{ 


  {
  {
#line 300
  kernel_sigaction(sig, (__sighandler_t )1);
  }
#line 301
  return;
}
}
#line 303
extern struct kmem_cache *sighand_cachep ;
#line 305
extern int unhandled_signal(struct task_struct *tsk , int sig ) ;
#line 430
extern void signals_init(void) ;
#line 432
extern int restore_altstack(stack_t const   * ) ;
#line 433
extern int __save_altstack(stack_t * , unsigned long  ) ;
#line 445
extern void render_sigset_t(struct seq_file * , char const   * , sigset_t * ) ;
#line 67 "../../../analyzer/../bench/linux-headers/include/linux/pid.h"
extern struct pid init_struct_pid ;
#line 75
__inline static struct pid *get_pid(struct pid *pid )  __attribute__((__no_instrument_function__)) ;
#line 75 "../../../analyzer/../bench/linux-headers/include/linux/pid.h"
__inline static struct pid *get_pid(struct pid *pid ) 
{ 


  {
#line 77
  if (pid) {
    {
#line 78
    atomic_inc(& pid->count);
    }
  }
#line 79
  return (pid);
}
}
#line 82
extern void put_pid(struct pid *pid ) ;
#line 83
extern struct task_struct *pid_task(struct pid *pid , enum pid_type  ) ;
#line 84
extern struct task_struct *get_pid_task(struct pid *pid , enum pid_type  ) ;
#line 86
extern struct pid *get_task_pid(struct task_struct *task , enum pid_type type ) ;
#line 91
extern void attach_pid(struct task_struct *task , enum pid_type  ) ;
#line 92
extern void detach_pid(struct task_struct *task , enum pid_type  ) ;
#line 93
extern void change_pid(struct task_struct *task , enum pid_type  , struct pid *pid ) ;
#line 95
extern void transfer_pid(struct task_struct *old , struct task_struct *new , enum pid_type  ) ;
#line 99
extern struct pid_namespace init_pid_ns ;
#line 110
extern struct pid *find_pid_ns(int nr , struct pid_namespace *ns ) ;
#line 111
extern struct pid *find_vpid(int nr ) ;
#line 116
extern struct pid *find_get_pid(int nr ) ;
#line 117
extern struct pid *find_ge_pid(int nr , struct pid_namespace * ) ;
#line 118
extern int next_pidmap(struct pid_namespace *pid_ns , unsigned int last ) ;
#line 120
extern struct pid *alloc_pid(struct pid_namespace *ns ) ;
#line 121
extern void free_pid(struct pid *pid ) ;
#line 122
extern void disable_pid_allocation(struct pid_namespace *ns ) ;
#line 134
__inline static struct pid_namespace *ns_of_pid(struct pid *pid )  __attribute__((__no_instrument_function__)) ;
#line 134 "../../../analyzer/../bench/linux-headers/include/linux/pid.h"
__inline static struct pid_namespace *ns_of_pid(struct pid *pid ) 
{ 
  struct pid_namespace *ns ;

  {
  {
#line 136
  ns = (struct pid_namespace *)((void *)0);
  }
#line 137
  if (pid) {
    {
#line 138
    ns = pid->numbers[pid->level].ns;
    }
  }
#line 139
  return (ns);
}
}
#line 148
__inline static bool is_child_reaper(struct pid *pid )  __attribute__((__no_instrument_function__)) ;
#line 148 "../../../analyzer/../bench/linux-headers/include/linux/pid.h"
__inline static bool is_child_reaper(struct pid *pid ) 
{ 


  {
#line 150
  return ((bool )(pid->numbers[pid->level].nr == 1));
}
}
#line 164
__inline static pid_t pid_nr(struct pid *pid )  __attribute__((__no_instrument_function__)) ;
#line 164 "../../../analyzer/../bench/linux-headers/include/linux/pid.h"
__inline static pid_t pid_nr(struct pid *pid ) 
{ 
  pid_t nr ;

  {
  {
#line 166
  nr = 0;
  }
#line 167
  if (pid) {
    {
#line 168
    nr = pid->numbers[0].nr;
    }
  }
#line 169
  return (nr);
}
}
#line 172
extern pid_t pid_nr_ns(struct pid *pid , struct pid_namespace *ns ) ;
#line 173
extern pid_t pid_vnr(struct pid *pid ) ;
#line 27 "../../../analyzer/../bench/linux-headers/include/linux/percpu_counter.h"
extern int percpu_counter_batch ;
#line 29
extern int __percpu_counter_init(struct percpu_counter *fbc , s64 amount , struct lock_class_key *key ) ;
#line 39
extern void percpu_counter_destroy(struct percpu_counter *fbc ) ;
#line 40
extern void percpu_counter_set(struct percpu_counter *fbc , s64 amount ) ;
#line 41
extern void __percpu_counter_add(struct percpu_counter *fbc , s64 amount , s32 batch ) ;
#line 42
extern s64 __percpu_counter_sum(struct percpu_counter *fbc ) ;
#line 43
extern int percpu_counter_compare(struct percpu_counter *fbc , s64 rhs ) ;
#line 45
__inline static void percpu_counter_add(struct percpu_counter *fbc , s64 amount )  __attribute__((__no_instrument_function__)) ;
#line 45 "../../../analyzer/../bench/linux-headers/include/linux/percpu_counter.h"
__inline static void percpu_counter_add(struct percpu_counter *fbc , s64 amount ) 
{ 


  {
  {
#line 47
  __percpu_counter_add(fbc, amount, percpu_counter_batch);
  }
#line 48
  return;
}
}
#line 50
__inline static s64 percpu_counter_sum_positive(struct percpu_counter *fbc )  __attribute__((__no_instrument_function__)) ;
#line 50 "../../../analyzer/../bench/linux-headers/include/linux/percpu_counter.h"
__inline static s64 percpu_counter_sum_positive(struct percpu_counter *fbc ) 
{ 
  s64 ret ;
  s64 tmp ;
  s64 tmp___0 ;

  {
  {
#line 52
  tmp = __percpu_counter_sum(fbc);
#line 52
  ret = tmp;
  }
#line 53
  if (ret < 0LL) {
    {
#line 53
    tmp___0 = (s64 )0;
    }
  } else {
    {
#line 53
    tmp___0 = ret;
    }
  }
#line 53
  return (tmp___0);
}
}
#line 56
__inline static s64 percpu_counter_sum(struct percpu_counter *fbc )  __attribute__((__no_instrument_function__)) ;
#line 56 "../../../analyzer/../bench/linux-headers/include/linux/percpu_counter.h"
__inline static s64 percpu_counter_sum(struct percpu_counter *fbc ) 
{ 
  s64 tmp ;

  {
  {
#line 58
  tmp = __percpu_counter_sum(fbc);
  }
#line 58
  return (tmp);
}
}
#line 61
__inline static s64 percpu_counter_read(struct percpu_counter *fbc )  __attribute__((__no_instrument_function__)) ;
#line 61 "../../../analyzer/../bench/linux-headers/include/linux/percpu_counter.h"
__inline static s64 percpu_counter_read(struct percpu_counter *fbc ) 
{ 


  {
#line 63
  return (fbc->count);
}
}
#line 71
__inline static s64 percpu_counter_read_positive(struct percpu_counter *fbc )  __attribute__((__no_instrument_function__)) ;
#line 71 "../../../analyzer/../bench/linux-headers/include/linux/percpu_counter.h"
__inline static s64 percpu_counter_read_positive(struct percpu_counter *fbc ) 
{ 
  s64 ret ;

  {
  {
#line 73
  ret = fbc->count;
#line 75
  __asm__  volatile   ("": : : "memory");
  }
#line 76
  if (ret >= 0LL) {
#line 77
    return (ret);
  }
#line 78
  return ((s64 )0);
}
}
#line 81
__inline static int percpu_counter_initialized(struct percpu_counter *fbc )  __attribute__((__no_instrument_function__)) ;
#line 81 "../../../analyzer/../bench/linux-headers/include/linux/percpu_counter.h"
__inline static int percpu_counter_initialized(struct percpu_counter *fbc ) 
{ 


  {
#line 83
  return ((unsigned long )fbc->counters != (unsigned long )((void *)0));
}
}
#line 162
__inline static void percpu_counter_inc(struct percpu_counter *fbc )  __attribute__((__no_instrument_function__)) ;
#line 162 "../../../analyzer/../bench/linux-headers/include/linux/percpu_counter.h"
__inline static void percpu_counter_inc(struct percpu_counter *fbc ) 
{ 


  {
  {
#line 164
  percpu_counter_add(fbc, (s64 )1);
  }
#line 165
  return;
}
}
#line 167
__inline static void percpu_counter_dec(struct percpu_counter *fbc )  __attribute__((__no_instrument_function__)) ;
#line 167 "../../../analyzer/../bench/linux-headers/include/linux/percpu_counter.h"
__inline static void percpu_counter_dec(struct percpu_counter *fbc ) 
{ 


  {
  {
#line 169
  percpu_counter_add(fbc, (s64 )-1);
  }
#line 170
  return;
}
}
#line 172
__inline static void percpu_counter_sub(struct percpu_counter *fbc , s64 amount )  __attribute__((__no_instrument_function__)) ;
#line 172 "../../../analyzer/../bench/linux-headers/include/linux/percpu_counter.h"
__inline static void percpu_counter_sub(struct percpu_counter *fbc , s64 amount ) 
{ 


  {
  {
#line 174
  percpu_counter_add(fbc, - amount);
  }
#line 175
  return;
}
}
#line 43 "../../../analyzer/../bench/linux-headers/include/linux/proportions.h"
extern int prop_descriptor_init(struct prop_descriptor *pd , int shift ) ;
#line 44
extern void prop_change_shift(struct prop_descriptor *pd , int new_shift ) ;
#line 64
extern int prop_local_init_percpu(struct prop_local_percpu *pl ) ;
#line 65
extern void prop_local_destroy_percpu(struct prop_local_percpu *pl ) ;
#line 66
extern void __prop_inc_percpu(struct prop_descriptor *pd , struct prop_local_percpu *pl ) ;
#line 67
extern void prop_fraction_percpu(struct prop_descriptor *pd , struct prop_local_percpu *pl ,
                                 long *numerator , long *denominator ) ;
#line 70
__inline static void prop_inc_percpu(struct prop_descriptor *pd , struct prop_local_percpu *pl )  __attribute__((__no_instrument_function__)) ;
#line 70 "../../../analyzer/../bench/linux-headers/include/linux/proportions.h"
__inline static void prop_inc_percpu(struct prop_descriptor *pd , struct prop_local_percpu *pl ) 
{ 
  unsigned long flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;
  unsigned long __dummy___1 ;
  unsigned long __dummy2___1 ;
  unsigned long __dummy___2 ;
  unsigned long __dummy2___2 ;
  int tmp ;

  {
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 75
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 75
      flags = arch_local_irq_save();
      }
#line 75
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 75
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 75
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 75
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 76
  __prop_inc_percpu(pd, pl);
  }
  {
#line 77
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 77
    tmp = arch_irqs_disabled_flags(flags);
    }
#line 77
    if (tmp) {
      {
#line 77
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 77
        arch_local_irq_restore(flags);
        }
#line 77
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 77
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 77
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else {
      {
#line 77
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 77
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 77
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 77
        arch_local_irq_restore(flags);
        }
#line 77
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 77
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 78
  return;
}
}
#line 93
extern void __prop_inc_percpu_max(struct prop_descriptor *pd , struct prop_local_percpu *pl ,
                                  long frac ) ;
#line 120
extern int prop_local_init_single(struct prop_local_single *pl ) ;
#line 121
extern void prop_local_destroy_single(struct prop_local_single *pl ) ;
#line 122
extern void __prop_inc_single(struct prop_descriptor *pd , struct prop_local_single *pl ) ;
#line 123
extern void prop_fraction_single(struct prop_descriptor *pd , struct prop_local_single *pl ,
                                 long *numerator , long *denominator ) ;
#line 126
__inline static void prop_inc_single(struct prop_descriptor *pd , struct prop_local_single *pl )  __attribute__((__no_instrument_function__)) ;
#line 126 "../../../analyzer/../bench/linux-headers/include/linux/proportions.h"
__inline static void prop_inc_single(struct prop_descriptor *pd , struct prop_local_single *pl ) 
{ 
  unsigned long flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;
  unsigned long __dummy___1 ;
  unsigned long __dummy2___1 ;
  unsigned long __dummy___2 ;
  unsigned long __dummy2___2 ;
  int tmp ;

  {
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 131
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 131
      flags = arch_local_irq_save();
      }
#line 131
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 131
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 131
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 131
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 132
  __prop_inc_single(pd, pl);
  }
  {
#line 133
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 133
    tmp = arch_irqs_disabled_flags(flags);
    }
#line 133
    if (tmp) {
      {
#line 133
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 133
        arch_local_irq_restore(flags);
        }
#line 133
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 133
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 133
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else {
      {
#line 133
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 133
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 133
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 133
        arch_local_irq_restore(flags);
        }
#line 133
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 133
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 134
  return;
}
}
#line 30 "../../../analyzer/../bench/linux-headers/include/linux/seccomp.h"
extern int __secure_computing(int  ) ;
#line 31
__inline static int secure_computing(int this_syscall )  __attribute__((__no_instrument_function__)) ;
#line 31 "../../../analyzer/../bench/linux-headers/include/linux/seccomp.h"
__inline static int secure_computing(int this_syscall ) 
{ 
  int tmp ;
  struct thread_info *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  {
#line 33
  tmp___0 = current_thread_info();
#line 33
  tmp___1 = test_ti_thread_flag(tmp___0, 8);
  }
#line 33
  if (tmp___1) {
    {
#line 33
    tmp___2 = 1;
    }
  } else {
    {
#line 33
    tmp___2 = 0;
    }
  }
  {
#line 33
  tmp___3 = __builtin_expect((long )tmp___2, 0L);
  }
#line 33
  if (tmp___3) {
    {
#line 34
    tmp = __secure_computing(this_syscall);
    }
#line 34
    return (tmp);
  }
#line 35
  return (0);
}
}
#line 39
__inline static void secure_computing_strict(int this_syscall )  __attribute__((__no_instrument_function__)) ;
#line 39 "../../../analyzer/../bench/linux-headers/include/linux/seccomp.h"
__inline static void secure_computing_strict(int this_syscall ) 
{ 
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 41
    tmp = secure_computing(this_syscall);
    }
#line 41
    if (tmp != 0) {
      {
#line 41
      tmp___0 = 1;
      }
    } else {
      {
#line 41
      tmp___0 = 0;
      }
    }
    {
#line 41
    tmp___1 = __builtin_expect((long )tmp___0, 0L);
    }
#line 41
    if (tmp___1) {
      {
#line 41
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 41
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("../../../analyzer/../bench/linux-headers/include/linux/seccomp.h"),
                             "i" (41), "i" (sizeof(struct bug_entry )));
#line 41
        __builtin_unreachable();
        }
#line 41
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 41
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return;
}
}
#line 44
extern long prctl_get_seccomp(void) ;
#line 45
extern long prctl_set_seccomp(unsigned long  , char * ) ;
#line 47
__inline static int seccomp_mode(struct seccomp *s )  __attribute__((__no_instrument_function__)) ;
#line 47 "../../../analyzer/../bench/linux-headers/include/linux/seccomp.h"
__inline static int seccomp_mode(struct seccomp *s ) 
{ 


  {
#line 49
  return (s->mode);
}
}
#line 79
extern void put_seccomp_filter(struct task_struct *tsk ) ;
#line 80
extern void get_seccomp_filter(struct task_struct *tsk ) ;
#line 30 "../../../analyzer/../bench/linux-headers/include/linux/rculist.h"
__inline static void INIT_LIST_HEAD_RCU(struct list_head *list )  __attribute__((__no_instrument_function__)) ;
#line 30 "../../../analyzer/../bench/linux-headers/include/linux/rculist.h"
__inline static void INIT_LIST_HEAD_RCU(struct list_head *list ) 
{ 


  {
  {
#line 32
  *((struct list_head * volatile  *)(& list->next)) = (struct list_head * volatile  )list;
#line 33
  *((struct list_head * volatile  *)(& list->prev)) = (struct list_head * volatile  )list;
  }
#line 34
  return;
}
}
#line 54
extern void __compiletime_assert_54(void)  __attribute__((__error__("Need native word sized stores/loads for atomicity."))) ;
#line 49
__inline static void __list_add_rcu(struct list_head *new , struct list_head *prev ,
                                    struct list_head *next )  __attribute__((__no_instrument_function__)) ;
#line 49 "../../../analyzer/../bench/linux-headers/include/linux/rculist.h"
__inline static void __list_add_rcu(struct list_head *new , struct list_head *prev ,
                                    struct list_head *next ) 
{ 
  bool __cond ;
  int tmp ;

  {
  {
#line 52
  new->next = next;
#line 53
  new->prev = prev;
  }
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 54
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 54
      if (sizeof(prev->next) == sizeof(int )) {
        {
#line 54
        tmp = 0;
        }
      } else
#line 54
      if (sizeof(prev->next) == sizeof(long )) {
        {
#line 54
        tmp = 0;
        }
      } else {
        {
#line 54
        tmp = 1;
        }
      }
      {
#line 54
      __cond = (bool )tmp;
      }
#line 54
      if (__cond) {
        {
#line 54
        __compiletime_assert_54();
        }
      }
      {
#line 54
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 54
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 54
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 54
    __asm__  volatile   ("": : : "memory");
#line 54
    *((struct list_head * volatile  *)(& prev->next)) = (struct list_head * volatile  )new;
    }
#line 54
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 55
  next->prev = new;
  }
#line 56
  return;
}
}
#line 78
__inline static void list_add_rcu(struct list_head *new , struct list_head *head )  __attribute__((__no_instrument_function__)) ;
#line 78 "../../../analyzer/../bench/linux-headers/include/linux/rculist.h"
__inline static void list_add_rcu(struct list_head *new , struct list_head *head ) 
{ 


  {
  {
#line 80
  __list_add_rcu(new, head, head->next);
  }
#line 81
  return;
}
}
#line 99
__inline static void list_add_tail_rcu(struct list_head *new , struct list_head *head )  __attribute__((__no_instrument_function__)) ;
#line 99 "../../../analyzer/../bench/linux-headers/include/linux/rculist.h"
__inline static void list_add_tail_rcu(struct list_head *new , struct list_head *head ) 
{ 


  {
  {
#line 102
  __list_add_rcu(new, head->prev, head);
  }
#line 103
  return;
}
}
#line 129
__inline static void list_del_rcu(struct list_head *entry )  __attribute__((__no_instrument_function__)) ;
#line 129 "../../../analyzer/../bench/linux-headers/include/linux/rculist.h"
__inline static void list_del_rcu(struct list_head *entry ) 
{ 


  {
  {
#line 131
  __list_del_entry(entry);
#line 132
  entry->prev = (struct list_head *)((void *)2097664 + 0xdead000000000000UL);
  }
#line 133
  return;
}
}
#line 155
__inline static void hlist_del_init_rcu(struct hlist_node *n )  __attribute__((__no_instrument_function__)) ;
#line 155 "../../../analyzer/../bench/linux-headers/include/linux/rculist.h"
__inline static void hlist_del_init_rcu(struct hlist_node *n ) 
{ 
  int tmp ;

  {
  {
#line 157
  tmp = hlist_unhashed((struct hlist_node  const  *)n);
  }
#line 157
  if (! tmp) {
    {
#line 158
    __hlist_del(n);
#line 159
    n->pprev = (struct hlist_node **)((void *)0);
    }
  }
#line 161
  return;
}
}
#line 176
extern void __compiletime_assert_176(void)  __attribute__((__error__("Need native word sized stores/loads for atomicity."))) ;
#line 171
__inline static void list_replace_rcu(struct list_head *old , struct list_head *new )  __attribute__((__no_instrument_function__)) ;
#line 171 "../../../analyzer/../bench/linux-headers/include/linux/rculist.h"
__inline static void list_replace_rcu(struct list_head *old , struct list_head *new ) 
{ 
  bool __cond ;
  int tmp ;

  {
  {
#line 174
  new->next = old->next;
#line 175
  new->prev = old->prev;
  }
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 176
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 176
      if (sizeof((new->prev)->next) == sizeof(int )) {
        {
#line 176
        tmp = 0;
        }
      } else
#line 176
      if (sizeof((new->prev)->next) == sizeof(long )) {
        {
#line 176
        tmp = 0;
        }
      } else {
        {
#line 176
        tmp = 1;
        }
      }
      {
#line 176
      __cond = (bool )tmp;
      }
#line 176
      if (__cond) {
        {
#line 176
        __compiletime_assert_176();
        }
      }
      {
#line 176
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 176
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 176
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 176
    __asm__  volatile   ("": : : "memory");
#line 176
    *((struct list_head * volatile  *)(& (new->prev)->next)) = (struct list_head * volatile  )new;
    }
#line 176
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 177
  (new->next)->prev = new;
#line 178
  old->prev = (struct list_head *)((void *)2097664 + 0xdead000000000000UL);
  }
#line 179
  return;
}
}
#line 235
extern void __compiletime_assert_235(void)  __attribute__((__error__("Need native word sized stores/loads for atomicity."))) ;
#line 198
__inline static void list_splice_init_rcu(struct list_head *list , struct list_head *head ,
                                          void (*sync)(void) )  __attribute__((__no_instrument_function__)) ;
#line 198 "../../../analyzer/../bench/linux-headers/include/linux/rculist.h"
__inline static void list_splice_init_rcu(struct list_head *list , struct list_head *head ,
                                          void (*sync)(void) ) 
{ 
  struct list_head *first ;
  struct list_head *last ;
  struct list_head *at ;
  int tmp ;
  bool __cond ;
  int tmp___0 ;

  {
  {
#line 202
  first = list->next;
#line 203
  last = list->prev;
#line 204
  at = head->next;
#line 206
  tmp = list_empty((struct list_head  const  *)list);
  }
#line 206
  if (tmp) {
#line 207
    return;
  }
  {
#line 215
  INIT_LIST_HEAD_RCU(list);
#line 224
  (*sync)();
#line 234
  last->next = at;
  }
  {
#line 235
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 235
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 235
      if (sizeof(head->next) == sizeof(int )) {
        {
#line 235
        tmp___0 = 0;
        }
      } else
#line 235
      if (sizeof(head->next) == sizeof(long )) {
        {
#line 235
        tmp___0 = 0;
        }
      } else {
        {
#line 235
        tmp___0 = 1;
        }
      }
      {
#line 235
      __cond = (bool )tmp___0;
      }
#line 235
      if (__cond) {
        {
#line 235
        __compiletime_assert_235();
        }
      }
      {
#line 235
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 235
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 235
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 235
    __asm__  volatile   ("": : : "memory");
#line 235
    *((struct list_head * volatile  *)(& head->next)) = (struct list_head * volatile  )first;
    }
#line 235
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 236
  first->prev = head;
#line 237
  at->prev = last;
  }
#line 238
  return;
}
}
#line 343
__inline static void hlist_del_rcu(struct hlist_node *n )  __attribute__((__no_instrument_function__)) ;
#line 343 "../../../analyzer/../bench/linux-headers/include/linux/rculist.h"
__inline static void hlist_del_rcu(struct hlist_node *n ) 
{ 


  {
  {
#line 345
  __hlist_del(n);
#line 346
  n->pprev = (struct hlist_node **)((void *)2097664 + 0xdead000000000000UL);
  }
#line 347
  return;
}
}
#line 363
extern void __compiletime_assert_363(void)  __attribute__((__error__("Need native word sized stores/loads for atomicity."))) ;
#line 356
__inline static void hlist_replace_rcu(struct hlist_node *old , struct hlist_node *new )  __attribute__((__no_instrument_function__)) ;
#line 356 "../../../analyzer/../bench/linux-headers/include/linux/rculist.h"
__inline static void hlist_replace_rcu(struct hlist_node *old , struct hlist_node *new ) 
{ 
  struct hlist_node *next ;
  bool __cond ;
  int tmp ;

  {
  {
#line 359
  next = old->next;
#line 361
  new->next = next;
#line 362
  new->pprev = old->pprev;
  }
  {
#line 363
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 363
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 363
      if (sizeof(*(new->pprev)) == sizeof(int )) {
        {
#line 363
        tmp = 0;
        }
      } else
#line 363
      if (sizeof(*(new->pprev)) == sizeof(long )) {
        {
#line 363
        tmp = 0;
        }
      } else {
        {
#line 363
        tmp = 1;
        }
      }
      {
#line 363
      __cond = (bool )tmp;
      }
#line 363
      if (__cond) {
        {
#line 363
        __compiletime_assert_363();
        }
      }
      {
#line 363
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 363
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 363
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 363
    __asm__  volatile   ("": : : "memory");
#line 363
    *((struct hlist_node * volatile  *)new->pprev) = (struct hlist_node * volatile  )new;
    }
#line 363
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 364
  if (next) {
    {
#line 365
    (new->next)->pprev = & new->next;
    }
  }
  {
#line 366
  old->pprev = (struct hlist_node **)((void *)2097664 + 0xdead000000000000UL);
  }
#line 367
  return;
}
}
#line 402
extern void __compiletime_assert_402(void)  __attribute__((__error__("Need native word sized stores/loads for atomicity."))) ;
#line 395
__inline static void hlist_add_head_rcu(struct hlist_node *n , struct hlist_head *h )  __attribute__((__no_instrument_function__)) ;
#line 395 "../../../analyzer/../bench/linux-headers/include/linux/rculist.h"
__inline static void hlist_add_head_rcu(struct hlist_node *n , struct hlist_head *h ) 
{ 
  struct hlist_node *first ;
  bool __cond ;
  int tmp ;

  {
  {
#line 398
  first = h->first;
#line 400
  n->next = first;
#line 401
  n->pprev = & h->first;
  }
  {
#line 402
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 402
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 402
      if (sizeof(h->first) == sizeof(int )) {
        {
#line 402
        tmp = 0;
        }
      } else
#line 402
      if (sizeof(h->first) == sizeof(long )) {
        {
#line 402
        tmp = 0;
        }
      } else {
        {
#line 402
        tmp = 1;
        }
      }
      {
#line 402
      __cond = (bool )tmp;
      }
#line 402
      if (__cond) {
        {
#line 402
        __compiletime_assert_402();
        }
      }
      {
#line 402
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 402
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 402
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 402
    __asm__  volatile   ("": : : "memory");
#line 402
    *((struct hlist_node * volatile  *)(& h->first)) = (struct hlist_node * volatile  )n;
    }
#line 402
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  if (first) {
    {
#line 404
    first->pprev = & n->next;
    }
  }
#line 405
  return;
}
}
#line 430
extern void __compiletime_assert_430(void)  __attribute__((__error__("Need native word sized stores/loads for atomicity."))) ;
#line 425
__inline static void hlist_add_before_rcu(struct hlist_node *n , struct hlist_node *next )  __attribute__((__no_instrument_function__)) ;
#line 425 "../../../analyzer/../bench/linux-headers/include/linux/rculist.h"
__inline static void hlist_add_before_rcu(struct hlist_node *n , struct hlist_node *next ) 
{ 
  bool __cond ;
  int tmp ;

  {
  {
#line 428
  n->pprev = next->pprev;
#line 429
  n->next = next;
  }
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 430
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 430
      if (sizeof(*(n->pprev)) == sizeof(int )) {
        {
#line 430
        tmp = 0;
        }
      } else
#line 430
      if (sizeof(*(n->pprev)) == sizeof(long )) {
        {
#line 430
        tmp = 0;
        }
      } else {
        {
#line 430
        tmp = 1;
        }
      }
      {
#line 430
      __cond = (bool )tmp;
      }
#line 430
      if (__cond) {
        {
#line 430
        __compiletime_assert_430();
        }
      }
      {
#line 430
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 430
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 430
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 430
    __asm__  volatile   ("": : : "memory");
#line 430
    *((struct hlist_node * volatile  *)n->pprev) = (struct hlist_node * volatile  )n;
    }
#line 430
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 431
  next->pprev = & n->next;
  }
#line 432
  return;
}
}
#line 457
extern void __compiletime_assert_457(void)  __attribute__((__error__("Need native word sized stores/loads for atomicity."))) ;
#line 452
__inline static void hlist_add_behind_rcu(struct hlist_node *n , struct hlist_node *prev )  __attribute__((__no_instrument_function__)) ;
#line 452 "../../../analyzer/../bench/linux-headers/include/linux/rculist.h"
__inline static void hlist_add_behind_rcu(struct hlist_node *n , struct hlist_node *prev ) 
{ 
  bool __cond ;
  int tmp ;

  {
  {
#line 455
  n->next = prev->next;
#line 456
  n->pprev = & prev->next;
  }
  {
#line 457
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 457
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 457
      if (sizeof(prev->next) == sizeof(int )) {
        {
#line 457
        tmp = 0;
        }
      } else
#line 457
      if (sizeof(prev->next) == sizeof(long )) {
        {
#line 457
        tmp = 0;
        }
      } else {
        {
#line 457
        tmp = 1;
        }
      }
      {
#line 457
      __cond = (bool )tmp;
      }
#line 457
      if (__cond) {
        {
#line 457
        __compiletime_assert_457();
        }
      }
      {
#line 457
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 457
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 457
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 457
    __asm__  volatile   ("": : : "memory");
#line 457
    *((struct hlist_node * volatile  *)(& prev->next)) = (struct hlist_node * volatile  )n;
    }
#line 457
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 458
  if (n->next) {
    {
#line 459
    (n->next)->pprev = & n->next;
    }
  }
#line 460
  return;
}
}
#line 19 "../../../analyzer/../bench/linux-headers/include/linux/rtmutex.h"
extern int max_lock_depth ;
#line 50
__inline static int rt_mutex_debug_check_no_locks_freed(void const   *from , unsigned long len )  __attribute__((__no_instrument_function__)) ;
#line 50 "../../../analyzer/../bench/linux-headers/include/linux/rtmutex.h"
__inline static int rt_mutex_debug_check_no_locks_freed(void const   *from , unsigned long len ) 
{ 


  {
#line 53
  return (0);
}
}
#line 84
__inline static int rt_mutex_is_locked(struct rt_mutex *lock )  __attribute__((__no_instrument_function__)) ;
#line 84 "../../../analyzer/../bench/linux-headers/include/linux/rtmutex.h"
__inline static int rt_mutex_is_locked(struct rt_mutex *lock ) 
{ 


  {
#line 86
  return ((unsigned long )lock->owner != (unsigned long )((void *)0));
}
}
#line 89
extern void __rt_mutex_init(struct rt_mutex *lock , char const   *name ) ;
#line 90
extern void rt_mutex_destroy(struct rt_mutex *lock ) ;
#line 92
extern void rt_mutex_lock(struct rt_mutex *lock ) ;
#line 93
extern int rt_mutex_lock_interruptible(struct rt_mutex *lock ) ;
#line 94
extern int rt_mutex_timed_lock(struct rt_mutex *lock , struct hrtimer_sleeper *timeout ) ;
#line 97
extern int rt_mutex_trylock(struct rt_mutex *lock ) ;
#line 99
extern void rt_mutex_unlock(struct rt_mutex *lock ) ;
#line 9 "../../../analyzer/../bench/linux-headers/include/linux/resource.h"
extern int getrusage(struct task_struct *p , int who , struct rusage *ru ) ;
#line 10
extern int do_prlimit(struct task_struct *tsk , unsigned int resource , struct rlimit *new_rlim ,
                      struct rlimit *old_rlim ) ;
#line 42 "../../../analyzer/../bench/linux-headers/include/linux/latencytop.h"
__inline static void account_scheduler_latency(struct task_struct *task , int usecs ,
                                               int inter )  __attribute__((__no_instrument_function__)) ;
#line 42 "../../../analyzer/../bench/linux-headers/include/linux/latencytop.h"
__inline static void account_scheduler_latency(struct task_struct *task , int usecs ,
                                               int inter ) 
{ 


  {
#line 45
  return;
}
}
#line 47
__inline static void clear_all_latency_tracing(struct task_struct *p )  __attribute__((__no_instrument_function__)) ;
#line 47 "../../../analyzer/../bench/linux-headers/include/linux/latencytop.h"
__inline static void clear_all_latency_tracing(struct task_struct *p ) 
{ 


  {
#line 49
  return;
}
}
#line 58 "../../../analyzer/../bench/linux-headers/include/linux/assoc_array.h"
__inline static void assoc_array_init(struct assoc_array *array )  __attribute__((__no_instrument_function__)) ;
#line 58 "../../../analyzer/../bench/linux-headers/include/linux/assoc_array.h"
__inline static void assoc_array_init(struct assoc_array *array ) 
{ 


  {
  {
#line 60
  array->root = (struct assoc_array_ptr *)((void *)0);
#line 61
  array->nr_leaves_on_tree = 0UL;
  }
#line 62
  return;
}
}
#line 64
extern int assoc_array_iterate(struct assoc_array  const  *array , int (*iterator)(void const   *object ,
                                                                                   void *iterator_data ) ,
                               void *iterator_data ) ;
#line 68
extern void *assoc_array_find(struct assoc_array  const  *array , struct assoc_array_ops  const  *ops ,
                              void const   *index_key ) ;
#line 71
extern void assoc_array_destroy(struct assoc_array *array , struct assoc_array_ops  const  *ops ) ;
#line 73
extern struct assoc_array_edit *assoc_array_insert(struct assoc_array *array , struct assoc_array_ops  const  *ops ,
                                                   void const   *index_key , void *object ) ;
#line 77
extern void assoc_array_insert_set_object(struct assoc_array_edit *edit , void *object ) ;
#line 79
extern struct assoc_array_edit *assoc_array_delete(struct assoc_array *array , struct assoc_array_ops  const  *ops ,
                                                   void const   *index_key ) ;
#line 82
extern struct assoc_array_edit *assoc_array_clear(struct assoc_array *array , struct assoc_array_ops  const  *ops ) ;
#line 84
extern void assoc_array_apply_edit(struct assoc_array_edit *edit ) ;
#line 85
extern void assoc_array_cancel_edit(struct assoc_array_edit *edit ) ;
#line 86
extern int assoc_array_gc(struct assoc_array *array , struct assoc_array_ops  const  *ops ,
                          bool (*iterator)(void *object , void *iterator_data ) ,
                          void *iterator_data ) ;
#line 108 "../../../analyzer/../bench/linux-headers/include/linux/key.h"
__inline static key_ref_t make_key_ref(struct key  const  *key , bool possession )  __attribute__((__no_instrument_function__)) ;
#line 108 "../../../analyzer/../bench/linux-headers/include/linux/key.h"
__inline static key_ref_t make_key_ref(struct key  const  *key , bool possession ) 
{ 


  {
#line 111
  return ((key_ref_t )((unsigned long )key | (unsigned long )possession));
}
}
#line 114
__inline static struct key *key_ref_to_ptr(key_ref_t const   key_ref )  __attribute__((__no_instrument_function__)) ;
#line 114 "../../../analyzer/../bench/linux-headers/include/linux/key.h"
__inline static struct key *key_ref_to_ptr(key_ref_t const   key_ref ) 
{ 


  {
#line 116
  return ((struct key *)((unsigned long )key_ref & 0xfffffffffffffffeUL));
}
}
#line 119
__inline static bool is_key_possessed(key_ref_t const   key_ref )  __attribute__((__no_instrument_function__)) ;
#line 119 "../../../analyzer/../bench/linux-headers/include/linux/key.h"
__inline static bool is_key_possessed(key_ref_t const   key_ref ) 
{ 


  {
#line 121
  return ((bool )((unsigned long )key_ref & 1UL));
}
}
#line 214
extern struct key *key_alloc(struct key_type *type , char const   *desc , kuid_t uid ,
                             kgid_t gid , struct cred  const  *cred , key_perm_t perm ,
                             unsigned long flags ) ;
#line 227
extern void key_revoke(struct key *key ) ;
#line 228
extern void key_invalidate(struct key *key ) ;
#line 229
extern void key_put(struct key *key ) ;
#line 231
__inline static struct key *__key_get(struct key *key )  __attribute__((__no_instrument_function__)) ;
#line 231 "../../../analyzer/../bench/linux-headers/include/linux/key.h"
__inline static struct key *__key_get(struct key *key ) 
{ 


  {
  {
#line 233
  atomic_inc(& key->usage);
  }
#line 234
  return (key);
}
}
#line 237
__inline static struct key *key_get(struct key *key )  __attribute__((__no_instrument_function__)) ;
#line 237 "../../../analyzer/../bench/linux-headers/include/linux/key.h"
__inline static struct key *key_get(struct key *key ) 
{ 
  struct key *tmp ;
  struct key *tmp___0 ;

  {
#line 239
  if (key) {
    {
#line 239
    tmp = __key_get(key);
#line 239
    tmp___0 = tmp;
    }
  } else {
    {
#line 239
    tmp___0 = key;
    }
  }
#line 239
  return (tmp___0);
}
}
#line 242
__inline static void key_ref_put(key_ref_t key_ref )  __attribute__((__no_instrument_function__)) ;
#line 242 "../../../analyzer/../bench/linux-headers/include/linux/key.h"
__inline static void key_ref_put(key_ref_t key_ref ) 
{ 
  struct key *tmp ;

  {
  {
#line 244
  tmp = key_ref_to_ptr((key_ref_t const   )key_ref);
#line 244
  key_put(tmp);
  }
#line 245
  return;
}
}
#line 247
extern struct key *request_key(struct key_type *type , char const   *description ,
                               char const   *callout_info ) ;
#line 251
extern struct key *request_key_with_auxdata(struct key_type *type , char const   *description ,
                                            void const   *callout_info , size_t callout_len ,
                                            void *aux ) ;
#line 257
extern struct key *request_key_async(struct key_type *type , char const   *description ,
                                     void const   *callout_info , size_t callout_len ) ;
#line 262
extern struct key *request_key_async_with_auxdata(struct key_type *type , char const   *description ,
                                                  void const   *callout_info , size_t callout_len ,
                                                  void *aux ) ;
#line 268
extern int wait_for_key_construction(struct key *key , bool intr ) ;
#line 270
extern int key_validate(struct key  const  *key ) ;
#line 272
extern key_ref_t key_create_or_update(key_ref_t keyring , char const   *type , char const   *description ,
                                      void const   *payload , size_t plen , key_perm_t perm ,
                                      unsigned long flags ) ;
#line 280
extern int key_update(key_ref_t key , void const   *payload , size_t plen ) ;
#line 284
extern int key_link(struct key *keyring , struct key *key ) ;
#line 287
extern int key_unlink(struct key *keyring , struct key *key ) ;
#line 290
extern struct key *keyring_alloc(char const   *description , kuid_t uid , kgid_t gid ,
                                 struct cred  const  *cred , key_perm_t perm , unsigned long flags ,
                                 struct key *dest ) ;
#line 296
extern int keyring_clear(struct key *keyring ) ;
#line 298
extern key_ref_t keyring_search(key_ref_t keyring , struct key_type *type , char const   *description ) ;
#line 302
extern int keyring_add_key(struct key *keyring , struct key *key ) ;
#line 305
extern struct key *key_lookup(key_serial_t id ) ;
#line 307
__inline static key_serial_t key_serial(struct key  const  *key )  __attribute__((__no_instrument_function__)) ;
#line 307 "../../../analyzer/../bench/linux-headers/include/linux/key.h"
__inline static key_serial_t key_serial(struct key  const  *key ) 
{ 
  key_serial_t tmp ;

  {
#line 309
  if (key) {
    {
#line 309
    tmp = key->serial;
    }
  } else {
    {
#line 309
    tmp = (key_serial_t const   )0;
    }
  }
#line 309
  return ((key_serial_t )tmp);
}
}
#line 312
extern void key_set_timeout(struct key * , unsigned int  ) ;
#line 332
__inline static bool key_is_instantiated(struct key  const  *key )  __attribute__((__no_instrument_function__)) ;
#line 332 "../../../analyzer/../bench/linux-headers/include/linux/key.h"
__inline static bool key_is_instantiated(struct key  const  *key ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 334
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& key->flags));
  }
#line 334
  if (tmp) {
    {
#line 334
    tmp___1 = constant_test_bit(5L, (unsigned long const volatile   *)(& key->flags));
    }
#line 334
    if (tmp___1) {
      {
#line 334
      tmp___3 = 0;
      }
    } else {
      {
#line 334
      tmp___3 = 1;
      }
    }
  } else {
    {
#line 334
    tmp___3 = 0;
    }
  }
#line 334
  return ((bool )tmp___3);
}
}
#line 348
extern struct ctl_table key_sysctls[] ;
#line 353
extern int install_thread_keyring_to_cred(struct cred *cred ) ;
#line 354
extern void key_fsuid_changed(struct task_struct *tsk ) ;
#line 355
extern void key_fsgid_changed(struct task_struct *tsk ) ;
#line 356
extern void key_init(void) ;
#line 26 "../../../analyzer/../bench/linux-headers/include/linux/selinux.h"
extern bool selinux_is_enabled(void) ;
#line 49 "../../../analyzer/../bench/linux-headers/include/linux/cred.h"
__inline static struct group_info *get_group_info(struct group_info *gi )  __attribute__((__no_instrument_function__)) ;
#line 49 "../../../analyzer/../bench/linux-headers/include/linux/cred.h"
__inline static struct group_info *get_group_info(struct group_info *gi ) 
{ 


  {
  {
#line 51
  atomic_inc(& gi->usage);
  }
#line 52
  return (gi);
}
}
#line 65
extern struct group_info *groups_alloc(int  ) ;
#line 66
extern struct group_info init_groups ;
#line 67
extern void groups_free(struct group_info * ) ;
#line 68
extern int set_current_groups(struct group_info * ) ;
#line 69
extern void set_groups(struct cred * , struct group_info * ) ;
#line 70
extern int groups_search(struct group_info  const  * , kgid_t  ) ;
#line 76
extern int in_group_p(kgid_t  ) ;
#line 77
extern int in_egroup_p(kgid_t  ) ;
#line 141
extern void __put_cred(struct cred * ) ;
#line 142
extern void exit_creds(struct task_struct * ) ;
#line 143
extern int copy_creds(struct task_struct * , unsigned long  ) ;
#line 144
extern struct cred  const  *get_task_cred(struct task_struct * ) ;
#line 145
extern struct cred *cred_alloc_blank(void) ;
#line 146
extern struct cred *prepare_creds(void) ;
#line 147
extern struct cred *prepare_exec_creds(void) ;
#line 148
extern int commit_creds(struct cred * ) ;
#line 149
extern void abort_creds(struct cred * ) ;
#line 150
extern struct cred  const  *override_creds(struct cred  const  * ) ;
#line 151
extern void revert_creds(struct cred  const  * ) ;
#line 152
extern struct cred *prepare_kernel_cred(struct task_struct * ) ;
#line 153
extern int change_create_files_as(struct cred * , struct inode * ) ;
#line 154
extern int set_security_override(struct cred * , u32  ) ;
#line 155
extern int set_security_override_from_ctx(struct cred * , char const   * ) ;
#line 156
extern int set_create_files_as(struct cred * , struct inode * ) ;
#line 157
extern void __attribute__((__cold__))  cred_init(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 188
__inline static void validate_creds(struct cred  const  *cred )  __attribute__((__no_instrument_function__)) ;
#line 188 "../../../analyzer/../bench/linux-headers/include/linux/cred.h"
__inline static void validate_creds(struct cred  const  *cred ) 
{ 


  {
#line 190
  return;
}
}
#line 191
__inline static void validate_creds_for_do_exit(struct task_struct *tsk )  __attribute__((__no_instrument_function__)) ;
#line 191 "../../../analyzer/../bench/linux-headers/include/linux/cred.h"
__inline static void validate_creds_for_do_exit(struct task_struct *tsk ) 
{ 


  {
#line 193
  return;
}
}
#line 194
__inline static void validate_process_creds(void)  __attribute__((__no_instrument_function__)) ;
#line 194 "../../../analyzer/../bench/linux-headers/include/linux/cred.h"
__inline static void validate_process_creds(void) 
{ 


  {
#line 196
  return;
}
}
#line 206
__inline static struct cred *get_new_cred(struct cred *cred )  __attribute__((__no_instrument_function__)) ;
#line 206 "../../../analyzer/../bench/linux-headers/include/linux/cred.h"
__inline static struct cred *get_new_cred(struct cred *cred ) 
{ 


  {
  {
#line 208
  atomic_inc(& cred->usage);
  }
#line 209
  return (cred);
}
}
#line 225
__inline static struct cred  const  *get_cred(struct cred  const  *cred )  __attribute__((__no_instrument_function__)) ;
#line 225 "../../../analyzer/../bench/linux-headers/include/linux/cred.h"
__inline static struct cred  const  *get_cred(struct cred  const  *cred ) 
{ 
  struct cred *nonconst_cred ;
  struct cred *tmp ;

  {
  {
#line 227
  nonconst_cred = (struct cred *)cred;
#line 228
  validate_creds(cred);
#line 229
  tmp = get_new_cred(nonconst_cred);
  }
#line 229
  return ((struct cred  const  *)tmp);
}
}
#line 243
__inline static void put_cred(struct cred  const  *_cred )  __attribute__((__no_instrument_function__)) ;
#line 243 "../../../analyzer/../bench/linux-headers/include/linux/cred.h"
__inline static void put_cred(struct cred  const  *_cred ) 
{ 
  int tmp___6 ;
  int tmp___5 ;
  int tmp___4 ;
  int tmp___3 ;
  int tmp___2 ;
  int tmp___1 ;
  int tmp___0 ;
  int tmp ;
  struct cred *cred ;
  int tmp ;

  {
  {
#line 245
  cred = (struct cred *)_cred;
#line 247
  validate_creds((struct cred  const  *)cred);
#line 248
  tmp = atomic_dec_and_test(& cred->usage);
  }
#line 248
  if (tmp) {
    {
#line 249
    __put_cred(cred);
    }
  }
#line 250
  return;
}
}
#line 150 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
extern unsigned long avenrun[] ;
#line 151
extern void get_avenrun(unsigned long *loads , unsigned long offset , int shift ) ;
#line 165
extern unsigned long total_forks ;
#line 166
extern int nr_threads ;
#line 167
extern unsigned long process_counts  __attribute__((__section__(".data..percpu"))) ;
#line 168
extern int nr_processes(void) ;
#line 169
extern unsigned long nr_running(void) ;
#line 170
extern unsigned long nr_iowait(void) ;
#line 171
extern unsigned long nr_iowait_cpu(int cpu ) ;
#line 172
extern void get_iowait_load(unsigned long *nr_waiters , unsigned long *load ) ;
#line 174
extern void calc_global_load(unsigned long ticks ) ;
#line 175
extern void update_cpu_load_nohz(void) ;
#line 177
extern unsigned long get_parent_ip(unsigned long addr ) ;
#line 179
extern void dump_cpu_task(int cpu ) ;
#line 219
extern char ___assert_task_state[1] ;
#line 276
extern rwlock_t tasklist_lock ;
#line 277
extern spinlock_t mmlist_lock ;
#line 285
extern void sched_init(void) ;
#line 286
extern void sched_init_smp(void) ;
#line 287
extern void schedule_tail(struct task_struct *prev ) ;
#line 288
extern void init_idle(struct task_struct *idle , int cpu ) ;
#line 289
extern void init_idle_bootup_task(struct task_struct *idle ) ;
#line 291
extern int runqueue_is_locked(int cpu ) ;
#line 294
extern void nohz_balance_enter_idle(int cpu ) ;
#line 295
extern void set_cpu_sd_state_idle(void) ;
#line 296
extern int get_nohz_timer_target(int pinned ) ;
#line 309
extern void show_state_filter(unsigned long state_filter ) ;
#line 311
__inline static void show_state(void)  __attribute__((__no_instrument_function__)) ;
#line 311 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void show_state(void) 
{ 


  {
  {
#line 313
  show_state_filter(0UL);
  }
#line 314
  return;
}
}
#line 316
extern void show_regs(struct pt_regs * ) ;
#line 323
extern void show_stack(struct task_struct *task , unsigned long *sp ) ;
#line 325
extern void io_schedule(void) ;
#line 326
extern long io_schedule_timeout(long timeout ) ;
#line 329
extern void trap_init(void) ;
#line 330
extern void update_process_times(int user ) ;
#line 331
extern void scheduler_tick(void) ;
#line 333
extern void sched_show_task(struct task_struct *p ) ;
#line 345
__inline static void touch_softlockup_watchdog(void)  __attribute__((__no_instrument_function__)) ;
#line 345 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void touch_softlockup_watchdog(void) 
{ 


  {
#line 347
  return;
}
}
#line 348
__inline static void touch_softlockup_watchdog_sync(void)  __attribute__((__no_instrument_function__)) ;
#line 348 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void touch_softlockup_watchdog_sync(void) 
{ 


  {
#line 350
  return;
}
}
#line 351
__inline static void touch_all_softlockup_watchdogs(void)  __attribute__((__no_instrument_function__)) ;
#line 351 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void touch_all_softlockup_watchdogs(void) 
{ 


  {
#line 353
  return;
}
}
#line 354
__inline static void lockup_detector_init(void)  __attribute__((__no_instrument_function__)) ;
#line 354 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void lockup_detector_init(void) 
{ 


  {
#line 356
  return;
}
}
#line 362
__inline static void reset_hung_task_detector(void)  __attribute__((__no_instrument_function__)) ;
#line 362 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void reset_hung_task_detector(void) 
{ 


  {
#line 364
  return;
}
}
#line 371
extern char __sched_text_start[] ;
#line 371
extern char __sched_text_end[] ;
#line 374
extern int in_sched_functions(unsigned long addr ) ;
#line 377
extern long schedule_timeout(long timeout ) ;
#line 378
extern long schedule_timeout_interruptible(long timeout ) ;
#line 379
extern long schedule_timeout_killable(long timeout ) ;
#line 380
extern long schedule_timeout_uninterruptible(long timeout ) ;
#line 381
extern void schedule(void) ;
#line 382
extern void schedule_preempt_disabled(void) ;
#line 388
extern void arch_pick_mmap_layout(struct mm_struct *mm ) ;
#line 389
extern unsigned long arch_get_unmapped_area(struct file * , unsigned long  , unsigned long  ,
                                            unsigned long  , unsigned long  ) ;
#line 392
extern unsigned long arch_get_unmapped_area_topdown(struct file *filp , unsigned long addr ,
                                                    unsigned long len , unsigned long pgoff ,
                                                    unsigned long flags ) ;
#line 410
extern void set_dumpable(struct mm_struct *mm , int value ) ;
#line 417
__inline static int __get_dumpable(unsigned long mm_flags )  __attribute__((__no_instrument_function__)) ;
#line 417 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static int __get_dumpable(unsigned long mm_flags ) 
{ 


  {
#line 419
  return ((int )(mm_flags & (unsigned long )((1 << 2) - 1)));
}
}
#line 422
__inline static int get_dumpable(struct mm_struct *mm )  __attribute__((__no_instrument_function__)) ;
#line 422 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static int get_dumpable(struct mm_struct *mm ) 
{ 
  int tmp___7 ;

  {
  {
#line 424
  tmp___7 = __get_dumpable(mm->flags);
  }
#line 424
  return (tmp___7);
}
}
#line 730
__inline static int signal_group_exit(struct signal_struct  const  *sig )  __attribute__((__no_instrument_function__)) ;
#line 730 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static int signal_group_exit(struct signal_struct  const  *sig ) 
{ 
  int tmp___7 ;

  {
#line 732
  if (sig->flags & 4U) {
    {
#line 732
    tmp___7 = 1;
    }
  } else
#line 732
  if ((unsigned long )sig->group_exit_task != (unsigned long )((void *)0)) {
    {
#line 732
    tmp___7 = 1;
    }
  } else {
    {
#line 732
    tmp___7 = 0;
    }
  }
#line 732
  return (tmp___7);
}
}
#line 773
extern int uids_sysfs_init(void) ;
#line 775
extern struct user_struct *find_user(kuid_t  ) ;
#line 777
extern struct user_struct root_user ;
#line 830
__inline static int sched_info_on(void)  __attribute__((__no_instrument_function__)) ;
#line 830 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static int sched_info_on(void) 
{ 


  {
#line 833
  return (1);
}
}
#line 875
__inline static int cpu_smt_flags(void)  __attribute__((__no_instrument_function__)) ;
#line 875 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static int cpu_smt_flags(void) 
{ 


  {
#line 877
  return (640);
}
}
#line 882
__inline static int cpu_core_flags(void)  __attribute__((__no_instrument_function__)) ;
#line 882 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static int cpu_core_flags(void) 
{ 


  {
#line 884
  return (512);
}
}
#line 889
__inline static int cpu_numa_flags(void)  __attribute__((__no_instrument_function__)) ;
#line 889 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static int cpu_numa_flags(void) 
{ 


  {
#line 891
  return (16384);
}
}
#line 903
extern int sched_domain_level_max ;
#line 987
__inline static struct cpumask *sched_domain_span(struct sched_domain *sd )  __attribute__((__no_instrument_function__)) ;
#line 987 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static struct cpumask *sched_domain_span(struct sched_domain *sd ) 
{ 
  int tmp___7 ;

  {
#line 989
  return ((struct cpumask *)(sd->span));
}
}
#line 992
extern void partition_sched_domains(int ndoms_new , cpumask_var_t *doms_new , struct sched_domain_attr *dattr_new ) ;
#line 996
extern cpumask_var_t *alloc_sched_domains(unsigned int ndoms ) ;
#line 997
extern void free_sched_domains(cpumask_var_t *doms , unsigned int ndoms ) ;
#line 999
extern bool cpus_share_cache(int this_cpu , int that_cpu ) ;
#line 1023
extern struct sched_domain_topology_level *sched_domain_topology ;
#line 1025
extern void set_sched_topology(struct sched_domain_topology_level *tl ) ;
#line 1057
__inline static void prefetch_stack(struct task_struct *t )  __attribute__((__no_instrument_function__)) ;
#line 1057 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void prefetch_stack(struct task_struct *t ) 
{ 


  {
#line 1057
  return;
}
}
#line 1665
__inline static void task_numa_fault(int last_node , int node , int pages , int flags )  __attribute__((__no_instrument_function__)) ;
#line 1665 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void task_numa_fault(int last_node , int node , int pages , int flags ) 
{ 


  {
#line 1668
  return;
}
}
#line 1669
__inline static pid_t task_numa_group_id(struct task_struct *p )  __attribute__((__no_instrument_function__)) ;
#line 1669 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static pid_t task_numa_group_id(struct task_struct *p ) 
{ 


  {
#line 1671
  return (0);
}
}
#line 1673
__inline static void set_numabalancing_state(bool enabled )  __attribute__((__no_instrument_function__)) ;
#line 1673 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void set_numabalancing_state(bool enabled ) 
{ 


  {
#line 1675
  return;
}
}
#line 1676
__inline static void task_numa_free(struct task_struct *p )  __attribute__((__no_instrument_function__)) ;
#line 1676 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void task_numa_free(struct task_struct *p ) 
{ 


  {
#line 1678
  return;
}
}
#line 1679
__inline static bool should_numa_migrate_memory(struct task_struct *p , struct page *page ,
                                                int src_nid , int dst_cpu )  __attribute__((__no_instrument_function__)) ;
#line 1679 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static bool should_numa_migrate_memory(struct task_struct *p , struct page *page ,
                                                int src_nid , int dst_cpu ) 
{ 


  {
#line 1682
  return ((bool )1);
}
}
#line 1686
__inline static struct pid *task_pid(struct task_struct *task )  __attribute__((__no_instrument_function__)) ;
#line 1686 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static struct pid *task_pid(struct task_struct *task ) 
{ 


  {
#line 1688
  return (task->pids[0].pid);
}
}
#line 1691
__inline static struct pid *task_tgid(struct task_struct *task )  __attribute__((__no_instrument_function__)) ;
#line 1691 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static struct pid *task_tgid(struct task_struct *task ) 
{ 


  {
#line 1693
  return ((task->group_leader)->pids[0].pid);
}
}
#line 1701
__inline static struct pid *task_pgrp(struct task_struct *task )  __attribute__((__no_instrument_function__)) ;
#line 1701 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static struct pid *task_pgrp(struct task_struct *task ) 
{ 


  {
#line 1703
  return ((task->group_leader)->pids[1].pid);
}
}
#line 1706
__inline static struct pid *task_session(struct task_struct *task )  __attribute__((__no_instrument_function__)) ;
#line 1706 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static struct pid *task_session(struct task_struct *task ) 
{ 


  {
#line 1708
  return ((task->group_leader)->pids[2].pid);
}
}
#line 1726
extern pid_t __task_pid_nr_ns(struct task_struct *task , enum pid_type type , struct pid_namespace *ns ) ;
#line 1729
__inline static pid_t task_pid_nr(struct task_struct *tsk )  __attribute__((__no_instrument_function__)) ;
#line 1729 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static pid_t task_pid_nr(struct task_struct *tsk ) 
{ 


  {
#line 1731
  return (tsk->pid);
}
}
#line 1734
__inline static pid_t task_pid_nr_ns(struct task_struct *tsk , struct pid_namespace *ns )  __attribute__((__no_instrument_function__)) ;
#line 1734 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static pid_t task_pid_nr_ns(struct task_struct *tsk , struct pid_namespace *ns ) 
{ 
  pid_t tmp___7 ;

  {
  {
#line 1737
  tmp___7 = __task_pid_nr_ns(tsk, (enum pid_type )0, ns);
  }
#line 1737
  return (tmp___7);
}
}
#line 1740
__inline static pid_t task_pid_vnr(struct task_struct *tsk )  __attribute__((__no_instrument_function__)) ;
#line 1740 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static pid_t task_pid_vnr(struct task_struct *tsk ) 
{ 
  pid_t tmp___7 ;

  {
  {
#line 1742
  tmp___7 = __task_pid_nr_ns(tsk, (enum pid_type )0, (struct pid_namespace *)((void *)0));
  }
#line 1742
  return (tmp___7);
}
}
#line 1746
__inline static pid_t task_tgid_nr(struct task_struct *tsk )  __attribute__((__no_instrument_function__)) ;
#line 1746 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static pid_t task_tgid_nr(struct task_struct *tsk ) 
{ 


  {
#line 1748
  return (tsk->tgid);
}
}
#line 1751
extern pid_t task_tgid_nr_ns(struct task_struct *tsk , struct pid_namespace *ns ) ;
#line 1753
__inline static pid_t task_tgid_vnr(struct task_struct *tsk )  __attribute__((__no_instrument_function__)) ;
#line 1753 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static pid_t task_tgid_vnr(struct task_struct *tsk ) 
{ 
  struct pid *tmp___7 ;
  pid_t tmp___8 ;

  {
  {
#line 1755
  tmp___7 = task_tgid(tsk);
#line 1755
  tmp___8 = pid_vnr(tmp___7);
  }
#line 1755
  return (tmp___8);
}
}
#line 1759
__inline static int pid_alive(struct task_struct  const  *p )  __attribute__((__no_instrument_function__)) ;
#line 1760
__inline static pid_t task_ppid_nr_ns(struct task_struct  const  *tsk , struct pid_namespace *ns )  __attribute__((__no_instrument_function__)) ;
#line 1760 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static pid_t task_ppid_nr_ns(struct task_struct  const  *tsk , struct pid_namespace *ns ) 
{ 
  pid_t pid ;
  struct task_struct *_________p1 ;
  int tmp___7 ;

  {
  {
#line 1762
  pid = 0;
#line 1764
  rcu_read_lock();
#line 1765
  tmp___7 = pid_alive(tsk);
  }
#line 1765
  if (tmp___7) {
    {
#line 1766
    _________p1 = (struct task_struct *)*((struct task_struct * const volatile  *)(& tsk->real_parent));
    }
    {
#line 1766
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1766
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1766
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1766
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1766
    pid = task_tgid_nr_ns(_________p1, ns);
    }
  }
  {
#line 1767
  rcu_read_unlock();
  }
#line 1769
  return (pid);
}
}
#line 1772
__inline static pid_t task_ppid_nr(struct task_struct  const  *tsk )  __attribute__((__no_instrument_function__)) ;
#line 1772 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static pid_t task_ppid_nr(struct task_struct  const  *tsk ) 
{ 
  pid_t tmp___7 ;

  {
  {
#line 1774
  tmp___7 = task_ppid_nr_ns(tsk, & init_pid_ns);
  }
#line 1774
  return (tmp___7);
}
}
#line 1777
__inline static pid_t task_pgrp_nr_ns(struct task_struct *tsk , struct pid_namespace *ns )  __attribute__((__no_instrument_function__)) ;
#line 1777 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static pid_t task_pgrp_nr_ns(struct task_struct *tsk , struct pid_namespace *ns ) 
{ 
  pid_t tmp___7 ;

  {
  {
#line 1780
  tmp___7 = __task_pid_nr_ns(tsk, (enum pid_type )1, ns);
  }
#line 1780
  return (tmp___7);
}
}
#line 1783
__inline static pid_t task_pgrp_vnr(struct task_struct *tsk )  __attribute__((__no_instrument_function__)) ;
#line 1783 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static pid_t task_pgrp_vnr(struct task_struct *tsk ) 
{ 
  pid_t tmp___7 ;

  {
  {
#line 1785
  tmp___7 = __task_pid_nr_ns(tsk, (enum pid_type )1, (struct pid_namespace *)((void *)0));
  }
#line 1785
  return (tmp___7);
}
}
#line 1789
__inline static pid_t task_session_nr_ns(struct task_struct *tsk , struct pid_namespace *ns )  __attribute__((__no_instrument_function__)) ;
#line 1789 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static pid_t task_session_nr_ns(struct task_struct *tsk , struct pid_namespace *ns ) 
{ 
  pid_t tmp___7 ;

  {
  {
#line 1792
  tmp___7 = __task_pid_nr_ns(tsk, (enum pid_type )2, ns);
  }
#line 1792
  return (tmp___7);
}
}
#line 1795
__inline static pid_t task_session_vnr(struct task_struct *tsk )  __attribute__((__no_instrument_function__)) ;
#line 1795 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static pid_t task_session_vnr(struct task_struct *tsk ) 
{ 
  pid_t tmp___7 ;

  {
  {
#line 1797
  tmp___7 = __task_pid_nr_ns(tsk, (enum pid_type )2, (struct pid_namespace *)((void *)0));
  }
#line 1797
  return (tmp___7);
}
}
#line 1801
__inline static pid_t task_pgrp_nr(struct task_struct *tsk )  __attribute__((__no_instrument_function__)) ;
#line 1801 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static pid_t task_pgrp_nr(struct task_struct *tsk ) 
{ 
  pid_t tmp___7 ;

  {
  {
#line 1803
  tmp___7 = task_pgrp_nr_ns(tsk, & init_pid_ns);
  }
#line 1803
  return (tmp___7);
}
}
#line 1816
__inline static int pid_alive(struct task_struct  const  *p )  __attribute__((__no_instrument_function__)) ;
#line 1816 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static int pid_alive(struct task_struct  const  *p ) 
{ 


  {
#line 1818
  return ((unsigned long )p->pids[0].pid != (unsigned long )((void *)0));
}
}
#line 1829
__inline static int is_global_init(struct task_struct *tsk )  __attribute__((__no_instrument_function__)) ;
#line 1829 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static int is_global_init(struct task_struct *tsk ) 
{ 


  {
#line 1831
  return (tsk->pid == 1);
}
}
#line 1834
extern struct pid *cad_pid ;
#line 1836
extern void free_task(struct task_struct *tsk ) ;
#line 1839
extern void __put_task_struct(struct task_struct *t ) ;
#line 1841
__inline static void put_task_struct(struct task_struct *t )  __attribute__((__no_instrument_function__)) ;
#line 1841 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void put_task_struct(struct task_struct *t ) 
{ 
  int tmp___7 ;

  {
  {
#line 1843
  tmp___7 = atomic_dec_and_test(& t->usage);
  }
#line 1843
  if (tmp___7) {
    {
#line 1844
    __put_task_struct(t);
    }
  }
#line 1845
  return;
}
}
#line 1854
__inline static void task_cputime(struct task_struct *t , cputime_t *utime , cputime_t *stime )  __attribute__((__no_instrument_function__)) ;
#line 1854 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void task_cputime(struct task_struct *t , cputime_t *utime , cputime_t *stime ) 
{ 


  {
#line 1857
  if (utime) {
    {
#line 1858
    *utime = t->utime;
    }
  }
#line 1859
  if (stime) {
    {
#line 1860
    *stime = t->stime;
    }
  }
#line 1861
  return;
}
}
#line 1863
__inline static void task_cputime_scaled(struct task_struct *t , cputime_t *utimescaled ,
                                         cputime_t *stimescaled )  __attribute__((__no_instrument_function__)) ;
#line 1863 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void task_cputime_scaled(struct task_struct *t , cputime_t *utimescaled ,
                                         cputime_t *stimescaled ) 
{ 


  {
#line 1867
  if (utimescaled) {
    {
#line 1868
    *utimescaled = t->utimescaled;
    }
  }
#line 1869
  if (stimescaled) {
    {
#line 1870
    *stimescaled = t->stimescaled;
    }
  }
#line 1871
  return;
}
}
#line 1873
__inline static cputime_t task_gtime(struct task_struct *t )  __attribute__((__no_instrument_function__)) ;
#line 1873 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static cputime_t task_gtime(struct task_struct *t ) 
{ 


  {
#line 1875
  return (t->gtime);
}
}
#line 1878
extern void task_cputime_adjusted(struct task_struct *p , cputime_t *ut , cputime_t *st ) ;
#line 1879
extern void thread_group_cputime_adjusted(struct task_struct *p , cputime_t *ut ,
                                          cputime_t *st ) ;
#line 1938
__inline static gfp_t memalloc_noio_flags(gfp_t flags )  __attribute__((__no_instrument_function__)) ;
#line 1938 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static gfp_t memalloc_noio_flags(gfp_t flags ) 
{ 
  struct task_struct *tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;

  {
  {
#line 1940
  tmp___7 = get_current();
  }
#line 1940
  if (tmp___7->flags & 524288U) {
    {
#line 1940
    tmp___8 = 1;
    }
  } else {
    {
#line 1940
    tmp___8 = 0;
    }
  }
  {
#line 1940
  tmp___9 = __builtin_expect((long )tmp___8, 0L);
  }
#line 1940
  if (tmp___9) {
    {
#line 1941
    flags &= 4294967231U;
    }
  }
#line 1942
  return (flags);
}
}
#line 1945
__inline static unsigned int memalloc_noio_save(void)  __attribute__((__no_instrument_function__)) ;
#line 1945 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static unsigned int memalloc_noio_save(void) 
{ 
  unsigned int flags ;
  struct task_struct *tmp___7 ;
  struct task_struct *tmp___8 ;

  {
  {
#line 1947
  tmp___7 = get_current();
#line 1947
  flags = tmp___7->flags & 524288U;
#line 1948
  tmp___8 = get_current();
#line 1948
  tmp___8->flags |= 524288U;
  }
#line 1949
  return (flags);
}
}
#line 1952
__inline static void memalloc_noio_restore(unsigned int flags )  __attribute__((__no_instrument_function__)) ;
#line 1952 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void memalloc_noio_restore(unsigned int flags ) 
{ 
  struct task_struct *tmp___7 ;
  struct task_struct *tmp___8 ;

  {
  {
#line 1954
  tmp___7 = get_current();
#line 1954
  tmp___8 = get_current();
#line 1954
  tmp___7->flags = (tmp___8->flags & 4294443007U) | flags;
  }
#line 1955
  return;
}
}
#line 1973
__inline static bool task_no_new_privs(struct task_struct *p )  __attribute__((__no_instrument_function__)) ;
#line 1973 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static bool task_no_new_privs(struct task_struct *p ) 
{ 
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 1973
  tmp___7 = constant_test_bit(0L, (unsigned long const volatile   *)(& p->atomic_flags));
  }
#line 1973
  return ((bool )tmp___7);
}
}
#line 1974
__inline static void task_set_no_new_privs(struct task_struct *p )  __attribute__((__no_instrument_function__)) ;
#line 1974 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void task_set_no_new_privs(struct task_struct *p ) 
{ 


  {
  {
#line 1974
  set_bit(0L, (unsigned long volatile   *)(& p->atomic_flags));
  }
#line 1974
  return;
}
}
#line 1976
__inline static bool task_spread_page(struct task_struct *p )  __attribute__((__no_instrument_function__)) ;
#line 1976 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static bool task_spread_page(struct task_struct *p ) 
{ 
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 1976
  tmp___7 = constant_test_bit(1L, (unsigned long const volatile   *)(& p->atomic_flags));
  }
#line 1976
  return ((bool )tmp___7);
}
}
#line 1977
__inline static void task_set_spread_page(struct task_struct *p )  __attribute__((__no_instrument_function__)) ;
#line 1977 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void task_set_spread_page(struct task_struct *p ) 
{ 


  {
  {
#line 1977
  set_bit(1L, (unsigned long volatile   *)(& p->atomic_flags));
  }
#line 1977
  return;
}
}
#line 1978
__inline static void task_clear_spread_page(struct task_struct *p )  __attribute__((__no_instrument_function__)) ;
#line 1978 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void task_clear_spread_page(struct task_struct *p ) 
{ 


  {
  {
#line 1978
  clear_bit(1L, (unsigned long volatile   *)(& p->atomic_flags));
  }
#line 1978
  return;
}
}
#line 1980
__inline static bool task_spread_slab(struct task_struct *p )  __attribute__((__no_instrument_function__)) ;
#line 1980 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static bool task_spread_slab(struct task_struct *p ) 
{ 
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 1980
  tmp___7 = constant_test_bit(2L, (unsigned long const volatile   *)(& p->atomic_flags));
  }
#line 1980
  return ((bool )tmp___7);
}
}
#line 1981
__inline static void task_set_spread_slab(struct task_struct *p )  __attribute__((__no_instrument_function__)) ;
#line 1981 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void task_set_spread_slab(struct task_struct *p ) 
{ 


  {
  {
#line 1981
  set_bit(2L, (unsigned long volatile   *)(& p->atomic_flags));
  }
#line 1981
  return;
}
}
#line 1982
__inline static void task_clear_spread_slab(struct task_struct *p )  __attribute__((__no_instrument_function__)) ;
#line 1982 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void task_clear_spread_slab(struct task_struct *p ) 
{ 


  {
  {
#line 1982
  clear_bit(2L, (unsigned long volatile   *)(& p->atomic_flags));
  }
#line 1982
  return;
}
}
#line 2008
extern bool task_set_jobctl_pending(struct task_struct *task , unsigned int mask ) ;
#line 2010
extern void task_clear_jobctl_trapping(struct task_struct *task ) ;
#line 2011
extern void task_clear_jobctl_pending(struct task_struct *task , unsigned int mask ) ;
#line 2031
__inline static void rcu_copy_process(struct task_struct *p )  __attribute__((__no_instrument_function__)) ;
#line 2031 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void rcu_copy_process(struct task_struct *p ) 
{ 


  {
#line 2033
  return;
}
}
#line 2037
__inline static void tsk_restore_flags(struct task_struct *task , unsigned long orig_flags ,
                                       unsigned long flags )  __attribute__((__no_instrument_function__)) ;
#line 2037 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void tsk_restore_flags(struct task_struct *task , unsigned long orig_flags ,
                                       unsigned long flags ) 
{ 


  {
  {
#line 2040
  task->flags = (unsigned int )((unsigned long )task->flags & ~ flags);
#line 2041
  task->flags = (unsigned int )((unsigned long )task->flags | (orig_flags & flags));
  }
#line 2042
  return;
}
}
#line 2045
extern void do_set_cpus_allowed(struct task_struct *p , struct cpumask  const  *new_mask ) ;
#line 2048
extern int set_cpus_allowed_ptr(struct task_struct *p , struct cpumask  const  *new_mask ) ;
#line 2065
extern void calc_load_enter_idle(void) ;
#line 2066
extern void calc_load_exit_idle(void) ;
#line 2073
__inline static int set_cpus_allowed(struct task_struct *p , cpumask_t new_mask )  __attribute__((__no_instrument_function__)) ;
#line 2073 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static int set_cpus_allowed(struct task_struct *p , cpumask_t new_mask ) 
{ 
  int tmp___7 ;

  {
  {
#line 2075
  tmp___7 = set_cpus_allowed_ptr(p, (struct cpumask  const  *)(& new_mask));
  }
#line 2075
  return (tmp___7);
}
}
#line 2087
extern unsigned long long sched_clock(void)  __attribute__((__no_instrument_function__)) ;
#line 2091
extern u64 cpu_clock(int cpu ) ;
#line 2092
extern u64 local_clock(void) ;
#line 2093
extern u64 sched_clock_cpu(int cpu ) ;
#line 2096
extern void sched_clock_init(void) ;
#line 2117
extern int sched_clock_stable(void) ;
#line 2118
extern void set_sched_clock_stable(void) ;
#line 2119
extern void clear_sched_clock_stable(void) ;
#line 2121
extern void sched_clock_tick(void) ;
#line 2122
extern void sched_clock_idle_sleep_event(void) ;
#line 2123
extern void sched_clock_idle_wakeup_event(u64 delta_ns ) ;
#line 2135
__inline static void enable_sched_clock_irqtime(void)  __attribute__((__no_instrument_function__)) ;
#line 2135 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void enable_sched_clock_irqtime(void) 
{ 


  {
#line 2135
  return;
}
}
#line 2136
__inline static void disable_sched_clock_irqtime(void)  __attribute__((__no_instrument_function__)) ;
#line 2136 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void disable_sched_clock_irqtime(void) 
{ 


  {
#line 2136
  return;
}
}
#line 2139
extern unsigned long long task_sched_runtime(struct task_struct *task ) ;
#line 2144
extern void sched_exec(void) ;
#line 2153
extern void idle_task_exit(void) ;
#line 2159
extern void wake_up_nohz_cpu(int cpu ) ;
#line 2168
__inline static bool sched_can_stop_tick(void)  __attribute__((__no_instrument_function__)) ;
#line 2168 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static bool sched_can_stop_tick(void) 
{ 


  {
#line 2168
  return ((bool )0);
}
}
#line 2181
__inline static void sched_autogroup_create_attach(struct task_struct *p )  __attribute__((__no_instrument_function__)) ;
#line 2181 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void sched_autogroup_create_attach(struct task_struct *p ) 
{ 


  {
#line 2181
  return;
}
}
#line 2182
__inline static void sched_autogroup_detach(struct task_struct *p )  __attribute__((__no_instrument_function__)) ;
#line 2182 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void sched_autogroup_detach(struct task_struct *p ) 
{ 


  {
#line 2182
  return;
}
}
#line 2183
__inline static void sched_autogroup_fork(struct signal_struct *sig )  __attribute__((__no_instrument_function__)) ;
#line 2183 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void sched_autogroup_fork(struct signal_struct *sig ) 
{ 


  {
#line 2183
  return;
}
}
#line 2184
__inline static void sched_autogroup_exit(struct signal_struct *sig )  __attribute__((__no_instrument_function__)) ;
#line 2184 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void sched_autogroup_exit(struct signal_struct *sig ) 
{ 


  {
#line 2184
  return;
}
}
#line 2187
extern int yield_to(struct task_struct *p , bool preempt ) ;
#line 2188
extern void set_user_nice(struct task_struct *p , long nice ) ;
#line 2189
extern int task_prio(struct task_struct  const  *p ) ;
#line 2196
__inline static int task_nice(struct task_struct  const  *p )  __attribute__((__no_instrument_function__)) ;
#line 2196 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static int task_nice(struct task_struct  const  *p ) 
{ 


  {
#line 2198
  return ((int )(p->static_prio - 120));
}
}
#line 2200
extern int can_nice(struct task_struct  const  *p , int const   nice ) ;
#line 2201
extern int task_curr(struct task_struct  const  *p ) ;
#line 2202
extern int idle_cpu(int cpu ) ;
#line 2203
extern int sched_setscheduler(struct task_struct * , int  , struct sched_param  const  * ) ;
#line 2205
extern int sched_setscheduler_nocheck(struct task_struct * , int  , struct sched_param  const  * ) ;
#line 2207
extern int sched_setattr(struct task_struct * , struct sched_attr  const  * ) ;
#line 2209
extern struct task_struct *idle_task(int cpu ) ;
#line 2216
__inline static bool is_idle_task(struct task_struct  const  *p )  __attribute__((__no_instrument_function__)) ;
#line 2216 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static bool is_idle_task(struct task_struct  const  *p ) 
{ 


  {
#line 2218
  return ((bool )(p->pid == 0));
}
}
#line 2220
extern struct task_struct *curr_task(int cpu ) ;
#line 2221
extern void set_curr_task(int cpu , struct task_struct *p ) ;
#line 2223
extern void yield(void) ;
#line 2228
extern struct exec_domain default_exec_domain ;
#line 2236
__inline static int kstack_end(void *addr )  __attribute__((__no_instrument_function__)) ;
#line 2236 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static int kstack_end(void *addr ) 
{ 


  {
#line 2241
  return (! ((((unsigned long )addr + sizeof(void *)) - 1UL) & (((1UL << 12) << 2) - sizeof(void *))));
}
}
#line 2245
extern union thread_union init_thread_union ;
#line 2246
extern struct task_struct init_task ;
#line 2248
extern struct mm_struct init_mm ;
#line 2263
extern struct task_struct *find_task_by_vpid(pid_t nr ) ;
#line 2264
extern struct task_struct *find_task_by_pid_ns(pid_t nr , struct pid_namespace *ns ) ;
#line 2268
extern struct user_struct *alloc_uid(kuid_t  ) ;
#line 2269
__inline static struct user_struct *get_uid(struct user_struct *u )  __attribute__((__no_instrument_function__)) ;
#line 2269 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static struct user_struct *get_uid(struct user_struct *u ) 
{ 


  {
  {
#line 2271
  atomic_inc(& u->__count);
  }
#line 2272
  return (u);
}
}
#line 2274
extern void free_uid(struct user_struct * ) ;
#line 2278
extern void xtime_update(unsigned long ticks ) ;
#line 2280
extern int wake_up_state(struct task_struct *tsk , unsigned int state ) ;
#line 2281
extern int wake_up_process(struct task_struct *tsk ) ;
#line 2282
extern void wake_up_new_task(struct task_struct *tsk ) ;
#line 2284
extern void kick_process(struct task_struct *tsk ) ;
#line 2288
extern int sched_fork(unsigned long clone_flags , struct task_struct *p ) ;
#line 2289
extern void sched_dead(struct task_struct *p ) ;
#line 2291
extern void proc_caches_init(void) ;
#line 2292
extern void flush_signals(struct task_struct * ) ;
#line 2293
extern void __flush_signals(struct task_struct * ) ;
#line 2294
extern void ignore_signals(struct task_struct * ) ;
#line 2295
extern void flush_signal_handlers(struct task_struct * , int force_default ) ;
#line 2296
extern int dequeue_signal(struct task_struct *tsk , sigset_t *mask , siginfo_t *info ) ;
#line 2298
__inline static int dequeue_signal_lock(struct task_struct *tsk , sigset_t *mask ,
                                        siginfo_t *info )  __attribute__((__no_instrument_function__)) ;
#line 2298 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static int dequeue_signal_lock(struct task_struct *tsk , sigset_t *mask ,
                                        siginfo_t *info ) 
{ 
  unsigned long flags ;
  int ret ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  raw_spinlock_t *tmp___7 ;

  {
  {
#line 2303
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2303
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2303
      tmp___7 = spinlock_check(& (tsk->sighand)->siglock);
#line 2303
      flags = _raw_spin_lock_irqsave(tmp___7);
      }
#line 2303
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2303
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2304
  ret = dequeue_signal(tsk, mask, info);
#line 2305
  spin_unlock_irqrestore(& (tsk->sighand)->siglock, flags);
  }
#line 2307
  return (ret);
}
}
#line 2310
extern void block_all_signals(int (*notifier)(void *priv ) , void *priv , sigset_t *mask ) ;
#line 2312
extern void unblock_all_signals(void) ;
#line 2313
extern void release_task(struct task_struct *p ) ;
#line 2314
extern int send_sig_info(int  , struct siginfo * , struct task_struct * ) ;
#line 2315
extern int force_sigsegv(int  , struct task_struct * ) ;
#line 2316
extern int force_sig_info(int  , struct siginfo * , struct task_struct * ) ;
#line 2317
extern int __kill_pgrp_info(int sig , struct siginfo *info , struct pid *pgrp ) ;
#line 2318
extern int kill_pid_info(int sig , struct siginfo *info , struct pid *pid ) ;
#line 2319
extern int kill_pid_info_as_cred(int  , struct siginfo * , struct pid * , struct cred  const  * ,
                                 u32  ) ;
#line 2321
extern int kill_pgrp(struct pid *pid , int sig , int priv ) ;
#line 2322
extern int kill_pid(struct pid *pid , int sig , int priv ) ;
#line 2323
extern int kill_proc_info(int  , struct siginfo * , pid_t  ) ;
#line 2324
extern bool ( __attribute__((__warn_unused_result__)) do_notify_parent)(struct task_struct * ,
                                                                        int  ) ;
#line 2325
extern void __wake_up_parent(struct task_struct *p , struct task_struct *parent ) ;
#line 2326
extern void force_sig(int  , struct task_struct * ) ;
#line 2327
extern int send_sig(int  , struct task_struct * , int  ) ;
#line 2328
extern int zap_other_threads(struct task_struct *p ) ;
#line 2329
extern struct sigqueue *sigqueue_alloc(void) ;
#line 2330
extern void sigqueue_free(struct sigqueue * ) ;
#line 2331
extern int send_sigqueue(struct sigqueue * , struct task_struct * , int group ) ;
#line 2332
extern int do_sigaction(int  , struct k_sigaction * , struct k_sigaction * ) ;
#line 2334
__inline static void restore_saved_sigmask(void)  __attribute__((__no_instrument_function__)) ;
#line 2334 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void restore_saved_sigmask(void) 
{ 
  struct task_struct *tmp___7 ;
  bool tmp___8 ;

  {
  {
#line 2336
  tmp___8 = test_and_clear_restore_sigmask();
  }
#line 2336
  if (tmp___8) {
    {
#line 2337
    tmp___7 = get_current();
#line 2337
    __set_current_blocked((sigset_t const   *)(& tmp___7->saved_sigmask));
    }
  }
#line 2338
  return;
}
}
#line 2340
__inline static sigset_t *sigmask_to_save(void)  __attribute__((__no_instrument_function__)) ;
#line 2340 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static sigset_t *sigmask_to_save(void) 
{ 
  sigset_t *res ;
  struct task_struct *tmp___7 ;
  struct task_struct *tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;

  {
  {
#line 2342
  tmp___7 = get_current();
#line 2342
  res = & tmp___7->blocked;
#line 2343
  tmp___9 = test_restore_sigmask();
  }
#line 2343
  if (tmp___9) {
    {
#line 2343
    tmp___10 = 1;
    }
  } else {
    {
#line 2343
    tmp___10 = 0;
    }
  }
  {
#line 2343
  tmp___11 = __builtin_expect((long )tmp___10, 0L);
  }
#line 2343
  if (tmp___11) {
    {
#line 2344
    tmp___8 = get_current();
#line 2344
    res = & tmp___8->saved_sigmask;
    }
  }
#line 2345
  return (res);
}
}
#line 2348
__inline static int kill_cad_pid(int sig , int priv )  __attribute__((__no_instrument_function__)) ;
#line 2348 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static int kill_cad_pid(int sig , int priv ) 
{ 
  int tmp___7 ;

  {
  {
#line 2350
  tmp___7 = kill_pid(cad_pid, sig, priv);
  }
#line 2350
  return (tmp___7);
}
}
#line 2361
__inline static int on_sig_stack(unsigned long sp )  __attribute__((__no_instrument_function__)) ;
#line 2361 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static int on_sig_stack(unsigned long sp ) 
{ 
  struct task_struct *tmp___7 ;
  struct task_struct *tmp___8 ;
  struct task_struct *tmp___9 ;
  int tmp___10 ;

  {
  {
#line 2367
  tmp___7 = get_current();
  }
#line 2367
  if (sp > tmp___7->sas_ss_sp) {
    {
#line 2367
    tmp___8 = get_current();
#line 2367
    tmp___9 = get_current();
    }
#line 2367
    if (sp - tmp___8->sas_ss_sp <= tmp___9->sas_ss_size) {
      {
#line 2367
      tmp___10 = 1;
      }
    } else {
      {
#line 2367
      tmp___10 = 0;
      }
    }
  } else {
    {
#line 2367
    tmp___10 = 0;
    }
  }
#line 2367
  return (tmp___10);
}
}
#line 2372
__inline static int sas_ss_flags(unsigned long sp )  __attribute__((__no_instrument_function__)) ;
#line 2372 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static int sas_ss_flags(unsigned long sp ) 
{ 
  struct task_struct *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 2374
  tmp___7 = get_current();
  }
#line 2374
  if (! tmp___7->sas_ss_size) {
#line 2375
    return (2);
  }
  {
#line 2377
  tmp___10 = on_sig_stack(sp);
  }
#line 2377
  if (tmp___10) {
    {
#line 2377
    tmp___9 = 1;
    }
  } else {
    {
#line 2377
    tmp___9 = 0;
    }
  }
#line 2377
  return (tmp___9);
}
}
#line 2380
__inline static unsigned long sigsp(unsigned long sp , struct ksignal *ksig )  __attribute__((__no_instrument_function__)) ;
#line 2380 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static unsigned long sigsp(unsigned long sp , struct ksignal *ksig ) 
{ 
  struct task_struct *tmp___7 ;
  struct task_struct *tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;

  {
  {
#line 2382
  tmp___9 = __builtin_expect((long )(! (! (ksig->ka.sa.sa_flags & 134217728UL))),
                             0L);
  }
#line 2382
  if (tmp___9) {
    {
#line 2382
    tmp___10 = sas_ss_flags(sp);
    }
#line 2382
    if (! tmp___10) {
      {
#line 2386
      tmp___7 = get_current();
#line 2386
      tmp___8 = get_current();
      }
#line 2386
      return (tmp___7->sas_ss_sp + tmp___8->sas_ss_size);
    }
  }
#line 2388
  return (sp);
}
}
#line 2394
extern struct mm_struct *mm_alloc(void) ;
#line 2397
extern void __mmdrop(struct mm_struct * ) ;
#line 2398
__inline static void mmdrop(struct mm_struct *mm )  __attribute__((__no_instrument_function__)) ;
#line 2398 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void mmdrop(struct mm_struct *mm ) 
{ 
  int tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;

  {
  {
#line 2400
  tmp___7 = atomic_dec_and_test(& mm->mm_count);
  }
#line 2400
  if (tmp___7) {
    {
#line 2400
    tmp___8 = 1;
    }
  } else {
    {
#line 2400
    tmp___8 = 0;
    }
  }
  {
#line 2400
  tmp___9 = __builtin_expect((long )tmp___8, 0L);
  }
#line 2400
  if (tmp___9) {
    {
#line 2401
    __mmdrop(mm);
    }
  }
#line 2402
  return;
}
}
#line 2405
extern void mmput(struct mm_struct * ) ;
#line 2407
extern struct mm_struct *get_task_mm(struct task_struct *task ) ;
#line 2413
extern struct mm_struct *mm_access(struct task_struct *task , unsigned int mode ) ;
#line 2415
extern void mm_release(struct task_struct * , struct mm_struct * ) ;
#line 2417
extern int copy_thread(unsigned long  , unsigned long  , unsigned long  , struct task_struct * ) ;
#line 2419
extern void flush_thread(void) ;
#line 2420
extern void exit_thread(void) ;
#line 2422
extern void exit_files(struct task_struct * ) ;
#line 2423
extern void __cleanup_sighand(struct sighand_struct * ) ;
#line 2425
extern void exit_itimers(struct signal_struct * ) ;
#line 2426
extern void flush_itimer_signals(void) ;
#line 2428
extern void do_group_exit(int  ) ;
#line 2430
extern int do_execve(struct filename * , char const   * const  * , char const   * const  * ) ;
#line 2433
extern long do_fork(unsigned long  , unsigned long  , unsigned long  , int * , int * ) ;
#line 2434
extern struct task_struct *fork_idle(int  ) ;
#line 2435
extern pid_t kernel_thread(int (*fn)(void * ) , void *arg , unsigned long flags ) ;
#line 2437
extern void __set_task_comm(struct task_struct *tsk , char const   *from , bool exec ) ;
#line 2438
__inline static void set_task_comm(struct task_struct *tsk , char const   *from )  __attribute__((__no_instrument_function__)) ;
#line 2438 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void set_task_comm(struct task_struct *tsk , char const   *from ) 
{ 


  {
  {
#line 2440
  __set_task_comm(tsk, from, (bool )0);
  }
#line 2441
  return;
}
}
#line 2442
extern char *get_task_comm(char *to , struct task_struct *tsk ) ;
#line 2445
extern void scheduler_ipi(void) ;
#line 2446
extern unsigned long wait_task_inactive(struct task_struct * , long match_state ) ;
#line 2462
extern bool current_is_single_threaded(void) ;
#line 2484
__inline static int get_nr_threads(struct task_struct *tsk )  __attribute__((__no_instrument_function__)) ;
#line 2484 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static int get_nr_threads(struct task_struct *tsk ) 
{ 


  {
#line 2486
  return ((tsk->signal)->nr_threads);
}
}
#line 2489
__inline static bool thread_group_leader(struct task_struct *p )  __attribute__((__no_instrument_function__)) ;
#line 2489 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static bool thread_group_leader(struct task_struct *p ) 
{ 


  {
#line 2491
  return ((bool )(p->exit_signal >= 0));
}
}
#line 2500
__inline static bool has_group_leader_pid(struct task_struct *p )  __attribute__((__no_instrument_function__)) ;
#line 2500 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static bool has_group_leader_pid(struct task_struct *p ) 
{ 
  struct pid *tmp___7 ;

  {
  {
#line 2502
  tmp___7 = task_pid(p);
  }
#line 2502
  return ((bool )((unsigned long )tmp___7 == (unsigned long )(p->signal)->leader_pid));
}
}
#line 2505
__inline static bool same_thread_group(struct task_struct *p1 , struct task_struct *p2 )  __attribute__((__no_instrument_function__)) ;
#line 2505 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static bool same_thread_group(struct task_struct *p1 , struct task_struct *p2 ) 
{ 


  {
#line 2508
  return ((bool )((unsigned long )p1->signal == (unsigned long )p2->signal));
}
}
#line 2511
__inline static struct task_struct *next_thread(struct task_struct  const  *p )  __attribute__((__no_instrument_function__)) ;
#line 2511 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static struct task_struct *next_thread(struct task_struct  const  *p ) 
{ 
  struct list_head *__ptr ;
  struct list_head  const  *__mptr ;
  struct list_head *_________p1 ;

  {
  {
#line 2513
  __ptr = (struct list_head *)p->thread_group.next;
#line 2513
  _________p1 = (struct list_head *)*((struct list_head * volatile  *)(& __ptr));
  }
  {
#line 2513
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2513
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2513
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2513
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2513
  __mptr = (struct list_head  const  *)((struct list_head * const  )_________p1);
  }
#line 2513
  return ((struct task_struct *)((char *)__mptr - (unsigned long )(& ((struct task_struct *)0)->thread_group)));
}
}
#line 2517
__inline static int thread_group_empty(struct task_struct *p )  __attribute__((__no_instrument_function__)) ;
#line 2517 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static int thread_group_empty(struct task_struct *p ) 
{ 
  int tmp___7 ;

  {
  {
#line 2519
  tmp___7 = list_empty((struct list_head  const  *)(& p->thread_group));
  }
#line 2519
  return (tmp___7);
}
}
#line 2535
__inline static void task_lock(struct task_struct *p )  __attribute__((__no_instrument_function__)) ;
#line 2535 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void task_lock(struct task_struct *p ) 
{ 


  {
  {
#line 2537
  spin_lock(& p->alloc_lock);
  }
#line 2538
  return;
}
}
#line 2540
__inline static void task_unlock(struct task_struct *p )  __attribute__((__no_instrument_function__)) ;
#line 2540 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void task_unlock(struct task_struct *p ) 
{ 


  {
  {
#line 2542
  spin_unlock(& p->alloc_lock);
  }
#line 2543
  return;
}
}
#line 2545
extern struct sighand_struct *__lock_task_sighand(struct task_struct *tsk , unsigned long *flags ) ;
#line 2548
__inline static struct sighand_struct *lock_task_sighand(struct task_struct *tsk ,
                                                         unsigned long *flags )  __attribute__((__no_instrument_function__)) ;
#line 2548 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static struct sighand_struct *lock_task_sighand(struct task_struct *tsk ,
                                                         unsigned long *flags ) 
{ 
  struct sighand_struct *ret ;

  {
  {
#line 2553
  ret = __lock_task_sighand(tsk, flags);
  }
#line 2555
  return (ret);
}
}
#line 2558
__inline static void unlock_task_sighand(struct task_struct *tsk , unsigned long *flags )  __attribute__((__no_instrument_function__)) ;
#line 2558 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void unlock_task_sighand(struct task_struct *tsk , unsigned long *flags ) 
{ 


  {
  {
#line 2561
  spin_unlock_irqrestore(& (tsk->sighand)->siglock, *flags);
  }
#line 2562
  return;
}
}
#line 2565
__inline static void threadgroup_change_begin(struct task_struct *tsk )  __attribute__((__no_instrument_function__)) ;
#line 2565 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void threadgroup_change_begin(struct task_struct *tsk ) 
{ 


  {
  {
#line 2567
  down_read(& (tsk->signal)->group_rwsem);
  }
#line 2568
  return;
}
}
#line 2569
__inline static void threadgroup_change_end(struct task_struct *tsk )  __attribute__((__no_instrument_function__)) ;
#line 2569 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void threadgroup_change_end(struct task_struct *tsk ) 
{ 


  {
  {
#line 2571
  up_read(& (tsk->signal)->group_rwsem);
  }
#line 2572
  return;
}
}
#line 2590
__inline static void threadgroup_lock(struct task_struct *tsk )  __attribute__((__no_instrument_function__)) ;
#line 2590 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void threadgroup_lock(struct task_struct *tsk ) 
{ 


  {
  {
#line 2592
  down_write(& (tsk->signal)->group_rwsem);
  }
#line 2593
  return;
}
}
#line 2601
__inline static void threadgroup_unlock(struct task_struct *tsk )  __attribute__((__no_instrument_function__)) ;
#line 2601 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void threadgroup_unlock(struct task_struct *tsk ) 
{ 


  {
  {
#line 2603
  up_write(& (tsk->signal)->group_rwsem);
  }
#line 2604
  return;
}
}
#line 2617
__inline static void setup_thread_stack(struct task_struct *p , struct task_struct *org )  __attribute__((__no_instrument_function__)) ;
#line 2617 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void setup_thread_stack(struct task_struct *p , struct task_struct *org ) 
{ 


  {
  {
#line 2619
  *((struct thread_info *)p->stack) = *((struct thread_info *)org->stack);
#line 2620
  ((struct thread_info *)p->stack)->task = p;
  }
#line 2621
  return;
}
}
#line 2632
__inline static unsigned long *end_of_stack(struct task_struct *p )  __attribute__((__no_instrument_function__)) ;
#line 2632 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static unsigned long *end_of_stack(struct task_struct *p ) 
{ 


  {
#line 2637
  return ((unsigned long *)((struct thread_info *)p->stack + 1));
}
}
#line 2643
__inline static int object_is_on_stack(void *obj )  __attribute__((__no_instrument_function__)) ;
#line 2643 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static int object_is_on_stack(void *obj ) 
{ 
  void *stack ;
  struct task_struct *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 2645
  tmp___7 = get_current();
#line 2645
  stack = tmp___7->stack;
  }
#line 2647
  if ((unsigned long )obj >= (unsigned long )stack) {
#line 2647
    if ((unsigned long )obj < (unsigned long )(stack + ((1UL << 12) << 2))) {
      {
#line 2647
      tmp___8 = 1;
      }
    } else {
      {
#line 2647
      tmp___8 = 0;
      }
    }
  } else {
    {
#line 2647
    tmp___8 = 0;
    }
  }
#line 2647
  return (tmp___8);
}
}
#line 2650
extern void thread_info_cache_init(void) ;
#line 2653
__inline static unsigned long stack_not_used(struct task_struct *p )  __attribute__((__no_instrument_function__)) ;
#line 2653 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static unsigned long stack_not_used(struct task_struct *p ) 
{ 
  unsigned long *n ;
  unsigned long *tmp___7 ;
  unsigned long *tmp___8 ;

  {
  {
#line 2655
  tmp___7 = end_of_stack(p);
#line 2655
  n = tmp___7;
  }
  {
#line 2657
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2658
    n ++;
    }
#line 2657
    if (! (! *n)) {
#line 2657
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2661
  tmp___8 = end_of_stack(p);
  }
#line 2661
  return ((unsigned long )n - (unsigned long )tmp___8);
}
}
#line 2668
__inline static void set_tsk_thread_flag(struct task_struct *tsk , int flag )  __attribute__((__no_instrument_function__)) ;
#line 2668 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void set_tsk_thread_flag(struct task_struct *tsk , int flag ) 
{ 


  {
  {
#line 2670
  set_ti_thread_flag((struct thread_info *)tsk->stack, flag);
  }
#line 2671
  return;
}
}
#line 2673
__inline static void clear_tsk_thread_flag(struct task_struct *tsk , int flag )  __attribute__((__no_instrument_function__)) ;
#line 2673 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void clear_tsk_thread_flag(struct task_struct *tsk , int flag ) 
{ 


  {
  {
#line 2675
  clear_ti_thread_flag((struct thread_info *)tsk->stack, flag);
  }
#line 2676
  return;
}
}
#line 2678
__inline static int test_and_set_tsk_thread_flag(struct task_struct *tsk , int flag )  __attribute__((__no_instrument_function__)) ;
#line 2678 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static int test_and_set_tsk_thread_flag(struct task_struct *tsk , int flag ) 
{ 
  int tmp___7 ;

  {
  {
#line 2680
  tmp___7 = test_and_set_ti_thread_flag((struct thread_info *)tsk->stack, flag);
  }
#line 2680
  return (tmp___7);
}
}
#line 2683
__inline static int test_and_clear_tsk_thread_flag(struct task_struct *tsk , int flag )  __attribute__((__no_instrument_function__)) ;
#line 2683 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static int test_and_clear_tsk_thread_flag(struct task_struct *tsk , int flag ) 
{ 
  int tmp___7 ;

  {
  {
#line 2685
  tmp___7 = test_and_clear_ti_thread_flag((struct thread_info *)tsk->stack, flag);
  }
#line 2685
  return (tmp___7);
}
}
#line 2688
__inline static int test_tsk_thread_flag(struct task_struct *tsk , int flag )  __attribute__((__no_instrument_function__)) ;
#line 2688 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static int test_tsk_thread_flag(struct task_struct *tsk , int flag ) 
{ 
  int tmp___7 ;

  {
  {
#line 2690
  tmp___7 = test_ti_thread_flag((struct thread_info *)tsk->stack, flag);
  }
#line 2690
  return (tmp___7);
}
}
#line 2693
__inline static void set_tsk_need_resched(struct task_struct *tsk )  __attribute__((__no_instrument_function__)) ;
#line 2693 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void set_tsk_need_resched(struct task_struct *tsk ) 
{ 


  {
  {
#line 2695
  set_tsk_thread_flag(tsk, 3);
  }
#line 2696
  return;
}
}
#line 2698
__inline static void clear_tsk_need_resched(struct task_struct *tsk )  __attribute__((__no_instrument_function__)) ;
#line 2698 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void clear_tsk_need_resched(struct task_struct *tsk ) 
{ 


  {
  {
#line 2700
  clear_tsk_thread_flag(tsk, 3);
  }
#line 2701
  return;
}
}
#line 2703
__inline static int test_tsk_need_resched(struct task_struct *tsk )  __attribute__((__no_instrument_function__)) ;
#line 2703 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static int test_tsk_need_resched(struct task_struct *tsk ) 
{ 
  int tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;

  {
  {
#line 2705
  tmp___7 = test_tsk_thread_flag(tsk, 3);
  }
#line 2705
  if (tmp___7) {
    {
#line 2705
    tmp___8 = 1;
    }
  } else {
    {
#line 2705
    tmp___8 = 0;
    }
  }
  {
#line 2705
  tmp___9 = __builtin_expect((long )tmp___8, 0L);
  }
#line 2705
  return ((int )tmp___9);
}
}
#line 2708
__inline static int restart_syscall(void)  __attribute__((__no_instrument_function__)) ;
#line 2708 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static int restart_syscall(void) 
{ 
  struct task_struct *tmp___7 ;

  {
  {
#line 2710
  tmp___7 = get_current();
#line 2710
  set_tsk_thread_flag(tmp___7, 2);
  }
#line 2711
  return (-513);
}
}
#line 2714
__inline static int signal_pending(struct task_struct *p )  __attribute__((__no_instrument_function__)) ;
#line 2714 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static int signal_pending(struct task_struct *p ) 
{ 
  int tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;

  {
  {
#line 2716
  tmp___7 = test_tsk_thread_flag(p, 2);
  }
#line 2716
  if (tmp___7) {
    {
#line 2716
    tmp___8 = 1;
    }
  } else {
    {
#line 2716
    tmp___8 = 0;
    }
  }
  {
#line 2716
  tmp___9 = __builtin_expect((long )tmp___8, 0L);
  }
#line 2716
  return ((int )tmp___9);
}
}
#line 2719
__inline static int __fatal_signal_pending(struct task_struct *p )  __attribute__((__no_instrument_function__)) ;
#line 2719 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static int __fatal_signal_pending(struct task_struct *p ) 
{ 
  int tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;

  {
  {
#line 2721
  tmp___7 = sigismember(& p->pending.signal, 9);
  }
#line 2721
  if (tmp___7) {
    {
#line 2721
    tmp___8 = 1;
    }
  } else {
    {
#line 2721
    tmp___8 = 0;
    }
  }
  {
#line 2721
  tmp___9 = __builtin_expect((long )tmp___8, 0L);
  }
#line 2721
  return ((int )tmp___9);
}
}
#line 2724
__inline static int fatal_signal_pending(struct task_struct *p )  __attribute__((__no_instrument_function__)) ;
#line 2724 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static int fatal_signal_pending(struct task_struct *p ) 
{ 
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 2726
  tmp___7 = signal_pending(p);
  }
#line 2726
  if (tmp___7) {
    {
#line 2726
    tmp___8 = __fatal_signal_pending(p);
    }
#line 2726
    if (tmp___8) {
      {
#line 2726
      tmp___9 = 1;
      }
    } else {
      {
#line 2726
      tmp___9 = 0;
      }
    }
  } else {
    {
#line 2726
    tmp___9 = 0;
    }
  }
#line 2726
  return (tmp___9);
}
}
#line 2729
__inline static int signal_pending_state(long state , struct task_struct *p )  __attribute__((__no_instrument_function__)) ;
#line 2729 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static int signal_pending_state(long state , struct task_struct *p ) 
{ 
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 2731
  if (! (state & 129L)) {
#line 2732
    return (0);
  }
  {
#line 2733
  tmp___7 = signal_pending(p);
  }
#line 2733
  if (! tmp___7) {
#line 2734
    return (0);
  }
#line 2736
  if (state & 1L) {
    {
#line 2736
    tmp___9 = 1;
    }
  } else {
    {
#line 2736
    tmp___8 = __fatal_signal_pending(p);
    }
#line 2736
    if (tmp___8) {
      {
#line 2736
      tmp___9 = 1;
      }
    } else {
      {
#line 2736
      tmp___9 = 0;
      }
    }
  }
#line 2736
  return (tmp___9);
}
}
#line 2753
extern int __cond_resched_lock(spinlock_t *lock ) ;
#line 2766
extern int __cond_resched_softirq(void) ;
#line 2773
__inline static void cond_resched_rcu(void)  __attribute__((__no_instrument_function__)) ;
#line 2773 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void cond_resched_rcu(void) 
{ 


  {
  {
#line 2776
  rcu_read_unlock();
#line 2777
  __might_sleep("../../../analyzer/../bench/linux-headers/include/linux/sched.h",
                2777, 0);
#line 2777
  _cond_resched();
#line 2778
  rcu_read_lock();
  }
#line 2780
  return;
}
}
#line 2787
__inline static int spin_needbreak(spinlock_t *lock )  __attribute__((__no_instrument_function__)) ;
#line 2787 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static int spin_needbreak(spinlock_t *lock ) 
{ 


  {
#line 2792
  return (0);
}
}
#line 2801
__inline static int tsk_is_polling(struct task_struct *p )  __attribute__((__no_instrument_function__)) ;
#line 2801 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static int tsk_is_polling(struct task_struct *p ) 
{ 
  int tmp___7 ;

  {
  {
#line 2803
  tmp___7 = test_tsk_thread_flag(p, 21);
  }
#line 2803
  return (tmp___7);
}
}
#line 2806
__inline static void __current_set_polling(void)  __attribute__((__no_instrument_function__)) ;
#line 2806 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void __current_set_polling(void) 
{ 
  struct thread_info *tmp___7 ;

  {
  {
#line 2808
  tmp___7 = current_thread_info();
#line 2808
  set_ti_thread_flag(tmp___7, 21);
  }
#line 2809
  return;
}
}
#line 2811
__inline static bool ( __attribute__((__warn_unused_result__)) current_set_polling_and_test)(void)  __attribute__((__no_instrument_function__)) ;
#line 2811 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static bool ( __attribute__((__warn_unused_result__)) current_set_polling_and_test)(void) 
{ 
  struct thread_info *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;

  {
  {
#line 2813
  __current_set_polling();
#line 2819
  __asm__  volatile   ("": : : "memory");
#line 2821
  tmp___7 = current_thread_info();
#line 2821
  tmp___8 = test_ti_thread_flag(tmp___7, 3);
  }
#line 2821
  if (tmp___8) {
    {
#line 2821
    tmp___9 = 1;
    }
  } else {
    {
#line 2821
    tmp___9 = 0;
    }
  }
  {
#line 2821
  tmp___10 = __builtin_expect((long )tmp___9, 0L);
  }
#line 2821
  return ((bool )tmp___10);
}
}
#line 2824
__inline static void __current_clr_polling(void)  __attribute__((__no_instrument_function__)) ;
#line 2824 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void __current_clr_polling(void) 
{ 
  struct thread_info *tmp___7 ;

  {
  {
#line 2826
  tmp___7 = current_thread_info();
#line 2826
  clear_ti_thread_flag(tmp___7, 21);
  }
#line 2827
  return;
}
}
#line 2829
__inline static bool ( __attribute__((__warn_unused_result__)) current_clr_polling_and_test)(void)  __attribute__((__no_instrument_function__)) ;
#line 2829 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static bool ( __attribute__((__warn_unused_result__)) current_clr_polling_and_test)(void) 
{ 
  struct thread_info *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;

  {
  {
#line 2831
  __current_clr_polling();
#line 2837
  __asm__  volatile   ("": : : "memory");
#line 2839
  tmp___7 = current_thread_info();
#line 2839
  tmp___8 = test_ti_thread_flag(tmp___7, 3);
  }
#line 2839
  if (tmp___8) {
    {
#line 2839
    tmp___9 = 1;
    }
  } else {
    {
#line 2839
    tmp___9 = 0;
    }
  }
  {
#line 2839
  tmp___10 = __builtin_expect((long )tmp___9, 0L);
  }
#line 2839
  return ((bool )tmp___10);
}
}
#line 2857
__inline static void current_clr_polling(void)  __attribute__((__no_instrument_function__)) ;
#line 2857 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void current_clr_polling(void) 
{ 
  struct thread_info *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 2859
  __current_clr_polling();
#line 2867
  __asm__  volatile   ("mfence": : : "memory");
  }
  {
#line 2869
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2869
    tmp___7 = current_thread_info();
#line 2869
    tmp___8 = test_ti_thread_flag(tmp___7, 3);
    }
#line 2869
    if (tmp___8) {
      {
#line 2869
      set_preempt_need_resched();
      }
    }
#line 2869
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2870
  return;
}
}
#line 2872
__inline static bool ( __attribute__((__always_inline__)) need_resched)(void)  __attribute__((__no_instrument_function__)) ;
#line 2872 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static bool ( __attribute__((__always_inline__)) need_resched)(void) 
{ 
  struct thread_info *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;

  {
  {
#line 2874
  tmp___7 = current_thread_info();
#line 2874
  tmp___8 = test_ti_thread_flag(tmp___7, 3);
  }
#line 2874
  if (tmp___8) {
    {
#line 2874
    tmp___9 = 1;
    }
  } else {
    {
#line 2874
    tmp___9 = 0;
    }
  }
  {
#line 2874
  tmp___10 = __builtin_expect((long )tmp___9, 0L);
  }
#line 2874
  return ((bool )tmp___10);
}
}
#line 2880
extern void thread_group_cputime(struct task_struct *tsk , struct task_cputime *times ) ;
#line 2881
extern void thread_group_cputimer(struct task_struct *tsk , struct task_cputime *times ) ;
#line 2885 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
static struct lock_class_key __key___0  ;
#line 2883
__inline static void thread_group_cputime_init(struct signal_struct *sig )  __attribute__((__no_instrument_function__)) ;
#line 2883 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void thread_group_cputime_init(struct signal_struct *sig ) 
{ 


  {
  {
#line 2885
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2885
    __raw_spin_lock_init(& sig->cputimer.lock, "&sig->cputimer.lock", & __key___0);
    }
#line 2885
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2886
  return;
}
}
#line 2894
extern void recalc_sigpending_and_wake(struct task_struct *t ) ;
#line 2895
extern void recalc_sigpending(void) ;
#line 2897
extern void signal_wake_up_state(struct task_struct *t , unsigned int state ) ;
#line 2899
__inline static void signal_wake_up(struct task_struct *t , bool resume )  __attribute__((__no_instrument_function__)) ;
#line 2899 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void signal_wake_up(struct task_struct *t , bool resume ) 
{ 
  int tmp___7 ;

  {
#line 2901
  if (resume) {
    {
#line 2901
    tmp___7 = 128;
    }
  } else {
    {
#line 2901
    tmp___7 = 0;
    }
  }
  {
#line 2901
  signal_wake_up_state(t, (unsigned int )tmp___7);
  }
#line 2902
  return;
}
}
#line 2903
__inline static void ptrace_signal_wake_up(struct task_struct *t , bool resume )  __attribute__((__no_instrument_function__)) ;
#line 2903 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void ptrace_signal_wake_up(struct task_struct *t , bool resume ) 
{ 
  int tmp___7 ;

  {
#line 2905
  if (resume) {
    {
#line 2905
    tmp___7 = 8;
    }
  } else {
    {
#line 2905
    tmp___7 = 0;
    }
  }
  {
#line 2905
  signal_wake_up_state(t, (unsigned int )tmp___7);
  }
#line 2906
  return;
}
}
#line 2913
__inline static unsigned int task_cpu(struct task_struct  const  *p )  __attribute__((__no_instrument_function__)) ;
#line 2913 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static unsigned int task_cpu(struct task_struct  const  *p ) 
{ 


  {
#line 2915
  return (((struct thread_info *)p->stack)->cpu);
}
}
#line 2918
__inline static int task_node(struct task_struct  const  *p )  __attribute__((__no_instrument_function__)) ;
#line 2918 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static int task_node(struct task_struct  const  *p ) 
{ 
  unsigned int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 2920
  tmp___7 = task_cpu(p);
#line 2920
  tmp___8 = cpu_to_node((int )tmp___7);
  }
#line 2920
  return (tmp___8);
}
}
#line 2923
extern void set_task_cpu(struct task_struct *p , unsigned int cpu ) ;
#line 2938
extern long sched_setaffinity(pid_t pid , struct cpumask  const  *new_mask ) ;
#line 2939
extern long sched_getaffinity(pid_t pid , struct cpumask *mask ) ;
#line 2942
extern struct task_group root_task_group ;
#line 2945
extern int task_can_switch_user(struct user_struct *up , struct task_struct *tsk ) ;
#line 2949
__inline static void add_rchar(struct task_struct *tsk , ssize_t amt )  __attribute__((__no_instrument_function__)) ;
#line 2949 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void add_rchar(struct task_struct *tsk , ssize_t amt ) 
{ 


  {
  {
#line 2951
  tsk->ioac.rchar += (u64 )amt;
  }
#line 2952
  return;
}
}
#line 2954
__inline static void add_wchar(struct task_struct *tsk , ssize_t amt )  __attribute__((__no_instrument_function__)) ;
#line 2954 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void add_wchar(struct task_struct *tsk , ssize_t amt ) 
{ 


  {
  {
#line 2956
  tsk->ioac.wchar += (u64 )amt;
  }
#line 2957
  return;
}
}
#line 2959
__inline static void inc_syscr(struct task_struct *tsk )  __attribute__((__no_instrument_function__)) ;
#line 2959 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void inc_syscr(struct task_struct *tsk ) 
{ 


  {
  {
#line 2961
  (tsk->ioac.syscr) ++;
  }
#line 2962
  return;
}
}
#line 2964
__inline static void inc_syscw(struct task_struct *tsk )  __attribute__((__no_instrument_function__)) ;
#line 2964 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void inc_syscw(struct task_struct *tsk ) 
{ 


  {
  {
#line 2966
  (tsk->ioac.syscw) ++;
  }
#line 2967
  return;
}
}
#line 2993
__inline static void mm_update_next_owner(struct mm_struct *mm )  __attribute__((__no_instrument_function__)) ;
#line 2993 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static void mm_update_next_owner(struct mm_struct *mm ) 
{ 


  {
#line 2995
  return;
}
}
#line 2998
__inline static unsigned long task_rlimit(struct task_struct  const  *tsk , unsigned int limit )  __attribute__((__no_instrument_function__)) ;
#line 2998 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static unsigned long task_rlimit(struct task_struct  const  *tsk , unsigned int limit ) 
{ 


  {
#line 3001
  return ((unsigned long )*((__kernel_ulong_t volatile   *)(& (tsk->signal)->rlim[limit].rlim_cur)));
}
}
#line 3004
__inline static unsigned long task_rlimit_max(struct task_struct  const  *tsk , unsigned int limit )  __attribute__((__no_instrument_function__)) ;
#line 3004 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static unsigned long task_rlimit_max(struct task_struct  const  *tsk , unsigned int limit ) 
{ 


  {
#line 3007
  return ((unsigned long )*((__kernel_ulong_t volatile   *)(& (tsk->signal)->rlim[limit].rlim_max)));
}
}
#line 3010
__inline static unsigned long rlimit(unsigned int limit )  __attribute__((__no_instrument_function__)) ;
#line 3010 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static unsigned long rlimit(unsigned int limit ) 
{ 
  struct task_struct *tmp___7 ;
  unsigned long tmp___8 ;

  {
  {
#line 3012
  tmp___7 = get_current();
#line 3012
  tmp___8 = task_rlimit((struct task_struct  const  *)tmp___7, limit);
  }
#line 3012
  return (tmp___8);
}
}
#line 3015
__inline static unsigned long rlimit_max(unsigned int limit )  __attribute__((__no_instrument_function__)) ;
#line 3015 "../../../analyzer/../bench/linux-headers/include/linux/sched.h"
__inline static unsigned long rlimit_max(unsigned int limit ) 
{ 
  struct task_struct *tmp___7 ;
  unsigned long tmp___8 ;

  {
  {
#line 3017
  tmp___7 = get_current();
#line 3017
  tmp___8 = task_rlimit_max((struct task_struct  const  *)tmp___7, limit);
  }
#line 3017
  return (tmp___8);
}
}
#line 60 "../../../analyzer/../bench/linux-headers/include/linux/kmemleak.h"
__inline static void kmemleak_init(void)  __attribute__((__no_instrument_function__)) ;
#line 60 "../../../analyzer/../bench/linux-headers/include/linux/kmemleak.h"
__inline static void kmemleak_init(void) 
{ 


  {
#line 62
  return;
}
}
#line 63
__inline static void kmemleak_alloc(void const   *ptr , size_t size , int min_count ,
                                    gfp_t gfp )  __attribute__((__no_instrument_function__)) ;
#line 63 "../../../analyzer/../bench/linux-headers/include/linux/kmemleak.h"
__inline static void kmemleak_alloc(void const   *ptr , size_t size , int min_count ,
                                    gfp_t gfp ) 
{ 


  {
#line 66
  return;
}
}
#line 67
__inline static void kmemleak_alloc_recursive(void const   *ptr , size_t size , int min_count ,
                                              unsigned long flags , gfp_t gfp )  __attribute__((__no_instrument_function__)) ;
#line 67 "../../../analyzer/../bench/linux-headers/include/linux/kmemleak.h"
__inline static void kmemleak_alloc_recursive(void const   *ptr , size_t size , int min_count ,
                                              unsigned long flags , gfp_t gfp ) 
{ 


  {
#line 71
  return;
}
}
#line 72
__inline static void kmemleak_alloc_percpu(void const   *ptr , size_t size )  __attribute__((__no_instrument_function__)) ;
#line 72 "../../../analyzer/../bench/linux-headers/include/linux/kmemleak.h"
__inline static void kmemleak_alloc_percpu(void const   *ptr , size_t size ) 
{ 


  {
#line 74
  return;
}
}
#line 75
__inline static void kmemleak_free(void const   *ptr )  __attribute__((__no_instrument_function__)) ;
#line 75 "../../../analyzer/../bench/linux-headers/include/linux/kmemleak.h"
__inline static void kmemleak_free(void const   *ptr ) 
{ 


  {
#line 77
  return;
}
}
#line 78
__inline static void kmemleak_free_part(void const   *ptr , size_t size )  __attribute__((__no_instrument_function__)) ;
#line 78 "../../../analyzer/../bench/linux-headers/include/linux/kmemleak.h"
__inline static void kmemleak_free_part(void const   *ptr , size_t size ) 
{ 


  {
#line 80
  return;
}
}
#line 81
__inline static void kmemleak_free_recursive(void const   *ptr , unsigned long flags )  __attribute__((__no_instrument_function__)) ;
#line 81 "../../../analyzer/../bench/linux-headers/include/linux/kmemleak.h"
__inline static void kmemleak_free_recursive(void const   *ptr , unsigned long flags ) 
{ 


  {
#line 83
  return;
}
}
#line 84
__inline static void kmemleak_free_percpu(void const   *ptr )  __attribute__((__no_instrument_function__)) ;
#line 84 "../../../analyzer/../bench/linux-headers/include/linux/kmemleak.h"
__inline static void kmemleak_free_percpu(void const   *ptr ) 
{ 


  {
#line 86
  return;
}
}
#line 87
__inline static void kmemleak_update_trace(void const   *ptr )  __attribute__((__no_instrument_function__)) ;
#line 87 "../../../analyzer/../bench/linux-headers/include/linux/kmemleak.h"
__inline static void kmemleak_update_trace(void const   *ptr ) 
{ 


  {
#line 89
  return;
}
}
#line 90
__inline static void kmemleak_not_leak(void const   *ptr )  __attribute__((__no_instrument_function__)) ;
#line 90 "../../../analyzer/../bench/linux-headers/include/linux/kmemleak.h"
__inline static void kmemleak_not_leak(void const   *ptr ) 
{ 


  {
#line 92
  return;
}
}
#line 93
__inline static void kmemleak_ignore(void const   *ptr )  __attribute__((__no_instrument_function__)) ;
#line 93 "../../../analyzer/../bench/linux-headers/include/linux/kmemleak.h"
__inline static void kmemleak_ignore(void const   *ptr ) 
{ 


  {
#line 95
  return;
}
}
#line 96
__inline static void kmemleak_scan_area(void const   *ptr , size_t size , gfp_t gfp )  __attribute__((__no_instrument_function__)) ;
#line 96 "../../../analyzer/../bench/linux-headers/include/linux/kmemleak.h"
__inline static void kmemleak_scan_area(void const   *ptr , size_t size , gfp_t gfp ) 
{ 


  {
#line 98
  return;
}
}
#line 99
__inline static void kmemleak_erase(void **ptr )  __attribute__((__no_instrument_function__)) ;
#line 99 "../../../analyzer/../bench/linux-headers/include/linux/kmemleak.h"
__inline static void kmemleak_erase(void **ptr ) 
{ 


  {
#line 101
  return;
}
}
#line 102
__inline static void kmemleak_no_scan(void const   *ptr )  __attribute__((__no_instrument_function__)) ;
#line 102 "../../../analyzer/../bench/linux-headers/include/linux/kmemleak.h"
__inline static void kmemleak_no_scan(void const   *ptr ) 
{ 


  {
#line 104
  return;
}
}
#line 112 "../../../analyzer/../bench/linux-headers/include/linux/slab.h"
extern void __attribute__((__cold__))  kmem_cache_init(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 113
extern int slab_is_available(void) ;
#line 115
extern struct kmem_cache *kmem_cache_create(char const   * , size_t  , size_t  , unsigned long  ,
                                            void (*)(void * ) ) ;
#line 123
extern void kmem_cache_destroy(struct kmem_cache * ) ;
#line 124
extern int kmem_cache_shrink(struct kmem_cache * ) ;
#line 125
extern void kmem_cache_free(struct kmem_cache * , void * ) ;
#line 142
extern void *( __attribute__((__warn_unused_result__)) __krealloc)(void const   * ,
                                                                   size_t  , gfp_t  ) ;
#line 143
extern void *( __attribute__((__warn_unused_result__)) krealloc)(void const   * ,
                                                                 size_t  , gfp_t  ) ;
#line 144
extern void kfree(void const   * ) ;
#line 145
extern void kzfree(void const   * ) ;
#line 146
extern size_t ksize(void const   * ) ;
#line 259
extern struct kmem_cache *kmalloc_caches[14] ;
#line 261
extern struct kmem_cache *kmalloc_dma_caches[14] ;
#line 272
__inline static int ( __attribute__((__always_inline__)) kmalloc_index)(size_t size )  __attribute__((__no_instrument_function__)) ;
#line 272 "../../../analyzer/../bench/linux-headers/include/linux/slab.h"
__inline static int ( __attribute__((__always_inline__)) kmalloc_index)(size_t size ) 
{ 


  {
#line 274
  if (! size) {
#line 275
    return (0);
  }
#line 277
  if (size <= (size_t )(1 << 3)) {
#line 278
    return (3);
  }
#line 280
  if (1 << 3 <= 32) {
#line 280
    if (size > 64UL) {
#line 280
      if (size <= 96UL) {
#line 281
        return (1);
      }
    }
  }
#line 282
  if (1 << 3 <= 64) {
#line 282
    if (size > 128UL) {
#line 282
      if (size <= 192UL) {
#line 283
        return (2);
      }
    }
  }
#line 284
  if (size <= 8UL) {
#line 284
    return (3);
  }
#line 285
  if (size <= 16UL) {
#line 285
    return (4);
  }
#line 286
  if (size <= 32UL) {
#line 286
    return (5);
  }
#line 287
  if (size <= 64UL) {
#line 287
    return (6);
  }
#line 288
  if (size <= 128UL) {
#line 288
    return (7);
  }
#line 289
  if (size <= 256UL) {
#line 289
    return (8);
  }
#line 290
  if (size <= 512UL) {
#line 290
    return (9);
  }
#line 291
  if (size <= 1024UL) {
#line 291
    return (10);
  }
#line 292
  if (size <= 2048UL) {
#line 292
    return (11);
  }
#line 293
  if (size <= 4096UL) {
#line 293
    return (12);
  }
#line 294
  if (size <= 8192UL) {
#line 294
    return (13);
  }
#line 295
  if (size <= 16384UL) {
#line 295
    return (14);
  }
#line 296
  if (size <= 32768UL) {
#line 296
    return (15);
  }
#line 297
  if (size <= 65536UL) {
#line 297
    return (16);
  }
#line 298
  if (size <= 131072UL) {
#line 298
    return (17);
  }
#line 299
  if (size <= 262144UL) {
#line 299
    return (18);
  }
#line 300
  if (size <= 524288UL) {
#line 300
    return (19);
  }
#line 301
  if (size <= 1048576UL) {
#line 301
    return (20);
  }
#line 302
  if (size <= 2097152UL) {
#line 302
    return (21);
  }
#line 303
  if (size <= 4194304UL) {
#line 303
    return (22);
  }
#line 304
  if (size <= 8388608UL) {
#line 304
    return (23);
  }
#line 305
  if (size <= 16777216UL) {
#line 305
    return (24);
  }
#line 306
  if (size <= 33554432UL) {
#line 306
    return (25);
  }
#line 307
  if (size <= 67108864UL) {
#line 307
    return (26);
  }
  {
#line 308
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 308
    __asm__  volatile   ("1:\tud2\n"
                         ".pushsection __bug_table,\"a\"\n"
                         "2:\t.long 1b - 2b, %c0 - 2b\n"
                         "\t.word %c1, 0\n"
                         "\t.org 2b+%c2\n"
                         ".popsection": : "i" ("../../../analyzer/../bench/linux-headers/include/linux/slab.h"),
                         "i" (308), "i" (sizeof(struct bug_entry )));
#line 308
    __builtin_unreachable();
    }
#line 308
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 311
  return (-1);
}
}
#line 315
extern void *__kmalloc(size_t size , gfp_t flags ) ;
#line 316
extern void *kmem_cache_alloc(struct kmem_cache * , gfp_t flags ) ;
#line 319
extern void *__kmalloc_node(size_t size , gfp_t flags , int node ) ;
#line 320
extern void *kmem_cache_alloc_node(struct kmem_cache * , gfp_t flags , int node ) ;
#line 334
extern void *kmem_cache_alloc_trace(struct kmem_cache * , gfp_t  , size_t  ) ;
#line 337
extern void *kmem_cache_alloc_node_trace(struct kmem_cache *s , gfp_t gfpflags , int node ,
                                         size_t size ) ;
#line 106 "../../../analyzer/../bench/linux-headers/include/linux/slub_def.h"
extern void sysfs_slab_remove(struct kmem_cache * ) ;
#line 374 "../../../analyzer/../bench/linux-headers/include/linux/slab.h"
extern void *kmalloc_order(size_t size , gfp_t flags , unsigned int order ) ;
#line 377
extern void *kmalloc_order_trace(size_t size , gfp_t flags , unsigned int order ) ;
#line 386
__inline static void *( __attribute__((__always_inline__)) kmalloc_large)(size_t size ,
                                                                          gfp_t flags )  __attribute__((__no_instrument_function__)) ;
#line 386 "../../../analyzer/../bench/linux-headers/include/linux/slab.h"
__inline static void *( __attribute__((__always_inline__)) kmalloc_large)(size_t size ,
                                                                          gfp_t flags ) 
{ 
  unsigned int order ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  void *tmp___80 ;

  {
  {
#line 388
  tmp___79 = __get_order(size);
#line 388
  order = (unsigned int )tmp___79;
#line 389
  tmp___80 = kmalloc_order_trace(size, flags, order);
  }
#line 389
  return (tmp___80);
}
}
#line 445
__inline static void *( __attribute__((__always_inline__)) kmalloc)(size_t size ,
                                                                    gfp_t flags )  __attribute__((__no_instrument_function__)) ;
#line 445 "../../../analyzer/../bench/linux-headers/include/linux/slab.h"
__inline static void *( __attribute__((__always_inline__)) kmalloc)(size_t size ,
                                                                    gfp_t flags ) 
{ 
  void *tmp___7 ;
  int index ;
  int tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;

  {
  {
#line 462
  tmp___10 = __kmalloc(size, flags);
  }
#line 462
  return (tmp___10);
}
}
#line 470
__inline static int ( __attribute__((__always_inline__)) kmalloc_size)(int n )  __attribute__((__no_instrument_function__)) ;
#line 470 "../../../analyzer/../bench/linux-headers/include/linux/slab.h"
__inline static int ( __attribute__((__always_inline__)) kmalloc_size)(int n ) 
{ 


  {
#line 473
  if (n > 2) {
#line 474
    return (1 << n);
  }
#line 476
  if (n == 1) {
#line 476
    if (1 << 3 <= 32) {
#line 477
      return (96);
    }
  }
#line 479
  if (n == 2) {
#line 479
    if (1 << 3 <= 64) {
#line 480
      return (192);
    }
  }
#line 482
  return (0);
}
}
#line 485
__inline static void *( __attribute__((__always_inline__)) kmalloc_node)(size_t size ,
                                                                         gfp_t flags ,
                                                                         int node )  __attribute__((__no_instrument_function__)) ;
#line 485 "../../../analyzer/../bench/linux-headers/include/linux/slab.h"
__inline static void *( __attribute__((__always_inline__)) kmalloc_node)(size_t size ,
                                                                         gfp_t flags ,
                                                                         int node ) 
{ 
  int i ;
  int tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;

  {
  {
#line 499
  tmp___9 = __kmalloc_node(size, flags, node);
  }
#line 499
  return (tmp___9);
}
}
#line 547
extern int memcg_update_all_caches(int num_memcgs ) ;
#line 550
extern int cache_show(struct kmem_cache *s , struct seq_file *m ) ;
#line 551
extern void print_slabinfo_header(struct seq_file *m ) ;
#line 559
__inline static void *kmalloc_array(size_t n , size_t size , gfp_t flags )  __attribute__((__no_instrument_function__)) ;
#line 559 "../../../analyzer/../bench/linux-headers/include/linux/slab.h"
__inline static void *kmalloc_array(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp___7 ;

  {
#line 561
  if (size != 0UL) {
#line 561
    if (n > 0xffffffffffffffffUL / size) {
#line 562
      return ((void *)0);
    }
  }
  {
#line 563
  tmp___7 = __kmalloc(n * size, flags);
  }
#line 563
  return (tmp___7);
}
}
#line 572
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags )  __attribute__((__no_instrument_function__)) ;
#line 572 "../../../analyzer/../bench/linux-headers/include/linux/slab.h"
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp___7 ;

  {
  {
#line 574
  tmp___7 = kmalloc_array(n, size, flags | 32768U);
  }
#line 574
  return (tmp___7);
}
}
#line 588
extern void *__kmalloc_track_caller(size_t  , gfp_t  , unsigned long  ) ;
#line 608
extern void *__kmalloc_node_track_caller(size_t  , gfp_t  , int  , unsigned long  ) ;
#line 627
__inline static void *kmem_cache_zalloc(struct kmem_cache *k , gfp_t flags )  __attribute__((__no_instrument_function__)) ;
#line 627 "../../../analyzer/../bench/linux-headers/include/linux/slab.h"
__inline static void *kmem_cache_zalloc(struct kmem_cache *k , gfp_t flags ) 
{ 
  void *tmp___7 ;

  {
  {
#line 629
  tmp___7 = kmem_cache_alloc(k, flags | 32768U);
  }
#line 629
  return (tmp___7);
}
}
#line 637
__inline static void *kzalloc(size_t size , gfp_t flags )  __attribute__((__no_instrument_function__)) ;
#line 637 "../../../analyzer/../bench/linux-headers/include/linux/slab.h"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp___7 ;

  {
  {
#line 639
  tmp___7 = kmalloc(size, flags | 32768U);
  }
#line 639
  return (tmp___7);
}
}
#line 648
__inline static void *kzalloc_node(size_t size , gfp_t flags , int node )  __attribute__((__no_instrument_function__)) ;
#line 648 "../../../analyzer/../bench/linux-headers/include/linux/slab.h"
__inline static void *kzalloc_node(size_t size , gfp_t flags , int node ) 
{ 
  void *tmp___7 ;

  {
  {
#line 650
  tmp___7 = kmalloc_node(size, flags | 32768U, node);
  }
#line 650
  return (tmp___7);
}
}
#line 656
__inline static unsigned int kmem_cache_size(struct kmem_cache *s )  __attribute__((__no_instrument_function__)) ;
#line 656 "../../../analyzer/../bench/linux-headers/include/linux/slab.h"
__inline static unsigned int kmem_cache_size(struct kmem_cache *s ) 
{ 


  {
#line 658
  return ((unsigned int )s->object_size);
}
}
#line 661
extern void __attribute__((__cold__))  kmem_cache_init_late(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 67 "../../../analyzer/../bench/linux-headers/include/linux/miscdevice.h"
extern int misc_register(struct miscdevice *misc ) ;
#line 68
extern int misc_deregister(struct miscdevice *misc ) ;
#line 26 "../../../analyzer/../bench/linux-headers/include/linux/uuid.h"
__inline static int uuid_le_cmp(uuid_le const   u1 , uuid_le const   u2 )  __attribute__((__no_instrument_function__)) ;
#line 26 "../../../analyzer/../bench/linux-headers/include/linux/uuid.h"
__inline static int uuid_le_cmp(uuid_le const   u1 , uuid_le const   u2 ) 
{ 
  int tmp___7 ;

  {
  {
#line 28
  tmp___7 = memcmp((void const   *)(& u1), (void const   *)(& u2), sizeof(uuid_le ));
  }
#line 28
  return (tmp___7);
}
}
#line 31
__inline static int uuid_be_cmp(uuid_be const   u1 , uuid_be const   u2 )  __attribute__((__no_instrument_function__)) ;
#line 31 "../../../analyzer/../bench/linux-headers/include/linux/uuid.h"
__inline static int uuid_be_cmp(uuid_be const   u1 , uuid_be const   u2 ) 
{ 
  int tmp___7 ;

  {
  {
#line 33
  tmp___7 = memcmp((void const   *)(& u1), (void const   *)(& u2), sizeof(uuid_be ));
  }
#line 33
  return (tmp___7);
}
}
#line 36
extern void uuid_le_gen(uuid_le *u ) ;
#line 37
extern void uuid_be_gen(uuid_be *u ) ;
#line 36 "../../../analyzer/../bench/linux-headers/include/linux/klist.h"
extern void klist_init(struct klist *k , void (*get)(struct klist_node * ) , void (*put)(struct klist_node * ) ) ;
#line 45
extern void klist_add_tail(struct klist_node *n , struct klist *k ) ;
#line 46
extern void klist_add_head(struct klist_node *n , struct klist *k ) ;
#line 47
extern void klist_add_behind(struct klist_node *n , struct klist_node *pos ) ;
#line 48
extern void klist_add_before(struct klist_node *n , struct klist_node *pos ) ;
#line 50
extern void klist_del(struct klist_node *n ) ;
#line 51
extern void klist_remove(struct klist_node *n ) ;
#line 53
extern int klist_node_attached(struct klist_node *n ) ;
#line 62
extern void klist_iter_init(struct klist *k , struct klist_iter *i ) ;
#line 63
extern void klist_iter_init_node(struct klist *k , struct klist_iter *i , struct klist_node *n ) ;
#line 65
extern void klist_iter_exit(struct klist_iter *i ) ;
#line 66
extern struct klist_node *klist_next(struct klist_iter *i ) ;
#line 43 "../../../analyzer/../bench/linux-headers/include/linux/pinctrl/devinfo.h"
__inline static int pinctrl_bind_pins(struct device *dev )  __attribute__((__no_instrument_function__)) ;
#line 43 "../../../analyzer/../bench/linux-headers/include/linux/pinctrl/devinfo.h"
__inline static int pinctrl_bind_pins(struct device *dev ) 
{ 


  {
#line 45
  return (0);
}
}
#line 31 "../../../analyzer/../bench/linux-headers/include/linux/ratelimit.h"
static struct lock_class_key __key___1  ;
#line 28
__inline static void ratelimit_state_init(struct ratelimit_state *rs , int interval ,
                                          int burst )  __attribute__((__no_instrument_function__)) ;
#line 28 "../../../analyzer/../bench/linux-headers/include/linux/ratelimit.h"
__inline static void ratelimit_state_init(struct ratelimit_state *rs , int interval ,
                                          int burst ) 
{ 


  {
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 31
    __raw_spin_lock_init(& rs->lock, "&rs->lock", & __key___1);
    }
#line 31
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 32
  rs->interval = interval;
#line 33
  rs->burst = burst;
#line 34
  rs->printed = 0;
#line 35
  rs->missed = 0;
#line 36
  rs->begin = 0UL;
  }
#line 37
  return;
}
}
#line 39
extern struct ratelimit_state printk_ratelimit_state ;
#line 41
extern int ___ratelimit(struct ratelimit_state *rs , char const   *func ) ;
#line 57 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
extern int ( __attribute__((__warn_unused_result__)) bus_create_file)(struct bus_type * ,
                                                                      struct bus_attribute * ) ;
#line 59
extern void bus_remove_file(struct bus_type * , struct bus_attribute * ) ;
#line 133
extern int ( __attribute__((__warn_unused_result__)) bus_register)(struct bus_type *bus ) ;
#line 135
extern void bus_unregister(struct bus_type *bus ) ;
#line 137
extern int ( __attribute__((__warn_unused_result__)) bus_rescan_devices)(struct bus_type *bus ) ;
#line 144
extern void subsys_dev_iter_init(struct subsys_dev_iter *iter , struct bus_type *subsys ,
                                 struct device *start , struct device_type  const  *type ) ;
#line 148
extern struct device *subsys_dev_iter_next(struct subsys_dev_iter *iter ) ;
#line 149
extern void subsys_dev_iter_exit(struct subsys_dev_iter *iter ) ;
#line 151
extern int bus_for_each_dev(struct bus_type *bus , struct device *start , void *data ,
                            int (*fn)(struct device *dev , void *data ) ) ;
#line 153
extern struct device *bus_find_device(struct bus_type *bus , struct device *start ,
                                      void *data , int (*match)(struct device *dev ,
                                                                void *data ) ) ;
#line 156
extern struct device *bus_find_device_by_name(struct bus_type *bus , struct device *start ,
                                              char const   *name ) ;
#line 159
extern struct device *subsys_find_device_by_id(struct bus_type *bus , unsigned int id ,
                                               struct device *hint ) ;
#line 161
extern int bus_for_each_drv(struct bus_type *bus , struct device_driver *start , void *data ,
                            int (*fn)(struct device_driver * , void * ) ) ;
#line 163
extern void bus_sort_breadthfirst(struct bus_type *bus , int (*compare)(struct device  const  *a ,
                                                                        struct device  const  *b ) ) ;
#line 174
extern int bus_register_notifier(struct bus_type *bus , struct notifier_block *nb ) ;
#line 176
extern int bus_unregister_notifier(struct bus_type *bus , struct notifier_block *nb ) ;
#line 193
extern struct kset *bus_get_kset(struct bus_type *bus ) ;
#line 194
extern struct klist *bus_get_device_klist(struct bus_type *bus ) ;
#line 253
extern int ( __attribute__((__warn_unused_result__)) driver_register)(struct device_driver *drv ) ;
#line 254
extern void driver_unregister(struct device_driver *drv ) ;
#line 256
extern struct device_driver *driver_find(char const   *name , struct bus_type *bus ) ;
#line 258
extern int driver_probe_done(void) ;
#line 259
extern void wait_for_device_probe(void) ;
#line 280
extern int ( __attribute__((__warn_unused_result__)) driver_create_file)(struct device_driver *driver ,
                                                                         struct driver_attribute  const  *attr ) ;
#line 282
extern void driver_remove_file(struct device_driver *driver , struct driver_attribute  const  *attr ) ;
#line 285
extern int ( __attribute__((__warn_unused_result__)) driver_for_each_device)(struct device_driver *drv ,
                                                                             struct device *start ,
                                                                             void *data ,
                                                                             int (*fn)(struct device *dev ,
                                                                                       void * ) ) ;
#line 290
extern struct device *driver_find_device(struct device_driver *drv , struct device *start ,
                                         void *data , int (*match)(struct device *dev ,
                                                                   void *data ) ) ;
#line 315
extern int subsys_interface_register(struct subsys_interface *sif ) ;
#line 316
extern void subsys_interface_unregister(struct subsys_interface *sif ) ;
#line 318
extern int subsys_system_register(struct bus_type *subsys , struct attribute_group  const  **groups ) ;
#line 320
extern int subsys_virtual_register(struct bus_type *subsys , struct attribute_group  const  **groups ) ;
#line 381
extern struct kobject *sysfs_dev_block_kobj ;
#line 382
extern struct kobject *sysfs_dev_char_kobj ;
#line 383
extern int ( __attribute__((__warn_unused_result__)) __class_register)(struct class *class ,
                                                                       struct lock_class_key *key ) ;
#line 385
extern void class_unregister(struct class *class ) ;
#line 396
extern struct class_compat *class_compat_register(char const   *name ) ;
#line 397
extern void class_compat_unregister(struct class_compat *cls ) ;
#line 398
extern int class_compat_create_link(struct class_compat *cls , struct device *dev ,
                                    struct device *device_link ) ;
#line 400
extern void class_compat_remove_link(struct class_compat *cls , struct device *dev ,
                                     struct device *device_link ) ;
#line 403
extern void class_dev_iter_init(struct class_dev_iter *iter , struct class *class ,
                                struct device *start , struct device_type  const  *type ) ;
#line 407
extern struct device *class_dev_iter_next(struct class_dev_iter *iter ) ;
#line 408
extern void class_dev_iter_exit(struct class_dev_iter *iter ) ;
#line 410
extern int class_for_each_device(struct class *class , struct device *start , void *data ,
                                 int (*fn)(struct device *dev , void *data ) ) ;
#line 413
extern struct device *class_find_device(struct class *class , struct device *start ,
                                        void const   *data , int (*match)(struct device * ,
                                                                          void const   * ) ) ;
#line 432
extern int ( __attribute__((__warn_unused_result__)) class_create_file_ns)(struct class *class ,
                                                                           struct class_attribute  const  *attr ,
                                                                           void const   *ns ) ;
#line 435
extern void class_remove_file_ns(struct class *class , struct class_attribute  const  *attr ,
                                 void const   *ns ) ;
#line 439
__inline static int ( __attribute__((__warn_unused_result__)) class_create_file)(struct class *class ,
                                                                                 struct class_attribute  const  *attr )  __attribute__((__no_instrument_function__)) ;
#line 439 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
__inline static int ( __attribute__((__warn_unused_result__)) class_create_file)(struct class *class ,
                                                                                 struct class_attribute  const  *attr ) 
{ 
  int tmp___7 ;

  {
  {
#line 442
  tmp___7 = class_create_file_ns(class, attr, (void const   *)((void *)0));
  }
#line 442
  return (tmp___7);
}
}
#line 445
__inline static void class_remove_file(struct class *class , struct class_attribute  const  *attr )  __attribute__((__no_instrument_function__)) ;
#line 445 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
__inline static void class_remove_file(struct class *class , struct class_attribute  const  *attr ) 
{ 


  {
  {
#line 448
  class_remove_file_ns(class, attr, (void const   *)((void *)0));
  }
#line 448
  return;
}
}
#line 464
extern ssize_t show_class_attr_string(struct class *class , struct class_attribute *attr ,
                                      char *buf ) ;
#line 475
extern int ( __attribute__((__warn_unused_result__)) class_interface_register)(struct class_interface * ) ;
#line 476
extern void class_interface_unregister(struct class_interface * ) ;
#line 478
extern struct class *( __attribute__((__warn_unused_result__)) __class_create)(struct module *owner ,
                                                                               char const   *name ,
                                                                               struct lock_class_key *key ) ;
#line 481
extern void class_destroy(struct class *cls ) ;
#line 525
extern ssize_t device_show_ulong(struct device *dev , struct device_attribute *attr ,
                                 char *buf ) ;
#line 527
extern ssize_t device_store_ulong(struct device *dev , struct device_attribute *attr ,
                                  char const   *buf , size_t count ) ;
#line 529
extern ssize_t device_show_int(struct device *dev , struct device_attribute *attr ,
                               char *buf ) ;
#line 531
extern ssize_t device_store_int(struct device *dev , struct device_attribute *attr ,
                                char const   *buf , size_t count ) ;
#line 533
extern ssize_t device_show_bool(struct device *dev , struct device_attribute *attr ,
                                char *buf ) ;
#line 535
extern ssize_t device_store_bool(struct device *dev , struct device_attribute *attr ,
                                 char const   *buf , size_t count ) ;
#line 559
extern int device_create_file(struct device *device , struct device_attribute  const  *entry ) ;
#line 561
extern void device_remove_file(struct device *dev , struct device_attribute  const  *attr ) ;
#line 563
extern bool device_remove_file_self(struct device *dev , struct device_attribute  const  *attr ) ;
#line 565
extern int ( __attribute__((__warn_unused_result__)) device_create_bin_file)(struct device *dev ,
                                                                             struct bin_attribute  const  *attr ) ;
#line 567
extern void device_remove_bin_file(struct device *dev , struct bin_attribute  const  *attr ) ;
#line 575
extern void *__devres_alloc(void (*release)(struct device *dev , void *res ) , size_t size ,
                            gfp_t gfp , char const   *name ) ;
#line 582
extern void devres_for_each_res(struct device *dev , void (*release)(struct device *dev ,
                                                                     void *res ) ,
                                int (*match)(struct device *dev , void *res , void *match_data ) ,
                                void *match_data , void (*fn)(struct device * , void * ,
                                                              void * ) , void *data ) ;
#line 586
extern void devres_free(void *res ) ;
#line 587
extern void devres_add(struct device *dev , void *res ) ;
#line 588
extern void *devres_find(struct device *dev , void (*release)(struct device *dev ,
                                                              void *res ) , int (*match)(struct device *dev ,
                                                                                         void *res ,
                                                                                         void *match_data ) ,
                         void *match_data ) ;
#line 590
extern void *devres_get(struct device *dev , void *new_res , int (*match)(struct device *dev ,
                                                                          void *res ,
                                                                          void *match_data ) ,
                        void *match_data ) ;
#line 592
extern void *devres_remove(struct device *dev , void (*release)(struct device *dev ,
                                                                void *res ) , int (*match)(struct device *dev ,
                                                                                           void *res ,
                                                                                           void *match_data ) ,
                           void *match_data ) ;
#line 594
extern int devres_destroy(struct device *dev , void (*release)(struct device *dev ,
                                                               void *res ) , int (*match)(struct device *dev ,
                                                                                          void *res ,
                                                                                          void *match_data ) ,
                          void *match_data ) ;
#line 596
extern int devres_release(struct device *dev , void (*release)(struct device *dev ,
                                                               void *res ) , int (*match)(struct device *dev ,
                                                                                          void *res ,
                                                                                          void *match_data ) ,
                          void *match_data ) ;
#line 600
extern void *( __attribute__((__warn_unused_result__)) devres_open_group)(struct device *dev ,
                                                                          void *id ,
                                                                          gfp_t gfp ) ;
#line 602
extern void devres_close_group(struct device *dev , void *id ) ;
#line 603
extern void devres_remove_group(struct device *dev , void *id ) ;
#line 604
extern int devres_release_group(struct device *dev , void *id ) ;
#line 607
extern void *devm_kmalloc(struct device *dev , size_t size , gfp_t gfp ) ;
#line 608
extern char *devm_kvasprintf(struct device *dev , gfp_t gfp , char const   *fmt ,
                             va_list ap ) ;
#line 610
extern char *devm_kasprintf(struct device *dev , gfp_t gfp , char const   *fmt  , ...) ;
#line 612
__inline static void *devm_kzalloc(struct device *dev , size_t size , gfp_t gfp )  __attribute__((__no_instrument_function__)) ;
#line 612 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
__inline static void *devm_kzalloc(struct device *dev , size_t size , gfp_t gfp ) 
{ 
  void *tmp___7 ;

  {
  {
#line 614
  tmp___7 = devm_kmalloc(dev, size, gfp | 32768U);
  }
#line 614
  return (tmp___7);
}
}
#line 616
__inline static void *devm_kmalloc_array(struct device *dev , size_t n , size_t size ,
                                         gfp_t flags )  __attribute__((__no_instrument_function__)) ;
#line 616 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
__inline static void *devm_kmalloc_array(struct device *dev , size_t n , size_t size ,
                                         gfp_t flags ) 
{ 
  void *tmp___7 ;

  {
#line 619
  if (size != 0UL) {
#line 619
    if (n > 0xffffffffffffffffUL / size) {
#line 620
      return ((void *)0);
    }
  }
  {
#line 621
  tmp___7 = devm_kmalloc(dev, n * size, flags);
  }
#line 621
  return (tmp___7);
}
}
#line 623
__inline static void *devm_kcalloc(struct device *dev , size_t n , size_t size , gfp_t flags )  __attribute__((__no_instrument_function__)) ;
#line 623 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
__inline static void *devm_kcalloc(struct device *dev , size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp___7 ;

  {
  {
#line 626
  tmp___7 = devm_kmalloc_array(dev, n, size, flags | 32768U);
  }
#line 626
  return (tmp___7);
}
}
#line 628
extern void devm_kfree(struct device *dev , void *p ) ;
#line 629
extern char *devm_kstrdup(struct device *dev , char const   *s , gfp_t gfp ) ;
#line 630
extern void *devm_kmemdup(struct device *dev , void const   *src , size_t len , gfp_t gfp ) ;
#line 633
extern unsigned long devm_get_free_pages(struct device *dev , gfp_t gfp_mask , unsigned int order ) ;
#line 635
extern void devm_free_pages(struct device *dev , unsigned long addr ) ;
#line 637
extern void *devm_ioremap_resource(struct device *dev , struct resource *res ) ;
#line 640
extern int devm_add_action(struct device *dev , void (*action)(void * ) , void *data ) ;
#line 641
extern void devm_remove_action(struct device *dev , void (*action)(void * ) , void *data ) ;
#line 800
__inline static struct device *kobj_to_dev(struct kobject *kobj )  __attribute__((__no_instrument_function__)) ;
#line 800 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
__inline static struct device *kobj_to_dev(struct kobject *kobj ) 
{ 
  struct kobject  const  *__mptr ;

  {
  {
#line 802
  __mptr = (struct kobject  const  *)kobj;
  }
#line 802
  return ((struct device *)((char *)__mptr - (unsigned long )(& ((struct device *)0)->kobj)));
}
}
#line 72 "../../../analyzer/../bench/linux-headers/include/linux/pm_wakeup.h"
__inline static bool device_can_wakeup(struct device *dev )  __attribute__((__no_instrument_function__)) ;
#line 72 "../../../analyzer/../bench/linux-headers/include/linux/pm_wakeup.h"
__inline static bool device_can_wakeup(struct device *dev ) 
{ 


  {
#line 74
  return ((bool )dev->power.can_wakeup);
}
}
#line 77
__inline static bool device_may_wakeup(struct device *dev )  __attribute__((__no_instrument_function__)) ;
#line 77 "../../../analyzer/../bench/linux-headers/include/linux/pm_wakeup.h"
__inline static bool device_may_wakeup(struct device *dev ) 
{ 
  int tmp___7 ;

  {
#line 79
  if (dev->power.can_wakeup) {
#line 79
    if (! (! dev->power.wakeup)) {
      {
#line 79
      tmp___7 = 1;
      }
    } else {
      {
#line 79
      tmp___7 = 0;
      }
    }
  } else {
    {
#line 79
    tmp___7 = 0;
    }
  }
#line 79
  return ((bool )tmp___7);
}
}
#line 83
extern void wakeup_source_prepare(struct wakeup_source *ws , char const   *name ) ;
#line 84
extern struct wakeup_source *wakeup_source_create(char const   *name ) ;
#line 85
extern void wakeup_source_drop(struct wakeup_source *ws ) ;
#line 86
extern void wakeup_source_destroy(struct wakeup_source *ws ) ;
#line 87
extern void wakeup_source_add(struct wakeup_source *ws ) ;
#line 88
extern void wakeup_source_remove(struct wakeup_source *ws ) ;
#line 89
extern struct wakeup_source *wakeup_source_register(char const   *name ) ;
#line 90
extern void wakeup_source_unregister(struct wakeup_source *ws ) ;
#line 91
extern int device_wakeup_enable(struct device *dev ) ;
#line 92
extern int device_wakeup_disable(struct device *dev ) ;
#line 93
extern void device_set_wakeup_capable(struct device *dev , bool capable ) ;
#line 94
extern int device_init_wakeup(struct device *dev , bool val ) ;
#line 95
extern int device_set_wakeup_enable(struct device *dev , bool enable ) ;
#line 96
extern void __pm_stay_awake(struct wakeup_source *ws ) ;
#line 97
extern void pm_stay_awake(struct device *dev ) ;
#line 98
extern void __pm_relax(struct wakeup_source *ws ) ;
#line 99
extern void pm_relax(struct device *dev ) ;
#line 100
extern void __pm_wakeup_event(struct wakeup_source *ws , unsigned int msec ) ;
#line 101
extern void pm_wakeup_event(struct device *dev , unsigned int msec ) ;
#line 182
__inline static void wakeup_source_init(struct wakeup_source *ws , char const   *name )  __attribute__((__no_instrument_function__)) ;
#line 182 "../../../analyzer/../bench/linux-headers/include/linux/pm_wakeup.h"
__inline static void wakeup_source_init(struct wakeup_source *ws , char const   *name ) 
{ 


  {
  {
#line 185
  wakeup_source_prepare(ws, name);
#line 186
  wakeup_source_add(ws);
  }
#line 187
  return;
}
}
#line 189
__inline static void wakeup_source_trash(struct wakeup_source *ws )  __attribute__((__no_instrument_function__)) ;
#line 189 "../../../analyzer/../bench/linux-headers/include/linux/pm_wakeup.h"
__inline static void wakeup_source_trash(struct wakeup_source *ws ) 
{ 


  {
  {
#line 191
  wakeup_source_remove(ws);
#line 192
  wakeup_source_drop(ws);
  }
#line 193
  return;
}
}
#line 808 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
__inline static char const   *dev_name(struct device  const  *dev )  __attribute__((__no_instrument_function__)) ;
#line 808 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
__inline static char const   *dev_name(struct device  const  *dev ) 
{ 
  char const   *tmp___7 ;

  {
#line 811
  if (dev->init_name) {
#line 812
    return ((char const   *)dev->init_name);
  }
  {
#line 814
  tmp___7 = kobject_name(& dev->kobj);
  }
#line 814
  return (tmp___7);
}
}
#line 817
extern int ( /* format attribute */  dev_set_name)(struct device *dev , char const   *name 
                                                   , ...) ;
#line 821
__inline static int dev_to_node(struct device *dev )  __attribute__((__no_instrument_function__)) ;
#line 821 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
__inline static int dev_to_node(struct device *dev ) 
{ 


  {
#line 823
  return (dev->numa_node);
}
}
#line 825
__inline static void set_dev_node(struct device *dev , int node )  __attribute__((__no_instrument_function__)) ;
#line 825 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
__inline static void set_dev_node(struct device *dev , int node ) 
{ 


  {
  {
#line 827
  dev->numa_node = node;
  }
#line 828
  return;
}
}
#line 839
__inline static void *dev_get_drvdata(struct device  const  *dev )  __attribute__((__no_instrument_function__)) ;
#line 839 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
__inline static void *dev_get_drvdata(struct device  const  *dev ) 
{ 


  {
#line 841
  return ((void *)dev->driver_data);
}
}
#line 844
__inline static void dev_set_drvdata(struct device *dev , void *data )  __attribute__((__no_instrument_function__)) ;
#line 844 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
__inline static void dev_set_drvdata(struct device *dev , void *data ) 
{ 


  {
  {
#line 846
  dev->driver_data = data;
  }
#line 847
  return;
}
}
#line 849
__inline static struct pm_subsys_data *dev_to_psd(struct device *dev )  __attribute__((__no_instrument_function__)) ;
#line 849 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
__inline static struct pm_subsys_data *dev_to_psd(struct device *dev ) 
{ 
  struct pm_subsys_data *tmp___7 ;

  {
#line 851
  if (dev) {
    {
#line 851
    tmp___7 = dev->power.subsys_data;
    }
  } else {
    {
#line 851
    tmp___7 = (struct pm_subsys_data *)((void *)0);
    }
  }
#line 851
  return (tmp___7);
}
}
#line 854
__inline static unsigned int dev_get_uevent_suppress(struct device  const  *dev )  __attribute__((__no_instrument_function__)) ;
#line 854 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
__inline static unsigned int dev_get_uevent_suppress(struct device  const  *dev ) 
{ 


  {
#line 856
  return ((unsigned int )dev->kobj.uevent_suppress);
}
}
#line 859
__inline static void dev_set_uevent_suppress(struct device *dev , int val )  __attribute__((__no_instrument_function__)) ;
#line 859 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
__inline static void dev_set_uevent_suppress(struct device *dev , int val ) 
{ 


  {
  {
#line 861
  dev->kobj.uevent_suppress = (unsigned int )val;
  }
#line 862
  return;
}
}
#line 864
__inline static int device_is_registered(struct device *dev )  __attribute__((__no_instrument_function__)) ;
#line 864 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
__inline static int device_is_registered(struct device *dev ) 
{ 


  {
#line 866
  return ((int )dev->kobj.state_in_sysfs);
}
}
#line 869
__inline static void device_enable_async_suspend(struct device *dev )  __attribute__((__no_instrument_function__)) ;
#line 869 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
__inline static void device_enable_async_suspend(struct device *dev ) 
{ 


  {
#line 871
  if (! dev->power.is_prepared) {
    {
#line 872
    dev->power.async_suspend = 1U;
    }
  }
#line 873
  return;
}
}
#line 875
__inline static void device_disable_async_suspend(struct device *dev )  __attribute__((__no_instrument_function__)) ;
#line 875 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
__inline static void device_disable_async_suspend(struct device *dev ) 
{ 


  {
#line 877
  if (! dev->power.is_prepared) {
    {
#line 878
    dev->power.async_suspend = 0U;
    }
  }
#line 879
  return;
}
}
#line 881
__inline static bool device_async_suspend_enabled(struct device *dev )  __attribute__((__no_instrument_function__)) ;
#line 881 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
__inline static bool device_async_suspend_enabled(struct device *dev ) 
{ 


  {
#line 883
  return ((bool )(! (! dev->power.async_suspend)));
}
}
#line 886
__inline static void pm_suspend_ignore_children(struct device *dev , bool enable )  __attribute__((__no_instrument_function__)) ;
#line 886 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
__inline static void pm_suspend_ignore_children(struct device *dev , bool enable ) 
{ 


  {
  {
#line 888
  dev->power.ignore_children = enable;
  }
#line 889
  return;
}
}
#line 891
__inline static void dev_pm_syscore_device(struct device *dev , bool val )  __attribute__((__no_instrument_function__)) ;
#line 891 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
__inline static void dev_pm_syscore_device(struct device *dev , bool val ) 
{ 


  {
  {
#line 894
  dev->power.syscore = val;
  }
#line 896
  return;
}
}
#line 898
__inline static void device_lock(struct device *dev )  __attribute__((__no_instrument_function__)) ;
#line 898 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
__inline static void device_lock(struct device *dev ) 
{ 


  {
  {
#line 900
  mutex_lock(& dev->mutex);
  }
#line 901
  return;
}
}
#line 903
__inline static int device_trylock(struct device *dev )  __attribute__((__no_instrument_function__)) ;
#line 903 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
__inline static int device_trylock(struct device *dev ) 
{ 
  int tmp___7 ;

  {
  {
#line 905
  tmp___7 = mutex_trylock(& dev->mutex);
  }
#line 905
  return (tmp___7);
}
}
#line 908
__inline static void device_unlock(struct device *dev )  __attribute__((__no_instrument_function__)) ;
#line 908 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
__inline static void device_unlock(struct device *dev ) 
{ 


  {
  {
#line 910
  mutex_unlock(& dev->mutex);
  }
#line 911
  return;
}
}
#line 913
extern void driver_init(void) ;
#line 918
extern int ( __attribute__((__warn_unused_result__)) device_register)(struct device *dev ) ;
#line 919
extern void device_unregister(struct device *dev ) ;
#line 920
extern void device_initialize(struct device *dev ) ;
#line 921
extern int ( __attribute__((__warn_unused_result__)) device_add)(struct device *dev ) ;
#line 922
extern void device_del(struct device *dev ) ;
#line 923
extern int device_for_each_child(struct device *dev , void *data , int (*fn)(struct device *dev ,
                                                                             void *data ) ) ;
#line 925
extern struct device *device_find_child(struct device *dev , void *data , int (*match)(struct device *dev ,
                                                                                       void *data ) ) ;
#line 927
extern int device_rename(struct device *dev , char const   *new_name ) ;
#line 928
extern int device_move(struct device *dev , struct device *new_parent , enum dpm_order dpm_order ) ;
#line 930
extern char const   *device_get_devnode(struct device *dev , umode_t *mode , kuid_t *uid ,
                                        kgid_t *gid , char const   **tmp ) ;
#line 934
__inline static bool device_supports_offline(struct device *dev )  __attribute__((__no_instrument_function__)) ;
#line 934 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
__inline static bool device_supports_offline(struct device *dev ) 
{ 
  int tmp___7 ;

  {
#line 936
  if (dev->bus) {
#line 936
    if ((dev->bus)->offline) {
#line 936
      if ((dev->bus)->online) {
        {
#line 936
        tmp___7 = 1;
        }
      } else {
        {
#line 936
        tmp___7 = 0;
        }
      }
    } else {
      {
#line 936
      tmp___7 = 0;
      }
    }
  } else {
    {
#line 936
    tmp___7 = 0;
    }
  }
#line 936
  return ((bool )tmp___7);
}
}
#line 939
extern void lock_device_hotplug(void) ;
#line 940
extern void unlock_device_hotplug(void) ;
#line 941
extern int lock_device_hotplug_sysfs(void) ;
#line 942
extern int device_offline(struct device *dev ) ;
#line 943
extern int device_online(struct device *dev ) ;
#line 947
extern struct device *__root_device_register(char const   *name , struct module *owner ) ;
#line 954
extern void root_device_unregister(struct device *root ) ;
#line 956
__inline static void *dev_get_platdata(struct device  const  *dev )  __attribute__((__no_instrument_function__)) ;
#line 956 "../../../analyzer/../bench/linux-headers/include/linux/device.h"
__inline static void *dev_get_platdata(struct device  const  *dev ) 
{ 


  {
#line 958
  return ((void *)dev->platform_data);
}
}
#line 965
extern int ( __attribute__((__warn_unused_result__)) device_bind_driver)(struct device *dev ) ;
#line 966
extern void device_release_driver(struct device *dev ) ;
#line 967
extern int ( __attribute__((__warn_unused_result__)) device_attach)(struct device *dev ) ;
#line 968
extern int ( __attribute__((__warn_unused_result__)) driver_attach)(struct device_driver *drv ) ;
#line 969
extern int ( __attribute__((__warn_unused_result__)) device_reprobe)(struct device *dev ) ;
#line 974
extern struct device *device_create_vargs(struct class *cls , struct device *parent ,
                                          dev_t devt , void *drvdata , char const   *fmt ,
                                          va_list vargs ) ;
#line 980
extern struct device *( /* format attribute */  device_create)(struct class *cls ,
                                                               struct device *parent ,
                                                               dev_t devt , void *drvdata ,
                                                               char const   *fmt 
                                                               , ...) ;
#line 984
extern struct device *( /* format attribute */  device_create_with_groups)(struct class *cls ,
                                                                           struct device *parent ,
                                                                           dev_t devt ,
                                                                           void *drvdata ,
                                                                           struct attribute_group  const  **groups ,
                                                                           char const   *fmt 
                                                                           , ...) ;
#line 989
extern void device_destroy(struct class *cls , dev_t devt ) ;
#line 997
extern int (*platform_notify)(struct device *dev ) ;
#line 999
extern int (*platform_notify_remove)(struct device *dev ) ;
#line 1006
extern struct device *get_device(struct device *dev ) ;
#line 1007
extern void put_device(struct device *dev ) ;
#line 1010
extern int devtmpfs_create_node(struct device *dev ) ;
#line 1011
extern int devtmpfs_delete_node(struct device *dev ) ;
#line 1012
extern int devtmpfs_mount(char const   *mntdir ) ;
#line 1020
extern void device_shutdown(void) ;
#line 1023
extern char const   *dev_driver_string(struct device  const  *dev ) ;
#line 1028
extern int ( /* format attribute */  dev_vprintk_emit)(int level , struct device  const  *dev ,
                                                       char const   *fmt , va_list args ) ;
#line 1031
extern int ( /* format attribute */  dev_printk_emit)(int level , struct device  const  *dev ,
                                                      char const   *fmt  , ...) ;
#line 1034
extern int ( /* format attribute */  dev_printk)(char const   *level , struct device  const  *dev ,
                                                 char const   *fmt  , ...) ;
#line 1037
extern int ( /* format attribute */  dev_emerg)(struct device  const  *dev , char const   *fmt 
                                                , ...) ;
#line 1039
extern int ( /* format attribute */  dev_alert)(struct device  const  *dev , char const   *fmt 
                                                , ...) ;
#line 1041
extern int ( /* format attribute */  dev_crit)(struct device  const  *dev , char const   *fmt 
                                               , ...) ;
#line 1043
extern int ( /* format attribute */  dev_err)(struct device  const  *dev , char const   *fmt 
                                              , ...) ;
#line 1045
extern int ( /* format attribute */  dev_warn)(struct device  const  *dev , char const   *fmt 
                                               , ...) ;
#line 1047
extern int ( /* format attribute */  dev_notice)(struct device  const  *dev , char const   *fmt 
                                                 , ...) ;
#line 1049
extern int ( /* format attribute */  _dev_info)(struct device  const  *dev , char const   *fmt 
                                                , ...) ;
#line 27 "../../../analyzer/../bench/linux-headers/include/linux/io.h"
extern void __attribute__((__externally_visible__))  __iowrite32_copy(void *to , void const   *from ,
                                                                      size_t count ) ;
#line 28
extern void __iowrite64_copy(void *to , void const   *from , size_t count ) ;
#line 31
extern int ioremap_page_range(unsigned long addr , unsigned long end , phys_addr_t phys_addr ,
                              pgprot_t prot ) ;
#line 45
extern void *devm_ioport_map(struct device *dev , unsigned long port , unsigned int nr ) ;
#line 47
extern void devm_ioport_unmap(struct device *dev , void *addr ) ;
#line 63
extern void *devm_ioremap(struct device *dev , resource_size_t offset , unsigned long size ) ;
#line 65
extern void *devm_ioremap_nocache(struct device *dev , resource_size_t offset , unsigned long size ) ;
#line 67
extern void devm_iounmap(struct device *dev , void *addr ) ;
#line 68
extern int check_signature(void const volatile   *io_addr , unsigned char const   *signature ,
                           int length ) ;
#line 70
extern void devm_ioremap_release(struct device *dev , void *res ) ;
#line 61 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static char const   *pci_slot_name(struct pci_slot  const  *slot )  __attribute__((__no_instrument_function__)) ;
#line 61 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static char const   *pci_slot_name(struct pci_slot  const  *slot ) 
{ 
  char const   *tmp___7 ;

  {
  {
#line 63
  tmp___7 = kobject_name(& slot->kobj);
  }
#line 63
  return (tmp___7);
}
}
#line 120
extern char const   *pci_power_names[] ;
#line 122
__inline static char const   *pci_power_name(pci_power_t state )  __attribute__((__no_instrument_function__)) ;
#line 122 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static char const   *pci_power_name(pci_power_t state ) 
{ 


  {
#line 124
  return (pci_power_names[1 + state]);
}
}
#line 377
__inline static struct pci_dev *pci_physfn(struct pci_dev *dev )  __attribute__((__no_instrument_function__)) ;
#line 377 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static struct pci_dev *pci_physfn(struct pci_dev *dev ) 
{ 


  {
#line 383
  return (dev);
}
}
#line 386
extern struct pci_dev *pci_alloc_dev(struct pci_bus *bus ) ;
#line 391
__inline static int pci_channel_offline(struct pci_dev *pdev )  __attribute__((__no_instrument_function__)) ;
#line 391 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static int pci_channel_offline(struct pci_dev *pdev ) 
{ 


  {
#line 393
  return (pdev->error_state != 1U);
}
}
#line 411
extern void pci_set_host_bridge_release(struct pci_host_bridge *bridge , void (*release_fn)(struct pci_host_bridge * ) ,
                                        void *release_data ) ;
#line 415
extern int pcibios_root_bridge_prepare(struct pci_host_bridge *bridge ) ;
#line 482
__inline static bool pci_is_root_bus(struct pci_bus *pbus )  __attribute__((__no_instrument_function__)) ;
#line 482 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static bool pci_is_root_bus(struct pci_bus *pbus ) 
{ 


  {
#line 484
  return ((bool )(! pbus->parent));
}
}
#line 494
__inline static bool pci_is_bridge(struct pci_dev *dev )  __attribute__((__no_instrument_function__)) ;
#line 494 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static bool pci_is_bridge(struct pci_dev *dev ) 
{ 
  int tmp___7 ;

  {
#line 496
  if ((int )dev->hdr_type == 1) {
    {
#line 496
    tmp___7 = 1;
    }
  } else
#line 496
  if ((int )dev->hdr_type == 2) {
    {
#line 496
    tmp___7 = 1;
    }
  } else {
    {
#line 496
    tmp___7 = 0;
    }
  }
#line 496
  return ((bool )tmp___7);
}
}
#line 500
__inline static struct pci_dev *pci_upstream_bridge(struct pci_dev *dev )  __attribute__((__no_instrument_function__)) ;
#line 500 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static struct pci_dev *pci_upstream_bridge(struct pci_dev *dev ) 
{ 
  bool tmp___7 ;

  {
  {
#line 502
  dev = pci_physfn(dev);
#line 503
  tmp___7 = pci_is_root_bus(dev->bus);
  }
#line 503
  if (tmp___7) {
#line 504
    return ((struct pci_dev *)((void *)0));
  }
#line 506
  return ((dev->bus)->self);
}
}
#line 510
__inline static bool pci_dev_msi_enabled(struct pci_dev *pci_dev )  __attribute__((__no_instrument_function__)) ;
#line 510 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static bool pci_dev_msi_enabled(struct pci_dev *pci_dev ) 
{ 
  int tmp___7 ;

  {
#line 512
  if (pci_dev->msi_enabled) {
    {
#line 512
    tmp___7 = 1;
    }
  } else
#line 512
  if (pci_dev->msix_enabled) {
    {
#line 512
    tmp___7 = 1;
    }
  } else {
    {
#line 512
    tmp___7 = 0;
    }
  }
#line 512
  return ((bool )tmp___7);
}
}
#line 532
__inline static int pcibios_err_to_errno(int err )  __attribute__((__no_instrument_function__)) ;
#line 532 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static int pcibios_err_to_errno(int err ) 
{ 


  {
#line 534
  if (err <= 0) {
#line 535
    return (err);
  }
  {
#line 538
  if (err == 129) {
#line 538
    goto case_129;
  }
#line 540
  if (err == 131) {
#line 540
    goto case_131;
  }
#line 542
  if (err == 134) {
#line 542
    goto case_134;
  }
#line 544
  if (err == 135) {
#line 544
    goto case_135;
  }
#line 546
  if (err == 136) {
#line 546
    goto case_136;
  }
#line 548
  if (err == 137) {
#line 548
    goto case_137;
  }
#line 537
  goto switch_break;
  case_129: /* CIL Label */ 
#line 539
  return (-2);
  case_131: /* CIL Label */ 
#line 541
  return (-25);
  case_134: /* CIL Label */ 
#line 543
  return (-19);
  case_135: /* CIL Label */ 
#line 545
  return (-14);
  case_136: /* CIL Label */ 
#line 547
  return (-5);
  case_137: /* CIL Label */ 
#line 549
  return (-28);
  switch_break: /* CIL Label */ ;
  }
#line 552
  return (-34);
}
}
#line 566
extern int raw_pci_read(unsigned int domain , unsigned int bus , unsigned int devfn ,
                        int reg , int len , u32 *val ) ;
#line 568
extern int raw_pci_write(unsigned int domain , unsigned int bus , unsigned int devfn ,
                         int reg , int len , u32 val ) ;
#line 722
extern void pcie_bus_configure_settings(struct pci_bus *bus ) ;
#line 731
extern enum pcie_bus_config_types pcie_bus_config ;
#line 733
extern struct bus_type pci_bus_type ;
#line 737
extern struct list_head pci_root_buses ;
#line 739
extern int no_pci_devices(void) ;
#line 741
extern void pcibios_resource_survey_bus(struct pci_bus *bus ) ;
#line 742
extern void pcibios_add_bus(struct pci_bus *bus ) ;
#line 743
extern void pcibios_remove_bus(struct pci_bus *bus ) ;
#line 744
extern void pcibios_fixup_bus(struct pci_bus * ) ;
#line 745
extern int ( __attribute__((__warn_unused_result__)) pcibios_enable_device)(struct pci_dev * ,
                                                                            int mask ) ;
#line 747
extern char *pcibios_setup(char *str ) ;
#line 750
extern resource_size_t pcibios_align_resource(void * , struct resource  const  * ,
                                              resource_size_t  , resource_size_t  ) ;
#line 753
extern void pcibios_update_irq(struct pci_dev * , int irq ) ;
#line 756
extern void pci_fixup_cardbus(struct pci_bus * ) ;
#line 760
extern void pcibios_resource_to_bus(struct pci_bus *bus , struct pci_bus_region *region ,
                                    struct resource *res ) ;
#line 762
extern void pcibios_bus_to_resource(struct pci_bus *bus , struct resource *res , struct pci_bus_region *region ) ;
#line 764
extern void pcibios_scan_specific_bus(int busn ) ;
#line 765
extern struct pci_bus *pci_find_bus(int domain , int busnr ) ;
#line 766
extern void pci_bus_add_devices(struct pci_bus  const  *bus ) ;
#line 767
extern struct pci_bus *pci_scan_bus_parented(struct device *parent , int bus , struct pci_ops *ops ,
                                             void *sysdata ) ;
#line 769
extern struct pci_bus *pci_scan_bus(int bus , struct pci_ops *ops , void *sysdata ) ;
#line 770
extern struct pci_bus *pci_create_root_bus(struct device *parent , int bus , struct pci_ops *ops ,
                                           void *sysdata , struct list_head *resources ) ;
#line 773
extern int pci_bus_insert_busn_res(struct pci_bus *b , int bus , int busmax ) ;
#line 774
extern int pci_bus_update_busn_res_end(struct pci_bus *b , int busmax ) ;
#line 775
extern void pci_bus_release_busn_res(struct pci_bus *b ) ;
#line 776
extern struct pci_bus *pci_scan_root_bus(struct device *parent , int bus , struct pci_ops *ops ,
                                         void *sysdata , struct list_head *resources ) ;
#line 779
extern struct pci_bus *pci_add_new_bus(struct pci_bus *parent , struct pci_dev *dev ,
                                       int busnr ) ;
#line 781
extern void pcie_update_link_speed(struct pci_bus *bus , u16 link_status ) ;
#line 782
extern struct pci_slot *pci_create_slot(struct pci_bus *parent , int slot_nr , char const   *name ,
                                        struct hotplug_slot *hotplug ) ;
#line 785
extern void pci_destroy_slot(struct pci_slot *slot ) ;
#line 786
extern int pci_scan_slot(struct pci_bus *bus , int devfn ) ;
#line 787
extern struct pci_dev *pci_scan_single_device(struct pci_bus *bus , int devfn ) ;
#line 788
extern void pci_device_add(struct pci_dev *dev , struct pci_bus *bus ) ;
#line 789
extern unsigned int pci_scan_child_bus(struct pci_bus *bus ) ;
#line 790
extern void pci_bus_add_device(struct pci_dev *dev ) ;
#line 791
extern void pci_read_bridge_bases(struct pci_bus *child ) ;
#line 792
extern struct resource *pci_find_parent_resource(struct pci_dev  const  *dev , struct resource *res ) ;
#line 794
extern u8 pci_swizzle_interrupt_pin(struct pci_dev  const  *dev , u8 pin ) ;
#line 795
extern int pci_get_interrupt_pin(struct pci_dev *dev , struct pci_dev **bridge ) ;
#line 796
extern u8 pci_common_swizzle(struct pci_dev *dev , u8 *pinp ) ;
#line 797
extern struct pci_dev *pci_dev_get(struct pci_dev *dev ) ;
#line 798
extern void pci_dev_put(struct pci_dev *dev ) ;
#line 799
extern void pci_remove_bus(struct pci_bus *b ) ;
#line 800
extern void pci_stop_and_remove_bus_device(struct pci_dev *dev ) ;
#line 801
extern void pci_stop_and_remove_bus_device_locked(struct pci_dev *dev ) ;
#line 802
extern void pci_stop_root_bus(struct pci_bus *bus ) ;
#line 803
extern void pci_remove_root_bus(struct pci_bus *bus ) ;
#line 804
extern void pci_setup_cardbus(struct pci_bus *bus ) ;
#line 805
extern void pci_sort_breadthfirst(void) ;
#line 818
extern enum pci_lost_interrupt_reason pci_lost_interrupt(struct pci_dev *dev ) ;
#line 819
extern int pci_find_capability(struct pci_dev *dev , int cap ) ;
#line 820
extern int pci_find_next_capability(struct pci_dev *dev , u8 pos , int cap ) ;
#line 821
extern int pci_find_ext_capability(struct pci_dev *dev , int cap ) ;
#line 822
extern int pci_find_next_ext_capability(struct pci_dev *dev , int pos , int cap ) ;
#line 823
extern int pci_find_ht_capability(struct pci_dev *dev , int ht_cap ) ;
#line 824
extern int pci_find_next_ht_capability(struct pci_dev *dev , int pos , int ht_cap ) ;
#line 825
extern struct pci_bus *pci_find_next_bus(struct pci_bus  const  *from ) ;
#line 827
extern struct pci_dev *pci_get_device(unsigned int vendor , unsigned int device ,
                                      struct pci_dev *from ) ;
#line 829
extern struct pci_dev *pci_get_subsys(unsigned int vendor , unsigned int device ,
                                      unsigned int ss_vendor , unsigned int ss_device ,
                                      struct pci_dev *from ) ;
#line 832
extern struct pci_dev *pci_get_slot(struct pci_bus *bus , unsigned int devfn ) ;
#line 833
extern struct pci_dev *pci_get_domain_bus_and_slot(int domain , unsigned int bus ,
                                                   unsigned int devfn ) ;
#line 835
__inline static struct pci_dev *pci_get_bus_and_slot(unsigned int bus , unsigned int devfn )  __attribute__((__no_instrument_function__)) ;
#line 835 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static struct pci_dev *pci_get_bus_and_slot(unsigned int bus , unsigned int devfn ) 
{ 
  struct pci_dev *tmp___7 ;

  {
  {
#line 838
  tmp___7 = pci_get_domain_bus_and_slot(0, bus, devfn);
  }
#line 838
  return (tmp___7);
}
}
#line 840
extern struct pci_dev *pci_get_class(unsigned int class , struct pci_dev *from ) ;
#line 841
extern int pci_dev_present(struct pci_device_id  const  *ids ) ;
#line 843
extern int pci_bus_read_config_byte(struct pci_bus *bus , unsigned int devfn , int where ,
                                    u8 *val ) ;
#line 845
extern int pci_bus_read_config_word(struct pci_bus *bus , unsigned int devfn , int where ,
                                    u16 *val ) ;
#line 847
extern int pci_bus_read_config_dword(struct pci_bus *bus , unsigned int devfn , int where ,
                                     u32 *val ) ;
#line 849
extern int pci_bus_write_config_byte(struct pci_bus *bus , unsigned int devfn , int where ,
                                     u8 val ) ;
#line 851
extern int pci_bus_write_config_word(struct pci_bus *bus , unsigned int devfn , int where ,
                                     u16 val ) ;
#line 853
extern int pci_bus_write_config_dword(struct pci_bus *bus , unsigned int devfn , int where ,
                                      u32 val ) ;
#line 855
extern struct pci_ops *pci_bus_set_ops(struct pci_bus *bus , struct pci_ops *ops ) ;
#line 857
__inline static int pci_read_config_byte(struct pci_dev  const  *dev , int where ,
                                         u8 *val )  __attribute__((__no_instrument_function__)) ;
#line 857 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static int pci_read_config_byte(struct pci_dev  const  *dev , int where ,
                                         u8 *val ) 
{ 
  int tmp___7 ;

  {
  {
#line 859
  tmp___7 = pci_bus_read_config_byte((struct pci_bus *)dev->bus, (unsigned int )dev->devfn,
                                     where, val);
  }
#line 859
  return (tmp___7);
}
}
#line 861
__inline static int pci_read_config_word(struct pci_dev  const  *dev , int where ,
                                         u16 *val )  __attribute__((__no_instrument_function__)) ;
#line 861 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static int pci_read_config_word(struct pci_dev  const  *dev , int where ,
                                         u16 *val ) 
{ 
  int tmp___7 ;

  {
  {
#line 863
  tmp___7 = pci_bus_read_config_word((struct pci_bus *)dev->bus, (unsigned int )dev->devfn,
                                     where, val);
  }
#line 863
  return (tmp___7);
}
}
#line 865
__inline static int pci_read_config_dword(struct pci_dev  const  *dev , int where ,
                                          u32 *val )  __attribute__((__no_instrument_function__)) ;
#line 865 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static int pci_read_config_dword(struct pci_dev  const  *dev , int where ,
                                          u32 *val ) 
{ 
  int tmp___7 ;

  {
  {
#line 868
  tmp___7 = pci_bus_read_config_dword((struct pci_bus *)dev->bus, (unsigned int )dev->devfn,
                                      where, val);
  }
#line 868
  return (tmp___7);
}
}
#line 870
__inline static int pci_write_config_byte(struct pci_dev  const  *dev , int where ,
                                          u8 val )  __attribute__((__no_instrument_function__)) ;
#line 870 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static int pci_write_config_byte(struct pci_dev  const  *dev , int where ,
                                          u8 val ) 
{ 
  int tmp___7 ;

  {
  {
#line 872
  tmp___7 = pci_bus_write_config_byte((struct pci_bus *)dev->bus, (unsigned int )dev->devfn,
                                      where, val);
  }
#line 872
  return (tmp___7);
}
}
#line 874
__inline static int pci_write_config_word(struct pci_dev  const  *dev , int where ,
                                          u16 val )  __attribute__((__no_instrument_function__)) ;
#line 874 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static int pci_write_config_word(struct pci_dev  const  *dev , int where ,
                                          u16 val ) 
{ 
  int tmp___7 ;

  {
  {
#line 876
  tmp___7 = pci_bus_write_config_word((struct pci_bus *)dev->bus, (unsigned int )dev->devfn,
                                      where, val);
  }
#line 876
  return (tmp___7);
}
}
#line 878
__inline static int pci_write_config_dword(struct pci_dev  const  *dev , int where ,
                                           u32 val )  __attribute__((__no_instrument_function__)) ;
#line 878 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static int pci_write_config_dword(struct pci_dev  const  *dev , int where ,
                                           u32 val ) 
{ 
  int tmp___7 ;

  {
  {
#line 881
  tmp___7 = pci_bus_write_config_dword((struct pci_bus *)dev->bus, (unsigned int )dev->devfn,
                                       where, val);
  }
#line 881
  return (tmp___7);
}
}
#line 884
extern int pcie_capability_read_word(struct pci_dev *dev , int pos , u16 *val ) ;
#line 885
extern int pcie_capability_read_dword(struct pci_dev *dev , int pos , u32 *val ) ;
#line 886
extern int pcie_capability_write_word(struct pci_dev *dev , int pos , u16 val ) ;
#line 887
extern int pcie_capability_write_dword(struct pci_dev *dev , int pos , u32 val ) ;
#line 888
extern int pcie_capability_clear_and_set_word(struct pci_dev *dev , int pos , u16 clear ,
                                              u16 set ) ;
#line 890
extern int pcie_capability_clear_and_set_dword(struct pci_dev *dev , int pos , u32 clear ,
                                               u32 set ) ;
#line 893
__inline static int pcie_capability_set_word(struct pci_dev *dev , int pos , u16 set )  __attribute__((__no_instrument_function__)) ;
#line 893 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static int pcie_capability_set_word(struct pci_dev *dev , int pos , u16 set ) 
{ 
  int tmp___7 ;

  {
  {
#line 896
  tmp___7 = pcie_capability_clear_and_set_word(dev, pos, (u16 )0, set);
  }
#line 896
  return (tmp___7);
}
}
#line 899
__inline static int pcie_capability_set_dword(struct pci_dev *dev , int pos , u32 set )  __attribute__((__no_instrument_function__)) ;
#line 899 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static int pcie_capability_set_dword(struct pci_dev *dev , int pos , u32 set ) 
{ 
  int tmp___7 ;

  {
  {
#line 902
  tmp___7 = pcie_capability_clear_and_set_dword(dev, pos, (u32 )0, set);
  }
#line 902
  return (tmp___7);
}
}
#line 905
__inline static int pcie_capability_clear_word(struct pci_dev *dev , int pos , u16 clear )  __attribute__((__no_instrument_function__)) ;
#line 905 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static int pcie_capability_clear_word(struct pci_dev *dev , int pos , u16 clear ) 
{ 
  int tmp___7 ;

  {
  {
#line 908
  tmp___7 = pcie_capability_clear_and_set_word(dev, pos, clear, (u16 )0);
  }
#line 908
  return (tmp___7);
}
}
#line 911
__inline static int pcie_capability_clear_dword(struct pci_dev *dev , int pos , u32 clear )  __attribute__((__no_instrument_function__)) ;
#line 911 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static int pcie_capability_clear_dword(struct pci_dev *dev , int pos , u32 clear ) 
{ 
  int tmp___7 ;

  {
  {
#line 914
  tmp___7 = pcie_capability_clear_and_set_dword(dev, pos, clear, (u32 )0);
  }
#line 914
  return (tmp___7);
}
}
#line 918
extern int pci_user_read_config_byte(struct pci_dev *dev , int where , u8 *val ) ;
#line 919
extern int pci_user_read_config_word(struct pci_dev *dev , int where , u16 *val ) ;
#line 920
extern int pci_user_read_config_dword(struct pci_dev *dev , int where , u32 *val ) ;
#line 921
extern int pci_user_write_config_byte(struct pci_dev *dev , int where , u8 val ) ;
#line 922
extern int pci_user_write_config_word(struct pci_dev *dev , int where , u16 val ) ;
#line 923
extern int pci_user_write_config_dword(struct pci_dev *dev , int where , u32 val ) ;
#line 925
extern int ( __attribute__((__warn_unused_result__)) pci_enable_device)(struct pci_dev *dev ) ;
#line 926
extern int ( __attribute__((__warn_unused_result__)) pci_enable_device_io)(struct pci_dev *dev ) ;
#line 927
extern int ( __attribute__((__warn_unused_result__)) pci_enable_device_mem)(struct pci_dev *dev ) ;
#line 928
extern int ( __attribute__((__warn_unused_result__)) pci_reenable_device)(struct pci_dev * ) ;
#line 929
extern int ( __attribute__((__warn_unused_result__)) pcim_enable_device)(struct pci_dev *pdev ) ;
#line 930
extern void pcim_pin_device(struct pci_dev *pdev ) ;
#line 932
__inline static int pci_is_enabled(struct pci_dev *pdev )  __attribute__((__no_instrument_function__)) ;
#line 932 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static int pci_is_enabled(struct pci_dev *pdev ) 
{ 
  int tmp___7 ;

  {
  {
#line 934
  tmp___7 = atomic_read((atomic_t const   *)(& pdev->enable_cnt));
  }
#line 934
  return (tmp___7 > 0);
}
}
#line 937
__inline static int pci_is_managed(struct pci_dev *pdev )  __attribute__((__no_instrument_function__)) ;
#line 937 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static int pci_is_managed(struct pci_dev *pdev ) 
{ 


  {
#line 939
  return ((int )pdev->is_managed);
}
}
#line 942
extern void pci_disable_device(struct pci_dev *dev ) ;
#line 944
extern unsigned int pcibios_max_latency ;
#line 945
extern void pci_set_master(struct pci_dev *dev ) ;
#line 946
extern void pci_clear_master(struct pci_dev *dev ) ;
#line 948
extern int pci_set_pcie_reset_state(struct pci_dev *dev , enum pcie_reset_state state ) ;
#line 949
extern int pci_set_cacheline_size(struct pci_dev *dev ) ;
#line 951
extern int ( __attribute__((__warn_unused_result__)) pci_set_mwi)(struct pci_dev *dev ) ;
#line 952
extern int pci_try_set_mwi(struct pci_dev *dev ) ;
#line 953
extern void pci_clear_mwi(struct pci_dev *dev ) ;
#line 954
extern void pci_intx(struct pci_dev *dev , int enable ) ;
#line 955
extern bool pci_intx_mask_supported(struct pci_dev *dev ) ;
#line 956
extern bool pci_check_and_mask_intx(struct pci_dev *dev ) ;
#line 957
extern bool pci_check_and_unmask_intx(struct pci_dev *dev ) ;
#line 958
extern void pci_msi_off(struct pci_dev *dev ) ;
#line 959
extern int pci_set_dma_max_seg_size(struct pci_dev *dev , unsigned int size ) ;
#line 960
extern int pci_set_dma_seg_boundary(struct pci_dev *dev , unsigned long mask ) ;
#line 961
extern int pci_wait_for_pending(struct pci_dev *dev , int pos , u16 mask ) ;
#line 962
extern int pci_wait_for_pending_transaction(struct pci_dev *dev ) ;
#line 963
extern int pcix_get_max_mmrbc(struct pci_dev *dev ) ;
#line 964
extern int pcix_get_mmrbc(struct pci_dev *dev ) ;
#line 965
extern int pcix_set_mmrbc(struct pci_dev *dev , int mmrbc ) ;
#line 966
extern int pcie_get_readrq(struct pci_dev *dev ) ;
#line 967
extern int pcie_set_readrq(struct pci_dev *dev , int rq ) ;
#line 968
extern int pcie_get_mps(struct pci_dev *dev ) ;
#line 969
extern int pcie_set_mps(struct pci_dev *dev , int mps ) ;
#line 970
extern int pcie_get_minimum_link(struct pci_dev *dev , enum pci_bus_speed *speed ,
                                 enum pcie_link_width *width ) ;
#line 972
extern int __pci_reset_function(struct pci_dev *dev ) ;
#line 973
extern int __pci_reset_function_locked(struct pci_dev *dev ) ;
#line 974
extern int pci_reset_function(struct pci_dev *dev ) ;
#line 975
extern int pci_try_reset_function(struct pci_dev *dev ) ;
#line 976
extern int pci_probe_reset_slot(struct pci_slot *slot ) ;
#line 977
extern int pci_reset_slot(struct pci_slot *slot ) ;
#line 978
extern int pci_try_reset_slot(struct pci_slot *slot ) ;
#line 979
extern int pci_probe_reset_bus(struct pci_bus *bus ) ;
#line 980
extern int pci_reset_bus(struct pci_bus *bus ) ;
#line 981
extern int pci_try_reset_bus(struct pci_bus *bus ) ;
#line 982
extern void pci_reset_secondary_bus(struct pci_dev *dev ) ;
#line 983
extern void pcibios_reset_secondary_bus(struct pci_dev *dev ) ;
#line 984
extern void pci_reset_bridge_secondary_bus(struct pci_dev *dev ) ;
#line 985
extern void pci_update_resource(struct pci_dev *dev , int resno ) ;
#line 986
extern int ( __attribute__((__warn_unused_result__)) pci_assign_resource)(struct pci_dev *dev ,
                                                                          int i ) ;
#line 987
extern int ( __attribute__((__warn_unused_result__)) pci_reassign_resource)(struct pci_dev *dev ,
                                                                            int i ,
                                                                            resource_size_t add_size ,
                                                                            resource_size_t align ) ;
#line 988
extern int pci_select_bars(struct pci_dev *dev , unsigned long flags ) ;
#line 989
extern bool pci_device_is_present(struct pci_dev *pdev ) ;
#line 992
extern int pci_enable_rom(struct pci_dev *pdev ) ;
#line 993
extern void pci_disable_rom(struct pci_dev *pdev ) ;
#line 994
extern void *( __attribute__((__warn_unused_result__)) pci_map_rom)(struct pci_dev *pdev ,
                                                                    size_t *size ) ;
#line 995
extern void pci_unmap_rom(struct pci_dev *pdev , void *rom ) ;
#line 996
extern size_t pci_get_rom_size(struct pci_dev *pdev , void *rom , size_t size ) ;
#line 997
extern void *( __attribute__((__warn_unused_result__)) pci_platform_rom)(struct pci_dev *pdev ,
                                                                         size_t *size ) ;
#line 1000
extern int pci_save_state(struct pci_dev *dev ) ;
#line 1001
extern void pci_restore_state(struct pci_dev *dev ) ;
#line 1002
extern struct pci_saved_state *pci_store_saved_state(struct pci_dev *dev ) ;
#line 1003
extern int pci_load_and_free_saved_state(struct pci_dev *dev , struct pci_saved_state **state ) ;
#line 1005
extern struct pci_cap_saved_state *pci_find_saved_cap(struct pci_dev *dev , char cap ) ;
#line 1006
extern struct pci_cap_saved_state *pci_find_saved_ext_cap(struct pci_dev *dev , u16 cap ) ;
#line 1008
extern int pci_add_cap_save_buffer(struct pci_dev *dev , char cap , unsigned int size ) ;
#line 1009
extern int pci_add_ext_cap_save_buffer(struct pci_dev *dev , u16 cap , unsigned int size ) ;
#line 1011
extern int __pci_complete_power_transition(struct pci_dev *dev , pci_power_t state ) ;
#line 1012
extern int pci_set_power_state(struct pci_dev *dev , pci_power_t state ) ;
#line 1013
extern pci_power_t pci_choose_state(struct pci_dev *dev , pm_message_t state ) ;
#line 1014
extern bool pci_pme_capable(struct pci_dev *dev , pci_power_t state ) ;
#line 1015
extern void pci_pme_active(struct pci_dev *dev , bool enable ) ;
#line 1016
extern int __pci_enable_wake(struct pci_dev *dev , pci_power_t state , bool runtime ,
                             bool enable ) ;
#line 1018
extern int pci_wake_from_d3(struct pci_dev *dev , bool enable ) ;
#line 1019
extern int pci_prepare_to_sleep(struct pci_dev *dev ) ;
#line 1020
extern int pci_back_from_sleep(struct pci_dev *dev ) ;
#line 1021
extern bool pci_dev_run_wake(struct pci_dev *dev ) ;
#line 1022
extern bool pci_check_pme_status(struct pci_dev *dev ) ;
#line 1023
extern void pci_pme_wakeup_bus(struct pci_bus *bus ) ;
#line 1025
__inline static void pci_ignore_hotplug(struct pci_dev *dev )  __attribute__((__no_instrument_function__)) ;
#line 1025 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static void pci_ignore_hotplug(struct pci_dev *dev ) 
{ 


  {
  {
#line 1027
  dev->ignore_hotplug = 1U;
  }
#line 1028
  return;
}
}
#line 1030
__inline static int pci_enable_wake(struct pci_dev *dev , pci_power_t state , bool enable )  __attribute__((__no_instrument_function__)) ;
#line 1030 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static int pci_enable_wake(struct pci_dev *dev , pci_power_t state , bool enable ) 
{ 
  int tmp___7 ;

  {
  {
#line 1033
  tmp___7 = __pci_enable_wake(dev, state, (bool )0, enable);
  }
#line 1033
  return (tmp___7);
}
}
#line 1037
extern int pci_save_vc_state(struct pci_dev *dev ) ;
#line 1038
extern void pci_restore_vc_state(struct pci_dev *dev ) ;
#line 1039
extern void pci_allocate_vc_save_buffers(struct pci_dev *dev ) ;
#line 1042
extern void set_pcie_port_type(struct pci_dev *pdev ) ;
#line 1043
extern void set_pcie_hotplug_bridge(struct pci_dev *pdev ) ;
#line 1046
extern int pci_bus_find_capability(struct pci_bus *bus , unsigned int devfn , int cap ) ;
#line 1047
extern unsigned int pci_rescan_bus_bridge_resize(struct pci_dev *bridge ) ;
#line 1048
extern unsigned int pci_rescan_bus(struct pci_bus *bus ) ;
#line 1049
extern void pci_lock_rescan_remove(void) ;
#line 1050
extern void pci_unlock_rescan_remove(void) ;
#line 1053
extern ssize_t pci_read_vpd(struct pci_dev *dev , loff_t pos , size_t count , void *buf ) ;
#line 1054
extern ssize_t pci_write_vpd(struct pci_dev *dev , loff_t pos , size_t count , void const   *buf ) ;
#line 1057
extern resource_size_t pcibios_retrieve_fw_addr(struct pci_dev *dev , int idx ) ;
#line 1058
extern void pci_bus_assign_resources(struct pci_bus  const  *bus ) ;
#line 1059
extern void pci_bus_size_bridges(struct pci_bus *bus ) ;
#line 1060
extern int pci_claim_resource(struct pci_dev * , int  ) ;
#line 1061
extern void pci_assign_unassigned_resources(void) ;
#line 1062
extern void pci_assign_unassigned_bridge_resources(struct pci_dev *bridge ) ;
#line 1063
extern void pci_assign_unassigned_bus_resources(struct pci_bus *bus ) ;
#line 1064
extern void pci_assign_unassigned_root_bus_resources(struct pci_bus *bus ) ;
#line 1065
extern void pdev_enable_device(struct pci_dev * ) ;
#line 1066
extern int pci_enable_resources(struct pci_dev * , int mask ) ;
#line 1067
extern void pci_fixup_irqs(u8 (*)(struct pci_dev * , u8 * ) , int (*)(struct pci_dev  const  * ,
                                                                      u8  , u8  ) ) ;
#line 1070
extern int ( __attribute__((__warn_unused_result__)) pci_request_regions)(struct pci_dev * ,
                                                                          char const   * ) ;
#line 1071
extern int ( __attribute__((__warn_unused_result__)) pci_request_regions_exclusive)(struct pci_dev * ,
                                                                                    char const   * ) ;
#line 1072
extern void pci_release_regions(struct pci_dev * ) ;
#line 1073
extern int ( __attribute__((__warn_unused_result__)) pci_request_region)(struct pci_dev * ,
                                                                         int  , char const   * ) ;
#line 1074
extern int ( __attribute__((__warn_unused_result__)) pci_request_region_exclusive)(struct pci_dev * ,
                                                                                   int  ,
                                                                                   char const   * ) ;
#line 1075
extern void pci_release_region(struct pci_dev * , int  ) ;
#line 1076
extern int pci_request_selected_regions(struct pci_dev * , int  , char const   * ) ;
#line 1077
extern int pci_request_selected_regions_exclusive(struct pci_dev * , int  , char const   * ) ;
#line 1078
extern void pci_release_selected_regions(struct pci_dev * , int  ) ;
#line 1081
extern struct pci_bus *pci_bus_get(struct pci_bus *bus ) ;
#line 1082
extern void pci_bus_put(struct pci_bus *bus ) ;
#line 1083
extern void pci_add_resource(struct list_head *resources , struct resource *res ) ;
#line 1084
extern void pci_add_resource_offset(struct list_head *resources , struct resource *res ,
                                    resource_size_t offset ) ;
#line 1086
extern void pci_free_resource_list(struct list_head *resources ) ;
#line 1087
extern void pci_bus_add_resource(struct pci_bus *bus , struct resource *res , unsigned int flags ) ;
#line 1088
extern struct resource *pci_bus_resource_n(struct pci_bus  const  *bus , int n ) ;
#line 1089
extern void pci_bus_remove_resources(struct pci_bus *bus ) ;
#line 1096
extern int ( __attribute__((__warn_unused_result__)) pci_bus_alloc_resource)(struct pci_bus *bus ,
                                                                             struct resource *res ,
                                                                             resource_size_t size ,
                                                                             resource_size_t align ,
                                                                             resource_size_t min ,
                                                                             unsigned long type_mask ,
                                                                             resource_size_t (*alignf)(void * ,
                                                                                                       struct resource  const  * ,
                                                                                                       resource_size_t  ,
                                                                                                       resource_size_t  ) ,
                                                                             void *alignf_data ) ;
#line 1106
__inline static dma_addr_t pci_bus_address(struct pci_dev *pdev , int bar )  __attribute__((__no_instrument_function__)) ;
#line 1106 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static dma_addr_t pci_bus_address(struct pci_dev *pdev , int bar ) 
{ 
  struct pci_bus_region region ;

  {
  {
#line 1110
  pcibios_resource_to_bus(pdev->bus, & region, & pdev->resource[bar]);
  }
#line 1111
  return (region.start);
}
}
#line 1115
extern int ( __attribute__((__warn_unused_result__)) __pci_register_driver)(struct pci_driver * ,
                                                                            struct module * ,
                                                                            char const   *mod_name ) ;
#line 1124
extern void pci_unregister_driver(struct pci_driver *dev ) ;
#line 1138
extern struct pci_driver *pci_dev_driver(struct pci_dev  const  *dev ) ;
#line 1139
extern int pci_add_dynid(struct pci_driver *drv , unsigned int vendor , unsigned int device ,
                         unsigned int subvendor , unsigned int subdevice , unsigned int class ,
                         unsigned int class_mask , unsigned long driver_data ) ;
#line 1144
extern struct pci_device_id  const  *pci_match_id(struct pci_device_id  const  *ids ,
                                                  struct pci_dev *dev ) ;
#line 1146
extern int pci_scan_bridge(struct pci_bus *bus , struct pci_dev *dev , int max , int pass ) ;
#line 1149
extern void pci_walk_bus(struct pci_bus *top , int (*cb)(struct pci_dev * , void * ) ,
                         void *userdata ) ;
#line 1151
extern int pci_cfg_space_size(struct pci_dev *dev ) ;
#line 1152
extern unsigned char pci_bus_max_busnr(struct pci_bus *bus ) ;
#line 1153
extern void pci_setup_bridge(struct pci_bus *bus ) ;
#line 1154
extern resource_size_t pcibios_window_alignment(struct pci_bus *bus , unsigned long type ) ;
#line 1160
extern int pci_set_vga_state(struct pci_dev *pdev , bool decode , unsigned int command_bits ,
                             u32 flags ) ;
#line 17 "../../../analyzer/../bench/linux-headers/include/linux/dmapool.h"
extern struct dma_pool *dma_pool_create(char const   *name , struct device *dev ,
                                        size_t size , size_t align , size_t allocation ) ;
#line 20
extern void dma_pool_destroy(struct dma_pool *pool ) ;
#line 22
extern void *dma_pool_alloc(struct dma_pool *pool , gfp_t mem_flags , dma_addr_t *handle ) ;
#line 25
extern void dma_pool_free(struct dma_pool *pool , void *vaddr , dma_addr_t addr ) ;
#line 30
extern struct dma_pool *dmam_pool_create(char const   *name , struct device *dev ,
                                         size_t size , size_t align , size_t allocation ) ;
#line 32
extern void dmam_pool_destroy(struct dma_pool *pool ) ;
#line 1190 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
extern int pci_msi_vec_count(struct pci_dev *dev ) ;
#line 1191
extern void pci_msi_shutdown(struct pci_dev *dev ) ;
#line 1192
extern void pci_disable_msi(struct pci_dev *dev ) ;
#line 1193
extern int pci_msix_vec_count(struct pci_dev *dev ) ;
#line 1194
extern int pci_enable_msix(struct pci_dev *dev , struct msix_entry *entries , int nvec ) ;
#line 1195
extern void pci_msix_shutdown(struct pci_dev *dev ) ;
#line 1196
extern void pci_disable_msix(struct pci_dev *dev ) ;
#line 1197
extern void pci_restore_msi_state(struct pci_dev *dev ) ;
#line 1198
extern int pci_msi_enabled(void) ;
#line 1199
extern int pci_enable_msi_range(struct pci_dev *dev , int minvec , int maxvec ) ;
#line 1200
__inline static int pci_enable_msi_exact(struct pci_dev *dev , int nvec )  __attribute__((__no_instrument_function__)) ;
#line 1200 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static int pci_enable_msi_exact(struct pci_dev *dev , int nvec ) 
{ 
  int rc ;
  int tmp___7 ;

  {
  {
#line 1202
  tmp___7 = pci_enable_msi_range(dev, nvec, nvec);
#line 1202
  rc = tmp___7;
  }
#line 1203
  if (rc < 0) {
#line 1204
    return (rc);
  }
#line 1205
  return (0);
}
}
#line 1207
extern int pci_enable_msix_range(struct pci_dev *dev , struct msix_entry *entries ,
                                 int minvec , int maxvec ) ;
#line 1209
__inline static int pci_enable_msix_exact(struct pci_dev *dev , struct msix_entry *entries ,
                                          int nvec )  __attribute__((__no_instrument_function__)) ;
#line 1209 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static int pci_enable_msix_exact(struct pci_dev *dev , struct msix_entry *entries ,
                                          int nvec ) 
{ 
  int rc ;
  int tmp___7 ;

  {
  {
#line 1212
  tmp___7 = pci_enable_msix_range(dev, entries, nvec, nvec);
#line 1212
  rc = tmp___7;
  }
#line 1213
  if (rc < 0) {
#line 1214
    return (rc);
  }
#line 1215
  return (0);
}
}
#line 1243
extern bool pcie_ports_disabled ;
#line 1244
extern bool pcie_ports_auto ;
#line 1251
extern bool pcie_aspm_support_enabled(void) ;
#line 1257
extern void pci_no_aer(void) ;
#line 1258
extern bool pci_aer_available(void) ;
#line 1268
__inline static void pcie_set_ecrc_checking(struct pci_dev *dev )  __attribute__((__no_instrument_function__)) ;
#line 1268 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static void pcie_set_ecrc_checking(struct pci_dev *dev ) 
{ 


  {
#line 1268
  return;
}
}
#line 1269
__inline static void pcie_ecrc_get_policy(char *str )  __attribute__((__no_instrument_function__)) ;
#line 1269 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static void pcie_ecrc_get_policy(char *str ) 
{ 


  {
#line 1269
  return;
}
}
#line 1276
extern int ht_create_irq(struct pci_dev *dev , int idx ) ;
#line 1277
extern void ht_destroy_irq(unsigned int irq ) ;
#line 1280
extern void pci_cfg_access_lock(struct pci_dev *dev ) ;
#line 1281
extern bool pci_cfg_access_trylock(struct pci_dev *dev ) ;
#line 1282
extern void pci_cfg_access_unlock(struct pci_dev *dev ) ;
#line 1290
extern int pci_domains_supported ;
#line 1300
extern void pci_register_set_vga_state(int (*func)(struct pci_dev *pdev , bool decode ,
                                                   unsigned int command_bits , u32 flags ) ) ;
#line 10 "../../../analyzer/../bench/linux-headers/include/linux/debug_locks.h"
extern int debug_locks ;
#line 11
extern int debug_locks_silent ;
#line 14
__inline static int __debug_locks_off(void)  __attribute__((__no_instrument_function__)) ;
#line 14 "../../../analyzer/../bench/linux-headers/include/linux/debug_locks.h"
__inline static int __debug_locks_off(void) 
{ 
  int __ret ;

  {
  {
#line 16
  __ret = 0;
  }
  {
#line 16
  if (sizeof(debug_locks) == 1UL) {
#line 16
    goto case_1;
  }
#line 16
  if (sizeof(debug_locks) == 2UL) {
#line 16
    goto case_2;
  }
#line 16
  if (sizeof(debug_locks) == 4UL) {
#line 16
    goto case_4;
  }
#line 16
  if (sizeof(debug_locks) == 8UL) {
#line 16
    goto case_8;
  }
#line 16
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 16
  __asm__  volatile   (""
                       "xchg"
                       "b %b0, %1\n": "+q" (__ret), "+m" (debug_locks): : "memory",
                       "cc");
  }
#line 16
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 16
  __asm__  volatile   (""
                       "xchg"
                       "w %w0, %1\n": "+r" (__ret), "+m" (debug_locks): : "memory",
                       "cc");
  }
#line 16
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 16
  __asm__  volatile   (""
                       "xchg"
                       "l %0, %1\n": "+r" (__ret), "+m" (debug_locks): : "memory",
                       "cc");
  }
#line 16
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 16
  __asm__  volatile   (""
                       "xchg"
                       "q %q0, %1\n": "+r" (__ret), "+m" (debug_locks): : "memory",
                       "cc");
  }
#line 16
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 16
  __xchg_wrong_size();
  }
  switch_break: /* CIL Label */ ;
  }
#line 16
  return (__ret);
}
}
#line 22
extern int debug_locks_off(void) ;
#line 56
__inline static void debug_show_all_locks(void)  __attribute__((__no_instrument_function__)) ;
#line 56 "../../../analyzer/../bench/linux-headers/include/linux/debug_locks.h"
__inline static void debug_show_all_locks(void) 
{ 


  {
#line 58
  return;
}
}
#line 60
__inline static void debug_show_held_locks(struct task_struct *task )  __attribute__((__no_instrument_function__)) ;
#line 60 "../../../analyzer/../bench/linux-headers/include/linux/debug_locks.h"
__inline static void debug_show_held_locks(struct task_struct *task ) 
{ 


  {
#line 62
  return;
}
}
#line 64
__inline static void debug_check_no_locks_freed(void const   *from , unsigned long len )  __attribute__((__no_instrument_function__)) ;
#line 64 "../../../analyzer/../bench/linux-headers/include/linux/debug_locks.h"
__inline static void debug_check_no_locks_freed(void const   *from , unsigned long len ) 
{ 


  {
#line 67
  return;
}
}
#line 69
__inline static void debug_check_no_locks_held(void)  __attribute__((__no_instrument_function__)) ;
#line 69 "../../../analyzer/../bench/linux-headers/include/linux/debug_locks.h"
__inline static void debug_check_no_locks_held(void) 
{ 


  {
#line 72
  return;
}
}
#line 15 "../../../analyzer/../bench/linux-headers/include/linux/bit_spinlock.h"
__inline static void bit_spin_lock(int bitnum , unsigned long *addr )  __attribute__((__no_instrument_function__)) ;
#line 15 "../../../analyzer/../bench/linux-headers/include/linux/bit_spinlock.h"
__inline static void bit_spin_lock(int bitnum , unsigned long *addr ) 
{ 
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;

  {
  {
#line 24
  __asm__  volatile   ("": : : "memory");
  }
  {
#line 26
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 26
    tmp___9 = test_and_set_bit_lock((long )bitnum, (unsigned long volatile   *)addr);
    }
#line 26
    if (tmp___9) {
      {
#line 26
      tmp___10 = 1;
      }
    } else {
      {
#line 26
      tmp___10 = 0;
      }
    }
    {
#line 26
    tmp___11 = __builtin_expect((long )tmp___10, 0L);
    }
#line 26
    if (! tmp___11) {
#line 26
      goto while_break;
    }
    {
#line 27
    __asm__  volatile   ("": : : "memory");
    }
    {
#line 28
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 29
      cpu_relax();
#line 28
      tmp___8 = variable_test_bit((long )bitnum, (unsigned long const volatile   *)addr);
      }
#line 28
      if (! tmp___8) {
#line 28
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 31
    __asm__  volatile   ("": : : "memory");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 35
  return;
}
}
#line 40
__inline static int bit_spin_trylock(int bitnum , unsigned long *addr )  __attribute__((__no_instrument_function__)) ;
#line 40 "../../../analyzer/../bench/linux-headers/include/linux/bit_spinlock.h"
__inline static int bit_spin_trylock(int bitnum , unsigned long *addr ) 
{ 
  int tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;

  {
  {
#line 42
  __asm__  volatile   ("": : : "memory");
#line 44
  tmp___7 = test_and_set_bit_lock((long )bitnum, (unsigned long volatile   *)addr);
  }
#line 44
  if (tmp___7) {
    {
#line 44
    tmp___8 = 1;
    }
  } else {
    {
#line 44
    tmp___8 = 0;
    }
  }
  {
#line 44
  tmp___9 = __builtin_expect((long )tmp___8, 0L);
  }
#line 44
  if (tmp___9) {
    {
#line 45
    __asm__  volatile   ("": : : "memory");
    }
#line 46
    return (0);
  }
#line 50
  return (1);
}
}
#line 56
__inline static void bit_spin_unlock(int bitnum , unsigned long *addr )  __attribute__((__no_instrument_function__)) ;
#line 56 "../../../analyzer/../bench/linux-headers/include/linux/bit_spinlock.h"
__inline static void bit_spin_unlock(int bitnum , unsigned long *addr ) 
{ 
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;

  {
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 59
    tmp___8 = variable_test_bit((long )bitnum, (unsigned long const volatile   *)addr);
    }
#line 59
    if (tmp___8) {
      {
#line 59
      tmp___9 = 0;
      }
    } else {
      {
#line 59
      tmp___9 = 1;
      }
    }
    {
#line 59
    tmp___10 = __builtin_expect((long )tmp___9, 0L);
    }
#line 59
    if (tmp___10) {
      {
#line 59
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 59
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("../../../analyzer/../bench/linux-headers/include/linux/bit_spinlock.h"),
                             "i" (59), "i" (sizeof(struct bug_entry )));
#line 59
        __builtin_unreachable();
        }
#line 59
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 59
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 62
  clear_bit_unlock((long )bitnum, (unsigned long volatile   *)addr);
#line 64
  __asm__  volatile   ("": : : "memory");
  }
#line 66
  return;
}
}
#line 73
__inline static void __bit_spin_unlock(int bitnum , unsigned long *addr )  __attribute__((__no_instrument_function__)) ;
#line 73 "../../../analyzer/../bench/linux-headers/include/linux/bit_spinlock.h"
__inline static void __bit_spin_unlock(int bitnum , unsigned long *addr ) 
{ 
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;

  {
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 76
    tmp___8 = variable_test_bit((long )bitnum, (unsigned long const volatile   *)addr);
    }
#line 76
    if (tmp___8) {
      {
#line 76
      tmp___9 = 0;
      }
    } else {
      {
#line 76
      tmp___9 = 1;
      }
    }
    {
#line 76
    tmp___10 = __builtin_expect((long )tmp___9, 0L);
    }
#line 76
    if (tmp___10) {
      {
#line 76
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 76
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("../../../analyzer/../bench/linux-headers/include/linux/bit_spinlock.h"),
                             "i" (76), "i" (sizeof(struct bug_entry )));
#line 76
        __builtin_unreachable();
        }
#line 76
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 76
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 79
  __clear_bit_unlock((long )bitnum, (unsigned long volatile   *)addr);
#line 81
  __asm__  volatile   ("": : : "memory");
  }
#line 83
  return;
}
}
#line 88
__inline static int bit_spin_is_locked(int bitnum , unsigned long *addr )  __attribute__((__no_instrument_function__)) ;
#line 88 "../../../analyzer/../bench/linux-headers/include/linux/bit_spinlock.h"
__inline static int bit_spin_is_locked(int bitnum , unsigned long *addr ) 
{ 
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 91
  tmp___8 = variable_test_bit((long )bitnum, (unsigned long const volatile   *)addr);
  }
#line 91
  return (tmp___8);
}
}
#line 68 "../../../analyzer/../bench/linux-headers/include/linux/shrinker.h"
extern int register_shrinker(struct shrinker * ) ;
#line 69
extern void unregister_shrinker(struct shrinker * ) ;
#line 37 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void set_max_mapnr(unsigned long limit )  __attribute__((__no_instrument_function__)) ;
#line 37 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void set_max_mapnr(unsigned long limit ) 
{ 


  {
#line 37
  return;
}
}
#line 40
extern unsigned long totalram_pages ;
#line 41
extern void *high_memory ;
#line 42
extern int page_cluster ;
#line 45
extern int sysctl_legacy_va_layout ;
#line 20 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
extern void ptdump_walk_pgd_level(struct seq_file *m , pgd_t *pgd ) ;
#line 26
extern unsigned long empty_zero_page[(1UL << 12) / sizeof(unsigned long )]  __attribute__((__externally_visible__)) ;
#line 30
extern spinlock_t pgd_lock ;
#line 31
extern struct list_head pgd_list ;
#line 33
extern struct mm_struct *pgd_page_get_mm(struct page *page ) ;
#line 92
__inline static int pte_dirty(pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 92 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pte_dirty(pte_t pte ) 
{ 
  pteval_t tmp___7 ;

  {
  {
#line 94
  tmp___7 = pte_flags(pte);
  }
#line 94
  return ((int )(tmp___7 & (1UL << 6)));
}
}
#line 97
__inline static int pte_young(pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 97 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pte_young(pte_t pte ) 
{ 
  pteval_t tmp___7 ;

  {
  {
#line 99
  tmp___7 = pte_flags(pte);
  }
#line 99
  return ((int )(tmp___7 & (1UL << 5)));
}
}
#line 102
__inline static int pmd_young(pmd_t pmd )  __attribute__((__no_instrument_function__)) ;
#line 102 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pmd_young(pmd_t pmd ) 
{ 
  pmdval_t tmp___7 ;

  {
  {
#line 104
  tmp___7 = pmd_flags(pmd);
  }
#line 104
  return ((int )(tmp___7 & (1UL << 5)));
}
}
#line 107
__inline static int pte_write(pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 107 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pte_write(pte_t pte ) 
{ 
  pteval_t tmp___7 ;

  {
  {
#line 109
  tmp___7 = pte_flags(pte);
  }
#line 109
  return ((int )(tmp___7 & (1UL << 1)));
}
}
#line 112
__inline static int pte_file(pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 112 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pte_file(pte_t pte ) 
{ 
  pteval_t tmp___7 ;

  {
  {
#line 114
  tmp___7 = pte_flags(pte);
  }
#line 114
  return ((int )(tmp___7 & (1UL << 6)));
}
}
#line 117
__inline static int pte_huge(pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 117 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pte_huge(pte_t pte ) 
{ 
  pteval_t tmp___7 ;

  {
  {
#line 119
  tmp___7 = pte_flags(pte);
  }
#line 119
  return ((int )(tmp___7 & (1UL << 7)));
}
}
#line 122
__inline static int pte_global(pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 122 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pte_global(pte_t pte ) 
{ 
  pteval_t tmp___7 ;

  {
  {
#line 124
  tmp___7 = pte_flags(pte);
  }
#line 124
  return ((int )(tmp___7 & (1UL << 8)));
}
}
#line 127
__inline static int pte_exec(pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 127 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pte_exec(pte_t pte ) 
{ 
  pteval_t tmp___7 ;
  int tmp___8 ;

  {
  {
#line 129
  tmp___7 = pte_flags(pte);
  }
#line 129
  if (tmp___7 & (1UL << 63)) {
    {
#line 129
    tmp___8 = 0;
    }
  } else {
    {
#line 129
    tmp___8 = 1;
    }
  }
#line 129
  return (tmp___8);
}
}
#line 132
__inline static int pte_special(pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 132 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pte_special(pte_t pte ) 
{ 
  pteval_t tmp___7 ;
  pteval_t tmp___8 ;
  int tmp___9 ;

  {
  {
#line 139
  tmp___7 = pte_flags(pte);
  }
#line 139
  if (tmp___7 & (1UL << 9)) {
    {
#line 139
    tmp___8 = pte_flags(pte);
    }
#line 139
    if (tmp___8 & (1UL | (1UL << 8))) {
      {
#line 139
      tmp___9 = 1;
      }
    } else {
      {
#line 139
      tmp___9 = 0;
      }
    }
  } else {
    {
#line 139
    tmp___9 = 0;
    }
  }
#line 139
  return (tmp___9);
}
}
#line 143
__inline static unsigned long pte_pfn(pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 143 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static unsigned long pte_pfn(pte_t pte ) 
{ 
  pteval_t tmp___7 ;

  {
  {
#line 145
  tmp___7 = native_pte_val(pte);
  }
#line 145
  return ((tmp___7 & (pteval_t )((unsigned long long )((long )(~ ((1UL << 12) - 1UL))) & ((1ULL << 46) - 1ULL))) >> 12);
}
}
#line 148
__inline static unsigned long pmd_pfn(pmd_t pmd )  __attribute__((__no_instrument_function__)) ;
#line 148 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static unsigned long pmd_pfn(pmd_t pmd ) 
{ 
  pmdval_t tmp___7 ;

  {
  {
#line 150
  tmp___7 = native_pmd_val(pmd);
  }
#line 150
  return ((tmp___7 & (pteval_t )((unsigned long long )((long )(~ ((1UL << 12) - 1UL))) & ((1ULL << 46) - 1ULL))) >> 12);
}
}
#line 153
__inline static unsigned long pud_pfn(pud_t pud )  __attribute__((__no_instrument_function__)) ;
#line 153 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static unsigned long pud_pfn(pud_t pud ) 
{ 
  pudval_t tmp___7 ;

  {
  {
#line 155
  tmp___7 = native_pud_val(pud);
  }
#line 155
  return ((tmp___7 & (pteval_t )((unsigned long long )((long )(~ ((1UL << 12) - 1UL))) & ((1ULL << 46) - 1ULL))) >> 12);
}
}
#line 160
__inline static int pmd_large(pmd_t pte )  __attribute__((__no_instrument_function__)) ;
#line 160 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pmd_large(pmd_t pte ) 
{ 
  pmdval_t tmp___7 ;

  {
  {
#line 162
  tmp___7 = pmd_flags(pte);
  }
#line 162
  return ((int )(tmp___7 & (1UL << 7)));
}
}
#line 182
__inline static pte_t pte_set_flags(pte_t pte , pteval_t set )  __attribute__((__no_instrument_function__)) ;
#line 182 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t pte_set_flags(pte_t pte , pteval_t set ) 
{ 
  pteval_t v ;
  pteval_t tmp___7 ;
  pte_t tmp___8 ;

  {
  {
#line 184
  tmp___7 = native_pte_val(pte);
#line 184
  v = tmp___7;
#line 186
  tmp___8 = native_make_pte(v | set);
  }
#line 186
  return (tmp___8);
}
}
#line 189
__inline static pte_t pte_clear_flags(pte_t pte , pteval_t clear )  __attribute__((__no_instrument_function__)) ;
#line 189 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t pte_clear_flags(pte_t pte , pteval_t clear ) 
{ 
  pteval_t v ;
  pteval_t tmp___7 ;
  pte_t tmp___8 ;

  {
  {
#line 191
  tmp___7 = native_pte_val(pte);
#line 191
  v = tmp___7;
#line 193
  tmp___8 = native_make_pte(v & ~ clear);
  }
#line 193
  return (tmp___8);
}
}
#line 196
__inline static pte_t pte_mkclean(pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 196 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t pte_mkclean(pte_t pte ) 
{ 
  pte_t tmp___7 ;

  {
  {
#line 198
  tmp___7 = pte_clear_flags(pte, 1UL << 6);
  }
#line 198
  return (tmp___7);
}
}
#line 201
__inline static pte_t pte_mkold(pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 201 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t pte_mkold(pte_t pte ) 
{ 
  pte_t tmp___7 ;

  {
  {
#line 203
  tmp___7 = pte_clear_flags(pte, 1UL << 5);
  }
#line 203
  return (tmp___7);
}
}
#line 206
__inline static pte_t pte_wrprotect(pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 206 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t pte_wrprotect(pte_t pte ) 
{ 
  pte_t tmp___7 ;

  {
  {
#line 208
  tmp___7 = pte_clear_flags(pte, 1UL << 1);
  }
#line 208
  return (tmp___7);
}
}
#line 211
__inline static pte_t pte_mkexec(pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 211 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t pte_mkexec(pte_t pte ) 
{ 
  pte_t tmp___7 ;

  {
  {
#line 213
  tmp___7 = pte_clear_flags(pte, 1UL << 63);
  }
#line 213
  return (tmp___7);
}
}
#line 216
__inline static pte_t pte_mkdirty(pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 216 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t pte_mkdirty(pte_t pte ) 
{ 
  pte_t tmp___7 ;

  {
  {
#line 218
  tmp___7 = pte_set_flags(pte, 1UL << 6);
  }
#line 218
  return (tmp___7);
}
}
#line 221
__inline static pte_t pte_mkyoung(pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 221 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t pte_mkyoung(pte_t pte ) 
{ 
  pte_t tmp___7 ;

  {
  {
#line 223
  tmp___7 = pte_set_flags(pte, 1UL << 5);
  }
#line 223
  return (tmp___7);
}
}
#line 226
__inline static pte_t pte_mkwrite(pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 226 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t pte_mkwrite(pte_t pte ) 
{ 
  pte_t tmp___7 ;

  {
  {
#line 228
  tmp___7 = pte_set_flags(pte, 1UL << 1);
  }
#line 228
  return (tmp___7);
}
}
#line 231
__inline static pte_t pte_mkhuge(pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 231 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t pte_mkhuge(pte_t pte ) 
{ 
  pte_t tmp___7 ;

  {
  {
#line 233
  tmp___7 = pte_set_flags(pte, 1UL << 7);
  }
#line 233
  return (tmp___7);
}
}
#line 236
__inline static pte_t pte_clrhuge(pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 236 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t pte_clrhuge(pte_t pte ) 
{ 
  pte_t tmp___7 ;

  {
  {
#line 238
  tmp___7 = pte_clear_flags(pte, 1UL << 7);
  }
#line 238
  return (tmp___7);
}
}
#line 241
__inline static pte_t pte_mkglobal(pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 241 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t pte_mkglobal(pte_t pte ) 
{ 
  pte_t tmp___7 ;

  {
  {
#line 243
  tmp___7 = pte_set_flags(pte, 1UL << 8);
  }
#line 243
  return (tmp___7);
}
}
#line 246
__inline static pte_t pte_clrglobal(pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 246 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t pte_clrglobal(pte_t pte ) 
{ 
  pte_t tmp___7 ;

  {
  {
#line 248
  tmp___7 = pte_clear_flags(pte, 1UL << 8);
  }
#line 248
  return (tmp___7);
}
}
#line 251
__inline static pte_t pte_mkspecial(pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 251 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t pte_mkspecial(pte_t pte ) 
{ 
  pte_t tmp___7 ;

  {
  {
#line 253
  tmp___7 = pte_set_flags(pte, 1UL << 9);
  }
#line 253
  return (tmp___7);
}
}
#line 256
__inline static pmd_t pmd_set_flags(pmd_t pmd , pmdval_t set )  __attribute__((__no_instrument_function__)) ;
#line 256 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pmd_t pmd_set_flags(pmd_t pmd , pmdval_t set ) 
{ 
  pmdval_t v ;
  pmdval_t tmp___7 ;
  pmd_t tmp___8 ;

  {
  {
#line 258
  tmp___7 = native_pmd_val(pmd);
#line 258
  v = tmp___7;
#line 260
  tmp___8 = native_make_pmd(v | set);
  }
#line 260
  return (tmp___8);
}
}
#line 263
__inline static pmd_t pmd_clear_flags(pmd_t pmd , pmdval_t clear )  __attribute__((__no_instrument_function__)) ;
#line 263 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pmd_t pmd_clear_flags(pmd_t pmd , pmdval_t clear ) 
{ 
  pmdval_t v ;
  pmdval_t tmp___7 ;
  pmd_t tmp___8 ;

  {
  {
#line 265
  tmp___7 = native_pmd_val(pmd);
#line 265
  v = tmp___7;
#line 267
  tmp___8 = native_make_pmd(v & ~ clear);
  }
#line 267
  return (tmp___8);
}
}
#line 270
__inline static pmd_t pmd_mkold(pmd_t pmd )  __attribute__((__no_instrument_function__)) ;
#line 270 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pmd_t pmd_mkold(pmd_t pmd ) 
{ 
  pmd_t tmp___7 ;

  {
  {
#line 272
  tmp___7 = pmd_clear_flags(pmd, 1UL << 5);
  }
#line 272
  return (tmp___7);
}
}
#line 275
__inline static pmd_t pmd_wrprotect(pmd_t pmd )  __attribute__((__no_instrument_function__)) ;
#line 275 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pmd_t pmd_wrprotect(pmd_t pmd ) 
{ 
  pmd_t tmp___7 ;

  {
  {
#line 277
  tmp___7 = pmd_clear_flags(pmd, 1UL << 1);
  }
#line 277
  return (tmp___7);
}
}
#line 280
__inline static pmd_t pmd_mkdirty(pmd_t pmd )  __attribute__((__no_instrument_function__)) ;
#line 280 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pmd_t pmd_mkdirty(pmd_t pmd ) 
{ 
  pmd_t tmp___7 ;

  {
  {
#line 282
  tmp___7 = pmd_set_flags(pmd, 1UL << 6);
  }
#line 282
  return (tmp___7);
}
}
#line 285
__inline static pmd_t pmd_mkhuge(pmd_t pmd )  __attribute__((__no_instrument_function__)) ;
#line 285 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pmd_t pmd_mkhuge(pmd_t pmd ) 
{ 
  pmd_t tmp___7 ;

  {
  {
#line 287
  tmp___7 = pmd_set_flags(pmd, 1UL << 7);
  }
#line 287
  return (tmp___7);
}
}
#line 290
__inline static pmd_t pmd_mkyoung(pmd_t pmd )  __attribute__((__no_instrument_function__)) ;
#line 290 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pmd_t pmd_mkyoung(pmd_t pmd ) 
{ 
  pmd_t tmp___7 ;

  {
  {
#line 292
  tmp___7 = pmd_set_flags(pmd, 1UL << 5);
  }
#line 292
  return (tmp___7);
}
}
#line 295
__inline static pmd_t pmd_mkwrite(pmd_t pmd )  __attribute__((__no_instrument_function__)) ;
#line 295 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pmd_t pmd_mkwrite(pmd_t pmd ) 
{ 
  pmd_t tmp___7 ;

  {
  {
#line 297
  tmp___7 = pmd_set_flags(pmd, 1UL << 1);
  }
#line 297
  return (tmp___7);
}
}
#line 300
__inline static pmd_t pmd_mknotpresent(pmd_t pmd )  __attribute__((__no_instrument_function__)) ;
#line 300 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pmd_t pmd_mknotpresent(pmd_t pmd ) 
{ 
  pmd_t tmp___7 ;

  {
  {
#line 302
  tmp___7 = pmd_clear_flags(pmd, 1UL);
  }
#line 302
  return (tmp___7);
}
}
#line 306
__inline static int pte_soft_dirty(pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 306 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pte_soft_dirty(pte_t pte ) 
{ 
  pteval_t tmp___7 ;

  {
  {
#line 308
  tmp___7 = pte_flags(pte);
  }
#line 308
  return (0);
}
}
#line 311
__inline static int pmd_soft_dirty(pmd_t pmd )  __attribute__((__no_instrument_function__)) ;
#line 311 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pmd_soft_dirty(pmd_t pmd ) 
{ 
  pmdval_t tmp___7 ;

  {
  {
#line 313
  tmp___7 = pmd_flags(pmd);
  }
#line 313
  return (0);
}
}
#line 316
__inline static pte_t pte_mksoft_dirty(pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 316 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t pte_mksoft_dirty(pte_t pte ) 
{ 
  pte_t tmp___7 ;

  {
  {
#line 318
  tmp___7 = pte_set_flags(pte, (pteval_t )0);
  }
#line 318
  return (tmp___7);
}
}
#line 321
__inline static pmd_t pmd_mksoft_dirty(pmd_t pmd )  __attribute__((__no_instrument_function__)) ;
#line 321 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pmd_t pmd_mksoft_dirty(pmd_t pmd ) 
{ 
  pmd_t tmp___7 ;

  {
  {
#line 323
  tmp___7 = pmd_set_flags(pmd, (pteval_t )0);
  }
#line 323
  return (tmp___7);
}
}
#line 326
__inline static pte_t pte_file_clear_soft_dirty(pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 326 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t pte_file_clear_soft_dirty(pte_t pte ) 
{ 
  pte_t tmp___7 ;

  {
  {
#line 328
  tmp___7 = pte_clear_flags(pte, (pteval_t )0);
  }
#line 328
  return (tmp___7);
}
}
#line 331
__inline static pte_t pte_file_mksoft_dirty(pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 331 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t pte_file_mksoft_dirty(pte_t pte ) 
{ 
  pte_t tmp___7 ;

  {
  {
#line 333
  tmp___7 = pte_set_flags(pte, (pteval_t )0);
  }
#line 333
  return (tmp___7);
}
}
#line 336
__inline static int pte_file_soft_dirty(pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 336 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pte_file_soft_dirty(pte_t pte ) 
{ 
  pteval_t tmp___7 ;

  {
  {
#line 338
  tmp___7 = pte_flags(pte);
  }
#line 338
  return (0);
}
}
#line 347
__inline static pgprotval_t massage_pgprot(pgprot_t pgprot )  __attribute__((__no_instrument_function__)) ;
#line 347 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pgprotval_t massage_pgprot(pgprot_t pgprot ) 
{ 
  pgprotval_t protval ;

  {
  {
#line 349
  protval = pgprot.pgprot;
  }
#line 351
  if (protval & 1UL) {
    {
#line 352
    protval &= __supported_pte_mask;
    }
  }
#line 354
  return (protval);
}
}
#line 357
__inline static pte_t pfn_pte(unsigned long page_nr , pgprot_t pgprot )  __attribute__((__no_instrument_function__)) ;
#line 357 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t pfn_pte(unsigned long page_nr , pgprot_t pgprot ) 
{ 
  pgprotval_t tmp___7 ;
  pte_t tmp___8 ;

  {
  {
#line 359
  tmp___7 = massage_pgprot(pgprot);
#line 359
  tmp___8 = native_make_pte((pteval_t )(((phys_addr_t )page_nr << 12) | (unsigned long long )tmp___7));
  }
#line 359
  return (tmp___8);
}
}
#line 363
__inline static pmd_t pfn_pmd(unsigned long page_nr , pgprot_t pgprot )  __attribute__((__no_instrument_function__)) ;
#line 363 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pmd_t pfn_pmd(unsigned long page_nr , pgprot_t pgprot ) 
{ 
  pgprotval_t tmp___7 ;
  pmd_t tmp___8 ;

  {
  {
#line 365
  tmp___7 = massage_pgprot(pgprot);
#line 365
  tmp___8 = native_make_pmd((pmdval_t )(((phys_addr_t )page_nr << 12) | (unsigned long long )tmp___7));
  }
#line 365
  return (tmp___8);
}
}
#line 369
__inline static pte_t pte_modify(pte_t pte , pgprot_t newprot )  __attribute__((__no_instrument_function__)) ;
#line 369 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t pte_modify(pte_t pte , pgprot_t newprot ) 
{ 
  pteval_t val ;
  pteval_t tmp___7 ;
  pgprotval_t tmp___8 ;
  pte_t tmp___9 ;

  {
  {
#line 371
  tmp___7 = native_pte_val(pte);
#line 371
  val = tmp___7;
#line 377
  val &= (((((pteval_t )((unsigned long long )((long )(~ ((1UL << 12) - 1UL))) & ((1ULL << 46) - 1ULL)) | (1UL << 4)) | (1UL << 3)) | (1UL << 9)) | (1UL << 5)) | (1UL << 6);
#line 378
  tmp___8 = massage_pgprot(newprot);
#line 378
  val |= tmp___8 & ~ ((((((pteval_t )((unsigned long long )((long )(~ ((1UL << 12) - 1UL))) & ((1ULL << 46) - 1ULL)) | (1UL << 4)) | (1UL << 3)) | (1UL << 9)) | (1UL << 5)) | (1UL << 6));
#line 380
  tmp___9 = native_make_pte(val);
  }
#line 380
  return (tmp___9);
}
}
#line 383
__inline static pmd_t pmd_modify(pmd_t pmd , pgprot_t newprot )  __attribute__((__no_instrument_function__)) ;
#line 383 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pmd_t pmd_modify(pmd_t pmd , pgprot_t newprot ) 
{ 
  pmdval_t val ;
  pmdval_t tmp___7 ;
  pgprotval_t tmp___8 ;
  pmd_t tmp___9 ;

  {
  {
#line 385
  tmp___7 = native_pmd_val(pmd);
#line 385
  val = tmp___7;
#line 387
  val &= ((((((pteval_t )((unsigned long long )((long )(~ ((1UL << 12) - 1UL))) & ((1ULL << 46) - 1ULL)) | (1UL << 4)) | (1UL << 3)) | (1UL << 9)) | (1UL << 5)) | (1UL << 6)) | (1UL << 7);
#line 388
  tmp___8 = massage_pgprot(newprot);
#line 388
  val |= tmp___8 & ~ (((((((pteval_t )((unsigned long long )((long )(~ ((1UL << 12) - 1UL))) & ((1ULL << 46) - 1ULL)) | (1UL << 4)) | (1UL << 3)) | (1UL << 9)) | (1UL << 5)) | (1UL << 6)) | (1UL << 7));
#line 390
  tmp___9 = native_make_pmd(val);
  }
#line 390
  return (tmp___9);
}
}
#line 395
__inline static pgprot_t pgprot_modify(pgprot_t oldprot , pgprot_t newprot )  __attribute__((__no_instrument_function__)) ;
#line 395 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pgprot_t pgprot_modify(pgprot_t oldprot , pgprot_t newprot ) 
{ 
  pgprotval_t preservebits ;
  pgprotval_t addbits ;
  pgprot_t __constr_expr_20 ;

  {
  {
#line 397
  preservebits = oldprot.pgprot & ((((((pteval_t )((unsigned long long )((long )(~ ((1UL << 12) - 1UL))) & ((1ULL << 46) - 1ULL)) | (1UL << 4)) | (1UL << 3)) | (1UL << 9)) | (1UL << 5)) | (1UL << 6));
#line 398
  addbits = newprot.pgprot;
#line 399
  __constr_expr_20.pgprot = preservebits | addbits;
  }
#line 399
  return (__constr_expr_20);
}
}
#line 406
__inline static int is_new_memtype_allowed(u64 paddr , unsigned long size , unsigned long flags ,
                                           unsigned long new_flags )  __attribute__((__no_instrument_function__)) ;
#line 406 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int is_new_memtype_allowed(u64 paddr , unsigned long size , unsigned long flags ,
                                           unsigned long new_flags ) 
{ 
  bool tmp___7 ;

  {
  {
#line 413
  tmp___7 = (*(x86_platform.is_untracked_pat_range))(paddr, paddr + (u64 )size);
  }
#line 413
  if (tmp___7) {
#line 414
    return (1);
  }
#line 422
  if (flags == 1UL << 4) {
#line 422
    if (new_flags == 0UL) {
#line 426
      return (0);
    } else {
#line 422
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 422
  if (flags == 1UL << 3) {
#line 422
    if (new_flags == 0UL) {
#line 426
      return (0);
    }
  }
#line 429
  return (1);
}
}
#line 432
extern pmd_t *populate_extra_pmd(unsigned long vaddr ) ;
#line 433
extern pte_t *populate_extra_pte(unsigned long vaddr ) ;
#line 17 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_64.h"
extern pud_t level3_kernel_pgt[512] ;
#line 18
extern pud_t level3_ident_pgt[512] ;
#line 19
extern pmd_t level2_kernel_pgt[512] ;
#line 20
extern pmd_t level2_fixmap_pgt[512] ;
#line 21
extern pmd_t level2_ident_pgt[512] ;
#line 22
extern pte_t level1_fixmap_pgt[512] ;
#line 23
extern pgd_t init_level4_pgt[] ;
#line 27
extern void paging_init(void) ;
#line 44
extern void set_pte_vaddr_pud(pud_t *pud_page , unsigned long vaddr , pte_t new_pte ) ;
#line 47
__inline static void native_pte_clear(struct mm_struct *mm , unsigned long addr ,
                                      pte_t *ptep )  __attribute__((__no_instrument_function__)) ;
#line 47 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_64.h"
__inline static void native_pte_clear(struct mm_struct *mm , unsigned long addr ,
                                      pte_t *ptep ) 
{ 


  {
  {
#line 50
  *ptep = native_make_pte((pteval_t )0);
  }
#line 51
  return;
}
}
#line 53
__inline static void native_set_pte(pte_t *ptep , pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 53 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_64.h"
__inline static void native_set_pte(pte_t *ptep , pte_t pte ) 
{ 


  {
  {
#line 55
  *ptep = pte;
  }
#line 56
  return;
}
}
#line 58
__inline static void native_set_pte_atomic(pte_t *ptep , pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 58 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_64.h"
__inline static void native_set_pte_atomic(pte_t *ptep , pte_t pte ) 
{ 


  {
  {
#line 60
  native_set_pte(ptep, pte);
  }
#line 61
  return;
}
}
#line 63
__inline static void native_set_pmd(pmd_t *pmdp , pmd_t pmd )  __attribute__((__no_instrument_function__)) ;
#line 63 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_64.h"
__inline static void native_set_pmd(pmd_t *pmdp , pmd_t pmd ) 
{ 


  {
  {
#line 65
  *pmdp = pmd;
  }
#line 66
  return;
}
}
#line 68
__inline static void native_pmd_clear(pmd_t *pmd )  __attribute__((__no_instrument_function__)) ;
#line 68 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_64.h"
__inline static void native_pmd_clear(pmd_t *pmd ) 
{ 
  pmd_t tmp___7 ;

  {
  {
#line 70
  tmp___7 = native_make_pmd((pmdval_t )0);
#line 70
  native_set_pmd(pmd, tmp___7);
  }
#line 71
  return;
}
}
#line 73
__inline static pte_t native_ptep_get_and_clear(pte_t *xp )  __attribute__((__no_instrument_function__)) ;
#line 73 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_64.h"
__inline static pte_t native_ptep_get_and_clear(pte_t *xp ) 
{ 
  pteval_t __ret ;
  pte_t tmp___7 ;

  {
  {
#line 76
  __ret = (pteval_t )0;
  }
  {
#line 76
  if (sizeof(xp->pte) == 1UL) {
#line 76
    goto case_1;
  }
#line 76
  if (sizeof(xp->pte) == 2UL) {
#line 76
    goto case_2;
  }
#line 76
  if (sizeof(xp->pte) == 4UL) {
#line 76
    goto case_4;
  }
#line 76
  if (sizeof(xp->pte) == 8UL) {
#line 76
    goto case_8;
  }
#line 76
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 76
  __asm__  volatile   (""
                       "xchg"
                       "b %b0, %1\n": "+q" (__ret), "+m" (xp->pte): : "memory", "cc");
  }
#line 76
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 76
  __asm__  volatile   (""
                       "xchg"
                       "w %w0, %1\n": "+r" (__ret), "+m" (xp->pte): : "memory", "cc");
  }
#line 76
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 76
  __asm__  volatile   (""
                       "xchg"
                       "l %0, %1\n": "+r" (__ret), "+m" (xp->pte): : "memory", "cc");
  }
#line 76
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 76
  __asm__  volatile   (""
                       "xchg"
                       "q %q0, %1\n": "+r" (__ret), "+m" (xp->pte): : "memory", "cc");
  }
#line 76
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 76
  __xchg_wrong_size();
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 76
  tmp___7 = native_make_pte(__ret);
  }
#line 76
  return (tmp___7);
}
}
#line 86
__inline static pmd_t native_pmdp_get_and_clear(pmd_t *xp )  __attribute__((__no_instrument_function__)) ;
#line 86 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_64.h"
__inline static pmd_t native_pmdp_get_and_clear(pmd_t *xp ) 
{ 
  pmdval_t __ret ;
  pmd_t tmp___7 ;

  {
  {
#line 89
  __ret = (pmdval_t )0;
  }
  {
#line 89
  if (sizeof(xp->pmd) == 1UL) {
#line 89
    goto case_1;
  }
#line 89
  if (sizeof(xp->pmd) == 2UL) {
#line 89
    goto case_2;
  }
#line 89
  if (sizeof(xp->pmd) == 4UL) {
#line 89
    goto case_4;
  }
#line 89
  if (sizeof(xp->pmd) == 8UL) {
#line 89
    goto case_8;
  }
#line 89
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 89
  __asm__  volatile   (""
                       "xchg"
                       "b %b0, %1\n": "+q" (__ret), "+m" (xp->pmd): : "memory", "cc");
  }
#line 89
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 89
  __asm__  volatile   (""
                       "xchg"
                       "w %w0, %1\n": "+r" (__ret), "+m" (xp->pmd): : "memory", "cc");
  }
#line 89
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 89
  __asm__  volatile   (""
                       "xchg"
                       "l %0, %1\n": "+r" (__ret), "+m" (xp->pmd): : "memory", "cc");
  }
#line 89
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 89
  __asm__  volatile   (""
                       "xchg"
                       "q %q0, %1\n": "+r" (__ret), "+m" (xp->pmd): : "memory", "cc");
  }
#line 89
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 89
  __xchg_wrong_size();
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 89
  tmp___7 = native_make_pmd(__ret);
  }
#line 89
  return (tmp___7);
}
}
#line 99
__inline static void native_set_pud(pud_t *pudp , pud_t pud )  __attribute__((__no_instrument_function__)) ;
#line 99 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_64.h"
__inline static void native_set_pud(pud_t *pudp , pud_t pud ) 
{ 


  {
  {
#line 101
  *pudp = pud;
  }
#line 102
  return;
}
}
#line 104
__inline static void native_pud_clear(pud_t *pud )  __attribute__((__no_instrument_function__)) ;
#line 104 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_64.h"
__inline static void native_pud_clear(pud_t *pud ) 
{ 
  pud_t tmp___7 ;

  {
  {
#line 106
  tmp___7 = native_make_pud((pmdval_t )0);
#line 106
  native_set_pud(pud, tmp___7);
  }
#line 107
  return;
}
}
#line 109
__inline static void native_set_pgd(pgd_t *pgdp , pgd_t pgd )  __attribute__((__no_instrument_function__)) ;
#line 109 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_64.h"
__inline static void native_set_pgd(pgd_t *pgdp , pgd_t pgd ) 
{ 


  {
  {
#line 111
  *pgdp = pgd;
  }
#line 112
  return;
}
}
#line 114
__inline static void native_pgd_clear(pgd_t *pgd )  __attribute__((__no_instrument_function__)) ;
#line 114 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_64.h"
__inline static void native_pgd_clear(pgd_t *pgd ) 
{ 
  pgd_t tmp___7 ;

  {
  {
#line 116
  tmp___7 = native_make_pgd((pgdval_t )0);
#line 116
  native_set_pgd(pgd, tmp___7);
  }
#line 117
  return;
}
}
#line 119
extern void sync_global_pgds(unsigned long start , unsigned long end ) ;
#line 129
__inline static int pgd_large(pgd_t pgd )  __attribute__((__no_instrument_function__)) ;
#line 129 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable_64.h"
__inline static int pgd_large(pgd_t pgd ) 
{ 


  {
#line 129
  return (0);
}
}
#line 166
extern int kern_addr_valid(unsigned long addr ) ;
#line 167
extern void cleanup_highmap(void) ;
#line 186
extern void init_extra_mapping_uc(unsigned long phys , unsigned long size ) ;
#line 187
extern void init_extra_mapping_wb(unsigned long phys , unsigned long size ) ;
#line 447 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pte_none(pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 447 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pte_none(pte_t pte ) 
{ 


  {
#line 449
  return (! pte.pte);
}
}
#line 453
__inline static int pte_same(pte_t a , pte_t b )  __attribute__((__no_instrument_function__)) ;
#line 453 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pte_same(pte_t a , pte_t b ) 
{ 


  {
#line 455
  return (a.pte == b.pte);
}
}
#line 458
__inline static int pte_present(pte_t a )  __attribute__((__no_instrument_function__)) ;
#line 458 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pte_present(pte_t a ) 
{ 
  pteval_t tmp___7 ;

  {
  {
#line 460
  tmp___7 = pte_flags(a);
  }
#line 460
  return ((int )(tmp___7 & (1UL | (1UL << 8))));
}
}
#line 465
__inline static int pte_present_nonuma(pte_t a )  __attribute__((__no_instrument_function__)) ;
#line 465 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pte_present_nonuma(pte_t a ) 
{ 
  pteval_t tmp___7 ;

  {
  {
#line 467
  tmp___7 = pte_flags(a);
  }
#line 467
  return ((int )(tmp___7 & (1UL | (1UL << 8))));
}
}
#line 471
__inline static bool pte_accessible(struct mm_struct *mm , pte_t a )  __attribute__((__no_instrument_function__)) ;
#line 471 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static bool pte_accessible(struct mm_struct *mm , pte_t a ) 
{ 
  pteval_t tmp___7 ;
  pteval_t tmp___8 ;
  bool tmp___9 ;

  {
  {
#line 473
  tmp___7 = pte_flags(a);
  }
#line 473
  if (tmp___7 & 1UL) {
#line 474
    return ((bool )1);
  }
  {
#line 476
  tmp___8 = pte_flags(a);
  }
#line 476
  if (tmp___8 & (1UL << 8)) {
    {
#line 476
    tmp___9 = mm_tlb_flush_pending(mm);
    }
#line 476
    if (tmp___9) {
#line 478
      return ((bool )1);
    }
  }
#line 480
  return ((bool )0);
}
}
#line 483
__inline static int pte_hidden(pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 483 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pte_hidden(pte_t pte ) 
{ 
  pteval_t tmp___7 ;

  {
  {
#line 485
  tmp___7 = pte_flags(pte);
  }
#line 485
  return (0);
}
}
#line 488
__inline static int pmd_present(pmd_t pmd )  __attribute__((__no_instrument_function__)) ;
#line 488 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pmd_present(pmd_t pmd ) 
{ 
  pmdval_t tmp___7 ;

  {
  {
#line 496
  tmp___7 = pmd_flags(pmd);
  }
#line 496
  return ((int )(tmp___7 & ((1UL | (1UL << 8)) | (1UL << 7))));
}
}
#line 500
__inline static int pmd_none(pmd_t pmd )  __attribute__((__no_instrument_function__)) ;
#line 500 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pmd_none(pmd_t pmd ) 
{ 
  pmdval_t tmp___7 ;

  {
  {
#line 504
  tmp___7 = native_pmd_val(pmd);
  }
#line 504
  return (tmp___7 == 0UL);
}
}
#line 507
__inline static unsigned long pmd_page_vaddr(pmd_t pmd )  __attribute__((__no_instrument_function__)) ;
#line 507 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static unsigned long pmd_page_vaddr(pmd_t pmd ) 
{ 
  pmdval_t tmp___7 ;

  {
  {
#line 509
  tmp___7 = native_pmd_val(pmd);
  }
#line 509
  return ((unsigned long )((void *)((tmp___7 & (pteval_t )((unsigned long long )((long )(~ ((1UL << 12) - 1UL))) & ((1ULL << 46) - 1ULL))) + 0xffff880000000000UL)));
}
}
#line 524
__inline static unsigned long pmd_index(unsigned long address )  __attribute__((__no_instrument_function__)) ;
#line 524 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static unsigned long pmd_index(unsigned long address ) 
{ 


  {
#line 526
  return ((address >> 21) & 511UL);
}
}
#line 544
__inline static unsigned long pte_index(unsigned long address )  __attribute__((__no_instrument_function__)) ;
#line 544 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static unsigned long pte_index(unsigned long address ) 
{ 


  {
#line 546
  return ((address >> 12) & 511UL);
}
}
#line 549
__inline static pte_t *pte_offset_kernel(pmd_t *pmd , unsigned long address )  __attribute__((__no_instrument_function__)) ;
#line 549 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t *pte_offset_kernel(pmd_t *pmd , unsigned long address ) 
{ 
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;

  {
  {
#line 551
  tmp___7 = pmd_page_vaddr(*pmd);
#line 551
  tmp___8 = pte_index(address);
  }
#line 551
  return ((pte_t *)tmp___7 + tmp___8);
}
}
#line 554
__inline static int pmd_bad(pmd_t pmd )  __attribute__((__no_instrument_function__)) ;
#line 554 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pmd_bad(pmd_t pmd ) 
{ 
  pmdval_t tmp___7 ;

  {
  {
#line 561
  tmp___7 = pmd_flags(pmd);
  }
#line 561
  return ((tmp___7 & ~ (1UL << 2)) != (((1UL | (1UL << 1)) | (1UL << 5)) | (1UL << 6)));
}
}
#line 564
__inline static unsigned long pages_to_mb(unsigned long npg )  __attribute__((__no_instrument_function__)) ;
#line 564 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static unsigned long pages_to_mb(unsigned long npg ) 
{ 


  {
#line 566
  return (npg >> 8);
}
}
#line 570
__inline static int pud_none(pud_t pud )  __attribute__((__no_instrument_function__)) ;
#line 570 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pud_none(pud_t pud ) 
{ 
  pudval_t tmp___7 ;

  {
  {
#line 572
  tmp___7 = native_pud_val(pud);
  }
#line 572
  return (tmp___7 == 0UL);
}
}
#line 575
__inline static int pud_present(pud_t pud )  __attribute__((__no_instrument_function__)) ;
#line 575 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pud_present(pud_t pud ) 
{ 
  pudval_t tmp___7 ;

  {
  {
#line 577
  tmp___7 = pud_flags(pud);
  }
#line 577
  return ((int )(tmp___7 & 1UL));
}
}
#line 580
__inline static unsigned long pud_page_vaddr(pud_t pud )  __attribute__((__no_instrument_function__)) ;
#line 580 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static unsigned long pud_page_vaddr(pud_t pud ) 
{ 
  pudval_t tmp___7 ;

  {
  {
#line 582
  tmp___7 = native_pud_val(pud);
  }
#line 582
  return ((unsigned long )((void *)((tmp___7 & (pteval_t )((unsigned long long )((long )(~ ((1UL << 12) - 1UL))) & ((1ULL << 46) - 1ULL))) + 0xffff880000000000UL)));
}
}
#line 592
__inline static pmd_t *pmd_offset(pud_t *pud , unsigned long address )  __attribute__((__no_instrument_function__)) ;
#line 592 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pmd_t *pmd_offset(pud_t *pud , unsigned long address ) 
{ 
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;

  {
  {
#line 594
  tmp___7 = pud_page_vaddr(*pud);
#line 594
  tmp___8 = pmd_index(address);
  }
#line 594
  return ((pmd_t *)tmp___7 + tmp___8);
}
}
#line 597
__inline static int pud_large(pud_t pud )  __attribute__((__no_instrument_function__)) ;
#line 597 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pud_large(pud_t pud ) 
{ 
  pudval_t tmp___7 ;

  {
  {
#line 599
  tmp___7 = native_pud_val(pud);
  }
#line 599
  return ((tmp___7 & ((1UL << 7) | 1UL)) == ((1UL << 7) | 1UL));
}
}
#line 603
__inline static int pud_bad(pud_t pud )  __attribute__((__no_instrument_function__)) ;
#line 603 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pud_bad(pud_t pud ) 
{ 
  pudval_t tmp___7 ;

  {
  {
#line 605
  tmp___7 = pud_flags(pud);
  }
#line 605
  return ((tmp___7 & ~ ((((1UL | (1UL << 1)) | (1UL << 5)) | (1UL << 6)) | (1UL << 2))) != 0UL);
}
}
#line 615
__inline static int pgd_present(pgd_t pgd )  __attribute__((__no_instrument_function__)) ;
#line 615 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pgd_present(pgd_t pgd ) 
{ 
  pgdval_t tmp___7 ;

  {
  {
#line 617
  tmp___7 = pgd_flags(pgd);
  }
#line 617
  return ((int )(tmp___7 & 1UL));
}
}
#line 620
__inline static unsigned long pgd_page_vaddr(pgd_t pgd )  __attribute__((__no_instrument_function__)) ;
#line 620 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static unsigned long pgd_page_vaddr(pgd_t pgd ) 
{ 
  pgdval_t tmp___7 ;

  {
  {
#line 622
  tmp___7 = native_pgd_val(pgd);
  }
#line 622
  return ((unsigned long )((void *)((tmp___7 & (pteval_t )((unsigned long long )((long )(~ ((1UL << 12) - 1UL))) & ((1ULL << 46) - 1ULL))) + 0xffff880000000000UL)));
}
}
#line 632
__inline static unsigned long pud_index(unsigned long address )  __attribute__((__no_instrument_function__)) ;
#line 632 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static unsigned long pud_index(unsigned long address ) 
{ 


  {
#line 634
  return ((address >> 30) & 511UL);
}
}
#line 637
__inline static pud_t *pud_offset(pgd_t *pgd , unsigned long address )  __attribute__((__no_instrument_function__)) ;
#line 637 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pud_t *pud_offset(pgd_t *pgd , unsigned long address ) 
{ 
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;

  {
  {
#line 639
  tmp___7 = pgd_page_vaddr(*pgd);
#line 639
  tmp___8 = pud_index(address);
  }
#line 639
  return ((pud_t *)tmp___7 + tmp___8);
}
}
#line 642
__inline static int pgd_bad(pgd_t pgd )  __attribute__((__no_instrument_function__)) ;
#line 642 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pgd_bad(pgd_t pgd ) 
{ 
  pgdval_t tmp___7 ;

  {
  {
#line 644
  tmp___7 = pgd_flags(pgd);
  }
#line 644
  return ((tmp___7 & ~ (1UL << 2)) != (((1UL | (1UL << 1)) | (1UL << 5)) | (1UL << 6)));
}
}
#line 647
__inline static int pgd_none(pgd_t pgd )  __attribute__((__no_instrument_function__)) ;
#line 647 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pgd_none(pgd_t pgd ) 
{ 
  pgdval_t tmp___7 ;
  int tmp___8 ;

  {
  {
#line 649
  tmp___7 = native_pgd_val(pgd);
  }
#line 649
  if (tmp___7) {
    {
#line 649
    tmp___8 = 0;
    }
  } else {
    {
#line 649
    tmp___8 = 1;
    }
  }
#line 649
  return (tmp___8);
}
}
#line 680
extern int direct_gbpages ;
#line 681
extern void init_mem_mapping(void) ;
#line 682
extern void early_alloc_pgt_buf(void) ;
#line 685
__inline static pte_t native_local_ptep_get_and_clear(pte_t *ptep )  __attribute__((__no_instrument_function__)) ;
#line 685 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t native_local_ptep_get_and_clear(pte_t *ptep ) 
{ 
  pte_t res ;

  {
  {
#line 687
  res = *ptep;
#line 690
  native_pte_clear((struct mm_struct *)((void *)0), 0UL, ptep);
  }
#line 691
  return (res);
}
}
#line 694
__inline static pmd_t native_local_pmdp_get_and_clear(pmd_t *pmdp )  __attribute__((__no_instrument_function__)) ;
#line 694 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pmd_t native_local_pmdp_get_and_clear(pmd_t *pmdp ) 
{ 
  pmd_t res ;

  {
  {
#line 696
  res = *pmdp;
#line 698
  native_pmd_clear(pmdp);
  }
#line 699
  return (res);
}
}
#line 702
__inline static void native_set_pte_at(struct mm_struct *mm , unsigned long addr ,
                                       pte_t *ptep , pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 702 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static void native_set_pte_at(struct mm_struct *mm , unsigned long addr ,
                                       pte_t *ptep , pte_t pte ) 
{ 


  {
  {
#line 705
  native_set_pte(ptep, pte);
  }
#line 706
  return;
}
}
#line 708
__inline static void native_set_pmd_at(struct mm_struct *mm , unsigned long addr ,
                                       pmd_t *pmdp , pmd_t pmd )  __attribute__((__no_instrument_function__)) ;
#line 708 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static void native_set_pmd_at(struct mm_struct *mm , unsigned long addr ,
                                       pmd_t *pmdp , pmd_t pmd ) 
{ 


  {
  {
#line 711
  native_set_pmd(pmdp, pmd);
  }
#line 712
  return;
}
}
#line 742
extern int ptep_set_access_flags(struct vm_area_struct *vma , unsigned long address ,
                                 pte_t *ptep , pte_t entry , int dirty ) ;
#line 747
extern int ptep_test_and_clear_young(struct vm_area_struct *vma , unsigned long addr ,
                                     pte_t *ptep ) ;
#line 751
extern int ptep_clear_flush_young(struct vm_area_struct *vma , unsigned long address ,
                                  pte_t *ptep ) ;
#line 755
__inline static pte_t ptep_get_and_clear(struct mm_struct *mm , unsigned long addr ,
                                         pte_t *ptep )  __attribute__((__no_instrument_function__)) ;
#line 755 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t ptep_get_and_clear(struct mm_struct *mm , unsigned long addr ,
                                         pte_t *ptep ) 
{ 
  pte_t pte ;
  pte_t tmp___7 ;

  {
  {
#line 758
  tmp___7 = native_ptep_get_and_clear(ptep);
#line 758
  pte = tmp___7;
  }
  {
#line 759
  while (1) {
    while_continue: /* CIL Label */ ;
#line 759
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 760
  return (pte);
}
}
#line 764
__inline static pte_t ptep_get_and_clear_full(struct mm_struct *mm , unsigned long addr ,
                                              pte_t *ptep , int full )  __attribute__((__no_instrument_function__)) ;
#line 764 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t ptep_get_and_clear_full(struct mm_struct *mm , unsigned long addr ,
                                              pte_t *ptep , int full ) 
{ 
  pte_t pte ;

  {
#line 769
  if (full) {
    {
#line 774
    pte = native_local_ptep_get_and_clear(ptep);
    }
  } else {
    {
#line 776
    pte = ptep_get_and_clear(mm, addr, ptep);
    }
  }
#line 778
  return (pte);
}
}
#line 782
__inline static void ptep_set_wrprotect(struct mm_struct *mm , unsigned long addr ,
                                        pte_t *ptep )  __attribute__((__no_instrument_function__)) ;
#line 782 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static void ptep_set_wrprotect(struct mm_struct *mm , unsigned long addr ,
                                        pte_t *ptep ) 
{ 


  {
  {
#line 785
  clear_bit(1L, (unsigned long volatile   *)(& ptep->pte));
  }
  {
#line 786
  while (1) {
    while_continue: /* CIL Label */ ;
#line 786
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 787
  return;
}
}
#line 794
extern int pmdp_set_access_flags(struct vm_area_struct *vma , unsigned long address ,
                                 pmd_t *pmdp , pmd_t entry , int dirty ) ;
#line 799
extern int pmdp_test_and_clear_young(struct vm_area_struct *vma , unsigned long addr ,
                                     pmd_t *pmdp ) ;
#line 803
extern int pmdp_clear_flush_young(struct vm_area_struct *vma , unsigned long address ,
                                  pmd_t *pmdp ) ;
#line 808
extern void pmdp_splitting_flush(struct vm_area_struct *vma , unsigned long addr ,
                                 pmd_t *pmdp ) ;
#line 812
__inline static int pmd_write(pmd_t pmd )  __attribute__((__no_instrument_function__)) ;
#line 812 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pmd_write(pmd_t pmd ) 
{ 
  pmdval_t tmp___7 ;

  {
  {
#line 814
  tmp___7 = pmd_flags(pmd);
  }
#line 814
  return ((int )(tmp___7 & (1UL << 1)));
}
}
#line 818
__inline static pmd_t pmdp_get_and_clear(struct mm_struct *mm , unsigned long addr ,
                                         pmd_t *pmdp )  __attribute__((__no_instrument_function__)) ;
#line 818 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pmd_t pmdp_get_and_clear(struct mm_struct *mm , unsigned long addr ,
                                         pmd_t *pmdp ) 
{ 
  pmd_t pmd ;
  pmd_t tmp___7 ;

  {
  {
#line 821
  tmp___7 = native_pmdp_get_and_clear(pmdp);
#line 821
  pmd = tmp___7;
  }
  {
#line 822
  while (1) {
    while_continue: /* CIL Label */ ;
#line 822
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 823
  return (pmd);
}
}
#line 827
__inline static void pmdp_set_wrprotect(struct mm_struct *mm , unsigned long addr ,
                                        pmd_t *pmdp )  __attribute__((__no_instrument_function__)) ;
#line 827 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static void pmdp_set_wrprotect(struct mm_struct *mm , unsigned long addr ,
                                        pmd_t *pmdp ) 
{ 


  {
  {
#line 830
  clear_bit(1L, (unsigned long volatile   *)((unsigned long *)pmdp));
  }
  {
#line 831
  while (1) {
    while_continue: /* CIL Label */ ;
#line 831
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 832
  return;
}
}
#line 844
__inline static void clone_pgd_range(pgd_t *dst , pgd_t *src , int count )  __attribute__((__no_instrument_function__)) ;
#line 844 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static void clone_pgd_range(pgd_t *dst , pgd_t *src , int count ) 
{ 


  {
  {
#line 846
  memcpy((void *)dst, (void const   *)src, (unsigned long )count * sizeof(pgd_t ));
  }
#line 847
  return;
}
}
#line 850
__inline static int page_level_shift(enum pg_level level )  __attribute__((__no_instrument_function__)) ;
#line 850 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int page_level_shift(enum pg_level level ) 
{ 
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  int tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;
  int tmp___99 ;
  int tmp___100 ;
  int tmp___101 ;
  int tmp___102 ;
  int tmp___103 ;
  int tmp___104 ;
  int tmp___105 ;
  int tmp___106 ;
  int tmp___107 ;
  int tmp___108 ;
  int tmp___109 ;
  int tmp___110 ;
  int tmp___111 ;
  int tmp___112 ;
  int tmp___113 ;
  int tmp___114 ;
  int tmp___115 ;
  int tmp___116 ;
  int tmp___117 ;
  int tmp___118 ;
  int tmp___119 ;
  int tmp___120 ;
  int tmp___121 ;
  int tmp___122 ;
  int tmp___123 ;
  int tmp___124 ;
  int tmp___125 ;
  int tmp___126 ;
  int tmp___127 ;
  int tmp___128 ;
  int tmp___129 ;
  int tmp___130 ;
  int tmp___131 ;
  int tmp___132 ;
  int tmp___133 ;
  int tmp___134 ;
  int tmp___135 ;
  int tmp___136 ;
  int tmp___137 ;
  int tmp___138 ;
  int tmp___139 ;
  int tmp___140 ;
  int tmp___141 ;
  int tmp___142 ;

  {
#line 852
  if (512ULL & (1ULL << 63)) {
    {
#line 852
    tmp___71 = 63;
    }
  } else {
#line 852
    if (512ULL & (1ULL << 62)) {
      {
#line 852
      tmp___70 = 62;
      }
    } else {
#line 852
      if (512ULL & (1ULL << 61)) {
        {
#line 852
        tmp___69 = 61;
        }
      } else {
#line 852
        if (512ULL & (1ULL << 60)) {
          {
#line 852
          tmp___68 = 60;
          }
        } else {
#line 852
          if (512ULL & (1ULL << 59)) {
            {
#line 852
            tmp___67 = 59;
            }
          } else {
#line 852
            if (512ULL & (1ULL << 58)) {
              {
#line 852
              tmp___66 = 58;
              }
            } else {
#line 852
              if (512ULL & (1ULL << 57)) {
                {
#line 852
                tmp___65 = 57;
                }
              } else {
#line 852
                if (512ULL & (1ULL << 56)) {
                  {
#line 852
                  tmp___64 = 56;
                  }
                } else {
#line 852
                  if (512ULL & (1ULL << 55)) {
                    {
#line 852
                    tmp___63 = 55;
                    }
                  } else {
#line 852
                    if (512ULL & (1ULL << 54)) {
                      {
#line 852
                      tmp___62 = 54;
                      }
                    } else {
#line 852
                      if (512ULL & (1ULL << 53)) {
                        {
#line 852
                        tmp___61 = 53;
                        }
                      } else {
#line 852
                        if (512ULL & (1ULL << 52)) {
                          {
#line 852
                          tmp___60 = 52;
                          }
                        } else {
#line 852
                          if (512ULL & (1ULL << 51)) {
                            {
#line 852
                            tmp___59 = 51;
                            }
                          } else {
#line 852
                            if (512ULL & (1ULL << 50)) {
                              {
#line 852
                              tmp___58 = 50;
                              }
                            } else {
#line 852
                              if (512ULL & (1ULL << 49)) {
                                {
#line 852
                                tmp___57 = 49;
                                }
                              } else {
#line 852
                                if (512ULL & (1ULL << 48)) {
                                  {
#line 852
                                  tmp___56 = 48;
                                  }
                                } else {
#line 852
                                  if (512ULL & (1ULL << 47)) {
                                    {
#line 852
                                    tmp___55 = 47;
                                    }
                                  } else {
#line 852
                                    if (512ULL & (1ULL << 46)) {
                                      {
#line 852
                                      tmp___54 = 46;
                                      }
                                    } else {
#line 852
                                      if (512ULL & (1ULL << 45)) {
                                        {
#line 852
                                        tmp___53 = 45;
                                        }
                                      } else {
#line 852
                                        if (512ULL & (1ULL << 44)) {
                                          {
#line 852
                                          tmp___52 = 44;
                                          }
                                        } else {
#line 852
                                          if (512ULL & (1ULL << 43)) {
                                            {
#line 852
                                            tmp___51 = 43;
                                            }
                                          } else {
#line 852
                                            if (512ULL & (1ULL << 42)) {
                                              {
#line 852
                                              tmp___50 = 42;
                                              }
                                            } else {
#line 852
                                              if (512ULL & (1ULL << 41)) {
                                                {
#line 852
                                                tmp___49 = 41;
                                                }
                                              } else {
#line 852
                                                if (512ULL & (1ULL << 40)) {
                                                  {
#line 852
                                                  tmp___48 = 40;
                                                  }
                                                } else {
#line 852
                                                  if (512ULL & (1ULL << 39)) {
                                                    {
#line 852
                                                    tmp___47 = 39;
                                                    }
                                                  } else {
#line 852
                                                    if (512ULL & (1ULL << 38)) {
                                                      {
#line 852
                                                      tmp___46 = 38;
                                                      }
                                                    } else {
#line 852
                                                      if (512ULL & (1ULL << 37)) {
                                                        {
#line 852
                                                        tmp___45 = 37;
                                                        }
                                                      } else {
#line 852
                                                        if (512ULL & (1ULL << 36)) {
                                                          {
#line 852
                                                          tmp___44 = 36;
                                                          }
                                                        } else {
#line 852
                                                          if (512ULL & (1ULL << 35)) {
                                                            {
#line 852
                                                            tmp___43 = 35;
                                                            }
                                                          } else {
#line 852
                                                            if (512ULL & (1ULL << 34)) {
                                                              {
#line 852
                                                              tmp___42 = 34;
                                                              }
                                                            } else {
#line 852
                                                              if (512ULL & (1ULL << 33)) {
                                                                {
#line 852
                                                                tmp___41 = 33;
                                                                }
                                                              } else {
#line 852
                                                                if (512ULL & (1ULL << 32)) {
                                                                  {
#line 852
                                                                  tmp___40 = 32;
                                                                  }
                                                                } else {
#line 852
                                                                  if (512ULL & (1ULL << 31)) {
                                                                    {
#line 852
                                                                    tmp___39 = 31;
                                                                    }
                                                                  } else {
#line 852
                                                                    if (512ULL & (1ULL << 30)) {
                                                                      {
#line 852
                                                                      tmp___38 = 30;
                                                                      }
                                                                    } else {
#line 852
                                                                      if (512ULL & (1ULL << 29)) {
                                                                        {
#line 852
                                                                        tmp___37 = 29;
                                                                        }
                                                                      } else {
#line 852
                                                                        if (512ULL & (1ULL << 28)) {
                                                                          {
#line 852
                                                                          tmp___36 = 28;
                                                                          }
                                                                        } else {
#line 852
                                                                          if (512ULL & (1ULL << 27)) {
                                                                            {
#line 852
                                                                            tmp___35 = 27;
                                                                            }
                                                                          } else {
#line 852
                                                                            if (512ULL & (1ULL << 26)) {
                                                                              {
#line 852
                                                                              tmp___34 = 26;
                                                                              }
                                                                            } else {
#line 852
                                                                              if (512ULL & (1ULL << 25)) {
                                                                                {
#line 852
                                                                                tmp___33 = 25;
                                                                                }
                                                                              } else {
#line 852
                                                                                if (512ULL & (1ULL << 24)) {
                                                                                  {
#line 852
                                                                                  tmp___32 = 24;
                                                                                  }
                                                                                } else {
#line 852
                                                                                  if (512ULL & (1ULL << 23)) {
                                                                                    {
#line 852
                                                                                    tmp___31 = 23;
                                                                                    }
                                                                                  } else {
#line 852
                                                                                    if (512ULL & (1ULL << 22)) {
                                                                                      {
#line 852
                                                                                      tmp___30 = 22;
                                                                                      }
                                                                                    } else {
#line 852
                                                                                      if (512ULL & (1ULL << 21)) {
                                                                                        {
#line 852
                                                                                        tmp___29 = 21;
                                                                                        }
                                                                                      } else {
#line 852
                                                                                        if (512ULL & (1ULL << 20)) {
                                                                                          {
#line 852
                                                                                          tmp___28 = 20;
                                                                                          }
                                                                                        } else {
#line 852
                                                                                          if (512ULL & (1ULL << 19)) {
                                                                                            {
#line 852
                                                                                            tmp___27 = 19;
                                                                                            }
                                                                                          } else {
#line 852
                                                                                            if (512ULL & (1ULL << 18)) {
                                                                                              {
#line 852
                                                                                              tmp___26 = 18;
                                                                                              }
                                                                                            } else {
#line 852
                                                                                              if (512ULL & (1ULL << 17)) {
                                                                                                {
#line 852
                                                                                                tmp___25 = 17;
                                                                                                }
                                                                                              } else {
#line 852
                                                                                                if (512ULL & (1ULL << 16)) {
                                                                                                  {
#line 852
                                                                                                  tmp___24 = 16;
                                                                                                  }
                                                                                                } else {
#line 852
                                                                                                  if (512ULL & (1ULL << 15)) {
                                                                                                    {
#line 852
                                                                                                    tmp___23 = 15;
                                                                                                    }
                                                                                                  } else {
#line 852
                                                                                                    if (512ULL & (1ULL << 14)) {
                                                                                                      {
#line 852
                                                                                                      tmp___22 = 14;
                                                                                                      }
                                                                                                    } else {
#line 852
                                                                                                      if (512ULL & (1ULL << 13)) {
                                                                                                        {
#line 852
                                                                                                        tmp___21 = 13;
                                                                                                        }
                                                                                                      } else {
#line 852
                                                                                                        if (512ULL & (1ULL << 12)) {
                                                                                                          {
#line 852
                                                                                                          tmp___20 = 12;
                                                                                                          }
                                                                                                        } else {
#line 852
                                                                                                          if (512ULL & (1ULL << 11)) {
                                                                                                            {
#line 852
                                                                                                            tmp___19 = 11;
                                                                                                            }
                                                                                                          } else {
#line 852
                                                                                                            if (512ULL & (1ULL << 10)) {
                                                                                                              {
#line 852
                                                                                                              tmp___18 = 10;
                                                                                                              }
                                                                                                            } else {
#line 852
                                                                                                              if (512ULL & (1ULL << 9)) {
                                                                                                                {
#line 852
                                                                                                                tmp___17 = 9;
                                                                                                                }
                                                                                                              } else {
#line 852
                                                                                                                if (512ULL & (1ULL << 8)) {
                                                                                                                  {
#line 852
                                                                                                                  tmp___16 = 8;
                                                                                                                  }
                                                                                                                } else {
#line 852
                                                                                                                  if (512ULL & (1ULL << 7)) {
                                                                                                                    {
#line 852
                                                                                                                    tmp___15 = 7;
                                                                                                                    }
                                                                                                                  } else {
#line 852
                                                                                                                    if (512ULL & (1ULL << 6)) {
                                                                                                                      {
#line 852
                                                                                                                      tmp___14 = 6;
                                                                                                                      }
                                                                                                                    } else {
#line 852
                                                                                                                      if (512ULL & (1ULL << 5)) {
                                                                                                                        {
#line 852
                                                                                                                        tmp___13 = 5;
                                                                                                                        }
                                                                                                                      } else {
#line 852
                                                                                                                        if (512ULL & (1ULL << 4)) {
                                                                                                                          {
#line 852
                                                                                                                          tmp___12 = 4;
                                                                                                                          }
                                                                                                                        } else {
#line 852
                                                                                                                          if (512ULL & (1ULL << 3)) {
                                                                                                                            {
#line 852
                                                                                                                            tmp___11 = 3;
                                                                                                                            }
                                                                                                                          } else {
#line 852
                                                                                                                            if (512ULL & (1ULL << 2)) {
                                                                                                                              {
#line 852
                                                                                                                              tmp___10 = 2;
                                                                                                                              }
                                                                                                                            } else {
#line 852
                                                                                                                              if (512ULL & (1ULL << 1)) {
                                                                                                                                {
#line 852
                                                                                                                                tmp___9 = 1;
                                                                                                                                }
                                                                                                                              } else {
                                                                                                                                {
#line 852
                                                                                                                                tmp___8 = ____ilog2_NaN();
#line 852
                                                                                                                                tmp___9 = tmp___8;
                                                                                                                                }
                                                                                                                              }
                                                                                                                              {
#line 852
                                                                                                                              tmp___10 = tmp___9;
                                                                                                                              }
                                                                                                                            }
                                                                                                                            {
#line 852
                                                                                                                            tmp___11 = tmp___10;
                                                                                                                            }
                                                                                                                          }
                                                                                                                          {
#line 852
                                                                                                                          tmp___12 = tmp___11;
                                                                                                                          }
                                                                                                                        }
                                                                                                                        {
#line 852
                                                                                                                        tmp___13 = tmp___12;
                                                                                                                        }
                                                                                                                      }
                                                                                                                      {
#line 852
                                                                                                                      tmp___14 = tmp___13;
                                                                                                                      }
                                                                                                                    }
                                                                                                                    {
#line 852
                                                                                                                    tmp___15 = tmp___14;
                                                                                                                    }
                                                                                                                  }
                                                                                                                  {
#line 852
                                                                                                                  tmp___16 = tmp___15;
                                                                                                                  }
                                                                                                                }
                                                                                                                {
#line 852
                                                                                                                tmp___17 = tmp___16;
                                                                                                                }
                                                                                                              }
                                                                                                              {
#line 852
                                                                                                              tmp___18 = tmp___17;
                                                                                                              }
                                                                                                            }
                                                                                                            {
#line 852
                                                                                                            tmp___19 = tmp___18;
                                                                                                            }
                                                                                                          }
                                                                                                          {
#line 852
                                                                                                          tmp___20 = tmp___19;
                                                                                                          }
                                                                                                        }
                                                                                                        {
#line 852
                                                                                                        tmp___21 = tmp___20;
                                                                                                        }
                                                                                                      }
                                                                                                      {
#line 852
                                                                                                      tmp___22 = tmp___21;
                                                                                                      }
                                                                                                    }
                                                                                                    {
#line 852
                                                                                                    tmp___23 = tmp___22;
                                                                                                    }
                                                                                                  }
                                                                                                  {
#line 852
                                                                                                  tmp___24 = tmp___23;
                                                                                                  }
                                                                                                }
                                                                                                {
#line 852
                                                                                                tmp___25 = tmp___24;
                                                                                                }
                                                                                              }
                                                                                              {
#line 852
                                                                                              tmp___26 = tmp___25;
                                                                                              }
                                                                                            }
                                                                                            {
#line 852
                                                                                            tmp___27 = tmp___26;
                                                                                            }
                                                                                          }
                                                                                          {
#line 852
                                                                                          tmp___28 = tmp___27;
                                                                                          }
                                                                                        }
                                                                                        {
#line 852
                                                                                        tmp___29 = tmp___28;
                                                                                        }
                                                                                      }
                                                                                      {
#line 852
                                                                                      tmp___30 = tmp___29;
                                                                                      }
                                                                                    }
                                                                                    {
#line 852
                                                                                    tmp___31 = tmp___30;
                                                                                    }
                                                                                  }
                                                                                  {
#line 852
                                                                                  tmp___32 = tmp___31;
                                                                                  }
                                                                                }
                                                                                {
#line 852
                                                                                tmp___33 = tmp___32;
                                                                                }
                                                                              }
                                                                              {
#line 852
                                                                              tmp___34 = tmp___33;
                                                                              }
                                                                            }
                                                                            {
#line 852
                                                                            tmp___35 = tmp___34;
                                                                            }
                                                                          }
                                                                          {
#line 852
                                                                          tmp___36 = tmp___35;
                                                                          }
                                                                        }
                                                                        {
#line 852
                                                                        tmp___37 = tmp___36;
                                                                        }
                                                                      }
                                                                      {
#line 852
                                                                      tmp___38 = tmp___37;
                                                                      }
                                                                    }
                                                                    {
#line 852
                                                                    tmp___39 = tmp___38;
                                                                    }
                                                                  }
                                                                  {
#line 852
                                                                  tmp___40 = tmp___39;
                                                                  }
                                                                }
                                                                {
#line 852
                                                                tmp___41 = tmp___40;
                                                                }
                                                              }
                                                              {
#line 852
                                                              tmp___42 = tmp___41;
                                                              }
                                                            }
                                                            {
#line 852
                                                            tmp___43 = tmp___42;
                                                            }
                                                          }
                                                          {
#line 852
                                                          tmp___44 = tmp___43;
                                                          }
                                                        }
                                                        {
#line 852
                                                        tmp___45 = tmp___44;
                                                        }
                                                      }
                                                      {
#line 852
                                                      tmp___46 = tmp___45;
                                                      }
                                                    }
                                                    {
#line 852
                                                    tmp___47 = tmp___46;
                                                    }
                                                  }
                                                  {
#line 852
                                                  tmp___48 = tmp___47;
                                                  }
                                                }
                                                {
#line 852
                                                tmp___49 = tmp___48;
                                                }
                                              }
                                              {
#line 852
                                              tmp___50 = tmp___49;
                                              }
                                            }
                                            {
#line 852
                                            tmp___51 = tmp___50;
                                            }
                                          }
                                          {
#line 852
                                          tmp___52 = tmp___51;
                                          }
                                        }
                                        {
#line 852
                                        tmp___53 = tmp___52;
                                        }
                                      }
                                      {
#line 852
                                      tmp___54 = tmp___53;
                                      }
                                    }
                                    {
#line 852
                                    tmp___55 = tmp___54;
                                    }
                                  }
                                  {
#line 852
                                  tmp___56 = tmp___55;
                                  }
                                }
                                {
#line 852
                                tmp___57 = tmp___56;
                                }
                              }
                              {
#line 852
                              tmp___58 = tmp___57;
                              }
                            }
                            {
#line 852
                            tmp___59 = tmp___58;
                            }
                          }
                          {
#line 852
                          tmp___60 = tmp___59;
                          }
                        }
                        {
#line 852
                        tmp___61 = tmp___60;
                        }
                      }
                      {
#line 852
                      tmp___62 = tmp___61;
                      }
                    }
                    {
#line 852
                    tmp___63 = tmp___62;
                    }
                  }
                  {
#line 852
                  tmp___64 = tmp___63;
                  }
                }
                {
#line 852
                tmp___65 = tmp___64;
                }
              }
              {
#line 852
              tmp___66 = tmp___65;
              }
            }
            {
#line 852
            tmp___67 = tmp___66;
            }
          }
          {
#line 852
          tmp___68 = tmp___67;
          }
        }
        {
#line 852
        tmp___69 = tmp___68;
        }
      }
      {
#line 852
      tmp___70 = tmp___69;
      }
    }
    {
#line 852
    tmp___71 = tmp___70;
    }
  }
#line 852
  if (512ULL & (1ULL << 63)) {
    {
#line 852
    tmp___139 = 63;
    }
  } else {
#line 852
    if (512ULL & (1ULL << 62)) {
      {
#line 852
      tmp___138 = 62;
      }
    } else {
#line 852
      if (512ULL & (1ULL << 61)) {
        {
#line 852
        tmp___137 = 61;
        }
      } else {
#line 852
        if (512ULL & (1ULL << 60)) {
          {
#line 852
          tmp___136 = 60;
          }
        } else {
#line 852
          if (512ULL & (1ULL << 59)) {
            {
#line 852
            tmp___135 = 59;
            }
          } else {
#line 852
            if (512ULL & (1ULL << 58)) {
              {
#line 852
              tmp___134 = 58;
              }
            } else {
#line 852
              if (512ULL & (1ULL << 57)) {
                {
#line 852
                tmp___133 = 57;
                }
              } else {
#line 852
                if (512ULL & (1ULL << 56)) {
                  {
#line 852
                  tmp___132 = 56;
                  }
                } else {
#line 852
                  if (512ULL & (1ULL << 55)) {
                    {
#line 852
                    tmp___131 = 55;
                    }
                  } else {
#line 852
                    if (512ULL & (1ULL << 54)) {
                      {
#line 852
                      tmp___130 = 54;
                      }
                    } else {
#line 852
                      if (512ULL & (1ULL << 53)) {
                        {
#line 852
                        tmp___129 = 53;
                        }
                      } else {
#line 852
                        if (512ULL & (1ULL << 52)) {
                          {
#line 852
                          tmp___128 = 52;
                          }
                        } else {
#line 852
                          if (512ULL & (1ULL << 51)) {
                            {
#line 852
                            tmp___127 = 51;
                            }
                          } else {
#line 852
                            if (512ULL & (1ULL << 50)) {
                              {
#line 852
                              tmp___126 = 50;
                              }
                            } else {
#line 852
                              if (512ULL & (1ULL << 49)) {
                                {
#line 852
                                tmp___125 = 49;
                                }
                              } else {
#line 852
                                if (512ULL & (1ULL << 48)) {
                                  {
#line 852
                                  tmp___124 = 48;
                                  }
                                } else {
#line 852
                                  if (512ULL & (1ULL << 47)) {
                                    {
#line 852
                                    tmp___123 = 47;
                                    }
                                  } else {
#line 852
                                    if (512ULL & (1ULL << 46)) {
                                      {
#line 852
                                      tmp___122 = 46;
                                      }
                                    } else {
#line 852
                                      if (512ULL & (1ULL << 45)) {
                                        {
#line 852
                                        tmp___121 = 45;
                                        }
                                      } else {
#line 852
                                        if (512ULL & (1ULL << 44)) {
                                          {
#line 852
                                          tmp___120 = 44;
                                          }
                                        } else {
#line 852
                                          if (512ULL & (1ULL << 43)) {
                                            {
#line 852
                                            tmp___119 = 43;
                                            }
                                          } else {
#line 852
                                            if (512ULL & (1ULL << 42)) {
                                              {
#line 852
                                              tmp___118 = 42;
                                              }
                                            } else {
#line 852
                                              if (512ULL & (1ULL << 41)) {
                                                {
#line 852
                                                tmp___117 = 41;
                                                }
                                              } else {
#line 852
                                                if (512ULL & (1ULL << 40)) {
                                                  {
#line 852
                                                  tmp___116 = 40;
                                                  }
                                                } else {
#line 852
                                                  if (512ULL & (1ULL << 39)) {
                                                    {
#line 852
                                                    tmp___115 = 39;
                                                    }
                                                  } else {
#line 852
                                                    if (512ULL & (1ULL << 38)) {
                                                      {
#line 852
                                                      tmp___114 = 38;
                                                      }
                                                    } else {
#line 852
                                                      if (512ULL & (1ULL << 37)) {
                                                        {
#line 852
                                                        tmp___113 = 37;
                                                        }
                                                      } else {
#line 852
                                                        if (512ULL & (1ULL << 36)) {
                                                          {
#line 852
                                                          tmp___112 = 36;
                                                          }
                                                        } else {
#line 852
                                                          if (512ULL & (1ULL << 35)) {
                                                            {
#line 852
                                                            tmp___111 = 35;
                                                            }
                                                          } else {
#line 852
                                                            if (512ULL & (1ULL << 34)) {
                                                              {
#line 852
                                                              tmp___110 = 34;
                                                              }
                                                            } else {
#line 852
                                                              if (512ULL & (1ULL << 33)) {
                                                                {
#line 852
                                                                tmp___109 = 33;
                                                                }
                                                              } else {
#line 852
                                                                if (512ULL & (1ULL << 32)) {
                                                                  {
#line 852
                                                                  tmp___108 = 32;
                                                                  }
                                                                } else {
#line 852
                                                                  if (512ULL & (1ULL << 31)) {
                                                                    {
#line 852
                                                                    tmp___107 = 31;
                                                                    }
                                                                  } else {
#line 852
                                                                    if (512ULL & (1ULL << 30)) {
                                                                      {
#line 852
                                                                      tmp___106 = 30;
                                                                      }
                                                                    } else {
#line 852
                                                                      if (512ULL & (1ULL << 29)) {
                                                                        {
#line 852
                                                                        tmp___105 = 29;
                                                                        }
                                                                      } else {
#line 852
                                                                        if (512ULL & (1ULL << 28)) {
                                                                          {
#line 852
                                                                          tmp___104 = 28;
                                                                          }
                                                                        } else {
#line 852
                                                                          if (512ULL & (1ULL << 27)) {
                                                                            {
#line 852
                                                                            tmp___103 = 27;
                                                                            }
                                                                          } else {
#line 852
                                                                            if (512ULL & (1ULL << 26)) {
                                                                              {
#line 852
                                                                              tmp___102 = 26;
                                                                              }
                                                                            } else {
#line 852
                                                                              if (512ULL & (1ULL << 25)) {
                                                                                {
#line 852
                                                                                tmp___101 = 25;
                                                                                }
                                                                              } else {
#line 852
                                                                                if (512ULL & (1ULL << 24)) {
                                                                                  {
#line 852
                                                                                  tmp___100 = 24;
                                                                                  }
                                                                                } else {
#line 852
                                                                                  if (512ULL & (1ULL << 23)) {
                                                                                    {
#line 852
                                                                                    tmp___99 = 23;
                                                                                    }
                                                                                  } else {
#line 852
                                                                                    if (512ULL & (1ULL << 22)) {
                                                                                      {
#line 852
                                                                                      tmp___98 = 22;
                                                                                      }
                                                                                    } else {
#line 852
                                                                                      if (512ULL & (1ULL << 21)) {
                                                                                        {
#line 852
                                                                                        tmp___97 = 21;
                                                                                        }
                                                                                      } else {
#line 852
                                                                                        if (512ULL & (1ULL << 20)) {
                                                                                          {
#line 852
                                                                                          tmp___96 = 20;
                                                                                          }
                                                                                        } else {
#line 852
                                                                                          if (512ULL & (1ULL << 19)) {
                                                                                            {
#line 852
                                                                                            tmp___95 = 19;
                                                                                            }
                                                                                          } else {
#line 852
                                                                                            if (512ULL & (1ULL << 18)) {
                                                                                              {
#line 852
                                                                                              tmp___94 = 18;
                                                                                              }
                                                                                            } else {
#line 852
                                                                                              if (512ULL & (1ULL << 17)) {
                                                                                                {
#line 852
                                                                                                tmp___93 = 17;
                                                                                                }
                                                                                              } else {
#line 852
                                                                                                if (512ULL & (1ULL << 16)) {
                                                                                                  {
#line 852
                                                                                                  tmp___92 = 16;
                                                                                                  }
                                                                                                } else {
#line 852
                                                                                                  if (512ULL & (1ULL << 15)) {
                                                                                                    {
#line 852
                                                                                                    tmp___91 = 15;
                                                                                                    }
                                                                                                  } else {
#line 852
                                                                                                    if (512ULL & (1ULL << 14)) {
                                                                                                      {
#line 852
                                                                                                      tmp___90 = 14;
                                                                                                      }
                                                                                                    } else {
#line 852
                                                                                                      if (512ULL & (1ULL << 13)) {
                                                                                                        {
#line 852
                                                                                                        tmp___89 = 13;
                                                                                                        }
                                                                                                      } else {
#line 852
                                                                                                        if (512ULL & (1ULL << 12)) {
                                                                                                          {
#line 852
                                                                                                          tmp___88 = 12;
                                                                                                          }
                                                                                                        } else {
#line 852
                                                                                                          if (512ULL & (1ULL << 11)) {
                                                                                                            {
#line 852
                                                                                                            tmp___87 = 11;
                                                                                                            }
                                                                                                          } else {
#line 852
                                                                                                            if (512ULL & (1ULL << 10)) {
                                                                                                              {
#line 852
                                                                                                              tmp___86 = 10;
                                                                                                              }
                                                                                                            } else {
#line 852
                                                                                                              if (512ULL & (1ULL << 9)) {
                                                                                                                {
#line 852
                                                                                                                tmp___85 = 9;
                                                                                                                }
                                                                                                              } else {
#line 852
                                                                                                                if (512ULL & (1ULL << 8)) {
                                                                                                                  {
#line 852
                                                                                                                  tmp___84 = 8;
                                                                                                                  }
                                                                                                                } else {
#line 852
                                                                                                                  if (512ULL & (1ULL << 7)) {
                                                                                                                    {
#line 852
                                                                                                                    tmp___83 = 7;
                                                                                                                    }
                                                                                                                  } else {
#line 852
                                                                                                                    if (512ULL & (1ULL << 6)) {
                                                                                                                      {
#line 852
                                                                                                                      tmp___82 = 6;
                                                                                                                      }
                                                                                                                    } else {
#line 852
                                                                                                                      if (512ULL & (1ULL << 5)) {
                                                                                                                        {
#line 852
                                                                                                                        tmp___81 = 5;
                                                                                                                        }
                                                                                                                      } else {
#line 852
                                                                                                                        if (512ULL & (1ULL << 4)) {
                                                                                                                          {
#line 852
                                                                                                                          tmp___80 = 4;
                                                                                                                          }
                                                                                                                        } else {
#line 852
                                                                                                                          if (512ULL & (1ULL << 3)) {
                                                                                                                            {
#line 852
                                                                                                                            tmp___79 = 3;
                                                                                                                            }
                                                                                                                          } else {
#line 852
                                                                                                                            if (512ULL & (1ULL << 2)) {
                                                                                                                              {
#line 852
                                                                                                                              tmp___78 = 2;
                                                                                                                              }
                                                                                                                            } else {
#line 852
                                                                                                                              if (512ULL & (1ULL << 1)) {
                                                                                                                                {
#line 852
                                                                                                                                tmp___77 = 1;
                                                                                                                                }
                                                                                                                              } else {
                                                                                                                                {
#line 852
                                                                                                                                tmp___76 = ____ilog2_NaN();
#line 852
                                                                                                                                tmp___77 = tmp___76;
                                                                                                                                }
                                                                                                                              }
                                                                                                                              {
#line 852
                                                                                                                              tmp___78 = tmp___77;
                                                                                                                              }
                                                                                                                            }
                                                                                                                            {
#line 852
                                                                                                                            tmp___79 = tmp___78;
                                                                                                                            }
                                                                                                                          }
                                                                                                                          {
#line 852
                                                                                                                          tmp___80 = tmp___79;
                                                                                                                          }
                                                                                                                        }
                                                                                                                        {
#line 852
                                                                                                                        tmp___81 = tmp___80;
                                                                                                                        }
                                                                                                                      }
                                                                                                                      {
#line 852
                                                                                                                      tmp___82 = tmp___81;
                                                                                                                      }
                                                                                                                    }
                                                                                                                    {
#line 852
                                                                                                                    tmp___83 = tmp___82;
                                                                                                                    }
                                                                                                                  }
                                                                                                                  {
#line 852
                                                                                                                  tmp___84 = tmp___83;
                                                                                                                  }
                                                                                                                }
                                                                                                                {
#line 852
                                                                                                                tmp___85 = tmp___84;
                                                                                                                }
                                                                                                              }
                                                                                                              {
#line 852
                                                                                                              tmp___86 = tmp___85;
                                                                                                              }
                                                                                                            }
                                                                                                            {
#line 852
                                                                                                            tmp___87 = tmp___86;
                                                                                                            }
                                                                                                          }
                                                                                                          {
#line 852
                                                                                                          tmp___88 = tmp___87;
                                                                                                          }
                                                                                                        }
                                                                                                        {
#line 852
                                                                                                        tmp___89 = tmp___88;
                                                                                                        }
                                                                                                      }
                                                                                                      {
#line 852
                                                                                                      tmp___90 = tmp___89;
                                                                                                      }
                                                                                                    }
                                                                                                    {
#line 852
                                                                                                    tmp___91 = tmp___90;
                                                                                                    }
                                                                                                  }
                                                                                                  {
#line 852
                                                                                                  tmp___92 = tmp___91;
                                                                                                  }
                                                                                                }
                                                                                                {
#line 852
                                                                                                tmp___93 = tmp___92;
                                                                                                }
                                                                                              }
                                                                                              {
#line 852
                                                                                              tmp___94 = tmp___93;
                                                                                              }
                                                                                            }
                                                                                            {
#line 852
                                                                                            tmp___95 = tmp___94;
                                                                                            }
                                                                                          }
                                                                                          {
#line 852
                                                                                          tmp___96 = tmp___95;
                                                                                          }
                                                                                        }
                                                                                        {
#line 852
                                                                                        tmp___97 = tmp___96;
                                                                                        }
                                                                                      }
                                                                                      {
#line 852
                                                                                      tmp___98 = tmp___97;
                                                                                      }
                                                                                    }
                                                                                    {
#line 852
                                                                                    tmp___99 = tmp___98;
                                                                                    }
                                                                                  }
                                                                                  {
#line 852
                                                                                  tmp___100 = tmp___99;
                                                                                  }
                                                                                }
                                                                                {
#line 852
                                                                                tmp___101 = tmp___100;
                                                                                }
                                                                              }
                                                                              {
#line 852
                                                                              tmp___102 = tmp___101;
                                                                              }
                                                                            }
                                                                            {
#line 852
                                                                            tmp___103 = tmp___102;
                                                                            }
                                                                          }
                                                                          {
#line 852
                                                                          tmp___104 = tmp___103;
                                                                          }
                                                                        }
                                                                        {
#line 852
                                                                        tmp___105 = tmp___104;
                                                                        }
                                                                      }
                                                                      {
#line 852
                                                                      tmp___106 = tmp___105;
                                                                      }
                                                                    }
                                                                    {
#line 852
                                                                    tmp___107 = tmp___106;
                                                                    }
                                                                  }
                                                                  {
#line 852
                                                                  tmp___108 = tmp___107;
                                                                  }
                                                                }
                                                                {
#line 852
                                                                tmp___109 = tmp___108;
                                                                }
                                                              }
                                                              {
#line 852
                                                              tmp___110 = tmp___109;
                                                              }
                                                            }
                                                            {
#line 852
                                                            tmp___111 = tmp___110;
                                                            }
                                                          }
                                                          {
#line 852
                                                          tmp___112 = tmp___111;
                                                          }
                                                        }
                                                        {
#line 852
                                                        tmp___113 = tmp___112;
                                                        }
                                                      }
                                                      {
#line 852
                                                      tmp___114 = tmp___113;
                                                      }
                                                    }
                                                    {
#line 852
                                                    tmp___115 = tmp___114;
                                                    }
                                                  }
                                                  {
#line 852
                                                  tmp___116 = tmp___115;
                                                  }
                                                }
                                                {
#line 852
                                                tmp___117 = tmp___116;
                                                }
                                              }
                                              {
#line 852
                                              tmp___118 = tmp___117;
                                              }
                                            }
                                            {
#line 852
                                            tmp___119 = tmp___118;
                                            }
                                          }
                                          {
#line 852
                                          tmp___120 = tmp___119;
                                          }
                                        }
                                        {
#line 852
                                        tmp___121 = tmp___120;
                                        }
                                      }
                                      {
#line 852
                                      tmp___122 = tmp___121;
                                      }
                                    }
                                    {
#line 852
                                    tmp___123 = tmp___122;
                                    }
                                  }
                                  {
#line 852
                                  tmp___124 = tmp___123;
                                  }
                                }
                                {
#line 852
                                tmp___125 = tmp___124;
                                }
                              }
                              {
#line 852
                              tmp___126 = tmp___125;
                              }
                            }
                            {
#line 852
                            tmp___127 = tmp___126;
                            }
                          }
                          {
#line 852
                          tmp___128 = tmp___127;
                          }
                        }
                        {
#line 852
                        tmp___129 = tmp___128;
                        }
                      }
                      {
#line 852
                      tmp___130 = tmp___129;
                      }
                    }
                    {
#line 852
                    tmp___131 = tmp___130;
                    }
                  }
                  {
#line 852
                  tmp___132 = tmp___131;
                  }
                }
                {
#line 852
                tmp___133 = tmp___132;
                }
              }
              {
#line 852
              tmp___134 = tmp___133;
              }
            }
            {
#line 852
            tmp___135 = tmp___134;
            }
          }
          {
#line 852
          tmp___136 = tmp___135;
          }
        }
        {
#line 852
        tmp___137 = tmp___136;
        }
      }
      {
#line 852
      tmp___138 = tmp___137;
      }
    }
    {
#line 852
    tmp___139 = tmp___138;
    }
  }
#line 852
  return ((int )((unsigned int )(12 - tmp___71) + (unsigned int )level * (unsigned int )tmp___139));
}
}
#line 854
__inline static unsigned long page_level_size(enum pg_level level )  __attribute__((__no_instrument_function__)) ;
#line 854 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static unsigned long page_level_size(enum pg_level level ) 
{ 
  int tmp___7 ;

  {
  {
#line 856
  tmp___7 = page_level_shift(level);
  }
#line 856
  return (1UL << tmp___7);
}
}
#line 858
__inline static unsigned long page_level_mask(enum pg_level level )  __attribute__((__no_instrument_function__)) ;
#line 858 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static unsigned long page_level_mask(enum pg_level level ) 
{ 
  unsigned long tmp___7 ;

  {
  {
#line 860
  tmp___7 = page_level_size(level);
  }
#line 860
  return (~ (tmp___7 - 1UL));
}
}
#line 867
__inline static void update_mmu_cache(struct vm_area_struct *vma , unsigned long addr ,
                                      pte_t *ptep )  __attribute__((__no_instrument_function__)) ;
#line 867 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static void update_mmu_cache(struct vm_area_struct *vma , unsigned long addr ,
                                      pte_t *ptep ) 
{ 


  {
#line 870
  return;
}
}
#line 871
__inline static void update_mmu_cache_pmd(struct vm_area_struct *vma , unsigned long addr ,
                                          pmd_t *pmd )  __attribute__((__no_instrument_function__)) ;
#line 871 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static void update_mmu_cache_pmd(struct vm_area_struct *vma , unsigned long addr ,
                                          pmd_t *pmd ) 
{ 


  {
#line 874
  return;
}
}
#line 877
__inline static pte_t pte_swp_mksoft_dirty(pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 877 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t pte_swp_mksoft_dirty(pte_t pte ) 
{ 
  pte_t tmp___7 ;

  {
  {
#line 880
  tmp___7 = pte_set_flags(pte, (pteval_t )0);
  }
#line 880
  return (tmp___7);
}
}
#line 883
__inline static int pte_swp_soft_dirty(pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 883 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pte_swp_soft_dirty(pte_t pte ) 
{ 
  pteval_t tmp___7 ;

  {
  {
#line 886
  tmp___7 = pte_flags(pte);
  }
#line 886
  return (0);
}
}
#line 889
__inline static pte_t pte_swp_clear_soft_dirty(pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 889 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t pte_swp_clear_soft_dirty(pte_t pte ) 
{ 
  pte_t tmp___7 ;

  {
  {
#line 892
  tmp___7 = pte_clear_flags(pte, (pteval_t )0);
  }
#line 892
  return (tmp___7);
}
}
#line 123 "../../../analyzer/../bench/linux-headers/include/asm-generic/pgtable.h"
__inline static void pte_clear_not_present_full(struct mm_struct *mm , unsigned long address ,
                                                pte_t *ptep , int full )  __attribute__((__no_instrument_function__)) ;
#line 123 "../../../analyzer/../bench/linux-headers/include/asm-generic/pgtable.h"
__inline static void pte_clear_not_present_full(struct mm_struct *mm , unsigned long address ,
                                                pte_t *ptep , int full ) 
{ 


  {
  {
#line 128
  native_pte_clear(mm, address, ptep);
  }
#line 129
  return;
}
}
#line 133
extern pte_t ptep_clear_flush(struct vm_area_struct *vma , unsigned long address ,
                              pte_t *ptep ) ;
#line 139
extern pmd_t pmdp_clear_flush(struct vm_area_struct *vma , unsigned long address ,
                              pmd_t *pmdp ) ;
#line 176
extern void pgtable_trans_huge_deposit(struct mm_struct *mm , pmd_t *pmdp , pgtable_t pgtable ) ;
#line 181
extern pgtable_t pgtable_trans_huge_withdraw(struct mm_struct *mm , pmd_t *pmdp ) ;
#line 185
extern void pmdp_invalidate(struct vm_area_struct *vma , unsigned long address , pmd_t *pmdp ) ;
#line 203
__inline static int pte_unused(pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 203 "../../../analyzer/../bench/linux-headers/include/asm-generic/pgtable.h"
__inline static int pte_unused(pte_t pte ) 
{ 


  {
#line 205
  return (0);
}
}
#line 216
__inline static int pmd_same(pmd_t pmd_a , pmd_t pmd_b )  __attribute__((__no_instrument_function__)) ;
#line 216 "../../../analyzer/../bench/linux-headers/include/asm-generic/pgtable.h"
__inline static int pmd_same(pmd_t pmd_a , pmd_t pmd_b ) 
{ 


  {
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 218
    __asm__  volatile   ("1:\tud2\n"
                         ".pushsection __bug_table,\"a\"\n"
                         "2:\t.long 1b - 2b, %c0 - 2b\n"
                         "\t.word %c1, 0\n"
                         "\t.org 2b+%c2\n"
                         ".popsection": : "i" ("../../../analyzer/../bench/linux-headers/include/asm-generic/pgtable.h"),
                         "i" (218), "i" (sizeof(struct bug_entry )));
#line 218
    __builtin_unreachable();
    }
#line 218
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 219
  return (0);
}
}
#line 282
extern void pgd_clear_bad(pgd_t * ) ;
#line 283
extern void pud_clear_bad(pud_t * ) ;
#line 284
extern void pmd_clear_bad(pmd_t * ) ;
#line 286
__inline static int pgd_none_or_clear_bad(pgd_t *pgd )  __attribute__((__no_instrument_function__)) ;
#line 286 "../../../analyzer/../bench/linux-headers/include/asm-generic/pgtable.h"
__inline static int pgd_none_or_clear_bad(pgd_t *pgd ) 
{ 
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;

  {
  {
#line 288
  tmp___7 = pgd_none(*pgd);
  }
#line 288
  if (tmp___7) {
#line 289
    return (1);
  }
  {
#line 290
  tmp___8 = pgd_bad(*pgd);
  }
#line 290
  if (tmp___8) {
    {
#line 290
    tmp___9 = 1;
    }
  } else {
    {
#line 290
    tmp___9 = 0;
    }
  }
  {
#line 290
  tmp___10 = __builtin_expect((long )tmp___9, 0L);
  }
#line 290
  if (tmp___10) {
    {
#line 291
    pgd_clear_bad(pgd);
    }
#line 292
    return (1);
  }
#line 294
  return (0);
}
}
#line 297
__inline static int pud_none_or_clear_bad(pud_t *pud )  __attribute__((__no_instrument_function__)) ;
#line 297 "../../../analyzer/../bench/linux-headers/include/asm-generic/pgtable.h"
__inline static int pud_none_or_clear_bad(pud_t *pud ) 
{ 
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;

  {
  {
#line 299
  tmp___7 = pud_none(*pud);
  }
#line 299
  if (tmp___7) {
#line 300
    return (1);
  }
  {
#line 301
  tmp___8 = pud_bad(*pud);
  }
#line 301
  if (tmp___8) {
    {
#line 301
    tmp___9 = 1;
    }
  } else {
    {
#line 301
    tmp___9 = 0;
    }
  }
  {
#line 301
  tmp___10 = __builtin_expect((long )tmp___9, 0L);
  }
#line 301
  if (tmp___10) {
    {
#line 302
    pud_clear_bad(pud);
    }
#line 303
    return (1);
  }
#line 305
  return (0);
}
}
#line 308
__inline static int pmd_none_or_clear_bad(pmd_t *pmd )  __attribute__((__no_instrument_function__)) ;
#line 308 "../../../analyzer/../bench/linux-headers/include/asm-generic/pgtable.h"
__inline static int pmd_none_or_clear_bad(pmd_t *pmd ) 
{ 
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;

  {
  {
#line 310
  tmp___7 = pmd_none(*pmd);
  }
#line 310
  if (tmp___7) {
#line 311
    return (1);
  }
  {
#line 312
  tmp___8 = pmd_bad(*pmd);
  }
#line 312
  if (tmp___8) {
    {
#line 312
    tmp___9 = 1;
    }
  } else {
    {
#line 312
    tmp___9 = 0;
    }
  }
  {
#line 312
  tmp___10 = __builtin_expect((long )tmp___9, 0L);
  }
#line 312
  if (tmp___10) {
    {
#line 313
    pmd_clear_bad(pmd);
    }
#line 314
    return (1);
  }
#line 316
  return (0);
}
}
#line 319
__inline static pte_t __ptep_modify_prot_start(struct mm_struct *mm , unsigned long addr ,
                                               pte_t *ptep )  __attribute__((__no_instrument_function__)) ;
#line 319 "../../../analyzer/../bench/linux-headers/include/asm-generic/pgtable.h"
__inline static pte_t __ptep_modify_prot_start(struct mm_struct *mm , unsigned long addr ,
                                               pte_t *ptep ) 
{ 
  pte_t tmp___7 ;

  {
  {
#line 328
  tmp___7 = ptep_get_and_clear(mm, addr, ptep);
  }
#line 328
  return (tmp___7);
}
}
#line 331
__inline static void __ptep_modify_prot_commit(struct mm_struct *mm , unsigned long addr ,
                                               pte_t *ptep , pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 331 "../../../analyzer/../bench/linux-headers/include/asm-generic/pgtable.h"
__inline static void __ptep_modify_prot_commit(struct mm_struct *mm , unsigned long addr ,
                                               pte_t *ptep , pte_t pte ) 
{ 


  {
  {
#line 339
  native_set_pte_at(mm, addr, ptep, pte);
  }
#line 340
  return;
}
}
#line 357
__inline static pte_t ptep_modify_prot_start(struct mm_struct *mm , unsigned long addr ,
                                             pte_t *ptep )  __attribute__((__no_instrument_function__)) ;
#line 357 "../../../analyzer/../bench/linux-headers/include/asm-generic/pgtable.h"
__inline static pte_t ptep_modify_prot_start(struct mm_struct *mm , unsigned long addr ,
                                             pte_t *ptep ) 
{ 
  pte_t tmp___7 ;

  {
  {
#line 361
  tmp___7 = __ptep_modify_prot_start(mm, addr, ptep);
  }
#line 361
  return (tmp___7);
}
}
#line 368
__inline static void ptep_modify_prot_commit(struct mm_struct *mm , unsigned long addr ,
                                             pte_t *ptep , pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 368 "../../../analyzer/../bench/linux-headers/include/asm-generic/pgtable.h"
__inline static void ptep_modify_prot_commit(struct mm_struct *mm , unsigned long addr ,
                                             pte_t *ptep , pte_t pte ) 
{ 


  {
  {
#line 372
  __ptep_modify_prot_commit(mm, addr, ptep, pte);
  }
#line 373
  return;
}
}
#line 512
extern int track_pfn_remap(struct vm_area_struct *vma , pgprot_t *prot , unsigned long pfn ,
                           unsigned long addr , unsigned long size ) ;
#line 515
extern int track_pfn_insert(struct vm_area_struct *vma , pgprot_t *prot , unsigned long pfn ) ;
#line 517
extern int track_pfn_copy(struct vm_area_struct *vma ) ;
#line 518
extern void untrack_pfn(struct vm_area_struct *vma , unsigned long pfn , unsigned long size ) ;
#line 535
extern unsigned long zero_pfn ;
#line 533
__inline static int is_zero_pfn(unsigned long pfn )  __attribute__((__no_instrument_function__)) ;
#line 533 "../../../analyzer/../bench/linux-headers/include/asm-generic/pgtable.h"
__inline static int is_zero_pfn(unsigned long pfn ) 
{ 


  {
#line 536
  return (pfn == zero_pfn);
}
}
#line 539
__inline static unsigned long my_zero_pfn(unsigned long addr )  __attribute__((__no_instrument_function__)) ;
#line 539 "../../../analyzer/../bench/linux-headers/include/asm-generic/pgtable.h"
__inline static unsigned long my_zero_pfn(unsigned long addr ) 
{ 


  {
#line 542
  return (zero_pfn);
}
}
#line 549
__inline static int pmd_trans_huge(pmd_t pmd )  __attribute__((__no_instrument_function__)) ;
#line 549 "../../../analyzer/../bench/linux-headers/include/asm-generic/pgtable.h"
__inline static int pmd_trans_huge(pmd_t pmd ) 
{ 


  {
#line 551
  return (0);
}
}
#line 553
__inline static int pmd_trans_splitting(pmd_t pmd )  __attribute__((__no_instrument_function__)) ;
#line 553 "../../../analyzer/../bench/linux-headers/include/asm-generic/pgtable.h"
__inline static int pmd_trans_splitting(pmd_t pmd ) 
{ 


  {
#line 555
  return (0);
}
}
#line 567
__inline static pmd_t pmd_read_atomic(pmd_t *pmdp )  __attribute__((__no_instrument_function__)) ;
#line 567 "../../../analyzer/../bench/linux-headers/include/asm-generic/pgtable.h"
__inline static pmd_t pmd_read_atomic(pmd_t *pmdp ) 
{ 


  {
#line 574
  return (*pmdp);
}
}
#line 579
__inline static int pmd_move_must_withdraw(spinlock_t *new_pmd_ptl , spinlock_t *old_pmd_ptl )  __attribute__((__no_instrument_function__)) ;
#line 579 "../../../analyzer/../bench/linux-headers/include/asm-generic/pgtable.h"
__inline static int pmd_move_must_withdraw(spinlock_t *new_pmd_ptl , spinlock_t *old_pmd_ptl ) 
{ 


  {
#line 586
  return ((unsigned long )new_pmd_ptl != (unsigned long )old_pmd_ptl);
}
}
#line 611
__inline static int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd )  __attribute__((__no_instrument_function__)) ;
#line 611 "../../../analyzer/../bench/linux-headers/include/asm-generic/pgtable.h"
__inline static int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd ) 
{ 
  pmd_t pmdval ;
  pmd_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  long tmp___12 ;

  {
  {
#line 613
  tmp___7 = pmd_read_atomic(pmd);
#line 613
  pmdval = tmp___7;
#line 631
  tmp___8 = pmd_none(pmdval);
  }
#line 631
  if (tmp___8) {
#line 632
    return (1);
  } else {
    {
#line 631
    tmp___9 = pmd_trans_huge(pmdval);
    }
#line 631
    if (tmp___9) {
#line 632
      return (1);
    }
  }
  {
#line 633
  tmp___10 = pmd_bad(pmdval);
  }
#line 633
  if (tmp___10) {
    {
#line 633
    tmp___11 = 1;
    }
  } else {
    {
#line 633
    tmp___11 = 0;
    }
  }
  {
#line 633
  tmp___12 = __builtin_expect((long )tmp___11, 0L);
  }
#line 633
  if (tmp___12) {
    {
#line 634
    pmd_clear_bad(pmd);
    }
#line 635
    return (1);
  }
#line 637
  return (0);
}
}
#line 653
__inline static int pmd_trans_unstable(pmd_t *pmd )  __attribute__((__no_instrument_function__)) ;
#line 653 "../../../analyzer/../bench/linux-headers/include/asm-generic/pgtable.h"
__inline static int pmd_trans_unstable(pmd_t *pmd ) 
{ 


  {
#line 658
  return (0);
}
}
#line 778
__inline static int pmd_numa(pmd_t pmd )  __attribute__((__no_instrument_function__)) ;
#line 778 "../../../analyzer/../bench/linux-headers/include/asm-generic/pgtable.h"
__inline static int pmd_numa(pmd_t pmd ) 
{ 


  {
#line 780
  return (0);
}
}
#line 783
__inline static int pte_numa(pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 783 "../../../analyzer/../bench/linux-headers/include/asm-generic/pgtable.h"
__inline static int pte_numa(pte_t pte ) 
{ 


  {
#line 785
  return (0);
}
}
#line 788
__inline static pte_t pte_mknonnuma(pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 788 "../../../analyzer/../bench/linux-headers/include/asm-generic/pgtable.h"
__inline static pte_t pte_mknonnuma(pte_t pte ) 
{ 


  {
#line 790
  return (pte);
}
}
#line 793
__inline static pmd_t pmd_mknonnuma(pmd_t pmd )  __attribute__((__no_instrument_function__)) ;
#line 793 "../../../analyzer/../bench/linux-headers/include/asm-generic/pgtable.h"
__inline static pmd_t pmd_mknonnuma(pmd_t pmd ) 
{ 


  {
#line 795
  return (pmd);
}
}
#line 798
__inline static pte_t pte_mknuma(pte_t pte )  __attribute__((__no_instrument_function__)) ;
#line 798 "../../../analyzer/../bench/linux-headers/include/asm-generic/pgtable.h"
__inline static pte_t pte_mknuma(pte_t pte ) 
{ 


  {
#line 800
  return (pte);
}
}
#line 803
__inline static void ptep_set_numa(struct mm_struct *mm , unsigned long addr , pte_t *ptep )  __attribute__((__no_instrument_function__)) ;
#line 803 "../../../analyzer/../bench/linux-headers/include/asm-generic/pgtable.h"
__inline static void ptep_set_numa(struct mm_struct *mm , unsigned long addr , pte_t *ptep ) 
{ 


  {
#line 806
  return;
}
}
#line 810
__inline static pmd_t pmd_mknuma(pmd_t pmd )  __attribute__((__no_instrument_function__)) ;
#line 810 "../../../analyzer/../bench/linux-headers/include/asm-generic/pgtable.h"
__inline static pmd_t pmd_mknuma(pmd_t pmd ) 
{ 


  {
#line 812
  return (pmd);
}
}
#line 815
__inline static void pmdp_set_numa(struct mm_struct *mm , unsigned long addr , pmd_t *pmdp )  __attribute__((__no_instrument_function__)) ;
#line 815 "../../../analyzer/../bench/linux-headers/include/asm-generic/pgtable.h"
__inline static void pmdp_set_numa(struct mm_struct *mm , unsigned long addr , pmd_t *pmdp ) 
{ 


  {
#line 818
  return;
}
}
#line 58 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
extern unsigned long sysctl_user_reserve_kbytes ;
#line 59
extern unsigned long sysctl_admin_reserve_kbytes ;
#line 61
extern int sysctl_overcommit_memory ;
#line 62
extern int sysctl_overcommit_ratio ;
#line 63
extern unsigned long sysctl_overcommit_kbytes ;
#line 65
extern int overcommit_ratio_handler(struct ctl_table * , int  , void * , size_t * ,
                                    loff_t * ) ;
#line 67
extern int overcommit_kbytes_handler(struct ctl_table * , int  , void * , size_t * ,
                                     loff_t * ) ;
#line 87
extern struct kmem_cache *vm_area_cachep ;
#line 187
extern pgprot_t protection_map[16] ;
#line 285
__inline static void set_freepage_migratetype(struct page *page , int migratetype )  __attribute__((__no_instrument_function__)) ;
#line 285 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void set_freepage_migratetype(struct page *page , int migratetype ) 
{ 


  {
  {
#line 287
  page->__annonCompField27.__annonCompField22.index = (unsigned long )migratetype;
  }
#line 288
  return;
}
}
#line 291
__inline static int get_freepage_migratetype(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 291 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static int get_freepage_migratetype(struct page *page ) 
{ 


  {
#line 293
  return ((int )page->__annonCompField27.__annonCompField22.index);
}
}
#line 206 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int PageLocked(struct page  const  *page )  __attribute__((__no_instrument_function__)) ;
#line 206 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int PageLocked(struct page  const  *page ) 
{ 
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 206
  tmp___7 = constant_test_bit(0L, (unsigned long const volatile   *)(& page->flags));
  }
#line 206
  return (tmp___7);
}
}
#line 207
__inline static int PageError(struct page  const  *page )  __attribute__((__no_instrument_function__)) ;
#line 207 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int PageError(struct page  const  *page ) 
{ 
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 207
  tmp___7 = constant_test_bit(1L, (unsigned long const volatile   *)(& page->flags));
  }
#line 207
  return (tmp___7);
}
}
#line 207
__inline static void SetPageError(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 207 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void SetPageError(struct page *page ) 
{ 


  {
  {
#line 207
  set_bit(1L, (unsigned long volatile   *)(& page->flags));
  }
#line 207
  return;
}
}
#line 207
__inline static void ClearPageError(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 207 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void ClearPageError(struct page *page ) 
{ 


  {
  {
#line 207
  clear_bit(1L, (unsigned long volatile   *)(& page->flags));
  }
#line 207
  return;
}
}
#line 207
__inline static int TestClearPageError(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 207 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int TestClearPageError(struct page *page ) 
{ 
  int tmp___7 ;

  {
  {
#line 207
  tmp___7 = test_and_clear_bit(1L, (unsigned long volatile   *)(& page->flags));
  }
#line 207
  return (tmp___7);
}
}
#line 208
__inline static int PageReferenced(struct page  const  *page )  __attribute__((__no_instrument_function__)) ;
#line 208 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int PageReferenced(struct page  const  *page ) 
{ 
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 208
  tmp___7 = constant_test_bit(2L, (unsigned long const volatile   *)(& page->flags));
  }
#line 208
  return (tmp___7);
}
}
#line 208
__inline static void SetPageReferenced(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 208 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void SetPageReferenced(struct page *page ) 
{ 


  {
  {
#line 208
  set_bit(2L, (unsigned long volatile   *)(& page->flags));
  }
#line 208
  return;
}
}
#line 208
__inline static void ClearPageReferenced(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 208 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void ClearPageReferenced(struct page *page ) 
{ 


  {
  {
#line 208
  clear_bit(2L, (unsigned long volatile   *)(& page->flags));
  }
#line 208
  return;
}
}
#line 208
__inline static int TestClearPageReferenced(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 208 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int TestClearPageReferenced(struct page *page ) 
{ 
  int tmp___7 ;

  {
  {
#line 208
  tmp___7 = test_and_clear_bit(2L, (unsigned long volatile   *)(& page->flags));
  }
#line 208
  return (tmp___7);
}
}
#line 209
__inline static void __SetPageReferenced(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 209 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void __SetPageReferenced(struct page *page ) 
{ 


  {
  {
#line 209
  __set_bit(2L, (unsigned long volatile   *)(& page->flags));
  }
#line 209
  return;
}
}
#line 210
__inline static int PageDirty(struct page  const  *page )  __attribute__((__no_instrument_function__)) ;
#line 210 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int PageDirty(struct page  const  *page ) 
{ 
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 210
  tmp___7 = constant_test_bit(4L, (unsigned long const volatile   *)(& page->flags));
  }
#line 210
  return (tmp___7);
}
}
#line 210
__inline static void SetPageDirty(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 210 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void SetPageDirty(struct page *page ) 
{ 


  {
  {
#line 210
  set_bit(4L, (unsigned long volatile   *)(& page->flags));
  }
#line 210
  return;
}
}
#line 210
__inline static void ClearPageDirty(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 210 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void ClearPageDirty(struct page *page ) 
{ 


  {
  {
#line 210
  clear_bit(4L, (unsigned long volatile   *)(& page->flags));
  }
#line 210
  return;
}
}
#line 210
__inline static int TestSetPageDirty(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 210 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int TestSetPageDirty(struct page *page ) 
{ 
  int tmp___7 ;

  {
  {
#line 210
  tmp___7 = test_and_set_bit(4L, (unsigned long volatile   *)(& page->flags));
  }
#line 210
  return (tmp___7);
}
}
#line 210
__inline static int TestClearPageDirty(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 210 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int TestClearPageDirty(struct page *page ) 
{ 
  int tmp___7 ;

  {
  {
#line 210
  tmp___7 = test_and_clear_bit(4L, (unsigned long volatile   *)(& page->flags));
  }
#line 210
  return (tmp___7);
}
}
#line 210
__inline static void __ClearPageDirty(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 210 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void __ClearPageDirty(struct page *page ) 
{ 


  {
  {
#line 210
  __clear_bit(4L, (unsigned long volatile   *)(& page->flags));
  }
#line 210
  return;
}
}
#line 211
__inline static int PageLRU(struct page  const  *page )  __attribute__((__no_instrument_function__)) ;
#line 211 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int PageLRU(struct page  const  *page ) 
{ 
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 211
  tmp___7 = constant_test_bit(5L, (unsigned long const volatile   *)(& page->flags));
  }
#line 211
  return (tmp___7);
}
}
#line 211
__inline static void SetPageLRU(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 211 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void SetPageLRU(struct page *page ) 
{ 


  {
  {
#line 211
  set_bit(5L, (unsigned long volatile   *)(& page->flags));
  }
#line 211
  return;
}
}
#line 211
__inline static void ClearPageLRU(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 211 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void ClearPageLRU(struct page *page ) 
{ 


  {
  {
#line 211
  clear_bit(5L, (unsigned long volatile   *)(& page->flags));
  }
#line 211
  return;
}
}
#line 211
__inline static void __ClearPageLRU(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 211 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void __ClearPageLRU(struct page *page ) 
{ 


  {
  {
#line 211
  __clear_bit(5L, (unsigned long volatile   *)(& page->flags));
  }
#line 211
  return;
}
}
#line 212
__inline static int PageActive(struct page  const  *page )  __attribute__((__no_instrument_function__)) ;
#line 212 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int PageActive(struct page  const  *page ) 
{ 
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 212
  tmp___7 = constant_test_bit(6L, (unsigned long const volatile   *)(& page->flags));
  }
#line 212
  return (tmp___7);
}
}
#line 212
__inline static void SetPageActive(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 212 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void SetPageActive(struct page *page ) 
{ 


  {
  {
#line 212
  set_bit(6L, (unsigned long volatile   *)(& page->flags));
  }
#line 212
  return;
}
}
#line 212
__inline static void ClearPageActive(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 212 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void ClearPageActive(struct page *page ) 
{ 


  {
  {
#line 212
  clear_bit(6L, (unsigned long volatile   *)(& page->flags));
  }
#line 212
  return;
}
}
#line 212
__inline static void __ClearPageActive(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 212 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void __ClearPageActive(struct page *page ) 
{ 


  {
  {
#line 212
  __clear_bit(6L, (unsigned long volatile   *)(& page->flags));
  }
#line 212
  return;
}
}
#line 213
__inline static int TestClearPageActive(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 213 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int TestClearPageActive(struct page *page ) 
{ 
  int tmp___7 ;

  {
  {
#line 213
  tmp___7 = test_and_clear_bit(6L, (unsigned long volatile   *)(& page->flags));
  }
#line 213
  return (tmp___7);
}
}
#line 214
__inline static int PageSlab(struct page  const  *page )  __attribute__((__no_instrument_function__)) ;
#line 214 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int PageSlab(struct page  const  *page ) 
{ 
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 214
  tmp___7 = constant_test_bit(7L, (unsigned long const volatile   *)(& page->flags));
  }
#line 214
  return (tmp___7);
}
}
#line 214
__inline static void __SetPageSlab(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 214 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void __SetPageSlab(struct page *page ) 
{ 


  {
  {
#line 214
  __set_bit(7L, (unsigned long volatile   *)(& page->flags));
  }
#line 214
  return;
}
}
#line 214
__inline static void __ClearPageSlab(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 214 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void __ClearPageSlab(struct page *page ) 
{ 


  {
  {
#line 214
  __clear_bit(7L, (unsigned long volatile   *)(& page->flags));
  }
#line 214
  return;
}
}
#line 215
__inline static int PageChecked(struct page  const  *page )  __attribute__((__no_instrument_function__)) ;
#line 215 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int PageChecked(struct page  const  *page ) 
{ 
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 215
  tmp___7 = constant_test_bit(8L, (unsigned long const volatile   *)(& page->flags));
  }
#line 215
  return (tmp___7);
}
}
#line 215
__inline static void SetPageChecked(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 215 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void SetPageChecked(struct page *page ) 
{ 


  {
  {
#line 215
  set_bit(8L, (unsigned long volatile   *)(& page->flags));
  }
#line 215
  return;
}
}
#line 215
__inline static void ClearPageChecked(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 215 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void ClearPageChecked(struct page *page ) 
{ 


  {
  {
#line 215
  clear_bit(8L, (unsigned long volatile   *)(& page->flags));
  }
#line 215
  return;
}
}
#line 216
__inline static int PagePinned(struct page  const  *page )  __attribute__((__no_instrument_function__)) ;
#line 216 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int PagePinned(struct page  const  *page ) 
{ 
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 216
  tmp___7 = constant_test_bit(8L, (unsigned long const volatile   *)(& page->flags));
  }
#line 216
  return (tmp___7);
}
}
#line 216
__inline static void SetPagePinned(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 216 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void SetPagePinned(struct page *page ) 
{ 


  {
  {
#line 216
  set_bit(8L, (unsigned long volatile   *)(& page->flags));
  }
#line 216
  return;
}
}
#line 216
__inline static void ClearPagePinned(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 216 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void ClearPagePinned(struct page *page ) 
{ 


  {
  {
#line 216
  clear_bit(8L, (unsigned long volatile   *)(& page->flags));
  }
#line 216
  return;
}
}
#line 216
__inline static int TestSetPagePinned(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 216 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int TestSetPagePinned(struct page *page ) 
{ 
  int tmp___7 ;

  {
  {
#line 216
  tmp___7 = test_and_set_bit(8L, (unsigned long volatile   *)(& page->flags));
  }
#line 216
  return (tmp___7);
}
}
#line 216
__inline static int TestClearPagePinned(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 216 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int TestClearPagePinned(struct page *page ) 
{ 
  int tmp___7 ;

  {
  {
#line 216
  tmp___7 = test_and_clear_bit(8L, (unsigned long volatile   *)(& page->flags));
  }
#line 216
  return (tmp___7);
}
}
#line 217
__inline static int PageSavePinned(struct page  const  *page )  __attribute__((__no_instrument_function__)) ;
#line 217 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int PageSavePinned(struct page  const  *page ) 
{ 
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 217
  tmp___7 = constant_test_bit(4L, (unsigned long const volatile   *)(& page->flags));
  }
#line 217
  return (tmp___7);
}
}
#line 217
__inline static void SetPageSavePinned(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 217 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void SetPageSavePinned(struct page *page ) 
{ 


  {
  {
#line 217
  set_bit(4L, (unsigned long volatile   *)(& page->flags));
  }
#line 217
  return;
}
}
#line 217
__inline static void ClearPageSavePinned(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 217 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void ClearPageSavePinned(struct page *page ) 
{ 


  {
  {
#line 217
  clear_bit(4L, (unsigned long volatile   *)(& page->flags));
  }
#line 217
  return;
}
}
#line 218
__inline static int PageReserved(struct page  const  *page )  __attribute__((__no_instrument_function__)) ;
#line 218 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int PageReserved(struct page  const  *page ) 
{ 
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 218
  tmp___7 = constant_test_bit(10L, (unsigned long const volatile   *)(& page->flags));
  }
#line 218
  return (tmp___7);
}
}
#line 218
__inline static void SetPageReserved(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 218 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void SetPageReserved(struct page *page ) 
{ 


  {
  {
#line 218
  set_bit(10L, (unsigned long volatile   *)(& page->flags));
  }
#line 218
  return;
}
}
#line 218
__inline static void ClearPageReserved(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 218 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void ClearPageReserved(struct page *page ) 
{ 


  {
  {
#line 218
  clear_bit(10L, (unsigned long volatile   *)(& page->flags));
  }
#line 218
  return;
}
}
#line 218
__inline static void __ClearPageReserved(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 218 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void __ClearPageReserved(struct page *page ) 
{ 


  {
  {
#line 218
  __clear_bit(10L, (unsigned long volatile   *)(& page->flags));
  }
#line 218
  return;
}
}
#line 219
__inline static int PageSwapBacked(struct page  const  *page )  __attribute__((__no_instrument_function__)) ;
#line 219 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int PageSwapBacked(struct page  const  *page ) 
{ 
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 219
  tmp___7 = constant_test_bit(19L, (unsigned long const volatile   *)(& page->flags));
  }
#line 219
  return (tmp___7);
}
}
#line 219
__inline static void SetPageSwapBacked(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 219 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void SetPageSwapBacked(struct page *page ) 
{ 


  {
  {
#line 219
  set_bit(19L, (unsigned long volatile   *)(& page->flags));
  }
#line 219
  return;
}
}
#line 219
__inline static void ClearPageSwapBacked(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 219 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void ClearPageSwapBacked(struct page *page ) 
{ 


  {
  {
#line 219
  clear_bit(19L, (unsigned long volatile   *)(& page->flags));
  }
#line 219
  return;
}
}
#line 219
__inline static void __ClearPageSwapBacked(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 219 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void __ClearPageSwapBacked(struct page *page ) 
{ 


  {
  {
#line 219
  __clear_bit(19L, (unsigned long volatile   *)(& page->flags));
  }
#line 219
  return;
}
}
#line 220
__inline static void __SetPageSwapBacked(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 220 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void __SetPageSwapBacked(struct page *page ) 
{ 


  {
  {
#line 220
  __set_bit(19L, (unsigned long volatile   *)(& page->flags));
  }
#line 220
  return;
}
}
#line 222
__inline static int PageSlobFree(struct page  const  *page )  __attribute__((__no_instrument_function__)) ;
#line 222 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int PageSlobFree(struct page  const  *page ) 
{ 
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 222
  tmp___7 = constant_test_bit(11L, (unsigned long const volatile   *)(& page->flags));
  }
#line 222
  return (tmp___7);
}
}
#line 222
__inline static void __SetPageSlobFree(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 222 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void __SetPageSlobFree(struct page *page ) 
{ 


  {
  {
#line 222
  __set_bit(11L, (unsigned long volatile   *)(& page->flags));
  }
#line 222
  return;
}
}
#line 222
__inline static void __ClearPageSlobFree(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 222 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void __ClearPageSlobFree(struct page *page ) 
{ 


  {
  {
#line 222
  __clear_bit(11L, (unsigned long volatile   *)(& page->flags));
  }
#line 222
  return;
}
}
#line 229
__inline static int PagePrivate(struct page  const  *page )  __attribute__((__no_instrument_function__)) ;
#line 229 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int PagePrivate(struct page  const  *page ) 
{ 
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 229
  tmp___7 = constant_test_bit(11L, (unsigned long const volatile   *)(& page->flags));
  }
#line 229
  return (tmp___7);
}
}
#line 229
__inline static void SetPagePrivate(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 229 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void SetPagePrivate(struct page *page ) 
{ 


  {
  {
#line 229
  set_bit(11L, (unsigned long volatile   *)(& page->flags));
  }
#line 229
  return;
}
}
#line 229
__inline static void ClearPagePrivate(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 229 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void ClearPagePrivate(struct page *page ) 
{ 


  {
  {
#line 229
  clear_bit(11L, (unsigned long volatile   *)(& page->flags));
  }
#line 229
  return;
}
}
#line 229
__inline static void __SetPagePrivate(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 229 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void __SetPagePrivate(struct page *page ) 
{ 


  {
  {
#line 229
  __set_bit(11L, (unsigned long volatile   *)(& page->flags));
  }
#line 229
  return;
}
}
#line 230
__inline static void __ClearPagePrivate(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 230 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void __ClearPagePrivate(struct page *page ) 
{ 


  {
  {
#line 230
  __clear_bit(11L, (unsigned long volatile   *)(& page->flags));
  }
#line 230
  return;
}
}
#line 231
__inline static int PagePrivate2(struct page  const  *page )  __attribute__((__no_instrument_function__)) ;
#line 231 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int PagePrivate2(struct page  const  *page ) 
{ 
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 231
  tmp___7 = constant_test_bit(12L, (unsigned long const volatile   *)(& page->flags));
  }
#line 231
  return (tmp___7);
}
}
#line 231
__inline static void SetPagePrivate2(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 231 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void SetPagePrivate2(struct page *page ) 
{ 


  {
  {
#line 231
  set_bit(12L, (unsigned long volatile   *)(& page->flags));
  }
#line 231
  return;
}
}
#line 231
__inline static void ClearPagePrivate2(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 231 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void ClearPagePrivate2(struct page *page ) 
{ 


  {
  {
#line 231
  clear_bit(12L, (unsigned long volatile   *)(& page->flags));
  }
#line 231
  return;
}
}
#line 231
__inline static int TestSetPagePrivate2(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 231 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int TestSetPagePrivate2(struct page *page ) 
{ 
  int tmp___7 ;

  {
  {
#line 231
  tmp___7 = test_and_set_bit(12L, (unsigned long volatile   *)(& page->flags));
  }
#line 231
  return (tmp___7);
}
}
#line 231
__inline static int TestClearPagePrivate2(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 231 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int TestClearPagePrivate2(struct page *page ) 
{ 
  int tmp___7 ;

  {
  {
#line 231
  tmp___7 = test_and_clear_bit(12L, (unsigned long volatile   *)(& page->flags));
  }
#line 231
  return (tmp___7);
}
}
#line 232
__inline static int PageOwnerPriv1(struct page  const  *page )  __attribute__((__no_instrument_function__)) ;
#line 232 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int PageOwnerPriv1(struct page  const  *page ) 
{ 
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 232
  tmp___7 = constant_test_bit(8L, (unsigned long const volatile   *)(& page->flags));
  }
#line 232
  return (tmp___7);
}
}
#line 232
__inline static void SetPageOwnerPriv1(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 232 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void SetPageOwnerPriv1(struct page *page ) 
{ 


  {
  {
#line 232
  set_bit(8L, (unsigned long volatile   *)(& page->flags));
  }
#line 232
  return;
}
}
#line 232
__inline static void ClearPageOwnerPriv1(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 232 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void ClearPageOwnerPriv1(struct page *page ) 
{ 


  {
  {
#line 232
  clear_bit(8L, (unsigned long volatile   *)(& page->flags));
  }
#line 232
  return;
}
}
#line 232
__inline static int TestClearPageOwnerPriv1(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 232 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int TestClearPageOwnerPriv1(struct page *page ) 
{ 
  int tmp___7 ;

  {
  {
#line 232
  tmp___7 = test_and_clear_bit(8L, (unsigned long volatile   *)(& page->flags));
  }
#line 232
  return (tmp___7);
}
}
#line 238
__inline static int PageWriteback(struct page  const  *page )  __attribute__((__no_instrument_function__)) ;
#line 238 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int PageWriteback(struct page  const  *page ) 
{ 
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 238
  tmp___7 = constant_test_bit(13L, (unsigned long const volatile   *)(& page->flags));
  }
#line 238
  return (tmp___7);
}
}
#line 238
__inline static int TestSetPageWriteback(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 238 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int TestSetPageWriteback(struct page *page ) 
{ 
  int tmp___7 ;

  {
  {
#line 238
  tmp___7 = test_and_set_bit(13L, (unsigned long volatile   *)(& page->flags));
  }
#line 238
  return (tmp___7);
}
}
#line 238
__inline static int TestClearPageWriteback(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 238 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int TestClearPageWriteback(struct page *page ) 
{ 
  int tmp___7 ;

  {
  {
#line 238
  tmp___7 = test_and_clear_bit(13L, (unsigned long volatile   *)(& page->flags));
  }
#line 238
  return (tmp___7);
}
}
#line 239
__inline static int PageMappedToDisk(struct page  const  *page )  __attribute__((__no_instrument_function__)) ;
#line 239 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int PageMappedToDisk(struct page  const  *page ) 
{ 
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 239
  tmp___7 = constant_test_bit(17L, (unsigned long const volatile   *)(& page->flags));
  }
#line 239
  return (tmp___7);
}
}
#line 239
__inline static void SetPageMappedToDisk(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 239 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void SetPageMappedToDisk(struct page *page ) 
{ 


  {
  {
#line 239
  set_bit(17L, (unsigned long volatile   *)(& page->flags));
  }
#line 239
  return;
}
}
#line 239
__inline static void ClearPageMappedToDisk(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 239 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void ClearPageMappedToDisk(struct page *page ) 
{ 


  {
  {
#line 239
  clear_bit(17L, (unsigned long volatile   *)(& page->flags));
  }
#line 239
  return;
}
}
#line 242
__inline static int PageReclaim(struct page  const  *page )  __attribute__((__no_instrument_function__)) ;
#line 242 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int PageReclaim(struct page  const  *page ) 
{ 
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 242
  tmp___7 = constant_test_bit(18L, (unsigned long const volatile   *)(& page->flags));
  }
#line 242
  return (tmp___7);
}
}
#line 242
__inline static void SetPageReclaim(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 242 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void SetPageReclaim(struct page *page ) 
{ 


  {
  {
#line 242
  set_bit(18L, (unsigned long volatile   *)(& page->flags));
  }
#line 242
  return;
}
}
#line 242
__inline static void ClearPageReclaim(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 242 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void ClearPageReclaim(struct page *page ) 
{ 


  {
  {
#line 242
  clear_bit(18L, (unsigned long volatile   *)(& page->flags));
  }
#line 242
  return;
}
}
#line 242
__inline static int TestClearPageReclaim(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 242 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int TestClearPageReclaim(struct page *page ) 
{ 
  int tmp___7 ;

  {
  {
#line 242
  tmp___7 = test_and_clear_bit(18L, (unsigned long volatile   *)(& page->flags));
  }
#line 242
  return (tmp___7);
}
}
#line 243
__inline static int PageReadahead(struct page  const  *page )  __attribute__((__no_instrument_function__)) ;
#line 243 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int PageReadahead(struct page  const  *page ) 
{ 
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 243
  tmp___7 = constant_test_bit(18L, (unsigned long const volatile   *)(& page->flags));
  }
#line 243
  return (tmp___7);
}
}
#line 243
__inline static void SetPageReadahead(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 243 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void SetPageReadahead(struct page *page ) 
{ 


  {
  {
#line 243
  set_bit(18L, (unsigned long volatile   *)(& page->flags));
  }
#line 243
  return;
}
}
#line 243
__inline static void ClearPageReadahead(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 243 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void ClearPageReadahead(struct page *page ) 
{ 


  {
  {
#line 243
  clear_bit(18L, (unsigned long volatile   *)(& page->flags));
  }
#line 243
  return;
}
}
#line 243
__inline static int TestClearPageReadahead(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 243 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int TestClearPageReadahead(struct page *page ) 
{ 
  int tmp___7 ;

  {
  {
#line 243
  tmp___7 = test_and_clear_bit(18L, (unsigned long volatile   *)(& page->flags));
  }
#line 243
  return (tmp___7);
}
}
#line 252
__inline static int PageHighMem(struct page  const  *page )  __attribute__((__no_instrument_function__)) ;
#line 252 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int PageHighMem(struct page  const  *page ) 
{ 


  {
#line 252
  return (0);
}
}
#line 252
__inline static void SetPageHighMem(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 252 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void SetPageHighMem(struct page *page ) 
{ 


  {
#line 252
  return;
}
}
#line 252
__inline static void ClearPageHighMem(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 252 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void ClearPageHighMem(struct page *page ) 
{ 


  {
#line 252
  return;
}
}
#line 256
__inline static int PageSwapCache(struct page  const  *page )  __attribute__((__no_instrument_function__)) ;
#line 256 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int PageSwapCache(struct page  const  *page ) 
{ 
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 256
  tmp___7 = constant_test_bit(16L, (unsigned long const volatile   *)(& page->flags));
  }
#line 256
  return (tmp___7);
}
}
#line 256
__inline static void SetPageSwapCache(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 256 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void SetPageSwapCache(struct page *page ) 
{ 


  {
  {
#line 256
  set_bit(16L, (unsigned long volatile   *)(& page->flags));
  }
#line 256
  return;
}
}
#line 256
__inline static void ClearPageSwapCache(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 256 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void ClearPageSwapCache(struct page *page ) 
{ 


  {
  {
#line 256
  clear_bit(16L, (unsigned long volatile   *)(& page->flags));
  }
#line 256
  return;
}
}
#line 261
__inline static int PageUnevictable(struct page  const  *page )  __attribute__((__no_instrument_function__)) ;
#line 261 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int PageUnevictable(struct page  const  *page ) 
{ 
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 261
  tmp___7 = constant_test_bit(20L, (unsigned long const volatile   *)(& page->flags));
  }
#line 261
  return (tmp___7);
}
}
#line 261
__inline static void SetPageUnevictable(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 261 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void SetPageUnevictable(struct page *page ) 
{ 


  {
  {
#line 261
  set_bit(20L, (unsigned long volatile   *)(& page->flags));
  }
#line 261
  return;
}
}
#line 261
__inline static void ClearPageUnevictable(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 261 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void ClearPageUnevictable(struct page *page ) 
{ 


  {
  {
#line 261
  clear_bit(20L, (unsigned long volatile   *)(& page->flags));
  }
#line 261
  return;
}
}
#line 261
__inline static void __ClearPageUnevictable(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 261 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void __ClearPageUnevictable(struct page *page ) 
{ 


  {
  {
#line 261
  __clear_bit(20L, (unsigned long volatile   *)(& page->flags));
  }
#line 261
  return;
}
}
#line 262
__inline static int TestClearPageUnevictable(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 262 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int TestClearPageUnevictable(struct page *page ) 
{ 
  int tmp___7 ;

  {
  {
#line 262
  tmp___7 = test_and_clear_bit(20L, (unsigned long volatile   *)(& page->flags));
  }
#line 262
  return (tmp___7);
}
}
#line 265
__inline static int PageMlocked(struct page  const  *page )  __attribute__((__no_instrument_function__)) ;
#line 265 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int PageMlocked(struct page  const  *page ) 
{ 
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 265
  tmp___7 = constant_test_bit(21L, (unsigned long const volatile   *)(& page->flags));
  }
#line 265
  return (tmp___7);
}
}
#line 265
__inline static void SetPageMlocked(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 265 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void SetPageMlocked(struct page *page ) 
{ 


  {
  {
#line 265
  set_bit(21L, (unsigned long volatile   *)(& page->flags));
  }
#line 265
  return;
}
}
#line 265
__inline static void ClearPageMlocked(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 265 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void ClearPageMlocked(struct page *page ) 
{ 


  {
  {
#line 265
  clear_bit(21L, (unsigned long volatile   *)(& page->flags));
  }
#line 265
  return;
}
}
#line 265
__inline static void __ClearPageMlocked(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 265 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void __ClearPageMlocked(struct page *page ) 
{ 


  {
  {
#line 265
  __clear_bit(21L, (unsigned long volatile   *)(& page->flags));
  }
#line 265
  return;
}
}
#line 266
__inline static int TestSetPageMlocked(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 266 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int TestSetPageMlocked(struct page *page ) 
{ 
  int tmp___7 ;

  {
  {
#line 266
  tmp___7 = test_and_set_bit(21L, (unsigned long volatile   *)(& page->flags));
  }
#line 266
  return (tmp___7);
}
}
#line 266
__inline static int TestClearPageMlocked(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 266 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int TestClearPageMlocked(struct page *page ) 
{ 
  int tmp___7 ;

  {
  {
#line 266
  tmp___7 = test_and_clear_bit(21L, (unsigned long volatile   *)(& page->flags));
  }
#line 266
  return (tmp___7);
}
}
#line 266
__inline static int __TestClearPageMlocked(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 266 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int __TestClearPageMlocked(struct page *page ) 
{ 
  int tmp___7 ;

  {
  {
#line 266
  tmp___7 = __test_and_clear_bit(21L, (unsigned long volatile   *)(& page->flags));
  }
#line 266
  return (tmp___7);
}
}
#line 273
__inline static int PageUncached(struct page  const  *page )  __attribute__((__no_instrument_function__)) ;
#line 273 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int PageUncached(struct page  const  *page ) 
{ 
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 273
  tmp___7 = constant_test_bit(22L, (unsigned long const volatile   *)(& page->flags));
  }
#line 273
  return (tmp___7);
}
}
#line 273
__inline static void SetPageUncached(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 273 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void SetPageUncached(struct page *page ) 
{ 


  {
  {
#line 273
  set_bit(22L, (unsigned long volatile   *)(& page->flags));
  }
#line 273
  return;
}
}
#line 273
__inline static void ClearPageUncached(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 273 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void ClearPageUncached(struct page *page ) 
{ 


  {
  {
#line 273
  clear_bit(22L, (unsigned long volatile   *)(& page->flags));
  }
#line 273
  return;
}
}
#line 283
__inline static int PageHWPoison(struct page  const  *page )  __attribute__((__no_instrument_function__)) ;
#line 283 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int PageHWPoison(struct page  const  *page ) 
{ 


  {
#line 283
  return (0);
}
}
#line 283
__inline static void SetPageHWPoison(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 283 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void SetPageHWPoison(struct page *page ) 
{ 


  {
#line 283
  return;
}
}
#line 283
__inline static void ClearPageHWPoison(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 283 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void ClearPageHWPoison(struct page *page ) 
{ 


  {
#line 283
  return;
}
}
#line 287
extern u64 stable_page_flags(struct page *page ) ;
#line 289
__inline static int PageUptodate(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 289 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int PageUptodate(struct page *page ) 
{ 
  int ret ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 291
  tmp___7 = constant_test_bit(3L, (unsigned long const volatile   *)(& page->flags));
#line 291
  ret = tmp___7;
  }
#line 301
  if (ret) {
    {
#line 302
    __asm__  volatile   ("": : : "memory");
    }
  }
#line 304
  return (ret);
}
}
#line 307
__inline static void __SetPageUptodate(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 307 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void __SetPageUptodate(struct page *page ) 
{ 


  {
  {
#line 309
  __asm__  volatile   ("": : : "memory");
#line 310
  __set_bit(3L, (unsigned long volatile   *)(& page->flags));
  }
#line 311
  return;
}
}
#line 313
__inline static void SetPageUptodate(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 313 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void SetPageUptodate(struct page *page ) 
{ 


  {
  {
#line 320
  __asm__  volatile   ("": : : "memory");
#line 321
  set_bit(3L, (unsigned long volatile   *)(& page->flags));
  }
#line 322
  return;
}
}
#line 324
__inline static void ClearPageUptodate(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 324 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void ClearPageUptodate(struct page *page ) 
{ 


  {
  {
#line 324
  clear_bit(3L, (unsigned long volatile   *)(& page->flags));
  }
#line 324
  return;
}
}
#line 326
extern void cancel_dirty_page(struct page *page , unsigned int account_size ) ;
#line 328
extern int test_clear_page_writeback(struct page *page ) ;
#line 329
extern int __test_set_page_writeback(struct page *page , bool keep_write ) ;
#line 336
__inline static void set_page_writeback(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 336 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void set_page_writeback(struct page *page ) 
{ 


  {
  {
#line 338
  __test_set_page_writeback(page, (bool )0);
  }
#line 339
  return;
}
}
#line 341
__inline static void set_page_writeback_keepwrite(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 341 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void set_page_writeback_keepwrite(struct page *page ) 
{ 


  {
  {
#line 343
  __test_set_page_writeback(page, (bool )1);
  }
#line 344
  return;
}
}
#line 355
__inline static int PageHead(struct page  const  *page )  __attribute__((__no_instrument_function__)) ;
#line 355 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int PageHead(struct page  const  *page ) 
{ 
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 355
  tmp___7 = constant_test_bit(14L, (unsigned long const volatile   *)(& page->flags));
  }
#line 355
  return (tmp___7);
}
}
#line 355
__inline static void __SetPageHead(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 355 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void __SetPageHead(struct page *page ) 
{ 


  {
  {
#line 355
  __set_bit(14L, (unsigned long volatile   *)(& page->flags));
  }
#line 355
  return;
}
}
#line 355
__inline static void __ClearPageHead(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 355 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void __ClearPageHead(struct page *page ) 
{ 


  {
  {
#line 355
  __clear_bit(14L, (unsigned long volatile   *)(& page->flags));
  }
#line 355
  return;
}
}
#line 355
__inline static void ClearPageHead(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 355 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void ClearPageHead(struct page *page ) 
{ 


  {
  {
#line 355
  clear_bit(14L, (unsigned long volatile   *)(& page->flags));
  }
#line 355
  return;
}
}
#line 356
__inline static int PageTail(struct page  const  *page )  __attribute__((__no_instrument_function__)) ;
#line 356 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int PageTail(struct page  const  *page ) 
{ 
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 356
  tmp___7 = constant_test_bit(15L, (unsigned long const volatile   *)(& page->flags));
  }
#line 356
  return (tmp___7);
}
}
#line 356
__inline static void __SetPageTail(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 356 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void __SetPageTail(struct page *page ) 
{ 


  {
  {
#line 356
  __set_bit(15L, (unsigned long volatile   *)(& page->flags));
  }
#line 356
  return;
}
}
#line 356
__inline static void __ClearPageTail(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 356 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void __ClearPageTail(struct page *page ) 
{ 


  {
  {
#line 356
  __clear_bit(15L, (unsigned long volatile   *)(& page->flags));
  }
#line 356
  return;
}
}
#line 358
__inline static int PageCompound(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 358 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int PageCompound(struct page *page ) 
{ 


  {
#line 360
  return ((int )(page->flags & (unsigned long )((1L << 14) | (1L << 15))));
}
}
#line 463
__inline static int PageTransHuge(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 463 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int PageTransHuge(struct page *page ) 
{ 


  {
#line 465
  return (0);
}
}
#line 468
__inline static int PageTransCompound(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 468 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int PageTransCompound(struct page *page ) 
{ 


  {
#line 470
  return (0);
}
}
#line 473
__inline static int PageTransTail(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 473 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int PageTransTail(struct page *page ) 
{ 


  {
#line 475
  return (0);
}
}
#line 483
__inline static int PageSlabPfmemalloc(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 483 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int PageSlabPfmemalloc(struct page *page ) 
{ 
  int tmp___7 ;

  {
  {
#line 486
  tmp___7 = PageActive((struct page  const  *)page);
  }
#line 486
  return (tmp___7);
}
}
#line 489
__inline static void SetPageSlabPfmemalloc(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 489 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void SetPageSlabPfmemalloc(struct page *page ) 
{ 


  {
  {
#line 492
  SetPageActive(page);
  }
#line 493
  return;
}
}
#line 495
__inline static void __ClearPageSlabPfmemalloc(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 495 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void __ClearPageSlabPfmemalloc(struct page *page ) 
{ 


  {
  {
#line 498
  __ClearPageActive(page);
  }
#line 499
  return;
}
}
#line 501
__inline static void ClearPageSlabPfmemalloc(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 501 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static void ClearPageSlabPfmemalloc(struct page *page ) 
{ 


  {
  {
#line 504
  ClearPageActive(page);
  }
#line 505
  return;
}
}
#line 547
__inline static int page_has_private(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 547 "../../../analyzer/../bench/linux-headers/include/linux/page-flags.h"
__inline static int page_has_private(struct page *page ) 
{ 


  {
#line 549
  return (! (! (page->flags & (unsigned long )((1 << 11) | (1 << 12)))));
}
}
#line 4 "../../../analyzer/../bench/linux-headers/include/linux/huge_mm.h"
extern int do_huge_pmd_anonymous_page(struct mm_struct *mm , struct vm_area_struct *vma ,
                                      unsigned long address , pmd_t *pmd , unsigned int flags ) ;
#line 8
extern int copy_huge_pmd(struct mm_struct *dst_mm , struct mm_struct *src_mm , pmd_t *dst_pmd ,
                         pmd_t *src_pmd , unsigned long addr , struct vm_area_struct *vma ) ;
#line 11
extern void huge_pmd_set_accessed(struct mm_struct *mm , struct vm_area_struct *vma ,
                                  unsigned long address , pmd_t *pmd , pmd_t orig_pmd ,
                                  int dirty ) ;
#line 15
extern int do_huge_pmd_wp_page(struct mm_struct *mm , struct vm_area_struct *vma ,
                               unsigned long address , pmd_t *pmd , pmd_t orig_pmd ) ;
#line 18
extern struct page *follow_trans_huge_pmd(struct vm_area_struct *vma , unsigned long addr ,
                                          pmd_t *pmd , unsigned int flags ) ;
#line 22
extern int zap_huge_pmd(struct mmu_gather *tlb , struct vm_area_struct *vma , pmd_t *pmd ,
                        unsigned long addr ) ;
#line 25
extern int mincore_huge_pmd(struct vm_area_struct *vma , pmd_t *pmd , unsigned long addr ,
                            unsigned long end , unsigned char *vec ) ;
#line 28
extern int move_huge_pmd(struct vm_area_struct *vma , struct vm_area_struct *new_vma ,
                         unsigned long old_addr , unsigned long new_addr , unsigned long old_end ,
                         pmd_t *old_pmd , pmd_t *new_pmd ) ;
#line 33
extern int change_huge_pmd(struct vm_area_struct *vma , pmd_t *pmd , unsigned long addr ,
                           pgprot_t newprot , int prot_numa ) ;
#line 54
extern pmd_t *page_check_address_pmd(struct page *page , struct mm_struct *mm , unsigned long address ,
                                     enum page_check_address_pmd_flag flag , spinlock_t **ptl ) ;
#line 170
__inline static int split_huge_page_to_list(struct page *page , struct list_head *list )  __attribute__((__no_instrument_function__)) ;
#line 170 "../../../analyzer/../bench/linux-headers/include/linux/huge_mm.h"
__inline static int split_huge_page_to_list(struct page *page , struct list_head *list ) 
{ 


  {
#line 173
  return (0);
}
}
#line 175
__inline static int split_huge_page(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 175 "../../../analyzer/../bench/linux-headers/include/linux/huge_mm.h"
__inline static int split_huge_page(struct page *page ) 
{ 


  {
#line 177
  return (0);
}
}
#line 185
__inline static int hugepage_madvise(struct vm_area_struct *vma , unsigned long *vm_flags ,
                                     int advice )  __attribute__((__no_instrument_function__)) ;
#line 185 "../../../analyzer/../bench/linux-headers/include/linux/huge_mm.h"
__inline static int hugepage_madvise(struct vm_area_struct *vma , unsigned long *vm_flags ,
                                     int advice ) 
{ 


  {
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 188
    __asm__  volatile   ("1:\tud2\n"
                         ".pushsection __bug_table,\"a\"\n"
                         "2:\t.long 1b - 2b, %c0 - 2b\n"
                         "\t.word %c1, 0\n"
                         "\t.org 2b+%c2\n"
                         ".popsection": : "i" ("../../../analyzer/../bench/linux-headers/include/linux/huge_mm.h"),
                         "i" (188), "i" (sizeof(struct bug_entry )));
#line 188
    __builtin_unreachable();
    }
#line 188
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 189
  return (0);
}
}
#line 191
__inline static void vma_adjust_trans_huge(struct vm_area_struct *vma , unsigned long start ,
                                           unsigned long end , long adjust_next )  __attribute__((__no_instrument_function__)) ;
#line 191 "../../../analyzer/../bench/linux-headers/include/linux/huge_mm.h"
__inline static void vma_adjust_trans_huge(struct vm_area_struct *vma , unsigned long start ,
                                           unsigned long end , long adjust_next ) 
{ 


  {
#line 196
  return;
}
}
#line 197
__inline static int pmd_trans_huge_lock(pmd_t *pmd , struct vm_area_struct *vma ,
                                        spinlock_t **ptl )  __attribute__((__no_instrument_function__)) ;
#line 197 "../../../analyzer/../bench/linux-headers/include/linux/huge_mm.h"
__inline static int pmd_trans_huge_lock(pmd_t *pmd , struct vm_area_struct *vma ,
                                        spinlock_t **ptl ) 
{ 


  {
#line 200
  return (0);
}
}
#line 203
__inline static int do_huge_pmd_numa_page(struct mm_struct *mm , struct vm_area_struct *vma ,
                                          unsigned long addr , pmd_t pmd , pmd_t *pmdp )  __attribute__((__no_instrument_function__)) ;
#line 203 "../../../analyzer/../bench/linux-headers/include/linux/huge_mm.h"
__inline static int do_huge_pmd_numa_page(struct mm_struct *mm , struct vm_area_struct *vma ,
                                          unsigned long addr , pmd_t pmd , pmd_t *pmdp ) 
{ 


  {
#line 206
  return (0);
}
}
#line 319 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static int put_page_testzero(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 319 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static int put_page_testzero(struct page *page ) 
{ 
  int tmp___7 ;

  {
  {
#line 322
  tmp___7 = atomic_dec_and_test(& page->__annonCompField27.__annonCompField26.__annonCompField25._count);
  }
#line 322
  return (tmp___7);
}
}
#line 331
__inline static int get_page_unless_zero(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 331 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static int get_page_unless_zero(struct page *page ) 
{ 
  int tmp___7 ;

  {
  {
#line 333
  tmp___7 = atomic_add_unless(& page->__annonCompField27.__annonCompField26.__annonCompField25._count,
                              1, 0);
  }
#line 333
  return (tmp___7);
}
}
#line 343
__inline static int put_page_unless_one(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 343 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static int put_page_unless_one(struct page *page ) 
{ 
  int tmp___7 ;

  {
  {
#line 345
  tmp___7 = atomic_add_unless(& page->__annonCompField27.__annonCompField26.__annonCompField25._count,
                              -1, 1);
  }
#line 345
  return (tmp___7);
}
}
#line 348
extern int page_is_ram(unsigned long pfn ) ;
#line 351
extern struct page *vmalloc_to_page(void const   *addr ) ;
#line 352
extern unsigned long vmalloc_to_pfn(void const   *addr ) ;
#line 360
__inline static int is_vmalloc_addr(void const   *x )  __attribute__((__no_instrument_function__)) ;
#line 360 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static int is_vmalloc_addr(void const   *x ) 
{ 
  unsigned long addr ;
  int tmp___7 ;

  {
  {
#line 363
  addr = (unsigned long )x;
  }
#line 365
  if (addr >= 0xffffc90000000000UL) {
#line 365
    if (addr < 0xffffe8ffffffffffUL) {
      {
#line 365
      tmp___7 = 1;
      }
    } else {
      {
#line 365
      tmp___7 = 0;
      }
    }
  } else {
    {
#line 365
    tmp___7 = 0;
    }
  }
#line 365
  return (tmp___7);
}
}
#line 371
extern int is_vmalloc_or_module_addr(void const   *x ) ;
#line 379
extern void kvfree(void const   *addr ) ;
#line 381
__inline static void compound_lock(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 381 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void compound_lock(struct page *page ) 
{ 


  {
#line 387
  return;
}
}
#line 389
__inline static void compound_unlock(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 389 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void compound_unlock(struct page *page ) 
{ 


  {
#line 395
  return;
}
}
#line 397
__inline static unsigned long compound_lock_irqsave(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 397 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static unsigned long compound_lock_irqsave(struct page *page ) 
{ 
  unsigned long flags ;

  {
  {
#line 399
  flags = flags;
  }
#line 404
  return (flags);
}
}
#line 407
__inline static void compound_unlock_irqrestore(struct page *page , unsigned long flags )  __attribute__((__no_instrument_function__)) ;
#line 407 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void compound_unlock_irqrestore(struct page *page , unsigned long flags ) 
{ 


  {
#line 414
  return;
}
}
#line 416
__inline static struct page *compound_head_by_tail(struct page *tail )  __attribute__((__no_instrument_function__)) ;
#line 416 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static struct page *compound_head_by_tail(struct page *tail ) 
{ 
  struct page *head ;
  int tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;

  {
  {
#line 418
  head = tail->__annonCompField30.first_page;
#line 425
  __asm__  volatile   ("": : : "memory");
#line 426
  tmp___7 = PageTail((struct page  const  *)tail);
  }
#line 426
  if (tmp___7) {
    {
#line 426
    tmp___8 = 1;
    }
  } else {
    {
#line 426
    tmp___8 = 0;
    }
  }
  {
#line 426
  tmp___9 = __builtin_expect((long )tmp___8, 1L);
  }
#line 426
  if (tmp___9) {
#line 427
    return (head);
  }
#line 428
  return (tail);
}
}
#line 431
__inline static struct page *compound_head(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 431 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static struct page *compound_head(struct page *page ) 
{ 
  struct page *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;

  {
  {
#line 433
  tmp___8 = PageTail((struct page  const  *)page);
  }
#line 433
  if (tmp___8) {
    {
#line 433
    tmp___9 = 1;
    }
  } else {
    {
#line 433
    tmp___9 = 0;
    }
  }
  {
#line 433
  tmp___10 = __builtin_expect((long )tmp___9, 0L);
  }
#line 433
  if (tmp___10) {
    {
#line 434
    tmp___7 = compound_head_by_tail(page);
    }
#line 434
    return (tmp___7);
  }
#line 435
  return (page);
}
}
#line 443
__inline static void page_mapcount_reset(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 443 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void page_mapcount_reset(struct page *page ) 
{ 


  {
  {
#line 445
  atomic_set(& page->__annonCompField27.__annonCompField26.__annonCompField25.__annonCompField24._mapcount,
             -1);
  }
#line 446
  return;
}
}
#line 448
__inline static int page_mapcount(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 448 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static int page_mapcount(struct page *page ) 
{ 
  int tmp___7 ;

  {
  {
#line 450
  tmp___7 = atomic_read((atomic_t const   *)(& page->__annonCompField27.__annonCompField26.__annonCompField25.__annonCompField24._mapcount));
  }
#line 450
  return (tmp___7 + 1);
}
}
#line 453
__inline static int page_count(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 453 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static int page_count(struct page *page ) 
{ 
  struct page *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 455
  tmp___7 = compound_head(page);
#line 455
  tmp___8 = atomic_read((atomic_t const   *)(& tmp___7->__annonCompField27.__annonCompField26.__annonCompField25._count));
  }
#line 455
  return (tmp___8);
}
}
#line 459
extern int PageHeadHuge(struct page *page_head ) ;
#line 467
__inline static bool __compound_tail_refcounted(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 467 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static bool __compound_tail_refcounted(struct page *page ) 
{ 
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 469
  tmp___7 = PageSlab((struct page  const  *)page);
  }
#line 469
  if (tmp___7) {
    {
#line 469
    tmp___9 = 0;
    }
  } else {
    {
#line 469
    tmp___8 = PageHeadHuge(page);
    }
#line 469
    if (tmp___8) {
      {
#line 469
      tmp___9 = 0;
      }
    } else {
      {
#line 469
      tmp___9 = 1;
      }
    }
  }
#line 469
  return ((bool )tmp___9);
}
}
#line 480
__inline static bool compound_tail_refcounted(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 480 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static bool compound_tail_refcounted(struct page *page ) 
{ 
  bool tmp___7 ;

  {
  {
#line 483
  tmp___7 = __compound_tail_refcounted(page);
  }
#line 483
  return (tmp___7);
}
}
#line 486
__inline static void get_huge_page_tail(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 486 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void get_huge_page_tail(struct page *page ) 
{ 
  bool tmp___7 ;

  {
  {
#line 494
  tmp___7 = compound_tail_refcounted(page->__annonCompField30.first_page);
  }
#line 494
  if (tmp___7) {
    {
#line 495
    atomic_inc(& page->__annonCompField27.__annonCompField26.__annonCompField25.__annonCompField24._mapcount);
    }
  }
#line 496
  return;
}
}
#line 498
extern bool __get_page_tail(struct page *page ) ;
#line 500
__inline static void get_page(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 500 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void get_page(struct page *page ) 
{ 
  bool tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  long tmp___12 ;

  {
  {
#line 502
  tmp___10 = PageTail((struct page  const  *)page);
  }
#line 502
  if (tmp___10) {
    {
#line 502
    tmp___11 = 1;
    }
  } else {
    {
#line 502
    tmp___11 = 0;
    }
  }
  {
#line 502
  tmp___12 = __builtin_expect((long )tmp___11, 0L);
  }
#line 502
  if (tmp___12) {
    {
#line 503
    tmp___7 = __get_page_tail(page);
    }
#line 503
    if (tmp___7) {
      {
#line 503
      tmp___8 = 1;
      }
    } else {
      {
#line 503
      tmp___8 = 0;
      }
    }
    {
#line 503
    tmp___9 = __builtin_expect((long )tmp___8, 1L);
    }
#line 503
    if (tmp___9) {
#line 504
      return;
    }
  }
  {
#line 510
  atomic_inc(& page->__annonCompField27.__annonCompField26.__annonCompField25._count);
  }
#line 511
  return;
}
}
#line 513
__inline static struct page *virt_to_head_page(void const   *x )  __attribute__((__no_instrument_function__)) ;
#line 513 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static struct page *virt_to_head_page(void const   *x ) 
{ 
  struct page *page ;
  unsigned long tmp___7 ;
  struct page *tmp___8 ;

  {
  {
#line 515
  tmp___7 = __phys_addr_nodebug((unsigned long )x);
#line 515
  page = (struct page *)0xffffea0000000000UL + (tmp___7 >> 12);
#line 516
  tmp___8 = compound_head(page);
  }
#line 516
  return (tmp___8);
}
}
#line 523
__inline static void init_page_count(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 523 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void init_page_count(struct page *page ) 
{ 


  {
  {
#line 525
  atomic_set(& page->__annonCompField27.__annonCompField26.__annonCompField25._count,
             1);
  }
#line 526
  return;
}
}
#line 539
__inline static int PageBuddy(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 539 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static int PageBuddy(struct page *page ) 
{ 
  int tmp___7 ;

  {
  {
#line 541
  tmp___7 = atomic_read((atomic_t const   *)(& page->__annonCompField27.__annonCompField26.__annonCompField25.__annonCompField24._mapcount));
  }
#line 541
  return (tmp___7 == -128);
}
}
#line 544
__inline static void __SetPageBuddy(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 544 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void __SetPageBuddy(struct page *page ) 
{ 


  {
  {
#line 547
  atomic_set(& page->__annonCompField27.__annonCompField26.__annonCompField25.__annonCompField24._mapcount,
             -128);
  }
#line 548
  return;
}
}
#line 550
__inline static void __ClearPageBuddy(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 550 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void __ClearPageBuddy(struct page *page ) 
{ 


  {
  {
#line 553
  atomic_set(& page->__annonCompField27.__annonCompField26.__annonCompField25.__annonCompField24._mapcount,
             -1);
  }
#line 554
  return;
}
}
#line 556
extern void put_page(struct page *page ) ;
#line 557
extern void put_pages_list(struct list_head *pages ) ;
#line 559
extern void split_page(struct page *page , unsigned int order ) ;
#line 560
extern int split_free_page(struct page *page ) ;
#line 569
__inline static void set_compound_page_dtor(struct page *page , compound_page_dtor *dtor )  __attribute__((__no_instrument_function__)) ;
#line 569 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void set_compound_page_dtor(struct page *page , compound_page_dtor *dtor ) 
{ 


  {
  {
#line 572
  (page + 1)->__annonCompField29.lru.next = (struct list_head *)((void *)dtor);
  }
#line 573
  return;
}
}
#line 575
__inline static compound_page_dtor *get_compound_page_dtor(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 575 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static compound_page_dtor *get_compound_page_dtor(struct page *page ) 
{ 


  {
#line 577
  return ((compound_page_dtor *)(page + 1)->__annonCompField29.lru.next);
}
}
#line 580
__inline static int compound_order(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 580 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static int compound_order(struct page *page ) 
{ 
  int tmp___7 ;

  {
  {
#line 582
  tmp___7 = PageHead((struct page  const  *)page);
  }
#line 582
  if (! tmp___7) {
#line 583
    return (0);
  }
#line 584
  return ((int )((unsigned long )(page + 1)->__annonCompField29.lru.prev));
}
}
#line 587
__inline static void set_compound_order(struct page *page , unsigned long order )  __attribute__((__no_instrument_function__)) ;
#line 587 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void set_compound_order(struct page *page , unsigned long order ) 
{ 


  {
  {
#line 589
  (page + 1)->__annonCompField29.lru.prev = (struct list_head *)((void *)order);
  }
#line 590
  return;
}
}
#line 599
__inline static pte_t maybe_mkwrite(pte_t pte , struct vm_area_struct *vma )  __attribute__((__no_instrument_function__)) ;
#line 599 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static pte_t maybe_mkwrite(pte_t pte , struct vm_area_struct *vma ) 
{ 
  long tmp___7 ;

  {
  {
#line 601
  tmp___7 = __builtin_expect((long )(! (! (vma->vm_flags & 2UL))), 1L);
  }
#line 601
  if (tmp___7) {
    {
#line 602
    pte = pte_mkwrite(pte);
    }
  }
#line 603
  return (pte);
}
}
#line 606
extern void do_set_pte(struct vm_area_struct *vma , unsigned long address , struct page *page ,
                       pte_t *pte , bool write , bool anon ) ;
#line 714
__inline static enum zone_type page_zonenum(struct page  const  *page )  __attribute__((__no_instrument_function__)) ;
#line 714 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static enum zone_type page_zonenum(struct page  const  *page ) 
{ 


  {
#line 716
  return ((enum zone_type )((page->flags >> ((sizeof(unsigned long ) * 8UL - 6UL) - 2UL)) & (unsigned long const   )((1UL << 2) - 1UL)));
}
}
#line 731
__inline static int page_zone_id(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 731 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static int page_zone_id(struct page *page ) 
{ 
  unsigned long tmp___7 ;

  {
#line 733
  if (sizeof(unsigned long ) * 8UL - 6UL < (sizeof(unsigned long ) * 8UL - 6UL) - 2UL) {
    {
#line 733
    tmp___7 = sizeof(unsigned long ) * 8UL - 6UL;
    }
  } else {
    {
#line 733
    tmp___7 = (sizeof(unsigned long ) * 8UL - 6UL) - 2UL;
    }
  }
#line 733
  return ((int )((page->flags >> tmp___7) & ((1UL << 8) - 1UL)));
}
}
#line 736
__inline static int zone_to_nid(struct zone *zone )  __attribute__((__no_instrument_function__)) ;
#line 736 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static int zone_to_nid(struct zone *zone ) 
{ 


  {
#line 739
  return (zone->node);
}
}
#line 748
__inline static int page_to_nid(struct page  const  *page )  __attribute__((__no_instrument_function__)) ;
#line 748 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static int page_to_nid(struct page  const  *page ) 
{ 


  {
#line 750
  return ((int )((page->flags >> (sizeof(unsigned long ) * 8UL - 6UL)) & (unsigned long const   )((1UL << 6) - 1UL)));
}
}
#line 822
__inline static int page_cpupid_xchg_last(struct page *page , int cpupid )  __attribute__((__no_instrument_function__)) ;
#line 822 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static int page_cpupid_xchg_last(struct page *page , int cpupid ) 
{ 
  int tmp___7 ;

  {
  {
#line 824
  tmp___7 = page_to_nid((struct page  const  *)page);
  }
#line 824
  return (tmp___7);
}
}
#line 827
__inline static int page_cpupid_last(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 827 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static int page_cpupid_last(struct page *page ) 
{ 
  int tmp___7 ;

  {
  {
#line 829
  tmp___7 = page_to_nid((struct page  const  *)page);
  }
#line 829
  return (tmp___7);
}
}
#line 832
__inline static int cpupid_to_nid(int cpupid )  __attribute__((__no_instrument_function__)) ;
#line 832 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static int cpupid_to_nid(int cpupid ) 
{ 


  {
#line 834
  return (-1);
}
}
#line 837
__inline static int cpupid_to_pid(int cpupid )  __attribute__((__no_instrument_function__)) ;
#line 837 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static int cpupid_to_pid(int cpupid ) 
{ 


  {
#line 839
  return (-1);
}
}
#line 842
__inline static int cpupid_to_cpu(int cpupid )  __attribute__((__no_instrument_function__)) ;
#line 842 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static int cpupid_to_cpu(int cpupid ) 
{ 


  {
#line 844
  return (-1);
}
}
#line 847
__inline static int cpu_pid_to_cpupid(int nid , int pid )  __attribute__((__no_instrument_function__)) ;
#line 847 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static int cpu_pid_to_cpupid(int nid , int pid ) 
{ 


  {
#line 849
  return (-1);
}
}
#line 852
__inline static bool cpupid_pid_unset(int cpupid )  __attribute__((__no_instrument_function__)) ;
#line 852 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static bool cpupid_pid_unset(int cpupid ) 
{ 


  {
#line 854
  return ((bool )1);
}
}
#line 857
__inline static void page_cpupid_reset_last(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 857 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void page_cpupid_reset_last(struct page *page ) 
{ 


  {
#line 859
  return;
}
}
#line 861
__inline static bool cpupid_match_pid(struct task_struct *task , int cpupid )  __attribute__((__no_instrument_function__)) ;
#line 861 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static bool cpupid_match_pid(struct task_struct *task , int cpupid ) 
{ 


  {
#line 863
  return ((bool )0);
}
}
#line 867
__inline static struct zone *page_zone(struct page  const  *page )  __attribute__((__no_instrument_function__)) ;
#line 867 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static struct zone *page_zone(struct page  const  *page ) 
{ 
  int tmp___7 ;
  enum zone_type tmp___8 ;

  {
  {
#line 869
  tmp___7 = page_to_nid(page);
#line 869
  tmp___8 = page_zonenum(page);
  }
#line 869
  return (& (node_data[tmp___7])->node_zones[tmp___8]);
}
}
#line 885
__inline static void set_page_zone(struct page *page , enum zone_type zone )  __attribute__((__no_instrument_function__)) ;
#line 885 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void set_page_zone(struct page *page , enum zone_type zone ) 
{ 


  {
  {
#line 887
  page->flags &= ~ (((1UL << 2) - 1UL) << ((sizeof(unsigned long ) * 8UL - 6UL) - 2UL));
#line 888
  page->flags |= ((unsigned long )zone & ((1UL << 2) - 1UL)) << ((sizeof(unsigned long ) * 8UL - 6UL) - 2UL);
  }
#line 889
  return;
}
}
#line 891
__inline static void set_page_node(struct page *page , unsigned long node )  __attribute__((__no_instrument_function__)) ;
#line 891 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void set_page_node(struct page *page , unsigned long node ) 
{ 


  {
  {
#line 893
  page->flags &= ~ (((1UL << 6) - 1UL) << (sizeof(unsigned long ) * 8UL - 6UL));
#line 894
  page->flags |= (node & ((1UL << 6) - 1UL)) << (sizeof(unsigned long ) * 8UL - 6UL);
  }
#line 895
  return;
}
}
#line 897
__inline static void set_page_links(struct page *page , enum zone_type zone , unsigned long node ,
                                    unsigned long pfn )  __attribute__((__no_instrument_function__)) ;
#line 897 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void set_page_links(struct page *page , enum zone_type zone , unsigned long node ,
                                    unsigned long pfn ) 
{ 


  {
  {
#line 900
  set_page_zone(page, zone);
#line 901
  set_page_node(page, node);
  }
#line 905
  return;
}
}
#line 11 "../../../analyzer/../bench/linux-headers/include/linux/vmstat.h"
extern int sysctl_stat_interval ;
#line 28
extern struct vm_event_state vm_event_states  __attribute__((__section__(".data..percpu"))) ;
#line 34
__inline static void __count_vm_event(enum vm_event_item item )  __attribute__((__no_instrument_function__)) ;
#line 34 "../../../analyzer/../bench/linux-headers/include/linux/vmstat.h"
__inline static void __count_vm_event(enum vm_event_item item ) 
{ 
  void const   *__vpp_verify ;
  int pao_ID__ ;
  pao_T_____1 pao_tmp__ ;
  int pao_ID_____0 ;
  pao_T_____2 pao_tmp_____0 ;
  int pao_ID_____1 ;
  pao_T_____3 pao_tmp_____1 ;
  int pao_ID_____2 ;
  pao_T_____4 pao_tmp_____2 ;

  {
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 36
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 36
      __vpp_verify = (void const   *)((unsigned long *)((void *)0));
      }
#line 36
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 36
    if (sizeof(vm_event_states.event[item]) == 1UL) {
#line 36
      goto case_1;
    }
#line 36
    if (sizeof(vm_event_states.event[item]) == 2UL) {
#line 36
      goto case_2___0;
    }
#line 36
    if (sizeof(vm_event_states.event[item]) == 4UL) {
#line 36
      goto case_4___1;
    }
#line 36
    if (sizeof(vm_event_states.event[item]) == 8UL) {
#line 36
      goto case_8___2;
    }
#line 36
    goto switch_default___3;
    case_1: /* CIL Label */ 
    {
#line 36
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 36
      pao_ID__ = 1;
      }
      {
#line 36
      if (sizeof(vm_event_states.event[item]) == 1UL) {
#line 36
        goto case_1___0;
      }
#line 36
      if (sizeof(vm_event_states.event[item]) == 2UL) {
#line 36
        goto case_2;
      }
#line 36
      if (sizeof(vm_event_states.event[item]) == 4UL) {
#line 36
        goto case_4;
      }
#line 36
      if (sizeof(vm_event_states.event[item]) == 8UL) {
#line 36
        goto case_8;
      }
#line 36
      goto switch_default;
      case_1___0: /* CIL Label */ 
#line 36
      if (pao_ID__ == 1) {
        {
#line 36
        __asm__  ("incb "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 36
      if (pao_ID__ == -1) {
        {
#line 36
        __asm__  ("decb "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 36
        __asm__  ("addb %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "qi" ((pao_T_____1 )1));
        }
      }
#line 36
      goto switch_break___0;
      case_2: /* CIL Label */ 
#line 36
      if (pao_ID__ == 1) {
        {
#line 36
        __asm__  ("incw "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 36
      if (pao_ID__ == -1) {
        {
#line 36
        __asm__  ("decw "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 36
        __asm__  ("addw %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "ri" ((pao_T_____1 )1));
        }
      }
#line 36
      goto switch_break___0;
      case_4: /* CIL Label */ 
#line 36
      if (pao_ID__ == 1) {
        {
#line 36
        __asm__  ("incl "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 36
      if (pao_ID__ == -1) {
        {
#line 36
        __asm__  ("decl "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 36
        __asm__  ("addl %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "ri" ((pao_T_____1 )1));
        }
      }
#line 36
      goto switch_break___0;
      case_8: /* CIL Label */ 
#line 36
      if (pao_ID__ == 1) {
        {
#line 36
        __asm__  ("incq "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 36
      if (pao_ID__ == -1) {
        {
#line 36
        __asm__  ("decq "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 36
        __asm__  ("addq %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "re" ((pao_T_____1 )1));
        }
      }
#line 36
      goto switch_break___0;
      switch_default: /* CIL Label */ 
      {
#line 36
      __bad_percpu_size();
      }
      switch_break___0: /* CIL Label */ ;
      }
#line 36
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 36
    goto switch_break;
    case_2___0: /* CIL Label */ 
    {
#line 36
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 36
      pao_ID_____0 = 1;
      }
      {
#line 36
      if (sizeof(vm_event_states.event[item]) == 1UL) {
#line 36
        goto case_1___1;
      }
#line 36
      if (sizeof(vm_event_states.event[item]) == 2UL) {
#line 36
        goto case_2___1;
      }
#line 36
      if (sizeof(vm_event_states.event[item]) == 4UL) {
#line 36
        goto case_4___0;
      }
#line 36
      if (sizeof(vm_event_states.event[item]) == 8UL) {
#line 36
        goto case_8___0;
      }
#line 36
      goto switch_default___0;
      case_1___1: /* CIL Label */ 
#line 36
      if (pao_ID_____0 == 1) {
        {
#line 36
        __asm__  ("incb "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 36
      if (pao_ID_____0 == -1) {
        {
#line 36
        __asm__  ("decb "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 36
        __asm__  ("addb %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "qi" ((pao_T_____2 )1));
        }
      }
#line 36
      goto switch_break___1;
      case_2___1: /* CIL Label */ 
#line 36
      if (pao_ID_____0 == 1) {
        {
#line 36
        __asm__  ("incw "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 36
      if (pao_ID_____0 == -1) {
        {
#line 36
        __asm__  ("decw "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 36
        __asm__  ("addw %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "ri" ((pao_T_____2 )1));
        }
      }
#line 36
      goto switch_break___1;
      case_4___0: /* CIL Label */ 
#line 36
      if (pao_ID_____0 == 1) {
        {
#line 36
        __asm__  ("incl "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 36
      if (pao_ID_____0 == -1) {
        {
#line 36
        __asm__  ("decl "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 36
        __asm__  ("addl %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "ri" ((pao_T_____2 )1));
        }
      }
#line 36
      goto switch_break___1;
      case_8___0: /* CIL Label */ 
#line 36
      if (pao_ID_____0 == 1) {
        {
#line 36
        __asm__  ("incq "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 36
      if (pao_ID_____0 == -1) {
        {
#line 36
        __asm__  ("decq "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 36
        __asm__  ("addq %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "re" ((pao_T_____2 )1));
        }
      }
#line 36
      goto switch_break___1;
      switch_default___0: /* CIL Label */ 
      {
#line 36
      __bad_percpu_size();
      }
      switch_break___1: /* CIL Label */ ;
      }
#line 36
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 36
    goto switch_break;
    case_4___1: /* CIL Label */ 
    {
#line 36
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 36
      pao_ID_____1 = 1;
      }
      {
#line 36
      if (sizeof(vm_event_states.event[item]) == 1UL) {
#line 36
        goto case_1___2;
      }
#line 36
      if (sizeof(vm_event_states.event[item]) == 2UL) {
#line 36
        goto case_2___2;
      }
#line 36
      if (sizeof(vm_event_states.event[item]) == 4UL) {
#line 36
        goto case_4___2;
      }
#line 36
      if (sizeof(vm_event_states.event[item]) == 8UL) {
#line 36
        goto case_8___1;
      }
#line 36
      goto switch_default___1;
      case_1___2: /* CIL Label */ 
#line 36
      if (pao_ID_____1 == 1) {
        {
#line 36
        __asm__  ("incb "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 36
      if (pao_ID_____1 == -1) {
        {
#line 36
        __asm__  ("decb "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 36
        __asm__  ("addb %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "qi" ((pao_T_____3 )1));
        }
      }
#line 36
      goto switch_break___2;
      case_2___2: /* CIL Label */ 
#line 36
      if (pao_ID_____1 == 1) {
        {
#line 36
        __asm__  ("incw "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 36
      if (pao_ID_____1 == -1) {
        {
#line 36
        __asm__  ("decw "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 36
        __asm__  ("addw %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "ri" ((pao_T_____3 )1));
        }
      }
#line 36
      goto switch_break___2;
      case_4___2: /* CIL Label */ 
#line 36
      if (pao_ID_____1 == 1) {
        {
#line 36
        __asm__  ("incl "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 36
      if (pao_ID_____1 == -1) {
        {
#line 36
        __asm__  ("decl "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 36
        __asm__  ("addl %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "ri" ((pao_T_____3 )1));
        }
      }
#line 36
      goto switch_break___2;
      case_8___1: /* CIL Label */ 
#line 36
      if (pao_ID_____1 == 1) {
        {
#line 36
        __asm__  ("incq "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 36
      if (pao_ID_____1 == -1) {
        {
#line 36
        __asm__  ("decq "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 36
        __asm__  ("addq %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "re" ((pao_T_____3 )1));
        }
      }
#line 36
      goto switch_break___2;
      switch_default___1: /* CIL Label */ 
      {
#line 36
      __bad_percpu_size();
      }
      switch_break___2: /* CIL Label */ ;
      }
#line 36
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 36
    goto switch_break;
    case_8___2: /* CIL Label */ 
    {
#line 36
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 36
      pao_ID_____2 = 1;
      }
      {
#line 36
      if (sizeof(vm_event_states.event[item]) == 1UL) {
#line 36
        goto case_1___3;
      }
#line 36
      if (sizeof(vm_event_states.event[item]) == 2UL) {
#line 36
        goto case_2___3;
      }
#line 36
      if (sizeof(vm_event_states.event[item]) == 4UL) {
#line 36
        goto case_4___3;
      }
#line 36
      if (sizeof(vm_event_states.event[item]) == 8UL) {
#line 36
        goto case_8___3;
      }
#line 36
      goto switch_default___2;
      case_1___3: /* CIL Label */ 
#line 36
      if (pao_ID_____2 == 1) {
        {
#line 36
        __asm__  ("incb "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 36
      if (pao_ID_____2 == -1) {
        {
#line 36
        __asm__  ("decb "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 36
        __asm__  ("addb %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "qi" ((pao_T_____4 )1));
        }
      }
#line 36
      goto switch_break___3;
      case_2___3: /* CIL Label */ 
#line 36
      if (pao_ID_____2 == 1) {
        {
#line 36
        __asm__  ("incw "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 36
      if (pao_ID_____2 == -1) {
        {
#line 36
        __asm__  ("decw "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 36
        __asm__  ("addw %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "ri" ((pao_T_____4 )1));
        }
      }
#line 36
      goto switch_break___3;
      case_4___3: /* CIL Label */ 
#line 36
      if (pao_ID_____2 == 1) {
        {
#line 36
        __asm__  ("incl "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 36
      if (pao_ID_____2 == -1) {
        {
#line 36
        __asm__  ("decl "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 36
        __asm__  ("addl %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "ri" ((pao_T_____4 )1));
        }
      }
#line 36
      goto switch_break___3;
      case_8___3: /* CIL Label */ 
#line 36
      if (pao_ID_____2 == 1) {
        {
#line 36
        __asm__  ("incq "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 36
      if (pao_ID_____2 == -1) {
        {
#line 36
        __asm__  ("decq "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 36
        __asm__  ("addq %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "re" ((pao_T_____4 )1));
        }
      }
#line 36
      goto switch_break___3;
      switch_default___2: /* CIL Label */ 
      {
#line 36
      __bad_percpu_size();
      }
      switch_break___3: /* CIL Label */ ;
      }
#line 36
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 36
    goto switch_break;
    switch_default___3: /* CIL Label */ 
    {
#line 36
    __bad_size_call_parameter();
    }
#line 36
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 36
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 37
  return;
}
}
#line 39
__inline static void count_vm_event(enum vm_event_item item )  __attribute__((__no_instrument_function__)) ;
#line 39 "../../../analyzer/../bench/linux-headers/include/linux/vmstat.h"
__inline static void count_vm_event(enum vm_event_item item ) 
{ 
  void const   *__vpp_verify ;
  int pao_ID__ ;
  pao_T_____5 pao_tmp__ ;
  int pao_ID_____0 ;
  pao_T_____6 pao_tmp_____0 ;
  int pao_ID_____1 ;
  pao_T_____7 pao_tmp_____1 ;
  int pao_ID_____2 ;
  pao_T_____8 pao_tmp_____2 ;

  {
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 41
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 41
      __vpp_verify = (void const   *)((unsigned long *)((void *)0));
      }
#line 41
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 41
    if (sizeof(vm_event_states.event[item]) == 1UL) {
#line 41
      goto case_1;
    }
#line 41
    if (sizeof(vm_event_states.event[item]) == 2UL) {
#line 41
      goto case_2___0;
    }
#line 41
    if (sizeof(vm_event_states.event[item]) == 4UL) {
#line 41
      goto case_4___1;
    }
#line 41
    if (sizeof(vm_event_states.event[item]) == 8UL) {
#line 41
      goto case_8___2;
    }
#line 41
    goto switch_default___3;
    case_1: /* CIL Label */ 
    {
#line 41
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 41
      pao_ID__ = 1;
      }
      {
#line 41
      if (sizeof(vm_event_states.event[item]) == 1UL) {
#line 41
        goto case_1___0;
      }
#line 41
      if (sizeof(vm_event_states.event[item]) == 2UL) {
#line 41
        goto case_2;
      }
#line 41
      if (sizeof(vm_event_states.event[item]) == 4UL) {
#line 41
        goto case_4;
      }
#line 41
      if (sizeof(vm_event_states.event[item]) == 8UL) {
#line 41
        goto case_8;
      }
#line 41
      goto switch_default;
      case_1___0: /* CIL Label */ 
#line 41
      if (pao_ID__ == 1) {
        {
#line 41
        __asm__  ("incb "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 41
      if (pao_ID__ == -1) {
        {
#line 41
        __asm__  ("decb "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 41
        __asm__  ("addb %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "qi" ((pao_T_____5 )1));
        }
      }
#line 41
      goto switch_break___0;
      case_2: /* CIL Label */ 
#line 41
      if (pao_ID__ == 1) {
        {
#line 41
        __asm__  ("incw "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 41
      if (pao_ID__ == -1) {
        {
#line 41
        __asm__  ("decw "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 41
        __asm__  ("addw %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "ri" ((pao_T_____5 )1));
        }
      }
#line 41
      goto switch_break___0;
      case_4: /* CIL Label */ 
#line 41
      if (pao_ID__ == 1) {
        {
#line 41
        __asm__  ("incl "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 41
      if (pao_ID__ == -1) {
        {
#line 41
        __asm__  ("decl "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 41
        __asm__  ("addl %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "ri" ((pao_T_____5 )1));
        }
      }
#line 41
      goto switch_break___0;
      case_8: /* CIL Label */ 
#line 41
      if (pao_ID__ == 1) {
        {
#line 41
        __asm__  ("incq "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 41
      if (pao_ID__ == -1) {
        {
#line 41
        __asm__  ("decq "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 41
        __asm__  ("addq %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "re" ((pao_T_____5 )1));
        }
      }
#line 41
      goto switch_break___0;
      switch_default: /* CIL Label */ 
      {
#line 41
      __bad_percpu_size();
      }
      switch_break___0: /* CIL Label */ ;
      }
#line 41
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 41
    goto switch_break;
    case_2___0: /* CIL Label */ 
    {
#line 41
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 41
      pao_ID_____0 = 1;
      }
      {
#line 41
      if (sizeof(vm_event_states.event[item]) == 1UL) {
#line 41
        goto case_1___1;
      }
#line 41
      if (sizeof(vm_event_states.event[item]) == 2UL) {
#line 41
        goto case_2___1;
      }
#line 41
      if (sizeof(vm_event_states.event[item]) == 4UL) {
#line 41
        goto case_4___0;
      }
#line 41
      if (sizeof(vm_event_states.event[item]) == 8UL) {
#line 41
        goto case_8___0;
      }
#line 41
      goto switch_default___0;
      case_1___1: /* CIL Label */ 
#line 41
      if (pao_ID_____0 == 1) {
        {
#line 41
        __asm__  ("incb "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 41
      if (pao_ID_____0 == -1) {
        {
#line 41
        __asm__  ("decb "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 41
        __asm__  ("addb %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "qi" ((pao_T_____6 )1));
        }
      }
#line 41
      goto switch_break___1;
      case_2___1: /* CIL Label */ 
#line 41
      if (pao_ID_____0 == 1) {
        {
#line 41
        __asm__  ("incw "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 41
      if (pao_ID_____0 == -1) {
        {
#line 41
        __asm__  ("decw "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 41
        __asm__  ("addw %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "ri" ((pao_T_____6 )1));
        }
      }
#line 41
      goto switch_break___1;
      case_4___0: /* CIL Label */ 
#line 41
      if (pao_ID_____0 == 1) {
        {
#line 41
        __asm__  ("incl "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 41
      if (pao_ID_____0 == -1) {
        {
#line 41
        __asm__  ("decl "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 41
        __asm__  ("addl %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "ri" ((pao_T_____6 )1));
        }
      }
#line 41
      goto switch_break___1;
      case_8___0: /* CIL Label */ 
#line 41
      if (pao_ID_____0 == 1) {
        {
#line 41
        __asm__  ("incq "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 41
      if (pao_ID_____0 == -1) {
        {
#line 41
        __asm__  ("decq "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 41
        __asm__  ("addq %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "re" ((pao_T_____6 )1));
        }
      }
#line 41
      goto switch_break___1;
      switch_default___0: /* CIL Label */ 
      {
#line 41
      __bad_percpu_size();
      }
      switch_break___1: /* CIL Label */ ;
      }
#line 41
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 41
    goto switch_break;
    case_4___1: /* CIL Label */ 
    {
#line 41
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 41
      pao_ID_____1 = 1;
      }
      {
#line 41
      if (sizeof(vm_event_states.event[item]) == 1UL) {
#line 41
        goto case_1___2;
      }
#line 41
      if (sizeof(vm_event_states.event[item]) == 2UL) {
#line 41
        goto case_2___2;
      }
#line 41
      if (sizeof(vm_event_states.event[item]) == 4UL) {
#line 41
        goto case_4___2;
      }
#line 41
      if (sizeof(vm_event_states.event[item]) == 8UL) {
#line 41
        goto case_8___1;
      }
#line 41
      goto switch_default___1;
      case_1___2: /* CIL Label */ 
#line 41
      if (pao_ID_____1 == 1) {
        {
#line 41
        __asm__  ("incb "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 41
      if (pao_ID_____1 == -1) {
        {
#line 41
        __asm__  ("decb "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 41
        __asm__  ("addb %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "qi" ((pao_T_____7 )1));
        }
      }
#line 41
      goto switch_break___2;
      case_2___2: /* CIL Label */ 
#line 41
      if (pao_ID_____1 == 1) {
        {
#line 41
        __asm__  ("incw "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 41
      if (pao_ID_____1 == -1) {
        {
#line 41
        __asm__  ("decw "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 41
        __asm__  ("addw %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "ri" ((pao_T_____7 )1));
        }
      }
#line 41
      goto switch_break___2;
      case_4___2: /* CIL Label */ 
#line 41
      if (pao_ID_____1 == 1) {
        {
#line 41
        __asm__  ("incl "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 41
      if (pao_ID_____1 == -1) {
        {
#line 41
        __asm__  ("decl "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 41
        __asm__  ("addl %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "ri" ((pao_T_____7 )1));
        }
      }
#line 41
      goto switch_break___2;
      case_8___1: /* CIL Label */ 
#line 41
      if (pao_ID_____1 == 1) {
        {
#line 41
        __asm__  ("incq "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 41
      if (pao_ID_____1 == -1) {
        {
#line 41
        __asm__  ("decq "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 41
        __asm__  ("addq %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "re" ((pao_T_____7 )1));
        }
      }
#line 41
      goto switch_break___2;
      switch_default___1: /* CIL Label */ 
      {
#line 41
      __bad_percpu_size();
      }
      switch_break___2: /* CIL Label */ ;
      }
#line 41
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 41
    goto switch_break;
    case_8___2: /* CIL Label */ 
    {
#line 41
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 41
      pao_ID_____2 = 1;
      }
      {
#line 41
      if (sizeof(vm_event_states.event[item]) == 1UL) {
#line 41
        goto case_1___3;
      }
#line 41
      if (sizeof(vm_event_states.event[item]) == 2UL) {
#line 41
        goto case_2___3;
      }
#line 41
      if (sizeof(vm_event_states.event[item]) == 4UL) {
#line 41
        goto case_4___3;
      }
#line 41
      if (sizeof(vm_event_states.event[item]) == 8UL) {
#line 41
        goto case_8___3;
      }
#line 41
      goto switch_default___2;
      case_1___3: /* CIL Label */ 
#line 41
      if (pao_ID_____2 == 1) {
        {
#line 41
        __asm__  ("incb "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 41
      if (pao_ID_____2 == -1) {
        {
#line 41
        __asm__  ("decb "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 41
        __asm__  ("addb %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "qi" ((pao_T_____8 )1));
        }
      }
#line 41
      goto switch_break___3;
      case_2___3: /* CIL Label */ 
#line 41
      if (pao_ID_____2 == 1) {
        {
#line 41
        __asm__  ("incw "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 41
      if (pao_ID_____2 == -1) {
        {
#line 41
        __asm__  ("decw "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 41
        __asm__  ("addw %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "ri" ((pao_T_____8 )1));
        }
      }
#line 41
      goto switch_break___3;
      case_4___3: /* CIL Label */ 
#line 41
      if (pao_ID_____2 == 1) {
        {
#line 41
        __asm__  ("incl "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 41
      if (pao_ID_____2 == -1) {
        {
#line 41
        __asm__  ("decl "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 41
        __asm__  ("addl %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "ri" ((pao_T_____8 )1));
        }
      }
#line 41
      goto switch_break___3;
      case_8___3: /* CIL Label */ 
#line 41
      if (pao_ID_____2 == 1) {
        {
#line 41
        __asm__  ("incq "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 41
      if (pao_ID_____2 == -1) {
        {
#line 41
        __asm__  ("decq "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 41
        __asm__  ("addq %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "re" ((pao_T_____8 )1));
        }
      }
#line 41
      goto switch_break___3;
      switch_default___2: /* CIL Label */ 
      {
#line 41
      __bad_percpu_size();
      }
      switch_break___3: /* CIL Label */ ;
      }
#line 41
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 41
    goto switch_break;
    switch_default___3: /* CIL Label */ 
    {
#line 41
    __bad_size_call_parameter();
    }
#line 41
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 41
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return;
}
}
#line 44
__inline static void __count_vm_events(enum vm_event_item item , long delta )  __attribute__((__no_instrument_function__)) ;
#line 44 "../../../analyzer/../bench/linux-headers/include/linux/vmstat.h"
__inline static void __count_vm_events(enum vm_event_item item , long delta ) 
{ 
  void const   *__vpp_verify ;
  int pao_ID__ ;
  pao_T_____9 pao_tmp__ ;
  int pao_ID_____0 ;
  pao_T_____10 pao_tmp_____0 ;
  int pao_ID_____1 ;
  pao_T_____11 pao_tmp_____1 ;
  int pao_ID_____2 ;
  pao_T_____12 pao_tmp_____2 ;

  {
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 46
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 46
      __vpp_verify = (void const   *)((unsigned long *)((void *)0));
      }
#line 46
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 46
    if (sizeof(vm_event_states.event[item]) == 1UL) {
#line 46
      goto case_1;
    }
#line 46
    if (sizeof(vm_event_states.event[item]) == 2UL) {
#line 46
      goto case_2___0;
    }
#line 46
    if (sizeof(vm_event_states.event[item]) == 4UL) {
#line 46
      goto case_4___1;
    }
#line 46
    if (sizeof(vm_event_states.event[item]) == 8UL) {
#line 46
      goto case_8___2;
    }
#line 46
    goto switch_default___3;
    case_1: /* CIL Label */ 
    {
#line 46
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 46
      pao_ID__ = 0;
      }
      {
#line 46
      if (sizeof(vm_event_states.event[item]) == 1UL) {
#line 46
        goto case_1___0;
      }
#line 46
      if (sizeof(vm_event_states.event[item]) == 2UL) {
#line 46
        goto case_2;
      }
#line 46
      if (sizeof(vm_event_states.event[item]) == 4UL) {
#line 46
        goto case_4;
      }
#line 46
      if (sizeof(vm_event_states.event[item]) == 8UL) {
#line 46
        goto case_8;
      }
#line 46
      goto switch_default;
      case_1___0: /* CIL Label */ 
#line 46
      if (pao_ID__ == 1) {
        {
#line 46
        __asm__  ("incb "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 46
      if (pao_ID__ == -1) {
        {
#line 46
        __asm__  ("decb "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 46
        __asm__  ("addb %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "qi" ((pao_T_____9 )delta));
        }
      }
#line 46
      goto switch_break___0;
      case_2: /* CIL Label */ 
#line 46
      if (pao_ID__ == 1) {
        {
#line 46
        __asm__  ("incw "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 46
      if (pao_ID__ == -1) {
        {
#line 46
        __asm__  ("decw "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 46
        __asm__  ("addw %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "ri" ((pao_T_____9 )delta));
        }
      }
#line 46
      goto switch_break___0;
      case_4: /* CIL Label */ 
#line 46
      if (pao_ID__ == 1) {
        {
#line 46
        __asm__  ("incl "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 46
      if (pao_ID__ == -1) {
        {
#line 46
        __asm__  ("decl "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 46
        __asm__  ("addl %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "ri" ((pao_T_____9 )delta));
        }
      }
#line 46
      goto switch_break___0;
      case_8: /* CIL Label */ 
#line 46
      if (pao_ID__ == 1) {
        {
#line 46
        __asm__  ("incq "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 46
      if (pao_ID__ == -1) {
        {
#line 46
        __asm__  ("decq "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 46
        __asm__  ("addq %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "re" ((pao_T_____9 )delta));
        }
      }
#line 46
      goto switch_break___0;
      switch_default: /* CIL Label */ 
      {
#line 46
      __bad_percpu_size();
      }
      switch_break___0: /* CIL Label */ ;
      }
#line 46
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 46
    goto switch_break;
    case_2___0: /* CIL Label */ 
    {
#line 46
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 46
      pao_ID_____0 = 0;
      }
      {
#line 46
      if (sizeof(vm_event_states.event[item]) == 1UL) {
#line 46
        goto case_1___1;
      }
#line 46
      if (sizeof(vm_event_states.event[item]) == 2UL) {
#line 46
        goto case_2___1;
      }
#line 46
      if (sizeof(vm_event_states.event[item]) == 4UL) {
#line 46
        goto case_4___0;
      }
#line 46
      if (sizeof(vm_event_states.event[item]) == 8UL) {
#line 46
        goto case_8___0;
      }
#line 46
      goto switch_default___0;
      case_1___1: /* CIL Label */ 
#line 46
      if (pao_ID_____0 == 1) {
        {
#line 46
        __asm__  ("incb "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 46
      if (pao_ID_____0 == -1) {
        {
#line 46
        __asm__  ("decb "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 46
        __asm__  ("addb %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "qi" ((pao_T_____10 )delta));
        }
      }
#line 46
      goto switch_break___1;
      case_2___1: /* CIL Label */ 
#line 46
      if (pao_ID_____0 == 1) {
        {
#line 46
        __asm__  ("incw "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 46
      if (pao_ID_____0 == -1) {
        {
#line 46
        __asm__  ("decw "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 46
        __asm__  ("addw %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "ri" ((pao_T_____10 )delta));
        }
      }
#line 46
      goto switch_break___1;
      case_4___0: /* CIL Label */ 
#line 46
      if (pao_ID_____0 == 1) {
        {
#line 46
        __asm__  ("incl "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 46
      if (pao_ID_____0 == -1) {
        {
#line 46
        __asm__  ("decl "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 46
        __asm__  ("addl %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "ri" ((pao_T_____10 )delta));
        }
      }
#line 46
      goto switch_break___1;
      case_8___0: /* CIL Label */ 
#line 46
      if (pao_ID_____0 == 1) {
        {
#line 46
        __asm__  ("incq "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 46
      if (pao_ID_____0 == -1) {
        {
#line 46
        __asm__  ("decq "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 46
        __asm__  ("addq %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "re" ((pao_T_____10 )delta));
        }
      }
#line 46
      goto switch_break___1;
      switch_default___0: /* CIL Label */ 
      {
#line 46
      __bad_percpu_size();
      }
      switch_break___1: /* CIL Label */ ;
      }
#line 46
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 46
    goto switch_break;
    case_4___1: /* CIL Label */ 
    {
#line 46
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 46
      pao_ID_____1 = 0;
      }
      {
#line 46
      if (sizeof(vm_event_states.event[item]) == 1UL) {
#line 46
        goto case_1___2;
      }
#line 46
      if (sizeof(vm_event_states.event[item]) == 2UL) {
#line 46
        goto case_2___2;
      }
#line 46
      if (sizeof(vm_event_states.event[item]) == 4UL) {
#line 46
        goto case_4___2;
      }
#line 46
      if (sizeof(vm_event_states.event[item]) == 8UL) {
#line 46
        goto case_8___1;
      }
#line 46
      goto switch_default___1;
      case_1___2: /* CIL Label */ 
#line 46
      if (pao_ID_____1 == 1) {
        {
#line 46
        __asm__  ("incb "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 46
      if (pao_ID_____1 == -1) {
        {
#line 46
        __asm__  ("decb "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 46
        __asm__  ("addb %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "qi" ((pao_T_____11 )delta));
        }
      }
#line 46
      goto switch_break___2;
      case_2___2: /* CIL Label */ 
#line 46
      if (pao_ID_____1 == 1) {
        {
#line 46
        __asm__  ("incw "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 46
      if (pao_ID_____1 == -1) {
        {
#line 46
        __asm__  ("decw "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 46
        __asm__  ("addw %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "ri" ((pao_T_____11 )delta));
        }
      }
#line 46
      goto switch_break___2;
      case_4___2: /* CIL Label */ 
#line 46
      if (pao_ID_____1 == 1) {
        {
#line 46
        __asm__  ("incl "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 46
      if (pao_ID_____1 == -1) {
        {
#line 46
        __asm__  ("decl "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 46
        __asm__  ("addl %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "ri" ((pao_T_____11 )delta));
        }
      }
#line 46
      goto switch_break___2;
      case_8___1: /* CIL Label */ 
#line 46
      if (pao_ID_____1 == 1) {
        {
#line 46
        __asm__  ("incq "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 46
      if (pao_ID_____1 == -1) {
        {
#line 46
        __asm__  ("decq "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 46
        __asm__  ("addq %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "re" ((pao_T_____11 )delta));
        }
      }
#line 46
      goto switch_break___2;
      switch_default___1: /* CIL Label */ 
      {
#line 46
      __bad_percpu_size();
      }
      switch_break___2: /* CIL Label */ ;
      }
#line 46
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 46
    goto switch_break;
    case_8___2: /* CIL Label */ 
    {
#line 46
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 46
      pao_ID_____2 = 0;
      }
      {
#line 46
      if (sizeof(vm_event_states.event[item]) == 1UL) {
#line 46
        goto case_1___3;
      }
#line 46
      if (sizeof(vm_event_states.event[item]) == 2UL) {
#line 46
        goto case_2___3;
      }
#line 46
      if (sizeof(vm_event_states.event[item]) == 4UL) {
#line 46
        goto case_4___3;
      }
#line 46
      if (sizeof(vm_event_states.event[item]) == 8UL) {
#line 46
        goto case_8___3;
      }
#line 46
      goto switch_default___2;
      case_1___3: /* CIL Label */ 
#line 46
      if (pao_ID_____2 == 1) {
        {
#line 46
        __asm__  ("incb "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 46
      if (pao_ID_____2 == -1) {
        {
#line 46
        __asm__  ("decb "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 46
        __asm__  ("addb %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "qi" ((pao_T_____12 )delta));
        }
      }
#line 46
      goto switch_break___3;
      case_2___3: /* CIL Label */ 
#line 46
      if (pao_ID_____2 == 1) {
        {
#line 46
        __asm__  ("incw "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 46
      if (pao_ID_____2 == -1) {
        {
#line 46
        __asm__  ("decw "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 46
        __asm__  ("addw %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "ri" ((pao_T_____12 )delta));
        }
      }
#line 46
      goto switch_break___3;
      case_4___3: /* CIL Label */ 
#line 46
      if (pao_ID_____2 == 1) {
        {
#line 46
        __asm__  ("incl "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 46
      if (pao_ID_____2 == -1) {
        {
#line 46
        __asm__  ("decl "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 46
        __asm__  ("addl %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "ri" ((pao_T_____12 )delta));
        }
      }
#line 46
      goto switch_break___3;
      case_8___3: /* CIL Label */ 
#line 46
      if (pao_ID_____2 == 1) {
        {
#line 46
        __asm__  ("incq "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 46
      if (pao_ID_____2 == -1) {
        {
#line 46
        __asm__  ("decq "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 46
        __asm__  ("addq %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "re" ((pao_T_____12 )delta));
        }
      }
#line 46
      goto switch_break___3;
      switch_default___2: /* CIL Label */ 
      {
#line 46
      __bad_percpu_size();
      }
      switch_break___3: /* CIL Label */ ;
      }
#line 46
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 46
    goto switch_break;
    switch_default___3: /* CIL Label */ 
    {
#line 46
    __bad_size_call_parameter();
    }
#line 46
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 46
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  return;
}
}
#line 49
__inline static void count_vm_events(enum vm_event_item item , long delta )  __attribute__((__no_instrument_function__)) ;
#line 49 "../../../analyzer/../bench/linux-headers/include/linux/vmstat.h"
__inline static void count_vm_events(enum vm_event_item item , long delta ) 
{ 
  void const   *__vpp_verify ;
  int pao_ID__ ;
  pao_T_____13 pao_tmp__ ;
  int pao_ID_____0 ;
  pao_T_____14 pao_tmp_____0 ;
  int pao_ID_____1 ;
  pao_T_____15 pao_tmp_____1 ;
  int pao_ID_____2 ;
  pao_T_____16 pao_tmp_____2 ;

  {
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 51
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 51
      __vpp_verify = (void const   *)((unsigned long *)((void *)0));
      }
#line 51
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 51
    if (sizeof(vm_event_states.event[item]) == 1UL) {
#line 51
      goto case_1;
    }
#line 51
    if (sizeof(vm_event_states.event[item]) == 2UL) {
#line 51
      goto case_2___0;
    }
#line 51
    if (sizeof(vm_event_states.event[item]) == 4UL) {
#line 51
      goto case_4___1;
    }
#line 51
    if (sizeof(vm_event_states.event[item]) == 8UL) {
#line 51
      goto case_8___2;
    }
#line 51
    goto switch_default___3;
    case_1: /* CIL Label */ 
    {
#line 51
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 51
      pao_ID__ = 0;
      }
      {
#line 51
      if (sizeof(vm_event_states.event[item]) == 1UL) {
#line 51
        goto case_1___0;
      }
#line 51
      if (sizeof(vm_event_states.event[item]) == 2UL) {
#line 51
        goto case_2;
      }
#line 51
      if (sizeof(vm_event_states.event[item]) == 4UL) {
#line 51
        goto case_4;
      }
#line 51
      if (sizeof(vm_event_states.event[item]) == 8UL) {
#line 51
        goto case_8;
      }
#line 51
      goto switch_default;
      case_1___0: /* CIL Label */ 
#line 51
      if (pao_ID__ == 1) {
        {
#line 51
        __asm__  ("incb "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 51
      if (pao_ID__ == -1) {
        {
#line 51
        __asm__  ("decb "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 51
        __asm__  ("addb %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "qi" ((pao_T_____13 )delta));
        }
      }
#line 51
      goto switch_break___0;
      case_2: /* CIL Label */ 
#line 51
      if (pao_ID__ == 1) {
        {
#line 51
        __asm__  ("incw "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 51
      if (pao_ID__ == -1) {
        {
#line 51
        __asm__  ("decw "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 51
        __asm__  ("addw %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "ri" ((pao_T_____13 )delta));
        }
      }
#line 51
      goto switch_break___0;
      case_4: /* CIL Label */ 
#line 51
      if (pao_ID__ == 1) {
        {
#line 51
        __asm__  ("incl "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 51
      if (pao_ID__ == -1) {
        {
#line 51
        __asm__  ("decl "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 51
        __asm__  ("addl %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "ri" ((pao_T_____13 )delta));
        }
      }
#line 51
      goto switch_break___0;
      case_8: /* CIL Label */ 
#line 51
      if (pao_ID__ == 1) {
        {
#line 51
        __asm__  ("incq "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 51
      if (pao_ID__ == -1) {
        {
#line 51
        __asm__  ("decq "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 51
        __asm__  ("addq %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "re" ((pao_T_____13 )delta));
        }
      }
#line 51
      goto switch_break___0;
      switch_default: /* CIL Label */ 
      {
#line 51
      __bad_percpu_size();
      }
      switch_break___0: /* CIL Label */ ;
      }
#line 51
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 51
    goto switch_break;
    case_2___0: /* CIL Label */ 
    {
#line 51
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 51
      pao_ID_____0 = 0;
      }
      {
#line 51
      if (sizeof(vm_event_states.event[item]) == 1UL) {
#line 51
        goto case_1___1;
      }
#line 51
      if (sizeof(vm_event_states.event[item]) == 2UL) {
#line 51
        goto case_2___1;
      }
#line 51
      if (sizeof(vm_event_states.event[item]) == 4UL) {
#line 51
        goto case_4___0;
      }
#line 51
      if (sizeof(vm_event_states.event[item]) == 8UL) {
#line 51
        goto case_8___0;
      }
#line 51
      goto switch_default___0;
      case_1___1: /* CIL Label */ 
#line 51
      if (pao_ID_____0 == 1) {
        {
#line 51
        __asm__  ("incb "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 51
      if (pao_ID_____0 == -1) {
        {
#line 51
        __asm__  ("decb "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 51
        __asm__  ("addb %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "qi" ((pao_T_____14 )delta));
        }
      }
#line 51
      goto switch_break___1;
      case_2___1: /* CIL Label */ 
#line 51
      if (pao_ID_____0 == 1) {
        {
#line 51
        __asm__  ("incw "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 51
      if (pao_ID_____0 == -1) {
        {
#line 51
        __asm__  ("decw "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 51
        __asm__  ("addw %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "ri" ((pao_T_____14 )delta));
        }
      }
#line 51
      goto switch_break___1;
      case_4___0: /* CIL Label */ 
#line 51
      if (pao_ID_____0 == 1) {
        {
#line 51
        __asm__  ("incl "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 51
      if (pao_ID_____0 == -1) {
        {
#line 51
        __asm__  ("decl "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 51
        __asm__  ("addl %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "ri" ((pao_T_____14 )delta));
        }
      }
#line 51
      goto switch_break___1;
      case_8___0: /* CIL Label */ 
#line 51
      if (pao_ID_____0 == 1) {
        {
#line 51
        __asm__  ("incq "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 51
      if (pao_ID_____0 == -1) {
        {
#line 51
        __asm__  ("decq "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 51
        __asm__  ("addq %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "re" ((pao_T_____14 )delta));
        }
      }
#line 51
      goto switch_break___1;
      switch_default___0: /* CIL Label */ 
      {
#line 51
      __bad_percpu_size();
      }
      switch_break___1: /* CIL Label */ ;
      }
#line 51
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 51
    goto switch_break;
    case_4___1: /* CIL Label */ 
    {
#line 51
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 51
      pao_ID_____1 = 0;
      }
      {
#line 51
      if (sizeof(vm_event_states.event[item]) == 1UL) {
#line 51
        goto case_1___2;
      }
#line 51
      if (sizeof(vm_event_states.event[item]) == 2UL) {
#line 51
        goto case_2___2;
      }
#line 51
      if (sizeof(vm_event_states.event[item]) == 4UL) {
#line 51
        goto case_4___2;
      }
#line 51
      if (sizeof(vm_event_states.event[item]) == 8UL) {
#line 51
        goto case_8___1;
      }
#line 51
      goto switch_default___1;
      case_1___2: /* CIL Label */ 
#line 51
      if (pao_ID_____1 == 1) {
        {
#line 51
        __asm__  ("incb "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 51
      if (pao_ID_____1 == -1) {
        {
#line 51
        __asm__  ("decb "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 51
        __asm__  ("addb %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "qi" ((pao_T_____15 )delta));
        }
      }
#line 51
      goto switch_break___2;
      case_2___2: /* CIL Label */ 
#line 51
      if (pao_ID_____1 == 1) {
        {
#line 51
        __asm__  ("incw "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 51
      if (pao_ID_____1 == -1) {
        {
#line 51
        __asm__  ("decw "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 51
        __asm__  ("addw %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "ri" ((pao_T_____15 )delta));
        }
      }
#line 51
      goto switch_break___2;
      case_4___2: /* CIL Label */ 
#line 51
      if (pao_ID_____1 == 1) {
        {
#line 51
        __asm__  ("incl "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 51
      if (pao_ID_____1 == -1) {
        {
#line 51
        __asm__  ("decl "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 51
        __asm__  ("addl %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "ri" ((pao_T_____15 )delta));
        }
      }
#line 51
      goto switch_break___2;
      case_8___1: /* CIL Label */ 
#line 51
      if (pao_ID_____1 == 1) {
        {
#line 51
        __asm__  ("incq "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 51
      if (pao_ID_____1 == -1) {
        {
#line 51
        __asm__  ("decq "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 51
        __asm__  ("addq %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "re" ((pao_T_____15 )delta));
        }
      }
#line 51
      goto switch_break___2;
      switch_default___1: /* CIL Label */ 
      {
#line 51
      __bad_percpu_size();
      }
      switch_break___2: /* CIL Label */ ;
      }
#line 51
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 51
    goto switch_break;
    case_8___2: /* CIL Label */ 
    {
#line 51
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 51
      pao_ID_____2 = 0;
      }
      {
#line 51
      if (sizeof(vm_event_states.event[item]) == 1UL) {
#line 51
        goto case_1___3;
      }
#line 51
      if (sizeof(vm_event_states.event[item]) == 2UL) {
#line 51
        goto case_2___3;
      }
#line 51
      if (sizeof(vm_event_states.event[item]) == 4UL) {
#line 51
        goto case_4___3;
      }
#line 51
      if (sizeof(vm_event_states.event[item]) == 8UL) {
#line 51
        goto case_8___3;
      }
#line 51
      goto switch_default___2;
      case_1___3: /* CIL Label */ 
#line 51
      if (pao_ID_____2 == 1) {
        {
#line 51
        __asm__  ("incb "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 51
      if (pao_ID_____2 == -1) {
        {
#line 51
        __asm__  ("decb "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 51
        __asm__  ("addb %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "qi" ((pao_T_____16 )delta));
        }
      }
#line 51
      goto switch_break___3;
      case_2___3: /* CIL Label */ 
#line 51
      if (pao_ID_____2 == 1) {
        {
#line 51
        __asm__  ("incw "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 51
      if (pao_ID_____2 == -1) {
        {
#line 51
        __asm__  ("decw "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 51
        __asm__  ("addw %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "ri" ((pao_T_____16 )delta));
        }
      }
#line 51
      goto switch_break___3;
      case_4___3: /* CIL Label */ 
#line 51
      if (pao_ID_____2 == 1) {
        {
#line 51
        __asm__  ("incl "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 51
      if (pao_ID_____2 == -1) {
        {
#line 51
        __asm__  ("decl "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 51
        __asm__  ("addl %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "ri" ((pao_T_____16 )delta));
        }
      }
#line 51
      goto switch_break___3;
      case_8___3: /* CIL Label */ 
#line 51
      if (pao_ID_____2 == 1) {
        {
#line 51
        __asm__  ("incq "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else
#line 51
      if (pao_ID_____2 == -1) {
        {
#line 51
        __asm__  ("decq "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]));
        }
      } else {
        {
#line 51
        __asm__  ("addq %1, "
                  "%%"
                  "gs"
                  ":"
                  "%P"
                  "0": "+m" (vm_event_states.event[item]): "re" ((pao_T_____16 )delta));
        }
      }
#line 51
      goto switch_break___3;
      switch_default___2: /* CIL Label */ 
      {
#line 51
      __bad_percpu_size();
      }
      switch_break___3: /* CIL Label */ ;
      }
#line 51
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 51
    goto switch_break;
    switch_default___3: /* CIL Label */ 
    {
#line 51
    __bad_size_call_parameter();
    }
#line 51
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 51
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return;
}
}
#line 54
extern void all_vm_events(unsigned long * ) ;
#line 56
extern void vm_events_fold_cpu(int cpu ) ;
#line 111
extern atomic_long_t vm_stat[39] ;
#line 113
__inline static void zone_page_state_add(long x , struct zone *zone , enum zone_stat_item item )  __attribute__((__no_instrument_function__)) ;
#line 113 "../../../analyzer/../bench/linux-headers/include/linux/vmstat.h"
__inline static void zone_page_state_add(long x , struct zone *zone , enum zone_stat_item item ) 
{ 


  {
  {
#line 116
  atomic_long_add(x, & zone->vm_stat[item]);
#line 117
  atomic_long_add(x, & vm_stat[item]);
  }
#line 118
  return;
}
}
#line 120
__inline static unsigned long global_page_state(enum zone_stat_item item )  __attribute__((__no_instrument_function__)) ;
#line 120 "../../../analyzer/../bench/linux-headers/include/linux/vmstat.h"
__inline static unsigned long global_page_state(enum zone_stat_item item ) 
{ 
  long x ;
  long tmp___7 ;

  {
  {
#line 122
  tmp___7 = atomic_long_read(& vm_stat[item]);
#line 122
  x = tmp___7;
  }
#line 124
  if (x < 0L) {
    {
#line 125
    x = 0L;
    }
  }
#line 127
  return ((unsigned long )x);
}
}
#line 130
__inline static unsigned long zone_page_state(struct zone *zone , enum zone_stat_item item )  __attribute__((__no_instrument_function__)) ;
#line 130 "../../../analyzer/../bench/linux-headers/include/linux/vmstat.h"
__inline static unsigned long zone_page_state(struct zone *zone , enum zone_stat_item item ) 
{ 
  long x ;
  long tmp___7 ;

  {
  {
#line 133
  tmp___7 = atomic_long_read(& zone->vm_stat[item]);
#line 133
  x = tmp___7;
  }
#line 135
  if (x < 0L) {
    {
#line 136
    x = 0L;
    }
  }
#line 138
  return ((unsigned long )x);
}
}
#line 147
__inline static unsigned long zone_page_state_snapshot(struct zone *zone , enum zone_stat_item item )  __attribute__((__no_instrument_function__)) ;
#line 147 "../../../analyzer/../bench/linux-headers/include/linux/vmstat.h"
__inline static unsigned long zone_page_state_snapshot(struct zone *zone , enum zone_stat_item item ) 
{ 
  long x ;
  long tmp___7 ;
  int cpu ;
  void const   *__vpp_verify ;
  unsigned long __ptr ;
  unsigned int tmp___8 ;

  {
  {
#line 150
  tmp___7 = atomic_long_read(& zone->vm_stat[item]);
#line 150
  x = tmp___7;
#line 154
  cpu = -1;
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 154
    tmp___8 = cpumask_next(cpu, (struct cpumask  const  *)cpu_online_mask);
#line 154
    cpu = (int )tmp___8;
    }
#line 154
    if (! (cpu < nr_cpu_ids)) {
#line 154
      goto while_break;
    }
    {
#line 155
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 155
      __vpp_verify = (void const   *)((struct per_cpu_pageset *)((void *)0));
      }
#line 155
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 155
    __asm__  ("": "=r" (__ptr): "0" (zone->pageset));
#line 155
    x += (long )((struct per_cpu_pageset *)(__ptr + __per_cpu_offset[cpu]))->vm_stat_diff[item];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  if (x < 0L) {
    {
#line 158
    x = 0L;
    }
  }
#line 160
  return ((unsigned long )x);
}
}
#line 169
__inline static unsigned long node_page_state(int node , enum zone_stat_item item )  __attribute__((__no_instrument_function__)) ;
#line 169 "../../../analyzer/../bench/linux-headers/include/linux/vmstat.h"
__inline static unsigned long node_page_state(int node , enum zone_stat_item item ) 
{ 
  struct zone *zones ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___10 ;

  {
  {
#line 172
  zones = (node_data[node])->node_zones;
#line 174
  tmp___7 = zone_page_state(zones + 0, item);
#line 174
  tmp___8 = zone_page_state(zones + 1, item);
#line 174
  tmp___9 = zone_page_state(zones + 2, item);
#line 174
  tmp___10 = zone_page_state(zones + 3, item);
  }
#line 174
  return (((tmp___7 + tmp___8) + tmp___9) + tmp___10);
}
}
#line 188
extern void zone_statistics(struct zone * , struct zone * , gfp_t gfp ) ;
#line 201
extern void __mod_zone_page_state(struct zone * , enum zone_stat_item item , int  ) ;
#line 202
extern void __inc_zone_page_state(struct page * , enum zone_stat_item  ) ;
#line 203
extern void __dec_zone_page_state(struct page * , enum zone_stat_item  ) ;
#line 205
extern void mod_zone_page_state(struct zone * , enum zone_stat_item  , int  ) ;
#line 206
extern void inc_zone_page_state(struct page * , enum zone_stat_item  ) ;
#line 207
extern void dec_zone_page_state(struct page * , enum zone_stat_item  ) ;
#line 209
extern void inc_zone_state(struct zone * , enum zone_stat_item  ) ;
#line 210
extern void __inc_zone_state(struct zone * , enum zone_stat_item  ) ;
#line 211
extern void dec_zone_state(struct zone * , enum zone_stat_item  ) ;
#line 212
extern void __dec_zone_state(struct zone * , enum zone_stat_item  ) ;
#line 214
extern void cpu_vm_stats_fold(int cpu ) ;
#line 215
extern void refresh_zone_stat_thresholds(void) ;
#line 217
extern void drain_zonestat(struct zone *zone , struct per_cpu_pageset * ) ;
#line 219
extern int calculate_pressure_threshold(struct zone *zone ) ;
#line 220
extern int calculate_normal_threshold(struct zone *zone ) ;
#line 221
extern void set_pgdat_percpu_threshold(pg_data_t *pgdat , int (*calculate_pressure)(struct zone * ) ) ;
#line 280
__inline static void __mod_zone_freepage_state(struct zone *zone , int nr_pages ,
                                               int migratetype )  __attribute__((__no_instrument_function__)) ;
#line 280 "../../../analyzer/../bench/linux-headers/include/linux/vmstat.h"
__inline static void __mod_zone_freepage_state(struct zone *zone , int nr_pages ,
                                               int migratetype ) 
{ 


  {
  {
#line 283
  __mod_zone_page_state(zone, (enum zone_stat_item )0, nr_pages);
  }
#line 286
  return;
}
}
#line 288
extern char const   * const  vmstat_text[] ;
#line 912 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void *( __attribute__((__always_inline__)) lowmem_page_address)(struct page  const  *page )  __attribute__((__no_instrument_function__)) ;
#line 912 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void *( __attribute__((__always_inline__)) lowmem_page_address)(struct page  const  *page ) 
{ 


  {
#line 914
  return ((void *)((unsigned long )((phys_addr_t )((unsigned long )(page - (struct page  const  *)((struct page *)0xffffea0000000000UL))) << 12) + 0xffff880000000000UL));
}
}
#line 965
extern struct address_space *page_mapping(struct page *page ) ;
#line 968
__inline static void *page_rmapping(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 968 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void *page_rmapping(struct page *page ) 
{ 


  {
#line 970
  return ((void *)((unsigned long )page->__annonCompField21.mapping & 0xfffffffffffffffcUL));
}
}
#line 973
extern struct address_space *__page_file_mapping(struct page * ) ;
#line 975
__inline static struct address_space *page_file_mapping(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 975 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static struct address_space *page_file_mapping(struct page *page ) 
{ 
  struct address_space *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;

  {
  {
#line 978
  tmp___8 = PageSwapCache((struct page  const  *)page);
  }
#line 978
  if (tmp___8) {
    {
#line 978
    tmp___9 = 1;
    }
  } else {
    {
#line 978
    tmp___9 = 0;
    }
  }
  {
#line 978
  tmp___10 = __builtin_expect((long )tmp___9, 0L);
  }
#line 978
  if (tmp___10) {
    {
#line 979
    tmp___7 = __page_file_mapping(page);
    }
#line 979
    return (tmp___7);
  }
#line 981
  return (page->__annonCompField21.mapping);
}
}
#line 984
__inline static int PageAnon(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 984 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static int PageAnon(struct page *page ) 
{ 


  {
#line 986
  return (((unsigned long )page->__annonCompField21.mapping & 1UL) != 0UL);
}
}
#line 993
__inline static unsigned long page_index(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 993 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static unsigned long page_index(struct page *page ) 
{ 
  int tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;

  {
  {
#line 995
  tmp___7 = PageSwapCache((struct page  const  *)page);
  }
#line 995
  if (tmp___7) {
    {
#line 995
    tmp___8 = 1;
    }
  } else {
    {
#line 995
    tmp___8 = 0;
    }
  }
  {
#line 995
  tmp___9 = __builtin_expect((long )tmp___8, 0L);
  }
#line 995
  if (tmp___9) {
#line 996
    return (page->__annonCompField30.private);
  }
#line 997
  return (page->__annonCompField27.__annonCompField22.index);
}
}
#line 1000
extern unsigned long __page_file_index(struct page *page ) ;
#line 1006
__inline static unsigned long page_file_index(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 1006 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static unsigned long page_file_index(struct page *page ) 
{ 
  unsigned long tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;

  {
  {
#line 1008
  tmp___8 = PageSwapCache((struct page  const  *)page);
  }
#line 1008
  if (tmp___8) {
    {
#line 1008
    tmp___9 = 1;
    }
  } else {
    {
#line 1008
    tmp___9 = 0;
    }
  }
  {
#line 1008
  tmp___10 = __builtin_expect((long )tmp___9, 0L);
  }
#line 1008
  if (tmp___10) {
    {
#line 1009
    tmp___7 = __page_file_index(page);
    }
#line 1009
    return (tmp___7);
  }
#line 1011
  return (page->__annonCompField27.__annonCompField22.index);
}
}
#line 1017
__inline static int page_mapped(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 1017 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static int page_mapped(struct page *page ) 
{ 
  int tmp___7 ;

  {
  {
#line 1019
  tmp___7 = atomic_read((atomic_t const   *)(& page->__annonCompField27.__annonCompField26.__annonCompField25.__annonCompField24._mapcount));
  }
#line 1019
  return (tmp___7 >= 0);
}
}
#line 1054
extern void pagefault_out_of_memory(void) ;
#line 1064
extern void show_free_areas(unsigned int flags ) ;
#line 1065
extern bool skip_free_areas_node(unsigned int flags , int nid ) ;
#line 1067
extern int shmem_zero_setup(struct vm_area_struct * ) ;
#line 1069
extern bool shmem_mapping(struct address_space *mapping ) ;
#line 1077
extern int can_do_mlock(void) ;
#line 1078
extern int user_shm_lock(size_t  , struct user_struct * ) ;
#line 1079
extern void user_shm_unlock(size_t  , struct user_struct * ) ;
#line 1091
extern struct page *vm_normal_page(struct vm_area_struct *vma , unsigned long addr ,
                                   pte_t pte ) ;
#line 1094
extern int zap_vma_ptes(struct vm_area_struct *vma , unsigned long address , unsigned long size ) ;
#line 1096
extern void zap_page_range(struct vm_area_struct *vma , unsigned long address , unsigned long size ,
                           struct zap_details * ) ;
#line 1098
extern void unmap_vmas(struct mmu_gather *tlb , struct vm_area_struct *start_vma ,
                       unsigned long start , unsigned long end ) ;
#line 1135
extern int walk_page_range(unsigned long addr , unsigned long end , struct mm_walk *walk ) ;
#line 1137
extern void free_pgd_range(struct mmu_gather *tlb , unsigned long addr , unsigned long end ,
                           unsigned long floor , unsigned long ceiling ) ;
#line 1139
extern int copy_page_range(struct mm_struct *dst , struct mm_struct *src , struct vm_area_struct *vma ) ;
#line 1141
extern void unmap_mapping_range(struct address_space *mapping , loff_t const   holebegin ,
                                loff_t const   holelen , int even_cows ) ;
#line 1143
extern int follow_pfn(struct vm_area_struct *vma , unsigned long address , unsigned long *pfn ) ;
#line 1145
extern int follow_phys(struct vm_area_struct *vma , unsigned long address , unsigned int flags ,
                       unsigned long *prot , resource_size_t *phys ) ;
#line 1147
extern int generic_access_phys(struct vm_area_struct *vma , unsigned long addr , void *buf ,
                               int len , int write ) ;
#line 1150
__inline static void unmap_shared_mapping_range(struct address_space *mapping , loff_t const   holebegin ,
                                                loff_t const   holelen )  __attribute__((__no_instrument_function__)) ;
#line 1150 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void unmap_shared_mapping_range(struct address_space *mapping , loff_t const   holebegin ,
                                                loff_t const   holelen ) 
{ 


  {
  {
#line 1153
  unmap_mapping_range(mapping, holebegin, holelen, 0);
  }
#line 1154
  return;
}
}
#line 1156
extern void truncate_pagecache(struct inode *inode , loff_t new ) ;
#line 1157
extern void truncate_setsize(struct inode *inode , loff_t newsize ) ;
#line 1158
extern void truncate_pagecache_range(struct inode *inode , loff_t offset , loff_t end ) ;
#line 1159
extern int truncate_inode_page(struct address_space *mapping , struct page *page ) ;
#line 1160
extern int generic_error_remove_page(struct address_space *mapping , struct page *page ) ;
#line 1161
extern int invalidate_inode_page(struct page *page ) ;
#line 1164
extern int handle_mm_fault(struct mm_struct *mm , struct vm_area_struct *vma , unsigned long address ,
                           unsigned int flags ) ;
#line 1166
extern int fixup_user_fault(struct task_struct *tsk , struct mm_struct *mm , unsigned long address ,
                            unsigned int fault_flags ) ;
#line 1187
extern int access_process_vm(struct task_struct *tsk , unsigned long addr , void *buf ,
                             int len , int write ) ;
#line 1188
extern int access_remote_vm(struct mm_struct *mm , unsigned long addr , void *buf ,
                            int len , int write ) ;
#line 1191
extern long __get_user_pages(struct task_struct *tsk , struct mm_struct *mm , unsigned long start ,
                             unsigned long nr_pages , unsigned int foll_flags , struct page **pages ,
                             struct vm_area_struct **vmas , int *nonblocking ) ;
#line 1195
extern long get_user_pages(struct task_struct *tsk , struct mm_struct *mm , unsigned long start ,
                           unsigned long nr_pages , int write , int force , struct page **pages ,
                           struct vm_area_struct **vmas ) ;
#line 1199
extern int get_user_pages_fast(unsigned long start , int nr_pages , int write , struct page **pages ) ;
#line 1202
extern int get_kernel_pages(struct kvec  const  *iov , int nr_pages , int write ,
                            struct page **pages ) ;
#line 1204
extern int get_kernel_page(unsigned long start , int write , struct page **pages ) ;
#line 1205
extern struct page *get_dump_page(unsigned long addr ) ;
#line 1207
extern int try_to_release_page(struct page *page , gfp_t gfp_mask ) ;
#line 1208
extern void do_invalidatepage(struct page *page , unsigned int offset , unsigned int length ) ;
#line 1211
extern int __set_page_dirty_nobuffers(struct page *page ) ;
#line 1212
extern int __set_page_dirty_no_writeback(struct page *page ) ;
#line 1213
extern int redirty_page_for_writepage(struct writeback_control *wbc , struct page *page ) ;
#line 1215
extern void account_page_dirtied(struct page *page , struct address_space *mapping ) ;
#line 1216
extern void account_page_writeback(struct page *page ) ;
#line 1217
extern int set_page_dirty(struct page *page ) ;
#line 1218
extern int set_page_dirty_lock(struct page *page ) ;
#line 1219
extern int clear_page_dirty_for_io(struct page *page ) ;
#line 1220
extern int get_cmdline(struct task_struct *task , char *buffer , int buflen ) ;
#line 1223
__inline static int vma_growsdown(struct vm_area_struct *vma , unsigned long addr )  __attribute__((__no_instrument_function__)) ;
#line 1223 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static int vma_growsdown(struct vm_area_struct *vma , unsigned long addr ) 
{ 
  int tmp___7 ;

  {
#line 1225
  if (vma) {
#line 1225
    if (vma->vm_end == addr) {
#line 1225
      if (vma->vm_flags & 256UL) {
        {
#line 1225
        tmp___7 = 1;
        }
      } else {
        {
#line 1225
        tmp___7 = 0;
        }
      }
    } else {
      {
#line 1225
      tmp___7 = 0;
      }
    }
  } else {
    {
#line 1225
    tmp___7 = 0;
    }
  }
#line 1225
  return (tmp___7);
}
}
#line 1228
__inline static int stack_guard_page_start(struct vm_area_struct *vma , unsigned long addr )  __attribute__((__no_instrument_function__)) ;
#line 1228 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static int stack_guard_page_start(struct vm_area_struct *vma , unsigned long addr ) 
{ 
  int tmp___7 ;
  int tmp___8 ;

  {
#line 1231
  if (vma->vm_flags & 256UL) {
#line 1231
    if (vma->vm_start == addr) {
      {
#line 1231
      tmp___7 = vma_growsdown(vma->vm_prev, addr);
      }
#line 1231
      if (tmp___7) {
        {
#line 1231
        tmp___8 = 0;
        }
      } else {
        {
#line 1231
        tmp___8 = 1;
        }
      }
    } else {
      {
#line 1231
      tmp___8 = 0;
      }
    }
  } else {
    {
#line 1231
    tmp___8 = 0;
    }
  }
#line 1231
  return (tmp___8);
}
}
#line 1237
__inline static int vma_growsup(struct vm_area_struct *vma , unsigned long addr )  __attribute__((__no_instrument_function__)) ;
#line 1237 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static int vma_growsup(struct vm_area_struct *vma , unsigned long addr ) 
{ 
  int tmp___7 ;

  {
#line 1239
  if (vma) {
#line 1239
    if (vma->vm_start == addr) {
      {
#line 1239
      tmp___7 = 0;
      }
    } else {
      {
#line 1239
      tmp___7 = 0;
      }
    }
  } else {
    {
#line 1239
    tmp___7 = 0;
    }
  }
#line 1239
  return (tmp___7);
}
}
#line 1242
__inline static int stack_guard_page_end(struct vm_area_struct *vma , unsigned long addr )  __attribute__((__no_instrument_function__)) ;
#line 1242 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static int stack_guard_page_end(struct vm_area_struct *vma , unsigned long addr ) 
{ 
  int tmp___7 ;

  {
#line 1245
  return (0);
}
}
#line 1250
extern pid_t vm_is_stack(struct task_struct *task , struct vm_area_struct *vma , int in_group ) ;
#line 1253
extern unsigned long move_page_tables(struct vm_area_struct *vma , unsigned long old_addr ,
                                      struct vm_area_struct *new_vma , unsigned long new_addr ,
                                      unsigned long len , bool need_rmap_locks ) ;
#line 1257
extern unsigned long change_protection(struct vm_area_struct *vma , unsigned long start ,
                                       unsigned long end , pgprot_t newprot , int dirty_accountable ,
                                       int prot_numa ) ;
#line 1260
extern int mprotect_fixup(struct vm_area_struct *vma , struct vm_area_struct **pprev ,
                          unsigned long start , unsigned long end , unsigned long newflags ) ;
#line 1267
extern int __get_user_pages_fast(unsigned long start , int nr_pages , int write ,
                                 struct page **pages ) ;
#line 1272
__inline static unsigned long get_mm_counter(struct mm_struct *mm , int member )  __attribute__((__no_instrument_function__)) ;
#line 1272 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static unsigned long get_mm_counter(struct mm_struct *mm , int member ) 
{ 
  long val ;
  long tmp___7 ;

  {
  {
#line 1274
  tmp___7 = atomic_long_read(& mm->rss_stat.count[member]);
#line 1274
  val = tmp___7;
  }
#line 1281
  if (val < 0L) {
    {
#line 1282
    val = 0L;
    }
  }
#line 1284
  return ((unsigned long )val);
}
}
#line 1287
__inline static void add_mm_counter(struct mm_struct *mm , int member , long value )  __attribute__((__no_instrument_function__)) ;
#line 1287 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void add_mm_counter(struct mm_struct *mm , int member , long value ) 
{ 


  {
  {
#line 1289
  atomic_long_add(value, & mm->rss_stat.count[member]);
  }
#line 1290
  return;
}
}
#line 1292
__inline static void inc_mm_counter(struct mm_struct *mm , int member )  __attribute__((__no_instrument_function__)) ;
#line 1292 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void inc_mm_counter(struct mm_struct *mm , int member ) 
{ 


  {
  {
#line 1294
  atomic_long_inc(& mm->rss_stat.count[member]);
  }
#line 1295
  return;
}
}
#line 1297
__inline static void dec_mm_counter(struct mm_struct *mm , int member )  __attribute__((__no_instrument_function__)) ;
#line 1297 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void dec_mm_counter(struct mm_struct *mm , int member ) 
{ 


  {
  {
#line 1299
  atomic_long_dec(& mm->rss_stat.count[member]);
  }
#line 1300
  return;
}
}
#line 1302
__inline static unsigned long get_mm_rss(struct mm_struct *mm )  __attribute__((__no_instrument_function__)) ;
#line 1302 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static unsigned long get_mm_rss(struct mm_struct *mm ) 
{ 
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;

  {
  {
#line 1304
  tmp___7 = get_mm_counter(mm, 0);
#line 1304
  tmp___8 = get_mm_counter(mm, 1);
  }
#line 1304
  return (tmp___7 + tmp___8);
}
}
#line 1308
__inline static unsigned long get_mm_hiwater_rss(struct mm_struct *mm )  __attribute__((__no_instrument_function__)) ;
#line 1308 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static unsigned long get_mm_hiwater_rss(struct mm_struct *mm ) 
{ 
  unsigned long _max1 ;
  unsigned long _max2 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;

  {
  {
#line 1310
  _max1 = mm->hiwater_rss;
#line 1310
  tmp___7 = get_mm_rss(mm);
#line 1310
  _max2 = tmp___7;
  }
#line 1310
  if (_max1 > _max2) {
    {
#line 1310
    tmp___8 = _max1;
    }
  } else {
    {
#line 1310
    tmp___8 = _max2;
    }
  }
#line 1310
  return (tmp___8);
}
}
#line 1313
__inline static unsigned long get_mm_hiwater_vm(struct mm_struct *mm )  __attribute__((__no_instrument_function__)) ;
#line 1313 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static unsigned long get_mm_hiwater_vm(struct mm_struct *mm ) 
{ 
  unsigned long _max1 ;
  unsigned long _max2 ;
  unsigned long tmp___7 ;

  {
  {
#line 1315
  _max1 = mm->hiwater_vm;
#line 1315
  _max2 = mm->total_vm;
  }
#line 1315
  if (_max1 > _max2) {
    {
#line 1315
    tmp___7 = _max1;
    }
  } else {
    {
#line 1315
    tmp___7 = _max2;
    }
  }
#line 1315
  return (tmp___7);
}
}
#line 1318
__inline static void update_hiwater_rss(struct mm_struct *mm )  __attribute__((__no_instrument_function__)) ;
#line 1318 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void update_hiwater_rss(struct mm_struct *mm ) 
{ 
  unsigned long _rss ;
  unsigned long tmp___7 ;

  {
  {
#line 1320
  tmp___7 = get_mm_rss(mm);
#line 1320
  _rss = tmp___7;
  }
#line 1322
  if (mm->hiwater_rss < _rss) {
    {
#line 1323
    mm->hiwater_rss = _rss;
    }
  }
#line 1324
  return;
}
}
#line 1326
__inline static void update_hiwater_vm(struct mm_struct *mm )  __attribute__((__no_instrument_function__)) ;
#line 1326 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void update_hiwater_vm(struct mm_struct *mm ) 
{ 


  {
#line 1328
  if (mm->hiwater_vm < mm->total_vm) {
    {
#line 1329
    mm->hiwater_vm = mm->total_vm;
    }
  }
#line 1330
  return;
}
}
#line 1332
__inline static void setmax_mm_hiwater_rss(unsigned long *maxrss , struct mm_struct *mm )  __attribute__((__no_instrument_function__)) ;
#line 1332 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void setmax_mm_hiwater_rss(unsigned long *maxrss , struct mm_struct *mm ) 
{ 
  unsigned long hiwater_rss ;
  unsigned long tmp___7 ;

  {
  {
#line 1335
  tmp___7 = get_mm_hiwater_rss(mm);
#line 1335
  hiwater_rss = tmp___7;
  }
#line 1337
  if (*maxrss < hiwater_rss) {
    {
#line 1338
    *maxrss = hiwater_rss;
    }
  }
#line 1339
  return;
}
}
#line 1342
extern void sync_mm_rss(struct mm_struct *mm ) ;
#line 1349
extern int vma_wants_writenotify(struct vm_area_struct *vma ) ;
#line 1351
extern pte_t *__get_locked_pte(struct mm_struct *mm , unsigned long addr , spinlock_t **ptl ) ;
#line 1353
__inline static pte_t *get_locked_pte(struct mm_struct *mm , unsigned long addr ,
                                      spinlock_t **ptl )  __attribute__((__no_instrument_function__)) ;
#line 1353 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static pte_t *get_locked_pte(struct mm_struct *mm , unsigned long addr ,
                                      spinlock_t **ptl ) 
{ 
  pte_t *ptep ;

  {
  {
#line 1357
  ptep = __get_locked_pte(mm, addr, ptl);
  }
#line 1358
  return (ptep);
}
}
#line 1368
extern int __pud_alloc(struct mm_struct *mm , pgd_t *pgd , unsigned long address ) ;
#line 1378
extern int __pmd_alloc(struct mm_struct *mm , pud_t *pud , unsigned long address ) ;
#line 1381
extern int __pte_alloc(struct mm_struct *mm , struct vm_area_struct *vma , pmd_t *pmd ,
                       unsigned long address ) ;
#line 1383
extern int __pte_alloc_kernel(pmd_t *pmd , unsigned long address ) ;
#line 1390
__inline static pud_t *pud_alloc(struct mm_struct *mm , pgd_t *pgd , unsigned long address )  __attribute__((__no_instrument_function__)) ;
#line 1390 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static pud_t *pud_alloc(struct mm_struct *mm , pgd_t *pgd , unsigned long address ) 
{ 
  int tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  pud_t *tmp___11 ;
  pud_t *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  long tmp___15 ;
  int tmp___16 ;

  {
  {
#line 1392
  tmp___13 = pgd_none(*pgd);
  }
#line 1392
  if (tmp___13) {
    {
#line 1392
    tmp___14 = 1;
    }
  } else {
    {
#line 1392
    tmp___14 = 0;
    }
  }
  {
#line 1392
  tmp___15 = __builtin_expect((long )tmp___14, 0L);
  }
#line 1392
  if (tmp___15) {
    {
#line 1392
    tmp___16 = __pud_alloc(mm, pgd, address);
    }
#line 1392
    if (tmp___16) {
      {
#line 1392
      tmp___12 = (pud_t *)((void *)0);
      }
    } else {
      {
#line 1392
      tmp___11 = pud_offset(pgd, address);
#line 1392
      tmp___12 = tmp___11;
      }
    }
  } else {
    {
#line 1392
    tmp___11 = pud_offset(pgd, address);
#line 1392
    tmp___12 = tmp___11;
    }
  }
#line 1392
  return (tmp___12);
}
}
#line 1396
__inline static pmd_t *pmd_alloc(struct mm_struct *mm , pud_t *pud , unsigned long address )  __attribute__((__no_instrument_function__)) ;
#line 1396 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static pmd_t *pmd_alloc(struct mm_struct *mm , pud_t *pud , unsigned long address ) 
{ 
  int tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  pmd_t *tmp___11 ;
  pmd_t *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  long tmp___15 ;
  int tmp___16 ;

  {
  {
#line 1398
  tmp___13 = pud_none(*pud);
  }
#line 1398
  if (tmp___13) {
    {
#line 1398
    tmp___14 = 1;
    }
  } else {
    {
#line 1398
    tmp___14 = 0;
    }
  }
  {
#line 1398
  tmp___15 = __builtin_expect((long )tmp___14, 0L);
  }
#line 1398
  if (tmp___15) {
    {
#line 1398
    tmp___16 = __pmd_alloc(mm, pud, address);
    }
#line 1398
    if (tmp___16) {
      {
#line 1398
      tmp___12 = (pmd_t *)((void *)0);
      }
    } else {
      {
#line 1398
      tmp___11 = pmd_offset(pud, address);
#line 1398
      tmp___12 = tmp___11;
      }
    }
  } else {
    {
#line 1398
    tmp___11 = pmd_offset(pud, address);
#line 1398
    tmp___12 = tmp___11;
    }
  }
#line 1398
  return (tmp___12);
}
}
#line 1414
__inline static void ptlock_cache_init(void)  __attribute__((__no_instrument_function__)) ;
#line 1414 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void ptlock_cache_init(void) 
{ 


  {
#line 1416
  return;
}
}
#line 1418
__inline static bool ptlock_alloc(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 1418 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static bool ptlock_alloc(struct page *page ) 
{ 


  {
#line 1420
  return ((bool )1);
}
}
#line 1423
__inline static void ptlock_free(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 1423 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void ptlock_free(struct page *page ) 
{ 


  {
#line 1425
  return;
}
}
#line 1427
__inline static spinlock_t *ptlock_ptr(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 1427 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static spinlock_t *ptlock_ptr(struct page *page ) 
{ 


  {
#line 1429
  return (& page->__annonCompField30.ptl);
}
}
#line 1433
__inline static spinlock_t *pte_lockptr(struct mm_struct *mm , pmd_t *pmd )  __attribute__((__no_instrument_function__)) ;
#line 1433 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static spinlock_t *pte_lockptr(struct mm_struct *mm , pmd_t *pmd ) 
{ 
  pmdval_t tmp___7 ;
  spinlock_t *tmp___8 ;

  {
  {
#line 1435
  tmp___7 = native_pmd_val(*pmd);
#line 1435
  tmp___8 = ptlock_ptr((struct page *)0xffffea0000000000UL + ((tmp___7 & (pteval_t )((unsigned long long )((long )(~ ((1UL << 12) - 1UL))) & ((1ULL << 46) - 1ULL))) >> 12));
  }
#line 1435
  return (tmp___8);
}
}
#line 1451 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
static struct lock_class_key __key___2  ;
#line 1438
__inline static bool ptlock_init(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 1438 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static bool ptlock_init(struct page *page ) 
{ 
  bool tmp___7 ;
  spinlock_t *tmp___8 ;
  spinlock_t *tmp___9 ;

  {
  {
#line 1449
  tmp___7 = ptlock_alloc(page);
  }
#line 1449
  if (! tmp___7) {
#line 1450
    return ((bool )0);
  }
  {
#line 1451
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1451
    tmp___8 = ptlock_ptr(page);
#line 1451
    spinlock_check(tmp___8);
    }
    {
#line 1451
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1451
      tmp___9 = ptlock_ptr(page);
#line 1451
      __raw_spin_lock_init(& tmp___9->__annonCompField18.rlock, "&(ptlock_ptr(page))->rlock",
                           & __key___2);
      }
#line 1451
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1451
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1452
  return ((bool )1);
}
}
#line 1456
__inline static void pte_lock_deinit(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 1456 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void pte_lock_deinit(struct page *page ) 
{ 


  {
  {
#line 1458
  page->__annonCompField21.mapping = (struct address_space *)((void *)0);
#line 1459
  ptlock_free(page);
  }
#line 1460
  return;
}
}
#line 1475
__inline static void pgtable_init(void)  __attribute__((__no_instrument_function__)) ;
#line 1475 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void pgtable_init(void) 
{ 


  {
  {
#line 1477
  ptlock_cache_init();
  }
  {
#line 1478
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1478
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1479
  return;
}
}
#line 1481
__inline static bool pgtable_page_ctor(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 1481 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static bool pgtable_page_ctor(struct page *page ) 
{ 
  bool tmp___7 ;

  {
  {
#line 1483
  inc_zone_page_state(page, (enum zone_stat_item )15);
#line 1484
  tmp___7 = ptlock_init(page);
  }
#line 1484
  return (tmp___7);
}
}
#line 1487
__inline static void pgtable_page_dtor(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 1487 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void pgtable_page_dtor(struct page *page ) 
{ 


  {
  {
#line 1489
  pte_lock_deinit(page);
#line 1490
  dec_zone_page_state(page, (enum zone_stat_item )15);
  }
#line 1491
  return;
}
}
#line 1523 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
static struct page *pmd_to_page(pmd_t *pmd ) 
{ 
  unsigned long mask ;
  unsigned long tmp___7 ;

  {
  {
#line 1525
  mask = ~ (512UL * sizeof(pmd_t ) - 1UL);
#line 1526
  tmp___7 = __phys_addr_nodebug((unsigned long )((void *)((unsigned long )pmd & mask)));
  }
#line 1526
  return ((struct page *)0xffffea0000000000UL + (tmp___7 >> 12));
}
}
#line 1529
__inline static spinlock_t *pmd_lockptr(struct mm_struct *mm , pmd_t *pmd )  __attribute__((__no_instrument_function__)) ;
#line 1529 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static spinlock_t *pmd_lockptr(struct mm_struct *mm , pmd_t *pmd ) 
{ 
  struct page *tmp___7 ;
  spinlock_t *tmp___8 ;

  {
  {
#line 1531
  tmp___7 = pmd_to_page(pmd);
#line 1531
  tmp___8 = ptlock_ptr(tmp___7);
  }
#line 1531
  return (tmp___8);
}
}
#line 1534
__inline static bool pgtable_pmd_page_ctor(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 1534 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static bool pgtable_pmd_page_ctor(struct page *page ) 
{ 
  bool tmp___7 ;

  {
  {
#line 1539
  tmp___7 = ptlock_init(page);
  }
#line 1539
  return (tmp___7);
}
}
#line 1542
__inline static void pgtable_pmd_page_dtor(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 1542 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void pgtable_pmd_page_dtor(struct page *page ) 
{ 


  {
  {
#line 1547
  ptlock_free(page);
  }
#line 1548
  return;
}
}
#line 1566
__inline static spinlock_t *pmd_lock(struct mm_struct *mm , pmd_t *pmd )  __attribute__((__no_instrument_function__)) ;
#line 1566 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static spinlock_t *pmd_lock(struct mm_struct *mm , pmd_t *pmd ) 
{ 
  spinlock_t *ptl ;
  spinlock_t *tmp___7 ;

  {
  {
#line 1568
  tmp___7 = pmd_lockptr(mm, pmd);
#line 1568
  ptl = tmp___7;
#line 1569
  spin_lock(ptl);
  }
#line 1570
  return (ptl);
}
}
#line 1573
extern void free_area_init(unsigned long *zones_size ) ;
#line 1574
extern void free_area_init_node(int nid , unsigned long *zones_size , unsigned long zone_start_pfn ,
                                unsigned long *zholes_size ) ;
#line 1576
extern void free_initmem(void) ;
#line 1584
extern unsigned long free_reserved_area(void *start , void *end , int poison , char *s ) ;
#line 1595
extern void adjust_managed_page_count(struct page *page , long count ) ;
#line 1596
extern void mem_init_print_info(char const   *str ) ;
#line 1599
__inline static void __free_reserved_page(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 1599 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void __free_reserved_page(struct page *page ) 
{ 


  {
  {
#line 1601
  ClearPageReserved(page);
#line 1602
  init_page_count(page);
#line 1603
  __free_pages(page, 0U);
  }
#line 1604
  return;
}
}
#line 1606
__inline static void free_reserved_page(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 1606 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void free_reserved_page(struct page *page ) 
{ 


  {
  {
#line 1608
  __free_reserved_page(page);
#line 1609
  adjust_managed_page_count(page, 1L);
  }
#line 1610
  return;
}
}
#line 1612
__inline static void mark_page_reserved(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 1612 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void mark_page_reserved(struct page *page ) 
{ 


  {
  {
#line 1614
  SetPageReserved(page);
#line 1615
  adjust_managed_page_count(page, -1L);
  }
#line 1616
  return;
}
}
#line 1624
__inline static unsigned long free_initmem_default(int poison )  __attribute__((__no_instrument_function__)) ;
#line 1624 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static unsigned long free_initmem_default(int poison ) 
{ 
  unsigned long tmp___7 ;

  {
  {
#line 1628
  tmp___7 = free_reserved_area((void *)(& __init_begin), (void *)(& __init_end), poison,
                               (char *)"unused kernel");
  }
#line 1628
  return (tmp___7);
}
}
#line 1632
__inline static unsigned long get_num_physpages(void)  __attribute__((__no_instrument_function__)) ;
#line 1632 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static unsigned long get_num_physpages(void) 
{ 
  int nid ;
  unsigned long phys_pages ;

  {
  {
#line 1635
  phys_pages = 0UL;
#line 1637
  nid = __first_node((nodemask_t const   *)(& node_states[1]));
  }
  {
#line 1637
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1637
    if (! (nid < 1 << 6)) {
#line 1637
      goto while_break;
    }
    {
#line 1638
    phys_pages += (node_data[nid])->node_present_pages;
#line 1637
    nid = __next_node(nid, (nodemask_t const   *)(& node_states[1]));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1640
  return (phys_pages);
}
}
#line 1670
extern void free_area_init_nodes(unsigned long *max_zone_pfn ) ;
#line 1671
extern unsigned long node_map_pfn_alignment(void) ;
#line 1672
extern unsigned long __absent_pages_in_range(int nid , unsigned long start_pfn , unsigned long end_pfn ) ;
#line 1674
extern unsigned long absent_pages_in_range(unsigned long start_pfn , unsigned long end_pfn ) ;
#line 1676
extern void get_pfn_range_for_nid(unsigned int nid , unsigned long *start_pfn , unsigned long *end_pfn ) ;
#line 1678
extern unsigned long find_min_pfn_with_active_regions(void) ;
#line 1679
extern void free_bootmem_with_active_regions(int nid , unsigned long max_low_pfn ) ;
#line 1681
extern void sparse_memory_present_with_active_regions(int nid ) ;
#line 1693
extern int __attribute__((__cold__))  early_pfn_to_nid(unsigned long pfn )  __attribute__((__section__(".meminit.text"),
__no_instrument_function__)) ;
#line 1695
extern int __attribute__((__cold__))  __early_pfn_to_nid(unsigned long pfn )  __attribute__((__section__(".meminit.text"),
__no_instrument_function__)) ;
#line 1698
extern void set_dma_reserve(unsigned long new_dma_reserve ) ;
#line 1699
extern void memmap_init_zone(unsigned long  , int  , unsigned long  , unsigned long  ,
                             enum memmap_context  ) ;
#line 1701
extern void setup_per_zone_wmarks(void) ;
#line 1702
extern int __attribute__((__cold__))  init_per_zone_wmark_min(void)  __attribute__((__section__(".meminit.text"),
__no_instrument_function__)) ;
#line 1703
extern void mem_init(void) ;
#line 1704
extern void __attribute__((__cold__))  mmap_init(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 1705
extern void show_mem(unsigned int flags ) ;
#line 1706
extern void si_meminfo(struct sysinfo *val ) ;
#line 1707
extern void si_meminfo_node(struct sysinfo *val , int nid ) ;
#line 1709
extern void ( /* format attribute */  warn_alloc_failed)(gfp_t gfp_mask , int order ,
                                                         char const   *fmt  , ...) ;
#line 1712
extern void setup_per_cpu_pageset(void) ;
#line 1714
extern void zone_pcp_update(struct zone *zone ) ;
#line 1715
extern void zone_pcp_reset(struct zone *zone ) ;
#line 1718
extern int min_free_kbytes ;
#line 1721
extern atomic_long_t mmap_pages_allocated ;
#line 1722
extern int nommu_shrink_inode_mappings(struct inode * , size_t  , size_t  ) ;
#line 1725
extern void vma_interval_tree_insert(struct vm_area_struct *node , struct rb_root *root ) ;
#line 1727
extern void vma_interval_tree_insert_after(struct vm_area_struct *node , struct vm_area_struct *prev ,
                                           struct rb_root *root ) ;
#line 1730
extern void vma_interval_tree_remove(struct vm_area_struct *node , struct rb_root *root ) ;
#line 1732
extern struct vm_area_struct *vma_interval_tree_iter_first(struct rb_root *root ,
                                                           unsigned long start , unsigned long last ) ;
#line 1734
extern struct vm_area_struct *vma_interval_tree_iter_next(struct vm_area_struct *node ,
                                                          unsigned long start , unsigned long last ) ;
#line 1741
__inline static void vma_nonlinear_insert(struct vm_area_struct *vma , struct list_head *list )  __attribute__((__no_instrument_function__)) ;
#line 1741 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void vma_nonlinear_insert(struct vm_area_struct *vma , struct list_head *list ) 
{ 


  {
  {
#line 1744
  list_add_tail(& vma->shared.nonlinear, list);
  }
#line 1745
  return;
}
}
#line 1747
extern void anon_vma_interval_tree_insert(struct anon_vma_chain *node , struct rb_root *root ) ;
#line 1749
extern void anon_vma_interval_tree_remove(struct anon_vma_chain *node , struct rb_root *root ) ;
#line 1751
extern struct anon_vma_chain *anon_vma_interval_tree_iter_first(struct rb_root *root ,
                                                                unsigned long start ,
                                                                unsigned long last ) ;
#line 1753
extern struct anon_vma_chain *anon_vma_interval_tree_iter_next(struct anon_vma_chain *node ,
                                                               unsigned long start ,
                                                               unsigned long last ) ;
#line 1764
extern int __vm_enough_memory(struct mm_struct *mm , long pages , int cap_sys_admin ) ;
#line 1765
extern int vma_adjust(struct vm_area_struct *vma , unsigned long start , unsigned long end ,
                      unsigned long pgoff , struct vm_area_struct *insert ) ;
#line 1767
extern struct vm_area_struct *vma_merge(struct mm_struct * , struct vm_area_struct *prev ,
                                        unsigned long addr , unsigned long end , unsigned long vm_flags ,
                                        struct anon_vma * , struct file * , unsigned long  ,
                                        struct mempolicy * ) ;
#line 1771
extern struct anon_vma *find_mergeable_anon_vma(struct vm_area_struct * ) ;
#line 1772
extern int split_vma(struct mm_struct * , struct vm_area_struct * , unsigned long addr ,
                     int new_below ) ;
#line 1774
extern int insert_vm_struct(struct mm_struct * , struct vm_area_struct * ) ;
#line 1775
extern void __vma_link_rb(struct mm_struct * , struct vm_area_struct * , struct rb_node ** ,
                          struct rb_node * ) ;
#line 1777
extern void unlink_file_vma(struct vm_area_struct * ) ;
#line 1778
extern struct vm_area_struct *copy_vma(struct vm_area_struct ** , unsigned long addr ,
                                       unsigned long len , unsigned long pgoff , bool *need_rmap_locks ) ;
#line 1781
extern void exit_mmap(struct mm_struct * ) ;
#line 1783
extern int mm_take_all_locks(struct mm_struct *mm ) ;
#line 1784
extern void mm_drop_all_locks(struct mm_struct *mm ) ;
#line 1786
extern void set_mm_exe_file(struct mm_struct *mm , struct file *new_exe_file ) ;
#line 1787
extern struct file *get_mm_exe_file(struct mm_struct *mm ) ;
#line 1789
extern int may_expand_vm(struct mm_struct *mm , unsigned long npages ) ;
#line 1790
extern struct vm_area_struct *_install_special_mapping(struct mm_struct *mm , unsigned long addr ,
                                                       unsigned long len , unsigned long flags ,
                                                       struct vm_special_mapping  const  *spec ) ;
#line 1795
extern int install_special_mapping(struct mm_struct *mm , unsigned long addr , unsigned long len ,
                                   unsigned long flags , struct page **pages ) ;
#line 1799
extern unsigned long get_unmapped_area(struct file * , unsigned long  , unsigned long  ,
                                       unsigned long  , unsigned long  ) ;
#line 1801
extern unsigned long mmap_region(struct file *file , unsigned long addr , unsigned long len ,
                                 vm_flags_t vm_flags , unsigned long pgoff ) ;
#line 1803
extern unsigned long do_mmap_pgoff(struct file *file , unsigned long addr , unsigned long len ,
                                   unsigned long prot , unsigned long flags , unsigned long pgoff ,
                                   unsigned long *populate ) ;
#line 1806
extern int do_munmap(struct mm_struct * , unsigned long  , size_t  ) ;
#line 1809
extern int __mm_populate(unsigned long addr , unsigned long len , int ignore_errors ) ;
#line 1811
__inline static void mm_populate(unsigned long addr , unsigned long len )  __attribute__((__no_instrument_function__)) ;
#line 1811 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void mm_populate(unsigned long addr , unsigned long len ) 
{ 


  {
  {
#line 1814
  __mm_populate(addr, len, 1);
  }
#line 1815
  return;
}
}
#line 1821
extern unsigned long vm_brk(unsigned long  , unsigned long  ) ;
#line 1822
extern int vm_munmap(unsigned long  , size_t  ) ;
#line 1823
extern unsigned long vm_mmap(struct file * , unsigned long  , unsigned long  , unsigned long  ,
                             unsigned long  , unsigned long  ) ;
#line 1837
extern unsigned long unmapped_area(struct vm_unmapped_area_info *info ) ;
#line 1838
extern unsigned long unmapped_area_topdown(struct vm_unmapped_area_info *info ) ;
#line 1849
__inline static unsigned long vm_unmapped_area(struct vm_unmapped_area_info *info )  __attribute__((__no_instrument_function__)) ;
#line 1849 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static unsigned long vm_unmapped_area(struct vm_unmapped_area_info *info ) 
{ 
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;

  {
#line 1852
  if (! (info->flags & 1UL)) {
    {
#line 1853
    tmp___7 = unmapped_area(info);
    }
#line 1853
    return (tmp___7);
  } else {
    {
#line 1855
    tmp___8 = unmapped_area_topdown(info);
    }
#line 1855
    return (tmp___8);
  }
}
}
#line 1859
extern void truncate_inode_pages(struct address_space * , loff_t  ) ;
#line 1860
extern void truncate_inode_pages_range(struct address_space * , loff_t lstart , loff_t lend ) ;
#line 1862
extern void truncate_inode_pages_final(struct address_space * ) ;
#line 1865
extern int filemap_fault(struct vm_area_struct * , struct vm_fault * ) ;
#line 1866
extern void filemap_map_pages(struct vm_area_struct *vma , struct vm_fault *vmf ) ;
#line 1867
extern int filemap_page_mkwrite(struct vm_area_struct *vma , struct vm_fault *vmf ) ;
#line 1870
extern int write_one_page(struct page *page , int wait ) ;
#line 1871
extern void task_dirty_inc(struct task_struct *tsk ) ;
#line 1877
extern int force_page_cache_readahead(struct address_space *mapping , struct file *filp ,
                                      unsigned long offset , unsigned long nr_to_read ) ;
#line 1880
extern void page_cache_sync_readahead(struct address_space *mapping , struct file_ra_state *ra ,
                                      struct file *filp , unsigned long offset , unsigned long size ) ;
#line 1886
extern void page_cache_async_readahead(struct address_space *mapping , struct file_ra_state *ra ,
                                       struct file *filp , struct page *pg , unsigned long offset ,
                                       unsigned long size ) ;
#line 1893
extern unsigned long max_sane_readahead(unsigned long nr ) ;
#line 1896
extern int expand_stack(struct vm_area_struct *vma , unsigned long address ) ;
#line 1899
extern int expand_downwards(struct vm_area_struct *vma , unsigned long address ) ;
#line 1908
extern struct vm_area_struct *find_vma(struct mm_struct *mm , unsigned long addr ) ;
#line 1909
extern struct vm_area_struct *find_vma_prev(struct mm_struct *mm , unsigned long addr ,
                                            struct vm_area_struct **pprev ) ;
#line 1914
__inline static struct vm_area_struct *find_vma_intersection(struct mm_struct *mm ,
                                                             unsigned long start_addr ,
                                                             unsigned long end_addr )  __attribute__((__no_instrument_function__)) ;
#line 1914 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static struct vm_area_struct *find_vma_intersection(struct mm_struct *mm ,
                                                             unsigned long start_addr ,
                                                             unsigned long end_addr ) 
{ 
  struct vm_area_struct *vma ;
  struct vm_area_struct *tmp___7 ;

  {
  {
#line 1916
  tmp___7 = find_vma(mm, start_addr);
#line 1916
  vma = tmp___7;
  }
#line 1918
  if (vma) {
#line 1918
    if (end_addr <= vma->vm_start) {
      {
#line 1919
      vma = (struct vm_area_struct *)((void *)0);
      }
    }
  }
#line 1920
  return (vma);
}
}
#line 1923
__inline static unsigned long vma_pages(struct vm_area_struct *vma )  __attribute__((__no_instrument_function__)) ;
#line 1923 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static unsigned long vma_pages(struct vm_area_struct *vma ) 
{ 


  {
#line 1925
  return ((vma->vm_end - vma->vm_start) >> 12);
}
}
#line 1929
__inline static struct vm_area_struct *find_exact_vma(struct mm_struct *mm , unsigned long vm_start ,
                                                      unsigned long vm_end )  __attribute__((__no_instrument_function__)) ;
#line 1929 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static struct vm_area_struct *find_exact_vma(struct mm_struct *mm , unsigned long vm_start ,
                                                      unsigned long vm_end ) 
{ 
  struct vm_area_struct *vma ;
  struct vm_area_struct *tmp___7 ;

  {
  {
#line 1932
  tmp___7 = find_vma(mm, vm_start);
#line 1932
  vma = tmp___7;
  }
#line 1934
  if (vma) {
#line 1934
    if (vma->vm_start != vm_start) {
      {
#line 1935
      vma = (struct vm_area_struct *)((void *)0);
      }
    } else
#line 1934
    if (vma->vm_end != vm_end) {
      {
#line 1935
      vma = (struct vm_area_struct *)((void *)0);
      }
    }
  }
#line 1937
  return (vma);
}
}
#line 1941
extern pgprot_t vm_get_page_prot(unsigned long vm_flags ) ;
#line 1954
extern struct vm_area_struct *find_extend_vma(struct mm_struct * , unsigned long addr ) ;
#line 1955
extern int remap_pfn_range(struct vm_area_struct * , unsigned long addr , unsigned long pfn ,
                           unsigned long size , pgprot_t  ) ;
#line 1957
extern int vm_insert_page(struct vm_area_struct * , unsigned long addr , struct page * ) ;
#line 1958
extern int vm_insert_pfn(struct vm_area_struct *vma , unsigned long addr , unsigned long pfn ) ;
#line 1960
extern int vm_insert_mixed(struct vm_area_struct *vma , unsigned long addr , unsigned long pfn ) ;
#line 1962
extern int vm_iomap_memory(struct vm_area_struct *vma , phys_addr_t start , unsigned long len ) ;
#line 1965
extern struct page *follow_page_mask(struct vm_area_struct *vma , unsigned long address ,
                                     unsigned int foll_flags , unsigned int *page_mask ) ;
#line 1969
__inline static struct page *follow_page(struct vm_area_struct *vma , unsigned long address ,
                                         unsigned int foll_flags )  __attribute__((__no_instrument_function__)) ;
#line 1969 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static struct page *follow_page(struct vm_area_struct *vma , unsigned long address ,
                                         unsigned int foll_flags ) 
{ 
  unsigned int unused_page_mask ;
  struct page *tmp___7 ;

  {
  {
#line 1973
  tmp___7 = follow_page_mask(vma, address, foll_flags, & unused_page_mask);
  }
#line 1973
  return (tmp___7);
}
}
#line 1991
extern int apply_to_page_range(struct mm_struct *mm , unsigned long address , unsigned long size ,
                               int (*fn)(pte_t *pte , pgtable_t token , unsigned long addr ,
                                         void *data ) , void *data ) ;
#line 1995
extern void vm_stat_account(struct mm_struct * , unsigned long  , struct file * ,
                            long  ) ;
#line 2010
__inline static void kernel_map_pages(struct page *page , int numpages , int enable )  __attribute__((__no_instrument_function__)) ;
#line 2010 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static void kernel_map_pages(struct page *page , int numpages , int enable ) 
{ 


  {
#line 2011
  return;
}
}
#line 2013
__inline static bool kernel_page_present(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 2013 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static bool kernel_page_present(struct page *page ) 
{ 


  {
#line 2013
  return ((bool )1);
}
}
#line 2018
extern struct vm_area_struct *get_gate_vma(struct mm_struct *mm ) ;
#line 2019
extern int in_gate_area_no_mm(unsigned long addr ) ;
#line 2020
extern int in_gate_area(struct mm_struct *mm , unsigned long addr ) ;
#line 2034
extern int sysctl_drop_caches ;
#line 2035
extern int drop_caches_sysctl_handler(struct ctl_table * , int  , void * , size_t * ,
                                      loff_t * ) ;
#line 2039
extern unsigned long shrink_slab(struct shrink_control *shrink , unsigned long nr_pages_scanned ,
                                 unsigned long lru_pages ) ;
#line 2046
extern int randomize_va_space ;
#line 2049
extern char const   *arch_vma_name(struct vm_area_struct *vma ) ;
#line 2050
extern void print_vma_addr(char *prefix , unsigned long rip ) ;
#line 2052
extern void sparse_mem_maps_populate_node(struct page **map_map , unsigned long pnum_begin ,
                                          unsigned long pnum_end , unsigned long map_count ,
                                          int nodeid ) ;
#line 2058
extern struct page *sparse_mem_map_populate(unsigned long pnum , int nid ) ;
#line 2059
extern pgd_t *vmemmap_pgd_populate(unsigned long addr , int node ) ;
#line 2060
extern pud_t *vmemmap_pud_populate(pgd_t *pgd , unsigned long addr , int node ) ;
#line 2061
extern pmd_t *vmemmap_pmd_populate(pud_t *pud , unsigned long addr , int node ) ;
#line 2062
extern pte_t *vmemmap_pte_populate(pmd_t *pmd , unsigned long addr , int node ) ;
#line 2063
extern void *vmemmap_alloc_block(unsigned long size , int node ) ;
#line 2064
extern void *vmemmap_alloc_block_buf(unsigned long size , int node ) ;
#line 2065
extern void vmemmap_verify(pte_t * , int  , unsigned long  , unsigned long  ) ;
#line 2066
extern int vmemmap_populate_basepages(unsigned long start , unsigned long end , int node ) ;
#line 2068
extern int vmemmap_populate(unsigned long start , unsigned long end , int node ) ;
#line 2069
extern void vmemmap_populate_print_last(void) ;
#line 2073
extern void register_page_bootmem_memmap(unsigned long section_nr , struct page *map ,
                                         unsigned long size ) ;
#line 2082
extern int memory_failure(unsigned long pfn , int trapno , int flags ) ;
#line 2083
extern void memory_failure_queue(unsigned long pfn , int trapno , int flags ) ;
#line 2084
extern int unpoison_memory(unsigned long pfn ) ;
#line 2085
extern int sysctl_memory_failure_early_kill ;
#line 2086
extern int sysctl_memory_failure_recovery ;
#line 2087
extern void shake_page(struct page *p , int access ) ;
#line 2088
extern atomic_long_t num_poisoned_pages ;
#line 2089
extern int soft_offline_page(struct page *page , int flags ) ;
#line 2092
extern void clear_huge_page(struct page *page , unsigned long addr , unsigned int pages_per_huge_page ) ;
#line 2095
extern void copy_user_huge_page(struct page *dst , struct page *src , unsigned long addr ,
                                struct vm_area_struct *vma , unsigned int pages_per_huge_page ) ;
#line 2113
__inline static unsigned int debug_guardpage_minorder(void)  __attribute__((__no_instrument_function__)) ;
#line 2113 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static unsigned int debug_guardpage_minorder(void) 
{ 


  {
#line 2113
  return (0U);
}
}
#line 2114
__inline static bool page_is_guard(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 2114 "../../../analyzer/../bench/linux-headers/include/linux/mm.h"
__inline static bool page_is_guard(struct page *page ) 
{ 


  {
#line 2114
  return ((bool )0);
}
}
#line 2118
extern void __attribute__((__cold__))  setup_nr_node_ids(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 25 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pci.h"
extern int pci_routeirq ;
#line 32
__inline static int pci_domain_nr(struct pci_bus *bus )  __attribute__((__no_instrument_function__)) ;
#line 32 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pci.h"
__inline static int pci_domain_nr(struct pci_bus *bus ) 
{ 
  struct pci_sysdata *sd ;

  {
  {
#line 34
  sd = (struct pci_sysdata *)bus->sysdata;
  }
#line 35
  return (sd->domain);
}
}
#line 38
__inline static int pci_proc_domain(struct pci_bus *bus )  __attribute__((__no_instrument_function__)) ;
#line 38 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pci.h"
__inline static int pci_proc_domain(struct pci_bus *bus ) 
{ 
  int tmp___7 ;

  {
  {
#line 40
  tmp___7 = pci_domain_nr(bus);
  }
#line 40
  return (tmp___7);
}
}
#line 48
extern unsigned int pcibios_assign_all_busses(void) ;
#line 49
extern int pci_legacy_init(void) ;
#line 66
extern int pcibios_enabled ;
#line 67
extern void pcibios_config_init(void) ;
#line 68
extern void pcibios_scan_root(int bus ) ;
#line 70
extern void pcibios_set_master(struct pci_dev *dev ) ;
#line 71
extern struct irq_routing_table *pcibios_get_irq_routing_table(void) ;
#line 72
extern int pcibios_set_irq_routing(struct pci_dev *dev , int pin , int irq ) ;
#line 76
extern int pci_mmap_page_range(struct pci_dev *dev , struct vm_area_struct *vma ,
                               enum pci_mmap_state mmap_state , int write_combine ) ;
#line 82
extern void early_quirks(void) ;
#line 83
__inline static void pci_dma_burst_advice(struct pci_dev *pdev , enum pci_dma_burst_strategy *strat ,
                                          unsigned long *strategy_parameter )  __attribute__((__no_instrument_function__)) ;
#line 83 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pci.h"
__inline static void pci_dma_burst_advice(struct pci_dev *pdev , enum pci_dma_burst_strategy *strat ,
                                          unsigned long *strategy_parameter ) 
{ 


  {
  {
#line 87
  *strat = (enum pci_dma_burst_strategy )0;
#line 88
  *strategy_parameter = ~ 0UL;
  }
#line 89
  return;
}
}
#line 94
extern void pci_iommu_alloc(void) ;
#line 99
extern int native_setup_msi_irqs(struct pci_dev *dev , int nvec , int type ) ;
#line 100
extern void native_teardown_msi_irq(unsigned int irq ) ;
#line 101
extern void native_restore_msi_irqs(struct pci_dev *dev ) ;
#line 102
extern int setup_msi_irq(struct pci_dev *dev , struct msi_desc *msidesc , unsigned int irq_base ,
                         unsigned int irq_offset ) ;
#line 7 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pci_64.h"
__inline static void *pci_iommu(struct pci_bus *bus )  __attribute__((__no_instrument_function__)) ;
#line 7 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pci_64.h"
__inline static void *pci_iommu(struct pci_bus *bus ) 
{ 
  struct pci_sysdata *sd ;

  {
  {
#line 9
  sd = (struct pci_sysdata *)bus->sysdata;
  }
#line 10
  return (sd->iommu);
}
}
#line 13
__inline static void set_pci_iommu(struct pci_bus *bus , void *val )  __attribute__((__no_instrument_function__)) ;
#line 13 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pci_64.h"
__inline static void set_pci_iommu(struct pci_bus *bus , void *val ) 
{ 
  struct pci_sysdata *sd ;

  {
  {
#line 15
  sd = (struct pci_sysdata *)bus->sysdata;
#line 16
  sd->iommu = val;
  }
#line 17
  return;
}
}
#line 20
extern int (*pci_config_read)(int seg , int bus , int dev , int fn , int reg , int len ,
                              u32 *value ) ;
#line 22
extern int (*pci_config_write)(int seg , int bus , int dev , int fn , int reg , int len ,
                               u32 value ) ;
#line 39 "../../../analyzer/../bench/linux-headers/include/linux/dma-attrs.h"
__inline static void init_dma_attrs(struct dma_attrs *attrs )  __attribute__((__no_instrument_function__)) ;
#line 39 "../../../analyzer/../bench/linux-headers/include/linux/dma-attrs.h"
__inline static void init_dma_attrs(struct dma_attrs *attrs ) 
{ 


  {
  {
#line 41
  bitmap_zero(attrs->flags, (int )(((7UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))));
  }
#line 42
  return;
}
}
#line 50
__inline static void dma_set_attr(enum dma_attr attr , struct dma_attrs *attrs )  __attribute__((__no_instrument_function__)) ;
#line 50 "../../../analyzer/../bench/linux-headers/include/linux/dma-attrs.h"
__inline static void dma_set_attr(enum dma_attr attr , struct dma_attrs *attrs ) 
{ 
  long tmp___7 ;

  {
#line 52
  if ((unsigned long )attrs == (unsigned long )((void *)0)) {
#line 53
    return;
  }
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 54
    tmp___7 = __builtin_expect((long )(! (! ((unsigned int )attr >= 7U))), 0L);
    }
#line 54
    if (tmp___7) {
      {
#line 54
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 54
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("../../../analyzer/../bench/linux-headers/include/linux/dma-attrs.h"),
                             "i" (54), "i" (sizeof(struct bug_entry )));
#line 54
        __builtin_unreachable();
        }
#line 54
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 54
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 55
  __set_bit((long )attr, (unsigned long volatile   *)(attrs->flags));
  }
#line 56
  return;
}
}
#line 63
__inline static int dma_get_attr(enum dma_attr attr , struct dma_attrs *attrs )  __attribute__((__no_instrument_function__)) ;
#line 63 "../../../analyzer/../bench/linux-headers/include/linux/dma-attrs.h"
__inline static int dma_get_attr(enum dma_attr attr , struct dma_attrs *attrs ) 
{ 
  long tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 65
  if ((unsigned long )attrs == (unsigned long )((void *)0)) {
#line 66
    return (0);
  }
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 67
    tmp___7 = __builtin_expect((long )(! (! ((unsigned int )attr >= 7U))), 0L);
    }
#line 67
    if (tmp___7) {
      {
#line 67
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 67
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("../../../analyzer/../bench/linux-headers/include/linux/dma-attrs.h"),
                             "i" (67), "i" (sizeof(struct bug_entry )));
#line 67
        __builtin_unreachable();
        }
#line 67
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 67
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 68
  tmp___9 = variable_test_bit((long )attr, (unsigned long const volatile   *)(attrs->flags));
  }
#line 68
  return (tmp___9);
}
}
#line 57 "../../../analyzer/../bench/linux-headers/include/linux/scatterlist.h"
__inline static void sg_assign_page(struct scatterlist *sg , struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 57 "../../../analyzer/../bench/linux-headers/include/linux/scatterlist.h"
__inline static void sg_assign_page(struct scatterlist *sg , struct page *page ) 
{ 
  unsigned long page_link ;
  long tmp___7 ;

  {
  {
#line 59
  page_link = sg->page_link & 3UL;
  }
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 65
    tmp___7 = __builtin_expect((long )(! (! ((unsigned long )page & 3UL))), 0L);
    }
#line 65
    if (tmp___7) {
      {
#line 65
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 65
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("../../../analyzer/../bench/linux-headers/include/linux/scatterlist.h"),
                             "i" (65), "i" (sizeof(struct bug_entry )));
#line 65
        __builtin_unreachable();
        }
#line 65
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 65
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 70
  sg->page_link = page_link | (unsigned long )page;
  }
#line 71
  return;
}
}
#line 87
__inline static void sg_set_page(struct scatterlist *sg , struct page *page , unsigned int len ,
                                 unsigned int offset )  __attribute__((__no_instrument_function__)) ;
#line 87 "../../../analyzer/../bench/linux-headers/include/linux/scatterlist.h"
__inline static void sg_set_page(struct scatterlist *sg , struct page *page , unsigned int len ,
                                 unsigned int offset ) 
{ 


  {
  {
#line 90
  sg_assign_page(sg, page);
#line 91
  sg->offset = offset;
#line 92
  sg->length = len;
  }
#line 93
  return;
}
}
#line 95
__inline static struct page *sg_page(struct scatterlist *sg )  __attribute__((__no_instrument_function__)) ;
#line 95 "../../../analyzer/../bench/linux-headers/include/linux/scatterlist.h"
__inline static struct page *sg_page(struct scatterlist *sg ) 
{ 


  {
#line 101
  return ((struct page *)(sg->page_link & 0xfffffffffffffffcUL));
}
}
#line 111
__inline static void sg_set_buf(struct scatterlist *sg , void const   *buf , unsigned int buflen )  __attribute__((__no_instrument_function__)) ;
#line 111 "../../../analyzer/../bench/linux-headers/include/linux/scatterlist.h"
__inline static void sg_set_buf(struct scatterlist *sg , void const   *buf , unsigned int buflen ) 
{ 
  unsigned long tmp___7 ;

  {
  {
#line 117
  tmp___7 = __phys_addr_nodebug((unsigned long )buf);
#line 117
  sg_set_page(sg, (struct page *)0xffffea0000000000UL + (tmp___7 >> 12), buflen, (unsigned int )((unsigned long )buf & ~ (~ ((1UL << 12) - 1UL))));
  }
#line 118
  return;
}
}
#line 136
__inline static void sg_chain(struct scatterlist *prv , unsigned int prv_nents , struct scatterlist *sgl )  __attribute__((__no_instrument_function__)) ;
#line 136 "../../../analyzer/../bench/linux-headers/include/linux/scatterlist.h"
__inline static void sg_chain(struct scatterlist *prv , unsigned int prv_nents , struct scatterlist *sgl ) 
{ 


  {
  {
#line 146
  (prv + (prv_nents - 1U))->offset = 0U;
#line 147
  (prv + (prv_nents - 1U))->length = 0U;
#line 153
  (prv + (prv_nents - 1U))->page_link = ((unsigned long )sgl | 1UL) & 0xfffffffffffffffdUL;
  }
#line 154
  return;
}
}
#line 165
__inline static void sg_mark_end(struct scatterlist *sg )  __attribute__((__no_instrument_function__)) ;
#line 165 "../../../analyzer/../bench/linux-headers/include/linux/scatterlist.h"
__inline static void sg_mark_end(struct scatterlist *sg ) 
{ 


  {
  {
#line 173
  sg->page_link |= 2UL;
#line 174
  sg->page_link &= 0xfffffffffffffffeUL;
  }
#line 175
  return;
}
}
#line 185
__inline static void sg_unmark_end(struct scatterlist *sg )  __attribute__((__no_instrument_function__)) ;
#line 185 "../../../analyzer/../bench/linux-headers/include/linux/scatterlist.h"
__inline static void sg_unmark_end(struct scatterlist *sg ) 
{ 


  {
  {
#line 190
  sg->page_link &= 0xfffffffffffffffdUL;
  }
#line 191
  return;
}
}
#line 203
__inline static dma_addr_t sg_phys(struct scatterlist *sg )  __attribute__((__no_instrument_function__)) ;
#line 203 "../../../analyzer/../bench/linux-headers/include/linux/scatterlist.h"
__inline static dma_addr_t sg_phys(struct scatterlist *sg ) 
{ 
  struct page *tmp___7 ;

  {
  {
#line 205
  tmp___7 = sg_page(sg);
  }
#line 205
  return (((dma_addr_t )((unsigned long )(tmp___7 - (struct page *)0xffffea0000000000UL)) << 12) + (dma_addr_t )sg->offset);
}
}
#line 218
__inline static void *sg_virt(struct scatterlist *sg )  __attribute__((__no_instrument_function__)) ;
#line 218 "../../../analyzer/../bench/linux-headers/include/linux/scatterlist.h"
__inline static void *sg_virt(struct scatterlist *sg ) 
{ 
  struct page *tmp___7 ;
  void *tmp___8 ;

  {
  {
#line 220
  tmp___7 = sg_page(sg);
#line 220
  tmp___8 = lowmem_page_address((struct page  const  *)tmp___7);
  }
#line 220
  return (tmp___8 + sg->offset);
}
}
#line 223
extern int sg_nents(struct scatterlist *sg ) ;
#line 224
extern struct scatterlist *sg_next(struct scatterlist * ) ;
#line 225
extern struct scatterlist *sg_last(struct scatterlist *s , unsigned int  ) ;
#line 226
extern void sg_init_table(struct scatterlist * , unsigned int  ) ;
#line 227
extern void sg_init_one(struct scatterlist * , void const   * , unsigned int  ) ;
#line 232
extern void __sg_free_table(struct sg_table * , unsigned int  , bool  , sg_free_fn * ) ;
#line 233
extern void sg_free_table(struct sg_table * ) ;
#line 234
extern int __sg_alloc_table(struct sg_table * , unsigned int  , unsigned int  , struct scatterlist * ,
                            gfp_t  , sg_alloc_fn * ) ;
#line 236
extern int sg_alloc_table(struct sg_table * , unsigned int  , gfp_t  ) ;
#line 237
extern int sg_alloc_table_from_pages(struct sg_table *sgt , struct page **pages ,
                                     unsigned int n_pages , unsigned long offset ,
                                     unsigned long size , gfp_t gfp_mask ) ;
#line 242
extern size_t sg_copy_from_buffer(struct scatterlist *sgl , unsigned int nents , void *buf ,
                                  size_t buflen ) ;
#line 244
extern size_t sg_copy_to_buffer(struct scatterlist *sgl , unsigned int nents , void *buf ,
                                size_t buflen ) ;
#line 247
extern size_t sg_pcopy_from_buffer(struct scatterlist *sgl , unsigned int nents ,
                                   void *buf , size_t buflen , off_t skip ) ;
#line 249
extern size_t sg_pcopy_to_buffer(struct scatterlist *sgl , unsigned int nents , void *buf ,
                                 size_t buflen , off_t skip ) ;
#line 278
extern bool __sg_page_iter_next(struct sg_page_iter *piter ) ;
#line 279
extern void __sg_page_iter_start(struct sg_page_iter *piter , struct scatterlist *sglist ,
                                 unsigned int nents , unsigned long pgoffset ) ;
#line 286
__inline static struct page *sg_page_iter_page(struct sg_page_iter *piter )  __attribute__((__no_instrument_function__)) ;
#line 286 "../../../analyzer/../bench/linux-headers/include/linux/scatterlist.h"
__inline static struct page *sg_page_iter_page(struct sg_page_iter *piter ) 
{ 
  struct page *tmp___7 ;

  {
  {
#line 288
  tmp___7 = sg_page(piter->sg);
  }
#line 288
  return ((struct page *)0xffffea0000000000UL + ((unsigned long )(tmp___7 - (struct page *)0xffffea0000000000UL) + (unsigned long )piter->sg_pgoffset));
}
}
#line 296
__inline static dma_addr_t sg_page_iter_dma_address(struct sg_page_iter *piter )  __attribute__((__no_instrument_function__)) ;
#line 296 "../../../analyzer/../bench/linux-headers/include/linux/scatterlist.h"
__inline static dma_addr_t sg_page_iter_dma_address(struct sg_page_iter *piter ) 
{ 


  {
#line 298
  return ((piter->sg)->dma_address + (dma_addr_t )(piter->sg_pgoffset << 12));
}
}
#line 346
extern void sg_miter_start(struct sg_mapping_iter *miter , struct scatterlist *sgl ,
                           unsigned int nents , unsigned int flags ) ;
#line 348
extern bool sg_miter_skip(struct sg_mapping_iter *miter , off_t offset ) ;
#line 349
extern bool sg_miter_next(struct sg_mapping_iter *miter ) ;
#line 350
extern void sg_miter_stop(struct sg_mapping_iter *miter ) ;
#line 69 "../../../analyzer/../bench/linux-headers/include/linux/dma-mapping.h"
__inline static int valid_dma_direction(int dma_direction )  __attribute__((__no_instrument_function__)) ;
#line 69 "../../../analyzer/../bench/linux-headers/include/linux/dma-mapping.h"
__inline static int valid_dma_direction(int dma_direction ) 
{ 
  int tmp___7 ;

  {
#line 71
  if (dma_direction == 0) {
    {
#line 71
    tmp___7 = 1;
    }
  } else
#line 71
  if (dma_direction == 1) {
    {
#line 71
    tmp___7 = 1;
    }
  } else
#line 71
  if (dma_direction == 2) {
    {
#line 71
    tmp___7 = 1;
    }
  } else {
    {
#line 71
    tmp___7 = 0;
    }
  }
#line 71
  return (tmp___7);
}
}
#line 76
__inline static int is_device_dma_capable(struct device *dev )  __attribute__((__no_instrument_function__)) ;
#line 76 "../../../analyzer/../bench/linux-headers/include/linux/dma-mapping.h"
__inline static int is_device_dma_capable(struct device *dev ) 
{ 
  int tmp___7 ;

  {
#line 78
  if ((unsigned long )dev->dma_mask != (unsigned long )((void *)0)) {
#line 78
    if (*(dev->dma_mask) != 0ULL) {
      {
#line 78
      tmp___7 = 1;
      }
    } else {
      {
#line 78
      tmp___7 = 0;
      }
    }
  } else {
    {
#line 78
    tmp___7 = 0;
    }
  }
#line 78
  return (tmp___7);
}
}
#line 92 "../../../analyzer/../bench/linux-headers/include/linux/kmemcheck.h"
__inline static void kmemcheck_alloc_shadow(struct page *page , int order , gfp_t flags ,
                                            int node )  __attribute__((__no_instrument_function__)) ;
#line 92 "../../../analyzer/../bench/linux-headers/include/linux/kmemcheck.h"
__inline static void kmemcheck_alloc_shadow(struct page *page , int order , gfp_t flags ,
                                            int node ) 
{ 


  {
#line 95
  return;
}
}
#line 97
__inline static void kmemcheck_free_shadow(struct page *page , int order )  __attribute__((__no_instrument_function__)) ;
#line 97 "../../../analyzer/../bench/linux-headers/include/linux/kmemcheck.h"
__inline static void kmemcheck_free_shadow(struct page *page , int order ) 
{ 


  {
#line 100
  return;
}
}
#line 102
__inline static void kmemcheck_slab_alloc(struct kmem_cache *s , gfp_t gfpflags ,
                                          void *object , size_t size )  __attribute__((__no_instrument_function__)) ;
#line 102 "../../../analyzer/../bench/linux-headers/include/linux/kmemcheck.h"
__inline static void kmemcheck_slab_alloc(struct kmem_cache *s , gfp_t gfpflags ,
                                          void *object , size_t size ) 
{ 


  {
#line 106
  return;
}
}
#line 108
__inline static void kmemcheck_slab_free(struct kmem_cache *s , void *object , size_t size )  __attribute__((__no_instrument_function__)) ;
#line 108 "../../../analyzer/../bench/linux-headers/include/linux/kmemcheck.h"
__inline static void kmemcheck_slab_free(struct kmem_cache *s , void *object , size_t size ) 
{ 


  {
#line 111
  return;
}
}
#line 113
__inline static void kmemcheck_pagealloc_alloc(struct page *p , unsigned int order ,
                                               gfp_t gfpflags )  __attribute__((__no_instrument_function__)) ;
#line 113 "../../../analyzer/../bench/linux-headers/include/linux/kmemcheck.h"
__inline static void kmemcheck_pagealloc_alloc(struct page *p , unsigned int order ,
                                               gfp_t gfpflags ) 
{ 


  {
#line 116
  return;
}
}
#line 118
__inline static bool kmemcheck_page_is_tracked(struct page *p )  __attribute__((__no_instrument_function__)) ;
#line 118 "../../../analyzer/../bench/linux-headers/include/linux/kmemcheck.h"
__inline static bool kmemcheck_page_is_tracked(struct page *p ) 
{ 


  {
#line 120
  return ((bool )0);
}
}
#line 123
__inline static void kmemcheck_mark_unallocated(void *address , unsigned int n )  __attribute__((__no_instrument_function__)) ;
#line 123 "../../../analyzer/../bench/linux-headers/include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_unallocated(void *address , unsigned int n ) 
{ 


  {
#line 125
  return;
}
}
#line 127
__inline static void kmemcheck_mark_uninitialized(void *address , unsigned int n )  __attribute__((__no_instrument_function__)) ;
#line 127 "../../../analyzer/../bench/linux-headers/include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_uninitialized(void *address , unsigned int n ) 
{ 


  {
#line 129
  return;
}
}
#line 131
__inline static void kmemcheck_mark_initialized(void *address , unsigned int n )  __attribute__((__no_instrument_function__)) ;
#line 131 "../../../analyzer/../bench/linux-headers/include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_initialized(void *address , unsigned int n ) 
{ 


  {
#line 133
  return;
}
}
#line 135
__inline static void kmemcheck_mark_freed(void *address , unsigned int n )  __attribute__((__no_instrument_function__)) ;
#line 135 "../../../analyzer/../bench/linux-headers/include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_freed(void *address , unsigned int n ) 
{ 


  {
#line 137
  return;
}
}
#line 139
__inline static void kmemcheck_mark_unallocated_pages(struct page *p , unsigned int n )  __attribute__((__no_instrument_function__)) ;
#line 139 "../../../analyzer/../bench/linux-headers/include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_unallocated_pages(struct page *p , unsigned int n ) 
{ 


  {
#line 142
  return;
}
}
#line 144
__inline static void kmemcheck_mark_uninitialized_pages(struct page *p , unsigned int n )  __attribute__((__no_instrument_function__)) ;
#line 144 "../../../analyzer/../bench/linux-headers/include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_uninitialized_pages(struct page *p , unsigned int n ) 
{ 


  {
#line 147
  return;
}
}
#line 149
__inline static void kmemcheck_mark_initialized_pages(struct page *p , unsigned int n )  __attribute__((__no_instrument_function__)) ;
#line 149 "../../../analyzer/../bench/linux-headers/include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_initialized_pages(struct page *p , unsigned int n ) 
{ 


  {
#line 152
  return;
}
}
#line 154
__inline static bool kmemcheck_is_obj_initialized(unsigned long addr , size_t size )  __attribute__((__no_instrument_function__)) ;
#line 154 "../../../analyzer/../bench/linux-headers/include/linux/kmemcheck.h"
__inline static bool kmemcheck_is_obj_initialized(unsigned long addr , size_t size ) 
{ 


  {
#line 156
  return ((bool )1);
}
}
#line 92 "../../../analyzer/../bench/linux-headers/include/linux/dma-debug.h"
__inline static void dma_debug_add_bus(struct bus_type *bus )  __attribute__((__no_instrument_function__)) ;
#line 92 "../../../analyzer/../bench/linux-headers/include/linux/dma-debug.h"
__inline static void dma_debug_add_bus(struct bus_type *bus ) 
{ 


  {
#line 94
  return;
}
}
#line 96
__inline static void dma_debug_init(u32 num_entries )  __attribute__((__no_instrument_function__)) ;
#line 96 "../../../analyzer/../bench/linux-headers/include/linux/dma-debug.h"
__inline static void dma_debug_init(u32 num_entries ) 
{ 


  {
#line 98
  return;
}
}
#line 100
__inline static int dma_debug_resize_entries(u32 num_entries )  __attribute__((__no_instrument_function__)) ;
#line 100 "../../../analyzer/../bench/linux-headers/include/linux/dma-debug.h"
__inline static int dma_debug_resize_entries(u32 num_entries ) 
{ 


  {
#line 102
  return (0);
}
}
#line 105
__inline static void debug_dma_map_page(struct device *dev , struct page *page , size_t offset ,
                                        size_t size , int direction , dma_addr_t dma_addr ,
                                        bool map_single )  __attribute__((__no_instrument_function__)) ;
#line 105 "../../../analyzer/../bench/linux-headers/include/linux/dma-debug.h"
__inline static void debug_dma_map_page(struct device *dev , struct page *page , size_t offset ,
                                        size_t size , int direction , dma_addr_t dma_addr ,
                                        bool map_single ) 
{ 


  {
#line 110
  return;
}
}
#line 112
__inline static void debug_dma_mapping_error(struct device *dev , dma_addr_t dma_addr )  __attribute__((__no_instrument_function__)) ;
#line 112 "../../../analyzer/../bench/linux-headers/include/linux/dma-debug.h"
__inline static void debug_dma_mapping_error(struct device *dev , dma_addr_t dma_addr ) 
{ 


  {
#line 115
  return;
}
}
#line 117
__inline static void debug_dma_unmap_page(struct device *dev , dma_addr_t addr , size_t size ,
                                          int direction , bool map_single )  __attribute__((__no_instrument_function__)) ;
#line 117 "../../../analyzer/../bench/linux-headers/include/linux/dma-debug.h"
__inline static void debug_dma_unmap_page(struct device *dev , dma_addr_t addr , size_t size ,
                                          int direction , bool map_single ) 
{ 


  {
#line 121
  return;
}
}
#line 123
__inline static void debug_dma_map_sg(struct device *dev , struct scatterlist *sg ,
                                      int nents , int mapped_ents , int direction )  __attribute__((__no_instrument_function__)) ;
#line 123 "../../../analyzer/../bench/linux-headers/include/linux/dma-debug.h"
__inline static void debug_dma_map_sg(struct device *dev , struct scatterlist *sg ,
                                      int nents , int mapped_ents , int direction ) 
{ 


  {
#line 126
  return;
}
}
#line 128
__inline static void debug_dma_unmap_sg(struct device *dev , struct scatterlist *sglist ,
                                        int nelems , int dir )  __attribute__((__no_instrument_function__)) ;
#line 128 "../../../analyzer/../bench/linux-headers/include/linux/dma-debug.h"
__inline static void debug_dma_unmap_sg(struct device *dev , struct scatterlist *sglist ,
                                        int nelems , int dir ) 
{ 


  {
#line 132
  return;
}
}
#line 134
__inline static void debug_dma_alloc_coherent(struct device *dev , size_t size , dma_addr_t dma_addr ,
                                              void *virt )  __attribute__((__no_instrument_function__)) ;
#line 134 "../../../analyzer/../bench/linux-headers/include/linux/dma-debug.h"
__inline static void debug_dma_alloc_coherent(struct device *dev , size_t size , dma_addr_t dma_addr ,
                                              void *virt ) 
{ 


  {
#line 137
  return;
}
}
#line 139
__inline static void debug_dma_free_coherent(struct device *dev , size_t size , void *virt ,
                                             dma_addr_t addr )  __attribute__((__no_instrument_function__)) ;
#line 139 "../../../analyzer/../bench/linux-headers/include/linux/dma-debug.h"
__inline static void debug_dma_free_coherent(struct device *dev , size_t size , void *virt ,
                                             dma_addr_t addr ) 
{ 


  {
#line 142
  return;
}
}
#line 144
__inline static void debug_dma_sync_single_for_cpu(struct device *dev , dma_addr_t dma_handle ,
                                                   size_t size , int direction )  __attribute__((__no_instrument_function__)) ;
#line 144 "../../../analyzer/../bench/linux-headers/include/linux/dma-debug.h"
__inline static void debug_dma_sync_single_for_cpu(struct device *dev , dma_addr_t dma_handle ,
                                                   size_t size , int direction ) 
{ 


  {
#line 148
  return;
}
}
#line 150
__inline static void debug_dma_sync_single_for_device(struct device *dev , dma_addr_t dma_handle ,
                                                      size_t size , int direction )  __attribute__((__no_instrument_function__)) ;
#line 150 "../../../analyzer/../bench/linux-headers/include/linux/dma-debug.h"
__inline static void debug_dma_sync_single_for_device(struct device *dev , dma_addr_t dma_handle ,
                                                      size_t size , int direction ) 
{ 


  {
#line 154
  return;
}
}
#line 156
__inline static void debug_dma_sync_single_range_for_cpu(struct device *dev , dma_addr_t dma_handle ,
                                                         unsigned long offset , size_t size ,
                                                         int direction )  __attribute__((__no_instrument_function__)) ;
#line 156 "../../../analyzer/../bench/linux-headers/include/linux/dma-debug.h"
__inline static void debug_dma_sync_single_range_for_cpu(struct device *dev , dma_addr_t dma_handle ,
                                                         unsigned long offset , size_t size ,
                                                         int direction ) 
{ 


  {
#line 162
  return;
}
}
#line 164
__inline static void debug_dma_sync_single_range_for_device(struct device *dev , dma_addr_t dma_handle ,
                                                            unsigned long offset ,
                                                            size_t size , int direction )  __attribute__((__no_instrument_function__)) ;
#line 164 "../../../analyzer/../bench/linux-headers/include/linux/dma-debug.h"
__inline static void debug_dma_sync_single_range_for_device(struct device *dev , dma_addr_t dma_handle ,
                                                            unsigned long offset ,
                                                            size_t size , int direction ) 
{ 


  {
#line 170
  return;
}
}
#line 172
__inline static void debug_dma_sync_sg_for_cpu(struct device *dev , struct scatterlist *sg ,
                                               int nelems , int direction )  __attribute__((__no_instrument_function__)) ;
#line 172 "../../../analyzer/../bench/linux-headers/include/linux/dma-debug.h"
__inline static void debug_dma_sync_sg_for_cpu(struct device *dev , struct scatterlist *sg ,
                                               int nelems , int direction ) 
{ 


  {
#line 176
  return;
}
}
#line 178
__inline static void debug_dma_sync_sg_for_device(struct device *dev , struct scatterlist *sg ,
                                                  int nelems , int direction )  __attribute__((__no_instrument_function__)) ;
#line 178 "../../../analyzer/../bench/linux-headers/include/linux/dma-debug.h"
__inline static void debug_dma_sync_sg_for_device(struct device *dev , struct scatterlist *sg ,
                                                  int nelems , int direction ) 
{ 


  {
#line 182
  return;
}
}
#line 184
__inline static void debug_dma_dump_mappings(struct device *dev )  __attribute__((__no_instrument_function__)) ;
#line 184 "../../../analyzer/../bench/linux-headers/include/linux/dma-debug.h"
__inline static void debug_dma_dump_mappings(struct device *dev ) 
{ 


  {
#line 186
  return;
}
}
#line 188
__inline static void debug_dma_assert_idle(struct page *page )  __attribute__((__no_instrument_function__)) ;
#line 188 "../../../analyzer/../bench/linux-headers/include/linux/dma-debug.h"
__inline static void debug_dma_assert_idle(struct page *page ) 
{ 


  {
#line 190
  return;
}
}
#line 10 "../../../analyzer/../bench/linux-headers/include/linux/swiotlb.h"
extern int swiotlb_force ;
#line 25
extern void swiotlb_init(int verbose ) ;
#line 26
extern int swiotlb_init_with_tbl(char *tlb , unsigned long nslabs , int verbose ) ;
#line 27
extern unsigned long swiotlb_nr_tbl(void) ;
#line 28
extern unsigned long swiotlb_size_or_default(void) ;
#line 29
extern int swiotlb_late_init_with_tbl(char *tlb , unsigned long nslabs ) ;
#line 42
extern phys_addr_t swiotlb_tbl_map_single(struct device *hwdev , dma_addr_t tbl_dma_addr ,
                                          phys_addr_t phys , size_t size , enum dma_data_direction dir ) ;
#line 47
extern void swiotlb_tbl_unmap_single(struct device *hwdev , phys_addr_t tlb_addr ,
                                     size_t size , enum dma_data_direction dir ) ;
#line 51
extern void swiotlb_tbl_sync_single(struct device *hwdev , phys_addr_t tlb_addr ,
                                    size_t size , enum dma_data_direction dir , enum dma_sync_target target ) ;
#line 57
extern void *swiotlb_alloc_coherent(struct device *hwdev , size_t size , dma_addr_t *dma_handle ,
                                    gfp_t flags ) ;
#line 61
extern void swiotlb_free_coherent(struct device *hwdev , size_t size , void *vaddr ,
                                  dma_addr_t dma_handle ) ;
#line 65
extern dma_addr_t swiotlb_map_page(struct device *dev , struct page *page , unsigned long offset ,
                                   size_t size , enum dma_data_direction dir , struct dma_attrs *attrs ) ;
#line 69
extern void swiotlb_unmap_page(struct device *hwdev , dma_addr_t dev_addr , size_t size ,
                               enum dma_data_direction dir , struct dma_attrs *attrs ) ;
#line 73
extern int swiotlb_map_sg(struct device *hwdev , struct scatterlist *sg , int nents ,
                          enum dma_data_direction dir ) ;
#line 77
extern void swiotlb_unmap_sg(struct device *hwdev , struct scatterlist *sg , int nents ,
                             enum dma_data_direction dir ) ;
#line 81
extern int swiotlb_map_sg_attrs(struct device *hwdev , struct scatterlist *sgl , int nelems ,
                                enum dma_data_direction dir , struct dma_attrs *attrs ) ;
#line 85
extern void swiotlb_unmap_sg_attrs(struct device *hwdev , struct scatterlist *sgl ,
                                   int nelems , enum dma_data_direction dir , struct dma_attrs *attrs ) ;
#line 90
extern void swiotlb_sync_single_for_cpu(struct device *hwdev , dma_addr_t dev_addr ,
                                        size_t size , enum dma_data_direction dir ) ;
#line 94
extern void swiotlb_sync_sg_for_cpu(struct device *hwdev , struct scatterlist *sg ,
                                    int nelems , enum dma_data_direction dir ) ;
#line 98
extern void swiotlb_sync_single_for_device(struct device *hwdev , dma_addr_t dev_addr ,
                                           size_t size , enum dma_data_direction dir ) ;
#line 102
extern void swiotlb_sync_sg_for_device(struct device *hwdev , struct scatterlist *sg ,
                                       int nelems , enum dma_data_direction dir ) ;
#line 106
extern int swiotlb_dma_mapping_error(struct device *hwdev , dma_addr_t dma_addr ) ;
#line 109
extern int swiotlb_dma_supported(struct device *hwdev , u64 mask ) ;
#line 113
extern void __attribute__((__cold__))  swiotlb_free(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 118
extern void swiotlb_print_info(void) ;
#line 119
extern int is_swiotlb_buffer(phys_addr_t paddr ) ;
#line 7 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/swiotlb.h"
extern int swiotlb ;
#line 8
extern int __attribute__((__cold__))  pci_swiotlb_detect_override(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 9
extern int __attribute__((__cold__))  pci_swiotlb_detect_4gb(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 10
extern void __attribute__((__cold__))  pci_swiotlb_init(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 11
extern void __attribute__((__cold__))  pci_swiotlb_late_init(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 30
__inline static void dma_mark_clean(void *addr , size_t size )  __attribute__((__no_instrument_function__)) ;
#line 30 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/swiotlb.h"
__inline static void dma_mark_clean(void *addr , size_t size ) 
{ 


  {
#line 30
  return;
}
}
#line 32
extern void *x86_swiotlb_alloc_coherent(struct device *hwdev , size_t size , dma_addr_t *dma_handle ,
                                        gfp_t flags , struct dma_attrs *attrs ) ;
#line 35
extern void x86_swiotlb_free_coherent(struct device *dev , size_t size , void *vaddr ,
                                      dma_addr_t dma_addr , struct dma_attrs *attrs ) ;
#line 121 "../../../analyzer/../bench/linux-headers/include/linux/dma-contiguous.h"
__inline static struct cma *dev_get_cma_area(struct device *dev )  __attribute__((__no_instrument_function__)) ;
#line 121 "../../../analyzer/../bench/linux-headers/include/linux/dma-contiguous.h"
__inline static struct cma *dev_get_cma_area(struct device *dev ) 
{ 


  {
#line 123
  return ((struct cma *)((void *)0));
}
}
#line 126
__inline static void dev_set_cma_area(struct device *dev , struct cma *cma )  __attribute__((__no_instrument_function__)) ;
#line 126 "../../../analyzer/../bench/linux-headers/include/linux/dma-contiguous.h"
__inline static void dev_set_cma_area(struct device *dev , struct cma *cma ) 
{ 


  {
#line 126
  return;
}
}
#line 128
__inline static void dma_contiguous_set_default(struct cma *cma )  __attribute__((__no_instrument_function__)) ;
#line 128 "../../../analyzer/../bench/linux-headers/include/linux/dma-contiguous.h"
__inline static void dma_contiguous_set_default(struct cma *cma ) 
{ 


  {
#line 128
  return;
}
}
#line 130
__inline static void dma_contiguous_reserve(phys_addr_t limit )  __attribute__((__no_instrument_function__)) ;
#line 130 "../../../analyzer/../bench/linux-headers/include/linux/dma-contiguous.h"
__inline static void dma_contiguous_reserve(phys_addr_t limit ) 
{ 


  {
#line 130
  return;
}
}
#line 132
__inline static int dma_contiguous_reserve_area(phys_addr_t size , phys_addr_t base ,
                                                phys_addr_t limit , struct cma **res_cma ,
                                                bool fixed )  __attribute__((__no_instrument_function__)) ;
#line 132 "../../../analyzer/../bench/linux-headers/include/linux/dma-contiguous.h"
__inline static int dma_contiguous_reserve_area(phys_addr_t size , phys_addr_t base ,
                                                phys_addr_t limit , struct cma **res_cma ,
                                                bool fixed ) 
{ 


  {
#line 136
  return (-38);
}
}
#line 139
__inline static int dma_declare_contiguous(struct device *dev , phys_addr_t size ,
                                           phys_addr_t base , phys_addr_t limit )  __attribute__((__no_instrument_function__)) ;
#line 139 "../../../analyzer/../bench/linux-headers/include/linux/dma-contiguous.h"
__inline static int dma_declare_contiguous(struct device *dev , phys_addr_t size ,
                                           phys_addr_t base , phys_addr_t limit ) 
{ 


  {
#line 143
  return (-38);
}
}
#line 146
__inline static struct page *dma_alloc_from_contiguous(struct device *dev , int count ,
                                                       unsigned int order )  __attribute__((__no_instrument_function__)) ;
#line 146 "../../../analyzer/../bench/linux-headers/include/linux/dma-contiguous.h"
__inline static struct page *dma_alloc_from_contiguous(struct device *dev , int count ,
                                                       unsigned int order ) 
{ 


  {
#line 150
  return ((struct page *)((void *)0));
}
}
#line 153
__inline static bool dma_release_from_contiguous(struct device *dev , struct page *pages ,
                                                 int count )  __attribute__((__no_instrument_function__)) ;
#line 153 "../../../analyzer/../bench/linux-headers/include/linux/dma-contiguous.h"
__inline static bool dma_release_from_contiguous(struct device *dev , struct page *pages ,
                                                 int count ) 
{ 


  {
#line 157
  return ((bool )0);
}
}
#line 26 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/dma-mapping.h"
extern int iommu_merge ;
#line 27
extern struct device x86_dma_fallback_dev ;
#line 28
extern int panic_on_overflow ;
#line 30
extern struct dma_map_ops *dma_ops ;
#line 32
__inline static struct dma_map_ops *get_dma_ops(struct device *dev )  __attribute__((__no_instrument_function__)) ;
#line 32 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/dma-mapping.h"
__inline static struct dma_map_ops *get_dma_ops(struct device *dev ) 
{ 
  long tmp___7 ;

  {
  {
#line 37
  tmp___7 = __builtin_expect((long )(! (! (! dev))), 0L);
  }
#line 37
  if (tmp___7) {
#line 38
    return (dma_ops);
  } else
#line 37
  if (! dev->archdata.dma_ops) {
#line 38
    return (dma_ops);
  } else {
#line 40
    return (dev->archdata.dma_ops);
  }
}
}
#line 10 "../../../analyzer/../bench/linux-headers/include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_single_attrs(struct device *dev , void *ptr , size_t size ,
                                                enum dma_data_direction dir , struct dma_attrs *attrs )  __attribute__((__no_instrument_function__)) ;
#line 10 "../../../analyzer/../bench/linux-headers/include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_single_attrs(struct device *dev , void *ptr , size_t size ,
                                                enum dma_data_direction dir , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp___7 ;
  dma_addr_t addr ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  unsigned long tmp___11 ;
  unsigned long tmp___12 ;

  {
  {
#line 15
  tmp___7 = get_dma_ops(dev);
#line 15
  ops = tmp___7;
#line 18
  kmemcheck_mark_initialized(ptr, (unsigned int )size);
  }
  {
#line 19
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 19
    tmp___8 = valid_dma_direction((int )dir);
    }
#line 19
    if (tmp___8) {
      {
#line 19
      tmp___9 = 0;
      }
    } else {
      {
#line 19
      tmp___9 = 1;
      }
    }
    {
#line 19
    tmp___10 = __builtin_expect((long )tmp___9, 0L);
    }
#line 19
    if (tmp___10) {
      {
#line 19
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 19
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("../../../analyzer/../bench/linux-headers/include/asm-generic/dma-mapping-common.h"),
                             "i" (19), "i" (sizeof(struct bug_entry )));
#line 19
        __builtin_unreachable();
        }
#line 19
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 19
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 20
  tmp___11 = __phys_addr_nodebug((unsigned long )ptr);
#line 20
  addr = (*(ops->map_page))(dev, (struct page *)0xffffea0000000000UL + (tmp___11 >> 12),
                            (unsigned long )ptr & ~ (~ ((1UL << 12) - 1UL)), size,
                            dir, attrs);
#line 23
  tmp___12 = __phys_addr_nodebug((unsigned long )ptr);
#line 23
  debug_dma_map_page(dev, (struct page *)0xffffea0000000000UL + (tmp___12 >> 12),
                     (unsigned long )ptr & ~ (~ ((1UL << 12) - 1UL)), size, (int )dir,
                     addr, (bool )1);
  }
#line 26
  return (addr);
}
}
#line 29
__inline static void dma_unmap_single_attrs(struct device *dev , dma_addr_t addr ,
                                            size_t size , enum dma_data_direction dir ,
                                            struct dma_attrs *attrs )  __attribute__((__no_instrument_function__)) ;
#line 29 "../../../analyzer/../bench/linux-headers/include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_single_attrs(struct device *dev , dma_addr_t addr ,
                                            size_t size , enum dma_data_direction dir ,
                                            struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;

  {
  {
#line 34
  tmp___7 = get_dma_ops(dev);
#line 34
  ops = tmp___7;
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 36
    tmp___8 = valid_dma_direction((int )dir);
    }
#line 36
    if (tmp___8) {
      {
#line 36
      tmp___9 = 0;
      }
    } else {
      {
#line 36
      tmp___9 = 1;
      }
    }
    {
#line 36
    tmp___10 = __builtin_expect((long )tmp___9, 0L);
    }
#line 36
    if (tmp___10) {
      {
#line 36
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 36
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("../../../analyzer/../bench/linux-headers/include/asm-generic/dma-mapping-common.h"),
                             "i" (36), "i" (sizeof(struct bug_entry )));
#line 36
        __builtin_unreachable();
        }
#line 36
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 36
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 37
  if (ops->unmap_page) {
    {
#line 38
    (*(ops->unmap_page))(dev, addr, size, dir, attrs);
    }
  }
  {
#line 39
  debug_dma_unmap_page(dev, addr, size, (int )dir, (bool )1);
  }
#line 40
  return;
}
}
#line 42
__inline static int dma_map_sg_attrs(struct device *dev , struct scatterlist *sg ,
                                     int nents , enum dma_data_direction dir , struct dma_attrs *attrs )  __attribute__((__no_instrument_function__)) ;
#line 42 "../../../analyzer/../bench/linux-headers/include/asm-generic/dma-mapping-common.h"
__inline static int dma_map_sg_attrs(struct device *dev , struct scatterlist *sg ,
                                     int nents , enum dma_data_direction dir , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp___7 ;
  int i ;
  int ents ;
  struct scatterlist *s ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;

  {
  {
#line 46
  tmp___7 = get_dma_ops(dev);
#line 46
  ops = tmp___7;
#line 50
  i = 0;
#line 50
  s = sg;
  }
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    if (! (i < nents)) {
#line 50
      goto while_break;
    }
    {
#line 51
    tmp___8 = sg_virt(s);
#line 51
    kmemcheck_mark_initialized(tmp___8, s->length);
#line 50
    i ++;
#line 50
    s = sg_next(s);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 52
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 52
    tmp___9 = valid_dma_direction((int )dir);
    }
#line 52
    if (tmp___9) {
      {
#line 52
      tmp___10 = 0;
      }
    } else {
      {
#line 52
      tmp___10 = 1;
      }
    }
    {
#line 52
    tmp___11 = __builtin_expect((long )tmp___10, 0L);
    }
#line 52
    if (tmp___11) {
      {
#line 52
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 52
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("../../../analyzer/../bench/linux-headers/include/asm-generic/dma-mapping-common.h"),
                             "i" (52), "i" (sizeof(struct bug_entry )));
#line 52
        __builtin_unreachable();
        }
#line 52
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 52
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 53
  ents = (*(ops->map_sg))(dev, sg, nents, dir, attrs);
#line 54
  debug_dma_map_sg(dev, sg, nents, ents, (int )dir);
  }
#line 56
  return (ents);
}
}
#line 59
__inline static void dma_unmap_sg_attrs(struct device *dev , struct scatterlist *sg ,
                                        int nents , enum dma_data_direction dir ,
                                        struct dma_attrs *attrs )  __attribute__((__no_instrument_function__)) ;
#line 59 "../../../analyzer/../bench/linux-headers/include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_sg_attrs(struct device *dev , struct scatterlist *sg ,
                                        int nents , enum dma_data_direction dir ,
                                        struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;

  {
  {
#line 63
  tmp___7 = get_dma_ops(dev);
#line 63
  ops = tmp___7;
  }
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 65
    tmp___8 = valid_dma_direction((int )dir);
    }
#line 65
    if (tmp___8) {
      {
#line 65
      tmp___9 = 0;
      }
    } else {
      {
#line 65
      tmp___9 = 1;
      }
    }
    {
#line 65
    tmp___10 = __builtin_expect((long )tmp___9, 0L);
    }
#line 65
    if (tmp___10) {
      {
#line 65
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 65
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("../../../analyzer/../bench/linux-headers/include/asm-generic/dma-mapping-common.h"),
                             "i" (65), "i" (sizeof(struct bug_entry )));
#line 65
        __builtin_unreachable();
        }
#line 65
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 65
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 66
  debug_dma_unmap_sg(dev, sg, nents, (int )dir);
  }
#line 67
  if (ops->unmap_sg) {
    {
#line 68
    (*(ops->unmap_sg))(dev, sg, nents, dir, attrs);
    }
  }
#line 69
  return;
}
}
#line 71
__inline static dma_addr_t dma_map_page(struct device *dev , struct page *page , size_t offset ,
                                        size_t size , enum dma_data_direction dir )  __attribute__((__no_instrument_function__)) ;
#line 71 "../../../analyzer/../bench/linux-headers/include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_page(struct device *dev , struct page *page , size_t offset ,
                                        size_t size , enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp___7 ;
  dma_addr_t addr ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;

  {
  {
#line 75
  tmp___7 = get_dma_ops(dev);
#line 75
  ops = tmp___7;
#line 78
  tmp___8 = lowmem_page_address((struct page  const  *)page);
#line 78
  kmemcheck_mark_initialized(tmp___8 + offset, (unsigned int )size);
  }
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp___9 = valid_dma_direction((int )dir);
    }
#line 79
    if (tmp___9) {
      {
#line 79
      tmp___10 = 0;
      }
    } else {
      {
#line 79
      tmp___10 = 1;
      }
    }
    {
#line 79
    tmp___11 = __builtin_expect((long )tmp___10, 0L);
    }
#line 79
    if (tmp___11) {
      {
#line 79
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 79
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("../../../analyzer/../bench/linux-headers/include/asm-generic/dma-mapping-common.h"),
                             "i" (79), "i" (sizeof(struct bug_entry )));
#line 79
        __builtin_unreachable();
        }
#line 79
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 79
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 80
  addr = (*(ops->map_page))(dev, page, offset, size, dir, (struct dma_attrs *)((void *)0));
#line 81
  debug_dma_map_page(dev, page, offset, size, (int )dir, addr, (bool )0);
  }
#line 83
  return (addr);
}
}
#line 86
__inline static void dma_unmap_page(struct device *dev , dma_addr_t addr , size_t size ,
                                    enum dma_data_direction dir )  __attribute__((__no_instrument_function__)) ;
#line 86 "../../../analyzer/../bench/linux-headers/include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_page(struct device *dev , dma_addr_t addr , size_t size ,
                                    enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;

  {
  {
#line 89
  tmp___7 = get_dma_ops(dev);
#line 89
  ops = tmp___7;
  }
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 91
    tmp___8 = valid_dma_direction((int )dir);
    }
#line 91
    if (tmp___8) {
      {
#line 91
      tmp___9 = 0;
      }
    } else {
      {
#line 91
      tmp___9 = 1;
      }
    }
    {
#line 91
    tmp___10 = __builtin_expect((long )tmp___9, 0L);
    }
#line 91
    if (tmp___10) {
      {
#line 91
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 91
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("../../../analyzer/../bench/linux-headers/include/asm-generic/dma-mapping-common.h"),
                             "i" (91), "i" (sizeof(struct bug_entry )));
#line 91
        __builtin_unreachable();
        }
#line 91
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 91
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  if (ops->unmap_page) {
    {
#line 93
    (*(ops->unmap_page))(dev, addr, size, dir, (struct dma_attrs *)((void *)0));
    }
  }
  {
#line 94
  debug_dma_unmap_page(dev, addr, size, (int )dir, (bool )0);
  }
#line 95
  return;
}
}
#line 97
__inline static void dma_sync_single_for_cpu(struct device *dev , dma_addr_t addr ,
                                             size_t size , enum dma_data_direction dir )  __attribute__((__no_instrument_function__)) ;
#line 97 "../../../analyzer/../bench/linux-headers/include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_for_cpu(struct device *dev , dma_addr_t addr ,
                                             size_t size , enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;

  {
  {
#line 101
  tmp___7 = get_dma_ops(dev);
#line 101
  ops = tmp___7;
  }
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 103
    tmp___8 = valid_dma_direction((int )dir);
    }
#line 103
    if (tmp___8) {
      {
#line 103
      tmp___9 = 0;
      }
    } else {
      {
#line 103
      tmp___9 = 1;
      }
    }
    {
#line 103
    tmp___10 = __builtin_expect((long )tmp___9, 0L);
    }
#line 103
    if (tmp___10) {
      {
#line 103
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 103
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("../../../analyzer/../bench/linux-headers/include/asm-generic/dma-mapping-common.h"),
                             "i" (103), "i" (sizeof(struct bug_entry )));
#line 103
        __builtin_unreachable();
        }
#line 103
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 103
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  if (ops->sync_single_for_cpu) {
    {
#line 105
    (*(ops->sync_single_for_cpu))(dev, addr, size, dir);
    }
  }
  {
#line 106
  debug_dma_sync_single_for_cpu(dev, addr, size, (int )dir);
  }
#line 107
  return;
}
}
#line 109
__inline static void dma_sync_single_for_device(struct device *dev , dma_addr_t addr ,
                                                size_t size , enum dma_data_direction dir )  __attribute__((__no_instrument_function__)) ;
#line 109 "../../../analyzer/../bench/linux-headers/include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_for_device(struct device *dev , dma_addr_t addr ,
                                                size_t size , enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;

  {
  {
#line 113
  tmp___7 = get_dma_ops(dev);
#line 113
  ops = tmp___7;
  }
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 115
    tmp___8 = valid_dma_direction((int )dir);
    }
#line 115
    if (tmp___8) {
      {
#line 115
      tmp___9 = 0;
      }
    } else {
      {
#line 115
      tmp___9 = 1;
      }
    }
    {
#line 115
    tmp___10 = __builtin_expect((long )tmp___9, 0L);
    }
#line 115
    if (tmp___10) {
      {
#line 115
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 115
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("../../../analyzer/../bench/linux-headers/include/asm-generic/dma-mapping-common.h"),
                             "i" (115), "i" (sizeof(struct bug_entry )));
#line 115
        __builtin_unreachable();
        }
#line 115
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 115
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 116
  if (ops->sync_single_for_device) {
    {
#line 117
    (*(ops->sync_single_for_device))(dev, addr, size, dir);
    }
  }
  {
#line 118
  debug_dma_sync_single_for_device(dev, addr, size, (int )dir);
  }
#line 119
  return;
}
}
#line 121
__inline static void dma_sync_single_range_for_cpu(struct device *dev , dma_addr_t addr ,
                                                   unsigned long offset , size_t size ,
                                                   enum dma_data_direction dir )  __attribute__((__no_instrument_function__)) ;
#line 121 "../../../analyzer/../bench/linux-headers/include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_range_for_cpu(struct device *dev , dma_addr_t addr ,
                                                   unsigned long offset , size_t size ,
                                                   enum dma_data_direction dir ) 
{ 
  struct dma_map_ops  const  *ops ;
  struct dma_map_ops *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;

  {
  {
#line 127
  tmp___7 = get_dma_ops(dev);
#line 127
  ops = (struct dma_map_ops  const  *)tmp___7;
  }
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 129
    tmp___8 = valid_dma_direction((int )dir);
    }
#line 129
    if (tmp___8) {
      {
#line 129
      tmp___9 = 0;
      }
    } else {
      {
#line 129
      tmp___9 = 1;
      }
    }
    {
#line 129
    tmp___10 = __builtin_expect((long )tmp___9, 0L);
    }
#line 129
    if (tmp___10) {
      {
#line 129
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 129
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("../../../analyzer/../bench/linux-headers/include/asm-generic/dma-mapping-common.h"),
                             "i" (129), "i" (sizeof(struct bug_entry )));
#line 129
        __builtin_unreachable();
        }
#line 129
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 129
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  if (ops->sync_single_for_cpu) {
    {
#line 131
    (*(ops->sync_single_for_cpu))(dev, addr + (dma_addr_t )offset, size, dir);
    }
  }
  {
#line 132
  debug_dma_sync_single_range_for_cpu(dev, addr, offset, size, (int )dir);
  }
#line 133
  return;
}
}
#line 135
__inline static void dma_sync_single_range_for_device(struct device *dev , dma_addr_t addr ,
                                                      unsigned long offset , size_t size ,
                                                      enum dma_data_direction dir )  __attribute__((__no_instrument_function__)) ;
#line 135 "../../../analyzer/../bench/linux-headers/include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_range_for_device(struct device *dev , dma_addr_t addr ,
                                                      unsigned long offset , size_t size ,
                                                      enum dma_data_direction dir ) 
{ 
  struct dma_map_ops  const  *ops ;
  struct dma_map_ops *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;

  {
  {
#line 141
  tmp___7 = get_dma_ops(dev);
#line 141
  ops = (struct dma_map_ops  const  *)tmp___7;
  }
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 143
    tmp___8 = valid_dma_direction((int )dir);
    }
#line 143
    if (tmp___8) {
      {
#line 143
      tmp___9 = 0;
      }
    } else {
      {
#line 143
      tmp___9 = 1;
      }
    }
    {
#line 143
    tmp___10 = __builtin_expect((long )tmp___9, 0L);
    }
#line 143
    if (tmp___10) {
      {
#line 143
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 143
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("../../../analyzer/../bench/linux-headers/include/asm-generic/dma-mapping-common.h"),
                             "i" (143), "i" (sizeof(struct bug_entry )));
#line 143
        __builtin_unreachable();
        }
#line 143
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 143
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  if (ops->sync_single_for_device) {
    {
#line 145
    (*(ops->sync_single_for_device))(dev, addr + (dma_addr_t )offset, size, dir);
    }
  }
  {
#line 146
  debug_dma_sync_single_range_for_device(dev, addr, offset, size, (int )dir);
  }
#line 147
  return;
}
}
#line 149
__inline static void dma_sync_sg_for_cpu(struct device *dev , struct scatterlist *sg ,
                                         int nelems , enum dma_data_direction dir )  __attribute__((__no_instrument_function__)) ;
#line 149 "../../../analyzer/../bench/linux-headers/include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_sg_for_cpu(struct device *dev , struct scatterlist *sg ,
                                         int nelems , enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;

  {
  {
#line 153
  tmp___7 = get_dma_ops(dev);
#line 153
  ops = tmp___7;
  }
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 155
    tmp___8 = valid_dma_direction((int )dir);
    }
#line 155
    if (tmp___8) {
      {
#line 155
      tmp___9 = 0;
      }
    } else {
      {
#line 155
      tmp___9 = 1;
      }
    }
    {
#line 155
    tmp___10 = __builtin_expect((long )tmp___9, 0L);
    }
#line 155
    if (tmp___10) {
      {
#line 155
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 155
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("../../../analyzer/../bench/linux-headers/include/asm-generic/dma-mapping-common.h"),
                             "i" (155), "i" (sizeof(struct bug_entry )));
#line 155
        __builtin_unreachable();
        }
#line 155
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 155
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  if (ops->sync_sg_for_cpu) {
    {
#line 157
    (*(ops->sync_sg_for_cpu))(dev, sg, nelems, dir);
    }
  }
  {
#line 158
  debug_dma_sync_sg_for_cpu(dev, sg, nelems, (int )dir);
  }
#line 159
  return;
}
}
#line 161
__inline static void dma_sync_sg_for_device(struct device *dev , struct scatterlist *sg ,
                                            int nelems , enum dma_data_direction dir )  __attribute__((__no_instrument_function__)) ;
#line 161 "../../../analyzer/../bench/linux-headers/include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_sg_for_device(struct device *dev , struct scatterlist *sg ,
                                            int nelems , enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;

  {
  {
#line 165
  tmp___7 = get_dma_ops(dev);
#line 165
  ops = tmp___7;
  }
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 167
    tmp___8 = valid_dma_direction((int )dir);
    }
#line 167
    if (tmp___8) {
      {
#line 167
      tmp___9 = 0;
      }
    } else {
      {
#line 167
      tmp___9 = 1;
      }
    }
    {
#line 167
    tmp___10 = __builtin_expect((long )tmp___9, 0L);
    }
#line 167
    if (tmp___10) {
      {
#line 167
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 167
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("../../../analyzer/../bench/linux-headers/include/asm-generic/dma-mapping-common.h"),
                             "i" (167), "i" (sizeof(struct bug_entry )));
#line 167
        __builtin_unreachable();
        }
#line 167
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 167
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 168
  if (ops->sync_sg_for_device) {
    {
#line 169
    (*(ops->sync_sg_for_device))(dev, sg, nelems, dir);
    }
  }
  {
#line 170
  debug_dma_sync_sg_for_device(dev, sg, nelems, (int )dir);
  }
#line 172
  return;
}
}
#line 179
extern int dma_common_mmap(struct device *dev , struct vm_area_struct *vma , void *cpu_addr ,
                           dma_addr_t dma_addr , size_t size ) ;
#line 195
__inline static int dma_mmap_attrs(struct device *dev , struct vm_area_struct *vma ,
                                   void *cpu_addr , dma_addr_t dma_addr , size_t size ,
                                   struct dma_attrs *attrs )  __attribute__((__no_instrument_function__)) ;
#line 195 "../../../analyzer/../bench/linux-headers/include/asm-generic/dma-mapping-common.h"
__inline static int dma_mmap_attrs(struct device *dev , struct vm_area_struct *vma ,
                                   void *cpu_addr , dma_addr_t dma_addr , size_t size ,
                                   struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 199
  tmp___7 = get_dma_ops(dev);
#line 199
  ops = tmp___7;
  }
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 200
    tmp___8 = __builtin_expect((long )(! (! (! ops))), 0L);
    }
#line 200
    if (tmp___8) {
      {
#line 200
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 200
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("../../../analyzer/../bench/linux-headers/include/asm-generic/dma-mapping-common.h"),
                             "i" (200), "i" (sizeof(struct bug_entry )));
#line 200
        __builtin_unreachable();
        }
#line 200
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 200
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 201
  if (ops->mmap) {
    {
#line 202
    tmp___9 = (*(ops->mmap))(dev, vma, cpu_addr, dma_addr, size, attrs);
    }
#line 202
    return (tmp___9);
  }
  {
#line 203
  tmp___10 = dma_common_mmap(dev, vma, cpu_addr, dma_addr, size);
  }
#line 203
  return (tmp___10);
}
}
#line 208
__inline static int dma_mmap_writecombine(struct device *dev , struct vm_area_struct *vma ,
                                          void *cpu_addr , dma_addr_t dma_addr , size_t size )  __attribute__((__no_instrument_function__)) ;
#line 208 "../../../analyzer/../bench/linux-headers/include/asm-generic/dma-mapping-common.h"
__inline static int dma_mmap_writecombine(struct device *dev , struct vm_area_struct *vma ,
                                          void *cpu_addr , dma_addr_t dma_addr , size_t size ) 
{ 
  struct dma_attrs attrs ;
  int tmp___7 ;

  {
  {
#line 211
  attrs.flags[0] = 0UL;
#line 212
  dma_set_attr((enum dma_attr )2, & attrs);
#line 213
  tmp___7 = dma_mmap_attrs(dev, vma, cpu_addr, dma_addr, size, & attrs);
  }
#line 213
  return (tmp___7);
}
}
#line 216
extern int dma_common_get_sgtable(struct device *dev , struct sg_table *sgt , void *cpu_addr ,
                                  dma_addr_t dma_addr , size_t size ) ;
#line 220
__inline static int dma_get_sgtable_attrs(struct device *dev , struct sg_table *sgt ,
                                          void *cpu_addr , dma_addr_t dma_addr , size_t size ,
                                          struct dma_attrs *attrs )  __attribute__((__no_instrument_function__)) ;
#line 220 "../../../analyzer/../bench/linux-headers/include/asm-generic/dma-mapping-common.h"
__inline static int dma_get_sgtable_attrs(struct device *dev , struct sg_table *sgt ,
                                          void *cpu_addr , dma_addr_t dma_addr , size_t size ,
                                          struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 224
  tmp___7 = get_dma_ops(dev);
#line 224
  ops = tmp___7;
  }
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 225
    tmp___8 = __builtin_expect((long )(! (! (! ops))), 0L);
    }
#line 225
    if (tmp___8) {
      {
#line 225
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 225
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("../../../analyzer/../bench/linux-headers/include/asm-generic/dma-mapping-common.h"),
                             "i" (225), "i" (sizeof(struct bug_entry )));
#line 225
        __builtin_unreachable();
        }
#line 225
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 225
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  if (ops->get_sgtable) {
    {
#line 227
    tmp___9 = (*(ops->get_sgtable))(dev, sgt, cpu_addr, dma_addr, size, attrs);
    }
#line 227
    return (tmp___9);
  }
  {
#line 229
  tmp___10 = dma_common_get_sgtable(dev, sgt, cpu_addr, dma_addr, size);
  }
#line 229
  return (tmp___10);
}
}
#line 47 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/dma-mapping.h"
__inline static int dma_mapping_error(struct device *dev , dma_addr_t dma_addr )  __attribute__((__no_instrument_function__)) ;
#line 47 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/dma-mapping.h"
__inline static int dma_mapping_error(struct device *dev , dma_addr_t dma_addr ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 49
  tmp___7 = get_dma_ops(dev);
#line 49
  ops = tmp___7;
#line 50
  debug_dma_mapping_error(dev, dma_addr);
  }
#line 51
  if (ops->mapping_error) {
    {
#line 52
    tmp___8 = (*(ops->mapping_error))(dev, dma_addr);
    }
#line 52
    return (tmp___8);
  }
#line 54
  return (dma_addr == 0ULL);
}
}
#line 60
extern int dma_supported(struct device *hwdev , u64 mask ) ;
#line 61
extern int dma_set_mask(struct device *dev , u64 mask ) ;
#line 63
extern void *dma_generic_alloc_coherent(struct device *dev , size_t size , dma_addr_t *dma_addr ,
                                        gfp_t flag , struct dma_attrs *attrs ) ;
#line 67
extern void dma_generic_free_coherent(struct device *dev , size_t size , void *vaddr ,
                                      dma_addr_t dma_addr , struct dma_attrs *attrs ) ;
#line 77
__inline static bool dma_capable(struct device *dev , dma_addr_t addr , size_t size )  __attribute__((__no_instrument_function__)) ;
#line 77 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/dma-mapping.h"
__inline static bool dma_capable(struct device *dev , dma_addr_t addr , size_t size ) 
{ 


  {
#line 79
  if (! dev->dma_mask) {
#line 80
    return ((bool )0);
  }
#line 82
  return ((bool )((addr + (dma_addr_t )size) - 1ULL <= *(dev->dma_mask)));
}
}
#line 85
__inline static dma_addr_t phys_to_dma(struct device *dev , phys_addr_t paddr )  __attribute__((__no_instrument_function__)) ;
#line 85 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/dma-mapping.h"
__inline static dma_addr_t phys_to_dma(struct device *dev , phys_addr_t paddr ) 
{ 


  {
#line 87
  return (paddr);
}
}
#line 90
__inline static phys_addr_t dma_to_phys(struct device *dev , dma_addr_t daddr )  __attribute__((__no_instrument_function__)) ;
#line 90 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/dma-mapping.h"
__inline static phys_addr_t dma_to_phys(struct device *dev , dma_addr_t daddr ) 
{ 


  {
#line 92
  return (daddr);
}
}
#line 96
__inline static void dma_cache_sync(struct device *dev , void *vaddr , size_t size ,
                                    enum dma_data_direction dir )  __attribute__((__no_instrument_function__)) ;
#line 96 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/dma-mapping.h"
__inline static void dma_cache_sync(struct device *dev , void *vaddr , size_t size ,
                                    enum dma_data_direction dir ) 
{ 


  {
  {
#line 100
  flush_write_buffers();
  }
#line 101
  return;
}
}
#line 103
__inline static unsigned long dma_alloc_coherent_mask(struct device *dev , gfp_t gfp )  __attribute__((__no_instrument_function__)) ;
#line 103 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/dma-mapping.h"
__inline static unsigned long dma_alloc_coherent_mask(struct device *dev , gfp_t gfp ) 
{ 
  unsigned long dma_mask ;

  {
  {
#line 106
  dma_mask = 0UL;
#line 108
  dma_mask = (unsigned long )dev->coherent_dma_mask;
  }
#line 109
  if (! dma_mask) {
#line 110
    if (gfp & 1U) {
      {
#line 110
      dma_mask = (unsigned long )((1ULL << 24) - 1ULL);
      }
    } else {
      {
#line 110
      dma_mask = (unsigned long )((1ULL << 32) - 1ULL);
      }
    }
  }
#line 112
  return (dma_mask);
}
}
#line 115
__inline static gfp_t dma_alloc_coherent_gfp_flags(struct device *dev , gfp_t gfp )  __attribute__((__no_instrument_function__)) ;
#line 115 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/dma-mapping.h"
__inline static gfp_t dma_alloc_coherent_gfp_flags(struct device *dev , gfp_t gfp ) 
{ 
  unsigned long dma_mask ;
  unsigned long tmp___7 ;

  {
  {
#line 117
  tmp___7 = dma_alloc_coherent_mask(dev, gfp);
#line 117
  dma_mask = tmp___7;
  }
#line 119
  if ((unsigned long long )dma_mask <= (1ULL << 24) - 1ULL) {
    {
#line 120
    gfp |= 1U;
    }
  }
#line 122
  if ((unsigned long long )dma_mask <= (1ULL << 32) - 1ULL) {
#line 122
    if (! (gfp & 1U)) {
      {
#line 123
      gfp |= 4U;
      }
    }
  }
#line 125
  return (gfp);
}
}
#line 130
__inline static void *dma_alloc_attrs(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                      gfp_t gfp , struct dma_attrs *attrs )  __attribute__((__no_instrument_function__)) ;
#line 130 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/dma-mapping.h"
__inline static void *dma_alloc_attrs(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                      gfp_t gfp , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp___7 ;
  void *memory ;
  int tmp___8 ;
  gfp_t tmp___9 ;

  {
  {
#line 134
  tmp___7 = get_dma_ops(dev);
#line 134
  ops = tmp___7;
#line 137
  gfp &= 4294967288U;
  }
#line 142
  if (! dev) {
    {
#line 143
    dev = & x86_dma_fallback_dev;
    }
  }
  {
#line 145
  tmp___8 = is_device_dma_capable(dev);
  }
#line 145
  if (! tmp___8) {
#line 146
    return ((void *)0);
  }
#line 148
  if (! ops->alloc) {
#line 149
    return ((void *)0);
  }
  {
#line 151
  tmp___9 = dma_alloc_coherent_gfp_flags(dev, gfp);
#line 151
  memory = (*(ops->alloc))(dev, size, dma_handle, tmp___9, attrs);
#line 153
  debug_dma_alloc_coherent(dev, size, *dma_handle, memory);
  }
#line 155
  return (memory);
}
}
#line 160
__inline static void dma_free_attrs(struct device *dev , size_t size , void *vaddr ,
                                    dma_addr_t bus , struct dma_attrs *attrs )  __attribute__((__no_instrument_function__)) ;
#line 160 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/dma-mapping.h"
__inline static void dma_free_attrs(struct device *dev , size_t size , void *vaddr ,
                                    dma_addr_t bus , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp___7 ;
  int __ret_warn_on ;
  unsigned long _flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;

  {
  {
#line 164
  tmp___7 = get_dma_ops(dev);
#line 164
  ops = tmp___7;
  }
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 166
    _flags = arch_local_save_flags();
    }
#line 166
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 166
  tmp___8 = arch_irqs_disabled_flags(_flags);
  }
#line 166
  if (tmp___8) {
    {
#line 166
    tmp___9 = 1;
    }
  } else {
    {
#line 166
    tmp___9 = 0;
    }
  }
  {
#line 166
  __ret_warn_on = tmp___9;
#line 166
  tmp___10 = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
  }
#line 166
  if (tmp___10) {
    {
#line 166
    warn_slowpath_null("../../../analyzer/../bench/linux-headers/arch/x86/include/asm/dma-mapping.h",
                       (int const   )166);
    }
  }
  {
#line 166
  __builtin_expect((long )(! (! __ret_warn_on)), 0L);
#line 171
  debug_dma_free_coherent(dev, size, vaddr, bus);
  }
#line 172
  if (ops->free) {
    {
#line 173
    (*(ops->free))(dev, size, vaddr, bus, attrs);
    }
  }
#line 174
  return;
}
}
#line 87 "../../../analyzer/../bench/linux-headers/include/linux/dma-mapping.h"
__inline static u64 dma_get_mask(struct device *dev )  __attribute__((__no_instrument_function__)) ;
#line 87 "../../../analyzer/../bench/linux-headers/include/linux/dma-mapping.h"
__inline static u64 dma_get_mask(struct device *dev ) 
{ 


  {
#line 89
  if (dev) {
#line 89
    if (dev->dma_mask) {
#line 89
      if (*(dev->dma_mask)) {
#line 90
        return (*(dev->dma_mask));
      }
    }
  }
#line 91
  return ((1ULL << 32) - 1ULL);
}
}
#line 97
__inline static int dma_set_coherent_mask(struct device *dev , u64 mask )  __attribute__((__no_instrument_function__)) ;
#line 97 "../../../analyzer/../bench/linux-headers/include/linux/dma-mapping.h"
__inline static int dma_set_coherent_mask(struct device *dev , u64 mask ) 
{ 
  int tmp___7 ;

  {
  {
#line 99
  tmp___7 = dma_supported(dev, mask);
  }
#line 99
  if (! tmp___7) {
#line 100
    return (-5);
  }
  {
#line 101
  dev->coherent_dma_mask = mask;
  }
#line 102
  return (0);
}
}
#line 112
__inline static int dma_set_mask_and_coherent(struct device *dev , u64 mask )  __attribute__((__no_instrument_function__)) ;
#line 112 "../../../analyzer/../bench/linux-headers/include/linux/dma-mapping.h"
__inline static int dma_set_mask_and_coherent(struct device *dev , u64 mask ) 
{ 
  int rc ;
  int tmp___7 ;

  {
  {
#line 114
  tmp___7 = dma_set_mask(dev, mask);
#line 114
  rc = tmp___7;
  }
#line 115
  if (rc == 0) {
    {
#line 116
    dma_set_coherent_mask(dev, mask);
    }
  }
#line 117
  return (rc);
}
}
#line 124
__inline static int dma_coerce_mask_and_coherent(struct device *dev , u64 mask )  __attribute__((__no_instrument_function__)) ;
#line 124 "../../../analyzer/../bench/linux-headers/include/linux/dma-mapping.h"
__inline static int dma_coerce_mask_and_coherent(struct device *dev , u64 mask ) 
{ 
  int tmp___7 ;

  {
  {
#line 126
  dev->dma_mask = & dev->coherent_dma_mask;
#line 127
  tmp___7 = dma_set_mask_and_coherent(dev, mask);
  }
#line 127
  return (tmp___7);
}
}
#line 130
extern u64 dma_get_required_mask(struct device *dev ) ;
#line 133
__inline static int set_arch_dma_coherent_ops(struct device *dev )  __attribute__((__no_instrument_function__)) ;
#line 133 "../../../analyzer/../bench/linux-headers/include/linux/dma-mapping.h"
__inline static int set_arch_dma_coherent_ops(struct device *dev ) 
{ 


  {
#line 135
  return (0);
}
}
#line 139
__inline static unsigned int dma_get_max_seg_size(struct device *dev )  __attribute__((__no_instrument_function__)) ;
#line 139 "../../../analyzer/../bench/linux-headers/include/linux/dma-mapping.h"
__inline static unsigned int dma_get_max_seg_size(struct device *dev ) 
{ 
  unsigned int tmp___7 ;

  {
#line 141
  if (dev->dma_parms) {
    {
#line 141
    tmp___7 = (dev->dma_parms)->max_segment_size;
    }
  } else {
    {
#line 141
    tmp___7 = 65536U;
    }
  }
#line 141
  return (tmp___7);
}
}
#line 144
__inline static unsigned int dma_set_max_seg_size(struct device *dev , unsigned int size )  __attribute__((__no_instrument_function__)) ;
#line 144 "../../../analyzer/../bench/linux-headers/include/linux/dma-mapping.h"
__inline static unsigned int dma_set_max_seg_size(struct device *dev , unsigned int size ) 
{ 


  {
#line 147
  if (dev->dma_parms) {
    {
#line 148
    (dev->dma_parms)->max_segment_size = size;
    }
#line 149
    return (0U);
  } else {
#line 151
    return (4294967291U);
  }
}
}
#line 154
__inline static unsigned long dma_get_seg_boundary(struct device *dev )  __attribute__((__no_instrument_function__)) ;
#line 154 "../../../analyzer/../bench/linux-headers/include/linux/dma-mapping.h"
__inline static unsigned long dma_get_seg_boundary(struct device *dev ) 
{ 
  unsigned long tmp___7 ;

  {
#line 156
  if (dev->dma_parms) {
    {
#line 156
    tmp___7 = (dev->dma_parms)->segment_boundary_mask;
    }
  } else {
    {
#line 156
    tmp___7 = 4294967295UL;
    }
  }
#line 156
  return (tmp___7);
}
}
#line 160
__inline static int dma_set_seg_boundary(struct device *dev , unsigned long mask )  __attribute__((__no_instrument_function__)) ;
#line 160 "../../../analyzer/../bench/linux-headers/include/linux/dma-mapping.h"
__inline static int dma_set_seg_boundary(struct device *dev , unsigned long mask ) 
{ 


  {
#line 162
  if (dev->dma_parms) {
    {
#line 163
    (dev->dma_parms)->segment_boundary_mask = mask;
    }
#line 164
    return (0);
  } else {
#line 166
    return (-5);
  }
}
}
#line 170
__inline static unsigned long dma_max_pfn(struct device *dev )  __attribute__((__no_instrument_function__)) ;
#line 170 "../../../analyzer/../bench/linux-headers/include/linux/dma-mapping.h"
__inline static unsigned long dma_max_pfn(struct device *dev ) 
{ 


  {
#line 172
  return ((unsigned long )(*(dev->dma_mask) >> 12));
}
}
#line 176
__inline static void *dma_zalloc_coherent(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                          gfp_t flag )  __attribute__((__no_instrument_function__)) ;
#line 176 "../../../analyzer/../bench/linux-headers/include/linux/dma-mapping.h"
__inline static void *dma_zalloc_coherent(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                          gfp_t flag ) 
{ 
  void *ret ;
  void *tmp___7 ;

  {
  {
#line 179
  tmp___7 = dma_alloc_attrs(dev, size, dma_handle, flag | 32768U, (struct dma_attrs *)((void *)0));
#line 179
  ret = tmp___7;
  }
#line 181
  return (ret);
}
}
#line 185
__inline static int dma_get_cache_alignment(void)  __attribute__((__no_instrument_function__)) ;
#line 185 "../../../analyzer/../bench/linux-headers/include/linux/dma-mapping.h"
__inline static int dma_get_cache_alignment(void) 
{ 


  {
#line 190
  return (1);
}
}
#line 201
__inline static int dma_declare_coherent_memory(struct device *dev , phys_addr_t phys_addr ,
                                                dma_addr_t device_addr , size_t size ,
                                                int flags )  __attribute__((__no_instrument_function__)) ;
#line 201 "../../../analyzer/../bench/linux-headers/include/linux/dma-mapping.h"
__inline static int dma_declare_coherent_memory(struct device *dev , phys_addr_t phys_addr ,
                                                dma_addr_t device_addr , size_t size ,
                                                int flags ) 
{ 


  {
#line 205
  return (0);
}
}
#line 208
__inline static void dma_release_declared_memory(struct device *dev )  __attribute__((__no_instrument_function__)) ;
#line 208 "../../../analyzer/../bench/linux-headers/include/linux/dma-mapping.h"
__inline static void dma_release_declared_memory(struct device *dev ) 
{ 


  {
#line 211
  return;
}
}
#line 213
__inline static void *dma_mark_declared_memory_occupied(struct device *dev , dma_addr_t device_addr ,
                                                        size_t size )  __attribute__((__no_instrument_function__)) ;
#line 213 "../../../analyzer/../bench/linux-headers/include/linux/dma-mapping.h"
__inline static void *dma_mark_declared_memory_occupied(struct device *dev , dma_addr_t device_addr ,
                                                        size_t size ) 
{ 
  void *tmp___7 ;

  {
  {
#line 217
  tmp___7 = ERR_PTR(-16L);
  }
#line 217
  return (tmp___7);
}
}
#line 224
extern void *dmam_alloc_coherent(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                 gfp_t gfp ) ;
#line 226
extern void dmam_free_coherent(struct device *dev , size_t size , void *vaddr , dma_addr_t dma_handle ) ;
#line 228
extern void *dmam_alloc_noncoherent(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                    gfp_t gfp ) ;
#line 230
extern void dmam_free_noncoherent(struct device *dev , size_t size , void *vaddr ,
                                  dma_addr_t dma_handle ) ;
#line 239
__inline static int dmam_declare_coherent_memory(struct device *dev , phys_addr_t phys_addr ,
                                                 dma_addr_t device_addr , size_t size ,
                                                 gfp_t gfp )  __attribute__((__no_instrument_function__)) ;
#line 239 "../../../analyzer/../bench/linux-headers/include/linux/dma-mapping.h"
__inline static int dmam_declare_coherent_memory(struct device *dev , phys_addr_t phys_addr ,
                                                 dma_addr_t device_addr , size_t size ,
                                                 gfp_t gfp ) 
{ 


  {
#line 243
  return (0);
}
}
#line 246
__inline static void dmam_release_declared_memory(struct device *dev )  __attribute__((__no_instrument_function__)) ;
#line 246 "../../../analyzer/../bench/linux-headers/include/linux/dma-mapping.h"
__inline static void dmam_release_declared_memory(struct device *dev ) 
{ 


  {
#line 248
  return;
}
}
#line 9 "../../../analyzer/../bench/linux-headers/include/asm-generic/pci-dma-compat.h"
__inline static int pci_dma_supported(struct pci_dev *hwdev , u64 mask )  __attribute__((__no_instrument_function__)) ;
#line 9 "../../../analyzer/../bench/linux-headers/include/asm-generic/pci-dma-compat.h"
__inline static int pci_dma_supported(struct pci_dev *hwdev , u64 mask ) 
{ 
  struct device *tmp___7 ;
  int tmp___8 ;

  {
#line 12
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
#line 12
    tmp___7 = (struct device *)((void *)0);
    }
  } else {
    {
#line 12
    tmp___7 = & hwdev->dev;
    }
  }
  {
#line 12
  tmp___8 = dma_supported(tmp___7, mask);
  }
#line 12
  return (tmp___8);
}
}
#line 15
__inline static void *pci_alloc_consistent(struct pci_dev *hwdev , size_t size , dma_addr_t *dma_handle )  __attribute__((__no_instrument_function__)) ;
#line 15 "../../../analyzer/../bench/linux-headers/include/asm-generic/pci-dma-compat.h"
__inline static void *pci_alloc_consistent(struct pci_dev *hwdev , size_t size , dma_addr_t *dma_handle ) 
{ 
  struct device *tmp___7 ;
  void *tmp___8 ;

  {
#line 19
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
#line 19
    tmp___7 = (struct device *)((void *)0);
    }
  } else {
    {
#line 19
    tmp___7 = & hwdev->dev;
    }
  }
  {
#line 19
  tmp___8 = dma_alloc_attrs(tmp___7, size, dma_handle, 32U, (struct dma_attrs *)((void *)0));
  }
#line 19
  return (tmp___8);
}
}
#line 22
__inline static void *pci_zalloc_consistent(struct pci_dev *hwdev , size_t size ,
                                            dma_addr_t *dma_handle )  __attribute__((__no_instrument_function__)) ;
#line 22 "../../../analyzer/../bench/linux-headers/include/asm-generic/pci-dma-compat.h"
__inline static void *pci_zalloc_consistent(struct pci_dev *hwdev , size_t size ,
                                            dma_addr_t *dma_handle ) 
{ 
  struct device *tmp___7 ;
  void *tmp___8 ;

  {
#line 26
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
#line 26
    tmp___7 = (struct device *)((void *)0);
    }
  } else {
    {
#line 26
    tmp___7 = & hwdev->dev;
    }
  }
  {
#line 26
  tmp___8 = dma_zalloc_coherent(tmp___7, size, dma_handle, 32U);
  }
#line 26
  return (tmp___8);
}
}
#line 30
__inline static void pci_free_consistent(struct pci_dev *hwdev , size_t size , void *vaddr ,
                                         dma_addr_t dma_handle )  __attribute__((__no_instrument_function__)) ;
#line 30 "../../../analyzer/../bench/linux-headers/include/asm-generic/pci-dma-compat.h"
__inline static void pci_free_consistent(struct pci_dev *hwdev , size_t size , void *vaddr ,
                                         dma_addr_t dma_handle ) 
{ 
  struct device *tmp___7 ;

  {
#line 34
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
#line 34
    tmp___7 = (struct device *)((void *)0);
    }
  } else {
    {
#line 34
    tmp___7 = & hwdev->dev;
    }
  }
  {
#line 34
  dma_free_attrs(tmp___7, size, vaddr, dma_handle, (struct dma_attrs *)((void *)0));
  }
#line 35
  return;
}
}
#line 37
__inline static dma_addr_t pci_map_single(struct pci_dev *hwdev , void *ptr , size_t size ,
                                          int direction )  __attribute__((__no_instrument_function__)) ;
#line 37 "../../../analyzer/../bench/linux-headers/include/asm-generic/pci-dma-compat.h"
__inline static dma_addr_t pci_map_single(struct pci_dev *hwdev , void *ptr , size_t size ,
                                          int direction ) 
{ 
  struct device *tmp___7 ;
  dma_addr_t tmp___8 ;

  {
#line 40
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
#line 40
    tmp___7 = (struct device *)((void *)0);
    }
  } else {
    {
#line 40
    tmp___7 = & hwdev->dev;
    }
  }
  {
#line 40
  tmp___8 = dma_map_single_attrs(tmp___7, ptr, size, (enum dma_data_direction )direction,
                                 (struct dma_attrs *)((void *)0));
  }
#line 40
  return (tmp___8);
}
}
#line 43
__inline static void pci_unmap_single(struct pci_dev *hwdev , dma_addr_t dma_addr ,
                                      size_t size , int direction )  __attribute__((__no_instrument_function__)) ;
#line 43 "../../../analyzer/../bench/linux-headers/include/asm-generic/pci-dma-compat.h"
__inline static void pci_unmap_single(struct pci_dev *hwdev , dma_addr_t dma_addr ,
                                      size_t size , int direction ) 
{ 
  struct device *tmp___7 ;

  {
#line 47
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
#line 47
    tmp___7 = (struct device *)((void *)0);
    }
  } else {
    {
#line 47
    tmp___7 = & hwdev->dev;
    }
  }
  {
#line 47
  dma_unmap_single_attrs(tmp___7, dma_addr, size, (enum dma_data_direction )direction,
                         (struct dma_attrs *)((void *)0));
  }
#line 48
  return;
}
}
#line 50
__inline static dma_addr_t pci_map_page(struct pci_dev *hwdev , struct page *page ,
                                        unsigned long offset , size_t size , int direction )  __attribute__((__no_instrument_function__)) ;
#line 50 "../../../analyzer/../bench/linux-headers/include/asm-generic/pci-dma-compat.h"
__inline static dma_addr_t pci_map_page(struct pci_dev *hwdev , struct page *page ,
                                        unsigned long offset , size_t size , int direction ) 
{ 
  struct device *tmp___7 ;
  dma_addr_t tmp___8 ;

  {
#line 54
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
#line 54
    tmp___7 = (struct device *)((void *)0);
    }
  } else {
    {
#line 54
    tmp___7 = & hwdev->dev;
    }
  }
  {
#line 54
  tmp___8 = dma_map_page(tmp___7, page, offset, size, (enum dma_data_direction )direction);
  }
#line 54
  return (tmp___8);
}
}
#line 57
__inline static void pci_unmap_page(struct pci_dev *hwdev , dma_addr_t dma_address ,
                                    size_t size , int direction )  __attribute__((__no_instrument_function__)) ;
#line 57 "../../../analyzer/../bench/linux-headers/include/asm-generic/pci-dma-compat.h"
__inline static void pci_unmap_page(struct pci_dev *hwdev , dma_addr_t dma_address ,
                                    size_t size , int direction ) 
{ 
  struct device *tmp___7 ;

  {
#line 61
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
#line 61
    tmp___7 = (struct device *)((void *)0);
    }
  } else {
    {
#line 61
    tmp___7 = & hwdev->dev;
    }
  }
  {
#line 61
  dma_unmap_page(tmp___7, dma_address, size, (enum dma_data_direction )direction);
  }
#line 62
  return;
}
}
#line 64
__inline static int pci_map_sg(struct pci_dev *hwdev , struct scatterlist *sg , int nents ,
                               int direction )  __attribute__((__no_instrument_function__)) ;
#line 64 "../../../analyzer/../bench/linux-headers/include/asm-generic/pci-dma-compat.h"
__inline static int pci_map_sg(struct pci_dev *hwdev , struct scatterlist *sg , int nents ,
                               int direction ) 
{ 
  struct device *tmp___7 ;
  int tmp___8 ;

  {
#line 68
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
#line 68
    tmp___7 = (struct device *)((void *)0);
    }
  } else {
    {
#line 68
    tmp___7 = & hwdev->dev;
    }
  }
  {
#line 68
  tmp___8 = dma_map_sg_attrs(tmp___7, sg, nents, (enum dma_data_direction )direction,
                             (struct dma_attrs *)((void *)0));
  }
#line 68
  return (tmp___8);
}
}
#line 71
__inline static void pci_unmap_sg(struct pci_dev *hwdev , struct scatterlist *sg ,
                                  int nents , int direction )  __attribute__((__no_instrument_function__)) ;
#line 71 "../../../analyzer/../bench/linux-headers/include/asm-generic/pci-dma-compat.h"
__inline static void pci_unmap_sg(struct pci_dev *hwdev , struct scatterlist *sg ,
                                  int nents , int direction ) 
{ 
  struct device *tmp___7 ;

  {
#line 75
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
#line 75
    tmp___7 = (struct device *)((void *)0);
    }
  } else {
    {
#line 75
    tmp___7 = & hwdev->dev;
    }
  }
  {
#line 75
  dma_unmap_sg_attrs(tmp___7, sg, nents, (enum dma_data_direction )direction, (struct dma_attrs *)((void *)0));
  }
#line 76
  return;
}
}
#line 78
__inline static void pci_dma_sync_single_for_cpu(struct pci_dev *hwdev , dma_addr_t dma_handle ,
                                                 size_t size , int direction )  __attribute__((__no_instrument_function__)) ;
#line 78 "../../../analyzer/../bench/linux-headers/include/asm-generic/pci-dma-compat.h"
__inline static void pci_dma_sync_single_for_cpu(struct pci_dev *hwdev , dma_addr_t dma_handle ,
                                                 size_t size , int direction ) 
{ 
  struct device *tmp___7 ;

  {
#line 82
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
#line 82
    tmp___7 = (struct device *)((void *)0);
    }
  } else {
    {
#line 82
    tmp___7 = & hwdev->dev;
    }
  }
  {
#line 82
  dma_sync_single_for_cpu(tmp___7, dma_handle, size, (enum dma_data_direction )direction);
  }
#line 83
  return;
}
}
#line 85
__inline static void pci_dma_sync_single_for_device(struct pci_dev *hwdev , dma_addr_t dma_handle ,
                                                    size_t size , int direction )  __attribute__((__no_instrument_function__)) ;
#line 85 "../../../analyzer/../bench/linux-headers/include/asm-generic/pci-dma-compat.h"
__inline static void pci_dma_sync_single_for_device(struct pci_dev *hwdev , dma_addr_t dma_handle ,
                                                    size_t size , int direction ) 
{ 
  struct device *tmp___7 ;

  {
#line 89
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
#line 89
    tmp___7 = (struct device *)((void *)0);
    }
  } else {
    {
#line 89
    tmp___7 = & hwdev->dev;
    }
  }
  {
#line 89
  dma_sync_single_for_device(tmp___7, dma_handle, size, (enum dma_data_direction )direction);
  }
#line 90
  return;
}
}
#line 92
__inline static void pci_dma_sync_sg_for_cpu(struct pci_dev *hwdev , struct scatterlist *sg ,
                                             int nelems , int direction )  __attribute__((__no_instrument_function__)) ;
#line 92 "../../../analyzer/../bench/linux-headers/include/asm-generic/pci-dma-compat.h"
__inline static void pci_dma_sync_sg_for_cpu(struct pci_dev *hwdev , struct scatterlist *sg ,
                                             int nelems , int direction ) 
{ 
  struct device *tmp___7 ;

  {
#line 96
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
#line 96
    tmp___7 = (struct device *)((void *)0);
    }
  } else {
    {
#line 96
    tmp___7 = & hwdev->dev;
    }
  }
  {
#line 96
  dma_sync_sg_for_cpu(tmp___7, sg, nelems, (enum dma_data_direction )direction);
  }
#line 97
  return;
}
}
#line 99
__inline static void pci_dma_sync_sg_for_device(struct pci_dev *hwdev , struct scatterlist *sg ,
                                                int nelems , int direction )  __attribute__((__no_instrument_function__)) ;
#line 99 "../../../analyzer/../bench/linux-headers/include/asm-generic/pci-dma-compat.h"
__inline static void pci_dma_sync_sg_for_device(struct pci_dev *hwdev , struct scatterlist *sg ,
                                                int nelems , int direction ) 
{ 
  struct device *tmp___7 ;

  {
#line 103
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
#line 103
    tmp___7 = (struct device *)((void *)0);
    }
  } else {
    {
#line 103
    tmp___7 = & hwdev->dev;
    }
  }
  {
#line 103
  dma_sync_sg_for_device(tmp___7, sg, nelems, (enum dma_data_direction )direction);
  }
#line 104
  return;
}
}
#line 106
__inline static int pci_dma_mapping_error(struct pci_dev *pdev , dma_addr_t dma_addr )  __attribute__((__no_instrument_function__)) ;
#line 106 "../../../analyzer/../bench/linux-headers/include/asm-generic/pci-dma-compat.h"
__inline static int pci_dma_mapping_error(struct pci_dev *pdev , dma_addr_t dma_addr ) 
{ 
  int tmp___7 ;

  {
  {
#line 109
  tmp___7 = dma_mapping_error(& pdev->dev, dma_addr);
  }
#line 109
  return (tmp___7);
}
}
#line 113
__inline static int pci_set_dma_mask(struct pci_dev *dev , u64 mask )  __attribute__((__no_instrument_function__)) ;
#line 113 "../../../analyzer/../bench/linux-headers/include/asm-generic/pci-dma-compat.h"
__inline static int pci_set_dma_mask(struct pci_dev *dev , u64 mask ) 
{ 
  int tmp___7 ;

  {
  {
#line 115
  tmp___7 = dma_set_mask(& dev->dev, mask);
  }
#line 115
  return (tmp___7);
}
}
#line 118
__inline static int pci_set_consistent_dma_mask(struct pci_dev *dev , u64 mask )  __attribute__((__no_instrument_function__)) ;
#line 118 "../../../analyzer/../bench/linux-headers/include/asm-generic/pci-dma-compat.h"
__inline static int pci_set_consistent_dma_mask(struct pci_dev *dev , u64 mask ) 
{ 
  int tmp___7 ;

  {
  {
#line 120
  tmp___7 = dma_set_coherent_mask(& dev->dev, mask);
  }
#line 120
  return (tmp___7);
}
}
#line 9 "../../../analyzer/../bench/linux-headers/include/asm-generic/pci.h"
__inline static struct resource *pcibios_select_root(struct pci_dev *pdev , struct resource *res )  __attribute__((__no_instrument_function__)) ;
#line 9 "../../../analyzer/../bench/linux-headers/include/asm-generic/pci.h"
__inline static struct resource *pcibios_select_root(struct pci_dev *pdev , struct resource *res ) 
{ 
  struct resource *root ;

  {
  {
#line 12
  root = (struct resource *)((void *)0);
  }
#line 14
  if (res->flags & 256UL) {
    {
#line 15
    root = & ioport_resource;
    }
  }
#line 16
  if (res->flags & 512UL) {
    {
#line 17
    root = & iomem_resource;
    }
  }
#line 19
  return (root);
}
}
#line 23
__inline static int pci_get_legacy_ide_irq(struct pci_dev *dev , int channel )  __attribute__((__no_instrument_function__)) ;
#line 23 "../../../analyzer/../bench/linux-headers/include/asm-generic/pci.h"
__inline static int pci_get_legacy_ide_irq(struct pci_dev *dev , int channel ) 
{ 
  int tmp___7 ;

  {
#line 25
  if (channel) {
    {
#line 25
    tmp___7 = 15;
    }
  } else {
    {
#line 25
    tmp___7 = 14;
    }
  }
#line 25
  return (tmp___7);
}
}
#line 125 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pci.h"
__inline static int __pcibus_to_node(struct pci_bus  const  *bus )  __attribute__((__no_instrument_function__)) ;
#line 125 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pci.h"
__inline static int __pcibus_to_node(struct pci_bus  const  *bus ) 
{ 
  struct pci_sysdata  const  *sd ;

  {
  {
#line 127
  sd = (struct pci_sysdata  const  *)bus->sysdata;
  }
#line 129
  return ((int )sd->node);
}
}
#line 132
__inline static struct cpumask  const  *cpumask_of_pcibus(struct pci_bus  const  *bus )  __attribute__((__no_instrument_function__)) ;
#line 132 "../../../analyzer/../bench/linux-headers/arch/x86/include/asm/pci.h"
__inline static struct cpumask  const  *cpumask_of_pcibus(struct pci_bus  const  *bus ) 
{ 
  int node ;
  struct cpumask  const  *tmp___7 ;
  struct cpumask  const  *tmp___8 ;

  {
  {
#line 137
  node = __pcibus_to_node(bus);
  }
#line 138
  if (node == -1) {
    {
#line 138
    tmp___8 = cpu_online_mask;
    }
  } else {
    {
#line 138
    tmp___7 = cpumask_of_node(node);
#line 138
    tmp___8 = (struct cpumask  const  * const  )tmp___7;
    }
  }
#line 138
  return ((struct cpumask  const  *)tmp___8);
}
}
#line 1432 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev )  __attribute__((__no_instrument_function__)) ;
#line 1432 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev ) 
{ 
  void *tmp___7 ;

  {
  {
#line 1434
  tmp___7 = dev_get_drvdata((struct device  const  *)(& pdev->dev));
  }
#line 1434
  return (tmp___7);
}
}
#line 1437
__inline static void pci_set_drvdata(struct pci_dev *pdev , void *data )  __attribute__((__no_instrument_function__)) ;
#line 1437 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static void pci_set_drvdata(struct pci_dev *pdev , void *data ) 
{ 


  {
  {
#line 1439
  dev_set_drvdata(& pdev->dev, data);
  }
#line 1440
  return;
}
}
#line 1445
__inline static char const   *pci_name(struct pci_dev  const  *pdev )  __attribute__((__no_instrument_function__)) ;
#line 1445 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static char const   *pci_name(struct pci_dev  const  *pdev ) 
{ 
  char const   *tmp___7 ;

  {
  {
#line 1447
  tmp___7 = dev_name(& pdev->dev);
  }
#line 1447
  return (tmp___7);
}
}
#line 1455
__inline static void pci_resource_to_user(struct pci_dev  const  *dev , int bar ,
                                          struct resource  const  *rsrc , resource_size_t *start ,
                                          resource_size_t *end )  __attribute__((__no_instrument_function__)) ;
#line 1455 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static void pci_resource_to_user(struct pci_dev  const  *dev , int bar ,
                                          struct resource  const  *rsrc , resource_size_t *start ,
                                          resource_size_t *end ) 
{ 


  {
  {
#line 1459
  *start = (resource_size_t )rsrc->start;
#line 1460
  *end = (resource_size_t )rsrc->end;
  }
#line 1461
  return;
}
}
#line 1565
extern void pci_fixup_device(enum pci_fixup_pass pass , struct pci_dev *dev ) ;
#line 1566
extern struct pci_dev *pci_get_dma_source(struct pci_dev *dev ) ;
#line 1567
extern int pci_dev_specific_acs_enabled(struct pci_dev *dev , u16 acs_flags ) ;
#line 1568
extern void pci_dev_specific_enable_acs(struct pci_dev *dev ) ;
#line 1584
extern void *pcim_iomap(struct pci_dev *pdev , int bar , unsigned long maxlen ) ;
#line 1585
extern void pcim_iounmap(struct pci_dev *pdev , void *addr ) ;
#line 1586
extern void * const  *pcim_iomap_table(struct pci_dev *pdev ) ;
#line 1587
extern int pcim_iomap_regions(struct pci_dev *pdev , int mask , char const   *name ) ;
#line 1588
extern int pcim_iomap_regions_request_all(struct pci_dev *pdev , int mask , char const   *name ) ;
#line 1590
extern void pcim_iounmap_regions(struct pci_dev *pdev , int mask ) ;
#line 1592
extern int pci_pci_problems ;
#line 1601
extern unsigned long pci_cardbus_io_size ;
#line 1602
extern unsigned long pci_cardbus_mem_size ;
#line 1603
extern u8 pci_dfl_cache_line_size ;
#line 1604
extern u8 pci_cache_line_size ;
#line 1606
extern unsigned long pci_hotplug_io_size ;
#line 1607
extern unsigned long pci_hotplug_mem_size ;
#line 1610
extern void pcibios_disable_device(struct pci_dev *dev ) ;
#line 1612
extern int pcibios_set_pcie_reset_state(struct pci_dev *dev , enum pcie_reset_state state ) ;
#line 1614
extern int pcibios_add_device(struct pci_dev *dev ) ;
#line 1615
extern void pcibios_release_device(struct pci_dev *dev ) ;
#line 1616
extern void pcibios_penalize_isa_irq(int irq , int active ) ;
#line 1619
extern struct dev_pm_ops pcibios_pm_ops ;
#line 1623
extern void __attribute__((__cold__))  pci_mmcfg_early_init(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 1624
extern void __attribute__((__cold__))  pci_mmcfg_late_init(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 1630
extern int pci_ext_cfg_avail(void) ;
#line 1632
extern void *pci_ioremap_bar(struct pci_dev *pdev , int bar ) ;
#line 1642
__inline static int pci_enable_sriov(struct pci_dev *dev , int nr_virtfn )  __attribute__((__no_instrument_function__)) ;
#line 1642 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static int pci_enable_sriov(struct pci_dev *dev , int nr_virtfn ) 
{ 


  {
#line 1643
  return (-19);
}
}
#line 1644
__inline static void pci_disable_sriov(struct pci_dev *dev )  __attribute__((__no_instrument_function__)) ;
#line 1644 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static void pci_disable_sriov(struct pci_dev *dev ) 
{ 


  {
#line 1644
  return;
}
}
#line 1645
__inline static int pci_num_vf(struct pci_dev *dev )  __attribute__((__no_instrument_function__)) ;
#line 1645 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static int pci_num_vf(struct pci_dev *dev ) 
{ 


  {
#line 1645
  return (0);
}
}
#line 1646
__inline static int pci_vfs_assigned(struct pci_dev *dev )  __attribute__((__no_instrument_function__)) ;
#line 1646 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static int pci_vfs_assigned(struct pci_dev *dev ) 
{ 


  {
#line 1647
  return (0);
}
}
#line 1648
__inline static int pci_sriov_set_totalvfs(struct pci_dev *dev , u16 numvfs )  __attribute__((__no_instrument_function__)) ;
#line 1648 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static int pci_sriov_set_totalvfs(struct pci_dev *dev , u16 numvfs ) 
{ 


  {
#line 1649
  return (0);
}
}
#line 1650
__inline static int pci_sriov_get_totalvfs(struct pci_dev *dev )  __attribute__((__no_instrument_function__)) ;
#line 1650 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static int pci_sriov_get_totalvfs(struct pci_dev *dev ) 
{ 


  {
#line 1651
  return (0);
}
}
#line 1655
extern void pci_hp_create_module_link(struct pci_slot *pci_slot ) ;
#line 1656
extern void pci_hp_remove_module_link(struct pci_slot *pci_slot ) ;
#line 1670
__inline static int pci_pcie_cap(struct pci_dev *dev )  __attribute__((__no_instrument_function__)) ;
#line 1670 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static int pci_pcie_cap(struct pci_dev *dev ) 
{ 


  {
#line 1672
  return ((int )dev->pcie_cap);
}
}
#line 1681
__inline static bool pci_is_pcie(struct pci_dev *dev )  __attribute__((__no_instrument_function__)) ;
#line 1681 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static bool pci_is_pcie(struct pci_dev *dev ) 
{ 
  int tmp___7 ;

  {
  {
#line 1683
  tmp___7 = pci_pcie_cap(dev);
  }
#line 1683
  return ((bool )tmp___7);
}
}
#line 1690
__inline static u16 pcie_caps_reg(struct pci_dev  const  *dev )  __attribute__((__no_instrument_function__)) ;
#line 1690 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static u16 pcie_caps_reg(struct pci_dev  const  *dev ) 
{ 


  {
#line 1692
  return ((u16 )dev->pcie_flags_reg);
}
}
#line 1699
__inline static int pci_pcie_type(struct pci_dev  const  *dev )  __attribute__((__no_instrument_function__)) ;
#line 1699 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static int pci_pcie_type(struct pci_dev  const  *dev ) 
{ 
  u16 tmp___7 ;

  {
  {
#line 1701
  tmp___7 = pcie_caps_reg(dev);
  }
#line 1701
  return (((int )tmp___7 & 240) >> 4);
}
}
#line 1704
extern void pci_request_acs(void) ;
#line 1705
extern bool pci_acs_enabled(struct pci_dev *pdev , u16 acs_flags ) ;
#line 1706
extern bool pci_acs_path_enabled(struct pci_dev *start , struct pci_dev *end , u16 acs_flags ) ;
#line 1745
__inline static u16 pci_vpd_lrdt_size(u8 const   *lrdt )  __attribute__((__no_instrument_function__)) ;
#line 1745 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static u16 pci_vpd_lrdt_size(u8 const   *lrdt ) 
{ 


  {
#line 1747
  return ((u16 )((int )((u16 )*(lrdt + 1)) + ((int )((u16 )*(lrdt + 2)) << 8)));
}
}
#line 1756
__inline static u8 pci_vpd_srdt_size(u8 const   *srdt )  __attribute__((__no_instrument_function__)) ;
#line 1756 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static u8 pci_vpd_srdt_size(u8 const   *srdt ) 
{ 


  {
#line 1758
  return ((u8 )((int const   )*srdt & 7));
}
}
#line 1767
__inline static u8 pci_vpd_info_field_size(u8 const   *info_field )  __attribute__((__no_instrument_function__)) ;
#line 1767 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static u8 pci_vpd_info_field_size(u8 const   *info_field ) 
{ 


  {
#line 1769
  return ((u8 )*(info_field + 2));
}
}
#line 1782
extern int pci_vpd_find_tag(u8 const   *buf , unsigned int off , unsigned int len ,
                            u8 rdt ) ;
#line 1794
extern int pci_vpd_find_info_keyword(u8 const   *buf , unsigned int off , unsigned int len ,
                                     char const   *kw ) ;
#line 1820
__inline static void pci_set_of_node(struct pci_dev *dev )  __attribute__((__no_instrument_function__)) ;
#line 1820 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static void pci_set_of_node(struct pci_dev *dev ) 
{ 


  {
#line 1820
  return;
}
}
#line 1821
__inline static void pci_release_of_node(struct pci_dev *dev )  __attribute__((__no_instrument_function__)) ;
#line 1821 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static void pci_release_of_node(struct pci_dev *dev ) 
{ 


  {
#line 1821
  return;
}
}
#line 1822
__inline static void pci_set_bus_of_node(struct pci_bus *bus )  __attribute__((__no_instrument_function__)) ;
#line 1822 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static void pci_set_bus_of_node(struct pci_bus *bus ) 
{ 


  {
#line 1822
  return;
}
}
#line 1823
__inline static void pci_release_bus_of_node(struct pci_bus *bus )  __attribute__((__no_instrument_function__)) ;
#line 1823 "../../../analyzer/../bench/linux-headers/include/linux/pci.h"
__inline static void pci_release_bus_of_node(struct pci_bus *bus ) 
{ 


  {
#line 1823
  return;
}
}
#line 1833
extern int pci_for_each_dma_alias(struct pci_dev *pdev , int (*fn)(struct pci_dev *pdev ,
                                                                   u16 alias , void *data ) ,
                                  void *data ) ;
#line 1846
extern struct pci_dev *pci_find_upstream_pcie_bridge(struct pci_dev *pdev ) ;
#line 23 "../../../analyzer/../bench/linux-headers/include/linux/kdev_t.h"
__inline static int old_valid_dev(dev_t dev )  __attribute__((__no_instrument_function__)) ;
#line 23 "../../../analyzer/../bench/linux-headers/include/linux/kdev_t.h"
__inline static int old_valid_dev(dev_t dev ) 
{ 
  int tmp___7 ;

  {
#line 25
  if (dev >> 20 < 256U) {
#line 25
    if ((dev & ((1U << 20) - 1U)) < 256U) {
      {
#line 25
      tmp___7 = 1;
      }
    } else {
      {
#line 25
      tmp___7 = 0;
      }
    }
  } else {
    {
#line 25
    tmp___7 = 0;
    }
  }
#line 25
  return (tmp___7);
}
}
#line 28
__inline static u16 old_encode_dev(dev_t dev )  __attribute__((__no_instrument_function__)) ;
#line 28 "../../../analyzer/../bench/linux-headers/include/linux/kdev_t.h"
__inline static u16 old_encode_dev(dev_t dev ) 
{ 


  {
#line 30
  return ((u16 )(((dev >> 20) << 8) | (dev & ((1U << 20) - 1U))));
}
}
#line 33
__inline static dev_t old_decode_dev(u16 val )  __attribute__((__no_instrument_function__)) ;
#line 33 "../../../analyzer/../bench/linux-headers/include/linux/kdev_t.h"
__inline static dev_t old_decode_dev(u16 val ) 
{ 


  {
#line 35
  return ((dev_t )(((((int )val >> 8) & 255) << 20) | ((int )val & 255)));
}
}
#line 38
__inline static int new_valid_dev(dev_t dev )  __attribute__((__no_instrument_function__)) ;
#line 38 "../../../analyzer/../bench/linux-headers/include/linux/kdev_t.h"
__inline static int new_valid_dev(dev_t dev ) 
{ 


  {
#line 40
  return (1);
}
}
#line 43
__inline static u32 new_encode_dev(dev_t dev )  __attribute__((__no_instrument_function__)) ;
#line 43 "../../../analyzer/../bench/linux-headers/include/linux/kdev_t.h"
__inline static u32 new_encode_dev(dev_t dev ) 
{ 
  unsigned int major ;
  unsigned int minor ;

  {
  {
#line 45
  major = dev >> 20;
#line 46
  minor = dev & ((1U << 20) - 1U);
  }
#line 47
  return (((minor & 255U) | (major << 8)) | ((minor & 4294967040U) << 12));
}
}
#line 50
__inline static dev_t new_decode_dev(u32 dev )  __attribute__((__no_instrument_function__)) ;
#line 50 "../../../analyzer/../bench/linux-headers/include/linux/kdev_t.h"
__inline static dev_t new_decode_dev(u32 dev ) 
{ 
  unsigned int major ;
  unsigned int minor ;

  {
  {
#line 52
  major = (dev & 1048320U) >> 8;
#line 53
  minor = (dev & 255U) | ((dev >> 12) & 1048320U);
  }
#line 54
  return ((major << 20) | minor);
}
}
#line 57
__inline static int huge_valid_dev(dev_t dev )  __attribute__((__no_instrument_function__)) ;
#line 57 "../../../analyzer/../bench/linux-headers/include/linux/kdev_t.h"
__inline static int huge_valid_dev(dev_t dev ) 
{ 


  {
#line 59
  return (1);
}
}
#line 62
__inline static u64 huge_encode_dev(dev_t dev )  __attribute__((__no_instrument_function__)) ;
#line 62 "../../../analyzer/../bench/linux-headers/include/linux/kdev_t.h"
__inline static u64 huge_encode_dev(dev_t dev ) 
{ 
  u32 tmp___7 ;

  {
  {
#line 64
  tmp___7 = new_encode_dev(dev);
  }
#line 64
  return ((u64 )tmp___7);
}
}
#line 67
__inline static dev_t huge_decode_dev(u64 dev )  __attribute__((__no_instrument_function__)) ;
#line 67 "../../../analyzer/../bench/linux-headers/include/linux/kdev_t.h"
__inline static dev_t huge_decode_dev(u64 dev ) 
{ 
  dev_t tmp___7 ;

  {
  {
#line 69
  tmp___7 = new_decode_dev((u32 )dev);
  }
#line 69
  return (tmp___7);
}
}
#line 72
__inline static int sysv_valid_dev(dev_t dev )  __attribute__((__no_instrument_function__)) ;
#line 72 "../../../analyzer/../bench/linux-headers/include/linux/kdev_t.h"
__inline static int sysv_valid_dev(dev_t dev ) 
{ 
  int tmp___7 ;

  {
#line 74
  if (dev >> 20 < (unsigned int )(1 << 14)) {
#line 74
    if ((dev & ((1U << 20) - 1U)) < (unsigned int )(1 << 18)) {
      {
#line 74
      tmp___7 = 1;
      }
    } else {
      {
#line 74
      tmp___7 = 0;
      }
    }
  } else {
    {
#line 74
    tmp___7 = 0;
    }
  }
#line 74
  return (tmp___7);
}
}
#line 77
__inline static u32 sysv_encode_dev(dev_t dev )  __attribute__((__no_instrument_function__)) ;
#line 77 "../../../analyzer/../bench/linux-headers/include/linux/kdev_t.h"
__inline static u32 sysv_encode_dev(dev_t dev ) 
{ 


  {
#line 79
  return ((dev & ((1U << 20) - 1U)) | ((dev >> 20) << 18));
}
}
#line 82
__inline static unsigned int sysv_major(u32 dev )  __attribute__((__no_instrument_function__)) ;
#line 82 "../../../analyzer/../bench/linux-headers/include/linux/kdev_t.h"
__inline static unsigned int sysv_major(u32 dev ) 
{ 


  {
#line 84
  return ((dev >> 18) & 16383U);
}
}
#line 87
__inline static unsigned int sysv_minor(u32 dev )  __attribute__((__no_instrument_function__)) ;
#line 87 "../../../analyzer/../bench/linux-headers/include/linux/kdev_t.h"
__inline static unsigned int sysv_minor(u32 dev ) 
{ 


  {
#line 89
  return (dev & 262143U);
}
}
#line 43 "../../../analyzer/../bench/linux-headers/include/linux/list_bl.h"
__inline static void INIT_HLIST_BL_NODE(struct hlist_bl_node *h )  __attribute__((__no_instrument_function__)) ;
#line 43 "../../../analyzer/../bench/linux-headers/include/linux/list_bl.h"
__inline static void INIT_HLIST_BL_NODE(struct hlist_bl_node *h ) 
{ 


  {
  {
#line 45
  h->next = (struct hlist_bl_node *)((void *)0);
#line 46
  h->pprev = (struct hlist_bl_node **)((void *)0);
  }
#line 47
  return;
}
}
#line 51
__inline static int hlist_bl_unhashed(struct hlist_bl_node  const  *h )  __attribute__((__no_instrument_function__)) ;
#line 51 "../../../analyzer/../bench/linux-headers/include/linux/list_bl.h"
__inline static int hlist_bl_unhashed(struct hlist_bl_node  const  *h ) 
{ 


  {
#line 53
  return (! h->pprev);
}
}
#line 56
__inline static struct hlist_bl_node *hlist_bl_first(struct hlist_bl_head *h )  __attribute__((__no_instrument_function__)) ;
#line 56 "../../../analyzer/../bench/linux-headers/include/linux/list_bl.h"
__inline static struct hlist_bl_node *hlist_bl_first(struct hlist_bl_head *h ) 
{ 


  {
#line 58
  return ((struct hlist_bl_node *)((unsigned long )h->first & 0xfffffffffffffffeUL));
}
}
#line 62
__inline static void hlist_bl_set_first(struct hlist_bl_head *h , struct hlist_bl_node *n )  __attribute__((__no_instrument_function__)) ;
#line 62 "../../../analyzer/../bench/linux-headers/include/linux/list_bl.h"
__inline static void hlist_bl_set_first(struct hlist_bl_head *h , struct hlist_bl_node *n ) 
{ 


  {
  {
#line 68
  h->first = (struct hlist_bl_node *)((unsigned long )n | 1UL);
  }
#line 69
  return;
}
}
#line 71
__inline static int hlist_bl_empty(struct hlist_bl_head  const  *h )  __attribute__((__no_instrument_function__)) ;
#line 71 "../../../analyzer/../bench/linux-headers/include/linux/list_bl.h"
__inline static int hlist_bl_empty(struct hlist_bl_head  const  *h ) 
{ 


  {
#line 73
  return (! ((unsigned long )h->first & 0xfffffffffffffffeUL));
}
}
#line 76
__inline static void hlist_bl_add_head(struct hlist_bl_node *n , struct hlist_bl_head *h )  __attribute__((__no_instrument_function__)) ;
#line 76 "../../../analyzer/../bench/linux-headers/include/linux/list_bl.h"
__inline static void hlist_bl_add_head(struct hlist_bl_node *n , struct hlist_bl_head *h ) 
{ 
  struct hlist_bl_node *first ;
  struct hlist_bl_node *tmp___7 ;

  {
  {
#line 79
  tmp___7 = hlist_bl_first(h);
#line 79
  first = tmp___7;
#line 81
  n->next = first;
  }
#line 82
  if (first) {
    {
#line 83
    first->pprev = & n->next;
    }
  }
  {
#line 84
  n->pprev = & h->first;
#line 85
  hlist_bl_set_first(h, n);
  }
#line 86
  return;
}
}
#line 88
__inline static void __hlist_bl_del(struct hlist_bl_node *n )  __attribute__((__no_instrument_function__)) ;
#line 88 "../../../analyzer/../bench/linux-headers/include/linux/list_bl.h"
__inline static void __hlist_bl_del(struct hlist_bl_node *n ) 
{ 
  struct hlist_bl_node *next ;
  struct hlist_bl_node **pprev ;

  {
  {
#line 90
  next = n->next;
#line 91
  pprev = n->pprev;
#line 96
  *pprev = (struct hlist_bl_node *)((unsigned long )next | ((unsigned long )*pprev & 1UL));
  }
#line 99
  if (next) {
    {
#line 100
    next->pprev = pprev;
    }
  }
#line 101
  return;
}
}
#line 103
__inline static void hlist_bl_del(struct hlist_bl_node *n )  __attribute__((__no_instrument_function__)) ;
#line 103 "../../../analyzer/../bench/linux-headers/include/linux/list_bl.h"
__inline static void hlist_bl_del(struct hlist_bl_node *n ) 
{ 


  {
  {
#line 105
  __hlist_bl_del(n);
#line 106
  n->next = (struct hlist_bl_node *)((void *)1048832 + 0xdead000000000000UL);
#line 107
  n->pprev = (struct hlist_bl_node **)((void *)2097664 + 0xdead000000000000UL);
  }
#line 108
  return;
}
}
#line 110
__inline static void hlist_bl_del_init(struct hlist_bl_node *n )  __attribute__((__no_instrument_function__)) ;
#line 110 "../../../analyzer/../bench/linux-headers/include/linux/list_bl.h"
__inline static void hlist_bl_del_init(struct hlist_bl_node *n ) 
{ 
  int tmp___7 ;

  {
  {
#line 112
  tmp___7 = hlist_bl_unhashed((struct hlist_bl_node  const  *)n);
  }
#line 112
  if (! tmp___7) {
    {
#line 113
    __hlist_bl_del(n);
#line 114
    INIT_HLIST_BL_NODE(n);
    }
  }
#line 116
  return;
}
}
#line 118
__inline static void hlist_bl_lock(struct hlist_bl_head *b )  __attribute__((__no_instrument_function__)) ;
#line 118 "../../../analyzer/../bench/linux-headers/include/linux/list_bl.h"
__inline static void hlist_bl_lock(struct hlist_bl_head *b ) 
{ 


  {
  {
#line 120
  bit_spin_lock(0, (unsigned long *)b);
  }
#line 121
  return;
}
}
#line 123
__inline static void hlist_bl_unlock(struct hlist_bl_head *b )  __attribute__((__no_instrument_function__)) ;
#line 123 "../../../analyzer/../bench/linux-headers/include/linux/list_bl.h"
__inline static void hlist_bl_unlock(struct hlist_bl_head *b ) 
{ 


  {
  {
#line 125
  __bit_spin_unlock(0, (unsigned long *)b);
  }
#line 126
  return;
}
}
#line 128
__inline static bool hlist_bl_is_locked(struct hlist_bl_head *b )  __attribute__((__no_instrument_function__)) ;
#line 128 "../../../analyzer/../bench/linux-headers/include/linux/list_bl.h"
__inline static bool hlist_bl_is_locked(struct hlist_bl_head *b ) 
{ 
  int tmp___7 ;

  {
  {
#line 130
  tmp___7 = bit_spin_is_locked(0, (unsigned long *)b);
  }
#line 130
  return ((bool )tmp___7);
}
}
#line 16 "../../../analyzer/../bench/linux-headers/include/linux/rculist_bl.h"
extern void __compiletime_assert_17(void)  __attribute__((__error__("Need native word sized stores/loads for atomicity."))) ;
#line 10
__inline static void hlist_bl_set_first_rcu(struct hlist_bl_head *h , struct hlist_bl_node *n )  __attribute__((__no_instrument_function__)) ;
#line 10 "../../../analyzer/../bench/linux-headers/include/linux/rculist_bl.h"
__inline static void hlist_bl_set_first_rcu(struct hlist_bl_head *h , struct hlist_bl_node *n ) 
{ 
  bool __cond ;
  int tmp___7 ;

  {
  {
#line 16
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 16
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 16
      if (sizeof(h->first) == sizeof(int )) {
        {
#line 16
        tmp___7 = 0;
        }
      } else
#line 16
      if (sizeof(h->first) == sizeof(long )) {
        {
#line 16
        tmp___7 = 0;
        }
      } else {
        {
#line 16
        tmp___7 = 1;
        }
      }
      {
#line 16
      __cond = (bool )tmp___7;
      }
#line 16
      if (__cond) {
        {
#line 16
        __compiletime_assert_17();
        }
      }
      {
#line 16
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 16
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 16
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 16
    __asm__  volatile   ("": : : "memory");
#line 16
    *((struct hlist_bl_node * volatile  *)(& h->first)) = (struct hlist_bl_node * volatile  )((struct hlist_bl_node *)((unsigned long )n | 1UL));
    }
#line 16
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 18
  return;
}
}
#line 20
__inline static struct hlist_bl_node *hlist_bl_first_rcu(struct hlist_bl_head *h )  __attribute__((__no_instrument_function__)) ;
#line 20 "../../../analyzer/../bench/linux-headers/include/linux/rculist_bl.h"
__inline static struct hlist_bl_node *hlist_bl_first_rcu(struct hlist_bl_head *h ) 
{ 
  struct hlist_bl_node *_________p1 ;

  {
  {
#line 23
  _________p1 = (struct hlist_bl_node *)*((struct hlist_bl_node * volatile  *)(& h->first));
  }
  {
#line 23
  while (1) {
    while_continue: /* CIL Label */ ;
#line 23
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 23
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 23
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 22
  return ((struct hlist_bl_node *)((unsigned long )_________p1 & 0xfffffffffffffffeUL));
}
}
#line 46
__inline static void hlist_bl_del_init_rcu(struct hlist_bl_node *n )  __attribute__((__no_instrument_function__)) ;
#line 46 "../../../analyzer/../bench/linux-headers/include/linux/rculist_bl.h"
__inline static void hlist_bl_del_init_rcu(struct hlist_bl_node *n ) 
{ 
  int tmp___7 ;

  {
  {
#line 48
  tmp___7 = hlist_bl_unhashed((struct hlist_bl_node  const  *)n);
  }
#line 48
  if (! tmp___7) {
    {
#line 49
    __hlist_bl_del(n);
#line 50
    n->pprev = (struct hlist_bl_node **)((void *)0);
    }
  }
#line 52
  return;
}
}
#line 73
__inline static void hlist_bl_del_rcu(struct hlist_bl_node *n )  __attribute__((__no_instrument_function__)) ;
#line 73 "../../../analyzer/../bench/linux-headers/include/linux/rculist_bl.h"
__inline static void hlist_bl_del_rcu(struct hlist_bl_node *n ) 
{ 


  {
  {
#line 75
  __hlist_bl_del(n);
#line 76
  n->pprev = (struct hlist_bl_node **)((void *)2097664 + 0xdead000000000000UL);
  }
#line 77
  return;
}
}
#line 98
__inline static void hlist_bl_add_head_rcu(struct hlist_bl_node *n , struct hlist_bl_head *h )  __attribute__((__no_instrument_function__)) ;
#line 98 "../../../analyzer/../bench/linux-headers/include/linux/rculist_bl.h"
__inline static void hlist_bl_add_head_rcu(struct hlist_bl_node *n , struct hlist_bl_head *h ) 
{ 
  struct hlist_bl_node *first ;

  {
  {
#line 104
  first = hlist_bl_first(h);
#line 106
  n->next = first;
  }
#line 107
  if (first) {
    {
#line 108
    first->pprev = & n->next;
    }
  }
  {
#line 109
  n->pprev = & h->first;
#line 112
  hlist_bl_set_first_rcu(h, n);
  }
#line 113
  return;
}
}
#line 36 "../../../analyzer/../bench/linux-headers/include/linux/lockref.h"
extern void lockref_get(struct lockref * ) ;
#line 37
extern int lockref_get_not_zero(struct lockref * ) ;
#line 38
extern int lockref_get_or_lock(struct lockref * ) ;
#line 39
extern int lockref_put_or_lock(struct lockref * ) ;
#line 41
extern void lockref_mark_dead(struct lockref * ) ;
#line 42
extern int lockref_get_not_dead(struct lockref * ) ;
#line 45
__inline static int __lockref_is_dead(struct lockref  const  *l )  __attribute__((__no_instrument_function__)) ;
#line 45 "../../../analyzer/../bench/linux-headers/include/linux/lockref.h"
__inline static int __lockref_is_dead(struct lockref  const  *l ) 
{ 


  {
#line 47
  return ((int )l->__annonCompField45.__annonCompField44.count < 0);
}
}
#line 67 "../../../analyzer/../bench/linux-headers/include/linux/dcache.h"
extern struct dentry_stat_t dentry_stat ;
#line 74
__inline static unsigned long partial_name_hash(unsigned long c , unsigned long prevhash )  __attribute__((__no_instrument_function__)) ;
#line 74 "../../../analyzer/../bench/linux-headers/include/linux/dcache.h"
__inline static unsigned long partial_name_hash(unsigned long c , unsigned long prevhash ) 
{ 


  {
#line 77
  return (((prevhash + (c << 4)) + (c >> 4)) * 11UL);
}
}
#line 84
__inline static unsigned long end_name_hash(unsigned long hash )  __attribute__((__no_instrument_function__)) ;
#line 84 "../../../analyzer/../bench/linux-headers/include/linux/dcache.h"
__inline static unsigned long end_name_hash(unsigned long hash ) 
{ 


  {
#line 86
  return ((unsigned long )((unsigned int )hash));
}
}
#line 90
extern unsigned int full_name_hash(unsigned char const   * , unsigned int  ) ;
#line 227
extern seqlock_t rename_lock ;
#line 229
__inline static int dname_external(struct dentry  const  *dentry )  __attribute__((__no_instrument_function__)) ;
#line 229 "../../../analyzer/../bench/linux-headers/include/linux/dcache.h"
__inline static int dname_external(struct dentry  const  *dentry ) 
{ 


  {
#line 231
  return ((unsigned long )dentry->d_name.name != (unsigned long )(dentry->d_iname));
}
}
#line 237
extern void d_instantiate(struct dentry * , struct inode * ) ;
#line 238
extern struct dentry *d_instantiate_unique(struct dentry * , struct inode * ) ;
#line 239
extern struct dentry *d_materialise_unique(struct dentry * , struct inode * ) ;
#line 240
extern int d_instantiate_no_diralias(struct dentry * , struct inode * ) ;
#line 241
extern void __d_drop(struct dentry *dentry ) ;
#line 242
extern void d_drop(struct dentry *dentry ) ;
#line 243
extern void d_delete(struct dentry * ) ;
#line 244
extern void d_set_d_op(struct dentry *dentry , struct dentry_operations  const  *op ) ;
#line 247
extern struct dentry *d_alloc(struct dentry * , struct qstr  const  * ) ;
#line 248
extern struct dentry *d_alloc_pseudo(struct super_block * , struct qstr  const  * ) ;
#line 249
extern struct dentry *d_splice_alias(struct inode * , struct dentry * ) ;
#line 250
extern struct dentry *d_add_ci(struct dentry * , struct inode * , struct qstr * ) ;
#line 251
extern struct dentry *d_find_any_alias(struct inode *inode ) ;
#line 252
extern struct dentry *d_obtain_alias(struct inode * ) ;
#line 253
extern struct dentry *d_obtain_root(struct inode * ) ;
#line 254
extern void shrink_dcache_sb(struct super_block * ) ;
#line 255
extern void shrink_dcache_parent(struct dentry * ) ;
#line 256
extern void shrink_dcache_for_umount(struct super_block * ) ;
#line 257
extern int d_invalidate(struct dentry * ) ;
#line 260
extern struct dentry *d_make_root(struct inode * ) ;
#line 263
extern void d_genocide(struct dentry * ) ;
#line 265
extern void d_tmpfile(struct dentry * , struct inode * ) ;
#line 267
extern struct dentry *d_find_alias(struct inode * ) ;
#line 268
extern void d_prune_aliases(struct inode * ) ;
#line 271
extern int have_submounts(struct dentry * ) ;
#line 272
extern int check_submounts_and_drop(struct dentry * ) ;
#line 277
extern void d_rehash(struct dentry * ) ;
#line 288
__inline static void d_add(struct dentry *entry , struct inode *inode )  __attribute__((__no_instrument_function__)) ;
#line 288 "../../../analyzer/../bench/linux-headers/include/linux/dcache.h"
__inline static void d_add(struct dentry *entry , struct inode *inode ) 
{ 


  {
  {
#line 290
  d_instantiate(entry, inode);
#line 291
  d_rehash(entry);
  }
#line 292
  return;
}
}
#line 302
__inline static struct dentry *d_add_unique(struct dentry *entry , struct inode *inode )  __attribute__((__no_instrument_function__)) ;
#line 302 "../../../analyzer/../bench/linux-headers/include/linux/dcache.h"
__inline static struct dentry *d_add_unique(struct dentry *entry , struct inode *inode ) 
{ 
  struct dentry *res ;
  struct dentry *tmp___7 ;

  {
  {
#line 306
  res = d_instantiate_unique(entry, inode);
  }
#line 307
  if ((unsigned long )res != (unsigned long )((void *)0)) {
    {
#line 307
    tmp___7 = res;
    }
  } else {
    {
#line 307
    tmp___7 = entry;
    }
  }
  {
#line 307
  d_rehash(tmp___7);
  }
#line 308
  return (res);
}
}
#line 311
extern void dentry_update_name_case(struct dentry * , struct qstr * ) ;
#line 314
extern void d_move(struct dentry * , struct dentry * ) ;
#line 315
extern void d_exchange(struct dentry * , struct dentry * ) ;
#line 316
extern struct dentry *d_ancestor(struct dentry * , struct dentry * ) ;
#line 319
extern struct dentry *d_lookup(struct dentry  const  * , struct qstr  const  * ) ;
#line 320
extern struct dentry *d_hash_and_lookup(struct dentry * , struct qstr * ) ;
#line 321
extern struct dentry *__d_lookup(struct dentry  const  * , struct qstr  const  * ) ;
#line 322
extern struct dentry *__d_lookup_rcu(struct dentry  const  *parent , struct qstr  const  *name ,
                                     unsigned int *seq ) ;
#line 325
__inline static unsigned int d_count(struct dentry  const  *dentry )  __attribute__((__no_instrument_function__)) ;
#line 325 "../../../analyzer/../bench/linux-headers/include/linux/dcache.h"
__inline static unsigned int d_count(struct dentry  const  *dentry ) 
{ 


  {
#line 327
  return ((unsigned int )dentry->d_lockref.__annonCompField45.__annonCompField44.count);
}
}
#line 331
extern int d_validate(struct dentry * , struct dentry * ) ;
#line 336
extern char *dynamic_dname(struct dentry * , char * , int  , char const   *  , ...) ;
#line 337
extern char *simple_dname(struct dentry * , char * , int  ) ;
#line 339
extern char *__d_path(struct path  const  * , struct path  const  * , char * , int  ) ;
#line 340
extern char *d_absolute_path(struct path  const  * , char * , int  ) ;
#line 341
extern char *d_path(struct path  const  * , char * , int  ) ;
#line 342
extern char *dentry_path_raw(struct dentry * , char * , int  ) ;
#line 343
extern char *dentry_path(struct dentry * , char * , int  ) ;
#line 355
__inline static struct dentry *dget_dlock(struct dentry *dentry )  __attribute__((__no_instrument_function__)) ;
#line 355 "../../../analyzer/../bench/linux-headers/include/linux/dcache.h"
__inline static struct dentry *dget_dlock(struct dentry *dentry ) 
{ 


  {
#line 357
  if (dentry) {
    {
#line 358
    (dentry->d_lockref.__annonCompField45.__annonCompField44.count) ++;
    }
  }
#line 359
  return (dentry);
}
}
#line 362
__inline static struct dentry *dget(struct dentry *dentry )  __attribute__((__no_instrument_function__)) ;
#line 362 "../../../analyzer/../bench/linux-headers/include/linux/dcache.h"
__inline static struct dentry *dget(struct dentry *dentry ) 
{ 


  {
#line 364
  if (dentry) {
    {
#line 365
    lockref_get(& dentry->d_lockref);
    }
  }
#line 366
  return (dentry);
}
}
#line 369
extern struct dentry *dget_parent(struct dentry *dentry ) ;
#line 378
__inline static int d_unhashed(struct dentry  const  *dentry )  __attribute__((__no_instrument_function__)) ;
#line 378 "../../../analyzer/../bench/linux-headers/include/linux/dcache.h"
__inline static int d_unhashed(struct dentry  const  *dentry ) 
{ 
  int tmp___7 ;

  {
  {
#line 380
  tmp___7 = hlist_bl_unhashed(& dentry->d_hash);
  }
#line 380
  return (tmp___7);
}
}
#line 383
__inline static int d_unlinked(struct dentry  const  *dentry )  __attribute__((__no_instrument_function__)) ;
#line 383 "../../../analyzer/../bench/linux-headers/include/linux/dcache.h"
__inline static int d_unlinked(struct dentry  const  *dentry ) 
{ 
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 385
  tmp___7 = d_unhashed(dentry);
  }
#line 385
  if (tmp___7) {
#line 385
    if (! ((unsigned long )dentry == (unsigned long )dentry->d_parent)) {
      {
#line 385
      tmp___8 = 1;
      }
    } else {
      {
#line 385
      tmp___8 = 0;
      }
    }
  } else {
    {
#line 385
    tmp___8 = 0;
    }
  }
#line 385
  return (tmp___8);
}
}
#line 388
__inline static int cant_mount(struct dentry  const  *dentry )  __attribute__((__no_instrument_function__)) ;
#line 388 "../../../analyzer/../bench/linux-headers/include/linux/dcache.h"
__inline static int cant_mount(struct dentry  const  *dentry ) 
{ 


  {
#line 390
  return ((int )(dentry->d_flags & 256U));
}
}
#line 393
__inline static void dont_mount(struct dentry *dentry )  __attribute__((__no_instrument_function__)) ;
#line 393 "../../../analyzer/../bench/linux-headers/include/linux/dcache.h"
__inline static void dont_mount(struct dentry *dentry ) 
{ 


  {
  {
#line 395
  spin_lock(& dentry->d_lockref.__annonCompField45.__annonCompField44.lock);
#line 396
  dentry->d_flags |= 256U;
#line 397
  spin_unlock(& dentry->d_lockref.__annonCompField45.__annonCompField44.lock);
  }
#line 398
  return;
}
}
#line 400
extern void dput(struct dentry * ) ;
#line 402
__inline static bool d_managed(struct dentry  const  *dentry )  __attribute__((__no_instrument_function__)) ;
#line 402 "../../../analyzer/../bench/linux-headers/include/linux/dcache.h"
__inline static bool d_managed(struct dentry  const  *dentry ) 
{ 


  {
#line 404
  return ((bool )(dentry->d_flags & 458752U));
}
}
#line 407
__inline static bool d_mountpoint(struct dentry  const  *dentry )  __attribute__((__no_instrument_function__)) ;
#line 407 "../../../analyzer/../bench/linux-headers/include/linux/dcache.h"
__inline static bool d_mountpoint(struct dentry  const  *dentry ) 
{ 


  {
#line 409
  return ((bool )(dentry->d_flags & 65536U));
}
}
#line 415
__inline static void __d_set_type(struct dentry *dentry , unsigned int type )  __attribute__((__no_instrument_function__)) ;
#line 415 "../../../analyzer/../bench/linux-headers/include/linux/dcache.h"
__inline static void __d_set_type(struct dentry *dentry , unsigned int type ) 
{ 


  {
  {
#line 417
  dentry->d_flags = (dentry->d_flags & 4287627263U) | type;
  }
#line 418
  return;
}
}
#line 420
__inline static void __d_clear_type(struct dentry *dentry )  __attribute__((__no_instrument_function__)) ;
#line 420 "../../../analyzer/../bench/linux-headers/include/linux/dcache.h"
__inline static void __d_clear_type(struct dentry *dentry ) 
{ 


  {
  {
#line 422
  __d_set_type(dentry, 0U);
  }
#line 423
  return;
}
}
#line 425
__inline static void d_set_type(struct dentry *dentry , unsigned int type )  __attribute__((__no_instrument_function__)) ;
#line 425 "../../../analyzer/../bench/linux-headers/include/linux/dcache.h"
__inline static void d_set_type(struct dentry *dentry , unsigned int type ) 
{ 


  {
  {
#line 427
  spin_lock(& dentry->d_lockref.__annonCompField45.__annonCompField44.lock);
#line 428
  __d_set_type(dentry, type);
#line 429
  spin_unlock(& dentry->d_lockref.__annonCompField45.__annonCompField44.lock);
  }
#line 430
  return;
}
}
#line 432
__inline static unsigned int __d_entry_type(struct dentry  const  *dentry )  __attribute__((__no_instrument_function__)) ;
#line 432 "../../../analyzer/../bench/linux-headers/include/linux/dcache.h"
__inline static unsigned int __d_entry_type(struct dentry  const  *dentry ) 
{ 


  {
#line 434
  return ((unsigned int )(dentry->d_flags & 7340032U));
}
}
#line 437
__inline static bool d_can_lookup(struct dentry  const  *dentry )  __attribute__((__no_instrument_function__)) ;
#line 437 "../../../analyzer/../bench/linux-headers/include/linux/dcache.h"
__inline static bool d_can_lookup(struct dentry  const  *dentry ) 
{ 
  unsigned int tmp___7 ;

  {
  {
#line 439
  tmp___7 = __d_entry_type(dentry);
  }
#line 439
  return ((bool )(tmp___7 == 1048576U));
}
}
#line 442
__inline static bool d_is_autodir(struct dentry  const  *dentry )  __attribute__((__no_instrument_function__)) ;
#line 442 "../../../analyzer/../bench/linux-headers/include/linux/dcache.h"
__inline static bool d_is_autodir(struct dentry  const  *dentry ) 
{ 
  unsigned int tmp___7 ;

  {
  {
#line 444
  tmp___7 = __d_entry_type(dentry);
  }
#line 444
  return ((bool )(tmp___7 == 2097152U));
}
}
#line 447
__inline static bool d_is_dir(struct dentry  const  *dentry )  __attribute__((__no_instrument_function__)) ;
#line 447 "../../../analyzer/../bench/linux-headers/include/linux/dcache.h"
__inline static bool d_is_dir(struct dentry  const  *dentry ) 
{ 
  bool tmp___7 ;
  bool tmp___8 ;
  int tmp___9 ;

  {
  {
#line 449
  tmp___7 = d_can_lookup(dentry);
  }
#line 449
  if (tmp___7) {
    {
#line 449
    tmp___9 = 1;
    }
  } else {
    {
#line 449
    tmp___8 = d_is_autodir(dentry);
    }
#line 449
    if (tmp___8) {
      {
#line 449
      tmp___9 = 1;
      }
    } else {
      {
#line 449
      tmp___9 = 0;
      }
    }
  }
#line 449
  return ((bool )tmp___9);
}
}
#line 452
__inline static bool d_is_symlink(struct dentry  const  *dentry )  __attribute__((__no_instrument_function__)) ;
#line 452 "../../../analyzer/../bench/linux-headers/include/linux/dcache.h"
__inline static bool d_is_symlink(struct dentry  const  *dentry ) 
{ 
  unsigned int tmp___7 ;

  {
  {
#line 454
  tmp___7 = __d_entry_type(dentry);
  }
#line 454
  return ((bool )(tmp___7 == 3145728U));
}
}
#line 457
__inline static bool d_is_file(struct dentry  const  *dentry )  __attribute__((__no_instrument_function__)) ;
#line 457 "../../../analyzer/../bench/linux-headers/include/linux/dcache.h"
__inline static bool d_is_file(struct dentry  const  *dentry ) 
{ 
  unsigned int tmp___7 ;

  {
  {
#line 459
  tmp___7 = __d_entry_type(dentry);
  }
#line 459
  return ((bool )(tmp___7 == 4194304U));
}
}
#line 462
__inline static bool d_is_negative(struct dentry  const  *dentry )  __attribute__((__no_instrument_function__)) ;
#line 462 "../../../analyzer/../bench/linux-headers/include/linux/dcache.h"
__inline static bool d_is_negative(struct dentry  const  *dentry ) 
{ 
  unsigned int tmp___7 ;

  {
  {
#line 464
  tmp___7 = __d_entry_type(dentry);
  }
#line 464
  return ((bool )(tmp___7 == 0U));
}
}
#line 467
__inline static bool d_is_positive(struct dentry  const  *dentry )  __attribute__((__no_instrument_function__)) ;
#line 467 "../../../analyzer/../bench/linux-headers/include/linux/dcache.h"
__inline static bool d_is_positive(struct dentry  const  *dentry ) 
{ 
  bool tmp___7 ;
  int tmp___8 ;

  {
  {
#line 469
  tmp___7 = d_is_negative(dentry);
  }
#line 469
  if (tmp___7) {
    {
#line 469
    tmp___8 = 0;
    }
  } else {
    {
#line 469
    tmp___8 = 1;
    }
  }
#line 469
  return ((bool )tmp___8);
}
}
#line 472
extern int sysctl_vfs_cache_pressure ;
#line 474
__inline static unsigned long vfs_pressure_ratio(unsigned long val )  __attribute__((__no_instrument_function__)) ;
#line 474 "../../../analyzer/../bench/linux-headers/include/linux/dcache.h"
__inline static unsigned long vfs_pressure_ratio(unsigned long val ) 
{ 
  unsigned long quot ;
  unsigned long rem ;

  {
  {
#line 476
  quot = val / 100UL;
#line 476
  rem = val % 100UL;
  }
#line 476
  return (quot * (unsigned long )sysctl_vfs_cache_pressure + (rem * (unsigned long )sysctl_vfs_cache_pressure) / 100UL);
}
}
#line 12 "../../../analyzer/../bench/linux-headers/include/linux/path.h"
extern void path_get(struct path  const  * ) ;
#line 13
extern void path_put(struct path  const  * ) ;
#line 15
__inline static int path_equal(struct path  const  *path1 , struct path  const  *path2 )  __attribute__((__no_instrument_function__)) ;
#line 15 "../../../analyzer/../bench/linux-headers/include/linux/path.h"
__inline static int path_equal(struct path  const  *path1 , struct path  const  *path2 ) 
{ 
  int tmp___7 ;

  {
#line 17
  if ((unsigned long )path1->mnt == (unsigned long )path2->mnt) {
#line 17
    if ((unsigned long )path1->dentry == (unsigned long )path2->dentry) {
      {
#line 17
      tmp___7 = 1;
      }
    } else {
      {
#line 17
      tmp___7 = 0;
      }
    }
  } else {
    {
#line 17
    tmp___7 = 0;
    }
  }
#line 17
  return (tmp___7);
}
}
#line 36 "../../../analyzer/../bench/linux-headers/include/linux/list_lru.h"
extern void list_lru_destroy(struct list_lru *lru ) ;
#line 37
extern int list_lru_init_key(struct list_lru *lru , struct lock_class_key *key ) ;
#line 38
__inline static int list_lru_init(struct list_lru *lru )  __attribute__((__no_instrument_function__)) ;
#line 38 "../../../analyzer/../bench/linux-headers/include/linux/list_lru.h"
__inline static int list_lru_init(struct list_lru *lru ) 
{ 
  int tmp___7 ;

  {
  {
#line 40
  tmp___7 = list_lru_init_key(lru, (struct lock_class_key *)((void *)0));
  }
#line 40
  return (tmp___7);
}
}
#line 59
extern bool list_lru_add(struct list_lru *lru , struct list_head *item ) ;
#line 72
extern bool list_lru_del(struct list_lru *lru , struct list_head *item ) ;
#line 83
extern unsigned long list_lru_count_node(struct list_lru *lru , int nid ) ;
#line 84
__inline static unsigned long list_lru_count(struct list_lru *lru )  __attribute__((__no_instrument_function__)) ;
#line 84 "../../../analyzer/../bench/linux-headers/include/linux/list_lru.h"
__inline static unsigned long list_lru_count(struct list_lru *lru ) 
{ 
  long count ;
  int nid ;
  unsigned long tmp___7 ;

  {
  {
#line 86
  count = 0L;
#line 89
  nid = __first_node((nodemask_t const   *)(& lru->active_nodes));
  }
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! (nid < 1 << 6)) {
#line 89
      goto while_break;
    }
    {
#line 90
    tmp___7 = list_lru_count_node(lru, nid);
#line 90
    count = (long )((unsigned long )count + tmp___7);
#line 89
    nid = __next_node(nid, (nodemask_t const   *)(& lru->active_nodes));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  return ((unsigned long )count);
}
}
#line 118
extern unsigned long list_lru_walk_node(struct list_lru *lru , int nid , enum lru_status (*isolate)(struct list_head *item ,
                                                                                                    spinlock_t *lock ,
                                                                                                    void *cb_arg ) ,
                                        void *cb_arg , unsigned long *nr_to_walk ) ;
#line 122
__inline static unsigned long list_lru_walk(struct list_lru *lru , enum lru_status (*isolate)(struct list_head *item ,
                                                                                              spinlock_t *lock ,
                                                                                              void *cb_arg ) ,
                                            void *cb_arg , unsigned long nr_to_walk )  __attribute__((__no_instrument_function__)) ;
#line 122 "../../../analyzer/../bench/linux-headers/include/linux/list_lru.h"
__inline static unsigned long list_lru_walk(struct list_lru *lru , enum lru_status (*isolate)(struct list_head *item ,
                                                                                              spinlock_t *lock ,
                                                                                              void *cb_arg ) ,
                                            void *cb_arg , unsigned long nr_to_walk ) 
{ 
  long isolated ;
  int nid ;
  unsigned long tmp___7 ;

  {
  {
#line 126
  isolated = 0L;
#line 129
  nid = __first_node((nodemask_t const   *)(& lru->active_nodes));
  }
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (! (nid < 1 << 6)) {
#line 129
      goto while_break;
    }
    {
#line 130
    tmp___7 = list_lru_walk_node(lru, nid, isolate, cb_arg, & nr_to_walk);
#line 130
    isolated = (long )((unsigned long )isolated + tmp___7);
    }
#line 132
    if (nr_to_walk <= 0UL) {
#line 133
      goto while_break;
    }
    {
#line 129
    nid = __next_node(nid, (nodemask_t const   *)(& lru->active_nodes));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  return ((unsigned long )isolated);
}
}
#line 54 "../../../analyzer/../bench/linux-headers/include/linux/radix-tree.h"
__inline static int radix_tree_is_indirect_ptr(void *ptr )  __attribute__((__no_instrument_function__)) ;
#line 54 "../../../analyzer/../bench/linux-headers/include/linux/radix-tree.h"
__inline static int radix_tree_is_indirect_ptr(void *ptr ) 
{ 


  {
#line 56
  return ((int )((unsigned long )ptr & 1UL));
}
}
#line 194
__inline static void *radix_tree_deref_slot(void **pslot )  __attribute__((__no_instrument_function__)) ;
#line 194 "../../../analyzer/../bench/linux-headers/include/linux/radix-tree.h"
__inline static void *radix_tree_deref_slot(void **pslot ) 
{ 
  void *_________p1 ;

  {
  {
#line 196
  _________p1 = (void *)*((void * volatile  *)pslot);
  }
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 196
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 196
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 196
  return (_________p1);
}
}
#line 209
__inline static void *radix_tree_deref_slot_protected(void **pslot , spinlock_t *treelock )  __attribute__((__no_instrument_function__)) ;
#line 209 "../../../analyzer/../bench/linux-headers/include/linux/radix-tree.h"
__inline static void *radix_tree_deref_slot_protected(void **pslot , spinlock_t *treelock ) 
{ 


  {
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 212
  return (*pslot);
}
}
#line 222
__inline static int radix_tree_deref_retry(void *arg )  __attribute__((__no_instrument_function__)) ;
#line 222 "../../../analyzer/../bench/linux-headers/include/linux/radix-tree.h"
__inline static int radix_tree_deref_retry(void *arg ) 
{ 
  long tmp___7 ;

  {
  {
#line 224
  tmp___7 = __builtin_expect((long )(! (! ((unsigned long )arg & 1UL))), 0L);
  }
#line 224
  return ((int )tmp___7);
}
}
#line 232
__inline static int radix_tree_exceptional_entry(void *arg )  __attribute__((__no_instrument_function__)) ;
#line 232 "../../../analyzer/../bench/linux-headers/include/linux/radix-tree.h"
__inline static int radix_tree_exceptional_entry(void *arg ) 
{ 


  {
#line 235
  return ((int )((unsigned long )arg & 2UL));
}
}
#line 243
__inline static int radix_tree_exception(void *arg )  __attribute__((__no_instrument_function__)) ;
#line 243 "../../../analyzer/../bench/linux-headers/include/linux/radix-tree.h"
__inline static int radix_tree_exception(void *arg ) 
{ 
  long tmp___7 ;

  {
  {
#line 245
  tmp___7 = __builtin_expect((long )(! (! ((unsigned long )arg & 3UL))), 0L);
  }
#line 245
  return ((int )tmp___7);
}
}
#line 260
extern void __compiletime_assert_260(void)  __attribute__((__error__("Need native word sized stores/loads for atomicity."))) ;
#line 257
__inline static void radix_tree_replace_slot(void **pslot , void *item )  __attribute__((__no_instrument_function__)) ;
#line 257 "../../../analyzer/../bench/linux-headers/include/linux/radix-tree.h"
__inline static void radix_tree_replace_slot(void **pslot , void *item ) 
{ 
  int tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  bool __cond ;
  int tmp___10 ;

  {
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 259
    tmp___7 = radix_tree_is_indirect_ptr(item);
    }
#line 259
    if (tmp___7) {
      {
#line 259
      tmp___8 = 1;
      }
    } else {
      {
#line 259
      tmp___8 = 0;
      }
    }
    {
#line 259
    tmp___9 = __builtin_expect((long )tmp___8, 0L);
    }
#line 259
    if (tmp___9) {
      {
#line 259
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 259
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b - 2b, %c0 - 2b\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("../../../analyzer/../bench/linux-headers/include/linux/radix-tree.h"),
                             "i" (259), "i" (sizeof(struct bug_entry )));
#line 259
        __builtin_unreachable();
        }
#line 259
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 259
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 260
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 260
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 260
      if (sizeof(*pslot) == sizeof(int )) {
        {
#line 260
        tmp___10 = 0;
        }
      } else
#line 260
      if (sizeof(*pslot) == sizeof(long )) {
        {
#line 260
        tmp___10 = 0;
        }
      } else {
        {
#line 260
        tmp___10 = 1;
        }
      }
      {
#line 260
      __cond = (bool )tmp___10;
      }
#line 260
      if (__cond) {
        {
#line 260
        __compiletime_assert_260();
        }
      }
      {
#line 260
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 260
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 260
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 260
    __asm__  volatile   ("": : : "memory");
#line 260
    *((void * volatile  *)pslot) = (void * volatile  )item;
    }
#line 260
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 261
  return;
}
}
#line 263
extern int __radix_tree_create(struct radix_tree_root *root , unsigned long index ,
                               struct radix_tree_node **nodep , void ***slotp ) ;
#line 265
extern int radix_tree_insert(struct radix_tree_root * , unsigned long  , void * ) ;
#line 266
extern void *__radix_tree_lookup(struct radix_tree_root *root , unsigned long index ,
                                 struct radix_tree_node **nodep , void ***slotp ) ;
#line 268
extern void *radix_tree_lookup(struct radix_tree_root * , unsigned long  ) ;
#line 269
extern void **radix_tree_lookup_slot(struct radix_tree_root * , unsigned long  ) ;
#line 270
extern bool __radix_tree_delete_node(struct radix_tree_root *root , struct radix_tree_node *node ) ;
#line 272
extern void *radix_tree_delete_item(struct radix_tree_root * , unsigned long  , void * ) ;
#line 273
extern void *radix_tree_delete(struct radix_tree_root * , unsigned long  ) ;
#line 274
extern unsigned int radix_tree_gang_lookup(struct radix_tree_root *root , void **results ,
                                           unsigned long first_index , unsigned int max_items ) ;
#line 277
extern unsigned int radix_tree_gang_lookup_slot(struct radix_tree_root *root , void ***results ,
                                                unsigned long *indices , unsigned long first_index ,
                                                unsigned int max_items ) ;
#line 280
extern int radix_tree_preload(gfp_t gfp_mask ) ;
#line 281
extern int radix_tree_maybe_preload(gfp_t gfp_mask ) ;
#line 282
extern void radix_tree_init(void) ;
#line 283
extern void *radix_tree_tag_set(struct radix_tree_root *root , unsigned long index ,
                                unsigned int tag ) ;
#line 285
extern void *radix_tree_tag_clear(struct radix_tree_root *root , unsigned long index ,
                                  unsigned int tag ) ;
#line 287
extern int radix_tree_tag_get(struct radix_tree_root *root , unsigned long index ,
                              unsigned int tag ) ;
#line 289
extern unsigned int radix_tree_gang_lookup_tag(struct radix_tree_root *root , void **results ,
                                               unsigned long first_index , unsigned int max_items ,
                                               unsigned int tag ) ;
#line 293
extern unsigned int radix_tree_gang_lookup_tag_slot(struct radix_tree_root *root ,
                                                    void ***results , unsigned long first_index ,
                                                    unsigned int max_items , unsigned int tag ) ;
#line 297
extern unsigned long radix_tree_range_tag_if_tagged(struct radix_tree_root *root ,
                                                    unsigned long *first_indexp ,
                                                    unsigned long last_index , unsigned long nr_to_tag ,
                                                    unsigned int fromtag , unsigned int totag ) ;
#line 301
extern int radix_tree_tagged(struct radix_tree_root *root , unsigned int tag ) ;
#line 302
extern unsigned long radix_tree_locate_item(struct radix_tree_root *root , void *item ) ;
#line 304
__inline static void radix_tree_preload_end(void)  __attribute__((__no_instrument_function__)) ;
#line 304 "../../../analyzer/../bench/linux-headers/include/linux/radix-tree.h"
__inline static void radix_tree_preload_end(void) 
{ 


  {
  {
#line 306
  __asm__  volatile   ("": : : "memory");
  }
#line 307
  return;
}
}
#line 340
__inline static void **( __attribute__((__always_inline__)) radix_tree_iter_init)(struct radix_tree_iter *iter ,
                                                                                  unsigned long start )  __attribute__((__no_instrument_function__)) ;
#line 340 "../../../analyzer/../bench/linux-headers/include/linux/radix-tree.h"
__inline static void **( __attribute__((__always_inline__)) radix_tree_iter_init)(struct radix_tree_iter *iter ,
                                                                                  unsigned long start ) 
{ 


  {
  {
#line 351
  iter->index = 0UL;
#line 352
  iter->next_index = start;
  }
#line 353
  return ((void **)((void *)0));
}
}
#line 369
extern void **radix_tree_next_chunk(struct radix_tree_root *root , struct radix_tree_iter *iter ,
                                    unsigned int flags ) ;
#line 378
__inline static unsigned int ( __attribute__((__always_inline__)) radix_tree_chunk_size)(struct radix_tree_iter *iter )  __attribute__((__no_instrument_function__)) ;
#line 378 "../../../analyzer/../bench/linux-headers/include/linux/radix-tree.h"
__inline static unsigned int ( __attribute__((__always_inline__)) radix_tree_chunk_size)(struct radix_tree_iter *iter ) 
{ 


  {
#line 381
  return ((unsigned int )(iter->next_index - iter->index));
}
}
#line 395
__inline static void **( __attribute__((__always_inline__)) radix_tree_next_slot)(void **slot ,
                                                                                  struct radix_tree_iter *iter ,
                                                                                  unsigned int flags )  __attribute__((__no_instrument_function__)) ;
#line 395 "../../../analyzer/../bench/linux-headers/include/linux/radix-tree.h"
__inline static void **( __attribute__((__always_inline__)) radix_tree_next_slot)(void **slot ,
                                                                                  struct radix_tree_iter *iter ,
                                                                                  unsigned int flags ) 
{ 
  long tmp___7 ;
  unsigned int offset ;
  unsigned long tmp___8 ;
  long tmp___9 ;
  unsigned int size ;
  unsigned int tmp___10 ;
  long tmp___11 ;
  unsigned int tmp___12 ;

  {
#line 398
  if (flags & 256U) {
    {
#line 399
    iter->tags >>= 1;
#line 400
    tmp___7 = __builtin_expect((long )(! (! (iter->tags & 1UL))), 1L);
    }
#line 400
    if (tmp___7) {
      {
#line 401
      (iter->index) ++;
      }
#line 402
      return (slot + 1);
    }
#line 404
    if (! (flags & 512U)) {
      {
#line 404
      tmp___9 = __builtin_expect((long )(! (! iter->tags)), 1L);
      }
#line 404
      if (tmp___9) {
        {
#line 405
        tmp___8 = __ffs(iter->tags);
#line 405
        offset = (unsigned int )tmp___8;
#line 407
        iter->tags >>= offset;
#line 408
        iter->index += (unsigned long )(offset + 1U);
        }
#line 409
        return ((slot + offset) + 1);
      }
    }
  } else {
    {
#line 412
    tmp___10 = radix_tree_chunk_size(iter);
#line 412
    size = tmp___10 - 1U;
    }
    {
#line 414
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 414
      tmp___12 = size;
#line 414
      size --;
      }
#line 414
      if (! tmp___12) {
#line 414
        goto while_break;
      }
      {
#line 415
      slot ++;
#line 416
      (iter->index) ++;
#line 417
      tmp___11 = __builtin_expect((long )(! (! *slot)), 1L);
      }
#line 417
      if (tmp___11) {
#line 418
        return (slot);
      }
#line 419
      if (flags & 512U) {
        {
#line 421
        iter->next_index = 0UL;
        }
#line 422
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 426
  return ((void **)((void *)0));
}
}
#line 34 "../../../analyzer/../bench/linux-headers/include/linux/semaphore.h"
static struct lock_class_key __key___3  ;
#line 32
__inline static void sema_init(struct semaphore *sem , int val )  __attribute__((__no_instrument_function__)) ;
#line 32 "../../../analyzer/../bench/linux-headers/include/linux/semaphore.h"
__inline static void sema_init(struct semaphore *sem , int val ) 
{ 
  struct semaphore __constr_expr_21 ;

  {
  {
#line 35
  __constr_expr_21.lock.raw_lock.__annonCompField17.head_tail = (__ticketpair_t )0;
#line 35
  __constr_expr_21.lock.magic = 3735899821U;
#line 35
  __constr_expr_21.lock.owner_cpu = 4294967295U;
#line 35
  __constr_expr_21.lock.owner = (void *)-1L;
#line 35
  __constr_expr_21.count = (unsigned int )val;
#line 35
  __constr_expr_21.wait_list.next = & sem->wait_list;
#line 35
  __constr_expr_21.wait_list.prev = & sem->wait_list;
#line 35
  *sem = __constr_expr_21;
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 37
  return;
}
}
#line 39
extern void down(struct semaphore *sem ) ;
#line 40
extern int ( __attribute__((__warn_unused_result__)) down_interruptible)(struct semaphore *sem ) ;
#line 41
extern int ( __attribute__((__warn_unused_result__)) down_killable)(struct semaphore *sem ) ;
#line 42
extern int ( __attribute__((__warn_unused_result__)) down_trylock)(struct semaphore *sem ) ;
#line 43
extern int ( __attribute__((__warn_unused_result__)) down_timeout)(struct semaphore *sem ,
                                                                   long jiffies ) ;
#line 44
extern void up(struct semaphore *sem ) ;
#line 18 "../../../analyzer/../bench/linux-headers/include/linux/percpu-rwsem.h"
extern void percpu_down_read(struct percpu_rw_semaphore * ) ;
#line 19
extern void percpu_up_read(struct percpu_rw_semaphore * ) ;
#line 21
extern void percpu_down_write(struct percpu_rw_semaphore * ) ;
#line 22
extern void percpu_up_write(struct percpu_rw_semaphore * ) ;
#line 24
extern int __percpu_init_rwsem(struct percpu_rw_semaphore * , char const   * , struct lock_class_key * ) ;
#line 26
extern void percpu_free_rwsem(struct percpu_rw_semaphore * ) ;
#line 53 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
extern void __attribute__((__cold__))  inode_init(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 54
extern void __attribute__((__cold__))  inode_init_early(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 55
extern void __attribute__((__cold__))  files_init(unsigned long  )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 57
extern struct files_stat_struct files_stat ;
#line 58
extern unsigned long get_max_files(void) ;
#line 59
extern int sysctl_nr_open ;
#line 60
extern struct inodes_stat_t inodes_stat ;
#line 61
extern int leases_enable ;
#line 61
extern int lease_break_time ;
#line 62
extern int sysctl_protected_symlinks ;
#line 63
extern int sysctl_protected_hardlinks ;
#line 40 "../../../analyzer/../bench/linux-headers/include/linux/dqblk_qtree.h"
extern int qtree_write_dquot(struct qtree_mem_dqinfo *info , struct dquot *dquot ) ;
#line 41
extern int qtree_read_dquot(struct qtree_mem_dqinfo *info , struct dquot *dquot ) ;
#line 42
extern int qtree_delete_dquot(struct qtree_mem_dqinfo *info , struct dquot *dquot ) ;
#line 43
extern int qtree_release_dquot(struct qtree_mem_dqinfo *info , struct dquot *dquot ) ;
#line 44
extern int qtree_entry_unused(struct qtree_mem_dqinfo *info , char *disk ) ;
#line 45
__inline static int qtree_depth(struct qtree_mem_dqinfo *info )  __attribute__((__no_instrument_function__)) ;
#line 45 "../../../analyzer/../bench/linux-headers/include/linux/dqblk_qtree.h"
__inline static int qtree_depth(struct qtree_mem_dqinfo *info ) 
{ 
  unsigned int epb ;
  unsigned long long entries ;
  int i ;

  {
  {
#line 47
  epb = info->dqi_usable_bs >> 2;
#line 48
  entries = (unsigned long long )epb;
#line 51
  i = 1;
  }
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (! (entries < 1ULL << 32)) {
#line 51
      goto while_break;
    }
    {
#line 52
    entries *= (unsigned long long )epb;
#line 51
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  return (i);
}
}
#line 25 "../../../analyzer/../bench/linux-headers/include/linux/projid.h"
__inline static projid_t __kprojid_val(kprojid_t projid )  __attribute__((__no_instrument_function__)) ;
#line 25 "../../../analyzer/../bench/linux-headers/include/linux/projid.h"
__inline static projid_t __kprojid_val(kprojid_t projid ) 
{ 


  {
#line 27
  return (projid.val);
}
}
#line 35
__inline static bool projid_eq(kprojid_t left , kprojid_t right )  __attribute__((__no_instrument_function__)) ;
#line 35 "../../../analyzer/../bench/linux-headers/include/linux/projid.h"
__inline static bool projid_eq(kprojid_t left , kprojid_t right ) 
{ 
  projid_t tmp___7 ;
  projid_t tmp___8 ;

  {
  {
#line 37
  tmp___7 = __kprojid_val(left);
#line 37
  tmp___8 = __kprojid_val(right);
  }
#line 37
  return ((bool )(tmp___7 == tmp___8));
}
}
#line 40
__inline static bool projid_lt(kprojid_t left , kprojid_t right )  __attribute__((__no_instrument_function__)) ;
#line 40 "../../../analyzer/../bench/linux-headers/include/linux/projid.h"
__inline static bool projid_lt(kprojid_t left , kprojid_t right ) 
{ 
  projid_t tmp___7 ;
  projid_t tmp___8 ;

  {
  {
#line 42
  tmp___7 = __kprojid_val(left);
#line 42
  tmp___8 = __kprojid_val(right);
  }
#line 42
  return ((bool )(tmp___7 < tmp___8));
}
}
#line 45
__inline static bool projid_valid(kprojid_t projid )  __attribute__((__no_instrument_function__)) ;
#line 45 "../../../analyzer/../bench/linux-headers/include/linux/projid.h"
__inline static bool projid_valid(kprojid_t projid ) 
{ 
  kprojid_t __constr_expr_22 ;
  bool tmp___7 ;
  int tmp___8 ;

  {
  {
#line 47
  __constr_expr_22.val = (projid_t )-1;
#line 47
  tmp___7 = projid_eq(projid, __constr_expr_22);
  }
#line 47
  if (tmp___7) {
    {
#line 47
    tmp___8 = 0;
    }
  } else {
    {
#line 47
    tmp___8 = 1;
    }
  }
#line 47
  return ((bool )tmp___8);
}
}
#line 64
__inline static kprojid_t make_kprojid(struct user_namespace *from , projid_t projid )  __attribute__((__no_instrument_function__)) ;
#line 64 "../../../analyzer/../bench/linux-headers/include/linux/projid.h"
__inline static kprojid_t make_kprojid(struct user_namespace *from , projid_t projid ) 
{ 
  kprojid_t __constr_expr_23 ;

  {
  {
#line 66
  __constr_expr_23.val = projid;
  }
#line 66
  return (__constr_expr_23);
}
}
#line 69
__inline static projid_t from_kprojid(struct user_namespace *to , kprojid_t kprojid )  __attribute__((__no_instrument_function__)) ;
#line 69 "../../../analyzer/../bench/linux-headers/include/linux/projid.h"
__inline static projid_t from_kprojid(struct user_namespace *to , kprojid_t kprojid ) 
{ 
  projid_t tmp___7 ;

  {
  {
#line 71
  tmp___7 = __kprojid_val(kprojid);
  }
#line 71
  return (tmp___7);
}
}
#line 74
__inline static projid_t from_kprojid_munged(struct user_namespace *to , kprojid_t kprojid )  __attribute__((__no_instrument_function__)) ;
#line 74 "../../../analyzer/../bench/linux-headers/include/linux/projid.h"
__inline static projid_t from_kprojid_munged(struct user_namespace *to , kprojid_t kprojid ) 
{ 
  projid_t projid ;
  projid_t tmp___7 ;

  {
  {
#line 76
  tmp___7 = from_kprojid(to, kprojid);
#line 76
  projid = tmp___7;
  }
#line 77
  if (projid == 4294967295U) {
    {
#line 78
    projid = (projid_t )65534;
    }
  }
#line 79
  return (projid);
}
}
#line 82
__inline static bool kprojid_has_mapping(struct user_namespace *ns , kprojid_t projid )  __attribute__((__no_instrument_function__)) ;
#line 82 "../../../analyzer/../bench/linux-headers/include/linux/projid.h"
__inline static bool kprojid_has_mapping(struct user_namespace *ns , kprojid_t projid ) 
{ 


  {
#line 84
  return ((bool )1);
}
}
#line 71 "../../../analyzer/../bench/linux-headers/include/linux/quota.h"
extern bool qid_eq(struct kqid left , struct kqid right ) ;
#line 72
extern bool qid_lt(struct kqid left , struct kqid right ) ;
#line 73
extern qid_t from_kqid(struct user_namespace *to , struct kqid qid ) ;
#line 74
extern qid_t from_kqid_munged(struct user_namespace *to , struct kqid qid ) ;
#line 75
extern bool qid_valid(struct kqid qid ) ;
#line 91
__inline static struct kqid make_kqid(struct user_namespace *from , enum quota_type type ,
                                      qid_t qid )  __attribute__((__no_instrument_function__)) ;
#line 91 "../../../analyzer/../bench/linux-headers/include/linux/quota.h"
__inline static struct kqid make_kqid(struct user_namespace *from , enum quota_type type ,
                                      qid_t qid ) 
{ 
  struct kqid kqid ;

  {
  {
#line 96
  kqid.type = type;
  }
  {
#line 98
  if ((unsigned int )type == 0U) {
#line 98
    goto case_0;
  }
#line 101
  if ((unsigned int )type == 1U) {
#line 101
    goto case_1;
  }
#line 104
  if ((unsigned int )type == 2U) {
#line 104
    goto case_2;
  }
#line 107
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 99
  kqid.__annonCompField50.uid = make_kuid(from, qid);
  }
#line 100
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 102
  kqid.__annonCompField50.gid = make_kgid(from, qid);
  }
#line 103
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 105
  kqid.__annonCompField50.projid = make_kprojid(from, qid);
  }
#line 106
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 108
    __asm__  volatile   ("1:\tud2\n"
                         ".pushsection __bug_table,\"a\"\n"
                         "2:\t.long 1b - 2b, %c0 - 2b\n"
                         "\t.word %c1, 0\n"
                         "\t.org 2b+%c2\n"
                         ".popsection": : "i" ("../../../analyzer/../bench/linux-headers/include/linux/quota.h"),
                         "i" (108), "i" (sizeof(struct bug_entry )));
#line 108
    __builtin_unreachable();
    }
#line 108
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
#line 110
  return (kqid);
}
}
#line 119
__inline static struct kqid make_kqid_invalid(enum quota_type type )  __attribute__((__no_instrument_function__)) ;
#line 119 "../../../analyzer/../bench/linux-headers/include/linux/quota.h"
__inline static struct kqid make_kqid_invalid(enum quota_type type ) 
{ 
  struct kqid kqid ;
  kuid_t __constr_expr_24 ;
  kgid_t __constr_expr_25 ;
  kprojid_t __constr_expr_26 ;

  {
  {
#line 123
  kqid.type = type;
  }
  {
#line 125
  if ((unsigned int )type == 0U) {
#line 125
    goto case_0;
  }
#line 128
  if ((unsigned int )type == 1U) {
#line 128
    goto case_1;
  }
#line 131
  if ((unsigned int )type == 2U) {
#line 131
    goto case_2;
  }
#line 134
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 126
  __constr_expr_24.val = (uid_t )-1;
#line 126
  kqid.__annonCompField50.uid = __constr_expr_24;
  }
#line 127
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 129
  __constr_expr_25.val = (gid_t )-1;
#line 129
  kqid.__annonCompField50.gid = __constr_expr_25;
  }
#line 130
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 132
  __constr_expr_26.val = (projid_t )-1;
#line 132
  kqid.__annonCompField50.projid = __constr_expr_26;
  }
#line 133
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 135
    __asm__  volatile   ("1:\tud2\n"
                         ".pushsection __bug_table,\"a\"\n"
                         "2:\t.long 1b - 2b, %c0 - 2b\n"
                         "\t.word %c1, 0\n"
                         "\t.org 2b+%c2\n"
                         ".popsection": : "i" ("../../../analyzer/../bench/linux-headers/include/linux/quota.h"),
                         "i" (135), "i" (sizeof(struct bug_entry )));
#line 135
    __builtin_unreachable();
    }
#line 135
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
#line 137
  return (kqid);
}
}
#line 144
__inline static struct kqid make_kqid_uid(kuid_t uid )  __attribute__((__no_instrument_function__)) ;
#line 144 "../../../analyzer/../bench/linux-headers/include/linux/quota.h"
__inline static struct kqid make_kqid_uid(kuid_t uid ) 
{ 
  struct kqid kqid ;

  {
  {
#line 147
  kqid.type = (enum quota_type )0;
#line 148
  kqid.__annonCompField50.uid = uid;
  }
#line 149
  return (kqid);
}
}
#line 156
__inline static struct kqid make_kqid_gid(kgid_t gid )  __attribute__((__no_instrument_function__)) ;
#line 156 "../../../analyzer/../bench/linux-headers/include/linux/quota.h"
__inline static struct kqid make_kqid_gid(kgid_t gid ) 
{ 
  struct kqid kqid ;

  {
  {
#line 159
  kqid.type = (enum quota_type )1;
#line 160
  kqid.__annonCompField50.gid = gid;
  }
#line 161
  return (kqid);
}
}
#line 168
__inline static struct kqid make_kqid_projid(kprojid_t projid )  __attribute__((__no_instrument_function__)) ;
#line 168 "../../../analyzer/../bench/linux-headers/include/linux/quota.h"
__inline static struct kqid make_kqid_projid(kprojid_t projid ) 
{ 
  struct kqid kqid ;

  {
  {
#line 171
  kqid.type = (enum quota_type )2;
#line 172
  kqid.__annonCompField50.projid = projid;
  }
#line 173
  return (kqid);
}
}
#line 177
extern spinlock_t dq_data_lock ;
#line 229
extern void mark_info_dirty(struct super_block *sb , int type ) ;
#line 230
__inline static int info_dirty(struct mem_dqinfo *info )  __attribute__((__no_instrument_function__)) ;
#line 230 "../../../analyzer/../bench/linux-headers/include/linux/quota.h"
__inline static int info_dirty(struct mem_dqinfo *info ) 
{ 
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 232
  tmp___7 = constant_test_bit(31L, (unsigned long const volatile   *)(& info->dqi_flags));
  }
#line 232
  return (tmp___7);
}
}
#line 252
extern struct dqstats *dqstats_pcpu ;
#line 253
extern struct dqstats dqstats ;
#line 255
__inline static void dqstats_inc(unsigned int type )  __attribute__((__no_instrument_function__)) ;
#line 255 "../../../analyzer/../bench/linux-headers/include/linux/quota.h"
__inline static void dqstats_inc(unsigned int type ) 
{ 


  {
  {
#line 257
  percpu_counter_inc(& dqstats.counter[type]);
  }
#line 258
  return;
}
}
#line 260
__inline static void dqstats_dec(unsigned int type )  __attribute__((__no_instrument_function__)) ;
#line 260 "../../../analyzer/../bench/linux-headers/include/linux/quota.h"
__inline static void dqstats_dec(unsigned int type ) 
{ 


  {
  {
#line 262
  percpu_counter_dec(& dqstats.counter[type]);
  }
#line 263
  return;
}
}
#line 368
__inline static unsigned int dquot_state_flag(unsigned int flags , int type )  __attribute__((__no_instrument_function__)) ;
#line 368 "../../../analyzer/../bench/linux-headers/include/linux/quota.h"
__inline static unsigned int dquot_state_flag(unsigned int flags , int type ) 
{ 


  {
#line 370
  return (flags << 3 * type);
}
}
#line 373
__inline static unsigned int dquot_generic_flag(unsigned int flags , int type )  __attribute__((__no_instrument_function__)) ;
#line 373 "../../../analyzer/../bench/linux-headers/include/linux/quota.h"
__inline static unsigned int dquot_generic_flag(unsigned int flags , int type ) 
{ 


  {
#line 375
  return ((flags >> 3 * type) & (unsigned int )((1 | (1 << 1)) | (1 << 2)));
}
}
#line 379
extern void quota_send_warning(struct kqid qid , dev_t dev , char const   warntype ) ;
#line 398
extern int register_quota_format(struct quota_format_type *fmt ) ;
#line 399
extern void unregister_quota_format(struct quota_format_type *fmt ) ;
#line 371 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
extern struct address_space_operations  const  empty_aops ;
#line 377
extern int pagecache_write_begin(struct file * , struct address_space *mapping , loff_t pos ,
                                 unsigned int len , unsigned int flags , struct page **pagep ,
                                 void **fsdata ) ;
#line 381
extern int pagecache_write_end(struct file * , struct address_space *mapping , loff_t pos ,
                               unsigned int len , unsigned int copied , struct page *page ,
                               void *fsdata ) ;
#line 457
extern int mapping_tagged(struct address_space *mapping , int tag ) ;
#line 462
__inline static int mapping_mapped(struct address_space *mapping )  __attribute__((__no_instrument_function__)) ;
#line 462 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static int mapping_mapped(struct address_space *mapping ) 
{ 
  int tmp___7 ;
  int tmp___8 ;

  {
#line 464
  if (! ((unsigned long )mapping->i_mmap.rb_node == (unsigned long )((void *)0))) {
    {
#line 464
    tmp___8 = 1;
    }
  } else {
    {
#line 464
    tmp___7 = list_empty((struct list_head  const  *)(& mapping->i_mmap_nonlinear));
    }
#line 464
    if (tmp___7) {
      {
#line 464
      tmp___8 = 0;
      }
    } else {
      {
#line 464
      tmp___8 = 1;
      }
    }
  }
#line 464
  return (tmp___8);
}
}
#line 477
__inline static int mapping_writably_mapped(struct address_space *mapping )  __attribute__((__no_instrument_function__)) ;
#line 477 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static int mapping_writably_mapped(struct address_space *mapping ) 
{ 
  int tmp___7 ;

  {
  {
#line 479
  tmp___7 = atomic_read((atomic_t const   *)(& mapping->i_mmap_writable));
  }
#line 479
  return (tmp___7 > 0);
}
}
#line 482
__inline static int mapping_map_writable(struct address_space *mapping )  __attribute__((__no_instrument_function__)) ;
#line 482 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static int mapping_map_writable(struct address_space *mapping ) 
{ 
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 484
  tmp___9 = atomic_inc_unless_negative(& mapping->i_mmap_writable);
  }
#line 484
  if (tmp___9) {
    {
#line 484
    tmp___8 = 0;
    }
  } else {
    {
#line 484
    tmp___8 = -1;
    }
  }
#line 484
  return (tmp___8);
}
}
#line 488
__inline static void mapping_unmap_writable(struct address_space *mapping )  __attribute__((__no_instrument_function__)) ;
#line 488 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static void mapping_unmap_writable(struct address_space *mapping ) 
{ 


  {
  {
#line 490
  atomic_dec(& mapping->i_mmap_writable);
  }
#line 491
  return;
}
}
#line 493
__inline static int mapping_deny_writable(struct address_space *mapping )  __attribute__((__no_instrument_function__)) ;
#line 493 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static int mapping_deny_writable(struct address_space *mapping ) 
{ 
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 495
  tmp___9 = atomic_dec_unless_positive(& mapping->i_mmap_writable);
  }
#line 495
  if (tmp___9) {
    {
#line 495
    tmp___8 = 0;
    }
  } else {
    {
#line 495
    tmp___8 = -16;
    }
  }
#line 495
  return (tmp___8);
}
}
#line 499
__inline static void mapping_allow_writable(struct address_space *mapping )  __attribute__((__no_instrument_function__)) ;
#line 499 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static void mapping_allow_writable(struct address_space *mapping ) 
{ 


  {
  {
#line 501
  atomic_inc(& mapping->i_mmap_writable);
  }
#line 502
  return;
}
}
#line 618
__inline static int inode_unhashed(struct inode *inode )  __attribute__((__no_instrument_function__)) ;
#line 618 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static int inode_unhashed(struct inode *inode ) 
{ 
  int tmp___7 ;

  {
  {
#line 620
  tmp___7 = hlist_unhashed((struct hlist_node  const  *)(& inode->i_hash));
  }
#line 620
  return (tmp___7);
}
}
#line 646
extern void lock_two_nondirectories(struct inode * , struct inode * ) ;
#line 647
extern void unlock_two_nondirectories(struct inode * , struct inode * ) ;
#line 659
__inline static loff_t i_size_read(struct inode  const  *inode )  __attribute__((__no_instrument_function__)) ;
#line 659 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static loff_t i_size_read(struct inode  const  *inode ) 
{ 


  {
#line 678
  return ((loff_t )inode->i_size);
}
}
#line 687
__inline static void i_size_write(struct inode *inode , loff_t i_size )  __attribute__((__no_instrument_function__)) ;
#line 687 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static void i_size_write(struct inode *inode , loff_t i_size ) 
{ 


  {
  {
#line 700
  inode->i_size = i_size;
  }
#line 702
  return;
}
}
#line 709
__inline static uid_t i_uid_read(struct inode  const  *inode )  __attribute__((__no_instrument_function__)) ;
#line 709 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static uid_t i_uid_read(struct inode  const  *inode ) 
{ 
  uid_t tmp___7 ;

  {
  {
#line 711
  tmp___7 = from_kuid(& init_user_ns, (kuid_t )inode->i_uid);
  }
#line 711
  return (tmp___7);
}
}
#line 714
__inline static gid_t i_gid_read(struct inode  const  *inode )  __attribute__((__no_instrument_function__)) ;
#line 714 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static gid_t i_gid_read(struct inode  const  *inode ) 
{ 
  gid_t tmp___7 ;

  {
  {
#line 716
  tmp___7 = from_kgid(& init_user_ns, (kgid_t )inode->i_gid);
  }
#line 716
  return (tmp___7);
}
}
#line 719
__inline static void i_uid_write(struct inode *inode , uid_t uid )  __attribute__((__no_instrument_function__)) ;
#line 719 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static void i_uid_write(struct inode *inode , uid_t uid ) 
{ 


  {
  {
#line 721
  inode->i_uid = make_kuid(& init_user_ns, uid);
  }
#line 722
  return;
}
}
#line 724
__inline static void i_gid_write(struct inode *inode , gid_t gid )  __attribute__((__no_instrument_function__)) ;
#line 724 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static void i_gid_write(struct inode *inode , gid_t gid ) 
{ 


  {
  {
#line 726
  inode->i_gid = make_kgid(& init_user_ns, gid);
  }
#line 727
  return;
}
}
#line 729
__inline static unsigned int iminor(struct inode  const  *inode )  __attribute__((__no_instrument_function__)) ;
#line 729 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static unsigned int iminor(struct inode  const  *inode ) 
{ 


  {
#line 731
  return ((unsigned int )(inode->i_rdev & (unsigned int const   )((1U << 20) - 1U)));
}
}
#line 734
__inline static unsigned int imajor(struct inode  const  *inode )  __attribute__((__no_instrument_function__)) ;
#line 734 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static unsigned int imajor(struct inode  const  *inode ) 
{ 


  {
#line 736
  return ((unsigned int )(inode->i_rdev >> 20));
}
}
#line 739
extern struct block_device *I_BDEV(struct inode *inode ) ;
#line 766
__inline static int ra_has_index(struct file_ra_state *ra , unsigned long index )  __attribute__((__no_instrument_function__)) ;
#line 766 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static int ra_has_index(struct file_ra_state *ra , unsigned long index ) 
{ 
  int tmp___7 ;

  {
#line 768
  if (index >= ra->start) {
#line 768
    if (index < ra->start + (unsigned long )ra->size) {
      {
#line 768
      tmp___7 = 1;
      }
    } else {
      {
#line 768
      tmp___7 = 0;
      }
    }
  } else {
    {
#line 768
    tmp___7 = 0;
    }
  }
#line 768
  return (tmp___7);
}
}
#line 818
__inline static struct file *get_file(struct file *f )  __attribute__((__no_instrument_function__)) ;
#line 818 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static struct file *get_file(struct file *f ) 
{ 


  {
  {
#line 820
  atomic_long_inc(& f->f_count);
  }
#line 821
  return (f);
}
}
#line 882
extern void locks_start_grace(struct net * , struct lock_manager * ) ;
#line 883
extern void locks_end_grace(struct lock_manager * ) ;
#line 884
extern int locks_in_grace(struct net * ) ;
#line 948
extern void send_sigio(struct fown_struct *fown , int fd , int band ) ;
#line 951
extern int fcntl_getlk(struct file * , unsigned int  , struct flock * ) ;
#line 952
extern int fcntl_setlk(unsigned int  , struct file * , unsigned int  , struct flock * ) ;
#line 961
extern int fcntl_setlease(unsigned int fd , struct file *filp , long arg ) ;
#line 962
extern int fcntl_getlease(struct file *filp ) ;
#line 965
extern void locks_free_lock(struct file_lock *fl ) ;
#line 966
extern void locks_init_lock(struct file_lock * ) ;
#line 967
extern struct file_lock *locks_alloc_lock(void) ;
#line 968
extern void locks_copy_lock(struct file_lock * , struct file_lock * ) ;
#line 969
extern void __locks_copy_lock(struct file_lock * , struct file_lock  const  * ) ;
#line 970
extern void locks_remove_posix(struct file * , fl_owner_t  ) ;
#line 971
extern void locks_remove_file(struct file * ) ;
#line 972
extern void locks_release_private(struct file_lock * ) ;
#line 973
extern void posix_test_lock(struct file * , struct file_lock * ) ;
#line 974
extern int posix_lock_file(struct file * , struct file_lock * , struct file_lock * ) ;
#line 975
extern int posix_lock_file_wait(struct file * , struct file_lock * ) ;
#line 976
extern int posix_unblock_lock(struct file_lock * ) ;
#line 977
extern int vfs_test_lock(struct file * , struct file_lock * ) ;
#line 978
extern int vfs_lock_file(struct file * , unsigned int  , struct file_lock * , struct file_lock * ) ;
#line 979
extern int vfs_cancel_lock(struct file *filp , struct file_lock *fl ) ;
#line 980
extern int flock_lock_file_wait(struct file *filp , struct file_lock *fl ) ;
#line 981
extern int __break_lease(struct inode *inode , unsigned int flags , unsigned int type ) ;
#line 982
extern void lease_get_mtime(struct inode * , struct timespec *time ) ;
#line 983
extern int generic_setlease(struct file * , long  , struct file_lock ** ) ;
#line 984
extern int vfs_setlease(struct file * , long  , struct file_lock ** ) ;
#line 985
extern int lease_modify(struct file_lock ** , int  ) ;
#line 986
extern int lock_may_read(struct inode * , loff_t start , unsigned long count ) ;
#line 987
extern int lock_may_write(struct inode * , loff_t start , unsigned long count ) ;
#line 1145
extern int fasync_helper(int  , struct file * , int  , struct fasync_struct ** ) ;
#line 1146
extern struct fasync_struct *fasync_insert_entry(int  , struct file * , struct fasync_struct ** ,
                                                 struct fasync_struct * ) ;
#line 1147
extern int fasync_remove_entry(struct file * , struct fasync_struct ** ) ;
#line 1148
extern struct fasync_struct *fasync_alloc(void) ;
#line 1149
extern void fasync_free(struct fasync_struct * ) ;
#line 1152
extern void kill_fasync(struct fasync_struct ** , int  , int  ) ;
#line 1154
extern int __f_setown(struct file *filp , struct pid * , enum pid_type  , int force ) ;
#line 1155
extern int f_setown(struct file *filp , unsigned long arg , int force ) ;
#line 1156
extern void f_delown(struct file *filp ) ;
#line 1157
extern pid_t f_getown(struct file *filp ) ;
#line 1158
extern int send_sigurg(struct fown_struct *fown ) ;
#line 1172
extern struct list_head super_blocks ;
#line 1173
extern spinlock_t sb_lock ;
#line 1289
extern struct timespec current_fs_time(struct super_block *sb ) ;
#line 1295
extern void __sb_end_write(struct super_block *sb , int level ) ;
#line 1296
extern int __sb_start_write(struct super_block *sb , int level , bool wait ) ;
#line 1305
__inline static void sb_end_write(struct super_block *sb )  __attribute__((__no_instrument_function__)) ;
#line 1305 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static void sb_end_write(struct super_block *sb ) 
{ 


  {
  {
#line 1307
  __sb_end_write(sb, 1);
  }
#line 1308
  return;
}
}
#line 1317
__inline static void sb_end_pagefault(struct super_block *sb )  __attribute__((__no_instrument_function__)) ;
#line 1317 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static void sb_end_pagefault(struct super_block *sb ) 
{ 


  {
  {
#line 1319
  __sb_end_write(sb, 2);
  }
#line 1320
  return;
}
}
#line 1329
__inline static void sb_end_intwrite(struct super_block *sb )  __attribute__((__no_instrument_function__)) ;
#line 1329 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static void sb_end_intwrite(struct super_block *sb ) 
{ 


  {
  {
#line 1331
  __sb_end_write(sb, 3);
  }
#line 1332
  return;
}
}
#line 1353
__inline static void sb_start_write(struct super_block *sb )  __attribute__((__no_instrument_function__)) ;
#line 1353 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static void sb_start_write(struct super_block *sb ) 
{ 


  {
  {
#line 1355
  __sb_start_write(sb, 1, (bool )1);
  }
#line 1356
  return;
}
}
#line 1358
__inline static int sb_start_write_trylock(struct super_block *sb )  __attribute__((__no_instrument_function__)) ;
#line 1358 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static int sb_start_write_trylock(struct super_block *sb ) 
{ 
  int tmp___7 ;

  {
  {
#line 1360
  tmp___7 = __sb_start_write(sb, 1, (bool )0);
  }
#line 1360
  return (tmp___7);
}
}
#line 1382
__inline static void sb_start_pagefault(struct super_block *sb )  __attribute__((__no_instrument_function__)) ;
#line 1382 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static void sb_start_pagefault(struct super_block *sb ) 
{ 


  {
  {
#line 1384
  __sb_start_write(sb, 2, (bool )1);
  }
#line 1385
  return;
}
}
#line 1400
__inline static void sb_start_intwrite(struct super_block *sb )  __attribute__((__no_instrument_function__)) ;
#line 1400 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static void sb_start_intwrite(struct super_block *sb ) 
{ 


  {
  {
#line 1402
  __sb_start_write(sb, 3, (bool )1);
  }
#line 1403
  return;
}
}
#line 1406
extern bool inode_owner_or_capable(struct inode  const  *inode ) ;
#line 1411
extern int vfs_create(struct inode * , struct dentry * , umode_t  , bool  ) ;
#line 1412
extern int vfs_mkdir(struct inode * , struct dentry * , umode_t  ) ;
#line 1413
extern int vfs_mknod(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
#line 1414
extern int vfs_symlink(struct inode * , struct dentry * , char const   * ) ;
#line 1415
extern int vfs_link(struct dentry * , struct inode * , struct dentry * , struct inode ** ) ;
#line 1416
extern int vfs_rmdir(struct inode * , struct dentry * ) ;
#line 1417
extern int vfs_unlink(struct inode * , struct dentry * , struct inode ** ) ;
#line 1418
extern int vfs_rename(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                      struct inode ** , unsigned int  ) ;
#line 1423
extern void dentry_unhash(struct dentry *dentry ) ;
#line 1428
extern void inode_init_owner(struct inode *inode , struct inode  const  *dir , umode_t mode ) ;
#line 1440
extern int fiemap_fill_next_extent(struct fiemap_extent_info *info , u64 logical ,
                                   u64 phys , u64 len , u32 flags ) ;
#line 1442
extern int fiemap_check_flags(struct fiemap_extent_info *fieinfo , u32 fs_flags ) ;
#line 1551
extern ssize_t rw_copy_check_uvector(int type , struct iovec  const  *uvector , unsigned long nr_segs ,
                                     unsigned long fast_segs , struct iovec *fast_pointer ,
                                     struct iovec **ret_pointer ) ;
#line 1556
extern ssize_t vfs_read(struct file * , char * , size_t  , loff_t * ) ;
#line 1557
extern ssize_t vfs_write(struct file * , char const   * , size_t  , loff_t * ) ;
#line 1558
extern ssize_t vfs_readv(struct file * , struct iovec  const  * , unsigned long  ,
                         loff_t * ) ;
#line 1560
extern ssize_t vfs_writev(struct file * , struct iovec  const  * , unsigned long  ,
                          loff_t * ) ;
#line 1716
extern void __mark_inode_dirty(struct inode * , int  ) ;
#line 1717
__inline static void mark_inode_dirty(struct inode *inode )  __attribute__((__no_instrument_function__)) ;
#line 1717 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static void mark_inode_dirty(struct inode *inode ) 
{ 


  {
  {
#line 1719
  __mark_inode_dirty(inode, (1 | (1 << 1)) | (1 << 2));
  }
#line 1720
  return;
}
}
#line 1722
__inline static void mark_inode_dirty_sync(struct inode *inode )  __attribute__((__no_instrument_function__)) ;
#line 1722 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static void mark_inode_dirty_sync(struct inode *inode ) 
{ 


  {
  {
#line 1724
  __mark_inode_dirty(inode, 1);
  }
#line 1725
  return;
}
}
#line 1727
extern void inc_nlink(struct inode *inode ) ;
#line 1728
extern void drop_nlink(struct inode *inode ) ;
#line 1729
extern void clear_nlink(struct inode *inode ) ;
#line 1730
extern void set_nlink(struct inode *inode , unsigned int nlink ) ;
#line 1732
__inline static void inode_inc_link_count(struct inode *inode )  __attribute__((__no_instrument_function__)) ;
#line 1732 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static void inode_inc_link_count(struct inode *inode ) 
{ 


  {
  {
#line 1734
  inc_nlink(inode);
#line 1735
  mark_inode_dirty(inode);
  }
#line 1736
  return;
}
}
#line 1738
__inline static void inode_dec_link_count(struct inode *inode )  __attribute__((__no_instrument_function__)) ;
#line 1738 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static void inode_dec_link_count(struct inode *inode ) 
{ 


  {
  {
#line 1740
  drop_nlink(inode);
#line 1741
  mark_inode_dirty(inode);
  }
#line 1742
  return;
}
}
#line 1752
__inline static void inode_inc_iversion(struct inode *inode )  __attribute__((__no_instrument_function__)) ;
#line 1752 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static void inode_inc_iversion(struct inode *inode ) 
{ 


  {
  {
#line 1754
  spin_lock(& inode->i_lock);
#line 1755
  (inode->i_version) ++;
#line 1756
  spin_unlock(& inode->i_lock);
  }
#line 1757
  return;
}
}
#line 1766
extern void touch_atime(struct path  const  * ) ;
#line 1767
__inline static void file_accessed(struct file *file )  __attribute__((__no_instrument_function__)) ;
#line 1767 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static void file_accessed(struct file *file ) 
{ 


  {
#line 1769
  if (! (file->f_flags & 262144U)) {
    {
#line 1770
    touch_atime((struct path  const  *)(& file->f_path));
    }
  }
#line 1771
  return;
}
}
#line 1773
extern int sync_inode(struct inode *inode , struct writeback_control *wbc ) ;
#line 1774
extern int sync_inode_metadata(struct inode *inode , int wait ) ;
#line 1804
extern struct dentry *mount_ns(struct file_system_type *fs_type , int flags , void *data ,
                               int (*fill_super)(struct super_block * , void * , int  ) ) ;
#line 1806
extern struct dentry *mount_bdev(struct file_system_type *fs_type , int flags , char const   *dev_name ,
                                 void *data , int (*fill_super)(struct super_block * ,
                                                                void * , int  ) ) ;
#line 1809
extern struct dentry *mount_single(struct file_system_type *fs_type , int flags ,
                                   void *data , int (*fill_super)(struct super_block * ,
                                                                  void * , int  ) ) ;
#line 1812
extern struct dentry *mount_nodev(struct file_system_type *fs_type , int flags , void *data ,
                                  int (*fill_super)(struct super_block * , void * ,
                                                    int  ) ) ;
#line 1815
extern struct dentry *mount_subtree(struct vfsmount *mnt , char const   *path ) ;
#line 1816
extern void generic_shutdown_super(struct super_block *sb ) ;
#line 1817
extern void kill_block_super(struct super_block *sb ) ;
#line 1818
extern void kill_anon_super(struct super_block *sb ) ;
#line 1819
extern void kill_litter_super(struct super_block *sb ) ;
#line 1820
extern void deactivate_super(struct super_block *sb ) ;
#line 1821
extern void deactivate_locked_super(struct super_block *sb ) ;
#line 1822
extern int set_anon_super(struct super_block *s , void *data ) ;
#line 1823
extern int get_anon_bdev(dev_t * ) ;
#line 1824
extern void free_anon_bdev(dev_t  ) ;
#line 1825
extern struct super_block *sget(struct file_system_type *type , int (*test)(struct super_block * ,
                                                                            void * ) ,
                                int (*set)(struct super_block * , void * ) , int flags ,
                                void *data ) ;
#line 1829
extern struct dentry *mount_pseudo(struct file_system_type * , char * , struct super_operations  const  *ops ,
                                   struct dentry_operations  const  *dops , unsigned long  ) ;
#line 1851
extern int register_filesystem(struct file_system_type * ) ;
#line 1852
extern int unregister_filesystem(struct file_system_type * ) ;
#line 1853
extern struct vfsmount *kern_mount_data(struct file_system_type * , void *data ) ;
#line 1855
extern void kern_unmount(struct vfsmount *mnt ) ;
#line 1856
extern int may_umount_tree(struct vfsmount * ) ;
#line 1857
extern int may_umount(struct vfsmount * ) ;
#line 1858
extern long do_mount(char const   * , char const   * , char const   * , unsigned long  ,
                     void * ) ;
#line 1859
extern struct vfsmount *collect_mounts(struct path * ) ;
#line 1860
extern void drop_collected_mounts(struct vfsmount * ) ;
#line 1861
extern int iterate_mounts(int (*)(struct vfsmount * , void * ) , void * , struct vfsmount * ) ;
#line 1863
extern int vfs_statfs(struct path * , struct kstatfs * ) ;
#line 1864
extern int user_statfs(char const   * , struct kstatfs * ) ;
#line 1865
extern int fd_statfs(int  , struct kstatfs * ) ;
#line 1866
extern int vfs_ustat(dev_t  , struct kstatfs * ) ;
#line 1867
extern int freeze_super(struct super_block *super ) ;
#line 1868
extern int thaw_super(struct super_block *super ) ;
#line 1869
extern bool our_mnt(struct vfsmount *mnt ) ;
#line 1870
extern bool fs_fully_visible(struct file_system_type * ) ;
#line 1872
extern int current_umask(void) ;
#line 1874
extern void ihold(struct inode *inode ) ;
#line 1875
extern void iput(struct inode * ) ;
#line 1877
__inline static struct inode *file_inode(struct file *f )  __attribute__((__no_instrument_function__)) ;
#line 1877 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static struct inode *file_inode(struct file *f ) 
{ 


  {
#line 1879
  return (f->f_inode);
}
}
#line 1883
extern struct kobject *fs_kobj ;
#line 1891
extern int locks_mandatory_locked(struct file * ) ;
#line 1892
extern int locks_mandatory_area(int  , struct inode * , struct file * , loff_t  ,
                                size_t  ) ;
#line 1899
__inline static int __mandatory_lock(struct inode *ino )  __attribute__((__no_instrument_function__)) ;
#line 1899 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static int __mandatory_lock(struct inode *ino ) 
{ 


  {
#line 1901
  return (((int )ino->i_mode & 1032) == 1024);
}
}
#line 1909
__inline static int mandatory_lock(struct inode *ino )  __attribute__((__no_instrument_function__)) ;
#line 1909 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static int mandatory_lock(struct inode *ino ) 
{ 
  int tmp___7 ;
  int tmp___8 ;

  {
#line 1911
  if ((ino->i_sb)->s_flags & 64UL) {
    {
#line 1911
    tmp___7 = __mandatory_lock(ino);
    }
#line 1911
    if (tmp___7) {
      {
#line 1911
      tmp___8 = 1;
      }
    } else {
      {
#line 1911
      tmp___8 = 0;
      }
    }
  } else {
    {
#line 1911
    tmp___8 = 0;
    }
  }
#line 1911
  return (tmp___8);
}
}
#line 1914
__inline static int locks_verify_locked(struct file *file )  __attribute__((__no_instrument_function__)) ;
#line 1914 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static int locks_verify_locked(struct file *file ) 
{ 
  int tmp___7 ;
  struct inode *tmp___8 ;
  int tmp___9 ;

  {
  {
#line 1916
  tmp___8 = file_inode(file);
#line 1916
  tmp___9 = mandatory_lock(tmp___8);
  }
#line 1916
  if (tmp___9) {
    {
#line 1917
    tmp___7 = locks_mandatory_locked(file);
    }
#line 1917
    return (tmp___7);
  }
#line 1918
  return (0);
}
}
#line 1921
__inline static int locks_verify_truncate(struct inode *inode , struct file *filp ,
                                          loff_t size )  __attribute__((__no_instrument_function__)) ;
#line 1921 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static int locks_verify_truncate(struct inode *inode , struct file *filp ,
                                          loff_t size ) 
{ 
  loff_t tmp___7 ;
  loff_t tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 1925
  if (inode->i_flock) {
    {
#line 1925
    tmp___10 = mandatory_lock(inode);
    }
#line 1925
    if (tmp___10) {
#line 1926
      if (size < inode->i_size) {
        {
#line 1926
        tmp___7 = inode->i_size - size;
        }
      } else {
        {
#line 1926
        tmp___7 = size - inode->i_size;
        }
      }
#line 1926
      if (size < inode->i_size) {
        {
#line 1926
        tmp___8 = size;
        }
      } else {
        {
#line 1926
        tmp___8 = inode->i_size;
        }
      }
      {
#line 1926
      tmp___9 = locks_mandatory_area(2, inode, filp, tmp___8, (size_t )tmp___7);
      }
#line 1926
      return (tmp___9);
    }
  }
#line 1932
  return (0);
}
}
#line 1935
__inline static int break_lease(struct inode *inode , unsigned int mode )  __attribute__((__no_instrument_function__)) ;
#line 1935 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static int break_lease(struct inode *inode , unsigned int mode ) 
{ 
  int tmp___7 ;

  {
  {
#line 1942
  __asm__  volatile   ("mfence": : : "memory");
  }
#line 1943
  if (inode->i_flock) {
    {
#line 1944
    tmp___7 = __break_lease(inode, mode, 32U);
    }
#line 1944
    return (tmp___7);
  }
#line 1945
  return (0);
}
}
#line 1948
__inline static int break_deleg(struct inode *inode , unsigned int mode )  __attribute__((__no_instrument_function__)) ;
#line 1948 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static int break_deleg(struct inode *inode , unsigned int mode ) 
{ 
  int tmp___7 ;

  {
  {
#line 1955
  __asm__  volatile   ("mfence": : : "memory");
  }
#line 1956
  if (inode->i_flock) {
    {
#line 1957
    tmp___7 = __break_lease(inode, mode, 4U);
    }
#line 1957
    return (tmp___7);
  }
#line 1958
  return (0);
}
}
#line 1961
__inline static int try_break_deleg(struct inode *inode , struct inode **delegated_inode )  __attribute__((__no_instrument_function__)) ;
#line 1961 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static int try_break_deleg(struct inode *inode , struct inode **delegated_inode ) 
{ 
  int ret ;

  {
  {
#line 1965
  ret = break_deleg(inode, 2049U);
  }
#line 1966
  if (ret == -11) {
#line 1966
    if (delegated_inode) {
      {
#line 1967
      *delegated_inode = inode;
#line 1968
      ihold(inode);
      }
    }
  }
#line 1970
  return (ret);
}
}
#line 1973
__inline static int break_deleg_wait(struct inode **delegated_inode )  __attribute__((__no_instrument_function__)) ;
#line 1973 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static int break_deleg_wait(struct inode **delegated_inode ) 
{ 
  int ret ;

  {
  {
#line 1977
  ret = break_deleg(*delegated_inode, 1U);
#line 1978
  iput(*delegated_inode);
#line 1979
  *delegated_inode = (struct inode *)((void *)0);
  }
#line 1980
  return (ret);
}
}
#line 2049
extern long vfs_truncate(struct path * , loff_t  ) ;
#line 2050
extern int do_truncate(struct dentry * , loff_t start , unsigned int time_attrs ,
                       struct file *filp ) ;
#line 2052
extern int do_fallocate(struct file *file , int mode , loff_t offset , loff_t len ) ;
#line 2054
extern long do_sys_open(int dfd , char const   *filename , int flags , umode_t mode ) ;
#line 2056
extern struct file *file_open_name(struct filename * , int  , umode_t  ) ;
#line 2057
extern struct file *filp_open(char const   * , int  , umode_t  ) ;
#line 2058
extern struct file *file_open_root(struct dentry * , struct vfsmount * , char const   * ,
                                   int  ) ;
#line 2060
extern struct file *dentry_open(struct path  const  * , int  , struct cred  const  * ) ;
#line 2061
extern int filp_close(struct file * , fl_owner_t id ) ;
#line 2063
extern struct filename *getname(char const   * ) ;
#line 2064
extern struct filename *getname_kernel(char const   * ) ;
#line 2070
extern int finish_open(struct file *file , struct dentry *dentry , int (*open)(struct inode * ,
                                                                               struct file * ) ,
                       int *opened ) ;
#line 2073
extern int finish_no_open(struct file *file , struct dentry *dentry ) ;
#line 2077
extern int ioctl_preallocate(struct file *filp , void *argp ) ;
#line 2080
extern void __attribute__((__cold__))  vfs_caches_init_early(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 2081
extern void __attribute__((__cold__))  vfs_caches_init(unsigned long  )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 2083
extern struct kmem_cache *names_cachep ;
#line 2085
extern void final_putname(struct filename *name ) ;
#line 2092
extern void putname(struct filename *name ) ;
#line 2096
extern int register_blkdev(unsigned int  , char const   * ) ;
#line 2097
extern void unregister_blkdev(unsigned int  , char const   * ) ;
#line 2098
extern struct block_device *bdget(dev_t  ) ;
#line 2099
extern struct block_device *bdgrab(struct block_device *bdev ) ;
#line 2100
extern void bd_set_size(struct block_device * , loff_t size ) ;
#line 2101
extern void bd_forget(struct inode *inode ) ;
#line 2102
extern void bdput(struct block_device * ) ;
#line 2103
extern void invalidate_bdev(struct block_device * ) ;
#line 2104
extern void iterate_bdevs(void (*)(struct block_device * , void * ) , void * ) ;
#line 2105
extern int sync_blockdev(struct block_device *bdev ) ;
#line 2106
extern void kill_bdev(struct block_device * ) ;
#line 2107
extern struct super_block *freeze_bdev(struct block_device * ) ;
#line 2108
extern void emergency_thaw_all(void) ;
#line 2109
extern int thaw_bdev(struct block_device *bdev , struct super_block *sb ) ;
#line 2110
extern int fsync_bdev(struct block_device * ) ;
#line 2111
extern int sb_is_blkdev_sb(struct super_block *sb ) ;
#line 2137
extern int sync_filesystem(struct super_block * ) ;
#line 2138
extern struct file_operations  const  def_blk_fops ;
#line 2139
extern struct file_operations  const  def_chr_fops ;
#line 2140
extern struct file_operations  const  bad_sock_fops ;
#line 2142
extern int ioctl_by_bdev(struct block_device * , unsigned int  , unsigned long  ) ;
#line 2143
extern int blkdev_ioctl(struct block_device * , fmode_t  , unsigned int  , unsigned long  ) ;
#line 2144
extern long compat_blkdev_ioctl(struct file * , unsigned int  , unsigned long  ) ;
#line 2145
extern int blkdev_get(struct block_device *bdev , fmode_t mode , void *holder ) ;
#line 2146
extern struct block_device *blkdev_get_by_path(char const   *path , fmode_t mode ,
                                               void *holder ) ;
#line 2148
extern struct block_device *blkdev_get_by_dev(dev_t dev , fmode_t mode , void *holder ) ;
#line 2150
extern void blkdev_put(struct block_device *bdev , fmode_t mode ) ;
#line 2152
extern int bd_link_disk_holder(struct block_device *bdev , struct gendisk *disk ) ;
#line 2153
extern void bd_unlink_disk_holder(struct block_device *bdev , struct gendisk *disk ) ;
#line 2170
extern int alloc_chrdev_region(dev_t * , unsigned int  , unsigned int  , char const   * ) ;
#line 2171
extern int register_chrdev_region(dev_t  , unsigned int  , char const   * ) ;
#line 2172
extern int __register_chrdev(unsigned int major , unsigned int baseminor , unsigned int count ,
                             char const   *name , struct file_operations  const  *fops ) ;
#line 2175
extern void __unregister_chrdev(unsigned int major , unsigned int baseminor , unsigned int count ,
                                char const   *name ) ;
#line 2177
extern void unregister_chrdev_region(dev_t  , unsigned int  ) ;
#line 2178
extern void chrdev_show(struct seq_file * , off_t  ) ;
#line 2180
__inline static int register_chrdev(unsigned int major , char const   *name , struct file_operations  const  *fops )  __attribute__((__no_instrument_function__)) ;
#line 2180 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static int register_chrdev(unsigned int major , char const   *name , struct file_operations  const  *fops ) 
{ 
  int tmp___7 ;

  {
  {
#line 2183
  tmp___7 = __register_chrdev(major, 0U, 256U, name, fops);
  }
#line 2183
  return (tmp___7);
}
}
#line 2186
__inline static void unregister_chrdev(unsigned int major , char const   *name )  __attribute__((__no_instrument_function__)) ;
#line 2186 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static void unregister_chrdev(unsigned int major , char const   *name ) 
{ 


  {
  {
#line 2188
  __unregister_chrdev(major, 0U, 256U, name);
  }
#line 2189
  return;
}
}
#line 2197
extern char const   *__bdevname(dev_t  , char *buffer ) ;
#line 2198
extern char const   *bdevname(struct block_device *bdev , char *buffer ) ;
#line 2199
extern struct block_device *lookup_bdev(char const   * ) ;
#line 2200
extern void blkdev_show(struct seq_file * , off_t  ) ;
#line 2206
extern void init_special_inode(struct inode * , umode_t  , dev_t  ) ;
#line 2209
extern void make_bad_inode(struct inode * ) ;
#line 2210
extern int is_bad_inode(struct inode * ) ;
#line 2223
extern void check_disk_size_change(struct gendisk *disk , struct block_device *bdev ) ;
#line 2225
extern int revalidate_disk(struct gendisk * ) ;
#line 2226
extern int check_disk_change(struct block_device * ) ;
#line 2227
extern int __invalidate_device(struct block_device * , bool  ) ;
#line 2228
extern int invalidate_partition(struct gendisk * , int  ) ;
#line 2230
extern unsigned long invalidate_mapping_pages(struct address_space *mapping , unsigned long start ,
                                              unsigned long end ) ;
#line 2233
__inline static void invalidate_remote_inode(struct inode *inode )  __attribute__((__no_instrument_function__)) ;
#line 2233 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static void invalidate_remote_inode(struct inode *inode ) 
{ 


  {
#line 2235
  if (((int )inode->i_mode & 61440) == 32768) {
    {
#line 2237
    invalidate_mapping_pages(inode->i_mapping, 0UL, 0xffffffffffffffffUL);
    }
  } else
#line 2235
  if (((int )inode->i_mode & 61440) == 16384) {
    {
#line 2237
    invalidate_mapping_pages(inode->i_mapping, 0UL, 0xffffffffffffffffUL);
    }
  } else
#line 2235
  if (((int )inode->i_mode & 61440) == 40960) {
    {
#line 2237
    invalidate_mapping_pages(inode->i_mapping, 0UL, 0xffffffffffffffffUL);
    }
  }
#line 2238
  return;
}
}
#line 2239
extern int invalidate_inode_pages2(struct address_space *mapping ) ;
#line 2240
extern int invalidate_inode_pages2_range(struct address_space *mapping , unsigned long start ,
                                         unsigned long end ) ;
#line 2242
extern int write_inode_now(struct inode * , int  ) ;
#line 2243
extern int filemap_fdatawrite(struct address_space * ) ;
#line 2244
extern int filemap_flush(struct address_space * ) ;
#line 2245
extern int filemap_fdatawait(struct address_space * ) ;
#line 2246
extern int filemap_fdatawait_range(struct address_space * , loff_t lstart , loff_t lend ) ;
#line 2248
extern int filemap_write_and_wait(struct address_space *mapping ) ;
#line 2249
extern int filemap_write_and_wait_range(struct address_space *mapping , loff_t lstart ,
                                        loff_t lend ) ;
#line 2251
extern int __filemap_fdatawrite_range(struct address_space *mapping , loff_t start ,
                                      loff_t end , int sync_mode ) ;
#line 2253
extern int filemap_fdatawrite_range(struct address_space *mapping , loff_t start ,
                                    loff_t end ) ;
#line 2256
extern int vfs_fsync_range(struct file *file , loff_t start , loff_t end , int datasync ) ;
#line 2258
extern int vfs_fsync(struct file *file , int datasync ) ;
#line 2259
__inline static int generic_write_sync(struct file *file , loff_t pos , loff_t count )  __attribute__((__no_instrument_function__)) ;
#line 2259 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static int generic_write_sync(struct file *file , loff_t pos , loff_t count ) 
{ 
  int tmp___7 ;
  int tmp___8 ;

  {
#line 2261
  if (! (file->f_flags & 4096U)) {
#line 2261
    if (! ((((file->f_mapping)->host)->i_sb)->s_flags & 16UL)) {
#line 2261
      if (! (((file->f_mapping)->host)->i_flags & 1U)) {
#line 2262
        return (0);
      }
    }
  }
#line 2263
  if (file->f_flags & 1048576U) {
    {
#line 2263
    tmp___7 = 0;
    }
  } else {
    {
#line 2263
    tmp___7 = 1;
    }
  }
  {
#line 2263
  tmp___8 = vfs_fsync_range(file, pos, (pos + count) - 1LL, tmp___7);
  }
#line 2263
  return (tmp___8);
}
}
#line 2266
extern void emergency_sync(void) ;
#line 2267
extern void emergency_remount(void) ;
#line 2269
extern sector_t bmap(struct inode * , sector_t  ) ;
#line 2271
extern int notify_change(struct dentry * , struct iattr * , struct inode ** ) ;
#line 2272
extern int inode_permission(struct inode * , int  ) ;
#line 2273
extern int generic_permission(struct inode * , int  ) ;
#line 2275
__inline static bool execute_ok(struct inode *inode )  __attribute__((__no_instrument_function__)) ;
#line 2275 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static bool execute_ok(struct inode *inode ) 
{ 
  int tmp___7 ;

  {
#line 2277
  if ((int )inode->i_mode & 73) {
    {
#line 2277
    tmp___7 = 1;
    }
  } else
#line 2277
  if (((int )inode->i_mode & 61440) == 16384) {
    {
#line 2277
    tmp___7 = 1;
    }
  } else {
    {
#line 2277
    tmp___7 = 0;
    }
  }
#line 2277
  return ((bool )tmp___7);
}
}
#line 2280
__inline static void file_start_write(struct file *file )  __attribute__((__no_instrument_function__)) ;
#line 2280 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static void file_start_write(struct file *file ) 
{ 
  struct inode *tmp___7 ;
  struct inode *tmp___8 ;

  {
  {
#line 2282
  tmp___7 = file_inode(file);
  }
#line 2282
  if (! (((int )tmp___7->i_mode & 61440) == 32768)) {
#line 2283
    return;
  }
  {
#line 2284
  tmp___8 = file_inode(file);
#line 2284
  __sb_start_write(tmp___8->i_sb, 1, (bool )1);
  }
#line 2285
  return;
}
}
#line 2287
__inline static bool file_start_write_trylock(struct file *file )  __attribute__((__no_instrument_function__)) ;
#line 2287 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static bool file_start_write_trylock(struct file *file ) 
{ 
  struct inode *tmp___7 ;
  struct inode *tmp___8 ;
  int tmp___9 ;

  {
  {
#line 2289
  tmp___7 = file_inode(file);
  }
#line 2289
  if (! (((int )tmp___7->i_mode & 61440) == 32768)) {
#line 2290
    return ((bool )1);
  }
  {
#line 2291
  tmp___8 = file_inode(file);
#line 2291
  tmp___9 = __sb_start_write(tmp___8->i_sb, 1, (bool )0);
  }
#line 2291
  return ((bool )tmp___9);
}
}
#line 2294
__inline static void file_end_write(struct file *file )  __attribute__((__no_instrument_function__)) ;
#line 2294 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static void file_end_write(struct file *file ) 
{ 
  struct inode *tmp___7 ;
  struct inode *tmp___8 ;

  {
  {
#line 2296
  tmp___7 = file_inode(file);
  }
#line 2296
  if (! (((int )tmp___7->i_mode & 61440) == 32768)) {
#line 2297
    return;
  }
  {
#line 2298
  tmp___8 = file_inode(file);
#line 2298
  __sb_end_write(tmp___8->i_sb, 1);
  }
#line 2299
  return;
}
}
#line 2317
__inline static int get_write_access(struct inode *inode )  __attribute__((__no_instrument_function__)) ;
#line 2317 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static int get_write_access(struct inode *inode ) 
{ 
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 2319
  tmp___9 = atomic_inc_unless_negative(& inode->i_writecount);
  }
#line 2319
  if (tmp___9) {
    {
#line 2319
    tmp___8 = 0;
    }
  } else {
    {
#line 2319
    tmp___8 = -26;
    }
  }
#line 2319
  return (tmp___8);
}
}
#line 2321
__inline static int deny_write_access(struct file *file )  __attribute__((__no_instrument_function__)) ;
#line 2321 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static int deny_write_access(struct file *file ) 
{ 
  struct inode *inode ;
  struct inode *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 2323
  tmp___7 = file_inode(file);
#line 2323
  inode = tmp___7;
#line 2324
  tmp___10 = atomic_dec_unless_positive(& inode->i_writecount);
  }
#line 2324
  if (tmp___10) {
    {
#line 2324
    tmp___9 = 0;
    }
  } else {
    {
#line 2324
    tmp___9 = -26;
    }
  }
#line 2324
  return (tmp___9);
}
}
#line 2326
__inline static void put_write_access(struct inode *inode )  __attribute__((__no_instrument_function__)) ;
#line 2326 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static void put_write_access(struct inode *inode ) 
{ 


  {
  {
#line 2328
  atomic_dec(& inode->i_writecount);
  }
#line 2329
  return;
}
}
#line 2330
__inline static void allow_write_access(struct file *file )  __attribute__((__no_instrument_function__)) ;
#line 2330 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static void allow_write_access(struct file *file ) 
{ 
  struct inode *tmp___7 ;

  {
#line 2332
  if (file) {
    {
#line 2333
    tmp___7 = file_inode(file);
#line 2333
    atomic_inc(& tmp___7->i_writecount);
    }
  }
#line 2334
  return;
}
}
#line 2335
__inline static bool inode_is_open_for_write(struct inode  const  *inode )  __attribute__((__no_instrument_function__)) ;
#line 2335 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static bool inode_is_open_for_write(struct inode  const  *inode ) 
{ 
  int tmp___7 ;

  {
  {
#line 2337
  tmp___7 = atomic_read(& inode->i_writecount);
  }
#line 2337
  return ((bool )(tmp___7 > 0));
}
}
#line 2351
__inline static void i_readcount_dec(struct inode *inode )  __attribute__((__no_instrument_function__)) ;
#line 2351 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static void i_readcount_dec(struct inode *inode ) 
{ 


  {
#line 2353
  return;
}
}
#line 2355
__inline static void i_readcount_inc(struct inode *inode )  __attribute__((__no_instrument_function__)) ;
#line 2355 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static void i_readcount_inc(struct inode *inode ) 
{ 


  {
#line 2357
  return;
}
}
#line 2360
extern int do_pipe_flags(int * , int  ) ;
#line 2362
extern int kernel_read(struct file * , loff_t  , char * , unsigned long  ) ;
#line 2363
extern ssize_t kernel_write(struct file * , char const   * , size_t  , loff_t  ) ;
#line 2364
extern ssize_t __kernel_write(struct file * , char const   * , size_t  , loff_t * ) ;
#line 2365
extern struct file *open_exec(char const   * ) ;
#line 2368
extern int is_subdir(struct dentry * , struct dentry * ) ;
#line 2369
extern int path_is_under(struct path * , struct path * ) ;
#line 2374
extern loff_t default_llseek(struct file *file , loff_t offset , int whence ) ;
#line 2376
extern loff_t vfs_llseek(struct file *file , loff_t offset , int whence ) ;
#line 2378
extern int inode_init_always(struct super_block * , struct inode * ) ;
#line 2379
extern void inode_init_once(struct inode * ) ;
#line 2380
extern void address_space_init_once(struct address_space *mapping ) ;
#line 2381
extern struct inode *igrab(struct inode * ) ;
#line 2382
extern ino_t iunique(struct super_block * , ino_t  ) ;
#line 2383
extern int inode_needs_sync(struct inode *inode ) ;
#line 2384
extern int generic_delete_inode(struct inode *inode ) ;
#line 2385
__inline static int generic_drop_inode(struct inode *inode )  __attribute__((__no_instrument_function__)) ;
#line 2385 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static int generic_drop_inode(struct inode *inode ) 
{ 
  int tmp___7 ;
  int tmp___8 ;

  {
#line 2387
  if (! inode->__annonCompField51.i_nlink) {
    {
#line 2387
    tmp___8 = 1;
    }
  } else {
    {
#line 2387
    tmp___7 = inode_unhashed(inode);
    }
#line 2387
    if (tmp___7) {
      {
#line 2387
      tmp___8 = 1;
      }
    } else {
      {
#line 2387
      tmp___8 = 0;
      }
    }
  }
#line 2387
  return (tmp___8);
}
}
#line 2390
extern struct inode *ilookup5_nowait(struct super_block *sb , unsigned long hashval ,
                                     int (*test)(struct inode * , void * ) , void *data ) ;
#line 2393
extern struct inode *ilookup5(struct super_block *sb , unsigned long hashval , int (*test)(struct inode * ,
                                                                                           void * ) ,
                              void *data ) ;
#line 2395
extern struct inode *ilookup(struct super_block *sb , unsigned long ino ) ;
#line 2397
extern struct inode *iget5_locked(struct super_block * , unsigned long  , int (*test)(struct inode * ,
                                                                                      void * ) ,
                                  int (*set)(struct inode * , void * ) , void * ) ;
#line 2398
extern struct inode *iget_locked(struct super_block * , unsigned long  ) ;
#line 2399
extern int insert_inode_locked4(struct inode * , unsigned long  , int (*test)(struct inode * ,
                                                                              void * ) ,
                                void * ) ;
#line 2400
extern int insert_inode_locked(struct inode * ) ;
#line 2404
__inline static void lockdep_annotate_inode_mutex_key(struct inode *inode )  __attribute__((__no_instrument_function__)) ;
#line 2404 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static void lockdep_annotate_inode_mutex_key(struct inode *inode ) 
{ 


  {
#line 2404
  return;
}
}
#line 2406
extern void unlock_new_inode(struct inode * ) ;
#line 2407
extern unsigned int get_next_ino(void) ;
#line 2409
extern void __iget(struct inode *inode ) ;
#line 2410
extern void iget_failed(struct inode * ) ;
#line 2411
extern void clear_inode(struct inode * ) ;
#line 2412
extern void __destroy_inode(struct inode * ) ;
#line 2413
extern struct inode *new_inode_pseudo(struct super_block *sb ) ;
#line 2414
extern struct inode *new_inode(struct super_block *sb ) ;
#line 2415
extern void free_inode_nonrcu(struct inode *inode ) ;
#line 2416
extern int should_remove_suid(struct dentry * ) ;
#line 2417
extern int file_remove_suid(struct file * ) ;
#line 2419
extern void __insert_inode_hash(struct inode * , unsigned long hashval ) ;
#line 2420
__inline static void insert_inode_hash(struct inode *inode )  __attribute__((__no_instrument_function__)) ;
#line 2420 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static void insert_inode_hash(struct inode *inode ) 
{ 


  {
  {
#line 2422
  __insert_inode_hash(inode, inode->i_ino);
  }
#line 2423
  return;
}
}
#line 2425
extern void __remove_inode_hash(struct inode * ) ;
#line 2426
__inline static void remove_inode_hash(struct inode *inode )  __attribute__((__no_instrument_function__)) ;
#line 2426 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static void remove_inode_hash(struct inode *inode ) 
{ 
  int tmp___7 ;

  {
  {
#line 2428
  tmp___7 = inode_unhashed(inode);
  }
#line 2428
  if (! tmp___7) {
    {
#line 2429
    __remove_inode_hash(inode);
    }
  }
#line 2430
  return;
}
}
#line 2432
extern void inode_sb_list_add(struct inode *inode ) ;
#line 2435
extern void submit_bio(int  , struct bio * ) ;
#line 2436
extern int bdev_read_only(struct block_device * ) ;
#line 2438
extern int set_blocksize(struct block_device * , int  ) ;
#line 2439
extern int sb_set_blocksize(struct super_block * , int  ) ;
#line 2440
extern int sb_min_blocksize(struct super_block * , int  ) ;
#line 2442
extern int generic_file_mmap(struct file * , struct vm_area_struct * ) ;
#line 2443
extern int generic_file_readonly_mmap(struct file * , struct vm_area_struct * ) ;
#line 2444
extern int generic_file_remap_pages(struct vm_area_struct * , unsigned long addr ,
                                    unsigned long size , unsigned long pgoff ) ;
#line 2446
extern int generic_write_checks(struct file *file , loff_t *pos , size_t *count ,
                                int isblk ) ;
#line 2447
extern ssize_t generic_file_read_iter(struct kiocb * , struct iov_iter * ) ;
#line 2448
extern ssize_t __generic_file_write_iter(struct kiocb * , struct iov_iter * ) ;
#line 2449
extern ssize_t generic_file_write_iter(struct kiocb * , struct iov_iter * ) ;
#line 2450
extern ssize_t generic_file_direct_write(struct kiocb * , struct iov_iter * , loff_t  ) ;
#line 2451
extern ssize_t generic_perform_write(struct file * , struct iov_iter * , loff_t  ) ;
#line 2452
extern ssize_t do_sync_read(struct file *filp , char *buf , size_t len , loff_t *ppos ) ;
#line 2453
extern ssize_t do_sync_write(struct file *filp , char const   *buf , size_t len ,
                             loff_t *ppos ) ;
#line 2454
extern ssize_t new_sync_read(struct file *filp , char *buf , size_t len , loff_t *ppos ) ;
#line 2455
extern ssize_t new_sync_write(struct file *filp , char const   *buf , size_t len ,
                              loff_t *ppos ) ;
#line 2458
extern ssize_t blkdev_write_iter(struct kiocb *iocb , struct iov_iter *from ) ;
#line 2459
extern int blkdev_fsync(struct file *filp , loff_t start , loff_t end , int datasync ) ;
#line 2461
extern void block_sync_page(struct page *page ) ;
#line 2464
extern ssize_t generic_file_splice_read(struct file * , loff_t * , struct pipe_inode_info * ,
                                        size_t  , unsigned int  ) ;
#line 2466
extern ssize_t default_file_splice_read(struct file * , loff_t * , struct pipe_inode_info * ,
                                        size_t  , unsigned int  ) ;
#line 2468
extern ssize_t iter_file_splice_write(struct pipe_inode_info * , struct file * , loff_t * ,
                                      size_t  , unsigned int  ) ;
#line 2470
extern ssize_t generic_splice_sendpage(struct pipe_inode_info *pipe , struct file *out ,
                                       loff_t * , size_t len , unsigned int flags ) ;
#line 2473
extern void file_ra_state_init(struct file_ra_state *ra , struct address_space *mapping ) ;
#line 2475
extern loff_t noop_llseek(struct file *file , loff_t offset , int whence ) ;
#line 2476
extern loff_t no_llseek(struct file *file , loff_t offset , int whence ) ;
#line 2477
extern loff_t vfs_setpos(struct file *file , loff_t offset , loff_t maxsize ) ;
#line 2478
extern loff_t generic_file_llseek(struct file *file , loff_t offset , int whence ) ;
#line 2479
extern loff_t generic_file_llseek_size(struct file *file , loff_t offset , int whence ,
                                       loff_t maxsize , loff_t eof ) ;
#line 2481
extern loff_t fixed_size_llseek(struct file *file , loff_t offset , int whence , loff_t size ) ;
#line 2483
extern int generic_file_open(struct inode *inode , struct file *filp ) ;
#line 2484
extern int nonseekable_open(struct inode *inode , struct file *filp ) ;
#line 2494
__inline static int xip_truncate_page(struct address_space *mapping , loff_t from )  __attribute__((__no_instrument_function__)) ;
#line 2494 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static int xip_truncate_page(struct address_space *mapping , loff_t from ) 
{ 


  {
#line 2496
  return (0);
}
}
#line 2515
extern void dio_end_io(struct bio *bio , int error ) ;
#line 2517
extern ssize_t __blockdev_direct_IO(int rw , struct kiocb *iocb , struct inode *inode ,
                                    struct block_device *bdev , struct iov_iter *iter ,
                                    loff_t offset , get_block_t *get_block , dio_iodone_t *end_io ,
                                    dio_submit_t *submit_io , int flags ) ;
#line 2522
__inline static ssize_t blockdev_direct_IO(int rw , struct kiocb *iocb , struct inode *inode ,
                                           struct iov_iter *iter , loff_t offset ,
                                           get_block_t *get_block )  __attribute__((__no_instrument_function__)) ;
#line 2522 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static ssize_t blockdev_direct_IO(int rw , struct kiocb *iocb , struct inode *inode ,
                                           struct iov_iter *iter , loff_t offset ,
                                           get_block_t *get_block ) 
{ 
  ssize_t tmp___7 ;

  {
  {
#line 2526
  tmp___7 = __blockdev_direct_IO(rw, iocb, inode, (inode->i_sb)->s_bdev, iter, offset,
                                 get_block, (dio_iodone_t *)((void *)0), (dio_submit_t *)((void *)0),
                                 3);
  }
#line 2526
  return (tmp___7);
}
}
#line 2532
extern void inode_dio_wait(struct inode *inode ) ;
#line 2533
extern void inode_dio_done(struct inode *inode ) ;
#line 2535
extern void inode_set_flags(struct inode *inode , unsigned int flags , unsigned int mask ) ;
#line 2538
extern struct file_operations  const  generic_ro_fops ;
#line 2542
extern int readlink_copy(char * , int  , char const   * ) ;
#line 2543
extern int page_readlink(struct dentry * , char * , int  ) ;
#line 2544
extern void *page_follow_link_light(struct dentry * , struct nameidata * ) ;
#line 2545
extern void page_put_link(struct dentry * , struct nameidata * , void * ) ;
#line 2546
extern int __page_symlink(struct inode *inode , char const   *symname , int len ,
                          int nofs ) ;
#line 2548
extern int page_symlink(struct inode *inode , char const   *symname , int len ) ;
#line 2549
extern struct inode_operations  const  page_symlink_inode_operations ;
#line 2550
extern void kfree_put_link(struct dentry * , struct nameidata * , void * ) ;
#line 2551
extern int generic_readlink(struct dentry * , char * , int  ) ;
#line 2552
extern void generic_fillattr(struct inode * , struct kstat * ) ;
#line 2553
extern int vfs_getattr_nosec(struct path *path , struct kstat *stat ) ;
#line 2554
extern int vfs_getattr(struct path * , struct kstat * ) ;
#line 2555
extern void __inode_add_bytes(struct inode *inode , loff_t bytes ) ;
#line 2556
extern void inode_add_bytes(struct inode *inode , loff_t bytes ) ;
#line 2557
extern void __inode_sub_bytes(struct inode *inode , loff_t bytes ) ;
#line 2558
extern void inode_sub_bytes(struct inode *inode , loff_t bytes ) ;
#line 2559
extern loff_t inode_get_bytes(struct inode *inode ) ;
#line 2560
extern void inode_set_bytes(struct inode *inode , loff_t bytes ) ;
#line 2562
extern int vfs_readdir(struct file * , int (*)(void * , char const   * , int  , loff_t  ,
                                               u64  , unsigned int  ) , void * ) ;
#line 2563
extern int iterate_dir(struct file * , struct dir_context * ) ;
#line 2565
extern int vfs_stat(char const   * , struct kstat * ) ;
#line 2566
extern int vfs_lstat(char const   * , struct kstat * ) ;
#line 2567
extern int vfs_fstat(unsigned int  , struct kstat * ) ;
#line 2568
extern int vfs_fstatat(int  , char const   * , struct kstat * , int  ) ;
#line 2570
extern int do_vfs_ioctl(struct file *filp , unsigned int fd , unsigned int cmd , unsigned long arg ) ;
#line 2572
extern int __generic_block_fiemap(struct inode *inode , struct fiemap_extent_info *fieinfo ,
                                  loff_t start , loff_t len , get_block_t *get_block ) ;
#line 2576
extern int generic_block_fiemap(struct inode *inode , struct fiemap_extent_info *fieinfo ,
                                u64 start , u64 len , get_block_t *get_block ) ;
#line 2580
extern void get_filesystem(struct file_system_type *fs ) ;
#line 2581
extern void put_filesystem(struct file_system_type *fs ) ;
#line 2582
extern struct file_system_type *get_fs_type(char const   *name ) ;
#line 2583
extern struct super_block *get_super(struct block_device * ) ;
#line 2584
extern struct super_block *get_super_thawed(struct block_device * ) ;
#line 2585
extern struct super_block *get_active_super(struct block_device *bdev ) ;
#line 2586
extern void drop_super(struct super_block *sb ) ;
#line 2587
extern void iterate_supers(void (*)(struct super_block * , void * ) , void * ) ;
#line 2588
extern void iterate_supers_type(struct file_system_type * , void (*)(struct super_block * ,
                                                                     void * ) , void * ) ;
#line 2591
extern int dcache_dir_open(struct inode * , struct file * ) ;
#line 2592
extern int dcache_dir_close(struct inode * , struct file * ) ;
#line 2593
extern loff_t dcache_dir_lseek(struct file * , loff_t  , int  ) ;
#line 2594
extern int dcache_readdir(struct file * , struct dir_context * ) ;
#line 2595
extern int simple_setattr(struct dentry * , struct iattr * ) ;
#line 2596
extern int simple_getattr(struct vfsmount * , struct dentry * , struct kstat * ) ;
#line 2597
extern int simple_statfs(struct dentry * , struct kstatfs * ) ;
#line 2598
extern int simple_open(struct inode *inode , struct file *file ) ;
#line 2599
extern int simple_link(struct dentry * , struct inode * , struct dentry * ) ;
#line 2600
extern int simple_unlink(struct inode * , struct dentry * ) ;
#line 2601
extern int simple_rmdir(struct inode * , struct dentry * ) ;
#line 2602
extern int simple_rename(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
#line 2603
extern int noop_fsync(struct file * , loff_t  , loff_t  , int  ) ;
#line 2604
extern int simple_empty(struct dentry * ) ;
#line 2605
extern int simple_readpage(struct file *file , struct page *page ) ;
#line 2606
extern int simple_write_begin(struct file *file , struct address_space *mapping ,
                              loff_t pos , unsigned int len , unsigned int flags ,
                              struct page **pagep , void **fsdata ) ;
#line 2609
extern int simple_write_end(struct file *file , struct address_space *mapping , loff_t pos ,
                            unsigned int len , unsigned int copied , struct page *page ,
                            void *fsdata ) ;
#line 2612
extern int always_delete_dentry(struct dentry  const  * ) ;
#line 2613
extern struct inode *alloc_anon_inode(struct super_block * ) ;
#line 2614
extern struct dentry_operations  const  simple_dentry_operations ;
#line 2616
extern struct dentry *simple_lookup(struct inode * , struct dentry * , unsigned int flags ) ;
#line 2617
extern ssize_t generic_read_dir(struct file * , char * , size_t  , loff_t * ) ;
#line 2618
extern struct file_operations  const  simple_dir_operations ;
#line 2619
extern struct inode_operations  const  simple_dir_inode_operations ;
#line 2621
extern struct dentry *d_alloc_name(struct dentry * , char const   * ) ;
#line 2622
extern int simple_fill_super(struct super_block * , unsigned long  , struct tree_descr * ) ;
#line 2623
extern int simple_pin_fs(struct file_system_type * , struct vfsmount **mount , int *count ) ;
#line 2624
extern void simple_release_fs(struct vfsmount **mount , int *count ) ;
#line 2626
extern ssize_t simple_read_from_buffer(void *to , size_t count , loff_t *ppos , void const   *from ,
                                       size_t available ) ;
#line 2628
extern ssize_t simple_write_to_buffer(void *to , size_t available , loff_t *ppos ,
                                      void const   *from , size_t count ) ;
#line 2631
extern int __generic_file_fsync(struct file * , loff_t  , loff_t  , int  ) ;
#line 2632
extern int generic_file_fsync(struct file * , loff_t  , loff_t  , int  ) ;
#line 2634
extern int generic_check_addressable(unsigned int  , u64  ) ;
#line 2637
extern int buffer_migrate_page(struct address_space * , struct page * , struct page * ,
                               enum migrate_mode  ) ;
#line 2644
extern int inode_change_ok(struct inode  const  * , struct iattr * ) ;
#line 2645
extern int inode_newsize_ok(struct inode  const  * , loff_t offset ) ;
#line 2646
extern void setattr_copy(struct inode *inode , struct iattr  const  *attr ) ;
#line 2648
extern int file_update_time(struct file *file ) ;
#line 2650
extern int generic_show_options(struct seq_file *m , struct dentry *root ) ;
#line 2651
extern void save_mount_options(struct super_block *sb , char *options ) ;
#line 2652
extern void replace_mount_options(struct super_block *sb , char *options ) ;
#line 2654
__inline static ino_t parent_ino(struct dentry *dentry )  __attribute__((__no_instrument_function__)) ;
#line 2654 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static ino_t parent_ino(struct dentry *dentry ) 
{ 
  ino_t res ;

  {
  {
#line 2662
  spin_lock(& dentry->d_lockref.__annonCompField45.__annonCompField44.lock);
#line 2663
  res = ((dentry->d_parent)->d_inode)->i_ino;
#line 2664
  spin_unlock(& dentry->d_lockref.__annonCompField45.__annonCompField44.lock);
  }
#line 2665
  return (res);
}
}
#line 2681
extern char *simple_transaction_get(struct file *file , char const   *buf , size_t size ) ;
#line 2683
extern ssize_t simple_transaction_read(struct file *file , char *buf , size_t size ,
                                       loff_t *pos ) ;
#line 2685
extern int simple_transaction_release(struct inode *inode , struct file *file ) ;
#line 2687
extern void simple_transaction_set(struct file *file , size_t n ) ;
#line 2720
__inline static void ( /* format attribute */  __simple_attr_check_format)(char const   *fmt 
                                                                           , ...)  __attribute__((__no_instrument_function__)) ;
#line 2720 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static void ( /* format attribute */  __simple_attr_check_format)(char const   *fmt 
                                                                           , ...) 
{ 


  {
#line 2724
  return;
}
}
#line 2726
extern int simple_attr_open(struct inode *inode , struct file *file , int (*get)(void * ,
                                                                                 u64 * ) ,
                            int (*set)(void * , u64  ) , char const   *fmt ) ;
#line 2729
extern int simple_attr_release(struct inode *inode , struct file *file ) ;
#line 2730
extern ssize_t simple_attr_read(struct file *file , char *buf , size_t len , loff_t *ppos ) ;
#line 2732
extern ssize_t simple_attr_write(struct file *file , char const   *buf , size_t len ,
                                 loff_t *ppos ) ;
#line 2736
extern int proc_nr_files(struct ctl_table *table , int write , void *buffer , size_t *lenp ,
                         loff_t *ppos ) ;
#line 2738
extern int proc_nr_dentry(struct ctl_table *table , int write , void *buffer , size_t *lenp ,
                          loff_t *ppos ) ;
#line 2740
extern int proc_nr_inodes(struct ctl_table *table , int write , void *buffer , size_t *lenp ,
                          loff_t *ppos ) ;
#line 2742
extern int __attribute__((__cold__))  get_filesystem_list(char *buf )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 2751
__inline static int is_sxid(umode_t mode )  __attribute__((__no_instrument_function__)) ;
#line 2751 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static int is_sxid(umode_t mode ) 
{ 
  int tmp___7 ;

  {
#line 2753
  if ((int )mode & 2048) {
    {
#line 2753
    tmp___7 = 1;
    }
  } else
#line 2753
  if ((int )mode & 1024) {
#line 2753
    if ((int )mode & 8) {
      {
#line 2753
      tmp___7 = 1;
      }
    } else {
      {
#line 2753
      tmp___7 = 0;
      }
    }
  } else {
    {
#line 2753
    tmp___7 = 0;
    }
  }
#line 2753
  return (tmp___7);
}
}
#line 2756
__inline static void inode_has_no_xattr(struct inode *inode )  __attribute__((__no_instrument_function__)) ;
#line 2756 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static void inode_has_no_xattr(struct inode *inode ) 
{ 
  int tmp___7 ;

  {
  {
#line 2758
  tmp___7 = is_sxid(inode->i_mode);
  }
#line 2758
  if (! tmp___7) {
#line 2758
    if ((inode->i_sb)->s_flags & (unsigned long )(1 << 28)) {
      {
#line 2759
      inode->i_flags |= 4096U;
      }
    }
  }
#line 2760
  return;
}
}
#line 2762
__inline static bool dir_emit(struct dir_context *ctx , char const   *name , int namelen ,
                              u64 ino , unsigned int type )  __attribute__((__no_instrument_function__)) ;
#line 2762 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static bool dir_emit(struct dir_context *ctx , char const   *name , int namelen ,
                              u64 ino , unsigned int type ) 
{ 
  int tmp___7 ;

  {
  {
#line 2766
  tmp___7 = (*(ctx->actor))((void *)ctx, name, namelen, ctx->pos, ino, type);
  }
#line 2766
  return ((bool )(tmp___7 == 0));
}
}
#line 2768
__inline static bool dir_emit_dot(struct file *file , struct dir_context *ctx )  __attribute__((__no_instrument_function__)) ;
#line 2768 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static bool dir_emit_dot(struct file *file , struct dir_context *ctx ) 
{ 
  int tmp___7 ;

  {
  {
#line 2770
  tmp___7 = (*(ctx->actor))((void *)ctx, ".", 1, ctx->pos, (u64 )((file->f_path.dentry)->d_inode)->i_ino,
                            4U);
  }
#line 2770
  return ((bool )(tmp___7 == 0));
}
}
#line 2773
__inline static bool dir_emit_dotdot(struct file *file , struct dir_context *ctx )  __attribute__((__no_instrument_function__)) ;
#line 2773 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static bool dir_emit_dotdot(struct file *file , struct dir_context *ctx ) 
{ 
  ino_t tmp___7 ;
  int tmp___8 ;

  {
  {
#line 2775
  tmp___7 = parent_ino(file->f_path.dentry);
#line 2775
  tmp___8 = (*(ctx->actor))((void *)ctx, "..", 2, ctx->pos, (u64 )tmp___7, 4U);
  }
#line 2775
  return ((bool )(tmp___8 == 0));
}
}
#line 2778
__inline static bool dir_emit_dots(struct file *file , struct dir_context *ctx )  __attribute__((__no_instrument_function__)) ;
#line 2778 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static bool dir_emit_dots(struct file *file , struct dir_context *ctx ) 
{ 
  bool tmp___7 ;
  bool tmp___8 ;

  {
#line 2780
  if (ctx->pos == 0LL) {
    {
#line 2781
    tmp___7 = dir_emit_dot(file, ctx);
    }
#line 2781
    if (! tmp___7) {
#line 2782
      return ((bool )0);
    }
    {
#line 2783
    ctx->pos = (loff_t )1;
    }
  }
#line 2785
  if (ctx->pos == 1LL) {
    {
#line 2786
    tmp___8 = dir_emit_dotdot(file, ctx);
    }
#line 2786
    if (! tmp___8) {
#line 2787
      return ((bool )0);
    }
    {
#line 2788
    ctx->pos = (loff_t )2;
    }
  }
#line 2790
  return ((bool )1);
}
}
#line 2792
__inline static bool dir_relax(struct inode *inode )  __attribute__((__no_instrument_function__)) ;
#line 2792 "../../../analyzer/../bench/linux-headers/include/linux/fs.h"
__inline static bool dir_relax(struct inode *inode ) 
{ 


  {
  {
#line 2794
  mutex_unlock(& inode->i_mutex);
#line 2795
  mutex_lock(& inode->i_mutex);
  }
#line 2796
  return ((bool )(! (inode->i_flags & 16U)));
}
}
#line 63 "applicom.c"
static struct mutex ac_mutex  =    {{1}, {{{{{(__ticketpair_t )0}}, 3735899821U, 4294967295U, (void *)-1L}}}, {& ac_mutex.wait_list,
                                                                               & ac_mutex.wait_list},
    (struct task_struct *)0, {{0}}};
#line 64 "applicom.c"
static char *applicom_pci_devnames[3]  = {      (char *)"PCI board",      (char *)"PCI2000IBS / PCI2000CAN",      (char *)"PCI2000PFB"};
#line 70 "applicom.c"
static struct pci_device_id applicom_pci_tbl[4]  = {      {(__u32 )5001, (__u32 )1, (__u32 )(~ 0), (__u32 )(~ 0), (__u32 )0, (__u32 )0,
      0UL}, 
        {(__u32 )5001, (__u32 )2, (__u32 )(~ 0), (__u32 )(~ 0), (__u32 )0, (__u32 )0,
      0UL}, 
        {(__u32 )5001, (__u32 )3, (__u32 )(~ 0), (__u32 )(~ 0), (__u32 )0, (__u32 )0,
      0UL}, 
        {(__u32 )0, 0U, 0U, 0U, 0U, 0U, 0UL}};
#line 76
extern struct pci_device_id  const  __mod_pci__applicom_pci_tbl_device_table  __attribute__((__unused__,
__alias__("applicom_pci_tbl"))) ;
#line 78 "applicom.c"
static char const   __UNIQUE_ID_author0[48]  __attribute__((__used__, __unused__,
__section__(".modinfo"), __aligned__(1)))  = 
#line 78
  {      (char const   )'a',      (char const   )'u',      (char const   )'t',      (char const   )'h', 
        (char const   )'o',      (char const   )'r',      (char const   )'=',      (char const   )'D', 
        (char const   )'a',      (char const   )'v',      (char const   )'i',      (char const   )'d', 
        (char const   )' ',      (char const   )'W',      (char const   )'o',      (char const   )'o', 
        (char const   )'d',      (char const   )'h',      (char const   )'o',      (char const   )'u', 
        (char const   )'s',      (char const   )'e',      (char const   )' ',      (char const   )'&', 
        (char const   )' ',      (char const   )'A',      (char const   )'p',      (char const   )'p', 
        (char const   )'l',      (char const   )'i',      (char const   )'c',      (char const   )'o', 
        (char const   )'m',      (char const   )' ',      (char const   )'I',      (char const   )'n', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )'n', 
        (char const   )'a',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )'a',      (char const   )'l',      (char const   )'\000'};
#line 79 "applicom.c"
static char const   __UNIQUE_ID_description1[46]  __attribute__((__used__, __unused__,
__section__(".modinfo"), __aligned__(1)))  = 
#line 79
  {      (char const   )'d',      (char const   )'e',      (char const   )'s',      (char const   )'c', 
        (char const   )'r',      (char const   )'i',      (char const   )'p',      (char const   )'t', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'=', 
        (char const   )'D',      (char const   )'r',      (char const   )'i',      (char const   )'v', 
        (char const   )'e',      (char const   )'r',      (char const   )' ',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )' ',      (char const   )'A', 
        (char const   )'p',      (char const   )'p',      (char const   )'l',      (char const   )'i', 
        (char const   )'c',      (char const   )'o',      (char const   )'m',      (char const   )' ', 
        (char const   )'P',      (char const   )'r',      (char const   )'o',      (char const   )'f', 
        (char const   )'i',      (char const   )'b',      (char const   )'u',      (char const   )'s', 
        (char const   )' ',      (char const   )'c',      (char const   )'a',      (char const   )'r', 
        (char const   )'d',      (char const   )'\000'};
#line 80 "applicom.c"
static char const   __UNIQUE_ID_license2[12]  __attribute__((__used__, __unused__,
__section__(".modinfo"), __aligned__(1)))  = 
#line 80
  {      (char const   )'l',      (char const   )'i',      (char const   )'c',      (char const   )'e', 
        (char const   )'n',      (char const   )'s',      (char const   )'e',      (char const   )'=', 
        (char const   )'G',      (char const   )'P',      (char const   )'L',      (char const   )'\000'};
#line 81 "applicom.c"
static char const   __UNIQUE_ID_alias3[24]  __attribute__((__used__, __unused__, __section__(".modinfo"),
__aligned__(1)))  = 
#line 81
  {      (char const   )'a',      (char const   )'l',      (char const   )'i',      (char const   )'a', 
        (char const   )'s',      (char const   )'=',      (char const   )'c',      (char const   )'h', 
        (char const   )'a',      (char const   )'r',      (char const   )'-',      (char const   )'m', 
        (char const   )'a',      (char const   )'j',      (char const   )'o',      (char const   )'r', 
        (char const   )'-',      (char const   )'1',      (char const   )'0',      (char const   )'-', 
        (char const   )'1',      (char const   )'5',      (char const   )'7',      (char const   )'\000'};
#line 86 "applicom.c"
static struct applicom_board apbs[8]  ;
#line 94 "applicom.c"
static unsigned int irq  =    0U;
#line 95 "applicom.c"
static unsigned long mem  =    0UL;
#line 97
__inline static unsigned int *__check_irq(void)  __attribute__((__unused__, __no_instrument_function__)) ;
#line 97 "applicom.c"
__inline static unsigned int *__check_irq(void) 
{ 


  {
#line 97
  return (& irq);
}
}
#line 97 "applicom.c"
static char const   __param_str_irq[4]  = {      (char const   )'i',      (char const   )'r',      (char const   )'q',      (char const   )'\000'};
#line 97 "applicom.c"
static struct kernel_param  const  __param_irq  __attribute__((__used__, __unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_irq, (struct kernel_param_ops  const  *)(& param_ops_uint), (u16 )0,
    (s16 )-1, {(void *)(& irq)}};
#line 97 "applicom.c"
static char const   __UNIQUE_ID_irqtype4[18]  __attribute__((__used__, __unused__,
__section__(".modinfo"), __aligned__(1)))  = 
#line 97
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'i',      (char const   )'r',      (char const   )'q', 
        (char const   )':',      (char const   )'u',      (char const   )'i',      (char const   )'n', 
        (char const   )'t',      (char const   )'\000'};
#line 98 "applicom.c"
static char const   __UNIQUE_ID_irq5[35]  __attribute__((__used__, __unused__, __section__(".modinfo"),
__aligned__(1)))  = 
#line 98
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'i',      (char const   )'r',      (char const   )'q', 
        (char const   )':',      (char const   )'I',      (char const   )'R',      (char const   )'Q', 
        (char const   )' ',      (char const   )'o',      (char const   )'f',      (char const   )' ', 
        (char const   )'t',      (char const   )'h',      (char const   )'e',      (char const   )' ', 
        (char const   )'A',      (char const   )'p',      (char const   )'p',      (char const   )'l', 
        (char const   )'i',      (char const   )'c',      (char const   )'o',      (char const   )'m', 
        (char const   )' ',      (char const   )'b',      (char const   )'o',      (char const   )'a', 
        (char const   )'r',      (char const   )'d',      (char const   )'\000'};
#line 99
__inline static unsigned long *__check_mem(void)  __attribute__((__unused__, __no_instrument_function__)) ;
#line 99 "applicom.c"
__inline static unsigned long *__check_mem(void) 
{ 


  {
#line 99
  return (& mem);
}
}
#line 99 "applicom.c"
static char const   __param_str_mem[4]  = {      (char const   )'m',      (char const   )'e',      (char const   )'m',      (char const   )'\000'};
#line 99 "applicom.c"
static struct kernel_param  const  __param_mem  __attribute__((__used__, __unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_mem, (struct kernel_param_ops  const  *)(& param_ops_ulong), (u16 )0,
    (s16 )-1, {(void *)(& mem)}};
#line 99 "applicom.c"
static char const   __UNIQUE_ID_memtype6[19]  __attribute__((__used__, __unused__,
__section__(".modinfo"), __aligned__(1)))  = 
#line 99
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'m',      (char const   )'e',      (char const   )'m', 
        (char const   )':',      (char const   )'u',      (char const   )'l',      (char const   )'o', 
        (char const   )'n',      (char const   )'g',      (char const   )'\000'};
#line 100 "applicom.c"
static char const   __UNIQUE_ID_mem7[49]  __attribute__((__used__, __unused__, __section__(".modinfo"),
__aligned__(1)))  = 
#line 100
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'m',      (char const   )'e',      (char const   )'m', 
        (char const   )':',      (char const   )'S',      (char const   )'h',      (char const   )'a', 
        (char const   )'r',      (char const   )'e',      (char const   )'d',      (char const   )' ', 
        (char const   )'M',      (char const   )'e',      (char const   )'m',      (char const   )'o', 
        (char const   )'r',      (char const   )'y',      (char const   )' ',      (char const   )'A', 
        (char const   )'d',      (char const   )'d',      (char const   )'r',      (char const   )'e', 
        (char const   )'s',      (char const   )'s',      (char const   )' ',      (char const   )'o', 
        (char const   )'f',      (char const   )' ',      (char const   )'A',      (char const   )'p', 
        (char const   )'p',      (char const   )'l',      (char const   )'i',      (char const   )'c', 
        (char const   )'o',      (char const   )'m',      (char const   )' ',      (char const   )'b', 
        (char const   )'o',      (char const   )'a',      (char const   )'r',      (char const   )'d', 
        (char const   )'\000'};
#line 102 "applicom.c"
static unsigned int numboards  ;
#line 103 "applicom.c"
static unsigned char volatile   Dummy  ;
#line 104 "applicom.c"
static wait_queue_head_t FlagSleepRec  =    {{{{{{(__ticketpair_t )0}}, 3735899821U, 4294967295U, (void *)-1L}}}, {& FlagSleepRec.task_list,
                                                                          & FlagSleepRec.task_list}};
#line 105 "applicom.c"
static unsigned int WriteErrorCount  ;
#line 106 "applicom.c"
static unsigned int ReadErrorCount  ;
#line 107 "applicom.c"
static unsigned int DeviceErrorCount  ;
#line 109
static ssize_t ac_read(struct file *filp , char *buf , size_t count , loff_t *ptr ) ;
#line 110
static ssize_t ac_write(struct file *file , char const   *buf , size_t count , loff_t *ppos ) ;
#line 111
static long ac_ioctl(struct file *file , unsigned int cmd , unsigned long arg ) ;
#line 112
static irqreturn_t ac_interrupt(int vec , void *dev_instance ) ;
#line 114 "applicom.c"
static struct file_operations  const  ac_fops  = 
#line 114
     {& __this_module, & no_llseek, & ac_read, & ac_write, (ssize_t (*)(struct kiocb * ,
                                                                      struct iovec  const  * ,
                                                                      unsigned long  ,
                                                                      loff_t  ))0,
    (ssize_t (*)(struct kiocb * , struct iovec  const  * , unsigned long  , loff_t  ))0,
    (ssize_t (*)(struct kiocb * , struct iov_iter * ))0, (ssize_t (*)(struct kiocb * ,
                                                                      struct iov_iter * ))0,
    (int (*)(struct file * , struct dir_context * ))0, (unsigned int (*)(struct file * ,
                                                                         struct poll_table_struct * ))0,
    & ac_ioctl, (long (*)(struct file * , unsigned int  , unsigned long  ))0, (int (*)(struct file * ,
                                                                                       struct vm_area_struct * ))0,
    (int (*)(struct inode * , struct file * ))0, (int (*)(struct file * , fl_owner_t id ))0,
    (int (*)(struct inode * , struct file * ))0, (int (*)(struct file * , loff_t  ,
                                                          loff_t  , int datasync ))0,
    (int (*)(struct kiocb * , int datasync ))0, (int (*)(int  , struct file * , int  ))0,
    (int (*)(struct file * , int  , struct file_lock * ))0, (ssize_t (*)(struct file * ,
                                                                         struct page * ,
                                                                         int  , size_t  ,
                                                                         loff_t * ,
                                                                         int  ))0,
    (unsigned long (*)(struct file * , unsigned long  , unsigned long  , unsigned long  ,
                       unsigned long  ))0, (int (*)(int  ))0, (int (*)(struct file * ,
                                                                       int  , struct file_lock * ))0,
    (ssize_t (*)(struct pipe_inode_info * , struct file * , loff_t * , size_t  , unsigned int  ))0,
    (ssize_t (*)(struct file * , loff_t * , struct pipe_inode_info * , size_t  , unsigned int  ))0,
    (int (*)(struct file * , long  , struct file_lock ** ))0, (long (*)(struct file *file ,
                                                                        int mode ,
                                                                        loff_t offset ,
                                                                        loff_t len ))0,
    (int (*)(struct seq_file *m , struct file *f ))0};
#line 122 "applicom.c"
static struct miscdevice ac_miscdev  = 
#line 122
     {157, "ac", & ac_fops, {(struct list_head *)0, (struct list_head *)0}, (struct device *)0,
    (struct device *)0, (char const   *)0, (unsigned short)0};
#line 128 "applicom.c"
static int dummy  ;
#line 160 "applicom.c"
static struct lock_class_key __key___4  ;
#line 161 "applicom.c"
static struct lock_class_key __key___5  ;
#line 130 "applicom.c"
static int ac_register_board(unsigned long physloc , void *loc , unsigned char boardno ) 
{ 
  unsigned char volatile   byte_reset_it ;
  unsigned char tmp___7 ;
  unsigned char tmp___8 ;
  unsigned char tmp___9 ;
  unsigned char tmp___10 ;
  unsigned char tmp___11 ;

  {
  {
#line 135
  tmp___7 = readb((void const volatile   *)(loc + 18));
  }
#line 135
  if ((int )tmp___7 != 0) {
#line 139
    return (0);
  } else {
    {
#line 135
    tmp___8 = readb((void const volatile   *)((loc + 18) + 1));
    }
#line 135
    if ((int )tmp___8 != 85) {
#line 139
      return (0);
    } else {
      {
#line 135
      tmp___9 = readb((void const volatile   *)((loc + 18) + 2));
      }
#line 135
      if ((int )tmp___9 != 170) {
#line 139
        return (0);
      } else {
        {
#line 135
        tmp___10 = readb((void const volatile   *)((loc + 18) + 3));
        }
#line 135
        if ((int )tmp___10 != 255) {
#line 139
          return (0);
        }
      }
    }
  }
#line 141
  if (! boardno) {
    {
#line 142
    boardno = readb((void const volatile   *)(loc + 2));
    }
  }
#line 144
  if (! boardno) {
    {
#line 145
    printk("\0014Board #%d (at 0x%lx) is out of range (1 <= x <= %d).\n", (int )boardno,
           physloc, 8);
    }
#line 147
    return (0);
  } else
#line 144
  if ((int )boardno > 8) {
    {
#line 145
    printk("\0014Board #%d (at 0x%lx) is out of range (1 <= x <= %d).\n", (int )boardno,
           physloc, 8);
    }
#line 147
    return (0);
  }
#line 150
  if (apbs[(int )boardno - 1].RamIO) {
    {
#line 151
    printk("\0014Board #%d (at 0x%lx) conflicts with previous board #%d (at 0x%lx)\n",
           (int )boardno, physloc, (int )boardno, apbs[(int )boardno - 1].PhysIO);
    }
#line 153
    return (0);
  }
  {
#line 156
  boardno = (unsigned char )((int )boardno - 1);
#line 158
  apbs[boardno].PhysIO = physloc;
#line 159
  apbs[boardno].RamIO = loc;
  }
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 160
    __init_waitqueue_head(& apbs[boardno].FlagSleepSend, "&apbs[boardno].FlagSleepSend",
                          & __key___4);
    }
#line 160
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 161
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 161
    spinlock_check(& apbs[boardno].mutex);
    }
    {
#line 161
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 161
      __raw_spin_lock_init(& apbs[boardno].mutex.__annonCompField18.rlock, "&(&apbs[boardno].mutex)->rlock",
                           & __key___5);
      }
#line 161
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 161
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 162
  tmp___11 = readb((void const volatile   *)(loc + 1023));
#line 162
  byte_reset_it = (unsigned char volatile   )tmp___11;
#line 164
  numboards ++;
  }
#line 165
  return ((int )boardno + 1);
}
}
#line 168
static void __attribute__((__cold__))  applicom_exit(void)  __attribute__((__section__(".exit.text"),
__no_instrument_function__)) ;
#line 168 "applicom.c"
static void __attribute__((__cold__))  applicom_exit(void) 
{ 
  unsigned int i ;

  {
  {
#line 172
  misc_deregister(& ac_miscdev);
#line 174
  i = 0U;
  }
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if (! (i < 8U)) {
#line 174
      goto while_break;
    }
#line 176
    if (! apbs[i].RamIO) {
#line 177
      goto __Cont;
    }
#line 179
    if (apbs[i].irq) {
      {
#line 180
      free_irq((unsigned int )apbs[i].irq, (void *)(& dummy));
      }
    }
    {
#line 182
    iounmap((void volatile   *)apbs[i].RamIO);
    }
    __Cont: /* CIL Label */ 
    {
#line 174
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  return;
}
}
#line 295 "applicom.c"
static struct lock_class_key __key___6  ;
#line 186
static int __attribute__((__cold__))  applicom_init(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 186 "applicom.c"
static int __attribute__((__cold__))  applicom_init(void) 
{ 
  int i ;
  int numisa ;
  struct pci_dev *dev ;
  void *RamIO ;
  int boardno ;
  int ret ;
  struct pci_device_id  const  *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int serial ;
  char boardname[27] ;
  unsigned char tmp___11 ;
  unsigned char tmp___12 ;
  unsigned char tmp___13 ;
  unsigned char tmp___14 ;
  unsigned char tmp___15 ;
  unsigned char tmp___16 ;

  {
  {
#line 188
  numisa = 0;
#line 189
  dev = (struct pci_dev *)((void *)0);
#line 193
  printk("\0016Applicom driver: $Id: ac.c,v 1.30 2000/03/22 16:03:57 dwmw2 Exp $\n");
  }
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 197
    dev = pci_get_class((unsigned int )(255 << 16), dev);
    }
#line 197
    if (! dev) {
#line 197
      goto while_break;
    }
    {
#line 199
    tmp___7 = pci_match_id((struct pci_device_id  const  *)(applicom_pci_tbl), dev);
    }
#line 199
    if (! tmp___7) {
#line 200
      goto while_continue;
    }
    {
#line 202
    tmp___8 = pci_enable_device(dev);
    }
#line 202
    if (tmp___8) {
#line 203
      return ((int __attribute__((__cold__))  )-5);
    }
    {
#line 205
    RamIO = ioremap_nocache(dev->resource[0].start, 2048UL);
    }
#line 207
    if (! RamIO) {
      {
#line 208
      printk("\0016ac.o: Failed to ioremap PCI memory space at 0x%llx\n", dev->resource[0].start);
#line 211
      pci_disable_device(dev);
      }
#line 212
      return ((int __attribute__((__cold__))  )-5);
    }
    {
#line 215
    printk("\0016Applicom %s found at mem 0x%llx, irq %d\n", applicom_pci_devnames[(int )dev->device - 1],
           dev->resource[0].start, dev->irq);
#line 220
    boardno = ac_register_board((unsigned long )dev->resource[0].start, RamIO, (unsigned char)0);
    }
#line 222
    if (! boardno) {
      {
#line 223
      printk("\0016ac.o: PCI Applicom device doesn\'t have correct signature.\n");
#line 224
      iounmap((void volatile   *)RamIO);
#line 225
      pci_disable_device(dev);
      }
#line 226
      goto while_continue;
    }
    {
#line 229
    tmp___9 = request_irq(dev->irq, & ac_interrupt, 128UL, "Applicom PCI", (void *)(& dummy));
    }
#line 229
    if (tmp___9) {
      {
#line 230
      printk("\0016Could not allocate IRQ %d for PCI Applicom device.\n", dev->irq);
#line 231
      iounmap((void volatile   *)RamIO);
#line 232
      pci_disable_device(dev);
#line 233
      apbs[boardno - 1].RamIO = (void *)0;
      }
#line 234
      goto while_continue;
    }
    {
#line 239
    writeb((unsigned char)64, (void volatile   *)(apbs[boardno - 1].RamIO + 1022));
#line 241
    apbs[boardno - 1].irq = (long )dev->irq;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 247
  if (! mem) {
#line 247
    goto _L;
  } else
#line 247
  if (! irq) {
    _L: /* CIL Label */ 
#line 248
    if (numboards) {
#line 249
      goto fin;
    } else {
      {
#line 251
      printk("\0016ac.o: No PCI boards found.\n");
#line 252
      printk("\0016ac.o: For an ISA board you must supply memory and irq parameters.\n");
      }
#line 253
      return ((int __attribute__((__cold__))  )-6);
    }
  }
  {
#line 259
  i = 0;
  }
  {
#line 259
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 259
    if (! (i < 4)) {
#line 259
      goto while_break___0;
    }
    {
#line 260
    RamIO = ioremap_nocache((resource_size_t )(mem + (unsigned long )(2048 * i)),
                            2048UL);
    }
#line 262
    if (! RamIO) {
      {
#line 263
      printk("\0016ac.o: Failed to ioremap the ISA card\'s memory space (slot #%d)\n",
             i + 1);
      }
#line 264
      goto __Cont;
    }
    {
#line 267
    boardno = ac_register_board(mem + (unsigned long )(2048 * i), RamIO, (unsigned char )(i + 1));
    }
#line 267
    if (! boardno) {
      {
#line 269
      iounmap((void volatile   *)RamIO);
      }
#line 270
      goto __Cont;
    }
    {
#line 273
    printk("\0015Applicom ISA card found at mem 0x%lx, irq %d\n", mem + (unsigned long )(2048 * i),
           irq);
    }
#line 275
    if (! numisa) {
      {
#line 276
      tmp___10 = request_irq(irq, & ac_interrupt, 128UL, "Applicom ISA", (void *)(& dummy));
      }
#line 276
      if (tmp___10) {
        {
#line 277
        printk("\0014Could not allocate IRQ %d for ISA Applicom device.\n", irq);
#line 278
        iounmap((void volatile   *)RamIO);
#line 279
        apbs[boardno - 1].RamIO = (void *)0;
        }
      } else {
        {
#line 282
        apbs[boardno - 1].irq = (long )irq;
        }
      }
    } else {
      {
#line 285
      apbs[boardno - 1].irq = 0L;
      }
    }
    {
#line 287
    numisa ++;
    }
    __Cont: /* CIL Label */ 
    {
#line 259
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 290
  if (! numisa) {
    {
#line 291
    printk("\0014ac.o: No valid ISA Applicom boards found at mem 0x%lx\n", mem);
    }
  }
  fin: 
  {
#line 295
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 295
    __init_waitqueue_head(& FlagSleepRec, "&FlagSleepRec", & __key___6);
    }
#line 295
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 297
  WriteErrorCount = 0U;
#line 298
  ReadErrorCount = 0U;
#line 299
  DeviceErrorCount = 0U;
  }
#line 301
  if (numboards) {
    {
#line 302
    ret = misc_register(& ac_miscdev);
    }
#line 303
    if (ret) {
      {
#line 304
      printk("\0014ac.o: Unable to register misc device\n");
      }
#line 305
      goto out;
    }
    {
#line 307
    i = 0;
    }
    {
#line 307
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 307
      if (! (i < 8)) {
#line 307
        goto while_break___2;
      }
#line 311
      if (! apbs[i].RamIO) {
#line 312
        goto __Cont___0;
      }
      {
#line 314
      serial = 0;
      }
      {
#line 314
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 314
        if (! (serial < 26)) {
#line 314
          goto while_break___3;
        }
        {
#line 315
        tmp___11 = readb((void const volatile   *)((apbs[i].RamIO + 960) + serial));
#line 315
        boardname[serial] = (char )tmp___11;
#line 314
        serial ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 317
      boardname[serial] = (char)0;
#line 320
      tmp___12 = readb((void const volatile   *)(apbs[i].RamIO + 30));
#line 320
      tmp___13 = readb((void const volatile   *)(apbs[i].RamIO + 30));
#line 320
      printk("\0016Applicom board %d: %s, PROM V%d.%d", i + 1, boardname, (int )tmp___13 >> 4,
             (int )tmp___12 & 15);
#line 325
      tmp___14 = readb((void const volatile   *)(apbs[i].RamIO + 986));
#line 325
      tmp___15 = readb((void const volatile   *)((apbs[i].RamIO + 986) + 1));
#line 325
      tmp___16 = readb((void const volatile   *)((apbs[i].RamIO + 986) + 2));
#line 325
      serial = (((int )tmp___14 << 16) + ((int )tmp___15 << 8)) + (int )tmp___16;
      }
#line 329
      if (serial != 0) {
        {
#line 330
        printk(" S/N %d\n", serial);
        }
      } else {
        {
#line 332
        printk("\n");
        }
      }
      __Cont___0: /* CIL Label */ 
      {
#line 307
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 334
    return ((int __attribute__((__cold__))  )0);
  } else {
#line 338
    return ((int __attribute__((__cold__))  )-6);
  }
  out: 
  {
#line 341
  i = 0;
  }
  {
#line 341
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 341
    if (! (i < 8)) {
#line 341
      goto while_break___4;
    }
#line 342
    if (! apbs[i].RamIO) {
#line 343
      goto __Cont___1;
    }
#line 344
    if (apbs[i].irq) {
      {
#line 345
      free_irq((unsigned int )apbs[i].irq, (void *)(& dummy));
      }
    }
    {
#line 346
    iounmap((void volatile   *)apbs[i].RamIO);
    }
    __Cont___1: /* CIL Label */ 
    {
#line 341
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 348
  return ((int __attribute__((__cold__))  )ret);
}
}
#line 351
__inline static initcall_t __inittest(void)  __attribute__((__no_instrument_function__)) ;
#line 351 "applicom.c"
__inline static initcall_t __inittest(void) 
{ 


  {
#line 351
  return ((initcall_t )(& applicom_init));
}
}
#line 351 "applicom.c"
int init_module(void) 
{ 
  int __attribute__((__cold__))  tmp___7 ;

  {
  {
#line 351
  tmp___7 = applicom_init();
  }
#line 351
  return ((int )tmp___7);
}
}
#line 352
__inline static exitcall_t __exittest(void)  __attribute__((__no_instrument_function__)) ;
#line 352 "applicom.c"
__inline static exitcall_t __exittest(void) 
{ 


  {
#line 352
  return ((exitcall_t )(& applicom_exit));
}
}
#line 352 "applicom.c"
void cleanup_module(void) 
{ 


  {
  {
#line 352
  applicom_exit();
  }
#line 352
  return;
}
}
#line 369
static ssize_t ac_write(struct file *file , char const   *buf , size_t count , loff_t *ppos ) ;
#line 369 "applicom.c"
static int warncount  =    5;
#line 355 "applicom.c"
static ssize_t ac_write(struct file *file , char const   *buf , size_t count , loff_t *ppos ) 
{ 
  unsigned int NumCard ;
  unsigned int IndexCard ;
  unsigned char TicCard ;
  unsigned long flags ;
  struct st_ram_io st_loc ;
  struct mailbox tmpmailbox ;
  wait_queue_t wait ;
  struct task_struct *tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  raw_spinlock_t *tmp___10 ;
  unsigned char tmp___11 ;
  unsigned char tmp___12 ;
  unsigned char tmp___13 ;
  struct task_struct *tmp___14 ;
  long volatile   __ret ;
  struct task_struct *tmp___15 ;
  struct task_struct *tmp___16 ;
  struct task_struct *tmp___17 ;
  struct task_struct *tmp___18 ;
  struct task_struct *tmp___19 ;
  unsigned char tmp___20 ;
  struct task_struct *tmp___21 ;
  int tmp___22 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;
  raw_spinlock_t *tmp___23 ;
  struct task_struct *tmp___24 ;
  long volatile   __ret___0 ;
  struct task_struct *tmp___25 ;
  struct task_struct *tmp___26 ;
  struct task_struct *tmp___27 ;
  struct task_struct *tmp___28 ;
  struct task_struct *tmp___29 ;
  unsigned char tmp___30 ;
  struct task_struct *tmp___31 ;
  long volatile   __ret___1 ;
  struct task_struct *tmp___32 ;
  struct task_struct *tmp___33 ;
  struct task_struct *tmp___34 ;
  struct task_struct *tmp___35 ;
  struct task_struct *tmp___36 ;
  unsigned char *from ;
  void *to ;
  int c ;
  void *tmp___37 ;
  unsigned char *tmp___38 ;
  unsigned char tmp___39 ;

  {
  {
#line 366
  tmp___7 = get_current();
#line 366
  wait.flags = 0U;
#line 366
  wait.private = (void *)tmp___7;
#line 366
  wait.func = & default_wake_function;
#line 366
  wait.task_list.next = (struct list_head *)((void *)0);
#line 366
  wait.task_list.prev = (struct list_head *)((void *)0);
  }
#line 368
  if (count != sizeof(struct st_ram_io ) + sizeof(struct mailbox )) {
#line 370
    if (warncount) {
      {
#line 371
      printk("\0016Hmmm. write() of Applicom card, length %zd != expected %zd\n",
             count, sizeof(struct st_ram_io ) + sizeof(struct mailbox ));
#line 373
      warncount --;
      }
    }
#line 375
    return ((ssize_t )-22);
  }
  {
#line 378
  tmp___8 = copy_from_user((void *)(& st_loc), (void const   *)buf, sizeof(struct st_ram_io ));
  }
#line 378
  if (tmp___8) {
#line 379
    return ((ssize_t )-14);
  }
  {
#line 381
  tmp___9 = copy_from_user((void *)(& tmpmailbox), (void const   *)(buf + sizeof(struct st_ram_io )),
                           sizeof(struct mailbox ));
  }
#line 381
  if (tmp___9) {
#line 383
    return ((ssize_t )-14);
  }
  {
#line 385
  NumCard = (unsigned int )st_loc.num_card;
#line 386
  TicCard = st_loc.tic_des_from_pc;
#line 387
  IndexCard = NumCard - 1U;
  }
#line 389
  if (NumCard < 1U) {
#line 390
    return ((ssize_t )-22);
  } else
#line 389
  if (NumCard > 8U) {
#line 390
    return ((ssize_t )-22);
  } else
#line 389
  if (! apbs[IndexCard].RamIO) {
#line 390
    return ((ssize_t )-22);
  }
  {
#line 418
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 418
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 418
      tmp___10 = spinlock_check(& apbs[IndexCard].mutex);
#line 418
      flags = _raw_spin_lock_irqsave(tmp___10);
      }
#line 418
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 418
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 421
  tmp___13 = readb((void const volatile   *)(apbs[IndexCard].RamIO + 5));
  }
#line 421
  if ((int )tmp___13 > 2) {
    {
#line 422
    tmp___11 = readb((void const volatile   *)(apbs[IndexCard].RamIO + 30));
#line 422
    Dummy = (unsigned char volatile   )tmp___11;
#line 423
    spin_unlock_irqrestore(& apbs[IndexCard].mutex, flags);
#line 424
    tmp___12 = readb((void const volatile   *)(apbs[IndexCard].RamIO + 5));
#line 424
    printk("\0014APPLICOM driver write error board %d, DataFromPcReady = %d\n", IndexCard,
           (int )tmp___12);
#line 426
    DeviceErrorCount ++;
    }
#line 427
    return ((ssize_t )-5);
  }
  {
#line 431
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 431
    __ret = (long volatile   )1;
    }
    {
#line 431
    if (sizeof(tmp___15->state) == 1UL) {
#line 431
      goto case_1;
    }
#line 431
    if (sizeof(tmp___15->state) == 2UL) {
#line 431
      goto case_2;
    }
#line 431
    if (sizeof(tmp___15->state) == 4UL) {
#line 431
      goto case_4;
    }
#line 431
    if (sizeof(tmp___15->state) == 8UL) {
#line 431
      goto case_8;
    }
#line 431
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 431
    tmp___16 = get_current();
#line 431
    __asm__  volatile   (""
                         "xchg"
                         "b %b0, %1\n": "+q" (__ret), "+m" (tmp___16->state): : "memory",
                         "cc");
    }
#line 431
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 431
    tmp___17 = get_current();
#line 431
    __asm__  volatile   (""
                         "xchg"
                         "w %w0, %1\n": "+r" (__ret), "+m" (tmp___17->state): : "memory",
                         "cc");
    }
#line 431
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 431
    tmp___18 = get_current();
#line 431
    __asm__  volatile   (""
                         "xchg"
                         "l %0, %1\n": "+r" (__ret), "+m" (tmp___18->state): : "memory",
                         "cc");
    }
#line 431
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 431
    tmp___19 = get_current();
#line 431
    __asm__  volatile   (""
                         "xchg"
                         "q %q0, %1\n": "+r" (__ret), "+m" (tmp___19->state): : "memory",
                         "cc");
    }
#line 431
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 431
    __xchg_wrong_size();
    }
    switch_break: /* CIL Label */ ;
    }
#line 431
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 432
  add_wait_queue(& apbs[IndexCard].FlagSleepSend, & wait);
  }
  {
#line 435
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 435
    tmp___30 = readb((void const volatile   *)(apbs[IndexCard].RamIO + 5));
    }
#line 435
    if (! ((int )tmp___30 != 0)) {
#line 435
      goto while_break___2;
    }
    {
#line 436
    tmp___20 = readb((void const volatile   *)(apbs[IndexCard].RamIO + 30));
#line 436
    Dummy = (unsigned char volatile   )tmp___20;
#line 439
    spin_unlock_irqrestore(& apbs[IndexCard].mutex, flags);
#line 440
    schedule();
#line 441
    tmp___21 = get_current();
#line 441
    tmp___22 = signal_pending(tmp___21);
    }
#line 441
    if (tmp___22) {
      {
#line 442
      remove_wait_queue(& apbs[IndexCard].FlagSleepSend, & wait);
      }
#line 444
      return ((ssize_t )-4);
    }
    {
#line 446
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 446
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 446
        tmp___23 = spinlock_check(& apbs[IndexCard].mutex);
#line 446
        flags = _raw_spin_lock_irqsave(tmp___23);
        }
#line 446
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 446
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 447
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 447
      __ret___0 = (long volatile   )1;
      }
      {
#line 447
      if (sizeof(tmp___25->state) == 1UL) {
#line 447
        goto case_1___0;
      }
#line 447
      if (sizeof(tmp___25->state) == 2UL) {
#line 447
        goto case_2___0;
      }
#line 447
      if (sizeof(tmp___25->state) == 4UL) {
#line 447
        goto case_4___0;
      }
#line 447
      if (sizeof(tmp___25->state) == 8UL) {
#line 447
        goto case_8___0;
      }
#line 447
      goto switch_default___0;
      case_1___0: /* CIL Label */ 
      {
#line 447
      tmp___26 = get_current();
#line 447
      __asm__  volatile   (""
                           "xchg"
                           "b %b0, %1\n": "+q" (__ret___0), "+m" (tmp___26->state): : "memory",
                           "cc");
      }
#line 447
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
      {
#line 447
      tmp___27 = get_current();
#line 447
      __asm__  volatile   (""
                           "xchg"
                           "w %w0, %1\n": "+r" (__ret___0), "+m" (tmp___27->state): : "memory",
                           "cc");
      }
#line 447
      goto switch_break___0;
      case_4___0: /* CIL Label */ 
      {
#line 447
      tmp___28 = get_current();
#line 447
      __asm__  volatile   (""
                           "xchg"
                           "l %0, %1\n": "+r" (__ret___0), "+m" (tmp___28->state): : "memory",
                           "cc");
      }
#line 447
      goto switch_break___0;
      case_8___0: /* CIL Label */ 
      {
#line 447
      tmp___29 = get_current();
#line 447
      __asm__  volatile   (""
                           "xchg"
                           "q %q0, %1\n": "+r" (__ret___0), "+m" (tmp___29->state): : "memory",
                           "cc");
      }
#line 447
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
      {
#line 447
      __xchg_wrong_size();
      }
      switch_break___0: /* CIL Label */ ;
      }
#line 447
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 451
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 451
    __ret___1 = (long volatile   )0;
    }
    {
#line 451
    if (sizeof(tmp___32->state) == 1UL) {
#line 451
      goto case_1___1;
    }
#line 451
    if (sizeof(tmp___32->state) == 2UL) {
#line 451
      goto case_2___1;
    }
#line 451
    if (sizeof(tmp___32->state) == 4UL) {
#line 451
      goto case_4___1;
    }
#line 451
    if (sizeof(tmp___32->state) == 8UL) {
#line 451
      goto case_8___1;
    }
#line 451
    goto switch_default___1;
    case_1___1: /* CIL Label */ 
    {
#line 451
    tmp___33 = get_current();
#line 451
    __asm__  volatile   (""
                         "xchg"
                         "b %b0, %1\n": "+q" (__ret___1), "+m" (tmp___33->state): : "memory",
                         "cc");
    }
#line 451
    goto switch_break___1;
    case_2___1: /* CIL Label */ 
    {
#line 451
    tmp___34 = get_current();
#line 451
    __asm__  volatile   (""
                         "xchg"
                         "w %w0, %1\n": "+r" (__ret___1), "+m" (tmp___34->state): : "memory",
                         "cc");
    }
#line 451
    goto switch_break___1;
    case_4___1: /* CIL Label */ 
    {
#line 451
    tmp___35 = get_current();
#line 451
    __asm__  volatile   (""
                         "xchg"
                         "l %0, %1\n": "+r" (__ret___1), "+m" (tmp___35->state): : "memory",
                         "cc");
    }
#line 451
    goto switch_break___1;
    case_8___1: /* CIL Label */ 
    {
#line 451
    tmp___36 = get_current();
#line 451
    __asm__  volatile   (""
                         "xchg"
                         "q %q0, %1\n": "+r" (__ret___1), "+m" (tmp___36->state): : "memory",
                         "cc");
    }
#line 451
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
    {
#line 451
    __xchg_wrong_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
#line 451
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 452
  remove_wait_queue(& apbs[IndexCard].FlagSleepSend, & wait);
#line 454
  writeb((unsigned char)1, (void volatile   *)(apbs[IndexCard].RamIO + 5));
#line 460
  from = (unsigned char *)(& tmpmailbox);
#line 461
  to = apbs[IndexCard].RamIO + 368;
#line 464
  c = 0;
  }
  {
#line 464
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 464
    if (! ((unsigned long )c < sizeof(struct mailbox ))) {
#line 464
      goto while_break___7;
    }
    {
#line 465
    tmp___37 = to;
#line 465
    to ++;
#line 465
    tmp___38 = from;
#line 465
    from ++;
#line 465
    writeb(*tmp___38, (void volatile   *)tmp___37);
#line 464
    c ++;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 468
  writeb((unsigned char)32, (void volatile   *)(apbs[IndexCard].RamIO + 6));
#line 469
  writeb((unsigned char)255, (void volatile   *)(apbs[IndexCard].RamIO + 7));
#line 470
  writeb(TicCard, (void volatile   *)(apbs[IndexCard].RamIO + 8));
#line 471
  writeb((unsigned char )NumCard, (void volatile   *)(apbs[IndexCard].RamIO + 9));
#line 472
  writeb((unsigned char)2, (void volatile   *)(apbs[IndexCard].RamIO + 5));
#line 473
  writeb((unsigned char)1, (void volatile   *)(apbs[IndexCard].RamIO + 1022));
#line 474
  tmp___39 = readb((void const volatile   *)(apbs[IndexCard].RamIO + 30));
#line 474
  Dummy = (unsigned char volatile   )tmp___39;
#line 475
  spin_unlock_irqrestore(& apbs[IndexCard].mutex, flags);
  }
#line 476
  return ((ssize_t )0);
}
}
#line 479 "applicom.c"
static int do_ac_read(int IndexCard , char *buf , struct st_ram_io *st_loc , struct mailbox *mailbox ) 
{ 
  void *from ;
  unsigned char *to ;
  int c ;
  unsigned char *tmp___7 ;
  void *tmp___8 ;
  unsigned char tmp___9 ;
  unsigned char tmp___10 ;

  {
  {
#line 482
  from = apbs[IndexCard].RamIO + 64;
#line 483
  to = (unsigned char *)mailbox;
#line 488
  st_loc->tic_owner_to_pc = readb((void const volatile   *)(apbs[IndexCard].RamIO + 1));
#line 489
  st_loc->numcard_owner_to_pc = readb((void const volatile   *)(apbs[IndexCard].RamIO + 2));
#line 495
  c = 0;
  }
  {
#line 495
  while (1) {
    while_continue: /* CIL Label */ ;
#line 495
    if (! ((unsigned long )c < sizeof(struct mailbox ))) {
#line 495
      goto while_break;
    }
    {
#line 496
    tmp___7 = to;
#line 496
    to ++;
#line 496
    tmp___8 = from;
#line 496
    from ++;
#line 496
    *tmp___7 = readb((void const volatile   *)tmp___8);
#line 495
    c ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 498
  writeb((unsigned char)1, (void volatile   *)(apbs[IndexCard].RamIO + 14));
#line 499
  writeb((unsigned char)1, (void volatile   *)(apbs[IndexCard].RamIO + 17));
#line 500
  writeb((unsigned char )(IndexCard + 1), (void volatile   *)(apbs[IndexCard].RamIO + 16));
#line 501
  tmp___9 = readb((void const volatile   *)(apbs[IndexCard].RamIO + 1));
#line 501
  writeb(tmp___9, (void volatile   *)(apbs[IndexCard].RamIO + 15));
#line 503
  writeb((unsigned char)2, (void volatile   *)(apbs[IndexCard].RamIO + 14));
#line 504
  writeb((unsigned char)0, (void volatile   *)(apbs[IndexCard].RamIO + 0));
#line 505
  writeb((unsigned char)2, (void volatile   *)(apbs[IndexCard].RamIO + 1022));
#line 506
  tmp___10 = readb((void const volatile   *)(apbs[IndexCard].RamIO + 30));
#line 506
  Dummy = (unsigned char volatile   )tmp___10;
  }
#line 530
  return ((int )(sizeof(struct st_ram_io ) + sizeof(struct mailbox )));
}
}
#line 533 "applicom.c"
static ssize_t ac_read(struct file *filp , char *buf , size_t count , loff_t *ptr ) 
{ 
  unsigned long flags ;
  unsigned int i ;
  unsigned char tmp___7 ;
  int ret ;
  wait_queue_t wait ;
  struct task_struct *tmp___8 ;
  struct task_struct *tmp___9 ;
  long volatile   __ret ;
  struct task_struct *tmp___10 ;
  struct task_struct *tmp___11 ;
  struct task_struct *tmp___12 ;
  struct task_struct *tmp___13 ;
  struct task_struct *tmp___14 ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  raw_spinlock_t *tmp___15 ;
  struct st_ram_io st_loc ;
  struct mailbox mailbox ;
  struct task_struct *tmp___16 ;
  long volatile   __ret___0 ;
  struct task_struct *tmp___17 ;
  struct task_struct *tmp___18 ;
  struct task_struct *tmp___19 ;
  struct task_struct *tmp___20 ;
  struct task_struct *tmp___21 ;
  unsigned long tmp___22 ;
  unsigned long tmp___23 ;
  unsigned char tmp___24 ;
  struct task_struct *tmp___25 ;
  long volatile   __ret___1 ;
  struct task_struct *tmp___26 ;
  struct task_struct *tmp___27 ;
  struct task_struct *tmp___28 ;
  struct task_struct *tmp___29 ;
  struct task_struct *tmp___30 ;
  unsigned char tmp___31 ;
  unsigned char tmp___32 ;
  struct task_struct *tmp___33 ;
  int tmp___34 ;

  {
  {
#line 538
  ret = 0;
#line 539
  tmp___8 = get_current();
#line 539
  wait.flags = 0U;
#line 539
  wait.private = (void *)tmp___8;
#line 539
  wait.func = & default_wake_function;
#line 539
  wait.task_list.next = (struct list_head *)((void *)0);
#line 539
  wait.task_list.prev = (struct list_head *)((void *)0);
  }
#line 544
  if (count != sizeof(struct st_ram_io ) + sizeof(struct mailbox )) {
    {
#line 545
    printk("\0014Hmmm. read() of Applicom card, length %zd != expected %zd\n", count,
           sizeof(struct st_ram_io ) + sizeof(struct mailbox ));
    }
#line 547
    return ((ssize_t )-22);
  }
  {
#line 550
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 552
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 552
      __ret = (long volatile   )1;
      }
      {
#line 552
      if (sizeof(tmp___10->state) == 1UL) {
#line 552
        goto case_1;
      }
#line 552
      if (sizeof(tmp___10->state) == 2UL) {
#line 552
        goto case_2;
      }
#line 552
      if (sizeof(tmp___10->state) == 4UL) {
#line 552
        goto case_4;
      }
#line 552
      if (sizeof(tmp___10->state) == 8UL) {
#line 552
        goto case_8;
      }
#line 552
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 552
      tmp___11 = get_current();
#line 552
      __asm__  volatile   (""
                           "xchg"
                           "b %b0, %1\n": "+q" (__ret), "+m" (tmp___11->state): : "memory",
                           "cc");
      }
#line 552
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 552
      tmp___12 = get_current();
#line 552
      __asm__  volatile   (""
                           "xchg"
                           "w %w0, %1\n": "+r" (__ret), "+m" (tmp___12->state): : "memory",
                           "cc");
      }
#line 552
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 552
      tmp___13 = get_current();
#line 552
      __asm__  volatile   (""
                           "xchg"
                           "l %0, %1\n": "+r" (__ret), "+m" (tmp___13->state): : "memory",
                           "cc");
      }
#line 552
      goto switch_break;
      case_8: /* CIL Label */ 
      {
#line 552
      tmp___14 = get_current();
#line 552
      __asm__  volatile   (""
                           "xchg"
                           "q %q0, %1\n": "+r" (__ret), "+m" (tmp___14->state): : "memory",
                           "cc");
      }
#line 552
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 552
      __xchg_wrong_size();
      }
      switch_break: /* CIL Label */ ;
      }
#line 552
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 553
    add_wait_queue(& FlagSleepRec, & wait);
#line 556
    i = 0U;
    }
    {
#line 556
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 556
      if (! (i < 8U)) {
#line 556
        goto while_break___1;
      }
#line 557
      if (! apbs[i].RamIO) {
#line 558
        goto __Cont;
      }
      {
#line 559
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 559
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 559
          tmp___15 = spinlock_check(& apbs[i].mutex);
#line 559
          flags = _raw_spin_lock_irqsave(tmp___15);
          }
#line 559
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 559
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 561
      tmp___7 = readb((void const volatile   *)(apbs[i].RamIO + 0));
      }
#line 563
      if ((int )tmp___7 == 2) {
        {
#line 568
        memset((void *)(& st_loc), 0, sizeof(st_loc));
#line 569
        ret = do_ac_read((int )i, buf, & st_loc, & mailbox);
#line 570
        spin_unlock_irqrestore(& apbs[i].mutex, flags);
        }
        {
#line 571
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 571
          __ret___0 = (long volatile   )0;
          }
          {
#line 571
          if (sizeof(tmp___17->state) == 1UL) {
#line 571
            goto case_1___0;
          }
#line 571
          if (sizeof(tmp___17->state) == 2UL) {
#line 571
            goto case_2___0;
          }
#line 571
          if (sizeof(tmp___17->state) == 4UL) {
#line 571
            goto case_4___0;
          }
#line 571
          if (sizeof(tmp___17->state) == 8UL) {
#line 571
            goto case_8___0;
          }
#line 571
          goto switch_default___0;
          case_1___0: /* CIL Label */ 
          {
#line 571
          tmp___18 = get_current();
#line 571
          __asm__  volatile   (""
                               "xchg"
                               "b %b0, %1\n": "+q" (__ret___0), "+m" (tmp___18->state): : "memory",
                               "cc");
          }
#line 571
          goto switch_break___0;
          case_2___0: /* CIL Label */ 
          {
#line 571
          tmp___19 = get_current();
#line 571
          __asm__  volatile   (""
                               "xchg"
                               "w %w0, %1\n": "+r" (__ret___0), "+m" (tmp___19->state): : "memory",
                               "cc");
          }
#line 571
          goto switch_break___0;
          case_4___0: /* CIL Label */ 
          {
#line 571
          tmp___20 = get_current();
#line 571
          __asm__  volatile   (""
                               "xchg"
                               "l %0, %1\n": "+r" (__ret___0), "+m" (tmp___20->state): : "memory",
                               "cc");
          }
#line 571
          goto switch_break___0;
          case_8___0: /* CIL Label */ 
          {
#line 571
          tmp___21 = get_current();
#line 571
          __asm__  volatile   (""
                               "xchg"
                               "q %q0, %1\n": "+r" (__ret___0), "+m" (tmp___21->state): : "memory",
                               "cc");
          }
#line 571
          goto switch_break___0;
          switch_default___0: /* CIL Label */ 
          {
#line 571
          __xchg_wrong_size();
          }
          switch_break___0: /* CIL Label */ ;
          }
#line 571
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 572
        remove_wait_queue(& FlagSleepRec, & wait);
#line 574
        tmp___22 = copy_to_user((void *)buf, (void const   *)(& st_loc), sizeof(st_loc));
        }
#line 574
        if (tmp___22) {
#line 575
          return ((ssize_t )-14);
        }
        {
#line 576
        tmp___23 = copy_to_user((void *)(buf + sizeof(st_loc)), (void const   *)(& mailbox),
                                sizeof(mailbox));
        }
#line 576
        if (tmp___23) {
#line 577
          return ((ssize_t )-14);
        }
#line 578
        return ((ssize_t )tmp___7);
      }
#line 581
      if ((int )tmp___7 > 2) {
        {
#line 583
        tmp___24 = readb((void const volatile   *)(apbs[i].RamIO + 30));
#line 583
        Dummy = (unsigned char volatile   )tmp___24;
#line 585
        spin_unlock_irqrestore(& apbs[i].mutex, flags);
        }
        {
#line 586
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 586
          __ret___1 = (long volatile   )0;
          }
          {
#line 586
          if (sizeof(tmp___26->state) == 1UL) {
#line 586
            goto case_1___1;
          }
#line 586
          if (sizeof(tmp___26->state) == 2UL) {
#line 586
            goto case_2___1;
          }
#line 586
          if (sizeof(tmp___26->state) == 4UL) {
#line 586
            goto case_4___1;
          }
#line 586
          if (sizeof(tmp___26->state) == 8UL) {
#line 586
            goto case_8___1;
          }
#line 586
          goto switch_default___1;
          case_1___1: /* CIL Label */ 
          {
#line 586
          tmp___27 = get_current();
#line 586
          __asm__  volatile   (""
                               "xchg"
                               "b %b0, %1\n": "+q" (__ret___1), "+m" (tmp___27->state): : "memory",
                               "cc");
          }
#line 586
          goto switch_break___1;
          case_2___1: /* CIL Label */ 
          {
#line 586
          tmp___28 = get_current();
#line 586
          __asm__  volatile   (""
                               "xchg"
                               "w %w0, %1\n": "+r" (__ret___1), "+m" (tmp___28->state): : "memory",
                               "cc");
          }
#line 586
          goto switch_break___1;
          case_4___1: /* CIL Label */ 
          {
#line 586
          tmp___29 = get_current();
#line 586
          __asm__  volatile   (""
                               "xchg"
                               "l %0, %1\n": "+r" (__ret___1), "+m" (tmp___29->state): : "memory",
                               "cc");
          }
#line 586
          goto switch_break___1;
          case_8___1: /* CIL Label */ 
          {
#line 586
          tmp___30 = get_current();
#line 586
          __asm__  volatile   (""
                               "xchg"
                               "q %q0, %1\n": "+r" (__ret___1), "+m" (tmp___30->state): : "memory",
                               "cc");
          }
#line 586
          goto switch_break___1;
          switch_default___1: /* CIL Label */ 
          {
#line 586
          __xchg_wrong_size();
          }
          switch_break___1: /* CIL Label */ ;
          }
#line 586
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
        {
#line 587
        remove_wait_queue(& FlagSleepRec, & wait);
#line 589
        tmp___31 = readb((void const volatile   *)(apbs[i].RamIO + 0));
#line 589
        printk("\0014APPLICOM driver read error board %d, DataToPcReady = %d\n", i,
               (int )tmp___31);
#line 591
        DeviceErrorCount ++;
        }
#line 592
        return ((ssize_t )-5);
      }
      {
#line 596
      tmp___32 = readb((void const volatile   *)(apbs[i].RamIO + 30));
#line 596
      Dummy = (unsigned char volatile   )tmp___32;
#line 597
      spin_unlock_irqrestore(& apbs[i].mutex, flags);
      }
      __Cont: /* CIL Label */ 
      {
#line 556
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 603
    schedule();
#line 604
    remove_wait_queue(& FlagSleepRec, & wait);
#line 606
    tmp___33 = get_current();
#line 606
    tmp___34 = signal_pending(tmp___33);
    }
#line 606
    if (tmp___34) {
#line 607
      return ((ssize_t )-4);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 617 "applicom.c"
static irqreturn_t ac_interrupt(int vec , void *dev_instance ) 
{ 
  unsigned int i ;
  unsigned int FlagInt ;
  unsigned int LoopCount ;
  int handled ;
  unsigned char tmp___7 ;
  unsigned char tmp___8 ;
  unsigned char tmp___9 ;
  unsigned char tmp___10 ;
  unsigned char tmp___11 ;
  unsigned char tmp___12 ;
  int tmp___13 ;
  unsigned char tmp___14 ;
  int tmp___15 ;
  unsigned char tmp___16 ;
  unsigned char tmp___17 ;
  unsigned char tmp___18 ;
  int tmp___19 ;

  {
  {
#line 622
  handled = 0;
#line 626
  LoopCount = 0U;
  }
  {
#line 628
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 629
    FlagInt = 0U;
#line 630
    i = 0U;
    }
    {
#line 630
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 630
      if (! (i < 8U)) {
#line 630
        goto while_break___0;
      }
#line 633
      if (! apbs[i].RamIO) {
#line 634
        goto __Cont;
      }
      {
#line 636
      spin_lock(& apbs[i].mutex);
#line 639
      tmp___7 = readb((void const volatile   *)(apbs[i].RamIO + 1023));
      }
#line 639
      if ((int )tmp___7 == 0) {
        {
#line 640
        spin_unlock(& apbs[i].mutex);
        }
#line 641
        goto __Cont;
      }
      {
#line 644
      handled = 1;
#line 645
      FlagInt = 1U;
#line 646
      writeb((unsigned char)0, (void volatile   *)(apbs[i].RamIO + 1023));
#line 648
      tmp___9 = readb((void const volatile   *)(apbs[i].RamIO + 0));
      }
#line 648
      if ((int )tmp___9 > 2) {
        {
#line 649
        tmp___8 = readb((void const volatile   *)(apbs[i].RamIO + 0));
#line 649
        printk("\0014APPLICOM driver interrupt err board %d, DataToPcReady = %d\n",
               i + 1U, (int )tmp___8);
#line 651
        DeviceErrorCount ++;
        }
      }
      {
#line 654
      tmp___11 = readb((void const volatile   *)(apbs[i].RamIO + 5));
      }
#line 654
      if ((int )tmp___11 > 2) {
        {
#line 654
        tmp___12 = readb((void const volatile   *)(apbs[i].RamIO + 5));
        }
#line 654
        if ((int )tmp___12 != 6) {
          {
#line 657
          tmp___10 = readb((void const volatile   *)(apbs[i].RamIO + 5));
#line 657
          printk("\0014APPLICOM driver interrupt err board %d, DataFromPcReady = %d\n",
                 i + 1U, (int )tmp___10);
#line 659
          DeviceErrorCount ++;
          }
        }
      }
      {
#line 662
      tmp___14 = readb((void const volatile   *)(apbs[i].RamIO + 0));
      }
#line 662
      if ((int )tmp___14 == 2) {
        {
#line 663
        tmp___13 = waitqueue_active(& FlagSleepRec);
        }
#line 663
        if (tmp___13) {
          {
#line 664
          __wake_up(& FlagSleepRec, 1U, 1, (void *)0);
          }
        }
      }
      {
#line 668
      tmp___16 = readb((void const volatile   *)(apbs[i].RamIO + 5));
      }
#line 668
      if ((int )tmp___16 == 0) {
        {
#line 669
        tmp___15 = waitqueue_active(& apbs[i].FlagSleepSend);
        }
#line 669
        if (tmp___15) {
          {
#line 670
          __wake_up(& apbs[i].FlagSleepSend, 1U, 1, (void *)0);
          }
        }
      }
      {
#line 673
      tmp___17 = readb((void const volatile   *)(apbs[i].RamIO + 30));
#line 673
      Dummy = (unsigned char volatile   )tmp___17;
#line 675
      tmp___18 = readb((void const volatile   *)(apbs[i].RamIO + 1023));
      }
#line 675
      if (tmp___18) {
        {
#line 677
        spin_unlock(& apbs[i].mutex);
#line 678
        i --;
        }
      } else {
        {
#line 680
        spin_unlock(& apbs[i].mutex);
        }
      }
      __Cont: /* CIL Label */ 
      {
#line 630
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 683
    if (FlagInt) {
      {
#line 684
      LoopCount = 0U;
      }
    } else {
      {
#line 686
      LoopCount ++;
      }
    }
#line 628
    if (! (LoopCount < 2U)) {
#line 628
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 688
  if (handled) {
    {
#line 688
    tmp___19 = 1;
    }
  } else {
    {
#line 688
    tmp___19 = 0;
    }
  }
#line 688
  return ((irqreturn_t )tmp___19);
}
}
#line 715
static long ac_ioctl(struct file *file , unsigned int cmd , unsigned long arg ) ;
#line 715 "applicom.c"
static int warncount___0  =    10;
#line 693 "applicom.c"
static long ac_ioctl(struct file *file , unsigned int cmd , unsigned long arg ) 
{ 
  int i ;
  unsigned char IndexCard ;
  void *pmem ;
  int ret ;
  unsigned char volatile   byte_reset_it ;
  struct st_ram_io *adgl ;
  void *argp ;
  void *tmp___7 ;
  long tmp___8 ;
  bool tmp___9 ;
  void *tmp___10 ;
  unsigned long tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  unsigned char tmp___16 ;
  unsigned char tmp___17 ;
  unsigned char tmp___18 ;
  unsigned long tmp___19 ;
  void *tmp___20 ;
  unsigned char tmp___21 ;
  void *tmp___22 ;
  unsigned long tmp___23 ;
  int serial ;
  char boardname[27] ;
  unsigned char tmp___24 ;
  unsigned char tmp___25 ;
  unsigned char tmp___26 ;
  unsigned char tmp___27 ;
  unsigned char tmp___28 ;
  unsigned char tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  unsigned char tmp___32 ;

  {
  {
#line 699
  ret = 0;
#line 702
  argp = (void *)arg;
#line 707
  tmp___7 = memdup_user((void const   *)argp, sizeof(struct st_ram_io ));
#line 707
  adgl = (struct st_ram_io *)tmp___7;
#line 708
  tmp___9 = IS_ERR((void const   *)adgl);
  }
#line 708
  if (tmp___9) {
    {
#line 709
    tmp___8 = PTR_ERR((void const   *)adgl);
    }
#line 709
    return (tmp___8);
  }
  {
#line 711
  mutex_lock(& ac_mutex);
#line 712
  IndexCard = (unsigned char )((int )adgl->num_card - 1);
  }
#line 714
  if (cmd != 6U) {
#line 714
    if ((int )IndexCard >= 8) {
#line 714
      goto _L;
    } else
#line 714
    if (! apbs[IndexCard].RamIO) {
      _L: /* CIL Label */ 
#line 716
      if (warncount___0) {
        {
#line 717
        printk("\0014APPLICOM driver IOCTL, bad board number %d\n", (int )IndexCard + 1);
#line 718
        warncount___0 --;
        }
      }
      {
#line 720
      kfree((void const   *)adgl);
#line 721
      mutex_unlock(& ac_mutex);
      }
#line 722
      return (-22L);
    }
  }
  {
#line 727
  if (cmd == 0U) {
#line 727
    goto case_0;
  }
#line 734
  if (cmd == 1U) {
#line 734
    goto case_1;
  }
#line 755
  if (cmd == 2U) {
#line 755
    goto case_2;
  }
#line 770
  if (cmd == 3U) {
#line 770
    goto case_3;
  }
#line 774
  if (cmd == 4U) {
#line 774
    goto case_4;
  }
#line 781
  if (cmd == 5U) {
#line 781
    goto case_5;
  }
#line 788
  if (cmd == 6U) {
#line 788
    goto case_6;
  }
#line 833
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 728
  pmem = apbs[IndexCard].RamIO;
#line 729
  i = 0;
  }
  {
#line 729
  while (1) {
    while_continue: /* CIL Label */ ;
#line 729
    if (! ((unsigned long )i < sizeof(struct st_ram_io ))) {
#line 729
      goto while_break;
    }
    {
#line 730
    tmp___10 = pmem;
#line 730
    pmem ++;
#line 730
    *((unsigned char *)adgl + i) = readb((void const volatile   *)tmp___10);
#line 729
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 731
  tmp___11 = copy_to_user(argp, (void const   *)adgl, sizeof(struct st_ram_io ));
  }
#line 731
  if (tmp___11) {
    {
#line 732
    ret = -14;
    }
  }
#line 733
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 735
  pmem = apbs[IndexCard].RamIO + 18;
#line 736
  i = 0;
  }
  {
#line 736
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 736
    if (! (i < 4)) {
#line 736
      goto while_break___0;
    }
    {
#line 737
    tmp___12 = pmem;
#line 737
    pmem ++;
#line 737
    adgl->conf_end_test[i] = readb((void const volatile   *)tmp___12);
#line 736
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 738
  i = 0;
  }
  {
#line 738
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 738
    if (! (i < 2)) {
#line 738
      goto while_break___1;
    }
    {
#line 739
    tmp___13 = pmem;
#line 739
    pmem ++;
#line 739
    adgl->error_code[i] = readb((void const volatile   *)tmp___13);
#line 738
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 740
  i = 0;
  }
  {
#line 740
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 740
    if (! (i < 4)) {
#line 740
      goto while_break___2;
    }
    {
#line 741
    tmp___14 = pmem;
#line 741
    pmem ++;
#line 741
    adgl->parameter_error[i] = readb((void const volatile   *)tmp___14);
#line 740
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 742
  pmem = apbs[IndexCard].RamIO + 30;
#line 743
  adgl->vers = readb((void const volatile   *)pmem);
#line 744
  pmem = apbs[IndexCard].RamIO + 960;
#line 745
  i = 0;
  }
  {
#line 745
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 745
    if (! (i < 20)) {
#line 745
      goto while_break___3;
    }
    {
#line 746
    tmp___15 = pmem;
#line 746
    pmem ++;
#line 746
    adgl->reserv1[i] = readb((void const volatile   *)tmp___15);
#line 745
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 747
  tmp___16 = readb((void const volatile   *)(apbs[IndexCard].RamIO + 986));
#line 747
  tmp___17 = readb((void const volatile   *)((apbs[IndexCard].RamIO + 986) + 1));
#line 747
  tmp___18 = readb((void const volatile   *)((apbs[IndexCard].RamIO + 986) + 2));
#line 747
  *((int *)(& adgl->reserv1[20])) = (((int )tmp___16 << 16) + ((int )tmp___17 << 8)) + (int )tmp___18;
#line 752
  tmp___19 = copy_to_user(argp, (void const   *)adgl, sizeof(struct st_ram_io ));
  }
#line 752
  if (tmp___19) {
    {
#line 753
    ret = -14;
    }
  }
#line 754
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 756
  pmem = apbs[IndexCard].RamIO + 18;
#line 757
  i = 0;
  }
  {
#line 757
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 757
    if (! (i < 10)) {
#line 757
      goto while_break___4;
    }
    {
#line 758
    tmp___20 = pmem;
#line 758
    pmem ++;
#line 758
    writeb((unsigned char)255, (void volatile   *)tmp___20);
#line 757
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 759
  writeb(adgl->data_from_pc_ready, (void volatile   *)(apbs[IndexCard].RamIO + 5));
#line 762
  writeb((unsigned char)1, (void volatile   *)(apbs[IndexCard].RamIO + 1022));
#line 764
  i = 0;
  }
  {
#line 764
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 764
    if (! (i < 8)) {
#line 764
      goto while_break___5;
    }
#line 765
    if (apbs[i].RamIO) {
      {
#line 766
      tmp___21 = readb((void const volatile   *)(apbs[i].RamIO + 1023));
#line 766
      byte_reset_it = (unsigned char volatile   )tmp___21;
      }
    }
    {
#line 764
    i ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 769
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 771
  pmem = apbs[IndexCard].RamIO + 8;
#line 772
  writeb(adgl->tic_des_from_pc, (void volatile   *)pmem);
  }
#line 773
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 775
  pmem = apbs[IndexCard].RamIO + 1;
#line 776
  tmp___22 = pmem;
#line 776
  pmem ++;
#line 776
  adgl->tic_owner_to_pc = readb((void const volatile   *)tmp___22);
#line 777
  adgl->numcard_owner_to_pc = readb((void const volatile   *)pmem);
#line 778
  tmp___23 = copy_to_user(argp, (void const   *)adgl, sizeof(struct st_ram_io ));
  }
#line 778
  if (tmp___23) {
    {
#line 779
    ret = -14;
    }
  }
#line 780
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 782
  writeb(adgl->num_card, (void volatile   *)(apbs[IndexCard].RamIO + 2));
#line 783
  writeb(adgl->num_card, (void volatile   *)(apbs[IndexCard].RamIO + 9));
#line 784
  writeb(adgl->num_card, (void volatile   *)(apbs[IndexCard].RamIO + 16));
#line 785
  writeb((unsigned char)4, (void volatile   *)(apbs[IndexCard].RamIO + 5));
#line 786
  writeb((unsigned char)1, (void volatile   *)(apbs[IndexCard].RamIO + 1022));
  }
#line 787
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 789
  printk("\0016APPLICOM driver release .... V2.8.0 ($Revision: 1.30 $)\n");
#line 790
  printk("\0016Number of installed boards . %d\n", (int )numboards);
#line 791
  printk("\0016Segment of board ........... %X\n", (int )mem);
#line 792
  printk("\0016Interrupt IRQ number ....... %d\n", (int )irq);
#line 793
  i = 0;
  }
  {
#line 793
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 793
    if (! (i < 8)) {
#line 793
      goto while_break___6;
    }
#line 797
    if (! apbs[i].RamIO) {
#line 798
      goto __Cont;
    }
    {
#line 800
    serial = 0;
    }
    {
#line 800
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 800
      if (! (serial < 26)) {
#line 800
        goto while_break___7;
      }
      {
#line 801
      tmp___24 = readb((void const volatile   *)((apbs[i].RamIO + 960) + serial));
#line 801
      boardname[serial] = (char )tmp___24;
#line 800
      serial ++;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 802
    boardname[serial] = (char)0;
#line 804
    tmp___25 = readb((void const volatile   *)(apbs[i].RamIO + 30));
#line 804
    tmp___26 = readb((void const volatile   *)(apbs[i].RamIO + 30));
#line 804
    printk("\0016Prom version board %d ....... V%d.%d %s", i + 1, (int )tmp___26 >> 4,
           (int )tmp___25 & 15, boardname);
#line 811
    tmp___27 = readb((void const volatile   *)(apbs[i].RamIO + 986));
#line 811
    tmp___28 = readb((void const volatile   *)((apbs[i].RamIO + 986) + 1));
#line 811
    tmp___29 = readb((void const volatile   *)((apbs[i].RamIO + 986) + 2));
#line 811
    serial = (((int )tmp___27 << 16) + ((int )tmp___28 << 8)) + (int )tmp___29;
    }
#line 815
    if (serial != 0) {
      {
#line 816
      printk(" S/N %d\n", serial);
      }
    } else {
      {
#line 818
      printk("\n");
      }
    }
    __Cont: /* CIL Label */ 
    {
#line 793
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 820
  if (DeviceErrorCount != 0U) {
    {
#line 821
    printk("\0016DeviceErrorCount ........... %d\n", DeviceErrorCount);
    }
  }
#line 822
  if (ReadErrorCount != 0U) {
    {
#line 823
    printk("\0016ReadErrorCount ............. %d\n", ReadErrorCount);
    }
  }
#line 824
  if (WriteErrorCount != 0U) {
    {
#line 825
    printk("\0016WriteErrorCount ............ %d\n", WriteErrorCount);
    }
  }
  {
#line 826
  tmp___30 = waitqueue_active(& FlagSleepRec);
  }
#line 826
  if (tmp___30) {
    {
#line 827
    printk("\0016Process in read pending\n");
    }
  }
  {
#line 828
  i = 0;
  }
  {
#line 828
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 828
    if (! (i < 8)) {
#line 828
      goto while_break___8;
    }
#line 829
    if (apbs[i].RamIO) {
      {
#line 829
      tmp___31 = waitqueue_active(& apbs[i].FlagSleepSend);
      }
#line 829
      if (tmp___31) {
        {
#line 830
        printk("\0016Process in write pending board %d\n", i + 1);
        }
      }
    }
    {
#line 828
    i ++;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
#line 832
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 834
  ret = -25;
  }
#line 835
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 837
  tmp___32 = readb((void const volatile   *)(apbs[IndexCard].RamIO + 30));
#line 837
  Dummy = (unsigned char volatile   )tmp___32;
#line 838
  kfree((void const   *)adgl);
#line 839
  mutex_unlock(& ac_mutex);
  }
#line 840
  return (0L);
}
}
