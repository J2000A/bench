// pngtest.c and dependencies compiled into one file for analysis by Goblint
// Seeded with the issue described for ImageMagick here https://patrakov.blogspot.com/2009/07/dangers-of-setjmplongjmp.html
// Licensed under the PNG Reference Library License version 2
// See LICENSE for license details.
/* Generated by CIL v. 2.0.1-33-g4ef5a08 */
/* print_CIL_Input is true */

#line 143 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h"
typedef long ptrdiff_t;
#line 209 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h"
typedef unsigned long size_t;
#line 321 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h"
typedef int wchar_t;
#line 415 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h"
struct __anonstruct_max_align_t_896270833 {
   long long __max_align_ll  __attribute__((__aligned__(__alignof__(long long )))) ;
   long double __max_align_ld  __attribute__((__aligned__(__alignof__(long double )))) ;
};
#line 415 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h"
typedef struct __anonstruct_max_align_t_896270833 max_align_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 34 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef signed char __int8_t;
#line 38 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef short __int16_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __int64_t;
#line 45 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 52 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int8_t __int_least8_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint8_t __uint_least8_t;
#line 54 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int16_t __int_least16_t;
#line 55 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint16_t __uint_least16_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int32_t __int_least32_t;
#line 57 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint32_t __uint_least32_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int64_t __int_least64_t;
#line 59 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint64_t __uint_least64_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __quad_t;
#line 64 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_quad_t;
#line 72 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intmax_t;
#line 73 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t;
#line 145 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 146 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 151 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 152 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 154 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
struct __anonstruct___fsid_t_109580352 {
   int __val[2] ;
};
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef struct __anonstruct___fsid_t_109580352 __fsid_t;
#line 156 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 157 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim64_t;
#line 159 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __id_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 161 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 164 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __daddr_t;
#line 165 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __key_t;
#line 168 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 171 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef void *__timer_t;
#line 174 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 179 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 180 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt64_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt64_t;
#line 187 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 188 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt64_t;
#line 191 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __fsword_t;
#line 193 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 196 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 198 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __syscall_ulong_t;
#line 202 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __off_t __loff_t;
#line 203 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 206 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intptr_t;
#line 209 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 214 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __sig_atomic_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 38 "/usr/include/sched.h"
typedef __pid_t pid_t;
#line 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h"
struct sched_param {
   int sched_priority ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
typedef unsigned long __cpu_mask;
#line 39 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
struct __anonstruct_cpu_set_t_826868708 {
   __cpu_mask __bits[1024UL / (8UL * sizeof(__cpu_mask ))] ;
};
#line 39 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
typedef struct __anonstruct_cpu_set_t_826868708 cpu_set_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h"
typedef __clock_t clock_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h"
typedef __clockid_t clockid_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h"
typedef __timer_t timer_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h"
struct itimerspec {
   struct timespec it_interval ;
   struct timespec it_value ;
};
#line 49 "/usr/include/time.h"
struct sigevent ;
#line 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_data ;
#line 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_struct {
   struct __locale_data *__locales[13] ;
   unsigned short const   *__ctype_b ;
   int const   *__ctype_tolower ;
   int const   *__ctype_toupper ;
   char const   *__names[13] ;
};
#line 42 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
typedef struct __locale_struct *__locale_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h"
typedef __locale_t locale_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 49 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 55 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_slist {
   struct __pthread_internal_slist *__next ;
};
#line 55 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_slist __pthread_slist_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h"
struct __pthread_rwlock_arch_t {
   unsigned int __readers ;
   unsigned int __writers ;
   unsigned int __wrphase_futex ;
   unsigned int __writers_futex ;
   unsigned int __pad3 ;
   unsigned int __pad4 ;
   int __cur_writer ;
   int __shared ;
   signed char __rwelision ;
   unsigned char __pad1[7] ;
   unsigned long __pad2 ;
   unsigned int __flags ;
};
#line 92 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct___wseq32_817613185 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 92 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
union __anonunion____missing_field_name_702539785 {
   unsigned long long __wseq ;
   struct __anonstruct___wseq32_817613185 __wseq32 ;
};
#line 92 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct___g1_start32_891907540 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 92 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
union __anonunion____missing_field_name_891907539 {
   unsigned long long __g1_start ;
   struct __anonstruct___g1_start32_891907540 __g1_start32 ;
};
#line 92 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_cond_s {
   union __anonunion____missing_field_name_702539785 __annonCompField1 ;
   union __anonunion____missing_field_name_891907539 __annonCompField2 ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_condattr_t_488594145 {
   char __size[4] ;
   int __align ;
};
#line 41 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_condattr_t_488594145 pthread_condattr_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned int pthread_key_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_once_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 67 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 67 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_cond_t_951761805 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_cond_t_951761805 pthread_cond_t;
#line 86 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_rwlock_t_656928968 {
   struct __pthread_rwlock_arch_t __data ;
   char __size[56] ;
   long __align ;
};
#line 86 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_rwlock_t_656928968 pthread_rwlock_t;
#line 93 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_rwlockattr_t_145707745 {
   char __size[8] ;
   long __align ;
};
#line 93 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_rwlockattr_t_145707745 pthread_rwlockattr_t;
#line 103 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int volatile   pthread_spinlock_t;
#line 108 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_barrier_t_145707746 {
   char __size[32] ;
   long __align ;
};
#line 108 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_barrier_t_145707746 pthread_barrier_t;
#line 114 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_barrierattr_t_951761806 {
   char __size[4] ;
   int __align ;
};
#line 114 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_barrierattr_t_951761806 pthread_barrierattr_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 33 "/usr/include/pthread.h"
enum __anonenum_34415463 {
    PTHREAD_CREATE_JOINABLE = 0,
    PTHREAD_CREATE_DETACHED = 1
} ;
#line 43
enum __anonenum_508643754 {
    PTHREAD_MUTEX_TIMED_NP = 0,
    PTHREAD_MUTEX_RECURSIVE_NP = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP = 3,
    PTHREAD_MUTEX_NORMAL = 0,
    PTHREAD_MUTEX_RECURSIVE = 1,
    PTHREAD_MUTEX_ERRORCHECK = 2,
    PTHREAD_MUTEX_DEFAULT = 0
} ;
#line 65
enum __anonenum_931900394 {
    PTHREAD_MUTEX_STALLED = 0,
    PTHREAD_MUTEX_STALLED_NP = 0,
    PTHREAD_MUTEX_ROBUST = 1,
    PTHREAD_MUTEX_ROBUST_NP = 1
} ;
#line 77
enum __anonenum_205214487 {
    PTHREAD_PRIO_NONE = 0,
    PTHREAD_PRIO_INHERIT = 1,
    PTHREAD_PRIO_PROTECT = 2
} ;
#line 100
enum __anonenum_25043950 {
    PTHREAD_RWLOCK_PREFER_READER_NP = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP = 2,
    PTHREAD_RWLOCK_DEFAULT_NP = 0
} ;
#line 120
enum __anonenum_436439511 {
    PTHREAD_INHERIT_SCHED = 0,
    PTHREAD_EXPLICIT_SCHED = 1
} ;
#line 130
enum __anonenum_998661166 {
    PTHREAD_SCOPE_SYSTEM = 0,
    PTHREAD_SCOPE_PROCESS = 1
} ;
#line 140
enum __anonenum_146137331 {
    PTHREAD_PROCESS_PRIVATE = 0,
    PTHREAD_PROCESS_SHARED = 1
} ;
#line 155 "/usr/include/pthread.h"
struct _pthread_cleanup_buffer {
   void (*__routine)(void * ) ;
   void *__arg ;
   int __canceltype ;
   struct _pthread_cleanup_buffer *__prev ;
};
#line 164
enum __anonenum_53396917 {
    PTHREAD_CANCEL_ENABLE = 0,
    PTHREAD_CANCEL_DISABLE = 1
} ;
#line 171
enum __anonenum_904563783 {
    PTHREAD_CANCEL_DEFERRED = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS = 1
} ;
#line 499 "/usr/include/pthread.h"
struct __anonstruct___cancel_jmp_buf_572769531 {
   __jmp_buf __cancel_jmp_buf ;
   int __mask_was_saved ;
};
#line 499 "/usr/include/pthread.h"
struct __anonstruct___pthread_unwind_buf_t_69853028 {
   struct __anonstruct___cancel_jmp_buf_572769531 __cancel_jmp_buf[1] ;
   void *__pad[4] ;
};
#line 499 "/usr/include/pthread.h"
typedef struct __anonstruct___pthread_unwind_buf_t_69853028  __attribute__((__aligned__)) __pthread_unwind_buf_t;
#line 516 "/usr/include/pthread.h"
struct __pthread_cleanup_frame {
   void (*__cancel_routine)(void * ) ;
   void *__cancel_arg ;
   int __do_it ;
   int __cancel_type ;
};
#line 718
struct __jmp_buf_tag ;
#line 58 "/usr/include/stdlib.h"
struct __anonstruct_div_t_773697287 {
   int quot ;
   int rem ;
};
#line 58 "/usr/include/stdlib.h"
typedef struct __anonstruct_div_t_773697287 div_t;
#line 66 "/usr/include/stdlib.h"
struct __anonstruct_ldiv_t_790849867 {
   long quot ;
   long rem ;
};
#line 66 "/usr/include/stdlib.h"
typedef struct __anonstruct_ldiv_t_790849867 ldiv_t;
#line 76 "/usr/include/stdlib.h"
struct __anonstruct_lldiv_t_103911545 {
   long long quot ;
   long long rem ;
};
#line 76 "/usr/include/stdlib.h"
typedef struct __anonstruct_lldiv_t_103911545 lldiv_t;
#line 808 "/usr/include/stdlib.h"
typedef int (*__compar_fn_t)(void const   * , void const   * );
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion___value_628077854 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct___mbstate_t_743004153 {
   int __count ;
   union __anonunion___value_628077854 __value ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct___mbstate_t_743004153 __mbstate_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
struct _G_fpos_t {
   __off_t __pos ;
   __mbstate_t __state ;
};
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
typedef struct _G_fpos_t __fpos_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
struct _G_fpos64_t {
   __off_t __pos ;
   __mbstate_t __state ;
};
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
typedef struct _G_fpos64_t __fpos64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
typedef struct _IO_FILE __FILE;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_marker ;
#line 37
struct _IO_codecvt ;
#line 38
struct _IO_wide_data ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
typedef void _IO_lock_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 84 "/usr/include/stdio.h"
typedef __fpos_t fpos_t;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct___sigset_t_764561023 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct___sigset_t_764561023 __sigset_t;
#line 33 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 45 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 83 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag sigjmp_buf[1];
#line 481 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef unsigned char png_byte;
#line 489 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef short png_int_16;
#line 497 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef unsigned short png_uint_16;
#line 503 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef int png_int_32;
#line 511 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef unsigned int png_uint_32;
#line 523 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef size_t png_size_t;
#line 524 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef ptrdiff_t png_ptrdiff_t;
#line 557 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef size_t png_alloc_size_t;
#line 574 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef png_int_32 png_fixed_point;
#line 577 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef void *png_voidp;
#line 578 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef void const   *png_const_voidp;
#line 579 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef png_byte *png_bytep;
#line 580 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef png_byte const   *png_const_bytep;
#line 581 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef png_uint_32 *png_uint_32p;
#line 582 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef png_uint_32 const   *png_const_uint_32p;
#line 583 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef png_int_32 *png_int_32p;
#line 584 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef png_int_32 const   *png_const_int_32p;
#line 585 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef png_uint_16 *png_uint_16p;
#line 586 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef png_uint_16 const   *png_const_uint_16p;
#line 587 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef png_int_16 *png_int_16p;
#line 588 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef png_int_16 const   *png_const_int_16p;
#line 589 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef char *png_charp;
#line 590 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef char const   *png_const_charp;
#line 591 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef png_fixed_point *png_fixed_point_p;
#line 592 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef png_fixed_point const   *png_const_fixed_point_p;
#line 593 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef size_t *png_size_tp;
#line 594 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef size_t const   *png_const_size_tp;
#line 597 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef FILE *png_FILE_p;
#line 601 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef double *png_doublep;
#line 602 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef double const   *png_const_doublep;
#line 606 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef png_byte **png_bytepp;
#line 607 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef png_uint_32 **png_uint_32pp;
#line 608 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef png_int_32 **png_int_32pp;
#line 609 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef png_uint_16 **png_uint_16pp;
#line 610 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef png_int_16 **png_int_16pp;
#line 611 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef char const   **png_const_charpp;
#line 612 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef char **png_charpp;
#line 613 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef png_fixed_point **png_fixed_point_pp;
#line 615 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef double **png_doublepp;
#line 619 "/home/goblint2/bench/libpng-1.6.39/pngconf.h"
typedef char ***png_charppp;
#line 431 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef char *png_libpng_version_1_6_39;
#line 439
struct png_struct_def ;
#line 439 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef struct png_struct_def png_struct;
#line 440 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef png_struct const   *png_const_structp;
#line 441 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef png_struct *png_structp;
#line 442 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef png_struct **png_structpp;
#line 453
struct png_info_def ;
#line 453 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef struct png_info_def png_info;
#line 454 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef png_info *png_infop;
#line 455 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef png_info const   *png_const_infop;
#line 456 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef png_info **png_infopp;
#line 469 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef png_struct * __restrict  png_structrp;
#line 470 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef png_struct const   * __restrict  png_const_structrp;
#line 471 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef png_info * __restrict  png_inforp;
#line 472 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef png_info const   * __restrict  png_const_inforp;
#line 478 "/home/goblint2/bench/libpng-1.6.39/png.h"
struct png_color_struct {
   png_byte red ;
   png_byte green ;
   png_byte blue ;
};
#line 478 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef struct png_color_struct png_color;
#line 484 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef png_color *png_colorp;
#line 485 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef png_color const   *png_const_colorp;
#line 486 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef png_color **png_colorpp;
#line 488 "/home/goblint2/bench/libpng-1.6.39/png.h"
struct png_color_16_struct {
   png_byte index ;
   png_uint_16 red ;
   png_uint_16 green ;
   png_uint_16 blue ;
   png_uint_16 gray ;
};
#line 488 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef struct png_color_16_struct png_color_16;
#line 496 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef png_color_16 *png_color_16p;
#line 497 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef png_color_16 const   *png_const_color_16p;
#line 498 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef png_color_16 **png_color_16pp;
#line 500 "/home/goblint2/bench/libpng-1.6.39/png.h"
struct png_color_8_struct {
   png_byte red ;
   png_byte green ;
   png_byte blue ;
   png_byte gray ;
   png_byte alpha ;
};
#line 500 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef struct png_color_8_struct png_color_8;
#line 508 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef png_color_8 *png_color_8p;
#line 509 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef png_color_8 const   *png_const_color_8p;
#line 510 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef png_color_8 **png_color_8pp;
#line 516 "/home/goblint2/bench/libpng-1.6.39/png.h"
struct png_sPLT_entry_struct {
   png_uint_16 red ;
   png_uint_16 green ;
   png_uint_16 blue ;
   png_uint_16 alpha ;
   png_uint_16 frequency ;
};
#line 516 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef struct png_sPLT_entry_struct png_sPLT_entry;
#line 524 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef png_sPLT_entry *png_sPLT_entryp;
#line 525 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef png_sPLT_entry const   *png_const_sPLT_entryp;
#line 526 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef png_sPLT_entry **png_sPLT_entrypp;
#line 533 "/home/goblint2/bench/libpng-1.6.39/png.h"
struct png_sPLT_struct {
   png_charp name ;
   png_byte depth ;
   png_sPLT_entryp entries ;
   png_int_32 nentries ;
};
#line 533 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef struct png_sPLT_struct png_sPLT_t;
#line 540 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef png_sPLT_t *png_sPLT_tp;
#line 541 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef png_sPLT_t const   *png_const_sPLT_tp;
#line 542 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef png_sPLT_t **png_sPLT_tpp;
#line 562 "/home/goblint2/bench/libpng-1.6.39/png.h"
struct png_text_struct {
   int compression ;
   png_charp key ;
   png_charp text ;
   size_t text_length ;
   size_t itxt_length ;
   png_charp lang ;
   png_charp lang_key ;
};
#line 562 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef struct png_text_struct png_text;
#line 579 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef png_text *png_textp;
#line 580 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef png_text const   *png_const_textp;
#line 581 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef png_text **png_textpp;
#line 600 "/home/goblint2/bench/libpng-1.6.39/png.h"
struct png_time_struct {
   png_uint_16 year ;
   png_byte month ;
   png_byte day ;
   png_byte hour ;
   png_byte minute ;
   png_byte second ;
};
#line 600 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef struct png_time_struct png_time;
#line 609 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef png_time *png_timep;
#line 610 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef png_time const   *png_const_timep;
#line 611 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef png_time **png_timepp;
#line 622 "/home/goblint2/bench/libpng-1.6.39/png.h"
struct png_unknown_chunk_t {
   png_byte name[5] ;
   png_byte *data ;
   size_t size ;
   png_byte location ;
};
#line 622 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef struct png_unknown_chunk_t png_unknown_chunk;
#line 638 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef png_unknown_chunk *png_unknown_chunkp;
#line 639 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef png_unknown_chunk const   *png_const_unknown_chunkp;
#line 640 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef png_unknown_chunk **png_unknown_chunkpp;
#line 754 "/home/goblint2/bench/libpng-1.6.39/png.h"
struct png_row_info_struct {
   png_uint_32 width ;
   size_t rowbytes ;
   png_byte color_type ;
   png_byte bit_depth ;
   png_byte channels ;
   png_byte pixel_depth ;
};
#line 754 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef struct png_row_info_struct png_row_info;
#line 764 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef png_row_info *png_row_infop;
#line 765 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef png_row_info **png_row_infopp;
#line 775 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef void (*png_error_ptr)(png_structp  , png_const_charp  );
#line 776 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef void (*png_rw_ptr)(png_structp  , png_bytep  , size_t  );
#line 777 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef void (*png_flush_ptr)(png_structp  );
#line 778 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef void (*png_read_status_ptr)(png_structp  , png_uint_32  , int  );
#line 780 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef void (*png_write_status_ptr)(png_structp  , png_uint_32  , int  );
#line 784 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef void (*png_progressive_info_ptr)(png_structp  , png_infop  );
#line 785 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef void (*png_progressive_end_ptr)(png_structp  , png_infop  );
#line 797 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef void (*png_progressive_row_ptr)(png_structp  , png_bytep  , png_uint_32  ,
                                        int  );
#line 803 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef void (*png_user_transform_ptr)(png_structp  , png_row_infop  , png_bytep  );
#line 808 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef int (*png_user_chunk_ptr)(png_structp  , png_unknown_chunkp  );
#line 828 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef void (*png_longjmp_ptr)(struct __jmp_buf_tag * , int  );
#line 867 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef png_voidp (*png_malloc_ptr)(png_structp  , png_alloc_size_t  );
#line 869 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef void (*png_free_ptr)(png_structp  , png_voidp  );
#line 2671
struct png_control ;
#line 2671 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef struct png_control *png_controlp;
#line 2672 "/home/goblint2/bench/libpng-1.6.39/png.h"
struct __anonstruct_png_image_465464113 {
   png_controlp opaque ;
   png_uint_32 version ;
   png_uint_32 width ;
   png_uint_32 height ;
   png_uint_32 format ;
   png_uint_32 flags ;
   png_uint_32 colormap_entries ;
   png_uint_32 warning_or_error ;
   char message[64] ;
};
#line 2672 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef struct __anonstruct_png_image_465464113 png_image;
#line 2672 "/home/goblint2/bench/libpng-1.6.39/png.h"
typedef struct __anonstruct_png_image_465464113 *png_imagep;
#line 149 "/usr/include/math.h"
typedef float float_t;
#line 150 "/usr/include/math.h"
typedef double double_t;
#line 853
enum __anonenum_1037408945 {
    FP_NAN = 0,
    FP_INFINITE = 1,
    FP_ZERO = 2,
    FP_SUBNORMAL = 3,
    FP_NORMAL = 4
} ;
#line 248 "/usr/include/zconf.h"
typedef size_t z_size_t;
#line 391 "/usr/include/zconf.h"
typedef unsigned char Byte;
#line 393 "/usr/include/zconf.h"
typedef unsigned int uInt;
#line 394 "/usr/include/zconf.h"
typedef unsigned long uLong;
#line 400 "/usr/include/zconf.h"
typedef Byte Bytef;
#line 402 "/usr/include/zconf.h"
typedef char charf;
#line 403 "/usr/include/zconf.h"
typedef int intf;
#line 404 "/usr/include/zconf.h"
typedef uInt uIntf;
#line 405 "/usr/include/zconf.h"
typedef uLong uLongf;
#line 408 "/usr/include/zconf.h"
typedef void const   *voidpc;
#line 409 "/usr/include/zconf.h"
typedef void *voidpf;
#line 410 "/usr/include/zconf.h"
typedef void *voidp;
#line 429 "/usr/include/zconf.h"
typedef unsigned int z_crc_t;
#line 47 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 59 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 64 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 69 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 74 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __nlink_t nlink_t;
#line 79 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 85 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 108 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int8_t int8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int16_t int16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int32_t int32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int64_t int64_t;
#line 158 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint8_t u_int8_t;
#line 159 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint16_t u_int16_t;
#line 160 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint32_t u_int32_t;
#line 161 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint64_t u_int64_t;
#line 164 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int register_t;
#line 192 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blkcnt_t blkcnt_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsblkcnt_t fsblkcnt_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsfilcnt_t fsfilcnt_t;
#line 99 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum_437032235 {
    _PC_LINK_MAX = 0,
    _PC_MAX_CANON = 1,
    _PC_MAX_INPUT = 2,
    _PC_NAME_MAX = 3,
    _PC_PATH_MAX = 4,
    _PC_PIPE_BUF = 5,
    _PC_CHOWN_RESTRICTED = 6,
    _PC_NO_TRUNC = 7,
    _PC_VDISABLE = 8,
    _PC_SYNC_IO = 9,
    _PC_ASYNC_IO = 10,
    _PC_PRIO_IO = 11,
    _PC_SOCK_MAXBUF = 12,
    _PC_FILESIZEBITS = 13,
    _PC_REC_INCR_XFER_SIZE = 14,
    _PC_REC_MAX_XFER_SIZE = 15,
    _PC_REC_MIN_XFER_SIZE = 16,
    _PC_REC_XFER_ALIGN = 17,
    _PC_ALLOC_SIZE_MIN = 18,
    _PC_SYMLINK_MAX = 19,
    _PC_2_SYMLINKS = 20
} ;
#line 71
enum __anonenum_315186338 {
    _SC_ARG_MAX = 0,
    _SC_CHILD_MAX = 1,
    _SC_CLK_TCK = 2,
    _SC_NGROUPS_MAX = 3,
    _SC_OPEN_MAX = 4,
    _SC_STREAM_MAX = 5,
    _SC_TZNAME_MAX = 6,
    _SC_JOB_CONTROL = 7,
    _SC_SAVED_IDS = 8,
    _SC_REALTIME_SIGNALS = 9,
    _SC_PRIORITY_SCHEDULING = 10,
    _SC_TIMERS = 11,
    _SC_ASYNCHRONOUS_IO = 12,
    _SC_PRIORITIZED_IO = 13,
    _SC_SYNCHRONIZED_IO = 14,
    _SC_FSYNC = 15,
    _SC_MAPPED_FILES = 16,
    _SC_MEMLOCK = 17,
    _SC_MEMLOCK_RANGE = 18,
    _SC_MEMORY_PROTECTION = 19,
    _SC_MESSAGE_PASSING = 20,
    _SC_SEMAPHORES = 21,
    _SC_SHARED_MEMORY_OBJECTS = 22,
    _SC_AIO_LISTIO_MAX = 23,
    _SC_AIO_MAX = 24,
    _SC_AIO_PRIO_DELTA_MAX = 25,
    _SC_DELAYTIMER_MAX = 26,
    _SC_MQ_OPEN_MAX = 27,
    _SC_MQ_PRIO_MAX = 28,
    _SC_VERSION = 29,
    _SC_PAGESIZE = 30,
    _SC_RTSIG_MAX = 31,
    _SC_SEM_NSEMS_MAX = 32,
    _SC_SEM_VALUE_MAX = 33,
    _SC_SIGQUEUE_MAX = 34,
    _SC_TIMER_MAX = 35,
    _SC_BC_BASE_MAX = 36,
    _SC_BC_DIM_MAX = 37,
    _SC_BC_SCALE_MAX = 38,
    _SC_BC_STRING_MAX = 39,
    _SC_COLL_WEIGHTS_MAX = 40,
    _SC_EQUIV_CLASS_MAX = 41,
    _SC_EXPR_NEST_MAX = 42,
    _SC_LINE_MAX = 43,
    _SC_RE_DUP_MAX = 44,
    _SC_CHARCLASS_NAME_MAX = 45,
    _SC_2_VERSION = 46,
    _SC_2_C_BIND = 47,
    _SC_2_C_DEV = 48,
    _SC_2_FORT_DEV = 49,
    _SC_2_FORT_RUN = 50,
    _SC_2_SW_DEV = 51,
    _SC_2_LOCALEDEF = 52,
    _SC_PII = 53,
    _SC_PII_XTI = 54,
    _SC_PII_SOCKET = 55,
    _SC_PII_INTERNET = 56,
    _SC_PII_OSI = 57,
    _SC_POLL = 58,
    _SC_SELECT = 59,
    _SC_UIO_MAXIOV = 60,
    _SC_IOV_MAX = 60,
    _SC_PII_INTERNET_STREAM = 61,
    _SC_PII_INTERNET_DGRAM = 62,
    _SC_PII_OSI_COTS = 63,
    _SC_PII_OSI_CLTS = 64,
    _SC_PII_OSI_M = 65,
    _SC_T_IOV_MAX = 66,
    _SC_THREADS = 67,
    _SC_THREAD_SAFE_FUNCTIONS = 68,
    _SC_GETGR_R_SIZE_MAX = 69,
    _SC_GETPW_R_SIZE_MAX = 70,
    _SC_LOGIN_NAME_MAX = 71,
    _SC_TTY_NAME_MAX = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS = 73,
    _SC_THREAD_KEYS_MAX = 74,
    _SC_THREAD_STACK_MIN = 75,
    _SC_THREAD_THREADS_MAX = 76,
    _SC_THREAD_ATTR_STACKADDR = 77,
    _SC_THREAD_ATTR_STACKSIZE = 78,
    _SC_THREAD_PRIORITY_SCHEDULING = 79,
    _SC_THREAD_PRIO_INHERIT = 80,
    _SC_THREAD_PRIO_PROTECT = 81,
    _SC_THREAD_PROCESS_SHARED = 82,
    _SC_NPROCESSORS_CONF = 83,
    _SC_NPROCESSORS_ONLN = 84,
    _SC_PHYS_PAGES = 85,
    _SC_AVPHYS_PAGES = 86,
    _SC_ATEXIT_MAX = 87,
    _SC_PASS_MAX = 88,
    _SC_XOPEN_VERSION = 89,
    _SC_XOPEN_XCU_VERSION = 90,
    _SC_XOPEN_UNIX = 91,
    _SC_XOPEN_CRYPT = 92,
    _SC_XOPEN_ENH_I18N = 93,
    _SC_XOPEN_SHM = 94,
    _SC_2_CHAR_TERM = 95,
    _SC_2_C_VERSION = 96,
    _SC_2_UPE = 97,
    _SC_XOPEN_XPG2 = 98,
    _SC_XOPEN_XPG3 = 99,
    _SC_XOPEN_XPG4 = 100,
    _SC_CHAR_BIT = 101,
    _SC_CHAR_MAX = 102,
    _SC_CHAR_MIN = 103,
    _SC_INT_MAX = 104,
    _SC_INT_MIN = 105,
    _SC_LONG_BIT = 106,
    _SC_WORD_BIT = 107,
    _SC_MB_LEN_MAX = 108,
    _SC_NZERO = 109,
    _SC_SSIZE_MAX = 110,
    _SC_SCHAR_MAX = 111,
    _SC_SCHAR_MIN = 112,
    _SC_SHRT_MAX = 113,
    _SC_SHRT_MIN = 114,
    _SC_UCHAR_MAX = 115,
    _SC_UINT_MAX = 116,
    _SC_ULONG_MAX = 117,
    _SC_USHRT_MAX = 118,
    _SC_NL_ARGMAX = 119,
    _SC_NL_LANGMAX = 120,
    _SC_NL_MSGMAX = 121,
    _SC_NL_NMAX = 122,
    _SC_NL_SETMAX = 123,
    _SC_NL_TEXTMAX = 124,
    _SC_XBS5_ILP32_OFF32 = 125,
    _SC_XBS5_ILP32_OFFBIG = 126,
    _SC_XBS5_LP64_OFF64 = 127,
    _SC_XBS5_LPBIG_OFFBIG = 128,
    _SC_XOPEN_LEGACY = 129,
    _SC_XOPEN_REALTIME = 130,
    _SC_XOPEN_REALTIME_THREADS = 131,
    _SC_ADVISORY_INFO = 132,
    _SC_BARRIERS = 133,
    _SC_BASE = 134,
    _SC_C_LANG_SUPPORT = 135,
    _SC_C_LANG_SUPPORT_R = 136,
    _SC_CLOCK_SELECTION = 137,
    _SC_CPUTIME = 138,
    _SC_THREAD_CPUTIME = 139,
    _SC_DEVICE_IO = 140,
    _SC_DEVICE_SPECIFIC = 141,
    _SC_DEVICE_SPECIFIC_R = 142,
    _SC_FD_MGMT = 143,
    _SC_FIFO = 144,
    _SC_PIPE = 145,
    _SC_FILE_ATTRIBUTES = 146,
    _SC_FILE_LOCKING = 147,
    _SC_FILE_SYSTEM = 148,
    _SC_MONOTONIC_CLOCK = 149,
    _SC_MULTI_PROCESS = 150,
    _SC_SINGLE_PROCESS = 151,
    _SC_NETWORKING = 152,
    _SC_READER_WRITER_LOCKS = 153,
    _SC_SPIN_LOCKS = 154,
    _SC_REGEXP = 155,
    _SC_REGEX_VERSION = 156,
    _SC_SHELL = 157,
    _SC_SIGNALS = 158,
    _SC_SPAWN = 159,
    _SC_SPORADIC_SERVER = 160,
    _SC_THREAD_SPORADIC_SERVER = 161,
    _SC_SYSTEM_DATABASE = 162,
    _SC_SYSTEM_DATABASE_R = 163,
    _SC_TIMEOUTS = 164,
    _SC_TYPED_MEMORY_OBJECTS = 165,
    _SC_USER_GROUPS = 166,
    _SC_USER_GROUPS_R = 167,
    _SC_2_PBS = 168,
    _SC_2_PBS_ACCOUNTING = 169,
    _SC_2_PBS_LOCATE = 170,
    _SC_2_PBS_MESSAGE = 171,
    _SC_2_PBS_TRACK = 172,
    _SC_SYMLOOP_MAX = 173,
    _SC_STREAMS = 174,
    _SC_2_PBS_CHECKPOINT = 175,
    _SC_V6_ILP32_OFF32 = 176,
    _SC_V6_ILP32_OFFBIG = 177,
    _SC_V6_LP64_OFF64 = 178,
    _SC_V6_LPBIG_OFFBIG = 179,
    _SC_HOST_NAME_MAX = 180,
    _SC_TRACE = 181,
    _SC_TRACE_EVENT_FILTER = 182,
    _SC_TRACE_INHERIT = 183,
    _SC_TRACE_LOG = 184,
    _SC_LEVEL1_ICACHE_SIZE = 185,
    _SC_LEVEL1_ICACHE_ASSOC = 186,
    _SC_LEVEL1_ICACHE_LINESIZE = 187,
    _SC_LEVEL1_DCACHE_SIZE = 188,
    _SC_LEVEL1_DCACHE_ASSOC = 189,
    _SC_LEVEL1_DCACHE_LINESIZE = 190,
    _SC_LEVEL2_CACHE_SIZE = 191,
    _SC_LEVEL2_CACHE_ASSOC = 192,
    _SC_LEVEL2_CACHE_LINESIZE = 193,
    _SC_LEVEL3_CACHE_SIZE = 194,
    _SC_LEVEL3_CACHE_ASSOC = 195,
    _SC_LEVEL3_CACHE_LINESIZE = 196,
    _SC_LEVEL4_CACHE_SIZE = 197,
    _SC_LEVEL4_CACHE_ASSOC = 198,
    _SC_LEVEL4_CACHE_LINESIZE = 199,
    _SC_IPV6 = 235,
    _SC_RAW_SOCKETS = 236,
    _SC_V7_ILP32_OFF32 = 237,
    _SC_V7_ILP32_OFFBIG = 238,
    _SC_V7_LP64_OFF64 = 239,
    _SC_V7_LPBIG_OFFBIG = 240,
    _SC_SS_REPL_MAX = 241,
    _SC_TRACE_EVENT_NAME_MAX = 242,
    _SC_TRACE_NAME_MAX = 243,
    _SC_TRACE_SYS_MAX = 244,
    _SC_TRACE_USER_EVENT_MAX = 245,
    _SC_XOPEN_STREAMS = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT = 248
} ;
#line 533
enum __anonenum_875524036 {
    _CS_PATH = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS = 1,
    _CS_GNU_LIBC_VERSION = 2,
    _CS_GNU_LIBPTHREAD_VERSION = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS = 5,
    _CS_LFS_CFLAGS = 1000,
    _CS_LFS_LDFLAGS = 1001,
    _CS_LFS_LIBS = 1002,
    _CS_LFS_LINTFLAGS = 1003,
    _CS_LFS64_CFLAGS = 1004,
    _CS_LFS64_LDFLAGS = 1005,
    _CS_LFS64_LIBS = 1006,
    _CS_LFS64_LINTFLAGS = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS = 1109,
    _CS_XBS5_LP64_OFF64_LIBS = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS = 1147,
    _CS_V6_ENV = 1148,
    _CS_V7_ENV = 1149
} ;
#line 81 "/usr/include/zlib.h"
typedef voidpf (*alloc_func)(voidpf opaque , uInt items , uInt size );
#line 82 "/usr/include/zlib.h"
typedef void (*free_func)(voidpf opaque , voidpf address );
#line 84
struct internal_state ;
#line 86 "/usr/include/zlib.h"
struct z_stream_s {
   Bytef const   *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char const   *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 86 "/usr/include/zlib.h"
typedef struct z_stream_s z_stream;
#line 108 "/usr/include/zlib.h"
typedef z_stream *z_streamp;
#line 114 "/usr/include/zlib.h"
struct gz_header_s {
   int text ;
   uLong time ;
   int xflags ;
   int os ;
   Bytef *extra ;
   uInt extra_len ;
   uInt extra_max ;
   Bytef *name ;
   uInt name_max ;
   Bytef *comment ;
   uInt comm_max ;
   int hcrc ;
   int done ;
};
#line 114 "/usr/include/zlib.h"
typedef struct gz_header_s gz_header;
#line 131 "/usr/include/zlib.h"
typedef gz_header *gz_headerp;
#line 1093 "/usr/include/zlib.h"
typedef unsigned int (*in_func)(void * , unsigned char const   ** );
#line 1095 "/usr/include/zlib.h"
typedef int (*out_func)(void * , unsigned char * , unsigned int  );
#line 1301
struct gzFile_s ;
#line 1301 "/usr/include/zlib.h"
typedef struct gzFile_s *gzFile;
#line 1818 "/usr/include/zlib.h"
struct gzFile_s {
   unsigned int have ;
   unsigned char *next ;
   off_t pos ;
};
#line 61 "/home/goblint2/bench/libpng-1.6.39/pngstruct.h"
struct png_compression_buffer {
   struct png_compression_buffer *next ;
   png_byte output[1] ;
};
#line 61 "/home/goblint2/bench/libpng-1.6.39/pngstruct.h"
typedef struct png_compression_buffer png_compression_buffer;
#line 61 "/home/goblint2/bench/libpng-1.6.39/pngstruct.h"
typedef struct png_compression_buffer *png_compression_bufferp;
#line 83 "/home/goblint2/bench/libpng-1.6.39/pngstruct.h"
struct png_xy {
   png_fixed_point redx ;
   png_fixed_point redy ;
   png_fixed_point greenx ;
   png_fixed_point greeny ;
   png_fixed_point bluex ;
   png_fixed_point bluey ;
   png_fixed_point whitex ;
   png_fixed_point whitey ;
};
#line 83 "/home/goblint2/bench/libpng-1.6.39/pngstruct.h"
typedef struct png_xy png_xy;
#line 94 "/home/goblint2/bench/libpng-1.6.39/pngstruct.h"
struct png_XYZ {
   png_fixed_point red_X ;
   png_fixed_point red_Y ;
   png_fixed_point red_Z ;
   png_fixed_point green_X ;
   png_fixed_point green_Y ;
   png_fixed_point green_Z ;
   png_fixed_point blue_X ;
   png_fixed_point blue_Y ;
   png_fixed_point blue_Z ;
};
#line 94 "/home/goblint2/bench/libpng-1.6.39/pngstruct.h"
typedef struct png_XYZ png_XYZ;
#line 112 "/home/goblint2/bench/libpng-1.6.39/pngstruct.h"
struct png_colorspace {
   png_fixed_point gamma ;
   png_xy end_points_xy ;
   png_XYZ end_points_XYZ ;
   png_uint_16 rendering_intent ;
   png_uint_16 flags ;
};
#line 112 "/home/goblint2/bench/libpng-1.6.39/pngstruct.h"
typedef struct png_colorspace png_colorspace;
#line 112 "/home/goblint2/bench/libpng-1.6.39/pngstruct.h"
typedef struct png_colorspace * __restrict  png_colorspacerp;
#line 128 "/home/goblint2/bench/libpng-1.6.39/pngstruct.h"
typedef png_colorspace const   * __restrict  png_const_colorspacerp;
#line 143 "/home/goblint2/bench/libpng-1.6.39/pngstruct.h"
struct png_struct_def {
   jmp_buf jmp_buf_local ;
   void (*longjmp_fn)(struct __jmp_buf_tag * , int  ) ;
   jmp_buf *jmp_buf_ptr ;
   size_t jmp_buf_size ;
   void (*error_fn)(png_structp  , png_const_charp  ) ;
   void (*warning_fn)(png_structp  , png_const_charp  ) ;
   png_voidp error_ptr ;
   void (*write_data_fn)(png_structp  , png_bytep  , size_t  ) ;
   void (*read_data_fn)(png_structp  , png_bytep  , size_t  ) ;
   png_voidp io_ptr ;
   void (*read_user_transform_fn)(png_structp  , png_row_infop  , png_bytep  ) ;
   void (*write_user_transform_fn)(png_structp  , png_row_infop  , png_bytep  ) ;
   png_voidp user_transform_ptr ;
   png_byte user_transform_depth ;
   png_byte user_transform_channels ;
   png_uint_32 mode ;
   png_uint_32 flags ;
   png_uint_32 transformations ;
   png_uint_32 zowner ;
   z_stream zstream ;
   png_compression_bufferp zbuffer_list ;
   uInt zbuffer_size ;
   int zlib_level ;
   int zlib_method ;
   int zlib_window_bits ;
   int zlib_mem_level ;
   int zlib_strategy ;
   int zlib_text_level ;
   int zlib_text_method ;
   int zlib_text_window_bits ;
   int zlib_text_mem_level ;
   int zlib_text_strategy ;
   int zlib_set_level ;
   int zlib_set_method ;
   int zlib_set_window_bits ;
   int zlib_set_mem_level ;
   int zlib_set_strategy ;
   png_uint_32 width ;
   png_uint_32 height ;
   png_uint_32 num_rows ;
   png_uint_32 usr_width ;
   size_t rowbytes ;
   png_uint_32 iwidth ;
   png_uint_32 row_number ;
   png_uint_32 chunk_name ;
   png_bytep prev_row ;
   png_bytep row_buf ;
   png_bytep try_row ;
   png_bytep tst_row ;
   size_t info_rowbytes ;
   png_uint_32 idat_size ;
   png_uint_32 crc ;
   png_colorp palette ;
   png_uint_16 num_palette ;
   int num_palette_max ;
   png_uint_16 num_trans ;
   png_byte compression ;
   png_byte filter ;
   png_byte interlaced ;
   png_byte pass ;
   png_byte do_filter ;
   png_byte color_type ;
   png_byte bit_depth ;
   png_byte usr_bit_depth ;
   png_byte pixel_depth ;
   png_byte channels ;
   png_byte usr_channels ;
   png_byte sig_bytes ;
   png_byte maximum_pixel_depth ;
   png_byte transformed_pixel_depth ;
   png_byte zstream_start ;
   png_uint_16 filler ;
   png_byte background_gamma_type ;
   png_fixed_point background_gamma ;
   png_color_16 background ;
   png_color_16 background_1 ;
   void (*output_flush_fn)(png_structp  ) ;
   png_uint_32 flush_dist ;
   png_uint_32 flush_rows ;
   int gamma_shift ;
   png_fixed_point screen_gamma ;
   png_bytep gamma_table ;
   png_uint_16pp gamma_16_table ;
   png_bytep gamma_from_1 ;
   png_bytep gamma_to_1 ;
   png_uint_16pp gamma_16_from_1 ;
   png_uint_16pp gamma_16_to_1 ;
   png_color_8 sig_bit ;
   png_color_8 shift ;
   png_bytep trans_alpha ;
   png_color_16 trans_color ;
   void (*read_row_fn)(png_structp  , png_uint_32  , int  ) ;
   void (*write_row_fn)(png_structp  , png_uint_32  , int  ) ;
   void (*info_fn)(png_structp  , png_infop  ) ;
   void (*row_fn)(png_structp  , png_bytep  , png_uint_32  , int  ) ;
   void (*end_fn)(png_structp  , png_infop  ) ;
   png_bytep save_buffer_ptr ;
   png_bytep save_buffer ;
   png_bytep current_buffer_ptr ;
   png_bytep current_buffer ;
   png_uint_32 push_length ;
   png_uint_32 skip_length ;
   size_t save_buffer_size ;
   size_t save_buffer_max ;
   size_t buffer_size ;
   size_t current_buffer_size ;
   int process_mode ;
   int cur_palette ;
   png_bytep palette_lookup ;
   png_bytep quantize_index ;
   png_uint_32 options ;
   char time_buffer[29] ;
   png_uint_32 free_me ;
   png_voidp user_chunk_ptr ;
   int (*read_user_chunk_fn)(png_structp  , png_unknown_chunkp  ) ;
   int unknown_default ;
   unsigned int num_chunk_list ;
   png_bytep chunk_list ;
   png_byte rgb_to_gray_status ;
   png_byte rgb_to_gray_coefficients_set ;
   png_uint_16 rgb_to_gray_red_coeff ;
   png_uint_16 rgb_to_gray_green_coeff ;
   png_bytep riffled_palette ;
   png_uint_32 mng_features_permitted ;
   png_byte filter_type ;
   png_voidp mem_ptr ;
   png_voidp (*malloc_fn)(png_structp  , png_alloc_size_t  ) ;
   void (*free_fn)(png_structp  , png_voidp  ) ;
   png_bytep big_row_buf ;
   png_bytep quantize_sort ;
   png_bytep index_to_palette ;
   png_bytep palette_to_index ;
   png_byte compression_type ;
   png_uint_32 user_width_max ;
   png_uint_32 user_height_max ;
   png_uint_32 user_chunk_cache_max ;
   png_alloc_size_t user_chunk_malloc_max ;
   png_unknown_chunk unknown_chunk ;
   size_t old_big_row_buf_size ;
   png_bytep read_buffer ;
   png_alloc_size_t read_buffer_size ;
   uInt IDAT_read_size ;
   png_uint_32 io_state ;
   png_bytep big_prev_row ;
   void (*read_filter[4])(png_row_infop row_info , png_bytep row , png_const_bytep prev_row ) ;
   png_colorspace colorspace ;
};
#line 55 "/home/goblint2/bench/libpng-1.6.39/pnginfo.h"
struct png_info_def {
   png_uint_32 width ;
   png_uint_32 height ;
   png_uint_32 valid ;
   size_t rowbytes ;
   png_colorp palette ;
   png_uint_16 num_palette ;
   png_uint_16 num_trans ;
   png_byte bit_depth ;
   png_byte color_type ;
   png_byte compression_type ;
   png_byte filter_type ;
   png_byte interlace_type ;
   png_byte channels ;
   png_byte pixel_depth ;
   png_byte spare_byte ;
   png_byte signature[8] ;
   png_colorspace colorspace ;
   png_charp iccp_name ;
   png_bytep iccp_profile ;
   png_uint_32 iccp_proflen ;
   int num_text ;
   int max_text ;
   png_textp text ;
   png_time mod_time ;
   png_color_8 sig_bit ;
   png_bytep trans_alpha ;
   png_color_16 trans_color ;
   png_color_16 background ;
   png_int_32 x_offset ;
   png_int_32 y_offset ;
   png_byte offset_unit_type ;
   png_uint_32 x_pixels_per_unit ;
   png_uint_32 y_pixels_per_unit ;
   png_byte phys_unit_type ;
   int num_exif ;
   png_bytep exif ;
   png_bytep eXIf_buf ;
   png_uint_16p hist ;
   png_charp pcal_purpose ;
   png_int_32 pcal_X0 ;
   png_int_32 pcal_X1 ;
   png_charp pcal_units ;
   png_charpp pcal_params ;
   png_byte pcal_type ;
   png_byte pcal_nparams ;
   png_uint_32 free_me ;
   png_unknown_chunkp unknown_chunks ;
   int unknown_chunks_num ;
   png_sPLT_tp splt_palettes ;
   int splt_palettes_num ;
   png_byte scal_unit ;
   png_charp scal_s_width ;
   png_charp scal_s_height ;
   png_bytepp row_pointers ;
};
#line 928 "/home/goblint2/bench/libpng-1.6.39/pngpriv.h"
typedef png_uint_16p const   *png_const_uint_16pp;
#line 1765 "/home/goblint2/bench/libpng-1.6.39/pngpriv.h"
typedef char png_warning_parameters[8][32];
#line 2026 "/home/goblint2/bench/libpng-1.6.39/pngpriv.h"
struct png_control {
   png_structp png_ptr ;
   png_infop info_ptr ;
   png_voidp error_buf ;
   png_const_bytep memory ;
   size_t size ;
   unsigned int for_write : 1 ;
   unsigned int owned_file : 1 ;
};
#line 2026 "/home/goblint2/bench/libpng-1.6.39/pngpriv.h"
typedef struct png_control png_control;
#line 17 "/home/goblint2/bench/libpng-1.6.39/png.c"
typedef png_libpng_version_1_6_39 Your_png_h_is_not_version_1_6_39;
#line 2245 "/home/goblint2/bench/libpng-1.6.39/png.c"
struct __anonstruct_png_sRGB_checks_880336243 {
   png_uint_32 adler ;
   png_uint_32 crc ;
   png_uint_32 length ;
   png_uint_32 md5[4] ;
   png_byte have_md5 ;
   png_byte is_broken ;
   png_uint_16 intent ;
};
#line 853 "/usr/include/math.h"
enum __anonenum_1037408945___0 {
    FP_NAN___0 = 0,
    FP_INFINITE___0 = 1,
    FP_ZERO___0 = 2,
    FP_SUBNORMAL___0 = 3,
    FP_NORMAL___0 = 4
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum_437032235___0 {
    _PC_LINK_MAX___0 = 0,
    _PC_MAX_CANON___0 = 1,
    _PC_MAX_INPUT___0 = 2,
    _PC_NAME_MAX___0 = 3,
    _PC_PATH_MAX___0 = 4,
    _PC_PIPE_BUF___0 = 5,
    _PC_CHOWN_RESTRICTED___0 = 6,
    _PC_NO_TRUNC___0 = 7,
    _PC_VDISABLE___0 = 8,
    _PC_SYNC_IO___0 = 9,
    _PC_ASYNC_IO___0 = 10,
    _PC_PRIO_IO___0 = 11,
    _PC_SOCK_MAXBUF___0 = 12,
    _PC_FILESIZEBITS___0 = 13,
    _PC_REC_INCR_XFER_SIZE___0 = 14,
    _PC_REC_MAX_XFER_SIZE___0 = 15,
    _PC_REC_MIN_XFER_SIZE___0 = 16,
    _PC_REC_XFER_ALIGN___0 = 17,
    _PC_ALLOC_SIZE_MIN___0 = 18,
    _PC_SYMLINK_MAX___0 = 19,
    _PC_2_SYMLINKS___0 = 20
} ;
#line 71
enum __anonenum_315186338___0 {
    _SC_ARG_MAX___0 = 0,
    _SC_CHILD_MAX___0 = 1,
    _SC_CLK_TCK___0 = 2,
    _SC_NGROUPS_MAX___0 = 3,
    _SC_OPEN_MAX___0 = 4,
    _SC_STREAM_MAX___0 = 5,
    _SC_TZNAME_MAX___0 = 6,
    _SC_JOB_CONTROL___0 = 7,
    _SC_SAVED_IDS___0 = 8,
    _SC_REALTIME_SIGNALS___0 = 9,
    _SC_PRIORITY_SCHEDULING___0 = 10,
    _SC_TIMERS___0 = 11,
    _SC_ASYNCHRONOUS_IO___0 = 12,
    _SC_PRIORITIZED_IO___0 = 13,
    _SC_SYNCHRONIZED_IO___0 = 14,
    _SC_FSYNC___0 = 15,
    _SC_MAPPED_FILES___0 = 16,
    _SC_MEMLOCK___0 = 17,
    _SC_MEMLOCK_RANGE___0 = 18,
    _SC_MEMORY_PROTECTION___0 = 19,
    _SC_MESSAGE_PASSING___0 = 20,
    _SC_SEMAPHORES___0 = 21,
    _SC_SHARED_MEMORY_OBJECTS___0 = 22,
    _SC_AIO_LISTIO_MAX___0 = 23,
    _SC_AIO_MAX___0 = 24,
    _SC_AIO_PRIO_DELTA_MAX___0 = 25,
    _SC_DELAYTIMER_MAX___0 = 26,
    _SC_MQ_OPEN_MAX___0 = 27,
    _SC_MQ_PRIO_MAX___0 = 28,
    _SC_VERSION___0 = 29,
    _SC_PAGESIZE___0 = 30,
    _SC_RTSIG_MAX___0 = 31,
    _SC_SEM_NSEMS_MAX___0 = 32,
    _SC_SEM_VALUE_MAX___0 = 33,
    _SC_SIGQUEUE_MAX___0 = 34,
    _SC_TIMER_MAX___0 = 35,
    _SC_BC_BASE_MAX___0 = 36,
    _SC_BC_DIM_MAX___0 = 37,
    _SC_BC_SCALE_MAX___0 = 38,
    _SC_BC_STRING_MAX___0 = 39,
    _SC_COLL_WEIGHTS_MAX___0 = 40,
    _SC_EQUIV_CLASS_MAX___0 = 41,
    _SC_EXPR_NEST_MAX___0 = 42,
    _SC_LINE_MAX___0 = 43,
    _SC_RE_DUP_MAX___0 = 44,
    _SC_CHARCLASS_NAME_MAX___0 = 45,
    _SC_2_VERSION___0 = 46,
    _SC_2_C_BIND___0 = 47,
    _SC_2_C_DEV___0 = 48,
    _SC_2_FORT_DEV___0 = 49,
    _SC_2_FORT_RUN___0 = 50,
    _SC_2_SW_DEV___0 = 51,
    _SC_2_LOCALEDEF___0 = 52,
    _SC_PII___0 = 53,
    _SC_PII_XTI___0 = 54,
    _SC_PII_SOCKET___0 = 55,
    _SC_PII_INTERNET___0 = 56,
    _SC_PII_OSI___0 = 57,
    _SC_POLL___0 = 58,
    _SC_SELECT___0 = 59,
    _SC_UIO_MAXIOV___0 = 60,
    _SC_IOV_MAX___0 = 60,
    _SC_PII_INTERNET_STREAM___0 = 61,
    _SC_PII_INTERNET_DGRAM___0 = 62,
    _SC_PII_OSI_COTS___0 = 63,
    _SC_PII_OSI_CLTS___0 = 64,
    _SC_PII_OSI_M___0 = 65,
    _SC_T_IOV_MAX___0 = 66,
    _SC_THREADS___0 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___0 = 68,
    _SC_GETGR_R_SIZE_MAX___0 = 69,
    _SC_GETPW_R_SIZE_MAX___0 = 70,
    _SC_LOGIN_NAME_MAX___0 = 71,
    _SC_TTY_NAME_MAX___0 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___0 = 73,
    _SC_THREAD_KEYS_MAX___0 = 74,
    _SC_THREAD_STACK_MIN___0 = 75,
    _SC_THREAD_THREADS_MAX___0 = 76,
    _SC_THREAD_ATTR_STACKADDR___0 = 77,
    _SC_THREAD_ATTR_STACKSIZE___0 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___0 = 79,
    _SC_THREAD_PRIO_INHERIT___0 = 80,
    _SC_THREAD_PRIO_PROTECT___0 = 81,
    _SC_THREAD_PROCESS_SHARED___0 = 82,
    _SC_NPROCESSORS_CONF___0 = 83,
    _SC_NPROCESSORS_ONLN___0 = 84,
    _SC_PHYS_PAGES___0 = 85,
    _SC_AVPHYS_PAGES___0 = 86,
    _SC_ATEXIT_MAX___0 = 87,
    _SC_PASS_MAX___0 = 88,
    _SC_XOPEN_VERSION___0 = 89,
    _SC_XOPEN_XCU_VERSION___0 = 90,
    _SC_XOPEN_UNIX___0 = 91,
    _SC_XOPEN_CRYPT___0 = 92,
    _SC_XOPEN_ENH_I18N___0 = 93,
    _SC_XOPEN_SHM___0 = 94,
    _SC_2_CHAR_TERM___0 = 95,
    _SC_2_C_VERSION___0 = 96,
    _SC_2_UPE___0 = 97,
    _SC_XOPEN_XPG2___0 = 98,
    _SC_XOPEN_XPG3___0 = 99,
    _SC_XOPEN_XPG4___0 = 100,
    _SC_CHAR_BIT___0 = 101,
    _SC_CHAR_MAX___0 = 102,
    _SC_CHAR_MIN___0 = 103,
    _SC_INT_MAX___0 = 104,
    _SC_INT_MIN___0 = 105,
    _SC_LONG_BIT___0 = 106,
    _SC_WORD_BIT___0 = 107,
    _SC_MB_LEN_MAX___0 = 108,
    _SC_NZERO___0 = 109,
    _SC_SSIZE_MAX___0 = 110,
    _SC_SCHAR_MAX___0 = 111,
    _SC_SCHAR_MIN___0 = 112,
    _SC_SHRT_MAX___0 = 113,
    _SC_SHRT_MIN___0 = 114,
    _SC_UCHAR_MAX___0 = 115,
    _SC_UINT_MAX___0 = 116,
    _SC_ULONG_MAX___0 = 117,
    _SC_USHRT_MAX___0 = 118,
    _SC_NL_ARGMAX___0 = 119,
    _SC_NL_LANGMAX___0 = 120,
    _SC_NL_MSGMAX___0 = 121,
    _SC_NL_NMAX___0 = 122,
    _SC_NL_SETMAX___0 = 123,
    _SC_NL_TEXTMAX___0 = 124,
    _SC_XBS5_ILP32_OFF32___0 = 125,
    _SC_XBS5_ILP32_OFFBIG___0 = 126,
    _SC_XBS5_LP64_OFF64___0 = 127,
    _SC_XBS5_LPBIG_OFFBIG___0 = 128,
    _SC_XOPEN_LEGACY___0 = 129,
    _SC_XOPEN_REALTIME___0 = 130,
    _SC_XOPEN_REALTIME_THREADS___0 = 131,
    _SC_ADVISORY_INFO___0 = 132,
    _SC_BARRIERS___0 = 133,
    _SC_BASE___0 = 134,
    _SC_C_LANG_SUPPORT___0 = 135,
    _SC_C_LANG_SUPPORT_R___0 = 136,
    _SC_CLOCK_SELECTION___0 = 137,
    _SC_CPUTIME___0 = 138,
    _SC_THREAD_CPUTIME___0 = 139,
    _SC_DEVICE_IO___0 = 140,
    _SC_DEVICE_SPECIFIC___0 = 141,
    _SC_DEVICE_SPECIFIC_R___0 = 142,
    _SC_FD_MGMT___0 = 143,
    _SC_FIFO___0 = 144,
    _SC_PIPE___0 = 145,
    _SC_FILE_ATTRIBUTES___0 = 146,
    _SC_FILE_LOCKING___0 = 147,
    _SC_FILE_SYSTEM___0 = 148,
    _SC_MONOTONIC_CLOCK___0 = 149,
    _SC_MULTI_PROCESS___0 = 150,
    _SC_SINGLE_PROCESS___0 = 151,
    _SC_NETWORKING___0 = 152,
    _SC_READER_WRITER_LOCKS___0 = 153,
    _SC_SPIN_LOCKS___0 = 154,
    _SC_REGEXP___0 = 155,
    _SC_REGEX_VERSION___0 = 156,
    _SC_SHELL___0 = 157,
    _SC_SIGNALS___0 = 158,
    _SC_SPAWN___0 = 159,
    _SC_SPORADIC_SERVER___0 = 160,
    _SC_THREAD_SPORADIC_SERVER___0 = 161,
    _SC_SYSTEM_DATABASE___0 = 162,
    _SC_SYSTEM_DATABASE_R___0 = 163,
    _SC_TIMEOUTS___0 = 164,
    _SC_TYPED_MEMORY_OBJECTS___0 = 165,
    _SC_USER_GROUPS___0 = 166,
    _SC_USER_GROUPS_R___0 = 167,
    _SC_2_PBS___0 = 168,
    _SC_2_PBS_ACCOUNTING___0 = 169,
    _SC_2_PBS_LOCATE___0 = 170,
    _SC_2_PBS_MESSAGE___0 = 171,
    _SC_2_PBS_TRACK___0 = 172,
    _SC_SYMLOOP_MAX___0 = 173,
    _SC_STREAMS___0 = 174,
    _SC_2_PBS_CHECKPOINT___0 = 175,
    _SC_V6_ILP32_OFF32___0 = 176,
    _SC_V6_ILP32_OFFBIG___0 = 177,
    _SC_V6_LP64_OFF64___0 = 178,
    _SC_V6_LPBIG_OFFBIG___0 = 179,
    _SC_HOST_NAME_MAX___0 = 180,
    _SC_TRACE___0 = 181,
    _SC_TRACE_EVENT_FILTER___0 = 182,
    _SC_TRACE_INHERIT___0 = 183,
    _SC_TRACE_LOG___0 = 184,
    _SC_LEVEL1_ICACHE_SIZE___0 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___0 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___0 = 187,
    _SC_LEVEL1_DCACHE_SIZE___0 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___0 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___0 = 190,
    _SC_LEVEL2_CACHE_SIZE___0 = 191,
    _SC_LEVEL2_CACHE_ASSOC___0 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___0 = 193,
    _SC_LEVEL3_CACHE_SIZE___0 = 194,
    _SC_LEVEL3_CACHE_ASSOC___0 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___0 = 196,
    _SC_LEVEL4_CACHE_SIZE___0 = 197,
    _SC_LEVEL4_CACHE_ASSOC___0 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___0 = 199,
    _SC_IPV6___0 = 235,
    _SC_RAW_SOCKETS___0 = 236,
    _SC_V7_ILP32_OFF32___0 = 237,
    _SC_V7_ILP32_OFFBIG___0 = 238,
    _SC_V7_LP64_OFF64___0 = 239,
    _SC_V7_LPBIG_OFFBIG___0 = 240,
    _SC_SS_REPL_MAX___0 = 241,
    _SC_TRACE_EVENT_NAME_MAX___0 = 242,
    _SC_TRACE_NAME_MAX___0 = 243,
    _SC_TRACE_SYS_MAX___0 = 244,
    _SC_TRACE_USER_EVENT_MAX___0 = 245,
    _SC_XOPEN_STREAMS___0 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___0 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___0 = 248
} ;
#line 533
enum __anonenum_875524036___0 {
    _CS_PATH___0 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___0 = 1,
    _CS_GNU_LIBC_VERSION___0 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___0 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___0 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___0 = 5,
    _CS_LFS_CFLAGS___0 = 1000,
    _CS_LFS_LDFLAGS___0 = 1001,
    _CS_LFS_LIBS___0 = 1002,
    _CS_LFS_LINTFLAGS___0 = 1003,
    _CS_LFS64_CFLAGS___0 = 1004,
    _CS_LFS64_LDFLAGS___0 = 1005,
    _CS_LFS64_LIBS___0 = 1006,
    _CS_LFS64_LINTFLAGS___0 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___0 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___0 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___0 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___0 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___0 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___0 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___0 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___0 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___0 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___0 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___0 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___0 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___0 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___0 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___0 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___0 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___0 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___0 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___0 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___0 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___0 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___0 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___0 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___0 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___0 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___0 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___0 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___0 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___0 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___0 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___0 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___0 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___0 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___0 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___0 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___0 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___0 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___0 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___0 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___0 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___0 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___0 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___0 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___0 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___0 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___0 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___0 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___0 = 1147,
    _CS_V6_ENV___0 = 1148,
    _CS_V7_ENV___0 = 1149
} ;
#line 853 "/usr/include/math.h"
enum __anonenum_1037408945___1 {
    FP_NAN___1 = 0,
    FP_INFINITE___1 = 1,
    FP_ZERO___1 = 2,
    FP_SUBNORMAL___1 = 3,
    FP_NORMAL___1 = 4
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum_437032235___1 {
    _PC_LINK_MAX___1 = 0,
    _PC_MAX_CANON___1 = 1,
    _PC_MAX_INPUT___1 = 2,
    _PC_NAME_MAX___1 = 3,
    _PC_PATH_MAX___1 = 4,
    _PC_PIPE_BUF___1 = 5,
    _PC_CHOWN_RESTRICTED___1 = 6,
    _PC_NO_TRUNC___1 = 7,
    _PC_VDISABLE___1 = 8,
    _PC_SYNC_IO___1 = 9,
    _PC_ASYNC_IO___1 = 10,
    _PC_PRIO_IO___1 = 11,
    _PC_SOCK_MAXBUF___1 = 12,
    _PC_FILESIZEBITS___1 = 13,
    _PC_REC_INCR_XFER_SIZE___1 = 14,
    _PC_REC_MAX_XFER_SIZE___1 = 15,
    _PC_REC_MIN_XFER_SIZE___1 = 16,
    _PC_REC_XFER_ALIGN___1 = 17,
    _PC_ALLOC_SIZE_MIN___1 = 18,
    _PC_SYMLINK_MAX___1 = 19,
    _PC_2_SYMLINKS___1 = 20
} ;
#line 71
enum __anonenum_315186338___1 {
    _SC_ARG_MAX___1 = 0,
    _SC_CHILD_MAX___1 = 1,
    _SC_CLK_TCK___1 = 2,
    _SC_NGROUPS_MAX___1 = 3,
    _SC_OPEN_MAX___1 = 4,
    _SC_STREAM_MAX___1 = 5,
    _SC_TZNAME_MAX___1 = 6,
    _SC_JOB_CONTROL___1 = 7,
    _SC_SAVED_IDS___1 = 8,
    _SC_REALTIME_SIGNALS___1 = 9,
    _SC_PRIORITY_SCHEDULING___1 = 10,
    _SC_TIMERS___1 = 11,
    _SC_ASYNCHRONOUS_IO___1 = 12,
    _SC_PRIORITIZED_IO___1 = 13,
    _SC_SYNCHRONIZED_IO___1 = 14,
    _SC_FSYNC___1 = 15,
    _SC_MAPPED_FILES___1 = 16,
    _SC_MEMLOCK___1 = 17,
    _SC_MEMLOCK_RANGE___1 = 18,
    _SC_MEMORY_PROTECTION___1 = 19,
    _SC_MESSAGE_PASSING___1 = 20,
    _SC_SEMAPHORES___1 = 21,
    _SC_SHARED_MEMORY_OBJECTS___1 = 22,
    _SC_AIO_LISTIO_MAX___1 = 23,
    _SC_AIO_MAX___1 = 24,
    _SC_AIO_PRIO_DELTA_MAX___1 = 25,
    _SC_DELAYTIMER_MAX___1 = 26,
    _SC_MQ_OPEN_MAX___1 = 27,
    _SC_MQ_PRIO_MAX___1 = 28,
    _SC_VERSION___1 = 29,
    _SC_PAGESIZE___1 = 30,
    _SC_RTSIG_MAX___1 = 31,
    _SC_SEM_NSEMS_MAX___1 = 32,
    _SC_SEM_VALUE_MAX___1 = 33,
    _SC_SIGQUEUE_MAX___1 = 34,
    _SC_TIMER_MAX___1 = 35,
    _SC_BC_BASE_MAX___1 = 36,
    _SC_BC_DIM_MAX___1 = 37,
    _SC_BC_SCALE_MAX___1 = 38,
    _SC_BC_STRING_MAX___1 = 39,
    _SC_COLL_WEIGHTS_MAX___1 = 40,
    _SC_EQUIV_CLASS_MAX___1 = 41,
    _SC_EXPR_NEST_MAX___1 = 42,
    _SC_LINE_MAX___1 = 43,
    _SC_RE_DUP_MAX___1 = 44,
    _SC_CHARCLASS_NAME_MAX___1 = 45,
    _SC_2_VERSION___1 = 46,
    _SC_2_C_BIND___1 = 47,
    _SC_2_C_DEV___1 = 48,
    _SC_2_FORT_DEV___1 = 49,
    _SC_2_FORT_RUN___1 = 50,
    _SC_2_SW_DEV___1 = 51,
    _SC_2_LOCALEDEF___1 = 52,
    _SC_PII___1 = 53,
    _SC_PII_XTI___1 = 54,
    _SC_PII_SOCKET___1 = 55,
    _SC_PII_INTERNET___1 = 56,
    _SC_PII_OSI___1 = 57,
    _SC_POLL___1 = 58,
    _SC_SELECT___1 = 59,
    _SC_UIO_MAXIOV___1 = 60,
    _SC_IOV_MAX___1 = 60,
    _SC_PII_INTERNET_STREAM___1 = 61,
    _SC_PII_INTERNET_DGRAM___1 = 62,
    _SC_PII_OSI_COTS___1 = 63,
    _SC_PII_OSI_CLTS___1 = 64,
    _SC_PII_OSI_M___1 = 65,
    _SC_T_IOV_MAX___1 = 66,
    _SC_THREADS___1 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___1 = 68,
    _SC_GETGR_R_SIZE_MAX___1 = 69,
    _SC_GETPW_R_SIZE_MAX___1 = 70,
    _SC_LOGIN_NAME_MAX___1 = 71,
    _SC_TTY_NAME_MAX___1 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___1 = 73,
    _SC_THREAD_KEYS_MAX___1 = 74,
    _SC_THREAD_STACK_MIN___1 = 75,
    _SC_THREAD_THREADS_MAX___1 = 76,
    _SC_THREAD_ATTR_STACKADDR___1 = 77,
    _SC_THREAD_ATTR_STACKSIZE___1 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___1 = 79,
    _SC_THREAD_PRIO_INHERIT___1 = 80,
    _SC_THREAD_PRIO_PROTECT___1 = 81,
    _SC_THREAD_PROCESS_SHARED___1 = 82,
    _SC_NPROCESSORS_CONF___1 = 83,
    _SC_NPROCESSORS_ONLN___1 = 84,
    _SC_PHYS_PAGES___1 = 85,
    _SC_AVPHYS_PAGES___1 = 86,
    _SC_ATEXIT_MAX___1 = 87,
    _SC_PASS_MAX___1 = 88,
    _SC_XOPEN_VERSION___1 = 89,
    _SC_XOPEN_XCU_VERSION___1 = 90,
    _SC_XOPEN_UNIX___1 = 91,
    _SC_XOPEN_CRYPT___1 = 92,
    _SC_XOPEN_ENH_I18N___1 = 93,
    _SC_XOPEN_SHM___1 = 94,
    _SC_2_CHAR_TERM___1 = 95,
    _SC_2_C_VERSION___1 = 96,
    _SC_2_UPE___1 = 97,
    _SC_XOPEN_XPG2___1 = 98,
    _SC_XOPEN_XPG3___1 = 99,
    _SC_XOPEN_XPG4___1 = 100,
    _SC_CHAR_BIT___1 = 101,
    _SC_CHAR_MAX___1 = 102,
    _SC_CHAR_MIN___1 = 103,
    _SC_INT_MAX___1 = 104,
    _SC_INT_MIN___1 = 105,
    _SC_LONG_BIT___1 = 106,
    _SC_WORD_BIT___1 = 107,
    _SC_MB_LEN_MAX___1 = 108,
    _SC_NZERO___1 = 109,
    _SC_SSIZE_MAX___1 = 110,
    _SC_SCHAR_MAX___1 = 111,
    _SC_SCHAR_MIN___1 = 112,
    _SC_SHRT_MAX___1 = 113,
    _SC_SHRT_MIN___1 = 114,
    _SC_UCHAR_MAX___1 = 115,
    _SC_UINT_MAX___1 = 116,
    _SC_ULONG_MAX___1 = 117,
    _SC_USHRT_MAX___1 = 118,
    _SC_NL_ARGMAX___1 = 119,
    _SC_NL_LANGMAX___1 = 120,
    _SC_NL_MSGMAX___1 = 121,
    _SC_NL_NMAX___1 = 122,
    _SC_NL_SETMAX___1 = 123,
    _SC_NL_TEXTMAX___1 = 124,
    _SC_XBS5_ILP32_OFF32___1 = 125,
    _SC_XBS5_ILP32_OFFBIG___1 = 126,
    _SC_XBS5_LP64_OFF64___1 = 127,
    _SC_XBS5_LPBIG_OFFBIG___1 = 128,
    _SC_XOPEN_LEGACY___1 = 129,
    _SC_XOPEN_REALTIME___1 = 130,
    _SC_XOPEN_REALTIME_THREADS___1 = 131,
    _SC_ADVISORY_INFO___1 = 132,
    _SC_BARRIERS___1 = 133,
    _SC_BASE___1 = 134,
    _SC_C_LANG_SUPPORT___1 = 135,
    _SC_C_LANG_SUPPORT_R___1 = 136,
    _SC_CLOCK_SELECTION___1 = 137,
    _SC_CPUTIME___1 = 138,
    _SC_THREAD_CPUTIME___1 = 139,
    _SC_DEVICE_IO___1 = 140,
    _SC_DEVICE_SPECIFIC___1 = 141,
    _SC_DEVICE_SPECIFIC_R___1 = 142,
    _SC_FD_MGMT___1 = 143,
    _SC_FIFO___1 = 144,
    _SC_PIPE___1 = 145,
    _SC_FILE_ATTRIBUTES___1 = 146,
    _SC_FILE_LOCKING___1 = 147,
    _SC_FILE_SYSTEM___1 = 148,
    _SC_MONOTONIC_CLOCK___1 = 149,
    _SC_MULTI_PROCESS___1 = 150,
    _SC_SINGLE_PROCESS___1 = 151,
    _SC_NETWORKING___1 = 152,
    _SC_READER_WRITER_LOCKS___1 = 153,
    _SC_SPIN_LOCKS___1 = 154,
    _SC_REGEXP___1 = 155,
    _SC_REGEX_VERSION___1 = 156,
    _SC_SHELL___1 = 157,
    _SC_SIGNALS___1 = 158,
    _SC_SPAWN___1 = 159,
    _SC_SPORADIC_SERVER___1 = 160,
    _SC_THREAD_SPORADIC_SERVER___1 = 161,
    _SC_SYSTEM_DATABASE___1 = 162,
    _SC_SYSTEM_DATABASE_R___1 = 163,
    _SC_TIMEOUTS___1 = 164,
    _SC_TYPED_MEMORY_OBJECTS___1 = 165,
    _SC_USER_GROUPS___1 = 166,
    _SC_USER_GROUPS_R___1 = 167,
    _SC_2_PBS___1 = 168,
    _SC_2_PBS_ACCOUNTING___1 = 169,
    _SC_2_PBS_LOCATE___1 = 170,
    _SC_2_PBS_MESSAGE___1 = 171,
    _SC_2_PBS_TRACK___1 = 172,
    _SC_SYMLOOP_MAX___1 = 173,
    _SC_STREAMS___1 = 174,
    _SC_2_PBS_CHECKPOINT___1 = 175,
    _SC_V6_ILP32_OFF32___1 = 176,
    _SC_V6_ILP32_OFFBIG___1 = 177,
    _SC_V6_LP64_OFF64___1 = 178,
    _SC_V6_LPBIG_OFFBIG___1 = 179,
    _SC_HOST_NAME_MAX___1 = 180,
    _SC_TRACE___1 = 181,
    _SC_TRACE_EVENT_FILTER___1 = 182,
    _SC_TRACE_INHERIT___1 = 183,
    _SC_TRACE_LOG___1 = 184,
    _SC_LEVEL1_ICACHE_SIZE___1 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___1 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___1 = 187,
    _SC_LEVEL1_DCACHE_SIZE___1 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___1 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___1 = 190,
    _SC_LEVEL2_CACHE_SIZE___1 = 191,
    _SC_LEVEL2_CACHE_ASSOC___1 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___1 = 193,
    _SC_LEVEL3_CACHE_SIZE___1 = 194,
    _SC_LEVEL3_CACHE_ASSOC___1 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___1 = 196,
    _SC_LEVEL4_CACHE_SIZE___1 = 197,
    _SC_LEVEL4_CACHE_ASSOC___1 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___1 = 199,
    _SC_IPV6___1 = 235,
    _SC_RAW_SOCKETS___1 = 236,
    _SC_V7_ILP32_OFF32___1 = 237,
    _SC_V7_ILP32_OFFBIG___1 = 238,
    _SC_V7_LP64_OFF64___1 = 239,
    _SC_V7_LPBIG_OFFBIG___1 = 240,
    _SC_SS_REPL_MAX___1 = 241,
    _SC_TRACE_EVENT_NAME_MAX___1 = 242,
    _SC_TRACE_NAME_MAX___1 = 243,
    _SC_TRACE_SYS_MAX___1 = 244,
    _SC_TRACE_USER_EVENT_MAX___1 = 245,
    _SC_XOPEN_STREAMS___1 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___1 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___1 = 248
} ;
#line 533
enum __anonenum_875524036___1 {
    _CS_PATH___1 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___1 = 1,
    _CS_GNU_LIBC_VERSION___1 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___1 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___1 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___1 = 5,
    _CS_LFS_CFLAGS___1 = 1000,
    _CS_LFS_LDFLAGS___1 = 1001,
    _CS_LFS_LIBS___1 = 1002,
    _CS_LFS_LINTFLAGS___1 = 1003,
    _CS_LFS64_CFLAGS___1 = 1004,
    _CS_LFS64_LDFLAGS___1 = 1005,
    _CS_LFS64_LIBS___1 = 1006,
    _CS_LFS64_LINTFLAGS___1 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___1 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___1 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___1 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___1 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___1 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___1 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___1 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___1 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___1 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___1 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___1 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___1 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___1 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___1 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___1 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___1 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___1 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___1 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___1 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___1 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___1 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___1 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___1 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___1 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___1 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___1 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___1 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___1 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___1 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___1 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___1 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___1 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___1 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___1 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___1 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___1 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___1 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___1 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___1 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___1 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___1 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___1 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___1 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___1 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___1 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___1 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___1 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___1 = 1147,
    _CS_V6_ENV___1 = 1148,
    _CS_V7_ENV___1 = 1149
} ;
#line 853 "/usr/include/math.h"
enum __anonenum_1037408945___2 {
    FP_NAN___2 = 0,
    FP_INFINITE___2 = 1,
    FP_ZERO___2 = 2,
    FP_SUBNORMAL___2 = 3,
    FP_NORMAL___2 = 4
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum_437032235___2 {
    _PC_LINK_MAX___2 = 0,
    _PC_MAX_CANON___2 = 1,
    _PC_MAX_INPUT___2 = 2,
    _PC_NAME_MAX___2 = 3,
    _PC_PATH_MAX___2 = 4,
    _PC_PIPE_BUF___2 = 5,
    _PC_CHOWN_RESTRICTED___2 = 6,
    _PC_NO_TRUNC___2 = 7,
    _PC_VDISABLE___2 = 8,
    _PC_SYNC_IO___2 = 9,
    _PC_ASYNC_IO___2 = 10,
    _PC_PRIO_IO___2 = 11,
    _PC_SOCK_MAXBUF___2 = 12,
    _PC_FILESIZEBITS___2 = 13,
    _PC_REC_INCR_XFER_SIZE___2 = 14,
    _PC_REC_MAX_XFER_SIZE___2 = 15,
    _PC_REC_MIN_XFER_SIZE___2 = 16,
    _PC_REC_XFER_ALIGN___2 = 17,
    _PC_ALLOC_SIZE_MIN___2 = 18,
    _PC_SYMLINK_MAX___2 = 19,
    _PC_2_SYMLINKS___2 = 20
} ;
#line 71
enum __anonenum_315186338___2 {
    _SC_ARG_MAX___2 = 0,
    _SC_CHILD_MAX___2 = 1,
    _SC_CLK_TCK___2 = 2,
    _SC_NGROUPS_MAX___2 = 3,
    _SC_OPEN_MAX___2 = 4,
    _SC_STREAM_MAX___2 = 5,
    _SC_TZNAME_MAX___2 = 6,
    _SC_JOB_CONTROL___2 = 7,
    _SC_SAVED_IDS___2 = 8,
    _SC_REALTIME_SIGNALS___2 = 9,
    _SC_PRIORITY_SCHEDULING___2 = 10,
    _SC_TIMERS___2 = 11,
    _SC_ASYNCHRONOUS_IO___2 = 12,
    _SC_PRIORITIZED_IO___2 = 13,
    _SC_SYNCHRONIZED_IO___2 = 14,
    _SC_FSYNC___2 = 15,
    _SC_MAPPED_FILES___2 = 16,
    _SC_MEMLOCK___2 = 17,
    _SC_MEMLOCK_RANGE___2 = 18,
    _SC_MEMORY_PROTECTION___2 = 19,
    _SC_MESSAGE_PASSING___2 = 20,
    _SC_SEMAPHORES___2 = 21,
    _SC_SHARED_MEMORY_OBJECTS___2 = 22,
    _SC_AIO_LISTIO_MAX___2 = 23,
    _SC_AIO_MAX___2 = 24,
    _SC_AIO_PRIO_DELTA_MAX___2 = 25,
    _SC_DELAYTIMER_MAX___2 = 26,
    _SC_MQ_OPEN_MAX___2 = 27,
    _SC_MQ_PRIO_MAX___2 = 28,
    _SC_VERSION___2 = 29,
    _SC_PAGESIZE___2 = 30,
    _SC_RTSIG_MAX___2 = 31,
    _SC_SEM_NSEMS_MAX___2 = 32,
    _SC_SEM_VALUE_MAX___2 = 33,
    _SC_SIGQUEUE_MAX___2 = 34,
    _SC_TIMER_MAX___2 = 35,
    _SC_BC_BASE_MAX___2 = 36,
    _SC_BC_DIM_MAX___2 = 37,
    _SC_BC_SCALE_MAX___2 = 38,
    _SC_BC_STRING_MAX___2 = 39,
    _SC_COLL_WEIGHTS_MAX___2 = 40,
    _SC_EQUIV_CLASS_MAX___2 = 41,
    _SC_EXPR_NEST_MAX___2 = 42,
    _SC_LINE_MAX___2 = 43,
    _SC_RE_DUP_MAX___2 = 44,
    _SC_CHARCLASS_NAME_MAX___2 = 45,
    _SC_2_VERSION___2 = 46,
    _SC_2_C_BIND___2 = 47,
    _SC_2_C_DEV___2 = 48,
    _SC_2_FORT_DEV___2 = 49,
    _SC_2_FORT_RUN___2 = 50,
    _SC_2_SW_DEV___2 = 51,
    _SC_2_LOCALEDEF___2 = 52,
    _SC_PII___2 = 53,
    _SC_PII_XTI___2 = 54,
    _SC_PII_SOCKET___2 = 55,
    _SC_PII_INTERNET___2 = 56,
    _SC_PII_OSI___2 = 57,
    _SC_POLL___2 = 58,
    _SC_SELECT___2 = 59,
    _SC_UIO_MAXIOV___2 = 60,
    _SC_IOV_MAX___2 = 60,
    _SC_PII_INTERNET_STREAM___2 = 61,
    _SC_PII_INTERNET_DGRAM___2 = 62,
    _SC_PII_OSI_COTS___2 = 63,
    _SC_PII_OSI_CLTS___2 = 64,
    _SC_PII_OSI_M___2 = 65,
    _SC_T_IOV_MAX___2 = 66,
    _SC_THREADS___2 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___2 = 68,
    _SC_GETGR_R_SIZE_MAX___2 = 69,
    _SC_GETPW_R_SIZE_MAX___2 = 70,
    _SC_LOGIN_NAME_MAX___2 = 71,
    _SC_TTY_NAME_MAX___2 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___2 = 73,
    _SC_THREAD_KEYS_MAX___2 = 74,
    _SC_THREAD_STACK_MIN___2 = 75,
    _SC_THREAD_THREADS_MAX___2 = 76,
    _SC_THREAD_ATTR_STACKADDR___2 = 77,
    _SC_THREAD_ATTR_STACKSIZE___2 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___2 = 79,
    _SC_THREAD_PRIO_INHERIT___2 = 80,
    _SC_THREAD_PRIO_PROTECT___2 = 81,
    _SC_THREAD_PROCESS_SHARED___2 = 82,
    _SC_NPROCESSORS_CONF___2 = 83,
    _SC_NPROCESSORS_ONLN___2 = 84,
    _SC_PHYS_PAGES___2 = 85,
    _SC_AVPHYS_PAGES___2 = 86,
    _SC_ATEXIT_MAX___2 = 87,
    _SC_PASS_MAX___2 = 88,
    _SC_XOPEN_VERSION___2 = 89,
    _SC_XOPEN_XCU_VERSION___2 = 90,
    _SC_XOPEN_UNIX___2 = 91,
    _SC_XOPEN_CRYPT___2 = 92,
    _SC_XOPEN_ENH_I18N___2 = 93,
    _SC_XOPEN_SHM___2 = 94,
    _SC_2_CHAR_TERM___2 = 95,
    _SC_2_C_VERSION___2 = 96,
    _SC_2_UPE___2 = 97,
    _SC_XOPEN_XPG2___2 = 98,
    _SC_XOPEN_XPG3___2 = 99,
    _SC_XOPEN_XPG4___2 = 100,
    _SC_CHAR_BIT___2 = 101,
    _SC_CHAR_MAX___2 = 102,
    _SC_CHAR_MIN___2 = 103,
    _SC_INT_MAX___2 = 104,
    _SC_INT_MIN___2 = 105,
    _SC_LONG_BIT___2 = 106,
    _SC_WORD_BIT___2 = 107,
    _SC_MB_LEN_MAX___2 = 108,
    _SC_NZERO___2 = 109,
    _SC_SSIZE_MAX___2 = 110,
    _SC_SCHAR_MAX___2 = 111,
    _SC_SCHAR_MIN___2 = 112,
    _SC_SHRT_MAX___2 = 113,
    _SC_SHRT_MIN___2 = 114,
    _SC_UCHAR_MAX___2 = 115,
    _SC_UINT_MAX___2 = 116,
    _SC_ULONG_MAX___2 = 117,
    _SC_USHRT_MAX___2 = 118,
    _SC_NL_ARGMAX___2 = 119,
    _SC_NL_LANGMAX___2 = 120,
    _SC_NL_MSGMAX___2 = 121,
    _SC_NL_NMAX___2 = 122,
    _SC_NL_SETMAX___2 = 123,
    _SC_NL_TEXTMAX___2 = 124,
    _SC_XBS5_ILP32_OFF32___2 = 125,
    _SC_XBS5_ILP32_OFFBIG___2 = 126,
    _SC_XBS5_LP64_OFF64___2 = 127,
    _SC_XBS5_LPBIG_OFFBIG___2 = 128,
    _SC_XOPEN_LEGACY___2 = 129,
    _SC_XOPEN_REALTIME___2 = 130,
    _SC_XOPEN_REALTIME_THREADS___2 = 131,
    _SC_ADVISORY_INFO___2 = 132,
    _SC_BARRIERS___2 = 133,
    _SC_BASE___2 = 134,
    _SC_C_LANG_SUPPORT___2 = 135,
    _SC_C_LANG_SUPPORT_R___2 = 136,
    _SC_CLOCK_SELECTION___2 = 137,
    _SC_CPUTIME___2 = 138,
    _SC_THREAD_CPUTIME___2 = 139,
    _SC_DEVICE_IO___2 = 140,
    _SC_DEVICE_SPECIFIC___2 = 141,
    _SC_DEVICE_SPECIFIC_R___2 = 142,
    _SC_FD_MGMT___2 = 143,
    _SC_FIFO___2 = 144,
    _SC_PIPE___2 = 145,
    _SC_FILE_ATTRIBUTES___2 = 146,
    _SC_FILE_LOCKING___2 = 147,
    _SC_FILE_SYSTEM___2 = 148,
    _SC_MONOTONIC_CLOCK___2 = 149,
    _SC_MULTI_PROCESS___2 = 150,
    _SC_SINGLE_PROCESS___2 = 151,
    _SC_NETWORKING___2 = 152,
    _SC_READER_WRITER_LOCKS___2 = 153,
    _SC_SPIN_LOCKS___2 = 154,
    _SC_REGEXP___2 = 155,
    _SC_REGEX_VERSION___2 = 156,
    _SC_SHELL___2 = 157,
    _SC_SIGNALS___2 = 158,
    _SC_SPAWN___2 = 159,
    _SC_SPORADIC_SERVER___2 = 160,
    _SC_THREAD_SPORADIC_SERVER___2 = 161,
    _SC_SYSTEM_DATABASE___2 = 162,
    _SC_SYSTEM_DATABASE_R___2 = 163,
    _SC_TIMEOUTS___2 = 164,
    _SC_TYPED_MEMORY_OBJECTS___2 = 165,
    _SC_USER_GROUPS___2 = 166,
    _SC_USER_GROUPS_R___2 = 167,
    _SC_2_PBS___2 = 168,
    _SC_2_PBS_ACCOUNTING___2 = 169,
    _SC_2_PBS_LOCATE___2 = 170,
    _SC_2_PBS_MESSAGE___2 = 171,
    _SC_2_PBS_TRACK___2 = 172,
    _SC_SYMLOOP_MAX___2 = 173,
    _SC_STREAMS___2 = 174,
    _SC_2_PBS_CHECKPOINT___2 = 175,
    _SC_V6_ILP32_OFF32___2 = 176,
    _SC_V6_ILP32_OFFBIG___2 = 177,
    _SC_V6_LP64_OFF64___2 = 178,
    _SC_V6_LPBIG_OFFBIG___2 = 179,
    _SC_HOST_NAME_MAX___2 = 180,
    _SC_TRACE___2 = 181,
    _SC_TRACE_EVENT_FILTER___2 = 182,
    _SC_TRACE_INHERIT___2 = 183,
    _SC_TRACE_LOG___2 = 184,
    _SC_LEVEL1_ICACHE_SIZE___2 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___2 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___2 = 187,
    _SC_LEVEL1_DCACHE_SIZE___2 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___2 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___2 = 190,
    _SC_LEVEL2_CACHE_SIZE___2 = 191,
    _SC_LEVEL2_CACHE_ASSOC___2 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___2 = 193,
    _SC_LEVEL3_CACHE_SIZE___2 = 194,
    _SC_LEVEL3_CACHE_ASSOC___2 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___2 = 196,
    _SC_LEVEL4_CACHE_SIZE___2 = 197,
    _SC_LEVEL4_CACHE_ASSOC___2 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___2 = 199,
    _SC_IPV6___2 = 235,
    _SC_RAW_SOCKETS___2 = 236,
    _SC_V7_ILP32_OFF32___2 = 237,
    _SC_V7_ILP32_OFFBIG___2 = 238,
    _SC_V7_LP64_OFF64___2 = 239,
    _SC_V7_LPBIG_OFFBIG___2 = 240,
    _SC_SS_REPL_MAX___2 = 241,
    _SC_TRACE_EVENT_NAME_MAX___2 = 242,
    _SC_TRACE_NAME_MAX___2 = 243,
    _SC_TRACE_SYS_MAX___2 = 244,
    _SC_TRACE_USER_EVENT_MAX___2 = 245,
    _SC_XOPEN_STREAMS___2 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___2 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___2 = 248
} ;
#line 533
enum __anonenum_875524036___2 {
    _CS_PATH___2 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___2 = 1,
    _CS_GNU_LIBC_VERSION___2 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___2 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___2 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___2 = 5,
    _CS_LFS_CFLAGS___2 = 1000,
    _CS_LFS_LDFLAGS___2 = 1001,
    _CS_LFS_LIBS___2 = 1002,
    _CS_LFS_LINTFLAGS___2 = 1003,
    _CS_LFS64_CFLAGS___2 = 1004,
    _CS_LFS64_LDFLAGS___2 = 1005,
    _CS_LFS64_LIBS___2 = 1006,
    _CS_LFS64_LINTFLAGS___2 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___2 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___2 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___2 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___2 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___2 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___2 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___2 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___2 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___2 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___2 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___2 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___2 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___2 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___2 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___2 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___2 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___2 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___2 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___2 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___2 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___2 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___2 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___2 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___2 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___2 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___2 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___2 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___2 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___2 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___2 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___2 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___2 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___2 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___2 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___2 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___2 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___2 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___2 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___2 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___2 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___2 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___2 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___2 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___2 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___2 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___2 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___2 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___2 = 1147,
    _CS_V6_ENV___2 = 1148,
    _CS_V7_ENV___2 = 1149
} ;
#line 853 "/usr/include/math.h"
enum __anonenum_1037408945___3 {
    FP_NAN___3 = 0,
    FP_INFINITE___3 = 1,
    FP_ZERO___3 = 2,
    FP_SUBNORMAL___3 = 3,
    FP_NORMAL___3 = 4
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum_437032235___3 {
    _PC_LINK_MAX___3 = 0,
    _PC_MAX_CANON___3 = 1,
    _PC_MAX_INPUT___3 = 2,
    _PC_NAME_MAX___3 = 3,
    _PC_PATH_MAX___3 = 4,
    _PC_PIPE_BUF___3 = 5,
    _PC_CHOWN_RESTRICTED___3 = 6,
    _PC_NO_TRUNC___3 = 7,
    _PC_VDISABLE___3 = 8,
    _PC_SYNC_IO___3 = 9,
    _PC_ASYNC_IO___3 = 10,
    _PC_PRIO_IO___3 = 11,
    _PC_SOCK_MAXBUF___3 = 12,
    _PC_FILESIZEBITS___3 = 13,
    _PC_REC_INCR_XFER_SIZE___3 = 14,
    _PC_REC_MAX_XFER_SIZE___3 = 15,
    _PC_REC_MIN_XFER_SIZE___3 = 16,
    _PC_REC_XFER_ALIGN___3 = 17,
    _PC_ALLOC_SIZE_MIN___3 = 18,
    _PC_SYMLINK_MAX___3 = 19,
    _PC_2_SYMLINKS___3 = 20
} ;
#line 71
enum __anonenum_315186338___3 {
    _SC_ARG_MAX___3 = 0,
    _SC_CHILD_MAX___3 = 1,
    _SC_CLK_TCK___3 = 2,
    _SC_NGROUPS_MAX___3 = 3,
    _SC_OPEN_MAX___3 = 4,
    _SC_STREAM_MAX___3 = 5,
    _SC_TZNAME_MAX___3 = 6,
    _SC_JOB_CONTROL___3 = 7,
    _SC_SAVED_IDS___3 = 8,
    _SC_REALTIME_SIGNALS___3 = 9,
    _SC_PRIORITY_SCHEDULING___3 = 10,
    _SC_TIMERS___3 = 11,
    _SC_ASYNCHRONOUS_IO___3 = 12,
    _SC_PRIORITIZED_IO___3 = 13,
    _SC_SYNCHRONIZED_IO___3 = 14,
    _SC_FSYNC___3 = 15,
    _SC_MAPPED_FILES___3 = 16,
    _SC_MEMLOCK___3 = 17,
    _SC_MEMLOCK_RANGE___3 = 18,
    _SC_MEMORY_PROTECTION___3 = 19,
    _SC_MESSAGE_PASSING___3 = 20,
    _SC_SEMAPHORES___3 = 21,
    _SC_SHARED_MEMORY_OBJECTS___3 = 22,
    _SC_AIO_LISTIO_MAX___3 = 23,
    _SC_AIO_MAX___3 = 24,
    _SC_AIO_PRIO_DELTA_MAX___3 = 25,
    _SC_DELAYTIMER_MAX___3 = 26,
    _SC_MQ_OPEN_MAX___3 = 27,
    _SC_MQ_PRIO_MAX___3 = 28,
    _SC_VERSION___3 = 29,
    _SC_PAGESIZE___3 = 30,
    _SC_RTSIG_MAX___3 = 31,
    _SC_SEM_NSEMS_MAX___3 = 32,
    _SC_SEM_VALUE_MAX___3 = 33,
    _SC_SIGQUEUE_MAX___3 = 34,
    _SC_TIMER_MAX___3 = 35,
    _SC_BC_BASE_MAX___3 = 36,
    _SC_BC_DIM_MAX___3 = 37,
    _SC_BC_SCALE_MAX___3 = 38,
    _SC_BC_STRING_MAX___3 = 39,
    _SC_COLL_WEIGHTS_MAX___3 = 40,
    _SC_EQUIV_CLASS_MAX___3 = 41,
    _SC_EXPR_NEST_MAX___3 = 42,
    _SC_LINE_MAX___3 = 43,
    _SC_RE_DUP_MAX___3 = 44,
    _SC_CHARCLASS_NAME_MAX___3 = 45,
    _SC_2_VERSION___3 = 46,
    _SC_2_C_BIND___3 = 47,
    _SC_2_C_DEV___3 = 48,
    _SC_2_FORT_DEV___3 = 49,
    _SC_2_FORT_RUN___3 = 50,
    _SC_2_SW_DEV___3 = 51,
    _SC_2_LOCALEDEF___3 = 52,
    _SC_PII___3 = 53,
    _SC_PII_XTI___3 = 54,
    _SC_PII_SOCKET___3 = 55,
    _SC_PII_INTERNET___3 = 56,
    _SC_PII_OSI___3 = 57,
    _SC_POLL___3 = 58,
    _SC_SELECT___3 = 59,
    _SC_UIO_MAXIOV___3 = 60,
    _SC_IOV_MAX___3 = 60,
    _SC_PII_INTERNET_STREAM___3 = 61,
    _SC_PII_INTERNET_DGRAM___3 = 62,
    _SC_PII_OSI_COTS___3 = 63,
    _SC_PII_OSI_CLTS___3 = 64,
    _SC_PII_OSI_M___3 = 65,
    _SC_T_IOV_MAX___3 = 66,
    _SC_THREADS___3 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___3 = 68,
    _SC_GETGR_R_SIZE_MAX___3 = 69,
    _SC_GETPW_R_SIZE_MAX___3 = 70,
    _SC_LOGIN_NAME_MAX___3 = 71,
    _SC_TTY_NAME_MAX___3 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___3 = 73,
    _SC_THREAD_KEYS_MAX___3 = 74,
    _SC_THREAD_STACK_MIN___3 = 75,
    _SC_THREAD_THREADS_MAX___3 = 76,
    _SC_THREAD_ATTR_STACKADDR___3 = 77,
    _SC_THREAD_ATTR_STACKSIZE___3 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___3 = 79,
    _SC_THREAD_PRIO_INHERIT___3 = 80,
    _SC_THREAD_PRIO_PROTECT___3 = 81,
    _SC_THREAD_PROCESS_SHARED___3 = 82,
    _SC_NPROCESSORS_CONF___3 = 83,
    _SC_NPROCESSORS_ONLN___3 = 84,
    _SC_PHYS_PAGES___3 = 85,
    _SC_AVPHYS_PAGES___3 = 86,
    _SC_ATEXIT_MAX___3 = 87,
    _SC_PASS_MAX___3 = 88,
    _SC_XOPEN_VERSION___3 = 89,
    _SC_XOPEN_XCU_VERSION___3 = 90,
    _SC_XOPEN_UNIX___3 = 91,
    _SC_XOPEN_CRYPT___3 = 92,
    _SC_XOPEN_ENH_I18N___3 = 93,
    _SC_XOPEN_SHM___3 = 94,
    _SC_2_CHAR_TERM___3 = 95,
    _SC_2_C_VERSION___3 = 96,
    _SC_2_UPE___3 = 97,
    _SC_XOPEN_XPG2___3 = 98,
    _SC_XOPEN_XPG3___3 = 99,
    _SC_XOPEN_XPG4___3 = 100,
    _SC_CHAR_BIT___3 = 101,
    _SC_CHAR_MAX___3 = 102,
    _SC_CHAR_MIN___3 = 103,
    _SC_INT_MAX___3 = 104,
    _SC_INT_MIN___3 = 105,
    _SC_LONG_BIT___3 = 106,
    _SC_WORD_BIT___3 = 107,
    _SC_MB_LEN_MAX___3 = 108,
    _SC_NZERO___3 = 109,
    _SC_SSIZE_MAX___3 = 110,
    _SC_SCHAR_MAX___3 = 111,
    _SC_SCHAR_MIN___3 = 112,
    _SC_SHRT_MAX___3 = 113,
    _SC_SHRT_MIN___3 = 114,
    _SC_UCHAR_MAX___3 = 115,
    _SC_UINT_MAX___3 = 116,
    _SC_ULONG_MAX___3 = 117,
    _SC_USHRT_MAX___3 = 118,
    _SC_NL_ARGMAX___3 = 119,
    _SC_NL_LANGMAX___3 = 120,
    _SC_NL_MSGMAX___3 = 121,
    _SC_NL_NMAX___3 = 122,
    _SC_NL_SETMAX___3 = 123,
    _SC_NL_TEXTMAX___3 = 124,
    _SC_XBS5_ILP32_OFF32___3 = 125,
    _SC_XBS5_ILP32_OFFBIG___3 = 126,
    _SC_XBS5_LP64_OFF64___3 = 127,
    _SC_XBS5_LPBIG_OFFBIG___3 = 128,
    _SC_XOPEN_LEGACY___3 = 129,
    _SC_XOPEN_REALTIME___3 = 130,
    _SC_XOPEN_REALTIME_THREADS___3 = 131,
    _SC_ADVISORY_INFO___3 = 132,
    _SC_BARRIERS___3 = 133,
    _SC_BASE___3 = 134,
    _SC_C_LANG_SUPPORT___3 = 135,
    _SC_C_LANG_SUPPORT_R___3 = 136,
    _SC_CLOCK_SELECTION___3 = 137,
    _SC_CPUTIME___3 = 138,
    _SC_THREAD_CPUTIME___3 = 139,
    _SC_DEVICE_IO___3 = 140,
    _SC_DEVICE_SPECIFIC___3 = 141,
    _SC_DEVICE_SPECIFIC_R___3 = 142,
    _SC_FD_MGMT___3 = 143,
    _SC_FIFO___3 = 144,
    _SC_PIPE___3 = 145,
    _SC_FILE_ATTRIBUTES___3 = 146,
    _SC_FILE_LOCKING___3 = 147,
    _SC_FILE_SYSTEM___3 = 148,
    _SC_MONOTONIC_CLOCK___3 = 149,
    _SC_MULTI_PROCESS___3 = 150,
    _SC_SINGLE_PROCESS___3 = 151,
    _SC_NETWORKING___3 = 152,
    _SC_READER_WRITER_LOCKS___3 = 153,
    _SC_SPIN_LOCKS___3 = 154,
    _SC_REGEXP___3 = 155,
    _SC_REGEX_VERSION___3 = 156,
    _SC_SHELL___3 = 157,
    _SC_SIGNALS___3 = 158,
    _SC_SPAWN___3 = 159,
    _SC_SPORADIC_SERVER___3 = 160,
    _SC_THREAD_SPORADIC_SERVER___3 = 161,
    _SC_SYSTEM_DATABASE___3 = 162,
    _SC_SYSTEM_DATABASE_R___3 = 163,
    _SC_TIMEOUTS___3 = 164,
    _SC_TYPED_MEMORY_OBJECTS___3 = 165,
    _SC_USER_GROUPS___3 = 166,
    _SC_USER_GROUPS_R___3 = 167,
    _SC_2_PBS___3 = 168,
    _SC_2_PBS_ACCOUNTING___3 = 169,
    _SC_2_PBS_LOCATE___3 = 170,
    _SC_2_PBS_MESSAGE___3 = 171,
    _SC_2_PBS_TRACK___3 = 172,
    _SC_SYMLOOP_MAX___3 = 173,
    _SC_STREAMS___3 = 174,
    _SC_2_PBS_CHECKPOINT___3 = 175,
    _SC_V6_ILP32_OFF32___3 = 176,
    _SC_V6_ILP32_OFFBIG___3 = 177,
    _SC_V6_LP64_OFF64___3 = 178,
    _SC_V6_LPBIG_OFFBIG___3 = 179,
    _SC_HOST_NAME_MAX___3 = 180,
    _SC_TRACE___3 = 181,
    _SC_TRACE_EVENT_FILTER___3 = 182,
    _SC_TRACE_INHERIT___3 = 183,
    _SC_TRACE_LOG___3 = 184,
    _SC_LEVEL1_ICACHE_SIZE___3 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___3 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___3 = 187,
    _SC_LEVEL1_DCACHE_SIZE___3 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___3 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___3 = 190,
    _SC_LEVEL2_CACHE_SIZE___3 = 191,
    _SC_LEVEL2_CACHE_ASSOC___3 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___3 = 193,
    _SC_LEVEL3_CACHE_SIZE___3 = 194,
    _SC_LEVEL3_CACHE_ASSOC___3 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___3 = 196,
    _SC_LEVEL4_CACHE_SIZE___3 = 197,
    _SC_LEVEL4_CACHE_ASSOC___3 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___3 = 199,
    _SC_IPV6___3 = 235,
    _SC_RAW_SOCKETS___3 = 236,
    _SC_V7_ILP32_OFF32___3 = 237,
    _SC_V7_ILP32_OFFBIG___3 = 238,
    _SC_V7_LP64_OFF64___3 = 239,
    _SC_V7_LPBIG_OFFBIG___3 = 240,
    _SC_SS_REPL_MAX___3 = 241,
    _SC_TRACE_EVENT_NAME_MAX___3 = 242,
    _SC_TRACE_NAME_MAX___3 = 243,
    _SC_TRACE_SYS_MAX___3 = 244,
    _SC_TRACE_USER_EVENT_MAX___3 = 245,
    _SC_XOPEN_STREAMS___3 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___3 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___3 = 248
} ;
#line 533
enum __anonenum_875524036___3 {
    _CS_PATH___3 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___3 = 1,
    _CS_GNU_LIBC_VERSION___3 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___3 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___3 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___3 = 5,
    _CS_LFS_CFLAGS___3 = 1000,
    _CS_LFS_LDFLAGS___3 = 1001,
    _CS_LFS_LIBS___3 = 1002,
    _CS_LFS_LINTFLAGS___3 = 1003,
    _CS_LFS64_CFLAGS___3 = 1004,
    _CS_LFS64_LDFLAGS___3 = 1005,
    _CS_LFS64_LIBS___3 = 1006,
    _CS_LFS64_LINTFLAGS___3 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___3 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___3 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___3 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___3 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___3 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___3 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___3 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___3 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___3 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___3 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___3 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___3 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___3 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___3 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___3 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___3 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___3 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___3 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___3 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___3 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___3 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___3 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___3 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___3 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___3 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___3 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___3 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___3 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___3 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___3 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___3 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___3 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___3 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___3 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___3 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___3 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___3 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___3 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___3 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___3 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___3 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___3 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___3 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___3 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___3 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___3 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___3 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___3 = 1147,
    _CS_V6_ENV___3 = 1148,
    _CS_V7_ENV___3 = 1149
} ;
#line 853 "/usr/include/math.h"
enum __anonenum_1037408945___4 {
    FP_NAN___4 = 0,
    FP_INFINITE___4 = 1,
    FP_ZERO___4 = 2,
    FP_SUBNORMAL___4 = 3,
    FP_NORMAL___4 = 4
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum_437032235___4 {
    _PC_LINK_MAX___4 = 0,
    _PC_MAX_CANON___4 = 1,
    _PC_MAX_INPUT___4 = 2,
    _PC_NAME_MAX___4 = 3,
    _PC_PATH_MAX___4 = 4,
    _PC_PIPE_BUF___4 = 5,
    _PC_CHOWN_RESTRICTED___4 = 6,
    _PC_NO_TRUNC___4 = 7,
    _PC_VDISABLE___4 = 8,
    _PC_SYNC_IO___4 = 9,
    _PC_ASYNC_IO___4 = 10,
    _PC_PRIO_IO___4 = 11,
    _PC_SOCK_MAXBUF___4 = 12,
    _PC_FILESIZEBITS___4 = 13,
    _PC_REC_INCR_XFER_SIZE___4 = 14,
    _PC_REC_MAX_XFER_SIZE___4 = 15,
    _PC_REC_MIN_XFER_SIZE___4 = 16,
    _PC_REC_XFER_ALIGN___4 = 17,
    _PC_ALLOC_SIZE_MIN___4 = 18,
    _PC_SYMLINK_MAX___4 = 19,
    _PC_2_SYMLINKS___4 = 20
} ;
#line 71
enum __anonenum_315186338___4 {
    _SC_ARG_MAX___4 = 0,
    _SC_CHILD_MAX___4 = 1,
    _SC_CLK_TCK___4 = 2,
    _SC_NGROUPS_MAX___4 = 3,
    _SC_OPEN_MAX___4 = 4,
    _SC_STREAM_MAX___4 = 5,
    _SC_TZNAME_MAX___4 = 6,
    _SC_JOB_CONTROL___4 = 7,
    _SC_SAVED_IDS___4 = 8,
    _SC_REALTIME_SIGNALS___4 = 9,
    _SC_PRIORITY_SCHEDULING___4 = 10,
    _SC_TIMERS___4 = 11,
    _SC_ASYNCHRONOUS_IO___4 = 12,
    _SC_PRIORITIZED_IO___4 = 13,
    _SC_SYNCHRONIZED_IO___4 = 14,
    _SC_FSYNC___4 = 15,
    _SC_MAPPED_FILES___4 = 16,
    _SC_MEMLOCK___4 = 17,
    _SC_MEMLOCK_RANGE___4 = 18,
    _SC_MEMORY_PROTECTION___4 = 19,
    _SC_MESSAGE_PASSING___4 = 20,
    _SC_SEMAPHORES___4 = 21,
    _SC_SHARED_MEMORY_OBJECTS___4 = 22,
    _SC_AIO_LISTIO_MAX___4 = 23,
    _SC_AIO_MAX___4 = 24,
    _SC_AIO_PRIO_DELTA_MAX___4 = 25,
    _SC_DELAYTIMER_MAX___4 = 26,
    _SC_MQ_OPEN_MAX___4 = 27,
    _SC_MQ_PRIO_MAX___4 = 28,
    _SC_VERSION___4 = 29,
    _SC_PAGESIZE___4 = 30,
    _SC_RTSIG_MAX___4 = 31,
    _SC_SEM_NSEMS_MAX___4 = 32,
    _SC_SEM_VALUE_MAX___4 = 33,
    _SC_SIGQUEUE_MAX___4 = 34,
    _SC_TIMER_MAX___4 = 35,
    _SC_BC_BASE_MAX___4 = 36,
    _SC_BC_DIM_MAX___4 = 37,
    _SC_BC_SCALE_MAX___4 = 38,
    _SC_BC_STRING_MAX___4 = 39,
    _SC_COLL_WEIGHTS_MAX___4 = 40,
    _SC_EQUIV_CLASS_MAX___4 = 41,
    _SC_EXPR_NEST_MAX___4 = 42,
    _SC_LINE_MAX___4 = 43,
    _SC_RE_DUP_MAX___4 = 44,
    _SC_CHARCLASS_NAME_MAX___4 = 45,
    _SC_2_VERSION___4 = 46,
    _SC_2_C_BIND___4 = 47,
    _SC_2_C_DEV___4 = 48,
    _SC_2_FORT_DEV___4 = 49,
    _SC_2_FORT_RUN___4 = 50,
    _SC_2_SW_DEV___4 = 51,
    _SC_2_LOCALEDEF___4 = 52,
    _SC_PII___4 = 53,
    _SC_PII_XTI___4 = 54,
    _SC_PII_SOCKET___4 = 55,
    _SC_PII_INTERNET___4 = 56,
    _SC_PII_OSI___4 = 57,
    _SC_POLL___4 = 58,
    _SC_SELECT___4 = 59,
    _SC_UIO_MAXIOV___4 = 60,
    _SC_IOV_MAX___4 = 60,
    _SC_PII_INTERNET_STREAM___4 = 61,
    _SC_PII_INTERNET_DGRAM___4 = 62,
    _SC_PII_OSI_COTS___4 = 63,
    _SC_PII_OSI_CLTS___4 = 64,
    _SC_PII_OSI_M___4 = 65,
    _SC_T_IOV_MAX___4 = 66,
    _SC_THREADS___4 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___4 = 68,
    _SC_GETGR_R_SIZE_MAX___4 = 69,
    _SC_GETPW_R_SIZE_MAX___4 = 70,
    _SC_LOGIN_NAME_MAX___4 = 71,
    _SC_TTY_NAME_MAX___4 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___4 = 73,
    _SC_THREAD_KEYS_MAX___4 = 74,
    _SC_THREAD_STACK_MIN___4 = 75,
    _SC_THREAD_THREADS_MAX___4 = 76,
    _SC_THREAD_ATTR_STACKADDR___4 = 77,
    _SC_THREAD_ATTR_STACKSIZE___4 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___4 = 79,
    _SC_THREAD_PRIO_INHERIT___4 = 80,
    _SC_THREAD_PRIO_PROTECT___4 = 81,
    _SC_THREAD_PROCESS_SHARED___4 = 82,
    _SC_NPROCESSORS_CONF___4 = 83,
    _SC_NPROCESSORS_ONLN___4 = 84,
    _SC_PHYS_PAGES___4 = 85,
    _SC_AVPHYS_PAGES___4 = 86,
    _SC_ATEXIT_MAX___4 = 87,
    _SC_PASS_MAX___4 = 88,
    _SC_XOPEN_VERSION___4 = 89,
    _SC_XOPEN_XCU_VERSION___4 = 90,
    _SC_XOPEN_UNIX___4 = 91,
    _SC_XOPEN_CRYPT___4 = 92,
    _SC_XOPEN_ENH_I18N___4 = 93,
    _SC_XOPEN_SHM___4 = 94,
    _SC_2_CHAR_TERM___4 = 95,
    _SC_2_C_VERSION___4 = 96,
    _SC_2_UPE___4 = 97,
    _SC_XOPEN_XPG2___4 = 98,
    _SC_XOPEN_XPG3___4 = 99,
    _SC_XOPEN_XPG4___4 = 100,
    _SC_CHAR_BIT___4 = 101,
    _SC_CHAR_MAX___4 = 102,
    _SC_CHAR_MIN___4 = 103,
    _SC_INT_MAX___4 = 104,
    _SC_INT_MIN___4 = 105,
    _SC_LONG_BIT___4 = 106,
    _SC_WORD_BIT___4 = 107,
    _SC_MB_LEN_MAX___4 = 108,
    _SC_NZERO___4 = 109,
    _SC_SSIZE_MAX___4 = 110,
    _SC_SCHAR_MAX___4 = 111,
    _SC_SCHAR_MIN___4 = 112,
    _SC_SHRT_MAX___4 = 113,
    _SC_SHRT_MIN___4 = 114,
    _SC_UCHAR_MAX___4 = 115,
    _SC_UINT_MAX___4 = 116,
    _SC_ULONG_MAX___4 = 117,
    _SC_USHRT_MAX___4 = 118,
    _SC_NL_ARGMAX___4 = 119,
    _SC_NL_LANGMAX___4 = 120,
    _SC_NL_MSGMAX___4 = 121,
    _SC_NL_NMAX___4 = 122,
    _SC_NL_SETMAX___4 = 123,
    _SC_NL_TEXTMAX___4 = 124,
    _SC_XBS5_ILP32_OFF32___4 = 125,
    _SC_XBS5_ILP32_OFFBIG___4 = 126,
    _SC_XBS5_LP64_OFF64___4 = 127,
    _SC_XBS5_LPBIG_OFFBIG___4 = 128,
    _SC_XOPEN_LEGACY___4 = 129,
    _SC_XOPEN_REALTIME___4 = 130,
    _SC_XOPEN_REALTIME_THREADS___4 = 131,
    _SC_ADVISORY_INFO___4 = 132,
    _SC_BARRIERS___4 = 133,
    _SC_BASE___4 = 134,
    _SC_C_LANG_SUPPORT___4 = 135,
    _SC_C_LANG_SUPPORT_R___4 = 136,
    _SC_CLOCK_SELECTION___4 = 137,
    _SC_CPUTIME___4 = 138,
    _SC_THREAD_CPUTIME___4 = 139,
    _SC_DEVICE_IO___4 = 140,
    _SC_DEVICE_SPECIFIC___4 = 141,
    _SC_DEVICE_SPECIFIC_R___4 = 142,
    _SC_FD_MGMT___4 = 143,
    _SC_FIFO___4 = 144,
    _SC_PIPE___4 = 145,
    _SC_FILE_ATTRIBUTES___4 = 146,
    _SC_FILE_LOCKING___4 = 147,
    _SC_FILE_SYSTEM___4 = 148,
    _SC_MONOTONIC_CLOCK___4 = 149,
    _SC_MULTI_PROCESS___4 = 150,
    _SC_SINGLE_PROCESS___4 = 151,
    _SC_NETWORKING___4 = 152,
    _SC_READER_WRITER_LOCKS___4 = 153,
    _SC_SPIN_LOCKS___4 = 154,
    _SC_REGEXP___4 = 155,
    _SC_REGEX_VERSION___4 = 156,
    _SC_SHELL___4 = 157,
    _SC_SIGNALS___4 = 158,
    _SC_SPAWN___4 = 159,
    _SC_SPORADIC_SERVER___4 = 160,
    _SC_THREAD_SPORADIC_SERVER___4 = 161,
    _SC_SYSTEM_DATABASE___4 = 162,
    _SC_SYSTEM_DATABASE_R___4 = 163,
    _SC_TIMEOUTS___4 = 164,
    _SC_TYPED_MEMORY_OBJECTS___4 = 165,
    _SC_USER_GROUPS___4 = 166,
    _SC_USER_GROUPS_R___4 = 167,
    _SC_2_PBS___4 = 168,
    _SC_2_PBS_ACCOUNTING___4 = 169,
    _SC_2_PBS_LOCATE___4 = 170,
    _SC_2_PBS_MESSAGE___4 = 171,
    _SC_2_PBS_TRACK___4 = 172,
    _SC_SYMLOOP_MAX___4 = 173,
    _SC_STREAMS___4 = 174,
    _SC_2_PBS_CHECKPOINT___4 = 175,
    _SC_V6_ILP32_OFF32___4 = 176,
    _SC_V6_ILP32_OFFBIG___4 = 177,
    _SC_V6_LP64_OFF64___4 = 178,
    _SC_V6_LPBIG_OFFBIG___4 = 179,
    _SC_HOST_NAME_MAX___4 = 180,
    _SC_TRACE___4 = 181,
    _SC_TRACE_EVENT_FILTER___4 = 182,
    _SC_TRACE_INHERIT___4 = 183,
    _SC_TRACE_LOG___4 = 184,
    _SC_LEVEL1_ICACHE_SIZE___4 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___4 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___4 = 187,
    _SC_LEVEL1_DCACHE_SIZE___4 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___4 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___4 = 190,
    _SC_LEVEL2_CACHE_SIZE___4 = 191,
    _SC_LEVEL2_CACHE_ASSOC___4 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___4 = 193,
    _SC_LEVEL3_CACHE_SIZE___4 = 194,
    _SC_LEVEL3_CACHE_ASSOC___4 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___4 = 196,
    _SC_LEVEL4_CACHE_SIZE___4 = 197,
    _SC_LEVEL4_CACHE_ASSOC___4 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___4 = 199,
    _SC_IPV6___4 = 235,
    _SC_RAW_SOCKETS___4 = 236,
    _SC_V7_ILP32_OFF32___4 = 237,
    _SC_V7_ILP32_OFFBIG___4 = 238,
    _SC_V7_LP64_OFF64___4 = 239,
    _SC_V7_LPBIG_OFFBIG___4 = 240,
    _SC_SS_REPL_MAX___4 = 241,
    _SC_TRACE_EVENT_NAME_MAX___4 = 242,
    _SC_TRACE_NAME_MAX___4 = 243,
    _SC_TRACE_SYS_MAX___4 = 244,
    _SC_TRACE_USER_EVENT_MAX___4 = 245,
    _SC_XOPEN_STREAMS___4 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___4 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___4 = 248
} ;
#line 533
enum __anonenum_875524036___4 {
    _CS_PATH___4 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___4 = 1,
    _CS_GNU_LIBC_VERSION___4 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___4 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___4 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___4 = 5,
    _CS_LFS_CFLAGS___4 = 1000,
    _CS_LFS_LDFLAGS___4 = 1001,
    _CS_LFS_LIBS___4 = 1002,
    _CS_LFS_LINTFLAGS___4 = 1003,
    _CS_LFS64_CFLAGS___4 = 1004,
    _CS_LFS64_LDFLAGS___4 = 1005,
    _CS_LFS64_LIBS___4 = 1006,
    _CS_LFS64_LINTFLAGS___4 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___4 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___4 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___4 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___4 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___4 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___4 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___4 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___4 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___4 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___4 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___4 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___4 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___4 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___4 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___4 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___4 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___4 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___4 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___4 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___4 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___4 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___4 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___4 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___4 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___4 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___4 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___4 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___4 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___4 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___4 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___4 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___4 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___4 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___4 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___4 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___4 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___4 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___4 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___4 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___4 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___4 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___4 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___4 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___4 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___4 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___4 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___4 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___4 = 1147,
    _CS_V6_ENV___4 = 1148,
    _CS_V7_ENV___4 = 1149
} ;
#line 1283 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
struct __anonstruct_png_image_read_control_740894262 {
   png_imagep image ;
   png_voidp buffer ;
   png_int_32 row_stride ;
   png_voidp colormap ;
   png_const_colorp background ;
   png_voidp local_row ;
   png_voidp first_row ;
   ptrdiff_t row_bytes ;
   int file_encoding ;
   png_fixed_point gamma_to_linear ;
   int colormap_processing ;
};
#line 1283 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
typedef struct __anonstruct_png_image_read_control_740894262 png_image_read_control;
#line 853 "/usr/include/math.h"
enum __anonenum_1037408945___5 {
    FP_NAN___5 = 0,
    FP_INFINITE___5 = 1,
    FP_ZERO___5 = 2,
    FP_SUBNORMAL___5 = 3,
    FP_NORMAL___5 = 4
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum_437032235___5 {
    _PC_LINK_MAX___5 = 0,
    _PC_MAX_CANON___5 = 1,
    _PC_MAX_INPUT___5 = 2,
    _PC_NAME_MAX___5 = 3,
    _PC_PATH_MAX___5 = 4,
    _PC_PIPE_BUF___5 = 5,
    _PC_CHOWN_RESTRICTED___5 = 6,
    _PC_NO_TRUNC___5 = 7,
    _PC_VDISABLE___5 = 8,
    _PC_SYNC_IO___5 = 9,
    _PC_ASYNC_IO___5 = 10,
    _PC_PRIO_IO___5 = 11,
    _PC_SOCK_MAXBUF___5 = 12,
    _PC_FILESIZEBITS___5 = 13,
    _PC_REC_INCR_XFER_SIZE___5 = 14,
    _PC_REC_MAX_XFER_SIZE___5 = 15,
    _PC_REC_MIN_XFER_SIZE___5 = 16,
    _PC_REC_XFER_ALIGN___5 = 17,
    _PC_ALLOC_SIZE_MIN___5 = 18,
    _PC_SYMLINK_MAX___5 = 19,
    _PC_2_SYMLINKS___5 = 20
} ;
#line 71
enum __anonenum_315186338___5 {
    _SC_ARG_MAX___5 = 0,
    _SC_CHILD_MAX___5 = 1,
    _SC_CLK_TCK___5 = 2,
    _SC_NGROUPS_MAX___5 = 3,
    _SC_OPEN_MAX___5 = 4,
    _SC_STREAM_MAX___5 = 5,
    _SC_TZNAME_MAX___5 = 6,
    _SC_JOB_CONTROL___5 = 7,
    _SC_SAVED_IDS___5 = 8,
    _SC_REALTIME_SIGNALS___5 = 9,
    _SC_PRIORITY_SCHEDULING___5 = 10,
    _SC_TIMERS___5 = 11,
    _SC_ASYNCHRONOUS_IO___5 = 12,
    _SC_PRIORITIZED_IO___5 = 13,
    _SC_SYNCHRONIZED_IO___5 = 14,
    _SC_FSYNC___5 = 15,
    _SC_MAPPED_FILES___5 = 16,
    _SC_MEMLOCK___5 = 17,
    _SC_MEMLOCK_RANGE___5 = 18,
    _SC_MEMORY_PROTECTION___5 = 19,
    _SC_MESSAGE_PASSING___5 = 20,
    _SC_SEMAPHORES___5 = 21,
    _SC_SHARED_MEMORY_OBJECTS___5 = 22,
    _SC_AIO_LISTIO_MAX___5 = 23,
    _SC_AIO_MAX___5 = 24,
    _SC_AIO_PRIO_DELTA_MAX___5 = 25,
    _SC_DELAYTIMER_MAX___5 = 26,
    _SC_MQ_OPEN_MAX___5 = 27,
    _SC_MQ_PRIO_MAX___5 = 28,
    _SC_VERSION___5 = 29,
    _SC_PAGESIZE___5 = 30,
    _SC_RTSIG_MAX___5 = 31,
    _SC_SEM_NSEMS_MAX___5 = 32,
    _SC_SEM_VALUE_MAX___5 = 33,
    _SC_SIGQUEUE_MAX___5 = 34,
    _SC_TIMER_MAX___5 = 35,
    _SC_BC_BASE_MAX___5 = 36,
    _SC_BC_DIM_MAX___5 = 37,
    _SC_BC_SCALE_MAX___5 = 38,
    _SC_BC_STRING_MAX___5 = 39,
    _SC_COLL_WEIGHTS_MAX___5 = 40,
    _SC_EQUIV_CLASS_MAX___5 = 41,
    _SC_EXPR_NEST_MAX___5 = 42,
    _SC_LINE_MAX___5 = 43,
    _SC_RE_DUP_MAX___5 = 44,
    _SC_CHARCLASS_NAME_MAX___5 = 45,
    _SC_2_VERSION___5 = 46,
    _SC_2_C_BIND___5 = 47,
    _SC_2_C_DEV___5 = 48,
    _SC_2_FORT_DEV___5 = 49,
    _SC_2_FORT_RUN___5 = 50,
    _SC_2_SW_DEV___5 = 51,
    _SC_2_LOCALEDEF___5 = 52,
    _SC_PII___5 = 53,
    _SC_PII_XTI___5 = 54,
    _SC_PII_SOCKET___5 = 55,
    _SC_PII_INTERNET___5 = 56,
    _SC_PII_OSI___5 = 57,
    _SC_POLL___5 = 58,
    _SC_SELECT___5 = 59,
    _SC_UIO_MAXIOV___5 = 60,
    _SC_IOV_MAX___5 = 60,
    _SC_PII_INTERNET_STREAM___5 = 61,
    _SC_PII_INTERNET_DGRAM___5 = 62,
    _SC_PII_OSI_COTS___5 = 63,
    _SC_PII_OSI_CLTS___5 = 64,
    _SC_PII_OSI_M___5 = 65,
    _SC_T_IOV_MAX___5 = 66,
    _SC_THREADS___5 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___5 = 68,
    _SC_GETGR_R_SIZE_MAX___5 = 69,
    _SC_GETPW_R_SIZE_MAX___5 = 70,
    _SC_LOGIN_NAME_MAX___5 = 71,
    _SC_TTY_NAME_MAX___5 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___5 = 73,
    _SC_THREAD_KEYS_MAX___5 = 74,
    _SC_THREAD_STACK_MIN___5 = 75,
    _SC_THREAD_THREADS_MAX___5 = 76,
    _SC_THREAD_ATTR_STACKADDR___5 = 77,
    _SC_THREAD_ATTR_STACKSIZE___5 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___5 = 79,
    _SC_THREAD_PRIO_INHERIT___5 = 80,
    _SC_THREAD_PRIO_PROTECT___5 = 81,
    _SC_THREAD_PROCESS_SHARED___5 = 82,
    _SC_NPROCESSORS_CONF___5 = 83,
    _SC_NPROCESSORS_ONLN___5 = 84,
    _SC_PHYS_PAGES___5 = 85,
    _SC_AVPHYS_PAGES___5 = 86,
    _SC_ATEXIT_MAX___5 = 87,
    _SC_PASS_MAX___5 = 88,
    _SC_XOPEN_VERSION___5 = 89,
    _SC_XOPEN_XCU_VERSION___5 = 90,
    _SC_XOPEN_UNIX___5 = 91,
    _SC_XOPEN_CRYPT___5 = 92,
    _SC_XOPEN_ENH_I18N___5 = 93,
    _SC_XOPEN_SHM___5 = 94,
    _SC_2_CHAR_TERM___5 = 95,
    _SC_2_C_VERSION___5 = 96,
    _SC_2_UPE___5 = 97,
    _SC_XOPEN_XPG2___5 = 98,
    _SC_XOPEN_XPG3___5 = 99,
    _SC_XOPEN_XPG4___5 = 100,
    _SC_CHAR_BIT___5 = 101,
    _SC_CHAR_MAX___5 = 102,
    _SC_CHAR_MIN___5 = 103,
    _SC_INT_MAX___5 = 104,
    _SC_INT_MIN___5 = 105,
    _SC_LONG_BIT___5 = 106,
    _SC_WORD_BIT___5 = 107,
    _SC_MB_LEN_MAX___5 = 108,
    _SC_NZERO___5 = 109,
    _SC_SSIZE_MAX___5 = 110,
    _SC_SCHAR_MAX___5 = 111,
    _SC_SCHAR_MIN___5 = 112,
    _SC_SHRT_MAX___5 = 113,
    _SC_SHRT_MIN___5 = 114,
    _SC_UCHAR_MAX___5 = 115,
    _SC_UINT_MAX___5 = 116,
    _SC_ULONG_MAX___5 = 117,
    _SC_USHRT_MAX___5 = 118,
    _SC_NL_ARGMAX___5 = 119,
    _SC_NL_LANGMAX___5 = 120,
    _SC_NL_MSGMAX___5 = 121,
    _SC_NL_NMAX___5 = 122,
    _SC_NL_SETMAX___5 = 123,
    _SC_NL_TEXTMAX___5 = 124,
    _SC_XBS5_ILP32_OFF32___5 = 125,
    _SC_XBS5_ILP32_OFFBIG___5 = 126,
    _SC_XBS5_LP64_OFF64___5 = 127,
    _SC_XBS5_LPBIG_OFFBIG___5 = 128,
    _SC_XOPEN_LEGACY___5 = 129,
    _SC_XOPEN_REALTIME___5 = 130,
    _SC_XOPEN_REALTIME_THREADS___5 = 131,
    _SC_ADVISORY_INFO___5 = 132,
    _SC_BARRIERS___5 = 133,
    _SC_BASE___5 = 134,
    _SC_C_LANG_SUPPORT___5 = 135,
    _SC_C_LANG_SUPPORT_R___5 = 136,
    _SC_CLOCK_SELECTION___5 = 137,
    _SC_CPUTIME___5 = 138,
    _SC_THREAD_CPUTIME___5 = 139,
    _SC_DEVICE_IO___5 = 140,
    _SC_DEVICE_SPECIFIC___5 = 141,
    _SC_DEVICE_SPECIFIC_R___5 = 142,
    _SC_FD_MGMT___5 = 143,
    _SC_FIFO___5 = 144,
    _SC_PIPE___5 = 145,
    _SC_FILE_ATTRIBUTES___5 = 146,
    _SC_FILE_LOCKING___5 = 147,
    _SC_FILE_SYSTEM___5 = 148,
    _SC_MONOTONIC_CLOCK___5 = 149,
    _SC_MULTI_PROCESS___5 = 150,
    _SC_SINGLE_PROCESS___5 = 151,
    _SC_NETWORKING___5 = 152,
    _SC_READER_WRITER_LOCKS___5 = 153,
    _SC_SPIN_LOCKS___5 = 154,
    _SC_REGEXP___5 = 155,
    _SC_REGEX_VERSION___5 = 156,
    _SC_SHELL___5 = 157,
    _SC_SIGNALS___5 = 158,
    _SC_SPAWN___5 = 159,
    _SC_SPORADIC_SERVER___5 = 160,
    _SC_THREAD_SPORADIC_SERVER___5 = 161,
    _SC_SYSTEM_DATABASE___5 = 162,
    _SC_SYSTEM_DATABASE_R___5 = 163,
    _SC_TIMEOUTS___5 = 164,
    _SC_TYPED_MEMORY_OBJECTS___5 = 165,
    _SC_USER_GROUPS___5 = 166,
    _SC_USER_GROUPS_R___5 = 167,
    _SC_2_PBS___5 = 168,
    _SC_2_PBS_ACCOUNTING___5 = 169,
    _SC_2_PBS_LOCATE___5 = 170,
    _SC_2_PBS_MESSAGE___5 = 171,
    _SC_2_PBS_TRACK___5 = 172,
    _SC_SYMLOOP_MAX___5 = 173,
    _SC_STREAMS___5 = 174,
    _SC_2_PBS_CHECKPOINT___5 = 175,
    _SC_V6_ILP32_OFF32___5 = 176,
    _SC_V6_ILP32_OFFBIG___5 = 177,
    _SC_V6_LP64_OFF64___5 = 178,
    _SC_V6_LPBIG_OFFBIG___5 = 179,
    _SC_HOST_NAME_MAX___5 = 180,
    _SC_TRACE___5 = 181,
    _SC_TRACE_EVENT_FILTER___5 = 182,
    _SC_TRACE_INHERIT___5 = 183,
    _SC_TRACE_LOG___5 = 184,
    _SC_LEVEL1_ICACHE_SIZE___5 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___5 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___5 = 187,
    _SC_LEVEL1_DCACHE_SIZE___5 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___5 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___5 = 190,
    _SC_LEVEL2_CACHE_SIZE___5 = 191,
    _SC_LEVEL2_CACHE_ASSOC___5 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___5 = 193,
    _SC_LEVEL3_CACHE_SIZE___5 = 194,
    _SC_LEVEL3_CACHE_ASSOC___5 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___5 = 196,
    _SC_LEVEL4_CACHE_SIZE___5 = 197,
    _SC_LEVEL4_CACHE_ASSOC___5 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___5 = 199,
    _SC_IPV6___5 = 235,
    _SC_RAW_SOCKETS___5 = 236,
    _SC_V7_ILP32_OFF32___5 = 237,
    _SC_V7_ILP32_OFFBIG___5 = 238,
    _SC_V7_LP64_OFF64___5 = 239,
    _SC_V7_LPBIG_OFFBIG___5 = 240,
    _SC_SS_REPL_MAX___5 = 241,
    _SC_TRACE_EVENT_NAME_MAX___5 = 242,
    _SC_TRACE_NAME_MAX___5 = 243,
    _SC_TRACE_SYS_MAX___5 = 244,
    _SC_TRACE_USER_EVENT_MAX___5 = 245,
    _SC_XOPEN_STREAMS___5 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___5 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___5 = 248
} ;
#line 533
enum __anonenum_875524036___5 {
    _CS_PATH___5 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___5 = 1,
    _CS_GNU_LIBC_VERSION___5 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___5 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___5 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___5 = 5,
    _CS_LFS_CFLAGS___5 = 1000,
    _CS_LFS_LDFLAGS___5 = 1001,
    _CS_LFS_LIBS___5 = 1002,
    _CS_LFS_LINTFLAGS___5 = 1003,
    _CS_LFS64_CFLAGS___5 = 1004,
    _CS_LFS64_LDFLAGS___5 = 1005,
    _CS_LFS64_LIBS___5 = 1006,
    _CS_LFS64_LINTFLAGS___5 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___5 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___5 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___5 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___5 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___5 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___5 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___5 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___5 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___5 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___5 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___5 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___5 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___5 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___5 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___5 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___5 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___5 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___5 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___5 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___5 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___5 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___5 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___5 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___5 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___5 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___5 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___5 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___5 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___5 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___5 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___5 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___5 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___5 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___5 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___5 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___5 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___5 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___5 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___5 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___5 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___5 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___5 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___5 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___5 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___5 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___5 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___5 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___5 = 1147,
    _CS_V6_ENV___5 = 1148,
    _CS_V7_ENV___5 = 1149
} ;
#line 853 "/usr/include/math.h"
enum __anonenum_1037408945___6 {
    FP_NAN___6 = 0,
    FP_INFINITE___6 = 1,
    FP_ZERO___6 = 2,
    FP_SUBNORMAL___6 = 3,
    FP_NORMAL___6 = 4
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum_437032235___6 {
    _PC_LINK_MAX___6 = 0,
    _PC_MAX_CANON___6 = 1,
    _PC_MAX_INPUT___6 = 2,
    _PC_NAME_MAX___6 = 3,
    _PC_PATH_MAX___6 = 4,
    _PC_PIPE_BUF___6 = 5,
    _PC_CHOWN_RESTRICTED___6 = 6,
    _PC_NO_TRUNC___6 = 7,
    _PC_VDISABLE___6 = 8,
    _PC_SYNC_IO___6 = 9,
    _PC_ASYNC_IO___6 = 10,
    _PC_PRIO_IO___6 = 11,
    _PC_SOCK_MAXBUF___6 = 12,
    _PC_FILESIZEBITS___6 = 13,
    _PC_REC_INCR_XFER_SIZE___6 = 14,
    _PC_REC_MAX_XFER_SIZE___6 = 15,
    _PC_REC_MIN_XFER_SIZE___6 = 16,
    _PC_REC_XFER_ALIGN___6 = 17,
    _PC_ALLOC_SIZE_MIN___6 = 18,
    _PC_SYMLINK_MAX___6 = 19,
    _PC_2_SYMLINKS___6 = 20
} ;
#line 71
enum __anonenum_315186338___6 {
    _SC_ARG_MAX___6 = 0,
    _SC_CHILD_MAX___6 = 1,
    _SC_CLK_TCK___6 = 2,
    _SC_NGROUPS_MAX___6 = 3,
    _SC_OPEN_MAX___6 = 4,
    _SC_STREAM_MAX___6 = 5,
    _SC_TZNAME_MAX___6 = 6,
    _SC_JOB_CONTROL___6 = 7,
    _SC_SAVED_IDS___6 = 8,
    _SC_REALTIME_SIGNALS___6 = 9,
    _SC_PRIORITY_SCHEDULING___6 = 10,
    _SC_TIMERS___6 = 11,
    _SC_ASYNCHRONOUS_IO___6 = 12,
    _SC_PRIORITIZED_IO___6 = 13,
    _SC_SYNCHRONIZED_IO___6 = 14,
    _SC_FSYNC___6 = 15,
    _SC_MAPPED_FILES___6 = 16,
    _SC_MEMLOCK___6 = 17,
    _SC_MEMLOCK_RANGE___6 = 18,
    _SC_MEMORY_PROTECTION___6 = 19,
    _SC_MESSAGE_PASSING___6 = 20,
    _SC_SEMAPHORES___6 = 21,
    _SC_SHARED_MEMORY_OBJECTS___6 = 22,
    _SC_AIO_LISTIO_MAX___6 = 23,
    _SC_AIO_MAX___6 = 24,
    _SC_AIO_PRIO_DELTA_MAX___6 = 25,
    _SC_DELAYTIMER_MAX___6 = 26,
    _SC_MQ_OPEN_MAX___6 = 27,
    _SC_MQ_PRIO_MAX___6 = 28,
    _SC_VERSION___6 = 29,
    _SC_PAGESIZE___6 = 30,
    _SC_RTSIG_MAX___6 = 31,
    _SC_SEM_NSEMS_MAX___6 = 32,
    _SC_SEM_VALUE_MAX___6 = 33,
    _SC_SIGQUEUE_MAX___6 = 34,
    _SC_TIMER_MAX___6 = 35,
    _SC_BC_BASE_MAX___6 = 36,
    _SC_BC_DIM_MAX___6 = 37,
    _SC_BC_SCALE_MAX___6 = 38,
    _SC_BC_STRING_MAX___6 = 39,
    _SC_COLL_WEIGHTS_MAX___6 = 40,
    _SC_EQUIV_CLASS_MAX___6 = 41,
    _SC_EXPR_NEST_MAX___6 = 42,
    _SC_LINE_MAX___6 = 43,
    _SC_RE_DUP_MAX___6 = 44,
    _SC_CHARCLASS_NAME_MAX___6 = 45,
    _SC_2_VERSION___6 = 46,
    _SC_2_C_BIND___6 = 47,
    _SC_2_C_DEV___6 = 48,
    _SC_2_FORT_DEV___6 = 49,
    _SC_2_FORT_RUN___6 = 50,
    _SC_2_SW_DEV___6 = 51,
    _SC_2_LOCALEDEF___6 = 52,
    _SC_PII___6 = 53,
    _SC_PII_XTI___6 = 54,
    _SC_PII_SOCKET___6 = 55,
    _SC_PII_INTERNET___6 = 56,
    _SC_PII_OSI___6 = 57,
    _SC_POLL___6 = 58,
    _SC_SELECT___6 = 59,
    _SC_UIO_MAXIOV___6 = 60,
    _SC_IOV_MAX___6 = 60,
    _SC_PII_INTERNET_STREAM___6 = 61,
    _SC_PII_INTERNET_DGRAM___6 = 62,
    _SC_PII_OSI_COTS___6 = 63,
    _SC_PII_OSI_CLTS___6 = 64,
    _SC_PII_OSI_M___6 = 65,
    _SC_T_IOV_MAX___6 = 66,
    _SC_THREADS___6 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___6 = 68,
    _SC_GETGR_R_SIZE_MAX___6 = 69,
    _SC_GETPW_R_SIZE_MAX___6 = 70,
    _SC_LOGIN_NAME_MAX___6 = 71,
    _SC_TTY_NAME_MAX___6 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___6 = 73,
    _SC_THREAD_KEYS_MAX___6 = 74,
    _SC_THREAD_STACK_MIN___6 = 75,
    _SC_THREAD_THREADS_MAX___6 = 76,
    _SC_THREAD_ATTR_STACKADDR___6 = 77,
    _SC_THREAD_ATTR_STACKSIZE___6 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___6 = 79,
    _SC_THREAD_PRIO_INHERIT___6 = 80,
    _SC_THREAD_PRIO_PROTECT___6 = 81,
    _SC_THREAD_PROCESS_SHARED___6 = 82,
    _SC_NPROCESSORS_CONF___6 = 83,
    _SC_NPROCESSORS_ONLN___6 = 84,
    _SC_PHYS_PAGES___6 = 85,
    _SC_AVPHYS_PAGES___6 = 86,
    _SC_ATEXIT_MAX___6 = 87,
    _SC_PASS_MAX___6 = 88,
    _SC_XOPEN_VERSION___6 = 89,
    _SC_XOPEN_XCU_VERSION___6 = 90,
    _SC_XOPEN_UNIX___6 = 91,
    _SC_XOPEN_CRYPT___6 = 92,
    _SC_XOPEN_ENH_I18N___6 = 93,
    _SC_XOPEN_SHM___6 = 94,
    _SC_2_CHAR_TERM___6 = 95,
    _SC_2_C_VERSION___6 = 96,
    _SC_2_UPE___6 = 97,
    _SC_XOPEN_XPG2___6 = 98,
    _SC_XOPEN_XPG3___6 = 99,
    _SC_XOPEN_XPG4___6 = 100,
    _SC_CHAR_BIT___6 = 101,
    _SC_CHAR_MAX___6 = 102,
    _SC_CHAR_MIN___6 = 103,
    _SC_INT_MAX___6 = 104,
    _SC_INT_MIN___6 = 105,
    _SC_LONG_BIT___6 = 106,
    _SC_WORD_BIT___6 = 107,
    _SC_MB_LEN_MAX___6 = 108,
    _SC_NZERO___6 = 109,
    _SC_SSIZE_MAX___6 = 110,
    _SC_SCHAR_MAX___6 = 111,
    _SC_SCHAR_MIN___6 = 112,
    _SC_SHRT_MAX___6 = 113,
    _SC_SHRT_MIN___6 = 114,
    _SC_UCHAR_MAX___6 = 115,
    _SC_UINT_MAX___6 = 116,
    _SC_ULONG_MAX___6 = 117,
    _SC_USHRT_MAX___6 = 118,
    _SC_NL_ARGMAX___6 = 119,
    _SC_NL_LANGMAX___6 = 120,
    _SC_NL_MSGMAX___6 = 121,
    _SC_NL_NMAX___6 = 122,
    _SC_NL_SETMAX___6 = 123,
    _SC_NL_TEXTMAX___6 = 124,
    _SC_XBS5_ILP32_OFF32___6 = 125,
    _SC_XBS5_ILP32_OFFBIG___6 = 126,
    _SC_XBS5_LP64_OFF64___6 = 127,
    _SC_XBS5_LPBIG_OFFBIG___6 = 128,
    _SC_XOPEN_LEGACY___6 = 129,
    _SC_XOPEN_REALTIME___6 = 130,
    _SC_XOPEN_REALTIME_THREADS___6 = 131,
    _SC_ADVISORY_INFO___6 = 132,
    _SC_BARRIERS___6 = 133,
    _SC_BASE___6 = 134,
    _SC_C_LANG_SUPPORT___6 = 135,
    _SC_C_LANG_SUPPORT_R___6 = 136,
    _SC_CLOCK_SELECTION___6 = 137,
    _SC_CPUTIME___6 = 138,
    _SC_THREAD_CPUTIME___6 = 139,
    _SC_DEVICE_IO___6 = 140,
    _SC_DEVICE_SPECIFIC___6 = 141,
    _SC_DEVICE_SPECIFIC_R___6 = 142,
    _SC_FD_MGMT___6 = 143,
    _SC_FIFO___6 = 144,
    _SC_PIPE___6 = 145,
    _SC_FILE_ATTRIBUTES___6 = 146,
    _SC_FILE_LOCKING___6 = 147,
    _SC_FILE_SYSTEM___6 = 148,
    _SC_MONOTONIC_CLOCK___6 = 149,
    _SC_MULTI_PROCESS___6 = 150,
    _SC_SINGLE_PROCESS___6 = 151,
    _SC_NETWORKING___6 = 152,
    _SC_READER_WRITER_LOCKS___6 = 153,
    _SC_SPIN_LOCKS___6 = 154,
    _SC_REGEXP___6 = 155,
    _SC_REGEX_VERSION___6 = 156,
    _SC_SHELL___6 = 157,
    _SC_SIGNALS___6 = 158,
    _SC_SPAWN___6 = 159,
    _SC_SPORADIC_SERVER___6 = 160,
    _SC_THREAD_SPORADIC_SERVER___6 = 161,
    _SC_SYSTEM_DATABASE___6 = 162,
    _SC_SYSTEM_DATABASE_R___6 = 163,
    _SC_TIMEOUTS___6 = 164,
    _SC_TYPED_MEMORY_OBJECTS___6 = 165,
    _SC_USER_GROUPS___6 = 166,
    _SC_USER_GROUPS_R___6 = 167,
    _SC_2_PBS___6 = 168,
    _SC_2_PBS_ACCOUNTING___6 = 169,
    _SC_2_PBS_LOCATE___6 = 170,
    _SC_2_PBS_MESSAGE___6 = 171,
    _SC_2_PBS_TRACK___6 = 172,
    _SC_SYMLOOP_MAX___6 = 173,
    _SC_STREAMS___6 = 174,
    _SC_2_PBS_CHECKPOINT___6 = 175,
    _SC_V6_ILP32_OFF32___6 = 176,
    _SC_V6_ILP32_OFFBIG___6 = 177,
    _SC_V6_LP64_OFF64___6 = 178,
    _SC_V6_LPBIG_OFFBIG___6 = 179,
    _SC_HOST_NAME_MAX___6 = 180,
    _SC_TRACE___6 = 181,
    _SC_TRACE_EVENT_FILTER___6 = 182,
    _SC_TRACE_INHERIT___6 = 183,
    _SC_TRACE_LOG___6 = 184,
    _SC_LEVEL1_ICACHE_SIZE___6 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___6 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___6 = 187,
    _SC_LEVEL1_DCACHE_SIZE___6 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___6 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___6 = 190,
    _SC_LEVEL2_CACHE_SIZE___6 = 191,
    _SC_LEVEL2_CACHE_ASSOC___6 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___6 = 193,
    _SC_LEVEL3_CACHE_SIZE___6 = 194,
    _SC_LEVEL3_CACHE_ASSOC___6 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___6 = 196,
    _SC_LEVEL4_CACHE_SIZE___6 = 197,
    _SC_LEVEL4_CACHE_ASSOC___6 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___6 = 199,
    _SC_IPV6___6 = 235,
    _SC_RAW_SOCKETS___6 = 236,
    _SC_V7_ILP32_OFF32___6 = 237,
    _SC_V7_ILP32_OFFBIG___6 = 238,
    _SC_V7_LP64_OFF64___6 = 239,
    _SC_V7_LPBIG_OFFBIG___6 = 240,
    _SC_SS_REPL_MAX___6 = 241,
    _SC_TRACE_EVENT_NAME_MAX___6 = 242,
    _SC_TRACE_NAME_MAX___6 = 243,
    _SC_TRACE_SYS_MAX___6 = 244,
    _SC_TRACE_USER_EVENT_MAX___6 = 245,
    _SC_XOPEN_STREAMS___6 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___6 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___6 = 248
} ;
#line 533
enum __anonenum_875524036___6 {
    _CS_PATH___6 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___6 = 1,
    _CS_GNU_LIBC_VERSION___6 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___6 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___6 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___6 = 5,
    _CS_LFS_CFLAGS___6 = 1000,
    _CS_LFS_LDFLAGS___6 = 1001,
    _CS_LFS_LIBS___6 = 1002,
    _CS_LFS_LINTFLAGS___6 = 1003,
    _CS_LFS64_CFLAGS___6 = 1004,
    _CS_LFS64_LDFLAGS___6 = 1005,
    _CS_LFS64_LIBS___6 = 1006,
    _CS_LFS64_LINTFLAGS___6 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___6 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___6 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___6 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___6 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___6 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___6 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___6 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___6 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___6 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___6 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___6 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___6 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___6 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___6 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___6 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___6 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___6 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___6 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___6 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___6 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___6 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___6 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___6 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___6 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___6 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___6 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___6 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___6 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___6 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___6 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___6 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___6 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___6 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___6 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___6 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___6 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___6 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___6 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___6 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___6 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___6 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___6 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___6 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___6 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___6 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___6 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___6 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___6 = 1147,
    _CS_V6_ENV___6 = 1148,
    _CS_V7_ENV___6 = 1149
} ;
#line 418 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
struct png_dsort_struct {
   struct png_dsort_struct *next ;
   png_byte left ;
   png_byte right ;
};
#line 418 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
typedef struct png_dsort_struct png_dsort;
#line 424 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
typedef png_dsort *png_dsortp;
#line 425 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
typedef png_dsort **png_dsortpp;
#line 853 "/usr/include/math.h"
enum __anonenum_1037408945___7 {
    FP_NAN___7 = 0,
    FP_INFINITE___7 = 1,
    FP_ZERO___7 = 2,
    FP_SUBNORMAL___7 = 3,
    FP_NORMAL___7 = 4
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum_437032235___7 {
    _PC_LINK_MAX___7 = 0,
    _PC_MAX_CANON___7 = 1,
    _PC_MAX_INPUT___7 = 2,
    _PC_NAME_MAX___7 = 3,
    _PC_PATH_MAX___7 = 4,
    _PC_PIPE_BUF___7 = 5,
    _PC_CHOWN_RESTRICTED___7 = 6,
    _PC_NO_TRUNC___7 = 7,
    _PC_VDISABLE___7 = 8,
    _PC_SYNC_IO___7 = 9,
    _PC_ASYNC_IO___7 = 10,
    _PC_PRIO_IO___7 = 11,
    _PC_SOCK_MAXBUF___7 = 12,
    _PC_FILESIZEBITS___7 = 13,
    _PC_REC_INCR_XFER_SIZE___7 = 14,
    _PC_REC_MAX_XFER_SIZE___7 = 15,
    _PC_REC_MIN_XFER_SIZE___7 = 16,
    _PC_REC_XFER_ALIGN___7 = 17,
    _PC_ALLOC_SIZE_MIN___7 = 18,
    _PC_SYMLINK_MAX___7 = 19,
    _PC_2_SYMLINKS___7 = 20
} ;
#line 71
enum __anonenum_315186338___7 {
    _SC_ARG_MAX___7 = 0,
    _SC_CHILD_MAX___7 = 1,
    _SC_CLK_TCK___7 = 2,
    _SC_NGROUPS_MAX___7 = 3,
    _SC_OPEN_MAX___7 = 4,
    _SC_STREAM_MAX___7 = 5,
    _SC_TZNAME_MAX___7 = 6,
    _SC_JOB_CONTROL___7 = 7,
    _SC_SAVED_IDS___7 = 8,
    _SC_REALTIME_SIGNALS___7 = 9,
    _SC_PRIORITY_SCHEDULING___7 = 10,
    _SC_TIMERS___7 = 11,
    _SC_ASYNCHRONOUS_IO___7 = 12,
    _SC_PRIORITIZED_IO___7 = 13,
    _SC_SYNCHRONIZED_IO___7 = 14,
    _SC_FSYNC___7 = 15,
    _SC_MAPPED_FILES___7 = 16,
    _SC_MEMLOCK___7 = 17,
    _SC_MEMLOCK_RANGE___7 = 18,
    _SC_MEMORY_PROTECTION___7 = 19,
    _SC_MESSAGE_PASSING___7 = 20,
    _SC_SEMAPHORES___7 = 21,
    _SC_SHARED_MEMORY_OBJECTS___7 = 22,
    _SC_AIO_LISTIO_MAX___7 = 23,
    _SC_AIO_MAX___7 = 24,
    _SC_AIO_PRIO_DELTA_MAX___7 = 25,
    _SC_DELAYTIMER_MAX___7 = 26,
    _SC_MQ_OPEN_MAX___7 = 27,
    _SC_MQ_PRIO_MAX___7 = 28,
    _SC_VERSION___7 = 29,
    _SC_PAGESIZE___7 = 30,
    _SC_RTSIG_MAX___7 = 31,
    _SC_SEM_NSEMS_MAX___7 = 32,
    _SC_SEM_VALUE_MAX___7 = 33,
    _SC_SIGQUEUE_MAX___7 = 34,
    _SC_TIMER_MAX___7 = 35,
    _SC_BC_BASE_MAX___7 = 36,
    _SC_BC_DIM_MAX___7 = 37,
    _SC_BC_SCALE_MAX___7 = 38,
    _SC_BC_STRING_MAX___7 = 39,
    _SC_COLL_WEIGHTS_MAX___7 = 40,
    _SC_EQUIV_CLASS_MAX___7 = 41,
    _SC_EXPR_NEST_MAX___7 = 42,
    _SC_LINE_MAX___7 = 43,
    _SC_RE_DUP_MAX___7 = 44,
    _SC_CHARCLASS_NAME_MAX___7 = 45,
    _SC_2_VERSION___7 = 46,
    _SC_2_C_BIND___7 = 47,
    _SC_2_C_DEV___7 = 48,
    _SC_2_FORT_DEV___7 = 49,
    _SC_2_FORT_RUN___7 = 50,
    _SC_2_SW_DEV___7 = 51,
    _SC_2_LOCALEDEF___7 = 52,
    _SC_PII___7 = 53,
    _SC_PII_XTI___7 = 54,
    _SC_PII_SOCKET___7 = 55,
    _SC_PII_INTERNET___7 = 56,
    _SC_PII_OSI___7 = 57,
    _SC_POLL___7 = 58,
    _SC_SELECT___7 = 59,
    _SC_UIO_MAXIOV___7 = 60,
    _SC_IOV_MAX___7 = 60,
    _SC_PII_INTERNET_STREAM___7 = 61,
    _SC_PII_INTERNET_DGRAM___7 = 62,
    _SC_PII_OSI_COTS___7 = 63,
    _SC_PII_OSI_CLTS___7 = 64,
    _SC_PII_OSI_M___7 = 65,
    _SC_T_IOV_MAX___7 = 66,
    _SC_THREADS___7 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___7 = 68,
    _SC_GETGR_R_SIZE_MAX___7 = 69,
    _SC_GETPW_R_SIZE_MAX___7 = 70,
    _SC_LOGIN_NAME_MAX___7 = 71,
    _SC_TTY_NAME_MAX___7 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___7 = 73,
    _SC_THREAD_KEYS_MAX___7 = 74,
    _SC_THREAD_STACK_MIN___7 = 75,
    _SC_THREAD_THREADS_MAX___7 = 76,
    _SC_THREAD_ATTR_STACKADDR___7 = 77,
    _SC_THREAD_ATTR_STACKSIZE___7 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___7 = 79,
    _SC_THREAD_PRIO_INHERIT___7 = 80,
    _SC_THREAD_PRIO_PROTECT___7 = 81,
    _SC_THREAD_PROCESS_SHARED___7 = 82,
    _SC_NPROCESSORS_CONF___7 = 83,
    _SC_NPROCESSORS_ONLN___7 = 84,
    _SC_PHYS_PAGES___7 = 85,
    _SC_AVPHYS_PAGES___7 = 86,
    _SC_ATEXIT_MAX___7 = 87,
    _SC_PASS_MAX___7 = 88,
    _SC_XOPEN_VERSION___7 = 89,
    _SC_XOPEN_XCU_VERSION___7 = 90,
    _SC_XOPEN_UNIX___7 = 91,
    _SC_XOPEN_CRYPT___7 = 92,
    _SC_XOPEN_ENH_I18N___7 = 93,
    _SC_XOPEN_SHM___7 = 94,
    _SC_2_CHAR_TERM___7 = 95,
    _SC_2_C_VERSION___7 = 96,
    _SC_2_UPE___7 = 97,
    _SC_XOPEN_XPG2___7 = 98,
    _SC_XOPEN_XPG3___7 = 99,
    _SC_XOPEN_XPG4___7 = 100,
    _SC_CHAR_BIT___7 = 101,
    _SC_CHAR_MAX___7 = 102,
    _SC_CHAR_MIN___7 = 103,
    _SC_INT_MAX___7 = 104,
    _SC_INT_MIN___7 = 105,
    _SC_LONG_BIT___7 = 106,
    _SC_WORD_BIT___7 = 107,
    _SC_MB_LEN_MAX___7 = 108,
    _SC_NZERO___7 = 109,
    _SC_SSIZE_MAX___7 = 110,
    _SC_SCHAR_MAX___7 = 111,
    _SC_SCHAR_MIN___7 = 112,
    _SC_SHRT_MAX___7 = 113,
    _SC_SHRT_MIN___7 = 114,
    _SC_UCHAR_MAX___7 = 115,
    _SC_UINT_MAX___7 = 116,
    _SC_ULONG_MAX___7 = 117,
    _SC_USHRT_MAX___7 = 118,
    _SC_NL_ARGMAX___7 = 119,
    _SC_NL_LANGMAX___7 = 120,
    _SC_NL_MSGMAX___7 = 121,
    _SC_NL_NMAX___7 = 122,
    _SC_NL_SETMAX___7 = 123,
    _SC_NL_TEXTMAX___7 = 124,
    _SC_XBS5_ILP32_OFF32___7 = 125,
    _SC_XBS5_ILP32_OFFBIG___7 = 126,
    _SC_XBS5_LP64_OFF64___7 = 127,
    _SC_XBS5_LPBIG_OFFBIG___7 = 128,
    _SC_XOPEN_LEGACY___7 = 129,
    _SC_XOPEN_REALTIME___7 = 130,
    _SC_XOPEN_REALTIME_THREADS___7 = 131,
    _SC_ADVISORY_INFO___7 = 132,
    _SC_BARRIERS___7 = 133,
    _SC_BASE___7 = 134,
    _SC_C_LANG_SUPPORT___7 = 135,
    _SC_C_LANG_SUPPORT_R___7 = 136,
    _SC_CLOCK_SELECTION___7 = 137,
    _SC_CPUTIME___7 = 138,
    _SC_THREAD_CPUTIME___7 = 139,
    _SC_DEVICE_IO___7 = 140,
    _SC_DEVICE_SPECIFIC___7 = 141,
    _SC_DEVICE_SPECIFIC_R___7 = 142,
    _SC_FD_MGMT___7 = 143,
    _SC_FIFO___7 = 144,
    _SC_PIPE___7 = 145,
    _SC_FILE_ATTRIBUTES___7 = 146,
    _SC_FILE_LOCKING___7 = 147,
    _SC_FILE_SYSTEM___7 = 148,
    _SC_MONOTONIC_CLOCK___7 = 149,
    _SC_MULTI_PROCESS___7 = 150,
    _SC_SINGLE_PROCESS___7 = 151,
    _SC_NETWORKING___7 = 152,
    _SC_READER_WRITER_LOCKS___7 = 153,
    _SC_SPIN_LOCKS___7 = 154,
    _SC_REGEXP___7 = 155,
    _SC_REGEX_VERSION___7 = 156,
    _SC_SHELL___7 = 157,
    _SC_SIGNALS___7 = 158,
    _SC_SPAWN___7 = 159,
    _SC_SPORADIC_SERVER___7 = 160,
    _SC_THREAD_SPORADIC_SERVER___7 = 161,
    _SC_SYSTEM_DATABASE___7 = 162,
    _SC_SYSTEM_DATABASE_R___7 = 163,
    _SC_TIMEOUTS___7 = 164,
    _SC_TYPED_MEMORY_OBJECTS___7 = 165,
    _SC_USER_GROUPS___7 = 166,
    _SC_USER_GROUPS_R___7 = 167,
    _SC_2_PBS___7 = 168,
    _SC_2_PBS_ACCOUNTING___7 = 169,
    _SC_2_PBS_LOCATE___7 = 170,
    _SC_2_PBS_MESSAGE___7 = 171,
    _SC_2_PBS_TRACK___7 = 172,
    _SC_SYMLOOP_MAX___7 = 173,
    _SC_STREAMS___7 = 174,
    _SC_2_PBS_CHECKPOINT___7 = 175,
    _SC_V6_ILP32_OFF32___7 = 176,
    _SC_V6_ILP32_OFFBIG___7 = 177,
    _SC_V6_LP64_OFF64___7 = 178,
    _SC_V6_LPBIG_OFFBIG___7 = 179,
    _SC_HOST_NAME_MAX___7 = 180,
    _SC_TRACE___7 = 181,
    _SC_TRACE_EVENT_FILTER___7 = 182,
    _SC_TRACE_INHERIT___7 = 183,
    _SC_TRACE_LOG___7 = 184,
    _SC_LEVEL1_ICACHE_SIZE___7 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___7 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___7 = 187,
    _SC_LEVEL1_DCACHE_SIZE___7 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___7 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___7 = 190,
    _SC_LEVEL2_CACHE_SIZE___7 = 191,
    _SC_LEVEL2_CACHE_ASSOC___7 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___7 = 193,
    _SC_LEVEL3_CACHE_SIZE___7 = 194,
    _SC_LEVEL3_CACHE_ASSOC___7 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___7 = 196,
    _SC_LEVEL4_CACHE_SIZE___7 = 197,
    _SC_LEVEL4_CACHE_ASSOC___7 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___7 = 199,
    _SC_IPV6___7 = 235,
    _SC_RAW_SOCKETS___7 = 236,
    _SC_V7_ILP32_OFF32___7 = 237,
    _SC_V7_ILP32_OFFBIG___7 = 238,
    _SC_V7_LP64_OFF64___7 = 239,
    _SC_V7_LPBIG_OFFBIG___7 = 240,
    _SC_SS_REPL_MAX___7 = 241,
    _SC_TRACE_EVENT_NAME_MAX___7 = 242,
    _SC_TRACE_NAME_MAX___7 = 243,
    _SC_TRACE_SYS_MAX___7 = 244,
    _SC_TRACE_USER_EVENT_MAX___7 = 245,
    _SC_XOPEN_STREAMS___7 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___7 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___7 = 248
} ;
#line 533
enum __anonenum_875524036___7 {
    _CS_PATH___7 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___7 = 1,
    _CS_GNU_LIBC_VERSION___7 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___7 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___7 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___7 = 5,
    _CS_LFS_CFLAGS___7 = 1000,
    _CS_LFS_LDFLAGS___7 = 1001,
    _CS_LFS_LIBS___7 = 1002,
    _CS_LFS_LINTFLAGS___7 = 1003,
    _CS_LFS64_CFLAGS___7 = 1004,
    _CS_LFS64_LDFLAGS___7 = 1005,
    _CS_LFS64_LIBS___7 = 1006,
    _CS_LFS64_LINTFLAGS___7 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___7 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___7 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___7 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___7 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___7 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___7 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___7 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___7 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___7 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___7 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___7 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___7 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___7 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___7 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___7 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___7 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___7 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___7 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___7 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___7 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___7 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___7 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___7 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___7 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___7 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___7 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___7 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___7 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___7 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___7 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___7 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___7 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___7 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___7 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___7 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___7 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___7 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___7 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___7 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___7 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___7 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___7 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___7 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___7 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___7 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___7 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___7 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___7 = 1147,
    _CS_V6_ENV___7 = 1148,
    _CS_V7_ENV___7 = 1149
} ;
#line 853 "/usr/include/math.h"
enum __anonenum_1037408945___8 {
    FP_NAN___8 = 0,
    FP_INFINITE___8 = 1,
    FP_ZERO___8 = 2,
    FP_SUBNORMAL___8 = 3,
    FP_NORMAL___8 = 4
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum_437032235___8 {
    _PC_LINK_MAX___8 = 0,
    _PC_MAX_CANON___8 = 1,
    _PC_MAX_INPUT___8 = 2,
    _PC_NAME_MAX___8 = 3,
    _PC_PATH_MAX___8 = 4,
    _PC_PIPE_BUF___8 = 5,
    _PC_CHOWN_RESTRICTED___8 = 6,
    _PC_NO_TRUNC___8 = 7,
    _PC_VDISABLE___8 = 8,
    _PC_SYNC_IO___8 = 9,
    _PC_ASYNC_IO___8 = 10,
    _PC_PRIO_IO___8 = 11,
    _PC_SOCK_MAXBUF___8 = 12,
    _PC_FILESIZEBITS___8 = 13,
    _PC_REC_INCR_XFER_SIZE___8 = 14,
    _PC_REC_MAX_XFER_SIZE___8 = 15,
    _PC_REC_MIN_XFER_SIZE___8 = 16,
    _PC_REC_XFER_ALIGN___8 = 17,
    _PC_ALLOC_SIZE_MIN___8 = 18,
    _PC_SYMLINK_MAX___8 = 19,
    _PC_2_SYMLINKS___8 = 20
} ;
#line 71
enum __anonenum_315186338___8 {
    _SC_ARG_MAX___8 = 0,
    _SC_CHILD_MAX___8 = 1,
    _SC_CLK_TCK___8 = 2,
    _SC_NGROUPS_MAX___8 = 3,
    _SC_OPEN_MAX___8 = 4,
    _SC_STREAM_MAX___8 = 5,
    _SC_TZNAME_MAX___8 = 6,
    _SC_JOB_CONTROL___8 = 7,
    _SC_SAVED_IDS___8 = 8,
    _SC_REALTIME_SIGNALS___8 = 9,
    _SC_PRIORITY_SCHEDULING___8 = 10,
    _SC_TIMERS___8 = 11,
    _SC_ASYNCHRONOUS_IO___8 = 12,
    _SC_PRIORITIZED_IO___8 = 13,
    _SC_SYNCHRONIZED_IO___8 = 14,
    _SC_FSYNC___8 = 15,
    _SC_MAPPED_FILES___8 = 16,
    _SC_MEMLOCK___8 = 17,
    _SC_MEMLOCK_RANGE___8 = 18,
    _SC_MEMORY_PROTECTION___8 = 19,
    _SC_MESSAGE_PASSING___8 = 20,
    _SC_SEMAPHORES___8 = 21,
    _SC_SHARED_MEMORY_OBJECTS___8 = 22,
    _SC_AIO_LISTIO_MAX___8 = 23,
    _SC_AIO_MAX___8 = 24,
    _SC_AIO_PRIO_DELTA_MAX___8 = 25,
    _SC_DELAYTIMER_MAX___8 = 26,
    _SC_MQ_OPEN_MAX___8 = 27,
    _SC_MQ_PRIO_MAX___8 = 28,
    _SC_VERSION___8 = 29,
    _SC_PAGESIZE___8 = 30,
    _SC_RTSIG_MAX___8 = 31,
    _SC_SEM_NSEMS_MAX___8 = 32,
    _SC_SEM_VALUE_MAX___8 = 33,
    _SC_SIGQUEUE_MAX___8 = 34,
    _SC_TIMER_MAX___8 = 35,
    _SC_BC_BASE_MAX___8 = 36,
    _SC_BC_DIM_MAX___8 = 37,
    _SC_BC_SCALE_MAX___8 = 38,
    _SC_BC_STRING_MAX___8 = 39,
    _SC_COLL_WEIGHTS_MAX___8 = 40,
    _SC_EQUIV_CLASS_MAX___8 = 41,
    _SC_EXPR_NEST_MAX___8 = 42,
    _SC_LINE_MAX___8 = 43,
    _SC_RE_DUP_MAX___8 = 44,
    _SC_CHARCLASS_NAME_MAX___8 = 45,
    _SC_2_VERSION___8 = 46,
    _SC_2_C_BIND___8 = 47,
    _SC_2_C_DEV___8 = 48,
    _SC_2_FORT_DEV___8 = 49,
    _SC_2_FORT_RUN___8 = 50,
    _SC_2_SW_DEV___8 = 51,
    _SC_2_LOCALEDEF___8 = 52,
    _SC_PII___8 = 53,
    _SC_PII_XTI___8 = 54,
    _SC_PII_SOCKET___8 = 55,
    _SC_PII_INTERNET___8 = 56,
    _SC_PII_OSI___8 = 57,
    _SC_POLL___8 = 58,
    _SC_SELECT___8 = 59,
    _SC_UIO_MAXIOV___8 = 60,
    _SC_IOV_MAX___8 = 60,
    _SC_PII_INTERNET_STREAM___8 = 61,
    _SC_PII_INTERNET_DGRAM___8 = 62,
    _SC_PII_OSI_COTS___8 = 63,
    _SC_PII_OSI_CLTS___8 = 64,
    _SC_PII_OSI_M___8 = 65,
    _SC_T_IOV_MAX___8 = 66,
    _SC_THREADS___8 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___8 = 68,
    _SC_GETGR_R_SIZE_MAX___8 = 69,
    _SC_GETPW_R_SIZE_MAX___8 = 70,
    _SC_LOGIN_NAME_MAX___8 = 71,
    _SC_TTY_NAME_MAX___8 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___8 = 73,
    _SC_THREAD_KEYS_MAX___8 = 74,
    _SC_THREAD_STACK_MIN___8 = 75,
    _SC_THREAD_THREADS_MAX___8 = 76,
    _SC_THREAD_ATTR_STACKADDR___8 = 77,
    _SC_THREAD_ATTR_STACKSIZE___8 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___8 = 79,
    _SC_THREAD_PRIO_INHERIT___8 = 80,
    _SC_THREAD_PRIO_PROTECT___8 = 81,
    _SC_THREAD_PROCESS_SHARED___8 = 82,
    _SC_NPROCESSORS_CONF___8 = 83,
    _SC_NPROCESSORS_ONLN___8 = 84,
    _SC_PHYS_PAGES___8 = 85,
    _SC_AVPHYS_PAGES___8 = 86,
    _SC_ATEXIT_MAX___8 = 87,
    _SC_PASS_MAX___8 = 88,
    _SC_XOPEN_VERSION___8 = 89,
    _SC_XOPEN_XCU_VERSION___8 = 90,
    _SC_XOPEN_UNIX___8 = 91,
    _SC_XOPEN_CRYPT___8 = 92,
    _SC_XOPEN_ENH_I18N___8 = 93,
    _SC_XOPEN_SHM___8 = 94,
    _SC_2_CHAR_TERM___8 = 95,
    _SC_2_C_VERSION___8 = 96,
    _SC_2_UPE___8 = 97,
    _SC_XOPEN_XPG2___8 = 98,
    _SC_XOPEN_XPG3___8 = 99,
    _SC_XOPEN_XPG4___8 = 100,
    _SC_CHAR_BIT___8 = 101,
    _SC_CHAR_MAX___8 = 102,
    _SC_CHAR_MIN___8 = 103,
    _SC_INT_MAX___8 = 104,
    _SC_INT_MIN___8 = 105,
    _SC_LONG_BIT___8 = 106,
    _SC_WORD_BIT___8 = 107,
    _SC_MB_LEN_MAX___8 = 108,
    _SC_NZERO___8 = 109,
    _SC_SSIZE_MAX___8 = 110,
    _SC_SCHAR_MAX___8 = 111,
    _SC_SCHAR_MIN___8 = 112,
    _SC_SHRT_MAX___8 = 113,
    _SC_SHRT_MIN___8 = 114,
    _SC_UCHAR_MAX___8 = 115,
    _SC_UINT_MAX___8 = 116,
    _SC_ULONG_MAX___8 = 117,
    _SC_USHRT_MAX___8 = 118,
    _SC_NL_ARGMAX___8 = 119,
    _SC_NL_LANGMAX___8 = 120,
    _SC_NL_MSGMAX___8 = 121,
    _SC_NL_NMAX___8 = 122,
    _SC_NL_SETMAX___8 = 123,
    _SC_NL_TEXTMAX___8 = 124,
    _SC_XBS5_ILP32_OFF32___8 = 125,
    _SC_XBS5_ILP32_OFFBIG___8 = 126,
    _SC_XBS5_LP64_OFF64___8 = 127,
    _SC_XBS5_LPBIG_OFFBIG___8 = 128,
    _SC_XOPEN_LEGACY___8 = 129,
    _SC_XOPEN_REALTIME___8 = 130,
    _SC_XOPEN_REALTIME_THREADS___8 = 131,
    _SC_ADVISORY_INFO___8 = 132,
    _SC_BARRIERS___8 = 133,
    _SC_BASE___8 = 134,
    _SC_C_LANG_SUPPORT___8 = 135,
    _SC_C_LANG_SUPPORT_R___8 = 136,
    _SC_CLOCK_SELECTION___8 = 137,
    _SC_CPUTIME___8 = 138,
    _SC_THREAD_CPUTIME___8 = 139,
    _SC_DEVICE_IO___8 = 140,
    _SC_DEVICE_SPECIFIC___8 = 141,
    _SC_DEVICE_SPECIFIC_R___8 = 142,
    _SC_FD_MGMT___8 = 143,
    _SC_FIFO___8 = 144,
    _SC_PIPE___8 = 145,
    _SC_FILE_ATTRIBUTES___8 = 146,
    _SC_FILE_LOCKING___8 = 147,
    _SC_FILE_SYSTEM___8 = 148,
    _SC_MONOTONIC_CLOCK___8 = 149,
    _SC_MULTI_PROCESS___8 = 150,
    _SC_SINGLE_PROCESS___8 = 151,
    _SC_NETWORKING___8 = 152,
    _SC_READER_WRITER_LOCKS___8 = 153,
    _SC_SPIN_LOCKS___8 = 154,
    _SC_REGEXP___8 = 155,
    _SC_REGEX_VERSION___8 = 156,
    _SC_SHELL___8 = 157,
    _SC_SIGNALS___8 = 158,
    _SC_SPAWN___8 = 159,
    _SC_SPORADIC_SERVER___8 = 160,
    _SC_THREAD_SPORADIC_SERVER___8 = 161,
    _SC_SYSTEM_DATABASE___8 = 162,
    _SC_SYSTEM_DATABASE_R___8 = 163,
    _SC_TIMEOUTS___8 = 164,
    _SC_TYPED_MEMORY_OBJECTS___8 = 165,
    _SC_USER_GROUPS___8 = 166,
    _SC_USER_GROUPS_R___8 = 167,
    _SC_2_PBS___8 = 168,
    _SC_2_PBS_ACCOUNTING___8 = 169,
    _SC_2_PBS_LOCATE___8 = 170,
    _SC_2_PBS_MESSAGE___8 = 171,
    _SC_2_PBS_TRACK___8 = 172,
    _SC_SYMLOOP_MAX___8 = 173,
    _SC_STREAMS___8 = 174,
    _SC_2_PBS_CHECKPOINT___8 = 175,
    _SC_V6_ILP32_OFF32___8 = 176,
    _SC_V6_ILP32_OFFBIG___8 = 177,
    _SC_V6_LP64_OFF64___8 = 178,
    _SC_V6_LPBIG_OFFBIG___8 = 179,
    _SC_HOST_NAME_MAX___8 = 180,
    _SC_TRACE___8 = 181,
    _SC_TRACE_EVENT_FILTER___8 = 182,
    _SC_TRACE_INHERIT___8 = 183,
    _SC_TRACE_LOG___8 = 184,
    _SC_LEVEL1_ICACHE_SIZE___8 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___8 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___8 = 187,
    _SC_LEVEL1_DCACHE_SIZE___8 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___8 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___8 = 190,
    _SC_LEVEL2_CACHE_SIZE___8 = 191,
    _SC_LEVEL2_CACHE_ASSOC___8 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___8 = 193,
    _SC_LEVEL3_CACHE_SIZE___8 = 194,
    _SC_LEVEL3_CACHE_ASSOC___8 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___8 = 196,
    _SC_LEVEL4_CACHE_SIZE___8 = 197,
    _SC_LEVEL4_CACHE_ASSOC___8 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___8 = 199,
    _SC_IPV6___8 = 235,
    _SC_RAW_SOCKETS___8 = 236,
    _SC_V7_ILP32_OFF32___8 = 237,
    _SC_V7_ILP32_OFFBIG___8 = 238,
    _SC_V7_LP64_OFF64___8 = 239,
    _SC_V7_LPBIG_OFFBIG___8 = 240,
    _SC_SS_REPL_MAX___8 = 241,
    _SC_TRACE_EVENT_NAME_MAX___8 = 242,
    _SC_TRACE_NAME_MAX___8 = 243,
    _SC_TRACE_SYS_MAX___8 = 244,
    _SC_TRACE_USER_EVENT_MAX___8 = 245,
    _SC_XOPEN_STREAMS___8 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___8 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___8 = 248
} ;
#line 533
enum __anonenum_875524036___8 {
    _CS_PATH___8 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___8 = 1,
    _CS_GNU_LIBC_VERSION___8 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___8 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___8 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___8 = 5,
    _CS_LFS_CFLAGS___8 = 1000,
    _CS_LFS_LDFLAGS___8 = 1001,
    _CS_LFS_LIBS___8 = 1002,
    _CS_LFS_LINTFLAGS___8 = 1003,
    _CS_LFS64_CFLAGS___8 = 1004,
    _CS_LFS64_LDFLAGS___8 = 1005,
    _CS_LFS64_LIBS___8 = 1006,
    _CS_LFS64_LINTFLAGS___8 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___8 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___8 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___8 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___8 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___8 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___8 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___8 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___8 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___8 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___8 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___8 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___8 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___8 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___8 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___8 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___8 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___8 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___8 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___8 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___8 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___8 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___8 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___8 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___8 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___8 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___8 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___8 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___8 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___8 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___8 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___8 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___8 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___8 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___8 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___8 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___8 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___8 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___8 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___8 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___8 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___8 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___8 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___8 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___8 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___8 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___8 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___8 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___8 = 1147,
    _CS_V6_ENV___8 = 1148,
    _CS_V7_ENV___8 = 1149
} ;
#line 853 "/usr/include/math.h"
enum __anonenum_1037408945___9 {
    FP_NAN___9 = 0,
    FP_INFINITE___9 = 1,
    FP_ZERO___9 = 2,
    FP_SUBNORMAL___9 = 3,
    FP_NORMAL___9 = 4
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum_437032235___9 {
    _PC_LINK_MAX___9 = 0,
    _PC_MAX_CANON___9 = 1,
    _PC_MAX_INPUT___9 = 2,
    _PC_NAME_MAX___9 = 3,
    _PC_PATH_MAX___9 = 4,
    _PC_PIPE_BUF___9 = 5,
    _PC_CHOWN_RESTRICTED___9 = 6,
    _PC_NO_TRUNC___9 = 7,
    _PC_VDISABLE___9 = 8,
    _PC_SYNC_IO___9 = 9,
    _PC_ASYNC_IO___9 = 10,
    _PC_PRIO_IO___9 = 11,
    _PC_SOCK_MAXBUF___9 = 12,
    _PC_FILESIZEBITS___9 = 13,
    _PC_REC_INCR_XFER_SIZE___9 = 14,
    _PC_REC_MAX_XFER_SIZE___9 = 15,
    _PC_REC_MIN_XFER_SIZE___9 = 16,
    _PC_REC_XFER_ALIGN___9 = 17,
    _PC_ALLOC_SIZE_MIN___9 = 18,
    _PC_SYMLINK_MAX___9 = 19,
    _PC_2_SYMLINKS___9 = 20
} ;
#line 71
enum __anonenum_315186338___9 {
    _SC_ARG_MAX___9 = 0,
    _SC_CHILD_MAX___9 = 1,
    _SC_CLK_TCK___9 = 2,
    _SC_NGROUPS_MAX___9 = 3,
    _SC_OPEN_MAX___9 = 4,
    _SC_STREAM_MAX___9 = 5,
    _SC_TZNAME_MAX___9 = 6,
    _SC_JOB_CONTROL___9 = 7,
    _SC_SAVED_IDS___9 = 8,
    _SC_REALTIME_SIGNALS___9 = 9,
    _SC_PRIORITY_SCHEDULING___9 = 10,
    _SC_TIMERS___9 = 11,
    _SC_ASYNCHRONOUS_IO___9 = 12,
    _SC_PRIORITIZED_IO___9 = 13,
    _SC_SYNCHRONIZED_IO___9 = 14,
    _SC_FSYNC___9 = 15,
    _SC_MAPPED_FILES___9 = 16,
    _SC_MEMLOCK___9 = 17,
    _SC_MEMLOCK_RANGE___9 = 18,
    _SC_MEMORY_PROTECTION___9 = 19,
    _SC_MESSAGE_PASSING___9 = 20,
    _SC_SEMAPHORES___9 = 21,
    _SC_SHARED_MEMORY_OBJECTS___9 = 22,
    _SC_AIO_LISTIO_MAX___9 = 23,
    _SC_AIO_MAX___9 = 24,
    _SC_AIO_PRIO_DELTA_MAX___9 = 25,
    _SC_DELAYTIMER_MAX___9 = 26,
    _SC_MQ_OPEN_MAX___9 = 27,
    _SC_MQ_PRIO_MAX___9 = 28,
    _SC_VERSION___9 = 29,
    _SC_PAGESIZE___9 = 30,
    _SC_RTSIG_MAX___9 = 31,
    _SC_SEM_NSEMS_MAX___9 = 32,
    _SC_SEM_VALUE_MAX___9 = 33,
    _SC_SIGQUEUE_MAX___9 = 34,
    _SC_TIMER_MAX___9 = 35,
    _SC_BC_BASE_MAX___9 = 36,
    _SC_BC_DIM_MAX___9 = 37,
    _SC_BC_SCALE_MAX___9 = 38,
    _SC_BC_STRING_MAX___9 = 39,
    _SC_COLL_WEIGHTS_MAX___9 = 40,
    _SC_EQUIV_CLASS_MAX___9 = 41,
    _SC_EXPR_NEST_MAX___9 = 42,
    _SC_LINE_MAX___9 = 43,
    _SC_RE_DUP_MAX___9 = 44,
    _SC_CHARCLASS_NAME_MAX___9 = 45,
    _SC_2_VERSION___9 = 46,
    _SC_2_C_BIND___9 = 47,
    _SC_2_C_DEV___9 = 48,
    _SC_2_FORT_DEV___9 = 49,
    _SC_2_FORT_RUN___9 = 50,
    _SC_2_SW_DEV___9 = 51,
    _SC_2_LOCALEDEF___9 = 52,
    _SC_PII___9 = 53,
    _SC_PII_XTI___9 = 54,
    _SC_PII_SOCKET___9 = 55,
    _SC_PII_INTERNET___9 = 56,
    _SC_PII_OSI___9 = 57,
    _SC_POLL___9 = 58,
    _SC_SELECT___9 = 59,
    _SC_UIO_MAXIOV___9 = 60,
    _SC_IOV_MAX___9 = 60,
    _SC_PII_INTERNET_STREAM___9 = 61,
    _SC_PII_INTERNET_DGRAM___9 = 62,
    _SC_PII_OSI_COTS___9 = 63,
    _SC_PII_OSI_CLTS___9 = 64,
    _SC_PII_OSI_M___9 = 65,
    _SC_T_IOV_MAX___9 = 66,
    _SC_THREADS___9 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___9 = 68,
    _SC_GETGR_R_SIZE_MAX___9 = 69,
    _SC_GETPW_R_SIZE_MAX___9 = 70,
    _SC_LOGIN_NAME_MAX___9 = 71,
    _SC_TTY_NAME_MAX___9 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___9 = 73,
    _SC_THREAD_KEYS_MAX___9 = 74,
    _SC_THREAD_STACK_MIN___9 = 75,
    _SC_THREAD_THREADS_MAX___9 = 76,
    _SC_THREAD_ATTR_STACKADDR___9 = 77,
    _SC_THREAD_ATTR_STACKSIZE___9 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___9 = 79,
    _SC_THREAD_PRIO_INHERIT___9 = 80,
    _SC_THREAD_PRIO_PROTECT___9 = 81,
    _SC_THREAD_PROCESS_SHARED___9 = 82,
    _SC_NPROCESSORS_CONF___9 = 83,
    _SC_NPROCESSORS_ONLN___9 = 84,
    _SC_PHYS_PAGES___9 = 85,
    _SC_AVPHYS_PAGES___9 = 86,
    _SC_ATEXIT_MAX___9 = 87,
    _SC_PASS_MAX___9 = 88,
    _SC_XOPEN_VERSION___9 = 89,
    _SC_XOPEN_XCU_VERSION___9 = 90,
    _SC_XOPEN_UNIX___9 = 91,
    _SC_XOPEN_CRYPT___9 = 92,
    _SC_XOPEN_ENH_I18N___9 = 93,
    _SC_XOPEN_SHM___9 = 94,
    _SC_2_CHAR_TERM___9 = 95,
    _SC_2_C_VERSION___9 = 96,
    _SC_2_UPE___9 = 97,
    _SC_XOPEN_XPG2___9 = 98,
    _SC_XOPEN_XPG3___9 = 99,
    _SC_XOPEN_XPG4___9 = 100,
    _SC_CHAR_BIT___9 = 101,
    _SC_CHAR_MAX___9 = 102,
    _SC_CHAR_MIN___9 = 103,
    _SC_INT_MAX___9 = 104,
    _SC_INT_MIN___9 = 105,
    _SC_LONG_BIT___9 = 106,
    _SC_WORD_BIT___9 = 107,
    _SC_MB_LEN_MAX___9 = 108,
    _SC_NZERO___9 = 109,
    _SC_SSIZE_MAX___9 = 110,
    _SC_SCHAR_MAX___9 = 111,
    _SC_SCHAR_MIN___9 = 112,
    _SC_SHRT_MAX___9 = 113,
    _SC_SHRT_MIN___9 = 114,
    _SC_UCHAR_MAX___9 = 115,
    _SC_UINT_MAX___9 = 116,
    _SC_ULONG_MAX___9 = 117,
    _SC_USHRT_MAX___9 = 118,
    _SC_NL_ARGMAX___9 = 119,
    _SC_NL_LANGMAX___9 = 120,
    _SC_NL_MSGMAX___9 = 121,
    _SC_NL_NMAX___9 = 122,
    _SC_NL_SETMAX___9 = 123,
    _SC_NL_TEXTMAX___9 = 124,
    _SC_XBS5_ILP32_OFF32___9 = 125,
    _SC_XBS5_ILP32_OFFBIG___9 = 126,
    _SC_XBS5_LP64_OFF64___9 = 127,
    _SC_XBS5_LPBIG_OFFBIG___9 = 128,
    _SC_XOPEN_LEGACY___9 = 129,
    _SC_XOPEN_REALTIME___9 = 130,
    _SC_XOPEN_REALTIME_THREADS___9 = 131,
    _SC_ADVISORY_INFO___9 = 132,
    _SC_BARRIERS___9 = 133,
    _SC_BASE___9 = 134,
    _SC_C_LANG_SUPPORT___9 = 135,
    _SC_C_LANG_SUPPORT_R___9 = 136,
    _SC_CLOCK_SELECTION___9 = 137,
    _SC_CPUTIME___9 = 138,
    _SC_THREAD_CPUTIME___9 = 139,
    _SC_DEVICE_IO___9 = 140,
    _SC_DEVICE_SPECIFIC___9 = 141,
    _SC_DEVICE_SPECIFIC_R___9 = 142,
    _SC_FD_MGMT___9 = 143,
    _SC_FIFO___9 = 144,
    _SC_PIPE___9 = 145,
    _SC_FILE_ATTRIBUTES___9 = 146,
    _SC_FILE_LOCKING___9 = 147,
    _SC_FILE_SYSTEM___9 = 148,
    _SC_MONOTONIC_CLOCK___9 = 149,
    _SC_MULTI_PROCESS___9 = 150,
    _SC_SINGLE_PROCESS___9 = 151,
    _SC_NETWORKING___9 = 152,
    _SC_READER_WRITER_LOCKS___9 = 153,
    _SC_SPIN_LOCKS___9 = 154,
    _SC_REGEXP___9 = 155,
    _SC_REGEX_VERSION___9 = 156,
    _SC_SHELL___9 = 157,
    _SC_SIGNALS___9 = 158,
    _SC_SPAWN___9 = 159,
    _SC_SPORADIC_SERVER___9 = 160,
    _SC_THREAD_SPORADIC_SERVER___9 = 161,
    _SC_SYSTEM_DATABASE___9 = 162,
    _SC_SYSTEM_DATABASE_R___9 = 163,
    _SC_TIMEOUTS___9 = 164,
    _SC_TYPED_MEMORY_OBJECTS___9 = 165,
    _SC_USER_GROUPS___9 = 166,
    _SC_USER_GROUPS_R___9 = 167,
    _SC_2_PBS___9 = 168,
    _SC_2_PBS_ACCOUNTING___9 = 169,
    _SC_2_PBS_LOCATE___9 = 170,
    _SC_2_PBS_MESSAGE___9 = 171,
    _SC_2_PBS_TRACK___9 = 172,
    _SC_SYMLOOP_MAX___9 = 173,
    _SC_STREAMS___9 = 174,
    _SC_2_PBS_CHECKPOINT___9 = 175,
    _SC_V6_ILP32_OFF32___9 = 176,
    _SC_V6_ILP32_OFFBIG___9 = 177,
    _SC_V6_LP64_OFF64___9 = 178,
    _SC_V6_LPBIG_OFFBIG___9 = 179,
    _SC_HOST_NAME_MAX___9 = 180,
    _SC_TRACE___9 = 181,
    _SC_TRACE_EVENT_FILTER___9 = 182,
    _SC_TRACE_INHERIT___9 = 183,
    _SC_TRACE_LOG___9 = 184,
    _SC_LEVEL1_ICACHE_SIZE___9 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___9 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___9 = 187,
    _SC_LEVEL1_DCACHE_SIZE___9 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___9 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___9 = 190,
    _SC_LEVEL2_CACHE_SIZE___9 = 191,
    _SC_LEVEL2_CACHE_ASSOC___9 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___9 = 193,
    _SC_LEVEL3_CACHE_SIZE___9 = 194,
    _SC_LEVEL3_CACHE_ASSOC___9 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___9 = 196,
    _SC_LEVEL4_CACHE_SIZE___9 = 197,
    _SC_LEVEL4_CACHE_ASSOC___9 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___9 = 199,
    _SC_IPV6___9 = 235,
    _SC_RAW_SOCKETS___9 = 236,
    _SC_V7_ILP32_OFF32___9 = 237,
    _SC_V7_ILP32_OFFBIG___9 = 238,
    _SC_V7_LP64_OFF64___9 = 239,
    _SC_V7_LPBIG_OFFBIG___9 = 240,
    _SC_SS_REPL_MAX___9 = 241,
    _SC_TRACE_EVENT_NAME_MAX___9 = 242,
    _SC_TRACE_NAME_MAX___9 = 243,
    _SC_TRACE_SYS_MAX___9 = 244,
    _SC_TRACE_USER_EVENT_MAX___9 = 245,
    _SC_XOPEN_STREAMS___9 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___9 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___9 = 248
} ;
#line 533
enum __anonenum_875524036___9 {
    _CS_PATH___9 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___9 = 1,
    _CS_GNU_LIBC_VERSION___9 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___9 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___9 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___9 = 5,
    _CS_LFS_CFLAGS___9 = 1000,
    _CS_LFS_LDFLAGS___9 = 1001,
    _CS_LFS_LIBS___9 = 1002,
    _CS_LFS_LINTFLAGS___9 = 1003,
    _CS_LFS64_CFLAGS___9 = 1004,
    _CS_LFS64_LDFLAGS___9 = 1005,
    _CS_LFS64_LIBS___9 = 1006,
    _CS_LFS64_LINTFLAGS___9 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___9 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___9 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___9 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___9 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___9 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___9 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___9 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___9 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___9 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___9 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___9 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___9 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___9 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___9 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___9 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___9 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___9 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___9 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___9 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___9 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___9 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___9 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___9 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___9 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___9 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___9 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___9 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___9 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___9 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___9 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___9 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___9 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___9 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___9 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___9 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___9 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___9 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___9 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___9 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___9 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___9 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___9 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___9 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___9 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___9 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___9 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___9 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___9 = 1147,
    _CS_V6_ENV___9 = 1148,
    _CS_V7_ENV___9 = 1149
} ;
#line 853 "/usr/include/math.h"
enum __anonenum_1037408945___10 {
    FP_NAN___10 = 0,
    FP_INFINITE___10 = 1,
    FP_ZERO___10 = 2,
    FP_SUBNORMAL___10 = 3,
    FP_NORMAL___10 = 4
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum_437032235___10 {
    _PC_LINK_MAX___10 = 0,
    _PC_MAX_CANON___10 = 1,
    _PC_MAX_INPUT___10 = 2,
    _PC_NAME_MAX___10 = 3,
    _PC_PATH_MAX___10 = 4,
    _PC_PIPE_BUF___10 = 5,
    _PC_CHOWN_RESTRICTED___10 = 6,
    _PC_NO_TRUNC___10 = 7,
    _PC_VDISABLE___10 = 8,
    _PC_SYNC_IO___10 = 9,
    _PC_ASYNC_IO___10 = 10,
    _PC_PRIO_IO___10 = 11,
    _PC_SOCK_MAXBUF___10 = 12,
    _PC_FILESIZEBITS___10 = 13,
    _PC_REC_INCR_XFER_SIZE___10 = 14,
    _PC_REC_MAX_XFER_SIZE___10 = 15,
    _PC_REC_MIN_XFER_SIZE___10 = 16,
    _PC_REC_XFER_ALIGN___10 = 17,
    _PC_ALLOC_SIZE_MIN___10 = 18,
    _PC_SYMLINK_MAX___10 = 19,
    _PC_2_SYMLINKS___10 = 20
} ;
#line 71
enum __anonenum_315186338___10 {
    _SC_ARG_MAX___10 = 0,
    _SC_CHILD_MAX___10 = 1,
    _SC_CLK_TCK___10 = 2,
    _SC_NGROUPS_MAX___10 = 3,
    _SC_OPEN_MAX___10 = 4,
    _SC_STREAM_MAX___10 = 5,
    _SC_TZNAME_MAX___10 = 6,
    _SC_JOB_CONTROL___10 = 7,
    _SC_SAVED_IDS___10 = 8,
    _SC_REALTIME_SIGNALS___10 = 9,
    _SC_PRIORITY_SCHEDULING___10 = 10,
    _SC_TIMERS___10 = 11,
    _SC_ASYNCHRONOUS_IO___10 = 12,
    _SC_PRIORITIZED_IO___10 = 13,
    _SC_SYNCHRONIZED_IO___10 = 14,
    _SC_FSYNC___10 = 15,
    _SC_MAPPED_FILES___10 = 16,
    _SC_MEMLOCK___10 = 17,
    _SC_MEMLOCK_RANGE___10 = 18,
    _SC_MEMORY_PROTECTION___10 = 19,
    _SC_MESSAGE_PASSING___10 = 20,
    _SC_SEMAPHORES___10 = 21,
    _SC_SHARED_MEMORY_OBJECTS___10 = 22,
    _SC_AIO_LISTIO_MAX___10 = 23,
    _SC_AIO_MAX___10 = 24,
    _SC_AIO_PRIO_DELTA_MAX___10 = 25,
    _SC_DELAYTIMER_MAX___10 = 26,
    _SC_MQ_OPEN_MAX___10 = 27,
    _SC_MQ_PRIO_MAX___10 = 28,
    _SC_VERSION___10 = 29,
    _SC_PAGESIZE___10 = 30,
    _SC_RTSIG_MAX___10 = 31,
    _SC_SEM_NSEMS_MAX___10 = 32,
    _SC_SEM_VALUE_MAX___10 = 33,
    _SC_SIGQUEUE_MAX___10 = 34,
    _SC_TIMER_MAX___10 = 35,
    _SC_BC_BASE_MAX___10 = 36,
    _SC_BC_DIM_MAX___10 = 37,
    _SC_BC_SCALE_MAX___10 = 38,
    _SC_BC_STRING_MAX___10 = 39,
    _SC_COLL_WEIGHTS_MAX___10 = 40,
    _SC_EQUIV_CLASS_MAX___10 = 41,
    _SC_EXPR_NEST_MAX___10 = 42,
    _SC_LINE_MAX___10 = 43,
    _SC_RE_DUP_MAX___10 = 44,
    _SC_CHARCLASS_NAME_MAX___10 = 45,
    _SC_2_VERSION___10 = 46,
    _SC_2_C_BIND___10 = 47,
    _SC_2_C_DEV___10 = 48,
    _SC_2_FORT_DEV___10 = 49,
    _SC_2_FORT_RUN___10 = 50,
    _SC_2_SW_DEV___10 = 51,
    _SC_2_LOCALEDEF___10 = 52,
    _SC_PII___10 = 53,
    _SC_PII_XTI___10 = 54,
    _SC_PII_SOCKET___10 = 55,
    _SC_PII_INTERNET___10 = 56,
    _SC_PII_OSI___10 = 57,
    _SC_POLL___10 = 58,
    _SC_SELECT___10 = 59,
    _SC_UIO_MAXIOV___10 = 60,
    _SC_IOV_MAX___10 = 60,
    _SC_PII_INTERNET_STREAM___10 = 61,
    _SC_PII_INTERNET_DGRAM___10 = 62,
    _SC_PII_OSI_COTS___10 = 63,
    _SC_PII_OSI_CLTS___10 = 64,
    _SC_PII_OSI_M___10 = 65,
    _SC_T_IOV_MAX___10 = 66,
    _SC_THREADS___10 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___10 = 68,
    _SC_GETGR_R_SIZE_MAX___10 = 69,
    _SC_GETPW_R_SIZE_MAX___10 = 70,
    _SC_LOGIN_NAME_MAX___10 = 71,
    _SC_TTY_NAME_MAX___10 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___10 = 73,
    _SC_THREAD_KEYS_MAX___10 = 74,
    _SC_THREAD_STACK_MIN___10 = 75,
    _SC_THREAD_THREADS_MAX___10 = 76,
    _SC_THREAD_ATTR_STACKADDR___10 = 77,
    _SC_THREAD_ATTR_STACKSIZE___10 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___10 = 79,
    _SC_THREAD_PRIO_INHERIT___10 = 80,
    _SC_THREAD_PRIO_PROTECT___10 = 81,
    _SC_THREAD_PROCESS_SHARED___10 = 82,
    _SC_NPROCESSORS_CONF___10 = 83,
    _SC_NPROCESSORS_ONLN___10 = 84,
    _SC_PHYS_PAGES___10 = 85,
    _SC_AVPHYS_PAGES___10 = 86,
    _SC_ATEXIT_MAX___10 = 87,
    _SC_PASS_MAX___10 = 88,
    _SC_XOPEN_VERSION___10 = 89,
    _SC_XOPEN_XCU_VERSION___10 = 90,
    _SC_XOPEN_UNIX___10 = 91,
    _SC_XOPEN_CRYPT___10 = 92,
    _SC_XOPEN_ENH_I18N___10 = 93,
    _SC_XOPEN_SHM___10 = 94,
    _SC_2_CHAR_TERM___10 = 95,
    _SC_2_C_VERSION___10 = 96,
    _SC_2_UPE___10 = 97,
    _SC_XOPEN_XPG2___10 = 98,
    _SC_XOPEN_XPG3___10 = 99,
    _SC_XOPEN_XPG4___10 = 100,
    _SC_CHAR_BIT___10 = 101,
    _SC_CHAR_MAX___10 = 102,
    _SC_CHAR_MIN___10 = 103,
    _SC_INT_MAX___10 = 104,
    _SC_INT_MIN___10 = 105,
    _SC_LONG_BIT___10 = 106,
    _SC_WORD_BIT___10 = 107,
    _SC_MB_LEN_MAX___10 = 108,
    _SC_NZERO___10 = 109,
    _SC_SSIZE_MAX___10 = 110,
    _SC_SCHAR_MAX___10 = 111,
    _SC_SCHAR_MIN___10 = 112,
    _SC_SHRT_MAX___10 = 113,
    _SC_SHRT_MIN___10 = 114,
    _SC_UCHAR_MAX___10 = 115,
    _SC_UINT_MAX___10 = 116,
    _SC_ULONG_MAX___10 = 117,
    _SC_USHRT_MAX___10 = 118,
    _SC_NL_ARGMAX___10 = 119,
    _SC_NL_LANGMAX___10 = 120,
    _SC_NL_MSGMAX___10 = 121,
    _SC_NL_NMAX___10 = 122,
    _SC_NL_SETMAX___10 = 123,
    _SC_NL_TEXTMAX___10 = 124,
    _SC_XBS5_ILP32_OFF32___10 = 125,
    _SC_XBS5_ILP32_OFFBIG___10 = 126,
    _SC_XBS5_LP64_OFF64___10 = 127,
    _SC_XBS5_LPBIG_OFFBIG___10 = 128,
    _SC_XOPEN_LEGACY___10 = 129,
    _SC_XOPEN_REALTIME___10 = 130,
    _SC_XOPEN_REALTIME_THREADS___10 = 131,
    _SC_ADVISORY_INFO___10 = 132,
    _SC_BARRIERS___10 = 133,
    _SC_BASE___10 = 134,
    _SC_C_LANG_SUPPORT___10 = 135,
    _SC_C_LANG_SUPPORT_R___10 = 136,
    _SC_CLOCK_SELECTION___10 = 137,
    _SC_CPUTIME___10 = 138,
    _SC_THREAD_CPUTIME___10 = 139,
    _SC_DEVICE_IO___10 = 140,
    _SC_DEVICE_SPECIFIC___10 = 141,
    _SC_DEVICE_SPECIFIC_R___10 = 142,
    _SC_FD_MGMT___10 = 143,
    _SC_FIFO___10 = 144,
    _SC_PIPE___10 = 145,
    _SC_FILE_ATTRIBUTES___10 = 146,
    _SC_FILE_LOCKING___10 = 147,
    _SC_FILE_SYSTEM___10 = 148,
    _SC_MONOTONIC_CLOCK___10 = 149,
    _SC_MULTI_PROCESS___10 = 150,
    _SC_SINGLE_PROCESS___10 = 151,
    _SC_NETWORKING___10 = 152,
    _SC_READER_WRITER_LOCKS___10 = 153,
    _SC_SPIN_LOCKS___10 = 154,
    _SC_REGEXP___10 = 155,
    _SC_REGEX_VERSION___10 = 156,
    _SC_SHELL___10 = 157,
    _SC_SIGNALS___10 = 158,
    _SC_SPAWN___10 = 159,
    _SC_SPORADIC_SERVER___10 = 160,
    _SC_THREAD_SPORADIC_SERVER___10 = 161,
    _SC_SYSTEM_DATABASE___10 = 162,
    _SC_SYSTEM_DATABASE_R___10 = 163,
    _SC_TIMEOUTS___10 = 164,
    _SC_TYPED_MEMORY_OBJECTS___10 = 165,
    _SC_USER_GROUPS___10 = 166,
    _SC_USER_GROUPS_R___10 = 167,
    _SC_2_PBS___10 = 168,
    _SC_2_PBS_ACCOUNTING___10 = 169,
    _SC_2_PBS_LOCATE___10 = 170,
    _SC_2_PBS_MESSAGE___10 = 171,
    _SC_2_PBS_TRACK___10 = 172,
    _SC_SYMLOOP_MAX___10 = 173,
    _SC_STREAMS___10 = 174,
    _SC_2_PBS_CHECKPOINT___10 = 175,
    _SC_V6_ILP32_OFF32___10 = 176,
    _SC_V6_ILP32_OFFBIG___10 = 177,
    _SC_V6_LP64_OFF64___10 = 178,
    _SC_V6_LPBIG_OFFBIG___10 = 179,
    _SC_HOST_NAME_MAX___10 = 180,
    _SC_TRACE___10 = 181,
    _SC_TRACE_EVENT_FILTER___10 = 182,
    _SC_TRACE_INHERIT___10 = 183,
    _SC_TRACE_LOG___10 = 184,
    _SC_LEVEL1_ICACHE_SIZE___10 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___10 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___10 = 187,
    _SC_LEVEL1_DCACHE_SIZE___10 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___10 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___10 = 190,
    _SC_LEVEL2_CACHE_SIZE___10 = 191,
    _SC_LEVEL2_CACHE_ASSOC___10 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___10 = 193,
    _SC_LEVEL3_CACHE_SIZE___10 = 194,
    _SC_LEVEL3_CACHE_ASSOC___10 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___10 = 196,
    _SC_LEVEL4_CACHE_SIZE___10 = 197,
    _SC_LEVEL4_CACHE_ASSOC___10 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___10 = 199,
    _SC_IPV6___10 = 235,
    _SC_RAW_SOCKETS___10 = 236,
    _SC_V7_ILP32_OFF32___10 = 237,
    _SC_V7_ILP32_OFFBIG___10 = 238,
    _SC_V7_LP64_OFF64___10 = 239,
    _SC_V7_LPBIG_OFFBIG___10 = 240,
    _SC_SS_REPL_MAX___10 = 241,
    _SC_TRACE_EVENT_NAME_MAX___10 = 242,
    _SC_TRACE_NAME_MAX___10 = 243,
    _SC_TRACE_SYS_MAX___10 = 244,
    _SC_TRACE_USER_EVENT_MAX___10 = 245,
    _SC_XOPEN_STREAMS___10 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___10 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___10 = 248
} ;
#line 533
enum __anonenum_875524036___10 {
    _CS_PATH___10 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___10 = 1,
    _CS_GNU_LIBC_VERSION___10 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___10 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___10 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___10 = 5,
    _CS_LFS_CFLAGS___10 = 1000,
    _CS_LFS_LDFLAGS___10 = 1001,
    _CS_LFS_LIBS___10 = 1002,
    _CS_LFS_LINTFLAGS___10 = 1003,
    _CS_LFS64_CFLAGS___10 = 1004,
    _CS_LFS64_LDFLAGS___10 = 1005,
    _CS_LFS64_LIBS___10 = 1006,
    _CS_LFS64_LINTFLAGS___10 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___10 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___10 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___10 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___10 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___10 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___10 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___10 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___10 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___10 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___10 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___10 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___10 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___10 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___10 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___10 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___10 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___10 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___10 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___10 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___10 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___10 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___10 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___10 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___10 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___10 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___10 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___10 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___10 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___10 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___10 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___10 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___10 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___10 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___10 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___10 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___10 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___10 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___10 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___10 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___10 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___10 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___10 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___10 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___10 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___10 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___10 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___10 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___10 = 1147,
    _CS_V6_ENV___10 = 1148,
    _CS_V7_ENV___10 = 1149
} ;
#line 853 "/usr/include/math.h"
enum __anonenum_1037408945___11 {
    FP_NAN___11 = 0,
    FP_INFINITE___11 = 1,
    FP_ZERO___11 = 2,
    FP_SUBNORMAL___11 = 3,
    FP_NORMAL___11 = 4
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum_437032235___11 {
    _PC_LINK_MAX___11 = 0,
    _PC_MAX_CANON___11 = 1,
    _PC_MAX_INPUT___11 = 2,
    _PC_NAME_MAX___11 = 3,
    _PC_PATH_MAX___11 = 4,
    _PC_PIPE_BUF___11 = 5,
    _PC_CHOWN_RESTRICTED___11 = 6,
    _PC_NO_TRUNC___11 = 7,
    _PC_VDISABLE___11 = 8,
    _PC_SYNC_IO___11 = 9,
    _PC_ASYNC_IO___11 = 10,
    _PC_PRIO_IO___11 = 11,
    _PC_SOCK_MAXBUF___11 = 12,
    _PC_FILESIZEBITS___11 = 13,
    _PC_REC_INCR_XFER_SIZE___11 = 14,
    _PC_REC_MAX_XFER_SIZE___11 = 15,
    _PC_REC_MIN_XFER_SIZE___11 = 16,
    _PC_REC_XFER_ALIGN___11 = 17,
    _PC_ALLOC_SIZE_MIN___11 = 18,
    _PC_SYMLINK_MAX___11 = 19,
    _PC_2_SYMLINKS___11 = 20
} ;
#line 71
enum __anonenum_315186338___11 {
    _SC_ARG_MAX___11 = 0,
    _SC_CHILD_MAX___11 = 1,
    _SC_CLK_TCK___11 = 2,
    _SC_NGROUPS_MAX___11 = 3,
    _SC_OPEN_MAX___11 = 4,
    _SC_STREAM_MAX___11 = 5,
    _SC_TZNAME_MAX___11 = 6,
    _SC_JOB_CONTROL___11 = 7,
    _SC_SAVED_IDS___11 = 8,
    _SC_REALTIME_SIGNALS___11 = 9,
    _SC_PRIORITY_SCHEDULING___11 = 10,
    _SC_TIMERS___11 = 11,
    _SC_ASYNCHRONOUS_IO___11 = 12,
    _SC_PRIORITIZED_IO___11 = 13,
    _SC_SYNCHRONIZED_IO___11 = 14,
    _SC_FSYNC___11 = 15,
    _SC_MAPPED_FILES___11 = 16,
    _SC_MEMLOCK___11 = 17,
    _SC_MEMLOCK_RANGE___11 = 18,
    _SC_MEMORY_PROTECTION___11 = 19,
    _SC_MESSAGE_PASSING___11 = 20,
    _SC_SEMAPHORES___11 = 21,
    _SC_SHARED_MEMORY_OBJECTS___11 = 22,
    _SC_AIO_LISTIO_MAX___11 = 23,
    _SC_AIO_MAX___11 = 24,
    _SC_AIO_PRIO_DELTA_MAX___11 = 25,
    _SC_DELAYTIMER_MAX___11 = 26,
    _SC_MQ_OPEN_MAX___11 = 27,
    _SC_MQ_PRIO_MAX___11 = 28,
    _SC_VERSION___11 = 29,
    _SC_PAGESIZE___11 = 30,
    _SC_RTSIG_MAX___11 = 31,
    _SC_SEM_NSEMS_MAX___11 = 32,
    _SC_SEM_VALUE_MAX___11 = 33,
    _SC_SIGQUEUE_MAX___11 = 34,
    _SC_TIMER_MAX___11 = 35,
    _SC_BC_BASE_MAX___11 = 36,
    _SC_BC_DIM_MAX___11 = 37,
    _SC_BC_SCALE_MAX___11 = 38,
    _SC_BC_STRING_MAX___11 = 39,
    _SC_COLL_WEIGHTS_MAX___11 = 40,
    _SC_EQUIV_CLASS_MAX___11 = 41,
    _SC_EXPR_NEST_MAX___11 = 42,
    _SC_LINE_MAX___11 = 43,
    _SC_RE_DUP_MAX___11 = 44,
    _SC_CHARCLASS_NAME_MAX___11 = 45,
    _SC_2_VERSION___11 = 46,
    _SC_2_C_BIND___11 = 47,
    _SC_2_C_DEV___11 = 48,
    _SC_2_FORT_DEV___11 = 49,
    _SC_2_FORT_RUN___11 = 50,
    _SC_2_SW_DEV___11 = 51,
    _SC_2_LOCALEDEF___11 = 52,
    _SC_PII___11 = 53,
    _SC_PII_XTI___11 = 54,
    _SC_PII_SOCKET___11 = 55,
    _SC_PII_INTERNET___11 = 56,
    _SC_PII_OSI___11 = 57,
    _SC_POLL___11 = 58,
    _SC_SELECT___11 = 59,
    _SC_UIO_MAXIOV___11 = 60,
    _SC_IOV_MAX___11 = 60,
    _SC_PII_INTERNET_STREAM___11 = 61,
    _SC_PII_INTERNET_DGRAM___11 = 62,
    _SC_PII_OSI_COTS___11 = 63,
    _SC_PII_OSI_CLTS___11 = 64,
    _SC_PII_OSI_M___11 = 65,
    _SC_T_IOV_MAX___11 = 66,
    _SC_THREADS___11 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___11 = 68,
    _SC_GETGR_R_SIZE_MAX___11 = 69,
    _SC_GETPW_R_SIZE_MAX___11 = 70,
    _SC_LOGIN_NAME_MAX___11 = 71,
    _SC_TTY_NAME_MAX___11 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___11 = 73,
    _SC_THREAD_KEYS_MAX___11 = 74,
    _SC_THREAD_STACK_MIN___11 = 75,
    _SC_THREAD_THREADS_MAX___11 = 76,
    _SC_THREAD_ATTR_STACKADDR___11 = 77,
    _SC_THREAD_ATTR_STACKSIZE___11 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___11 = 79,
    _SC_THREAD_PRIO_INHERIT___11 = 80,
    _SC_THREAD_PRIO_PROTECT___11 = 81,
    _SC_THREAD_PROCESS_SHARED___11 = 82,
    _SC_NPROCESSORS_CONF___11 = 83,
    _SC_NPROCESSORS_ONLN___11 = 84,
    _SC_PHYS_PAGES___11 = 85,
    _SC_AVPHYS_PAGES___11 = 86,
    _SC_ATEXIT_MAX___11 = 87,
    _SC_PASS_MAX___11 = 88,
    _SC_XOPEN_VERSION___11 = 89,
    _SC_XOPEN_XCU_VERSION___11 = 90,
    _SC_XOPEN_UNIX___11 = 91,
    _SC_XOPEN_CRYPT___11 = 92,
    _SC_XOPEN_ENH_I18N___11 = 93,
    _SC_XOPEN_SHM___11 = 94,
    _SC_2_CHAR_TERM___11 = 95,
    _SC_2_C_VERSION___11 = 96,
    _SC_2_UPE___11 = 97,
    _SC_XOPEN_XPG2___11 = 98,
    _SC_XOPEN_XPG3___11 = 99,
    _SC_XOPEN_XPG4___11 = 100,
    _SC_CHAR_BIT___11 = 101,
    _SC_CHAR_MAX___11 = 102,
    _SC_CHAR_MIN___11 = 103,
    _SC_INT_MAX___11 = 104,
    _SC_INT_MIN___11 = 105,
    _SC_LONG_BIT___11 = 106,
    _SC_WORD_BIT___11 = 107,
    _SC_MB_LEN_MAX___11 = 108,
    _SC_NZERO___11 = 109,
    _SC_SSIZE_MAX___11 = 110,
    _SC_SCHAR_MAX___11 = 111,
    _SC_SCHAR_MIN___11 = 112,
    _SC_SHRT_MAX___11 = 113,
    _SC_SHRT_MIN___11 = 114,
    _SC_UCHAR_MAX___11 = 115,
    _SC_UINT_MAX___11 = 116,
    _SC_ULONG_MAX___11 = 117,
    _SC_USHRT_MAX___11 = 118,
    _SC_NL_ARGMAX___11 = 119,
    _SC_NL_LANGMAX___11 = 120,
    _SC_NL_MSGMAX___11 = 121,
    _SC_NL_NMAX___11 = 122,
    _SC_NL_SETMAX___11 = 123,
    _SC_NL_TEXTMAX___11 = 124,
    _SC_XBS5_ILP32_OFF32___11 = 125,
    _SC_XBS5_ILP32_OFFBIG___11 = 126,
    _SC_XBS5_LP64_OFF64___11 = 127,
    _SC_XBS5_LPBIG_OFFBIG___11 = 128,
    _SC_XOPEN_LEGACY___11 = 129,
    _SC_XOPEN_REALTIME___11 = 130,
    _SC_XOPEN_REALTIME_THREADS___11 = 131,
    _SC_ADVISORY_INFO___11 = 132,
    _SC_BARRIERS___11 = 133,
    _SC_BASE___11 = 134,
    _SC_C_LANG_SUPPORT___11 = 135,
    _SC_C_LANG_SUPPORT_R___11 = 136,
    _SC_CLOCK_SELECTION___11 = 137,
    _SC_CPUTIME___11 = 138,
    _SC_THREAD_CPUTIME___11 = 139,
    _SC_DEVICE_IO___11 = 140,
    _SC_DEVICE_SPECIFIC___11 = 141,
    _SC_DEVICE_SPECIFIC_R___11 = 142,
    _SC_FD_MGMT___11 = 143,
    _SC_FIFO___11 = 144,
    _SC_PIPE___11 = 145,
    _SC_FILE_ATTRIBUTES___11 = 146,
    _SC_FILE_LOCKING___11 = 147,
    _SC_FILE_SYSTEM___11 = 148,
    _SC_MONOTONIC_CLOCK___11 = 149,
    _SC_MULTI_PROCESS___11 = 150,
    _SC_SINGLE_PROCESS___11 = 151,
    _SC_NETWORKING___11 = 152,
    _SC_READER_WRITER_LOCKS___11 = 153,
    _SC_SPIN_LOCKS___11 = 154,
    _SC_REGEXP___11 = 155,
    _SC_REGEX_VERSION___11 = 156,
    _SC_SHELL___11 = 157,
    _SC_SIGNALS___11 = 158,
    _SC_SPAWN___11 = 159,
    _SC_SPORADIC_SERVER___11 = 160,
    _SC_THREAD_SPORADIC_SERVER___11 = 161,
    _SC_SYSTEM_DATABASE___11 = 162,
    _SC_SYSTEM_DATABASE_R___11 = 163,
    _SC_TIMEOUTS___11 = 164,
    _SC_TYPED_MEMORY_OBJECTS___11 = 165,
    _SC_USER_GROUPS___11 = 166,
    _SC_USER_GROUPS_R___11 = 167,
    _SC_2_PBS___11 = 168,
    _SC_2_PBS_ACCOUNTING___11 = 169,
    _SC_2_PBS_LOCATE___11 = 170,
    _SC_2_PBS_MESSAGE___11 = 171,
    _SC_2_PBS_TRACK___11 = 172,
    _SC_SYMLOOP_MAX___11 = 173,
    _SC_STREAMS___11 = 174,
    _SC_2_PBS_CHECKPOINT___11 = 175,
    _SC_V6_ILP32_OFF32___11 = 176,
    _SC_V6_ILP32_OFFBIG___11 = 177,
    _SC_V6_LP64_OFF64___11 = 178,
    _SC_V6_LPBIG_OFFBIG___11 = 179,
    _SC_HOST_NAME_MAX___11 = 180,
    _SC_TRACE___11 = 181,
    _SC_TRACE_EVENT_FILTER___11 = 182,
    _SC_TRACE_INHERIT___11 = 183,
    _SC_TRACE_LOG___11 = 184,
    _SC_LEVEL1_ICACHE_SIZE___11 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___11 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___11 = 187,
    _SC_LEVEL1_DCACHE_SIZE___11 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___11 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___11 = 190,
    _SC_LEVEL2_CACHE_SIZE___11 = 191,
    _SC_LEVEL2_CACHE_ASSOC___11 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___11 = 193,
    _SC_LEVEL3_CACHE_SIZE___11 = 194,
    _SC_LEVEL3_CACHE_ASSOC___11 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___11 = 196,
    _SC_LEVEL4_CACHE_SIZE___11 = 197,
    _SC_LEVEL4_CACHE_ASSOC___11 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___11 = 199,
    _SC_IPV6___11 = 235,
    _SC_RAW_SOCKETS___11 = 236,
    _SC_V7_ILP32_OFF32___11 = 237,
    _SC_V7_ILP32_OFFBIG___11 = 238,
    _SC_V7_LP64_OFF64___11 = 239,
    _SC_V7_LPBIG_OFFBIG___11 = 240,
    _SC_SS_REPL_MAX___11 = 241,
    _SC_TRACE_EVENT_NAME_MAX___11 = 242,
    _SC_TRACE_NAME_MAX___11 = 243,
    _SC_TRACE_SYS_MAX___11 = 244,
    _SC_TRACE_USER_EVENT_MAX___11 = 245,
    _SC_XOPEN_STREAMS___11 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___11 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___11 = 248
} ;
#line 533
enum __anonenum_875524036___11 {
    _CS_PATH___11 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___11 = 1,
    _CS_GNU_LIBC_VERSION___11 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___11 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___11 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___11 = 5,
    _CS_LFS_CFLAGS___11 = 1000,
    _CS_LFS_LDFLAGS___11 = 1001,
    _CS_LFS_LIBS___11 = 1002,
    _CS_LFS_LINTFLAGS___11 = 1003,
    _CS_LFS64_CFLAGS___11 = 1004,
    _CS_LFS64_LDFLAGS___11 = 1005,
    _CS_LFS64_LIBS___11 = 1006,
    _CS_LFS64_LINTFLAGS___11 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___11 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___11 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___11 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___11 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___11 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___11 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___11 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___11 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___11 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___11 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___11 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___11 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___11 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___11 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___11 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___11 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___11 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___11 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___11 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___11 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___11 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___11 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___11 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___11 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___11 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___11 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___11 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___11 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___11 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___11 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___11 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___11 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___11 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___11 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___11 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___11 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___11 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___11 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___11 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___11 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___11 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___11 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___11 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___11 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___11 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___11 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___11 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___11 = 1147,
    _CS_V6_ENV___11 = 1148,
    _CS_V7_ENV___11 = 1149
} ;
#line 1515 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
struct __anonstruct_png_image_write_control_855354051 {
   png_imagep image ;
   png_const_voidp buffer ;
   png_int_32 row_stride ;
   png_const_voidp colormap ;
   int convert_to_8bit ;
   png_const_voidp first_row ;
   ptrdiff_t row_bytes ;
   png_voidp local_row ;
   png_bytep memory ;
   png_alloc_size_t memory_bytes ;
   png_alloc_size_t output_bytes ;
};
#line 1515 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
typedef struct __anonstruct_png_image_write_control_855354051 png_image_write_control;
#line 853 "/usr/include/math.h"
enum __anonenum_1037408945___12 {
    FP_NAN___12 = 0,
    FP_INFINITE___12 = 1,
    FP_ZERO___12 = 2,
    FP_SUBNORMAL___12 = 3,
    FP_NORMAL___12 = 4
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum_437032235___12 {
    _PC_LINK_MAX___12 = 0,
    _PC_MAX_CANON___12 = 1,
    _PC_MAX_INPUT___12 = 2,
    _PC_NAME_MAX___12 = 3,
    _PC_PATH_MAX___12 = 4,
    _PC_PIPE_BUF___12 = 5,
    _PC_CHOWN_RESTRICTED___12 = 6,
    _PC_NO_TRUNC___12 = 7,
    _PC_VDISABLE___12 = 8,
    _PC_SYNC_IO___12 = 9,
    _PC_ASYNC_IO___12 = 10,
    _PC_PRIO_IO___12 = 11,
    _PC_SOCK_MAXBUF___12 = 12,
    _PC_FILESIZEBITS___12 = 13,
    _PC_REC_INCR_XFER_SIZE___12 = 14,
    _PC_REC_MAX_XFER_SIZE___12 = 15,
    _PC_REC_MIN_XFER_SIZE___12 = 16,
    _PC_REC_XFER_ALIGN___12 = 17,
    _PC_ALLOC_SIZE_MIN___12 = 18,
    _PC_SYMLINK_MAX___12 = 19,
    _PC_2_SYMLINKS___12 = 20
} ;
#line 71
enum __anonenum_315186338___12 {
    _SC_ARG_MAX___12 = 0,
    _SC_CHILD_MAX___12 = 1,
    _SC_CLK_TCK___12 = 2,
    _SC_NGROUPS_MAX___12 = 3,
    _SC_OPEN_MAX___12 = 4,
    _SC_STREAM_MAX___12 = 5,
    _SC_TZNAME_MAX___12 = 6,
    _SC_JOB_CONTROL___12 = 7,
    _SC_SAVED_IDS___12 = 8,
    _SC_REALTIME_SIGNALS___12 = 9,
    _SC_PRIORITY_SCHEDULING___12 = 10,
    _SC_TIMERS___12 = 11,
    _SC_ASYNCHRONOUS_IO___12 = 12,
    _SC_PRIORITIZED_IO___12 = 13,
    _SC_SYNCHRONIZED_IO___12 = 14,
    _SC_FSYNC___12 = 15,
    _SC_MAPPED_FILES___12 = 16,
    _SC_MEMLOCK___12 = 17,
    _SC_MEMLOCK_RANGE___12 = 18,
    _SC_MEMORY_PROTECTION___12 = 19,
    _SC_MESSAGE_PASSING___12 = 20,
    _SC_SEMAPHORES___12 = 21,
    _SC_SHARED_MEMORY_OBJECTS___12 = 22,
    _SC_AIO_LISTIO_MAX___12 = 23,
    _SC_AIO_MAX___12 = 24,
    _SC_AIO_PRIO_DELTA_MAX___12 = 25,
    _SC_DELAYTIMER_MAX___12 = 26,
    _SC_MQ_OPEN_MAX___12 = 27,
    _SC_MQ_PRIO_MAX___12 = 28,
    _SC_VERSION___12 = 29,
    _SC_PAGESIZE___12 = 30,
    _SC_RTSIG_MAX___12 = 31,
    _SC_SEM_NSEMS_MAX___12 = 32,
    _SC_SEM_VALUE_MAX___12 = 33,
    _SC_SIGQUEUE_MAX___12 = 34,
    _SC_TIMER_MAX___12 = 35,
    _SC_BC_BASE_MAX___12 = 36,
    _SC_BC_DIM_MAX___12 = 37,
    _SC_BC_SCALE_MAX___12 = 38,
    _SC_BC_STRING_MAX___12 = 39,
    _SC_COLL_WEIGHTS_MAX___12 = 40,
    _SC_EQUIV_CLASS_MAX___12 = 41,
    _SC_EXPR_NEST_MAX___12 = 42,
    _SC_LINE_MAX___12 = 43,
    _SC_RE_DUP_MAX___12 = 44,
    _SC_CHARCLASS_NAME_MAX___12 = 45,
    _SC_2_VERSION___12 = 46,
    _SC_2_C_BIND___12 = 47,
    _SC_2_C_DEV___12 = 48,
    _SC_2_FORT_DEV___12 = 49,
    _SC_2_FORT_RUN___12 = 50,
    _SC_2_SW_DEV___12 = 51,
    _SC_2_LOCALEDEF___12 = 52,
    _SC_PII___12 = 53,
    _SC_PII_XTI___12 = 54,
    _SC_PII_SOCKET___12 = 55,
    _SC_PII_INTERNET___12 = 56,
    _SC_PII_OSI___12 = 57,
    _SC_POLL___12 = 58,
    _SC_SELECT___12 = 59,
    _SC_UIO_MAXIOV___12 = 60,
    _SC_IOV_MAX___12 = 60,
    _SC_PII_INTERNET_STREAM___12 = 61,
    _SC_PII_INTERNET_DGRAM___12 = 62,
    _SC_PII_OSI_COTS___12 = 63,
    _SC_PII_OSI_CLTS___12 = 64,
    _SC_PII_OSI_M___12 = 65,
    _SC_T_IOV_MAX___12 = 66,
    _SC_THREADS___12 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___12 = 68,
    _SC_GETGR_R_SIZE_MAX___12 = 69,
    _SC_GETPW_R_SIZE_MAX___12 = 70,
    _SC_LOGIN_NAME_MAX___12 = 71,
    _SC_TTY_NAME_MAX___12 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___12 = 73,
    _SC_THREAD_KEYS_MAX___12 = 74,
    _SC_THREAD_STACK_MIN___12 = 75,
    _SC_THREAD_THREADS_MAX___12 = 76,
    _SC_THREAD_ATTR_STACKADDR___12 = 77,
    _SC_THREAD_ATTR_STACKSIZE___12 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___12 = 79,
    _SC_THREAD_PRIO_INHERIT___12 = 80,
    _SC_THREAD_PRIO_PROTECT___12 = 81,
    _SC_THREAD_PROCESS_SHARED___12 = 82,
    _SC_NPROCESSORS_CONF___12 = 83,
    _SC_NPROCESSORS_ONLN___12 = 84,
    _SC_PHYS_PAGES___12 = 85,
    _SC_AVPHYS_PAGES___12 = 86,
    _SC_ATEXIT_MAX___12 = 87,
    _SC_PASS_MAX___12 = 88,
    _SC_XOPEN_VERSION___12 = 89,
    _SC_XOPEN_XCU_VERSION___12 = 90,
    _SC_XOPEN_UNIX___12 = 91,
    _SC_XOPEN_CRYPT___12 = 92,
    _SC_XOPEN_ENH_I18N___12 = 93,
    _SC_XOPEN_SHM___12 = 94,
    _SC_2_CHAR_TERM___12 = 95,
    _SC_2_C_VERSION___12 = 96,
    _SC_2_UPE___12 = 97,
    _SC_XOPEN_XPG2___12 = 98,
    _SC_XOPEN_XPG3___12 = 99,
    _SC_XOPEN_XPG4___12 = 100,
    _SC_CHAR_BIT___12 = 101,
    _SC_CHAR_MAX___12 = 102,
    _SC_CHAR_MIN___12 = 103,
    _SC_INT_MAX___12 = 104,
    _SC_INT_MIN___12 = 105,
    _SC_LONG_BIT___12 = 106,
    _SC_WORD_BIT___12 = 107,
    _SC_MB_LEN_MAX___12 = 108,
    _SC_NZERO___12 = 109,
    _SC_SSIZE_MAX___12 = 110,
    _SC_SCHAR_MAX___12 = 111,
    _SC_SCHAR_MIN___12 = 112,
    _SC_SHRT_MAX___12 = 113,
    _SC_SHRT_MIN___12 = 114,
    _SC_UCHAR_MAX___12 = 115,
    _SC_UINT_MAX___12 = 116,
    _SC_ULONG_MAX___12 = 117,
    _SC_USHRT_MAX___12 = 118,
    _SC_NL_ARGMAX___12 = 119,
    _SC_NL_LANGMAX___12 = 120,
    _SC_NL_MSGMAX___12 = 121,
    _SC_NL_NMAX___12 = 122,
    _SC_NL_SETMAX___12 = 123,
    _SC_NL_TEXTMAX___12 = 124,
    _SC_XBS5_ILP32_OFF32___12 = 125,
    _SC_XBS5_ILP32_OFFBIG___12 = 126,
    _SC_XBS5_LP64_OFF64___12 = 127,
    _SC_XBS5_LPBIG_OFFBIG___12 = 128,
    _SC_XOPEN_LEGACY___12 = 129,
    _SC_XOPEN_REALTIME___12 = 130,
    _SC_XOPEN_REALTIME_THREADS___12 = 131,
    _SC_ADVISORY_INFO___12 = 132,
    _SC_BARRIERS___12 = 133,
    _SC_BASE___12 = 134,
    _SC_C_LANG_SUPPORT___12 = 135,
    _SC_C_LANG_SUPPORT_R___12 = 136,
    _SC_CLOCK_SELECTION___12 = 137,
    _SC_CPUTIME___12 = 138,
    _SC_THREAD_CPUTIME___12 = 139,
    _SC_DEVICE_IO___12 = 140,
    _SC_DEVICE_SPECIFIC___12 = 141,
    _SC_DEVICE_SPECIFIC_R___12 = 142,
    _SC_FD_MGMT___12 = 143,
    _SC_FIFO___12 = 144,
    _SC_PIPE___12 = 145,
    _SC_FILE_ATTRIBUTES___12 = 146,
    _SC_FILE_LOCKING___12 = 147,
    _SC_FILE_SYSTEM___12 = 148,
    _SC_MONOTONIC_CLOCK___12 = 149,
    _SC_MULTI_PROCESS___12 = 150,
    _SC_SINGLE_PROCESS___12 = 151,
    _SC_NETWORKING___12 = 152,
    _SC_READER_WRITER_LOCKS___12 = 153,
    _SC_SPIN_LOCKS___12 = 154,
    _SC_REGEXP___12 = 155,
    _SC_REGEX_VERSION___12 = 156,
    _SC_SHELL___12 = 157,
    _SC_SIGNALS___12 = 158,
    _SC_SPAWN___12 = 159,
    _SC_SPORADIC_SERVER___12 = 160,
    _SC_THREAD_SPORADIC_SERVER___12 = 161,
    _SC_SYSTEM_DATABASE___12 = 162,
    _SC_SYSTEM_DATABASE_R___12 = 163,
    _SC_TIMEOUTS___12 = 164,
    _SC_TYPED_MEMORY_OBJECTS___12 = 165,
    _SC_USER_GROUPS___12 = 166,
    _SC_USER_GROUPS_R___12 = 167,
    _SC_2_PBS___12 = 168,
    _SC_2_PBS_ACCOUNTING___12 = 169,
    _SC_2_PBS_LOCATE___12 = 170,
    _SC_2_PBS_MESSAGE___12 = 171,
    _SC_2_PBS_TRACK___12 = 172,
    _SC_SYMLOOP_MAX___12 = 173,
    _SC_STREAMS___12 = 174,
    _SC_2_PBS_CHECKPOINT___12 = 175,
    _SC_V6_ILP32_OFF32___12 = 176,
    _SC_V6_ILP32_OFFBIG___12 = 177,
    _SC_V6_LP64_OFF64___12 = 178,
    _SC_V6_LPBIG_OFFBIG___12 = 179,
    _SC_HOST_NAME_MAX___12 = 180,
    _SC_TRACE___12 = 181,
    _SC_TRACE_EVENT_FILTER___12 = 182,
    _SC_TRACE_INHERIT___12 = 183,
    _SC_TRACE_LOG___12 = 184,
    _SC_LEVEL1_ICACHE_SIZE___12 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___12 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___12 = 187,
    _SC_LEVEL1_DCACHE_SIZE___12 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___12 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___12 = 190,
    _SC_LEVEL2_CACHE_SIZE___12 = 191,
    _SC_LEVEL2_CACHE_ASSOC___12 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___12 = 193,
    _SC_LEVEL3_CACHE_SIZE___12 = 194,
    _SC_LEVEL3_CACHE_ASSOC___12 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___12 = 196,
    _SC_LEVEL4_CACHE_SIZE___12 = 197,
    _SC_LEVEL4_CACHE_ASSOC___12 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___12 = 199,
    _SC_IPV6___12 = 235,
    _SC_RAW_SOCKETS___12 = 236,
    _SC_V7_ILP32_OFF32___12 = 237,
    _SC_V7_ILP32_OFFBIG___12 = 238,
    _SC_V7_LP64_OFF64___12 = 239,
    _SC_V7_LPBIG_OFFBIG___12 = 240,
    _SC_SS_REPL_MAX___12 = 241,
    _SC_TRACE_EVENT_NAME_MAX___12 = 242,
    _SC_TRACE_NAME_MAX___12 = 243,
    _SC_TRACE_SYS_MAX___12 = 244,
    _SC_TRACE_USER_EVENT_MAX___12 = 245,
    _SC_XOPEN_STREAMS___12 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___12 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___12 = 248
} ;
#line 533
enum __anonenum_875524036___12 {
    _CS_PATH___12 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___12 = 1,
    _CS_GNU_LIBC_VERSION___12 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___12 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___12 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___12 = 5,
    _CS_LFS_CFLAGS___12 = 1000,
    _CS_LFS_LDFLAGS___12 = 1001,
    _CS_LFS_LIBS___12 = 1002,
    _CS_LFS_LINTFLAGS___12 = 1003,
    _CS_LFS64_CFLAGS___12 = 1004,
    _CS_LFS64_LDFLAGS___12 = 1005,
    _CS_LFS64_LIBS___12 = 1006,
    _CS_LFS64_LINTFLAGS___12 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___12 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___12 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___12 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___12 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___12 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___12 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___12 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___12 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___12 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___12 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___12 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___12 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___12 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___12 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___12 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___12 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___12 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___12 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___12 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___12 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___12 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___12 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___12 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___12 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___12 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___12 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___12 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___12 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___12 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___12 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___12 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___12 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___12 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___12 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___12 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___12 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___12 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___12 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___12 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___12 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___12 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___12 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___12 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___12 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___12 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___12 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___12 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___12 = 1147,
    _CS_V6_ENV___12 = 1148,
    _CS_V7_ENV___12 = 1149
} ;
#line 853 "/usr/include/math.h"
enum __anonenum_1037408945___13 {
    FP_NAN___13 = 0,
    FP_INFINITE___13 = 1,
    FP_ZERO___13 = 2,
    FP_SUBNORMAL___13 = 3,
    FP_NORMAL___13 = 4
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum_437032235___13 {
    _PC_LINK_MAX___13 = 0,
    _PC_MAX_CANON___13 = 1,
    _PC_MAX_INPUT___13 = 2,
    _PC_NAME_MAX___13 = 3,
    _PC_PATH_MAX___13 = 4,
    _PC_PIPE_BUF___13 = 5,
    _PC_CHOWN_RESTRICTED___13 = 6,
    _PC_NO_TRUNC___13 = 7,
    _PC_VDISABLE___13 = 8,
    _PC_SYNC_IO___13 = 9,
    _PC_ASYNC_IO___13 = 10,
    _PC_PRIO_IO___13 = 11,
    _PC_SOCK_MAXBUF___13 = 12,
    _PC_FILESIZEBITS___13 = 13,
    _PC_REC_INCR_XFER_SIZE___13 = 14,
    _PC_REC_MAX_XFER_SIZE___13 = 15,
    _PC_REC_MIN_XFER_SIZE___13 = 16,
    _PC_REC_XFER_ALIGN___13 = 17,
    _PC_ALLOC_SIZE_MIN___13 = 18,
    _PC_SYMLINK_MAX___13 = 19,
    _PC_2_SYMLINKS___13 = 20
} ;
#line 71
enum __anonenum_315186338___13 {
    _SC_ARG_MAX___13 = 0,
    _SC_CHILD_MAX___13 = 1,
    _SC_CLK_TCK___13 = 2,
    _SC_NGROUPS_MAX___13 = 3,
    _SC_OPEN_MAX___13 = 4,
    _SC_STREAM_MAX___13 = 5,
    _SC_TZNAME_MAX___13 = 6,
    _SC_JOB_CONTROL___13 = 7,
    _SC_SAVED_IDS___13 = 8,
    _SC_REALTIME_SIGNALS___13 = 9,
    _SC_PRIORITY_SCHEDULING___13 = 10,
    _SC_TIMERS___13 = 11,
    _SC_ASYNCHRONOUS_IO___13 = 12,
    _SC_PRIORITIZED_IO___13 = 13,
    _SC_SYNCHRONIZED_IO___13 = 14,
    _SC_FSYNC___13 = 15,
    _SC_MAPPED_FILES___13 = 16,
    _SC_MEMLOCK___13 = 17,
    _SC_MEMLOCK_RANGE___13 = 18,
    _SC_MEMORY_PROTECTION___13 = 19,
    _SC_MESSAGE_PASSING___13 = 20,
    _SC_SEMAPHORES___13 = 21,
    _SC_SHARED_MEMORY_OBJECTS___13 = 22,
    _SC_AIO_LISTIO_MAX___13 = 23,
    _SC_AIO_MAX___13 = 24,
    _SC_AIO_PRIO_DELTA_MAX___13 = 25,
    _SC_DELAYTIMER_MAX___13 = 26,
    _SC_MQ_OPEN_MAX___13 = 27,
    _SC_MQ_PRIO_MAX___13 = 28,
    _SC_VERSION___13 = 29,
    _SC_PAGESIZE___13 = 30,
    _SC_RTSIG_MAX___13 = 31,
    _SC_SEM_NSEMS_MAX___13 = 32,
    _SC_SEM_VALUE_MAX___13 = 33,
    _SC_SIGQUEUE_MAX___13 = 34,
    _SC_TIMER_MAX___13 = 35,
    _SC_BC_BASE_MAX___13 = 36,
    _SC_BC_DIM_MAX___13 = 37,
    _SC_BC_SCALE_MAX___13 = 38,
    _SC_BC_STRING_MAX___13 = 39,
    _SC_COLL_WEIGHTS_MAX___13 = 40,
    _SC_EQUIV_CLASS_MAX___13 = 41,
    _SC_EXPR_NEST_MAX___13 = 42,
    _SC_LINE_MAX___13 = 43,
    _SC_RE_DUP_MAX___13 = 44,
    _SC_CHARCLASS_NAME_MAX___13 = 45,
    _SC_2_VERSION___13 = 46,
    _SC_2_C_BIND___13 = 47,
    _SC_2_C_DEV___13 = 48,
    _SC_2_FORT_DEV___13 = 49,
    _SC_2_FORT_RUN___13 = 50,
    _SC_2_SW_DEV___13 = 51,
    _SC_2_LOCALEDEF___13 = 52,
    _SC_PII___13 = 53,
    _SC_PII_XTI___13 = 54,
    _SC_PII_SOCKET___13 = 55,
    _SC_PII_INTERNET___13 = 56,
    _SC_PII_OSI___13 = 57,
    _SC_POLL___13 = 58,
    _SC_SELECT___13 = 59,
    _SC_UIO_MAXIOV___13 = 60,
    _SC_IOV_MAX___13 = 60,
    _SC_PII_INTERNET_STREAM___13 = 61,
    _SC_PII_INTERNET_DGRAM___13 = 62,
    _SC_PII_OSI_COTS___13 = 63,
    _SC_PII_OSI_CLTS___13 = 64,
    _SC_PII_OSI_M___13 = 65,
    _SC_T_IOV_MAX___13 = 66,
    _SC_THREADS___13 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___13 = 68,
    _SC_GETGR_R_SIZE_MAX___13 = 69,
    _SC_GETPW_R_SIZE_MAX___13 = 70,
    _SC_LOGIN_NAME_MAX___13 = 71,
    _SC_TTY_NAME_MAX___13 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___13 = 73,
    _SC_THREAD_KEYS_MAX___13 = 74,
    _SC_THREAD_STACK_MIN___13 = 75,
    _SC_THREAD_THREADS_MAX___13 = 76,
    _SC_THREAD_ATTR_STACKADDR___13 = 77,
    _SC_THREAD_ATTR_STACKSIZE___13 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___13 = 79,
    _SC_THREAD_PRIO_INHERIT___13 = 80,
    _SC_THREAD_PRIO_PROTECT___13 = 81,
    _SC_THREAD_PROCESS_SHARED___13 = 82,
    _SC_NPROCESSORS_CONF___13 = 83,
    _SC_NPROCESSORS_ONLN___13 = 84,
    _SC_PHYS_PAGES___13 = 85,
    _SC_AVPHYS_PAGES___13 = 86,
    _SC_ATEXIT_MAX___13 = 87,
    _SC_PASS_MAX___13 = 88,
    _SC_XOPEN_VERSION___13 = 89,
    _SC_XOPEN_XCU_VERSION___13 = 90,
    _SC_XOPEN_UNIX___13 = 91,
    _SC_XOPEN_CRYPT___13 = 92,
    _SC_XOPEN_ENH_I18N___13 = 93,
    _SC_XOPEN_SHM___13 = 94,
    _SC_2_CHAR_TERM___13 = 95,
    _SC_2_C_VERSION___13 = 96,
    _SC_2_UPE___13 = 97,
    _SC_XOPEN_XPG2___13 = 98,
    _SC_XOPEN_XPG3___13 = 99,
    _SC_XOPEN_XPG4___13 = 100,
    _SC_CHAR_BIT___13 = 101,
    _SC_CHAR_MAX___13 = 102,
    _SC_CHAR_MIN___13 = 103,
    _SC_INT_MAX___13 = 104,
    _SC_INT_MIN___13 = 105,
    _SC_LONG_BIT___13 = 106,
    _SC_WORD_BIT___13 = 107,
    _SC_MB_LEN_MAX___13 = 108,
    _SC_NZERO___13 = 109,
    _SC_SSIZE_MAX___13 = 110,
    _SC_SCHAR_MAX___13 = 111,
    _SC_SCHAR_MIN___13 = 112,
    _SC_SHRT_MAX___13 = 113,
    _SC_SHRT_MIN___13 = 114,
    _SC_UCHAR_MAX___13 = 115,
    _SC_UINT_MAX___13 = 116,
    _SC_ULONG_MAX___13 = 117,
    _SC_USHRT_MAX___13 = 118,
    _SC_NL_ARGMAX___13 = 119,
    _SC_NL_LANGMAX___13 = 120,
    _SC_NL_MSGMAX___13 = 121,
    _SC_NL_NMAX___13 = 122,
    _SC_NL_SETMAX___13 = 123,
    _SC_NL_TEXTMAX___13 = 124,
    _SC_XBS5_ILP32_OFF32___13 = 125,
    _SC_XBS5_ILP32_OFFBIG___13 = 126,
    _SC_XBS5_LP64_OFF64___13 = 127,
    _SC_XBS5_LPBIG_OFFBIG___13 = 128,
    _SC_XOPEN_LEGACY___13 = 129,
    _SC_XOPEN_REALTIME___13 = 130,
    _SC_XOPEN_REALTIME_THREADS___13 = 131,
    _SC_ADVISORY_INFO___13 = 132,
    _SC_BARRIERS___13 = 133,
    _SC_BASE___13 = 134,
    _SC_C_LANG_SUPPORT___13 = 135,
    _SC_C_LANG_SUPPORT_R___13 = 136,
    _SC_CLOCK_SELECTION___13 = 137,
    _SC_CPUTIME___13 = 138,
    _SC_THREAD_CPUTIME___13 = 139,
    _SC_DEVICE_IO___13 = 140,
    _SC_DEVICE_SPECIFIC___13 = 141,
    _SC_DEVICE_SPECIFIC_R___13 = 142,
    _SC_FD_MGMT___13 = 143,
    _SC_FIFO___13 = 144,
    _SC_PIPE___13 = 145,
    _SC_FILE_ATTRIBUTES___13 = 146,
    _SC_FILE_LOCKING___13 = 147,
    _SC_FILE_SYSTEM___13 = 148,
    _SC_MONOTONIC_CLOCK___13 = 149,
    _SC_MULTI_PROCESS___13 = 150,
    _SC_SINGLE_PROCESS___13 = 151,
    _SC_NETWORKING___13 = 152,
    _SC_READER_WRITER_LOCKS___13 = 153,
    _SC_SPIN_LOCKS___13 = 154,
    _SC_REGEXP___13 = 155,
    _SC_REGEX_VERSION___13 = 156,
    _SC_SHELL___13 = 157,
    _SC_SIGNALS___13 = 158,
    _SC_SPAWN___13 = 159,
    _SC_SPORADIC_SERVER___13 = 160,
    _SC_THREAD_SPORADIC_SERVER___13 = 161,
    _SC_SYSTEM_DATABASE___13 = 162,
    _SC_SYSTEM_DATABASE_R___13 = 163,
    _SC_TIMEOUTS___13 = 164,
    _SC_TYPED_MEMORY_OBJECTS___13 = 165,
    _SC_USER_GROUPS___13 = 166,
    _SC_USER_GROUPS_R___13 = 167,
    _SC_2_PBS___13 = 168,
    _SC_2_PBS_ACCOUNTING___13 = 169,
    _SC_2_PBS_LOCATE___13 = 170,
    _SC_2_PBS_MESSAGE___13 = 171,
    _SC_2_PBS_TRACK___13 = 172,
    _SC_SYMLOOP_MAX___13 = 173,
    _SC_STREAMS___13 = 174,
    _SC_2_PBS_CHECKPOINT___13 = 175,
    _SC_V6_ILP32_OFF32___13 = 176,
    _SC_V6_ILP32_OFFBIG___13 = 177,
    _SC_V6_LP64_OFF64___13 = 178,
    _SC_V6_LPBIG_OFFBIG___13 = 179,
    _SC_HOST_NAME_MAX___13 = 180,
    _SC_TRACE___13 = 181,
    _SC_TRACE_EVENT_FILTER___13 = 182,
    _SC_TRACE_INHERIT___13 = 183,
    _SC_TRACE_LOG___13 = 184,
    _SC_LEVEL1_ICACHE_SIZE___13 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___13 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___13 = 187,
    _SC_LEVEL1_DCACHE_SIZE___13 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___13 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___13 = 190,
    _SC_LEVEL2_CACHE_SIZE___13 = 191,
    _SC_LEVEL2_CACHE_ASSOC___13 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___13 = 193,
    _SC_LEVEL3_CACHE_SIZE___13 = 194,
    _SC_LEVEL3_CACHE_ASSOC___13 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___13 = 196,
    _SC_LEVEL4_CACHE_SIZE___13 = 197,
    _SC_LEVEL4_CACHE_ASSOC___13 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___13 = 199,
    _SC_IPV6___13 = 235,
    _SC_RAW_SOCKETS___13 = 236,
    _SC_V7_ILP32_OFF32___13 = 237,
    _SC_V7_ILP32_OFFBIG___13 = 238,
    _SC_V7_LP64_OFF64___13 = 239,
    _SC_V7_LPBIG_OFFBIG___13 = 240,
    _SC_SS_REPL_MAX___13 = 241,
    _SC_TRACE_EVENT_NAME_MAX___13 = 242,
    _SC_TRACE_NAME_MAX___13 = 243,
    _SC_TRACE_SYS_MAX___13 = 244,
    _SC_TRACE_USER_EVENT_MAX___13 = 245,
    _SC_XOPEN_STREAMS___13 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___13 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___13 = 248
} ;
#line 533
enum __anonenum_875524036___13 {
    _CS_PATH___13 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___13 = 1,
    _CS_GNU_LIBC_VERSION___13 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___13 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___13 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___13 = 5,
    _CS_LFS_CFLAGS___13 = 1000,
    _CS_LFS_LDFLAGS___13 = 1001,
    _CS_LFS_LIBS___13 = 1002,
    _CS_LFS_LINTFLAGS___13 = 1003,
    _CS_LFS64_CFLAGS___13 = 1004,
    _CS_LFS64_LDFLAGS___13 = 1005,
    _CS_LFS64_LIBS___13 = 1006,
    _CS_LFS64_LINTFLAGS___13 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___13 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___13 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___13 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___13 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___13 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___13 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___13 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___13 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___13 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___13 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___13 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___13 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___13 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___13 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___13 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___13 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___13 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___13 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___13 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___13 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___13 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___13 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___13 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___13 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___13 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___13 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___13 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___13 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___13 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___13 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___13 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___13 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___13 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___13 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___13 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___13 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___13 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___13 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___13 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___13 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___13 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___13 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___13 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___13 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___13 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___13 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___13 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___13 = 1147,
    _CS_V6_ENV___13 = 1148,
    _CS_V7_ENV___13 = 1149
} ;
#line 469 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
struct __anonstruct_compression_state_470411587 {
   png_const_bytep input ;
   png_alloc_size_t input_len ;
   png_uint_32 output_len ;
   png_byte output[1024] ;
};
#line 469 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
typedef struct __anonstruct_compression_state_470411587 compression_state;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum_437032235___14 {
    _PC_LINK_MAX___14 = 0,
    _PC_MAX_CANON___14 = 1,
    _PC_MAX_INPUT___14 = 2,
    _PC_NAME_MAX___14 = 3,
    _PC_PATH_MAX___14 = 4,
    _PC_PIPE_BUF___14 = 5,
    _PC_CHOWN_RESTRICTED___14 = 6,
    _PC_NO_TRUNC___14 = 7,
    _PC_VDISABLE___14 = 8,
    _PC_SYNC_IO___14 = 9,
    _PC_ASYNC_IO___14 = 10,
    _PC_PRIO_IO___14 = 11,
    _PC_SOCK_MAXBUF___14 = 12,
    _PC_FILESIZEBITS___14 = 13,
    _PC_REC_INCR_XFER_SIZE___14 = 14,
    _PC_REC_MAX_XFER_SIZE___14 = 15,
    _PC_REC_MIN_XFER_SIZE___14 = 16,
    _PC_REC_XFER_ALIGN___14 = 17,
    _PC_ALLOC_SIZE_MIN___14 = 18,
    _PC_SYMLINK_MAX___14 = 19,
    _PC_2_SYMLINKS___14 = 20
} ;
#line 71
enum __anonenum_315186338___14 {
    _SC_ARG_MAX___14 = 0,
    _SC_CHILD_MAX___14 = 1,
    _SC_CLK_TCK___14 = 2,
    _SC_NGROUPS_MAX___14 = 3,
    _SC_OPEN_MAX___14 = 4,
    _SC_STREAM_MAX___14 = 5,
    _SC_TZNAME_MAX___14 = 6,
    _SC_JOB_CONTROL___14 = 7,
    _SC_SAVED_IDS___14 = 8,
    _SC_REALTIME_SIGNALS___14 = 9,
    _SC_PRIORITY_SCHEDULING___14 = 10,
    _SC_TIMERS___14 = 11,
    _SC_ASYNCHRONOUS_IO___14 = 12,
    _SC_PRIORITIZED_IO___14 = 13,
    _SC_SYNCHRONIZED_IO___14 = 14,
    _SC_FSYNC___14 = 15,
    _SC_MAPPED_FILES___14 = 16,
    _SC_MEMLOCK___14 = 17,
    _SC_MEMLOCK_RANGE___14 = 18,
    _SC_MEMORY_PROTECTION___14 = 19,
    _SC_MESSAGE_PASSING___14 = 20,
    _SC_SEMAPHORES___14 = 21,
    _SC_SHARED_MEMORY_OBJECTS___14 = 22,
    _SC_AIO_LISTIO_MAX___14 = 23,
    _SC_AIO_MAX___14 = 24,
    _SC_AIO_PRIO_DELTA_MAX___14 = 25,
    _SC_DELAYTIMER_MAX___14 = 26,
    _SC_MQ_OPEN_MAX___14 = 27,
    _SC_MQ_PRIO_MAX___14 = 28,
    _SC_VERSION___14 = 29,
    _SC_PAGESIZE___14 = 30,
    _SC_RTSIG_MAX___14 = 31,
    _SC_SEM_NSEMS_MAX___14 = 32,
    _SC_SEM_VALUE_MAX___14 = 33,
    _SC_SIGQUEUE_MAX___14 = 34,
    _SC_TIMER_MAX___14 = 35,
    _SC_BC_BASE_MAX___14 = 36,
    _SC_BC_DIM_MAX___14 = 37,
    _SC_BC_SCALE_MAX___14 = 38,
    _SC_BC_STRING_MAX___14 = 39,
    _SC_COLL_WEIGHTS_MAX___14 = 40,
    _SC_EQUIV_CLASS_MAX___14 = 41,
    _SC_EXPR_NEST_MAX___14 = 42,
    _SC_LINE_MAX___14 = 43,
    _SC_RE_DUP_MAX___14 = 44,
    _SC_CHARCLASS_NAME_MAX___14 = 45,
    _SC_2_VERSION___14 = 46,
    _SC_2_C_BIND___14 = 47,
    _SC_2_C_DEV___14 = 48,
    _SC_2_FORT_DEV___14 = 49,
    _SC_2_FORT_RUN___14 = 50,
    _SC_2_SW_DEV___14 = 51,
    _SC_2_LOCALEDEF___14 = 52,
    _SC_PII___14 = 53,
    _SC_PII_XTI___14 = 54,
    _SC_PII_SOCKET___14 = 55,
    _SC_PII_INTERNET___14 = 56,
    _SC_PII_OSI___14 = 57,
    _SC_POLL___14 = 58,
    _SC_SELECT___14 = 59,
    _SC_UIO_MAXIOV___14 = 60,
    _SC_IOV_MAX___14 = 60,
    _SC_PII_INTERNET_STREAM___14 = 61,
    _SC_PII_INTERNET_DGRAM___14 = 62,
    _SC_PII_OSI_COTS___14 = 63,
    _SC_PII_OSI_CLTS___14 = 64,
    _SC_PII_OSI_M___14 = 65,
    _SC_T_IOV_MAX___14 = 66,
    _SC_THREADS___14 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___14 = 68,
    _SC_GETGR_R_SIZE_MAX___14 = 69,
    _SC_GETPW_R_SIZE_MAX___14 = 70,
    _SC_LOGIN_NAME_MAX___14 = 71,
    _SC_TTY_NAME_MAX___14 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___14 = 73,
    _SC_THREAD_KEYS_MAX___14 = 74,
    _SC_THREAD_STACK_MIN___14 = 75,
    _SC_THREAD_THREADS_MAX___14 = 76,
    _SC_THREAD_ATTR_STACKADDR___14 = 77,
    _SC_THREAD_ATTR_STACKSIZE___14 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___14 = 79,
    _SC_THREAD_PRIO_INHERIT___14 = 80,
    _SC_THREAD_PRIO_PROTECT___14 = 81,
    _SC_THREAD_PROCESS_SHARED___14 = 82,
    _SC_NPROCESSORS_CONF___14 = 83,
    _SC_NPROCESSORS_ONLN___14 = 84,
    _SC_PHYS_PAGES___14 = 85,
    _SC_AVPHYS_PAGES___14 = 86,
    _SC_ATEXIT_MAX___14 = 87,
    _SC_PASS_MAX___14 = 88,
    _SC_XOPEN_VERSION___14 = 89,
    _SC_XOPEN_XCU_VERSION___14 = 90,
    _SC_XOPEN_UNIX___14 = 91,
    _SC_XOPEN_CRYPT___14 = 92,
    _SC_XOPEN_ENH_I18N___14 = 93,
    _SC_XOPEN_SHM___14 = 94,
    _SC_2_CHAR_TERM___14 = 95,
    _SC_2_C_VERSION___14 = 96,
    _SC_2_UPE___14 = 97,
    _SC_XOPEN_XPG2___14 = 98,
    _SC_XOPEN_XPG3___14 = 99,
    _SC_XOPEN_XPG4___14 = 100,
    _SC_CHAR_BIT___14 = 101,
    _SC_CHAR_MAX___14 = 102,
    _SC_CHAR_MIN___14 = 103,
    _SC_INT_MAX___14 = 104,
    _SC_INT_MIN___14 = 105,
    _SC_LONG_BIT___14 = 106,
    _SC_WORD_BIT___14 = 107,
    _SC_MB_LEN_MAX___14 = 108,
    _SC_NZERO___14 = 109,
    _SC_SSIZE_MAX___14 = 110,
    _SC_SCHAR_MAX___14 = 111,
    _SC_SCHAR_MIN___14 = 112,
    _SC_SHRT_MAX___14 = 113,
    _SC_SHRT_MIN___14 = 114,
    _SC_UCHAR_MAX___14 = 115,
    _SC_UINT_MAX___14 = 116,
    _SC_ULONG_MAX___14 = 117,
    _SC_USHRT_MAX___14 = 118,
    _SC_NL_ARGMAX___14 = 119,
    _SC_NL_LANGMAX___14 = 120,
    _SC_NL_MSGMAX___14 = 121,
    _SC_NL_NMAX___14 = 122,
    _SC_NL_SETMAX___14 = 123,
    _SC_NL_TEXTMAX___14 = 124,
    _SC_XBS5_ILP32_OFF32___14 = 125,
    _SC_XBS5_ILP32_OFFBIG___14 = 126,
    _SC_XBS5_LP64_OFF64___14 = 127,
    _SC_XBS5_LPBIG_OFFBIG___14 = 128,
    _SC_XOPEN_LEGACY___14 = 129,
    _SC_XOPEN_REALTIME___14 = 130,
    _SC_XOPEN_REALTIME_THREADS___14 = 131,
    _SC_ADVISORY_INFO___14 = 132,
    _SC_BARRIERS___14 = 133,
    _SC_BASE___14 = 134,
    _SC_C_LANG_SUPPORT___14 = 135,
    _SC_C_LANG_SUPPORT_R___14 = 136,
    _SC_CLOCK_SELECTION___14 = 137,
    _SC_CPUTIME___14 = 138,
    _SC_THREAD_CPUTIME___14 = 139,
    _SC_DEVICE_IO___14 = 140,
    _SC_DEVICE_SPECIFIC___14 = 141,
    _SC_DEVICE_SPECIFIC_R___14 = 142,
    _SC_FD_MGMT___14 = 143,
    _SC_FIFO___14 = 144,
    _SC_PIPE___14 = 145,
    _SC_FILE_ATTRIBUTES___14 = 146,
    _SC_FILE_LOCKING___14 = 147,
    _SC_FILE_SYSTEM___14 = 148,
    _SC_MONOTONIC_CLOCK___14 = 149,
    _SC_MULTI_PROCESS___14 = 150,
    _SC_SINGLE_PROCESS___14 = 151,
    _SC_NETWORKING___14 = 152,
    _SC_READER_WRITER_LOCKS___14 = 153,
    _SC_SPIN_LOCKS___14 = 154,
    _SC_REGEXP___14 = 155,
    _SC_REGEX_VERSION___14 = 156,
    _SC_SHELL___14 = 157,
    _SC_SIGNALS___14 = 158,
    _SC_SPAWN___14 = 159,
    _SC_SPORADIC_SERVER___14 = 160,
    _SC_THREAD_SPORADIC_SERVER___14 = 161,
    _SC_SYSTEM_DATABASE___14 = 162,
    _SC_SYSTEM_DATABASE_R___14 = 163,
    _SC_TIMEOUTS___14 = 164,
    _SC_TYPED_MEMORY_OBJECTS___14 = 165,
    _SC_USER_GROUPS___14 = 166,
    _SC_USER_GROUPS_R___14 = 167,
    _SC_2_PBS___14 = 168,
    _SC_2_PBS_ACCOUNTING___14 = 169,
    _SC_2_PBS_LOCATE___14 = 170,
    _SC_2_PBS_MESSAGE___14 = 171,
    _SC_2_PBS_TRACK___14 = 172,
    _SC_SYMLOOP_MAX___14 = 173,
    _SC_STREAMS___14 = 174,
    _SC_2_PBS_CHECKPOINT___14 = 175,
    _SC_V6_ILP32_OFF32___14 = 176,
    _SC_V6_ILP32_OFFBIG___14 = 177,
    _SC_V6_LP64_OFF64___14 = 178,
    _SC_V6_LPBIG_OFFBIG___14 = 179,
    _SC_HOST_NAME_MAX___14 = 180,
    _SC_TRACE___14 = 181,
    _SC_TRACE_EVENT_FILTER___14 = 182,
    _SC_TRACE_INHERIT___14 = 183,
    _SC_TRACE_LOG___14 = 184,
    _SC_LEVEL1_ICACHE_SIZE___14 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___14 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___14 = 187,
    _SC_LEVEL1_DCACHE_SIZE___14 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___14 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___14 = 190,
    _SC_LEVEL2_CACHE_SIZE___14 = 191,
    _SC_LEVEL2_CACHE_ASSOC___14 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___14 = 193,
    _SC_LEVEL3_CACHE_SIZE___14 = 194,
    _SC_LEVEL3_CACHE_ASSOC___14 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___14 = 196,
    _SC_LEVEL4_CACHE_SIZE___14 = 197,
    _SC_LEVEL4_CACHE_ASSOC___14 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___14 = 199,
    _SC_IPV6___14 = 235,
    _SC_RAW_SOCKETS___14 = 236,
    _SC_V7_ILP32_OFF32___14 = 237,
    _SC_V7_ILP32_OFFBIG___14 = 238,
    _SC_V7_LP64_OFF64___14 = 239,
    _SC_V7_LPBIG_OFFBIG___14 = 240,
    _SC_SS_REPL_MAX___14 = 241,
    _SC_TRACE_EVENT_NAME_MAX___14 = 242,
    _SC_TRACE_NAME_MAX___14 = 243,
    _SC_TRACE_SYS_MAX___14 = 244,
    _SC_TRACE_USER_EVENT_MAX___14 = 245,
    _SC_XOPEN_STREAMS___14 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___14 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___14 = 248
} ;
#line 533
enum __anonenum_875524036___14 {
    _CS_PATH___14 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___14 = 1,
    _CS_GNU_LIBC_VERSION___14 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___14 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___14 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___14 = 5,
    _CS_LFS_CFLAGS___14 = 1000,
    _CS_LFS_LDFLAGS___14 = 1001,
    _CS_LFS_LIBS___14 = 1002,
    _CS_LFS_LINTFLAGS___14 = 1003,
    _CS_LFS64_CFLAGS___14 = 1004,
    _CS_LFS64_LDFLAGS___14 = 1005,
    _CS_LFS64_LIBS___14 = 1006,
    _CS_LFS64_LINTFLAGS___14 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___14 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___14 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___14 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___14 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___14 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___14 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___14 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___14 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___14 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___14 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___14 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___14 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___14 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___14 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___14 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___14 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___14 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___14 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___14 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___14 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___14 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___14 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___14 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___14 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___14 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___14 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___14 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___14 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___14 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___14 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___14 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___14 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___14 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___14 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___14 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___14 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___14 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___14 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___14 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___14 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___14 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___14 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___14 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___14 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___14 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___14 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___14 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___14 = 1147,
    _CS_V6_ENV___14 = 1148,
    _CS_V7_ENV___14 = 1149
} ;
#line 86 "/usr/include/zlib.h"
struct z_stream_s___0 {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 86 "/usr/include/zlib.h"
typedef struct z_stream_s___0 z_stream___0;
#line 108 "/usr/include/zlib.h"
typedef z_stream___0 *z_streamp___0;
#line 1093 "/usr/include/zlib.h"
typedef unsigned int (*in_func___0)(void * , unsigned char ** );
#line 450 "/home/goblint2/bench/libpng-1.6.39/pngtest.c"
struct __anonstruct_pngtest_error_parameters_1022237947 {
   char const   *file_name ;
};
#line 450 "/home/goblint2/bench/libpng-1.6.39/pngtest.c"
typedef struct __anonstruct_pngtest_error_parameters_1022237947 pngtest_error_parameters;
#line 638 "/home/goblint2/bench/libpng-1.6.39/pngtest.c"
struct user_chunk_data {
   png_const_infop info_ptr ;
   png_uint_32 vpAg_width ;
   png_uint_32 vpAg_height ;
   png_byte vpAg_units ;
   png_byte sTER_mode ;
   int location[2] ;
};
#line 52 "/usr/include/x86_64-linux-gnu/bits/waitflags.h"
enum __anonenum_idtype_t_558242672 {
    P_ALL = 0,
    P_PID = 1,
    P_PGID = 2
} ;
#line 52 "/usr/include/x86_64-linux-gnu/bits/waitflags.h"
typedef enum __anonenum_idtype_t_558242672 idtype_t;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 37 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __quad_t quad_t;
#line 38 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_quad_t u_quad_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsid_t fsid_t;
#line 42 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __loff_t loff_t;
#line 103 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __id_t id_t;
#line 114 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __daddr_t daddr_t;
#line 115 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 121 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __key_t key_t;
#line 148 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned long ulong;
#line 149 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short ushort;
#line 150 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int uint;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h"
typedef __sigset_t sigset_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 43 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __suseconds_t suseconds_t;
#line 49 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 59 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_356711149 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 59 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_356711149 fd_set;
#line 77 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __fd_mask fd_mask;
#line 185 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blksize_t blksize_t;
#line 423 "/usr/include/stdlib.h"
struct random_data {
   int32_t *fptr ;
   int32_t *rptr ;
   int32_t *state ;
   int rand_type ;
   int rand_deg ;
   int rand_sep ;
   int32_t *end_ptr ;
};
#line 490 "/usr/include/stdlib.h"
struct drand48_data {
   unsigned short __x[3] ;
   unsigned short __old_x[3] ;
   unsigned short __c ;
   unsigned short __init ;
   unsigned long long __a ;
};
#line 182 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngunknown.c"
struct __anonstruct_chunk_info_47712822 {
   char name[5] ;
   png_uint_32 flag ;
   png_uint_32 tag ;
   int unknown ;
   int all ;
   int position ;
   int keep ;
};
#line 396 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngunknown.c"
struct __anonstruct_display_350251107 {
   jmp_buf error_return ;
   png_structp png_ptr ;
   png_infop info_ptr ;
   png_infop end_ptr ;
   png_uint_32 before_IDAT ;
   png_uint_32 after_IDAT ;
   int error_count ;
   int warning_count ;
   int keep ;
   char const   *program ;
   char const   *file ;
   char const   *test ;
};
#line 396 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngunknown.c"
typedef struct __anonstruct_display_350251107 display;
#line 46 "/usr/include/ctype.h"
enum __anonenum_18926444 {
    _ISupper = 256,
    _ISlower = 512,
    _ISalpha = 1024,
    _ISdigit = 2048,
    _ISxdigit = 4096,
    _ISspace = 8192,
    _ISprint = 16384,
    _ISgraph = 32768,
    _ISblank = 1,
    _IScntrl = 2,
    _ISpunct = 4,
    _ISalnum = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum_1037408945___14 {
    FP_NAN___14 = 0,
    FP_INFINITE___14 = 1,
    FP_ZERO___14 = 2,
    FP_SUBNORMAL___14 = 3,
    FP_NORMAL___14 = 4
} ;
#line 473 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
struct __anonstruct_format_list_511530770 {
   png_uint_32 bits[2] ;
};
#line 473 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
typedef struct __anonstruct_format_list_511530770 format_list;
#line 574 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
struct __anonstruct_Image_482305373 {
   png_image image ;
   png_uint_32 opts ;
   char const   *file_name ;
   int stride_extra ;
   FILE *input_file ;
   png_voidp input_memory ;
   size_t input_memory_size ;
   png_bytep buffer ;
   ptrdiff_t stride ;
   size_t bufsize ;
   size_t allocsize ;
   char tmpfile_name[32] ;
   png_uint_16 colormap[1024] ;
};
#line 574 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
typedef struct __anonstruct_Image_482305373 Image;
#line 788 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
struct __anonstruct_Pixel_1037408946 {
   int r ;
   int g ;
   int b ;
   int a ;
};
#line 788 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
typedef struct __anonstruct_Pixel_1037408946 Pixel;
#line 796 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
struct __anonstruct_Background_18155537 {
   int ir ;
   int ig ;
   int ib ;
   double dr ;
   double dg ;
   double db ;
};
#line 796 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
typedef struct __anonstruct_Background_18155537 Background;
#line 2024 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
struct __anonstruct_Transform_882698582 {
   Image *in_image ;
   Image const   *out_image ;
   Background background_color ;
   Background const   *background ;
   int in_opaque ;
   int is_palette ;
   int accumulate ;
   int output_8bit ;
   void (*in_gp)(Pixel * , png_const_voidp  ) ;
   void (*out_gp)(Pixel * , png_const_voidp  ) ;
   void (*transform)(Pixel *out , Pixel const   *in , Background const   *back ) ;
   void (*from_linear)(Pixel *out , Pixel const   *in , Background const   *back ) ;
   png_uint_16 error[4] ;
   png_uint_16 *error_ptr ;
};
#line 2024 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
typedef struct __anonstruct_Transform_882698582 Transform;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/sig_atomic_t.h"
typedef __sig_atomic_t sig_atomic_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
typedef union sigval __sigval_t;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__kill_244518854 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__timer_490064738 {
   int si_tid ;
   int si_overrun ;
   __sigval_t si_sigval ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__rt_619254530 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   __sigval_t si_sigval ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigchld_284671705 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__addr_bnd_5259977 {
   void *_lower ;
   void *_upper ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion__bounds_55344115 {
   struct __anonstruct__addr_bnd_5259977 _addr_bnd ;
   __uint32_t _pkey ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigfault_376208014 {
   void *si_addr ;
   short si_addr_lsb ;
   union __anonunion__bounds_55344115 _bounds ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigpoll_386613454 {
   long si_band ;
   int si_fd ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigsys_634745154 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion__sifields_1000786197 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_244518854 _kill ;
   struct __anonstruct__timer_490064738 _timer ;
   struct __anonstruct__rt_619254530 _rt ;
   struct __anonstruct__sigchld_284671705 _sigchld ;
   struct __anonstruct__sigfault_376208014 _sigfault ;
   struct __anonstruct__sigpoll_386613454 _sigpoll ;
   struct __anonstruct__sigsys_634745154 _sigsys ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_siginfo_t_725937179 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   int __pad0 ;
   union __anonunion__sifields_1000786197 _sifields ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
typedef struct __anonstruct_siginfo_t_725937179 siginfo_t;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum_556971655 {
    SI_ASYNCNL = -60,
    SI_DETHREAD = -7,
    SI_TKILL = -6,
    SI_SIGIO = -5,
    SI_ASYNCIO = -4,
    SI_MESGQ = -3,
    SI_TIMER = -2,
    SI_QUEUE = -1,
    SI_USER = 0,
    SI_KERNEL = 128
} ;
#line 71
enum __anonenum_640648963 {
    ILL_ILLOPC = 1,
    ILL_ILLOPN = 2,
    ILL_ILLADR = 3,
    ILL_ILLTRP = 4,
    ILL_PRVOPC = 5,
    ILL_PRVREG = 6,
    ILL_COPROC = 7,
    ILL_BADSTK = 8,
    ILL_BADIADDR = 9
} ;
#line 94
enum __anonenum_457704180 {
    FPE_INTDIV = 1,
    FPE_INTOVF = 2,
    FPE_FLTDIV = 3,
    FPE_FLTOVF = 4,
    FPE_FLTUND = 5,
    FPE_FLTRES = 6,
    FPE_FLTINV = 7,
    FPE_FLTSUB = 8,
    FPE_FLTUNK = 14,
    FPE_CONDTRAP = 15
} ;
#line 119
enum __anonenum_47414555 {
    SEGV_MAPERR = 1,
    SEGV_ACCERR = 2,
    SEGV_BNDERR = 3,
    SEGV_PKUERR = 4,
    SEGV_ACCADI = 5,
    SEGV_ADIDERR = 6,
    SEGV_ADIPERR = 7
} ;
#line 138
enum __anonenum_1036286214 {
    BUS_ADRALN = 1,
    BUS_ADRERR = 2,
    BUS_OBJERR = 3,
    BUS_MCEERR_AR = 4,
    BUS_MCEERR_AO = 5
} ;
#line 155
enum __anonenum_91015150 {
    TRAP_BRKPT = 1,
    TRAP_TRACE = 2,
    TRAP_BRANCH = 3,
    TRAP_HWBKPT = 4,
    TRAP_UNK = 5
} ;
#line 172
enum __anonenum_23175539 {
    CLD_EXITED = 1,
    CLD_KILLED = 2,
    CLD_DUMPED = 3,
    CLD_TRAPPED = 4,
    CLD_STOPPED = 5,
    CLD_CONTINUED = 6
} ;
#line 189
enum __anonenum_111643124 {
    POLL_IN = 1,
    POLL_OUT = 2,
    POLL_MSG = 3,
    POLL_ERR = 4,
    POLL_PRI = 5,
    POLL_HUP = 6
} ;
#line 16 "/usr/include/x86_64-linux-gnu/bits/types/sigval_t.h"
typedef __sigval_t sigval_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h"
struct __anonstruct__sigev_thread_746770901 {
   void (*_function)(__sigval_t  ) ;
   pthread_attr_t *_attribute ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h"
union __anonunion__sigev_un_665438183 {
   int _pad[64UL / sizeof(int ) - 4UL] ;
   __pid_t _tid ;
   struct __anonstruct__sigev_thread_746770901 _sigev_thread ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h"
struct sigevent {
   __sigval_t sigev_value ;
   int sigev_signo ;
   int sigev_notify ;
   union __anonunion__sigev_un_665438183 _sigev_un ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h"
typedef struct sigevent sigevent_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum_852341087 {
    SIGEV_SIGNAL = 0,
    SIGEV_NONE = 1,
    SIGEV_THREAD = 2,
    SIGEV_THREAD_ID = 4
} ;
#line 72 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 185 "/usr/include/signal.h"
typedef void (*sighandler_t)(int  );
#line 190 "/usr/include/signal.h"
typedef void (*sig_t)(int  );
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_363639592 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_363639592 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _fpx_sw_bytes {
   __uint32_t magic1 ;
   __uint32_t extended_size ;
   __uint64_t xstate_bv ;
   __uint32_t xstate_size ;
   __uint32_t __glibc_reserved1[7] ;
};
#line 40 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _fpreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _fpxreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
   unsigned short __glibc_reserved1[3] ;
};
#line 53 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _xmmreg {
   __uint32_t element[4] ;
};
#line 123 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _fpstate {
   __uint16_t cwd ;
   __uint16_t swd ;
   __uint16_t ftw ;
   __uint16_t fop ;
   __uint64_t rip ;
   __uint64_t rdp ;
   __uint32_t mxcsr ;
   __uint32_t mxcr_mask ;
   struct _fpxreg _st[8] ;
   struct _xmmreg _xmm[16] ;
   __uint32_t __glibc_reserved1[24] ;
};
#line 139 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
union __anonunion____missing_field_name_501150464 {
   struct _fpstate *fpstate ;
   __uint64_t __fpstate_word ;
};
#line 139 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct sigcontext {
   __uint64_t r8 ;
   __uint64_t r9 ;
   __uint64_t r10 ;
   __uint64_t r11 ;
   __uint64_t r12 ;
   __uint64_t r13 ;
   __uint64_t r14 ;
   __uint64_t r15 ;
   __uint64_t rdi ;
   __uint64_t rsi ;
   __uint64_t rbp ;
   __uint64_t rbx ;
   __uint64_t rdx ;
   __uint64_t rax ;
   __uint64_t rcx ;
   __uint64_t rsp ;
   __uint64_t rip ;
   __uint64_t eflags ;
   unsigned short cs ;
   unsigned short gs ;
   unsigned short fs ;
   unsigned short __pad0 ;
   __uint64_t err ;
   __uint64_t trapno ;
   __uint64_t oldmask ;
   __uint64_t cr2 ;
   union __anonunion____missing_field_name_501150464 __annonCompField1 ;
   __uint64_t __reserved1[8] ;
};
#line 177 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _xsave_hdr {
   __uint64_t xstate_bv ;
   __uint64_t __glibc_reserved1[2] ;
   __uint64_t __glibc_reserved2[5] ;
};
#line 184 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _ymmh_state {
   __uint32_t ymmh_space[64] ;
};
#line 189 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _xstate {
   struct _fpstate fpstate ;
   struct _xsave_hdr xstate_hdr ;
   struct _ymmh_state ymmh ;
};
#line 26 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h"
struct __anonstruct_stack_t_648343364 {
   void *ss_sp ;
   int ss_flags ;
   size_t ss_size ;
};
#line 26 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h"
typedef struct __anonstruct_stack_t_648343364 stack_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef long long greg_t;
#line 46 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef greg_t gregset_t[23];
#line 50
enum __anonenum_451154152 {
    REG_R8 = 0,
    REG_R9 = 1,
    REG_R10 = 2,
    REG_R11 = 3,
    REG_R12 = 4,
    REG_R13 = 5,
    REG_R14 = 6,
    REG_R15 = 7,
    REG_RDI = 8,
    REG_RSI = 9,
    REG_RBP = 10,
    REG_RBX = 11,
    REG_RDX = 12,
    REG_RAX = 13,
    REG_RCX = 14,
    REG_RSP = 15,
    REG_RIP = 16,
    REG_EFL = 17,
    REG_CSGSFS = 18,
    REG_ERR = 19,
    REG_TRAPNO = 20,
    REG_OLDMASK = 21,
    REG_CR2 = 22
} ;
#line 101 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct _libc_fpxreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
   unsigned short __glibc_reserved1[3] ;
};
#line 108 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct _libc_xmmreg {
   __uint32_t element[4] ;
};
#line 113 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct _libc_fpstate {
   __uint16_t cwd ;
   __uint16_t swd ;
   __uint16_t ftw ;
   __uint16_t fop ;
   __uint64_t rip ;
   __uint64_t rdp ;
   __uint32_t mxcsr ;
   __uint32_t mxcr_mask ;
   struct _libc_fpxreg _st[8] ;
   struct _libc_xmmreg _xmm[16] ;
   __uint32_t __glibc_reserved1[24] ;
};
#line 130 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef struct _libc_fpstate *fpregset_t;
#line 133 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct __anonstruct_mcontext_t_5268627 {
   gregset_t gregs ;
   fpregset_t fpregs ;
   unsigned long long __reserved1[8] ;
};
#line 133 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef struct __anonstruct_mcontext_t_5268627 mcontext_t;
#line 142 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct ucontext_t {
   unsigned long uc_flags ;
   struct ucontext_t *uc_link ;
   stack_t uc_stack ;
   mcontext_t uc_mcontext ;
   sigset_t uc_sigmask ;
   struct _libc_fpstate __fpregs_mem ;
   unsigned long long __ssp[4] ;
};
#line 142 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef struct ucontext_t ucontext_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum_57186863 {
    SS_ONSTACK = 1,
    SS_DISABLE = 2
} ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_sigstack.h"
struct sigstack {
   void *ss_sp ;
   int ss_onstack ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h"
typedef __ssize_t cookie_read_function_t(void *__cookie , char *__buf , size_t __nbytes );
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h"
typedef __ssize_t cookie_write_function_t(void *__cookie , char const   *__buf , size_t __nbytes );
#line 45 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h"
typedef int cookie_seek_function_t(void *__cookie , __off_t *__pos , int __w );
#line 48 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h"
typedef int cookie_close_function_t(void *__cookie );
#line 55 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h"
struct _IO_cookie_io_functions_t {
   cookie_read_function_t *read ;
   cookie_write_function_t *write ;
   cookie_seek_function_t *seek ;
   cookie_close_function_t *close ;
};
#line 55 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h"
typedef struct _IO_cookie_io_functions_t cookie_io_functions_t;
#line 89 "/usr/include/stdio.h"
typedef __fpos64_t fpos64_t;
#line 823
struct obstack ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/fenv.h"
enum __anonenum_558789192 {
    FE_INVALID = 1,
    __FE_DENORM = 2,
    FE_DIVBYZERO = 4,
    FE_OVERFLOW = 8,
    FE_UNDERFLOW = 16,
    FE_INEXACT = 32
} ;
#line 50
enum __anonenum_217606311 {
    FE_TONEAREST = 0,
    FE_DOWNWARD = 1024,
    FE_UPWARD = 2048,
    FE_TOWARDZERO = 3072
} ;
#line 68 "/usr/include/x86_64-linux-gnu/bits/fenv.h"
typedef unsigned short fexcept_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/fenv.h"
struct __anonstruct_fenv_t_1034213925 {
   unsigned short __control_word ;
   unsigned short __glibc_reserved1 ;
   unsigned short __status_word ;
   unsigned short __glibc_reserved2 ;
   unsigned short __tags ;
   unsigned short __glibc_reserved3 ;
   unsigned int __eip ;
   unsigned short __cs_selector ;
   unsigned int __opcode : 11 ;
   unsigned int __glibc_reserved4 : 5 ;
   unsigned int __data_offset ;
   unsigned short __data_selector ;
   unsigned short __glibc_reserved5 ;
   unsigned int __mxcsr ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/fenv.h"
typedef struct __anonstruct_fenv_t_1034213925 fenv_t;
#line 106 "/usr/include/x86_64-linux-gnu/bits/fenv.h"
struct __anonstruct_femode_t_646494041 {
   unsigned short __control_word ;
   unsigned short __glibc_reserved ;
   unsigned int __mxcsr ;
};
#line 106 "/usr/include/x86_64-linux-gnu/bits/fenv.h"
typedef struct __anonstruct_femode_t_646494041 femode_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/timex.h"
struct timex {
   unsigned int modes ;
   __syscall_slong_t offset ;
   __syscall_slong_t freq ;
   __syscall_slong_t maxerror ;
   __syscall_slong_t esterror ;
   int status ;
   __syscall_slong_t constant ;
   __syscall_slong_t precision ;
   __syscall_slong_t tolerance ;
   struct timeval time ;
   __syscall_slong_t tick ;
   __syscall_slong_t ppsfreq ;
   __syscall_slong_t jitter ;
   int shift ;
   __syscall_slong_t stabil ;
   __syscall_slong_t jitcnt ;
   __syscall_slong_t calcnt ;
   __syscall_slong_t errcnt ;
   __syscall_slong_t stbcnt ;
   int tai ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino64_t ino64_t;
#line 134 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __useconds_t useconds_t;
#line 219 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blkcnt64_t blkcnt64_t;
#line 220 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsblkcnt64_t fsblkcnt64_t;
#line 221 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsfilcnt64_t fsfilcnt64_t;
#line 267 "/usr/include/unistd.h"
typedef __intptr_t intptr_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum_437032235___15 {
    _PC_LINK_MAX___15 = 0,
    _PC_MAX_CANON___15 = 1,
    _PC_MAX_INPUT___15 = 2,
    _PC_NAME_MAX___15 = 3,
    _PC_PATH_MAX___15 = 4,
    _PC_PIPE_BUF___15 = 5,
    _PC_CHOWN_RESTRICTED___15 = 6,
    _PC_NO_TRUNC___15 = 7,
    _PC_VDISABLE___15 = 8,
    _PC_SYNC_IO___15 = 9,
    _PC_ASYNC_IO___15 = 10,
    _PC_PRIO_IO___15 = 11,
    _PC_SOCK_MAXBUF___15 = 12,
    _PC_FILESIZEBITS___15 = 13,
    _PC_REC_INCR_XFER_SIZE___15 = 14,
    _PC_REC_MAX_XFER_SIZE___15 = 15,
    _PC_REC_MIN_XFER_SIZE___15 = 16,
    _PC_REC_XFER_ALIGN___15 = 17,
    _PC_ALLOC_SIZE_MIN___15 = 18,
    _PC_SYMLINK_MAX___15 = 19,
    _PC_2_SYMLINKS___15 = 20
} ;
#line 71
enum __anonenum_315186338___15 {
    _SC_ARG_MAX___15 = 0,
    _SC_CHILD_MAX___15 = 1,
    _SC_CLK_TCK___15 = 2,
    _SC_NGROUPS_MAX___15 = 3,
    _SC_OPEN_MAX___15 = 4,
    _SC_STREAM_MAX___15 = 5,
    _SC_TZNAME_MAX___15 = 6,
    _SC_JOB_CONTROL___15 = 7,
    _SC_SAVED_IDS___15 = 8,
    _SC_REALTIME_SIGNALS___15 = 9,
    _SC_PRIORITY_SCHEDULING___15 = 10,
    _SC_TIMERS___15 = 11,
    _SC_ASYNCHRONOUS_IO___15 = 12,
    _SC_PRIORITIZED_IO___15 = 13,
    _SC_SYNCHRONIZED_IO___15 = 14,
    _SC_FSYNC___15 = 15,
    _SC_MAPPED_FILES___15 = 16,
    _SC_MEMLOCK___15 = 17,
    _SC_MEMLOCK_RANGE___15 = 18,
    _SC_MEMORY_PROTECTION___15 = 19,
    _SC_MESSAGE_PASSING___15 = 20,
    _SC_SEMAPHORES___15 = 21,
    _SC_SHARED_MEMORY_OBJECTS___15 = 22,
    _SC_AIO_LISTIO_MAX___15 = 23,
    _SC_AIO_MAX___15 = 24,
    _SC_AIO_PRIO_DELTA_MAX___15 = 25,
    _SC_DELAYTIMER_MAX___15 = 26,
    _SC_MQ_OPEN_MAX___15 = 27,
    _SC_MQ_PRIO_MAX___15 = 28,
    _SC_VERSION___15 = 29,
    _SC_PAGESIZE___15 = 30,
    _SC_RTSIG_MAX___15 = 31,
    _SC_SEM_NSEMS_MAX___15 = 32,
    _SC_SEM_VALUE_MAX___15 = 33,
    _SC_SIGQUEUE_MAX___15 = 34,
    _SC_TIMER_MAX___15 = 35,
    _SC_BC_BASE_MAX___15 = 36,
    _SC_BC_DIM_MAX___15 = 37,
    _SC_BC_SCALE_MAX___15 = 38,
    _SC_BC_STRING_MAX___15 = 39,
    _SC_COLL_WEIGHTS_MAX___15 = 40,
    _SC_EQUIV_CLASS_MAX___15 = 41,
    _SC_EXPR_NEST_MAX___15 = 42,
    _SC_LINE_MAX___15 = 43,
    _SC_RE_DUP_MAX___15 = 44,
    _SC_CHARCLASS_NAME_MAX___15 = 45,
    _SC_2_VERSION___15 = 46,
    _SC_2_C_BIND___15 = 47,
    _SC_2_C_DEV___15 = 48,
    _SC_2_FORT_DEV___15 = 49,
    _SC_2_FORT_RUN___15 = 50,
    _SC_2_SW_DEV___15 = 51,
    _SC_2_LOCALEDEF___15 = 52,
    _SC_PII___15 = 53,
    _SC_PII_XTI___15 = 54,
    _SC_PII_SOCKET___15 = 55,
    _SC_PII_INTERNET___15 = 56,
    _SC_PII_OSI___15 = 57,
    _SC_POLL___15 = 58,
    _SC_SELECT___15 = 59,
    _SC_UIO_MAXIOV___15 = 60,
    _SC_IOV_MAX___15 = 60,
    _SC_PII_INTERNET_STREAM___15 = 61,
    _SC_PII_INTERNET_DGRAM___15 = 62,
    _SC_PII_OSI_COTS___15 = 63,
    _SC_PII_OSI_CLTS___15 = 64,
    _SC_PII_OSI_M___15 = 65,
    _SC_T_IOV_MAX___15 = 66,
    _SC_THREADS___15 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___15 = 68,
    _SC_GETGR_R_SIZE_MAX___15 = 69,
    _SC_GETPW_R_SIZE_MAX___15 = 70,
    _SC_LOGIN_NAME_MAX___15 = 71,
    _SC_TTY_NAME_MAX___15 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___15 = 73,
    _SC_THREAD_KEYS_MAX___15 = 74,
    _SC_THREAD_STACK_MIN___15 = 75,
    _SC_THREAD_THREADS_MAX___15 = 76,
    _SC_THREAD_ATTR_STACKADDR___15 = 77,
    _SC_THREAD_ATTR_STACKSIZE___15 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___15 = 79,
    _SC_THREAD_PRIO_INHERIT___15 = 80,
    _SC_THREAD_PRIO_PROTECT___15 = 81,
    _SC_THREAD_PROCESS_SHARED___15 = 82,
    _SC_NPROCESSORS_CONF___15 = 83,
    _SC_NPROCESSORS_ONLN___15 = 84,
    _SC_PHYS_PAGES___15 = 85,
    _SC_AVPHYS_PAGES___15 = 86,
    _SC_ATEXIT_MAX___15 = 87,
    _SC_PASS_MAX___15 = 88,
    _SC_XOPEN_VERSION___15 = 89,
    _SC_XOPEN_XCU_VERSION___15 = 90,
    _SC_XOPEN_UNIX___15 = 91,
    _SC_XOPEN_CRYPT___15 = 92,
    _SC_XOPEN_ENH_I18N___15 = 93,
    _SC_XOPEN_SHM___15 = 94,
    _SC_2_CHAR_TERM___15 = 95,
    _SC_2_C_VERSION___15 = 96,
    _SC_2_UPE___15 = 97,
    _SC_XOPEN_XPG2___15 = 98,
    _SC_XOPEN_XPG3___15 = 99,
    _SC_XOPEN_XPG4___15 = 100,
    _SC_CHAR_BIT___15 = 101,
    _SC_CHAR_MAX___15 = 102,
    _SC_CHAR_MIN___15 = 103,
    _SC_INT_MAX___15 = 104,
    _SC_INT_MIN___15 = 105,
    _SC_LONG_BIT___15 = 106,
    _SC_WORD_BIT___15 = 107,
    _SC_MB_LEN_MAX___15 = 108,
    _SC_NZERO___15 = 109,
    _SC_SSIZE_MAX___15 = 110,
    _SC_SCHAR_MAX___15 = 111,
    _SC_SCHAR_MIN___15 = 112,
    _SC_SHRT_MAX___15 = 113,
    _SC_SHRT_MIN___15 = 114,
    _SC_UCHAR_MAX___15 = 115,
    _SC_UINT_MAX___15 = 116,
    _SC_ULONG_MAX___15 = 117,
    _SC_USHRT_MAX___15 = 118,
    _SC_NL_ARGMAX___15 = 119,
    _SC_NL_LANGMAX___15 = 120,
    _SC_NL_MSGMAX___15 = 121,
    _SC_NL_NMAX___15 = 122,
    _SC_NL_SETMAX___15 = 123,
    _SC_NL_TEXTMAX___15 = 124,
    _SC_XBS5_ILP32_OFF32___15 = 125,
    _SC_XBS5_ILP32_OFFBIG___15 = 126,
    _SC_XBS5_LP64_OFF64___15 = 127,
    _SC_XBS5_LPBIG_OFFBIG___15 = 128,
    _SC_XOPEN_LEGACY___15 = 129,
    _SC_XOPEN_REALTIME___15 = 130,
    _SC_XOPEN_REALTIME_THREADS___15 = 131,
    _SC_ADVISORY_INFO___15 = 132,
    _SC_BARRIERS___15 = 133,
    _SC_BASE___15 = 134,
    _SC_C_LANG_SUPPORT___15 = 135,
    _SC_C_LANG_SUPPORT_R___15 = 136,
    _SC_CLOCK_SELECTION___15 = 137,
    _SC_CPUTIME___15 = 138,
    _SC_THREAD_CPUTIME___15 = 139,
    _SC_DEVICE_IO___15 = 140,
    _SC_DEVICE_SPECIFIC___15 = 141,
    _SC_DEVICE_SPECIFIC_R___15 = 142,
    _SC_FD_MGMT___15 = 143,
    _SC_FIFO___15 = 144,
    _SC_PIPE___15 = 145,
    _SC_FILE_ATTRIBUTES___15 = 146,
    _SC_FILE_LOCKING___15 = 147,
    _SC_FILE_SYSTEM___15 = 148,
    _SC_MONOTONIC_CLOCK___15 = 149,
    _SC_MULTI_PROCESS___15 = 150,
    _SC_SINGLE_PROCESS___15 = 151,
    _SC_NETWORKING___15 = 152,
    _SC_READER_WRITER_LOCKS___15 = 153,
    _SC_SPIN_LOCKS___15 = 154,
    _SC_REGEXP___15 = 155,
    _SC_REGEX_VERSION___15 = 156,
    _SC_SHELL___15 = 157,
    _SC_SIGNALS___15 = 158,
    _SC_SPAWN___15 = 159,
    _SC_SPORADIC_SERVER___15 = 160,
    _SC_THREAD_SPORADIC_SERVER___15 = 161,
    _SC_SYSTEM_DATABASE___15 = 162,
    _SC_SYSTEM_DATABASE_R___15 = 163,
    _SC_TIMEOUTS___15 = 164,
    _SC_TYPED_MEMORY_OBJECTS___15 = 165,
    _SC_USER_GROUPS___15 = 166,
    _SC_USER_GROUPS_R___15 = 167,
    _SC_2_PBS___15 = 168,
    _SC_2_PBS_ACCOUNTING___15 = 169,
    _SC_2_PBS_LOCATE___15 = 170,
    _SC_2_PBS_MESSAGE___15 = 171,
    _SC_2_PBS_TRACK___15 = 172,
    _SC_SYMLOOP_MAX___15 = 173,
    _SC_STREAMS___15 = 174,
    _SC_2_PBS_CHECKPOINT___15 = 175,
    _SC_V6_ILP32_OFF32___15 = 176,
    _SC_V6_ILP32_OFFBIG___15 = 177,
    _SC_V6_LP64_OFF64___15 = 178,
    _SC_V6_LPBIG_OFFBIG___15 = 179,
    _SC_HOST_NAME_MAX___15 = 180,
    _SC_TRACE___15 = 181,
    _SC_TRACE_EVENT_FILTER___15 = 182,
    _SC_TRACE_INHERIT___15 = 183,
    _SC_TRACE_LOG___15 = 184,
    _SC_LEVEL1_ICACHE_SIZE___15 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___15 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___15 = 187,
    _SC_LEVEL1_DCACHE_SIZE___15 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___15 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___15 = 190,
    _SC_LEVEL2_CACHE_SIZE___15 = 191,
    _SC_LEVEL2_CACHE_ASSOC___15 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___15 = 193,
    _SC_LEVEL3_CACHE_SIZE___15 = 194,
    _SC_LEVEL3_CACHE_ASSOC___15 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___15 = 196,
    _SC_LEVEL4_CACHE_SIZE___15 = 197,
    _SC_LEVEL4_CACHE_ASSOC___15 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___15 = 199,
    _SC_IPV6___15 = 235,
    _SC_RAW_SOCKETS___15 = 236,
    _SC_V7_ILP32_OFF32___15 = 237,
    _SC_V7_ILP32_OFFBIG___15 = 238,
    _SC_V7_LP64_OFF64___15 = 239,
    _SC_V7_LPBIG_OFFBIG___15 = 240,
    _SC_SS_REPL_MAX___15 = 241,
    _SC_TRACE_EVENT_NAME_MAX___15 = 242,
    _SC_TRACE_NAME_MAX___15 = 243,
    _SC_TRACE_SYS_MAX___15 = 244,
    _SC_TRACE_USER_EVENT_MAX___15 = 245,
    _SC_XOPEN_STREAMS___15 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___15 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___15 = 248
} ;
#line 533
enum __anonenum_875524036___15 {
    _CS_PATH___15 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___15 = 1,
    _CS_GNU_LIBC_VERSION___15 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___15 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___15 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___15 = 5,
    _CS_LFS_CFLAGS___15 = 1000,
    _CS_LFS_LDFLAGS___15 = 1001,
    _CS_LFS_LIBS___15 = 1002,
    _CS_LFS_LINTFLAGS___15 = 1003,
    _CS_LFS64_CFLAGS___15 = 1004,
    _CS_LFS64_LDFLAGS___15 = 1005,
    _CS_LFS64_LIBS___15 = 1006,
    _CS_LFS64_LINTFLAGS___15 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___15 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___15 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___15 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___15 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___15 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___15 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___15 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___15 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___15 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___15 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___15 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___15 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___15 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___15 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___15 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___15 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___15 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___15 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___15 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___15 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___15 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___15 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___15 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___15 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___15 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___15 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___15 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___15 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___15 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___15 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___15 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___15 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___15 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___15 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___15 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___15 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___15 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___15 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___15 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___15 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___15 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___15 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___15 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___15 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___15 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___15 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___15 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___15 = 1147,
    _CS_V6_ENV___15 = 1148,
    _CS_V7_ENV___15 = 1149
} ;
#line 811 "/usr/include/stdlib.h"
typedef int (*comparison_fn_t)(void const   * , void const   * );
#line 815 "/usr/include/stdlib.h"
typedef int (*__compar_d_fn_t)(void const   * , void const   * , void * );
#line 237 "/usr/include/math.h"
enum __anonenum_913965969 {
    FP_INT_UPWARD = 0,
    FP_INT_DOWNWARD = 1,
    FP_INT_TOWARDZERO = 2,
    FP_INT_TONEARESTFROMZERO = 3,
    FP_INT_TONEAREST = 4
} ;
#line 853
enum __anonenum_1037408945___15 {
    FP_NAN___15 = 0,
    FP_INFINITE___15 = 1,
    FP_ZERO___15 = 2,
    FP_SUBNORMAL___15 = 3,
    FP_NORMAL___15 = 4
} ;
#line 172 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
struct png_store ;
#line 173 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
struct __anonstruct_v_466957402 {
   struct png_store *etmp ;
};
#line 173 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
struct exception_context {
   jmp_buf *penv ;
   int caught ;
   struct __anonstruct_v_466957402  volatile  v ;
};
#line 693 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
struct png_store_buffer {
   struct png_store_buffer *prev ;
   png_byte buffer[500] ;
};
#line 693 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
typedef struct png_store_buffer png_store_buffer;
#line 701 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
struct store_palette_entry {
   png_byte red ;
   png_byte green ;
   png_byte blue ;
   png_byte alpha ;
};
#line 701 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
typedef struct store_palette_entry store_palette_entry;
#line 701 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
typedef struct store_palette_entry store_palette[256];
#line 709 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
struct png_store_file {
   struct png_store_file *next ;
   char name[64] ;
   unsigned int IDAT_bits ;
   png_uint_32 IDAT_size ;
   png_uint_32 id ;
   size_t datacount ;
   png_store_buffer data ;
   int npalette ;
   store_palette_entry *palette ;
};
#line 709 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
typedef struct png_store_file png_store_file;
#line 725
struct store_memory ;
#line 725 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
struct store_pool {
   struct png_store *store ;
   struct store_memory *list ;
   png_byte mark[4] ;
   png_alloc_size_t max ;
   png_alloc_size_t current ;
   png_alloc_size_t limit ;
   png_alloc_size_t total ;
   png_alloc_size_t max_max ;
   png_alloc_size_t max_limit ;
   png_alloc_size_t max_total ;
};
#line 725 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
typedef struct store_pool store_pool;
#line 743 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
struct __anonstruct_options_157313915 {
   unsigned char option ;
   unsigned char setting ;
};
#line 743 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
struct png_store {
   struct exception_context exception_context ;
   unsigned int verbose : 1 ;
   unsigned int treat_warnings_as_errors : 1 ;
   unsigned int expect_error : 1 ;
   unsigned int expect_warning : 1 ;
   unsigned int saw_warning : 1 ;
   unsigned int speed : 1 ;
   unsigned int progressive : 1 ;
   unsigned int validated : 1 ;
   int nerrors ;
   int nwarnings ;
   int noptions ;
   struct __anonstruct_options_157313915 options[16] ;
   char test[128] ;
   char error[256] ;
   png_uint_32 chunklen ;
   png_uint_32 chunktype ;
   png_uint_32 chunkpos ;
   png_uint_32 IDAT_size ;
   unsigned int IDAT_bits ;
   png_structp pread ;
   png_infop piread ;
   png_store_file *current ;
   png_store_buffer *next ;
   size_t readpos ;
   png_byte *image ;
   size_t cb_image ;
   size_t cb_row ;
   uLong IDAT_crc ;
   png_uint_32 IDAT_len ;
   png_uint_32 IDAT_pos ;
   png_uint_32 image_h ;
   store_pool read_memory_pool ;
   png_store_file *saved ;
   png_structp pwrite ;
   png_infop piwrite ;
   size_t writepos ;
   char wname[64] ;
   png_store_buffer new ;
   store_pool write_memory_pool ;
   store_palette_entry *palette ;
   int npalette ;
};
#line 743 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
typedef struct png_store png_store;
#line 1790 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
struct store_memory {
   store_pool *pool ;
   struct store_memory *next ;
   png_alloc_size_t size ;
   png_byte mark[4] ;
};
#line 1790 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
typedef struct store_memory store_memory;
#line 2232
enum modifier_state {
    modifier_start = 0,
    modifier_signature = 1,
    modifier_IHDR = 2
} ;
#line 2232 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
typedef enum modifier_state modifier_state;
#line 2239 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
struct CIE_color {
   double X ;
   double Y ;
   double Z ;
};
#line 2239 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
typedef struct CIE_color CIE_color;
#line 2249 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
struct color_encoding {
   double gamma ;
   CIE_color red ;
   CIE_color green ;
   CIE_color blue ;
};
#line 2249 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
typedef struct color_encoding color_encoding;
#line 2353
struct png_modification ;
#line 2353 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
struct png_modifier {
   png_store this ;
   struct png_modification *modifications ;
   modifier_state state ;
   png_byte bit_depth ;
   png_byte colour_type ;
   png_uint_32 pending_len ;
   png_uint_32 pending_chunk ;
   double *gammas ;
   unsigned int ngammas ;
   unsigned int ngamma_tests ;
   double current_gamma ;
   color_encoding const   *encodings ;
   unsigned int nencodings ;
   color_encoding const   *current_encoding ;
   unsigned int encoding_counter ;
   int encoding_ignored ;
   unsigned int repeat : 1 ;
   unsigned int test_uses_encoding : 1 ;
   png_byte sbitlow ;
   double maxout8 ;
   double maxabs8 ;
   double maxcalc8 ;
   double maxpc8 ;
   double maxout16 ;
   double maxabs16 ;
   double maxcalc16 ;
   double maxcalcG ;
   double maxpc16 ;
   double limit ;
   double log8 ;
   double log16 ;
   double error_gray_2 ;
   double error_gray_4 ;
   double error_gray_8 ;
   double error_gray_16 ;
   double error_color_8 ;
   double error_color_16 ;
   double error_indexed ;
   int use_update_info ;
   int interlace_type : 9 ;
   unsigned int test_standard : 1 ;
   unsigned int test_size : 1 ;
   unsigned int test_transform : 1 ;
   unsigned int test_tRNS : 1 ;
   unsigned int use_input_precision : 1 ;
   unsigned int use_input_precision_sbit : 1 ;
   unsigned int use_input_precision_16to8 : 1 ;
   unsigned int calculations_use_input_precision : 1 ;
   unsigned int assume_16_bit_calculations : 1 ;
   unsigned int test_gamma_threshold : 1 ;
   unsigned int test_gamma_transform : 1 ;
   unsigned int test_gamma_sbit : 1 ;
   unsigned int test_gamma_scale16 : 1 ;
   unsigned int test_gamma_background : 1 ;
   unsigned int test_gamma_alpha_mode : 1 ;
   unsigned int test_gamma_expand16 : 1 ;
   unsigned int test_exhaustive : 1 ;
   unsigned int test_lbg : 1 ;
   unsigned int test_lbg_gamma_threshold : 1 ;
   unsigned int test_lbg_gamma_transform : 1 ;
   unsigned int test_lbg_gamma_sbit : 1 ;
   unsigned int test_lbg_gamma_composition : 1 ;
   unsigned int log : 1 ;
   size_t flush ;
   size_t buffer_count ;
   size_t buffer_position ;
   png_byte buffer[1024] ;
};
#line 2353 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
typedef struct png_modifier png_modifier;
#line 2751 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
struct png_modification {
   struct png_modification *next ;
   png_uint_32 chunk ;
   int (*modify_fn)(struct png_modifier *pm , struct png_modification *me , int add ) ;
   png_uint_32 add ;
   unsigned int modified : 1 ;
   unsigned int added : 1 ;
   unsigned int removed : 1 ;
};
#line 2751 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
typedef struct png_modification png_modification;
#line 3296 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
struct gama_modification {
   png_modification this ;
   png_fixed_point gamma ;
};
#line 3296 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
typedef struct gama_modification gama_modification;
#line 3328 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
struct chrm_modification {
   png_modification this ;
   color_encoding const   *encoding ;
   png_fixed_point wx ;
   png_fixed_point wy ;
   png_fixed_point rx ;
   png_fixed_point ry ;
   png_fixed_point gx ;
   png_fixed_point gy ;
   png_fixed_point bx ;
   png_fixed_point by ;
};
#line 3328 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
typedef struct chrm_modification chrm_modification;
#line 3381 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
struct srgb_modification {
   png_modification this ;
   png_byte intent ;
};
#line 3381 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
typedef struct srgb_modification srgb_modification;
#line 3423 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
struct sbit_modification {
   png_modification this ;
   png_byte sbit ;
};
#line 3423 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
typedef struct sbit_modification sbit_modification;
#line 4624 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
struct __anonstruct_error_test_969491036 {
   void (*fn)(png_structp  , png_infop  ) ;
   char const   *msg ;
   unsigned int warning : 1 ;
};
#line 4936 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
struct __anonstruct_transparent_411880264 {
   png_uint_16 red ;
   png_uint_16 green ;
   png_uint_16 blue ;
};
#line 4936 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
struct standard_display {
   png_store *ps ;
   png_byte colour_type ;
   png_byte bit_depth ;
   png_byte red_sBIT ;
   png_byte green_sBIT ;
   png_byte blue_sBIT ;
   png_byte alpha_sBIT ;
   png_byte interlace_type ;
   png_byte filler ;
   png_uint_32 id ;
   png_uint_32 w ;
   png_uint_32 h ;
   int npasses ;
   png_uint_32 pixel_size ;
   png_uint_32 bit_width ;
   size_t cbRow ;
   int do_interlace ;
   int littleendian ;
   int is_transparent ;
   int has_tRNS ;
   int speed ;
   int use_update_info ;
   struct __anonstruct_transparent_411880264 transparent ;
   int npalette ;
   store_palette palette ;
};
#line 4936 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
typedef struct standard_display standard_display;
#line 6018 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
struct image_pixel {
   unsigned int red ;
   unsigned int green ;
   unsigned int blue ;
   unsigned int alpha ;
   unsigned int palette_index ;
   png_byte colour_type ;
   png_byte bit_depth ;
   png_byte sample_depth ;
   unsigned int have_tRNS : 1 ;
   unsigned int swap_rgb : 1 ;
   unsigned int alpha_first : 1 ;
   unsigned int alpha_inverted : 1 ;
   unsigned int mono_inverted : 1 ;
   unsigned int swap16 : 1 ;
   unsigned int littleendian : 1 ;
   unsigned int sig_bits : 1 ;
   double redf ;
   double greenf ;
   double bluef ;
   double alphaf ;
   double rede ;
   double greene ;
   double bluee ;
   double alphae ;
   png_byte red_sBIT ;
   png_byte green_sBIT ;
   png_byte blue_sBIT ;
   png_byte alpha_sBIT ;
};
#line 6018 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
typedef struct image_pixel image_pixel;
#line 6298
struct transform_display ;
#line 6299 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
struct image_transform {
   char const   *name ;
   int enable ;
   struct image_transform *list ;
   unsigned int global_use ;
   unsigned int local_use ;
   struct image_transform  const  *next ;
   void (*ini)(struct image_transform  const  *this , struct transform_display *that ) ;
   void (*set)(struct image_transform  const  *this , struct transform_display *that ,
               png_structp pp , png_infop pi ) ;
   void (*mod)(struct image_transform  const  *this , image_pixel *that , png_const_structp pp ,
               struct transform_display  const  *display ) ;
   int (*add)(struct image_transform *this , struct image_transform  const  **that ,
              png_byte colour_type , png_byte bit_depth ) ;
};
#line 6299 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
typedef struct image_transform image_transform;
#line 6356 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
struct transform_display {
   standard_display this ;
   png_modifier *pm ;
   image_transform const   *transform_list ;
   unsigned int max_gamma_8 ;
   png_byte output_colour_type ;
   png_byte output_bit_depth ;
   png_byte unpacked ;
   gama_modification gama_mod ;
   chrm_modification chrm_mod ;
   srgb_modification srgb_mod ;
};
#line 6356 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
typedef struct transform_display transform_display;
#line 7586 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
struct __anonstruct_image_transform_data_rgb_to_gray_394210925 {
   double gamma ;
   double red_to_set ;
   double green_to_set ;
   double red_coefficient ;
   double green_coefficient ;
   double blue_coefficient ;
   int coefficients_overridden ;
};
#line 8601 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
struct __anonstruct_image_transform_data_filler_51946980 {
   png_uint_32 filler ;
   int flags ;
};
#line 8674 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
struct __anonstruct_image_transform_data_add_alpha_51946981 {
   png_uint_32 filler ;
   int flags ;
};
#line 9216 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
struct gamma_display {
   standard_display this ;
   png_modifier *pm ;
   double file_gamma ;
   double screen_gamma ;
   double background_gamma ;
   png_byte sbit ;
   int threshold_test ;
   int use_input_precision ;
   int scale16 ;
   int expand16 ;
   int do_background ;
   png_color_16 background_color ;
   double maxerrout ;
   double maxerrpc ;
   double maxerrabs ;
};
#line 9216 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
typedef struct gamma_display gamma_display;
#line 9402 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
struct validate_info {
   png_const_structp pp ;
   gamma_display *dp ;
   png_byte sbit ;
   int use_input_precision ;
   int do_background ;
   int scale16 ;
   unsigned int sbit_max ;
   unsigned int isbit_shift ;
   unsigned int outmax ;
   double gamma_correction ;
   double file_inverse ;
   double screen_gamma ;
   double screen_inverse ;
   double background_red ;
   double background_green ;
   double background_blue ;
   double maxabs ;
   double maxpc ;
   double maxcalc ;
   double maxout ;
   double maxout_total ;
   double outlog ;
   int outquant ;
};
#line 9402 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
typedef struct validate_info validate_info;
#line 93 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
struct transform_info {
   char const   *name ;
   int transform ;
   png_uint_32 valid_chunks ;
   png_byte color_mask_required ;
   png_byte color_mask_absent ;
   png_byte bit_depths ;
   png_byte when ;
   png_byte tested ;
};
#line 369 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
struct buffer_list {
   struct buffer_list *next ;
   png_byte buffer[1024] ;
};
#line 375 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
struct buffer {
   struct buffer_list *last ;
   size_t end_count ;
   struct buffer_list *current ;
   size_t read_count ;
   struct buffer_list first ;
};
#line 509
enum __anonenum_error_level_91586677 {
    VERBOSE = 0,
    INFORMATION = 1,
    WARNINGS = 2,
    LIBPNG_WARNING = 3,
    APP_WARNING = 4,
    ERRORS = 5,
    APP_FAIL = 6,
    LIBPNG_ERROR = 7,
    LIBPNG_BUG = 8,
    APP_ERROR = 9,
    QUIET = 10,
    USER_ERROR = 11,
    INTERNAL_ERROR = 12
} ;
#line 509 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
typedef enum __anonenum_error_level_91586677 error_level;
#line 543 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
struct display {
   jmp_buf error_return ;
   char const   *filename ;
   char const   *operation ;
   int transforms ;
   png_uint_32 options ;
   png_uint_32 results ;
   png_structp original_pp ;
   png_infop original_ip ;
   size_t original_rowbytes ;
   png_bytepp original_rows ;
   png_uint_32 chunks ;
   png_uint_32 width ;
   png_uint_32 height ;
   int bit_depth ;
   int color_type ;
   int interlace_method ;
   int compression_method ;
   int filter_method ;
   int active_transforms ;
   int ignored_transforms ;
   png_structp read_pp ;
   png_infop read_ip ;
   png_structp write_pp ;
   struct buffer written_file ;
   struct buffer original_file ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum_437032235___16 {
    _PC_LINK_MAX___16 = 0,
    _PC_MAX_CANON___16 = 1,
    _PC_MAX_INPUT___16 = 2,
    _PC_NAME_MAX___16 = 3,
    _PC_PATH_MAX___16 = 4,
    _PC_PIPE_BUF___16 = 5,
    _PC_CHOWN_RESTRICTED___16 = 6,
    _PC_NO_TRUNC___16 = 7,
    _PC_VDISABLE___16 = 8,
    _PC_SYNC_IO___16 = 9,
    _PC_ASYNC_IO___16 = 10,
    _PC_PRIO_IO___16 = 11,
    _PC_SOCK_MAXBUF___16 = 12,
    _PC_FILESIZEBITS___16 = 13,
    _PC_REC_INCR_XFER_SIZE___16 = 14,
    _PC_REC_MAX_XFER_SIZE___16 = 15,
    _PC_REC_MIN_XFER_SIZE___16 = 16,
    _PC_REC_XFER_ALIGN___16 = 17,
    _PC_ALLOC_SIZE_MIN___16 = 18,
    _PC_SYMLINK_MAX___16 = 19,
    _PC_2_SYMLINKS___16 = 20
} ;
#line 71
enum __anonenum_315186338___16 {
    _SC_ARG_MAX___16 = 0,
    _SC_CHILD_MAX___16 = 1,
    _SC_CLK_TCK___16 = 2,
    _SC_NGROUPS_MAX___16 = 3,
    _SC_OPEN_MAX___16 = 4,
    _SC_STREAM_MAX___16 = 5,
    _SC_TZNAME_MAX___16 = 6,
    _SC_JOB_CONTROL___16 = 7,
    _SC_SAVED_IDS___16 = 8,
    _SC_REALTIME_SIGNALS___16 = 9,
    _SC_PRIORITY_SCHEDULING___16 = 10,
    _SC_TIMERS___16 = 11,
    _SC_ASYNCHRONOUS_IO___16 = 12,
    _SC_PRIORITIZED_IO___16 = 13,
    _SC_SYNCHRONIZED_IO___16 = 14,
    _SC_FSYNC___16 = 15,
    _SC_MAPPED_FILES___16 = 16,
    _SC_MEMLOCK___16 = 17,
    _SC_MEMLOCK_RANGE___16 = 18,
    _SC_MEMORY_PROTECTION___16 = 19,
    _SC_MESSAGE_PASSING___16 = 20,
    _SC_SEMAPHORES___16 = 21,
    _SC_SHARED_MEMORY_OBJECTS___16 = 22,
    _SC_AIO_LISTIO_MAX___16 = 23,
    _SC_AIO_MAX___16 = 24,
    _SC_AIO_PRIO_DELTA_MAX___16 = 25,
    _SC_DELAYTIMER_MAX___16 = 26,
    _SC_MQ_OPEN_MAX___16 = 27,
    _SC_MQ_PRIO_MAX___16 = 28,
    _SC_VERSION___16 = 29,
    _SC_PAGESIZE___16 = 30,
    _SC_RTSIG_MAX___16 = 31,
    _SC_SEM_NSEMS_MAX___16 = 32,
    _SC_SEM_VALUE_MAX___16 = 33,
    _SC_SIGQUEUE_MAX___16 = 34,
    _SC_TIMER_MAX___16 = 35,
    _SC_BC_BASE_MAX___16 = 36,
    _SC_BC_DIM_MAX___16 = 37,
    _SC_BC_SCALE_MAX___16 = 38,
    _SC_BC_STRING_MAX___16 = 39,
    _SC_COLL_WEIGHTS_MAX___16 = 40,
    _SC_EQUIV_CLASS_MAX___16 = 41,
    _SC_EXPR_NEST_MAX___16 = 42,
    _SC_LINE_MAX___16 = 43,
    _SC_RE_DUP_MAX___16 = 44,
    _SC_CHARCLASS_NAME_MAX___16 = 45,
    _SC_2_VERSION___16 = 46,
    _SC_2_C_BIND___16 = 47,
    _SC_2_C_DEV___16 = 48,
    _SC_2_FORT_DEV___16 = 49,
    _SC_2_FORT_RUN___16 = 50,
    _SC_2_SW_DEV___16 = 51,
    _SC_2_LOCALEDEF___16 = 52,
    _SC_PII___16 = 53,
    _SC_PII_XTI___16 = 54,
    _SC_PII_SOCKET___16 = 55,
    _SC_PII_INTERNET___16 = 56,
    _SC_PII_OSI___16 = 57,
    _SC_POLL___16 = 58,
    _SC_SELECT___16 = 59,
    _SC_UIO_MAXIOV___16 = 60,
    _SC_IOV_MAX___16 = 60,
    _SC_PII_INTERNET_STREAM___16 = 61,
    _SC_PII_INTERNET_DGRAM___16 = 62,
    _SC_PII_OSI_COTS___16 = 63,
    _SC_PII_OSI_CLTS___16 = 64,
    _SC_PII_OSI_M___16 = 65,
    _SC_T_IOV_MAX___16 = 66,
    _SC_THREADS___16 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___16 = 68,
    _SC_GETGR_R_SIZE_MAX___16 = 69,
    _SC_GETPW_R_SIZE_MAX___16 = 70,
    _SC_LOGIN_NAME_MAX___16 = 71,
    _SC_TTY_NAME_MAX___16 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___16 = 73,
    _SC_THREAD_KEYS_MAX___16 = 74,
    _SC_THREAD_STACK_MIN___16 = 75,
    _SC_THREAD_THREADS_MAX___16 = 76,
    _SC_THREAD_ATTR_STACKADDR___16 = 77,
    _SC_THREAD_ATTR_STACKSIZE___16 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___16 = 79,
    _SC_THREAD_PRIO_INHERIT___16 = 80,
    _SC_THREAD_PRIO_PROTECT___16 = 81,
    _SC_THREAD_PROCESS_SHARED___16 = 82,
    _SC_NPROCESSORS_CONF___16 = 83,
    _SC_NPROCESSORS_ONLN___16 = 84,
    _SC_PHYS_PAGES___16 = 85,
    _SC_AVPHYS_PAGES___16 = 86,
    _SC_ATEXIT_MAX___16 = 87,
    _SC_PASS_MAX___16 = 88,
    _SC_XOPEN_VERSION___16 = 89,
    _SC_XOPEN_XCU_VERSION___16 = 90,
    _SC_XOPEN_UNIX___16 = 91,
    _SC_XOPEN_CRYPT___16 = 92,
    _SC_XOPEN_ENH_I18N___16 = 93,
    _SC_XOPEN_SHM___16 = 94,
    _SC_2_CHAR_TERM___16 = 95,
    _SC_2_C_VERSION___16 = 96,
    _SC_2_UPE___16 = 97,
    _SC_XOPEN_XPG2___16 = 98,
    _SC_XOPEN_XPG3___16 = 99,
    _SC_XOPEN_XPG4___16 = 100,
    _SC_CHAR_BIT___16 = 101,
    _SC_CHAR_MAX___16 = 102,
    _SC_CHAR_MIN___16 = 103,
    _SC_INT_MAX___16 = 104,
    _SC_INT_MIN___16 = 105,
    _SC_LONG_BIT___16 = 106,
    _SC_WORD_BIT___16 = 107,
    _SC_MB_LEN_MAX___16 = 108,
    _SC_NZERO___16 = 109,
    _SC_SSIZE_MAX___16 = 110,
    _SC_SCHAR_MAX___16 = 111,
    _SC_SCHAR_MIN___16 = 112,
    _SC_SHRT_MAX___16 = 113,
    _SC_SHRT_MIN___16 = 114,
    _SC_UCHAR_MAX___16 = 115,
    _SC_UINT_MAX___16 = 116,
    _SC_ULONG_MAX___16 = 117,
    _SC_USHRT_MAX___16 = 118,
    _SC_NL_ARGMAX___16 = 119,
    _SC_NL_LANGMAX___16 = 120,
    _SC_NL_MSGMAX___16 = 121,
    _SC_NL_NMAX___16 = 122,
    _SC_NL_SETMAX___16 = 123,
    _SC_NL_TEXTMAX___16 = 124,
    _SC_XBS5_ILP32_OFF32___16 = 125,
    _SC_XBS5_ILP32_OFFBIG___16 = 126,
    _SC_XBS5_LP64_OFF64___16 = 127,
    _SC_XBS5_LPBIG_OFFBIG___16 = 128,
    _SC_XOPEN_LEGACY___16 = 129,
    _SC_XOPEN_REALTIME___16 = 130,
    _SC_XOPEN_REALTIME_THREADS___16 = 131,
    _SC_ADVISORY_INFO___16 = 132,
    _SC_BARRIERS___16 = 133,
    _SC_BASE___16 = 134,
    _SC_C_LANG_SUPPORT___16 = 135,
    _SC_C_LANG_SUPPORT_R___16 = 136,
    _SC_CLOCK_SELECTION___16 = 137,
    _SC_CPUTIME___16 = 138,
    _SC_THREAD_CPUTIME___16 = 139,
    _SC_DEVICE_IO___16 = 140,
    _SC_DEVICE_SPECIFIC___16 = 141,
    _SC_DEVICE_SPECIFIC_R___16 = 142,
    _SC_FD_MGMT___16 = 143,
    _SC_FIFO___16 = 144,
    _SC_PIPE___16 = 145,
    _SC_FILE_ATTRIBUTES___16 = 146,
    _SC_FILE_LOCKING___16 = 147,
    _SC_FILE_SYSTEM___16 = 148,
    _SC_MONOTONIC_CLOCK___16 = 149,
    _SC_MULTI_PROCESS___16 = 150,
    _SC_SINGLE_PROCESS___16 = 151,
    _SC_NETWORKING___16 = 152,
    _SC_READER_WRITER_LOCKS___16 = 153,
    _SC_SPIN_LOCKS___16 = 154,
    _SC_REGEXP___16 = 155,
    _SC_REGEX_VERSION___16 = 156,
    _SC_SHELL___16 = 157,
    _SC_SIGNALS___16 = 158,
    _SC_SPAWN___16 = 159,
    _SC_SPORADIC_SERVER___16 = 160,
    _SC_THREAD_SPORADIC_SERVER___16 = 161,
    _SC_SYSTEM_DATABASE___16 = 162,
    _SC_SYSTEM_DATABASE_R___16 = 163,
    _SC_TIMEOUTS___16 = 164,
    _SC_TYPED_MEMORY_OBJECTS___16 = 165,
    _SC_USER_GROUPS___16 = 166,
    _SC_USER_GROUPS_R___16 = 167,
    _SC_2_PBS___16 = 168,
    _SC_2_PBS_ACCOUNTING___16 = 169,
    _SC_2_PBS_LOCATE___16 = 170,
    _SC_2_PBS_MESSAGE___16 = 171,
    _SC_2_PBS_TRACK___16 = 172,
    _SC_SYMLOOP_MAX___16 = 173,
    _SC_STREAMS___16 = 174,
    _SC_2_PBS_CHECKPOINT___16 = 175,
    _SC_V6_ILP32_OFF32___16 = 176,
    _SC_V6_ILP32_OFFBIG___16 = 177,
    _SC_V6_LP64_OFF64___16 = 178,
    _SC_V6_LPBIG_OFFBIG___16 = 179,
    _SC_HOST_NAME_MAX___16 = 180,
    _SC_TRACE___16 = 181,
    _SC_TRACE_EVENT_FILTER___16 = 182,
    _SC_TRACE_INHERIT___16 = 183,
    _SC_TRACE_LOG___16 = 184,
    _SC_LEVEL1_ICACHE_SIZE___16 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___16 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___16 = 187,
    _SC_LEVEL1_DCACHE_SIZE___16 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___16 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___16 = 190,
    _SC_LEVEL2_CACHE_SIZE___16 = 191,
    _SC_LEVEL2_CACHE_ASSOC___16 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___16 = 193,
    _SC_LEVEL3_CACHE_SIZE___16 = 194,
    _SC_LEVEL3_CACHE_ASSOC___16 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___16 = 196,
    _SC_LEVEL4_CACHE_SIZE___16 = 197,
    _SC_LEVEL4_CACHE_ASSOC___16 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___16 = 199,
    _SC_IPV6___16 = 235,
    _SC_RAW_SOCKETS___16 = 236,
    _SC_V7_ILP32_OFF32___16 = 237,
    _SC_V7_ILP32_OFFBIG___16 = 238,
    _SC_V7_LP64_OFF64___16 = 239,
    _SC_V7_LPBIG_OFFBIG___16 = 240,
    _SC_SS_REPL_MAX___16 = 241,
    _SC_TRACE_EVENT_NAME_MAX___16 = 242,
    _SC_TRACE_NAME_MAX___16 = 243,
    _SC_TRACE_SYS_MAX___16 = 244,
    _SC_TRACE_USER_EVENT_MAX___16 = 245,
    _SC_XOPEN_STREAMS___16 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___16 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___16 = 248
} ;
#line 533
enum __anonenum_875524036___16 {
    _CS_PATH___16 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___16 = 1,
    _CS_GNU_LIBC_VERSION___16 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___16 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___16 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___16 = 5,
    _CS_LFS_CFLAGS___16 = 1000,
    _CS_LFS_LDFLAGS___16 = 1001,
    _CS_LFS_LIBS___16 = 1002,
    _CS_LFS_LINTFLAGS___16 = 1003,
    _CS_LFS64_CFLAGS___16 = 1004,
    _CS_LFS64_LDFLAGS___16 = 1005,
    _CS_LFS64_LIBS___16 = 1006,
    _CS_LFS64_LINTFLAGS___16 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___16 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___16 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___16 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___16 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___16 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___16 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___16 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___16 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___16 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___16 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___16 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___16 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___16 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___16 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___16 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___16 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___16 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___16 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___16 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___16 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___16 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___16 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___16 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___16 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___16 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___16 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___16 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___16 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___16 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___16 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___16 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___16 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___16 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___16 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___16 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___16 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___16 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___16 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___16 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___16 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___16 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___16 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___16 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___16 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___16 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___16 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___16 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___16 = 1147,
    _CS_V6_ENV___16 = 1148,
    _CS_V7_ENV___16 = 1149
} ;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   __time_t st_atime ;
   __syscall_ulong_t st_atimensec ;
   __time_t st_mtime ;
   __syscall_ulong_t st_mtimensec ;
   __time_t st_ctime ;
   __syscall_ulong_t st_ctimensec ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 165 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
struct value_list {
   char const   *name ;
   int value ;
};
#line 165 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
typedef struct value_list value_list;
#line 282 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
struct option {
   char const   *name ;
   png_uint_32 opt ;
   png_byte search ;
   png_byte value_count ;
   value_list const   *values ;
};
#line 282 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
typedef struct option option;
#line 394 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
struct stack {
   png_alloc_size_t best_size ;
   png_alloc_size_t lo_size ;
   png_alloc_size_t hi_size ;
   int lo ;
   int hi ;
   int best_val ;
   int opt_string_end ;
   png_byte opt ;
   png_byte entry ;
   png_byte end ;
};
#line 394
static option const   options[23] ;
#line 394
static option const   options[23] ;
#line 394
static option const   options[23] ;
#line 394
static option const   options[23] ;
#line 394 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
struct display___0 {
   jmp_buf error_return ;
   unsigned int errset ;
   char const   *operation ;
   char const   *filename ;
   char const   *output_file ;
   FILE *fp ;
   png_alloc_size_t read_size ;
   png_structp read_pp ;
   png_infop ip ;
   png_textp text_ptr ;
   int num_text ;
   int text_stashed ;
   png_alloc_size_t write_size ;
   png_alloc_size_t best_size ;
   png_structp write_pp ;
   png_alloc_size_t size ;
   png_uint_32 w ;
   png_uint_32 h ;
   int bpp ;
   png_byte ct ;
   int no_warnings ;
   int min_windowBits ;
   png_uint_32 results ;
   png_uint_32 options ;
   png_byte entry[sizeof(options) / sizeof(options[0])] ;
   int value[sizeof(options) / sizeof(options[0])] ;
   unsigned int csp ;
   unsigned int nsp ;
   unsigned int tsp ;
   int opt_string_start ;
   struct stack stack[8] ;
   char curr[256] ;
   char best[256] ;
   char namebuf[4096] ;
};
#line 60 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/timepng.c"
struct __anonstruct_io_data_331085666 {
   FILE *input ;
   FILE *output ;
};
#line 60 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/timepng.c"
typedef struct __anonstruct_io_data_331085666 io_data;
/* compiler builtin:
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
/* compiler builtin:
   void *__builtin_frob_return_address(void * ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __sync_and_and_fetch(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __sync_fetch_and_or(...) ;  */
/* compiler builtin:
   int __builtin_popcountll(unsigned long long  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_or_fetch(...) ;  */
/* compiler builtin:
   float __builtin_atanf(float  ) ;  */
/* compiler builtin:
   float __attribute__((____vector_size____(16)))  __builtin_ia32_addps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin:
   unsigned long __builtin_strcspn(char const   * , char const   * ) ;  */
/* compiler builtin:
   float __builtin_asinf(float  ) ;  */
/* compiler builtin:
   float __attribute__((____vector_size____(16)))  __builtin_ia32_maxps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin:
   float __attribute__((____vector_size____(16)))  __builtin_ia32_unpckhps(float __attribute__((____vector_size____(16)))   ,
                                                                           float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin:
   double __builtin_acos(double  ) ;  */
/* compiler builtin:
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_nand_fetch_8(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_fetch_and(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_xor_fetch_16(...) ;  */
/* compiler builtin:
   double __builtin_cosh(double  ) ;  */
/* compiler builtin:
   float __builtin_tanhf(float  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_fetch_nand_16(...) ;  */
/* compiler builtin:
   void *__builtin_mempcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_sub_fetch_1(...) ;  */
/* compiler builtin:
   long double __builtin_sqrtl(long double  ) ;  */
/* compiler builtin:
   int __builtin_parity(unsigned int  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_fetch_or(...) ;  */
/* compiler builtin:
   long double __builtin_coshl(long double  ) ;  */
/* compiler builtin:
   long double __builtin_cosl(long double  ) ;  */
/* compiler builtin:
   float __builtin_cosf(float  ) ;  */
/* compiler builtin:
   void __sync_synchronize(...) ;  */
/* compiler builtin:
   long double __builtin_acosl(long double  ) ;  */
/* compiler builtin:
   void *__builtin___mempcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __sync_or_and_fetch(...) ;  */
/* compiler builtin:
   int __builtin_clz(unsigned int  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_nand_fetch_4(...) ;  */
/* compiler builtin:
   double __builtin_log10(double  ) ;  */
/* compiler builtin:
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin:
   float __builtin_modff(float  , float * ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_sub_fetch_4(...) ;  */
/* compiler builtin:
   _Bool __atomic_compare_exchange_n(...) ;  */
/* compiler builtin:
   double __builtin_sin(double  ) ;  */
/* compiler builtin:
   double __builtin_frexp(double  , int * ) ;  */
/* compiler builtin:
   float __builtin_acosf(float  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __sync_add_and_fetch(...) ;  */
/* compiler builtin:
   long double __builtin_sinhl(long double  ) ;  */
/* compiler builtin:
   char *__builtin___stpcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin:
   void __atomic_signal_fence(int  ) ;  */
/* compiler builtin:
   double __builtin_fabs(double  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_fetch_nand_1(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_and_fetch_16(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __sync_fetch_and_nand(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_xor_fetch_8(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_xor_fetch_2(...) ;  */
/* compiler builtin:
   void __atomic_thread_fence(int  ) ;  */
/* compiler builtin:
   void __atomic_store_16(...) ;  */
/* compiler builtin:
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_fetch_and_8(...) ;  */
/* compiler builtin:
   short __builtin_bswap16(short  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_and_fetch_2(...) ;  */
/* compiler builtin:
   _Bool __atomic_test_and_set(void * , int  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_fetch_add_8(...) ;  */
/* compiler builtin:
   int __builtin_ctz(unsigned int  ) ;  */
/* compiler builtin:
   char *__builtin_strpbrk(char const   * , char const   * ) ;  */
/* compiler builtin:
   char *__builtin_strcpy(char * , char const   * ) ;  */
/* compiler builtin:
   double __builtin_sqrt(double  ) ;  */
/* compiler builtin:
   __builtin_va_list __builtin_next_arg(void) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_fetch_nand(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_exchange_16(...) ;  */
/* compiler builtin:
   void __atomic_clear(_Bool * , int  ) ;  */
/* compiler builtin:
   void __atomic_store(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_add_fetch_2(...) ;  */
/* compiler builtin:
   float __builtin_log10f(float  ) ;  */
/* compiler builtin:
   long double __builtin_fabsl(long double  ) ;  */
/* compiler builtin:
   long double __builtin_floorl(long double  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_fetch_xor_1(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_and_fetch(...) ;  */
/* compiler builtin:
   float __builtin_floorf(float  ) ;  */
/* compiler builtin:
   _Bool __atomic_compare_exchange_4(...) ;  */
/* compiler builtin:
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __sync_sub_and_fetch(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __sync_nand_and_fetch(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_load_16(...) ;  */
/* compiler builtin:
   float __attribute__((____vector_size____(16)))  __builtin_ia32_subps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin:
   int __builtin_parityll(unsigned long long  ) ;  */
/* compiler builtin:
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin:
   void __builtin_bzero(void * , unsigned long  ) ;  */
/* compiler builtin:
   _Bool __atomic_always_lock_free(unsigned long  , void * ) ;  */
/* compiler builtin:
   int __builtin_strncmp(char const   * , char const   * , unsigned long  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_nand_fetch_16(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __sync_xor_and_fetch(...) ;  */
/* compiler builtin:
   int __builtin___vsprintf_chk(char * , int  , unsigned long  , char const   * ,
                                __builtin_va_list  ) ;  */
/* compiler builtin:
   float __builtin_sqrtf(float  ) ;  */
/* compiler builtin:
   double __builtin_nans(char const   * ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_fetch_xor_8(...) ;  */
/* compiler builtin:
   double __builtin_exp(double  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_exchange_8(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_exchange_1(...) ;  */
/* compiler builtin:
   int __builtin_strcmp(char const   * , char const   * ) ;  */
/* compiler builtin:
   float __builtin_ldexpf(float  , int  ) ;  */
/* compiler builtin:
   float __builtin_powif(float  , int  ) ;  */
/* compiler builtin:
   long double __builtin_log10l(long double  ) ;  */
/* compiler builtin:
   void *__builtin___memmove_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __sync_fetch_and_and(...) ;  */
/* compiler builtin:
   void *__builtin_return_address(unsigned int  ) ;  */
/* compiler builtin:
   void __atomic_feraiseexcept(int  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_and_fetch_4(...) ;  */
/* compiler builtin:
   float __builtin_fabsf(float  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_or_fetch_8(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_or_fetch_4(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_or_fetch_1(...) ;  */
/* compiler builtin:
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* compiler builtin:
   void *__builtin_alloca(unsigned long  ) ;  */
/* compiler builtin:
   int __builtin_va_arg_pack_len(void) ;  */
/* compiler builtin:
   long double __builtin_tanl(long double  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_fetch_and_2(...) ;  */
/* compiler builtin:
   void __sync_lock_release(...) ;  */
/* compiler builtin:
   long double __builtin_modfl(long double  , long double * ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_fetch_nand_8(...) ;  */
/* compiler builtin:
   char *__builtin_stpcpy(char * , char const   * ) ;  */
/* compiler builtin:
   long double __builtin_sinl(long double  ) ;  */
/* compiler builtin:
   double __builtin_asin(double  ) ;  */
/* compiler builtin:
   float __builtin_sinhf(float  ) ;  */
/* compiler builtin:
   int __builtin_ctzl(unsigned long  ) ;  */
/* compiler builtin:
   long double __builtin_tanhl(long double  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_fetch_add(...) ;  */
/* compiler builtin:
   long __builtin_bswap64(long  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_nand_fetch_1(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_fetch_nand_2(...) ;  */
/* compiler builtin:
   float __attribute__((____vector_size____(16)))  __builtin_ia32_mulps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin:
   double __builtin_tan(double  ) ;  */
/* compiler builtin:
   char *__builtin_strncpy(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin:
   float __builtin_inff(void) ;  */
/* compiler builtin:
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_load_n(...) ;  */
/* compiler builtin:
   double __builtin_huge_val(void) ;  */
/* compiler builtin:
   int __builtin_clzl(unsigned long  ) ;  */
/* compiler builtin:
   _Bool __atomic_compare_exchange_16(...) ;  */
/* compiler builtin:
   float __builtin_frexpf(float  , int * ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_exchange_n(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_fetch_or_1(...) ;  */
/* compiler builtin:
   long double __builtin_fmodl(long double  ) ;  */
/* compiler builtin:
   double __builtin_atan(double  ) ;  */
/* compiler builtin:
   int __builtin___fprintf_chk(void * , int  , char const   *  , ...) ;  */
/* compiler builtin:
   float __builtin_ceilf(float  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_fetch_or_8(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_fetch_add_1(...) ;  */
/* compiler builtin:
   void __builtin_return(void const   * ) ;  */
/* compiler builtin:
   long double __builtin_asinl(long double  ) ;  */
/* compiler builtin:
   int __builtin_ffsll(unsigned long long  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_fetch_sub_1(...) ;  */
/* compiler builtin:
   int __builtin_va_arg_pack(void) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_fetch_or_4(...) ;  */
/* compiler builtin:
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin:
   double __builtin_powi(double  , int  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_load_2(...) ;  */
/* compiler builtin:
   char *__builtin_strchr(char * , int  ) ;  */
/* compiler builtin:
   char *__builtin___strncat_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin:
   void __atomic_store_2(...) ;  */
/* compiler builtin:
   long double __builtin_huge_vall(void) ;  */
/* compiler builtin:
   int __builtin_ffsl(unsigned long  ) ;  */
/* compiler builtin:
   int __builtin___vprintf_chk(int  , char const   * , __builtin_va_list  ) ;  */
/* compiler builtin:
   float __attribute__((____vector_size____(16)))  __builtin_ia32_unpcklps(float __attribute__((____vector_size____(16)))   ,
                                                                           float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin:
   char *__builtin_strncat(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin:
   int __builtin_ctzll(unsigned long long  ) ;  */
/* compiler builtin:
   void __builtin_stdarg_start(__builtin_va_list  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_exchange_4(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __sync_fetch_and_xor(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_fetch_sub_4(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_fetch_and_4(...) ;  */
/* compiler builtin:
   long double __builtin_frexpl(long double  , int * ) ;  */
/* compiler builtin:
   _Bool __atomic_compare_exchange(...) ;  */
/* compiler builtin:
   float __builtin_tanf(float  ) ;  */
/* compiler builtin:
   long double __builtin_logl(long double  ) ;  */
/* compiler builtin:
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin:
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_load_1(...) ;  */
/* compiler builtin:
   _Bool __atomic_compare_exchange_1(...) ;  */
/* compiler builtin:
   int __builtin___printf_chk(int  , char const   *  , ...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_fetch_xor_2(...) ;  */
/* compiler builtin:
   int __builtin___vfprintf_chk(void * , int  , char const   * , __builtin_va_list  ) ;  */
/* compiler builtin:
   void __builtin_prefetch(void const   *  , ...) ;  */
/* compiler builtin:
   long double __builtin_nansl(char const   * ) ;  */
/* compiler builtin:
   double __builtin_fmod(double  ) ;  */
/* compiler builtin:
   void __atomic_load(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_or_fetch_16(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_add_fetch_16(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __sync_val_compare_and_swap(...) ;  */
/* compiler builtin:
   void __atomic_store_4(...) ;  */
/* compiler builtin:
   double __builtin_tanh(double  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_fetch_and_1(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_fetch_nand_4(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_fetch_add_16(...) ;  */
/* compiler builtin:
   void __builtin_unreachable(void) ;  */
/* compiler builtin:
   _Bool __atomic_compare_exchange_2(...) ;  */
/* compiler builtin:
   long double __builtin_ldexpl(long double  , int  ) ;  */
/* compiler builtin:
   void *__builtin_apply(void (*)() , void * , unsigned long  ) ;  */
/* compiler builtin:
   float __builtin_sinf(float  ) ;  */
/* compiler builtin:
   double __builtin_ceil(double  ) ;  */
/* compiler builtin:
   void __atomic_exchange(...) ;  */
/* compiler builtin:
   long double __builtin_powil(long double  , int  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_sub_fetch_8(...) ;  */
/* compiler builtin:
   long double __builtin_expl(long double  ) ;  */
/* compiler builtin:
   int __builtin_constant_p(int  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_fetch_sub_16(...) ;  */
/* compiler builtin:
   double __builtin_log(double  ) ;  */
/* compiler builtin:
   float __builtin_expf(float  ) ;  */
/* compiler builtin:
   int __builtin_types_compatible_p(unsigned long  , unsigned long  ) ;  */
/* compiler builtin:
   long double __builtin_atan2l(long double  , long double  ) ;  */
/* compiler builtin:
   void *__builtin_apply_args(void) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_exchange_2(...) ;  */
/* compiler builtin:
   float __builtin_logf(float  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_sub_fetch_2(...) ;  */
/* compiler builtin:
   unsigned long __builtin_strlen(char const   * ) ;  */
/* compiler builtin:
   int __builtin_ffs(unsigned int  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_fetch_xor_16(...) ;  */
/* compiler builtin:
   double __builtin_inf(void) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_fetch_or_16(...) ;  */
/* compiler builtin:
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_load_4(...) ;  */
/* compiler builtin:
   void __atomic_store_n(...) ;  */
/* compiler builtin:
   void __builtin_trap(void) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_fetch_add_4(...) ;  */
/* compiler builtin:
   int __builtin_parityl(unsigned long  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_nand_fetch_2(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __sync_lock_test_and_set(...) ;  */
/* compiler builtin:
   unsigned long __builtin_strspn(char const   * , char const   * ) ;  */
/* compiler builtin:
   void __builtin_varargs_start(__builtin_va_list  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_sub_fetch(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_fetch_and_16(...) ;  */
/* compiler builtin:
   _Bool __atomic_compare_exchange_8(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_nand_fetch(...) ;  */
/* compiler builtin:
   double __builtin_nan(char const   * ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_load_8(...) ;  */
/* compiler builtin:
   int __builtin___snprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                char const   *  , ...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_xor_fetch_4(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_fetch_sub_2(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_add_fetch(...) ;  */
/* compiler builtin:
   long double __builtin_atanl(long double  ) ;  */
/* compiler builtin:
   int __builtin_clzll(unsigned long long  ) ;  */
/* compiler builtin:
   float __builtin_huge_valf(void) ;  */
/* compiler builtin:
   float __builtin_coshf(float  ) ;  */
/* compiler builtin:
   float __builtin_nansf(char const   * ) ;  */
/* compiler builtin:
   void __atomic_store_8(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_xor_fetch(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __sync_fetch_and_add(...) ;  */
/* compiler builtin:
   int __builtin___vsnprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                 char const   * , __builtin_va_list  ) ;  */
/* compiler builtin:
   float __builtin_nanf(char const   * ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_or_fetch_2(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_add_fetch_1(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_fetch_xor(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_add_fetch_8(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_fetch_xor_4(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_fetch_sub_8(...) ;  */
/* compiler builtin:
   _Bool __sync_bool_compare_and_swap(...) ;  */
/* compiler builtin:
   double __builtin_atan2(double  , double  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __builtin_tgmath(...) ;  */
/* compiler builtin:
   int __builtin_popcountl(unsigned long  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_and_fetch_1(...) ;  */
/* compiler builtin:
   long double __builtin_ceill(long double  ) ;  */
/* compiler builtin:
   void __atomic_store_1(...) ;  */
/* compiler builtin:
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_xor_fetch_1(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_fetch_or_2(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_sub_fetch_16(...) ;  */
/* compiler builtin:
   double __builtin_floor(double  ) ;  */
/* compiler builtin:
   double __builtin_cos(double  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __sync_fetch_and_sub(...) ;  */
/* compiler builtin:
   void *__builtin_memset(void * , int  , int  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_fetch_add_2(...) ;  */
/* compiler builtin:
   long double __builtin_nanl(char const   * ) ;  */
/* compiler builtin:
   float __builtin_atan2f(float  , float  ) ;  */
/* compiler builtin:
   _Bool __atomic_is_lock_free(unsigned long  , void * ) ;  */
/* compiler builtin:
   int __builtin_popcount(unsigned int  ) ;  */
/* compiler builtin:
   double __builtin_sinh(double  ) ;  */
/* compiler builtin:
   void __builtin_bcopy(void const   * , void * , unsigned long  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_and_fetch_8(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_fetch_sub(...) ;  */
/* compiler builtin:
   void *__builtin_extract_return_addr(void * ) ;  */
/* compiler builtin:
   int __builtin_bswap32(int  ) ;  */
/* compiler builtin:
   double __builtin_ldexp(double  , int  ) ;  */
/* compiler builtin:
   long double __builtin_infl(void) ;  */
/* compiler builtin:
   float __builtin_fmodf(float  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_add_fetch_4(...) ;  */
/* compiler builtin:
   void *__builtin_frame_address(unsigned int  ) ;  */
#line 6 "lib/libc/stub/src/stdlib.c"
void ( __attribute__((__nonnull__(1,4))) qsort)(void *ptr , size_t count , size_t size ,
                                                int (*comp)(void const   * , void const   * ) )  __attribute__((__goblint_stub__)) ;
#line 7
void ( __attribute__((__nonnull__(1,4))) qsort)(void *ptr , size_t count , size_t size ,
                                                int (*comp)(void const   * , void const   * ) )  __attribute__((__goblint_stub__)) ;
#line 7 "lib/libc/stub/src/stdlib.c"
void ( __attribute__((__nonnull__(1,4))) qsort)(void *ptr , size_t count , size_t size ,
                                                int (*comp)(void const   * , void const   * ) )
{
  size_t i ;
  size_t j ;
  size_t i___0 ;
  size_t j___0 ;
  int r ;
  size_t k ;
  char *a ;
  char *b ;
  char c ;

  {
#line 9
  i = (size_t )0;
  {
#line 9
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9
    if (! (i < count)) {
#line 9
      goto while_break;
    }
#line 10
    j = (size_t )0;
    {
#line 10
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 10
      if (! (j < count)) {
#line 10
        goto while_break___0;
      }
#line 11
      (*comp)((void const   *)(ptr + i * size), (void const   *)(ptr + j * size));
#line 10
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 9
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 16
  i___0 = (size_t )0;
  {
#line 16
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 16
    if (! (i___0 < count)) {
#line 16
      goto while_break___1;
    }
#line 17
    j___0 = (size_t )0;
    {
#line 17
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 17
      if (! (j___0 < count)) {
#line 17
        goto while_break___2;
      }
#line 19
      if (r) {
#line 21
        k = (size_t )0;
        {
#line 21
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 21
          if (! (k < size)) {
#line 21
            goto while_break___3;
          }
#line 22
          a = (char *)((ptr + i___0 * size) + k);
#line 23
          b = (char *)((ptr + j___0 * size) + k);
#line 24
          c = *a;
#line 25
          *a = *b;
#line 26
          *b = c;
#line 21
          k ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 17
      j___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 16
    i___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 33
  return;
}
}
#line 37
void *bsearch(void const   *key___3 , void const   *ptr , size_t count , size_t size ,
              int (*comp)(void const   * , void const   * ) )  __attribute__((__goblint_stub__)) ;
#line 38
void *bsearch(void const   *key___3 , void const   *ptr , size_t count , size_t size ,
              int (*comp)(void const   * , void const   * ) )  __attribute__((__goblint_stub__)) ;
#line 38 "lib/libc/stub/src/stdlib.c"
void *bsearch(void const   *key___3 , void const   *ptr , size_t count , size_t size ,
              int (*comp)(void const   * , void const   * ) )
{
  size_t i ;
  void const   *a ;
  int tmp ;

  {
#line 40
  i = (size_t )0;
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! (i < count)) {
#line 40
      goto while_break;
    }
#line 41
    a = ptr + i * size;
#line 42
    tmp = (*comp)(key___3, a);
#line 42
    if (tmp == 0) {
#line 43
      return ((void *)a);
    }
#line 40
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  return ((void *)0);
}
}
#line 117 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
extern int ( __attribute__((__leaf__)) __sched_cpucount)(size_t __setsize , cpu_set_t const   *__setp )  __attribute__((__nothrow__)) ;
#line 119
extern cpu_set_t *( __attribute__((__leaf__)) __sched_cpualloc)(size_t __count )  __attribute__((__nothrow__)) ;
#line 120
extern void ( __attribute__((__leaf__)) __sched_cpufree)(cpu_set_t *__set )  __attribute__((__nothrow__)) ;
#line 54 "/usr/include/sched.h"
extern int ( __attribute__((__leaf__)) sched_setparam)(__pid_t __pid , struct sched_param  const  *__param )  __attribute__((__nothrow__)) ;
#line 58
extern int ( __attribute__((__leaf__)) sched_getparam)(__pid_t __pid , struct sched_param *__param )  __attribute__((__nothrow__)) ;
#line 61
extern int ( __attribute__((__leaf__)) sched_setscheduler)(__pid_t __pid , int __policy ,
                                                           struct sched_param  const  *__param )  __attribute__((__nothrow__)) ;
#line 65
extern int ( __attribute__((__leaf__)) sched_getscheduler)(__pid_t __pid )  __attribute__((__nothrow__)) ;
#line 68
extern int ( __attribute__((__leaf__)) sched_yield)(void)  __attribute__((__nothrow__)) ;
#line 71
extern int ( __attribute__((__leaf__)) sched_get_priority_max)(int __algorithm )  __attribute__((__nothrow__)) ;
#line 74
extern int ( __attribute__((__leaf__)) sched_get_priority_min)(int __algorithm )  __attribute__((__nothrow__)) ;
#line 77
extern int ( __attribute__((__leaf__)) sched_rr_get_interval)(__pid_t __pid , struct timespec *__t )  __attribute__((__nothrow__)) ;
#line 72 "/usr/include/time.h"
extern clock_t ( __attribute__((__leaf__)) clock)(void)  __attribute__((__nothrow__)) ;
#line 75
extern time_t ( __attribute__((__leaf__)) time)(time_t *__timer )  __attribute__((__nothrow__)) ;
#line 78
extern double ( __attribute__((__leaf__)) difftime)(time_t __time1 , time_t __time0 )  __attribute__((__nothrow__,
__const__)) ;
#line 82
extern time_t ( __attribute__((__leaf__)) mktime)(struct tm *__tp )  __attribute__((__nothrow__)) ;
#line 88
extern size_t ( __attribute__((__leaf__)) strftime)(char *__s , size_t __maxsize ,
                                                    char const   *__format , struct tm  const  *__tp )  __attribute__((__nothrow__)) ;
#line 104
extern size_t ( __attribute__((__leaf__)) strftime_l)(char *__s , size_t __maxsize ,
                                                      char const   *__format , struct tm  const  *__tp ,
                                                      locale_t __loc )  __attribute__((__nothrow__)) ;
#line 119
extern struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer )  __attribute__((__nothrow__)) ;
#line 123
extern struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer )  __attribute__((__nothrow__)) ;
#line 128
extern struct tm *( __attribute__((__leaf__)) gmtime_r)(time_t const   *__timer ,
                                                        struct tm *__tp )  __attribute__((__nothrow__)) ;
#line 133
extern struct tm *( __attribute__((__leaf__)) localtime_r)(time_t const   *__timer ,
                                                           struct tm *__tp )  __attribute__((__nothrow__)) ;
#line 139
extern char *( __attribute__((__leaf__)) asctime)(struct tm  const  *__tp )  __attribute__((__nothrow__)) ;
#line 142
extern char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer )  __attribute__((__nothrow__)) ;
#line 149
extern char *( __attribute__((__leaf__)) asctime_r)(struct tm  const  *__tp , char *__buf )  __attribute__((__nothrow__)) ;
#line 153
extern char *( __attribute__((__leaf__)) ctime_r)(time_t const   *__timer , char *__buf )  __attribute__((__nothrow__)) ;
#line 159
extern char *__tzname[2] ;
#line 160
extern int __daylight ;
#line 161
extern long __timezone ;
#line 166
extern char *tzname[2] ;
#line 170
extern void ( __attribute__((__leaf__)) tzset)(void)  __attribute__((__nothrow__)) ;
#line 174
extern int daylight ;
#line 175
extern long timezone ;
#line 190
extern time_t ( __attribute__((__leaf__)) timegm)(struct tm *__tp )  __attribute__((__nothrow__)) ;
#line 193
extern time_t ( __attribute__((__leaf__)) timelocal)(struct tm *__tp )  __attribute__((__nothrow__)) ;
#line 196
extern int ( __attribute__((__leaf__)) dysize)(int __year )  __attribute__((__nothrow__,
__const__)) ;
#line 205
extern int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
#line 210
extern int ( __attribute__((__leaf__)) clock_getres)(clockid_t __clock_id , struct timespec *__res )  __attribute__((__nothrow__)) ;
#line 213
extern int ( __attribute__((__leaf__)) clock_gettime)(clockid_t __clock_id , struct timespec *__tp )  __attribute__((__nothrow__)) ;
#line 216
extern int ( __attribute__((__leaf__)) clock_settime)(clockid_t __clock_id , struct timespec  const  *__tp )  __attribute__((__nothrow__)) ;
#line 224
extern int clock_nanosleep(clockid_t __clock_id , int __flags , struct timespec  const  *__req ,
                           struct timespec *__rem ) ;
#line 229
extern int ( __attribute__((__leaf__)) clock_getcpuclockid)(pid_t __pid , clockid_t *__clock_id )  __attribute__((__nothrow__)) ;
#line 234
extern int ( __attribute__((__leaf__)) timer_create)(clockid_t __clock_id , struct sigevent *__evp ,
                                                     timer_t *__timerid )  __attribute__((__nothrow__)) ;
#line 239
extern int ( __attribute__((__leaf__)) timer_delete)(timer_t __timerid )  __attribute__((__nothrow__)) ;
#line 242
extern int ( __attribute__((__leaf__)) timer_settime)(timer_t __timerid , int __flags ,
                                                      struct itimerspec  const  *__value ,
                                                      struct itimerspec *__ovalue )  __attribute__((__nothrow__)) ;
#line 247
extern int ( __attribute__((__leaf__)) timer_gettime)(timer_t __timerid , struct itimerspec *__value )  __attribute__((__nothrow__)) ;
#line 251
extern int ( __attribute__((__leaf__)) timer_getoverrun)(timer_t __timerid )  __attribute__((__nothrow__)) ;
#line 257
extern int ( __attribute__((__nonnull__(1), __leaf__)) timespec_get)(struct timespec *__ts ,
                                                                     int __base )  __attribute__((__nothrow__)) ;
#line 198 "/usr/include/pthread.h"
extern int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                               pthread_attr_t const   * __restrict  __attr ,
                                                               void *(*__start_routine)(void * ) ,
                                                               void * __restrict  __arg )  __attribute__((__nothrow__)) ;
#line 207
extern void pthread_exit(void *__retval )  __attribute__((__noreturn__)) ;
#line 215
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 247
extern int ( __attribute__((__leaf__)) pthread_detach)(pthread_t __th )  __attribute__((__nothrow__)) ;
#line 251
extern pthread_t ( __attribute__((__leaf__)) pthread_self)(void)  __attribute__((__nothrow__,
__const__)) ;
#line 254
extern int ( __attribute__((__leaf__)) pthread_equal)(pthread_t __thread1 , pthread_t __thread2 )  __attribute__((__nothrow__,
__const__)) ;
#line 263
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_init)(pthread_attr_t *__attr )  __attribute__((__nothrow__)) ;
#line 266
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_destroy)(pthread_attr_t *__attr )  __attribute__((__nothrow__)) ;
#line 270
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getdetachstate)(pthread_attr_t const   *__attr ,
                                                                                      int *__detachstate )  __attribute__((__nothrow__)) ;
#line 275
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setdetachstate)(pthread_attr_t *__attr ,
                                                                                    int __detachstate )  __attribute__((__nothrow__)) ;
#line 281
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getguardsize)(pthread_attr_t const   *__attr ,
                                                                                    size_t *__guardsize )  __attribute__((__nothrow__)) ;
#line 286
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setguardsize)(pthread_attr_t *__attr ,
                                                                                  size_t __guardsize )  __attribute__((__nothrow__)) ;
#line 292
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getschedparam)(pthread_attr_t const   * __restrict  __attr ,
                                                                                     struct sched_param * __restrict  __param )  __attribute__((__nothrow__)) ;
#line 297
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_setschedparam)(pthread_attr_t * __restrict  __attr ,
                                                                                     struct sched_param  const  * __restrict  __param )  __attribute__((__nothrow__)) ;
#line 302
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getschedpolicy)(pthread_attr_t const   * __restrict  __attr ,
                                                                                      int * __restrict  __policy )  __attribute__((__nothrow__)) ;
#line 307
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setschedpolicy)(pthread_attr_t *__attr ,
                                                                                    int __policy )  __attribute__((__nothrow__)) ;
#line 311
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getinheritsched)(pthread_attr_t const   * __restrict  __attr ,
                                                                                       int * __restrict  __inherit )  __attribute__((__nothrow__)) ;
#line 316
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setinheritsched)(pthread_attr_t *__attr ,
                                                                                     int __inherit )  __attribute__((__nothrow__)) ;
#line 322
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getscope)(pthread_attr_t const   * __restrict  __attr ,
                                                                                int * __restrict  __scope )  __attribute__((__nothrow__)) ;
#line 327
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setscope)(pthread_attr_t *__attr ,
                                                                              int __scope )  __attribute__((__nothrow__)) ;
#line 331
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getstackaddr)(pthread_attr_t const   * __restrict  __attr ,
                                                                                    void ** __restrict  __stackaddr )  __attribute__((__nothrow__,
__deprecated__)) ;
#line 339
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setstackaddr)(pthread_attr_t *__attr ,
                                                                                  void *__stackaddr )  __attribute__((__nothrow__,
__deprecated__)) ;
#line 344
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getstacksize)(pthread_attr_t const   * __restrict  __attr ,
                                                                                    size_t * __restrict  __stacksize )  __attribute__((__nothrow__)) ;
#line 351
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setstacksize)(pthread_attr_t *__attr ,
                                                                                  size_t __stacksize )  __attribute__((__nothrow__)) ;
#line 357
extern int ( __attribute__((__nonnull__(1,2,3), __leaf__)) pthread_attr_getstack)(pthread_attr_t const   * __restrict  __attr ,
                                                                                  void ** __restrict  __stackaddr ,
                                                                                  size_t * __restrict  __stacksize )  __attribute__((__nothrow__)) ;
#line 365
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setstack)(pthread_attr_t *__attr ,
                                                                              void *__stackaddr ,
                                                                              size_t __stacksize )  __attribute__((__nothrow__)) ;
#line 405
extern int ( __attribute__((__nonnull__(3), __leaf__)) pthread_setschedparam)(pthread_t __target_thread ,
                                                                              int __policy ,
                                                                              struct sched_param  const  *__param )  __attribute__((__nothrow__)) ;
#line 410
extern int ( __attribute__((__nonnull__(2,3), __leaf__)) pthread_getschedparam)(pthread_t __target_thread ,
                                                                                int * __restrict  __policy ,
                                                                                struct sched_param * __restrict  __param )  __attribute__((__nothrow__)) ;
#line 416
extern int ( __attribute__((__leaf__)) pthread_setschedprio)(pthread_t __target_thread ,
                                                             int __prio )  __attribute__((__nothrow__)) ;
#line 470
int ( __attribute__((__nonnull__(1,2))) pthread_once)(pthread_once_t *once_control ,
                                                      void (*init_routine)(void) )  __attribute__((__goblint_stub__)) ;
#line 482
extern int pthread_setcancelstate(int __state , int *__oldstate ) ;
#line 486
extern int pthread_setcanceltype(int __type , int *__oldtype ) ;
#line 489
extern int pthread_cancel(pthread_t __th ) ;
#line 494
extern void pthread_testcancel(void) ;
#line 656
extern void __pthread_register_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 668
extern void __pthread_unregister_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 709
extern void __pthread_unwind_next(__pthread_unwind_buf_t *__buf )  __attribute__((__weak__,
__noreturn__)) ;
#line 719
extern int __sigsetjmp(struct __jmp_buf_tag *__env , int __savemask )  __attribute__((__nothrow__)) ;
#line 725
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                           pthread_mutexattr_t const   *__mutexattr )  __attribute__((__nothrow__)) ;
#line 730
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_destroy)(pthread_mutex_t *__mutex )  __attribute__((__nothrow__)) ;
#line 734
extern int ( __attribute__((__nonnull__(1))) pthread_mutex_trylock)(pthread_mutex_t *__mutex )  __attribute__((__nothrow__)) ;
#line 738
extern int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex )  __attribute__((__nothrow__)) ;
#line 743
extern int ( __attribute__((__nonnull__(1,2))) pthread_mutex_timedlock)(pthread_mutex_t * __restrict  __mutex ,
                                                                        struct timespec  const  * __restrict  __abstime )  __attribute__((__nothrow__)) ;
#line 756
extern int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex )  __attribute__((__nothrow__)) ;
#line 761
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_mutex_getprioceiling)(pthread_mutex_t const   * __restrict  __mutex ,
                                                                                       int * __restrict  __prioceiling )  __attribute__((__nothrow__)) ;
#line 768
extern int ( __attribute__((__nonnull__(1,3), __leaf__)) pthread_mutex_setprioceiling)(pthread_mutex_t * __restrict  __mutex ,
                                                                                       int __prioceiling ,
                                                                                       int * __restrict  __old_ceiling )  __attribute__((__nothrow__)) ;
#line 776
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_consistent)(pthread_mutex_t *__mutex )  __attribute__((__nothrow__)) ;
#line 789
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_init)(pthread_mutexattr_t *__attr )  __attribute__((__nothrow__)) ;
#line 793
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_destroy)(pthread_mutexattr_t *__attr )  __attribute__((__nothrow__)) ;
#line 797
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_mutexattr_getpshared)(pthread_mutexattr_t const   * __restrict  __attr ,
                                                                                       int * __restrict  __pshared )  __attribute__((__nothrow__)) ;
#line 803
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_setpshared)(pthread_mutexattr_t *__attr ,
                                                                                     int __pshared )  __attribute__((__nothrow__)) ;
#line 809
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_mutexattr_gettype)(pthread_mutexattr_t const   * __restrict  __attr ,
                                                                                    int * __restrict  __kind )  __attribute__((__nothrow__)) ;
#line 816
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_settype)(pthread_mutexattr_t *__attr ,
                                                                                  int __kind )  __attribute__((__nothrow__)) ;
#line 821
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_mutexattr_getprotocol)(pthread_mutexattr_t const   * __restrict  __attr ,
                                                                                        int * __restrict  __protocol )  __attribute__((__nothrow__)) ;
#line 828
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_setprotocol)(pthread_mutexattr_t *__attr ,
                                                                                      int __protocol )  __attribute__((__nothrow__)) ;
#line 833
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_mutexattr_getprioceiling)(pthread_mutexattr_t const   * __restrict  __attr ,
                                                                                           int * __restrict  __prioceiling )  __attribute__((__nothrow__)) ;
#line 839
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_setprioceiling)(pthread_mutexattr_t *__attr ,
                                                                                         int __prioceiling )  __attribute__((__nothrow__)) ;
#line 845
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_mutexattr_getrobust)(pthread_mutexattr_t const   *__attr ,
                                                                                      int *__robustness )  __attribute__((__nothrow__)) ;
#line 855
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutexattr_setrobust)(pthread_mutexattr_t *__attr ,
                                                                                    int __robustness )  __attribute__((__nothrow__)) ;
#line 871
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlock_init)(pthread_rwlock_t * __restrict  __rwlock ,
                                                                            pthread_rwlockattr_t const   * __restrict  __attr )  __attribute__((__nothrow__)) ;
#line 876
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlock_destroy)(pthread_rwlock_t *__rwlock )  __attribute__((__nothrow__)) ;
#line 880
extern int ( __attribute__((__nonnull__(1))) pthread_rwlock_rdlock)(pthread_rwlock_t *__rwlock )  __attribute__((__nothrow__)) ;
#line 884
extern int ( __attribute__((__nonnull__(1))) pthread_rwlock_tryrdlock)(pthread_rwlock_t *__rwlock )  __attribute__((__nothrow__)) ;
#line 889
extern int ( __attribute__((__nonnull__(1,2))) pthread_rwlock_timedrdlock)(pthread_rwlock_t * __restrict  __rwlock ,
                                                                           struct timespec  const  * __restrict  __abstime )  __attribute__((__nothrow__)) ;
#line 902
extern int ( __attribute__((__nonnull__(1))) pthread_rwlock_wrlock)(pthread_rwlock_t *__rwlock )  __attribute__((__nothrow__)) ;
#line 906
extern int ( __attribute__((__nonnull__(1))) pthread_rwlock_trywrlock)(pthread_rwlock_t *__rwlock )  __attribute__((__nothrow__)) ;
#line 911
extern int ( __attribute__((__nonnull__(1,2))) pthread_rwlock_timedwrlock)(pthread_rwlock_t * __restrict  __rwlock ,
                                                                           struct timespec  const  * __restrict  __abstime )  __attribute__((__nothrow__)) ;
#line 924
extern int ( __attribute__((__nonnull__(1))) pthread_rwlock_unlock)(pthread_rwlock_t *__rwlock )  __attribute__((__nothrow__)) ;
#line 931
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlockattr_init)(pthread_rwlockattr_t *__attr )  __attribute__((__nothrow__)) ;
#line 935
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlockattr_destroy)(pthread_rwlockattr_t *__attr )  __attribute__((__nothrow__)) ;
#line 939
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_rwlockattr_getpshared)(pthread_rwlockattr_t const   * __restrict  __attr ,
                                                                                        int * __restrict  __pshared )  __attribute__((__nothrow__)) ;
#line 945
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlockattr_setpshared)(pthread_rwlockattr_t *__attr ,
                                                                                      int __pshared )  __attribute__((__nothrow__)) ;
#line 950
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_rwlockattr_getkind_np)(pthread_rwlockattr_t const   * __restrict  __attr ,
                                                                                        int * __restrict  __pref )  __attribute__((__nothrow__)) ;
#line 956
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_rwlockattr_setkind_np)(pthread_rwlockattr_t *__attr ,
                                                                                      int __pref )  __attribute__((__nothrow__)) ;
#line 965
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_cond_init)(pthread_cond_t * __restrict  __cond ,
                                                                          pthread_condattr_t const   * __restrict  __cond_attr )  __attribute__((__nothrow__)) ;
#line 970
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_cond_destroy)(pthread_cond_t *__cond )  __attribute__((__nothrow__)) ;
#line 974
extern int ( __attribute__((__nonnull__(1))) pthread_cond_signal)(pthread_cond_t *__cond )  __attribute__((__nothrow__)) ;
#line 978
extern int ( __attribute__((__nonnull__(1))) pthread_cond_broadcast)(pthread_cond_t *__cond )  __attribute__((__nothrow__)) ;
#line 986
extern int ( __attribute__((__nonnull__(1,2))) pthread_cond_wait)(pthread_cond_t * __restrict  __cond ,
                                                                  pthread_mutex_t * __restrict  __mutex ) ;
#line 997
extern int ( __attribute__((__nonnull__(1,2,3))) pthread_cond_timedwait)(pthread_cond_t * __restrict  __cond ,
                                                                         pthread_mutex_t * __restrict  __mutex ,
                                                                         struct timespec  const  * __restrict  __abstime ) ;
#line 1020
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_condattr_init)(pthread_condattr_t *__attr )  __attribute__((__nothrow__)) ;
#line 1024
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_condattr_destroy)(pthread_condattr_t *__attr )  __attribute__((__nothrow__)) ;
#line 1028
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_condattr_getpshared)(pthread_condattr_t const   * __restrict  __attr ,
                                                                                      int * __restrict  __pshared )  __attribute__((__nothrow__)) ;
#line 1034
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_condattr_setpshared)(pthread_condattr_t *__attr ,
                                                                                    int __pshared )  __attribute__((__nothrow__)) ;
#line 1039
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_condattr_getclock)(pthread_condattr_t const   * __restrict  __attr ,
                                                                                    __clockid_t * __restrict  __clock_id )  __attribute__((__nothrow__)) ;
#line 1045
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_condattr_setclock)(pthread_condattr_t *__attr ,
                                                                                  __clockid_t __clock_id )  __attribute__((__nothrow__)) ;
#line 1056
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_spin_init)(pthread_spinlock_t *__lock ,
                                                                          int __pshared )  __attribute__((__nothrow__)) ;
#line 1060
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_spin_destroy)(pthread_spinlock_t *__lock )  __attribute__((__nothrow__)) ;
#line 1064
extern int ( __attribute__((__nonnull__(1))) pthread_spin_lock)(pthread_spinlock_t *__lock )  __attribute__((__nothrow__)) ;
#line 1068
extern int ( __attribute__((__nonnull__(1))) pthread_spin_trylock)(pthread_spinlock_t *__lock )  __attribute__((__nothrow__)) ;
#line 1072
extern int ( __attribute__((__nonnull__(1))) pthread_spin_unlock)(pthread_spinlock_t *__lock )  __attribute__((__nothrow__)) ;
#line 1080
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_barrier_init)(pthread_barrier_t * __restrict  __barrier ,
                                                                             pthread_barrierattr_t const   * __restrict  __attr ,
                                                                             unsigned int __count )  __attribute__((__nothrow__)) ;
#line 1086
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_barrier_destroy)(pthread_barrier_t *__barrier )  __attribute__((__nothrow__)) ;
#line 1090
extern int ( __attribute__((__nonnull__(1))) pthread_barrier_wait)(pthread_barrier_t *__barrier )  __attribute__((__nothrow__)) ;
#line 1095
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_barrierattr_init)(pthread_barrierattr_t *__attr )  __attribute__((__nothrow__)) ;
#line 1099
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_barrierattr_destroy)(pthread_barrierattr_t *__attr )  __attribute__((__nothrow__)) ;
#line 1103
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_barrierattr_getpshared)(pthread_barrierattr_t const   * __restrict  __attr ,
                                                                                         int * __restrict  __pshared )  __attribute__((__nothrow__)) ;
#line 1109
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_barrierattr_setpshared)(pthread_barrierattr_t *__attr ,
                                                                                       int __pshared )  __attribute__((__nothrow__)) ;
#line 1123
extern int ( __attribute__((__nonnull__(1), __leaf__)) pthread_key_create)(pthread_key_t *__key ,
                                                                           void (*__destr_function)(void * ) )  __attribute__((__nothrow__)) ;
#line 1128
extern int ( __attribute__((__leaf__)) pthread_key_delete)(pthread_key_t __key )  __attribute__((__nothrow__)) ;
#line 1131
extern void *( __attribute__((__leaf__)) pthread_getspecific)(pthread_key_t __key )  __attribute__((__nothrow__)) ;
#line 1134
extern int ( __attribute__((__leaf__)) pthread_setspecific)(pthread_key_t __key ,
                                                            void const   *__pointer )  __attribute__((__nothrow__)) ;
#line 1140
extern int ( __attribute__((__nonnull__(2), __leaf__)) pthread_getcpuclockid)(pthread_t __thread_id ,
                                                                              __clockid_t *__clock_id )  __attribute__((__nothrow__)) ;
#line 1157
extern int ( __attribute__((__leaf__)) pthread_atfork)(void (*__prepare)(void) , void (*__parent)(void) ,
                                                       void (*__child)(void) )  __attribute__((__nothrow__)) ;
#line 5 "lib/libc/stub/src/pthread.c"
int ( __attribute__((__nonnull__(1,2))) pthread_once)(pthread_once_t *once_control ,
                                                      void (*init_routine)(void) )  __attribute__((__goblint_stub__)) ;
#line 5 "lib/libc/stub/src/pthread.c"
int ( __attribute__((__nonnull__(1,2))) pthread_once)(pthread_once_t *once_control ,
                                                      void (*init_routine)(void) )
{
  int top ;

  {
#line 8
  (*init_routine)();
#line 9
  return (top);
}
}
#line 97 "/usr/include/stdlib.h"
extern size_t ( __attribute__((__warn_unused_result__, __leaf__)) __ctype_get_mb_cur_max)(void)  __attribute__((__nothrow__)) ;
#line 101
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 104
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 107
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 112
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__leaf__, __gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__,
__nothrow__)) ;
#line 117
extern double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   *__nptr ,
                                                                  char **__endptr )  __attribute__((__nothrow__)) ;
#line 123
extern float ( __attribute__((__nonnull__(1), __leaf__)) strtof)(char const   *__nptr ,
                                                                 char **__endptr )  __attribute__((__nothrow__)) ;
#line 126
extern long double ( __attribute__((__nonnull__(1), __leaf__)) strtold)(char const   *__nptr ,
                                                                        char **__endptr )  __attribute__((__nothrow__)) ;
#line 176
extern long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   *__nptr ,
                                                                char **__endptr ,
                                                                int __base )  __attribute__((__nothrow__)) ;
#line 180
extern unsigned long ( __attribute__((__nonnull__(1), __leaf__)) strtoul)(char const   *__nptr ,
                                                                          char **__endptr ,
                                                                          int __base )  __attribute__((__nothrow__)) ;
#line 200
extern long long ( __attribute__((__nonnull__(1), __leaf__)) strtoll)(char const   *__nptr ,
                                                                      char **__endptr ,
                                                                      int __base )  __attribute__((__nothrow__)) ;
#line 205
extern unsigned long long ( __attribute__((__nonnull__(1), __leaf__)) strtoull)(char const   *__nptr ,
                                                                                char **__endptr ,
                                                                                int __base )  __attribute__((__nothrow__)) ;
#line 360
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 360 "/usr/include/stdlib.h"
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atoi)(char const   *__nptr )
{
  long tmp ;

  {
#line 363
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
#line 363
  return ((int )tmp);
}
}
#line 365
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 365 "/usr/include/stdlib.h"
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atol)(char const   *__nptr )
{
  long tmp ;

  {
#line 368
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
#line 368
  return (tmp);
}
}
#line 372
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__leaf__, __gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__,
__nothrow__)) ;
#line 372 "/usr/include/stdlib.h"
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__leaf__, __gnu_inline__)) atoll)(char const   *__nptr )
{
  long long tmp ;

  {
#line 375
  tmp = strtoll((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                10);
#line 375
  return (tmp);
}
}
#line 453
extern int ( __attribute__((__leaf__)) rand)(void)  __attribute__((__nothrow__)) ;
#line 455
extern void ( __attribute__((__leaf__)) srand)(unsigned int __seed )  __attribute__((__nothrow__)) ;
#line 539
extern void *( __attribute__((__warn_unused_result__, __leaf__)) malloc)(size_t __size )  __attribute__((__nothrow__,
__malloc__, __alloc_size__(1))) ;
#line 542
extern void *( __attribute__((__warn_unused_result__, __leaf__)) calloc)(size_t __nmemb ,
                                                                         size_t __size )  __attribute__((__nothrow__,
__malloc__, __alloc_size__(1,2))) ;
#line 550
extern void *( __attribute__((__warn_unused_result__, __leaf__)) realloc)(void *__ptr ,
                                                                          size_t __size )  __attribute__((__nothrow__,
__alloc_size__(2))) ;
#line 565
extern void ( __attribute__((__leaf__)) free)(void *__ptr )  __attribute__((__nothrow__)) ;
#line 586
extern void *( __attribute__((__warn_unused_result__, __leaf__)) aligned_alloc)(size_t __alignment ,
                                                                                size_t __size )  __attribute__((__nothrow__,
__malloc__, __alloc_size__(2))) ;
#line 591
extern void ( __attribute__((__leaf__)) abort)(void)  __attribute__((__nothrow__,
__noreturn__)) ;
#line 595
extern int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) )  __attribute__((__nothrow__)) ;
#line 603
extern int ( __attribute__((__nonnull__(1), __leaf__)) at_quick_exit)(void (*__func)(void) )  __attribute__((__nothrow__)) ;
#line 617
extern void ( __attribute__((__leaf__)) exit)(int __status )  __attribute__((__nothrow__,
__noreturn__)) ;
#line 623
extern void ( __attribute__((__leaf__)) quick_exit)(int __status )  __attribute__((__nothrow__,
__noreturn__)) ;
#line 629
extern void ( __attribute__((__leaf__)) _Exit)(int __status )  __attribute__((__nothrow__,
__noreturn__)) ;
#line 634
extern char *( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) getenv)(char const   *__name )  __attribute__((__nothrow__)) ;
#line 784
extern int ( __attribute__((__warn_unused_result__)) system)(char const   *__command ) ;
#line 820
__inline extern void *( __attribute__((__warn_unused_result__, __nonnull__(1,2,5),
__gnu_inline__)) bsearch___0)(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , int (*__compar)(void const   * , void const   * ) ) ;
#line 19 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *( __attribute__((__warn_unused_result__, __nonnull__(1,2,5),
__gnu_inline__)) bsearch___0)(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , int (*__compar)(void const   * , void const   * ) )
{
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
#line 27
  __l = (size_t )0;
#line 28
  __u = __nmemb;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if (! (__l < __u)) {
#line 29
      goto while_break;
    }
#line 31
    __idx = (__l + __u) / 2UL;
#line 32
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
#line 33
    __comparison = (*__compar)(__key, __p);
#line 34
    if (__comparison < 0) {
#line 35
      __u = __idx;
    } else
#line 36
    if (__comparison > 0) {
#line 37
      __l = __idx + 1UL;
    } else {
#line 39
      return ((void *)__p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return ((void *)0);
}
}
#line 840 "/usr/include/stdlib.h"
extern int ( __attribute__((__warn_unused_result__, __leaf__)) abs)(int __x )  __attribute__((__nothrow__,
__const__)) ;
#line 841
extern long ( __attribute__((__warn_unused_result__, __leaf__)) labs)(long __x )  __attribute__((__nothrow__,
__const__)) ;
#line 844
extern long long ( __attribute__((__warn_unused_result__, __leaf__)) llabs)(long long __x )  __attribute__((__nothrow__,
__const__)) ;
#line 852
extern div_t ( __attribute__((__warn_unused_result__, __leaf__)) div)(int __numer ,
                                                                      int __denom )  __attribute__((__nothrow__,
__const__)) ;
#line 854
extern ldiv_t ( __attribute__((__warn_unused_result__, __leaf__)) ldiv)(long __numer ,
                                                                        long __denom )  __attribute__((__nothrow__,
__const__)) ;
#line 858
extern lldiv_t ( __attribute__((__warn_unused_result__, __leaf__)) lldiv)(long long __numer ,
                                                                          long long __denom )  __attribute__((__nothrow__,
__const__)) ;
#line 922
extern int ( __attribute__((__leaf__)) mblen)(char const   *__s , size_t __n )  __attribute__((__nothrow__)) ;
#line 925
extern int ( __attribute__((__leaf__)) mbtowc)(wchar_t *__pwc , char const   *__s ,
                                               size_t __n )  __attribute__((__nothrow__)) ;
#line 929
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar )  __attribute__((__nothrow__)) ;
#line 933
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t *__dst , char const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 936
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) wcstombs)(char *__dst , wchar_t const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atof)(char const   *__nptr )
{
  double tmp ;

  {
#line 27
  tmp = strtod((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)));
#line 27
  return (tmp);
}
}
#line 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
extern char *( __attribute__((__warn_unused_result__, __leaf__)) __realpath_chk)(char const   *__name ,
                                                                                 char *__resolved ,
                                                                                 size_t __resolvedlen )  __attribute__((__nothrow__)) ;
#line 26
extern char *( __attribute__((__warn_unused_result__, __leaf__)) __realpath_alias)(char const   *__name ,
                                                                                   char *__resolved )  __asm__("realpath") __attribute__((__nothrow__)) ;
#line 29
extern char *( __attribute__((__warn_unused_result__, __leaf__)) __realpath_chk_warn)(char const   *__name ,
                                                                                      char *__resolved ,
                                                                                      size_t __resolvedlen )  __asm__("__realpath_chk") __attribute__((__warning__("second argument of realpath must be either NULL or at least PATH_MAX bytes long buffer"),
__nothrow__)) ;
#line 36
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) realpath)(char const   * __restrict  __name ,
                                              char * __restrict  __resolved )  __attribute__((__nothrow__)) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) realpath)(char const   * __restrict  __name ,
                                              char * __restrict  __resolved )
{
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;

  {
#line 39
  tmp___1 = __builtin_object_size((void *)__resolved, 1);
#line 39
  if (tmp___1 != 18446744073709551615UL) {
#line 45
    tmp = __builtin_object_size((void *)__resolved, 1);
#line 45
    tmp___0 = __realpath_chk(__name, __resolved, tmp);
#line 45
    return (tmp___0);
  }
#line 48
  tmp___2 = __realpath_alias(__name, __resolved);
#line 48
  return (tmp___2);
}
}
#line 52
extern int ( __attribute__((__nonnull__(2), __leaf__)) __ptsname_r_chk)(int __fd ,
                                                                        char *__buf ,
                                                                        size_t __buflen ,
                                                                        size_t __nreal )  __attribute__((__nothrow__)) ;
#line 54
extern int ( __attribute__((__nonnull__(2), __leaf__)) __ptsname_r_alias)(int __fd ,
                                                                          char *__buf ,
                                                                          size_t __buflen )  __asm__("ptsname_r") __attribute__((__nothrow__)) ;
#line 57
extern int ( __attribute__((__nonnull__(2), __leaf__)) __ptsname_r_chk_warn)(int __fd ,
                                                                             char *__buf ,
                                                                             size_t __buflen ,
                                                                             size_t __nreal )  __asm__("__ptsname_r_chk") __attribute__((__warning__("ptsname_r called with buflen bigger than size of buf"),
__nothrow__)) ;
#line 63
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) ptsname_r)(int __fd ,
                                                                                                              char *__buf ,
                                                                                                              size_t __buflen )  __attribute__((__nothrow__)) ;
#line 63 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) ptsname_r)(int __fd ,
                                                                                                              char *__buf ,
                                                                                                              size_t __buflen )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 66
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 66
  if (tmp___4 != 18446744073709551615UL) {
#line 68
    if (1) {
#line 69
      tmp = __builtin_object_size((void *)__buf, 1);
#line 69
      tmp___0 = __ptsname_r_chk(__fd, __buf, __buflen, tmp);
#line 69
      return (tmp___0);
    }
#line 70
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 70
    if (__buflen > tmp___3) {
#line 71
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 71
      tmp___2 = __ptsname_r_chk_warn(__fd, __buf, __buflen, tmp___1);
#line 71
      return (tmp___2);
    }
  }
#line 73
  tmp___5 = __ptsname_r_alias(__fd, __buf, __buflen);
#line 73
  return (tmp___5);
}
}
#line 77
extern int ( __attribute__((__warn_unused_result__, __leaf__)) __wctomb_chk)(char *__s ,
                                                                             wchar_t __wchar ,
                                                                             size_t __buflen )  __attribute__((__nothrow__)) ;
#line 79
extern int ( __attribute__((__warn_unused_result__, __leaf__)) __wctomb_alias)(char *__s ,
                                                                               wchar_t __wchar )  __asm__("wctomb") __attribute__((__nothrow__)) ;
#line 82
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar )  __attribute__((__nothrow__)) ;
#line 82 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;

  {
#line 92
  tmp___1 = __builtin_object_size((void *)__s, 1);
#line 92
  if (tmp___1 != 18446744073709551615UL) {
#line 92
    tmp___2 = __builtin_object_size((void *)__s, 1);
#line 92
    if (16UL > tmp___2) {
#line 93
      tmp = __builtin_object_size((void *)__s, 1);
#line 93
      tmp___0 = __wctomb_chk(__s, __wchar, tmp);
#line 93
      return (tmp___0);
    }
  }
#line 94
  tmp___3 = __wctomb_alias(__s, __wchar);
#line 94
  return (tmp___3);
}
}
#line 98
extern size_t ( __attribute__((__leaf__)) __mbstowcs_chk)(wchar_t *__dst , char const   *__src ,
                                                          size_t __len , size_t __dstlen )  __attribute__((__nothrow__)) ;
#line 101
extern size_t ( __attribute__((__leaf__)) __mbstowcs_alias)(wchar_t *__dst , char const   *__src ,
                                                            size_t __len )  __asm__("mbstowcs") __attribute__((__nothrow__)) ;
#line 105
extern size_t ( __attribute__((__leaf__)) __mbstowcs_chk_warn)(wchar_t *__dst , char const   *__src ,
                                                               size_t __len , size_t __dstlen )  __asm__("__mbstowcs_chk") __attribute__((__warning__("mbstowcs called with dst buffer smaller than len * sizeof (wchar_t)"),
__nothrow__)) ;
#line 112
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t *__dst , char const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 112 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t *__dst , char const   *__src , size_t __len )
{
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 116
  tmp___4 = __builtin_object_size((void *)__dst, 1);
#line 116
  if (tmp___4 != 18446744073709551615UL) {
#line 118
    if (1) {
#line 119
      tmp = __builtin_object_size((void *)__dst, 1);
#line 119
      tmp___0 = __mbstowcs_chk((wchar_t * __restrict  )__dst, (char const   * __restrict  )__src,
                               __len, tmp / sizeof(wchar_t ));
#line 119
      return (tmp___0);
    }
#line 122
    tmp___3 = __builtin_object_size((void *)__dst, 1);
#line 122
    if (__len > tmp___3 / sizeof(wchar_t )) {
#line 123
      tmp___1 = __builtin_object_size((void *)__dst, 1);
#line 123
      tmp___2 = __mbstowcs_chk_warn((wchar_t * __restrict  )__dst, (char const   * __restrict  )__src,
                                    __len, tmp___1 / sizeof(wchar_t ));
#line 123
      return (tmp___2);
    }
  }
#line 126
  tmp___5 = __mbstowcs_alias((wchar_t * __restrict  )__dst, (char const   * __restrict  )__src,
                             __len);
#line 126
  return (tmp___5);
}
}
#line 130
extern size_t ( __attribute__((__leaf__)) __wcstombs_chk)(char *__dst , wchar_t const   *__src ,
                                                          size_t __len , size_t __dstlen )  __attribute__((__nothrow__)) ;
#line 133
extern size_t ( __attribute__((__leaf__)) __wcstombs_alias)(char *__dst , wchar_t const   *__src ,
                                                            size_t __len )  __asm__("wcstombs") __attribute__((__nothrow__)) ;
#line 137
extern size_t ( __attribute__((__leaf__)) __wcstombs_chk_warn)(char *__dst , wchar_t const   *__src ,
                                                               size_t __len , size_t __dstlen )  __asm__("__wcstombs_chk") __attribute__((__warning__("wcstombs called with dst buffer smaller than len"),
__nothrow__)) ;
#line 143
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) wcstombs)(char *__dst , wchar_t const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 143 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) wcstombs)(char *__dst , wchar_t const   *__src , size_t __len )
{
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 147
  tmp___4 = __builtin_object_size((void *)__dst, 1);
#line 147
  if (tmp___4 != 18446744073709551615UL) {
#line 149
    if (1) {
#line 150
      tmp = __builtin_object_size((void *)__dst, 1);
#line 150
      tmp___0 = __wcstombs_chk((char * __restrict  )__dst, (wchar_t const   * __restrict  )__src,
                               __len, tmp);
#line 150
      return (tmp___0);
    }
#line 151
    tmp___3 = __builtin_object_size((void *)__dst, 1);
#line 151
    if (__len > tmp___3) {
#line 152
      tmp___1 = __builtin_object_size((void *)__dst, 1);
#line 152
      tmp___2 = __wcstombs_chk_warn((char * __restrict  )__dst, (wchar_t const   * __restrict  )__src,
                                    __len, tmp___1);
#line 152
      return (tmp___2);
    }
  }
#line 154
  tmp___5 = __wcstombs_alias((char * __restrict  )__dst, (wchar_t const   * __restrict  )__src,
                             __len);
#line 154
  return (tmp___5);
}
}
#line 43 "/usr/include/string.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memcpy)(void *__dest , void const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 47
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 61
__inline extern void *( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) memset)(void *__dest , int __ch , size_t __len )  __attribute__((__nothrow__)) ;
#line 64
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                 void const   *__s2 ,
                                                                 size_t __n )  __attribute__((__pure__,
__nothrow__)) ;
#line 91
extern void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                 int __c , size_t __n )  __attribute__((__pure__,
__nothrow__)) ;
#line 122
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcpy)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 125
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncpy)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 130
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcat)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 133
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncat)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 137
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                 char const   *__s2 )  __attribute__((__pure__,
__nothrow__)) ;
#line 140
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                  char const   *__s2 ,
                                                                  size_t __n )  __attribute__((__pure__,
__nothrow__)) ;
#line 144
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) strcoll)(char const   *__s1 ,
                                                                  char const   *__s2 )  __attribute__((__pure__,
__nothrow__)) ;
#line 147
extern size_t ( __attribute__((__nonnull__(2), __leaf__)) strxfrm)(char *__dest ,
                                                                   char const   *__src ,
                                                                   size_t __n )  __attribute__((__nothrow__)) ;
#line 226
extern char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                 int __c )  __attribute__((__pure__,
__nothrow__)) ;
#line 253
extern char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                  int __c )  __attribute__((__pure__,
__nothrow__)) ;
#line 273
extern size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                     char const   *__reject )  __attribute__((__pure__,
__nothrow__)) ;
#line 277
extern size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                    char const   *__accept )  __attribute__((__pure__,
__nothrow__)) ;
#line 303
extern char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                    char const   *__accept )  __attribute__((__pure__,
__nothrow__)) ;
#line 330
extern char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                   char const   *__needle )  __attribute__((__pure__,
__nothrow__)) ;
#line 336
extern char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char *__s , char const   *__delim )  __attribute__((__nothrow__)) ;
#line 341
extern char *( __attribute__((__nonnull__(2,3), __leaf__)) __strtok_r)(char *__s ,
                                                                       char const   *__delim ,
                                                                       char **__save_ptr )  __attribute__((__nothrow__)) ;
#line 346
extern char *( __attribute__((__nonnull__(2,3), __leaf__)) strtok_r)(char *__s , char const   *__delim ,
                                                                     char **__save_ptr )  __attribute__((__nothrow__)) ;
#line 385
extern size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__,
__nothrow__)) ;
#line 397
extern char *( __attribute__((__leaf__)) strerror)(int __errnum )  __attribute__((__nothrow__)) ;
#line 30 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memcpy)(void *__dest , void const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 30 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memcpy)(void *__dest , void const   *__src , size_t __len )
{
  unsigned long tmp ;
  void *tmp___0 ;

  {
#line 34
  tmp = __builtin_object_size(__dest, 0);
#line 34
  tmp___0 = __builtin___memcpy_chk(__dest, __src, __len, tmp);
#line 34
  return (tmp___0);
}
}
#line 37
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 37 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                             size_t __len )
{
  unsigned long tmp ;
  void *tmp___0 ;

  {
#line 40
  tmp = __builtin_object_size(__dest, 0);
#line 40
  tmp___0 = __builtin___memmove_chk(__dest, __src, __len, tmp);
#line 40
  return (tmp___0);
}
}
#line 58
__inline extern void *( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) memset)(void *__dest , int __ch , size_t __len )  __attribute__((__nothrow__)) ;
#line 58 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) memset)(void *__dest , int __ch , size_t __len )
{
  unsigned long tmp ;
  void *tmp___0 ;

  {
#line 71
  tmp = __builtin_object_size(__dest, 0);
#line 71
  tmp___0 = __builtin___memset_chk(__dest, __ch, __len, tmp);
#line 71
  return (tmp___0);
}
}
#line 87
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcpy)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 87 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcpy)(char *__dest , char const   *__src )
{
  unsigned long tmp ;
  char *tmp___0 ;

  {
#line 90
  tmp = __builtin_object_size((void *)__dest, 1);
#line 90
  tmp___0 = __builtin___strcpy_chk(__dest, __src, tmp);
#line 90
  return (tmp___0);
}
}
#line 102
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncpy)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 102 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncpy)(char *__dest , char const   *__src ,
                                             size_t __len )
{
  unsigned long tmp ;
  char *tmp___0 ;

  {
#line 106
  tmp = __builtin_object_size((void *)__dest, 1);
#line 106
  tmp___0 = __builtin___strncpy_chk(__dest, __src, __len, tmp);
#line 106
  return (tmp___0);
}
}
#line 110
extern char *( __attribute__((__leaf__)) __stpncpy_chk)(char *__dest , char const   *__src ,
                                                        size_t __n , size_t __destlen )  __attribute__((__nothrow__)) ;
#line 112
extern char *( __attribute__((__leaf__)) __stpncpy_alias)(char *__dest , char const   *__src ,
                                                          size_t __n )  __asm__("stpncpy") __attribute__((__nothrow__)) ;
#line 115
__inline extern char *( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) stpncpy)(char *__dest ,
                                                                                                              char const   *__src ,
                                                                                                              size_t __n )  __attribute__((__nothrow__)) ;
#line 115 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) stpncpy)(char *__dest ,
                                                                                                              char const   *__src ,
                                                                                                              size_t __n )
{
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;

  {
#line 118
  tmp___1 = __builtin_object_size((void *)__dest, 1);
#line 118
  if (tmp___1 != 18446744073709551615UL) {
#line 118
    if (1) {
#line 120
      tmp = __builtin_object_size((void *)__dest, 1);
#line 120
      tmp___0 = __stpncpy_chk(__dest, __src, __n, tmp);
#line 120
      return (tmp___0);
    } else {
#line 118
      tmp___2 = __builtin_object_size((void *)__dest, 1);
#line 118
      if (__n > tmp___2) {
#line 120
        tmp = __builtin_object_size((void *)__dest, 1);
#line 120
        tmp___0 = __stpncpy_chk(__dest, __src, __n, tmp);
#line 120
        return (tmp___0);
      }
    }
  }
#line 121
  tmp___3 = __stpncpy_alias(__dest, __src, __n);
#line 121
  return (tmp___3);
}
}
#line 125
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcat)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 125 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcat)(char *__dest , char const   *__src )
{
  unsigned long tmp ;
  char *tmp___0 ;

  {
#line 128
  tmp = __builtin_object_size((void *)__dest, 1);
#line 128
  tmp___0 = __builtin___strcat_chk(__dest, __src, tmp);
#line 128
  return (tmp___0);
}
}
#line 132
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncat)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 132 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncat)(char *__dest , char const   *__src ,
                                             size_t __len )
{
  unsigned long tmp ;
  char *tmp___0 ;

  {
#line 136
  tmp = __builtin_object_size((void *)__dest, 1);
#line 136
  tmp___0 = __builtin___strncat_chk(__dest, __src, __len, tmp);
#line 136
  return (tmp___0);
}
}
#line 137 "/usr/include/stdio.h"
extern FILE *stdin ;
#line 138
extern FILE *stdout ;
#line 139
extern FILE *stderr ;
#line 146
extern int ( __attribute__((__leaf__)) remove)(char const   *__filename )  __attribute__((__nothrow__)) ;
#line 148
extern int ( __attribute__((__leaf__)) rename)(char const   *__old , char const   *__new )  __attribute__((__nothrow__)) ;
#line 173
extern FILE *( __attribute__((__warn_unused_result__)) tmpfile)(void) ;
#line 187
extern char *( __attribute__((__warn_unused_result__, __leaf__)) tmpnam)(char *__s )  __attribute__((__nothrow__)) ;
#line 213
extern int fclose(FILE *__stream ) ;
#line 218
extern int fflush(FILE *__stream ) ;
#line 246
extern FILE *( __attribute__((__warn_unused_result__)) fopen)(char const   *__filename ,
                                                              char const   *__modes ) ;
#line 252
extern FILE *( __attribute__((__warn_unused_result__)) freopen)(char const   *__filename ,
                                                                char const   *__modes ,
                                                                FILE *__stream ) ;
#line 279
extern FILE *( __attribute__((__warn_unused_result__, __leaf__)) fdopen)(int __fd ,
                                                                         char const   *__modes )  __attribute__((__nothrow__)) ;
#line 304
extern void ( __attribute__((__leaf__)) setbuf)(FILE *__stream , char *__buf )  __attribute__((__nothrow__)) ;
#line 308
extern int ( __attribute__((__leaf__)) setvbuf)(FILE *__stream , char *__buf , int __modes ,
                                                size_t __n )  __attribute__((__nothrow__)) ;
#line 326
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) fprintf)(FILE *__stream ,
                                                                                                  char const   *__fmt
                                                                                                  , ...) ;
#line 332
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) printf)(char const   *__fmt
                                                                                                 , ...) ;
#line 334
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) sprintf)(char *__s ,
                                                                                                            char const   *__fmt
                                                                                                            , ...)  __attribute__((__nothrow__)) ;
#line 341
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vfprintf)(FILE *__stream ,
                                                                                                   char const   *__fmt ,
                                                                                                   __gnuc_va_list __ap ) ;
#line 347
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vprintf)(char const   *__fmt ,
                                                                                                  __gnuc_va_list __ap ) ;
#line 349
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vsprintf)(char *__s ,
                                                                                                             char const   *__fmt ,
                                                                                                             __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 354
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) snprintf)(char *__s , size_t __n , char const   *__fmt
                                              , ...)  __attribute__((__nothrow__)) ;
#line 358
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) vsnprintf)(char *__s , size_t __n , char const   *__fmt ,
                                               __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 391
extern int ( __attribute__((__warn_unused_result__)) fscanf)(FILE *__stream , char const   *__format
                                                             , ...)  __asm__("__isoc99_fscanf")  ;
#line 397
extern int ( __attribute__((__warn_unused_result__)) scanf)(char const   *__format
                                                            , ...)  __asm__("__isoc99_scanf")  ;
#line 399
extern int ( __attribute__((__leaf__)) sscanf)(char const   *__s , char const   *__format
                                               , ...)  __asm__("__isoc99_sscanf") __attribute__((__nothrow__)) ;
#line 432
extern int ( /* format attribute */ __attribute__((__warn_unused_result__)) vfscanf)(FILE *__s ,
                                                                                     char const   *__format ,
                                                                                     __gnuc_va_list __arg )  __asm__("__isoc99_vfscanf")  ;
#line 440
extern int ( /* format attribute */ __attribute__((__warn_unused_result__)) vscanf)(char const   *__format ,
                                                                                    __gnuc_va_list __arg )  __asm__("__isoc99_vscanf")  ;
#line 444
extern int ( /* format attribute */ __attribute__((__leaf__)) vsscanf)(char const   *__s ,
                                                                       char const   *__format ,
                                                                       __gnuc_va_list __arg )  __asm__("__isoc99_vsscanf") __attribute__((__nothrow__)) ;
#line 485
extern int fgetc(FILE *__stream ) ;
#line 486
extern int getc(FILE *__stream ) ;
#line 492
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
#line 521
extern int fputc(int __c , FILE *__stream ) ;
#line 522
extern int putc(int __c , FILE *__stream ) ;
#line 528
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
#line 564
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fgets)(char *__s , int __n , FILE *__stream ) ;
#line 626
extern int fputs(char const   *__s , FILE *__stream ) ;
#line 632
extern int puts(char const   *__s ) ;
#line 639
extern int ungetc(int __c , FILE *__stream ) ;
#line 646
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fread)(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 652
extern size_t fwrite(void const   *__ptr , size_t __size , size_t __n , FILE *__s ) ;
#line 684
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 689
extern long ( __attribute__((__warn_unused_result__)) ftell)(FILE *__stream ) ;
#line 694
extern void rewind(FILE *__stream ) ;
#line 731
extern int fgetpos(FILE *__stream , fpos_t *__pos ) ;
#line 736
extern int fsetpos(FILE *__stream , fpos_t const   *__pos ) ;
#line 757
extern void ( __attribute__((__leaf__)) clearerr)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 759
extern int ( __attribute__((__warn_unused_result__, __leaf__)) feof)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 761
extern int ( __attribute__((__warn_unused_result__, __leaf__)) ferror)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 775
extern void perror(char const   *__s ) ;
#line 786
extern int ( __attribute__((__warn_unused_result__, __leaf__)) fileno)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 812
extern char *( __attribute__((__leaf__)) ctermid)(char *__s )  __attribute__((__nothrow__)) ;
#line 858
extern int __uflow(FILE * ) ;
#line 859
extern int __overflow(FILE * , int  ) ;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void)
{
  int tmp ;

  {
#line 49
  tmp = getc(stdin);
#line 49
  return (tmp);
}
}
#line 65 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp )
{
  long tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
#line 68
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
#line 68
  if (tmp___3) {
#line 68
    tmp___0 = __uflow(__fp);
#line 68
    tmp___2 = tmp___0;
  } else {
#line 68
    tmp___1 = __fp->_IO_read_ptr;
#line 68
    (__fp->_IO_read_ptr) ++;
#line 68
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
#line 68
  return (tmp___2);
}
}
#line 72 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void)
{
  long tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
#line 75
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
#line 75
  if (tmp___3) {
#line 75
    tmp___0 = __uflow(stdin);
#line 75
    tmp___2 = tmp___0;
  } else {
#line 75
    tmp___1 = stdin->_IO_read_ptr;
#line 75
    (stdin->_IO_read_ptr) ++;
#line 75
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
#line 75
  return (tmp___2);
}
}
#line 81 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c )
{
  int tmp ;

  {
#line 84
  tmp = putc(__c, stdout);
#line 84
  return (tmp);
}
}
#line 100 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) putc_unlocked)(int __c , FILE *__stream )
{
  long tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 103
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
#line 103
  if (tmp___4) {
#line 103
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
#line 103
    tmp___3 = tmp___0;
  } else {
#line 103
    tmp___1 = __stream->_IO_write_ptr;
#line 103
    (__stream->_IO_write_ptr) ++;
#line 103
    tmp___2 = (char )__c;
#line 103
    *tmp___1 = tmp___2;
#line 103
    tmp___3 = (int )((unsigned char )tmp___2);
  }
#line 103
  return (tmp___3);
}
}
#line 107 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c )
{
  long tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 110
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
#line 110
  if (tmp___4) {
#line 110
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
#line 110
    tmp___3 = tmp___0;
  } else {
#line 110
    tmp___1 = stdout->_IO_write_ptr;
#line 110
    (stdout->_IO_write_ptr) ++;
#line 110
    tmp___2 = (char )__c;
#line 110
    *tmp___1 = tmp___2;
#line 110
    tmp___3 = (int )((unsigned char )tmp___2);
  }
#line 110
  return (tmp___3);
}
}
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
extern int ( __attribute__((__leaf__)) __sprintf_chk)(char *__s , int __flag , size_t __slen ,
                                                      char const   *__format  , ...)  __attribute__((__nothrow__)) ;
#line 28
extern int ( __attribute__((__leaf__)) __vsprintf_chk)(char *__s , int __flag , size_t __slen ,
                                                       char const   *__format , __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 33
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) sprintf)(char *__s ,
                                                                                                            char const   *__fmt
                                                                                                            , ...)  __attribute__((__nothrow__)) ;
#line 33 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) sprintf)(char *__s ,
                                                                                                            char const   *__fmt
                                                                                                            , ...)
{
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 36
  tmp = __builtin_object_size((void *)__s, 1);
#line 36
  tmp___0 = __builtin___sprintf_chk(__s, 1, tmp, __fmt, __builtin_va_arg_pack());
#line 36
  return (tmp___0);
}
}
#line 45
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vsprintf)(char *__s ,
                                                                                                             char const   *__fmt ,
                                                                                                             __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 45 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vsprintf)(char *__s ,
                                                                                                             char const   *__fmt ,
                                                                                                             __gnuc_va_list __ap )
{
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 49
  tmp = __builtin_object_size((void *)__s, 1);
#line 49
  tmp___0 = __builtin___vsprintf_chk(__s, 1, tmp, __fmt, __ap);
#line 49
  return (tmp___0);
}
}
#line 55
extern int ( __attribute__((__leaf__)) __snprintf_chk)(char *__s , size_t __n , int __flag ,
                                                       size_t __slen , char const   *__format
                                                       , ...)  __attribute__((__nothrow__)) ;
#line 58
extern int ( __attribute__((__leaf__)) __vsnprintf_chk)(char *__s , size_t __n , int __flag ,
                                                        size_t __slen , char const   *__format ,
                                                        __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 63
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) snprintf)(char *__s , size_t __n , char const   *__fmt
                                              , ...)  __attribute__((__nothrow__)) ;
#line 63 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) snprintf)(char *__s , size_t __n , char const   *__fmt
                                              , ...)
{
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 67
  tmp = __builtin_object_size((void *)__s, 1);
#line 67
  tmp___0 = __builtin___snprintf_chk(__s, __n, 1, tmp, __fmt, __builtin_va_arg_pack());
#line 67
  return (tmp___0);
}
}
#line 76
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) vsnprintf)(char *__s , size_t __n , char const   *__fmt ,
                                               __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 76 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) vsnprintf)(char *__s , size_t __n , char const   *__fmt ,
                                               __gnuc_va_list __ap )
{
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 80
  tmp = __builtin_object_size((void *)__s, 1);
#line 80
  tmp___0 = __builtin___vsnprintf_chk(__s, __n, 1, tmp, __fmt, __ap);
#line 80
  return (tmp___0);
}
}
#line 88
extern int __fprintf_chk(FILE *__stream , int __flag , char const   *__format  , ...) ;
#line 90
extern int __printf_chk(int __flag , char const   *__format  , ...) ;
#line 91
extern int __vfprintf_chk(FILE *__stream , int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 93
extern int __vprintf_chk(int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 97 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) fprintf)(FILE *__stream ,
                                                                                                  char const   *__fmt
                                                                                                  , ...)
{
  int tmp ;

  {
#line 100
  tmp = __fprintf_chk((FILE * __restrict  )__stream, 1, (char const   * __restrict  )__fmt,
                      __builtin_va_arg_pack());
#line 100
  return (tmp);
}
}
#line 104 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) printf)(char const   *__fmt
                                                                                                 , ...)
{
  int tmp ;

  {
#line 107
  tmp = __printf_chk(1, (char const   * __restrict  )__fmt, __builtin_va_arg_pack());
#line 107
  return (tmp);
}
}
#line 116 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vprintf)(char const   *__fmt ,
                                                                                                  __gnuc_va_list __ap )
{
  int tmp ;

  {
#line 120
  tmp = __vfprintf_chk((FILE * __restrict  )stdout, 1, (char const   * __restrict  )__fmt,
                       __ap);
#line 120
  return (tmp);
}
}
#line 126 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vfprintf)(FILE *__stream ,
                                                                                                   char const   *__fmt ,
                                                                                                   __gnuc_va_list __ap )
{
  int tmp ;

  {
#line 130
  tmp = __vfprintf_chk((FILE * __restrict  )__stream, 1, (char const   * __restrict  )__fmt,
                       __ap);
#line 130
  return (tmp);
}
}
#line 243
extern char *( __attribute__((__warn_unused_result__)) __fgets_chk)(char *__s , size_t __size ,
                                                                    int __n , FILE *__stream ) ;
#line 245
extern char *( __attribute__((__warn_unused_result__)) __fgets_alias)(char *__s ,
                                                                      int __n , FILE *__stream )  __asm__("fgets")  ;
#line 248
extern char *( __attribute__((__warn_unused_result__)) __fgets_chk_warn)(char *__s ,
                                                                         size_t __size ,
                                                                         int __n ,
                                                                         FILE *__stream )  __asm__("__fgets_chk") __attribute__((__warning__("fgets called with bigger size than length of destination buffer"))) ;
#line 254 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fgets)(char *__s , int __n , FILE *__stream )
{
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;

  {
#line 257
  tmp___4 = __builtin_object_size((void *)__s, 1);
#line 257
  if (tmp___4 != 18446744073709551615UL) {
#line 259
    if (1) {
#line 260
      tmp = __builtin_object_size((void *)__s, 1);
#line 260
      tmp___0 = __fgets_chk((char * __restrict  )__s, tmp, __n, (FILE * __restrict  )__stream);
#line 260
      return (tmp___0);
    } else
#line 259
    if (__n <= 0) {
#line 260
      tmp = __builtin_object_size((void *)__s, 1);
#line 260
      tmp___0 = __fgets_chk((char * __restrict  )__s, tmp, __n, (FILE * __restrict  )__stream);
#line 260
      return (tmp___0);
    }
#line 262
    tmp___3 = __builtin_object_size((void *)__s, 1);
#line 262
    if ((size_t )__n > tmp___3) {
#line 263
      tmp___1 = __builtin_object_size((void *)__s, 1);
#line 263
      tmp___2 = __fgets_chk_warn((char * __restrict  )__s, tmp___1, __n, (FILE * __restrict  )__stream);
#line 263
      return (tmp___2);
    }
  }
#line 265
  tmp___5 = __fgets_alias((char * __restrict  )__s, __n, (FILE * __restrict  )__stream);
#line 265
  return (tmp___5);
}
}
#line 268
extern size_t ( __attribute__((__warn_unused_result__)) __fread_chk)(void *__ptr ,
                                                                     size_t __ptrlen ,
                                                                     size_t __size ,
                                                                     size_t __n ,
                                                                     FILE *__stream ) ;
#line 271
extern size_t ( __attribute__((__warn_unused_result__)) __fread_alias)(void *__ptr ,
                                                                       size_t __size ,
                                                                       size_t __n ,
                                                                       FILE *__stream )  __asm__("fread")  ;
#line 275
extern size_t ( __attribute__((__warn_unused_result__)) __fread_chk_warn)(void *__ptr ,
                                                                          size_t __ptrlen ,
                                                                          size_t __size ,
                                                                          size_t __n ,
                                                                          FILE *__stream )  __asm__("__fread_chk") __attribute__((__warning__("fread called with bigger size * nmemb than length of destination buffer"))) ;
#line 283 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fread)(void *__ptr , size_t __size , size_t __n , FILE *__stream )
{
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 287
  tmp___4 = __builtin_object_size(__ptr, 0);
#line 287
  if (tmp___4 != 18446744073709551615UL) {
#line 289
    if (1) {
#line 292
      tmp = __builtin_object_size(__ptr, 0);
#line 292
      tmp___0 = __fread_chk((void * __restrict  )__ptr, tmp, __size, __n, (FILE * __restrict  )__stream);
#line 292
      return (tmp___0);
    } else
#line 289
    if (1) {
#line 292
      tmp = __builtin_object_size(__ptr, 0);
#line 292
      tmp___0 = __fread_chk((void * __restrict  )__ptr, tmp, __size, __n, (FILE * __restrict  )__stream);
#line 292
      return (tmp___0);
    } else
#line 289
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
#line 292
      tmp = __builtin_object_size(__ptr, 0);
#line 292
      tmp___0 = __fread_chk((void * __restrict  )__ptr, tmp, __size, __n, (FILE * __restrict  )__stream);
#line 292
      return (tmp___0);
    }
#line 294
    tmp___3 = __builtin_object_size(__ptr, 0);
#line 294
    if (__size * __n > tmp___3) {
#line 295
      tmp___1 = __builtin_object_size(__ptr, 0);
#line 295
      tmp___2 = __fread_chk_warn((void * __restrict  )__ptr, tmp___1, __size, __n,
                                 (FILE * __restrict  )__stream);
#line 295
      return (tmp___2);
    }
  }
#line 297
  tmp___5 = __fread_alias((void * __restrict  )__ptr, __size, __n, (FILE * __restrict  )__stream);
#line 297
  return (tmp___5);
}
}
#line 49 "/usr/include/setjmp.h"
extern int setjmp(struct __jmp_buf_tag *__env )  __attribute__((__nothrow__)) ;
#line 58
extern int _setjmp(struct __jmp_buf_tag *__env )  __attribute__((__nothrow__)) ;
#line 67
extern void longjmp(struct __jmp_buf_tag *__env , int __val )  __asm__("__longjmp_chk") __attribute__((__nothrow__,
__noreturn__)) ;
#line 93
extern void siglongjmp(struct __jmp_buf_tag *__env , int __val )  __asm__("__longjmp_chk") __attribute__((__nothrow__,
__noreturn__)) ;
#line 28 "/usr/include/x86_64-linux-gnu/bits/setjmp2.h"
extern void _longjmp(struct __jmp_buf_tag *__env , int __val )  __asm__("__longjmp_chk") __attribute__((__nothrow__,
__noreturn__)) ;
#line 40 "/usr/include/x86_64-linux-gnu/bits/time.h"
extern long __sysconf(int  ) ;
#line 901 "/home/goblint2/bench/libpng-1.6.39/png.h"
png_uint_32 png_access_version_number(void) ;
#line 906
void png_set_sig_bytes(png_structrp png_ptr , int num_bytes ) ;
#line 913
int png_sig_cmp(png_const_bytep sig , size_t start , size_t num_to_check ) ;
#line 922
png_structp __attribute__((__malloc__))  png_create_read_struct(png_const_charp user_png_ver ,
                                                                png_voidp error_ptr ,
                                                                void (*error_fn)(png_structp  ,
                                                                                 png_const_charp  ) ,
                                                                void (*warn_fn)(png_structp  ,
                                                                                png_const_charp  ) ) ;
#line 928
png_structp __attribute__((__malloc__))  png_create_write_struct(png_const_charp user_png_ver ,
                                                                 png_voidp error_ptr ,
                                                                 void (*error_fn)(png_structp  ,
                                                                                  png_const_charp  ) ,
                                                                 void (*warn_fn)(png_structp  ,
                                                                                 png_const_charp  ) ) ;
#line 933
size_t png_get_compression_buffer_size(png_const_structrp png_ptr ) ;
#line 936
void png_set_compression_buffer_size(png_structrp png_ptr , size_t size ) ;
#line 950
jmp_buf *png_set_longjmp_fn(png_structrp png_ptr , void (*longjmp_fn)(struct __jmp_buf_tag * ,
                                                                      int  ) , size_t jmp_buf_size ) ;
#line 963
void png_longjmp(png_const_structrp png_ptr , int val )  __attribute__((__noreturn__)) ;
#line 968
int __attribute__((__deprecated__))  png_reset_zstream(png_structrp png_ptr ) ;
#line 973
png_structp __attribute__((__malloc__))  png_create_read_struct_2(png_const_charp user_png_ver ,
                                                                  png_voidp error_ptr ,
                                                                  void (*error_fn)(png_structp  ,
                                                                                   png_const_charp  ) ,
                                                                  void (*warn_fn)(png_structp  ,
                                                                                  png_const_charp  ) ,
                                                                  png_voidp mem_ptr ,
                                                                  png_voidp (*malloc_fn)(png_structp  ,
                                                                                         png_alloc_size_t  ) ,
                                                                  void (*free_fn)(png_structp  ,
                                                                                  png_voidp  ) ) ;
#line 978
png_structp __attribute__((__malloc__))  png_create_write_struct_2(png_const_charp user_png_ver ,
                                                                   png_voidp error_ptr ,
                                                                   void (*error_fn)(png_structp  ,
                                                                                    png_const_charp  ) ,
                                                                   void (*warn_fn)(png_structp  ,
                                                                                   png_const_charp  ) ,
                                                                   png_voidp mem_ptr ,
                                                                   png_voidp (*malloc_fn)(png_structp  ,
                                                                                          png_alloc_size_t  ) ,
                                                                   void (*free_fn)(png_structp  ,
                                                                                   png_voidp  ) ) ;
#line 986
void png_write_sig(png_structrp png_ptr ) ;
#line 989
void png_write_chunk(png_structrp png_ptr , png_const_bytep chunk_string , png_const_bytep data ,
                     size_t length ) ;
#line 993
void png_write_chunk_start(png_structrp png_ptr , png_const_bytep chunk_string , png_uint_32 length ) ;
#line 997
void png_write_chunk_data(png_structrp png_ptr , png_const_bytep data , size_t length ) ;
#line 1001
void png_write_chunk_end(png_structrp png_ptr ) ;
#line 1004
png_infop __attribute__((__malloc__))  png_create_info_struct(png_const_structrp png_ptr ) ;
#line 1011
void __attribute__((__deprecated__))  png_info_init_3(png_infopp ptr_ptr , size_t png_info_struct_size ) ;
#line 1015
void png_write_info_before_PLTE(png_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1017
void png_write_info(png_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1022
void png_read_info(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1033
png_const_charp __attribute__((__deprecated__))  png_convert_to_rfc1123(png_structrp png_ptr ,
                                                                        png_const_timep ptime ) ;
#line 1036
int png_convert_to_rfc1123_buffer(char *out , png_const_timep ptime ) ;
#line 1042
void png_convert_from_struct_tm(png_timep ptime , struct tm  const  *ttime ) ;
#line 1046
void png_convert_from_time_t(png_timep ptime , time_t ttime ) ;
#line 1051
void png_set_expand(png_structrp png_ptr ) ;
#line 1052
void png_set_expand_gray_1_2_4_to_8(png_structrp png_ptr ) ;
#line 1053
void png_set_palette_to_rgb(png_structrp png_ptr ) ;
#line 1054
void png_set_tRNS_to_alpha(png_structrp png_ptr ) ;
#line 1061
void png_set_expand_16(png_structrp png_ptr ) ;
#line 1066
void png_set_bgr(png_structrp png_ptr ) ;
#line 1071
void png_set_gray_to_rgb(png_structrp png_ptr ) ;
#line 1081
void png_set_rgb_to_gray(png_structrp png_ptr , int error_action , double red , double green ) ;
#line 1083
void png_set_rgb_to_gray_fixed(png_structrp png_ptr , int error_action , png_fixed_point red ,
                               png_fixed_point green ) ;
#line 1086
png_byte png_get_rgb_to_gray_status(png_const_structrp png_ptr ) ;
#line 1091
void png_build_grayscale_palette(int bit_depth , png_colorp palette ) ;
#line 1137
void png_set_alpha_mode(png_structrp png_ptr , int mode , double output_gamma ) ;
#line 1139
void png_set_alpha_mode_fixed(png_structrp png_ptr , int mode , png_fixed_point output_gamma ) ;
#line 1230
void png_set_strip_alpha(png_structrp png_ptr ) ;
#line 1235
void png_set_swap_alpha(png_structrp png_ptr ) ;
#line 1240
void png_set_invert_alpha(png_structrp png_ptr ) ;
#line 1245
void png_set_filler(png_structrp png_ptr , png_uint_32 filler , int filler_loc ) ;
#line 1251
void png_set_add_alpha(png_structrp png_ptr , png_uint_32 filler , int filler_loc ) ;
#line 1257
void png_set_swap(png_structrp png_ptr ) ;
#line 1262
void png_set_packing(png_structrp png_ptr ) ;
#line 1268
void png_set_packswap(png_structrp png_ptr ) ;
#line 1273
void png_set_shift(png_structrp png_ptr , png_const_color_8p true_bits ) ;
#line 1285
int png_set_interlace_handling(png_structrp png_ptr ) ;
#line 1290
void png_set_invert_mono(png_structrp png_ptr ) ;
#line 1299
void png_set_background(png_structrp png_ptr , png_const_color_16p background_color ,
                        int background_gamma_code , int need_expand , double background_gamma ) ;
#line 1302
void png_set_background_fixed(png_structrp png_ptr , png_const_color_16p background_color ,
                              int background_gamma_code , int need_expand , png_fixed_point background_gamma ) ;
#line 1315
void png_set_scale_16(png_structrp png_ptr ) ;
#line 1321
void png_set_strip_16(png_structrp png_ptr ) ;
#line 1328
void png_set_quantize(png_structrp png_ptr , png_colorp palette , int num_palette ,
                      int maximum_colors , png_const_uint_16p histogram , int full_quantize ) ;
#line 1350
void png_set_gamma(png_structrp png_ptr , double scrn_gamma , double file_gamma ) ;
#line 1352
void png_set_gamma_fixed(png_structrp png_ptr , png_fixed_point scrn_gamma , png_fixed_point file_gamma ) ;
#line 1358
void png_set_flush(png_structrp png_ptr , int nrows ) ;
#line 1360
void png_write_flush(png_structrp png_ptr ) ;
#line 1364
void png_start_read_image(png_structrp png_ptr ) ;
#line 1367
void png_read_update_info(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1372
void png_read_rows(png_structrp png_ptr , png_bytepp row , png_bytepp display_row ,
                   png_uint_32 num_rows ) ;
#line 1378
void png_read_row(png_structrp png_ptr , png_bytep row , png_bytep dsp_row ) ;
#line 1384
void png_read_image(png_structrp png_ptr , png_bytepp image ) ;
#line 1388
void png_write_row(png_structrp png_ptr , png_const_bytep row ) ;
#line 1396
void png_write_rows(png_structrp png_ptr , png_bytepp row , png_uint_32 num_rows ) ;
#line 1400
void png_write_image(png_structrp png_ptr , png_bytepp image ) ;
#line 1403
void png_write_end(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1408
void png_read_end(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1412
void png_destroy_info_struct(png_const_structrp png_ptr , png_infopp info_ptr_ptr ) ;
#line 1416
void png_destroy_read_struct(png_structpp png_ptr_ptr , png_infopp info_ptr_ptr ,
                             png_infopp end_info_ptr_ptr ) ;
#line 1420
void png_destroy_write_struct(png_structpp png_ptr_ptr , png_infopp info_ptr_ptr ) ;
#line 1424
void png_set_crc_action(png_structrp png_ptr , int crit_action , int ancil_action ) ;
#line 1455
void png_set_filter(png_structrp png_ptr , int method , int filters ) ;
#line 1485
void png_set_filter_heuristics(png_structrp png_ptr , int heuristic_method , int num_weights ,
                               png_const_doublep filter_weights , png_const_doublep filter_costs ) ;
#line 1488
void png_set_filter_heuristics_fixed(png_structrp png_ptr , int heuristic_method ,
                                     int num_weights , png_const_fixed_point_p filter_weights ,
                                     png_const_fixed_point_p filter_costs ) ;
#line 1508
void png_set_compression_level(png_structrp png_ptr , int level ) ;
#line 1511
void png_set_compression_mem_level(png_structrp png_ptr , int mem_level ) ;
#line 1514
void png_set_compression_strategy(png_structrp png_ptr , int strategy ) ;
#line 1520
void png_set_compression_window_bits(png_structrp png_ptr , int window_bits ) ;
#line 1523
void png_set_compression_method(png_structrp png_ptr , int method ) ;
#line 1529
void png_set_text_compression_level(png_structrp png_ptr , int level ) ;
#line 1532
void png_set_text_compression_mem_level(png_structrp png_ptr , int mem_level ) ;
#line 1535
void png_set_text_compression_strategy(png_structrp png_ptr , int strategy ) ;
#line 1541
void png_set_text_compression_window_bits(png_structrp png_ptr , int window_bits ) ;
#line 1544
void png_set_text_compression_method(png_structrp png_ptr , int method ) ;
#line 1560
void png_init_io(png_structrp png_ptr , png_FILE_p fp ) ;
#line 1571
void png_set_error_fn(png_structrp png_ptr , png_voidp error_ptr , void (*error_fn)(png_structp  ,
                                                                                    png_const_charp  ) ,
                      void (*warning_fn)(png_structp  , png_const_charp  ) ) ;
#line 1575
png_voidp png_get_error_ptr(png_const_structrp png_ptr ) ;
#line 1587
void png_set_write_fn(png_structrp png_ptr , png_voidp io_ptr , void (*write_data_fn)(png_structp  ,
                                                                                      png_bytep  ,
                                                                                      size_t  ) ,
                      void (*output_flush_fn)(png_structp  ) ) ;
#line 1591
void png_set_read_fn(png_structrp png_ptr , png_voidp io_ptr , void (*read_data_fn)(png_structp  ,
                                                                                    png_bytep  ,
                                                                                    size_t  ) ) ;
#line 1595
png_voidp png_get_io_ptr(png_const_structrp png_ptr ) ;
#line 1597
void png_set_read_status_fn(png_structrp png_ptr , void (*read_row_fn)(png_structp  ,
                                                                       png_uint_32  ,
                                                                       int  ) ) ;
#line 1600
void png_set_write_status_fn(png_structrp png_ptr , void (*write_row_fn)(png_structp  ,
                                                                         png_uint_32  ,
                                                                         int  ) ) ;
#line 1605
void png_set_mem_fn(png_structrp png_ptr , png_voidp mem_ptr , png_voidp (*malloc_fn)(png_structp  ,
                                                                                      png_alloc_size_t  ) ,
                    void (*free_fn)(png_structp  , png_voidp  ) ) ;
#line 1608
png_voidp png_get_mem_ptr(png_const_structrp png_ptr ) ;
#line 1612
void png_set_read_user_transform_fn(png_structrp png_ptr , void (*read_user_transform_fn)(png_structp  ,
                                                                                          png_row_infop  ,
                                                                                          png_bytep  ) ) ;
#line 1617
void png_set_write_user_transform_fn(png_structrp png_ptr , void (*write_user_transform_fn)(png_structp  ,
                                                                                            png_row_infop  ,
                                                                                            png_bytep  ) ) ;
#line 1622
void png_set_user_transform_info(png_structrp png_ptr , png_voidp user_transform_ptr ,
                                 int user_transform_depth , int user_transform_channels ) ;
#line 1626
png_voidp png_get_user_transform_ptr(png_const_structrp png_ptr ) ;
#line 1642
png_uint_32 png_get_current_row_number(png_const_structrp png_ptr ) ;
#line 1643
png_byte png_get_current_pass_number(png_const_structrp png_ptr ) ;
#line 1666
void png_set_read_user_chunk_fn(png_structrp png_ptr , png_voidp user_chunk_ptr ,
                                int (*read_user_chunk_fn)(png_structp  , png_unknown_chunkp  ) ) ;
#line 1671
png_voidp png_get_user_chunk_ptr(png_const_structrp png_ptr ) ;
#line 1678
void png_set_progressive_read_fn(png_structrp png_ptr , png_voidp progressive_ptr ,
                                 void (*info_fn)(png_structp  , png_infop  ) , void (*row_fn)(png_structp  ,
                                                                                              png_bytep  ,
                                                                                              png_uint_32  ,
                                                                                              int  ) ,
                                 void (*end_fn)(png_structp  , png_infop  ) ) ;
#line 1683
png_voidp png_get_progressive_ptr(png_const_structrp png_ptr ) ;
#line 1687
void png_process_data(png_structrp png_ptr , png_inforp info_ptr , png_bytep buffer___0 ,
                      size_t buffer_size ) ;
#line 1697
size_t png_process_data_pause(png_structrp png_ptr , int save ) ;
#line 1705
png_uint_32 png_process_data_skip(png_structrp png_ptr ) ;
#line 1712
void png_progressive_combine_row(png_const_structrp png_ptr , png_bytep old_row ,
                                 png_const_bytep new_row ) ;
#line 1716
png_voidp __attribute__((__malloc__))  png_malloc(png_const_structrp png_ptr , png_alloc_size_t size ) ;
#line 1719
png_voidp __attribute__((__malloc__))  png_calloc(png_const_structrp png_ptr , png_alloc_size_t size ) ;
#line 1723
png_voidp __attribute__((__malloc__))  png_malloc_warn(png_const_structrp png_ptr ,
                                                       png_alloc_size_t size ) ;
#line 1727
void png_free(png_const_structrp png_ptr , png_voidp ptr ) ;
#line 1730
void png_free_data(png_const_structrp png_ptr , png_inforp info_ptr , png_uint_32 mask ,
                   int num ) ;
#line 1740
void png_data_freer(png_const_structrp png_ptr , png_inforp info_ptr , int freer ,
                    png_uint_32 mask ) ;
#line 1766
png_voidp __attribute__((__malloc__, __deprecated__))  png_malloc_default(png_const_structrp png_ptr ,
                                                                          png_alloc_size_t size ) ;
#line 1768
void __attribute__((__deprecated__))  png_free_default(png_const_structrp png_ptr ,
                                                       png_voidp ptr ) ;
#line 1774
void png_error(png_const_structrp png_ptr , png_const_charp error_message )  __attribute__((__noreturn__)) ;
#line 1778
void png_chunk_error(png_const_structrp png_ptr , png_const_charp error_message )  __attribute__((__noreturn__)) ;
#line 1790
void png_warning(png_const_structrp png_ptr , png_const_charp warning_message ) ;
#line 1794
void png_chunk_warning(png_const_structrp png_ptr , png_const_charp warning_message ) ;
#line 1804
void png_benign_error(png_const_structrp png_ptr , png_const_charp error_message ) ;
#line 1809
void png_chunk_benign_error(png_const_structrp png_ptr , png_const_charp error_message ) ;
#line 1813
void png_set_benign_errors(png_structrp png_ptr , int allowed ) ;
#line 1838
png_uint_32 png_get_valid(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                          png_uint_32 flag ) ;
#line 1842
size_t png_get_rowbytes(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1849
png_bytepp png_get_rows(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1855
void png_set_rows(png_const_structrp png_ptr , png_inforp info_ptr , png_bytepp row_pointers ) ;
#line 1860
png_byte png_get_channels(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1865
png_uint_32 png_get_image_width(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1869
png_uint_32 png_get_image_height(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1873
png_byte png_get_bit_depth(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1877
png_byte png_get_color_type(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1881
png_byte png_get_filter_type(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1885
png_byte png_get_interlace_type(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1889
png_byte png_get_compression_type(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1893
png_uint_32 png_get_pixels_per_meter(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1895
png_uint_32 png_get_x_pixels_per_meter(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1897
png_uint_32 png_get_y_pixels_per_meter(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1901
float png_get_pixel_aspect_ratio(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1903
png_fixed_point png_get_pixel_aspect_ratio_fixed(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1907
png_int_32 png_get_x_offset_pixels(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1909
png_int_32 png_get_y_offset_pixels(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1911
png_int_32 png_get_x_offset_microns(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1913
png_int_32 png_get_y_offset_microns(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1920
png_const_bytep png_get_signature(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1925
png_uint_32 png_get_bKGD(png_const_structrp png_ptr , png_inforp info_ptr , png_color_16p *background ) ;
#line 1930
void png_set_bKGD(png_const_structrp png_ptr , png_inforp info_ptr , png_const_color_16p background ) ;
#line 1935
png_uint_32 png_get_cHRM(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                         double *white_x , double *white_y , double *red_x , double *red_y ,
                         double *green_x , double *green_y , double *blue_x , double *blue_y ) ;
#line 1939
png_uint_32 png_get_cHRM_XYZ(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                             double *red_X , double *red_Y , double *red_Z , double *green_X ,
                             double *green_Y , double *green_Z , double *blue_X ,
                             double *blue_Y , double *blue_Z ) ;
#line 1943
png_uint_32 png_get_cHRM_fixed(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                               png_fixed_point *white_x , png_fixed_point *white_y ,
                               png_fixed_point *red_x , png_fixed_point *red_y , png_fixed_point *green_x ,
                               png_fixed_point *green_y , png_fixed_point *blue_x ,
                               png_fixed_point *blue_y ) ;
#line 1949
png_uint_32 png_get_cHRM_XYZ_fixed(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                   png_fixed_point *int_red_X , png_fixed_point *int_red_Y ,
                                   png_fixed_point *int_red_Z , png_fixed_point *int_green_X ,
                                   png_fixed_point *int_green_Y , png_fixed_point *int_green_Z ,
                                   png_fixed_point *int_blue_X , png_fixed_point *int_blue_Y ,
                                   png_fixed_point *int_blue_Z ) ;
#line 1959
void png_set_cHRM(png_const_structrp png_ptr , png_inforp info_ptr , double white_x ,
                  double white_y , double red_x , double red_y , double green_x ,
                  double green_y , double blue_x , double blue_y ) ;
#line 1963
void png_set_cHRM_XYZ(png_const_structrp png_ptr , png_inforp info_ptr , double red_X ,
                      double red_Y , double red_Z , double green_X , double green_Y ,
                      double green_Z , double blue_X , double blue_Y , double blue_Z ) ;
#line 1967
void png_set_cHRM_fixed(png_const_structrp png_ptr , png_inforp info_ptr , png_fixed_point white_x ,
                        png_fixed_point white_y , png_fixed_point red_x , png_fixed_point red_y ,
                        png_fixed_point green_x , png_fixed_point green_y , png_fixed_point blue_x ,
                        png_fixed_point blue_y ) ;
#line 1973
void png_set_cHRM_XYZ_fixed(png_const_structrp png_ptr , png_inforp info_ptr , png_fixed_point int_red_X ,
                            png_fixed_point int_red_Y , png_fixed_point int_red_Z ,
                            png_fixed_point int_green_X , png_fixed_point int_green_Y ,
                            png_fixed_point int_green_Z , png_fixed_point int_blue_X ,
                            png_fixed_point int_blue_Y , png_fixed_point int_blue_Z ) ;
#line 1982
png_uint_32 png_get_eXIf(png_const_structrp png_ptr , png_inforp info_ptr , png_bytep *exif ) ;
#line 1984
void png_set_eXIf(png_const_structrp png_ptr , png_inforp info_ptr , png_bytep eXIf_buf ) ;
#line 1987
png_uint_32 png_get_eXIf_1(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                           png_uint_32 *num_exif , png_bytep *exif ) ;
#line 1989
void png_set_eXIf_1(png_const_structrp png_ptr , png_inforp info_ptr , png_uint_32 num_exif ,
                    png_bytep eXIf_buf ) ;
#line 1994
png_uint_32 png_get_gAMA(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                         double *file_gamma ) ;
#line 1996
png_uint_32 png_get_gAMA_fixed(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                               png_fixed_point *file_gamma ) ;
#line 2002
void png_set_gAMA(png_const_structrp png_ptr , png_inforp info_ptr , double file_gamma ) ;
#line 2004
void png_set_gAMA_fixed(png_const_structrp png_ptr , png_inforp info_ptr , png_fixed_point file_gamma ) ;
#line 2009
png_uint_32 png_get_hIST(png_const_structrp png_ptr , png_inforp info_ptr , png_uint_16p *hist ) ;
#line 2011
void png_set_hIST(png_const_structrp png_ptr , png_inforp info_ptr , png_const_uint_16p hist ) ;
#line 2015
png_uint_32 png_get_IHDR(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                         png_uint_32 *width , png_uint_32 *height , int *bit_depth ,
                         int *color_type , int *interlace_type , int *compression_type ,
                         int *filter_type ) ;
#line 2020
void png_set_IHDR(png_const_structrp png_ptr , png_inforp info_ptr , png_uint_32 width ,
                  png_uint_32 height , int bit_depth , int color_type , int interlace_type ,
                  int compression_type , int filter_type ) ;
#line 2026
png_uint_32 png_get_oFFs(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                         png_int_32 *offset_x , png_int_32 *offset_y , int *unit_type ) ;
#line 2032
void png_set_oFFs(png_const_structrp png_ptr , png_inforp info_ptr , png_int_32 offset_x ,
                  png_int_32 offset_y , int unit_type ) ;
#line 2038
png_uint_32 png_get_pCAL(png_const_structrp png_ptr , png_inforp info_ptr , png_charp *purpose ,
                         png_int_32 *X0 , png_int_32 *X1 , int *type , int *nparams ,
                         png_charp *units , png_charpp *params ) ;
#line 2045
void png_set_pCAL(png_const_structrp png_ptr , png_inforp info_ptr , png_const_charp purpose ,
                  png_int_32 X0 , png_int_32 X1 , int type , int nparams , png_const_charp units ,
                  png_charpp params ) ;
#line 2051
png_uint_32 png_get_pHYs(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                         png_uint_32 *res_x , png_uint_32 *res_y , int *unit_type ) ;
#line 2057
void png_set_pHYs(png_const_structrp png_ptr , png_inforp info_ptr , png_uint_32 res_x ,
                  png_uint_32 res_y , int unit_type ) ;
#line 2061
png_uint_32 png_get_PLTE(png_const_structrp png_ptr , png_inforp info_ptr , png_colorp *palette ,
                         int *num_palette ) ;
#line 2064
void png_set_PLTE(png_structrp png_ptr , png_inforp info_ptr , png_const_colorp palette ,
                  int num_palette ) ;
#line 2068
png_uint_32 png_get_sBIT(png_const_structrp png_ptr , png_inforp info_ptr , png_color_8p *sig_bit ) ;
#line 2073
void png_set_sBIT(png_const_structrp png_ptr , png_inforp info_ptr , png_const_color_8p sig_bit ) ;
#line 2078
png_uint_32 png_get_sRGB(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                         int *file_srgb_intent ) ;
#line 2083
void png_set_sRGB(png_const_structrp png_ptr , png_inforp info_ptr , int srgb_intent ) ;
#line 2085
void png_set_sRGB_gAMA_and_cHRM(png_const_structrp png_ptr , png_inforp info_ptr ,
                                int srgb_intent ) ;
#line 2090
png_uint_32 png_get_iCCP(png_const_structrp png_ptr , png_inforp info_ptr , png_charpp name ,
                         int *compression_type , png_bytepp profile , png_uint_32 *proflen ) ;
#line 2096
void png_set_iCCP(png_const_structrp png_ptr , png_inforp info_ptr , png_const_charp name ,
                  int compression_type , png_const_bytep profile , png_uint_32 proflen ) ;
#line 2102
int png_get_sPLT(png_const_structrp png_ptr , png_inforp info_ptr , png_sPLT_tpp spalettes ) ;
#line 2107
void png_set_sPLT(png_const_structrp png_ptr , png_inforp info_ptr , png_const_sPLT_tp entries ,
                  int nentries ) ;
#line 2113
int png_get_text(png_const_structrp png_ptr , png_inforp info_ptr , png_textp *text_ptr ,
                 int *num_text ) ;
#line 2125
void png_set_text(png_const_structrp png_ptr , png_inforp info_ptr , png_const_textp text_ptr ,
                  int num_text ) ;
#line 2130
png_uint_32 png_get_tIME(png_const_structrp png_ptr , png_inforp info_ptr , png_timep *mod_time ) ;
#line 2135
void png_set_tIME(png_const_structrp png_ptr , png_inforp info_ptr , png_const_timep mod_time ) ;
#line 2140
png_uint_32 png_get_tRNS(png_const_structrp png_ptr , png_inforp info_ptr , png_bytep *trans_alpha ,
                         int *num_trans , png_color_16p *trans_color ) ;
#line 2146
void png_set_tRNS(png_structrp png_ptr , png_inforp info_ptr , png_const_bytep trans_alpha ,
                  int num_trans , png_const_color_16p trans_color ) ;
#line 2152
png_uint_32 png_get_sCAL(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                         int *unit , double *width , double *height ) ;
#line 2161
png_uint_32 png_get_sCAL_fixed(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                               int *unit , png_fixed_point *width , png_fixed_point *height ) ;
#line 2165
png_uint_32 png_get_sCAL_s(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                           int *unit , png_charpp width , png_charpp height ) ;
#line 2169
void png_set_sCAL(png_const_structrp png_ptr , png_inforp info_ptr , int unit , double width ,
                  double height ) ;
#line 2171
void png_set_sCAL_fixed(png_const_structrp png_ptr , png_inforp info_ptr , int unit ,
                        png_fixed_point width , png_fixed_point height ) ;
#line 2174
void png_set_sCAL_s(png_const_structrp png_ptr , png_inforp info_ptr , int unit ,
                    png_const_charp swidth , png_const_charp sheight ) ;
#line 2279
void png_set_keep_unknown_chunks(png_structrp png_ptr , int keep , png_const_bytep chunk_list ,
                                 int num_chunks_in ) ;
#line 2287
int png_handle_as_unknown(png_const_structrp png_ptr , png_const_bytep chunk_name ) ;
#line 2292
void png_set_unknown_chunks(png_const_structrp png_ptr , png_inforp info_ptr , png_const_unknown_chunkp unknowns ,
                            int num_unknowns ) ;
#line 2304
void png_set_unknown_chunk_location(png_const_structrp png_ptr , png_inforp info_ptr ,
                                    int chunk , int location ) ;
#line 2307
int png_get_unknown_chunks(png_const_structrp png_ptr , png_inforp info_ptr , png_unknown_chunkpp unknowns ) ;
#line 2315
void png_set_invalid(png_const_structrp png_ptr , png_inforp info_ptr , int mask ) ;
#line 2321
void png_read_png(png_structrp png_ptr , png_inforp info_ptr , int transforms , void *params ) ;
#line 2325
void png_write_png(png_structrp png_ptr , png_inforp info_ptr , int transforms , void *params ) ;
#line 2330
png_const_charp png_get_copyright(png_const_structrp png_ptr ) ;
#line 2332
png_const_charp png_get_header_ver(png_const_structrp png_ptr ) ;
#line 2334
png_const_charp png_get_header_version(png_const_structrp png_ptr ) ;
#line 2336
png_const_charp png_get_libpng_ver(png_const_structrp png_ptr ) ;
#line 2340
png_uint_32 png_permit_mng_features(png_structrp png_ptr , png_uint_32 mng_features ) ;
#line 2361
void png_set_user_limits(png_structrp png_ptr , png_uint_32 user_width_max , png_uint_32 user_height_max ) ;
#line 2363
png_uint_32 png_get_user_width_max(png_const_structrp png_ptr ) ;
#line 2365
png_uint_32 png_get_user_height_max(png_const_structrp png_ptr ) ;
#line 2368
void png_set_chunk_cache_max(png_structrp png_ptr , png_uint_32 user_chunk_cache_max ) ;
#line 2370
png_uint_32 png_get_chunk_cache_max(png_const_structrp png_ptr ) ;
#line 2373
void png_set_chunk_malloc_max(png_structrp png_ptr , png_alloc_size_t user_chunk_malloc_max ) ;
#line 2375
png_alloc_size_t png_get_chunk_malloc_max(png_const_structrp png_ptr ) ;
#line 2380
png_uint_32 png_get_pixels_per_inch(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 2383
png_uint_32 png_get_x_pixels_per_inch(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 2386
png_uint_32 png_get_y_pixels_per_inch(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 2389
float png_get_x_offset_inches(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 2392
png_fixed_point png_get_x_offset_inches_fixed(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 2396
float png_get_y_offset_inches(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 2399
png_fixed_point png_get_y_offset_inches_fixed(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 2404
png_uint_32 png_get_pHYs_dpi(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                             png_uint_32 *res_x , png_uint_32 *res_y , int *unit_type ) ;
#line 2412
png_uint_32 png_get_io_state(png_const_structrp png_ptr ) ;
#line 2418
png_uint_32 png_get_io_chunk_type(png_const_structrp png_ptr ) ;
#line 2544
png_uint_32 png_get_uint_32(png_const_bytep buf ) ;
#line 2545
png_uint_16 png_get_uint_16(png_const_bytep buf ) ;
#line 2546
png_int_32 png_get_int_32(png_const_bytep buf ) ;
#line 2549
png_uint_32 png_get_uint_31(png_const_structrp png_ptr , png_const_bytep buf ) ;
#line 2555
void png_save_uint_32(png_bytep buf , png_uint_32 i ) ;
#line 2558
void png_save_int_32(png_bytep buf , png_int_32 i ) ;
#line 2566
void png_save_uint_16(png_bytep buf , unsigned int i ) ;
#line 2612
void png_set_check_for_invalid_index(png_structrp png_ptr , int allowed ) ;
#line 2615
int png_get_palette_max(png_const_structp png_ptr , png_const_infop info_ptr ) ;
#line 2980
int png_image_begin_read_from_file(png_imagep image , char const   *file_name ) ;
#line 2986
int png_image_begin_read_from_stdio(png_imagep image , FILE *file ) ;
#line 2991
int png_image_begin_read_from_memory(png_imagep image , png_const_voidp memory , size_t size ) ;
#line 2995
int png_image_finish_read(png_imagep image , png_const_colorp background , void *buffer___0 ,
                          png_int_32 row_stride , void *colormap ) ;
#line 3030
void png_image_free(png_imagep image ) ;
#line 3054
int png_image_write_to_file(png_imagep image , char const   *file_name , int convert_to_8bit ,
                            void const   *buffer___0 , png_int_32 row_stride , void const   *colormap ) ;
#line 3059
int png_image_write_to_stdio(png_imagep image , FILE *file , int convert_to_8bit ,
                             void const   *buffer___0 , png_int_32 row_stride , void const   *colormap ) ;
#line 3086
int png_image_write_to_memory(png_imagep image , void *memory , png_alloc_size_t *memory_bytes ,
                              int convert_to_8bit , void const   *buffer___0 , png_int_32 row_stride ,
                              void const   *colormap ) ;
#line 3222
int png_set_option(png_structrp png_ptr , int option , int onoff ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern int ( __attribute__((__leaf__)) __fpclassify)(double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 25
extern int ( __attribute__((__leaf__)) __signbit)(double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 30
extern int ( __attribute__((__leaf__)) __isinf)(double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 33
extern int ( __attribute__((__leaf__)) __finite)(double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 36
extern int ( __attribute__((__leaf__)) __isnan)(double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 39
extern int ( __attribute__((__leaf__)) __iseqsig)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 42
extern int ( __attribute__((__leaf__)) __issignaling)(double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern double ( __attribute__((__leaf__)) acos)(double __x )  __attribute__((__nothrow__)) ;
#line 53
extern double ( __attribute__((__leaf__)) __acos)(double __x )  __attribute__((__nothrow__)) ;
#line 55
extern double ( __attribute__((__leaf__)) asin)(double __x )  __attribute__((__nothrow__)) ;
#line 55
extern double ( __attribute__((__leaf__)) __asin)(double __x )  __attribute__((__nothrow__)) ;
#line 57
extern double ( __attribute__((__leaf__)) atan)(double __x )  __attribute__((__nothrow__)) ;
#line 57
extern double ( __attribute__((__leaf__)) __atan)(double __x )  __attribute__((__nothrow__)) ;
#line 59
extern double ( __attribute__((__leaf__)) atan2)(double __y , double __x )  __attribute__((__nothrow__)) ;
#line 59
extern double ( __attribute__((__leaf__)) __atan2)(double __y , double __x )  __attribute__((__nothrow__)) ;
#line 62
extern double ( __attribute__((__leaf__)) cos)(double __x )  __attribute__((__nothrow__)) ;
#line 62
extern double ( __attribute__((__leaf__)) __cos)(double __x )  __attribute__((__nothrow__)) ;
#line 64
extern double ( __attribute__((__leaf__)) sin)(double __x )  __attribute__((__nothrow__)) ;
#line 64
extern double ( __attribute__((__leaf__)) __sin)(double __x )  __attribute__((__nothrow__)) ;
#line 66
extern double ( __attribute__((__leaf__)) tan)(double __x )  __attribute__((__nothrow__)) ;
#line 66
extern double ( __attribute__((__leaf__)) __tan)(double __x )  __attribute__((__nothrow__)) ;
#line 71
extern double ( __attribute__((__leaf__)) cosh)(double __x )  __attribute__((__nothrow__)) ;
#line 71
extern double ( __attribute__((__leaf__)) __cosh)(double __x )  __attribute__((__nothrow__)) ;
#line 73
extern double ( __attribute__((__leaf__)) sinh)(double __x )  __attribute__((__nothrow__)) ;
#line 73
extern double ( __attribute__((__leaf__)) __sinh)(double __x )  __attribute__((__nothrow__)) ;
#line 75
extern double ( __attribute__((__leaf__)) tanh)(double __x )  __attribute__((__nothrow__)) ;
#line 75
extern double ( __attribute__((__leaf__)) __tanh)(double __x )  __attribute__((__nothrow__)) ;
#line 85
extern double ( __attribute__((__leaf__)) acosh)(double __x )  __attribute__((__nothrow__)) ;
#line 85
extern double ( __attribute__((__leaf__)) __acosh)(double __x )  __attribute__((__nothrow__)) ;
#line 87
extern double ( __attribute__((__leaf__)) asinh)(double __x )  __attribute__((__nothrow__)) ;
#line 87
extern double ( __attribute__((__leaf__)) __asinh)(double __x )  __attribute__((__nothrow__)) ;
#line 89
extern double ( __attribute__((__leaf__)) atanh)(double __x )  __attribute__((__nothrow__)) ;
#line 89
extern double ( __attribute__((__leaf__)) __atanh)(double __x )  __attribute__((__nothrow__)) ;
#line 95
extern double ( __attribute__((__leaf__)) exp)(double __x )  __attribute__((__nothrow__)) ;
#line 95
extern double ( __attribute__((__leaf__)) __exp)(double __x )  __attribute__((__nothrow__)) ;
#line 98
extern double ( __attribute__((__leaf__)) frexp)(double __x , int *__exponent )  __attribute__((__nothrow__)) ;
#line 98
extern double ( __attribute__((__leaf__)) __frexp)(double __x , int *__exponent )  __attribute__((__nothrow__)) ;
#line 101
extern double ( __attribute__((__leaf__)) ldexp)(double __x , int __exponent )  __attribute__((__nothrow__)) ;
#line 101
extern double ( __attribute__((__leaf__)) __ldexp)(double __x , int __exponent )  __attribute__((__nothrow__)) ;
#line 104
extern double ( __attribute__((__leaf__)) log)(double __x )  __attribute__((__nothrow__)) ;
#line 104
extern double ( __attribute__((__leaf__)) __log)(double __x )  __attribute__((__nothrow__)) ;
#line 107
extern double ( __attribute__((__leaf__)) log10)(double __x )  __attribute__((__nothrow__)) ;
#line 107
extern double ( __attribute__((__leaf__)) __log10)(double __x )  __attribute__((__nothrow__)) ;
#line 110
extern double ( __attribute__((__leaf__)) modf)(double __x , double *__iptr )  __attribute__((__nothrow__)) ;
#line 110
extern double ( __attribute__((__nonnull__(2), __leaf__)) __modf)(double __x , double *__iptr )  __attribute__((__nothrow__)) ;
#line 119
extern double ( __attribute__((__leaf__)) expm1)(double __x )  __attribute__((__nothrow__)) ;
#line 119
extern double ( __attribute__((__leaf__)) __expm1)(double __x )  __attribute__((__nothrow__)) ;
#line 122
extern double ( __attribute__((__leaf__)) log1p)(double __x )  __attribute__((__nothrow__)) ;
#line 122
extern double ( __attribute__((__leaf__)) __log1p)(double __x )  __attribute__((__nothrow__)) ;
#line 125
extern double ( __attribute__((__leaf__)) logb)(double __x )  __attribute__((__nothrow__)) ;
#line 125
extern double ( __attribute__((__leaf__)) __logb)(double __x )  __attribute__((__nothrow__)) ;
#line 130
extern double ( __attribute__((__leaf__)) exp2)(double __x )  __attribute__((__nothrow__)) ;
#line 130
extern double ( __attribute__((__leaf__)) __exp2)(double __x )  __attribute__((__nothrow__)) ;
#line 133
extern double ( __attribute__((__leaf__)) log2)(double __x )  __attribute__((__nothrow__)) ;
#line 133
extern double ( __attribute__((__leaf__)) __log2)(double __x )  __attribute__((__nothrow__)) ;
#line 140
extern double ( __attribute__((__leaf__)) pow)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 140
extern double ( __attribute__((__leaf__)) __pow)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 143
extern double ( __attribute__((__leaf__)) sqrt)(double __x )  __attribute__((__nothrow__)) ;
#line 143
extern double ( __attribute__((__leaf__)) __sqrt)(double __x )  __attribute__((__nothrow__)) ;
#line 147
extern double ( __attribute__((__leaf__)) hypot)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 147
extern double ( __attribute__((__leaf__)) __hypot)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 152
extern double ( __attribute__((__leaf__)) cbrt)(double __x )  __attribute__((__nothrow__)) ;
#line 152
extern double ( __attribute__((__leaf__)) __cbrt)(double __x )  __attribute__((__nothrow__)) ;
#line 159
extern double ( __attribute__((__leaf__)) ceil)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 159
extern double ( __attribute__((__leaf__)) __ceil)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 162
extern double ( __attribute__((__leaf__)) fabs)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 162
extern double ( __attribute__((__leaf__)) __fabs)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 165
extern double ( __attribute__((__leaf__)) floor)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 165
extern double ( __attribute__((__leaf__)) __floor)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 168
extern double ( __attribute__((__leaf__)) fmod)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 168
extern double ( __attribute__((__leaf__)) __fmod)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 196
extern double ( __attribute__((__leaf__)) copysign)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 196
extern double ( __attribute__((__leaf__)) __copysign)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 201
extern double ( __attribute__((__leaf__)) nan)(char const   *__tagb )  __attribute__((__nothrow__)) ;
#line 201
extern double ( __attribute__((__leaf__)) __nan)(char const   *__tagb )  __attribute__((__nothrow__)) ;
#line 228
extern double ( __attribute__((__leaf__)) erf)(double  )  __attribute__((__nothrow__)) ;
#line 228
extern double ( __attribute__((__leaf__)) __erf)(double  )  __attribute__((__nothrow__)) ;
#line 229
extern double ( __attribute__((__leaf__)) erfc)(double  )  __attribute__((__nothrow__)) ;
#line 229
extern double ( __attribute__((__leaf__)) __erfc)(double  )  __attribute__((__nothrow__)) ;
#line 230
extern double ( __attribute__((__leaf__)) lgamma)(double  )  __attribute__((__nothrow__)) ;
#line 230
extern double ( __attribute__((__leaf__)) __lgamma)(double  )  __attribute__((__nothrow__)) ;
#line 235
extern double ( __attribute__((__leaf__)) tgamma)(double  )  __attribute__((__nothrow__)) ;
#line 235
extern double ( __attribute__((__leaf__)) __tgamma)(double  )  __attribute__((__nothrow__)) ;
#line 256
extern double ( __attribute__((__leaf__)) rint)(double __x )  __attribute__((__nothrow__)) ;
#line 256
extern double ( __attribute__((__leaf__)) __rint)(double __x )  __attribute__((__nothrow__)) ;
#line 259
extern double ( __attribute__((__leaf__)) nextafter)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 259
extern double ( __attribute__((__leaf__)) __nextafter)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 261
extern double ( __attribute__((__leaf__)) nexttoward)(double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 261
extern double ( __attribute__((__leaf__)) __nexttoward)(double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 272
extern double ( __attribute__((__leaf__)) remainder)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 272
extern double ( __attribute__((__leaf__)) __remainder)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 276
extern double ( __attribute__((__leaf__)) scalbn)(double __x , int __n )  __attribute__((__nothrow__)) ;
#line 276
extern double ( __attribute__((__leaf__)) __scalbn)(double __x , int __n )  __attribute__((__nothrow__)) ;
#line 280
extern int ( __attribute__((__leaf__)) ilogb)(double __x )  __attribute__((__nothrow__)) ;
#line 280
extern int ( __attribute__((__leaf__)) __ilogb)(double __x )  __attribute__((__nothrow__)) ;
#line 290
extern double ( __attribute__((__leaf__)) scalbln)(double __x , long __n )  __attribute__((__nothrow__)) ;
#line 290
extern double ( __attribute__((__leaf__)) __scalbln)(double __x , long __n )  __attribute__((__nothrow__)) ;
#line 294
extern double ( __attribute__((__leaf__)) nearbyint)(double __x )  __attribute__((__nothrow__)) ;
#line 294
extern double ( __attribute__((__leaf__)) __nearbyint)(double __x )  __attribute__((__nothrow__)) ;
#line 298
extern double ( __attribute__((__leaf__)) round)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 298
extern double ( __attribute__((__leaf__)) __round)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 302
extern double ( __attribute__((__leaf__)) trunc)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 302
extern double ( __attribute__((__leaf__)) __trunc)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 307
extern double ( __attribute__((__leaf__)) remquo)(double __x , double __y , int *__quo )  __attribute__((__nothrow__)) ;
#line 307
extern double ( __attribute__((__leaf__)) __remquo)(double __x , double __y , int *__quo )  __attribute__((__nothrow__)) ;
#line 314
extern long ( __attribute__((__leaf__)) lrint)(double __x )  __attribute__((__nothrow__)) ;
#line 314
extern long ( __attribute__((__leaf__)) __lrint)(double __x )  __attribute__((__nothrow__)) ;
#line 316
extern long long ( __attribute__((__leaf__)) llrint)(double __x )  __attribute__((__nothrow__)) ;
#line 316
extern long long ( __attribute__((__leaf__)) __llrint)(double __x )  __attribute__((__nothrow__)) ;
#line 320
extern long ( __attribute__((__leaf__)) lround)(double __x )  __attribute__((__nothrow__)) ;
#line 320
extern long ( __attribute__((__leaf__)) __lround)(double __x )  __attribute__((__nothrow__)) ;
#line 322
extern long long ( __attribute__((__leaf__)) llround)(double __x )  __attribute__((__nothrow__)) ;
#line 322
extern long long ( __attribute__((__leaf__)) __llround)(double __x )  __attribute__((__nothrow__)) ;
#line 326
extern double ( __attribute__((__leaf__)) fdim)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 326
extern double ( __attribute__((__leaf__)) __fdim)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 329
extern double ( __attribute__((__leaf__)) fmax)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 329
extern double ( __attribute__((__leaf__)) __fmax)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 332
extern double ( __attribute__((__leaf__)) fmin)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 332
extern double ( __attribute__((__leaf__)) __fmin)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 335
extern double ( __attribute__((__leaf__)) fma)(double __x , double __y , double __z )  __attribute__((__nothrow__)) ;
#line 335
extern double ( __attribute__((__leaf__)) __fma)(double __x , double __y , double __z )  __attribute__((__nothrow__)) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern int ( __attribute__((__leaf__)) __fpclassifyf)(float __value )  __attribute__((__nothrow__,
__const__)) ;
#line 25
extern int ( __attribute__((__leaf__)) __signbitf)(float __value )  __attribute__((__nothrow__,
__const__)) ;
#line 30
extern int ( __attribute__((__leaf__)) __isinff)(float __value )  __attribute__((__nothrow__,
__const__)) ;
#line 33
extern int ( __attribute__((__leaf__)) __finitef)(float __value )  __attribute__((__nothrow__,
__const__)) ;
#line 36
extern int ( __attribute__((__leaf__)) __isnanf)(float __value )  __attribute__((__nothrow__,
__const__)) ;
#line 39
extern int ( __attribute__((__leaf__)) __iseqsigf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 42
extern int ( __attribute__((__leaf__)) __issignalingf)(float __value )  __attribute__((__nothrow__,
__const__)) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern float ( __attribute__((__leaf__)) acosf)(float __x )  __attribute__((__nothrow__)) ;
#line 53
extern float ( __attribute__((__leaf__)) __acosf)(float __x )  __attribute__((__nothrow__)) ;
#line 55
extern float ( __attribute__((__leaf__)) asinf)(float __x )  __attribute__((__nothrow__)) ;
#line 55
extern float ( __attribute__((__leaf__)) __asinf)(float __x )  __attribute__((__nothrow__)) ;
#line 57
extern float ( __attribute__((__leaf__)) atanf)(float __x )  __attribute__((__nothrow__)) ;
#line 57
extern float ( __attribute__((__leaf__)) __atanf)(float __x )  __attribute__((__nothrow__)) ;
#line 59
extern float ( __attribute__((__leaf__)) atan2f)(float __y , float __x )  __attribute__((__nothrow__)) ;
#line 59
extern float ( __attribute__((__leaf__)) __atan2f)(float __y , float __x )  __attribute__((__nothrow__)) ;
#line 62
extern float ( __attribute__((__leaf__)) cosf)(float __x )  __attribute__((__nothrow__)) ;
#line 62
extern float ( __attribute__((__leaf__)) __cosf)(float __x )  __attribute__((__nothrow__)) ;
#line 64
extern float ( __attribute__((__leaf__)) sinf)(float __x )  __attribute__((__nothrow__)) ;
#line 64
extern float ( __attribute__((__leaf__)) __sinf)(float __x )  __attribute__((__nothrow__)) ;
#line 66
extern float ( __attribute__((__leaf__)) tanf)(float __x )  __attribute__((__nothrow__)) ;
#line 66
extern float ( __attribute__((__leaf__)) __tanf)(float __x )  __attribute__((__nothrow__)) ;
#line 71
extern float ( __attribute__((__leaf__)) coshf)(float __x )  __attribute__((__nothrow__)) ;
#line 71
extern float ( __attribute__((__leaf__)) __coshf)(float __x )  __attribute__((__nothrow__)) ;
#line 73
extern float ( __attribute__((__leaf__)) sinhf)(float __x )  __attribute__((__nothrow__)) ;
#line 73
extern float ( __attribute__((__leaf__)) __sinhf)(float __x )  __attribute__((__nothrow__)) ;
#line 75
extern float ( __attribute__((__leaf__)) tanhf)(float __x )  __attribute__((__nothrow__)) ;
#line 75
extern float ( __attribute__((__leaf__)) __tanhf)(float __x )  __attribute__((__nothrow__)) ;
#line 85
extern float ( __attribute__((__leaf__)) acoshf)(float __x )  __attribute__((__nothrow__)) ;
#line 85
extern float ( __attribute__((__leaf__)) __acoshf)(float __x )  __attribute__((__nothrow__)) ;
#line 87
extern float ( __attribute__((__leaf__)) asinhf)(float __x )  __attribute__((__nothrow__)) ;
#line 87
extern float ( __attribute__((__leaf__)) __asinhf)(float __x )  __attribute__((__nothrow__)) ;
#line 89
extern float ( __attribute__((__leaf__)) atanhf)(float __x )  __attribute__((__nothrow__)) ;
#line 89
extern float ( __attribute__((__leaf__)) __atanhf)(float __x )  __attribute__((__nothrow__)) ;
#line 95
extern float ( __attribute__((__leaf__)) expf)(float __x )  __attribute__((__nothrow__)) ;
#line 95
extern float ( __attribute__((__leaf__)) __expf)(float __x )  __attribute__((__nothrow__)) ;
#line 98
extern float ( __attribute__((__leaf__)) frexpf)(float __x , int *__exponent )  __attribute__((__nothrow__)) ;
#line 98
extern float ( __attribute__((__leaf__)) __frexpf)(float __x , int *__exponent )  __attribute__((__nothrow__)) ;
#line 101
extern float ( __attribute__((__leaf__)) ldexpf)(float __x , int __exponent )  __attribute__((__nothrow__)) ;
#line 101
extern float ( __attribute__((__leaf__)) __ldexpf)(float __x , int __exponent )  __attribute__((__nothrow__)) ;
#line 104
extern float ( __attribute__((__leaf__)) logf)(float __x )  __attribute__((__nothrow__)) ;
#line 104
extern float ( __attribute__((__leaf__)) __logf)(float __x )  __attribute__((__nothrow__)) ;
#line 107
extern float ( __attribute__((__leaf__)) log10f)(float __x )  __attribute__((__nothrow__)) ;
#line 107
extern float ( __attribute__((__leaf__)) __log10f)(float __x )  __attribute__((__nothrow__)) ;
#line 110
extern float ( __attribute__((__leaf__)) modff)(float __x , float *__iptr )  __attribute__((__nothrow__)) ;
#line 110
extern float ( __attribute__((__nonnull__(2), __leaf__)) __modff)(float __x , float *__iptr )  __attribute__((__nothrow__)) ;
#line 119
extern float ( __attribute__((__leaf__)) expm1f)(float __x )  __attribute__((__nothrow__)) ;
#line 119
extern float ( __attribute__((__leaf__)) __expm1f)(float __x )  __attribute__((__nothrow__)) ;
#line 122
extern float ( __attribute__((__leaf__)) log1pf)(float __x )  __attribute__((__nothrow__)) ;
#line 122
extern float ( __attribute__((__leaf__)) __log1pf)(float __x )  __attribute__((__nothrow__)) ;
#line 125
extern float ( __attribute__((__leaf__)) logbf)(float __x )  __attribute__((__nothrow__)) ;
#line 125
extern float ( __attribute__((__leaf__)) __logbf)(float __x )  __attribute__((__nothrow__)) ;
#line 130
extern float ( __attribute__((__leaf__)) exp2f)(float __x )  __attribute__((__nothrow__)) ;
#line 130
extern float ( __attribute__((__leaf__)) __exp2f)(float __x )  __attribute__((__nothrow__)) ;
#line 133
extern float ( __attribute__((__leaf__)) log2f)(float __x )  __attribute__((__nothrow__)) ;
#line 133
extern float ( __attribute__((__leaf__)) __log2f)(float __x )  __attribute__((__nothrow__)) ;
#line 140
extern float ( __attribute__((__leaf__)) powf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 140
extern float ( __attribute__((__leaf__)) __powf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 143
extern float ( __attribute__((__leaf__)) sqrtf)(float __x )  __attribute__((__nothrow__)) ;
#line 143
extern float ( __attribute__((__leaf__)) __sqrtf)(float __x )  __attribute__((__nothrow__)) ;
#line 147
extern float ( __attribute__((__leaf__)) hypotf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 147
extern float ( __attribute__((__leaf__)) __hypotf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 152
extern float ( __attribute__((__leaf__)) cbrtf)(float __x )  __attribute__((__nothrow__)) ;
#line 152
extern float ( __attribute__((__leaf__)) __cbrtf)(float __x )  __attribute__((__nothrow__)) ;
#line 159
extern float ( __attribute__((__leaf__)) ceilf)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 159
extern float ( __attribute__((__leaf__)) __ceilf)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 162
extern float ( __attribute__((__leaf__)) fabsf)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 162
extern float ( __attribute__((__leaf__)) __fabsf)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 165
extern float ( __attribute__((__leaf__)) floorf)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 165
extern float ( __attribute__((__leaf__)) __floorf)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 168
extern float ( __attribute__((__leaf__)) fmodf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 168
extern float ( __attribute__((__leaf__)) __fmodf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 196
extern float ( __attribute__((__leaf__)) copysignf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 196
extern float ( __attribute__((__leaf__)) __copysignf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 201
extern float ( __attribute__((__leaf__)) nanf)(char const   *__tagb )  __attribute__((__nothrow__)) ;
#line 201
extern float ( __attribute__((__leaf__)) __nanf)(char const   *__tagb )  __attribute__((__nothrow__)) ;
#line 228
extern float ( __attribute__((__leaf__)) erff)(float  )  __attribute__((__nothrow__)) ;
#line 228
extern float ( __attribute__((__leaf__)) __erff)(float  )  __attribute__((__nothrow__)) ;
#line 229
extern float ( __attribute__((__leaf__)) erfcf)(float  )  __attribute__((__nothrow__)) ;
#line 229
extern float ( __attribute__((__leaf__)) __erfcf)(float  )  __attribute__((__nothrow__)) ;
#line 230
extern float ( __attribute__((__leaf__)) lgammaf)(float  )  __attribute__((__nothrow__)) ;
#line 230
extern float ( __attribute__((__leaf__)) __lgammaf)(float  )  __attribute__((__nothrow__)) ;
#line 235
extern float ( __attribute__((__leaf__)) tgammaf)(float  )  __attribute__((__nothrow__)) ;
#line 235
extern float ( __attribute__((__leaf__)) __tgammaf)(float  )  __attribute__((__nothrow__)) ;
#line 256
extern float ( __attribute__((__leaf__)) rintf)(float __x )  __attribute__((__nothrow__)) ;
#line 256
extern float ( __attribute__((__leaf__)) __rintf)(float __x )  __attribute__((__nothrow__)) ;
#line 259
extern float ( __attribute__((__leaf__)) nextafterf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 259
extern float ( __attribute__((__leaf__)) __nextafterf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 261
extern float ( __attribute__((__leaf__)) nexttowardf)(float __x , long double __y )  __attribute__((__nothrow__)) ;
#line 261
extern float ( __attribute__((__leaf__)) __nexttowardf)(float __x , long double __y )  __attribute__((__nothrow__)) ;
#line 272
extern float ( __attribute__((__leaf__)) remainderf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 272
extern float ( __attribute__((__leaf__)) __remainderf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 276
extern float ( __attribute__((__leaf__)) scalbnf)(float __x , int __n )  __attribute__((__nothrow__)) ;
#line 276
extern float ( __attribute__((__leaf__)) __scalbnf)(float __x , int __n )  __attribute__((__nothrow__)) ;
#line 280
extern int ( __attribute__((__leaf__)) ilogbf)(float __x )  __attribute__((__nothrow__)) ;
#line 280
extern int ( __attribute__((__leaf__)) __ilogbf)(float __x )  __attribute__((__nothrow__)) ;
#line 290
extern float ( __attribute__((__leaf__)) scalblnf)(float __x , long __n )  __attribute__((__nothrow__)) ;
#line 290
extern float ( __attribute__((__leaf__)) __scalblnf)(float __x , long __n )  __attribute__((__nothrow__)) ;
#line 294
extern float ( __attribute__((__leaf__)) nearbyintf)(float __x )  __attribute__((__nothrow__)) ;
#line 294
extern float ( __attribute__((__leaf__)) __nearbyintf)(float __x )  __attribute__((__nothrow__)) ;
#line 298
extern float ( __attribute__((__leaf__)) roundf)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 298
extern float ( __attribute__((__leaf__)) __roundf)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 302
extern float ( __attribute__((__leaf__)) truncf)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 302
extern float ( __attribute__((__leaf__)) __truncf)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 307
extern float ( __attribute__((__leaf__)) remquof)(float __x , float __y , int *__quo )  __attribute__((__nothrow__)) ;
#line 307
extern float ( __attribute__((__leaf__)) __remquof)(float __x , float __y , int *__quo )  __attribute__((__nothrow__)) ;
#line 314
extern long ( __attribute__((__leaf__)) lrintf)(float __x )  __attribute__((__nothrow__)) ;
#line 314
extern long ( __attribute__((__leaf__)) __lrintf)(float __x )  __attribute__((__nothrow__)) ;
#line 316
extern long long ( __attribute__((__leaf__)) llrintf)(float __x )  __attribute__((__nothrow__)) ;
#line 316
extern long long ( __attribute__((__leaf__)) __llrintf)(float __x )  __attribute__((__nothrow__)) ;
#line 320
extern long ( __attribute__((__leaf__)) lroundf)(float __x )  __attribute__((__nothrow__)) ;
#line 320
extern long ( __attribute__((__leaf__)) __lroundf)(float __x )  __attribute__((__nothrow__)) ;
#line 322
extern long long ( __attribute__((__leaf__)) llroundf)(float __x )  __attribute__((__nothrow__)) ;
#line 322
extern long long ( __attribute__((__leaf__)) __llroundf)(float __x )  __attribute__((__nothrow__)) ;
#line 326
extern float ( __attribute__((__leaf__)) fdimf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 326
extern float ( __attribute__((__leaf__)) __fdimf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 329
extern float ( __attribute__((__leaf__)) fmaxf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 329
extern float ( __attribute__((__leaf__)) __fmaxf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 332
extern float ( __attribute__((__leaf__)) fminf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 332
extern float ( __attribute__((__leaf__)) __fminf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 335
extern float ( __attribute__((__leaf__)) fmaf)(float __x , float __y , float __z )  __attribute__((__nothrow__)) ;
#line 335
extern float ( __attribute__((__leaf__)) __fmaf)(float __x , float __y , float __z )  __attribute__((__nothrow__)) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern int ( __attribute__((__leaf__)) __fpclassifyl)(long double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 25
extern int ( __attribute__((__leaf__)) __signbitl)(long double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 30
extern int ( __attribute__((__leaf__)) __isinfl)(long double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 33
extern int ( __attribute__((__leaf__)) __finitel)(long double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 36
extern int ( __attribute__((__leaf__)) __isnanl)(long double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 39
extern int ( __attribute__((__leaf__)) __iseqsigl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 42
extern int ( __attribute__((__leaf__)) __issignalingl)(long double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern long double ( __attribute__((__leaf__)) acosl)(long double __x )  __attribute__((__nothrow__)) ;
#line 53
extern long double ( __attribute__((__leaf__)) __acosl)(long double __x )  __attribute__((__nothrow__)) ;
#line 55
extern long double ( __attribute__((__leaf__)) asinl)(long double __x )  __attribute__((__nothrow__)) ;
#line 55
extern long double ( __attribute__((__leaf__)) __asinl)(long double __x )  __attribute__((__nothrow__)) ;
#line 57
extern long double ( __attribute__((__leaf__)) atanl)(long double __x )  __attribute__((__nothrow__)) ;
#line 57
extern long double ( __attribute__((__leaf__)) __atanl)(long double __x )  __attribute__((__nothrow__)) ;
#line 59
extern long double ( __attribute__((__leaf__)) atan2l)(long double __y , long double __x )  __attribute__((__nothrow__)) ;
#line 59
extern long double ( __attribute__((__leaf__)) __atan2l)(long double __y , long double __x )  __attribute__((__nothrow__)) ;
#line 62
extern long double ( __attribute__((__leaf__)) cosl)(long double __x )  __attribute__((__nothrow__)) ;
#line 62
extern long double ( __attribute__((__leaf__)) __cosl)(long double __x )  __attribute__((__nothrow__)) ;
#line 64
extern long double ( __attribute__((__leaf__)) sinl)(long double __x )  __attribute__((__nothrow__)) ;
#line 64
extern long double ( __attribute__((__leaf__)) __sinl)(long double __x )  __attribute__((__nothrow__)) ;
#line 66
extern long double ( __attribute__((__leaf__)) tanl)(long double __x )  __attribute__((__nothrow__)) ;
#line 66
extern long double ( __attribute__((__leaf__)) __tanl)(long double __x )  __attribute__((__nothrow__)) ;
#line 71
extern long double ( __attribute__((__leaf__)) coshl)(long double __x )  __attribute__((__nothrow__)) ;
#line 71
extern long double ( __attribute__((__leaf__)) __coshl)(long double __x )  __attribute__((__nothrow__)) ;
#line 73
extern long double ( __attribute__((__leaf__)) sinhl)(long double __x )  __attribute__((__nothrow__)) ;
#line 73
extern long double ( __attribute__((__leaf__)) __sinhl)(long double __x )  __attribute__((__nothrow__)) ;
#line 75
extern long double ( __attribute__((__leaf__)) tanhl)(long double __x )  __attribute__((__nothrow__)) ;
#line 75
extern long double ( __attribute__((__leaf__)) __tanhl)(long double __x )  __attribute__((__nothrow__)) ;
#line 85
extern long double ( __attribute__((__leaf__)) acoshl)(long double __x )  __attribute__((__nothrow__)) ;
#line 85
extern long double ( __attribute__((__leaf__)) __acoshl)(long double __x )  __attribute__((__nothrow__)) ;
#line 87
extern long double ( __attribute__((__leaf__)) asinhl)(long double __x )  __attribute__((__nothrow__)) ;
#line 87
extern long double ( __attribute__((__leaf__)) __asinhl)(long double __x )  __attribute__((__nothrow__)) ;
#line 89
extern long double ( __attribute__((__leaf__)) atanhl)(long double __x )  __attribute__((__nothrow__)) ;
#line 89
extern long double ( __attribute__((__leaf__)) __atanhl)(long double __x )  __attribute__((__nothrow__)) ;
#line 95
extern long double ( __attribute__((__leaf__)) expl)(long double __x )  __attribute__((__nothrow__)) ;
#line 95
extern long double ( __attribute__((__leaf__)) __expl)(long double __x )  __attribute__((__nothrow__)) ;
#line 98
extern long double ( __attribute__((__leaf__)) frexpl)(long double __x , int *__exponent )  __attribute__((__nothrow__)) ;
#line 98
extern long double ( __attribute__((__leaf__)) __frexpl)(long double __x , int *__exponent )  __attribute__((__nothrow__)) ;
#line 101
extern long double ( __attribute__((__leaf__)) ldexpl)(long double __x , int __exponent )  __attribute__((__nothrow__)) ;
#line 101
extern long double ( __attribute__((__leaf__)) __ldexpl)(long double __x , int __exponent )  __attribute__((__nothrow__)) ;
#line 104
extern long double ( __attribute__((__leaf__)) logl)(long double __x )  __attribute__((__nothrow__)) ;
#line 104
extern long double ( __attribute__((__leaf__)) __logl)(long double __x )  __attribute__((__nothrow__)) ;
#line 107
extern long double ( __attribute__((__leaf__)) log10l)(long double __x )  __attribute__((__nothrow__)) ;
#line 107
extern long double ( __attribute__((__leaf__)) __log10l)(long double __x )  __attribute__((__nothrow__)) ;
#line 110
extern long double ( __attribute__((__leaf__)) modfl)(long double __x , long double *__iptr )  __attribute__((__nothrow__)) ;
#line 110
extern long double ( __attribute__((__nonnull__(2), __leaf__)) __modfl)(long double __x ,
                                                                        long double *__iptr )  __attribute__((__nothrow__)) ;
#line 119
extern long double ( __attribute__((__leaf__)) expm1l)(long double __x )  __attribute__((__nothrow__)) ;
#line 119
extern long double ( __attribute__((__leaf__)) __expm1l)(long double __x )  __attribute__((__nothrow__)) ;
#line 122
extern long double ( __attribute__((__leaf__)) log1pl)(long double __x )  __attribute__((__nothrow__)) ;
#line 122
extern long double ( __attribute__((__leaf__)) __log1pl)(long double __x )  __attribute__((__nothrow__)) ;
#line 125
extern long double ( __attribute__((__leaf__)) logbl)(long double __x )  __attribute__((__nothrow__)) ;
#line 125
extern long double ( __attribute__((__leaf__)) __logbl)(long double __x )  __attribute__((__nothrow__)) ;
#line 130
extern long double ( __attribute__((__leaf__)) exp2l)(long double __x )  __attribute__((__nothrow__)) ;
#line 130
extern long double ( __attribute__((__leaf__)) __exp2l)(long double __x )  __attribute__((__nothrow__)) ;
#line 133
extern long double ( __attribute__((__leaf__)) log2l)(long double __x )  __attribute__((__nothrow__)) ;
#line 133
extern long double ( __attribute__((__leaf__)) __log2l)(long double __x )  __attribute__((__nothrow__)) ;
#line 140
extern long double ( __attribute__((__leaf__)) powl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 140
extern long double ( __attribute__((__leaf__)) __powl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 143
extern long double ( __attribute__((__leaf__)) sqrtl)(long double __x )  __attribute__((__nothrow__)) ;
#line 143
extern long double ( __attribute__((__leaf__)) __sqrtl)(long double __x )  __attribute__((__nothrow__)) ;
#line 147
extern long double ( __attribute__((__leaf__)) hypotl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 147
extern long double ( __attribute__((__leaf__)) __hypotl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 152
extern long double ( __attribute__((__leaf__)) cbrtl)(long double __x )  __attribute__((__nothrow__)) ;
#line 152
extern long double ( __attribute__((__leaf__)) __cbrtl)(long double __x )  __attribute__((__nothrow__)) ;
#line 159
extern long double ( __attribute__((__leaf__)) ceill)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 159
extern long double ( __attribute__((__leaf__)) __ceill)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 162
extern long double ( __attribute__((__leaf__)) fabsl)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 162
extern long double ( __attribute__((__leaf__)) __fabsl)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 165
extern long double ( __attribute__((__leaf__)) floorl)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 165
extern long double ( __attribute__((__leaf__)) __floorl)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 168
extern long double ( __attribute__((__leaf__)) fmodl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 168
extern long double ( __attribute__((__leaf__)) __fmodl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 196
extern long double ( __attribute__((__leaf__)) copysignl)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 196
extern long double ( __attribute__((__leaf__)) __copysignl)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 201
extern long double ( __attribute__((__leaf__)) nanl)(char const   *__tagb )  __attribute__((__nothrow__)) ;
#line 201
extern long double ( __attribute__((__leaf__)) __nanl)(char const   *__tagb )  __attribute__((__nothrow__)) ;
#line 228
extern long double ( __attribute__((__leaf__)) erfl)(long double  )  __attribute__((__nothrow__)) ;
#line 228
extern long double ( __attribute__((__leaf__)) __erfl)(long double  )  __attribute__((__nothrow__)) ;
#line 229
extern long double ( __attribute__((__leaf__)) erfcl)(long double  )  __attribute__((__nothrow__)) ;
#line 229
extern long double ( __attribute__((__leaf__)) __erfcl)(long double  )  __attribute__((__nothrow__)) ;
#line 230
extern long double ( __attribute__((__leaf__)) lgammal)(long double  )  __attribute__((__nothrow__)) ;
#line 230
extern long double ( __attribute__((__leaf__)) __lgammal)(long double  )  __attribute__((__nothrow__)) ;
#line 235
extern long double ( __attribute__((__leaf__)) tgammal)(long double  )  __attribute__((__nothrow__)) ;
#line 235
extern long double ( __attribute__((__leaf__)) __tgammal)(long double  )  __attribute__((__nothrow__)) ;
#line 256
extern long double ( __attribute__((__leaf__)) rintl)(long double __x )  __attribute__((__nothrow__)) ;
#line 256
extern long double ( __attribute__((__leaf__)) __rintl)(long double __x )  __attribute__((__nothrow__)) ;
#line 259
extern long double ( __attribute__((__leaf__)) nextafterl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 259
extern long double ( __attribute__((__leaf__)) __nextafterl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 261
extern long double ( __attribute__((__leaf__)) nexttowardl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 261
extern long double ( __attribute__((__leaf__)) __nexttowardl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 272
extern long double ( __attribute__((__leaf__)) remainderl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 272
extern long double ( __attribute__((__leaf__)) __remainderl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 276
extern long double ( __attribute__((__leaf__)) scalbnl)(long double __x , int __n )  __attribute__((__nothrow__)) ;
#line 276
extern long double ( __attribute__((__leaf__)) __scalbnl)(long double __x , int __n )  __attribute__((__nothrow__)) ;
#line 280
extern int ( __attribute__((__leaf__)) ilogbl)(long double __x )  __attribute__((__nothrow__)) ;
#line 280
extern int ( __attribute__((__leaf__)) __ilogbl)(long double __x )  __attribute__((__nothrow__)) ;
#line 290
extern long double ( __attribute__((__leaf__)) scalblnl)(long double __x , long __n )  __attribute__((__nothrow__)) ;
#line 290
extern long double ( __attribute__((__leaf__)) __scalblnl)(long double __x , long __n )  __attribute__((__nothrow__)) ;
#line 294
extern long double ( __attribute__((__leaf__)) nearbyintl)(long double __x )  __attribute__((__nothrow__)) ;
#line 294
extern long double ( __attribute__((__leaf__)) __nearbyintl)(long double __x )  __attribute__((__nothrow__)) ;
#line 298
extern long double ( __attribute__((__leaf__)) roundl)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 298
extern long double ( __attribute__((__leaf__)) __roundl)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 302
extern long double ( __attribute__((__leaf__)) truncl)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 302
extern long double ( __attribute__((__leaf__)) __truncl)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 307
extern long double ( __attribute__((__leaf__)) remquol)(long double __x , long double __y ,
                                                        int *__quo )  __attribute__((__nothrow__)) ;
#line 307
extern long double ( __attribute__((__leaf__)) __remquol)(long double __x , long double __y ,
                                                          int *__quo )  __attribute__((__nothrow__)) ;
#line 314
extern long ( __attribute__((__leaf__)) lrintl)(long double __x )  __attribute__((__nothrow__)) ;
#line 314
extern long ( __attribute__((__leaf__)) __lrintl)(long double __x )  __attribute__((__nothrow__)) ;
#line 316
extern long long ( __attribute__((__leaf__)) llrintl)(long double __x )  __attribute__((__nothrow__)) ;
#line 316
extern long long ( __attribute__((__leaf__)) __llrintl)(long double __x )  __attribute__((__nothrow__)) ;
#line 320
extern long ( __attribute__((__leaf__)) lroundl)(long double __x )  __attribute__((__nothrow__)) ;
#line 320
extern long ( __attribute__((__leaf__)) __lroundl)(long double __x )  __attribute__((__nothrow__)) ;
#line 322
extern long long ( __attribute__((__leaf__)) llroundl)(long double __x )  __attribute__((__nothrow__)) ;
#line 322
extern long long ( __attribute__((__leaf__)) __llroundl)(long double __x )  __attribute__((__nothrow__)) ;
#line 326
extern long double ( __attribute__((__leaf__)) fdiml)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 326
extern long double ( __attribute__((__leaf__)) __fdiml)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 329
extern long double ( __attribute__((__leaf__)) fmaxl)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 329
extern long double ( __attribute__((__leaf__)) __fmaxl)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 332
extern long double ( __attribute__((__leaf__)) fminl)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 332
extern long double ( __attribute__((__leaf__)) __fminl)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 335
extern long double ( __attribute__((__leaf__)) fmal)(long double __x , long double __y ,
                                                     long double __z )  __attribute__((__nothrow__)) ;
#line 335
extern long double ( __attribute__((__leaf__)) __fmal)(long double __x , long double __y ,
                                                       long double __z )  __attribute__((__nothrow__)) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern int ( __attribute__((__leaf__)) __fpclassifyf128)(_Float128 __value )  __attribute__((__nothrow__,
__const__)) ;
#line 25
extern int ( __attribute__((__leaf__)) __signbitf128)(_Float128 __value )  __attribute__((__nothrow__,
__const__)) ;
#line 30
extern int ( __attribute__((__leaf__)) __isinff128)(_Float128 __value )  __attribute__((__nothrow__,
__const__)) ;
#line 33
extern int ( __attribute__((__leaf__)) __finitef128)(_Float128 __value )  __attribute__((__nothrow__,
__const__)) ;
#line 36
extern int ( __attribute__((__leaf__)) __isnanf128)(_Float128 __value )  __attribute__((__nothrow__,
__const__)) ;
#line 39
extern int ( __attribute__((__leaf__)) __iseqsigf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 42
extern int ( __attribute__((__leaf__)) __issignalingf128)(_Float128 __value )  __attribute__((__nothrow__,
__const__)) ;
#line 287 "/usr/include/unistd.h"
extern int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                               int __type )  __attribute__((__nothrow__)) ;
#line 334
extern __off_t ( __attribute__((__leaf__)) lseek)(int __fd , __off_t __offset , int __whence )  __attribute__((__nothrow__)) ;
#line 353
extern int close(int __fd ) ;
#line 360
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) read)(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t ( __attribute__((__warn_unused_result__)) write)(int __fd , void const   *__buf ,
                                                                size_t __n ) ;
#line 417
extern int ( __attribute__((__warn_unused_result__, __leaf__)) pipe)(int *__pipedes )  __attribute__((__nothrow__)) ;
#line 432
extern unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds )  __attribute__((__nothrow__)) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 469
extern int pause(void) ;
#line 473
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) chown)(char const   *__file ,
                                                                                      __uid_t __owner ,
                                                                                      __gid_t __group )  __attribute__((__nothrow__)) ;
#line 497
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) chdir)(char const   *__path )  __attribute__((__nothrow__)) ;
#line 511
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size )  __attribute__((__nothrow__)) ;
#line 531
extern int ( __attribute__((__warn_unused_result__, __leaf__)) dup)(int __fd )  __attribute__((__nothrow__)) ;
#line 534
extern int ( __attribute__((__leaf__)) dup2)(int __fd , int __fd2 )  __attribute__((__nothrow__)) ;
#line 543
extern char **__environ ;
#line 551
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) execve)(char const   *__path ,
                                                                 char **__argv , char **__envp )  __attribute__((__nothrow__)) ;
#line 563
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) execv)(char const   *__path ,
                                                                char **__argv )  __attribute__((__nothrow__)) ;
#line 568
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) execle)(char const   *__path ,
                                                                 char const   *__arg
                                                                 , ...)  __attribute__((__nothrow__)) ;
#line 573
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *__path ,
                                                                char const   *__arg
                                                                , ...)  __attribute__((__nothrow__)) ;
#line 578
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                 char **__argv )  __attribute__((__nothrow__)) ;
#line 584
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) execlp)(char const   *__file ,
                                                                 char const   *__arg
                                                                 , ...)  __attribute__((__nothrow__)) ;
#line 603
extern void _exit(int __status )  __attribute__((__noreturn__)) ;
#line 612
extern long ( __attribute__((__nonnull__(1), __leaf__)) pathconf)(char const   *__path ,
                                                                  int __name )  __attribute__((__nothrow__)) ;
#line 616
extern long ( __attribute__((__leaf__)) fpathconf)(int __fd , int __name )  __attribute__((__nothrow__)) ;
#line 619
extern long ( __attribute__((__leaf__)) sysconf)(int __name )  __attribute__((__nothrow__)) ;
#line 628
extern __pid_t ( __attribute__((__leaf__)) getpid)(void)  __attribute__((__nothrow__)) ;
#line 631
extern __pid_t ( __attribute__((__leaf__)) getppid)(void)  __attribute__((__nothrow__)) ;
#line 634
extern __pid_t ( __attribute__((__leaf__)) getpgrp)(void)  __attribute__((__nothrow__)) ;
#line 637
extern __pid_t ( __attribute__((__leaf__)) __getpgid)(__pid_t __pid )  __attribute__((__nothrow__)) ;
#line 646
extern int ( __attribute__((__leaf__)) setpgid)(__pid_t __pid , __pid_t __pgid )  __attribute__((__nothrow__)) ;
#line 667
extern __pid_t ( __attribute__((__leaf__)) setsid)(void)  __attribute__((__nothrow__)) ;
#line 675
extern __uid_t ( __attribute__((__leaf__)) getuid)(void)  __attribute__((__nothrow__)) ;
#line 678
extern __uid_t ( __attribute__((__leaf__)) geteuid)(void)  __attribute__((__nothrow__)) ;
#line 681
extern __gid_t ( __attribute__((__leaf__)) getgid)(void)  __attribute__((__nothrow__)) ;
#line 684
extern __gid_t ( __attribute__((__leaf__)) getegid)(void)  __attribute__((__nothrow__)) ;
#line 689
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list )  __attribute__((__nothrow__)) ;
#line 700
extern int ( __attribute__((__warn_unused_result__, __leaf__)) setuid)(__uid_t __uid )  __attribute__((__nothrow__)) ;
#line 717
extern int ( __attribute__((__warn_unused_result__, __leaf__)) setgid)(__gid_t __gid )  __attribute__((__nothrow__)) ;
#line 756
extern __pid_t fork(void)  __attribute__((__nothrow__)) ;
#line 770
extern char *( __attribute__((__leaf__)) ttyname)(int __fd )  __attribute__((__nothrow__)) ;
#line 774
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                               size_t __buflen )  __attribute__((__nothrow__)) ;
#line 779
extern int ( __attribute__((__leaf__)) isatty)(int __fd )  __attribute__((__nothrow__)) ;
#line 789
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1,2), __leaf__)) link)(char const   *__from ,
                                                                                       char const   *__to )  __attribute__((__nothrow__)) ;
#line 825
extern int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name )  __attribute__((__nothrow__)) ;
#line 834
extern int ( __attribute__((__nonnull__(1), __leaf__)) rmdir)(char const   *__path )  __attribute__((__nothrow__)) ;
#line 838
extern __pid_t ( __attribute__((__leaf__)) tcgetpgrp)(int __fd )  __attribute__((__nothrow__)) ;
#line 841
extern int ( __attribute__((__leaf__)) tcsetpgrp)(int __fd , __pid_t __pgrp_id )  __attribute__((__nothrow__)) ;
#line 848
extern char *getlogin(void) ;
#line 954
extern int fsync(int __fd ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_chk)(int __fd , void *__buf ,
                                                                     size_t __nbytes ,
                                                                     size_t __buflen ) ;
#line 25
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_alias)(int __fd ,
                                                                       void *__buf ,
                                                                       size_t __nbytes )  __asm__("read")  ;
#line 27
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_chk_warn)(int __fd ,
                                                                          void *__buf ,
                                                                          size_t __nbytes ,
                                                                          size_t __buflen )  __asm__("__read_chk") __attribute__((__warning__("read called with bigger length than size of the destination buffer"))) ;
#line 33 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) read)(int __fd , void *__buf , size_t __nbytes )
{
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 36
  tmp___4 = __builtin_object_size(__buf, 0);
#line 36
  if (tmp___4 != 18446744073709551615UL) {
#line 38
    if (1) {
#line 39
      tmp = __builtin_object_size(__buf, 0);
#line 39
      tmp___0 = __read_chk(__fd, __buf, __nbytes, tmp);
#line 39
      return (tmp___0);
    }
#line 41
    tmp___3 = __builtin_object_size(__buf, 0);
#line 41
    if (__nbytes > tmp___3) {
#line 42
      tmp___1 = __builtin_object_size(__buf, 0);
#line 42
      tmp___2 = __read_chk_warn(__fd, __buf, __nbytes, tmp___1);
#line 42
      return (tmp___2);
    }
  }
#line 44
  tmp___5 = __read_alias(__fd, __buf, __nbytes);
#line 44
  return (tmp___5);
}
}
#line 189
extern char *( __attribute__((__warn_unused_result__, __leaf__)) __getcwd_chk)(char *__buf ,
                                                                               size_t __size ,
                                                                               size_t __buflen )  __attribute__((__nothrow__)) ;
#line 191
extern char *( __attribute__((__warn_unused_result__, __leaf__)) __getcwd_alias)(char *__buf ,
                                                                                 size_t __size )  __asm__("getcwd") __attribute__((__nothrow__)) ;
#line 193
extern char *( __attribute__((__warn_unused_result__, __leaf__)) __getcwd_chk_warn)(char *__buf ,
                                                                                    size_t __size ,
                                                                                    size_t __buflen )  __asm__("__getcwd_chk") __attribute__((__warning__("getcwd caller with bigger length than size of destination buffer"),
__nothrow__)) ;
#line 199
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size )  __attribute__((__nothrow__)) ;
#line 199 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size )
{
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;

  {
#line 202
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 202
  if (tmp___4 != 18446744073709551615UL) {
#line 204
    if (1) {
#line 205
      tmp = __builtin_object_size((void *)__buf, 1);
#line 205
      tmp___0 = __getcwd_chk(__buf, __size, tmp);
#line 205
      return (tmp___0);
    }
#line 207
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 207
    if (__size > tmp___3) {
#line 208
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 208
      tmp___2 = __getcwd_chk_warn(__buf, __size, tmp___1);
#line 208
      return (tmp___2);
    }
  }
#line 210
  tmp___5 = __getcwd_alias(__buf, __size);
#line 210
  return (tmp___5);
}
}
#line 229
extern size_t ( __attribute__((__leaf__)) __confstr_chk)(int __name , char *__buf ,
                                                         size_t __len , size_t __buflen )  __attribute__((__nothrow__)) ;
#line 231
extern size_t ( __attribute__((__leaf__)) __confstr_alias)(int __name , char *__buf ,
                                                           size_t __len )  __asm__("confstr") __attribute__((__nothrow__)) ;
#line 233
extern size_t ( __attribute__((__leaf__)) __confstr_chk_warn)(int __name , char *__buf ,
                                                              size_t __len , size_t __buflen )  __asm__("__confstr_chk") __attribute__((__warning__("confstr called with bigger length than size of destination buffer"),
__nothrow__)) ;
#line 239
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) confstr)(int __name , char *__buf , size_t __len )  __attribute__((__nothrow__)) ;
#line 239 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) confstr)(int __name , char *__buf , size_t __len )
{
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 242
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 242
  if (tmp___4 != 18446744073709551615UL) {
#line 244
    if (1) {
#line 245
      tmp = __builtin_object_size((void *)__buf, 1);
#line 245
      tmp___0 = __confstr_chk(__name, __buf, __len, tmp);
#line 245
      return (tmp___0);
    }
#line 247
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 247
    if (tmp___3 < __len) {
#line 248
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 248
      tmp___2 = __confstr_chk_warn(__name, __buf, __len, tmp___1);
#line 248
      return (tmp___2);
    }
  }
#line 250
  tmp___5 = __confstr_alias(__name, __buf, __len);
#line 250
  return (tmp___5);
}
}
#line 254
extern int ( __attribute__((__warn_unused_result__, __leaf__)) __getgroups_chk)(int __size ,
                                                                                __gid_t *__list ,
                                                                                size_t __listlen )  __attribute__((__nothrow__)) ;
#line 256
extern int ( __attribute__((__warn_unused_result__, __leaf__)) __getgroups_alias)(int __size ,
                                                                                  __gid_t *__list )  __asm__("getgroups") __attribute__((__nothrow__)) ;
#line 258
extern int ( __attribute__((__warn_unused_result__, __leaf__)) __getgroups_chk_warn)(int __size ,
                                                                                     __gid_t *__list ,
                                                                                     size_t __listlen )  __asm__("__getgroups_chk") __attribute__((__warning__("getgroups called with bigger group count than what can fit into destination buffer"),
__nothrow__)) ;
#line 264
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list )  __attribute__((__nothrow__)) ;
#line 264 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 267
  tmp___4 = __builtin_object_size((void *)__list, 1);
#line 267
  if (tmp___4 != 18446744073709551615UL) {
#line 269
    if (1) {
#line 270
      tmp = __builtin_object_size((void *)__list, 1);
#line 270
      tmp___0 = __getgroups_chk(__size, __list, tmp);
#line 270
      return (tmp___0);
    } else
#line 269
    if (__size < 0) {
#line 270
      tmp = __builtin_object_size((void *)__list, 1);
#line 270
      tmp___0 = __getgroups_chk(__size, __list, tmp);
#line 270
      return (tmp___0);
    }
#line 272
    tmp___3 = __builtin_object_size((void *)__list, 1);
#line 272
    if ((unsigned long )__size * sizeof(__gid_t ) > tmp___3) {
#line 273
      tmp___1 = __builtin_object_size((void *)__list, 1);
#line 273
      tmp___2 = __getgroups_chk_warn(__size, __list, tmp___1);
#line 273
      return (tmp___2);
    }
  }
#line 275
  tmp___5 = __getgroups_alias(__size, __list);
#line 275
  return (tmp___5);
}
}
#line 279
extern int ( __attribute__((__nonnull__(2), __leaf__)) __ttyname_r_chk)(int __fd ,
                                                                        char *__buf ,
                                                                        size_t __buflen ,
                                                                        size_t __nreal )  __attribute__((__nothrow__)) ;
#line 281
extern int ( __attribute__((__nonnull__(2), __leaf__)) __ttyname_r_alias)(int __fd ,
                                                                          char *__buf ,
                                                                          size_t __buflen )  __asm__("ttyname_r") __attribute__((__nothrow__)) ;
#line 284
extern int ( __attribute__((__nonnull__(2), __leaf__)) __ttyname_r_chk_warn)(int __fd ,
                                                                             char *__buf ,
                                                                             size_t __buflen ,
                                                                             size_t __nreal )  __asm__("__ttyname_r_chk") __attribute__((__warning__("ttyname_r called with bigger buflen than size of destination buffer"),
__nothrow__)) ;
#line 290
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                               size_t __buflen )  __attribute__((__nothrow__)) ;
#line 290 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                               size_t __buflen )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 293
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 293
  if (tmp___4 != 18446744073709551615UL) {
#line 295
    if (1) {
#line 296
      tmp = __builtin_object_size((void *)__buf, 1);
#line 296
      tmp___0 = __ttyname_r_chk(__fd, __buf, __buflen, tmp);
#line 296
      return (tmp___0);
    }
#line 298
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 298
    if (__buflen > tmp___3) {
#line 299
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 299
      tmp___2 = __ttyname_r_chk_warn(__fd, __buf, __buflen, tmp___1);
#line 299
      return (tmp___2);
    }
  }
#line 301
  tmp___5 = __ttyname_r_alias(__fd, __buf, __buflen);
#line 301
  return (tmp___5);
}
}
#line 220 "/usr/include/zlib.h"
extern char const   *zlibVersion(void) ;
#line 250
extern int deflate(z_streamp strm , int flush ) ;
#line 363
extern int deflateEnd(z_streamp strm ) ;
#line 400
extern int inflate(z_streamp strm , int flush ) ;
#line 520
extern int inflateEnd(z_streamp strm ) ;
#line 611
extern int deflateSetDictionary(z_streamp strm , Bytef const   *dictionary , uInt dictLength ) ;
#line 655
extern int deflateGetDictionary(z_streamp strm , Bytef *dictionary , uInt *dictLength ) ;
#line 677
extern int deflateCopy(z_streamp dest , z_streamp source ) ;
#line 695
extern int deflateReset(z_streamp strm ) ;
#line 706
extern int deflateParams(z_streamp strm , int level , int strategy ) ;
#line 744
extern int deflateTune(z_streamp strm , int good_length , int max_lazy , int nice_length ,
                       int max_chain ) ;
#line 761
extern uLong deflateBound(z_streamp strm , uLong sourceLen ) ;
#line 776
extern int deflatePending(z_streamp strm , unsigned int *pending , int *bits ) ;
#line 791
extern int deflatePrime(z_streamp strm , int bits , int value ) ;
#line 808
extern int deflateSetHeader(z_streamp strm , gz_headerp head ) ;
#line 885
extern int inflateSetDictionary(z_streamp strm , Bytef const   *dictionary , uInt dictLength ) ;
#line 908
extern int inflateGetDictionary(z_streamp strm , Bytef *dictionary , uInt *dictLength ) ;
#line 923
extern int inflateSync(z_streamp strm ) ;
#line 942
extern int inflateCopy(z_streamp dest , z_streamp source ) ;
#line 958
extern int inflateReset(z_streamp strm ) ;
#line 968
extern int inflateReset2(z_streamp strm , int windowBits ) ;
#line 982
extern int inflatePrime(z_streamp strm , int bits , int value ) ;
#line 1003
extern long inflateMark(z_streamp strm ) ;
#line 1031
extern int inflateGetHeader(z_streamp strm , gz_headerp head ) ;
#line 1097
extern int inflateBack(z_streamp strm , unsigned int (*in)(void * , unsigned char const   ** ) ,
                       void *in_desc , int (*out)(void * , unsigned char * , unsigned int  ) ,
                       void *out_desc ) ;
#line 1167
extern int inflateBackEnd(z_streamp strm ) ;
#line 1175
extern uLong zlibCompileFlags(void) ;
#line 1228
extern int compress(Bytef *dest , uLongf *destLen , Bytef const   *source , uLong sourceLen ) ;
#line 1243
extern int compress2(Bytef *dest , uLongf *destLen , Bytef const   *source , uLong sourceLen ,
                     int level ) ;
#line 1259
extern uLong compressBound(uLong sourceLen ) ;
#line 1266
extern int uncompress(Bytef *dest , uLongf *destLen , Bytef const   *source , uLong sourceLen ) ;
#line 1284
extern int uncompress2(Bytef *dest , uLongf *destLen , Bytef const   *source , uLong *sourceLen ) ;
#line 1341
extern gzFile gzdopen(int fd , char const   *mode ) ;
#line 1364
extern int gzbuffer(gzFile file , unsigned int size ) ;
#line 1380
extern int gzsetparams(gzFile file , int level , int strategy ) ;
#line 1391
extern int gzread(gzFile file , voidp buf , unsigned int len ) ;
#line 1421
extern z_size_t gzfread(voidp buf , z_size_t size , z_size_t nitems , gzFile file ) ;
#line 1447
extern int gzwrite(gzFile file , voidpc buf , unsigned int len ) ;
#line 1455
extern z_size_t gzfwrite(voidpc buf , z_size_t size , z_size_t nitems , gzFile file ) ;
#line 1469
extern int gzprintf(gzFile file , char const   *format  , ...) ;
#line 1484
extern int gzputs(gzFile file , char const   *s ) ;
#line 1492
extern char *gzgets(gzFile file , char *buf , int len ) ;
#line 1505
extern int gzputc(gzFile file , int c ) ;
#line 1511
extern int gzgetc(gzFile file ) ;
#line 1520
extern int gzungetc(int c , gzFile file ) ;
#line 1532
extern int gzflush(gzFile file , int flush ) ;
#line 1567
extern int gzrewind(gzFile file ) ;
#line 1595
extern int gzeof(gzFile file ) ;
#line 1610
extern int gzdirect(gzFile file ) ;
#line 1631
extern int gzclose(gzFile file ) ;
#line 1644
extern int gzclose_r(gzFile file ) ;
#line 1645
extern int gzclose_w(gzFile file ) ;
#line 1656
extern char const   *gzerror(gzFile file , int *errnum ) ;
#line 1672
extern void gzclearerr(gzFile file ) ;
#line 1689
extern uLong adler32(uLong adler , Bytef const   *buf , uInt len ) ;
#line 1708
extern uLong adler32_z(uLong adler , Bytef const   *buf , z_size_t len ) ;
#line 1726
extern uLong crc32(uLong crc , Bytef const   *buf , uInt len ) ;
#line 1743
extern uLong crc32_z(uLong adler , Bytef const   *buf , z_size_t len ) ;
#line 1765
extern int deflateInit_(z_streamp strm , int level , char const   *version , int stream_size ) ;
#line 1767
extern int inflateInit_(z_streamp strm , char const   *version , int stream_size ) ;
#line 1769
extern int deflateInit2_(z_streamp strm , int level , int method , int windowBits ,
                         int memLevel , int strategy , char const   *version , int stream_size ) ;
#line 1773
extern int inflateInit2_(z_streamp strm , int windowBits , char const   *version ,
                         int stream_size ) ;
#line 1775
extern int inflateBackInit_(z_streamp strm , int windowBits , unsigned char *window ,
                            char const   *version , int stream_size ) ;
#line 1823
extern int gzgetc_(gzFile file ) ;
#line 1873
extern gzFile gzopen(char const   * , char const   * ) ;
#line 1874
extern off_t gzseek(gzFile  , off_t  , int  ) ;
#line 1875
extern off_t gztell(gzFile  ) ;
#line 1876
extern off_t gzoffset(gzFile  ) ;
#line 1877
extern uLong adler32_combine(uLong  , uLong  , off_t  ) ;
#line 1878
extern uLong crc32_combine(uLong  , uLong  , off_t  ) ;
#line 1889
extern char const   *zError(int  ) ;
#line 1890
extern int inflateSyncPoint(z_streamp  ) ;
#line 1891
extern z_crc_t const   *get_crc_table(void) ;
#line 1892
extern int inflateUndermine(z_streamp  , int  ) ;
#line 1893
extern int inflateValidate(z_streamp  , int  ) ;
#line 1894
extern unsigned long inflateCodesUsed(z_streamp  ) ;
#line 1895
extern int inflateResetKeep(z_streamp  ) ;
#line 1896
extern int deflateResetKeep(z_streamp  ) ;
#line 1903
extern int gzvprintf(gzFile file , char const   *format , va_list va ) ;
#line 934 "/home/goblint2/bench/libpng-1.6.39/pngpriv.h"
png_uint_16 const   png_sRGB_table[256] ;
#line 940
png_uint_16 const   png_sRGB_base[512] ;
#line 941
png_byte const   png_sRGB_delta[512] ;
#line 965
void png_zstream_error(png_structrp png_ptr , int ret ) ;
#line 972
void png_free_buffer_list(png_structrp png_ptr , png_compression_bufferp *listp ) ;
#line 984
png_fixed_point png_fixed(png_const_structrp png_ptr , double fp , png_const_charp text ) ;
#line 991
int png_user_version_check(png_structrp png_ptr , png_const_charp user_png_ver ) ;
#line 998
png_voidp __attribute__((__malloc__))  png_malloc_base(png_const_structrp png_ptr ,
                                                       png_alloc_size_t size ) ;
#line 1006
png_voidp __attribute__((__malloc__))  png_malloc_array(png_const_structrp png_ptr ,
                                                        int nelements , size_t element_size ) ;
#line 1013
png_voidp __attribute__((__malloc__))  png_realloc_array(png_const_structrp png_ptr ,
                                                         png_const_voidp old_array ,
                                                         int old_elements , int add_elements ,
                                                         size_t element_size ) ;
#line 1024
png_structp __attribute__((__malloc__))  png_create_png_struct(png_const_charp user_png_ver ,
                                                               png_voidp error_ptr ,
                                                               void (*error_fn)(png_structp  ,
                                                                                png_const_charp  ) ,
                                                               void (*warn_fn)(png_structp  ,
                                                                               png_const_charp  ) ,
                                                               png_voidp mem_ptr ,
                                                               png_voidp (*malloc_fn)(png_structp  ,
                                                                                      png_alloc_size_t  ) ,
                                                               void (*free_fn)(png_structp  ,
                                                                               png_voidp  ) ) ;
#line 1030
void png_destroy_png_struct(png_structrp png_ptr ) ;
#line 1034
void png_free_jmpbuf(png_structrp png_ptr ) ;
#line 1037
voidpf __attribute__((__malloc__))  png_zalloc(voidpf png_ptr , uInt items , uInt size ) ;
#line 1041
void png_zfree(voidpf png_ptr , voidpf ptr ) ;
#line 1048
void png_default_read_data(png_structp png_ptr , png_bytep data , size_t length ) ;
#line 1052
void png_push_fill_buffer(png_structp png_ptr , png_bytep buffer___0 , size_t length ) ;
#line 1056
void png_default_write_data(png_structp png_ptr , png_bytep data , size_t length ) ;
#line 1061
void png_default_flush(png_structp png_ptr ) ;
#line 1067
void png_reset_crc(png_structrp png_ptr ) ;
#line 1070
void png_write_data(png_structrp png_ptr , png_const_bytep data , size_t length ) ;
#line 1074
void png_read_sig(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1078
png_uint_32 png_read_chunk_header(png_structrp png_ptr ) ;
#line 1082
void png_read_data(png_structrp png_ptr , png_bytep data , size_t length ) ;
#line 1086
void png_crc_read(png_structrp png_ptr , png_bytep buf , png_uint_32 length ) ;
#line 1090
int png_crc_finish(png_structrp png_ptr , png_uint_32 skip ) ;
#line 1094
int png_crc_error(png_structrp png_ptr ) ;
#line 1100
void png_calculate_crc(png_structrp png_ptr , png_const_bytep ptr , size_t length ) ;
#line 1104
void png_flush(png_structrp png_ptr ) ;
#line 1112
void png_write_IHDR(png_structrp png_ptr , png_uint_32 width , png_uint_32 height ,
                    int bit_depth , int color_type , int compression_type , int filter_type ,
                    int interlace_type ) ;
#line 1116
void png_write_PLTE(png_structrp png_ptr , png_const_colorp palette , png_uint_32 num_pal ) ;
#line 1119
void png_compress_IDAT(png_structrp png_ptr , png_const_bytep input , png_alloc_size_t input_len ,
                       int flush ) ;
#line 1123
void png_write_IEND(png_structrp png_ptr ) ;
#line 1126
void png_write_gAMA_fixed(png_structrp png_ptr , png_fixed_point file_gamma ) ;
#line 1131
void png_write_sBIT(png_structrp png_ptr , png_const_color_8p sbit , int color_type ) ;
#line 1136
void png_write_cHRM_fixed(png_structrp png_ptr , png_xy const   *xy ) ;
#line 1142
void png_write_sRGB(png_structrp png_ptr , int srgb_intent ) ;
#line 1147
void png_write_eXIf(png_structrp png_ptr , png_bytep exif , int num_exif ) ;
#line 1152
void png_write_iCCP(png_structrp png_ptr , png_const_charp name , png_const_bytep profile ) ;
#line 1161
void png_write_sPLT(png_structrp png_ptr , png_const_sPLT_tp spalette ) ;
#line 1166
void png_write_tRNS(png_structrp png_ptr , png_const_bytep trans_alpha , png_const_color_16p tran ,
                    int num_trans , int color_type ) ;
#line 1172
void png_write_bKGD(png_structrp png_ptr , png_const_color_16p back , int color_type ) ;
#line 1177
void png_write_hIST(png_structrp png_ptr , png_const_uint_16p hist , int num_hist ) ;
#line 1183
void png_write_tEXt(png_structrp png_ptr , png_const_charp key___3 , png_const_charp text ,
                    size_t text_len ) ;
#line 1188
void png_write_zTXt(png_structrp png_ptr , png_const_charp key___3 , png_const_charp text ,
                    int compression ) ;
#line 1193
void png_write_iTXt(png_structrp png_ptr , int compression , png_const_charp key___3 ,
                    png_const_charp lang , png_const_charp lang_key , png_const_charp text ) ;
#line 1199
int png_set_text_2(png_const_structrp png_ptr , png_inforp info_ptr , png_const_textp text_ptr ,
                   int num_text ) ;
#line 1204
void png_write_oFFs(png_structrp png_ptr , png_int_32 x_offset , png_int_32 y_offset ,
                    int unit_type ) ;
#line 1209
void png_write_pCAL(png_structrp png_ptr , png_charp purpose , png_int_32 X0 , png_int_32 X1 ,
                    int type , int nparams , png_const_charp units , png_charpp params ) ;
#line 1215
void png_write_pHYs(png_structrp png_ptr , png_uint_32 x_pixels_per_unit , png_uint_32 y_pixels_per_unit ,
                    int unit_type ) ;
#line 1221
void png_write_tIME(png_structrp png_ptr , png_const_timep mod_time ) ;
#line 1226
void png_write_sCAL_s(png_structrp png_ptr , int unit , png_const_charp width , png_const_charp height ) ;
#line 1231
void png_write_finish_row(png_structrp png_ptr ) ;
#line 1235
void png_write_start_row(png_structrp png_ptr ) ;
#line 1264
void png_combine_row(png_const_structrp png_ptr , png_bytep dp , int display ) ;
#line 1274
void png_do_read_interlace(png_row_infop row_info , png_bytep row , int pass , png_uint_32 transformations ) ;
#line 1282
void png_do_write_interlace(png_row_infop row_info , png_bytep row , int pass ) ;
#line 1289
void png_read_filter_row(png_structrp pp , png_row_infop row_info , png_bytep row ,
                         png_const_bytep prev_row , int filter ) ;
#line 1359
void png_write_find_filter(png_structrp png_ptr , png_row_infop row_info ) ;
#line 1363
void png_read_IDAT_data(png_structrp png_ptr , png_bytep output , png_alloc_size_t avail_out ) ;
#line 1370
void png_read_finish_IDAT(png_structrp png_ptr ) ;
#line 1376
void png_read_finish_row(png_structrp png_ptr ) ;
#line 1382
void png_read_start_row(png_structrp png_ptr ) ;
#line 1385
int png_zlib_inflate(png_structrp png_ptr , int flush ) ;
#line 1394
void png_read_transform_info(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1401
void png_do_strip_channel(png_row_infop row_info , png_bytep row , int at_start ) ;
#line 1407
void png_do_swap(png_row_infop row_info , png_bytep row ) ;
#line 1414
void png_do_packswap(png_row_infop row_info , png_bytep row ) ;
#line 1419
void png_do_invert(png_row_infop row_info , png_bytep row ) ;
#line 1424
void png_do_bgr(png_row_infop row_info , png_bytep row ) ;
#line 1433
void png_handle_IHDR(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1435
void png_handle_PLTE(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1437
void png_handle_IEND(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1441
void png_handle_bKGD(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1446
void png_handle_cHRM(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1451
void png_handle_eXIf(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1456
void png_handle_gAMA(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1461
void png_handle_hIST(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1466
void png_handle_iCCP(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1471
void png_handle_iTXt(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1476
void png_handle_oFFs(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1481
void png_handle_pCAL(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1486
void png_handle_pHYs(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1491
void png_handle_sBIT(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1496
void png_handle_sCAL(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1501
void png_handle_sPLT(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1506
void png_handle_sRGB(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1511
void png_handle_tEXt(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1516
void png_handle_tIME(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1521
void png_handle_tRNS(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1526
void png_handle_zTXt(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1530
void png_check_chunk_name(png_const_structrp png_ptr , png_uint_32 chunk_name ) ;
#line 1533
void png_check_chunk_length(png_const_structrp png_ptr , png_uint_32 length ) ;
#line 1536
void png_handle_unknown(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ,
                        int keep ) ;
#line 1546
int png_chunk_unknown_handling(png_const_structrp png_ptr , png_uint_32 chunk_name ) ;
#line 1555
void png_do_read_transformations(png_structrp png_ptr , png_row_infop row_info ) ;
#line 1559
void png_do_write_transformations(png_structrp png_ptr , png_row_infop row_info ) ;
#line 1564
void png_init_read_transformations(png_structrp png_ptr ) ;
#line 1569
void png_push_read_chunk(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1571
void png_push_read_sig(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1573
extern void png_push_check_crc(png_structrp png_ptr ) ;
#line 1574
void png_push_save_buffer(png_structrp png_ptr ) ;
#line 1576
void png_push_restore_buffer(png_structrp png_ptr , png_bytep buffer___0 , size_t buffer_length ) ;
#line 1578
void png_push_read_IDAT(png_structrp png_ptr ) ;
#line 1579
void png_process_IDAT_data(png_structrp png_ptr , png_bytep buffer___0 , size_t buffer_length ) ;
#line 1581
void png_push_process_row(png_structrp png_ptr ) ;
#line 1583
extern void png_push_handle_unknown(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1585
void png_push_have_info(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1587
void png_push_have_end(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1589
void png_push_have_row(png_structrp png_ptr , png_bytep row ) ;
#line 1591
extern void png_push_read_end(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1593
void png_process_some_data(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1595
void png_read_push_finish_row(png_structrp png_ptr ) ;
#line 1598
extern void png_push_handle_tEXt(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1600
extern void png_push_read_tEXt(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1604
extern void png_push_handle_zTXt(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1606
extern void png_push_read_zTXt(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1610
extern void png_push_handle_iTXt(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1612
extern void png_push_read_iTXt(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1620
void png_colorspace_set_gamma(png_const_structrp png_ptr , png_colorspacerp colorspace ,
                              png_fixed_point gAMA ) ;
#line 1627
void png_colorspace_sync_info(png_const_structrp png_ptr , png_inforp info_ptr ) ;
#line 1631
void png_colorspace_sync(png_const_structrp png_ptr , png_inforp info_ptr ) ;
#line 1643
int png_colorspace_set_chromaticities(png_const_structrp png_ptr , png_colorspacerp colorspace ,
                                      png_xy const   *xy , int preferred ) ;
#line 1647
int png_colorspace_set_endpoints(png_const_structrp png_ptr , png_colorspacerp colorspace ,
                                 png_XYZ const   *XYZ_in , int preferred ) ;
#line 1652
int png_colorspace_set_sRGB(png_const_structrp png_ptr , png_colorspacerp colorspace ,
                            int intent ) ;
#line 1662
int png_colorspace_set_ICC(png_const_structrp png_ptr , png_colorspacerp colorspace ,
                           png_const_charp name , png_uint_32 profile_length , png_const_bytep profile ,
                           int color_type ) ;
#line 1670
int png_icc_check_length(png_const_structrp png_ptr , png_colorspacerp colorspace ,
                         png_const_charp name , png_uint_32 profile_length ) ;
#line 1674
int png_icc_check_header(png_const_structrp png_ptr , png_colorspacerp colorspace ,
                         png_const_charp name , png_uint_32 profile_length , png_const_bytep profile ,
                         int color_type ) ;
#line 1679
int png_icc_check_tag_table(png_const_structrp png_ptr , png_colorspacerp colorspace ,
                            png_const_charp name , png_uint_32 profile_length , png_const_bytep profile ) ;
#line 1684
void png_icc_set_sRGB(png_const_structrp png_ptr , png_colorspacerp colorspace , png_const_bytep profile ,
                      uLong adler ) ;
#line 1695
void png_colorspace_set_rgb_coefficients(png_structrp png_ptr ) ;
#line 1702
void png_check_IHDR(png_const_structrp png_ptr , png_uint_32 width , png_uint_32 height ,
                    int bit_depth , int color_type , int interlace_type , int compression_type ,
                    int filter_type ) ;
#line 1710
void png_do_check_palette_indexes(png_structrp png_ptr , png_row_infop row_info ) ;
#line 1715
void png_fixed_error(png_const_structrp png_ptr , png_const_charp name )  __attribute__((__noreturn__)) ;
#line 1723
size_t png_safecat(png_charp buffer___0 , size_t bufsize , size_t pos , png_const_charp string ) ;
#line 1735
png_charp png_format_number(png_const_charp start , png_charp end , int format , png_alloc_size_t number ) ;
#line 1768
void png_warning_parameter(char (*p)[32] , int number , png_const_charp string ) ;
#line 1773
void png_warning_parameter_unsigned(char (*p)[32] , int number , int format , png_alloc_size_t value ) ;
#line 1779
void png_warning_parameter_signed(char (*p)[32] , int number , int format , png_int_32 value ) ;
#line 1783
void png_formatted_warning(png_const_structrp png_ptr , char (*p)[32] , png_const_charp message ) ;
#line 1806
void png_app_warning(png_const_structrp png_ptr , png_const_charp error_message ) ;
#line 1812
void png_app_error(png_const_structrp png_ptr , png_const_charp error_message ) ;
#line 1822
void png_chunk_report(png_const_structrp png_ptr , png_const_charp message , int error___0 ) ;
#line 1849
void png_ascii_from_fp(png_const_structrp png_ptr , png_charp ascii , size_t size ,
                       double fp , unsigned int precision ) ;
#line 1855
void png_ascii_from_fixed(png_const_structrp png_ptr , png_charp ascii , size_t size ,
                          png_fixed_point fp ) ;
#line 1948
int png_check_fp_number(png_const_charp string , size_t size , int *statep , size_t *whereami ) ;
#line 1957
int png_check_fp_string(png_const_charp string , size_t size ) ;
#line 1969
int png_muldiv(png_fixed_point_p res , png_fixed_point a , png_int_32 times , png_int_32 divisor ) ;
#line 1975
png_fixed_point png_muldiv_warn(png_const_structrp png_ptr , png_fixed_point a , png_int_32 times ,
                                png_int_32 divisor ) ;
#line 1985
png_fixed_point png_reciprocal(png_fixed_point a ) ;
#line 1993
png_fixed_point png_reciprocal2(png_fixed_point a , png_fixed_point b ) ;
#line 1998
int png_gamma_significant(png_fixed_point gamma_val ) ;
#line 2010
png_uint_16 png_gamma_correct(png_structrp png_ptr , unsigned int value , png_fixed_point gamma_val ) ;
#line 2012
png_uint_16 png_gamma_16bit_correct(unsigned int value , png_fixed_point gamma_val ) ;
#line 2014
png_byte png_gamma_8bit_correct(unsigned int value , png_fixed_point gamma_val ) ;
#line 2016
void png_destroy_gamma_table(png_structrp png_ptr ) ;
#line 2018
void png_build_gamma_table(png_structrp png_ptr , int bit_depth ) ;
#line 2052
void png_safe_error(png_structp png_nonconst_ptr , png_const_charp error_message )  __attribute__((__noreturn__)) ;
#line 2056
void png_safe_warning(png_structp png_nonconst_ptr , png_const_charp warning_message ) ;
#line 2062
int png_safe_execute(png_imagep image_in , int (*function)(png_voidp  ) , png_voidp arg ) ;
#line 2068
int png_image_error(png_imagep image , png_const_charp error_message ) ;
#line 2108
png_uint_32 png_check_keyword(png_structrp png_ptr , png_const_charp key___3 , png_bytep new_key ) ;
#line 46 "/home/goblint2/bench/libpng-1.6.39/png.c"
void png_set_sig_bytes(png_structrp png_ptr , int num_bytes )
{
  unsigned int nb ;

  {
#line 49
  nb = (unsigned int )num_bytes;
#line 53
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 54
    return;
  }
#line 56
  if (num_bytes < 0) {
#line 57
    nb = 0U;
  }
#line 59
  if (nb > 8U) {
#line 60
    png_error((png_const_structrp )png_ptr, (png_const_charp )"Too many bytes for PNG signature");
  }
#line 62
  png_ptr->sig_bytes = (png_byte )nb;
#line 63
  return;
}
}
#line 73 "/home/goblint2/bench/libpng-1.6.39/png.c"
int png_sig_cmp(png_const_bytep sig , size_t start , size_t num_to_check )
{
  png_byte png_signature[8] ;
  int tmp ;

  {
#line 76
  png_signature[0] = (png_byte )137;
#line 76
  png_signature[1] = (png_byte )80;
#line 76
  png_signature[2] = (png_byte )78;
#line 76
  png_signature[3] = (png_byte )71;
#line 76
  png_signature[4] = (png_byte )13;
#line 76
  png_signature[5] = (png_byte )10;
#line 76
  png_signature[6] = (png_byte )26;
#line 76
  png_signature[7] = (png_byte )10;
#line 78
  if (num_to_check > 8UL) {
#line 79
    num_to_check = (size_t )8;
  } else
#line 81
  if (num_to_check < 1UL) {
#line 82
    return (-1);
  }
#line 84
  if (start > 7UL) {
#line 85
    return (-1);
  }
#line 87
  if (start + num_to_check > 8UL) {
#line 88
    num_to_check = 8UL - start;
  }
#line 90
  tmp = memcmp((void const   *)(sig + start), (void const   *)(& png_signature[start]),
               num_to_check);
#line 90
  return (tmp);
}
}
#line 97 "/home/goblint2/bench/libpng-1.6.39/png.c"
voidpf __attribute__((__malloc__))  png_zalloc(voidpf png_ptr , uInt items , uInt size )
{
  png_alloc_size_t num_bytes ;
  png_voidp __attribute__((__malloc__))  tmp ;

  {
#line 100
  num_bytes = (png_alloc_size_t )size;
#line 102
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 103
    return ((voidpf __attribute__((__malloc__))  )((void *)0));
  }
#line 105
  if ((png_alloc_size_t )items >= 18446744073709551615UL / (png_alloc_size_t )size) {
#line 107
    png_warning((png_const_structrp )png_ptr, (png_const_charp )"Potential overflow in png_zalloc()");
#line 109
    return ((voidpf __attribute__((__malloc__))  )((void *)0));
  }
#line 112
  num_bytes *= (png_alloc_size_t )items;
#line 113
  tmp = png_malloc_warn((png_const_structrp )png_ptr, num_bytes);
#line 113
  return (tmp);
}
}
#line 117 "/home/goblint2/bench/libpng-1.6.39/png.c"
void png_zfree(voidpf png_ptr , voidpf ptr )
{


  {
#line 120
  png_free((png_const_structrp )png_ptr, ptr);
#line 121
  return;
}
}
#line 126 "/home/goblint2/bench/libpng-1.6.39/png.c"
void png_reset_crc(png_structrp png_ptr )
{
  uLong tmp ;

  {
#line 130
  tmp = crc32((uLong )0, (Bytef const   *)0, (uInt )0);
#line 130
  png_ptr->crc = (png_uint_32 )tmp;
#line 131
  return;
}
}
#line 138 "/home/goblint2/bench/libpng-1.6.39/png.c"
void png_calculate_crc(png_structrp png_ptr , png_const_bytep ptr , size_t length )
{
  int need_crc ;
  uLong crc ;
  uInt safe_length ;

  {
#line 141
  need_crc = 1;
#line 143
  if ((1U & (png_ptr->chunk_name >> 29)) != 0U) {
#line 145
    if ((png_ptr->flags & 768U) == 768U) {
#line 147
      need_crc = 0;
    }
  } else
#line 152
  if ((png_ptr->flags & 0x0800U) != 0U) {
#line 153
    need_crc = 0;
  }
#line 161
  if (need_crc != 0) {
#line 161
    if (length > 0UL) {
#line 163
      crc = (uLong )png_ptr->crc;
      {
#line 165
      while (1) {
        while_continue: /* CIL Label */ ;
#line 167
        safe_length = (uInt )length;
#line 169
        if (safe_length == 0U) {
#line 170
          safe_length = (uInt )-1;
        }
#line 173
        crc = crc32(crc, ptr, safe_length);
#line 179
        ptr += safe_length;
#line 180
        length -= (size_t )safe_length;
#line 165
        if (! (length > 0UL)) {
#line 165
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 185
      png_ptr->crc = (png_uint_32 )crc;
    }
  }
#line 187
  return;
}
}
#line 192 "/home/goblint2/bench/libpng-1.6.39/png.c"
int png_user_version_check(png_structrp png_ptr , png_const_charp user_png_ver )
{
  int i ;
  int found_dots ;
  size_t pos ;
  char m[128] ;

  {
#line 200
  if ((unsigned long )user_png_ver != (unsigned long )((void *)0)) {
#line 202
    i = -1;
#line 203
    found_dots = 0;
    {
#line 205
    while (1) {
      while_continue: /* CIL Label */ ;
#line 207
      i ++;
#line 208
      if ((int const   )*(user_png_ver + i) != (int const   )*("1.6.39" + i)) {
#line 209
        png_ptr->flags |= 0x20000U;
      }
#line 210
      if ((int const   )*(user_png_ver + i) == 46) {
#line 211
        found_dots ++;
      }
#line 205
      if (found_dots < 2) {
#line 205
        if ((int const   )*(user_png_ver + i) != 0) {
#line 205
          if (! ((int )*("1.6.39" + i) != 0)) {
#line 205
            goto while_break;
          }
        } else {
#line 205
          goto while_break;
        }
      } else {
#line 205
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 217
    png_ptr->flags |= 0x20000U;
  }
#line 219
  if ((png_ptr->flags & 0x20000U) != 0U) {
#line 222
    pos = (size_t )0;
#line 225
    pos = png_safecat(m, sizeof(m), pos, (png_const_charp )"Application built with libpng-");
#line 227
    pos = png_safecat(m, sizeof(m), pos, user_png_ver);
#line 228
    pos = png_safecat(m, sizeof(m), pos, (png_const_charp )" but running with ");
#line 229
    pos = png_safecat(m, sizeof(m), pos, (png_const_charp )"1.6.39");
#line 232
    png_warning((png_const_structrp )png_ptr, (png_const_charp )(m));
#line 239
    return (0);
  }
#line 243
  return (1);
}
}
#line 249 "/home/goblint2/bench/libpng-1.6.39/png.c"
png_structp __attribute__((__malloc__))  png_create_png_struct(png_const_charp user_png_ver ,
                                                               png_voidp error_ptr ,
                                                               void (*error_fn)(png_structp  ,
                                                                                png_const_charp  ) ,
                                                               void (*warn_fn)(png_structp  ,
                                                                               png_const_charp  ) ,
                                                               png_voidp mem_ptr ,
                                                               png_voidp (*malloc_fn)(png_structp  ,
                                                                                      png_alloc_size_t  ) ,
                                                               void (*free_fn)(png_structp  ,
                                                                               png_voidp  ) )
{
  png_struct create_struct ;
  jmp_buf create_jmp_buf ;
  png_structrp png_ptr ;
  png_voidp __attribute__((__malloc__))  tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 263
  memset((void *)(& create_struct), 0, sizeof(create_struct));
#line 267
  create_struct.user_width_max = (png_uint_32 )1000000;
#line 268
  create_struct.user_height_max = (png_uint_32 )1000000;
#line 272
  create_struct.user_chunk_cache_max = (png_uint_32 )1000;
#line 279
  create_struct.user_chunk_malloc_max = (png_alloc_size_t )8000000;
#line 287
  png_set_mem_fn((png_structrp )(& create_struct), mem_ptr, malloc_fn, free_fn);
#line 299
  png_set_error_fn((png_structrp )(& create_struct), error_ptr, error_fn, warn_fn);
#line 302
  tmp___1 = _setjmp((struct __jmp_buf_tag *)(create_jmp_buf));
#line 302
  if (! tmp___1) {
#line 311
    create_struct.jmp_buf_ptr = & create_jmp_buf;
#line 312
    create_struct.jmp_buf_size = (size_t )0;
#line 313
    create_struct.longjmp_fn = & longjmp;
#line 317
    tmp___0 = png_user_version_check((png_structrp )(& create_struct), user_png_ver);
#line 317
    if (tmp___0 != 0) {
#line 319
      tmp = png_malloc_warn((png_const_structrp )(& create_struct), sizeof(*png_ptr));
#line 319
      png_ptr = (png_structrp )tmp;
#line 322
      if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 327
        create_struct.zstream.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))(& png_zalloc);
#line 328
        create_struct.zstream.zfree = & png_zfree;
#line 329
        create_struct.zstream.opaque = (voidpf )png_ptr;
#line 333
        create_struct.jmp_buf_ptr = (jmp_buf *)((void *)0);
#line 334
        create_struct.jmp_buf_size = (size_t )0;
#line 335
        create_struct.longjmp_fn = (void (*)(struct __jmp_buf_tag * , int  ))0;
#line 338
        *png_ptr = create_struct;
#line 341
        return ((png_structp __attribute__((__malloc__))  )png_ptr);
      }
    }
  }
#line 349
  return ((png_structp __attribute__((__malloc__))  )((void *)0));
}
}
#line 353 "/home/goblint2/bench/libpng-1.6.39/png.c"
png_infop __attribute__((__malloc__))  png_create_info_struct(png_const_structrp png_ptr )
{
  png_inforp info_ptr ;
  png_voidp __attribute__((__malloc__))  tmp ;

  {
#line 360
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 361
    return ((png_infop __attribute__((__malloc__))  )((void *)0));
  }
#line 368
  tmp = png_malloc_base(png_ptr, sizeof(*info_ptr));
#line 368
  info_ptr = (png_inforp )tmp;
#line 371
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 372
    memset((void *)info_ptr, 0, sizeof(*info_ptr));
  }
#line 374
  return ((png_infop __attribute__((__malloc__))  )info_ptr);
}
}
#line 385 "/home/goblint2/bench/libpng-1.6.39/png.c"
void png_destroy_info_struct(png_const_structrp png_ptr , png_infopp info_ptr_ptr )
{
  png_inforp info_ptr ;

  {
#line 388
  info_ptr = (png_inforp )((void *)0);
#line 392
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 393
    return;
  }
#line 395
  if ((unsigned long )info_ptr_ptr != (unsigned long )((void *)0)) {
#line 396
    info_ptr = (png_inforp )*info_ptr_ptr;
  }
#line 398
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 406
    *info_ptr_ptr = (png_info *)((void *)0);
#line 408
    png_free_data(png_ptr, info_ptr, 0xffffU, -1);
#line 409
    memset((void *)info_ptr, 0, sizeof(*info_ptr));
#line 410
    png_free(png_ptr, (png_voidp )info_ptr);
  }
#line 412
  return;
}
}
#line 423 "/home/goblint2/bench/libpng-1.6.39/png.c"
void __attribute__((__deprecated__))  png_info_init_3(png_infopp ptr_ptr , size_t png_info_struct_size )
{
  png_inforp info_ptr ;
  png_voidp __attribute__((__malloc__))  tmp ;

  {
#line 427
  info_ptr = (png_inforp )*ptr_ptr;
#line 431
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 432
    return;
  }
#line 434
  if (sizeof(png_info ) > png_info_struct_size) {
#line 436
    *ptr_ptr = (png_info *)((void *)0);
#line 438
    free((void *)info_ptr);
#line 439
    tmp = png_malloc_base((png_const_structrp )((void *)0), sizeof(*info_ptr));
#line 439
    info_ptr = (png_inforp )tmp;
#line 441
    if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 442
      return;
    }
#line 443
    *ptr_ptr = (png_info *)info_ptr;
  }
#line 447
  memset((void *)info_ptr, 0, sizeof(*info_ptr));
#line 448
  return;
}
}
#line 451 "/home/goblint2/bench/libpng-1.6.39/png.c"
void png_data_freer(png_const_structrp png_ptr , png_inforp info_ptr , int freer ,
                    png_uint_32 mask )
{


  {
#line 457
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 458
    return;
  } else
#line 457
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 458
    return;
  }
#line 460
  if (freer == 1) {
#line 461
    info_ptr->free_me |= mask;
  } else
#line 463
  if (freer == 2) {
#line 464
    info_ptr->free_me &= ~ mask;
  } else {
#line 467
    png_error(png_ptr, (png_const_charp )"Unknown freer parameter in png_data_freer");
  }
#line 468
  return;
}
}
#line 470 "/home/goblint2/bench/libpng-1.6.39/png.c"
void png_free_data(png_const_structrp png_ptr , png_inforp info_ptr , png_uint_32 mask ,
                   int num )
{
  int i ;
  int i___0 ;
  int i___1 ;
  int i___2 ;
  png_uint_32 row ;

  {
#line 476
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 477
    return;
  } else
#line 476
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 477
    return;
  }
#line 481
  if ((unsigned long )info_ptr->text != (unsigned long )((void *)0)) {
#line 481
    if (((mask & 0x4000U) & info_ptr->free_me) != 0U) {
#line 484
      if (num != -1) {
#line 486
        png_free(png_ptr, (png_voidp )(info_ptr->text + num)->key);
#line 487
        (info_ptr->text + num)->key = (png_charp )((void *)0);
      } else {
#line 494
        i = 0;
        {
#line 494
        while (1) {
          while_continue: /* CIL Label */ ;
#line 494
          if (! (i < info_ptr->num_text)) {
#line 494
            goto while_break;
          }
#line 495
          png_free(png_ptr, (png_voidp )(info_ptr->text + i)->key);
#line 494
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 497
        png_free(png_ptr, (png_voidp )info_ptr->text);
#line 498
        info_ptr->text = (png_textp )((void *)0);
#line 499
        info_ptr->num_text = 0;
#line 500
        info_ptr->max_text = 0;
      }
    }
  }
#line 507
  if (((mask & 0x2000U) & info_ptr->free_me) != 0U) {
#line 509
    info_ptr->valid &= 4294967279U;
#line 510
    png_free(png_ptr, (png_voidp )info_ptr->trans_alpha);
#line 511
    info_ptr->trans_alpha = (png_bytep )((void *)0);
#line 512
    info_ptr->num_trans = (png_uint_16 )0;
  }
#line 518
  if (((mask & 0x0100U) & info_ptr->free_me) != 0U) {
#line 520
    png_free(png_ptr, (png_voidp )info_ptr->scal_s_width);
#line 521
    png_free(png_ptr, (png_voidp )info_ptr->scal_s_height);
#line 522
    info_ptr->scal_s_width = (png_charp )((void *)0);
#line 523
    info_ptr->scal_s_height = (png_charp )((void *)0);
#line 524
    info_ptr->valid &= 4294950911U;
  }
#line 530
  if (((mask & 0x0080U) & info_ptr->free_me) != 0U) {
#line 532
    png_free(png_ptr, (png_voidp )info_ptr->pcal_purpose);
#line 533
    png_free(png_ptr, (png_voidp )info_ptr->pcal_units);
#line 534
    info_ptr->pcal_purpose = (png_charp )((void *)0);
#line 535
    info_ptr->pcal_units = (png_charp )((void *)0);
#line 537
    if ((unsigned long )info_ptr->pcal_params != (unsigned long )((void *)0)) {
#line 541
      i___0 = 0;
      {
#line 541
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 541
        if (! (i___0 < (int )info_ptr->pcal_nparams)) {
#line 541
          goto while_break___0;
        }
#line 542
        png_free(png_ptr, (png_voidp )*(info_ptr->pcal_params + i___0));
#line 541
        i___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 544
      png_free(png_ptr, (png_voidp )info_ptr->pcal_params);
#line 545
      info_ptr->pcal_params = (png_charpp )((void *)0);
    }
#line 547
    info_ptr->valid &= 4294966271U;
  }
#line 553
  if (((mask & 0x0010U) & info_ptr->free_me) != 0U) {
#line 555
    png_free(png_ptr, (png_voidp )info_ptr->iccp_name);
#line 556
    png_free(png_ptr, (png_voidp )info_ptr->iccp_profile);
#line 557
    info_ptr->iccp_name = (png_charp )((void *)0);
#line 558
    info_ptr->iccp_profile = (png_bytep )((void *)0);
#line 559
    info_ptr->valid &= 4294963199U;
  }
#line 565
  if ((unsigned long )info_ptr->splt_palettes != (unsigned long )((void *)0)) {
#line 565
    if (((mask & 0x0020U) & info_ptr->free_me) != 0U) {
#line 568
      if (num != -1) {
#line 570
        png_free(png_ptr, (png_voidp )(info_ptr->splt_palettes + num)->name);
#line 571
        png_free(png_ptr, (png_voidp )(info_ptr->splt_palettes + num)->entries);
#line 572
        (info_ptr->splt_palettes + num)->name = (png_charp )((void *)0);
#line 573
        (info_ptr->splt_palettes + num)->entries = (png_sPLT_entryp )((void *)0);
      } else {
#line 580
        i___1 = 0;
        {
#line 580
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 580
          if (! (i___1 < info_ptr->splt_palettes_num)) {
#line 580
            goto while_break___1;
          }
#line 582
          png_free(png_ptr, (png_voidp )(info_ptr->splt_palettes + i___1)->name);
#line 583
          png_free(png_ptr, (png_voidp )(info_ptr->splt_palettes + i___1)->entries);
#line 580
          i___1 ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 586
        png_free(png_ptr, (png_voidp )info_ptr->splt_palettes);
#line 587
        info_ptr->splt_palettes = (png_sPLT_tp )((void *)0);
#line 588
        info_ptr->splt_palettes_num = 0;
#line 589
        info_ptr->valid &= 4294959103U;
      }
    }
  }
#line 595
  if ((unsigned long )info_ptr->unknown_chunks != (unsigned long )((void *)0)) {
#line 595
    if (((mask & 0x0200U) & info_ptr->free_me) != 0U) {
#line 598
      if (num != -1) {
#line 600
        png_free(png_ptr, (png_voidp )(info_ptr->unknown_chunks + num)->data);
#line 601
        (info_ptr->unknown_chunks + num)->data = (png_byte *)((void *)0);
      } else {
#line 608
        i___2 = 0;
        {
#line 608
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 608
          if (! (i___2 < info_ptr->unknown_chunks_num)) {
#line 608
            goto while_break___2;
          }
#line 609
          png_free(png_ptr, (png_voidp )(info_ptr->unknown_chunks + i___2)->data);
#line 608
          i___2 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 611
        png_free(png_ptr, (png_voidp )info_ptr->unknown_chunks);
#line 612
        info_ptr->unknown_chunks = (png_unknown_chunkp )((void *)0);
#line 613
        info_ptr->unknown_chunks_num = 0;
      }
    }
  }
#line 620
  if (((mask & 0x8000U) & info_ptr->free_me) != 0U) {
#line 623
    if (info_ptr->eXIf_buf) {
#line 625
      png_free(png_ptr, (png_voidp )info_ptr->eXIf_buf);
#line 626
      info_ptr->eXIf_buf = (png_bytep )((void *)0);
    }
#line 629
    if (info_ptr->exif) {
#line 631
      png_free(png_ptr, (png_voidp )info_ptr->exif);
#line 632
      info_ptr->exif = (png_bytep )((void *)0);
    }
#line 634
    info_ptr->valid &= 4294901759U;
  }
#line 640
  if (((mask & 0x0008U) & info_ptr->free_me) != 0U) {
#line 642
    png_free(png_ptr, (png_voidp )info_ptr->hist);
#line 643
    info_ptr->hist = (png_uint_16p )((void *)0);
#line 644
    info_ptr->valid &= 4294967231U;
  }
#line 649
  if (((mask & 0x1000U) & info_ptr->free_me) != 0U) {
#line 651
    png_free(png_ptr, (png_voidp )info_ptr->palette);
#line 652
    info_ptr->palette = (png_colorp )((void *)0);
#line 653
    info_ptr->valid &= 4294967287U;
#line 654
    info_ptr->num_palette = (png_uint_16 )0;
  }
#line 659
  if (((mask & 0x0040U) & info_ptr->free_me) != 0U) {
#line 661
    if ((unsigned long )info_ptr->row_pointers != (unsigned long )((void *)0)) {
#line 664
      row = (png_uint_32 )0;
      {
#line 664
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 664
        if (! (row < info_ptr->height)) {
#line 664
          goto while_break___3;
        }
#line 665
        png_free(png_ptr, (png_voidp )*(info_ptr->row_pointers + row));
#line 664
        row ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 667
      png_free(png_ptr, (png_voidp )info_ptr->row_pointers);
#line 668
      info_ptr->row_pointers = (png_bytepp )((void *)0);
    }
#line 670
    info_ptr->valid &= 4294934527U;
  }
#line 674
  if (num != -1) {
#line 675
    mask &= 4294950367U;
  }
#line 677
  info_ptr->free_me &= ~ mask;
#line 678
  return;
}
}
#line 685 "/home/goblint2/bench/libpng-1.6.39/png.c"
png_voidp png_get_io_ptr(png_const_structrp png_ptr )
{


  {
#line 688
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 689
    return ((void *)0);
  }
#line 691
  return ((png_voidp )png_ptr->io_ptr);
}
}
#line 702 "/home/goblint2/bench/libpng-1.6.39/png.c"
void png_init_io(png_structrp png_ptr , png_FILE_p fp )
{


  {
#line 707
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 708
    return;
  }
#line 710
  png_ptr->io_ptr = (png_voidp )fp;
#line 711
  return;
}
}
#line 725 "/home/goblint2/bench/libpng-1.6.39/png.c"
void png_save_int_32(png_bytep buf , png_int_32 i )
{


  {
#line 728
  png_save_uint_32(buf, (png_uint_32 )i);
#line 729
  return;
}
}
#line 739 "/home/goblint2/bench/libpng-1.6.39/png.c"
static char const   short_months[12][4]  =
#line 739
  { {        (char const   )'J',        (char const   )'a',        (char const   )'n',        (char const   )'\000'},
   {        (char const   )'F',        (char const   )'e',        (char const   )'b',        (char const   )'\000'},
   {        (char const   )'M',        (char const   )'a',        (char const   )'r',        (char const   )'\000'},
   {        (char const   )'A',        (char const   )'p',        (char const   )'r',        (char const   )'\000'},
   {        (char const   )'M',        (char const   )'a',        (char const   )'y',        (char const   )'\000'},
   {        (char const   )'J',        (char const   )'u',        (char const   )'n',        (char const   )'\000'},
   {        (char const   )'J',        (char const   )'u',        (char const   )'l',        (char const   )'\000'},
   {        (char const   )'A',        (char const   )'u',        (char const   )'g',        (char const   )'\000'},
   {        (char const   )'S',        (char const   )'e',        (char const   )'p',        (char const   )'\000'},
   {        (char const   )'O',        (char const   )'c',        (char const   )'t',        (char const   )'\000'},
   {        (char const   )'N',        (char const   )'o',        (char const   )'v',        (char const   )'\000'},
   {        (char const   )'D',        (char const   )'e',        (char const   )'c',        (char const   )'\000'}};
#line 736 "/home/goblint2/bench/libpng-1.6.39/png.c"
int png_convert_to_rfc1123_buffer(char *out , png_const_timep ptime )
{
  size_t pos ;
  char number_buf[5] ;
  png_charp tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  png_charp tmp___2 ;
  size_t tmp___3 ;
  png_charp tmp___4 ;
  size_t tmp___5 ;
  png_charp tmp___6 ;
  size_t tmp___7 ;
  png_charp tmp___8 ;

  {
#line 743
  if ((unsigned long )out == (unsigned long )((void *)0)) {
#line 744
    return (0);
  }
#line 746
  if ((int )ptime->year > 9999) {
#line 751
    return (0);
  } else
#line 746
  if ((int )ptime->month == 0) {
#line 751
    return (0);
  } else
#line 746
  if ((int )ptime->month > 12) {
#line 751
    return (0);
  } else
#line 746
  if ((int )ptime->day == 0) {
#line 751
    return (0);
  } else
#line 746
  if ((int )ptime->day > 31) {
#line 751
    return (0);
  } else
#line 746
  if ((int )ptime->hour > 23) {
#line 751
    return (0);
  } else
#line 746
  if ((int )ptime->minute > 59) {
#line 751
    return (0);
  } else
#line 746
  if ((int )ptime->second > 60) {
#line 751
    return (0);
  }
#line 754
  pos = (size_t )0;
#line 762
  tmp = png_format_number((png_const_charp )(number_buf), number_buf + sizeof(number_buf),
                          1, (png_alloc_size_t )((unsigned int )ptime->day));
#line 762
  pos = png_safecat((png_charp )out, (size_t )29, pos, (png_const_charp )tmp);
#line 763
  if (pos < 28UL) {
#line 763
    tmp___0 = pos;
#line 763
    pos ++;
#line 763
    *(out + tmp___0) = (char )' ';
  }
#line 764
  pos = png_safecat((png_charp )out, (size_t )29, pos, short_months[(int )ptime->month - 1]);
#line 765
  if (pos < 28UL) {
#line 765
    tmp___1 = pos;
#line 765
    pos ++;
#line 765
    *(out + tmp___1) = (char )' ';
  }
#line 766
  tmp___2 = png_format_number((png_const_charp )(number_buf), number_buf + sizeof(number_buf),
                              1, (png_alloc_size_t )ptime->year);
#line 766
  pos = png_safecat((png_charp )out, (size_t )29, pos, (png_const_charp )tmp___2);
#line 767
  if (pos < 28UL) {
#line 767
    tmp___3 = pos;
#line 767
    pos ++;
#line 767
    *(out + tmp___3) = (char )' ';
  }
#line 768
  tmp___4 = png_format_number((png_const_charp )(number_buf), number_buf + sizeof(number_buf),
                              2, (png_alloc_size_t )((unsigned int )ptime->hour));
#line 768
  pos = png_safecat((png_charp )out, (size_t )29, pos, (png_const_charp )tmp___4);
#line 769
  if (pos < 28UL) {
#line 769
    tmp___5 = pos;
#line 769
    pos ++;
#line 769
    *(out + tmp___5) = (char )':';
  }
#line 770
  tmp___6 = png_format_number((png_const_charp )(number_buf), number_buf + sizeof(number_buf),
                              2, (png_alloc_size_t )((unsigned int )ptime->minute));
#line 770
  pos = png_safecat((png_charp )out, (size_t )29, pos, (png_const_charp )tmp___6);
#line 771
  if (pos < 28UL) {
#line 771
    tmp___7 = pos;
#line 771
    pos ++;
#line 771
    *(out + tmp___7) = (char )':';
  }
#line 772
  tmp___8 = png_format_number((png_const_charp )(number_buf), number_buf + sizeof(number_buf),
                              2, (png_alloc_size_t )((unsigned int )ptime->second));
#line 772
  pos = png_safecat((png_charp )out, (size_t )29, pos, (png_const_charp )tmp___8);
#line 773
  pos = png_safecat((png_charp )out, (size_t )29, pos, (png_const_charp )" +0000");
#line 781
  return (1);
}
}
#line 790 "/home/goblint2/bench/libpng-1.6.39/png.c"
png_const_charp __attribute__((__deprecated__))  png_convert_to_rfc1123(png_structrp png_ptr ,
                                                                        png_const_timep ptime )
{
  int tmp ;

  {
#line 793
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 796
    tmp = png_convert_to_rfc1123_buffer((char *)(png_ptr->time_buffer), ptime);
#line 796
    if (tmp == 0) {
#line 797
      png_warning((png_const_structrp )png_ptr, (png_const_charp )"Ignoring invalid time value");
    } else {
#line 800
      return ((png_const_charp )(png_ptr->time_buffer));
    }
  }
#line 803
  return ((png_const_charp )((void *)0));
}
}
#line 810 "/home/goblint2/bench/libpng-1.6.39/png.c"
png_const_charp png_get_copyright(png_const_structrp png_ptr )
{


  {
#line 817
  return ((png_const_charp )"\nlibpng version 1.6.39\nCopyright (c) 2018-2022 Cosmin Truta\nCopyright (c) 1998-2002,2004,2006-2018 Glenn Randers-Pehrson\nCopyright (c) 1996-1997 Andreas Dilger\nCopyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.\n");
}
}
#line 836 "/home/goblint2/bench/libpng-1.6.39/png.c"
png_const_charp png_get_libpng_ver(png_const_structrp png_ptr )
{
  png_const_charp tmp ;

  {
#line 840
  tmp = png_get_header_ver(png_ptr);
#line 840
  return (tmp);
}
}
#line 843 "/home/goblint2/bench/libpng-1.6.39/png.c"
png_const_charp png_get_header_ver(png_const_structrp png_ptr )
{


  {
#line 848
  return ((png_const_charp )"1.6.39");
}
}
#line 851 "/home/goblint2/bench/libpng-1.6.39/png.c"
png_const_charp png_get_header_version(png_const_structrp png_ptr )
{


  {
#line 857
  return ((png_const_charp )" libpng version 1.6.39 - November 20, 2022\n\n");
}
}
#line 874 "/home/goblint2/bench/libpng-1.6.39/png.c"
void png_build_grayscale_palette(int bit_depth , png_colorp palette )
{
  int num_palette ;
  int color_inc ;
  int i ;
  int v ;

  {
#line 884
  if ((unsigned long )palette == (unsigned long )((void *)0)) {
#line 885
    return;
  }
  {
#line 889
  if (bit_depth == 1) {
#line 889
    goto case_1;
  }
#line 894
  if (bit_depth == 2) {
#line 894
    goto case_2;
  }
#line 899
  if (bit_depth == 4) {
#line 899
    goto case_4;
  }
#line 904
  if (bit_depth == 8) {
#line 904
    goto case_8;
  }
#line 909
  goto switch_default;
  case_1: /* CIL Label */
#line 890
  num_palette = 2;
#line 891
  color_inc = 0xff;
#line 892
  goto switch_break;
  case_2: /* CIL Label */
#line 895
  num_palette = 4;
#line 896
  color_inc = 0x55;
#line 897
  goto switch_break;
  case_4: /* CIL Label */
#line 900
  num_palette = 16;
#line 901
  color_inc = 0x11;
#line 902
  goto switch_break;
  case_8: /* CIL Label */
#line 905
  num_palette = 256;
#line 906
  color_inc = 1;
#line 907
  goto switch_break;
  switch_default: /* CIL Label */
#line 910
  num_palette = 0;
#line 911
  color_inc = 0;
#line 912
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 915
  i = 0;
#line 915
  v = 0;
  {
#line 915
  while (1) {
    while_continue: /* CIL Label */ ;
#line 915
    if (! (i < num_palette)) {
#line 915
      goto while_break;
    }
#line 917
    (palette + i)->red = (png_byte )(v & 0xff);
#line 918
    (palette + i)->green = (png_byte )(v & 0xff);
#line 919
    (palette + i)->blue = (png_byte )(v & 0xff);
#line 915
    i ++;
#line 915
    v += color_inc;
  }
  while_break: /* CIL Label */ ;
  }
#line 921
  return;
}
}
#line 925 "/home/goblint2/bench/libpng-1.6.39/png.c"
int png_handle_as_unknown(png_const_structrp png_ptr , png_const_bytep chunk_name )
{
  png_const_bytep p ;
  png_const_bytep p_end ;
  int tmp ;

  {
#line 931
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 932
    return (0);
  } else
#line 931
  if ((unsigned long )chunk_name == (unsigned long )((void *)0)) {
#line 932
    return (0);
  } else
#line 931
  if (png_ptr->num_chunk_list == 0U) {
#line 932
    return (0);
  }
#line 934
  p_end = (png_const_bytep )png_ptr->chunk_list;
#line 935
  p = p_end + png_ptr->num_chunk_list * 5U;
  {
#line 941
  while (1) {
    while_continue: /* CIL Label */ ;
#line 943
    p -= 5;
#line 945
    tmp = memcmp((void const   *)chunk_name, (void const   *)p, (size_t )4);
#line 945
    if (tmp == 0) {
#line 946
      return ((int )*(p + 4));
    }
#line 941
    if (! ((unsigned long )p > (unsigned long )p_end)) {
#line 941
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 955
  return (0);
}
}
#line 960 "/home/goblint2/bench/libpng-1.6.39/png.c"
int png_chunk_unknown_handling(png_const_structrp png_ptr , png_uint_32 chunk_name )
{
  png_byte chunk_string[5] ;
  int tmp ;

  {
#line 965
  *((char *)(chunk_string) + 0) = (char )((chunk_name >> 24) & 255U);
#line 965
  *((char *)(chunk_string) + 1) = (char )((chunk_name >> 16) & 255U);
#line 965
  *((char *)(chunk_string) + 2) = (char )((chunk_name >> 8) & 255U);
#line 965
  *((char *)(chunk_string) + 3) = (char )(chunk_name & 255U);
#line 965
  *((char *)(chunk_string) + 4) = (char)0;
#line 966
  tmp = png_handle_as_unknown(png_ptr, (png_const_bytep )(chunk_string));
#line 966
  return (tmp);
}
}
#line 973 "/home/goblint2/bench/libpng-1.6.39/png.c"
int __attribute__((__deprecated__))  png_reset_zstream(png_structrp png_ptr )
{
  int tmp ;

  {
#line 976
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 977
    return (-2);
  }
#line 980
  tmp = inflateReset(& png_ptr->zstream);
#line 980
  return (tmp);
}
}
#line 985 "/home/goblint2/bench/libpng-1.6.39/png.c"
png_uint_32 png_access_version_number(void)
{


  {
#line 989
  return ((png_uint_32 )10639);
}
}
#line 997 "/home/goblint2/bench/libpng-1.6.39/png.c"
void png_zstream_error(png_structrp png_ptr , int ret )
{


  {
#line 1004
  if ((unsigned long )png_ptr->zstream.msg == (unsigned long )((void *)0)) {
    {
#line 1011
    if (ret == 1) {
#line 1011
      goto case_1;
    }
#line 1016
    if (ret == 2) {
#line 1016
      goto case_2;
    }
#line 1023
    if (ret == -1) {
#line 1023
      goto case_neg_1;
    }
#line 1028
    if (ret == -2) {
#line 1028
      goto case_neg_2;
    }
#line 1033
    if (ret == -3) {
#line 1033
      goto case_neg_3;
    }
#line 1037
    if (ret == -4) {
#line 1037
      goto case_neg_4;
    }
#line 1041
    if (ret == -5) {
#line 1041
      goto case_neg_5;
    }
#line 1048
    if (ret == -6) {
#line 1048
      goto case_neg_6;
    }
#line 1052
    if (ret == -7) {
#line 1052
      goto case_neg_7;
    }
#line 1006
    goto case_0;
    case_0: /* CIL Label */
    switch_default: /* CIL Label */
#line 1008
    png_ptr->zstream.msg = (char const   *)"unexpected zlib return code";
#line 1009
    goto switch_break;
    case_1: /* CIL Label */
#line 1013
    png_ptr->zstream.msg = (char const   *)"unexpected end of LZ stream";
#line 1014
    goto switch_break;
    case_2: /* CIL Label */
#line 1020
    png_ptr->zstream.msg = (char const   *)"missing LZ dictionary";
#line 1021
    goto switch_break;
    case_neg_1: /* CIL Label */
#line 1025
    png_ptr->zstream.msg = (char const   *)"zlib IO error";
#line 1026
    goto switch_break;
    case_neg_2: /* CIL Label */
#line 1030
    png_ptr->zstream.msg = (char const   *)"bad parameters to zlib";
#line 1031
    goto switch_break;
    case_neg_3: /* CIL Label */
#line 1034
    png_ptr->zstream.msg = (char const   *)"damaged LZ stream";
#line 1035
    goto switch_break;
    case_neg_4: /* CIL Label */
#line 1038
    png_ptr->zstream.msg = (char const   *)"insufficient memory";
#line 1039
    goto switch_break;
    case_neg_5: /* CIL Label */
#line 1045
    png_ptr->zstream.msg = (char const   *)"truncated";
#line 1046
    goto switch_break;
    case_neg_6: /* CIL Label */
#line 1049
    png_ptr->zstream.msg = (char const   *)"unsupported zlib version";
#line 1050
    goto switch_break;
    case_neg_7: /* CIL Label */
#line 1058
    png_ptr->zstream.msg = (char const   *)"unexpected zlib return";
#line 1059
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 1061
  return;
}
}
#line 1069 "/home/goblint2/bench/libpng-1.6.39/png.c"
static int png_colorspace_check_gamma(png_const_structrp png_ptr , png_colorspacerp colorspace ,
                                      png_fixed_point gAMA , int from )
{
  png_fixed_point gtest ;
  int tmp ;
  int tmp___0 ;

  {
#line 1084
  if (((int )colorspace->flags & 0x0001) != 0) {
#line 1084
    tmp = png_muldiv(& gtest, colorspace->gamma, 100000, gAMA);
#line 1084
    if (tmp == 0) {
#line 1084
      goto _L;
    } else {
#line 1084
      tmp___0 = png_gamma_significant(gtest);
#line 1084
      if (tmp___0 != 0) {
        _L: /* CIL Label */
#line 1094
        if (((int )colorspace->flags & 0x0020) != 0) {
#line 1096
          png_chunk_report(png_ptr, (png_const_charp )"gamma value does not match sRGB",
                           2);
#line 1099
          return (from == 2);
        } else
#line 1094
        if (from == 2) {
#line 1096
          png_chunk_report(png_ptr, (png_const_charp )"gamma value does not match sRGB",
                           2);
#line 1099
          return (from == 2);
        } else {
#line 1104
          png_chunk_report(png_ptr, (png_const_charp )"gamma value does not match libpng estimate",
                           0);
#line 1106
          return (from == 1);
        }
      }
    }
  }
#line 1110
  return (1);
}
}
#line 1113 "/home/goblint2/bench/libpng-1.6.39/png.c"
void png_colorspace_set_gamma(png_const_structrp png_ptr , png_colorspacerp colorspace ,
                              png_fixed_point gAMA )
{
  png_const_charp errmsg ;
  int tmp ;

  {
#line 1130
  if (gAMA < 16) {
#line 1131
    errmsg = (png_const_charp )"gamma value out of range";
  } else
#line 1130
  if (gAMA > 625000000) {
#line 1131
    errmsg = (png_const_charp )"gamma value out of range";
  } else
#line 1135
  if ((png_ptr->mode & 32768U) != 0U) {
#line 1135
    if (((int )colorspace->flags & 0x0008) != 0) {
#line 1137
      errmsg = (png_const_charp )"duplicate";
    } else {
#line 1135
      goto _L;
    }
  } else
  _L: /* CIL Label */
#line 1141
  if (((int )colorspace->flags & 0x8000) != 0) {
#line 1142
    return;
  } else {
#line 1146
    tmp = png_colorspace_check_gamma(png_ptr, colorspace, gAMA, 1);
#line 1146
    if (tmp != 0) {
#line 1150
      colorspace->gamma = gAMA;
#line 1151
      colorspace->flags = (png_uint_16 )((int )colorspace->flags | 9);
    }
#line 1160
    return;
  }
#line 1164
  colorspace->flags = (png_uint_16 )((int )colorspace->flags | 0x8000);
#line 1165
  png_chunk_report(png_ptr, errmsg, 1);
#line 1166
  return;
}
}
#line 1168 "/home/goblint2/bench/libpng-1.6.39/png.c"
void png_colorspace_sync_info(png_const_structrp png_ptr , png_inforp info_ptr )
{


  {
#line 1171
  if (((int )info_ptr->colorspace.flags & 0x8000) != 0) {
#line 1174
    info_ptr->valid &= 4294961146U;
#line 1179
    png_free_data(png_ptr, info_ptr, 0x0010U, -1);
  } else {
#line 1192
    if (((int )info_ptr->colorspace.flags & 0x0080) != 0) {
#line 1193
      info_ptr->valid |= 0x0800U;
    } else {
#line 1196
      info_ptr->valid &= 4294965247U;
    }
#line 1198
    if (((int )info_ptr->colorspace.flags & 0x0002) != 0) {
#line 1199
      info_ptr->valid |= 0x0004U;
    } else {
#line 1202
      info_ptr->valid &= 4294967291U;
    }
#line 1205
    if (((int )info_ptr->colorspace.flags & 0x0001) != 0) {
#line 1206
      info_ptr->valid |= 0x0001U;
    } else {
#line 1209
      info_ptr->valid &= 4294967294U;
    }
  }
#line 1211
  return;
}
}
#line 1214 "/home/goblint2/bench/libpng-1.6.39/png.c"
void png_colorspace_sync(png_const_structrp png_ptr , png_inforp info_ptr )
{


  {
#line 1217
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 1218
    return;
  }
#line 1220
  info_ptr->colorspace = (png_colorspace )png_ptr->colorspace;
#line 1221
  png_colorspace_sync_info(png_ptr, info_ptr);
#line 1222
  return;
}
}
#line 1232 "/home/goblint2/bench/libpng-1.6.39/png.c"
static int png_xy_from_XYZ(png_xy *xy , png_XYZ const   *XYZ )
{
  png_int_32 d ;
  png_int_32 dwhite ;
  png_int_32 whiteX ;
  png_int_32 whiteY ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1237
  d = (png_int_32 )((XYZ->red_X + XYZ->red_Y) + XYZ->red_Z);
#line 1238
  tmp = png_muldiv(& xy->redx, (png_fixed_point )XYZ->red_X, 100000, d);
#line 1238
  if (tmp == 0) {
#line 1239
    return (1);
  }
#line 1240
  tmp___0 = png_muldiv(& xy->redy, (png_fixed_point )XYZ->red_Y, 100000, d);
#line 1240
  if (tmp___0 == 0) {
#line 1241
    return (1);
  }
#line 1242
  dwhite = d;
#line 1243
  whiteX = (png_int_32 )XYZ->red_X;
#line 1244
  whiteY = (png_int_32 )XYZ->red_Y;
#line 1246
  d = (png_int_32 )((XYZ->green_X + XYZ->green_Y) + XYZ->green_Z);
#line 1247
  tmp___1 = png_muldiv(& xy->greenx, (png_fixed_point )XYZ->green_X, 100000, d);
#line 1247
  if (tmp___1 == 0) {
#line 1248
    return (1);
  }
#line 1249
  tmp___2 = png_muldiv(& xy->greeny, (png_fixed_point )XYZ->green_Y, 100000, d);
#line 1249
  if (tmp___2 == 0) {
#line 1250
    return (1);
  }
#line 1251
  dwhite += d;
#line 1252
  whiteX += (png_int_32 )XYZ->green_X;
#line 1253
  whiteY += (png_int_32 )XYZ->green_Y;
#line 1255
  d = (png_int_32 )((XYZ->blue_X + XYZ->blue_Y) + XYZ->blue_Z);
#line 1256
  tmp___3 = png_muldiv(& xy->bluex, (png_fixed_point )XYZ->blue_X, 100000, d);
#line 1256
  if (tmp___3 == 0) {
#line 1257
    return (1);
  }
#line 1258
  tmp___4 = png_muldiv(& xy->bluey, (png_fixed_point )XYZ->blue_Y, 100000, d);
#line 1258
  if (tmp___4 == 0) {
#line 1259
    return (1);
  }
#line 1260
  dwhite += d;
#line 1261
  whiteX += (png_int_32 )XYZ->blue_X;
#line 1262
  whiteY += (png_int_32 )XYZ->blue_Y;
#line 1267
  tmp___5 = png_muldiv(& xy->whitex, whiteX, 100000, dwhite);
#line 1267
  if (tmp___5 == 0) {
#line 1268
    return (1);
  }
#line 1269
  tmp___6 = png_muldiv(& xy->whitey, whiteY, 100000, dwhite);
#line 1269
  if (tmp___6 == 0) {
#line 1270
    return (1);
  }
#line 1272
  return (0);
}
}
#line 1275 "/home/goblint2/bench/libpng-1.6.39/png.c"
static int png_XYZ_from_xy(png_XYZ *XYZ , png_xy const   *xy )
{
  png_fixed_point red_inverse ;
  png_fixed_point green_inverse ;
  png_fixed_point blue_scale ;
  png_fixed_point left ;
  png_fixed_point right ;
  png_fixed_point denominator ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  png_fixed_point tmp___7 ;
  png_fixed_point tmp___8 ;
  png_fixed_point tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 1286
  if (xy->redx < 0) {
#line 1286
    return (1);
  } else
#line 1286
  if (xy->redx > 100000) {
#line 1286
    return (1);
  }
#line 1287
  if (xy->redy < 0) {
#line 1287
    return (1);
  } else
#line 1287
  if (xy->redy > (png_fixed_point )(100000 - (int )xy->redx)) {
#line 1287
    return (1);
  }
#line 1288
  if (xy->greenx < 0) {
#line 1288
    return (1);
  } else
#line 1288
  if (xy->greenx > 100000) {
#line 1288
    return (1);
  }
#line 1289
  if (xy->greeny < 0) {
#line 1289
    return (1);
  } else
#line 1289
  if (xy->greeny > (png_fixed_point )(100000 - (int )xy->greenx)) {
#line 1289
    return (1);
  }
#line 1290
  if (xy->bluex < 0) {
#line 1290
    return (1);
  } else
#line 1290
  if (xy->bluex > 100000) {
#line 1290
    return (1);
  }
#line 1291
  if (xy->bluey < 0) {
#line 1291
    return (1);
  } else
#line 1291
  if (xy->bluey > (png_fixed_point )(100000 - (int )xy->bluex)) {
#line 1291
    return (1);
  }
#line 1292
  if (xy->whitex < 0) {
#line 1292
    return (1);
  } else
#line 1292
  if (xy->whitex > 100000) {
#line 1292
    return (1);
  }
#line 1293
  if (xy->whitey < 5) {
#line 1293
    return (1);
  } else
#line 1293
  if (xy->whitey > (png_fixed_point )(100000 - (int )xy->whitex)) {
#line 1293
    return (1);
  }
#line 1474
  tmp = png_muldiv(& left, (png_fixed_point )(xy->greenx - xy->bluex), (png_int_32 )(xy->redy - xy->bluey),
                   7);
#line 1474
  if (tmp == 0) {
#line 1475
    return (2);
  }
#line 1476
  tmp___0 = png_muldiv(& right, (png_fixed_point )(xy->greeny - xy->bluey), (png_int_32 )(xy->redx - xy->bluex),
                       7);
#line 1476
  if (tmp___0 == 0) {
#line 1477
    return (2);
  }
#line 1478
  denominator = left - right;
#line 1481
  tmp___1 = png_muldiv(& left, (png_fixed_point )(xy->greenx - xy->bluex), (png_int_32 )(xy->whitey - xy->bluey),
                       7);
#line 1481
  if (tmp___1 == 0) {
#line 1482
    return (2);
  }
#line 1483
  tmp___2 = png_muldiv(& right, (png_fixed_point )(xy->greeny - xy->bluey), (png_int_32 )(xy->whitex - xy->bluex),
                       7);
#line 1483
  if (tmp___2 == 0) {
#line 1484
    return (2);
  }
#line 1491
  tmp___3 = png_muldiv(& red_inverse, (png_fixed_point )xy->whitey, denominator, left - right);
#line 1491
  if (tmp___3 == 0) {
#line 1493
    return (1);
  } else
#line 1491
  if (red_inverse <= (png_fixed_point )xy->whitey) {
#line 1493
    return (1);
  }
#line 1496
  tmp___4 = png_muldiv(& left, (png_fixed_point )(xy->redy - xy->bluey), (png_int_32 )(xy->whitex - xy->bluex),
                       7);
#line 1496
  if (tmp___4 == 0) {
#line 1497
    return (2);
  }
#line 1498
  tmp___5 = png_muldiv(& right, (png_fixed_point )(xy->redx - xy->bluex), (png_int_32 )(xy->whitey - xy->bluey),
                       7);
#line 1498
  if (tmp___5 == 0) {
#line 1499
    return (2);
  }
#line 1500
  tmp___6 = png_muldiv(& green_inverse, (png_fixed_point )xy->whitey, denominator,
                       left - right);
#line 1500
  if (tmp___6 == 0) {
#line 1502
    return (1);
  } else
#line 1500
  if (green_inverse <= (png_fixed_point )xy->whitey) {
#line 1502
    return (1);
  }
#line 1507
  tmp___7 = png_reciprocal((png_fixed_point )xy->whitey);
#line 1507
  tmp___8 = png_reciprocal(red_inverse);
#line 1507
  tmp___9 = png_reciprocal(green_inverse);
#line 1507
  blue_scale = (tmp___7 - tmp___8) - tmp___9;
#line 1509
  if (blue_scale <= 0) {
#line 1510
    return (1);
  }
#line 1514
  tmp___10 = png_muldiv(& XYZ->red_X, (png_fixed_point )xy->redx, 100000, red_inverse);
#line 1514
  if (tmp___10 == 0) {
#line 1515
    return (1);
  }
#line 1516
  tmp___11 = png_muldiv(& XYZ->red_Y, (png_fixed_point )xy->redy, 100000, red_inverse);
#line 1516
  if (tmp___11 == 0) {
#line 1517
    return (1);
  }
#line 1518
  tmp___12 = png_muldiv(& XYZ->red_Z, (100000 - (int )xy->redx) - (int )xy->redy,
                        100000, red_inverse);
#line 1518
  if (tmp___12 == 0) {
#line 1520
    return (1);
  }
#line 1522
  tmp___13 = png_muldiv(& XYZ->green_X, (png_fixed_point )xy->greenx, 100000, green_inverse);
#line 1522
  if (tmp___13 == 0) {
#line 1523
    return (1);
  }
#line 1524
  tmp___14 = png_muldiv(& XYZ->green_Y, (png_fixed_point )xy->greeny, 100000, green_inverse);
#line 1524
  if (tmp___14 == 0) {
#line 1525
    return (1);
  }
#line 1526
  tmp___15 = png_muldiv(& XYZ->green_Z, (100000 - (int )xy->greenx) - (int )xy->greeny,
                        100000, green_inverse);
#line 1526
  if (tmp___15 == 0) {
#line 1528
    return (1);
  }
#line 1530
  tmp___16 = png_muldiv(& XYZ->blue_X, (png_fixed_point )xy->bluex, blue_scale, 100000);
#line 1530
  if (tmp___16 == 0) {
#line 1531
    return (1);
  }
#line 1532
  tmp___17 = png_muldiv(& XYZ->blue_Y, (png_fixed_point )xy->bluey, blue_scale, 100000);
#line 1532
  if (tmp___17 == 0) {
#line 1533
    return (1);
  }
#line 1534
  tmp___18 = png_muldiv(& XYZ->blue_Z, (100000 - (int )xy->bluex) - (int )xy->bluey,
                        blue_scale, 100000);
#line 1534
  if (tmp___18 == 0) {
#line 1536
    return (1);
  }
#line 1538
  return (0);
}
}
#line 1541 "/home/goblint2/bench/libpng-1.6.39/png.c"
static int png_XYZ_normalize(png_XYZ *XYZ )
{
  png_int_32 Y ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 1546
  if (XYZ->red_Y < 0) {
#line 1549
    return (1);
  } else
#line 1546
  if (XYZ->green_Y < 0) {
#line 1549
    return (1);
  } else
#line 1546
  if (XYZ->blue_Y < 0) {
#line 1549
    return (1);
  } else
#line 1546
  if (XYZ->red_X < 0) {
#line 1549
    return (1);
  } else
#line 1546
  if (XYZ->green_X < 0) {
#line 1549
    return (1);
  } else
#line 1546
  if (XYZ->blue_X < 0) {
#line 1549
    return (1);
  } else
#line 1546
  if (XYZ->red_Z < 0) {
#line 1549
    return (1);
  } else
#line 1546
  if (XYZ->green_Z < 0) {
#line 1549
    return (1);
  } else
#line 1546
  if (XYZ->blue_Z < 0) {
#line 1549
    return (1);
  }
#line 1556
  Y = XYZ->red_Y;
#line 1557
  if (0x7fffffff - Y < XYZ->green_X) {
#line 1558
    return (1);
  }
#line 1559
  Y += XYZ->green_Y;
#line 1560
  if (0x7fffffff - Y < XYZ->blue_X) {
#line 1561
    return (1);
  }
#line 1562
  Y += XYZ->blue_Y;
#line 1564
  if (Y != 100000) {
#line 1566
    tmp = png_muldiv(& XYZ->red_X, XYZ->red_X, 100000, Y);
#line 1566
    if (tmp == 0) {
#line 1567
      return (1);
    }
#line 1568
    tmp___0 = png_muldiv(& XYZ->red_Y, XYZ->red_Y, 100000, Y);
#line 1568
    if (tmp___0 == 0) {
#line 1569
      return (1);
    }
#line 1570
    tmp___1 = png_muldiv(& XYZ->red_Z, XYZ->red_Z, 100000, Y);
#line 1570
    if (tmp___1 == 0) {
#line 1571
      return (1);
    }
#line 1573
    tmp___2 = png_muldiv(& XYZ->green_X, XYZ->green_X, 100000, Y);
#line 1573
    if (tmp___2 == 0) {
#line 1574
      return (1);
    }
#line 1575
    tmp___3 = png_muldiv(& XYZ->green_Y, XYZ->green_Y, 100000, Y);
#line 1575
    if (tmp___3 == 0) {
#line 1576
      return (1);
    }
#line 1577
    tmp___4 = png_muldiv(& XYZ->green_Z, XYZ->green_Z, 100000, Y);
#line 1577
    if (tmp___4 == 0) {
#line 1578
      return (1);
    }
#line 1580
    tmp___5 = png_muldiv(& XYZ->blue_X, XYZ->blue_X, 100000, Y);
#line 1580
    if (tmp___5 == 0) {
#line 1581
      return (1);
    }
#line 1582
    tmp___6 = png_muldiv(& XYZ->blue_Y, XYZ->blue_Y, 100000, Y);
#line 1582
    if (tmp___6 == 0) {
#line 1583
      return (1);
    }
#line 1584
    tmp___7 = png_muldiv(& XYZ->blue_Z, XYZ->blue_Z, 100000, Y);
#line 1584
    if (tmp___7 == 0) {
#line 1585
      return (1);
    }
  }
#line 1588
  return (0);
}
}
#line 1591 "/home/goblint2/bench/libpng-1.6.39/png.c"
static int png_colorspace_endpoints_match(png_xy const   *xy1 , png_xy const   *xy2 ,
                                          int delta )
{


  {
#line 1595
  if (xy1->whitex < xy2->whitex - (png_fixed_point )delta) {
#line 1603
    return (0);
  } else
#line 1595
  if (xy1->whitex > xy2->whitex + (png_fixed_point )delta) {
#line 1603
    return (0);
  } else
#line 1595
  if (xy1->whitey < xy2->whitey - (png_fixed_point )delta) {
#line 1603
    return (0);
  } else
#line 1595
  if (xy1->whitey > xy2->whitey + (png_fixed_point )delta) {
#line 1603
    return (0);
  } else
#line 1595
  if (xy1->redx < xy2->redx - (png_fixed_point )delta) {
#line 1603
    return (0);
  } else
#line 1595
  if (xy1->redx > xy2->redx + (png_fixed_point )delta) {
#line 1603
    return (0);
  } else
#line 1595
  if (xy1->redy < xy2->redy - (png_fixed_point )delta) {
#line 1603
    return (0);
  } else
#line 1595
  if (xy1->redy > xy2->redy + (png_fixed_point )delta) {
#line 1603
    return (0);
  } else
#line 1595
  if (xy1->greenx < xy2->greenx - (png_fixed_point )delta) {
#line 1603
    return (0);
  } else
#line 1595
  if (xy1->greenx > xy2->greenx + (png_fixed_point )delta) {
#line 1603
    return (0);
  } else
#line 1595
  if (xy1->greeny < xy2->greeny - (png_fixed_point )delta) {
#line 1603
    return (0);
  } else
#line 1595
  if (xy1->greeny > xy2->greeny + (png_fixed_point )delta) {
#line 1603
    return (0);
  } else
#line 1595
  if (xy1->bluex < xy2->bluex - (png_fixed_point )delta) {
#line 1603
    return (0);
  } else
#line 1595
  if (xy1->bluex > xy2->bluex + (png_fixed_point )delta) {
#line 1603
    return (0);
  } else
#line 1595
  if (xy1->bluey < xy2->bluey - (png_fixed_point )delta) {
#line 1603
    return (0);
  } else
#line 1595
  if (xy1->bluey > xy2->bluey + (png_fixed_point )delta) {
#line 1603
    return (0);
  }
#line 1604
  return (1);
}
}
#line 1617 "/home/goblint2/bench/libpng-1.6.39/png.c"
static int png_colorspace_check_xy(png_XYZ *XYZ , png_xy const   *xy )
{
  int result ;
  png_xy xy_test ;
  int tmp ;

  {
#line 1624
  result = png_XYZ_from_xy(XYZ, xy);
#line 1625
  if (result != 0) {
#line 1626
    return (result);
  }
#line 1628
  result = png_xy_from_XYZ(& xy_test, (png_XYZ const   *)XYZ);
#line 1629
  if (result != 0) {
#line 1630
    return (result);
  }
#line 1632
  tmp = png_colorspace_endpoints_match(xy, (png_xy const   *)(& xy_test), 5);
#line 1632
  if (tmp != 0) {
#line 1634
    return (0);
  }
#line 1637
  return (1);
}
}
#line 1643 "/home/goblint2/bench/libpng-1.6.39/png.c"
static int png_colorspace_check_XYZ(png_xy *xy , png_XYZ *XYZ )
{
  int result ;
  png_XYZ XYZtemp ;
  int tmp ;

  {
#line 1649
  result = png_XYZ_normalize(XYZ);
#line 1650
  if (result != 0) {
#line 1651
    return (result);
  }
#line 1653
  result = png_xy_from_XYZ(xy, (png_XYZ const   *)XYZ);
#line 1654
  if (result != 0) {
#line 1655
    return (result);
  }
#line 1657
  XYZtemp = *XYZ;
#line 1658
  tmp = png_colorspace_check_xy(& XYZtemp, (png_xy const   *)xy);
#line 1658
  return (tmp);
}
}
#line 1662 "/home/goblint2/bench/libpng-1.6.39/png.c"
static struct png_xy  const  sRGB_xy  =
#line 1662
     {64000, 33000, 30000, 60000, 15000, 6000, 31270, 32900};
#line 1671 "/home/goblint2/bench/libpng-1.6.39/png.c"
static int png_colorspace_set_xy_and_XYZ(png_const_structrp png_ptr , png_colorspacerp colorspace ,
                                         png_xy const   *xy , png_XYZ const   *XYZ ,
                                         int preferred )
{
  int tmp ;
  int tmp___0 ;

  {
#line 1676
  if (((int )colorspace->flags & 0x8000) != 0) {
#line 1677
    return (0);
  }
#line 1683
  if (preferred < 2) {
#line 1683
    if (((int )colorspace->flags & 0x0002) != 0) {
#line 1689
      tmp = png_colorspace_endpoints_match(xy, (png_xy const   *)(& colorspace->end_points_xy),
                                           100);
#line 1689
      if (tmp == 0) {
#line 1692
        colorspace->flags = (png_uint_16 )((int )colorspace->flags | 0x8000);
#line 1693
        png_benign_error(png_ptr, (png_const_charp )"inconsistent chromaticities");
#line 1694
        return (0);
      }
#line 1698
      if (preferred == 0) {
#line 1699
        return (1);
      }
    }
  }
#line 1702
  colorspace->end_points_xy = (png_xy )*xy;
#line 1703
  colorspace->end_points_XYZ = (png_XYZ )*XYZ;
#line 1704
  colorspace->flags = (png_uint_16 )((int )colorspace->flags | 0x0002);
#line 1709
  tmp___0 = png_colorspace_endpoints_match(xy, & sRGB_xy, 1000);
#line 1709
  if (tmp___0 != 0) {
#line 1710
    colorspace->flags = (png_uint_16 )((int )colorspace->flags | 0x0040);
  } else {
#line 1713
    colorspace->flags = (png_uint_16 )((int )colorspace->flags & 65471);
  }
#line 1716
  return (2);
}
}
#line 1719 "/home/goblint2/bench/libpng-1.6.39/png.c"
int png_colorspace_set_chromaticities(png_const_structrp png_ptr , png_colorspacerp colorspace ,
                                      png_xy const   *xy , int preferred )
{
  png_XYZ XYZ ;
  int tmp ;
  int tmp___0 ;

  {
#line 1731
  tmp = png_colorspace_check_xy(& XYZ, xy);
  {
#line 1733
  if (tmp == 0) {
#line 1733
    goto case_0;
  }
#line 1737
  if (tmp == 1) {
#line 1737
    goto case_1;
  }
#line 1745
  goto switch_default;
  case_0: /* CIL Label */
#line 1734
  tmp___0 = png_colorspace_set_xy_and_XYZ(png_ptr, colorspace, xy, (png_XYZ const   *)(& XYZ),
                                          preferred);
#line 1734
  return (tmp___0);
  case_1: /* CIL Label */
#line 1741
  colorspace->flags = (png_uint_16 )((int )colorspace->flags | 0x8000);
#line 1742
  png_benign_error(png_ptr, (png_const_charp )"invalid chromaticities");
#line 1743
  goto switch_break;
  switch_default: /* CIL Label */
#line 1749
  colorspace->flags = (png_uint_16 )((int )colorspace->flags | 0x8000);
#line 1750
  png_error(png_ptr, (png_const_charp )"internal error checking chromaticities");
  switch_break: /* CIL Label */ ;
  }
#line 1753
  return (0);
}
}
#line 1756 "/home/goblint2/bench/libpng-1.6.39/png.c"
int png_colorspace_set_endpoints(png_const_structrp png_ptr , png_colorspacerp colorspace ,
                                 png_XYZ const   *XYZ_in , int preferred )
{
  png_XYZ XYZ ;
  png_xy xy ;
  int tmp ;
  int tmp___0 ;

  {
#line 1760
  XYZ = *XYZ_in;
#line 1763
  tmp = png_colorspace_check_XYZ(& xy, & XYZ);
  {
#line 1765
  if (tmp == 0) {
#line 1765
    goto case_0;
  }
#line 1769
  if (tmp == 1) {
#line 1769
    goto case_1;
  }
#line 1775
  goto switch_default;
  case_0: /* CIL Label */
#line 1766
  tmp___0 = png_colorspace_set_xy_and_XYZ(png_ptr, colorspace, (png_xy const   *)(& xy),
                                          (png_XYZ const   *)(& XYZ), preferred);
#line 1766
  return (tmp___0);
  case_1: /* CIL Label */
#line 1771
  colorspace->flags = (png_uint_16 )((int )colorspace->flags | 0x8000);
#line 1772
  png_benign_error(png_ptr, (png_const_charp )"invalid end points");
#line 1773
  goto switch_break;
  switch_default: /* CIL Label */
#line 1776
  colorspace->flags = (png_uint_16 )((int )colorspace->flags | 0x8000);
#line 1777
  png_error(png_ptr, (png_const_charp )"internal error checking chromaticities");
  switch_break: /* CIL Label */ ;
  }
#line 1780
  return (0);
}
}
#line 1785 "/home/goblint2/bench/libpng-1.6.39/png.c"
static char png_icc_tag_char(png_uint_32 byte )
{


  {
#line 1788
  byte &= 255U;
#line 1789
  if (byte >= 32U) {
#line 1789
    if (byte <= 126U) {
#line 1790
      return ((char )byte);
    } else {
#line 1792
      return ((char )'?');
    }
  } else {
#line 1792
    return ((char )'?');
  }
}
}
#line 1795 "/home/goblint2/bench/libpng-1.6.39/png.c"
static void png_icc_tag_name(char *name , png_uint_32 tag )
{


  {
#line 1798
  *(name + 0) = (char )'\'';
#line 1799
  *(name + 1) = png_icc_tag_char(tag >> 24);
#line 1800
  *(name + 2) = png_icc_tag_char(tag >> 16);
#line 1801
  *(name + 3) = png_icc_tag_char(tag >> 8);
#line 1802
  *(name + 4) = png_icc_tag_char(tag);
#line 1803
  *(name + 5) = (char )'\'';
#line 1804
  return;
}
}
#line 1806 "/home/goblint2/bench/libpng-1.6.39/png.c"
static int is_ICC_signature_char(png_alloc_size_t it )
{
  int tmp ;

  {
#line 1809
  if (it == 32UL) {
#line 1809
    tmp = 1;
  } else
#line 1809
  if (it >= 48UL) {
#line 1809
    if (it <= 57UL) {
#line 1809
      tmp = 1;
    } else {
#line 1809
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */
#line 1809
  if (it >= 65UL) {
#line 1809
    if (it <= 90UL) {
#line 1809
      tmp = 1;
    } else {
#line 1809
      goto _L;
    }
  } else
  _L: /* CIL Label */
#line 1809
  if (it >= 97UL) {
#line 1809
    if (it <= 122UL) {
#line 1809
      tmp = 1;
    } else {
#line 1809
      tmp = 0;
    }
  } else {
#line 1809
    tmp = 0;
  }
#line 1809
  return (tmp);
}
}
#line 1813 "/home/goblint2/bench/libpng-1.6.39/png.c"
static int is_ICC_signature(png_alloc_size_t it )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1816
  tmp = is_ICC_signature_char(it >> 24);
#line 1816
  if (tmp) {
#line 1816
    tmp___0 = is_ICC_signature_char((it >> 16) & 255UL);
#line 1816
    if (tmp___0) {
#line 1816
      tmp___1 = is_ICC_signature_char((it >> 8) & 255UL);
#line 1816
      if (tmp___1) {
#line 1816
        tmp___2 = is_ICC_signature_char(it & 255UL);
#line 1816
        if (tmp___2) {
#line 1816
          tmp___3 = 1;
        } else {
#line 1816
          tmp___3 = 0;
        }
      } else {
#line 1816
        tmp___3 = 0;
      }
    } else {
#line 1816
      tmp___3 = 0;
    }
  } else {
#line 1816
    tmp___3 = 0;
  }
#line 1816
  return (tmp___3);
}
}
#line 1822 "/home/goblint2/bench/libpng-1.6.39/png.c"
static int png_icc_profile_error(png_const_structrp png_ptr , png_colorspacerp colorspace ,
                                 png_const_charp name , png_alloc_size_t value , png_const_charp reason )
{
  size_t pos ;
  char message[196] ;
  size_t tmp ;
  size_t tmp___0 ;
  char number[24] ;
  png_charp tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1829
  if ((unsigned long )colorspace != (unsigned long )((void *)0)) {
#line 1830
    colorspace->flags = (png_uint_16 )((int )colorspace->flags | 0x8000);
  }
#line 1832
  pos = png_safecat(message, sizeof(message), (size_t )0, (png_const_charp )"profile \'");
#line 1833
  pos = png_safecat(message, pos + 79UL, pos, name);
#line 1834
  pos = png_safecat(message, sizeof(message), pos, (png_const_charp )"\': ");
#line 1835
  tmp___2 = is_ICC_signature(value);
#line 1835
  if (tmp___2 != 0) {
#line 1838
    png_icc_tag_name(message + pos, (png_uint_32 )value);
#line 1839
    pos += 6UL;
#line 1840
    tmp = pos;
#line 1840
    pos ++;
#line 1840
    message[tmp] = (char )':';
#line 1841
    tmp___0 = pos;
#line 1841
    pos ++;
#line 1841
    message[tmp___0] = (char )' ';
  } else {
#line 1848
    tmp___1 = png_format_number((png_const_charp )(number), number + sizeof(number),
                                3, value);
#line 1848
    pos = png_safecat(message, sizeof(message), pos, (png_const_charp )tmp___1);
#line 1851
    pos = png_safecat(message, sizeof(message), pos, (png_const_charp )"h: ");
  }
#line 1855
  pos = png_safecat(message, sizeof(message), pos, reason);
#line 1863
  if ((unsigned long )colorspace != (unsigned long )((void *)0)) {
#line 1863
    tmp___3 = 2;
  } else {
#line 1863
    tmp___3 = 1;
  }
#line 1863
  png_chunk_report(png_ptr, (png_const_charp )(message), tmp___3);
#line 1866
  return (0);
}
}
#line 1887 "/home/goblint2/bench/libpng-1.6.39/png.c"
static struct png_XYZ  const  sRGB_XYZ  =
#line 1887
     {41239, 21264, 1933, 35758, 71517, 11919, 18048, 7219, 95053};
#line 1871 "/home/goblint2/bench/libpng-1.6.39/png.c"
int png_colorspace_set_sRGB(png_const_structrp png_ptr , png_colorspacerp colorspace ,
                            int intent )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1896
  if (((int )colorspace->flags & 0x8000) != 0) {
#line 1897
    return (0);
  }
#line 1908
  if (intent < 0) {
#line 1909
    tmp = png_icc_profile_error(png_ptr, colorspace, (png_const_charp )"sRGB", (png_alloc_size_t )intent,
                                (png_const_charp )"invalid sRGB rendering intent");
#line 1909
    return (tmp);
  } else
#line 1908
  if (intent >= 4) {
#line 1909
    tmp = png_icc_profile_error(png_ptr, colorspace, (png_const_charp )"sRGB", (png_alloc_size_t )intent,
                                (png_const_charp )"invalid sRGB rendering intent");
#line 1909
    return (tmp);
  }
#line 1912
  if (((int )colorspace->flags & 0x0004) != 0) {
#line 1912
    if ((int )colorspace->rendering_intent != intent) {
#line 1914
      tmp___0 = png_icc_profile_error(png_ptr, colorspace, (png_const_charp )"sRGB",
                                      (png_alloc_size_t )intent, (png_const_charp )"inconsistent rendering intents");
#line 1914
      return (tmp___0);
    }
  }
#line 1917
  if (((int )colorspace->flags & 0x0020) != 0) {
#line 1919
    png_benign_error(png_ptr, (png_const_charp )"duplicate sRGB information ignored");
#line 1920
    return (0);
  }
#line 1926
  if (((int )colorspace->flags & 0x0002) != 0) {
#line 1926
    tmp___1 = png_colorspace_endpoints_match(& sRGB_xy, (png_xy const   *)(& colorspace->end_points_xy),
                                             100);
#line 1926
    if (! tmp___1) {
#line 1929
      png_chunk_report(png_ptr, (png_const_charp )"cHRM chunk does not match sRGB",
                       2);
    }
  }
#line 1935
  png_colorspace_check_gamma(png_ptr, colorspace, 45455, 2);
#line 1939
  colorspace->rendering_intent = (png_uint_16 )intent;
#line 1940
  colorspace->flags = (png_uint_16 )((int )colorspace->flags | 0x0004);
#line 1943
  colorspace->end_points_xy = (png_xy )sRGB_xy;
#line 1944
  colorspace->end_points_XYZ = (png_XYZ )sRGB_XYZ;
#line 1945
  colorspace->flags = (png_uint_16 )((int )colorspace->flags | 66);
#line 1949
  colorspace->gamma = 45455;
#line 1950
  colorspace->flags = (png_uint_16 )((int )colorspace->flags | 0x0001);
#line 1953
  colorspace->flags = (png_uint_16 )((int )colorspace->flags | 160);
#line 1956
  return (1);
}
}
#line 1966 "/home/goblint2/bench/libpng-1.6.39/png.c"
static png_byte const   D50_nCIEXYZ[12]  =
#line 1966
  {      (png_byte const   )0x00,      (png_byte const   )0x00,      (png_byte const   )0xf6,      (png_byte const   )0xd6,
        (png_byte const   )0x00,      (png_byte const   )0x01,      (png_byte const   )0x00,      (png_byte const   )0x00,
        (png_byte const   )0x00,      (png_byte const   )0x00,      (png_byte const   )0xd3,      (png_byte const   )0x2d};
#line 1969 "/home/goblint2/bench/libpng-1.6.39/png.c"
static int icc_check_length(png_const_structrp png_ptr , png_colorspacerp colorspace ,
                            png_const_charp name , png_uint_32 profile_length )
{
  int tmp ;

  {
#line 1973
  if (profile_length < 132U) {
#line 1974
    tmp = png_icc_profile_error(png_ptr, colorspace, name, (png_alloc_size_t )profile_length,
                                (png_const_charp )"too short");
#line 1974
    return (tmp);
  }
#line 1976
  return (1);
}
}
#line 1980 "/home/goblint2/bench/libpng-1.6.39/png.c"
int png_icc_check_length(png_const_structrp png_ptr , png_colorspacerp colorspace ,
                         png_const_charp name , png_uint_32 profile_length )
{
  int tmp ;
  int tmp___0 ;

  {
#line 1984
  tmp___0 = icc_check_length(png_ptr, colorspace, name, profile_length);
#line 1984
  if (tmp___0) {
#line 1994
    if (png_ptr->user_chunk_malloc_max > 0UL) {
#line 1994
      if (png_ptr->user_chunk_malloc_max < (png_alloc_size_t )profile_length) {
#line 1996
        tmp = png_icc_profile_error(png_ptr, colorspace, name, (png_alloc_size_t )profile_length,
                                    (png_const_charp )"exceeds application limits");
#line 1996
        return (tmp);
      }
    }
  } else {
#line 1985
    return (0);
  }
#line 2009
  return (1);
}
}
#line 2013 "/home/goblint2/bench/libpng-1.6.39/png.c"
int png_icc_check_header(png_const_structrp png_ptr , png_colorspacerp colorspace ,
                         png_const_charp name , png_uint_32 profile_length , png_const_bytep profile ,
                         int color_type )
{
  png_uint_32 temp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 2025
  temp = ((((png_uint_32 )*profile << 24) + ((png_uint_32 )*(profile + 1) << 16)) + ((png_uint_32 )*(profile + 2) << 8)) + (png_uint_32 )*(profile + 3);
#line 2026
  if (temp != profile_length) {
#line 2027
    tmp = png_icc_profile_error(png_ptr, colorspace, name, (png_alloc_size_t )temp,
                                (png_const_charp )"length does not match profile");
#line 2027
    return (tmp);
  }
#line 2030
  temp = (png_uint_32 )*(profile + 8);
#line 2031
  if (temp > 3U) {
#line 2031
    if (profile_length & 3U) {
#line 2032
      tmp___0 = png_icc_profile_error(png_ptr, colorspace, name, (png_alloc_size_t )profile_length,
                                      (png_const_charp )"invalid length");
#line 2032
      return (tmp___0);
    }
  }
#line 2035
  temp = ((((png_uint_32 )*(profile + 128) << 24) + ((png_uint_32 )*((profile + 128) + 1) << 16)) + ((png_uint_32 )*((profile + 128) + 2) << 8)) + (png_uint_32 )*((profile + 128) + 3);
#line 2036
  if (temp > 357913930U) {
#line 2038
    tmp___1 = png_icc_profile_error(png_ptr, colorspace, name, (png_alloc_size_t )temp,
                                    (png_const_charp )"tag count too large");
#line 2038
    return (tmp___1);
  } else
#line 2036
  if (profile_length < 132U + 12U * temp) {
#line 2038
    tmp___1 = png_icc_profile_error(png_ptr, colorspace, name, (png_alloc_size_t )temp,
                                    (png_const_charp )"tag count too large");
#line 2038
    return (tmp___1);
  }
#line 2044
  temp = ((((png_uint_32 )*(profile + 64) << 24) + ((png_uint_32 )*((profile + 64) + 1) << 16)) + ((png_uint_32 )*((profile + 64) + 2) << 8)) + (png_uint_32 )*((profile + 64) + 3);
#line 2045
  if (temp >= 65535U) {
#line 2046
    tmp___2 = png_icc_profile_error(png_ptr, colorspace, name, (png_alloc_size_t )temp,
                                    (png_const_charp )"invalid rendering intent");
#line 2046
    return (tmp___2);
  }
#line 2052
  if (temp >= 4U) {
#line 2053
    png_icc_profile_error(png_ptr, (png_colorspacerp )((void *)0), name, (png_alloc_size_t )temp,
                          (png_const_charp )"intent outside defined range");
  }
#line 2068
  temp = ((((png_uint_32 )*(profile + 36) << 24) + ((png_uint_32 )*((profile + 36) + 1) << 16)) + ((png_uint_32 )*((profile + 36) + 2) << 8)) + (png_uint_32 )*((profile + 36) + 3);
#line 2069
  if (temp != 1633907568U) {
#line 2070
    tmp___3 = png_icc_profile_error(png_ptr, colorspace, name, (png_alloc_size_t )temp,
                                    (png_const_charp )"invalid signature");
#line 2070
    return (tmp___3);
  }
#line 2080
  tmp___4 = memcmp((void const   *)(profile + 68), (void const   *)(D50_nCIEXYZ),
                   (size_t )12);
#line 2080
  if (tmp___4 != 0) {
#line 2081
    png_icc_profile_error(png_ptr, (png_colorspacerp )((void *)0), name, (png_alloc_size_t )0,
                          (png_const_charp )"PCS illuminant is not D50");
  }
#line 2104
  temp = ((((png_uint_32 )*(profile + 16) << 24) + ((png_uint_32 )*((profile + 16) + 1) << 16)) + ((png_uint_32 )*((profile + 16) + 2) << 8)) + (png_uint_32 )*((profile + 16) + 3);
  {
#line 2107
  if (temp == 1380401696U) {
#line 2107
    goto case_1380401696;
  }
#line 2113
  if (temp == 1196573017U) {
#line 2113
    goto case_1196573017;
  }
#line 2119
  goto switch_default;
  case_1380401696: /* CIL Label */
#line 2108
  if ((color_type & 2) == 0) {
#line 2109
    tmp___5 = png_icc_profile_error(png_ptr, colorspace, name, (png_alloc_size_t )temp,
                                    (png_const_charp )"RGB color space not permitted on grayscale PNG");
#line 2109
    return (tmp___5);
  }
#line 2111
  goto switch_break;
  case_1196573017: /* CIL Label */
#line 2114
  if ((color_type & 2) != 0) {
#line 2115
    tmp___6 = png_icc_profile_error(png_ptr, colorspace, name, (png_alloc_size_t )temp,
                                    (png_const_charp )"Gray color space not permitted on RGB PNG");
#line 2115
    return (tmp___6);
  }
#line 2117
  goto switch_break;
  switch_default: /* CIL Label */
#line 2120
  tmp___7 = png_icc_profile_error(png_ptr, colorspace, name, (png_alloc_size_t )temp,
                                  (png_const_charp )"invalid ICC profile color space");
#line 2120
  return (tmp___7);
  switch_break: /* CIL Label */ ;
  }
#line 2133
  temp = ((((png_uint_32 )*(profile + 12) << 24) + ((png_uint_32 )*((profile + 12) + 1) << 16)) + ((png_uint_32 )*((profile + 12) + 2) << 8)) + (png_uint_32 )*((profile + 12) + 3);
  {
#line 2139
  if (temp == 1936744803U) {
#line 2139
    goto case_1936744803;
  }
#line 2139
  if (temp == 1886549106U) {
#line 2139
    goto case_1936744803;
  }
#line 2139
  if (temp == 1835955314U) {
#line 2139
    goto case_1936744803;
  }
#line 2139
  if (temp == 1935896178U) {
#line 2139
    goto case_1936744803;
  }
#line 2143
  if (temp == 1633842036U) {
#line 2143
    goto case_1633842036;
  }
#line 2148
  if (temp == 1818848875U) {
#line 2148
    goto case_1818848875;
  }
#line 2158
  if (temp == 1852662636U) {
#line 2158
    goto case_1852662636;
  }
#line 2167
  goto switch_default___0;
  case_1936744803: /* CIL Label */
  case_1886549106: /* CIL Label */
  case_1835955314: /* CIL Label */
  case_1935896178: /* CIL Label */
#line 2141
  goto switch_break___0;
  case_1633842036: /* CIL Label */
#line 2145
  tmp___8 = png_icc_profile_error(png_ptr, colorspace, name, (png_alloc_size_t )temp,
                                  (png_const_charp )"invalid embedded Abstract ICC profile");
#line 2145
  return (tmp___8);
  case_1818848875: /* CIL Label */
#line 2155
  tmp___9 = png_icc_profile_error(png_ptr, colorspace, name, (png_alloc_size_t )temp,
                                  (png_const_charp )"unexpected DeviceLink ICC profile class");
#line 2155
  return (tmp___9);
  case_1852662636: /* CIL Label */
#line 2163
  png_icc_profile_error(png_ptr, (png_colorspacerp )((void *)0), name, (png_alloc_size_t )temp,
                        (png_const_charp )"unexpected NamedColor ICC profile class");
#line 2165
  goto switch_break___0;
  switch_default___0: /* CIL Label */
#line 2173
  png_icc_profile_error(png_ptr, (png_colorspacerp )((void *)0), name, (png_alloc_size_t )temp,
                        (png_const_charp )"unrecognized ICC profile class");
#line 2175
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 2181
  temp = ((((png_uint_32 )*(profile + 20) << 24) + ((png_uint_32 )*((profile + 20) + 1) << 16)) + ((png_uint_32 )*((profile + 20) + 2) << 8)) + (png_uint_32 )*((profile + 20) + 3);
  {
#line 2185
  if (temp == 1281450528U) {
#line 2185
    goto case_1281450528;
  }
#line 2185
  if (temp == 1482250784U) {
#line 2185
    goto case_1281450528;
  }
#line 2188
  goto switch_default___1;
  case_1281450528: /* CIL Label */
  case_1482250784: /* CIL Label */
#line 2186
  goto switch_break___1;
  switch_default___1: /* CIL Label */
#line 2189
  tmp___10 = png_icc_profile_error(png_ptr, colorspace, name, (png_alloc_size_t )temp,
                                   (png_const_charp )"unexpected ICC PCS encoding");
#line 2189
  return (tmp___10);
  switch_break___1: /* CIL Label */ ;
  }
#line 2193
  return (1);
}
}
#line 2196 "/home/goblint2/bench/libpng-1.6.39/png.c"
int png_icc_check_tag_table(png_const_structrp png_ptr , png_colorspacerp colorspace ,
                            png_const_charp name , png_uint_32 profile_length , png_const_bytep profile )
{
  png_uint_32 tag_count ;
  png_uint_32 itag ;
  png_const_bytep tag ;
  png_uint_32 tag_id ;
  png_uint_32 tag_start ;
  png_uint_32 tag_length ;
  int tmp ;

  {
#line 2201
  tag_count = ((((png_uint_32 )*(profile + 128) << 24) + ((png_uint_32 )*((profile + 128) + 1) << 16)) + ((png_uint_32 )*((profile + 128) + 2) << 8)) + (png_uint_32 )*((profile + 128) + 3);
#line 2203
  tag = profile + 132;
#line 2208
  itag = (png_uint_32 )0;
  {
#line 2208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2208
    if (! (itag < tag_count)) {
#line 2208
      goto while_break;
    }
#line 2210
    tag_id = ((((png_uint_32 )*(tag + 0) << 24) + ((png_uint_32 )*((tag + 0) + 1) << 16)) + ((png_uint_32 )*((tag + 0) + 2) << 8)) + (png_uint_32 )*((tag + 0) + 3);
#line 2211
    tag_start = ((((png_uint_32 )*(tag + 4) << 24) + ((png_uint_32 )*((tag + 4) + 1) << 16)) + ((png_uint_32 )*((tag + 4) + 2) << 8)) + (png_uint_32 )*((tag + 4) + 3);
#line 2212
    tag_length = ((((png_uint_32 )*(tag + 8) << 24) + ((png_uint_32 )*((tag + 8) + 1) << 16)) + ((png_uint_32 )*((tag + 8) + 2) << 8)) + (png_uint_32 )*((tag + 8) + 3);
#line 2224
    if (tag_start > profile_length) {
#line 2225
      tmp = png_icc_profile_error(png_ptr, colorspace, name, (png_alloc_size_t )tag_id,
                                  (png_const_charp )"ICC profile tag outside profile");
#line 2225
      return (tmp);
    } else
#line 2224
    if (tag_length > profile_length - tag_start) {
#line 2225
      tmp = png_icc_profile_error(png_ptr, colorspace, name, (png_alloc_size_t )tag_id,
                                  (png_const_charp )"ICC profile tag outside profile");
#line 2225
      return (tmp);
    }
#line 2228
    if ((tag_start & 3U) != 0U) {
#line 2234
      png_icc_profile_error(png_ptr, (png_colorspacerp )((void *)0), name, (png_alloc_size_t )tag_id,
                            (png_const_charp )"ICC profile tag start not a multiple of 4");
    }
#line 2208
    itag ++;
#line 2208
    tag += 12;
  }
  while_break: /* CIL Label */ ;
  }
#line 2239
  return (1);
}
}
#line 2257 "/home/goblint2/bench/libpng-1.6.39/png.c"
static struct __anonstruct_png_sRGB_checks_880336243  const  png_sRGB_checks[7]  = {      {(png_uint_32 )0x0a3fd9f6,
      (png_uint_32 )0x3b8772b9, (png_uint_32 )3048, {(png_uint_32 )0x29f83dde, 0xaff255ae,
                                                     (png_uint_32 )0x7842fae4, 0xca83390d},
      (png_byte )1, (png_byte )0, (png_uint_16 )0},
        {(png_uint_32 )0x4909e5e1, (png_uint_32 )0x427ebb21, (png_uint_32 )3052, {0xc95bd637,
                                                                               0xe95d8a3b,
                                                                               (png_uint_32 )0x0df38f99,
                                                                               0xc1320389},
      (png_byte )1, (png_byte )0, (png_uint_16 )1},
        {0xfd2144a1, (png_uint_32 )0x306fd8ae, (png_uint_32 )60988, {0xfc663378, (png_uint_32 )0x37e2886b,
                                                                  0xfd72e983, 0x8228f1b8},
      (png_byte )1, (png_byte )0, (png_uint_16 )0},
        {(png_uint_32 )0x209c35d2, 0xbbef7812, (png_uint_32 )60960, {(png_uint_32 )0x34562abf,
                                                                  0x994ccd06, (png_uint_32 )0x6d2c5721,
                                                                  0xd0d68c5d}, (png_byte )1,
      (png_byte )0, (png_uint_16 )0},
        {0xa054d762, (png_uint_32 )0x5d5129ce, (png_uint_32 )3024, {(png_uint_32 )0x00000000,
                                                                 (png_uint_32 )0x00000000,
                                                                 (png_uint_32 )0x00000000,
                                                                 (png_uint_32 )0x00000000},
      (png_byte )0, (png_byte )0, (png_uint_16 )1},
        {0xf784f3fb, (png_uint_32 )0x182ea552, (png_uint_32 )3144, {(png_uint_32 )0x00000000,
                                                                 (png_uint_32 )0x00000000,
                                                                 (png_uint_32 )0x00000000,
                                                                 (png_uint_32 )0x00000000},
      (png_byte )0, (png_byte )1, (png_uint_16 )0},
        {(png_uint_32 )0x0398f3fc, 0xf29e526d, (png_uint_32 )3144, {(png_uint_32 )0x00000000,
                                                                 (png_uint_32 )0x00000000,
                                                                 (png_uint_32 )0x00000000,
                                                                 (png_uint_32 )0x00000000},
      (png_byte )0, (png_byte )1, (png_uint_16 )1}};
#line 2306 "/home/goblint2/bench/libpng-1.6.39/png.c"
static int png_compare_ICC_profile_with_sRGB(png_const_structrp png_ptr , png_const_bytep profile ,
                                             uLong adler )
{
  png_uint_32 length ;
  png_uint_32 intent ;
  uLong crc ;
  unsigned int i ;

  {
#line 2318
  length = (png_uint_32 )0;
#line 2319
  intent = (png_uint_32 )0x10000;
#line 2321
  crc = (uLong )0;
#line 2327
  if (((png_ptr->options >> 4) & 3U) == 3U) {
#line 2329
    return (0);
  }
#line 2332
  i = 0U;
  {
#line 2332
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2332
    if (! ((unsigned long )i < sizeof(png_sRGB_checks) / sizeof(png_sRGB_checks[0]))) {
#line 2332
      goto while_break;
    }
#line 2334
    if (((((png_uint_32 )*(profile + 84) << 24) + ((png_uint_32 )*((profile + 84) + 1) << 16)) + ((png_uint_32 )*((profile + 84) + 2) << 8)) + (png_uint_32 )*((profile + 84) + 3) == png_sRGB_checks[i].md5[0]) {
#line 2334
      if (((((png_uint_32 )*(profile + 88) << 24) + ((png_uint_32 )*((profile + 88) + 1) << 16)) + ((png_uint_32 )*((profile + 88) + 2) << 8)) + (png_uint_32 )*((profile + 88) + 3) == png_sRGB_checks[i].md5[1]) {
#line 2334
        if (((((png_uint_32 )*(profile + 92) << 24) + ((png_uint_32 )*((profile + 92) + 1) << 16)) + ((png_uint_32 )*((profile + 92) + 2) << 8)) + (png_uint_32 )*((profile + 92) + 3) == png_sRGB_checks[i].md5[2]) {
#line 2334
          if (((((png_uint_32 )*(profile + 96) << 24) + ((png_uint_32 )*((profile + 96) + 1) << 16)) + ((png_uint_32 )*((profile + 96) + 2) << 8)) + (png_uint_32 )*((profile + 96) + 3) == png_sRGB_checks[i].md5[3]) {
#line 2349
            if (length == 0U) {
#line 2351
              length = ((((png_uint_32 )*profile << 24) + ((png_uint_32 )*(profile + 1) << 16)) + ((png_uint_32 )*(profile + 2) << 8)) + (png_uint_32 )*(profile + 3);
#line 2352
              intent = ((((png_uint_32 )*(profile + 64) << 24) + ((png_uint_32 )*((profile + 64) + 1) << 16)) + ((png_uint_32 )*((profile + 64) + 2) << 8)) + (png_uint_32 )*((profile + 64) + 3);
            }
#line 2356
            if (length == (png_uint_32 )png_sRGB_checks[i].length) {
#line 2356
              if (intent == (png_uint_32 )png_sRGB_checks[i].intent) {
#line 2360
                if (adler == 0UL) {
#line 2362
                  adler = adler32((uLong )0, (Bytef const   *)((void *)0), (uInt )0);
#line 2363
                  adler = adler32(adler, profile, length);
                }
#line 2366
                if (adler == (uLong )png_sRGB_checks[i].adler) {
#line 2373
                  if (crc == 0UL) {
#line 2375
                    crc = crc32((uLong )0, (Bytef const   *)((void *)0), (uInt )0);
#line 2376
                    crc = crc32(crc, profile, length);
                  }
#line 2381
                  if (crc == (uLong )png_sRGB_checks[i].crc) {
#line 2384
                    if ((int )png_sRGB_checks[i].is_broken != 0) {
#line 2391
                      png_chunk_report(png_ptr, (png_const_charp )"known incorrect sRGB profile",
                                       2);
                    } else
#line 2399
                    if ((int )png_sRGB_checks[i].have_md5 == 0) {
#line 2401
                      png_chunk_report(png_ptr, (png_const_charp )"out-of-date sRGB profile with no signature",
                                       0);
                    }
#line 2406
                    return (1 + (int )png_sRGB_checks[i].is_broken);
                  }
                }
#line 2415
                png_chunk_report(png_ptr, (png_const_charp )"Not recognizing known sRGB profile that has been edited",
                                 0);
#line 2418
                goto while_break;
              }
            }
          }
        }
      }
    }
#line 2332
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2424
  return (0);
}
}
#line 2427 "/home/goblint2/bench/libpng-1.6.39/png.c"
void png_icc_set_sRGB(png_const_structrp png_ptr , png_colorspacerp colorspace , png_const_bytep profile ,
                      uLong adler )
{
  int tmp ;

  {
#line 2434
  tmp = png_compare_ICC_profile_with_sRGB(png_ptr, profile, adler);
#line 2434
  if (tmp != 0) {
#line 2435
    png_colorspace_set_sRGB(png_ptr, colorspace, (int )(((((png_uint_32 )*(profile + 64) << 24) + ((png_uint_32 )*((profile + 64) + 1) << 16)) + ((png_uint_32 )*((profile + 64) + 2) << 8)) + (png_uint_32 )*((profile + 64) + 3)));
  }
#line 2437
  return;
}
}
#line 2441 "/home/goblint2/bench/libpng-1.6.39/png.c"
int png_colorspace_set_ICC(png_const_structrp png_ptr , png_colorspacerp colorspace ,
                           png_const_charp name , png_uint_32 profile_length , png_const_bytep profile ,
                           int color_type )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2446
  if (((int )colorspace->flags & 0x8000) != 0) {
#line 2447
    return (0);
  }
#line 2449
  tmp = icc_check_length(png_ptr, colorspace, name, profile_length);
#line 2449
  if (tmp != 0) {
#line 2449
    tmp___0 = png_icc_check_header(png_ptr, colorspace, name, profile_length, profile,
                                   color_type);
#line 2449
    if (tmp___0 != 0) {
#line 2449
      tmp___1 = png_icc_check_tag_table(png_ptr, colorspace, name, profile_length,
                                        profile);
#line 2449
      if (tmp___1 != 0) {
#line 2457
        png_icc_set_sRGB(png_ptr, colorspace, profile, (uLong )0);
#line 2459
        return (1);
      }
    }
  }
#line 2463
  return (0);
}
}
#line 2468 "/home/goblint2/bench/libpng-1.6.39/png.c"
void png_colorspace_set_rgb_coefficients(png_structrp png_ptr )
{
  png_fixed_point r ;
  png_fixed_point g ;
  png_fixed_point b ;
  png_fixed_point total ;
  int add ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2472
  if ((int )png_ptr->rgb_to_gray_coefficients_set == 0) {
#line 2472
    if (((int )png_ptr->colorspace.flags & 0x0002) != 0) {
#line 2478
      r = png_ptr->colorspace.end_points_XYZ.red_Y;
#line 2479
      g = png_ptr->colorspace.end_points_XYZ.green_Y;
#line 2480
      b = png_ptr->colorspace.end_points_XYZ.blue_Y;
#line 2481
      total = (r + g) + b;
#line 2483
      if (total > 0) {
#line 2483
        if (r >= 0) {
#line 2483
          tmp = png_muldiv(& r, r, 32768, total);
#line 2483
          if (tmp) {
#line 2483
            if (r >= 0) {
#line 2483
              if (r <= 32768) {
#line 2483
                if (g >= 0) {
#line 2483
                  tmp___0 = png_muldiv(& g, g, 32768, total);
#line 2483
                  if (tmp___0) {
#line 2483
                    if (g >= 0) {
#line 2483
                      if (g <= 32768) {
#line 2483
                        if (b >= 0) {
#line 2483
                          tmp___1 = png_muldiv(& b, b, 32768, total);
#line 2483
                          if (tmp___1) {
#line 2483
                            if (b >= 0) {
#line 2483
                              if (b <= 32768) {
#line 2483
                                if ((r + g) + b <= 32769) {
#line 2494
                                  add = 0;
#line 2496
                                  if ((r + g) + b > 32768) {
#line 2497
                                    add = -1;
                                  } else
#line 2498
                                  if ((r + g) + b < 32768) {
#line 2499
                                    add = 1;
                                  }
#line 2501
                                  if (add != 0) {
#line 2503
                                    if (g >= r) {
#line 2503
                                      if (g >= b) {
#line 2504
                                        g += add;
                                      } else {
#line 2503
                                        goto _L;
                                      }
                                    } else
                                    _L: /* CIL Label */
#line 2505
                                    if (r >= g) {
#line 2505
                                      if (r >= b) {
#line 2506
                                        r += add;
                                      } else {
#line 2508
                                        b += add;
                                      }
                                    } else {
#line 2508
                                      b += add;
                                    }
                                  }
#line 2512
                                  if ((r + g) + b != 32768) {
#line 2513
                                    png_error((png_const_structrp )png_ptr, (png_const_charp )"internal error handling cHRM coefficients");
                                  } else {
#line 2518
                                    png_ptr->rgb_to_gray_red_coeff = (png_uint_16 )r;
#line 2519
                                    png_ptr->rgb_to_gray_green_coeff = (png_uint_16 )g;
                                  }
                                } else {
#line 2528
                                  png_error((png_const_structrp )png_ptr, (png_const_charp )"internal error handling cHRM->XYZ");
                                }
                              } else {
#line 2528
                                png_error((png_const_structrp )png_ptr, (png_const_charp )"internal error handling cHRM->XYZ");
                              }
                            } else {
#line 2528
                              png_error((png_const_structrp )png_ptr, (png_const_charp )"internal error handling cHRM->XYZ");
                            }
                          } else {
#line 2528
                            png_error((png_const_structrp )png_ptr, (png_const_charp )"internal error handling cHRM->XYZ");
                          }
                        } else {
#line 2528
                          png_error((png_const_structrp )png_ptr, (png_const_charp )"internal error handling cHRM->XYZ");
                        }
                      } else {
#line 2528
                        png_error((png_const_structrp )png_ptr, (png_const_charp )"internal error handling cHRM->XYZ");
                      }
                    } else {
#line 2528
                      png_error((png_const_structrp )png_ptr, (png_const_charp )"internal error handling cHRM->XYZ");
                    }
                  } else {
#line 2528
                    png_error((png_const_structrp )png_ptr, (png_const_charp )"internal error handling cHRM->XYZ");
                  }
                } else {
#line 2528
                  png_error((png_const_structrp )png_ptr, (png_const_charp )"internal error handling cHRM->XYZ");
                }
              } else {
#line 2528
                png_error((png_const_structrp )png_ptr, (png_const_charp )"internal error handling cHRM->XYZ");
              }
            } else {
#line 2528
              png_error((png_const_structrp )png_ptr, (png_const_charp )"internal error handling cHRM->XYZ");
            }
          } else {
#line 2528
            png_error((png_const_structrp )png_ptr, (png_const_charp )"internal error handling cHRM->XYZ");
          }
        } else {
#line 2528
          png_error((png_const_structrp )png_ptr, (png_const_charp )"internal error handling cHRM->XYZ");
        }
      } else {
#line 2528
        png_error((png_const_structrp )png_ptr, (png_const_charp )"internal error handling cHRM->XYZ");
      }
    }
  }
#line 2530
  return;
}
}
#line 2537 "/home/goblint2/bench/libpng-1.6.39/png.c"
static int png_gt(size_t a , size_t b )
{


  {
#line 2540
  return (a > b);
}
}
#line 2546 "/home/goblint2/bench/libpng-1.6.39/png.c"
void png_check_IHDR(png_const_structrp png_ptr , png_uint_32 width , png_uint_32 height ,
                    int bit_depth , int color_type , int interlace_type , int compression_type ,
                    int filter_type )
{
  int error___0 ;
  int tmp ;

  {
#line 2552
  error___0 = 0;
#line 2555
  if (width == 0U) {
#line 2557
    png_warning(png_ptr, (png_const_charp )"Image width is zero in IHDR");
#line 2558
    error___0 = 1;
  }
#line 2561
  if (width > 2147483647U) {
#line 2563
    png_warning(png_ptr, (png_const_charp )"Invalid image width in IHDR");
#line 2564
    error___0 = 1;
  }
#line 2567
  tmp = png_gt((size_t )((width + 7U) & 4294967288U), 2305843009213693944UL);
#line 2567
  if (tmp) {
#line 2585
    png_warning(png_ptr, (png_const_charp )"Image width is too large for this architecture");
#line 2586
    error___0 = 1;
  }
#line 2590
  if (width > (png_uint_32 )png_ptr->user_width_max) {
#line 2595
    png_warning(png_ptr, (png_const_charp )"Image width exceeds user limit in IHDR");
#line 2596
    error___0 = 1;
  }
#line 2599
  if (height == 0U) {
#line 2601
    png_warning(png_ptr, (png_const_charp )"Image height is zero in IHDR");
#line 2602
    error___0 = 1;
  }
#line 2605
  if (height > 2147483647U) {
#line 2607
    png_warning(png_ptr, (png_const_charp )"Invalid image height in IHDR");
#line 2608
    error___0 = 1;
  }
#line 2612
  if (height > (png_uint_32 )png_ptr->user_height_max) {
#line 2617
    png_warning(png_ptr, (png_const_charp )"Image height exceeds user limit in IHDR");
#line 2618
    error___0 = 1;
  }
#line 2622
  if (bit_depth != 1) {
#line 2622
    if (bit_depth != 2) {
#line 2622
      if (bit_depth != 4) {
#line 2622
        if (bit_depth != 8) {
#line 2622
          if (bit_depth != 16) {
#line 2625
            png_warning(png_ptr, (png_const_charp )"Invalid bit depth in IHDR");
#line 2626
            error___0 = 1;
          }
        }
      }
    }
  }
#line 2629
  if (color_type < 0) {
#line 2632
    png_warning(png_ptr, (png_const_charp )"Invalid color type in IHDR");
#line 2633
    error___0 = 1;
  } else
#line 2629
  if (color_type == 1) {
#line 2632
    png_warning(png_ptr, (png_const_charp )"Invalid color type in IHDR");
#line 2633
    error___0 = 1;
  } else
#line 2629
  if (color_type == 5) {
#line 2632
    png_warning(png_ptr, (png_const_charp )"Invalid color type in IHDR");
#line 2633
    error___0 = 1;
  } else
#line 2629
  if (color_type > 6) {
#line 2632
    png_warning(png_ptr, (png_const_charp )"Invalid color type in IHDR");
#line 2633
    error___0 = 1;
  }
#line 2636
  if (color_type == 3) {
#line 2636
    if (bit_depth > 8) {
#line 2641
      png_warning(png_ptr, (png_const_charp )"Invalid color type/bit depth combination in IHDR");
#line 2642
      error___0 = 1;
    } else {
#line 2636
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */
#line 2636
  if (color_type == 2) {
#line 2636
    goto _L;
  } else
#line 2636
  if (color_type == 4) {
#line 2636
    goto _L;
  } else
#line 2636
  if (color_type == 6) {
    _L: /* CIL Label */
#line 2636
    if (bit_depth < 8) {
#line 2641
      png_warning(png_ptr, (png_const_charp )"Invalid color type/bit depth combination in IHDR");
#line 2642
      error___0 = 1;
    }
  }
#line 2645
  if (interlace_type >= 2) {
#line 2647
    png_warning(png_ptr, (png_const_charp )"Unknown interlace method in IHDR");
#line 2648
    error___0 = 1;
  }
#line 2651
  if (compression_type != 0) {
#line 2653
    png_warning(png_ptr, (png_const_charp )"Unknown compression method in IHDR");
#line 2654
    error___0 = 1;
  }
#line 2667
  if ((png_ptr->mode & 4096U) != 0U) {
#line 2667
    if (png_ptr->mng_features_permitted != 0U) {
#line 2669
      png_warning(png_ptr, (png_const_charp )"MNG features are not allowed in a PNG datastream");
    }
  }
#line 2671
  if (filter_type != 0) {
#line 2673
    if ((png_ptr->mng_features_permitted & 4U) != 0U) {
#line 2673
      if (filter_type == 64) {
#line 2673
        if ((png_ptr->mode & 4096U) == 0U) {
#line 2673
          if (! (color_type == 2)) {
#line 2673
            if (! (color_type == 6)) {
#line 2679
              png_warning(png_ptr, (png_const_charp )"Unknown filter method in IHDR");
#line 2680
              error___0 = 1;
            }
          }
        } else {
#line 2679
          png_warning(png_ptr, (png_const_charp )"Unknown filter method in IHDR");
#line 2680
          error___0 = 1;
        }
      } else {
#line 2679
        png_warning(png_ptr, (png_const_charp )"Unknown filter method in IHDR");
#line 2680
        error___0 = 1;
      }
    } else {
#line 2679
      png_warning(png_ptr, (png_const_charp )"Unknown filter method in IHDR");
#line 2680
      error___0 = 1;
    }
#line 2683
    if ((png_ptr->mode & 4096U) != 0U) {
#line 2685
      png_warning(png_ptr, (png_const_charp )"Invalid filter method in IHDR");
#line 2686
      error___0 = 1;
    }
  }
#line 2698
  if (error___0 == 1) {
#line 2699
    png_error(png_ptr, (png_const_charp )"Invalid IHDR data");
  }
#line 2700
  return;
}
}
#line 2711 "/home/goblint2/bench/libpng-1.6.39/png.c"
int png_check_fp_number(png_const_charp string , size_t size , int *statep , size_t *whereami )
{
  int state ;
  size_t i ;
  int type ;

  {
#line 2715
  state = *statep;
#line 2716
  i = *whereami;
  {
#line 2718
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2718
    if (! (i < size)) {
#line 2718
      goto while_break;
    }
    {
#line 2724
    if ((int const   )*(string + i) == 43) {
#line 2724
      goto case_43;
    }
#line 2725
    if ((int const   )*(string + i) == 45) {
#line 2725
      goto case_45;
    }
#line 2726
    if ((int const   )*(string + i) == 46) {
#line 2726
      goto case_46;
    }
#line 2727
    if ((int const   )*(string + i) == 48) {
#line 2727
      goto case_48;
    }
#line 2730
    if ((int const   )*(string + i) == 57) {
#line 2730
      goto case_57;
    }
#line 2730
    if ((int const   )*(string + i) == 56) {
#line 2730
      goto case_57;
    }
#line 2730
    if ((int const   )*(string + i) == 55) {
#line 2730
      goto case_57;
    }
#line 2730
    if ((int const   )*(string + i) == 54) {
#line 2730
      goto case_57;
    }
#line 2730
    if ((int const   )*(string + i) == 53) {
#line 2730
      goto case_57;
    }
#line 2730
    if ((int const   )*(string + i) == 52) {
#line 2730
      goto case_57;
    }
#line 2730
    if ((int const   )*(string + i) == 51) {
#line 2730
      goto case_57;
    }
#line 2730
    if ((int const   )*(string + i) == 50) {
#line 2730
      goto case_57;
    }
#line 2730
    if ((int const   )*(string + i) == 49) {
#line 2730
      goto case_57;
    }
#line 2732
    if ((int const   )*(string + i) == 101) {
#line 2732
      goto case_101;
    }
#line 2732
    if ((int const   )*(string + i) == 69) {
#line 2732
      goto case_101;
    }
#line 2733
    goto switch_default;
    case_43: /* CIL Label */
#line 2724
    type = 4;
#line 2724
    goto switch_break;
    case_45: /* CIL Label */
#line 2725
    type = 132;
#line 2725
    goto switch_break;
    case_46: /* CIL Label */
#line 2726
    type = 16;
#line 2726
    goto switch_break;
    case_48: /* CIL Label */
#line 2727
    type = 8;
#line 2727
    goto switch_break;
    case_57: /* CIL Label */
    case_56: /* CIL Label */
    case_55: /* CIL Label */
    case_54: /* CIL Label */
    case_53: /* CIL Label */
    case_52: /* CIL Label */
    case_51: /* CIL Label */
    case_50: /* CIL Label */
    case_49: /* CIL Label */
#line 2730
    type = 264;
#line 2730
    goto switch_break;
    case_101: /* CIL Label */
    case_69: /* CIL Label */
#line 2732
    type = 32;
#line 2732
    goto switch_break;
    switch_default: /* CIL Label */
#line 2733
    goto PNG_FP_End;
    switch_break: /* CIL Label */ ;
    }
    {
#line 2742
    if ((state & 3) + (type & 60) == 4) {
#line 2742
      goto case_4;
    }
#line 2749
    if ((state & 3) + (type & 60) == 16) {
#line 2749
      goto case_16;
    }
#line 2762
    if ((state & 3) + (type & 60) == 8) {
#line 2762
      goto case_8;
    }
#line 2770
    if ((state & 3) + (type & 60) == 32) {
#line 2770
      goto case_32;
    }
#line 2784
    if ((state & 3) + (type & 60) == 9) {
#line 2784
      goto case_9;
    }
#line 2788
    if ((state & 3) + (type & 60) == 33) {
#line 2788
      goto case_33;
    }
#line 2800
    if ((state & 3) + (type & 60) == 6) {
#line 2800
      goto case_6;
    }
#line 2811
    if ((state & 3) + (type & 60) == 10) {
#line 2811
      goto case_10;
    }
#line 2819
    goto switch_default___0;
    case_4: /* CIL Label */
#line 2743
    if ((state & 60) != 0) {
#line 2744
      goto PNG_FP_End;
    }
#line 2746
    state |= type;
#line 2747
    goto switch_break___0;
    case_16: /* CIL Label */
#line 2751
    if ((state & 16) != 0) {
#line 2752
      goto PNG_FP_End;
    } else
#line 2754
    if ((state & 8) != 0) {
#line 2755
      state |= type;
    } else {
#line 2758
      state = (1 | type) | (state & 448);
    }
#line 2760
    goto switch_break___0;
    case_8: /* CIL Label */
#line 2763
    if ((state & 16) != 0) {
#line 2764
      state = 17 | (state & 448);
    }
#line 2766
    state |= type | 64;
#line 2768
    goto switch_break___0;
    case_32: /* CIL Label */
#line 2771
    if ((state & 8) == 0) {
#line 2772
      goto PNG_FP_End;
    }
#line 2774
    state = 2 | (state & 448);
#line 2776
    goto switch_break___0;
    case_9: /* CIL Label */
#line 2785
    state |= type | 64;
#line 2786
    goto switch_break___0;
    case_33: /* CIL Label */
#line 2793
    if ((state & 8) == 0) {
#line 2794
      goto PNG_FP_End;
    }
#line 2796
    state = 2 | (state & 448);
#line 2798
    goto switch_break___0;
    case_6: /* CIL Label */
#line 2801
    if ((state & 60) != 0) {
#line 2802
      goto PNG_FP_End;
    }
#line 2804
    state |= 4;
#line 2806
    goto switch_break___0;
    case_10: /* CIL Label */
#line 2812
    state |= 72;
#line 2814
    goto switch_break___0;
    switch_default___0: /* CIL Label */
#line 2819
    goto PNG_FP_End;
    switch_break___0: /* CIL Label */ ;
    }
#line 2823
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  PNG_FP_End:
#line 2830
  *statep = state;
#line 2831
  *whereami = i;
#line 2833
  return ((state & 8) != 0);
}
}
#line 2838 "/home/goblint2/bench/libpng-1.6.39/png.c"
int png_check_fp_string(png_const_charp string , size_t size )
{
  int state ;
  size_t char_index ;
  int tmp ;

  {
#line 2841
  state = 0;
#line 2842
  char_index = (size_t )0;
#line 2844
  tmp = png_check_fp_number(string, size, & state, & char_index);
#line 2844
  if (tmp != 0) {
#line 2844
    if (char_index == size) {
#line 2846
      return (state);
    } else
#line 2844
    if ((int const   )*(string + char_index) == 0) {
#line 2846
      return (state);
    }
  }
#line 2848
  return (0);
}
}
#line 2857 "/home/goblint2/bench/libpng-1.6.39/png.c"
static double png_pow10(int power )
{
  int recip ;
  double d ;
  double mult ;

  {
#line 2860
  recip = 0;
#line 2861
  d = (double )1;
#line 2866
  if (power < 0) {
#line 2868
    if (power < -307) {
#line 2868
      return ((double )0);
    }
#line 2869
    recip = 1;
#line 2869
    power = - power;
  }
#line 2872
  if (power > 0) {
#line 2875
    mult = (double )10;
    {
#line 2876
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2878
      if (power & 1) {
#line 2878
        d *= mult;
      }
#line 2879
      mult *= mult;
#line 2880
      power >>= 1;
#line 2876
      if (! (power > 0)) {
#line 2876
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 2884
    if (recip != 0) {
#line 2884
      d = (double )1 / d;
    }
  }
#line 2888
  return (d);
}
}
#line 2902 "/home/goblint2/bench/libpng-1.6.39/png.c"
void png_ascii_from_fp(png_const_structrp png_ptr , png_charp ascii , size_t size ,
                       double fp , unsigned int precision )
{
  png_charp tmp ;
  int exp_b10 ;
  double base ;
  double test ;
  double tmp___0 ;
  unsigned int czero ;
  unsigned int clead ;
  unsigned int cdigits ;
  char exponent[10] ;
  double d ;
  int ch ;
  int ch___0 ;
  png_charp tmp___1 ;
  png_charp tmp___2 ;
  png_charp tmp___3 ;
  png_charp tmp___4 ;
  png_charp tmp___5 ;
  int tmp___6 ;
  png_charp tmp___7 ;
  unsigned int uexp_b10 ;
  png_charp tmp___8 ;
  unsigned int tmp___9 ;
  png_charp tmp___10 ;
  png_charp tmp___11 ;
  png_charp tmp___12 ;
  png_charp tmp___13 ;
  png_charp tmp___14 ;

  {
#line 2911
  if (precision < 1U) {
#line 2912
    precision = 15U;
  }
#line 2915
  if (precision > 16U) {
#line 2916
    precision = 16U;
  }
#line 2919
  if (size >= (size_t )(precision + 5U)) {
#line 2921
    if (fp < (double )0) {
#line 2923
      fp = - fp;
#line 2924
      tmp = ascii;
#line 2924
      ascii ++;
#line 2924
      *tmp = (char)45;
#line 2925
      size --;
    }
#line 2928
    if (fp >= (double )2.22507385850720138309023271733240406e-308L) {
#line 2928
      if (fp <= (double )1.79769313486231570814527423731704357e+308L) {
#line 2942
        frexp(fp, & exp_b10);
#line 2944
        exp_b10 = exp_b10 * 77 >> 8;
#line 2947
        base = png_pow10(exp_b10);
        {
#line 2949
        while (1) {
          while_continue: /* CIL Label */ ;
#line 2949
          if (! (base < (double )2.22507385850720138309023271733240406e-308L)) {
#line 2949
            if (! (base < fp)) {
#line 2949
              goto while_break;
            }
          }
#line 2952
          tmp___0 = png_pow10(exp_b10 + 1);
#line 2952
          test = tmp___0;
#line 2954
          if (test <= (double )1.79769313486231570814527423731704357e+308L) {
#line 2956
            exp_b10 ++;
#line 2956
            base = test;
          } else {
#line 2960
            goto while_break;
          }
        }
        while_break: /* CIL Label */ ;
        }
#line 2970
        fp /= base;
        {
#line 2971
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2971
          if (! (fp >= (double )1)) {
#line 2971
            goto while_break___0;
          }
#line 2973
          fp /= (double )10;
#line 2973
          exp_b10 ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 2989
        if (exp_b10 < 0) {
#line 2989
          if (exp_b10 > -3) {
#line 2991
            czero = 0U - (unsigned int )exp_b10;
#line 2992
            exp_b10 = 0;
          } else {
#line 2995
            czero = 0U;
          }
        } else {
#line 2995
          czero = 0U;
        }
#line 3000
        clead = czero;
#line 3001
        cdigits = 0U;
        {
#line 3003
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 3007
          fp *= (double )10;
#line 3013
          if ((cdigits + czero) + 1U < precision + clead) {
#line 3014
            fp = modf(fp, & d);
          } else {
#line 3018
            d = floor(fp + .5);
#line 3020
            if (d > (double )9) {
#line 3023
              if (czero > 0U) {
#line 3025
                czero --;
#line 3025
                d = (double )1;
#line 3026
                if (cdigits == 0U) {
#line 3026
                  clead --;
                }
              } else {
                {
#line 3030
                while (1) {
                  while_continue___2: /* CIL Label */ ;
#line 3030
                  if (cdigits > 0U) {
#line 3030
                    if (! (d > (double )9)) {
#line 3030
                      goto while_break___2;
                    }
                  } else {
#line 3030
                    goto while_break___2;
                  }
#line 3032
                  ascii --;
#line 3032
                  ch = (int )*ascii;
#line 3034
                  if (exp_b10 != -1) {
#line 3035
                    exp_b10 ++;
                  } else
#line 3037
                  if (ch == 46) {
#line 3039
                    ascii --;
#line 3039
                    ch = (int )*ascii;
#line 3039
                    size ++;
#line 3044
                    exp_b10 = 1;
                  }
#line 3047
                  cdigits --;
#line 3048
                  d = (double )(ch - 47);
                }
                while_break___2: /* CIL Label */ ;
                }
#line 3055
                if (d > (double )9) {
#line 3057
                  if (exp_b10 == -1) {
#line 3063
                    ascii --;
#line 3063
                    ch___0 = (int )*ascii;
#line 3065
                    if (ch___0 == 46) {
#line 3067
                      size ++;
#line 3067
                      exp_b10 = 1;
                    }
                  } else {
#line 3075
                    exp_b10 ++;
                  }
#line 3078
                  d = (double )1;
                }
              }
            }
#line 3082
            fp = (double )0;
          }
#line 3085
          if (d == (double )0) {
#line 3087
            czero ++;
#line 3088
            if (cdigits == 0U) {
#line 3088
              clead ++;
            }
          } else {
#line 3093
            cdigits += czero - clead;
#line 3094
            clead = 0U;
            {
#line 3096
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 3096
              if (! (czero > 0U)) {
#line 3096
                goto while_break___3;
              }
#line 3102
              if (exp_b10 != -1) {
#line 3104
                if (exp_b10 == 0) {
#line 3106
                  tmp___1 = ascii;
#line 3106
                  ascii ++;
#line 3106
                  *tmp___1 = (char)46;
#line 3106
                  size --;
                }
#line 3109
                exp_b10 --;
              }
#line 3111
              tmp___2 = ascii;
#line 3111
              ascii ++;
#line 3111
              *tmp___2 = (char)48;
#line 3111
              czero --;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 3114
            if (exp_b10 != -1) {
#line 3116
              if (exp_b10 == 0) {
#line 3118
                tmp___3 = ascii;
#line 3118
                ascii ++;
#line 3118
                *tmp___3 = (char)46;
#line 3118
                size --;
              }
#line 3121
              exp_b10 --;
            }
#line 3123
            tmp___4 = ascii;
#line 3123
            ascii ++;
#line 3123
            *tmp___4 = (char )(48 + (int )d);
#line 3123
            cdigits ++;
          }
#line 3003
          if (cdigits + czero < precision + clead) {
#line 3003
            if (! (fp > (double )2.22507385850720138309023271733240406e-308L)) {
#line 3003
              goto while_break___1;
            }
          } else {
#line 3003
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 3137
        if (exp_b10 >= -1) {
#line 3137
          if (exp_b10 <= 2) {
            {
#line 3146
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 3146
              tmp___6 = exp_b10;
#line 3146
              exp_b10 --;
#line 3146
              if (! (tmp___6 > 0)) {
#line 3146
                goto while_break___4;
              }
#line 3146
              tmp___5 = ascii;
#line 3146
              ascii ++;
#line 3146
              *tmp___5 = (char)48;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 3148
            *ascii = (char)0;
#line 3153
            return;
          }
        }
#line 3162
        size -= (size_t )cdigits;
#line 3164
        tmp___7 = ascii;
#line 3164
        ascii ++;
#line 3164
        *tmp___7 = (char)69;
#line 3164
        size --;
#line 3173
        if (exp_b10 < 0) {
#line 3175
          tmp___8 = ascii;
#line 3175
          ascii ++;
#line 3175
          *tmp___8 = (char)45;
#line 3175
          size --;
#line 3176
          uexp_b10 = 0U - (unsigned int )exp_b10;
        } else {
#line 3180
          uexp_b10 = (unsigned int )exp_b10;
        }
#line 3182
        cdigits = 0U;
        {
#line 3184
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 3184
          if (! (uexp_b10 > 0U)) {
#line 3184
            goto while_break___5;
          }
#line 3186
          tmp___9 = cdigits;
#line 3186
          cdigits ++;
#line 3186
          exponent[tmp___9] = (char )(48U + uexp_b10 % 10U);
#line 3187
          uexp_b10 /= 10U;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 3194
        if (size > (size_t )cdigits) {
          {
#line 3196
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 3196
            if (! (cdigits > 0U)) {
#line 3196
              goto while_break___6;
            }
#line 3196
            tmp___10 = ascii;
#line 3196
            ascii ++;
#line 3196
            cdigits --;
#line 3196
            *tmp___10 = exponent[cdigits];
          }
          while_break___6: /* CIL Label */ ;
          }
#line 3198
          *ascii = (char)0;
#line 3200
          return;
        }
      } else {
#line 2928
        goto _L;
      }
    } else
    _L: /* CIL Label */
#line 3204
    if (! (fp >= (double )2.22507385850720138309023271733240406e-308L)) {
#line 3206
      tmp___11 = ascii;
#line 3206
      ascii ++;
#line 3206
      *tmp___11 = (char)48;
#line 3207
      *ascii = (char)0;
#line 3208
      return;
    } else {
#line 3212
      tmp___12 = ascii;
#line 3212
      ascii ++;
#line 3212
      *tmp___12 = (char)105;
#line 3213
      tmp___13 = ascii;
#line 3213
      ascii ++;
#line 3213
      *tmp___13 = (char)110;
#line 3214
      tmp___14 = ascii;
#line 3214
      ascii ++;
#line 3214
      *tmp___14 = (char)102;
#line 3215
      *ascii = (char)0;
#line 3216
      return;
    }
  }
#line 3221
  png_error(png_ptr, (png_const_charp )"ASCII conversion buffer too small");
}
}
#line 3232 "/home/goblint2/bench/libpng-1.6.39/png.c"
void png_ascii_from_fixed(png_const_structrp png_ptr , png_charp ascii , size_t size ,
                          png_fixed_point fp )
{
  png_uint_32 num ;
  png_charp tmp ;
  unsigned int ndigits ;
  unsigned int first ;
  char digits___0[10] ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  png_charp tmp___2 ;
  unsigned int i ;
  png_charp tmp___3 ;
  png_charp tmp___4 ;
  png_charp tmp___5 ;
  png_charp tmp___6 ;

  {
#line 3239
  if (size > 12UL) {
#line 3244
    if (fp < 0) {
#line 3246
      tmp = ascii;
#line 3246
      ascii ++;
#line 3246
      *tmp = (char)45;
#line 3246
      num = (png_uint_32 )(- fp);
    } else {
#line 3249
      num = (png_uint_32 )fp;
    }
#line 3251
    if (num <= 0x80000000) {
#line 3253
      ndigits = 0U;
#line 3253
      first = 16U;
      {
#line 3256
      while (1) {
        while_continue: /* CIL Label */ ;
#line 3256
        if (! num) {
#line 3256
          goto while_break;
        }
#line 3259
        tmp___0 = num / 10U;
#line 3260
        num -= tmp___0 * 10U;
#line 3261
        tmp___1 = ndigits;
#line 3261
        ndigits ++;
#line 3261
        digits___0[tmp___1] = (char )(48U + num);
#line 3265
        if (first == 16U) {
#line 3265
          if (num > 0U) {
#line 3266
            first = ndigits;
          }
        }
#line 3267
        num = tmp___0;
      }
      while_break: /* CIL Label */ ;
      }
#line 3270
      if (ndigits > 0U) {
        {
#line 3272
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 3272
          if (! (ndigits > 5U)) {
#line 3272
            goto while_break___0;
          }
#line 3272
          tmp___2 = ascii;
#line 3272
          ascii ++;
#line 3272
          ndigits --;
#line 3272
          *tmp___2 = digits___0[ndigits];
        }
        while_break___0: /* CIL Label */ ;
        }
#line 3277
        if (first <= 5U) {
#line 3280
          tmp___3 = ascii;
#line 3280
          ascii ++;
#line 3280
          *tmp___3 = (char)46;
#line 3284
          i = 5U;
          {
#line 3285
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 3285
            if (! (ndigits < i)) {
#line 3285
              goto while_break___1;
            }
#line 3287
            tmp___4 = ascii;
#line 3287
            ascii ++;
#line 3287
            *tmp___4 = (char)48;
#line 3287
            i --;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 3289
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 3289
            if (! (ndigits >= first)) {
#line 3289
              goto while_break___2;
            }
#line 3289
            tmp___5 = ascii;
#line 3289
            ascii ++;
#line 3289
            ndigits --;
#line 3289
            *tmp___5 = digits___0[ndigits];
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      } else {
#line 3294
        tmp___6 = ascii;
#line 3294
        ascii ++;
#line 3294
        *tmp___6 = (char)48;
      }
#line 3297
      *ascii = (char)0;
#line 3298
      return;
    }
  }
#line 3303
  png_error(png_ptr, (png_const_charp )"ASCII conversion buffer too small");
}
}
#line 3315 "/home/goblint2/bench/libpng-1.6.39/png.c"
png_fixed_point png_fixed(png_const_structrp png_ptr , double fp , png_const_charp text )
{
  double r ;
  double tmp ;

  {
#line 3318
  tmp = floor((double )100000 * fp + .5);
#line 3318
  r = tmp;
#line 3320
  if (r > 2147483647.) {
#line 3321
    png_fixed_error(png_ptr, text);
  } else
#line 3320
  if (r < - 2147483648.) {
#line 3321
    png_fixed_error(png_ptr, text);
  }
#line 3327
  return ((png_fixed_point )r);
}
}
#line 3348 "/home/goblint2/bench/libpng-1.6.39/png.c"
int png_muldiv(png_fixed_point_p res , png_fixed_point a , png_int_32 times , png_int_32 divisor )
{
  double r ;

  {
#line 3353
  if (divisor != 0) {
#line 3355
    if (a == 0) {
#line 3357
      *res = 0;
#line 3358
      return (1);
    } else
#line 3355
    if (times == 0) {
#line 3357
      *res = 0;
#line 3358
      return (1);
    } else {
#line 3363
      r = (double )a;
#line 3364
      r *= (double )times;
#line 3365
      r /= (double )divisor;
#line 3366
      r = floor(r + .5);
#line 3369
      if (r <= 2147483647.) {
#line 3369
        if (r >= - 2147483648.) {
#line 3371
          *res = (png_fixed_point )r;
#line 3372
          return (1);
        }
      }
    }
  }
#line 3460
  return (0);
}
}
#line 3471 "/home/goblint2/bench/libpng-1.6.39/png.c"
png_fixed_point png_muldiv_warn(png_const_structrp png_ptr , png_fixed_point a , png_int_32 times ,
                                png_int_32 divisor )
{
  png_fixed_point result ;
  int tmp ;

  {
#line 3477
  tmp = png_muldiv(& result, a, times, divisor);
#line 3477
  if (tmp != 0) {
#line 3478
    return (result);
  }
#line 3480
  png_warning(png_ptr, (png_const_charp )"fixed point overflow ignored");
#line 3481
  return (0);
}
}
#line 3487 "/home/goblint2/bench/libpng-1.6.39/png.c"
png_fixed_point png_reciprocal(png_fixed_point a )
{
  double r ;
  double tmp ;

  {
#line 3491
  tmp = floor(1E10 / (double )a + .5);
#line 3491
  r = tmp;
#line 3493
  if (r <= 2147483647.) {
#line 3493
    if (r >= - 2147483648.) {
#line 3494
      return ((png_fixed_point )r);
    }
  }
#line 3502
  return (0);
}
}
#line 3508 "/home/goblint2/bench/libpng-1.6.39/png.c"
int png_gamma_significant(png_fixed_point gamma_val )
{
  int tmp ;

  {
#line 3511
  if (gamma_val < 95000) {
#line 3511
    tmp = 1;
  } else
#line 3511
  if (gamma_val > 105000) {
#line 3511
    tmp = 1;
  } else {
#line 3511
    tmp = 0;
  }
#line 3511
  return (tmp);
}
}
#line 3519 "/home/goblint2/bench/libpng-1.6.39/png.c"
static png_fixed_point png_product2(png_fixed_point a , png_fixed_point b )
{
  double r ;

  {
#line 3524
  r = (double )a * 1E-5;
#line 3525
  r *= (double )b;
#line 3526
  r = floor(r + .5);
#line 3528
  if (r <= 2147483647.) {
#line 3528
    if (r >= - 2147483648.) {
#line 3529
      return ((png_fixed_point )r);
    }
  }
#line 3537
  return (0);
}
}
#line 3542 "/home/goblint2/bench/libpng-1.6.39/png.c"
png_fixed_point png_reciprocal2(png_fixed_point a , png_fixed_point b )
{
  double r ;

  {
#line 3547
  if (a != 0) {
#line 3547
    if (b != 0) {
#line 3549
      r = 1E15 / (double )a;
#line 3550
      r /= (double )b;
#line 3551
      r = floor(r + .5);
#line 3553
      if (r <= 2147483647.) {
#line 3553
        if (r >= - 2147483648.) {
#line 3554
          return ((png_fixed_point )r);
        }
      }
    }
  }
#line 3568
  return (0);
}
}
#line 3863 "/home/goblint2/bench/libpng-1.6.39/png.c"
png_byte png_gamma_8bit_correct(unsigned int value , png_fixed_point gamma_val )
{
  double r ;
  double tmp ;
  double tmp___0 ;

  {
#line 3866
  if (value > 0U) {
#line 3866
    if (value < 255U) {
#line 3893
      tmp = pow((double )((int )value) / 255., (double )gamma_val * .00001);
#line 3893
      tmp___0 = floor((double )255 * tmp + .5);
#line 3893
      r = tmp___0;
#line 3894
      return ((png_byte )r);
    }
  }
#line 3907
  return ((png_byte )(value & 255U));
}
}
#line 3911 "/home/goblint2/bench/libpng-1.6.39/png.c"
png_uint_16 png_gamma_16bit_correct(unsigned int value , png_fixed_point gamma_val )
{
  double r ;
  double tmp ;
  double tmp___0 ;

  {
#line 3914
  if (value > 0U) {
#line 3914
    if (value < 65535U) {
#line 3922
      tmp = pow((double )((png_int_32 )value) / 65535., (double )gamma_val * .00001);
#line 3922
      tmp___0 = floor((double )65535 * tmp + .5);
#line 3922
      r = tmp___0;
#line 3924
      return ((png_uint_16 )r);
    }
  }
#line 3937
  return ((png_uint_16 )value);
}
}
#line 3946 "/home/goblint2/bench/libpng-1.6.39/png.c"
png_uint_16 png_gamma_correct(png_structrp png_ptr , unsigned int value , png_fixed_point gamma_val )
{
  png_byte tmp ;
  png_uint_16 tmp___0 ;

  {
#line 3950
  if ((int )png_ptr->bit_depth == 8) {
#line 3951
    tmp = png_gamma_8bit_correct(value, gamma_val);
#line 3951
    return ((png_uint_16 )tmp);
  } else {
#line 3955
    tmp___0 = png_gamma_16bit_correct(value, gamma_val);
#line 3955
    return (tmp___0);
  }
}
}
#line 3971 "/home/goblint2/bench/libpng-1.6.39/png.c"
static void png_build_16bit_table(png_structrp png_ptr , png_uint_16pp *ptable , unsigned int shift ,
                                  png_fixed_point gamma_val )
{
  unsigned int num ;
  double fmax___0 ;
  unsigned int max ;
  unsigned int max_by_2 ;
  unsigned int i ;
  png_uint_16pp table ;
  png_uint_16pp tmp ;
  png_voidp __attribute__((__malloc__))  tmp___0 ;
  png_uint_16p sub_table ;
  png_uint_16 *tmp___1 ;
  png_voidp __attribute__((__malloc__))  tmp___2 ;
  unsigned int j ;
  png_uint_32 ig ;
  double d ;
  double tmp___3 ;
  double tmp___4 ;
  unsigned int j___0 ;
  png_uint_32 ig___0 ;
  int tmp___5 ;

  {
#line 3976
  num = 1U << (8U - shift);
#line 3981
  fmax___0 = 1.0 / (double )((1 << (16U - shift)) - 1);
#line 3983
  max = (1U << (16U - shift)) - 1U;
#line 3984
  max_by_2 = 1U << (15U - shift);
#line 3987
  tmp___0 = png_calloc((png_const_structrp )png_ptr, (unsigned long )num * sizeof(png_uint_16p ));
#line 3987
  tmp = (png_uint_16pp )tmp___0;
#line 3987
  *ptable = tmp;
#line 3987
  table = tmp;
#line 3990
  i = 0U;
  {
#line 3990
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3990
    if (! (i < num)) {
#line 3990
      goto while_break;
    }
#line 3992
    tmp___2 = png_malloc((png_const_structrp )png_ptr, 256UL * sizeof(png_uint_16 ));
#line 3992
    tmp___1 = (png_uint_16p )tmp___2;
#line 3992
    *(table + i) = tmp___1;
#line 3992
    sub_table = tmp___1;
#line 3998
    tmp___5 = png_gamma_significant(gamma_val);
#line 3998
    if (tmp___5 != 0) {
#line 4009
      j = 0U;
      {
#line 4009
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 4009
        if (! (j < 256U)) {
#line 4009
          goto while_break___0;
        }
#line 4011
        ig = (j << (8U - shift)) + i;
#line 4017
        tmp___3 = pow((double )ig * fmax___0, (double )gamma_val * .00001);
#line 4017
        tmp___4 = floor(65535. * tmp___3 + .5);
#line 4017
        d = tmp___4;
#line 4018
        *(sub_table + j) = (png_uint_16 )d;
#line 4009
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 4032
      j___0 = 0U;
      {
#line 4032
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 4032
        if (! (j___0 < 256U)) {
#line 4032
          goto while_break___1;
        }
#line 4034
        ig___0 = (j___0 << (8U - shift)) + i;
#line 4036
        if (shift != 0U) {
#line 4037
          ig___0 = (ig___0 * 65535U + max_by_2) / max;
        }
#line 4039
        *(sub_table + j___0) = (png_uint_16 )ig___0;
#line 4032
        j___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 3990
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4043
  return;
}
}
#line 4048 "/home/goblint2/bench/libpng-1.6.39/png.c"
static void png_build_16to8_table(png_structrp png_ptr , png_uint_16pp *ptable , unsigned int shift ,
                                  png_fixed_point gamma_val )
{
  unsigned int num ;
  unsigned int max ;
  unsigned int i ;
  png_uint_32 last ;
  png_uint_16pp table ;
  png_uint_16pp tmp ;
  png_voidp __attribute__((__malloc__))  tmp___0 ;
  png_voidp __attribute__((__malloc__))  tmp___1 ;
  png_uint_16 out ;
  png_uint_32 bound ;
  png_uint_16 tmp___2 ;

  {
#line 4052
  num = 1U << (8U - shift);
#line 4053
  max = (1U << (16U - shift)) - 1U;
#line 4057
  tmp___0 = png_calloc((png_const_structrp )png_ptr, (unsigned long )num * sizeof(png_uint_16p ));
#line 4057
  tmp = (png_uint_16pp )tmp___0;
#line 4057
  *ptable = tmp;
#line 4057
  table = tmp;
#line 4064
  i = 0U;
  {
#line 4064
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4064
    if (! (i < num)) {
#line 4064
      goto while_break;
    }
#line 4065
    tmp___1 = png_malloc((png_const_structrp )png_ptr, 256UL * sizeof(png_uint_16 ));
#line 4065
    *(table + i) = (png_uint_16p )tmp___1;
#line 4064
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4084
  last = (png_uint_32 )0;
#line 4085
  i = 0U;
  {
#line 4085
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4085
    if (! (i < 255U)) {
#line 4085
      goto while_break___0;
    }
#line 4088
    out = (png_uint_16 )(i * 257U);
#line 4091
    tmp___2 = png_gamma_16bit_correct((unsigned int )out + 128U, gamma_val);
#line 4091
    bound = (png_uint_32 )tmp___2;
#line 4094
    bound = (bound * max + 32768U) / 65535U + 1U;
    {
#line 4096
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 4096
      if (! (last < bound)) {
#line 4096
        goto while_break___1;
      }
#line 4098
      *(*(table + (last & (0xffU >> shift))) + (last >> (8U - shift))) = out;
#line 4099
      last ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 4085
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 4104
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 4104
    if (! (last < num << 8)) {
#line 4104
      goto while_break___2;
    }
#line 4106
    *(*(table + (last & (unsigned int )(0xff >> shift))) + (last >> (8U - shift))) = (png_uint_16 )65535U;
#line 4107
    last ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 4109
  return;
}
}
#line 4116 "/home/goblint2/bench/libpng-1.6.39/png.c"
static void png_build_8bit_table(png_structrp png_ptr , png_bytepp ptable , png_fixed_point gamma_val )
{
  unsigned int i ;
  png_bytep table ;
  png_byte *tmp ;
  png_voidp __attribute__((__malloc__))  tmp___0 ;
  int tmp___1 ;

  {
#line 4121
  tmp___0 = png_malloc((png_const_structrp )png_ptr, (png_alloc_size_t )256);
#line 4121
  tmp = (png_bytep )tmp___0;
#line 4121
  *ptable = tmp;
#line 4121
  table = tmp;
#line 4123
  tmp___1 = png_gamma_significant(gamma_val);
#line 4123
  if (tmp___1 != 0) {
#line 4124
    i = 0U;
    {
#line 4124
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4124
      if (! (i < 256U)) {
#line 4124
        goto while_break;
      }
#line 4125
      *(table + i) = png_gamma_8bit_correct(i, gamma_val);
#line 4124
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 4128
    i = 0U;
    {
#line 4128
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4128
      if (! (i < 256U)) {
#line 4128
        goto while_break___0;
      }
#line 4129
      *(table + i) = (png_byte )(i & 255U);
#line 4128
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 4130
  return;
}
}
#line 4135 "/home/goblint2/bench/libpng-1.6.39/png.c"
void png_destroy_gamma_table(png_structrp png_ptr )
{
  int i ;
  int istop ;
  int i___0 ;
  int istop___0 ;
  int i___1 ;
  int istop___1 ;

  {
#line 4138
  png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->gamma_table);
#line 4139
  png_ptr->gamma_table = (png_bytep )((void *)0);
#line 4142
  if ((unsigned long )png_ptr->gamma_16_table != (unsigned long )((void *)0)) {
#line 4145
    istop = 1 << (8 - png_ptr->gamma_shift);
#line 4146
    i = 0;
    {
#line 4146
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4146
      if (! (i < istop)) {
#line 4146
        goto while_break;
      }
#line 4148
      png_free((png_const_structrp )png_ptr, (png_voidp )*(png_ptr->gamma_16_table + i));
#line 4146
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 4150
    png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->gamma_16_table);
#line 4151
    png_ptr->gamma_16_table = (png_uint_16pp )((void *)0);
  }
#line 4158
  png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->gamma_from_1);
#line 4159
  png_ptr->gamma_from_1 = (png_bytep )((void *)0);
#line 4160
  png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->gamma_to_1);
#line 4161
  png_ptr->gamma_to_1 = (png_bytep )((void *)0);
#line 4164
  if ((unsigned long )png_ptr->gamma_16_from_1 != (unsigned long )((void *)0)) {
#line 4167
    istop___0 = 1 << (8 - png_ptr->gamma_shift);
#line 4168
    i___0 = 0;
    {
#line 4168
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4168
      if (! (i___0 < istop___0)) {
#line 4168
        goto while_break___0;
      }
#line 4170
      png_free((png_const_structrp )png_ptr, (png_voidp )*(png_ptr->gamma_16_from_1 + i___0));
#line 4168
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4172
    png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->gamma_16_from_1);
#line 4173
    png_ptr->gamma_16_from_1 = (png_uint_16pp )((void *)0);
  }
#line 4175
  if ((unsigned long )png_ptr->gamma_16_to_1 != (unsigned long )((void *)0)) {
#line 4178
    istop___1 = 1 << (8 - png_ptr->gamma_shift);
#line 4179
    i___1 = 0;
    {
#line 4179
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 4179
      if (! (i___1 < istop___1)) {
#line 4179
        goto while_break___1;
      }
#line 4181
      png_free((png_const_structrp )png_ptr, (png_voidp )*(png_ptr->gamma_16_to_1 + i___1));
#line 4179
      i___1 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 4183
    png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->gamma_16_to_1);
#line 4184
    png_ptr->gamma_16_to_1 = (png_uint_16pp )((void *)0);
  }
#line 4188
  return;
}
}
#line 4195 "/home/goblint2/bench/libpng-1.6.39/png.c"
void png_build_gamma_table(png_structrp png_ptr , int bit_depth )
{
  png_fixed_point tmp ;
  png_fixed_point tmp___0 ;
  png_fixed_point tmp___1 ;
  png_fixed_point tmp___2 ;
  png_fixed_point tmp___3 ;
  png_byte shift ;
  png_byte sig_bit ;
  png_fixed_point tmp___4 ;
  png_fixed_point tmp___5 ;
  png_fixed_point tmp___6 ;
  png_fixed_point tmp___7 ;
  png_fixed_point tmp___8 ;
  png_fixed_point tmp___9 ;
  png_fixed_point tmp___10 ;

  {
#line 4206
  if ((unsigned long )png_ptr->gamma_table != (unsigned long )((void *)0)) {
#line 4208
    png_warning((png_const_structrp )png_ptr, (png_const_charp )"gamma table being rebuilt");
#line 4209
    png_destroy_gamma_table(png_ptr);
  } else
#line 4206
  if ((unsigned long )png_ptr->gamma_16_table != (unsigned long )((void *)0)) {
#line 4208
    png_warning((png_const_structrp )png_ptr, (png_const_charp )"gamma table being rebuilt");
#line 4209
    png_destroy_gamma_table(png_ptr);
  }
#line 4212
  if (bit_depth <= 8) {
#line 4214
    if (png_ptr->screen_gamma > 0) {
#line 4214
      tmp = png_reciprocal2(png_ptr->colorspace.gamma, png_ptr->screen_gamma);
#line 4214
      tmp___0 = tmp;
    } else {
#line 4214
      tmp___0 = 100000;
    }
#line 4214
    png_build_8bit_table(png_ptr, & png_ptr->gamma_table, tmp___0);
#line 4222
    if ((png_ptr->transformations & 6291584U) != 0U) {
#line 4224
      tmp___1 = png_reciprocal(png_ptr->colorspace.gamma);
#line 4224
      png_build_8bit_table(png_ptr, & png_ptr->gamma_to_1, tmp___1);
#line 4227
      if (png_ptr->screen_gamma > 0) {
#line 4227
        tmp___2 = png_reciprocal(png_ptr->screen_gamma);
#line 4227
        tmp___3 = tmp___2;
      } else {
#line 4227
        tmp___3 = png_ptr->colorspace.gamma;
      }
#line 4227
      png_build_8bit_table(png_ptr, & png_ptr->gamma_from_1, tmp___3);
    }
  } else {
#line 4239
    if (((int )png_ptr->color_type & 2) != 0) {
#line 4241
      sig_bit = png_ptr->sig_bit.red;
#line 4243
      if ((int )png_ptr->sig_bit.green > (int )sig_bit) {
#line 4244
        sig_bit = png_ptr->sig_bit.green;
      }
#line 4246
      if ((int )png_ptr->sig_bit.blue > (int )sig_bit) {
#line 4247
        sig_bit = png_ptr->sig_bit.blue;
      }
    } else {
#line 4250
      sig_bit = png_ptr->sig_bit.gray;
    }
#line 4270
    if ((int )sig_bit > 0) {
#line 4270
      if ((unsigned int )sig_bit < 16U) {
#line 4272
        shift = (png_byte )((16U - (unsigned int )sig_bit) & 255U);
      } else {
#line 4275
        shift = (png_byte )0;
      }
    } else {
#line 4275
      shift = (png_byte )0;
    }
#line 4277
    if ((png_ptr->transformations & 67109888U) != 0U) {
#line 4283
      if ((unsigned int )shift < 5U) {
#line 4284
        shift = (png_byte )5U;
      }
    }
#line 4287
    if ((unsigned int )shift > 8U) {
#line 4288
      shift = (png_byte )8U;
    }
#line 4290
    png_ptr->gamma_shift = (int )shift;
#line 4297
    if ((png_ptr->transformations & 67109888U) != 0U) {
#line 4298
      if (png_ptr->screen_gamma > 0) {
#line 4298
        tmp___4 = png_product2(png_ptr->colorspace.gamma, png_ptr->screen_gamma);
#line 4298
        tmp___5 = tmp___4;
      } else {
#line 4298
        tmp___5 = 100000;
      }
#line 4298
      png_build_16to8_table(png_ptr, & png_ptr->gamma_16_table, (unsigned int )shift,
                            tmp___5);
    } else {
#line 4303
      if (png_ptr->screen_gamma > 0) {
#line 4303
        tmp___6 = png_reciprocal2(png_ptr->colorspace.gamma, png_ptr->screen_gamma);
#line 4303
        tmp___7 = tmp___6;
      } else {
#line 4303
        tmp___7 = 100000;
      }
#line 4303
      png_build_16bit_table(png_ptr, & png_ptr->gamma_16_table, (unsigned int )shift,
                            tmp___7);
    }
#line 4310
    if ((png_ptr->transformations & 6291584U) != 0U) {
#line 4312
      tmp___8 = png_reciprocal(png_ptr->colorspace.gamma);
#line 4312
      png_build_16bit_table(png_ptr, & png_ptr->gamma_16_to_1, (unsigned int )shift,
                            tmp___8);
#line 4319
      if (png_ptr->screen_gamma > 0) {
#line 4319
        tmp___9 = png_reciprocal(png_ptr->screen_gamma);
#line 4319
        tmp___10 = tmp___9;
      } else {
#line 4319
        tmp___10 = png_ptr->colorspace.gamma;
      }
#line 4319
      png_build_16bit_table(png_ptr, & png_ptr->gamma_16_from_1, (unsigned int )shift,
                            tmp___10);
    }
  }
#line 4326
  return;
}
}
#line 4331 "/home/goblint2/bench/libpng-1.6.39/png.c"
int png_set_option(png_structrp png_ptr , int option , int onoff )
{
  png_uint_32 mask ;
  png_uint_32 setting ;
  png_uint_32 current ;

  {
#line 4334
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 4334
    if (option >= 0) {
#line 4334
      if (option < 12) {
#line 4334
        if ((option & 1) == 0) {
#line 4337
          mask = 3U << option;
#line 4338
          setting = (2U + (unsigned int )(onoff != 0)) << option;
#line 4339
          current = png_ptr->options;
#line 4341
          png_ptr->options = (current & ~ mask) | setting;
#line 4343
          return ((int )(current & mask) >> option);
        }
      }
    }
  }
#line 4346
  return (1);
}
}
#line 4373 "/home/goblint2/bench/libpng-1.6.39/png.c"
png_uint_16 const   png_sRGB_table[256]  =
#line 4373
  {      (png_uint_16 const   )0,      (png_uint_16 const   )20,      (png_uint_16 const   )40,      (png_uint_16 const   )60,
        (png_uint_16 const   )80,      (png_uint_16 const   )99,      (png_uint_16 const   )119,      (png_uint_16 const   )139,
        (png_uint_16 const   )159,      (png_uint_16 const   )179,      (png_uint_16 const   )199,      (png_uint_16 const   )219,
        (png_uint_16 const   )241,      (png_uint_16 const   )264,      (png_uint_16 const   )288,      (png_uint_16 const   )313,
        (png_uint_16 const   )340,      (png_uint_16 const   )367,      (png_uint_16 const   )396,      (png_uint_16 const   )427,
        (png_uint_16 const   )458,      (png_uint_16 const   )491,      (png_uint_16 const   )526,      (png_uint_16 const   )562,
        (png_uint_16 const   )599,      (png_uint_16 const   )637,      (png_uint_16 const   )677,      (png_uint_16 const   )718,
        (png_uint_16 const   )761,      (png_uint_16 const   )805,      (png_uint_16 const   )851,      (png_uint_16 const   )898,
        (png_uint_16 const   )947,      (png_uint_16 const   )997,      (png_uint_16 const   )1048,      (png_uint_16 const   )1101,
        (png_uint_16 const   )1156,      (png_uint_16 const   )1212,      (png_uint_16 const   )1270,      (png_uint_16 const   )1330,
        (png_uint_16 const   )1391,      (png_uint_16 const   )1453,      (png_uint_16 const   )1517,      (png_uint_16 const   )1583,
        (png_uint_16 const   )1651,      (png_uint_16 const   )1720,      (png_uint_16 const   )1790,      (png_uint_16 const   )1863,
        (png_uint_16 const   )1937,      (png_uint_16 const   )2013,      (png_uint_16 const   )2090,      (png_uint_16 const   )2170,
        (png_uint_16 const   )2250,      (png_uint_16 const   )2333,      (png_uint_16 const   )2418,      (png_uint_16 const   )2504,
        (png_uint_16 const   )2592,      (png_uint_16 const   )2681,      (png_uint_16 const   )2773,      (png_uint_16 const   )2866,
        (png_uint_16 const   )2961,      (png_uint_16 const   )3058,      (png_uint_16 const   )3157,      (png_uint_16 const   )3258,
        (png_uint_16 const   )3360,      (png_uint_16 const   )3464,      (png_uint_16 const   )3570,      (png_uint_16 const   )3678,
        (png_uint_16 const   )3788,      (png_uint_16 const   )3900,      (png_uint_16 const   )4014,      (png_uint_16 const   )4129,
        (png_uint_16 const   )4247,      (png_uint_16 const   )4366,      (png_uint_16 const   )4488,      (png_uint_16 const   )4611,
        (png_uint_16 const   )4736,      (png_uint_16 const   )4864,      (png_uint_16 const   )4993,      (png_uint_16 const   )5124,
        (png_uint_16 const   )5257,      (png_uint_16 const   )5392,      (png_uint_16 const   )5530,      (png_uint_16 const   )5669,
        (png_uint_16 const   )5810,      (png_uint_16 const   )5953,      (png_uint_16 const   )6099,      (png_uint_16 const   )6246,
        (png_uint_16 const   )6395,      (png_uint_16 const   )6547,      (png_uint_16 const   )6700,      (png_uint_16 const   )6856,
        (png_uint_16 const   )7014,      (png_uint_16 const   )7174,      (png_uint_16 const   )7335,      (png_uint_16 const   )7500,
        (png_uint_16 const   )7666,      (png_uint_16 const   )7834,      (png_uint_16 const   )8004,      (png_uint_16 const   )8177,
        (png_uint_16 const   )8352,      (png_uint_16 const   )8528,      (png_uint_16 const   )8708,      (png_uint_16 const   )8889,
        (png_uint_16 const   )9072,      (png_uint_16 const   )9258,      (png_uint_16 const   )9445,      (png_uint_16 const   )9635,
        (png_uint_16 const   )9828,      (png_uint_16 const   )10022,      (png_uint_16 const   )10219,      (png_uint_16 const   )10417,
        (png_uint_16 const   )10619,      (png_uint_16 const   )10822,      (png_uint_16 const   )11028,      (png_uint_16 const   )11235,
        (png_uint_16 const   )11446,      (png_uint_16 const   )11658,      (png_uint_16 const   )11873,      (png_uint_16 const   )12090,
        (png_uint_16 const   )12309,      (png_uint_16 const   )12530,      (png_uint_16 const   )12754,      (png_uint_16 const   )12980,
        (png_uint_16 const   )13209,      (png_uint_16 const   )13440,      (png_uint_16 const   )13673,      (png_uint_16 const   )13909,
        (png_uint_16 const   )14146,      (png_uint_16 const   )14387,      (png_uint_16 const   )14629,      (png_uint_16 const   )14874,
        (png_uint_16 const   )15122,      (png_uint_16 const   )15371,      (png_uint_16 const   )15623,      (png_uint_16 const   )15878,
        (png_uint_16 const   )16135,      (png_uint_16 const   )16394,      (png_uint_16 const   )16656,      (png_uint_16 const   )16920,
        (png_uint_16 const   )17187,      (png_uint_16 const   )17456,      (png_uint_16 const   )17727,      (png_uint_16 const   )18001,
        (png_uint_16 const   )18277,      (png_uint_16 const   )18556,      (png_uint_16 const   )18837,      (png_uint_16 const   )19121,
        (png_uint_16 const   )19407,      (png_uint_16 const   )19696,      (png_uint_16 const   )19987,      (png_uint_16 const   )20281,
        (png_uint_16 const   )20577,      (png_uint_16 const   )20876,      (png_uint_16 const   )21177,      (png_uint_16 const   )21481,
        (png_uint_16 const   )21787,      (png_uint_16 const   )22096,      (png_uint_16 const   )22407,      (png_uint_16 const   )22721,
        (png_uint_16 const   )23038,      (png_uint_16 const   )23357,      (png_uint_16 const   )23678,      (png_uint_16 const   )24002,
        (png_uint_16 const   )24329,      (png_uint_16 const   )24658,      (png_uint_16 const   )24990,      (png_uint_16 const   )25325,
        (png_uint_16 const   )25662,      (png_uint_16 const   )26001,      (png_uint_16 const   )26344,      (png_uint_16 const   )26688,
        (png_uint_16 const   )27036,      (png_uint_16 const   )27386,      (png_uint_16 const   )27739,      (png_uint_16 const   )28094,
        (png_uint_16 const   )28452,      (png_uint_16 const   )28813,      (png_uint_16 const   )29176,      (png_uint_16 const   )29542,
        (png_uint_16 const   )29911,      (png_uint_16 const   )30282,      (png_uint_16 const   )30656,      (png_uint_16 const   )31033,
        (png_uint_16 const   )31412,      (png_uint_16 const   )31794,      (png_uint_16 const   )32179,      (png_uint_16 const   )32567,
        (png_uint_16 const   )32957,      (png_uint_16 const   )33350,      (png_uint_16 const   )33745,      (png_uint_16 const   )34143,
        (png_uint_16 const   )34544,      (png_uint_16 const   )34948,      (png_uint_16 const   )35355,      (png_uint_16 const   )35764,
        (png_uint_16 const   )36176,      (png_uint_16 const   )36591,      (png_uint_16 const   )37008,      (png_uint_16 const   )37429,
        (png_uint_16 const   )37852,      (png_uint_16 const   )38278,      (png_uint_16 const   )38706,      (png_uint_16 const   )39138,
        (png_uint_16 const   )39572,      (png_uint_16 const   )40009,      (png_uint_16 const   )40449,      (png_uint_16 const   )40891,
        (png_uint_16 const   )41337,      (png_uint_16 const   )41785,      (png_uint_16 const   )42236,      (png_uint_16 const   )42690,
        (png_uint_16 const   )43147,      (png_uint_16 const   )43606,      (png_uint_16 const   )44069,      (png_uint_16 const   )44534,
        (png_uint_16 const   )45002,      (png_uint_16 const   )45473,      (png_uint_16 const   )45947,      (png_uint_16 const   )46423,
        (png_uint_16 const   )46903,      (png_uint_16 const   )47385,      (png_uint_16 const   )47871,      (png_uint_16 const   )48359,
        (png_uint_16 const   )48850,      (png_uint_16 const   )49344,      (png_uint_16 const   )49841,      (png_uint_16 const   )50341,
        (png_uint_16 const   )50844,      (png_uint_16 const   )51349,      (png_uint_16 const   )51858,      (png_uint_16 const   )52369,
        (png_uint_16 const   )52884,      (png_uint_16 const   )53401,      (png_uint_16 const   )53921,      (png_uint_16 const   )54445,
        (png_uint_16 const   )54971,      (png_uint_16 const   )55500,      (png_uint_16 const   )56032,      (png_uint_16 const   )56567,
        (png_uint_16 const   )57105,      (png_uint_16 const   )57646,      (png_uint_16 const   )58190,      (png_uint_16 const   )58737,
        (png_uint_16 const   )59287,      (png_uint_16 const   )59840,      (png_uint_16 const   )60396,      (png_uint_16 const   )60955,
        (png_uint_16 const   )61517,      (png_uint_16 const   )62082,      (png_uint_16 const   )62650,      (png_uint_16 const   )63221,
        (png_uint_16 const   )63795,      (png_uint_16 const   )64372,      (png_uint_16 const   )64952,      (png_uint_16 const   )65535};
#line 4413 "/home/goblint2/bench/libpng-1.6.39/png.c"
png_uint_16 const   png_sRGB_base[512]  =
#line 4413
  {      (png_uint_16 const   )128,      (png_uint_16 const   )1782,      (png_uint_16 const   )3383,      (png_uint_16 const   )4644,
        (png_uint_16 const   )5675,      (png_uint_16 const   )6564,      (png_uint_16 const   )7357,      (png_uint_16 const   )8074,
        (png_uint_16 const   )8732,      (png_uint_16 const   )9346,      (png_uint_16 const   )9921,      (png_uint_16 const   )10463,
        (png_uint_16 const   )10977,      (png_uint_16 const   )11466,      (png_uint_16 const   )11935,      (png_uint_16 const   )12384,
        (png_uint_16 const   )12816,      (png_uint_16 const   )13233,      (png_uint_16 const   )13634,      (png_uint_16 const   )14024,
        (png_uint_16 const   )14402,      (png_uint_16 const   )14769,      (png_uint_16 const   )15125,      (png_uint_16 const   )15473,
        (png_uint_16 const   )15812,      (png_uint_16 const   )16142,      (png_uint_16 const   )16466,      (png_uint_16 const   )16781,
        (png_uint_16 const   )17090,      (png_uint_16 const   )17393,      (png_uint_16 const   )17690,      (png_uint_16 const   )17981,
        (png_uint_16 const   )18266,      (png_uint_16 const   )18546,      (png_uint_16 const   )18822,      (png_uint_16 const   )19093,
        (png_uint_16 const   )19359,      (png_uint_16 const   )19621,      (png_uint_16 const   )19879,      (png_uint_16 const   )20133,
        (png_uint_16 const   )20383,      (png_uint_16 const   )20630,      (png_uint_16 const   )20873,      (png_uint_16 const   )21113,
        (png_uint_16 const   )21349,      (png_uint_16 const   )21583,      (png_uint_16 const   )21813,      (png_uint_16 const   )22041,
        (png_uint_16 const   )22265,      (png_uint_16 const   )22487,      (png_uint_16 const   )22707,      (png_uint_16 const   )22923,
        (png_uint_16 const   )23138,      (png_uint_16 const   )23350,      (png_uint_16 const   )23559,      (png_uint_16 const   )23767,
        (png_uint_16 const   )23972,      (png_uint_16 const   )24175,      (png_uint_16 const   )24376,      (png_uint_16 const   )24575,
        (png_uint_16 const   )24772,      (png_uint_16 const   )24967,      (png_uint_16 const   )25160,      (png_uint_16 const   )25352,
        (png_uint_16 const   )25542,      (png_uint_16 const   )25730,      (png_uint_16 const   )25916,      (png_uint_16 const   )26101,
        (png_uint_16 const   )26284,      (png_uint_16 const   )26465,      (png_uint_16 const   )26645,      (png_uint_16 const   )26823,
        (png_uint_16 const   )27000,      (png_uint_16 const   )27176,      (png_uint_16 const   )27350,      (png_uint_16 const   )27523,
        (png_uint_16 const   )27695,      (png_uint_16 const   )27865,      (png_uint_16 const   )28034,      (png_uint_16 const   )28201,
        (png_uint_16 const   )28368,      (png_uint_16 const   )28533,      (png_uint_16 const   )28697,      (png_uint_16 const   )28860,
        (png_uint_16 const   )29021,      (png_uint_16 const   )29182,      (png_uint_16 const   )29341,      (png_uint_16 const   )29500,
        (png_uint_16 const   )29657,      (png_uint_16 const   )29813,      (png_uint_16 const   )29969,      (png_uint_16 const   )30123,
        (png_uint_16 const   )30276,      (png_uint_16 const   )30429,      (png_uint_16 const   )30580,      (png_uint_16 const   )30730,
        (png_uint_16 const   )30880,      (png_uint_16 const   )31028,      (png_uint_16 const   )31176,      (png_uint_16 const   )31323,
        (png_uint_16 const   )31469,      (png_uint_16 const   )31614,      (png_uint_16 const   )31758,      (png_uint_16 const   )31902,
        (png_uint_16 const   )32045,      (png_uint_16 const   )32186,      (png_uint_16 const   )32327,      (png_uint_16 const   )32468,
        (png_uint_16 const   )32607,      (png_uint_16 const   )32746,      (png_uint_16 const   )32884,      (png_uint_16 const   )33021,
        (png_uint_16 const   )33158,      (png_uint_16 const   )33294,      (png_uint_16 const   )33429,      (png_uint_16 const   )33564,
        (png_uint_16 const   )33697,      (png_uint_16 const   )33831,      (png_uint_16 const   )33963,      (png_uint_16 const   )34095,
        (png_uint_16 const   )34226,      (png_uint_16 const   )34357,      (png_uint_16 const   )34486,      (png_uint_16 const   )34616,
        (png_uint_16 const   )34744,      (png_uint_16 const   )34873,      (png_uint_16 const   )35000,      (png_uint_16 const   )35127,
        (png_uint_16 const   )35253,      (png_uint_16 const   )35379,      (png_uint_16 const   )35504,      (png_uint_16 const   )35629,
        (png_uint_16 const   )35753,      (png_uint_16 const   )35876,      (png_uint_16 const   )35999,      (png_uint_16 const   )36122,
        (png_uint_16 const   )36244,      (png_uint_16 const   )36365,      (png_uint_16 const   )36486,      (png_uint_16 const   )36606,
        (png_uint_16 const   )36726,      (png_uint_16 const   )36845,      (png_uint_16 const   )36964,      (png_uint_16 const   )37083,
        (png_uint_16 const   )37201,      (png_uint_16 const   )37318,      (png_uint_16 const   )37435,      (png_uint_16 const   )37551,
        (png_uint_16 const   )37668,      (png_uint_16 const   )37783,      (png_uint_16 const   )37898,      (png_uint_16 const   )38013,
        (png_uint_16 const   )38127,      (png_uint_16 const   )38241,      (png_uint_16 const   )38354,      (png_uint_16 const   )38467,
        (png_uint_16 const   )38580,      (png_uint_16 const   )38692,      (png_uint_16 const   )38803,      (png_uint_16 const   )38915,
        (png_uint_16 const   )39026,      (png_uint_16 const   )39136,      (png_uint_16 const   )39246,      (png_uint_16 const   )39356,
        (png_uint_16 const   )39465,      (png_uint_16 const   )39574,      (png_uint_16 const   )39682,      (png_uint_16 const   )39790,
        (png_uint_16 const   )39898,      (png_uint_16 const   )40005,      (png_uint_16 const   )40112,      (png_uint_16 const   )40219,
        (png_uint_16 const   )40325,      (png_uint_16 const   )40431,      (png_uint_16 const   )40537,      (png_uint_16 const   )40642,
        (png_uint_16 const   )40747,      (png_uint_16 const   )40851,      (png_uint_16 const   )40955,      (png_uint_16 const   )41059,
        (png_uint_16 const   )41163,      (png_uint_16 const   )41266,      (png_uint_16 const   )41369,      (png_uint_16 const   )41471,
        (png_uint_16 const   )41573,      (png_uint_16 const   )41675,      (png_uint_16 const   )41777,      (png_uint_16 const   )41878,
        (png_uint_16 const   )41979,      (png_uint_16 const   )42079,      (png_uint_16 const   )42179,      (png_uint_16 const   )42279,
        (png_uint_16 const   )42379,      (png_uint_16 const   )42478,      (png_uint_16 const   )42577,      (png_uint_16 const   )42676,
        (png_uint_16 const   )42775,      (png_uint_16 const   )42873,      (png_uint_16 const   )42971,      (png_uint_16 const   )43068,
        (png_uint_16 const   )43165,      (png_uint_16 const   )43262,      (png_uint_16 const   )43359,      (png_uint_16 const   )43456,
        (png_uint_16 const   )43552,      (png_uint_16 const   )43648,      (png_uint_16 const   )43743,      (png_uint_16 const   )43839,
        (png_uint_16 const   )43934,      (png_uint_16 const   )44028,      (png_uint_16 const   )44123,      (png_uint_16 const   )44217,
        (png_uint_16 const   )44311,      (png_uint_16 const   )44405,      (png_uint_16 const   )44499,      (png_uint_16 const   )44592,
        (png_uint_16 const   )44685,      (png_uint_16 const   )44778,      (png_uint_16 const   )44870,      (png_uint_16 const   )44962,
        (png_uint_16 const   )45054,      (png_uint_16 const   )45146,      (png_uint_16 const   )45238,      (png_uint_16 const   )45329,
        (png_uint_16 const   )45420,      (png_uint_16 const   )45511,      (png_uint_16 const   )45601,      (png_uint_16 const   )45692,
        (png_uint_16 const   )45782,      (png_uint_16 const   )45872,      (png_uint_16 const   )45961,      (png_uint_16 const   )46051,
        (png_uint_16 const   )46140,      (png_uint_16 const   )46229,      (png_uint_16 const   )46318,      (png_uint_16 const   )46406,
        (png_uint_16 const   )46494,      (png_uint_16 const   )46583,      (png_uint_16 const   )46670,      (png_uint_16 const   )46758,
        (png_uint_16 const   )46846,      (png_uint_16 const   )46933,      (png_uint_16 const   )47020,      (png_uint_16 const   )47107,
        (png_uint_16 const   )47193,      (png_uint_16 const   )47280,      (png_uint_16 const   )47366,      (png_uint_16 const   )47452,
        (png_uint_16 const   )47538,      (png_uint_16 const   )47623,      (png_uint_16 const   )47709,      (png_uint_16 const   )47794,
        (png_uint_16 const   )47879,      (png_uint_16 const   )47964,      (png_uint_16 const   )48048,      (png_uint_16 const   )48133,
        (png_uint_16 const   )48217,      (png_uint_16 const   )48301,      (png_uint_16 const   )48385,      (png_uint_16 const   )48468,
        (png_uint_16 const   )48552,      (png_uint_16 const   )48635,      (png_uint_16 const   )48718,      (png_uint_16 const   )48801,
        (png_uint_16 const   )48884,      (png_uint_16 const   )48966,      (png_uint_16 const   )49048,      (png_uint_16 const   )49131,
        (png_uint_16 const   )49213,      (png_uint_16 const   )49294,      (png_uint_16 const   )49376,      (png_uint_16 const   )49458,
        (png_uint_16 const   )49539,      (png_uint_16 const   )49620,      (png_uint_16 const   )49701,      (png_uint_16 const   )49782,
        (png_uint_16 const   )49862,      (png_uint_16 const   )49943,      (png_uint_16 const   )50023,      (png_uint_16 const   )50103,
        (png_uint_16 const   )50183,      (png_uint_16 const   )50263,      (png_uint_16 const   )50342,      (png_uint_16 const   )50422,
        (png_uint_16 const   )50501,      (png_uint_16 const   )50580,      (png_uint_16 const   )50659,      (png_uint_16 const   )50738,
        (png_uint_16 const   )50816,      (png_uint_16 const   )50895,      (png_uint_16 const   )50973,      (png_uint_16 const   )51051,
        (png_uint_16 const   )51129,      (png_uint_16 const   )51207,      (png_uint_16 const   )51285,      (png_uint_16 const   )51362,
        (png_uint_16 const   )51439,      (png_uint_16 const   )51517,      (png_uint_16 const   )51594,      (png_uint_16 const   )51671,
        (png_uint_16 const   )51747,      (png_uint_16 const   )51824,      (png_uint_16 const   )51900,      (png_uint_16 const   )51977,
        (png_uint_16 const   )52053,      (png_uint_16 const   )52129,      (png_uint_16 const   )52205,      (png_uint_16 const   )52280,
        (png_uint_16 const   )52356,      (png_uint_16 const   )52432,      (png_uint_16 const   )52507,      (png_uint_16 const   )52582,
        (png_uint_16 const   )52657,      (png_uint_16 const   )52732,      (png_uint_16 const   )52807,      (png_uint_16 const   )52881,
        (png_uint_16 const   )52956,      (png_uint_16 const   )53030,      (png_uint_16 const   )53104,      (png_uint_16 const   )53178,
        (png_uint_16 const   )53252,      (png_uint_16 const   )53326,      (png_uint_16 const   )53400,      (png_uint_16 const   )53473,
        (png_uint_16 const   )53546,      (png_uint_16 const   )53620,      (png_uint_16 const   )53693,      (png_uint_16 const   )53766,
        (png_uint_16 const   )53839,      (png_uint_16 const   )53911,      (png_uint_16 const   )53984,      (png_uint_16 const   )54056,
        (png_uint_16 const   )54129,      (png_uint_16 const   )54201,      (png_uint_16 const   )54273,      (png_uint_16 const   )54345,
        (png_uint_16 const   )54417,      (png_uint_16 const   )54489,      (png_uint_16 const   )54560,      (png_uint_16 const   )54632,
        (png_uint_16 const   )54703,      (png_uint_16 const   )54774,      (png_uint_16 const   )54845,      (png_uint_16 const   )54916,
        (png_uint_16 const   )54987,      (png_uint_16 const   )55058,      (png_uint_16 const   )55129,      (png_uint_16 const   )55199,
        (png_uint_16 const   )55269,      (png_uint_16 const   )55340,      (png_uint_16 const   )55410,      (png_uint_16 const   )55480,
        (png_uint_16 const   )55550,      (png_uint_16 const   )55620,      (png_uint_16 const   )55689,      (png_uint_16 const   )55759,
        (png_uint_16 const   )55828,      (png_uint_16 const   )55898,      (png_uint_16 const   )55967,      (png_uint_16 const   )56036,
        (png_uint_16 const   )56105,      (png_uint_16 const   )56174,      (png_uint_16 const   )56243,      (png_uint_16 const   )56311,
        (png_uint_16 const   )56380,      (png_uint_16 const   )56448,      (png_uint_16 const   )56517,      (png_uint_16 const   )56585,
        (png_uint_16 const   )56653,      (png_uint_16 const   )56721,      (png_uint_16 const   )56789,      (png_uint_16 const   )56857,
        (png_uint_16 const   )56924,      (png_uint_16 const   )56992,      (png_uint_16 const   )57059,      (png_uint_16 const   )57127,
        (png_uint_16 const   )57194,      (png_uint_16 const   )57261,      (png_uint_16 const   )57328,      (png_uint_16 const   )57395,
        (png_uint_16 const   )57462,      (png_uint_16 const   )57529,      (png_uint_16 const   )57595,      (png_uint_16 const   )57662,
        (png_uint_16 const   )57728,      (png_uint_16 const   )57795,      (png_uint_16 const   )57861,      (png_uint_16 const   )57927,
        (png_uint_16 const   )57993,      (png_uint_16 const   )58059,      (png_uint_16 const   )58125,      (png_uint_16 const   )58191,
        (png_uint_16 const   )58256,      (png_uint_16 const   )58322,      (png_uint_16 const   )58387,      (png_uint_16 const   )58453,
        (png_uint_16 const   )58518,      (png_uint_16 const   )58583,      (png_uint_16 const   )58648,      (png_uint_16 const   )58713,
        (png_uint_16 const   )58778,      (png_uint_16 const   )58843,      (png_uint_16 const   )58908,      (png_uint_16 const   )58972,
        (png_uint_16 const   )59037,      (png_uint_16 const   )59101,      (png_uint_16 const   )59165,      (png_uint_16 const   )59230,
        (png_uint_16 const   )59294,      (png_uint_16 const   )59358,      (png_uint_16 const   )59422,      (png_uint_16 const   )59486,
        (png_uint_16 const   )59549,      (png_uint_16 const   )59613,      (png_uint_16 const   )59677,      (png_uint_16 const   )59740,
        (png_uint_16 const   )59804,      (png_uint_16 const   )59867,      (png_uint_16 const   )59930,      (png_uint_16 const   )59993,
        (png_uint_16 const   )60056,      (png_uint_16 const   )60119,      (png_uint_16 const   )60182,      (png_uint_16 const   )60245,
        (png_uint_16 const   )60308,      (png_uint_16 const   )60370,      (png_uint_16 const   )60433,      (png_uint_16 const   )60495,
        (png_uint_16 const   )60558,      (png_uint_16 const   )60620,      (png_uint_16 const   )60682,      (png_uint_16 const   )60744,
        (png_uint_16 const   )60806,      (png_uint_16 const   )60868,      (png_uint_16 const   )60930,      (png_uint_16 const   )60992,
        (png_uint_16 const   )61054,      (png_uint_16 const   )61115,      (png_uint_16 const   )61177,      (png_uint_16 const   )61238,
        (png_uint_16 const   )61300,      (png_uint_16 const   )61361,      (png_uint_16 const   )61422,      (png_uint_16 const   )61483,
        (png_uint_16 const   )61544,      (png_uint_16 const   )61605,      (png_uint_16 const   )61666,      (png_uint_16 const   )61727,
        (png_uint_16 const   )61788,      (png_uint_16 const   )61848,      (png_uint_16 const   )61909,      (png_uint_16 const   )61969,
        (png_uint_16 const   )62030,      (png_uint_16 const   )62090,      (png_uint_16 const   )62150,      (png_uint_16 const   )62211,
        (png_uint_16 const   )62271,      (png_uint_16 const   )62331,      (png_uint_16 const   )62391,      (png_uint_16 const   )62450,
        (png_uint_16 const   )62510,      (png_uint_16 const   )62570,      (png_uint_16 const   )62630,      (png_uint_16 const   )62689,
        (png_uint_16 const   )62749,      (png_uint_16 const   )62808,      (png_uint_16 const   )62867,      (png_uint_16 const   )62927,
        (png_uint_16 const   )62986,      (png_uint_16 const   )63045,      (png_uint_16 const   )63104,      (png_uint_16 const   )63163,
        (png_uint_16 const   )63222,      (png_uint_16 const   )63281,      (png_uint_16 const   )63340,      (png_uint_16 const   )63398,
        (png_uint_16 const   )63457,      (png_uint_16 const   )63515,      (png_uint_16 const   )63574,      (png_uint_16 const   )63632,
        (png_uint_16 const   )63691,      (png_uint_16 const   )63749,      (png_uint_16 const   )63807,      (png_uint_16 const   )63865,
        (png_uint_16 const   )63923,      (png_uint_16 const   )63981,      (png_uint_16 const   )64039,      (png_uint_16 const   )64097,
        (png_uint_16 const   )64155,      (png_uint_16 const   )64212,      (png_uint_16 const   )64270,      (png_uint_16 const   )64328,
        (png_uint_16 const   )64385,      (png_uint_16 const   )64443,      (png_uint_16 const   )64500,      (png_uint_16 const   )64557,
        (png_uint_16 const   )64614,      (png_uint_16 const   )64672,      (png_uint_16 const   )64729,      (png_uint_16 const   )64786,
        (png_uint_16 const   )64843,      (png_uint_16 const   )64900,      (png_uint_16 const   )64956,      (png_uint_16 const   )65013,
        (png_uint_16 const   )65070,      (png_uint_16 const   )65126,      (png_uint_16 const   )65183,      (png_uint_16 const   )65239,
        (png_uint_16 const   )65296,      (png_uint_16 const   )65352,      (png_uint_16 const   )65409,      (png_uint_16 const   )65465};
#line 4481 "/home/goblint2/bench/libpng-1.6.39/png.c"
png_byte const   png_sRGB_delta[512]  =
#line 4481
  {      (png_byte const   )207,      (png_byte const   )201,      (png_byte const   )158,      (png_byte const   )129,
        (png_byte const   )113,      (png_byte const   )100,      (png_byte const   )90,      (png_byte const   )82,
        (png_byte const   )77,      (png_byte const   )72,      (png_byte const   )68,      (png_byte const   )64,
        (png_byte const   )61,      (png_byte const   )59,      (png_byte const   )56,      (png_byte const   )54,
        (png_byte const   )52,      (png_byte const   )50,      (png_byte const   )49,      (png_byte const   )47,
        (png_byte const   )46,      (png_byte const   )45,      (png_byte const   )43,      (png_byte const   )42,
        (png_byte const   )41,      (png_byte const   )40,      (png_byte const   )39,      (png_byte const   )39,
        (png_byte const   )38,      (png_byte const   )37,      (png_byte const   )36,      (png_byte const   )36,
        (png_byte const   )35,      (png_byte const   )34,      (png_byte const   )34,      (png_byte const   )33,
        (png_byte const   )33,      (png_byte const   )32,      (png_byte const   )32,      (png_byte const   )31,
        (png_byte const   )31,      (png_byte const   )30,      (png_byte const   )30,      (png_byte const   )30,
        (png_byte const   )29,      (png_byte const   )29,      (png_byte const   )28,      (png_byte const   )28,
        (png_byte const   )28,      (png_byte const   )27,      (png_byte const   )27,      (png_byte const   )27,
        (png_byte const   )27,      (png_byte const   )26,      (png_byte const   )26,      (png_byte const   )26,
        (png_byte const   )25,      (png_byte const   )25,      (png_byte const   )25,      (png_byte const   )25,
        (png_byte const   )24,      (png_byte const   )24,      (png_byte const   )24,      (png_byte const   )24,
        (png_byte const   )23,      (png_byte const   )23,      (png_byte const   )23,      (png_byte const   )23,
        (png_byte const   )23,      (png_byte const   )22,      (png_byte const   )22,      (png_byte const   )22,
        (png_byte const   )22,      (png_byte const   )22,      (png_byte const   )22,      (png_byte const   )21,
        (png_byte const   )21,      (png_byte const   )21,      (png_byte const   )21,      (png_byte const   )21,
        (png_byte const   )21,      (png_byte const   )20,      (png_byte const   )20,      (png_byte const   )20,
        (png_byte const   )20,      (png_byte const   )20,      (png_byte const   )20,      (png_byte const   )20,
        (png_byte const   )20,      (png_byte const   )19,      (png_byte const   )19,      (png_byte const   )19,
        (png_byte const   )19,      (png_byte const   )19,      (png_byte const   )19,      (png_byte const   )19,
        (png_byte const   )19,      (png_byte const   )18,      (png_byte const   )18,      (png_byte const   )18,
        (png_byte const   )18,      (png_byte const   )18,      (png_byte const   )18,      (png_byte const   )18,
        (png_byte const   )18,      (png_byte const   )18,      (png_byte const   )18,      (png_byte const   )17,
        (png_byte const   )17,      (png_byte const   )17,      (png_byte const   )17,      (png_byte const   )17,
        (png_byte const   )17,      (png_byte const   )17,      (png_byte const   )17,      (png_byte const   )17,
        (png_byte const   )17,      (png_byte const   )17,      (png_byte const   )16,      (png_byte const   )16,
        (png_byte const   )16,      (png_byte const   )16,      (png_byte const   )16,      (png_byte const   )16,
        (png_byte const   )16,      (png_byte const   )16,      (png_byte const   )16,      (png_byte const   )16,
        (png_byte const   )16,      (png_byte const   )16,      (png_byte const   )16,      (png_byte const   )16,
        (png_byte const   )15,      (png_byte const   )15,      (png_byte const   )15,      (png_byte const   )15,
        (png_byte const   )15,      (png_byte const   )15,      (png_byte const   )15,      (png_byte const   )15,
        (png_byte const   )15,      (png_byte const   )15,      (png_byte const   )15,      (png_byte const   )15,
        (png_byte const   )15,      (png_byte const   )15,      (png_byte const   )15,      (png_byte const   )15,
        (png_byte const   )14,      (png_byte const   )14,      (png_byte const   )14,      (png_byte const   )14,
        (png_byte const   )14,      (png_byte const   )14,      (png_byte const   )14,      (png_byte const   )14,
        (png_byte const   )14,      (png_byte const   )14,      (png_byte const   )14,      (png_byte const   )14,
        (png_byte const   )14,      (png_byte const   )14,      (png_byte const   )14,      (png_byte const   )14,
        (png_byte const   )14,      (png_byte const   )14,      (png_byte const   )14,      (png_byte const   )13,
        (png_byte const   )13,      (png_byte const   )13,      (png_byte const   )13,      (png_byte const   )13,
        (png_byte const   )13,      (png_byte const   )13,      (png_byte const   )13,      (png_byte const   )13,
        (png_byte const   )13,      (png_byte const   )13,      (png_byte const   )13,      (png_byte const   )13,
        (png_byte const   )13,      (png_byte const   )13,      (png_byte const   )13,      (png_byte const   )13,
        (png_byte const   )13,      (png_byte const   )13,      (png_byte const   )13,      (png_byte const   )13,
        (png_byte const   )13,      (png_byte const   )13,      (png_byte const   )12,      (png_byte const   )12,
        (png_byte const   )12,      (png_byte const   )12,      (png_byte const   )12,      (png_byte const   )12,
        (png_byte const   )12,      (png_byte const   )12,      (png_byte const   )12,      (png_byte const   )12,
        (png_byte const   )12,      (png_byte const   )12,      (png_byte const   )12,      (png_byte const   )12,
        (png_byte const   )12,      (png_byte const   )12,      (png_byte const   )12,      (png_byte const   )12,
        (png_byte const   )12,      (png_byte const   )12,      (png_byte const   )12,      (png_byte const   )12,
        (png_byte const   )12,      (png_byte const   )12,      (png_byte const   )12,      (png_byte const   )12,
        (png_byte const   )12,      (png_byte const   )12,      (png_byte const   )12,      (png_byte const   )12,
        (png_byte const   )11,      (png_byte const   )11,      (png_byte const   )11,      (png_byte const   )11,
        (png_byte const   )11,      (png_byte const   )11,      (png_byte const   )11,      (png_byte const   )11,
        (png_byte const   )11,      (png_byte const   )11,      (png_byte const   )11,      (png_byte const   )11,
        (png_byte const   )11,      (png_byte const   )11,      (png_byte const   )11,      (png_byte const   )11,
        (png_byte const   )11,      (png_byte const   )11,      (png_byte const   )11,      (png_byte const   )11,
        (png_byte const   )11,      (png_byte const   )11,      (png_byte const   )11,      (png_byte const   )11,
        (png_byte const   )11,      (png_byte const   )11,      (png_byte const   )11,      (png_byte const   )11,
        (png_byte const   )11,      (png_byte const   )11,      (png_byte const   )11,      (png_byte const   )11,
        (png_byte const   )11,      (png_byte const   )11,      (png_byte const   )11,      (png_byte const   )11,
        (png_byte const   )11,      (png_byte const   )10,      (png_byte const   )10,      (png_byte const   )10,
        (png_byte const   )10,      (png_byte const   )10,      (png_byte const   )10,      (png_byte const   )10,
        (png_byte const   )10,      (png_byte const   )10,      (png_byte const   )10,      (png_byte const   )10,
        (png_byte const   )10,      (png_byte const   )10,      (png_byte const   )10,      (png_byte const   )10,
        (png_byte const   )10,      (png_byte const   )10,      (png_byte const   )10,      (png_byte const   )10,
        (png_byte const   )10,      (png_byte const   )10,      (png_byte const   )10,      (png_byte const   )10,
        (png_byte const   )10,      (png_byte const   )10,      (png_byte const   )10,      (png_byte const   )10,
        (png_byte const   )10,      (png_byte const   )10,      (png_byte const   )10,      (png_byte const   )10,
        (png_byte const   )10,      (png_byte const   )10,      (png_byte const   )10,      (png_byte const   )10,
        (png_byte const   )10,      (png_byte const   )10,      (png_byte const   )10,      (png_byte const   )10,
        (png_byte const   )10,      (png_byte const   )10,      (png_byte const   )10,      (png_byte const   )10,
        (png_byte const   )10,      (png_byte const   )10,      (png_byte const   )10,      (png_byte const   )10,
        (png_byte const   )10,      (png_byte const   )9,      (png_byte const   )9,      (png_byte const   )9,
        (png_byte const   )9,      (png_byte const   )9,      (png_byte const   )9,      (png_byte const   )9,
        (png_byte const   )9,      (png_byte const   )9,      (png_byte const   )9,      (png_byte const   )9,
        (png_byte const   )9,      (png_byte const   )9,      (png_byte const   )9,      (png_byte const   )9,
        (png_byte const   )9,      (png_byte const   )9,      (png_byte const   )9,      (png_byte const   )9,
        (png_byte const   )9,      (png_byte const   )9,      (png_byte const   )9,      (png_byte const   )9,
        (png_byte const   )9,      (png_byte const   )9,      (png_byte const   )9,      (png_byte const   )9,
        (png_byte const   )9,      (png_byte const   )9,      (png_byte const   )9,      (png_byte const   )9,
        (png_byte const   )9,      (png_byte const   )9,      (png_byte const   )9,      (png_byte const   )9,
        (png_byte const   )9,      (png_byte const   )9,      (png_byte const   )9,      (png_byte const   )9,
        (png_byte const   )9,      (png_byte const   )9,      (png_byte const   )9,      (png_byte const   )9,
        (png_byte const   )9,      (png_byte const   )9,      (png_byte const   )9,      (png_byte const   )9,
        (png_byte const   )9,      (png_byte const   )9,      (png_byte const   )9,      (png_byte const   )9,
        (png_byte const   )9,      (png_byte const   )9,      (png_byte const   )9,      (png_byte const   )9,
        (png_byte const   )9,      (png_byte const   )9,      (png_byte const   )9,      (png_byte const   )9,
        (png_byte const   )9,      (png_byte const   )9,      (png_byte const   )9,      (png_byte const   )9,
        (png_byte const   )9,      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,
        (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,
        (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,
        (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,
        (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,
        (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,
        (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,
        (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,
        (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,
        (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,
        (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,
        (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,
        (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,
        (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,
        (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,
        (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,
        (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,
        (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,
        (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,
        (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,
        (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,
        (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,
        (png_byte const   )8,      (png_byte const   )7,      (png_byte const   )7,      (png_byte const   )7,
        (png_byte const   )7,      (png_byte const   )7,      (png_byte const   )7,      (png_byte const   )7,
        (png_byte const   )7,      (png_byte const   )7,      (png_byte const   )7,      (png_byte const   )7,
        (png_byte const   )7,      (png_byte const   )7,      (png_byte const   )7,      (png_byte const   )7,
        (png_byte const   )7,      (png_byte const   )7,      (png_byte const   )7,      (png_byte const   )7,
        (png_byte const   )7,      (png_byte const   )7,      (png_byte const   )7,      (png_byte const   )7,
        (png_byte const   )7,      (png_byte const   )7,      (png_byte const   )7,      (png_byte const   )7,
        (png_byte const   )7,      (png_byte const   )7,      (png_byte const   )7,      (png_byte const   )7,
        (png_byte const   )7,      (png_byte const   )7,      (png_byte const   )7,      (png_byte const   )7,
        (png_byte const   )7,      (png_byte const   )7,      (png_byte const   )7,      (png_byte const   )7,
        (png_byte const   )7,      (png_byte const   )7,      (png_byte const   )7,      (png_byte const   )7,
        (png_byte const   )7,      (png_byte const   )7,      (png_byte const   )7,      (png_byte const   )7,
        (png_byte const   )7,      (png_byte const   )7,      (png_byte const   )7,      (png_byte const   )7,
        (png_byte const   )7,      (png_byte const   )7,      (png_byte const   )7,      (png_byte const   )7};
#line 4521 "/home/goblint2/bench/libpng-1.6.39/png.c"
static int png_image_free_function(png_voidp argument )
{
  png_imagep image ;
  png_controlp cp ;
  png_control c ;
  FILE *fp ;

  {
#line 4524
  image = (png_imagep )argument;
#line 4525
  cp = image->opaque;
#line 4531
  if ((unsigned long )cp->png_ptr == (unsigned long )((void *)0)) {
#line 4532
    return (0);
  }
#line 4536
  if (cp->owned_file != 0U) {
#line 4538
    fp = (FILE *)(cp->png_ptr)->io_ptr;
#line 4539
    cp->owned_file = 0U;
#line 4542
    if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 4544
      (cp->png_ptr)->io_ptr = (void *)0;
#line 4545
      fclose(fp);
    }
  }
#line 4555
  c = *cp;
#line 4556
  image->opaque = & c;
#line 4557
  png_free((png_const_structrp )c.png_ptr, (png_voidp )cp);
#line 4560
  if (c.for_write != 0U) {
#line 4563
    png_destroy_write_struct(& c.png_ptr, & c.info_ptr);
  } else {
#line 4571
    png_destroy_read_struct(& c.png_ptr, & c.info_ptr, (png_infopp )((void *)0));
  }
#line 4578
  return (1);
}
}
#line 4581 "/home/goblint2/bench/libpng-1.6.39/png.c"
void png_image_free(png_imagep image )
{


  {
#line 4588
  if ((unsigned long )image != (unsigned long )((void *)0)) {
#line 4588
    if ((unsigned long )image->opaque != (unsigned long )((void *)0)) {
#line 4588
      if ((unsigned long )(image->opaque)->error_buf == (unsigned long )((void *)0)) {
#line 4591
        png_image_free_function((png_voidp )image);
#line 4592
        image->opaque = (png_controlp )((void *)0);
      }
    }
  }
#line 4594
  return;
}
}
#line 4596 "/home/goblint2/bench/libpng-1.6.39/png.c"
int png_image_error(png_imagep image , png_const_charp error_message )
{


  {
#line 4600
  png_safecat(image->message, sizeof(image->message), (size_t )0, error_message);
#line 4601
  image->warning_or_error |= 2U;
#line 4602
  png_image_free(image);
#line 4603
  return (0);
}
}
#line 101 "/usr/include/stdlib.h"
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 104
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 107
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 112
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__leaf__, __gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__,
__nothrow__)) ;
#line 820
__inline extern void *( __attribute__((__warn_unused_result__, __nonnull__(1,2,5),
__gnu_inline__)) bsearch)(void const   *__key , void const   *__base , size_t __nmemb ,
                          size_t __size , int (*__compar)(void const   * , void const   * ) ) ;
#line 929
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar )  __attribute__((__nothrow__)) ;
#line 933
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t *__dst , char const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 936
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) wcstombs)(char *__dst , wchar_t const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 43 "/usr/include/string.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memcpy)(void *__dest , void const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 47
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 61
__inline extern void *( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) memset)(void *__dest , int __ch , size_t __len )  __attribute__((__nothrow__)) ;
#line 122
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcpy)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 125
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncpy)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 130
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcat)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 133
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncat)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 326 "/usr/include/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) fprintf)(FILE *__stream ,
                                                                                                  char const   *__fmt
                                                                                                  , ...) ;
#line 332
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) printf)(char const   *__fmt
                                                                                                 , ...) ;
#line 334
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) sprintf)(char *__s ,
                                                                                                            char const   *__fmt
                                                                                                            , ...)  __attribute__((__nothrow__)) ;
#line 341
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vfprintf)(FILE *__stream ,
                                                                                                   char const   *__fmt ,
                                                                                                   __gnuc_va_list __ap ) ;
#line 347
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vprintf)(char const   *__fmt ,
                                                                                                  __gnuc_va_list __ap ) ;
#line 349
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vsprintf)(char *__s ,
                                                                                                             char const   *__fmt ,
                                                                                                             __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 354
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) snprintf)(char *__s , size_t __n , char const   *__fmt
                                              , ...)  __attribute__((__nothrow__)) ;
#line 358
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) vsnprintf)(char *__s , size_t __n , char const   *__fmt ,
                                               __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 492
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
#line 528
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
#line 564
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fgets)(char *__s , int __n , FILE *__stream ) ;
#line 646
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fread)(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 360 "/usr/include/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) read)(int __fd , void *__buf , size_t __nbytes ) ;
#line 511
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size )  __attribute__((__nothrow__)) ;
#line 689
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list )  __attribute__((__nothrow__)) ;
#line 774
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                               size_t __buflen )  __attribute__((__nothrow__)) ;
#line 23 "/home/goblint2/bench/libpng-1.6.39/pngerror.c"
static void png_default_error(png_const_structrp png_ptr , png_const_charp error_message )  __attribute__((__noreturn__)) ;
#line 28
static void png_default_warning(png_const_structrp png_ptr , png_const_charp warning_message ) ;
#line 38
void png_error(png_const_structrp png_ptr , png_const_charp error_message )  __attribute__((__noreturn__)) ;
#line 38 "/home/goblint2/bench/libpng-1.6.39/pngerror.c"
void png_error(png_const_structrp png_ptr , png_const_charp error_message )
{


  {
#line 82
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 82
    if ((unsigned long )png_ptr->error_fn != (unsigned long )((void *)0)) {
#line 83
      (*(png_ptr->error_fn))((png_structp )((png_structrp )((void *)((void const   *)png_ptr))),
                             error_message);
    }
  }
#line 88
  png_default_error(png_ptr, error_message);
}
}
#line 111 "/home/goblint2/bench/libpng-1.6.39/pngerror.c"
size_t png_safecat(png_charp buffer___0 , size_t bufsize , size_t pos , png_const_charp string )
{
  size_t tmp ;
  png_const_charp tmp___0 ;

  {
#line 115
  if ((unsigned long )buffer___0 != (unsigned long )((void *)0)) {
#line 115
    if (pos < bufsize) {
#line 117
      if ((unsigned long )string != (unsigned long )((void *)0)) {
        {
#line 118
        while (1) {
          while_continue: /* CIL Label */ ;
#line 118
          if ((int const   )*string != 0) {
#line 118
            if (! (pos < bufsize - 1UL)) {
#line 118
              goto while_break;
            }
          } else {
#line 118
            goto while_break;
          }
#line 119
          tmp = pos;
#line 119
          pos ++;
#line 119
          tmp___0 = string;
#line 119
          string ++;
#line 119
          *(buffer___0 + tmp) = (char )*tmp___0;
        }
        while_break: /* CIL Label */ ;
        }
      }
#line 121
      *(buffer___0 + pos) = (char )'\000';
    }
  }
#line 124
  return (pos);
}
}
#line 148 "/home/goblint2/bench/libpng-1.6.39/pngerror.c"
static char const   digits[17]  =
#line 148
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3',
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7',
        (char const   )'8',      (char const   )'9',      (char const   )'A',      (char const   )'B',
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F',
        (char const   )'\000'};
#line 132 "/home/goblint2/bench/libpng-1.6.39/pngerror.c"
png_charp png_format_number(png_const_charp start , png_charp end , int format , png_alloc_size_t number )
{
  int count ;
  int mincount ;
  int output ;

  {
#line 136
  count = 0;
#line 137
  mincount = 1;
#line 138
  output = 0;
#line 140
  end --;
#line 140
  *end = (char )'\000';
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if ((unsigned long )end > (unsigned long )start) {
#line 145
      if (! (number != 0UL)) {
#line 145
        if (! (count < mincount)) {
#line 145
          goto while_break;
        }
      }
    } else {
#line 145
      goto while_break;
    }
    {
#line 152
    if (format == 5) {
#line 152
      goto case_5;
    }
#line 163
    if (format == 2) {
#line 163
      goto case_2;
    }
#line 168
    if (format == 1) {
#line 168
      goto case_1;
    }
#line 173
    if (format == 4) {
#line 173
      goto case_4;
    }
#line 178
    if (format == 3) {
#line 178
      goto case_3;
    }
#line 183
    goto switch_default;
    case_5: /* CIL Label */
#line 154
    mincount = 5;
#line 155
    if (output != 0) {
#line 157
      end --;
#line 157
      *end = (char )digits[number % 10UL];
#line 158
      output = 1;
    } else
#line 155
    if (number % 10UL != 0UL) {
#line 157
      end --;
#line 157
      *end = (char )digits[number % 10UL];
#line 158
      output = 1;
    }
#line 160
    number /= 10UL;
#line 161
    goto switch_break;
    case_2: /* CIL Label */
#line 165
    mincount = 2;
    case_1: /* CIL Label */
#line 169
    end --;
#line 169
    *end = (char )digits[number % 10UL];
#line 170
    number /= 10UL;
#line 171
    goto switch_break;
    case_4: /* CIL Label */
#line 175
    mincount = 2;
    case_3: /* CIL Label */
#line 179
    end --;
#line 179
    *end = (char )digits[number & 15UL];
#line 180
    number >>= 4;
#line 181
    goto switch_break;
    switch_default: /* CIL Label */
#line 184
    number = (png_alloc_size_t )0;
#line 185
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 189
    count ++;
#line 192
    if (format == 5) {
#line 192
      if (count == 5) {
#line 192
        if ((unsigned long )end > (unsigned long )start) {
#line 198
          if (output != 0) {
#line 199
            end --;
#line 199
            *end = (char )'.';
          } else
#line 200
          if (number == 0UL) {
#line 201
            end --;
#line 201
            *end = (char )'0';
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  return (end);
}
}
#line 215 "/home/goblint2/bench/libpng-1.6.39/pngerror.c"
void png_warning(png_const_structrp png_ptr , png_const_charp warning_message )
{
  int offset ;

  {
#line 218
  offset = 0;
#line 219
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 226
    if ((int const   )*warning_message == 35) {
#line 228
      offset = 1;
      {
#line 228
      while (1) {
        while_continue: /* CIL Label */ ;
#line 228
        if (! (offset < 15)) {
#line 228
          goto while_break;
        }
#line 229
        if ((int const   )*(warning_message + offset) == 32) {
#line 230
          goto while_break;
        }
#line 228
        offset ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 234
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 234
    if ((unsigned long )png_ptr->warning_fn != (unsigned long )((void *)0)) {
#line 235
      (*(png_ptr->warning_fn))((png_structp )((png_structrp )((void *)((void const   *)png_ptr))),
                               warning_message + offset);
    } else {
#line 238
      png_default_warning(png_ptr, warning_message + offset);
    }
  } else {
#line 238
    png_default_warning(png_ptr, warning_message + offset);
  }
#line 239
  return;
}
}
#line 246 "/home/goblint2/bench/libpng-1.6.39/pngerror.c"
void png_warning_parameter(char (*p)[32] , int number , png_const_charp string )
{


  {
#line 250
  if (number > 0) {
#line 250
    if (number <= 8) {
#line 251
      png_safecat(*(p + (number - 1)), sizeof(*(p + (number - 1))), (size_t )0, string);
    }
  }
#line 252
  return;
}
}
#line 254 "/home/goblint2/bench/libpng-1.6.39/pngerror.c"
void png_warning_parameter_unsigned(char (*p)[32] , int number , int format , png_alloc_size_t value )
{
  char buffer___0[24] ;
  png_charp tmp ;

  {
#line 259
  tmp = png_format_number((png_const_charp )(buffer___0), buffer___0 + sizeof(buffer___0),
                          format, value);
#line 259
  png_warning_parameter(p, number, (png_const_charp )tmp);
#line 260
  return;
}
}
#line 262 "/home/goblint2/bench/libpng-1.6.39/pngerror.c"
void png_warning_parameter_signed(char (*p)[32] , int number , int format , png_int_32 value )
{
  png_alloc_size_t u ;
  png_charp str ;
  char buffer___0[24] ;

  {
#line 271
  u = (png_alloc_size_t )value;
#line 272
  if (value < 0) {
#line 273
    u = ~ u + 1UL;
  }
#line 275
  str = png_format_number((png_const_charp )(buffer___0), buffer___0 + sizeof(buffer___0),
                          format, u);
#line 277
  if (value < 0) {
#line 277
    if ((unsigned long )str > (unsigned long )(buffer___0)) {
#line 278
      str --;
#line 278
      *str = (char )'-';
    }
  }
#line 280
  png_warning_parameter(p, number, (png_const_charp )str);
#line 281
  return;
}
}
#line 309 "/home/goblint2/bench/libpng-1.6.39/pngerror.c"
static char const   valid_parameters[10]  =
#line 309
  {      (char const   )'1',      (char const   )'2',      (char const   )'3',      (char const   )'4',
        (char const   )'5',      (char const   )'6',      (char const   )'7',      (char const   )'8',
        (char const   )'9',      (char const   )'\000'};
#line 283 "/home/goblint2/bench/libpng-1.6.39/pngerror.c"
void png_formatted_warning(png_const_structrp png_ptr , char (*p)[32] , png_const_charp message )
{
  size_t i ;
  char msg[192] ;
  int parameter_char ;
  int parameter ;
  png_const_charp parm ;
  png_const_charp pend ;
  size_t tmp ;
  png_const_charp tmp___0 ;
  size_t tmp___1 ;
  png_const_charp tmp___2 ;

  {
#line 292
  i = (size_t )0;
  {
#line 301
  while (1) {
    while_continue: /* CIL Label */ ;
#line 301
    if (i < sizeof(msg) - 1UL) {
#line 301
      if (! ((int const   )*message != 0)) {
#line 301
        goto while_break;
      }
    } else {
#line 301
      goto while_break;
    }
#line 306
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 306
      if ((int const   )*message == 64) {
#line 306
        if ((int const   )*(message + 1) != 0) {
#line 308
          message ++;
#line 308
          parameter_char = (int )*message;
#line 310
          parameter = 0;
          {
#line 315
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 315
            if ((int const   )valid_parameters[parameter] != (int const   )parameter_char) {
#line 315
              if (! ((int const   )valid_parameters[parameter] != 0)) {
#line 315
                goto while_break___0;
              }
            } else {
#line 315
              goto while_break___0;
            }
#line 317
            parameter ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 320
          if (parameter < 8) {
#line 323
            parm = (png_const_charp )(*(p + parameter));
#line 324
            pend = (png_const_charp )(*(p + parameter) + sizeof(*(p + parameter)));
            {
#line 330
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 330
              if (i < sizeof(msg) - 1UL) {
#line 330
                if ((int const   )*parm != 0) {
#line 330
                  if (! ((unsigned long )parm < (unsigned long )pend)) {
#line 330
                    goto while_break___1;
                  }
                } else {
#line 330
                  goto while_break___1;
                }
              } else {
#line 330
                goto while_break___1;
              }
#line 331
              tmp = i;
#line 331
              i ++;
#line 331
              tmp___0 = parm;
#line 331
              parm ++;
#line 331
              msg[tmp] = (char )*tmp___0;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 334
            message ++;
#line 335
            goto while_continue;
          }
        }
      }
    }
#line 346
    tmp___1 = i;
#line 346
    i ++;
#line 346
    tmp___2 = message;
#line 346
    message ++;
#line 346
    msg[tmp___1] = (char )*tmp___2;
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  msg[i] = (char )'\000';
#line 356
  png_warning(png_ptr, (png_const_charp )(msg));
#line 357
  return;
}
}
#line 361 "/home/goblint2/bench/libpng-1.6.39/pngerror.c"
void png_benign_error(png_const_structrp png_ptr , png_const_charp error_message )
{


  {
#line 364
  if ((png_ptr->flags & 1048576U) != 0U) {
#line 367
    if ((png_ptr->mode & 32768U) != 0U) {
#line 367
      if (png_ptr->chunk_name != 0U) {
#line 369
        png_chunk_warning(png_ptr, error_message);
      } else {
#line 372
        png_warning(png_ptr, error_message);
      }
    } else {
#line 372
      png_warning(png_ptr, error_message);
    }
  } else
#line 378
  if ((png_ptr->mode & 32768U) != 0U) {
#line 378
    if (png_ptr->chunk_name != 0U) {
#line 380
      png_chunk_error(png_ptr, error_message);
    } else {
#line 383
      png_error(png_ptr, error_message);
    }
  } else {
#line 383
    png_error(png_ptr, error_message);
  }
#line 389
  return;
}
}
#line 391 "/home/goblint2/bench/libpng-1.6.39/pngerror.c"
void png_app_warning(png_const_structrp png_ptr , png_const_charp error_message )
{


  {
#line 394
  if ((png_ptr->flags & 2097152U) != 0U) {
#line 395
    png_warning(png_ptr, error_message);
  } else {
#line 397
    png_error(png_ptr, error_message);
  }
#line 402
  return;
}
}
#line 404 "/home/goblint2/bench/libpng-1.6.39/pngerror.c"
void png_app_error(png_const_structrp png_ptr , png_const_charp error_message )
{


  {
#line 407
  if ((png_ptr->flags & 4194304U) != 0U) {
#line 408
    png_warning(png_ptr, error_message);
  } else {
#line 410
    png_error(png_ptr, error_message);
  }
#line 415
  return;
}
}
#line 428 "/home/goblint2/bench/libpng-1.6.39/pngerror.c"
static char const   png_digit[16]  =
#line 428
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3',
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7',
        (char const   )'8',      (char const   )'9',      (char const   )'A',      (char const   )'B',
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F'};
#line 433 "/home/goblint2/bench/libpng-1.6.39/pngerror.c"
static void png_format_buffer(png_const_structrp png_ptr , png_charp buffer___0 ,
                              png_const_charp error_message )
{
  png_uint_32 chunk_name ;
  int iout ;
  int ishift ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int iin ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 437
  chunk_name = (png_uint_32 )png_ptr->chunk_name;
#line 438
  iout = 0;
#line 438
  ishift = 24;
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 440
    if (! (ishift >= 0)) {
#line 440
      goto while_break;
    }
#line 442
    c = (int )(chunk_name >> ishift) & 0xff;
#line 444
    ishift -= 8;
#line 445
    if (c < 65) {
#line 445
      tmp___4 = 1;
    } else
#line 445
    if (c > 122) {
#line 445
      tmp___4 = 1;
    } else
#line 445
    if (c > 90) {
#line 445
      if (c < 97) {
#line 445
        tmp___4 = 1;
      } else {
#line 445
        tmp___4 = 0;
      }
    } else {
#line 445
      tmp___4 = 0;
    }
#line 445
    if (tmp___4 != 0) {
#line 447
      tmp = iout;
#line 447
      iout ++;
#line 447
      *(buffer___0 + tmp) = (char)91;
#line 448
      tmp___0 = iout;
#line 448
      iout ++;
#line 448
      *(buffer___0 + tmp___0) = (char )png_digit[(c & 0xf0) >> 4];
#line 449
      tmp___1 = iout;
#line 449
      iout ++;
#line 449
      *(buffer___0 + tmp___1) = (char )png_digit[c & 0x0f];
#line 450
      tmp___2 = iout;
#line 450
      iout ++;
#line 450
      *(buffer___0 + tmp___2) = (char)93;
    } else {
#line 455
      tmp___3 = iout;
#line 455
      iout ++;
#line 455
      *(buffer___0 + tmp___3) = (char )c;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 459
  if ((unsigned long )error_message == (unsigned long )((void *)0)) {
#line 460
    *(buffer___0 + iout) = (char )'\000';
  } else {
#line 464
    iin = 0;
#line 466
    tmp___5 = iout;
#line 466
    iout ++;
#line 466
    *(buffer___0 + tmp___5) = (char )':';
#line 467
    tmp___6 = iout;
#line 467
    iout ++;
#line 467
    *(buffer___0 + tmp___6) = (char )' ';
    {
#line 469
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 469
      if (iin < 195) {
#line 469
        if (! ((int const   )*(error_message + iin) != 0)) {
#line 469
          goto while_break___0;
        }
      } else {
#line 469
        goto while_break___0;
      }
#line 470
      tmp___7 = iout;
#line 470
      iout ++;
#line 470
      tmp___8 = iin;
#line 470
      iin ++;
#line 470
      *(buffer___0 + tmp___7) = (char )*(error_message + tmp___8);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 473
    *(buffer___0 + iout) = (char )'\000';
  }
#line 475
  return;
}
}
#line 479
void png_chunk_error(png_const_structrp png_ptr , png_const_charp error_message )  __attribute__((__noreturn__)) ;
#line 479 "/home/goblint2/bench/libpng-1.6.39/pngerror.c"
void png_chunk_error(png_const_structrp png_ptr , png_const_charp error_message )
{
  char msg[214] ;

  {
#line 484
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 485
    png_error(png_ptr, error_message);
  } else {
#line 489
    png_format_buffer(png_ptr, msg, error_message);
#line 490
    png_error(png_ptr, (png_const_charp )(msg));
  }
}
}
#line 496 "/home/goblint2/bench/libpng-1.6.39/pngerror.c"
void png_chunk_warning(png_const_structrp png_ptr , png_const_charp warning_message )
{
  char msg[214] ;

  {
#line 500
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 501
    png_warning(png_ptr, warning_message);
  } else {
#line 505
    png_format_buffer(png_ptr, msg, warning_message);
#line 506
    png_warning(png_ptr, (png_const_charp )(msg));
  }
#line 508
  return;
}
}
#line 513 "/home/goblint2/bench/libpng-1.6.39/pngerror.c"
void png_chunk_benign_error(png_const_structrp png_ptr , png_const_charp error_message )
{


  {
#line 517
  if ((png_ptr->flags & 1048576U) != 0U) {
#line 518
    png_chunk_warning(png_ptr, error_message);
  } else {
#line 521
    png_chunk_error(png_ptr, error_message);
  }
#line 526
  return;
}
}
#line 530 "/home/goblint2/bench/libpng-1.6.39/pngerror.c"
void png_chunk_report(png_const_structrp png_ptr , png_const_charp message , int error___0 )
{


  {
#line 541
  if ((png_ptr->mode & 32768U) != 0U) {
#line 546
    if (error___0 < 2) {
#line 547
      png_chunk_warning(png_ptr, message);
    } else {
#line 550
      png_chunk_benign_error(png_ptr, message);
    }
  } else
#line 555
  if ((png_ptr->mode & 32768U) == 0U) {
#line 560
    if (error___0 < 1) {
#line 561
      png_app_warning(png_ptr, message);
    } else {
#line 564
      png_app_error(png_ptr, message);
    }
  }
#line 567
  return;
}
}
#line 571
void png_fixed_error(png_const_structrp png_ptr , png_const_charp name )  __attribute__((__noreturn__)) ;
#line 571 "/home/goblint2/bench/libpng-1.6.39/pngerror.c"
void png_fixed_error(png_const_structrp png_ptr , png_const_charp name )
{
  unsigned int iin ;
  char msg[(sizeof("fixed point overflow in ") - 1UL) + 196UL] ;

  {
#line 578
  memcpy((void *)(msg), (void const   *)"fixed point overflow in ", sizeof("fixed point overflow in ") - 1UL);
#line 579
  iin = 0U;
#line 580
  if ((unsigned long )name != (unsigned long )((void *)0)) {
    {
#line 581
    while (1) {
      while_continue: /* CIL Label */ ;
#line 581
      if (iin < 195U) {
#line 581
        if (! ((int const   )*(name + iin) != 0)) {
#line 581
          goto while_break;
        }
      } else {
#line 581
        goto while_break;
      }
#line 583
      msg[(sizeof("fixed point overflow in ") - 1UL) + (unsigned long )iin] = (char )*(name + iin);
#line 584
      iin ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 586
  msg[(sizeof("fixed point overflow in ") - 1UL) + (unsigned long )iin] = (char)0;
#line 587
  png_error(png_ptr, (png_const_charp )(msg));
}
}
#line 596 "/home/goblint2/bench/libpng-1.6.39/pngerror.c"
jmp_buf *png_set_longjmp_fn(png_structrp png_ptr , void (*longjmp_fn)(struct __jmp_buf_tag * ,
                                                                      int  ) , size_t jmp_buf_size )
{
  png_voidp __attribute__((__malloc__))  tmp ;
  size_t size ;

  {
#line 610
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 611
    return ((jmp_buf *)((void *)0));
  }
#line 613
  if ((unsigned long )png_ptr->jmp_buf_ptr == (unsigned long )((void *)0)) {
#line 615
    png_ptr->jmp_buf_size = (size_t )0;
#line 617
    if (jmp_buf_size <= sizeof(png_ptr->jmp_buf_local)) {
#line 618
      png_ptr->jmp_buf_ptr = & png_ptr->jmp_buf_local;
    } else {
#line 622
      tmp = png_malloc_warn((png_const_structrp )png_ptr, jmp_buf_size);
#line 622
      png_ptr->jmp_buf_ptr = (jmp_buf *)tmp;
#line 625
      if ((unsigned long )png_ptr->jmp_buf_ptr == (unsigned long )((void *)0)) {
#line 626
        return ((jmp_buf *)((void *)0));
      }
#line 628
      png_ptr->jmp_buf_size = jmp_buf_size;
    }
  } else {
#line 634
    size = png_ptr->jmp_buf_size;
#line 636
    if (size == 0UL) {
#line 638
      size = sizeof(png_ptr->jmp_buf_local);
#line 639
      if ((unsigned long )png_ptr->jmp_buf_ptr != (unsigned long )(& png_ptr->jmp_buf_local)) {
#line 646
        png_error((png_const_structrp )png_ptr, (png_const_charp )"Libpng jmp_buf still allocated");
      }
    }
#line 651
    if (size != jmp_buf_size) {
#line 653
      png_warning((png_const_structrp )png_ptr, (png_const_charp )"Application jmp_buf size changed");
#line 654
      return ((jmp_buf *)((void *)0));
    }
  }
#line 661
  png_ptr->longjmp_fn = longjmp_fn;
#line 662
  return (png_ptr->jmp_buf_ptr);
}
}
#line 665 "/home/goblint2/bench/libpng-1.6.39/pngerror.c"
void png_free_jmpbuf(png_structrp png_ptr )
{
  jmp_buf *jb ;
  jmp_buf free_jmp_buf ;
  int tmp ;

  {
#line 668
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 670
    jb = png_ptr->jmp_buf_ptr;
#line 675
    if ((unsigned long )jb != (unsigned long )((void *)0)) {
#line 675
      if (png_ptr->jmp_buf_size > 0UL) {
#line 682
        if ((unsigned long )jb != (unsigned long )(& png_ptr->jmp_buf_local)) {
#line 687
          tmp = _setjmp((struct __jmp_buf_tag *)(free_jmp_buf));
#line 687
          if (! tmp) {
#line 689
            png_ptr->jmp_buf_ptr = & free_jmp_buf;
#line 690
            png_ptr->jmp_buf_size = (size_t )0;
#line 691
            png_ptr->longjmp_fn = & longjmp;
#line 692
            png_free((png_const_structrp )png_ptr, (png_voidp )jb);
          }
        }
      }
    }
#line 698
    png_ptr->jmp_buf_size = (size_t )0;
#line 699
    png_ptr->jmp_buf_ptr = (jmp_buf *)((void *)0);
#line 700
    png_ptr->longjmp_fn = (void (*)(struct __jmp_buf_tag * , int  ))0;
  }
#line 702
  return;
}
}
#line 710
static void png_default_error(png_const_structrp png_ptr , png_const_charp error_message )  __attribute__((__noreturn__)) ;
#line 710 "/home/goblint2/bench/libpng-1.6.39/pngerror.c"
static void png_default_error(png_const_structrp png_ptr , png_const_charp error_message )
{
  char const   *tmp ;

  {
#line 747
  if (error_message) {
#line 747
    tmp = error_message;
  } else {
#line 747
    tmp = (char const   *)"undefined";
  }
#line 747
  fprintf(stderr, (char const   *)"libpng error: %s", tmp);
#line 749
  fprintf(stderr, (char const   *)"\n");
#line 754
  png_longjmp(png_ptr, 1);
}
}
#line 757
void png_longjmp(png_const_structrp png_ptr , int val )  __attribute__((__noreturn__)) ;
#line 757 "/home/goblint2/bench/libpng-1.6.39/pngerror.c"
void png_longjmp(png_const_structrp png_ptr , int val )
{


  {
#line 761
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 761
    if ((unsigned long )png_ptr->longjmp_fn != (unsigned long )((void *)0)) {
#line 761
      if ((unsigned long )png_ptr->jmp_buf_ptr != (unsigned long )((void *)0)) {
#line 763
        (*(png_ptr->longjmp_fn))((struct __jmp_buf_tag *)(*(png_ptr->jmp_buf_ptr)),
                                 val);
      }
    }
  }
#line 775
  abort();
}
}
#line 784 "/home/goblint2/bench/libpng-1.6.39/pngerror.c"
static void png_default_warning(png_const_structrp png_ptr , png_const_charp warning_message )
{


  {
#line 819
  fprintf(stderr, (char const   *)"libpng warning: %s", warning_message);
#line 820
  fprintf(stderr, (char const   *)"\n");
#line 826
  return;
}
}
#line 834 "/home/goblint2/bench/libpng-1.6.39/pngerror.c"
void png_set_error_fn(png_structrp png_ptr , png_voidp error_ptr , void (*error_fn)(png_structp  ,
                                                                                    png_const_charp  ) ,
                      void (*warning_fn)(png_structp  , png_const_charp  ) )
{


  {
#line 838
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 839
    return;
  }
#line 841
  png_ptr->error_ptr = error_ptr;
#line 842
  png_ptr->error_fn = error_fn;
#line 844
  png_ptr->warning_fn = warning_fn;
#line 848
  return;
}
}
#line 855 "/home/goblint2/bench/libpng-1.6.39/pngerror.c"
png_voidp png_get_error_ptr(png_const_structrp png_ptr )
{


  {
#line 858
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 859
    return ((void *)0);
  }
#line 861
  return ((png_voidp )png_ptr->error_ptr);
}
}
#line 884
void png_safe_error(png_structp png_nonconst_ptr , png_const_charp error_message )  __attribute__((__noreturn__)) ;
#line 884 "/home/goblint2/bench/libpng-1.6.39/pngerror.c"
void png_safe_error(png_structp png_nonconst_ptr , png_const_charp error_message )
{
  png_const_structrp png_ptr ;
  png_imagep image ;
  size_t pos ;
  size_t tmp ;

  {
#line 888
  png_ptr = (png_const_structrp )png_nonconst_ptr;
#line 889
  image = (png_imagep )png_ptr->error_ptr;
#line 894
  if ((unsigned long )image != (unsigned long )((void *)0)) {
#line 896
    png_safecat(image->message, sizeof(image->message), (size_t )0, error_message);
#line 897
    image->warning_or_error |= 2U;
#line 903
    if ((unsigned long )image->opaque != (unsigned long )((void *)0)) {
#line 903
      if ((unsigned long )(image->opaque)->error_buf != (unsigned long )((void *)0)) {
#line 904
        longjmp((struct __jmp_buf_tag *)(image->opaque)->error_buf, 1);
      }
    }
#line 908
    tmp = png_safecat(image->message, sizeof(image->message), (size_t )0, (png_const_charp )"bad longjmp: ");
#line 908
    pos = tmp;
#line 910
    png_safecat(image->message, sizeof(image->message), pos, error_message);
  }
#line 916
  abort();
}
}
#line 920 "/home/goblint2/bench/libpng-1.6.39/pngerror.c"
void png_safe_warning(png_structp png_nonconst_ptr , png_const_charp warning_message )
{
  png_const_structrp png_ptr ;
  png_imagep image ;

  {
#line 923
  png_ptr = (png_const_structrp )png_nonconst_ptr;
#line 924
  image = (png_imagep )png_ptr->error_ptr;
#line 927
  if (image->warning_or_error == 0U) {
#line 929
    png_safecat(image->message, sizeof(image->message), (size_t )0, warning_message);
#line 930
    image->warning_or_error |= 1U;
  }
#line 932
  return;
}
}
#line 935 "/home/goblint2/bench/libpng-1.6.39/pngerror.c"
int png_safe_execute(png_imagep image_in , int (*function)(png_voidp  ) , png_voidp arg )
{
  png_imagep volatile   image ;
  int volatile   result ;
  png_voidp volatile   saved_error_buf ;
  jmp_buf safe_jmpbuf ;
  int tmp ;
  int tmp___0 ;

  {
#line 938
  image = (png_imagep volatile   )image_in;
#line 944
  saved_error_buf = (png_voidp volatile   )(image->opaque)->error_buf;
#line 945
  tmp = _setjmp((struct __jmp_buf_tag *)(safe_jmpbuf));
#line 945
  result = (int volatile   )(tmp == 0);
#line 947
  if (result != (int volatile   )0) {
#line 950
    (image->opaque)->error_buf = (png_voidp )(safe_jmpbuf);
#line 951
    tmp___0 = (*function)(arg);
#line 951
    result = (int volatile   )tmp___0;
  }
#line 954
  (image->opaque)->error_buf = (png_voidp )saved_error_buf;
#line 957
  if (result == (int volatile   )0) {
#line 958
    png_image_free((png_imagep )image);
  }
#line 960
  return ((int )result);
}
}
#line 101 "/usr/include/stdlib.h"
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 104
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 107
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 112
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__leaf__, __gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__,
__nothrow__)) ;
#line 820
__inline extern void *( __attribute__((__warn_unused_result__, __nonnull__(1,2,5),
__gnu_inline__)) bsearch)(void const   *__key , void const   *__base , size_t __nmemb ,
                          size_t __size , int (*__compar)(void const   * , void const   * ) ) ;
#line 929
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar )  __attribute__((__nothrow__)) ;
#line 933
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t *__dst , char const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 936
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) wcstombs)(char *__dst , wchar_t const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 43 "/usr/include/string.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memcpy)(void *__dest , void const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 47
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 61
__inline extern void *( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) memset)(void *__dest , int __ch , size_t __len )  __attribute__((__nothrow__)) ;
#line 122
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcpy)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 125
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncpy)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 130
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcat)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 133
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncat)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 326 "/usr/include/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) fprintf)(FILE *__stream ,
                                                                                                  char const   *__fmt
                                                                                                  , ...) ;
#line 332
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) printf)(char const   *__fmt
                                                                                                 , ...) ;
#line 334
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) sprintf)(char *__s ,
                                                                                                            char const   *__fmt
                                                                                                            , ...)  __attribute__((__nothrow__)) ;
#line 341
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vfprintf)(FILE *__stream ,
                                                                                                   char const   *__fmt ,
                                                                                                   __gnuc_va_list __ap ) ;
#line 347
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vprintf)(char const   *__fmt ,
                                                                                                  __gnuc_va_list __ap ) ;
#line 349
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vsprintf)(char *__s ,
                                                                                                             char const   *__fmt ,
                                                                                                             __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 354
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) snprintf)(char *__s , size_t __n , char const   *__fmt
                                              , ...)  __attribute__((__nothrow__)) ;
#line 358
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) vsnprintf)(char *__s , size_t __n , char const   *__fmt ,
                                               __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 492
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
#line 528
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
#line 564
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fgets)(char *__s , int __n , FILE *__stream ) ;
#line 646
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fread)(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 360 "/usr/include/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) read)(int __fd , void *__buf , size_t __nbytes ) ;
#line 511
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size )  __attribute__((__nothrow__)) ;
#line 689
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list )  __attribute__((__nothrow__)) ;
#line 774
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                               size_t __buflen )  __attribute__((__nothrow__)) ;
#line 19 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_uint_32 png_get_valid(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                          png_uint_32 flag )
{


  {
#line 23
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 23
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 24
      return ((png_uint_32 )(info_ptr->valid & (unsigned int )flag));
    }
  }
#line 26
  return ((png_uint_32 )0);
}
}
#line 29 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
size_t png_get_rowbytes(png_const_structrp png_ptr , png_const_inforp info_ptr )
{


  {
#line 32
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 32
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 33
      return ((size_t )info_ptr->rowbytes);
    }
  }
#line 35
  return ((size_t )0);
}
}
#line 39 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_bytepp png_get_rows(png_const_structrp png_ptr , png_const_inforp info_ptr )
{


  {
#line 42
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 42
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 43
      return ((png_bytepp )info_ptr->row_pointers);
    }
  }
#line 45
  return ((png_bytepp )0);
}
}
#line 51 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_uint_32 png_get_image_width(png_const_structrp png_ptr , png_const_inforp info_ptr )
{


  {
#line 54
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 54
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 55
      return ((png_uint_32 )info_ptr->width);
    }
  }
#line 57
  return ((png_uint_32 )0);
}
}
#line 60 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_uint_32 png_get_image_height(png_const_structrp png_ptr , png_const_inforp info_ptr )
{


  {
#line 63
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 63
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 64
      return ((png_uint_32 )info_ptr->height);
    }
  }
#line 66
  return ((png_uint_32 )0);
}
}
#line 69 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_byte png_get_bit_depth(png_const_structrp png_ptr , png_const_inforp info_ptr )
{


  {
#line 72
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 72
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 73
      return ((png_byte )info_ptr->bit_depth);
    }
  }
#line 75
  return ((png_byte )0);
}
}
#line 78 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_byte png_get_color_type(png_const_structrp png_ptr , png_const_inforp info_ptr )
{


  {
#line 81
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 81
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 82
      return ((png_byte )info_ptr->color_type);
    }
  }
#line 84
  return ((png_byte )0);
}
}
#line 87 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_byte png_get_filter_type(png_const_structrp png_ptr , png_const_inforp info_ptr )
{


  {
#line 90
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 90
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 91
      return ((png_byte )info_ptr->filter_type);
    }
  }
#line 93
  return ((png_byte )0);
}
}
#line 96 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_byte png_get_interlace_type(png_const_structrp png_ptr , png_const_inforp info_ptr )
{


  {
#line 99
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 99
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 100
      return ((png_byte )info_ptr->interlace_type);
    }
  }
#line 102
  return ((png_byte )0);
}
}
#line 105 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_byte png_get_compression_type(png_const_structrp png_ptr , png_const_inforp info_ptr )
{


  {
#line 108
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 108
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 109
      return ((png_byte )info_ptr->compression_type);
    }
  }
#line 111
  return ((png_byte )0);
}
}
#line 114 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_uint_32 png_get_x_pixels_per_meter(png_const_structrp png_ptr , png_const_inforp info_ptr )
{


  {
#line 119
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 119
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 119
      if ((info_ptr->valid & 128U) != 0U) {
#line 125
        if ((int )info_ptr->phys_unit_type == 1) {
#line 126
          return ((png_uint_32 )info_ptr->x_pixels_per_unit);
        }
      }
    }
  }
#line 133
  return ((png_uint_32 )0);
}
}
#line 136 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_uint_32 png_get_y_pixels_per_meter(png_const_structrp png_ptr , png_const_inforp info_ptr )
{


  {
#line 141
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 141
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 141
      if ((info_ptr->valid & 128U) != 0U) {
#line 147
        if ((int )info_ptr->phys_unit_type == 1) {
#line 148
          return ((png_uint_32 )info_ptr->y_pixels_per_unit);
        }
      }
    }
  }
#line 155
  return ((png_uint_32 )0);
}
}
#line 158 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_uint_32 png_get_pixels_per_meter(png_const_structrp png_ptr , png_const_inforp info_ptr )
{


  {
#line 162
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 162
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 162
      if ((info_ptr->valid & 128U) != 0U) {
#line 167
        if ((int )info_ptr->phys_unit_type == 1) {
#line 167
          if (info_ptr->x_pixels_per_unit == info_ptr->y_pixels_per_unit) {
#line 169
            return ((png_uint_32 )info_ptr->x_pixels_per_unit);
          }
        }
      }
    }
  }
#line 176
  return ((png_uint_32 )0);
}
}
#line 180 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
float png_get_pixel_aspect_ratio(png_const_structrp png_ptr , png_const_inforp info_ptr )
{


  {
#line 185
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 185
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 185
      if ((info_ptr->valid & 128U) != 0U) {
#line 190
        if (info_ptr->x_pixels_per_unit != 0U) {
#line 191
          return ((float )info_ptr->y_pixels_per_unit / (float )info_ptr->x_pixels_per_unit);
        }
      }
    }
  }
#line 199
  return ((float )0.0);
}
}
#line 204 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_fixed_point png_get_pixel_aspect_ratio_fixed(png_const_structrp png_ptr , png_const_inforp info_ptr )
{
  png_fixed_point res ;
  int tmp ;

  {
#line 209
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 209
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 209
      if ((info_ptr->valid & 128U) != 0U) {
#line 209
        if (info_ptr->x_pixels_per_unit > 0U) {
#line 209
          if (info_ptr->y_pixels_per_unit > 0U) {
#line 209
            if (info_ptr->x_pixels_per_unit <= 2147483647U) {
#line 209
              if (info_ptr->y_pixels_per_unit <= 2147483647U) {
#line 222
                tmp = png_muldiv(& res, (png_int_32 )info_ptr->y_pixels_per_unit,
                                 100000, (png_int_32 )info_ptr->x_pixels_per_unit);
#line 222
                if (tmp != 0) {
#line 224
                  return (res);
                }
              }
            }
          }
        }
      }
    }
  }
#line 231
  return (0);
}
}
#line 235 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_int_32 png_get_x_offset_microns(png_const_structrp png_ptr , png_const_inforp info_ptr )
{


  {
#line 239
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 239
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 239
      if ((info_ptr->valid & 256U) != 0U) {
#line 244
        if ((int )info_ptr->offset_unit_type == 1) {
#line 245
          return ((png_int_32 )info_ptr->x_offset);
        }
      }
    }
  }
#line 252
  return (0);
}
}
#line 255 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_int_32 png_get_y_offset_microns(png_const_structrp png_ptr , png_const_inforp info_ptr )
{


  {
#line 259
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 259
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 259
      if ((info_ptr->valid & 256U) != 0U) {
#line 264
        if ((int )info_ptr->offset_unit_type == 1) {
#line 265
          return ((png_int_32 )info_ptr->y_offset);
        }
      }
    }
  }
#line 272
  return (0);
}
}
#line 275 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_int_32 png_get_x_offset_pixels(png_const_structrp png_ptr , png_const_inforp info_ptr )
{


  {
#line 279
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 279
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 279
      if ((info_ptr->valid & 256U) != 0U) {
#line 284
        if ((int )info_ptr->offset_unit_type == 0) {
#line 285
          return ((png_int_32 )info_ptr->x_offset);
        }
      }
    }
  }
#line 292
  return (0);
}
}
#line 295 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_int_32 png_get_y_offset_pixels(png_const_structrp png_ptr , png_const_inforp info_ptr )
{


  {
#line 299
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 299
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 299
      if ((info_ptr->valid & 256U) != 0U) {
#line 304
        if ((int )info_ptr->offset_unit_type == 0) {
#line 305
          return ((png_int_32 )info_ptr->y_offset);
        }
      }
    }
  }
#line 312
  return (0);
}
}
#line 316 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
static png_uint_32 ppi_from_ppm(png_uint_32 ppm )
{
  png_fixed_point result ;
  int tmp ;

  {
#line 339
  if (ppm <= 2147483647U) {
#line 339
    tmp = png_muldiv(& result, (png_int_32 )ppm, 127, 5000);
#line 339
    if (tmp != 0) {
#line 341
      return ((png_uint_32 )result);
    }
  }
#line 344
  return ((png_uint_32 )0);
}
}
#line 348 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_uint_32 png_get_pixels_per_inch(png_const_structrp png_ptr , png_const_inforp info_ptr )
{
  png_uint_32 tmp ;
  png_uint_32 tmp___0 ;

  {
#line 351
  tmp = png_get_pixels_per_meter(png_ptr, info_ptr);
#line 351
  tmp___0 = ppi_from_ppm(tmp);
#line 351
  return (tmp___0);
}
}
#line 354 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_uint_32 png_get_x_pixels_per_inch(png_const_structrp png_ptr , png_const_inforp info_ptr )
{
  png_uint_32 tmp ;
  png_uint_32 tmp___0 ;

  {
#line 357
  tmp = png_get_x_pixels_per_meter(png_ptr, info_ptr);
#line 357
  tmp___0 = ppi_from_ppm(tmp);
#line 357
  return (tmp___0);
}
}
#line 360 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_uint_32 png_get_y_pixels_per_inch(png_const_structrp png_ptr , png_const_inforp info_ptr )
{
  png_uint_32 tmp ;
  png_uint_32 tmp___0 ;

  {
#line 363
  tmp = png_get_y_pixels_per_meter(png_ptr, info_ptr);
#line 363
  tmp___0 = ppi_from_ppm(tmp);
#line 363
  return (tmp___0);
}
}
#line 367 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
static png_fixed_point png_fixed_inches_from_microns(png_const_structrp png_ptr ,
                                                     png_int_32 microns )
{
  png_fixed_point tmp ;

  {
#line 375
  tmp = png_muldiv_warn(png_ptr, microns, 500, 127);
#line 375
  return (tmp);
}
}
#line 378 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_fixed_point png_get_x_offset_inches_fixed(png_const_structrp png_ptr , png_const_inforp info_ptr )
{
  png_int_32 tmp ;
  png_fixed_point tmp___0 ;

  {
#line 382
  tmp = png_get_x_offset_microns(png_ptr, info_ptr);
#line 382
  tmp___0 = png_fixed_inches_from_microns(png_ptr, tmp);
#line 382
  return (tmp___0);
}
}
#line 388 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_fixed_point png_get_y_offset_inches_fixed(png_const_structrp png_ptr , png_const_inforp info_ptr )
{
  png_int_32 tmp ;
  png_fixed_point tmp___0 ;

  {
#line 392
  tmp = png_get_y_offset_microns(png_ptr, info_ptr);
#line 392
  tmp___0 = png_fixed_inches_from_microns(png_ptr, tmp);
#line 392
  return (tmp___0);
}
}
#line 398 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
float png_get_x_offset_inches(png_const_structrp png_ptr , png_const_inforp info_ptr )
{
  png_int_32 tmp ;

  {
#line 404
  tmp = png_get_x_offset_microns(png_ptr, info_ptr);
#line 404
  return ((float )((double )tmp * .00003937));
}
}
#line 409 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
float png_get_y_offset_inches(png_const_structrp png_ptr , png_const_inforp info_ptr )
{
  png_int_32 tmp ;

  {
#line 415
  tmp = png_get_y_offset_microns(png_ptr, info_ptr);
#line 415
  return ((float )((double )tmp * .00003937));
}
}
#line 420 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_uint_32 png_get_pHYs_dpi(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                             png_uint_32 *res_x , png_uint_32 *res_y , int *unit_type )
{
  png_uint_32 retval ;

  {
#line 424
  retval = (png_uint_32 )0;
#line 426
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 426
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 426
      if ((info_ptr->valid & 128U) != 0U) {
#line 431
        if ((unsigned long )res_x != (unsigned long )((void *)0)) {
#line 433
          *res_x = (png_uint_32 )info_ptr->x_pixels_per_unit;
#line 434
          retval |= 0x0080U;
        }
#line 437
        if ((unsigned long )res_y != (unsigned long )((void *)0)) {
#line 439
          *res_y = (png_uint_32 )info_ptr->y_pixels_per_unit;
#line 440
          retval |= 0x0080U;
        }
#line 443
        if ((unsigned long )unit_type != (unsigned long )((void *)0)) {
#line 445
          *unit_type = (int )info_ptr->phys_unit_type;
#line 446
          retval |= 0x0080U;
#line 448
          if (*unit_type == 1) {
#line 450
            if ((unsigned long )res_x != (unsigned long )((void *)0)) {
#line 450
              *res_x = (png_uint_32 )((double )*res_x * .0254 + .50);
            }
#line 451
            if ((unsigned long )res_y != (unsigned long )((void *)0)) {
#line 451
              *res_y = (png_uint_32 )((double )*res_y * .0254 + .50);
            }
          }
        }
      }
    }
  }
#line 456
  return (retval);
}
}
#line 466 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_byte png_get_channels(png_const_structrp png_ptr , png_const_inforp info_ptr )
{


  {
#line 469
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 469
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 470
      return ((png_byte )info_ptr->channels);
    }
  }
#line 472
  return ((png_byte )0);
}
}
#line 476 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_const_bytep png_get_signature(png_const_structrp png_ptr , png_const_inforp info_ptr )
{


  {
#line 479
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 479
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 480
      return ((png_const_bytep )(info_ptr->signature));
    }
  }
#line 482
  return ((png_const_bytep )((void *)0));
}
}
#line 487 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_uint_32 png_get_bKGD(png_const_structrp png_ptr , png_inforp info_ptr , png_color_16p *background )
{


  {
#line 491
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 491
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 491
      if ((info_ptr->valid & 0x0020U) != 0U) {
#line 491
        if ((unsigned long )background != (unsigned long )((void *)0)) {
#line 497
          *background = & info_ptr->background;
#line 498
          return (0x0020U);
        }
      }
    }
  }
#line 501
  return ((png_uint_32 )0);
}
}
#line 511 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_uint_32 png_get_cHRM(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                         double *white_x , double *white_y , double *red_x , double *red_y ,
                         double *green_x , double *green_y , double *blue_x , double *blue_y )
{


  {
#line 522
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 522
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 522
      if (((int )info_ptr->colorspace.flags & 2) != 0) {
#line 527
        if ((unsigned long )white_x != (unsigned long )((void *)0)) {
#line 528
          *white_x = .00001 * (double )info_ptr->colorspace.end_points_xy.whitex;
        }
#line 530
        if ((unsigned long )white_y != (unsigned long )((void *)0)) {
#line 531
          *white_y = .00001 * (double )info_ptr->colorspace.end_points_xy.whitey;
        }
#line 533
        if ((unsigned long )red_x != (unsigned long )((void *)0)) {
#line 534
          *red_x = .00001 * (double )info_ptr->colorspace.end_points_xy.redx;
        }
#line 536
        if ((unsigned long )red_y != (unsigned long )((void *)0)) {
#line 537
          *red_y = .00001 * (double )info_ptr->colorspace.end_points_xy.redy;
        }
#line 539
        if ((unsigned long )green_x != (unsigned long )((void *)0)) {
#line 540
          *green_x = .00001 * (double )info_ptr->colorspace.end_points_xy.greenx;
        }
#line 542
        if ((unsigned long )green_y != (unsigned long )((void *)0)) {
#line 543
          *green_y = .00001 * (double )info_ptr->colorspace.end_points_xy.greeny;
        }
#line 545
        if ((unsigned long )blue_x != (unsigned long )((void *)0)) {
#line 546
          *blue_x = .00001 * (double )info_ptr->colorspace.end_points_xy.bluex;
        }
#line 548
        if ((unsigned long )blue_y != (unsigned long )((void *)0)) {
#line 549
          *blue_y = .00001 * (double )info_ptr->colorspace.end_points_xy.bluey;
        }
#line 551
        return (0x0004U);
      }
    }
  }
#line 554
  return ((png_uint_32 )0);
}
}
#line 557 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_uint_32 png_get_cHRM_XYZ(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                             double *red_X , double *red_Y , double *red_Z , double *green_X ,
                             double *green_Y , double *green_Z , double *blue_X ,
                             double *blue_Y , double *blue_Z )
{


  {
#line 563
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 563
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 563
      if (((int )info_ptr->colorspace.flags & 2) != 0) {
#line 568
        if ((unsigned long )red_X != (unsigned long )((void *)0)) {
#line 569
          *red_X = .00001 * (double )info_ptr->colorspace.end_points_XYZ.red_X;
        }
#line 571
        if ((unsigned long )red_Y != (unsigned long )((void *)0)) {
#line 572
          *red_Y = .00001 * (double )info_ptr->colorspace.end_points_XYZ.red_Y;
        }
#line 574
        if ((unsigned long )red_Z != (unsigned long )((void *)0)) {
#line 575
          *red_Z = .00001 * (double )info_ptr->colorspace.end_points_XYZ.red_Z;
        }
#line 577
        if ((unsigned long )green_X != (unsigned long )((void *)0)) {
#line 578
          *green_X = .00001 * (double )info_ptr->colorspace.end_points_XYZ.green_X;
        }
#line 580
        if ((unsigned long )green_Y != (unsigned long )((void *)0)) {
#line 581
          *green_Y = .00001 * (double )info_ptr->colorspace.end_points_XYZ.green_Y;
        }
#line 583
        if ((unsigned long )green_Z != (unsigned long )((void *)0)) {
#line 584
          *green_Z = .00001 * (double )info_ptr->colorspace.end_points_XYZ.green_Z;
        }
#line 586
        if ((unsigned long )blue_X != (unsigned long )((void *)0)) {
#line 587
          *blue_X = .00001 * (double )info_ptr->colorspace.end_points_XYZ.blue_X;
        }
#line 589
        if ((unsigned long )blue_Y != (unsigned long )((void *)0)) {
#line 590
          *blue_Y = .00001 * (double )info_ptr->colorspace.end_points_XYZ.blue_Y;
        }
#line 592
        if ((unsigned long )blue_Z != (unsigned long )((void *)0)) {
#line 593
          *blue_Z = .00001 * (double )info_ptr->colorspace.end_points_XYZ.blue_Z;
        }
#line 595
        return (0x0004U);
      }
    }
  }
#line 598
  return ((png_uint_32 )0);
}
}
#line 603 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_uint_32 png_get_cHRM_XYZ_fixed(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                   png_fixed_point *int_red_X , png_fixed_point *int_red_Y ,
                                   png_fixed_point *int_red_Z , png_fixed_point *int_green_X ,
                                   png_fixed_point *int_green_Y , png_fixed_point *int_green_Z ,
                                   png_fixed_point *int_blue_X , png_fixed_point *int_blue_Y ,
                                   png_fixed_point *int_blue_Z )
{


  {
#line 611
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 611
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 611
      if (((int )info_ptr->colorspace.flags & 2) != 0) {
#line 616
        if ((unsigned long )int_red_X != (unsigned long )((void *)0)) {
#line 617
          *int_red_X = (png_fixed_point )info_ptr->colorspace.end_points_XYZ.red_X;
        }
#line 618
        if ((unsigned long )int_red_Y != (unsigned long )((void *)0)) {
#line 619
          *int_red_Y = (png_fixed_point )info_ptr->colorspace.end_points_XYZ.red_Y;
        }
#line 620
        if ((unsigned long )int_red_Z != (unsigned long )((void *)0)) {
#line 621
          *int_red_Z = (png_fixed_point )info_ptr->colorspace.end_points_XYZ.red_Z;
        }
#line 622
        if ((unsigned long )int_green_X != (unsigned long )((void *)0)) {
#line 623
          *int_green_X = (png_fixed_point )info_ptr->colorspace.end_points_XYZ.green_X;
        }
#line 624
        if ((unsigned long )int_green_Y != (unsigned long )((void *)0)) {
#line 625
          *int_green_Y = (png_fixed_point )info_ptr->colorspace.end_points_XYZ.green_Y;
        }
#line 626
        if ((unsigned long )int_green_Z != (unsigned long )((void *)0)) {
#line 627
          *int_green_Z = (png_fixed_point )info_ptr->colorspace.end_points_XYZ.green_Z;
        }
#line 628
        if ((unsigned long )int_blue_X != (unsigned long )((void *)0)) {
#line 629
          *int_blue_X = (png_fixed_point )info_ptr->colorspace.end_points_XYZ.blue_X;
        }
#line 630
        if ((unsigned long )int_blue_Y != (unsigned long )((void *)0)) {
#line 631
          *int_blue_Y = (png_fixed_point )info_ptr->colorspace.end_points_XYZ.blue_Y;
        }
#line 632
        if ((unsigned long )int_blue_Z != (unsigned long )((void *)0)) {
#line 633
          *int_blue_Z = (png_fixed_point )info_ptr->colorspace.end_points_XYZ.blue_Z;
        }
#line 634
        return (0x0004U);
      }
    }
  }
#line 637
  return ((png_uint_32 )0);
}
}
#line 640 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_uint_32 png_get_cHRM_fixed(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                               png_fixed_point *white_x , png_fixed_point *white_y ,
                               png_fixed_point *red_x , png_fixed_point *red_y , png_fixed_point *green_x ,
                               png_fixed_point *green_y , png_fixed_point *blue_x ,
                               png_fixed_point *blue_y )
{


  {
#line 648
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 648
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 648
      if (((int )info_ptr->colorspace.flags & 2) != 0) {
#line 651
        if ((unsigned long )white_x != (unsigned long )((void *)0)) {
#line 652
          *white_x = (png_fixed_point )info_ptr->colorspace.end_points_xy.whitex;
        }
#line 653
        if ((unsigned long )white_y != (unsigned long )((void *)0)) {
#line 654
          *white_y = (png_fixed_point )info_ptr->colorspace.end_points_xy.whitey;
        }
#line 655
        if ((unsigned long )red_x != (unsigned long )((void *)0)) {
#line 656
          *red_x = (png_fixed_point )info_ptr->colorspace.end_points_xy.redx;
        }
#line 657
        if ((unsigned long )red_y != (unsigned long )((void *)0)) {
#line 658
          *red_y = (png_fixed_point )info_ptr->colorspace.end_points_xy.redy;
        }
#line 659
        if ((unsigned long )green_x != (unsigned long )((void *)0)) {
#line 660
          *green_x = (png_fixed_point )info_ptr->colorspace.end_points_xy.greenx;
        }
#line 661
        if ((unsigned long )green_y != (unsigned long )((void *)0)) {
#line 662
          *green_y = (png_fixed_point )info_ptr->colorspace.end_points_xy.greeny;
        }
#line 663
        if ((unsigned long )blue_x != (unsigned long )((void *)0)) {
#line 664
          *blue_x = (png_fixed_point )info_ptr->colorspace.end_points_xy.bluex;
        }
#line 665
        if ((unsigned long )blue_y != (unsigned long )((void *)0)) {
#line 666
          *blue_y = (png_fixed_point )info_ptr->colorspace.end_points_xy.bluey;
        }
#line 667
        return (0x0004U);
      }
    }
  }
#line 670
  return ((png_uint_32 )0);
}
}
#line 677 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_uint_32 png_get_gAMA_fixed(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                               png_fixed_point *file_gamma )
{


  {
#line 683
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 683
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 683
      if (((int )info_ptr->colorspace.flags & 1) != 0) {
#line 683
        if ((unsigned long )file_gamma != (unsigned long )((void *)0)) {
#line 687
          *file_gamma = (png_fixed_point )info_ptr->colorspace.gamma;
#line 688
          return (0x0001U);
        }
      }
    }
  }
#line 691
  return ((png_uint_32 )0);
}
}
#line 696 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_uint_32 png_get_gAMA(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                         double *file_gamma )
{


  {
#line 702
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 702
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 702
      if (((int )info_ptr->colorspace.flags & 1) != 0) {
#line 702
        if ((unsigned long )file_gamma != (unsigned long )((void *)0)) {
#line 706
          *file_gamma = .00001 * (double )info_ptr->colorspace.gamma;
#line 708
          return (0x0001U);
        }
      }
    }
  }
#line 711
  return ((png_uint_32 )0);
}
}
#line 717 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_uint_32 png_get_sRGB(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                         int *file_srgb_intent )
{


  {
#line 723
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 723
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 723
      if ((info_ptr->valid & 2048U) != 0U) {
#line 723
        if ((unsigned long )file_srgb_intent != (unsigned long )((void *)0)) {
#line 726
          *file_srgb_intent = (int )info_ptr->colorspace.rendering_intent;
#line 727
          return (0x0800U);
        }
      }
    }
  }
#line 730
  return ((png_uint_32 )0);
}
}
#line 735 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_uint_32 png_get_iCCP(png_const_structrp png_ptr , png_inforp info_ptr , png_charpp name ,
                         int *compression_type , png_bytepp profile , png_uint_32 *proflen )
{


  {
#line 742
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 742
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 742
      if ((info_ptr->valid & 0x1000U) != 0U) {
#line 742
        if ((unsigned long )name != (unsigned long )((void *)0)) {
#line 742
          if ((unsigned long )profile != (unsigned long )((void *)0)) {
#line 742
            if ((unsigned long )proflen != (unsigned long )((void *)0)) {
#line 746
              *name = info_ptr->iccp_name;
#line 747
              *profile = info_ptr->iccp_profile;
#line 748
              *proflen = ((((png_uint_32 )*(info_ptr->iccp_profile) << 24) + ((png_uint_32 )*(info_ptr->iccp_profile + 1) << 16)) + ((png_uint_32 )*(info_ptr->iccp_profile + 2) << 8)) + (png_uint_32 )*(info_ptr->iccp_profile + 3);
#line 752
              if ((unsigned long )compression_type != (unsigned long )((void *)0)) {
#line 753
                *compression_type = 0;
              }
#line 754
              return (0x1000U);
            }
          }
        }
      }
    }
  }
#line 757
  return ((png_uint_32 )0);
}
}
#line 763 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
int png_get_sPLT(png_const_structrp png_ptr , png_inforp info_ptr , png_sPLT_tpp spalettes )
{


  {
#line 767
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 767
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 767
      if ((unsigned long )spalettes != (unsigned long )((void *)0)) {
#line 769
        *spalettes = info_ptr->splt_palettes;
#line 770
        return (info_ptr->splt_palettes_num);
      }
    }
  }
#line 773
  return (0);
}
}
#line 778 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_uint_32 png_get_eXIf(png_const_structrp png_ptr , png_inforp info_ptr , png_bytep *exif )
{


  {
#line 782
  png_warning(png_ptr, (png_const_charp )"png_get_eXIf does not work; use png_get_eXIf_1");
#line 785
  return ((png_uint_32 )0);
}
}
#line 788 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_uint_32 png_get_eXIf_1(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                           png_uint_32 *num_exif , png_bytep *exif )
{


  {
#line 794
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 794
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 794
      if ((info_ptr->valid & 65536U) != 0U) {
#line 794
        if ((unsigned long )exif != (unsigned long )((void *)0)) {
#line 797
          *num_exif = (png_uint_32 )info_ptr->num_exif;
#line 798
          *exif = (png_bytep )info_ptr->exif;
#line 799
          return (0x10000U);
        }
      }
    }
  }
#line 802
  return ((png_uint_32 )0);
}
}
#line 807 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_uint_32 png_get_hIST(png_const_structrp png_ptr , png_inforp info_ptr , png_uint_16p *hist )
{


  {
#line 813
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 813
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 813
      if ((info_ptr->valid & 0x0040U) != 0U) {
#line 813
        if ((unsigned long )hist != (unsigned long )((void *)0)) {
#line 816
          *hist = info_ptr->hist;
#line 817
          return (0x0040U);
        }
      }
    }
  }
#line 820
  return ((png_uint_32 )0);
}
}
#line 824 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_uint_32 png_get_IHDR(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                         png_uint_32 *width , png_uint_32 *height , int *bit_depth ,
                         int *color_type , int *interlace_type , int *compression_type ,
                         int *filter_type )
{


  {
#line 832
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 833
    return ((png_uint_32 )0);
  } else
#line 832
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 833
    return ((png_uint_32 )0);
  }
#line 835
  if ((unsigned long )width != (unsigned long )((void *)0)) {
#line 836
    *width = (png_uint_32 )info_ptr->width;
  }
#line 838
  if ((unsigned long )height != (unsigned long )((void *)0)) {
#line 839
    *height = (png_uint_32 )info_ptr->height;
  }
#line 841
  if ((unsigned long )bit_depth != (unsigned long )((void *)0)) {
#line 842
    *bit_depth = (int )info_ptr->bit_depth;
  }
#line 844
  if ((unsigned long )color_type != (unsigned long )((void *)0)) {
#line 845
    *color_type = (int )info_ptr->color_type;
  }
#line 847
  if ((unsigned long )compression_type != (unsigned long )((void *)0)) {
#line 848
    *compression_type = (int )info_ptr->compression_type;
  }
#line 850
  if ((unsigned long )filter_type != (unsigned long )((void *)0)) {
#line 851
    *filter_type = (int )info_ptr->filter_type;
  }
#line 853
  if ((unsigned long )interlace_type != (unsigned long )((void *)0)) {
#line 854
    *interlace_type = (int )info_ptr->interlace_type;
  }
#line 861
  png_check_IHDR(png_ptr, (png_uint_32 )info_ptr->width, (png_uint_32 )info_ptr->height,
                 (int )info_ptr->bit_depth, (int )info_ptr->color_type, (int )info_ptr->interlace_type,
                 (int )info_ptr->compression_type, (int )info_ptr->filter_type);
#line 865
  return ((png_uint_32 )1);
}
}
#line 869 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_uint_32 png_get_oFFs(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                         png_int_32 *offset_x , png_int_32 *offset_y , int *unit_type )
{


  {
#line 875
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 875
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 875
      if ((info_ptr->valid & 256U) != 0U) {
#line 875
        if ((unsigned long )offset_x != (unsigned long )((void *)0)) {
#line 875
          if ((unsigned long )offset_y != (unsigned long )((void *)0)) {
#line 875
            if ((unsigned long )unit_type != (unsigned long )((void *)0)) {
#line 879
              *offset_x = (png_int_32 )info_ptr->x_offset;
#line 880
              *offset_y = (png_int_32 )info_ptr->y_offset;
#line 881
              *unit_type = (int )info_ptr->offset_unit_type;
#line 882
              return (0x0100U);
            }
          }
        }
      }
    }
  }
#line 885
  return ((png_uint_32 )0);
}
}
#line 890 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_uint_32 png_get_pCAL(png_const_structrp png_ptr , png_inforp info_ptr , png_charp *purpose ,
                         png_int_32 *X0 , png_int_32 *X1 , int *type , int *nparams ,
                         png_charp *units , png_charpp *params )
{


  {
#line 897
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 897
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 897
      if ((info_ptr->valid & 0x0400U) != 0U) {
#line 897
        if ((unsigned long )purpose != (unsigned long )((void *)0)) {
#line 897
          if ((unsigned long )X0 != (unsigned long )((void *)0)) {
#line 897
            if ((unsigned long )X1 != (unsigned long )((void *)0)) {
#line 897
              if ((unsigned long )type != (unsigned long )((void *)0)) {
#line 897
                if ((unsigned long )nparams != (unsigned long )((void *)0)) {
#line 897
                  if ((unsigned long )units != (unsigned long )((void *)0)) {
#line 897
                    if ((unsigned long )params != (unsigned long )((void *)0)) {
#line 902
                      *purpose = info_ptr->pcal_purpose;
#line 903
                      *X0 = info_ptr->pcal_X0;
#line 904
                      *X1 = info_ptr->pcal_X1;
#line 905
                      *type = (int )info_ptr->pcal_type;
#line 906
                      *nparams = (int )info_ptr->pcal_nparams;
#line 907
                      *units = info_ptr->pcal_units;
#line 908
                      *params = info_ptr->pcal_params;
#line 909
                      return (0x0400U);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 912
  return ((png_uint_32 )0);
}
}
#line 920 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_uint_32 png_get_sCAL_fixed(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                               int *unit , png_fixed_point *width , png_fixed_point *height )
{
  double tmp ;
  double tmp___0 ;

  {
#line 924
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 924
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 924
      if ((info_ptr->valid & 16384U) != 0U) {
#line 927
        *unit = (int )info_ptr->scal_unit;
#line 932
        tmp = atof((char const   *)info_ptr->scal_s_width);
#line 932
        *width = png_fixed(png_ptr, tmp, (png_const_charp )"sCAL width");
#line 933
        tmp___0 = atof((char const   *)info_ptr->scal_s_height);
#line 933
        *height = png_fixed(png_ptr, tmp___0, (png_const_charp )"sCAL height");
#line 935
        return (0x4000U);
      }
    }
  }
#line 938
  return ((png_uint_32 )0);
}
}
#line 943 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_uint_32 png_get_sCAL(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                         int *unit , double *width , double *height )
{


  {
#line 947
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 947
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 947
      if ((info_ptr->valid & 16384U) != 0U) {
#line 950
        *unit = (int )info_ptr->scal_unit;
#line 951
        *width = atof((char const   *)info_ptr->scal_s_width);
#line 952
        *height = atof((char const   *)info_ptr->scal_s_height);
#line 953
        return (0x4000U);
      }
    }
  }
#line 956
  return ((png_uint_32 )0);
}
}
#line 959 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_uint_32 png_get_sCAL_s(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                           int *unit , png_charpp width , png_charpp height )
{


  {
#line 963
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 963
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 963
      if ((info_ptr->valid & 16384U) != 0U) {
#line 966
        *unit = (int )info_ptr->scal_unit;
#line 967
        *width = (char *)info_ptr->scal_s_width;
#line 968
        *height = (char *)info_ptr->scal_s_height;
#line 969
        return (0x4000U);
      }
    }
  }
#line 972
  return ((png_uint_32 )0);
}
}
#line 977 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_uint_32 png_get_pHYs(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                         png_uint_32 *res_x , png_uint_32 *res_y , int *unit_type )
{
  png_uint_32 retval ;

  {
#line 981
  retval = (png_uint_32 )0;
#line 985
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 985
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 985
      if ((info_ptr->valid & 128U) != 0U) {
#line 988
        if ((unsigned long )res_x != (unsigned long )((void *)0)) {
#line 990
          *res_x = (png_uint_32 )info_ptr->x_pixels_per_unit;
#line 991
          retval |= 0x0080U;
        }
#line 994
        if ((unsigned long )res_y != (unsigned long )((void *)0)) {
#line 996
          *res_y = (png_uint_32 )info_ptr->y_pixels_per_unit;
#line 997
          retval |= 0x0080U;
        }
#line 1000
        if ((unsigned long )unit_type != (unsigned long )((void *)0)) {
#line 1002
          *unit_type = (int )info_ptr->phys_unit_type;
#line 1003
          retval |= 0x0080U;
        }
      }
    }
  }
#line 1007
  return (retval);
}
}
#line 1011 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_uint_32 png_get_PLTE(png_const_structrp png_ptr , png_inforp info_ptr , png_colorp *palette ,
                         int *num_palette )
{


  {
#line 1017
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 1017
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1017
      if ((info_ptr->valid & 0x0008U) != 0U) {
#line 1017
        if ((unsigned long )palette != (unsigned long )((void *)0)) {
#line 1020
          *palette = info_ptr->palette;
#line 1021
          *num_palette = (int )info_ptr->num_palette;
#line 1023
          return (0x0008U);
        }
      }
    }
  }
#line 1026
  return ((png_uint_32 )0);
}
}
#line 1030 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_uint_32 png_get_sBIT(png_const_structrp png_ptr , png_inforp info_ptr , png_color_8p *sig_bit )
{


  {
#line 1036
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 1036
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1036
      if ((info_ptr->valid & 0x0002U) != 0U) {
#line 1036
        if ((unsigned long )sig_bit != (unsigned long )((void *)0)) {
#line 1039
          *sig_bit = & info_ptr->sig_bit;
#line 1040
          return (0x0002U);
        }
      }
    }
  }
#line 1043
  return ((png_uint_32 )0);
}
}
#line 1048 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
int png_get_text(png_const_structrp png_ptr , png_inforp info_ptr , png_textp *text_ptr ,
                 int *num_text )
{


  {
#line 1052
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 1052
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1052
      if (info_ptr->num_text > 0) {
#line 1057
        if ((unsigned long )text_ptr != (unsigned long )((void *)0)) {
#line 1058
          *text_ptr = info_ptr->text;
        }
#line 1060
        if ((unsigned long )num_text != (unsigned long )((void *)0)) {
#line 1061
          *num_text = info_ptr->num_text;
        }
#line 1063
        return (info_ptr->num_text);
      }
    }
  }
#line 1066
  if ((unsigned long )num_text != (unsigned long )((void *)0)) {
#line 1067
    *num_text = 0;
  }
#line 1069
  return (0);
}
}
#line 1074 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_uint_32 png_get_tIME(png_const_structrp png_ptr , png_inforp info_ptr , png_timep *mod_time )
{


  {
#line 1080
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 1080
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1080
      if ((info_ptr->valid & 0x0200U) != 0U) {
#line 1080
        if ((unsigned long )mod_time != (unsigned long )((void *)0)) {
#line 1083
          *mod_time = & info_ptr->mod_time;
#line 1084
          return (0x0200U);
        }
      }
    }
  }
#line 1087
  return ((png_uint_32 )0);
}
}
#line 1092 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_uint_32 png_get_tRNS(png_const_structrp png_ptr , png_inforp info_ptr , png_bytep *trans_alpha ,
                         int *num_trans , png_color_16p *trans_color )
{
  png_uint_32 retval ;

  {
#line 1096
  retval = (png_uint_32 )0;
#line 1097
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 1097
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1097
      if ((info_ptr->valid & 0x0010U) != 0U) {
#line 1102
        if ((int )info_ptr->color_type == 3) {
#line 1104
          if ((unsigned long )trans_alpha != (unsigned long )((void *)0)) {
#line 1106
            *trans_alpha = info_ptr->trans_alpha;
#line 1107
            retval |= 0x0010U;
          }
#line 1110
          if ((unsigned long )trans_color != (unsigned long )((void *)0)) {
#line 1111
            *trans_color = & info_ptr->trans_color;
          }
        } else {
#line 1116
          if ((unsigned long )trans_color != (unsigned long )((void *)0)) {
#line 1118
            *trans_color = & info_ptr->trans_color;
#line 1119
            retval |= 0x0010U;
          }
#line 1122
          if ((unsigned long )trans_alpha != (unsigned long )((void *)0)) {
#line 1123
            *trans_alpha = (png_bytep )((void *)0);
          }
        }
#line 1126
        if ((unsigned long )num_trans != (unsigned long )((void *)0)) {
#line 1128
          *num_trans = (int )info_ptr->num_trans;
#line 1129
          retval |= 0x0010U;
        }
      }
    }
  }
#line 1133
  return (retval);
}
}
#line 1138 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
int png_get_unknown_chunks(png_const_structrp png_ptr , png_inforp info_ptr , png_unknown_chunkpp unknowns )
{


  {
#line 1142
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 1142
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1142
      if ((unsigned long )unknowns != (unsigned long )((void *)0)) {
#line 1144
        *unknowns = info_ptr->unknown_chunks;
#line 1145
        return (info_ptr->unknown_chunks_num);
      }
    }
  }
#line 1148
  return (0);
}
}
#line 1153 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_byte png_get_rgb_to_gray_status(png_const_structrp png_ptr )
{
  int tmp ;

  {
#line 1156
  if (png_ptr) {
#line 1156
    tmp = (int )png_ptr->rgb_to_gray_status;
  } else {
#line 1156
    tmp = (int )0;
  }
#line 1156
  return ((png_byte )tmp);
}
}
#line 1161 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_voidp png_get_user_chunk_ptr(png_const_structrp png_ptr )
{
  png_voidp tmp ;

  {
#line 1164
  if (png_ptr) {
#line 1164
    tmp = png_ptr->user_chunk_ptr;
  } else {
#line 1164
    tmp = (png_voidp )((void *)0);
  }
#line 1164
  return ((png_voidp )tmp);
}
}
#line 1168 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
size_t png_get_compression_buffer_size(png_const_structrp png_ptr )
{


  {
#line 1171
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1172
    return ((size_t )0);
  }
#line 1175
  if ((png_ptr->mode & 32768U) != 0U) {
#line 1179
    return ((size_t )png_ptr->IDAT_read_size);
  } else {
#line 1187
    return ((size_t )png_ptr->zbuffer_size);
  }
}
}
#line 1194 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_uint_32 png_get_user_width_max(png_const_structrp png_ptr )
{
  png_uint_32 tmp ;

  {
#line 1197
  if (png_ptr) {
#line 1197
    tmp = png_ptr->user_width_max;
  } else {
#line 1197
    tmp = (png_uint_32 )0;
  }
#line 1197
  return ((png_uint_32 )tmp);
}
}
#line 1200 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_uint_32 png_get_user_height_max(png_const_structrp png_ptr )
{
  png_uint_32 tmp ;

  {
#line 1203
  if (png_ptr) {
#line 1203
    tmp = png_ptr->user_height_max;
  } else {
#line 1203
    tmp = (png_uint_32 )0;
  }
#line 1203
  return ((png_uint_32 )tmp);
}
}
#line 1207 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_uint_32 png_get_chunk_cache_max(png_const_structrp png_ptr )
{
  png_uint_32 tmp ;

  {
#line 1210
  if (png_ptr) {
#line 1210
    tmp = png_ptr->user_chunk_cache_max;
  } else {
#line 1210
    tmp = (png_uint_32 )0;
  }
#line 1210
  return ((png_uint_32 )tmp);
}
}
#line 1214 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_alloc_size_t png_get_chunk_malloc_max(png_const_structrp png_ptr )
{
  png_alloc_size_t tmp ;

  {
#line 1217
  if (png_ptr) {
#line 1217
    tmp = png_ptr->user_chunk_malloc_max;
  } else {
#line 1217
    tmp = (png_alloc_size_t )0;
  }
#line 1217
  return ((png_alloc_size_t )tmp);
}
}
#line 1223 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_uint_32 png_get_io_state(png_const_structrp png_ptr )
{


  {
#line 1226
  return ((png_uint_32 )png_ptr->io_state);
}
}
#line 1229 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
png_uint_32 png_get_io_chunk_type(png_const_structrp png_ptr )
{


  {
#line 1232
  return ((png_uint_32 )png_ptr->chunk_name);
}
}
#line 1238 "/home/goblint2/bench/libpng-1.6.39/pngget.c"
int png_get_palette_max(png_const_structp png_ptr , png_const_infop info_ptr )
{


  {
#line 1241
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 1241
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1242
      return ((int )png_ptr->num_palette_max);
    }
  }
#line 1244
  return (-1);
}
}
#line 101 "/usr/include/stdlib.h"
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 104
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 107
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 112
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__leaf__, __gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__,
__nothrow__)) ;
#line 820
__inline extern void *( __attribute__((__warn_unused_result__, __nonnull__(1,2,5),
__gnu_inline__)) bsearch)(void const   *__key , void const   *__base , size_t __nmemb ,
                          size_t __size , int (*__compar)(void const   * , void const   * ) ) ;
#line 929
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar )  __attribute__((__nothrow__)) ;
#line 933
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t *__dst , char const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 936
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) wcstombs)(char *__dst , wchar_t const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 43 "/usr/include/string.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memcpy)(void *__dest , void const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 47
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 61
__inline extern void *( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) memset)(void *__dest , int __ch , size_t __len )  __attribute__((__nothrow__)) ;
#line 122
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcpy)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 125
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncpy)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 130
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcat)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 133
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncat)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 326 "/usr/include/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) fprintf)(FILE *__stream ,
                                                                                                  char const   *__fmt
                                                                                                  , ...) ;
#line 332
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) printf)(char const   *__fmt
                                                                                                 , ...) ;
#line 334
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) sprintf)(char *__s ,
                                                                                                            char const   *__fmt
                                                                                                            , ...)  __attribute__((__nothrow__)) ;
#line 341
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vfprintf)(FILE *__stream ,
                                                                                                   char const   *__fmt ,
                                                                                                   __gnuc_va_list __ap ) ;
#line 347
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vprintf)(char const   *__fmt ,
                                                                                                  __gnuc_va_list __ap ) ;
#line 349
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vsprintf)(char *__s ,
                                                                                                             char const   *__fmt ,
                                                                                                             __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 354
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) snprintf)(char *__s , size_t __n , char const   *__fmt
                                              , ...)  __attribute__((__nothrow__)) ;
#line 358
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) vsnprintf)(char *__s , size_t __n , char const   *__fmt ,
                                               __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 492
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
#line 528
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
#line 564
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fgets)(char *__s , int __n , FILE *__stream ) ;
#line 646
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fread)(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 360 "/usr/include/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) read)(int __fd , void *__buf , size_t __nbytes ) ;
#line 511
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size )  __attribute__((__nothrow__)) ;
#line 689
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list )  __attribute__((__nothrow__)) ;
#line 774
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                               size_t __buflen )  __attribute__((__nothrow__)) ;
#line 24 "/home/goblint2/bench/libpng-1.6.39/pngmem.c"
void png_destroy_png_struct(png_structrp png_ptr )
{
  png_struct dummy_struct ;

  {
#line 27
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 32
    dummy_struct = *png_ptr;
#line 33
    memset((void *)png_ptr, 0, sizeof(*png_ptr));
#line 34
    png_free((png_const_structrp )(& dummy_struct), (png_voidp )png_ptr);
#line 38
    png_free_jmpbuf((png_structrp )(& dummy_struct));
  }
#line 41
  return;
}
}
#line 49 "/home/goblint2/bench/libpng-1.6.39/pngmem.c"
png_voidp __attribute__((__malloc__))  png_calloc(png_const_structrp png_ptr , png_alloc_size_t size )
{
  png_voidp ret ;
  png_voidp __attribute__((__malloc__))  tmp ;

  {
#line 54
  tmp = png_malloc(png_ptr, size);
#line 54
  ret = (png_voidp )tmp;
#line 56
  if ((unsigned long )ret != (unsigned long )((void *)0)) {
#line 57
    memset(ret, 0, size);
  }
#line 59
  return ((png_voidp __attribute__((__malloc__))  )ret);
}
}
#line 67 "/home/goblint2/bench/libpng-1.6.39/pngmem.c"
png_voidp __attribute__((__malloc__))  png_malloc_base(png_const_structrp png_ptr ,
                                                       png_alloc_size_t size )
{
  png_voidp tmp ;
  void *tmp___0 ;

  {
#line 83
  if (size > 0UL) {
#line 83
    if (size <= 18446744073709551615UL) {
#line 90
      if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 90
        if ((unsigned long )png_ptr->malloc_fn != (unsigned long )((void *)0)) {
#line 91
          tmp = (*(png_ptr->malloc_fn))((png_structp )((png_structrp )((void *)((void const   *)png_ptr))),
                                        size);
#line 91
          return ((png_voidp __attribute__((__malloc__))  )tmp);
        } else {
#line 95
          tmp___0 = malloc(size);
#line 95
          return ((png_voidp __attribute__((__malloc__))  )tmp___0);
        }
      } else {
#line 95
        tmp___0 = malloc(size);
#line 95
        return ((png_voidp __attribute__((__malloc__))  )tmp___0);
      }
    } else {
#line 99
      return ((png_voidp __attribute__((__malloc__))  )((void *)0));
    }
  } else {
#line 99
    return ((png_voidp __attribute__((__malloc__))  )((void *)0));
  }
}
}
#line 108 "/home/goblint2/bench/libpng-1.6.39/pngmem.c"
static png_voidp png_malloc_array_checked(png_const_structrp png_ptr , int nelements ,
                                          size_t element_size )
{
  png_alloc_size_t req ;
  png_voidp __attribute__((__malloc__))  tmp ;

  {
#line 112
  req = (png_alloc_size_t )nelements;
#line 114
  if (req <= 18446744073709551615UL / element_size) {
#line 115
    tmp = png_malloc_base(png_ptr, req * element_size);
#line 115
    return ((png_voidp )tmp);
  }
#line 118
  return ((void *)0);
}
}
#line 121 "/home/goblint2/bench/libpng-1.6.39/pngmem.c"
png_voidp __attribute__((__malloc__))  png_malloc_array(png_const_structrp png_ptr ,
                                                        int nelements , size_t element_size )
{
  png_voidp tmp ;

  {
#line 125
  if (nelements <= 0) {
#line 126
    png_error(png_ptr, (png_const_charp )"internal error: array alloc");
  } else
#line 125
  if (element_size == 0UL) {
#line 126
    png_error(png_ptr, (png_const_charp )"internal error: array alloc");
  }
#line 128
  tmp = png_malloc_array_checked(png_ptr, nelements, element_size);
#line 128
  return ((png_voidp __attribute__((__malloc__))  )tmp);
}
}
#line 131 "/home/goblint2/bench/libpng-1.6.39/pngmem.c"
png_voidp __attribute__((__malloc__))  png_realloc_array(png_const_structrp png_ptr ,
                                                         png_const_voidp old_array ,
                                                         int old_elements , int add_elements ,
                                                         size_t element_size )
{
  png_voidp new_array ;
  png_voidp tmp ;

  {
#line 136
  if (add_elements <= 0) {
#line 138
    png_error(png_ptr, (png_const_charp )"internal error: array realloc");
  } else
#line 136
  if (element_size == 0UL) {
#line 138
    png_error(png_ptr, (png_const_charp )"internal error: array realloc");
  } else
#line 136
  if (old_elements < 0) {
#line 138
    png_error(png_ptr, (png_const_charp )"internal error: array realloc");
  } else
#line 136
  if ((unsigned long )old_array == (unsigned long )((void *)0)) {
#line 136
    if (old_elements > 0) {
#line 138
      png_error(png_ptr, (png_const_charp )"internal error: array realloc");
    }
  }
#line 143
  if (add_elements <= 0x7fffffff - old_elements) {
#line 145
    tmp = png_malloc_array_checked(png_ptr, old_elements + add_elements, element_size);
#line 145
    new_array = tmp;
#line 148
    if ((unsigned long )new_array != (unsigned long )((void *)0)) {
#line 153
      if (old_elements > 0) {
#line 154
        memcpy(new_array, old_array, element_size * (size_t )((unsigned int )old_elements));
      }
#line 156
      memset((void *)((char *)new_array + element_size * (size_t )((unsigned int )old_elements)),
             0, element_size * (size_t )((unsigned int )add_elements));
#line 159
      return ((png_voidp __attribute__((__malloc__))  )new_array);
    }
  }
#line 163
  return ((png_voidp __attribute__((__malloc__))  )((void *)0));
}
}
#line 171 "/home/goblint2/bench/libpng-1.6.39/pngmem.c"
png_voidp __attribute__((__malloc__))  png_malloc(png_const_structrp png_ptr , png_alloc_size_t size )
{
  png_voidp ret ;
  png_voidp __attribute__((__malloc__))  tmp ;

  {
#line 176
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 177
    return ((png_voidp __attribute__((__malloc__))  )((void *)0));
  }
#line 179
  tmp = png_malloc_base(png_ptr, size);
#line 179
  ret = (png_voidp )tmp;
#line 181
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 182
    png_error(png_ptr, (png_const_charp )"Out of memory");
  }
#line 184
  return ((png_voidp __attribute__((__malloc__))  )ret);
}
}
#line 188 "/home/goblint2/bench/libpng-1.6.39/pngmem.c"
png_voidp __attribute__((__malloc__, __deprecated__))  png_malloc_default(png_const_structrp png_ptr ,
                                                                          png_alloc_size_t size )
{
  png_voidp ret ;
  png_voidp __attribute__((__malloc__))  tmp ;

  {
#line 194
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 195
    return ((png_voidp __attribute__((__malloc__))  )((void *)0));
  }
#line 198
  tmp = png_malloc_base((png_const_structrp )((void *)0), size);
#line 198
  ret = (png_voidp )tmp;
#line 200
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 201
    png_error(png_ptr, (png_const_charp )"Out of Memory");
  }
#line 203
  return ((png_voidp __attribute__((__malloc__))  )ret);
}
}
#line 211 "/home/goblint2/bench/libpng-1.6.39/pngmem.c"
png_voidp __attribute__((__malloc__))  png_malloc_warn(png_const_structrp png_ptr ,
                                                       png_alloc_size_t size )
{
  png_voidp ret ;
  png_voidp __attribute__((__malloc__))  tmp ;

  {
#line 215
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 217
    tmp = png_malloc_base(png_ptr, size);
#line 217
    ret = (png_voidp )tmp;
#line 219
    if ((unsigned long )ret != (unsigned long )((void *)0)) {
#line 220
      return ((png_voidp __attribute__((__malloc__))  )ret);
    }
#line 222
    png_warning(png_ptr, (png_const_charp )"Out of memory");
  }
#line 225
  return ((png_voidp __attribute__((__malloc__))  )((void *)0));
}
}
#line 231 "/home/goblint2/bench/libpng-1.6.39/pngmem.c"
void png_free(png_const_structrp png_ptr , png_voidp ptr )
{


  {
#line 234
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 235
    return;
  } else
#line 234
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 235
    return;
  }
#line 238
  if ((unsigned long )png_ptr->free_fn != (unsigned long )((void *)0)) {
#line 239
    (*(png_ptr->free_fn))((png_structp )((png_structrp )((void *)((void const   *)png_ptr))),
                          ptr);
  } else {
#line 242
    png_free_default(png_ptr, ptr);
  }
#line 243
  return;
}
}
#line 245 "/home/goblint2/bench/libpng-1.6.39/pngmem.c"
void __attribute__((__deprecated__))  png_free_default(png_const_structrp png_ptr ,
                                                       png_voidp ptr )
{


  {
#line 248
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 249
    return;
  } else
#line 248
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 249
    return;
  }
#line 252
  free(ptr);
#line 253
  return;
}
}
#line 259 "/home/goblint2/bench/libpng-1.6.39/pngmem.c"
void png_set_mem_fn(png_structrp png_ptr , png_voidp mem_ptr , png_voidp (*malloc_fn)(png_structp  ,
                                                                                      png_alloc_size_t  ) ,
                    void (*free_fn)(png_structp  , png_voidp  ) )
{


  {
#line 263
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 265
    png_ptr->mem_ptr = mem_ptr;
#line 266
    png_ptr->malloc_fn = malloc_fn;
#line 267
    png_ptr->free_fn = free_fn;
  }
#line 269
  return;
}
}
#line 275 "/home/goblint2/bench/libpng-1.6.39/pngmem.c"
png_voidp png_get_mem_ptr(png_const_structrp png_ptr )
{


  {
#line 278
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 279
    return ((void *)0);
  }
#line 281
  return ((png_voidp )png_ptr->mem_ptr);
}
}
#line 101 "/usr/include/stdlib.h"
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 104
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 107
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 112
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__leaf__, __gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__,
__nothrow__)) ;
#line 820
__inline extern void *( __attribute__((__warn_unused_result__, __nonnull__(1,2,5),
__gnu_inline__)) bsearch)(void const   *__key , void const   *__base , size_t __nmemb ,
                          size_t __size , int (*__compar)(void const   * , void const   * ) ) ;
#line 929
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar )  __attribute__((__nothrow__)) ;
#line 933
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t *__dst , char const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 936
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) wcstombs)(char *__dst , wchar_t const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 43 "/usr/include/string.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memcpy)(void *__dest , void const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 47
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 61
__inline extern void *( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) memset)(void *__dest , int __ch , size_t __len )  __attribute__((__nothrow__)) ;
#line 122
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcpy)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 125
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncpy)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 130
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcat)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 133
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncat)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 326 "/usr/include/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) fprintf)(FILE *__stream ,
                                                                                                  char const   *__fmt
                                                                                                  , ...) ;
#line 332
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) printf)(char const   *__fmt
                                                                                                 , ...) ;
#line 334
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) sprintf)(char *__s ,
                                                                                                            char const   *__fmt
                                                                                                            , ...)  __attribute__((__nothrow__)) ;
#line 341
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vfprintf)(FILE *__stream ,
                                                                                                   char const   *__fmt ,
                                                                                                   __gnuc_va_list __ap ) ;
#line 347
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vprintf)(char const   *__fmt ,
                                                                                                  __gnuc_va_list __ap ) ;
#line 349
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vsprintf)(char *__s ,
                                                                                                             char const   *__fmt ,
                                                                                                             __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 354
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) snprintf)(char *__s , size_t __n , char const   *__fmt
                                              , ...)  __attribute__((__nothrow__)) ;
#line 358
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) vsnprintf)(char *__s , size_t __n , char const   *__fmt ,
                                               __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 492
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
#line 528
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
#line 564
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fgets)(char *__s , int __n , FILE *__stream ) ;
#line 646
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fread)(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 360 "/usr/include/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) read)(int __fd , void *__buf , size_t __nbytes ) ;
#line 511
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size )  __attribute__((__nothrow__)) ;
#line 689
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list )  __attribute__((__nothrow__)) ;
#line 774
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                               size_t __buflen )  __attribute__((__nothrow__)) ;
#line 35 "/home/goblint2/bench/libpng-1.6.39/pngpread.c"
void png_process_data(png_structrp png_ptr , png_inforp info_ptr , png_bytep buffer___0 ,
                      size_t buffer_size )
{


  {
#line 39
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 40
    return;
  } else
#line 39
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 40
    return;
  }
#line 42
  png_push_restore_buffer(png_ptr, buffer___0, buffer_size);
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! png_ptr->buffer_size) {
#line 44
      goto while_break;
    }
#line 46
    png_process_some_data(png_ptr, info_ptr);
  }
  while_break: /* CIL Label */ ;
  }
#line 48
  return;
}
}
#line 50 "/home/goblint2/bench/libpng-1.6.39/pngpread.c"
size_t png_process_data_pause(png_structrp png_ptr , int save )
{
  size_t remaining ;

  {
#line 53
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 58
    if (save != 0) {
#line 59
      png_push_save_buffer(png_ptr);
    } else {
#line 63
      remaining = png_ptr->buffer_size;
#line 64
      png_ptr->buffer_size = (size_t )0;
#line 69
      if (png_ptr->save_buffer_size < remaining) {
#line 70
        return (remaining - png_ptr->save_buffer_size);
      }
    }
  }
#line 74
  return ((size_t )0);
}
}
#line 77 "/home/goblint2/bench/libpng-1.6.39/pngpread.c"
png_uint_32 png_process_data_skip(png_structrp png_ptr )
{


  {
#line 85
  png_app_warning((png_const_structrp )png_ptr, (png_const_charp )"png_process_data_skip is not implemented in any current version of libpng");
#line 87
  return ((png_uint_32 )0);
}
}
#line 93 "/home/goblint2/bench/libpng-1.6.39/pngpread.c"
void png_process_some_data(png_structrp png_ptr , png_inforp info_ptr )
{


  {
#line 96
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 97
    return;
  }
  {
#line 101
  if (png_ptr->process_mode == 0) {
#line 101
    goto case_0;
  }
#line 107
  if (png_ptr->process_mode == 1) {
#line 107
    goto case_1;
  }
#line 113
  if (png_ptr->process_mode == 2) {
#line 113
    goto case_2;
  }
#line 119
  goto switch_default;
  case_0: /* CIL Label */
#line 103
  png_push_read_sig(png_ptr, info_ptr);
#line 104
  goto switch_break;
  case_1: /* CIL Label */
#line 109
  png_push_read_chunk(png_ptr, info_ptr);
#line 110
  goto switch_break;
  case_2: /* CIL Label */
#line 115
  png_push_read_IDAT(png_ptr);
#line 116
  goto switch_break;
  switch_default: /* CIL Label */
#line 121
  png_ptr->buffer_size = (size_t )0;
#line 122
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 125
  return;
}
}
#line 133 "/home/goblint2/bench/libpng-1.6.39/pngpread.c"
void png_push_read_sig(png_structrp png_ptr , png_inforp info_ptr )
{
  size_t num_checked ;
  size_t num_to_check ;
  int tmp ;
  int tmp___0 ;

  {
#line 136
  num_checked = (size_t )png_ptr->sig_bytes;
#line 137
  num_to_check = 8UL - num_checked;
#line 139
  if (png_ptr->buffer_size < num_to_check) {
#line 141
    num_to_check = png_ptr->buffer_size;
  }
#line 144
  png_push_fill_buffer((png_structp )png_ptr, & info_ptr->signature[num_checked],
                       num_to_check);
#line 146
  png_ptr->sig_bytes = (png_byte )((size_t )png_ptr->sig_bytes + num_to_check);
#line 148
  tmp___0 = png_sig_cmp((png_const_bytep )(info_ptr->signature), num_checked, num_to_check);
#line 148
  if (tmp___0) {
#line 150
    if (num_checked < 4UL) {
#line 150
      tmp = png_sig_cmp((png_const_bytep )(info_ptr->signature), num_checked, num_to_check - 4UL);
#line 150
      if (tmp) {
#line 152
        png_error((png_const_structrp )png_ptr, (png_const_charp )"Not a PNG file");
      } else {
#line 155
        png_error((png_const_structrp )png_ptr, (png_const_charp )"PNG file corrupted by ASCII conversion");
      }
    } else {
#line 155
      png_error((png_const_structrp )png_ptr, (png_const_charp )"PNG file corrupted by ASCII conversion");
    }
  } else
#line 159
  if ((int )png_ptr->sig_bytes >= 8) {
#line 161
    png_ptr->process_mode = 1;
  }
#line 164
  return;
}
}
#line 166 "/home/goblint2/bench/libpng-1.6.39/pngpread.c"
void png_push_read_chunk(png_structrp png_ptr , png_inforp info_ptr )
{
  png_uint_32 chunk_name ;
  int keep ;
  png_byte chunk_length[4] ;
  png_byte chunk_tag[4] ;
  size_t tmp ;

  {
#line 180
  if ((png_ptr->mode & 0x100U) == 0U) {
#line 185
    if (png_ptr->buffer_size < 8UL) {
#line 185
      png_push_save_buffer(png_ptr);
#line 185
      return;
    }
#line 186
    png_push_fill_buffer((png_structp )png_ptr, chunk_length, (size_t )4);
#line 187
    png_ptr->push_length = png_get_uint_31((png_const_structrp )png_ptr, (png_const_bytep )(chunk_length));
#line 188
    png_reset_crc(png_ptr);
#line 189
    png_crc_read(png_ptr, chunk_tag, (png_uint_32 )4);
#line 190
    png_ptr->chunk_name = ((((png_uint_32 )(0xff & (int )chunk_tag[0]) << 24) | ((png_uint_32 )(0xff & (int )chunk_tag[1]) << 16)) | ((png_uint_32 )(0xff & (int )chunk_tag[2]) << 8)) | (png_uint_32 )(0xff & (int )chunk_tag[3]);
#line 191
    png_check_chunk_name((png_const_structrp )png_ptr, png_ptr->chunk_name);
#line 192
    png_check_chunk_length((png_const_structrp )png_ptr, png_ptr->push_length);
#line 193
    png_ptr->mode |= 0x100U;
  }
#line 196
  chunk_name = png_ptr->chunk_name;
#line 198
  if (chunk_name == ((((73U << 24) | (68U << 16)) | (65U << 8)) | 84U)) {
#line 200
    if ((png_ptr->mode & 8U) != 0U) {
#line 201
      png_ptr->mode |= 0x2000U;
    }
#line 207
    if ((png_ptr->mode & 1U) == 0U) {
#line 208
      png_error((png_const_structrp )png_ptr, (png_const_charp )"Missing IHDR before IDAT");
    } else
#line 210
    if ((int )png_ptr->color_type == 3) {
#line 210
      if ((png_ptr->mode & 2U) == 0U) {
#line 212
        png_error((png_const_structrp )png_ptr, (png_const_charp )"Missing PLTE before IDAT");
      }
    }
#line 214
    png_ptr->process_mode = 2;
#line 216
    if ((png_ptr->mode & 0x04U) != 0U) {
#line 217
      if ((png_ptr->mode & 0x2000U) == 0U) {
#line 218
        if (png_ptr->push_length == 0U) {
#line 219
          return;
        }
      }
    }
#line 221
    png_ptr->mode |= 0x04U;
#line 223
    if ((png_ptr->mode & 8U) != 0U) {
#line 224
      png_benign_error((png_const_structrp )png_ptr, (png_const_charp )"Too many IDATs found");
    }
  }
#line 227
  if (chunk_name == ((((73U << 24) | (72U << 16)) | (68U << 8)) | 82U)) {
#line 229
    if (png_ptr->push_length != 13U) {
#line 230
      png_error((png_const_structrp )png_ptr, (png_const_charp )"Invalid IHDR length");
    }
#line 232
    if ((size_t )(png_ptr->push_length + 4U) > png_ptr->buffer_size) {
#line 232
      png_push_save_buffer(png_ptr);
#line 232
      return;
    }
#line 233
    png_handle_IHDR(png_ptr, info_ptr, png_ptr->push_length);
  } else
#line 236
  if (chunk_name == ((((73U << 24) | (69U << 16)) | (78U << 8)) | 68U)) {
#line 238
    if ((size_t )(png_ptr->push_length + 4U) > png_ptr->buffer_size) {
#line 238
      png_push_save_buffer(png_ptr);
#line 238
      return;
    }
#line 239
    png_handle_IEND(png_ptr, info_ptr, png_ptr->push_length);
#line 241
    png_ptr->process_mode = 6;
#line 242
    png_push_have_end(png_ptr, info_ptr);
  } else {
#line 246
    keep = png_chunk_unknown_handling((png_const_structrp )png_ptr, chunk_name);
#line 246
    if (keep != 0) {
#line 248
      if ((size_t )(png_ptr->push_length + 4U) > png_ptr->buffer_size) {
#line 248
        png_push_save_buffer(png_ptr);
#line 248
        return;
      }
#line 249
      png_handle_unknown(png_ptr, info_ptr, png_ptr->push_length, keep);
#line 251
      if (chunk_name == ((((80U << 24) | (76U << 16)) | (84U << 8)) | 69U)) {
#line 252
        png_ptr->mode |= 2U;
      }
    } else
#line 256
    if (chunk_name == ((((80U << 24) | (76U << 16)) | (84U << 8)) | 69U)) {
#line 258
      if ((size_t )(png_ptr->push_length + 4U) > png_ptr->buffer_size) {
#line 258
        png_push_save_buffer(png_ptr);
#line 258
        return;
      }
#line 259
      png_handle_PLTE(png_ptr, info_ptr, png_ptr->push_length);
    } else
#line 262
    if (chunk_name == ((((73U << 24) | (68U << 16)) | (65U << 8)) | 84U)) {
#line 264
      png_ptr->idat_size = png_ptr->push_length;
#line 265
      png_ptr->process_mode = 2;
#line 266
      png_push_have_info(png_ptr, info_ptr);
#line 267
      if ((int )png_ptr->pixel_depth >= 8) {
#line 267
        tmp = (size_t )png_ptr->iwidth * ((size_t )png_ptr->pixel_depth >> 3);
      } else {
#line 267
        tmp = ((size_t )png_ptr->iwidth * (size_t )png_ptr->pixel_depth + 7UL) >> 3;
      }
#line 267
      png_ptr->zstream.avail_out = (uInt )tmp + 1U;
#line 270
      png_ptr->zstream.next_out = png_ptr->row_buf;
#line 271
      return;
    } else
#line 275
    if (png_ptr->chunk_name == ((((103U << 24) | (65U << 16)) | (77U << 8)) | 65U)) {
#line 277
      if ((size_t )(png_ptr->push_length + 4U) > png_ptr->buffer_size) {
#line 277
        png_push_save_buffer(png_ptr);
#line 277
        return;
      }
#line 278
      png_handle_gAMA(png_ptr, info_ptr, png_ptr->push_length);
    } else
#line 283
    if (png_ptr->chunk_name == ((((115U << 24) | (66U << 16)) | (73U << 8)) | 84U)) {
#line 285
      if ((size_t )(png_ptr->push_length + 4U) > png_ptr->buffer_size) {
#line 285
        png_push_save_buffer(png_ptr);
#line 285
        return;
      }
#line 286
      png_handle_sBIT(png_ptr, info_ptr, png_ptr->push_length);
    } else
#line 291
    if (png_ptr->chunk_name == ((((99U << 24) | (72U << 16)) | (82U << 8)) | 77U)) {
#line 293
      if ((size_t )(png_ptr->push_length + 4U) > png_ptr->buffer_size) {
#line 293
        png_push_save_buffer(png_ptr);
#line 293
        return;
      }
#line 294
      png_handle_cHRM(png_ptr, info_ptr, png_ptr->push_length);
    } else
#line 299
    if (chunk_name == ((((115U << 24) | (82U << 16)) | (71U << 8)) | 66U)) {
#line 301
      if ((size_t )(png_ptr->push_length + 4U) > png_ptr->buffer_size) {
#line 301
        png_push_save_buffer(png_ptr);
#line 301
        return;
      }
#line 302
      png_handle_sRGB(png_ptr, info_ptr, png_ptr->push_length);
    } else
#line 307
    if (png_ptr->chunk_name == ((((105U << 24) | (67U << 16)) | (67U << 8)) | 80U)) {
#line 309
      if ((size_t )(png_ptr->push_length + 4U) > png_ptr->buffer_size) {
#line 309
        png_push_save_buffer(png_ptr);
#line 309
        return;
      }
#line 310
      png_handle_iCCP(png_ptr, info_ptr, png_ptr->push_length);
    } else
#line 315
    if (chunk_name == ((((115U << 24) | (80U << 16)) | (76U << 8)) | 84U)) {
#line 317
      if ((size_t )(png_ptr->push_length + 4U) > png_ptr->buffer_size) {
#line 317
        png_push_save_buffer(png_ptr);
#line 317
        return;
      }
#line 318
      png_handle_sPLT(png_ptr, info_ptr, png_ptr->push_length);
    } else
#line 323
    if (chunk_name == ((((116U << 24) | (82U << 16)) | (78U << 8)) | 83U)) {
#line 325
      if ((size_t )(png_ptr->push_length + 4U) > png_ptr->buffer_size) {
#line 325
        png_push_save_buffer(png_ptr);
#line 325
        return;
      }
#line 326
      png_handle_tRNS(png_ptr, info_ptr, png_ptr->push_length);
    } else
#line 331
    if (chunk_name == ((((98U << 24) | (75U << 16)) | (71U << 8)) | 68U)) {
#line 333
      if ((size_t )(png_ptr->push_length + 4U) > png_ptr->buffer_size) {
#line 333
        png_push_save_buffer(png_ptr);
#line 333
        return;
      }
#line 334
      png_handle_bKGD(png_ptr, info_ptr, png_ptr->push_length);
    } else
#line 339
    if (chunk_name == ((((104U << 24) | (73U << 16)) | (83U << 8)) | 84U)) {
#line 341
      if ((size_t )(png_ptr->push_length + 4U) > png_ptr->buffer_size) {
#line 341
        png_push_save_buffer(png_ptr);
#line 341
        return;
      }
#line 342
      png_handle_hIST(png_ptr, info_ptr, png_ptr->push_length);
    } else
#line 347
    if (chunk_name == ((((112U << 24) | (72U << 16)) | (89U << 8)) | 115U)) {
#line 349
      if ((size_t )(png_ptr->push_length + 4U) > png_ptr->buffer_size) {
#line 349
        png_push_save_buffer(png_ptr);
#line 349
        return;
      }
#line 350
      png_handle_pHYs(png_ptr, info_ptr, png_ptr->push_length);
    } else
#line 355
    if (chunk_name == ((((111U << 24) | (70U << 16)) | (70U << 8)) | 115U)) {
#line 357
      if ((size_t )(png_ptr->push_length + 4U) > png_ptr->buffer_size) {
#line 357
        png_push_save_buffer(png_ptr);
#line 357
        return;
      }
#line 358
      png_handle_oFFs(png_ptr, info_ptr, png_ptr->push_length);
    } else
#line 363
    if (chunk_name == ((((112U << 24) | (67U << 16)) | (65U << 8)) | 76U)) {
#line 365
      if ((size_t )(png_ptr->push_length + 4U) > png_ptr->buffer_size) {
#line 365
        png_push_save_buffer(png_ptr);
#line 365
        return;
      }
#line 366
      png_handle_pCAL(png_ptr, info_ptr, png_ptr->push_length);
    } else
#line 371
    if (chunk_name == ((((115U << 24) | (67U << 16)) | (65U << 8)) | 76U)) {
#line 373
      if ((size_t )(png_ptr->push_length + 4U) > png_ptr->buffer_size) {
#line 373
        png_push_save_buffer(png_ptr);
#line 373
        return;
      }
#line 374
      png_handle_sCAL(png_ptr, info_ptr, png_ptr->push_length);
    } else
#line 379
    if (chunk_name == ((((116U << 24) | (73U << 16)) | (77U << 8)) | 69U)) {
#line 381
      if ((size_t )(png_ptr->push_length + 4U) > png_ptr->buffer_size) {
#line 381
        png_push_save_buffer(png_ptr);
#line 381
        return;
      }
#line 382
      png_handle_tIME(png_ptr, info_ptr, png_ptr->push_length);
    } else
#line 387
    if (chunk_name == ((((116U << 24) | (69U << 16)) | (88U << 8)) | 116U)) {
#line 389
      if ((size_t )(png_ptr->push_length + 4U) > png_ptr->buffer_size) {
#line 389
        png_push_save_buffer(png_ptr);
#line 389
        return;
      }
#line 390
      png_handle_tEXt(png_ptr, info_ptr, png_ptr->push_length);
    } else
#line 395
    if (chunk_name == ((((122U << 24) | (84U << 16)) | (88U << 8)) | 116U)) {
#line 397
      if ((size_t )(png_ptr->push_length + 4U) > png_ptr->buffer_size) {
#line 397
        png_push_save_buffer(png_ptr);
#line 397
        return;
      }
#line 398
      png_handle_zTXt(png_ptr, info_ptr, png_ptr->push_length);
    } else
#line 403
    if (chunk_name == ((((105U << 24) | (84U << 16)) | (88U << 8)) | 116U)) {
#line 405
      if ((size_t )(png_ptr->push_length + 4U) > png_ptr->buffer_size) {
#line 405
        png_push_save_buffer(png_ptr);
#line 405
        return;
      }
#line 406
      png_handle_iTXt(png_ptr, info_ptr, png_ptr->push_length);
    } else {
#line 412
      if ((size_t )(png_ptr->push_length + 4U) > png_ptr->buffer_size) {
#line 412
        png_push_save_buffer(png_ptr);
#line 412
        return;
      }
#line 413
      png_handle_unknown(png_ptr, info_ptr, png_ptr->push_length, 0);
    }
  }
#line 417
  png_ptr->mode &= 4294967039U;
#line 418
  return;
}
}
#line 420 "/home/goblint2/bench/libpng-1.6.39/pngpread.c"
void png_push_fill_buffer(png_structp png_ptr , png_bytep buffer___0 , size_t length )
{
  png_bytep ptr ;
  size_t save_size ;
  size_t save_size___0 ;

  {
#line 425
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 426
    return;
  }
#line 428
  ptr = buffer___0;
#line 429
  if (png_ptr->save_buffer_size != 0UL) {
#line 433
    if (length < png_ptr->save_buffer_size) {
#line 434
      save_size = length;
    } else {
#line 437
      save_size = png_ptr->save_buffer_size;
    }
#line 439
    memcpy((void *)ptr, (void const   *)png_ptr->save_buffer_ptr, save_size);
#line 440
    length -= save_size;
#line 441
    ptr += save_size;
#line 442
    png_ptr->buffer_size -= save_size;
#line 443
    png_ptr->save_buffer_size -= save_size;
#line 444
    png_ptr->save_buffer_ptr += save_size;
  }
#line 446
  if (length != 0UL) {
#line 446
    if (png_ptr->current_buffer_size != 0UL) {
#line 450
      if (length < png_ptr->current_buffer_size) {
#line 451
        save_size___0 = length;
      } else {
#line 454
        save_size___0 = png_ptr->current_buffer_size;
      }
#line 456
      memcpy((void *)ptr, (void const   *)png_ptr->current_buffer_ptr, save_size___0);
#line 457
      png_ptr->buffer_size -= save_size___0;
#line 458
      png_ptr->current_buffer_size -= save_size___0;
#line 459
      png_ptr->current_buffer_ptr += save_size___0;
    }
  }
#line 461
  return;
}
}
#line 463 "/home/goblint2/bench/libpng-1.6.39/pngpread.c"
void png_push_save_buffer(png_structrp png_ptr )
{
  size_t i ;
  size_t istop ;
  png_bytep sp ;
  png_bytep dp ;
  size_t new_max ;
  png_bytep old_buffer ;
  png_voidp __attribute__((__malloc__))  tmp ;

  {
#line 466
  if (png_ptr->save_buffer_size != 0UL) {
#line 468
    if ((unsigned long )png_ptr->save_buffer_ptr != (unsigned long )png_ptr->save_buffer) {
#line 474
      istop = png_ptr->save_buffer_size;
#line 475
      i = (size_t )0;
#line 475
      sp = png_ptr->save_buffer_ptr;
#line 475
      dp = png_ptr->save_buffer;
      {
#line 475
      while (1) {
        while_continue: /* CIL Label */ ;
#line 475
        if (! (i < istop)) {
#line 475
          goto while_break;
        }
#line 478
        *dp = *sp;
#line 475
        i ++;
#line 475
        sp ++;
#line 475
        dp ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 482
  if (png_ptr->save_buffer_size + png_ptr->current_buffer_size > png_ptr->save_buffer_max) {
#line 488
    if (png_ptr->save_buffer_size > 18446744073709551615UL - (png_ptr->current_buffer_size + 256UL)) {
#line 491
      png_error((png_const_structrp )png_ptr, (png_const_charp )"Potential overflow of save_buffer");
    }
#line 494
    new_max = (png_ptr->save_buffer_size + png_ptr->current_buffer_size) + 256UL;
#line 495
    old_buffer = png_ptr->save_buffer;
#line 496
    tmp = png_malloc_warn((png_const_structrp )png_ptr, new_max);
#line 496
    png_ptr->save_buffer = (png_bytep )tmp;
#line 499
    if ((unsigned long )png_ptr->save_buffer == (unsigned long )((void *)0)) {
#line 501
      png_free((png_const_structrp )png_ptr, (png_voidp )old_buffer);
#line 502
      png_error((png_const_structrp )png_ptr, (png_const_charp )"Insufficient memory for save_buffer");
    }
#line 505
    if (old_buffer) {
#line 506
      memcpy((void *)png_ptr->save_buffer, (void const   *)old_buffer, png_ptr->save_buffer_size);
    } else
#line 507
    if (png_ptr->save_buffer_size) {
#line 508
      png_error((png_const_structrp )png_ptr, (png_const_charp )"save_buffer error");
    }
#line 509
    png_free((png_const_structrp )png_ptr, (png_voidp )old_buffer);
#line 510
    png_ptr->save_buffer_max = new_max;
  }
#line 512
  if (png_ptr->current_buffer_size) {
#line 514
    memcpy((void *)(png_ptr->save_buffer + png_ptr->save_buffer_size), (void const   *)png_ptr->current_buffer_ptr,
           png_ptr->current_buffer_size);
#line 516
    png_ptr->save_buffer_size += png_ptr->current_buffer_size;
#line 517
    png_ptr->current_buffer_size = (size_t )0;
  }
#line 519
  png_ptr->save_buffer_ptr = png_ptr->save_buffer;
#line 520
  png_ptr->buffer_size = (size_t )0;
#line 521
  return;
}
}
#line 523 "/home/goblint2/bench/libpng-1.6.39/pngpread.c"
void png_push_restore_buffer(png_structrp png_ptr , png_bytep buffer___0 , size_t buffer_length )
{


  {
#line 527
  png_ptr->current_buffer = buffer___0;
#line 528
  png_ptr->current_buffer_size = buffer_length;
#line 529
  png_ptr->buffer_size = buffer_length + png_ptr->save_buffer_size;
#line 530
  png_ptr->current_buffer_ptr = png_ptr->current_buffer;
#line 531
  return;
}
}
#line 533 "/home/goblint2/bench/libpng-1.6.39/pngpread.c"
void png_push_read_IDAT(png_structrp png_ptr )
{
  png_byte chunk_length[4] ;
  png_byte chunk_tag[4] ;
  size_t save_size ;
  png_uint_32 idat_size ;
  size_t save_size___0 ;
  png_uint_32 idat_size___0 ;

  {
#line 536
  if ((png_ptr->mode & 0x100U) == 0U) {
#line 542
    if (png_ptr->buffer_size < 8UL) {
#line 542
      png_push_save_buffer(png_ptr);
#line 542
      return;
    }
#line 543
    png_push_fill_buffer((png_structp )png_ptr, chunk_length, (size_t )4);
#line 544
    png_ptr->push_length = png_get_uint_31((png_const_structrp )png_ptr, (png_const_bytep )(chunk_length));
#line 545
    png_reset_crc(png_ptr);
#line 546
    png_crc_read(png_ptr, chunk_tag, (png_uint_32 )4);
#line 547
    png_ptr->chunk_name = ((((png_uint_32 )(0xff & (int )chunk_tag[0]) << 24) | ((png_uint_32 )(0xff & (int )chunk_tag[1]) << 16)) | ((png_uint_32 )(0xff & (int )chunk_tag[2]) << 8)) | (png_uint_32 )(0xff & (int )chunk_tag[3]);
#line 548
    png_ptr->mode |= 0x100U;
#line 550
    if (png_ptr->chunk_name != ((((73U << 24) | (68U << 16)) | (65U << 8)) | 84U)) {
#line 552
      png_ptr->process_mode = 1;
#line 554
      if ((png_ptr->flags & 0x0008U) == 0U) {
#line 555
        png_error((png_const_structrp )png_ptr, (png_const_charp )"Not enough compressed data");
      }
#line 557
      return;
    }
#line 560
    png_ptr->idat_size = png_ptr->push_length;
  }
#line 563
  if (png_ptr->idat_size != 0U) {
#line 563
    if (png_ptr->save_buffer_size != 0UL) {
#line 565
      save_size = png_ptr->save_buffer_size;
#line 566
      idat_size = png_ptr->idat_size;
#line 574
      if ((size_t )idat_size < save_size) {
#line 575
        save_size = (size_t )idat_size;
      } else {
#line 578
        idat_size = (png_uint_32 )save_size;
      }
#line 580
      png_calculate_crc(png_ptr, (png_const_bytep )png_ptr->save_buffer_ptr, save_size);
#line 582
      png_process_IDAT_data(png_ptr, png_ptr->save_buffer_ptr, save_size);
#line 584
      png_ptr->idat_size -= idat_size;
#line 585
      png_ptr->buffer_size -= save_size;
#line 586
      png_ptr->save_buffer_size -= save_size;
#line 587
      png_ptr->save_buffer_ptr += save_size;
    }
  }
#line 590
  if (png_ptr->idat_size != 0U) {
#line 590
    if (png_ptr->current_buffer_size != 0UL) {
#line 592
      save_size___0 = png_ptr->current_buffer_size;
#line 593
      idat_size___0 = png_ptr->idat_size;
#line 600
      if ((size_t )idat_size___0 < save_size___0) {
#line 601
        save_size___0 = (size_t )idat_size___0;
      } else {
#line 604
        idat_size___0 = (png_uint_32 )save_size___0;
      }
#line 606
      png_calculate_crc(png_ptr, (png_const_bytep )png_ptr->current_buffer_ptr, save_size___0);
#line 608
      png_process_IDAT_data(png_ptr, png_ptr->current_buffer_ptr, save_size___0);
#line 610
      png_ptr->idat_size -= idat_size___0;
#line 611
      png_ptr->buffer_size -= save_size___0;
#line 612
      png_ptr->current_buffer_size -= save_size___0;
#line 613
      png_ptr->current_buffer_ptr += save_size___0;
    }
  }
#line 616
  if (png_ptr->idat_size == 0U) {
#line 618
    if (png_ptr->buffer_size < 4UL) {
#line 618
      png_push_save_buffer(png_ptr);
#line 618
      return;
    }
#line 619
    png_crc_finish(png_ptr, (png_uint_32 )0);
#line 620
    png_ptr->mode &= 4294967039U;
#line 621
    png_ptr->mode |= 8U;
#line 622
    png_ptr->zowner = (png_uint_32 )0;
  }
#line 624
  return;
}
}
#line 626 "/home/goblint2/bench/libpng-1.6.39/pngpread.c"
void png_process_IDAT_data(png_structrp png_ptr , png_bytep buffer___0 , size_t buffer_length )
{
  int ret ;
  size_t tmp ;

  {
#line 631
  if (! (buffer_length > 0UL)) {
#line 632
    png_error((png_const_structrp )png_ptr, (png_const_charp )"No IDAT data (internal error)");
  } else
#line 631
  if ((unsigned long )buffer___0 == (unsigned long )((void *)0)) {
#line 632
    png_error((png_const_structrp )png_ptr, (png_const_charp )"No IDAT data (internal error)");
  }
#line 638
  png_ptr->zstream.next_in = (Bytef const   *)buffer___0;
#line 640
  png_ptr->zstream.avail_in = (uInt )buffer_length;
  {
#line 645
  while (1) {
    while_continue: /* CIL Label */ ;
#line 645
    if (png_ptr->zstream.avail_in > 0U) {
#line 645
      if (! ((png_ptr->flags & 0x0008U) == 0U)) {
#line 645
        goto while_break;
      }
    } else {
#line 645
      goto while_break;
    }
#line 655
    if (! (png_ptr->zstream.avail_out > 0U)) {
#line 658
      if ((int )png_ptr->pixel_depth >= 8) {
#line 658
        tmp = (size_t )png_ptr->iwidth * ((size_t )png_ptr->pixel_depth >> 3);
      } else {
#line 658
        tmp = ((size_t )png_ptr->iwidth * (size_t )png_ptr->pixel_depth + 7UL) >> 3;
      }
#line 658
      png_ptr->zstream.avail_out = (uInt )(tmp + 1UL);
#line 661
      png_ptr->zstream.next_out = png_ptr->row_buf;
    }
#line 671
    ret = png_zlib_inflate(png_ptr, 2);
#line 674
    if (ret != 0) {
#line 674
      if (ret != 1) {
#line 677
        png_ptr->flags |= 0x0008U;
#line 678
        png_ptr->zowner = (png_uint_32 )0;
#line 683
        if (png_ptr->row_number >= png_ptr->num_rows) {
#line 685
          png_warning((png_const_structrp )png_ptr, (png_const_charp )"Truncated compressed data in IDAT");
        } else
#line 683
        if ((int )png_ptr->pass > 6) {
#line 685
          png_warning((png_const_structrp )png_ptr, (png_const_charp )"Truncated compressed data in IDAT");
        } else
#line 689
        if (ret == -3) {
#line 690
          png_benign_error((png_const_structrp )png_ptr, (png_const_charp )"IDAT: ADLER32 checksum mismatch");
        } else {
#line 692
          png_error((png_const_structrp )png_ptr, (png_const_charp )"Decompression error in IDAT");
        }
#line 696
        return;
      }
    }
#line 700
    if ((unsigned long )png_ptr->zstream.next_out != (unsigned long )png_ptr->row_buf) {
#line 706
      if (png_ptr->row_number >= png_ptr->num_rows) {
#line 710
        png_warning((png_const_structrp )png_ptr, (png_const_charp )"Extra compressed data in IDAT");
#line 711
        png_ptr->flags |= 0x0008U;
#line 712
        png_ptr->zowner = (png_uint_32 )0;
#line 717
        return;
      } else
#line 706
      if ((int )png_ptr->pass > 6) {
#line 710
        png_warning((png_const_structrp )png_ptr, (png_const_charp )"Extra compressed data in IDAT");
#line 711
        png_ptr->flags |= 0x0008U;
#line 712
        png_ptr->zowner = (png_uint_32 )0;
#line 717
        return;
      }
#line 721
      if (png_ptr->zstream.avail_out == 0U) {
#line 722
        png_push_process_row(png_ptr);
      }
    }
#line 726
    if (ret == 1) {
#line 727
      png_ptr->flags |= 0x0008U;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 734
  if (png_ptr->zstream.avail_in > 0U) {
#line 735
    png_warning((png_const_structrp )png_ptr, (png_const_charp )"Extra compression data in IDAT");
  }
#line 736
  return;
}
}
#line 738 "/home/goblint2/bench/libpng-1.6.39/pngpread.c"
void png_push_process_row(png_structrp png_ptr )
{
  png_row_info row_info ;
  int i ;
  int i___0 ;
  int i___1 ;
  int i___2 ;
  int i___3 ;
  int i___4 ;

  {
#line 744
  row_info.width = png_ptr->iwidth;
#line 745
  row_info.color_type = png_ptr->color_type;
#line 746
  row_info.bit_depth = png_ptr->bit_depth;
#line 747
  row_info.channels = png_ptr->channels;
#line 748
  row_info.pixel_depth = png_ptr->pixel_depth;
#line 749
  if ((int )row_info.pixel_depth >= 8) {
#line 749
    row_info.rowbytes = (size_t )row_info.width * ((size_t )row_info.pixel_depth >> 3);
  } else {
#line 749
    row_info.rowbytes = ((size_t )row_info.width * (size_t )row_info.pixel_depth + 7UL) >> 3;
  }
#line 751
  if ((int )*(png_ptr->row_buf + 0) > 0) {
#line 753
    if ((int )*(png_ptr->row_buf + 0) < 5) {
#line 754
      png_read_filter_row(png_ptr, & row_info, png_ptr->row_buf + 1, (png_const_bytep )(png_ptr->prev_row + 1),
                          (int )*(png_ptr->row_buf + 0));
    } else {
#line 757
      png_error((png_const_structrp )png_ptr, (png_const_charp )"bad adaptive filter value");
    }
  }
#line 765
  memcpy((void *)png_ptr->prev_row, (void const   *)png_ptr->row_buf, row_info.rowbytes + 1UL);
#line 768
  if (png_ptr->transformations != 0U) {
#line 769
    png_do_read_transformations(png_ptr, & row_info);
  }
#line 773
  if ((int )png_ptr->transformed_pixel_depth == 0) {
#line 775
    png_ptr->transformed_pixel_depth = row_info.pixel_depth;
#line 776
    if ((int )row_info.pixel_depth > (int )png_ptr->maximum_pixel_depth) {
#line 777
      png_error((png_const_structrp )png_ptr, (png_const_charp )"progressive row overflow");
    }
  } else
#line 780
  if ((int )png_ptr->transformed_pixel_depth != (int )row_info.pixel_depth) {
#line 781
    png_error((png_const_structrp )png_ptr, (png_const_charp )"internal progressive row size calculation error");
  }
#line 786
  if ((int )png_ptr->interlaced != 0) {
#line 786
    if ((png_ptr->transformations & 0x0002U) != 0U) {
#line 789
      if ((int )png_ptr->pass < 6) {
#line 790
        png_do_read_interlace(& row_info, png_ptr->row_buf + 1, (int )png_ptr->pass,
                              png_ptr->transformations);
      }
      {
#line 795
      if ((int )png_ptr->pass == 0) {
#line 795
        goto case_0;
      }
#line 831
      if ((int )png_ptr->pass == 1) {
#line 831
        goto case_1;
      }
#line 852
      if ((int )png_ptr->pass == 2) {
#line 852
        goto case_2;
      }
#line 880
      if ((int )png_ptr->pass == 3) {
#line 880
        goto case_3;
      }
#line 902
      if ((int )png_ptr->pass == 4) {
#line 902
        goto case_4;
      }
#line 927
      if ((int )png_ptr->pass == 5) {
#line 927
        goto case_5;
      }
#line 946
      goto case_6;
      case_0: /* CIL Label */
#line 798
      i = 0;
      {
#line 798
      while (1) {
        while_continue: /* CIL Label */ ;
#line 798
        if (i < 8) {
#line 798
          if (! ((int )png_ptr->pass == 0)) {
#line 798
            goto while_break;
          }
        } else {
#line 798
          goto while_break;
        }
#line 800
        png_push_have_row(png_ptr, png_ptr->row_buf + 1);
#line 801
        png_read_push_finish_row(png_ptr);
#line 798
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 804
      if ((int )png_ptr->pass == 2) {
#line 806
        i = 0;
        {
#line 806
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 806
          if (i < 4) {
#line 806
            if (! ((int )png_ptr->pass == 2)) {
#line 806
              goto while_break___0;
            }
          } else {
#line 806
            goto while_break___0;
          }
#line 808
          png_push_have_row(png_ptr, (png_bytep )((void *)0));
#line 809
          png_read_push_finish_row(png_ptr);
#line 806
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 813
      if ((int )png_ptr->pass == 4) {
#line 813
        if (png_ptr->height <= 4U) {
#line 815
          i = 0;
          {
#line 815
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 815
            if (i < 2) {
#line 815
              if (! ((int )png_ptr->pass == 4)) {
#line 815
                goto while_break___1;
              }
            } else {
#line 815
              goto while_break___1;
            }
#line 817
            png_push_have_row(png_ptr, (png_bytep )((void *)0));
#line 818
            png_read_push_finish_row(png_ptr);
#line 815
            i ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
      }
#line 822
      if ((int )png_ptr->pass == 6) {
#line 822
        if (png_ptr->height <= 4U) {
#line 824
          png_push_have_row(png_ptr, (png_bytep )((void *)0));
#line 825
          png_read_push_finish_row(png_ptr);
        }
      }
#line 828
      goto switch_break;
      case_1: /* CIL Label */
#line 834
      i___0 = 0;
      {
#line 834
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 834
        if (i___0 < 8) {
#line 834
          if (! ((int )png_ptr->pass == 1)) {
#line 834
            goto while_break___2;
          }
        } else {
#line 834
          goto while_break___2;
        }
#line 836
        png_push_have_row(png_ptr, png_ptr->row_buf + 1);
#line 837
        png_read_push_finish_row(png_ptr);
#line 834
        i___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 840
      if ((int )png_ptr->pass == 2) {
#line 842
        i___0 = 0;
        {
#line 842
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 842
          if (i___0 < 4) {
#line 842
            if (! ((int )png_ptr->pass == 2)) {
#line 842
              goto while_break___3;
            }
          } else {
#line 842
            goto while_break___3;
          }
#line 844
          png_push_have_row(png_ptr, (png_bytep )((void *)0));
#line 845
          png_read_push_finish_row(png_ptr);
#line 842
          i___0 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 849
      goto switch_break;
      case_2: /* CIL Label */
#line 856
      i___1 = 0;
      {
#line 856
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 856
        if (i___1 < 4) {
#line 856
          if (! ((int )png_ptr->pass == 2)) {
#line 856
            goto while_break___4;
          }
        } else {
#line 856
          goto while_break___4;
        }
#line 858
        png_push_have_row(png_ptr, png_ptr->row_buf + 1);
#line 859
        png_read_push_finish_row(png_ptr);
#line 856
        i___1 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 862
      i___1 = 0;
      {
#line 862
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 862
        if (i___1 < 4) {
#line 862
          if (! ((int )png_ptr->pass == 2)) {
#line 862
            goto while_break___5;
          }
        } else {
#line 862
          goto while_break___5;
        }
#line 864
        png_push_have_row(png_ptr, (png_bytep )((void *)0));
#line 865
        png_read_push_finish_row(png_ptr);
#line 862
        i___1 ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 868
      if ((int )png_ptr->pass == 4) {
#line 870
        i___1 = 0;
        {
#line 870
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 870
          if (i___1 < 2) {
#line 870
            if (! ((int )png_ptr->pass == 4)) {
#line 870
              goto while_break___6;
            }
          } else {
#line 870
            goto while_break___6;
          }
#line 872
          png_push_have_row(png_ptr, (png_bytep )((void *)0));
#line 873
          png_read_push_finish_row(png_ptr);
#line 870
          i___1 ++;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
#line 877
      goto switch_break;
      case_3: /* CIL Label */
#line 884
      i___2 = 0;
      {
#line 884
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 884
        if (i___2 < 4) {
#line 884
          if (! ((int )png_ptr->pass == 3)) {
#line 884
            goto while_break___7;
          }
        } else {
#line 884
          goto while_break___7;
        }
#line 886
        png_push_have_row(png_ptr, png_ptr->row_buf + 1);
#line 887
        png_read_push_finish_row(png_ptr);
#line 884
        i___2 ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 890
      if ((int )png_ptr->pass == 4) {
#line 892
        i___2 = 0;
        {
#line 892
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 892
          if (i___2 < 2) {
#line 892
            if (! ((int )png_ptr->pass == 4)) {
#line 892
              goto while_break___8;
            }
          } else {
#line 892
            goto while_break___8;
          }
#line 894
          png_push_have_row(png_ptr, (png_bytep )((void *)0));
#line 895
          png_read_push_finish_row(png_ptr);
#line 892
          i___2 ++;
        }
        while_break___8: /* CIL Label */ ;
        }
      }
#line 899
      goto switch_break;
      case_4: /* CIL Label */
#line 906
      i___3 = 0;
      {
#line 906
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 906
        if (i___3 < 2) {
#line 906
          if (! ((int )png_ptr->pass == 4)) {
#line 906
            goto while_break___9;
          }
        } else {
#line 906
          goto while_break___9;
        }
#line 908
        png_push_have_row(png_ptr, png_ptr->row_buf + 1);
#line 909
        png_read_push_finish_row(png_ptr);
#line 906
        i___3 ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 912
      i___3 = 0;
      {
#line 912
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 912
        if (i___3 < 2) {
#line 912
          if (! ((int )png_ptr->pass == 4)) {
#line 912
            goto while_break___10;
          }
        } else {
#line 912
          goto while_break___10;
        }
#line 914
        png_push_have_row(png_ptr, (png_bytep )((void *)0));
#line 915
        png_read_push_finish_row(png_ptr);
#line 912
        i___3 ++;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 918
      if ((int )png_ptr->pass == 6) {
#line 920
        png_push_have_row(png_ptr, (png_bytep )((void *)0));
#line 921
        png_read_push_finish_row(png_ptr);
      }
#line 924
      goto switch_break;
      case_5: /* CIL Label */
#line 931
      i___4 = 0;
      {
#line 931
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 931
        if (i___4 < 2) {
#line 931
          if (! ((int )png_ptr->pass == 5)) {
#line 931
            goto while_break___11;
          }
        } else {
#line 931
          goto while_break___11;
        }
#line 933
        png_push_have_row(png_ptr, png_ptr->row_buf + 1);
#line 934
        png_read_push_finish_row(png_ptr);
#line 931
        i___4 ++;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 937
      if ((int )png_ptr->pass == 6) {
#line 939
        png_push_have_row(png_ptr, (png_bytep )((void *)0));
#line 940
        png_read_push_finish_row(png_ptr);
      }
#line 943
      goto switch_break;
      case_6: /* CIL Label */
      switch_default: /* CIL Label */
#line 949
      png_push_have_row(png_ptr, png_ptr->row_buf + 1);
#line 950
      png_read_push_finish_row(png_ptr);
#line 952
      if ((int )png_ptr->pass != 6) {
#line 953
        goto switch_break;
      }
#line 955
      png_push_have_row(png_ptr, (png_bytep )((void *)0));
#line 956
      png_read_push_finish_row(png_ptr);
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 963
      png_push_have_row(png_ptr, png_ptr->row_buf + 1);
#line 964
      png_read_push_finish_row(png_ptr);
    }
  } else {
#line 963
    png_push_have_row(png_ptr, png_ptr->row_buf + 1);
#line 964
    png_read_push_finish_row(png_ptr);
  }
#line 966
  return;
}
}
#line 975 "/home/goblint2/bench/libpng-1.6.39/pngpread.c"
static png_byte const   png_pass_start[7]  = {      (png_byte const   )0,      (png_byte const   )4,      (png_byte const   )0,      (png_byte const   )2,
        (png_byte const   )0,      (png_byte const   )1,      (png_byte const   )0};
#line 978 "/home/goblint2/bench/libpng-1.6.39/pngpread.c"
static png_byte const   png_pass_inc[7]  = {      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )4,      (png_byte const   )4,
        (png_byte const   )2,      (png_byte const   )2,      (png_byte const   )1};
#line 981 "/home/goblint2/bench/libpng-1.6.39/pngpread.c"
static png_byte const   png_pass_ystart[7]  = {      (png_byte const   )0,      (png_byte const   )0,      (png_byte const   )4,      (png_byte const   )0,
        (png_byte const   )2,      (png_byte const   )0,      (png_byte const   )1};
#line 984 "/home/goblint2/bench/libpng-1.6.39/pngpread.c"
static png_byte const   png_pass_yinc[7]  = {      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )4,
        (png_byte const   )4,      (png_byte const   )2,      (png_byte const   )2};
#line 968 "/home/goblint2/bench/libpng-1.6.39/pngpread.c"
void png_read_push_finish_row(png_structrp png_ptr )
{


  {
#line 992
  (png_ptr->row_number) ++;
#line 993
  if (png_ptr->row_number < png_ptr->num_rows) {
#line 994
    return;
  }
#line 997
  if ((int )png_ptr->interlaced != 0) {
#line 999
    png_ptr->row_number = (png_uint_32 )0;
#line 1000
    memset((void *)png_ptr->prev_row, 0, png_ptr->rowbytes + 1UL);
    {
#line 1002
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1004
      png_ptr->pass = (png_byte )((int )png_ptr->pass + 1);
#line 1005
      if ((int )png_ptr->pass == 1) {
#line 1005
        if (png_ptr->width < 5U) {
#line 1008
          png_ptr->pass = (png_byte )((int )png_ptr->pass + 1);
        } else {
#line 1005
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */
#line 1005
      if ((int )png_ptr->pass == 3) {
#line 1005
        if (png_ptr->width < 3U) {
#line 1008
          png_ptr->pass = (png_byte )((int )png_ptr->pass + 1);
        } else {
#line 1005
          goto _L;
        }
      } else
      _L: /* CIL Label */
#line 1005
      if ((int )png_ptr->pass == 5) {
#line 1005
        if (png_ptr->width < 2U) {
#line 1008
          png_ptr->pass = (png_byte )((int )png_ptr->pass + 1);
        }
      }
#line 1010
      if ((int )png_ptr->pass > 7) {
#line 1011
        png_ptr->pass = (png_byte )((int )png_ptr->pass - 1);
      }
#line 1013
      if ((int )png_ptr->pass >= 7) {
#line 1014
        goto while_break;
      }
#line 1016
      png_ptr->iwidth = (((png_ptr->width + (png_uint_32 )png_pass_inc[png_ptr->pass]) - 1U) - (png_uint_32 )png_pass_start[png_ptr->pass]) / (png_uint_32 )png_pass_inc[png_ptr->pass];
#line 1021
      if ((png_ptr->transformations & 0x0002U) != 0U) {
#line 1022
        goto while_break;
      }
#line 1024
      png_ptr->num_rows = (((png_ptr->height + (png_uint_32 )png_pass_yinc[png_ptr->pass]) - 1U) - (png_uint_32 )png_pass_ystart[png_ptr->pass]) / (png_uint_32 )png_pass_yinc[png_ptr->pass];
#line 1002
      if (! (png_ptr->iwidth == 0U)) {
#line 1002
        if (! (png_ptr->num_rows == 0U)) {
#line 1002
          goto while_break;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1032
  return;
}
}
#line 1034 "/home/goblint2/bench/libpng-1.6.39/pngpread.c"
void png_push_have_info(png_structrp png_ptr , png_inforp info_ptr )
{


  {
#line 1037
  if ((unsigned long )png_ptr->info_fn != (unsigned long )((void *)0)) {
#line 1038
    (*(png_ptr->info_fn))((png_structp )png_ptr, (png_infop )info_ptr);
  }
#line 1039
  return;
}
}
#line 1041 "/home/goblint2/bench/libpng-1.6.39/pngpread.c"
void png_push_have_end(png_structrp png_ptr , png_inforp info_ptr )
{


  {
#line 1044
  if ((unsigned long )png_ptr->end_fn != (unsigned long )((void *)0)) {
#line 1045
    (*(png_ptr->end_fn))((png_structp )png_ptr, (png_infop )info_ptr);
  }
#line 1046
  return;
}
}
#line 1048 "/home/goblint2/bench/libpng-1.6.39/pngpread.c"
void png_push_have_row(png_structrp png_ptr , png_bytep row )
{


  {
#line 1051
  if ((unsigned long )png_ptr->row_fn != (unsigned long )((void *)0)) {
#line 1052
    (*(png_ptr->row_fn))((png_structp )png_ptr, row, png_ptr->row_number, (int )png_ptr->pass);
  }
#line 1054
  return;
}
}
#line 1057 "/home/goblint2/bench/libpng-1.6.39/pngpread.c"
void png_progressive_combine_row(png_const_structrp png_ptr , png_bytep old_row ,
                                 png_const_bytep new_row )
{


  {
#line 1061
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1062
    return;
  }
#line 1068
  if ((unsigned long )new_row != (unsigned long )((void *)0)) {
#line 1069
    png_combine_row(png_ptr, old_row, 1);
  }
#line 1070
  return;
}
}
#line 1073 "/home/goblint2/bench/libpng-1.6.39/pngpread.c"
void png_set_progressive_read_fn(png_structrp png_ptr , png_voidp progressive_ptr ,
                                 void (*info_fn)(png_structp  , png_infop  ) , void (*row_fn)(png_structp  ,
                                                                                              png_bytep  ,
                                                                                              png_uint_32  ,
                                                                                              int  ) ,
                                 void (*end_fn)(png_structp  , png_infop  ) )
{


  {
#line 1078
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1079
    return;
  }
#line 1081
  png_ptr->info_fn = info_fn;
#line 1082
  png_ptr->row_fn = row_fn;
#line 1083
  png_ptr->end_fn = end_fn;
#line 1085
  png_set_read_fn(png_ptr, progressive_ptr, & png_push_fill_buffer);
#line 1086
  return;
}
}
#line 1088 "/home/goblint2/bench/libpng-1.6.39/pngpread.c"
png_voidp png_get_progressive_ptr(png_const_structrp png_ptr )
{


  {
#line 1091
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1092
    return ((void *)0);
  }
#line 1094
  return ((png_voidp )png_ptr->io_ptr);
}
}
#line 101 "/usr/include/stdlib.h"
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 104
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 107
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 112
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__leaf__, __gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__,
__nothrow__)) ;
#line 820
__inline extern void *( __attribute__((__warn_unused_result__, __nonnull__(1,2,5),
__gnu_inline__)) bsearch)(void const   *__key , void const   *__base , size_t __nmemb ,
                          size_t __size , int (*__compar)(void const   * , void const   * ) ) ;
#line 929
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar )  __attribute__((__nothrow__)) ;
#line 933
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t *__dst , char const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 936
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) wcstombs)(char *__dst , wchar_t const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 43 "/usr/include/string.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memcpy)(void *__dest , void const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 47
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 61
__inline extern void *( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) memset)(void *__dest , int __ch , size_t __len )  __attribute__((__nothrow__)) ;
#line 122
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcpy)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 125
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncpy)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 130
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcat)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 133
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncat)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 326 "/usr/include/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) fprintf)(FILE *__stream ,
                                                                                                  char const   *__fmt
                                                                                                  , ...) ;
#line 332
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) printf)(char const   *__fmt
                                                                                                 , ...) ;
#line 334
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) sprintf)(char *__s ,
                                                                                                            char const   *__fmt
                                                                                                            , ...)  __attribute__((__nothrow__)) ;
#line 341
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vfprintf)(FILE *__stream ,
                                                                                                   char const   *__fmt ,
                                                                                                   __gnuc_va_list __ap ) ;
#line 347
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vprintf)(char const   *__fmt ,
                                                                                                  __gnuc_va_list __ap ) ;
#line 349
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vsprintf)(char *__s ,
                                                                                                             char const   *__fmt ,
                                                                                                             __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 354
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) snprintf)(char *__s , size_t __n , char const   *__fmt
                                              , ...)  __attribute__((__nothrow__)) ;
#line 358
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) vsnprintf)(char *__s , size_t __n , char const   *__fmt ,
                                               __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 492
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
#line 528
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
#line 564
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fgets)(char *__s , int __n , FILE *__stream ) ;
#line 646
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fread)(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 360 "/usr/include/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) read)(int __fd , void *__buf , size_t __nbytes ) ;
#line 511
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size )  __attribute__((__nothrow__)) ;
#line 689
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list )  __attribute__((__nothrow__)) ;
#line 774
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                               size_t __buflen )  __attribute__((__nothrow__)) ;
#line 37 "/usr/include/errno.h"
extern int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__nothrow__,
__const__)) ;
#line 25 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
png_structp __attribute__((__malloc__))  png_create_read_struct(png_const_charp user_png_ver ,
                                                                png_voidp error_ptr ,
                                                                void (*error_fn)(png_structp  ,
                                                                                 png_const_charp  ) ,
                                                                void (*warn_fn)(png_structp  ,
                                                                                png_const_charp  ) )
{
  png_structp __attribute__((__malloc__))  tmp ;

  {
#line 33
  tmp = png_create_read_struct_2(user_png_ver, error_ptr, error_fn, warn_fn, (void *)0,
                                 (png_voidp (*)(png_structp  , png_alloc_size_t  ))((void *)0),
                                 (void (*)(png_structp  , png_voidp  ))((void *)0));
#line 33
  return (tmp);
}
}
#line 40 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
png_structp __attribute__((__malloc__))  png_create_read_struct_2(png_const_charp user_png_ver ,
                                                                  png_voidp error_ptr ,
                                                                  void (*error_fn)(png_structp  ,
                                                                                   png_const_charp  ) ,
                                                                  void (*warn_fn)(png_structp  ,
                                                                                  png_const_charp  ) ,
                                                                  png_voidp mem_ptr ,
                                                                  png_voidp (*malloc_fn)(png_structp  ,
                                                                                         png_alloc_size_t  ) ,
                                                                  void (*free_fn)(png_structp  ,
                                                                                  png_voidp  ) )
{
  png_structp png_ptr ;
  png_structp __attribute__((__malloc__))  tmp ;

  {
#line 45
  tmp = png_create_png_struct(user_png_ver, error_ptr, error_fn, warn_fn, mem_ptr,
                              malloc_fn, free_fn);
#line 45
  png_ptr = (png_structp )tmp;
#line 49
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 51
    png_ptr->mode = 0x8000U;
#line 57
    png_ptr->IDAT_read_size = (uInt )8192;
#line 61
    png_ptr->flags |= 0x100000U;
#line 67
    png_ptr->flags |= 0x200000U;
#line 75
    png_set_read_fn((png_structrp )png_ptr, (void *)0, (void (*)(png_structp  , png_bytep  ,
                                                                 size_t  ))((void *)0));
  }
#line 78
  return ((png_structp __attribute__((__malloc__))  )png_ptr);
}
}
#line 91 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
void png_read_info(png_structrp png_ptr , png_inforp info_ptr )
{
  int keep ;
  png_uint_32 length ;
  png_uint_32 tmp ;
  png_uint_32 chunk_name ;

  {
#line 100
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 101
    return;
  } else
#line 100
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 101
    return;
  }
#line 104
  png_read_sig(png_ptr, info_ptr);
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    tmp = png_read_chunk_header(png_ptr);
#line 108
    length = tmp;
#line 109
    chunk_name = png_ptr->chunk_name;
#line 114
    if (chunk_name == ((((73U << 24) | (68U << 16)) | (65U << 8)) | 84U)) {
#line 116
      if ((png_ptr->mode & 1U) == 0U) {
#line 117
        png_chunk_error((png_const_structrp )png_ptr, (png_const_charp )"Missing IHDR before IDAT");
      } else
#line 119
      if ((int )png_ptr->color_type == 3) {
#line 119
        if ((png_ptr->mode & 2U) == 0U) {
#line 121
          png_chunk_error((png_const_structrp )png_ptr, (png_const_charp )"Missing PLTE before IDAT");
        } else {
#line 119
          goto _L;
        }
      } else
      _L: /* CIL Label */
#line 123
      if ((png_ptr->mode & 8U) != 0U) {
#line 124
        png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"Too many IDATs found");
      }
#line 126
      png_ptr->mode |= 0x04U;
    } else
#line 129
    if ((png_ptr->mode & 0x04U) != 0U) {
#line 131
      png_ptr->mode |= 0x2000U;
#line 132
      png_ptr->mode |= 8U;
    }
#line 138
    if (chunk_name == ((((73U << 24) | (72U << 16)) | (68U << 8)) | 82U)) {
#line 139
      png_handle_IHDR(png_ptr, info_ptr, length);
    } else
#line 141
    if (chunk_name == ((((73U << 24) | (69U << 16)) | (78U << 8)) | 68U)) {
#line 142
      png_handle_IEND(png_ptr, info_ptr, length);
    } else {
#line 145
      keep = png_chunk_unknown_handling((png_const_structrp )png_ptr, chunk_name);
#line 145
      if (keep != 0) {
#line 147
        png_handle_unknown(png_ptr, info_ptr, length, keep);
#line 149
        if (chunk_name == ((((80U << 24) | (76U << 16)) | (84U << 8)) | 69U)) {
#line 150
          png_ptr->mode |= 2U;
        } else
#line 152
        if (chunk_name == ((((73U << 24) | (68U << 16)) | (65U << 8)) | 84U)) {
#line 154
          png_ptr->idat_size = (png_uint_32 )0;
#line 155
          goto while_break;
        }
      } else
#line 159
      if (chunk_name == ((((80U << 24) | (76U << 16)) | (84U << 8)) | 69U)) {
#line 160
        png_handle_PLTE(png_ptr, info_ptr, length);
      } else
#line 162
      if (chunk_name == ((((73U << 24) | (68U << 16)) | (65U << 8)) | 84U)) {
#line 164
        png_ptr->idat_size = length;
#line 165
        goto while_break;
      } else
#line 169
      if (chunk_name == ((((98U << 24) | (75U << 16)) | (71U << 8)) | 68U)) {
#line 170
        png_handle_bKGD(png_ptr, info_ptr, length);
      } else
#line 174
      if (chunk_name == ((((99U << 24) | (72U << 16)) | (82U << 8)) | 77U)) {
#line 175
        png_handle_cHRM(png_ptr, info_ptr, length);
      } else
#line 179
      if (chunk_name == ((((101U << 24) | (88U << 16)) | (73U << 8)) | 102U)) {
#line 180
        png_handle_eXIf(png_ptr, info_ptr, length);
      } else
#line 184
      if (chunk_name == ((((103U << 24) | (65U << 16)) | (77U << 8)) | 65U)) {
#line 185
        png_handle_gAMA(png_ptr, info_ptr, length);
      } else
#line 189
      if (chunk_name == ((((104U << 24) | (73U << 16)) | (83U << 8)) | 84U)) {
#line 190
        png_handle_hIST(png_ptr, info_ptr, length);
      } else
#line 194
      if (chunk_name == ((((111U << 24) | (70U << 16)) | (70U << 8)) | 115U)) {
#line 195
        png_handle_oFFs(png_ptr, info_ptr, length);
      } else
#line 199
      if (chunk_name == ((((112U << 24) | (67U << 16)) | (65U << 8)) | 76U)) {
#line 200
        png_handle_pCAL(png_ptr, info_ptr, length);
      } else
#line 204
      if (chunk_name == ((((115U << 24) | (67U << 16)) | (65U << 8)) | 76U)) {
#line 205
        png_handle_sCAL(png_ptr, info_ptr, length);
      } else
#line 209
      if (chunk_name == ((((112U << 24) | (72U << 16)) | (89U << 8)) | 115U)) {
#line 210
        png_handle_pHYs(png_ptr, info_ptr, length);
      } else
#line 214
      if (chunk_name == ((((115U << 24) | (66U << 16)) | (73U << 8)) | 84U)) {
#line 215
        png_handle_sBIT(png_ptr, info_ptr, length);
      } else
#line 219
      if (chunk_name == ((((115U << 24) | (82U << 16)) | (71U << 8)) | 66U)) {
#line 220
        png_handle_sRGB(png_ptr, info_ptr, length);
      } else
#line 224
      if (chunk_name == ((((105U << 24) | (67U << 16)) | (67U << 8)) | 80U)) {
#line 225
        png_handle_iCCP(png_ptr, info_ptr, length);
      } else
#line 229
      if (chunk_name == ((((115U << 24) | (80U << 16)) | (76U << 8)) | 84U)) {
#line 230
        png_handle_sPLT(png_ptr, info_ptr, length);
      } else
#line 234
      if (chunk_name == ((((116U << 24) | (69U << 16)) | (88U << 8)) | 116U)) {
#line 235
        png_handle_tEXt(png_ptr, info_ptr, length);
      } else
#line 239
      if (chunk_name == ((((116U << 24) | (73U << 16)) | (77U << 8)) | 69U)) {
#line 240
        png_handle_tIME(png_ptr, info_ptr, length);
      } else
#line 244
      if (chunk_name == ((((116U << 24) | (82U << 16)) | (78U << 8)) | 83U)) {
#line 245
        png_handle_tRNS(png_ptr, info_ptr, length);
      } else
#line 249
      if (chunk_name == ((((122U << 24) | (84U << 16)) | (88U << 8)) | 116U)) {
#line 250
        png_handle_zTXt(png_ptr, info_ptr, length);
      } else
#line 254
      if (chunk_name == ((((105U << 24) | (84U << 16)) | (88U << 8)) | 116U)) {
#line 255
        png_handle_iTXt(png_ptr, info_ptr, length);
      } else {
#line 259
        png_handle_unknown(png_ptr, info_ptr, length, 0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  return;
}
}
#line 266 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
void png_read_update_info(png_structrp png_ptr , png_inforp info_ptr )
{


  {
#line 271
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 273
    if ((png_ptr->flags & 0x0040U) == 0U) {
#line 275
      png_read_start_row(png_ptr);
#line 278
      png_read_transform_info(png_ptr, info_ptr);
    } else {
#line 286
      png_app_error((png_const_structrp )png_ptr, (png_const_charp )"png_read_update_info/png_start_read_image: duplicate call");
    }
  }
#line 289
  return;
}
}
#line 297 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
void png_start_read_image(png_structrp png_ptr )
{


  {
#line 302
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 304
    if ((png_ptr->flags & 0x0040U) == 0U) {
#line 305
      png_read_start_row(png_ptr);
    } else {
#line 309
      png_app_error((png_const_structrp )png_ptr, (png_const_charp )"png_start_read_image/png_read_update_info: duplicate call");
    }
  }
#line 312
  return;
}
}
#line 320 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
static void png_do_read_intrapixel(png_row_infop row_info , png_bytep row )
{
  int bytes_per_pixel ;
  png_uint_32 row_width ;
  png_bytep rp ;
  png_uint_32 i ;
  png_bytep rp___0 ;
  png_uint_32 i___0 ;
  png_uint_32 s0 ;
  png_uint_32 s1 ;
  png_uint_32 s2 ;
  png_uint_32 red ;
  png_uint_32 blue ;

  {
#line 325
  if (((int )row_info->color_type & 2) != 0) {
#line 329
    row_width = row_info->width;
#line 331
    if ((int )row_info->bit_depth == 8) {
#line 336
      if ((int )row_info->color_type == 2) {
#line 337
        bytes_per_pixel = 3;
      } else
#line 339
      if ((int )row_info->color_type == 6) {
#line 340
        bytes_per_pixel = 4;
      } else {
#line 343
        return;
      }
#line 345
      i = (png_uint_32 )0;
#line 345
      rp = row;
      {
#line 345
      while (1) {
        while_continue: /* CIL Label */ ;
#line 345
        if (! (i < row_width)) {
#line 345
          goto while_break;
        }
#line 347
        *rp = (png_byte )(((256 + (int )*rp) + (int )*(rp + 1)) & 0xff);
#line 348
        *(rp + 2) = (png_byte )(((256 + (int )*(rp + 2)) + (int )*(rp + 1)) & 0xff);
#line 345
        i ++;
#line 345
        rp += bytes_per_pixel;
      }
      while_break: /* CIL Label */ ;
      }
    } else
#line 351
    if ((int )row_info->bit_depth == 16) {
#line 356
      if ((int )row_info->color_type == 2) {
#line 357
        bytes_per_pixel = 6;
      } else
#line 359
      if ((int )row_info->color_type == 6) {
#line 360
        bytes_per_pixel = 8;
      } else {
#line 363
        return;
      }
#line 365
      i___0 = (png_uint_32 )0;
#line 365
      rp___0 = row;
      {
#line 365
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 365
        if (! (i___0 < row_width)) {
#line 365
          goto while_break___0;
        }
#line 367
        s0 = (png_uint_32 )((int )*rp___0 << 8) | (unsigned int )*(rp___0 + 1);
#line 368
        s1 = (png_uint_32 )((int )*(rp___0 + 2) << 8) | (unsigned int )*(rp___0 + 3);
#line 369
        s2 = (png_uint_32 )((int )*(rp___0 + 4) << 8) | (unsigned int )*(rp___0 + 5);
#line 370
        red = ((s0 + s1) + 65536U) & 65535U;
#line 371
        blue = ((s2 + s1) + 65536U) & 65535U;
#line 372
        *rp___0 = (png_byte )((red >> 8) & 255U);
#line 373
        *(rp___0 + 1) = (png_byte )(red & 255U);
#line 374
        *(rp___0 + 4) = (png_byte )((blue >> 8) & 255U);
#line 375
        *(rp___0 + 5) = (png_byte )(blue & 255U);
#line 365
        i___0 ++;
#line 365
        rp___0 += bytes_per_pixel;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 379
  return;
}
}
#line 382 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
void png_read_row(png_structrp png_ptr , png_bytep row , png_bytep dsp_row )
{
  png_row_info row_info ;
  int tmp ;

  {
#line 387
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 388
    return;
  }
#line 396
  if ((png_ptr->flags & 0x0040U) == 0U) {
#line 397
    png_read_start_row(png_ptr);
  }
#line 400
  row_info.width = png_ptr->iwidth;
#line 401
  row_info.color_type = png_ptr->color_type;
#line 402
  row_info.bit_depth = png_ptr->bit_depth;
#line 403
  row_info.channels = png_ptr->channels;
#line 404
  row_info.pixel_depth = png_ptr->pixel_depth;
#line 405
  if ((int )row_info.pixel_depth >= 8) {
#line 405
    row_info.rowbytes = (size_t )row_info.width * ((size_t )row_info.pixel_depth >> 3);
  } else {
#line 405
    row_info.rowbytes = ((size_t )row_info.width * (size_t )row_info.pixel_depth + 7UL) >> 3;
  }
#line 408
  if (png_ptr->row_number == 0U) {
#line 408
    if ((int )png_ptr->pass == 0) {
#line 408
      tmp = 1;
    } else {
#line 408
      tmp = 0;
    }
  } else {
#line 408
    tmp = 0;
  }
#line 456
  if ((int )png_ptr->interlaced != 0) {
#line 456
    if ((png_ptr->transformations & 0x0002U) != 0U) {
      {
#line 461
      if ((int )png_ptr->pass == 0) {
#line 461
        goto case_0;
      }
#line 471
      if ((int )png_ptr->pass == 1) {
#line 471
        goto case_1;
      }
#line 482
      if ((int )png_ptr->pass == 2) {
#line 482
        goto case_2;
      }
#line 493
      if ((int )png_ptr->pass == 3) {
#line 493
        goto case_3;
      }
#line 504
      if ((int )png_ptr->pass == 4) {
#line 504
        goto case_4;
      }
#line 515
      if ((int )png_ptr->pass == 5) {
#line 515
        goto case_5;
      }
#line 526
      goto case_6;
      case_0: /* CIL Label */
#line 462
      if (png_ptr->row_number & 7U) {
#line 464
        if ((unsigned long )dsp_row != (unsigned long )((void *)0)) {
#line 465
          png_combine_row((png_const_structrp )png_ptr, dsp_row, 1);
        }
#line 466
        png_read_finish_row(png_ptr);
#line 467
        return;
      }
#line 469
      goto switch_break;
      case_1: /* CIL Label */
#line 472
      if (png_ptr->row_number & 7U) {
#line 472
        goto _L;
      } else
#line 472
      if (png_ptr->width < 5U) {
        _L: /* CIL Label */
#line 474
        if ((unsigned long )dsp_row != (unsigned long )((void *)0)) {
#line 475
          png_combine_row((png_const_structrp )png_ptr, dsp_row, 1);
        }
#line 477
        png_read_finish_row(png_ptr);
#line 478
        return;
      }
#line 480
      goto switch_break;
      case_2: /* CIL Label */
#line 483
      if ((png_ptr->row_number & 7U) != 4U) {
#line 485
        if ((unsigned long )dsp_row != (unsigned long )((void *)0)) {
#line 485
          if (png_ptr->row_number & 4U) {
#line 486
            png_combine_row((png_const_structrp )png_ptr, dsp_row, 1);
          }
        }
#line 488
        png_read_finish_row(png_ptr);
#line 489
        return;
      }
#line 491
      goto switch_break;
      case_3: /* CIL Label */
#line 494
      if (png_ptr->row_number & 3U) {
#line 494
        goto _L___0;
      } else
#line 494
      if (png_ptr->width < 3U) {
        _L___0: /* CIL Label */
#line 496
        if ((unsigned long )dsp_row != (unsigned long )((void *)0)) {
#line 497
          png_combine_row((png_const_structrp )png_ptr, dsp_row, 1);
        }
#line 499
        png_read_finish_row(png_ptr);
#line 500
        return;
      }
#line 502
      goto switch_break;
      case_4: /* CIL Label */
#line 505
      if ((png_ptr->row_number & 3U) != 2U) {
#line 507
        if ((unsigned long )dsp_row != (unsigned long )((void *)0)) {
#line 507
          if (png_ptr->row_number & 2U) {
#line 508
            png_combine_row((png_const_structrp )png_ptr, dsp_row, 1);
          }
        }
#line 510
        png_read_finish_row(png_ptr);
#line 511
        return;
      }
#line 513
      goto switch_break;
      case_5: /* CIL Label */
#line 516
      if (png_ptr->row_number & 1U) {
#line 516
        goto _L___1;
      } else
#line 516
      if (png_ptr->width < 2U) {
        _L___1: /* CIL Label */
#line 518
        if ((unsigned long )dsp_row != (unsigned long )((void *)0)) {
#line 519
          png_combine_row((png_const_structrp )png_ptr, dsp_row, 1);
        }
#line 521
        png_read_finish_row(png_ptr);
#line 522
        return;
      }
#line 524
      goto switch_break;
      case_6: /* CIL Label */
      switch_default: /* CIL Label */
#line 528
      if ((png_ptr->row_number & 1U) == 0U) {
#line 530
        png_read_finish_row(png_ptr);
#line 531
        return;
      }
#line 533
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 538
  if ((png_ptr->mode & 0x04U) == 0U) {
#line 539
    png_error((png_const_structrp )png_ptr, (png_const_charp )"Invalid attempt to read row data");
  }
#line 542
  *(png_ptr->row_buf + 0) = (png_byte )255;
#line 543
  png_read_IDAT_data(png_ptr, png_ptr->row_buf, row_info.rowbytes + 1UL);
#line 545
  if ((int )*(png_ptr->row_buf + 0) > 0) {
#line 547
    if ((int )*(png_ptr->row_buf + 0) < 5) {
#line 548
      png_read_filter_row(png_ptr, & row_info, png_ptr->row_buf + 1, (png_const_bytep )(png_ptr->prev_row + 1),
                          (int )*(png_ptr->row_buf + 0));
    } else {
#line 551
      png_error((png_const_structrp )png_ptr, (png_const_charp )"bad adaptive filter value");
    }
  }
#line 559
  memcpy((void *)png_ptr->prev_row, (void const   *)png_ptr->row_buf, row_info.rowbytes + 1UL);
#line 562
  if ((png_ptr->mng_features_permitted & 4U) != 0U) {
#line 562
    if ((int )png_ptr->filter_type == 64) {
#line 566
      png_do_read_intrapixel(& row_info, png_ptr->row_buf + 1);
    }
  }
#line 571
  if (png_ptr->transformations) {
#line 572
    png_do_read_transformations(png_ptr, & row_info);
  }
#line 576
  if ((int )png_ptr->transformed_pixel_depth == 0) {
#line 578
    png_ptr->transformed_pixel_depth = row_info.pixel_depth;
#line 579
    if ((int )row_info.pixel_depth > (int )png_ptr->maximum_pixel_depth) {
#line 580
      png_error((png_const_structrp )png_ptr, (png_const_charp )"sequential row overflow");
    }
  } else
#line 583
  if ((int )png_ptr->transformed_pixel_depth != (int )row_info.pixel_depth) {
#line 584
    png_error((png_const_structrp )png_ptr, (png_const_charp )"internal sequential row size calculation error");
  }
#line 588
  if ((int )png_ptr->interlaced != 0) {
#line 588
    if ((png_ptr->transformations & 0x0002U) != 0U) {
#line 591
      if ((int )png_ptr->pass < 6) {
#line 592
        png_do_read_interlace(& row_info, png_ptr->row_buf + 1, (int )png_ptr->pass,
                              png_ptr->transformations);
      }
#line 595
      if ((unsigned long )dsp_row != (unsigned long )((void *)0)) {
#line 596
        png_combine_row((png_const_structrp )png_ptr, dsp_row, 1);
      }
#line 598
      if ((unsigned long )row != (unsigned long )((void *)0)) {
#line 599
        png_combine_row((png_const_structrp )png_ptr, row, 0);
      }
    } else {
#line 588
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */
#line 605
    if ((unsigned long )row != (unsigned long )((void *)0)) {
#line 606
      png_combine_row((png_const_structrp )png_ptr, row, -1);
    }
#line 608
    if ((unsigned long )dsp_row != (unsigned long )((void *)0)) {
#line 609
      png_combine_row((png_const_structrp )png_ptr, dsp_row, -1);
    }
  }
#line 611
  png_read_finish_row(png_ptr);
#line 613
  if ((unsigned long )png_ptr->read_row_fn != (unsigned long )((void *)0)) {
#line 614
    (*(png_ptr->read_row_fn))((png_structp )png_ptr, png_ptr->row_number, (int )png_ptr->pass);
  }
#line 616
  return;
}
}
#line 644 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
void png_read_rows(png_structrp png_ptr , png_bytepp row , png_bytepp display_row ,
                   png_uint_32 num_rows )
{
  png_uint_32 i ;
  png_bytepp rp ;
  png_bytepp dp ;
  png_bytep rptr ;
  png_bytepp tmp ;
  png_bytep dptr ;
  png_bytepp tmp___0 ;
  png_bytep rptr___0 ;
  png_bytep dptr___0 ;

  {
#line 654
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 655
    return;
  }
#line 657
  rp = row;
#line 658
  dp = display_row;
#line 659
  if ((unsigned long )rp != (unsigned long )((void *)0)) {
#line 659
    if ((unsigned long )dp != (unsigned long )((void *)0)) {
#line 660
      i = (png_uint_32 )0;
      {
#line 660
      while (1) {
        while_continue: /* CIL Label */ ;
#line 660
        if (! (i < num_rows)) {
#line 660
          goto while_break;
        }
#line 662
        tmp = rp;
#line 662
        rp ++;
#line 662
        rptr = *tmp;
#line 663
        tmp___0 = dp;
#line 663
        dp ++;
#line 663
        dptr = *tmp___0;
#line 665
        png_read_row(png_ptr, rptr, dptr);
#line 660
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 659
      goto _L;
    }
  } else
  _L: /* CIL Label */
#line 668
  if ((unsigned long )rp != (unsigned long )((void *)0)) {
#line 669
    i = (png_uint_32 )0;
    {
#line 669
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 669
      if (! (i < num_rows)) {
#line 669
        goto while_break___0;
      }
#line 671
      rptr___0 = *rp;
#line 672
      png_read_row(png_ptr, rptr___0, (png_bytep )((void *)0));
#line 673
      rp ++;
#line 669
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 676
  if ((unsigned long )dp != (unsigned long )((void *)0)) {
#line 677
    i = (png_uint_32 )0;
    {
#line 677
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 677
      if (! (i < num_rows)) {
#line 677
        goto while_break___1;
      }
#line 679
      dptr___0 = *dp;
#line 680
      png_read_row(png_ptr, (png_bytep )((void *)0), dptr___0);
#line 681
      dp ++;
#line 677
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 683
  return;
}
}
#line 699 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
void png_read_image(png_structrp png_ptr , png_bytepp image )
{
  png_uint_32 i ;
  png_uint_32 image_height ;
  int pass ;
  int j ;
  png_bytepp rp ;

  {
#line 708
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 709
    return;
  }
#line 712
  if ((png_ptr->flags & 0x0040U) == 0U) {
#line 714
    pass = png_set_interlace_handling(png_ptr);
#line 716
    png_start_read_image(png_ptr);
  } else {
#line 720
    if ((int )png_ptr->interlaced != 0) {
#line 720
      if ((png_ptr->transformations & 0x0002U) == 0U) {
#line 727
        png_warning((png_const_structrp )png_ptr, (png_const_charp )"Interlace handling should be turned on when using png_read_image");
#line 730
        png_ptr->num_rows = png_ptr->height;
      }
    }
#line 736
    pass = png_set_interlace_handling(png_ptr);
  }
#line 746
  image_height = png_ptr->height;
#line 748
  j = 0;
  {
#line 748
  while (1) {
    while_continue: /* CIL Label */ ;
#line 748
    if (! (j < pass)) {
#line 748
      goto while_break;
    }
#line 750
    rp = image;
#line 751
    i = (png_uint_32 )0;
    {
#line 751
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 751
      if (! (i < image_height)) {
#line 751
        goto while_break___0;
      }
#line 753
      png_read_row(png_ptr, *rp, (png_bytep )((void *)0));
#line 754
      rp ++;
#line 751
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 748
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 757
  return;
}
}
#line 765 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
void png_read_end(png_structrp png_ptr , png_inforp info_ptr )
{
  int keep ;
  int tmp ;
  png_uint_32 length ;
  png_uint_32 tmp___0 ;
  png_uint_32 chunk_name ;

  {
#line 774
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 775
    return;
  }
#line 781
  tmp = png_chunk_unknown_handling((png_const_structrp )png_ptr, (((73U << 24) | (68U << 16)) | (65U << 8)) | 84U);
#line 781
  if (tmp == 0) {
#line 783
    png_read_finish_IDAT(png_ptr);
  }
#line 787
  if ((int )png_ptr->color_type == 3) {
#line 787
    if (png_ptr->num_palette_max > (int )png_ptr->num_palette) {
#line 789
      png_benign_error((png_const_structrp )png_ptr, (png_const_charp )"Read palette index exceeding num_palette");
    }
  }
  {
#line 792
  while (1) {
    while_continue: /* CIL Label */ ;
#line 794
    tmp___0 = png_read_chunk_header(png_ptr);
#line 794
    length = tmp___0;
#line 795
    chunk_name = png_ptr->chunk_name;
#line 797
    if (chunk_name != ((((73U << 24) | (68U << 16)) | (65U << 8)) | 84U)) {
#line 798
      png_ptr->mode |= 0x2000U;
    }
#line 800
    if (chunk_name == ((((73U << 24) | (69U << 16)) | (78U << 8)) | 68U)) {
#line 801
      png_handle_IEND(png_ptr, info_ptr, length);
    } else
#line 803
    if (chunk_name == ((((73U << 24) | (72U << 16)) | (68U << 8)) | 82U)) {
#line 804
      png_handle_IHDR(png_ptr, info_ptr, length);
    } else
#line 806
    if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 807
      png_crc_finish(png_ptr, length);
    } else {
#line 810
      keep = png_chunk_unknown_handling((png_const_structrp )png_ptr, chunk_name);
#line 810
      if (keep != 0) {
#line 812
        if (chunk_name == ((((73U << 24) | (68U << 16)) | (65U << 8)) | 84U)) {
#line 814
          if (length > 0U) {
#line 814
            if (! (png_ptr->flags & 0x0008U)) {
#line 816
              png_benign_error((png_const_structrp )png_ptr, (png_const_charp )".Too many IDATs found");
            } else {
#line 814
              goto _L;
            }
          } else
          _L: /* CIL Label */
#line 814
          if ((png_ptr->mode & 0x2000U) != 0U) {
#line 816
            png_benign_error((png_const_structrp )png_ptr, (png_const_charp )".Too many IDATs found");
          }
        }
#line 818
        png_handle_unknown(png_ptr, info_ptr, length, keep);
#line 819
        if (chunk_name == ((((80U << 24) | (76U << 16)) | (84U << 8)) | 69U)) {
#line 820
          png_ptr->mode |= 2U;
        }
      } else
#line 824
      if (chunk_name == ((((73U << 24) | (68U << 16)) | (65U << 8)) | 84U)) {
#line 832
        if (length > 0U) {
#line 832
          if (! (png_ptr->flags & 0x0008U)) {
#line 834
            png_benign_error((png_const_structrp )png_ptr, (png_const_charp )"..Too many IDATs found");
          } else {
#line 832
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */
#line 832
        if ((png_ptr->mode & 0x2000U) != 0U) {
#line 834
          png_benign_error((png_const_structrp )png_ptr, (png_const_charp )"..Too many IDATs found");
        }
#line 836
        png_crc_finish(png_ptr, length);
      } else
#line 838
      if (chunk_name == ((((80U << 24) | (76U << 16)) | (84U << 8)) | 69U)) {
#line 839
        png_handle_PLTE(png_ptr, info_ptr, length);
      } else
#line 842
      if (chunk_name == ((((98U << 24) | (75U << 16)) | (71U << 8)) | 68U)) {
#line 843
        png_handle_bKGD(png_ptr, info_ptr, length);
      } else
#line 847
      if (chunk_name == ((((99U << 24) | (72U << 16)) | (82U << 8)) | 77U)) {
#line 848
        png_handle_cHRM(png_ptr, info_ptr, length);
      } else
#line 852
      if (chunk_name == ((((101U << 24) | (88U << 16)) | (73U << 8)) | 102U)) {
#line 853
        png_handle_eXIf(png_ptr, info_ptr, length);
      } else
#line 857
      if (chunk_name == ((((103U << 24) | (65U << 16)) | (77U << 8)) | 65U)) {
#line 858
        png_handle_gAMA(png_ptr, info_ptr, length);
      } else
#line 862
      if (chunk_name == ((((104U << 24) | (73U << 16)) | (83U << 8)) | 84U)) {
#line 863
        png_handle_hIST(png_ptr, info_ptr, length);
      } else
#line 867
      if (chunk_name == ((((111U << 24) | (70U << 16)) | (70U << 8)) | 115U)) {
#line 868
        png_handle_oFFs(png_ptr, info_ptr, length);
      } else
#line 872
      if (chunk_name == ((((112U << 24) | (67U << 16)) | (65U << 8)) | 76U)) {
#line 873
        png_handle_pCAL(png_ptr, info_ptr, length);
      } else
#line 877
      if (chunk_name == ((((115U << 24) | (67U << 16)) | (65U << 8)) | 76U)) {
#line 878
        png_handle_sCAL(png_ptr, info_ptr, length);
      } else
#line 882
      if (chunk_name == ((((112U << 24) | (72U << 16)) | (89U << 8)) | 115U)) {
#line 883
        png_handle_pHYs(png_ptr, info_ptr, length);
      } else
#line 887
      if (chunk_name == ((((115U << 24) | (66U << 16)) | (73U << 8)) | 84U)) {
#line 888
        png_handle_sBIT(png_ptr, info_ptr, length);
      } else
#line 892
      if (chunk_name == ((((115U << 24) | (82U << 16)) | (71U << 8)) | 66U)) {
#line 893
        png_handle_sRGB(png_ptr, info_ptr, length);
      } else
#line 897
      if (chunk_name == ((((105U << 24) | (67U << 16)) | (67U << 8)) | 80U)) {
#line 898
        png_handle_iCCP(png_ptr, info_ptr, length);
      } else
#line 902
      if (chunk_name == ((((115U << 24) | (80U << 16)) | (76U << 8)) | 84U)) {
#line 903
        png_handle_sPLT(png_ptr, info_ptr, length);
      } else
#line 907
      if (chunk_name == ((((116U << 24) | (69U << 16)) | (88U << 8)) | 116U)) {
#line 908
        png_handle_tEXt(png_ptr, info_ptr, length);
      } else
#line 912
      if (chunk_name == ((((116U << 24) | (73U << 16)) | (77U << 8)) | 69U)) {
#line 913
        png_handle_tIME(png_ptr, info_ptr, length);
      } else
#line 917
      if (chunk_name == ((((116U << 24) | (82U << 16)) | (78U << 8)) | 83U)) {
#line 918
        png_handle_tRNS(png_ptr, info_ptr, length);
      } else
#line 922
      if (chunk_name == ((((122U << 24) | (84U << 16)) | (88U << 8)) | 116U)) {
#line 923
        png_handle_zTXt(png_ptr, info_ptr, length);
      } else
#line 927
      if (chunk_name == ((((105U << 24) | (84U << 16)) | (88U << 8)) | 116U)) {
#line 928
        png_handle_iTXt(png_ptr, info_ptr, length);
      } else {
#line 932
        png_handle_unknown(png_ptr, info_ptr, length, 0);
      }
    }
#line 792
    if (! ((png_ptr->mode & 0x10U) == 0U)) {
#line 792
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 935
  return;
}
}
#line 939 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
static void png_read_destroy(png_structrp png_ptr )
{


  {
#line 945
  png_destroy_gamma_table(png_ptr);
#line 948
  png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->big_row_buf);
#line 949
  png_ptr->big_row_buf = (png_bytep )((void *)0);
#line 950
  png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->big_prev_row);
#line 951
  png_ptr->big_prev_row = (png_bytep )((void *)0);
#line 952
  png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->read_buffer);
#line 953
  png_ptr->read_buffer = (png_bytep )((void *)0);
#line 956
  png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->palette_lookup);
#line 957
  png_ptr->palette_lookup = (png_bytep )((void *)0);
#line 958
  png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->quantize_index);
#line 959
  png_ptr->quantize_index = (png_bytep )((void *)0);
#line 962
  if ((png_ptr->free_me & 0x1000U) != 0U) {
#line 964
    png_zfree((voidpf )png_ptr, (voidpf )png_ptr->palette);
#line 965
    png_ptr->palette = (png_colorp )((void *)0);
  }
#line 967
  png_ptr->free_me &= 4294963199U;
#line 971
  if ((png_ptr->free_me & 0x2000U) != 0U) {
#line 973
    png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->trans_alpha);
#line 974
    png_ptr->trans_alpha = (png_bytep )((void *)0);
  }
#line 976
  png_ptr->free_me &= 4294959103U;
#line 979
  inflateEnd(& png_ptr->zstream);
#line 982
  png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->save_buffer);
#line 983
  png_ptr->save_buffer = (png_bytep )((void *)0);
#line 988
  png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->unknown_chunk.data);
#line 989
  png_ptr->unknown_chunk.data = (png_byte *)((void *)0);
#line 993
  png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->chunk_list);
#line 994
  png_ptr->chunk_list = (png_bytep )((void *)0);
#line 999
  png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->riffled_palette);
#line 1000
  png_ptr->riffled_palette = (png_bytep )((void *)0);
#line 1007
  return;
}
}
#line 1010 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
void png_destroy_read_struct(png_structpp png_ptr_ptr , png_infopp info_ptr_ptr ,
                             png_infopp end_info_ptr_ptr )
{
  png_structrp png_ptr ;

  {
#line 1014
  png_ptr = (png_structrp )((void *)0);
#line 1018
  if ((unsigned long )png_ptr_ptr != (unsigned long )((void *)0)) {
#line 1019
    png_ptr = (png_structrp )*png_ptr_ptr;
  }
#line 1021
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1022
    return;
  }
#line 1028
  png_destroy_info_struct((png_const_structrp )png_ptr, end_info_ptr_ptr);
#line 1029
  png_destroy_info_struct((png_const_structrp )png_ptr, info_ptr_ptr);
#line 1031
  *png_ptr_ptr = (png_struct *)((void *)0);
#line 1032
  png_read_destroy(png_ptr);
#line 1033
  png_destroy_png_struct(png_ptr);
#line 1034
  return;
}
}
#line 1036 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
void png_set_read_status_fn(png_structrp png_ptr , void (*read_row_fn)(png_structp  ,
                                                                       png_uint_32  ,
                                                                       int  ) )
{


  {
#line 1039
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1040
    return;
  }
#line 1042
  png_ptr->read_row_fn = read_row_fn;
#line 1043
  return;
}
}
#line 1048 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
void png_read_png(png_structrp png_ptr , png_inforp info_ptr , int transforms , void *params )
{
  png_uint_32 iptr ;
  png_voidp __attribute__((__malloc__))  tmp ;
  png_voidp __attribute__((__malloc__))  tmp___0 ;

  {
#line 1052
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1053
    return;
  } else
#line 1052
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 1053
    return;
  }
#line 1058
  png_read_info(png_ptr, info_ptr);
#line 1059
  if ((unsigned long )info_ptr->height > 4294967295UL / sizeof(png_bytep )) {
#line 1060
    png_error((png_const_structrp )png_ptr, (png_const_charp )"Image is too high to process with png_read_png()");
  }
#line 1071
  if ((transforms & 0x8000) != 0) {
#line 1076
    png_set_scale_16(png_ptr);
  }
#line 1085
  if ((transforms & 0x0001) != 0) {
#line 1087
    png_set_strip_16(png_ptr);
  }
#line 1095
  if ((transforms & 0x0002) != 0) {
#line 1097
    png_set_strip_alpha(png_ptr);
  }
#line 1105
  if ((transforms & 0x0004) != 0) {
#line 1107
    png_set_packing(png_ptr);
  }
#line 1115
  if ((transforms & 0x0008) != 0) {
#line 1117
    png_set_packswap(png_ptr);
  }
#line 1127
  if ((transforms & 0x0010) != 0) {
#line 1129
    png_set_expand(png_ptr);
  }
#line 1139
  if ((transforms & 0x0020) != 0) {
#line 1141
    png_set_invert_mono(png_ptr);
  }
#line 1150
  if ((transforms & 0x0040) != 0) {
#line 1152
    if ((info_ptr->valid & 0x0002U) != 0U) {
#line 1153
      png_set_shift(png_ptr, (png_const_color_8p )(& info_ptr->sig_bit));
    }
  }
#line 1159
  if ((transforms & 0x0080) != 0) {
#line 1161
    png_set_bgr(png_ptr);
  }
#line 1167
  if ((transforms & 0x0100) != 0) {
#line 1169
    png_set_swap_alpha(png_ptr);
  }
#line 1175
  if ((transforms & 0x0200) != 0) {
#line 1177
    png_set_swap(png_ptr);
  }
#line 1184
  if ((transforms & 0x0400) != 0) {
#line 1186
    png_set_invert_alpha(png_ptr);
  }
#line 1193
  if ((transforms & 0x2000) != 0) {
#line 1195
    png_set_gray_to_rgb(png_ptr);
  }
#line 1201
  if ((transforms & 0x4000) != 0) {
#line 1203
    png_set_expand_16(png_ptr);
  }
#line 1213
  png_set_interlace_handling(png_ptr);
#line 1219
  png_read_update_info(png_ptr, info_ptr);
#line 1223
  png_free_data((png_const_structrp )png_ptr, info_ptr, 0x0040U, 0);
#line 1224
  if ((unsigned long )info_ptr->row_pointers == (unsigned long )((void *)0)) {
#line 1228
    tmp = png_malloc((png_const_structrp )png_ptr, (unsigned long )info_ptr->height * sizeof(png_bytep ));
#line 1228
    info_ptr->row_pointers = (png_bytepp )tmp;
#line 1231
    iptr = (png_uint_32 )0;
    {
#line 1231
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1231
      if (! (iptr < info_ptr->height)) {
#line 1231
        goto while_break;
      }
#line 1232
      *(info_ptr->row_pointers + iptr) = (png_byte *)((void *)0);
#line 1231
      iptr ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1234
    info_ptr->free_me |= 0x0040U;
#line 1236
    iptr = (png_uint_32 )0;
    {
#line 1236
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1236
      if (! (iptr < info_ptr->height)) {
#line 1236
        goto while_break___0;
      }
#line 1237
      tmp___0 = png_malloc((png_const_structrp )png_ptr, info_ptr->rowbytes);
#line 1237
      *(info_ptr->row_pointers + iptr) = (png_byte *)tmp___0;
#line 1236
      iptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1241
  png_read_image(png_ptr, info_ptr->row_pointers);
#line 1242
  info_ptr->valid |= 0x8000U;
#line 1245
  png_read_end(png_ptr, info_ptr);
#line 1248
  return;
}
}
#line 1305 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
static int png_image_read_init(png_imagep image )
{
  png_structp png_ptr ;
  png_structp __attribute__((__malloc__))  tmp ;
  png_infop info_ptr ;
  png_infop __attribute__((__malloc__))  tmp___0 ;
  png_controlp control ;
  png_voidp __attribute__((__malloc__))  tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1308
  if ((unsigned long )image->opaque == (unsigned long )((void *)0)) {
#line 1310
    tmp = png_create_read_struct((png_const_charp )"1.6.39", (png_voidp )image, & png_safe_error,
                                 & png_safe_warning);
#line 1310
    png_ptr = (png_structp )tmp;
#line 1316
    memset((void *)image, 0, sizeof(*image));
#line 1317
    image->version = (png_uint_32 )1;
#line 1319
    if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 1321
      tmp___0 = png_create_info_struct((png_const_structrp )png_ptr);
#line 1321
      info_ptr = (png_infop )tmp___0;
#line 1323
      if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1325
        tmp___1 = png_malloc_warn((png_const_structrp )png_ptr, sizeof(*control));
#line 1325
        control = (png_controlp )tmp___1;
#line 1328
        if ((unsigned long )control != (unsigned long )((void *)0)) {
#line 1330
          memset((void *)control, 0, sizeof(*control));
#line 1332
          control->png_ptr = png_ptr;
#line 1333
          control->info_ptr = info_ptr;
#line 1334
          control->for_write = 0U;
#line 1336
          image->opaque = control;
#line 1337
          return (1);
        }
#line 1341
        png_destroy_info_struct((png_const_structrp )png_ptr, & info_ptr);
      }
#line 1344
      png_destroy_read_struct(& png_ptr, (png_infopp )((void *)0), (png_infopp )((void *)0));
    }
#line 1347
    tmp___2 = png_image_error(image, (png_const_charp )"png_image_read: out of memory");
#line 1347
    return (tmp___2);
  }
#line 1350
  tmp___3 = png_image_error(image, (png_const_charp )"png_image_read: opaque pointer not NULL");
#line 1350
  return (tmp___3);
}
}
#line 1354 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
static png_uint_32 png_image_format(png_structrp png_ptr )
{
  png_uint_32 format ;

  {
#line 1357
  format = (png_uint_32 )0;
#line 1359
  if (((int )png_ptr->color_type & 2) != 0) {
#line 1360
    format |= 0x02U;
  }
#line 1362
  if (((int )png_ptr->color_type & 4) != 0) {
#line 1363
    format |= 0x01U;
  } else
#line 1370
  if ((int )png_ptr->num_trans > 0) {
#line 1371
    format |= 0x01U;
  }
#line 1373
  if ((int )png_ptr->bit_depth == 16) {
#line 1374
    format |= 0x04U;
  }
#line 1376
  if (((int )png_ptr->color_type & 1) != 0) {
#line 1377
    format |= 0x08U;
  }
#line 1379
  return (format);
}
}
#line 1387 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
static int png_gamma_not_sRGB(png_fixed_point g )
{
  int tmp ;

  {
#line 1390
  if (g < 100000) {
#line 1393
    if (g == 0) {
#line 1394
      return (0);
    }
#line 1396
    tmp = png_gamma_significant((g * 11 + 2) / 5);
#line 1396
    return (tmp);
  }
#line 1399
  return (1);
}
}
#line 1406 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
static int png_image_read_header(png_voidp argument )
{
  png_imagep image ;
  png_structrp png_ptr ;
  png_inforp info_ptr ;
  png_uint_32 format ;
  png_uint_32 tmp ;
  png_uint_32 cmap_entries ;

  {
#line 1409
  image = (png_imagep )argument;
#line 1410
  png_ptr = (png_structrp )(image->opaque)->png_ptr;
#line 1411
  info_ptr = (png_inforp )(image->opaque)->info_ptr;
#line 1414
  png_set_benign_errors(png_ptr, 1);
#line 1416
  png_read_info(png_ptr, info_ptr);
#line 1419
  image->width = png_ptr->width;
#line 1420
  image->height = png_ptr->height;
#line 1423
  tmp = png_image_format(png_ptr);
#line 1423
  format = tmp;
#line 1425
  image->format = format;
#line 1433
  if ((format & 0x02U) != 0U) {
#line 1433
    if (((int )png_ptr->colorspace.flags & 32834) == 0x0002) {
#line 1436
      image->flags |= 1U;
    }
  }
  {
#line 1448
  if ((int )png_ptr->color_type == 0) {
#line 1448
    goto case_0;
  }
#line 1452
  if ((int )png_ptr->color_type == 3) {
#line 1452
    goto case_3;
  }
#line 1456
  goto switch_default;
  case_0: /* CIL Label */
#line 1449
  cmap_entries = 1U << (int )png_ptr->bit_depth;
#line 1450
  goto switch_break;
  case_3: /* CIL Label */
#line 1453
  cmap_entries = (png_uint_32 )png_ptr->num_palette;
#line 1454
  goto switch_break;
  switch_default: /* CIL Label */
#line 1457
  cmap_entries = (png_uint_32 )256;
#line 1458
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1461
  if (cmap_entries > 256U) {
#line 1462
    cmap_entries = (png_uint_32 )256;
  }
#line 1464
  image->colormap_entries = cmap_entries;
#line 1467
  return (1);
}
}
#line 1471 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
int png_image_begin_read_from_stdio(png_imagep image , FILE *file )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1474
  if ((unsigned long )image != (unsigned long )((void *)0)) {
#line 1474
    if (image->version == 1U) {
#line 1476
      if ((unsigned long )file != (unsigned long )((void *)0)) {
#line 1478
        tmp___0 = png_image_read_init(image);
#line 1478
        if (tmp___0 != 0) {
#line 1484
          ((image->opaque)->png_ptr)->io_ptr = (png_voidp )file;
#line 1485
          tmp = png_safe_execute(image, & png_image_read_header, (png_voidp )image);
#line 1485
          return (tmp);
        }
      } else {
#line 1490
        tmp___1 = png_image_error(image, (png_const_charp )"png_image_begin_read_from_stdio: invalid argument");
#line 1490
        return (tmp___1);
      }
    } else {
#line 1474
      goto _L;
    }
  } else
  _L: /* CIL Label */
#line 1494
  if ((unsigned long )image != (unsigned long )((void *)0)) {
#line 1495
    tmp___2 = png_image_error(image, (png_const_charp )"png_image_begin_read_from_stdio: incorrect PNG_IMAGE_VERSION");
#line 1495
    return (tmp___2);
  }
#line 1498
  return (0);
}
}
#line 1501 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
int png_image_begin_read_from_file(png_imagep image , char const   *file_name )
{
  FILE *fp ;
  FILE *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1504
  if ((unsigned long )image != (unsigned long )((void *)0)) {
#line 1504
    if (image->version == 1U) {
#line 1506
      if ((unsigned long )file_name != (unsigned long )((void *)0)) {
#line 1508
        tmp = fopen((char const   * __restrict  )file_name, (char const   * __restrict  )"rb");
#line 1508
        fp = tmp;
#line 1510
        if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 1512
          tmp___1 = png_image_read_init(image);
#line 1512
          if (tmp___1 != 0) {
#line 1514
            ((image->opaque)->png_ptr)->io_ptr = (png_voidp )fp;
#line 1515
            (image->opaque)->owned_file = 1U;
#line 1516
            tmp___0 = png_safe_execute(image, & png_image_read_header, (png_voidp )image);
#line 1516
            return (tmp___0);
          }
#line 1520
          fclose(fp);
        } else {
#line 1524
          tmp___2 = __errno_location();
#line 1524
          tmp___3 = strerror(*tmp___2);
#line 1524
          tmp___4 = png_image_error(image, (png_const_charp )tmp___3);
#line 1524
          return (tmp___4);
        }
      } else {
#line 1528
        tmp___5 = png_image_error(image, (png_const_charp )"png_image_begin_read_from_file: invalid argument");
#line 1528
        return (tmp___5);
      }
    } else {
#line 1504
      goto _L;
    }
  } else
  _L: /* CIL Label */
#line 1532
  if ((unsigned long )image != (unsigned long )((void *)0)) {
#line 1533
    tmp___6 = png_image_error(image, (png_const_charp )"png_image_begin_read_from_file: incorrect PNG_IMAGE_VERSION");
#line 1533
    return (tmp___6);
  }
#line 1536
  return (0);
}
}
#line 1540 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
static void png_image_memory_read(png_structp png_ptr , png_bytep out , size_t need )
{
  png_imagep image ;
  png_controlp cp ;
  png_const_bytep memory ;
  size_t size ;

  {
#line 1543
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 1545
    image = (png_imagep )png_ptr->io_ptr;
#line 1546
    if ((unsigned long )image != (unsigned long )((void *)0)) {
#line 1548
      cp = image->opaque;
#line 1549
      if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 1551
        memory = cp->memory;
#line 1552
        size = cp->size;
#line 1554
        if ((unsigned long )memory != (unsigned long )((void *)0)) {
#line 1554
          if (size >= need) {
#line 1556
            memcpy((void *)out, (void const   *)memory, need);
#line 1557
            cp->memory = memory + need;
#line 1558
            cp->size = size - need;
#line 1559
            return;
          }
        }
#line 1562
        png_error((png_const_structrp )png_ptr, (png_const_charp )"read beyond end of data");
      }
    }
#line 1566
    png_error((png_const_structrp )png_ptr, (png_const_charp )"invalid memory read");
  }
#line 1568
  return;
}
}
#line 1570 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
int png_image_begin_read_from_memory(png_imagep image , png_const_voidp memory , size_t size )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1573
  if ((unsigned long )image != (unsigned long )((void *)0)) {
#line 1573
    if (image->version == 1U) {
#line 1575
      if ((unsigned long )memory != (unsigned long )((void *)0)) {
#line 1575
        if (size > 0UL) {
#line 1577
          tmp___0 = png_image_read_init(image);
#line 1577
          if (tmp___0 != 0) {
#line 1583
            (image->opaque)->memory = (png_const_bytep )memory;
#line 1584
            (image->opaque)->size = size;
#line 1585
            ((image->opaque)->png_ptr)->io_ptr = (png_voidp )image;
#line 1586
            ((image->opaque)->png_ptr)->read_data_fn = & png_image_memory_read;
#line 1588
            tmp = png_safe_execute(image, & png_image_read_header, (png_voidp )image);
#line 1588
            return (tmp);
          }
        } else {
#line 1593
          tmp___1 = png_image_error(image, (png_const_charp )"png_image_begin_read_from_memory: invalid argument");
#line 1593
          return (tmp___1);
        }
      } else {
#line 1593
        tmp___1 = png_image_error(image, (png_const_charp )"png_image_begin_read_from_memory: invalid argument");
#line 1593
        return (tmp___1);
      }
    } else {
#line 1573
      goto _L;
    }
  } else
  _L: /* CIL Label */
#line 1597
  if ((unsigned long )image != (unsigned long )((void *)0)) {
#line 1598
    tmp___2 = png_image_error(image, (png_const_charp )"png_image_begin_read_from_memory: incorrect PNG_IMAGE_VERSION");
#line 1598
    return (tmp___2);
  }
#line 1601
  return (0);
}
}
#line 1630
static void png_image_skip_unused_chunks(png_structrp png_ptr ) ;
#line 1630 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
static png_byte const   chunks_to_process[30]  =
#line 1630
  {      (png_byte const   )98,      (png_byte const   )75,      (png_byte const   )71,      (png_byte const   )68,
        (png_byte const   )'\000',      (png_byte const   )99,      (png_byte const   )72,      (png_byte const   )82,
        (png_byte const   )77,      (png_byte const   )'\000',      (png_byte const   )103,      (png_byte const   )65,
        (png_byte const   )77,      (png_byte const   )65,      (png_byte const   )'\000',      (png_byte const   )105,
        (png_byte const   )67,      (png_byte const   )67,      (png_byte const   )80,      (png_byte const   )'\000',
        (png_byte const   )115,      (png_byte const   )66,      (png_byte const   )73,      (png_byte const   )84,
        (png_byte const   )'\000',      (png_byte const   )115,      (png_byte const   )82,      (png_byte const   )71,
        (png_byte const   )66,      (png_byte const   )'\000'};
#line 1608 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
static void png_image_skip_unused_chunks(png_structrp png_ptr )
{


  {
#line 1644
  png_set_keep_unknown_chunks(png_ptr, 1, (png_const_bytep )((void *)0), -1);
#line 1648
  png_set_keep_unknown_chunks(png_ptr, 0, chunks_to_process, (int )sizeof(chunks_to_process) / 5);
#line 1651
  return;
}
}
#line 1665 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
static void set_file_encoding(png_image_read_control *display )
{
  png_fixed_point g ;
  int tmp ;
  int tmp___0 ;

  {
#line 1668
  g = (((display->image)->opaque)->png_ptr)->colorspace.gamma;
#line 1669
  tmp___0 = png_gamma_significant(g);
#line 1669
  if (tmp___0 != 0) {
#line 1671
    tmp = png_gamma_not_sRGB(g);
#line 1671
    if (tmp != 0) {
#line 1673
      display->file_encoding = 3;
#line 1674
      display->gamma_to_linear = png_reciprocal(g);
    } else {
#line 1678
      display->file_encoding = 1;
    }
  } else {
#line 1682
    display->file_encoding = 4;
  }
#line 1683
  return;
}
}
#line 1685 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
static unsigned int decode_gamma(png_image_read_control *display , png_uint_32 value ,
                                 int encoding )
{
  png_uint_16 tmp ;

  {
#line 1688
  if (encoding == 3) {
#line 1689
    encoding = display->file_encoding;
  }
#line 1691
  if (encoding == 0) {
#line 1693
    set_file_encoding(display);
#line 1694
    encoding = display->file_encoding;
  }
  {
#line 1699
  if (encoding == 3) {
#line 1699
    goto case_3;
  }
#line 1703
  if (encoding == 1) {
#line 1703
    goto case_1;
  }
#line 1707
  if (encoding == 2) {
#line 1707
    goto case_2;
  }
#line 1710
  if (encoding == 4) {
#line 1710
    goto case_4;
  }
#line 1715
  goto switch_default;
  case_3: /* CIL Label */
#line 1700
  tmp = png_gamma_16bit_correct(value * 257U, display->gamma_to_linear);
#line 1700
  value = (png_uint_32 )tmp;
#line 1701
  goto switch_break;
  case_1: /* CIL Label */
#line 1704
  value = (png_uint_32 )png_sRGB_table[value];
#line 1705
  goto switch_break;
  case_2: /* CIL Label */
#line 1708
  goto switch_break;
  case_4: /* CIL Label */
#line 1711
  value *= 257U;
#line 1712
  goto switch_break;
  switch_default: /* CIL Label */
#line 1716
  png_error((png_const_structrp )((display->image)->opaque)->png_ptr, (png_const_charp )"unexpected encoding (internal error)");
  switch_break: /* CIL Label */ ;
  }
#line 1721
  return (value);
}
}
#line 1724 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
static png_uint_32 png_colormap_compose(png_image_read_control *display , png_uint_32 foreground ,
                                        int foreground_encoding , png_uint_32 alpha ,
                                        png_uint_32 background , int encoding )
{
  png_uint_32 f ;
  unsigned int tmp ;
  png_uint_32 b ;
  unsigned int tmp___0 ;

  {
#line 1734
  tmp = decode_gamma(display, foreground, foreground_encoding);
#line 1734
  f = tmp;
#line 1735
  tmp___0 = decode_gamma(display, background, encoding);
#line 1735
  b = tmp___0;
#line 1740
  f = f * alpha + b * (255U - alpha);
#line 1742
  if (encoding == 2) {
#line 1747
    f *= 257U;
#line 1748
    f += f >> 16;
#line 1749
    f = (f + 32768U) >> 16;
  } else {
#line 1753
    f = (png_uint_32 )((png_byte )(255U & (((unsigned int )png_sRGB_base[f >> 15] + ((f & 32767U) * (unsigned int )png_sRGB_delta[f >> 15] >> 12)) >> 8)));
  }
#line 1755
  return (f);
}
}
#line 1761 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
static void png_create_colormap_entry(png_image_read_control *display , png_uint_32 ip ,
                                      png_uint_32 red , png_uint_32 green , png_uint_32 blue ,
                                      png_uint_32 alpha , int encoding )
{
  png_imagep image ;
  int output_encoding ;
  int tmp ;
  int convert_to_Y ;
  int tmp___0 ;
  png_fixed_point g ;
  png_uint_16 tmp___1 ;
  png_uint_16 tmp___2 ;
  png_uint_16 tmp___3 ;
  png_uint_32 y ;
  int afirst ;
  int tmp___4 ;
  int bgr ;
  int tmp___5 ;
  png_uint_16p entry ;
  int tmp___6 ;
  png_bytep entry___0 ;
  int tmp___7 ;

  {
#line 1766
  image = display->image;
#line 1767
  if ((image->format & 0x04U) != 0U) {
#line 1767
    tmp = 2;
  } else {
#line 1767
    tmp = 1;
  }
#line 1767
  output_encoding = tmp;
#line 1769
  if ((image->format & 0x02U) == 0U) {
#line 1769
    if (red != green) {
#line 1769
      tmp___0 = 1;
    } else
#line 1769
    if (green != blue) {
#line 1769
      tmp___0 = 1;
    } else {
#line 1769
      tmp___0 = 0;
    }
  } else {
#line 1769
    tmp___0 = 0;
  }
#line 1769
  convert_to_Y = tmp___0;
#line 1772
  if (ip > 255U) {
#line 1773
    png_error((png_const_structrp )(image->opaque)->png_ptr, (png_const_charp )"color-map index out of range");
  }
#line 1778
  if (encoding == 3) {
#line 1780
    if (display->file_encoding == 0) {
#line 1781
      set_file_encoding(display);
    }
#line 1786
    encoding = display->file_encoding;
  }
#line 1789
  if (encoding == 3) {
#line 1791
    g = display->gamma_to_linear;
#line 1793
    tmp___1 = png_gamma_16bit_correct(red * 257U, g);
#line 1793
    red = (png_uint_32 )tmp___1;
#line 1794
    tmp___2 = png_gamma_16bit_correct(green * 257U, g);
#line 1794
    green = (png_uint_32 )tmp___2;
#line 1795
    tmp___3 = png_gamma_16bit_correct(blue * 257U, g);
#line 1795
    blue = (png_uint_32 )tmp___3;
#line 1797
    if (convert_to_Y != 0) {
#line 1799
      alpha *= 257U;
#line 1800
      encoding = 2;
    } else
#line 1797
    if (output_encoding == 2) {
#line 1799
      alpha *= 257U;
#line 1800
      encoding = 2;
    } else {
#line 1805
      red = (png_uint_32 )((png_byte )(255U & (((unsigned int )png_sRGB_base[red * 255U >> 15] + ((red * 255U & 32767U) * (unsigned int )png_sRGB_delta[red * 255U >> 15] >> 12)) >> 8)));
#line 1806
      green = (png_uint_32 )((png_byte )(255U & (((unsigned int )png_sRGB_base[green * 255U >> 15] + ((green * 255U & 32767U) * (unsigned int )png_sRGB_delta[green * 255U >> 15] >> 12)) >> 8)));
#line 1807
      blue = (png_uint_32 )((png_byte )(255U & (((unsigned int )png_sRGB_base[blue * 255U >> 15] + ((blue * 255U & 32767U) * (unsigned int )png_sRGB_delta[blue * 255U >> 15] >> 12)) >> 8)));
#line 1808
      encoding = 1;
    }
  } else
#line 1812
  if (encoding == 4) {
#line 1817
    red *= 257U;
#line 1818
    green *= 257U;
#line 1819
    blue *= 257U;
#line 1820
    alpha *= 257U;
#line 1821
    encoding = 2;
  } else
#line 1824
  if (encoding == 1) {
#line 1824
    if (convert_to_Y != 0) {
#line 1830
      red = (png_uint_32 )png_sRGB_table[red];
#line 1831
      green = (png_uint_32 )png_sRGB_table[green];
#line 1832
      blue = (png_uint_32 )png_sRGB_table[blue];
#line 1833
      alpha *= 257U;
#line 1834
      encoding = 2;
    } else
#line 1824
    if (output_encoding == 2) {
#line 1830
      red = (png_uint_32 )png_sRGB_table[red];
#line 1831
      green = (png_uint_32 )png_sRGB_table[green];
#line 1832
      blue = (png_uint_32 )png_sRGB_table[blue];
#line 1833
      alpha *= 257U;
#line 1834
      encoding = 2;
    }
  }
#line 1838
  if (encoding == 2) {
#line 1840
    if (convert_to_Y != 0) {
#line 1843
      y = (6968U * red + 23434U * green) + 2366U * blue;
#line 1846
      if (output_encoding == 2) {
#line 1847
        y = (y + 16384U) >> 15;
      } else {
#line 1852
        y = (y + 128U) >> 8;
#line 1853
        y *= 255U;
#line 1854
        y = (png_uint_32 )((png_byte )(255U & (((unsigned int )png_sRGB_base[((y + 64U) >> 7) >> 15] + ((((y + 64U) >> 7) & 32767U) * (unsigned int )png_sRGB_delta[((y + 64U) >> 7) >> 15] >> 12)) >> 8)));
#line 1855
        alpha = (alpha * 255U + 32895U) >> 16;
#line 1856
        encoding = 1;
      }
#line 1859
      green = y;
#line 1859
      red = green;
#line 1859
      blue = red;
    } else
#line 1862
    if (output_encoding == 1) {
#line 1864
      red = (png_uint_32 )((png_byte )(255U & (((unsigned int )png_sRGB_base[red * 255U >> 15] + ((red * 255U & 32767U) * (unsigned int )png_sRGB_delta[red * 255U >> 15] >> 12)) >> 8)));
#line 1865
      green = (png_uint_32 )((png_byte )(255U & (((unsigned int )png_sRGB_base[green * 255U >> 15] + ((green * 255U & 32767U) * (unsigned int )png_sRGB_delta[green * 255U >> 15] >> 12)) >> 8)));
#line 1866
      blue = (png_uint_32 )((png_byte )(255U & (((unsigned int )png_sRGB_base[blue * 255U >> 15] + ((blue * 255U & 32767U) * (unsigned int )png_sRGB_delta[blue * 255U >> 15] >> 12)) >> 8)));
#line 1867
      alpha = (alpha * 255U + 32895U) >> 16;
#line 1868
      encoding = 1;
    }
  }
#line 1872
  if (encoding != output_encoding) {
#line 1873
    png_error((png_const_structrp )(image->opaque)->png_ptr, (png_const_charp )"bad encoding (internal error)");
  }
#line 1878
  if ((image->format & 0x20U) != 0U) {
#line 1878
    if ((image->format & 0x01U) != 0U) {
#line 1878
      tmp___4 = 1;
    } else {
#line 1878
      tmp___4 = 0;
    }
  } else {
#line 1878
    tmp___4 = 0;
  }
#line 1878
  afirst = tmp___4;
#line 1884
  if ((image->format & 0x10U) != 0U) {
#line 1884
    tmp___5 = 2;
  } else {
#line 1884
    tmp___5 = 0;
  }
#line 1884
  bgr = tmp___5;
#line 1889
  if (output_encoding == 2) {
#line 1891
    entry = (png_uint_16p )display->colormap;
#line 1893
    entry += ip * ((image->format & 3U) + 1U);
    {
#line 1901
    if ((image->format & 3U) + 1U == 4U) {
#line 1901
      goto case_4;
    }
#line 1905
    if ((image->format & 3U) + 1U == 3U) {
#line 1905
      goto case_3;
    }
#line 1923
    if ((image->format & 3U) + 1U == 2U) {
#line 1923
      goto case_2;
    }
#line 1927
    if ((image->format & 3U) + 1U == 1U) {
#line 1927
      goto case_1;
    }
#line 1939
    goto switch_default;
    case_4: /* CIL Label */
#line 1902
    if (afirst) {
#line 1902
      tmp___6 = 0;
    } else {
#line 1902
      tmp___6 = 3;
    }
#line 1902
    *(entry + tmp___6) = (png_uint_16 )alpha;
    case_3: /* CIL Label */
#line 1906
    if (alpha < 65535U) {
#line 1908
      if (alpha > 0U) {
#line 1910
        blue = (blue * alpha + 32767U) / 65535U;
#line 1911
        green = (green * alpha + 32767U) / 65535U;
#line 1912
        red = (red * alpha + 32767U) / 65535U;
      } else {
#line 1916
        blue = (png_uint_32 )0;
#line 1916
        green = blue;
#line 1916
        red = green;
      }
    }
#line 1918
    *(entry + (afirst + (2 ^ bgr))) = (png_uint_16 )blue;
#line 1919
    *(entry + (afirst + 1)) = (png_uint_16 )green;
#line 1920
    *(entry + (afirst + bgr)) = (png_uint_16 )red;
#line 1921
    goto switch_break;
    case_2: /* CIL Label */
#line 1924
    *(entry + (1 ^ afirst)) = (png_uint_16 )alpha;
    case_1: /* CIL Label */
#line 1928
    if (alpha < 65535U) {
#line 1930
      if (alpha > 0U) {
#line 1931
        green = (green * alpha + 32767U) / 65535U;
      } else {
#line 1934
        green = (png_uint_32 )0;
      }
    }
#line 1936
    *(entry + afirst) = (png_uint_16 )green;
#line 1937
    goto switch_break;
    switch_default: /* CIL Label */
#line 1940
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
#line 1946
    entry___0 = (png_bytep )display->colormap;
#line 1948
    entry___0 += ip * ((image->format & 3U) + 1U);
    {
#line 1952
    if ((image->format & 3U) + 1U == 4U) {
#line 1952
      goto case_4___0;
    }
#line 1955
    if ((image->format & 3U) + 1U == 3U) {
#line 1955
      goto case_3___0;
    }
#line 1961
    if ((image->format & 3U) + 1U == 2U) {
#line 1961
      goto case_2___0;
    }
#line 1964
    if ((image->format & 3U) + 1U == 1U) {
#line 1964
      goto case_1___0;
    }
#line 1968
    goto switch_default___0;
    case_4___0: /* CIL Label */
#line 1953
    if (afirst) {
#line 1953
      tmp___7 = 0;
    } else {
#line 1953
      tmp___7 = 3;
    }
#line 1953
    *(entry___0 + tmp___7) = (png_byte )alpha;
    case_3___0: /* CIL Label */
#line 1956
    *(entry___0 + (afirst + (2 ^ bgr))) = (png_byte )blue;
#line 1957
    *(entry___0 + (afirst + 1)) = (png_byte )green;
#line 1958
    *(entry___0 + (afirst + bgr)) = (png_byte )red;
#line 1959
    goto switch_break___0;
    case_2___0: /* CIL Label */
#line 1962
    *(entry___0 + (1 ^ afirst)) = (png_byte )alpha;
    case_1___0: /* CIL Label */
#line 1965
    *(entry___0 + afirst) = (png_byte )green;
#line 1966
    goto switch_break___0;
    switch_default___0: /* CIL Label */
#line 1969
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 1980
  return;
}
}
#line 1982 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
static int make_gray_file_colormap(png_image_read_control *display )
{
  unsigned int i ;

  {
#line 1987
  i = 0U;
  {
#line 1987
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1987
    if (! (i < 256U)) {
#line 1987
      goto while_break;
    }
#line 1988
    png_create_colormap_entry(display, i, i, i, i, (png_uint_32 )255, 3);
#line 1987
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1990
  return ((int )i);
}
}
#line 1993 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
static int make_gray_colormap(png_image_read_control *display )
{
  unsigned int i ;

  {
#line 1998
  i = 0U;
  {
#line 1998
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1998
    if (! (i < 256U)) {
#line 1998
      goto while_break;
    }
#line 1999
    png_create_colormap_entry(display, i, i, i, i, (png_uint_32 )255, 1);
#line 1998
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2001
  return ((int )i);
}
}
#line 2005 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
static int make_ga_colormap(png_image_read_control *display )
{
  unsigned int i ;
  unsigned int a ;
  unsigned int gray ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int g ;
  unsigned int tmp___1 ;

  {
#line 2034
  i = 0U;
  {
#line 2035
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2035
    if (! (i < 231U)) {
#line 2035
      goto while_break;
    }
#line 2037
    gray = (i * 256U + 115U) / 231U;
#line 2038
    tmp = i;
#line 2038
    i ++;
#line 2038
    png_create_colormap_entry(display, tmp, gray, gray, gray, (png_uint_32 )255, 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 2044
  tmp___0 = i;
#line 2044
  i ++;
#line 2044
  png_create_colormap_entry(display, tmp___0, (png_uint_32 )255, (png_uint_32 )255,
                            (png_uint_32 )255, (png_uint_32 )0, 1);
#line 2046
  a = 1U;
  {
#line 2046
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2046
    if (! (a < 5U)) {
#line 2046
      goto while_break___0;
    }
#line 2050
    g = 0U;
    {
#line 2050
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2050
      if (! (g < 6U)) {
#line 2050
        goto while_break___1;
      }
#line 2051
      tmp___1 = i;
#line 2051
      i ++;
#line 2051
      png_create_colormap_entry(display, tmp___1, g * 51U, g * 51U, g * 51U, a * 51U,
                                1);
#line 2050
      g ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2046
    a ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2055
  return ((int )i);
}
}
#line 2060 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
static int make_rgb_colormap(png_image_read_control *display )
{
  unsigned int i ;
  unsigned int r ;
  unsigned int g ;
  unsigned int b ;
  unsigned int tmp ;

  {
#line 2066
  r = 0U;
#line 2066
  i = r;
  {
#line 2066
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2066
    if (! (r < 6U)) {
#line 2066
      goto while_break;
    }
#line 2070
    g = 0U;
    {
#line 2070
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2070
      if (! (g < 6U)) {
#line 2070
        goto while_break___0;
      }
#line 2074
      b = 0U;
      {
#line 2074
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2074
        if (! (b < 6U)) {
#line 2074
          goto while_break___1;
        }
#line 2075
        tmp = i;
#line 2075
        i ++;
#line 2075
        png_create_colormap_entry(display, tmp, r * 51U, g * 51U, b * 51U, (png_uint_32 )255,
                                  1);
#line 2074
        b ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2070
      g ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2066
    r ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2080
  return ((int )i);
}
}
#line 2089 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
static int png_image_read_colormap(png_voidp argument )
{
  png_image_read_control *display ;
  png_imagep image ;
  png_structrp png_ptr ;
  png_uint_32 output_format ;
  int output_encoding ;
  int tmp ;
  unsigned int cmap_entries ;
  unsigned int output_processing ;
  unsigned int data_encoding ;
  unsigned int background_index ;
  png_uint_32 back_r ;
  png_uint_32 back_g ;
  png_uint_32 back_b ;
  int expand_tRNS ;
  unsigned int step ;
  unsigned int i ;
  unsigned int val ;
  unsigned int trans ;
  unsigned int back_alpha ;
  int tmp___0 ;
  unsigned int back_alpha___0 ;
  png_color_16 c ;
  png_uint_32 gray ;
  int tmp___1 ;
  png_color_16 c___0 ;
  png_uint_32 gray___0 ;
  int tmp___2 ;
  png_uint_32 i___0 ;
  png_uint_32 a ;
  png_uint_32 gray___1 ;
  png_uint_32 tmp___3 ;
  unsigned int tmp___4 ;
  png_uint_32 tmp___5 ;
  unsigned int g ;
  png_uint_32 alpha ;
  png_uint_32 back_rx ;
  png_uint_32 back_gx ;
  png_uint_32 back_bx ;
  png_uint_32 gray___2 ;
  png_uint_32 tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  png_color_16 c___1 ;
  png_uint_32 gray___3 ;
  png_uint_16 tmp___11 ;
  png_uint_32 r ;
  int tmp___12 ;
  unsigned int tmp___13 ;
  png_uint_32 g___0 ;
  png_uint_32 b ;
  unsigned int tmp___14 ;
  unsigned int sample_size ;
  png_uint_32 r___0 ;
  png_uint_32 g___1 ;
  png_uint_32 b___0 ;
  int tmp___15 ;
  unsigned int tmp___16 ;
  png_uint_32 tmp___17 ;
  png_uint_32 tmp___18 ;
  png_uint_32 tmp___19 ;
  unsigned int tmp___20 ;
  png_color_16 c___2 ;
  int tmp___21 ;
  int tmp___22 ;
  unsigned int num_trans ;
  png_const_bytep trans___0 ;
  png_bytep tmp___23 ;
  png_const_colorp colormap ;
  int do_background ;
  int tmp___24 ;
  unsigned int i___1 ;
  unsigned int tmp___25 ;
  png_uint_32 tmp___26 ;
  png_uint_32 tmp___27 ;
  png_uint_32 tmp___28 ;
  unsigned int tmp___29 ;

  {
#line 2092
  display = (png_image_read_control *)argument;
#line 2094
  image = display->image;
#line 2096
  png_ptr = (png_structrp )(image->opaque)->png_ptr;
#line 2097
  output_format = image->format;
#line 2098
  if ((output_format & 0x04U) != 0U) {
#line 2098
    tmp = 2;
  } else {
#line 2098
    tmp = 1;
  }
#line 2098
  output_encoding = tmp;
#line 2103
  data_encoding = 0U;
#line 2108
  background_index = 256U;
#line 2112
  expand_tRNS = 0;
#line 2119
  if (((int )png_ptr->color_type & 4) != 0) {
#line 2119
    goto _L___0;
  } else
#line 2119
  if ((int )png_ptr->num_trans > 0) {
    _L___0: /* CIL Label */
#line 2119
    if ((output_format & 0x01U) == 0U) {
#line 2123
      if (output_encoding == 2) {
#line 2124
        back_r = (png_uint_32 )0;
#line 2124
        back_g = back_r;
#line 2124
        back_b = back_g;
      } else
#line 2126
      if ((unsigned long )display->background == (unsigned long )((void *)0)) {
#line 2127
        png_error((png_const_structrp )png_ptr, (png_const_charp )"background color must be supplied to remove alpha/transparency");
      } else {
#line 2136
        back_g = (png_uint_32 )(display->background)->green;
#line 2137
        if ((output_format & 0x02U) != 0U) {
#line 2139
          back_r = (png_uint_32 )(display->background)->red;
#line 2140
          back_b = (png_uint_32 )(display->background)->blue;
        } else {
#line 2143
          back_r = back_g;
#line 2143
          back_b = back_r;
        }
      }
    } else {
#line 2119
      goto _L;
    }
  } else
  _L: /* CIL Label */
#line 2147
  if (output_encoding == 2) {
#line 2148
    back_g = (png_uint_32 )65535;
#line 2148
    back_r = back_g;
#line 2148
    back_b = back_r;
  } else {
#line 2151
    back_g = (png_uint_32 )255;
#line 2151
    back_r = back_g;
#line 2151
    back_b = back_r;
  }
#line 2158
  if (((int )png_ptr->colorspace.flags & 0x0001) == 0) {
#line 2165
    if ((int )png_ptr->bit_depth == 16) {
#line 2165
      if ((image->flags & 4U) == 0U) {
#line 2167
        png_ptr->colorspace.gamma = 100000;
      } else {
#line 2170
        png_ptr->colorspace.gamma = 45455;
      }
    } else {
#line 2170
      png_ptr->colorspace.gamma = 45455;
    }
#line 2172
    png_ptr->colorspace.flags = (png_uint_16 )((int )png_ptr->colorspace.flags | 0x0001);
  }
  {
#line 2182
  if ((int )png_ptr->color_type == 0) {
#line 2182
    goto case_0;
  }
#line 2353
  if ((int )png_ptr->color_type == 4) {
#line 2353
    goto case_4;
  }
#line 2510
  if ((int )png_ptr->color_type == 6) {
#line 2510
    goto case_6;
  }
#line 2510
  if ((int )png_ptr->color_type == 2) {
#line 2510
    goto case_6;
  }
#line 2803
  if ((int )png_ptr->color_type == 3) {
#line 2803
    goto case_3;
  }
#line 2868
  goto switch_default;
  case_0: /* CIL Label */
#line 2183
  if ((int )png_ptr->bit_depth <= 8) {
#line 2188
    trans = 256U;
#line 2188
    back_alpha = 0U;
#line 2190
    cmap_entries = 1U << (int )png_ptr->bit_depth;
#line 2191
    if (cmap_entries > image->colormap_entries) {
#line 2192
      png_error((png_const_structrp )png_ptr, (png_const_charp )"gray[8] color-map: too few entries");
    }
#line 2194
    step = 255U / (cmap_entries - 1U);
#line 2195
    output_processing = 0U;
#line 2200
    if ((int )png_ptr->num_trans > 0) {
#line 2202
      trans = (unsigned int )png_ptr->trans_color.gray;
#line 2204
      if ((output_format & 0x01U) == 0U) {
#line 2205
        if (output_encoding == 2) {
#line 2205
          back_alpha = 65535U;
        } else {
#line 2205
          back_alpha = 255U;
        }
      }
    }
#line 2215
    val = 0U;
#line 2215
    i = val;
    {
#line 2215
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2215
      if (! (i < cmap_entries)) {
#line 2215
        goto while_break;
      }
#line 2221
      if (i != trans) {
#line 2222
        png_create_colormap_entry(display, i, val, val, val, (png_uint_32 )255, 3);
      } else {
#line 2234
        png_create_colormap_entry(display, i, back_r, back_g, back_b, back_alpha,
                                  output_encoding);
      }
#line 2215
      i ++;
#line 2215
      val += step;
    }
    while_break: /* CIL Label */ ;
    }
#line 2239
    data_encoding = 3U;
#line 2246
    if ((int )png_ptr->bit_depth < 8) {
#line 2247
      png_set_packing(png_ptr);
    }
  } else {
#line 2268
    data_encoding = 1U;
#line 2270
    if (256U > image->colormap_entries) {
#line 2271
      png_error((png_const_structrp )png_ptr, (png_const_charp )"gray[16] color-map: too few entries");
    }
#line 2273
    tmp___0 = make_gray_colormap(display);
#line 2273
    cmap_entries = (unsigned int )tmp___0;
#line 2275
    if ((int )png_ptr->num_trans > 0) {
#line 2279
      if ((output_format & 0x01U) != 0U) {
#line 2280
        back_alpha___0 = 0U;
      } else {
#line 2284
        if (back_r == back_g) {
#line 2284
          if (back_g == back_b) {
#line 2290
            gray = back_g;
#line 2292
            if (output_encoding == 2) {
#line 2294
              gray = (png_uint_32 )((png_byte )(255U & (((unsigned int )png_sRGB_base[gray * 255U >> 15] + ((gray * 255U & 32767U) * (unsigned int )png_sRGB_delta[gray * 255U >> 15] >> 12)) >> 8)));
#line 2299
              png_create_colormap_entry(display, gray, back_g, back_g, back_g, (png_uint_32 )65535,
                                        2);
            }
#line 2306
            c.index = (png_byte )0;
#line 2307
            c.blue = (png_uint_16 )gray;
#line 2307
            c.green = c.blue;
#line 2307
            c.red = c.green;
#line 2307
            c.gray = c.red;
#line 2313
            png_set_background_fixed(png_ptr, (png_const_color_16p )(& c), 1, 0, 0);
#line 2317
            output_processing = 0U;
#line 2318
            goto switch_break;
          }
        }
#line 2326
        if (output_encoding == 2) {
#line 2326
          back_alpha___0 = 65535U;
        } else {
#line 2326
          back_alpha___0 = 255U;
        }
      }
#line 2337
      expand_tRNS = 1;
#line 2338
      output_processing = 2U;
#line 2339
      background_index = 254U;
#line 2344
      png_create_colormap_entry(display, (png_uint_32 )254, back_r, back_g, back_b,
                                back_alpha___0, output_encoding);
    } else {
#line 2349
      output_processing = 0U;
    }
  }
#line 2351
  goto switch_break;
  case_4: /* CIL Label */
#line 2364
  data_encoding = 1U;
#line 2366
  if ((output_format & 0x01U) != 0U) {
#line 2368
    if (256U > image->colormap_entries) {
#line 2369
      png_error((png_const_structrp )png_ptr, (png_const_charp )"gray+alpha color-map: too few entries");
    }
#line 2371
    tmp___1 = make_ga_colormap(display);
#line 2371
    cmap_entries = (unsigned int )tmp___1;
#line 2373
    background_index = 231U;
#line 2374
    output_processing = 1U;
  } else
#line 2395
  if ((output_format & 0x02U) == 0U) {
#line 2395
    goto _L___1;
  } else
#line 2395
  if (back_r == back_g) {
#line 2395
    if (back_g == back_b) {
      _L___1: /* CIL Label */
#line 2400
      gray___0 = back_g;
#line 2402
      if (256U > image->colormap_entries) {
#line 2403
        png_error((png_const_structrp )png_ptr, (png_const_charp )"gray-alpha color-map: too few entries");
      }
#line 2405
      tmp___2 = make_gray_colormap(display);
#line 2405
      cmap_entries = (unsigned int )tmp___2;
#line 2407
      if (output_encoding == 2) {
#line 2409
        gray___0 = (png_uint_32 )((png_byte )(255U & (((unsigned int )png_sRGB_base[gray___0 * 255U >> 15] + ((gray___0 * 255U & 32767U) * (unsigned int )png_sRGB_delta[gray___0 * 255U >> 15] >> 12)) >> 8)));
#line 2412
        png_create_colormap_entry(display, gray___0, back_g, back_g, back_g, (png_uint_32 )65535,
                                  2);
      }
#line 2419
      c___0.index = (png_byte )0;
#line 2420
      c___0.blue = (png_uint_16 )gray___0;
#line 2420
      c___0.green = c___0.blue;
#line 2420
      c___0.red = c___0.green;
#line 2420
      c___0.gray = c___0.red;
#line 2422
      png_set_background_fixed(png_ptr, (png_const_color_16p )(& c___0), 1, 0, 0);
#line 2426
      output_processing = 0U;
    } else {
#line 2395
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */
#line 2436
    if (256U > image->colormap_entries) {
#line 2437
      png_error((png_const_structrp )png_ptr, (png_const_charp )"ga-alpha color-map: too few entries");
    }
#line 2439
    i___0 = (png_uint_32 )0;
    {
#line 2440
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2440
      if (! (i___0 < 231U)) {
#line 2440
        goto while_break___0;
      }
#line 2442
      gray___1 = (i___0 * 256U + 115U) / 231U;
#line 2443
      tmp___3 = i___0;
#line 2443
      i___0 ++;
#line 2443
      png_create_colormap_entry(display, tmp___3, gray___1, gray___1, gray___1, (png_uint_32 )255,
                                1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2450
    background_index = i___0;
#line 2451
    if (output_encoding == 2) {
#line 2451
      tmp___4 = 65535U;
    } else {
#line 2451
      tmp___4 = 255U;
    }
#line 2451
    tmp___5 = i___0;
#line 2451
    i___0 ++;
#line 2451
    png_create_colormap_entry(display, tmp___5, back_r, back_g, back_b, tmp___4, output_encoding);
#line 2469
    if (output_encoding == 1) {
#line 2475
      back_r = (png_uint_32 )png_sRGB_table[back_r];
#line 2476
      back_g = (png_uint_32 )png_sRGB_table[back_g];
#line 2477
      back_b = (png_uint_32 )png_sRGB_table[back_b];
    }
#line 2480
    a = (png_uint_32 )1;
    {
#line 2480
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2480
      if (! (a < 5U)) {
#line 2480
        goto while_break___1;
      }
#line 2487
      alpha = 51U * a;
#line 2488
      back_rx = (255U - alpha) * back_r;
#line 2489
      back_gx = (255U - alpha) * back_g;
#line 2490
      back_bx = (255U - alpha) * back_b;
#line 2492
      g = 0U;
      {
#line 2492
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2492
        if (! (g < 6U)) {
#line 2492
          goto while_break___2;
        }
#line 2494
        gray___2 = (png_uint_32 )png_sRGB_table[g * 51U] * alpha;
#line 2496
        tmp___6 = i___0;
#line 2496
        i___0 ++;
#line 2496
        png_create_colormap_entry(display, tmp___6, (png_uint_32 )((png_byte )(255U & (((unsigned int )png_sRGB_base[(gray___2 + back_rx) >> 15] + (((gray___2 + back_rx) & 32767U) * (unsigned int )png_sRGB_delta[(gray___2 + back_rx) >> 15] >> 12)) >> 8))),
                                  (png_uint_32 )((png_byte )(255U & (((unsigned int )png_sRGB_base[(gray___2 + back_gx) >> 15] + (((gray___2 + back_gx) & 32767U) * (unsigned int )png_sRGB_delta[(gray___2 + back_gx) >> 15] >> 12)) >> 8))),
                                  (png_uint_32 )((png_byte )(255U & (((unsigned int )png_sRGB_base[(gray___2 + back_bx) >> 15] + (((gray___2 + back_bx) & 32767U) * (unsigned int )png_sRGB_delta[(gray___2 + back_bx) >> 15] >> 12)) >> 8))),
                                  (png_uint_32 )255, 1);
#line 2492
        g ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 2480
      a ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2503
    cmap_entries = i___0;
#line 2504
    output_processing = 1U;
  }
#line 2507
  goto switch_break;
  case_6: /* CIL Label */
  case_2: /* CIL Label */
#line 2514
  if ((output_format & 0x02U) == 0U) {
#line 2524
    png_set_rgb_to_gray_fixed(png_ptr, 1, -1, -1);
#line 2526
    data_encoding = 1U;
#line 2531
    if ((int )png_ptr->color_type == 6) {
#line 2531
      goto _L___6;
    } else
#line 2531
    if ((int )png_ptr->num_trans > 0) {
      _L___6: /* CIL Label */
#line 2531
      if ((output_format & 0x01U) != 0U) {
#line 2539
        expand_tRNS = 1;
#line 2541
        if (256U > image->colormap_entries) {
#line 2542
          png_error((png_const_structrp )png_ptr, (png_const_charp )"rgb[ga] color-map: too few entries");
        }
#line 2544
        tmp___7 = make_ga_colormap(display);
#line 2544
        cmap_entries = (unsigned int )tmp___7;
#line 2545
        background_index = 231U;
#line 2546
        output_processing = 1U;
      } else {
#line 2531
        goto _L___5;
      }
    } else {
      _L___5: /* CIL Label */
#line 2555
      if (256U > image->colormap_entries) {
#line 2556
        png_error((png_const_structrp )png_ptr, (png_const_charp )"rgb[gray] color-map: too few entries");
      }
#line 2566
      if ((int )png_ptr->color_type == 6) {
#line 2566
        goto _L___3;
      } else
#line 2566
      if ((int )png_ptr->num_trans > 0) {
        _L___3: /* CIL Label */
#line 2566
        tmp___10 = png_gamma_not_sRGB(png_ptr->colorspace.gamma);
#line 2566
        if (tmp___10 != 0) {
#line 2570
          tmp___8 = make_gray_file_colormap(display);
#line 2570
          cmap_entries = (unsigned int )tmp___8;
#line 2571
          data_encoding = 3U;
        } else {
#line 2575
          tmp___9 = make_gray_colormap(display);
#line 2575
          cmap_entries = (unsigned int )tmp___9;
        }
      } else {
#line 2575
        tmp___9 = make_gray_colormap(display);
#line 2575
        cmap_entries = (unsigned int )tmp___9;
      }
#line 2579
      if ((int )png_ptr->color_type == 6) {
#line 2579
        goto _L___4;
      } else
#line 2579
      if ((int )png_ptr->num_trans > 0) {
        _L___4: /* CIL Label */
#line 2583
        gray___3 = back_g;
#line 2590
        if (data_encoding == 3U) {
#line 2597
          if (output_encoding == 1) {
#line 2598
            gray___3 = (png_uint_32 )png_sRGB_table[gray___3];
          }
#line 2600
          tmp___11 = png_gamma_16bit_correct(gray___3, png_ptr->colorspace.gamma);
#line 2600
          gray___3 = ((png_uint_32 )tmp___11 * 255U + 32895U) >> 16;
#line 2606
          png_create_colormap_entry(display, gray___3, back_g, back_g, back_g, (png_uint_32 )0,
                                    output_encoding);
        } else
#line 2610
        if (output_encoding == 2) {
#line 2612
          gray___3 = (png_uint_32 )((png_byte )(255U & (((unsigned int )png_sRGB_base[gray___3 * 255U >> 15] + ((gray___3 * 255U & 32767U) * (unsigned int )png_sRGB_delta[gray___3 * 255U >> 15] >> 12)) >> 8)));
#line 2616
          png_create_colormap_entry(display, gray___3, back_g, back_g, back_g, (png_uint_32 )0,
                                    2);
        }
#line 2623
        c___1.index = (png_byte )0;
#line 2624
        c___1.blue = (png_uint_16 )gray___3;
#line 2624
        c___1.green = c___1.blue;
#line 2624
        c___1.red = c___1.green;
#line 2624
        c___1.gray = c___1.red;
#line 2630
        expand_tRNS = 1;
#line 2631
        png_set_background_fixed(png_ptr, (png_const_color_16p )(& c___1), 1, 0, 0);
      }
#line 2636
      output_processing = 0U;
    }
  } else {
#line 2647
    data_encoding = 1U;
#line 2650
    if ((int )png_ptr->color_type == 6) {
#line 2650
      goto _L___7;
    } else
#line 2650
    if ((int )png_ptr->num_trans > 0) {
      _L___7: /* CIL Label */
#line 2656
      if ((output_format & 0x01U) != 0U) {
#line 2660
        if (244U > image->colormap_entries) {
#line 2661
          png_error((png_const_structrp )png_ptr, (png_const_charp )"rgb+alpha color-map: too few entries");
        }
#line 2663
        tmp___12 = make_rgb_colormap(display);
#line 2663
        cmap_entries = (unsigned int )tmp___12;
#line 2666
        png_create_colormap_entry(display, cmap_entries, (png_uint_32 )255, (png_uint_32 )255,
                                  (png_uint_32 )255, (png_uint_32 )0, 1);
#line 2672
        tmp___13 = cmap_entries;
#line 2672
        cmap_entries ++;
#line 2672
        background_index = tmp___13;
#line 2675
        r = (png_uint_32 )0;
        {
#line 2675
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 2675
          if (! (r < 256U)) {
#line 2675
            goto while_break___3;
          }
#line 2679
          g___0 = (png_uint_32 )0;
          {
#line 2679
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 2679
            if (! (g___0 < 256U)) {
#line 2679
              goto while_break___4;
            }
#line 2686
            b = (png_uint_32 )0;
            {
#line 2686
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 2686
              if (! (b < 256U)) {
#line 2686
                goto while_break___5;
              }
#line 2687
              tmp___14 = cmap_entries;
#line 2687
              cmap_entries ++;
#line 2687
              png_create_colormap_entry(display, tmp___14, r, g___0, b, (png_uint_32 )128,
                                        1);
#line 2686
              b = (b << 1) | 127U;
            }
            while_break___5: /* CIL Label */ ;
            }
#line 2679
            g___0 = (g___0 << 1) | 127U;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 2675
          r = (r << 1) | 127U;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 2692
        expand_tRNS = 1;
#line 2693
        output_processing = 4U;
      } else {
#line 2705
        sample_size = ((output_format & 3U) + 1U) * (((output_format & 0x04U) >> 2) + 1U);
#line 2709
        if (244U > image->colormap_entries) {
#line 2710
          png_error((png_const_structrp )png_ptr, (png_const_charp )"rgb-alpha color-map: too few entries");
        }
#line 2712
        tmp___15 = make_rgb_colormap(display);
#line 2712
        cmap_entries = (unsigned int )tmp___15;
#line 2714
        png_create_colormap_entry(display, cmap_entries, back_r, back_g, back_b, (png_uint_32 )0,
                                  output_encoding);
#line 2717
        if (output_encoding == 2) {
#line 2719
          r___0 = (png_uint_32 )((png_byte )(255U & (((unsigned int )png_sRGB_base[back_r * 255U >> 15] + ((back_r * 255U & 32767U) * (unsigned int )png_sRGB_delta[back_r * 255U >> 15] >> 12)) >> 8)));
#line 2720
          g___1 = (png_uint_32 )((png_byte )(255U & (((unsigned int )png_sRGB_base[back_g * 255U >> 15] + ((back_g * 255U & 32767U) * (unsigned int )png_sRGB_delta[back_g * 255U >> 15] >> 12)) >> 8)));
#line 2721
          b___0 = (png_uint_32 )((png_byte )(255U & (((unsigned int )png_sRGB_base[back_b * 255U >> 15] + ((back_b * 255U & 32767U) * (unsigned int )png_sRGB_delta[back_b * 255U >> 15] >> 12)) >> 8)));
        } else {
#line 2726
          r___0 = back_r;
#line 2727
          g___1 = back_g;
#line 2728
          b___0 = back_g;
        }
#line 2736
        tmp___21 = memcmp((void const   *)((png_const_bytep )display->colormap + sample_size * cmap_entries),
                          (void const   *)((png_const_bytep )display->colormap + sample_size * (unsigned int )((png_byte )(6U * (6U * ((r___0 * 5U + 130U) >> 8) + ((g___1 * 5U + 130U) >> 8)) + ((b___0 * 5U + 130U) >> 8)))),
                          (size_t )sample_size);
#line 2736
        if (tmp___21 != 0) {
#line 2743
          tmp___16 = cmap_entries;
#line 2743
          cmap_entries ++;
#line 2743
          background_index = tmp___16;
#line 2748
          r___0 = (png_uint_32 )0;
          {
#line 2748
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 2748
            if (! (r___0 < 256U)) {
#line 2748
              goto while_break___6;
            }
#line 2750
            g___1 = (png_uint_32 )0;
            {
#line 2750
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 2750
              if (! (g___1 < 256U)) {
#line 2750
                goto while_break___7;
              }
#line 2755
              b___0 = (png_uint_32 )0;
              {
#line 2755
              while (1) {
                while_continue___8: /* CIL Label */ ;
#line 2755
                if (! (b___0 < 256U)) {
#line 2755
                  goto while_break___8;
                }
#line 2756
                tmp___17 = png_colormap_compose(display, b___0, 1, (png_uint_32 )128,
                                                back_b, output_encoding);
#line 2756
                tmp___18 = png_colormap_compose(display, g___1, 1, (png_uint_32 )128,
                                                back_g, output_encoding);
#line 2756
                tmp___19 = png_colormap_compose(display, r___0, 1, (png_uint_32 )128,
                                                back_r, output_encoding);
#line 2756
                tmp___20 = cmap_entries;
#line 2756
                cmap_entries ++;
#line 2756
                png_create_colormap_entry(display, tmp___20, tmp___19, tmp___18, tmp___17,
                                          (png_uint_32 )0, output_encoding);
#line 2755
                b___0 = (b___0 << 1) | 127U;
              }
              while_break___8: /* CIL Label */ ;
              }
#line 2750
              g___1 = (g___1 << 1) | 127U;
            }
            while_break___7: /* CIL Label */ ;
            }
#line 2748
            r___0 = (r___0 << 1) | 127U;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 2767
          expand_tRNS = 1;
#line 2768
          output_processing = 4U;
        } else {
#line 2775
          c___2.index = (png_byte )0;
#line 2776
          c___2.red = (png_uint_16 )back_r;
#line 2777
          c___2.green = (png_uint_16 )back_g;
#line 2777
          c___2.gray = c___2.green;
#line 2778
          c___2.blue = (png_uint_16 )back_b;
#line 2780
          png_set_background_fixed(png_ptr, (png_const_color_16p )(& c___2), 1, 0,
                                   0);
#line 2784
          output_processing = 3U;
        }
      }
    } else {
#line 2794
      if (216U > image->colormap_entries) {
#line 2795
        png_error((png_const_structrp )png_ptr, (png_const_charp )"rgb color-map: too few entries");
      }
#line 2797
      tmp___22 = make_rgb_colormap(display);
#line 2797
      cmap_entries = (unsigned int )tmp___22;
#line 2798
      output_processing = 3U;
    }
  }
#line 2801
  goto switch_break;
  case_3: /* CIL Label */
#line 2808
  num_trans = (unsigned int )png_ptr->num_trans;
#line 2809
  if (num_trans > 0U) {
#line 2809
    tmp___23 = png_ptr->trans_alpha;
  } else {
#line 2809
    tmp___23 = (png_bytep )((void *)0);
  }
#line 2809
  trans___0 = (png_const_bytep )tmp___23;
#line 2810
  colormap = (png_const_colorp )png_ptr->palette;
#line 2811
  if ((unsigned long )trans___0 != (unsigned long )((void *)0)) {
#line 2811
    if ((output_format & 0x01U) == 0U) {
#line 2811
      tmp___24 = 1;
    } else {
#line 2811
      tmp___24 = 0;
    }
  } else {
#line 2811
    tmp___24 = 0;
  }
#line 2811
  do_background = tmp___24;
#line 2816
  if ((unsigned long )trans___0 == (unsigned long )((void *)0)) {
#line 2817
    num_trans = 0U;
  }
#line 2819
  output_processing = 0U;
#line 2820
  data_encoding = 3U;
#line 2821
  cmap_entries = (unsigned int )png_ptr->num_palette;
#line 2822
  if (cmap_entries > 256U) {
#line 2823
    cmap_entries = 256U;
  }
#line 2825
  if (cmap_entries > image->colormap_entries) {
#line 2826
    png_error((png_const_structrp )png_ptr, (png_const_charp )"palette color-map: too few entries");
  }
#line 2828
  i___1 = 0U;
  {
#line 2828
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 2828
    if (! (i___1 < cmap_entries)) {
#line 2828
      goto while_break___9;
    }
#line 2830
    if (do_background != 0) {
#line 2830
      if (i___1 < num_trans) {
#line 2830
        if ((int const   )*(trans___0 + i___1) < 255) {
#line 2832
          if ((int const   )*(trans___0 + i___1) == 0) {
#line 2833
            png_create_colormap_entry(display, i___1, back_r, back_g, back_b, (png_uint_32 )0,
                                      output_encoding);
          } else {
#line 2841
            if (output_encoding == 2) {
#line 2841
              tmp___25 = (unsigned int )*(trans___0 + i___1) * 257U;
            } else {
#line 2841
              tmp___25 = (unsigned int )*(trans___0 + i___1);
            }
#line 2841
            tmp___26 = png_colormap_compose(display, (png_uint_32 )(colormap + i___1)->blue,
                                            3, (png_uint_32 )*(trans___0 + i___1),
                                            back_b, output_encoding);
#line 2841
            tmp___27 = png_colormap_compose(display, (png_uint_32 )(colormap + i___1)->green,
                                            3, (png_uint_32 )*(trans___0 + i___1),
                                            back_g, output_encoding);
#line 2841
            tmp___28 = png_colormap_compose(display, (png_uint_32 )(colormap + i___1)->red,
                                            3, (png_uint_32 )*(trans___0 + i___1),
                                            back_r, output_encoding);
#line 2841
            png_create_colormap_entry(display, i___1, tmp___28, tmp___27, tmp___26,
                                      tmp___25, output_encoding);
          }
        } else {
#line 2830
          goto _L___9;
        }
      } else {
#line 2830
        goto _L___9;
      }
    } else {
      _L___9: /* CIL Label */
      _L___8: /* CIL Label */
#line 2855
      if (i___1 < num_trans) {
#line 2855
        tmp___29 = (unsigned int )*(trans___0 + i___1);
      } else {
#line 2855
        tmp___29 = 255U;
      }
#line 2855
      png_create_colormap_entry(display, i___1, (png_uint_32 )(colormap + i___1)->red,
                                (png_uint_32 )(colormap + i___1)->green, (png_uint_32 )(colormap + i___1)->blue,
                                tmp___29, 3);
    }
#line 2828
    i___1 ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 2863
  if ((int )png_ptr->bit_depth < 8) {
#line 2864
    png_set_packing(png_ptr);
  }
#line 2866
  goto switch_break;
  switch_default: /* CIL Label */
#line 2869
  png_error((png_const_structrp )png_ptr, (png_const_charp )"invalid PNG color type");
  switch_break: /* CIL Label */ ;
  }
#line 2874
  if (expand_tRNS != 0) {
#line 2874
    if ((int )png_ptr->num_trans > 0) {
#line 2874
      if (((int )png_ptr->color_type & 4) == 0) {
#line 2876
        png_set_tRNS_to_alpha(png_ptr);
      }
    }
  }
  {
#line 2880
  if (data_encoding == 1U) {
#line 2880
    goto case_1;
  }
#line 2885
  if (data_encoding == 3U) {
#line 2885
    goto case_3___0;
  }
#line 2891
  goto switch_default___0;
  case_1: /* CIL Label */
#line 2882
  png_set_alpha_mode_fixed(png_ptr, 0, 220000);
  case_3___0: /* CIL Label */
#line 2886
  if ((int )png_ptr->bit_depth > 8) {
#line 2887
    png_set_scale_16(png_ptr);
  }
#line 2888
  goto switch_break___0;
  switch_default___0: /* CIL Label */
#line 2892
  png_error((png_const_structrp )png_ptr, (png_const_charp )"bad data option (internal error)");
  switch_break___0: /* CIL Label */ ;
  }
#line 2896
  if (cmap_entries > 256U) {
#line 2897
    png_error((png_const_structrp )png_ptr, (png_const_charp )"color map overflow (BAD internal error)");
  } else
#line 2896
  if (cmap_entries > image->colormap_entries) {
#line 2897
    png_error((png_const_structrp )png_ptr, (png_const_charp )"color map overflow (BAD internal error)");
  }
#line 2899
  image->colormap_entries = cmap_entries;
  {
#line 2904
  if (output_processing == 0U) {
#line 2904
    goto case_0___0;
  }
#line 2909
  if (output_processing == 1U) {
#line 2909
    goto case_1___0;
  }
#line 2914
  if (output_processing == 2U) {
#line 2914
    goto case_2___0;
  }
#line 2920
  if (output_processing == 3U) {
#line 2920
    goto case_3___1;
  }
#line 2925
  if (output_processing == 4U) {
#line 2925
    goto case_4___0;
  }
#line 2930
  goto switch_default___1;
  case_0___0: /* CIL Label */
#line 2905
  if (background_index != 256U) {
#line 2906
    goto bad_background;
  }
#line 2907
  goto switch_break___1;
  case_1___0: /* CIL Label */
#line 2910
  if (background_index != 231U) {
#line 2911
    goto bad_background;
  }
#line 2912
  goto switch_break___1;
  case_2___0: /* CIL Label */
#line 2915
  if (background_index >= cmap_entries) {
#line 2917
    goto bad_background;
  } else
#line 2915
  if (background_index != 254U) {
#line 2917
    goto bad_background;
  }
#line 2918
  goto switch_break___1;
  case_3___1: /* CIL Label */
#line 2921
  if (background_index != 256U) {
#line 2922
    goto bad_background;
  }
#line 2923
  goto switch_break___1;
  case_4___0: /* CIL Label */
#line 2926
  if (background_index != 216U) {
#line 2927
    goto bad_background;
  }
#line 2928
  goto switch_break___1;
  switch_default___1: /* CIL Label */
#line 2931
  png_error((png_const_structrp )png_ptr, (png_const_charp )"bad processing option (internal error)");
  bad_background:
#line 2934
  png_error((png_const_structrp )png_ptr, (png_const_charp )"bad background index (internal error)");
  switch_break___1: /* CIL Label */ ;
  }
#line 2937
  display->colormap_processing = (int )output_processing;
#line 2939
  return (1);
}
}
#line 2943 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
static int png_image_read_and_map(png_voidp argument )
{
  png_image_read_control *display ;
  png_imagep image ;
  png_structrp png_ptr ;
  int passes ;
  png_uint_32 height ;
  png_uint_32 width ;
  int proc ;
  png_bytep first_row ;
  ptrdiff_t step_row ;
  int pass ;
  unsigned int startx ;
  unsigned int stepx ;
  unsigned int stepy ;
  png_uint_32 y ;
  int tmp ;
  int tmp___0 ;
  png_bytep inrow ;
  png_bytep outrow ;
  png_const_bytep end_row ;
  unsigned int gray ;
  png_bytep tmp___1 ;
  unsigned int alpha ;
  png_bytep tmp___2 ;
  unsigned int entry ;
  png_byte gray___0 ;
  png_bytep tmp___3 ;
  png_byte alpha___0 ;
  png_bytep tmp___4 ;
  unsigned int alpha___1 ;
  unsigned int back_i ;

  {
#line 2946
  display = (png_image_read_control *)argument;
#line 2948
  image = display->image;
#line 2949
  png_ptr = (png_structrp )(image->opaque)->png_ptr;
  {
#line 2958
  if ((int )png_ptr->interlaced == 0) {
#line 2958
    goto case_0;
  }
#line 2962
  if ((int )png_ptr->interlaced == 1) {
#line 2962
    goto case_1;
  }
#line 2966
  goto switch_default;
  case_0: /* CIL Label */
#line 2959
  passes = 1;
#line 2960
  goto switch_break;
  case_1: /* CIL Label */
#line 2963
  passes = 7;
#line 2964
  goto switch_break;
  switch_default: /* CIL Label */
#line 2967
  png_error((png_const_structrp )png_ptr, (png_const_charp )"unknown interlace type");
  switch_break: /* CIL Label */ ;
  }
#line 2971
  height = image->height;
#line 2972
  width = image->width;
#line 2973
  proc = display->colormap_processing;
#line 2974
  first_row = (png_bytep )display->first_row;
#line 2975
  step_row = display->row_bytes;
#line 2978
  pass = 0;
  {
#line 2978
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2978
    if (! (pass < passes)) {
#line 2978
      goto while_break;
    }
#line 2983
    if ((int )png_ptr->interlaced == 1) {
#line 2986
      if (pass > 1) {
#line 2986
        tmp = (7 - pass) >> 1;
      } else {
#line 2986
        tmp = 3;
      }
#line 2986
      if (pass > 1) {
#line 2986
        tmp___0 = (7 - pass) >> 1;
      } else {
#line 2986
        tmp___0 = 3;
      }
#line 2986
      if ((width + (png_uint_32 )(((1 << tmp) - 1) - (((1 & pass) << (3 - ((pass + 1) >> 1))) & 7))) >> tmp___0 == 0U) {
#line 2987
        goto __Cont;
      }
#line 2989
      startx = (unsigned int )(((1 & pass) << (3 - ((pass + 1) >> 1))) & 7);
#line 2990
      stepx = (unsigned int )(1 << ((7 - pass) >> 1));
#line 2991
      y = (png_uint_32 )(((1 & ~ pass) << (3 - (pass >> 1))) & 7);
#line 2992
      if (pass > 2) {
#line 2992
        stepy = (unsigned int )(8 >> ((pass - 1) >> 1));
      } else {
#line 2992
        stepy = 8U;
      }
    } else {
#line 2997
      y = (png_uint_32 )0;
#line 2998
      startx = 0U;
#line 2999
      stepy = 1U;
#line 2999
      stepx = stepy;
    }
    {
#line 3002
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3002
      if (! (y < height)) {
#line 3002
        goto while_break___0;
      }
#line 3004
      inrow = (png_bytep )display->local_row;
#line 3005
      outrow = first_row + (ptrdiff_t )y * step_row;
#line 3006
      end_row = (png_const_bytep )(outrow + width);
#line 3009
      png_read_row(png_ptr, inrow, (png_bytep )((void *)0));
#line 3015
      outrow += startx;
      {
#line 3018
      if (proc == 1) {
#line 3018
        goto case_1___0;
      }
#line 3047
      if (proc == 2) {
#line 3047
        goto case_2;
      }
#line 3064
      if (proc == 3) {
#line 3064
        goto case_3;
      }
#line 3072
      if (proc == 4) {
#line 3072
        goto case_4;
      }
#line 3122
      goto switch_default___0;
      case_1___0: /* CIL Label */
      {
#line 3019
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3019
        if (! ((unsigned long )outrow < (unsigned long )end_row)) {
#line 3019
          goto while_break___1;
        }
#line 3022
        tmp___1 = inrow;
#line 3022
        inrow ++;
#line 3022
        gray = (unsigned int )*tmp___1;
#line 3023
        tmp___2 = inrow;
#line 3023
        inrow ++;
#line 3023
        alpha = (unsigned int )*tmp___2;
#line 3030
        if (alpha > 229U) {
#line 3032
          entry = (231U * gray + 128U) >> 8;
        } else
#line 3034
        if (alpha < 26U) {
#line 3036
          entry = 231U;
        } else {
#line 3040
          entry = (226U + 6U * ((alpha * 5U + 130U) >> 8)) + ((gray * 5U + 130U) >> 8);
        }
#line 3043
        *outrow = (png_byte )entry;
#line 3019
        outrow += stepx;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3045
      goto switch_break___0;
      case_2: /* CIL Label */
      {
#line 3048
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 3048
        if (! ((unsigned long )outrow < (unsigned long )end_row)) {
#line 3048
          goto while_break___2;
        }
#line 3050
        tmp___3 = inrow;
#line 3050
        inrow ++;
#line 3050
        gray___0 = *tmp___3;
#line 3051
        tmp___4 = inrow;
#line 3051
        inrow ++;
#line 3051
        alpha___0 = *tmp___4;
#line 3053
        if ((int )alpha___0 == 0) {
#line 3054
          *outrow = (png_byte )254;
        } else
#line 3056
        if ((int )gray___0 != 254) {
#line 3057
          *outrow = gray___0;
        } else {
#line 3060
          *outrow = (png_byte )255;
        }
#line 3048
        outrow += stepx;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 3062
      goto switch_break___0;
      case_3: /* CIL Label */
      {
#line 3065
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 3065
        if (! ((unsigned long )outrow < (unsigned long )end_row)) {
#line 3065
          goto while_break___3;
        }
#line 3067
        *outrow = (png_byte )(6 * (6 * (((int )*(inrow + 0) * 5 + 130) >> 8) + (((int )*(inrow + 1) * 5 + 130) >> 8)) + (((int )*(inrow + 2) * 5 + 130) >> 8));
#line 3068
        inrow += 3;
#line 3065
        outrow += stepx;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 3070
      goto switch_break___0;
      case_4: /* CIL Label */
      {
#line 3073
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 3073
        if (! ((unsigned long )outrow < (unsigned long )end_row)) {
#line 3073
          goto while_break___4;
        }
#line 3075
        alpha___1 = (unsigned int )*(inrow + 3);
#line 3082
        if (alpha___1 >= 196U) {
#line 3083
          *outrow = (png_byte )(6 * (6 * (((int )*(inrow + 0) * 5 + 130) >> 8) + (((int )*(inrow + 1) * 5 + 130) >> 8)) + (((int )*(inrow + 2) * 5 + 130) >> 8));
        } else
#line 3086
        if (alpha___1 < 64U) {
#line 3087
          *outrow = (png_byte )216;
        } else {
#line 3097
          back_i = 217U;
#line 3108
          if ((int )*(inrow + 0) & 0x80) {
#line 3108
            back_i += 9U;
          }
#line 3109
          if ((int )*(inrow + 0) & 0x40) {
#line 3109
            back_i += 9U;
          }
#line 3110
          if ((int )*(inrow + 0) & 0x80) {
#line 3110
            back_i += 3U;
          }
#line 3111
          if ((int )*(inrow + 0) & 0x40) {
#line 3111
            back_i += 3U;
          }
#line 3112
          if ((int )*(inrow + 0) & 0x80) {
#line 3112
            back_i ++;
          }
#line 3113
          if ((int )*(inrow + 0) & 0x40) {
#line 3113
            back_i ++;
          }
#line 3115
          *outrow = (png_byte )back_i;
        }
#line 3118
        inrow += 4;
#line 3073
        outrow += stepx;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 3120
      goto switch_break___0;
      switch_default___0: /* CIL Label */
#line 3123
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 3002
      y += stepy;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */
#line 2978
    pass ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3129
  return (1);
}
}
#line 3132 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
static int png_image_read_colormapped(png_voidp argument )
{
  png_image_read_control *display ;
  png_imagep image ;
  png_controlp control ;
  png_structrp png_ptr ;
  png_inforp info_ptr ;
  int passes ;
  png_voidp first_row ;
  ptrdiff_t row_bytes ;
  char *ptr ;
  int result ;
  png_voidp row ;
  size_t tmp ;
  png_voidp __attribute__((__malloc__))  tmp___0 ;
  png_alloc_size_t row_bytes___0 ;
  png_uint_32 y ;
  png_bytep row___0 ;

  {
#line 3135
  display = (png_image_read_control *)argument;
#line 3137
  image = display->image;
#line 3138
  control = image->opaque;
#line 3139
  png_ptr = (png_structrp )control->png_ptr;
#line 3140
  info_ptr = (png_inforp )control->info_ptr;
#line 3142
  passes = 0;
#line 3144
  png_image_skip_unused_chunks(png_ptr);
#line 3150
  if (display->colormap_processing == 0) {
#line 3151
    passes = png_set_interlace_handling(png_ptr);
  }
#line 3153
  png_read_update_info(png_ptr, info_ptr);
  {
#line 3158
  if (display->colormap_processing == 0) {
#line 3158
    goto case_0;
  }
#line 3170
  if (display->colormap_processing == 1) {
#line 3170
    goto case_1;
  }
#line 3170
  if (display->colormap_processing == 2) {
#line 3170
    goto case_1;
  }
#line 3183
  if (display->colormap_processing == 3) {
#line 3183
    goto case_3;
  }
#line 3193
  if (display->colormap_processing == 4) {
#line 3193
    goto case_4;
  }
#line 3203
  goto bad_output;
  case_0: /* CIL Label */
#line 3162
  if ((int )info_ptr->color_type == 3) {
#line 3162
    goto _L;
  } else
#line 3162
  if ((int )info_ptr->color_type == 0) {
    _L: /* CIL Label */
#line 3162
    if ((int )info_ptr->bit_depth == 8) {
#line 3165
      goto switch_break;
    }
  }
#line 3167
  goto bad_output;
  case_1: /* CIL Label */
  case_2: /* CIL Label */
#line 3175
  if ((int )info_ptr->color_type == 4) {
#line 3175
    if ((int )info_ptr->bit_depth == 8) {
#line 3175
      if (png_ptr->screen_gamma == 220000) {
#line 3175
        if (image->colormap_entries == 256U) {
#line 3179
          goto switch_break;
        }
      }
    }
  }
#line 3181
  goto bad_output;
  case_3: /* CIL Label */
#line 3185
  if ((int )info_ptr->color_type == 2) {
#line 3185
    if ((int )info_ptr->bit_depth == 8) {
#line 3185
      if (png_ptr->screen_gamma == 220000) {
#line 3185
        if (image->colormap_entries == 216U) {
#line 3189
          goto switch_break;
        }
      }
    }
  }
#line 3191
  goto bad_output;
  case_4: /* CIL Label */
#line 3195
  if ((int )info_ptr->color_type == 6) {
#line 3195
    if ((int )info_ptr->bit_depth == 8) {
#line 3195
      if (png_ptr->screen_gamma == 220000) {
#line 3195
        if (image->colormap_entries == 244U) {
#line 3199
          goto switch_break;
        }
      }
    }
  }
#line 3201
  goto bad_output;
  bad_output:
  switch_default: /* CIL Label */
#line 3205
  png_error((png_const_structrp )png_ptr, (png_const_charp )"bad color-map processing (internal error)");
  switch_break: /* CIL Label */ ;
  }
#line 3213
  first_row = display->buffer;
#line 3214
  row_bytes = (ptrdiff_t )display->row_stride;
#line 3219
  if (row_bytes < 0L) {
#line 3221
    ptr = (char *)first_row;
#line 3222
    ptr += (ptrdiff_t )(image->height - 1U) * - row_bytes;
#line 3223
    first_row = (png_voidp )ptr;
  }
#line 3226
  display->first_row = first_row;
#line 3227
  display->row_bytes = row_bytes;
#line 3230
  if (passes == 0) {
#line 3233
    tmp = png_get_rowbytes((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
#line 3233
    tmp___0 = png_malloc((png_const_structrp )png_ptr, tmp);
#line 3233
    row = (png_voidp )tmp___0;
#line 3235
    display->local_row = row;
#line 3236
    result = png_safe_execute(image, & png_image_read_and_map, (png_voidp )display);
#line 3237
    display->local_row = (void *)0;
#line 3238
    png_free((png_const_structrp )png_ptr, row);
#line 3240
    return (result);
  } else {
#line 3245
    row_bytes___0 = (png_alloc_size_t )display->row_bytes;
    {
#line 3247
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3247
      passes --;
#line 3247
      if (! (passes >= 0)) {
#line 3247
        goto while_break;
      }
#line 3249
      y = image->height;
#line 3250
      row___0 = (png_bytep )display->first_row;
      {
#line 3252
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3252
        if (! (y > 0U)) {
#line 3252
          goto while_break___0;
        }
#line 3254
        png_read_row(png_ptr, row___0, (png_bytep )((void *)0));
#line 3255
        row___0 += row_bytes___0;
#line 3252
        y --;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 3259
    return (1);
  }
}
}
#line 3264 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
static int png_image_read_composite(png_voidp argument )
{
  png_image_read_control *display ;
  png_imagep image ;
  png_structrp png_ptr ;
  int passes ;
  png_uint_32 height ;
  png_uint_32 width ;
  ptrdiff_t step_row ;
  unsigned int channels ;
  int tmp ;
  int pass ;
  unsigned int startx ;
  unsigned int stepx ;
  unsigned int stepy ;
  png_uint_32 y ;
  int tmp___0 ;
  int tmp___1 ;
  png_bytep inrow ;
  png_bytep outrow ;
  png_const_bytep end_row ;
  png_byte alpha ;
  unsigned int c ;
  png_uint_32 component ;

  {
#line 3267
  display = (png_image_read_control *)argument;
#line 3269
  image = display->image;
#line 3270
  png_ptr = (png_structrp )(image->opaque)->png_ptr;
  {
#line 3275
  if ((int )png_ptr->interlaced == 0) {
#line 3275
    goto case_0;
  }
#line 3279
  if ((int )png_ptr->interlaced == 1) {
#line 3279
    goto case_1;
  }
#line 3283
  goto switch_default;
  case_0: /* CIL Label */
#line 3276
  passes = 1;
#line 3277
  goto switch_break;
  case_1: /* CIL Label */
#line 3280
  passes = 7;
#line 3281
  goto switch_break;
  switch_default: /* CIL Label */
#line 3284
  png_error((png_const_structrp )png_ptr, (png_const_charp )"unknown interlace type");
  switch_break: /* CIL Label */ ;
  }
#line 3288
  height = image->height;
#line 3289
  width = image->width;
#line 3290
  step_row = display->row_bytes;
#line 3291
  if ((image->format & 0x02U) != 0U) {
#line 3291
    tmp = 3;
  } else {
#line 3291
    tmp = 1;
  }
#line 3291
  channels = (unsigned int )tmp;
#line 3295
  pass = 0;
  {
#line 3295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3295
    if (! (pass < passes)) {
#line 3295
      goto while_break;
    }
#line 3300
    if ((int )png_ptr->interlaced == 1) {
#line 3303
      if (pass > 1) {
#line 3303
        tmp___0 = (7 - pass) >> 1;
      } else {
#line 3303
        tmp___0 = 3;
      }
#line 3303
      if (pass > 1) {
#line 3303
        tmp___1 = (7 - pass) >> 1;
      } else {
#line 3303
        tmp___1 = 3;
      }
#line 3303
      if ((width + (png_uint_32 )(((1 << tmp___0) - 1) - (((1 & pass) << (3 - ((pass + 1) >> 1))) & 7))) >> tmp___1 == 0U) {
#line 3304
        goto __Cont;
      }
#line 3306
      startx = (unsigned int )(((1 & pass) << (3 - ((pass + 1) >> 1))) & 7) * channels;
#line 3307
      stepx = (unsigned int )(1 << ((7 - pass) >> 1)) * channels;
#line 3308
      y = (png_uint_32 )(((1 & ~ pass) << (3 - (pass >> 1))) & 7);
#line 3309
      if (pass > 2) {
#line 3309
        stepy = (unsigned int )(8 >> ((pass - 1) >> 1));
      } else {
#line 3309
        stepy = 8U;
      }
    } else {
#line 3314
      y = (png_uint_32 )0;
#line 3315
      startx = 0U;
#line 3316
      stepx = channels;
#line 3317
      stepy = 1U;
    }
    {
#line 3320
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3320
      if (! (y < height)) {
#line 3320
        goto while_break___0;
      }
#line 3322
      inrow = (png_bytep )display->local_row;
#line 3327
      png_read_row(png_ptr, inrow, (png_bytep )((void *)0));
#line 3329
      outrow = (png_bytep )display->first_row;
#line 3330
      outrow += (ptrdiff_t )y * step_row;
#line 3331
      end_row = (png_const_bytep )(outrow + width * channels);
#line 3334
      outrow += startx;
      {
#line 3335
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3335
        if (! ((unsigned long )outrow < (unsigned long )end_row)) {
#line 3335
          goto while_break___1;
        }
#line 3337
        alpha = *(inrow + channels);
#line 3339
        if ((int )alpha > 0) {
#line 3343
          c = 0U;
          {
#line 3343
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 3343
            if (! (c < channels)) {
#line 3343
              goto while_break___2;
            }
#line 3345
            component = (png_uint_32 )*(inrow + c);
#line 3347
            if ((int )alpha < 255) {
#line 3355
              component *= 65535U;
#line 3356
              component += (png_uint_32 )((255 - (int )alpha) * (int )png_sRGB_table[*(outrow + c)]);
#line 3362
              component = (png_uint_32 )((png_byte )(255U & (((unsigned int )png_sRGB_base[component >> 15] + ((component & 32767U) * (unsigned int )png_sRGB_delta[component >> 15] >> 12)) >> 8)));
            }
#line 3365
            *(outrow + c) = (png_byte )component;
#line 3343
            c ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 3369
        inrow += channels + 1U;
#line 3335
        outrow += stepx;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3320
      y += stepy;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */
#line 3295
    pass ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3375
  return (1);
}
}
#line 3391 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
static int png_image_read_background(png_voidp argument )
{
  png_image_read_control *display ;
  png_imagep image ;
  png_structrp png_ptr ;
  png_inforp info_ptr ;
  png_uint_32 height ;
  png_uint_32 width ;
  int pass ;
  int passes ;
  png_byte tmp ;
  png_bytep first_row ;
  ptrdiff_t step_row ;
  unsigned int startx ;
  unsigned int stepx ;
  unsigned int stepy ;
  png_uint_32 y ;
  int tmp___0 ;
  int tmp___1 ;
  png_bytep inrow ;
  png_bytep outrow ;
  png_const_bytep end_row ;
  png_byte alpha ;
  png_uint_32 component ;
  png_byte background8 ;
  png_uint_16 background ;
  png_bytep inrow___0 ;
  png_bytep outrow___0 ;
  png_const_bytep end_row___0 ;
  png_byte alpha___0 ;
  png_uint_32 component___0 ;
  png_uint_16p first_row___0 ;
  ptrdiff_t step_row___0 ;
  unsigned int preserve_alpha ;
  unsigned int outchannels ;
  int swap_alpha ;
  unsigned int startx___0 ;
  unsigned int stepx___0 ;
  unsigned int stepy___0 ;
  png_uint_32 y___0 ;
  int tmp___2 ;
  int tmp___3 ;
  png_const_uint_16p inrow___1 ;
  png_uint_16p outrow___1 ;
  png_uint_16p end_row___1 ;
  png_uint_32 component___1 ;
  png_uint_16 alpha___1 ;

  {
#line 3394
  display = (png_image_read_control *)argument;
#line 3396
  image = display->image;
#line 3397
  png_ptr = (png_structrp )(image->opaque)->png_ptr;
#line 3398
  info_ptr = (png_inforp )(image->opaque)->info_ptr;
#line 3399
  height = image->height;
#line 3400
  width = image->width;
#line 3408
  if ((png_ptr->transformations & 0x600000U) == 0U) {
#line 3409
    png_error((png_const_structrp )png_ptr, (png_const_charp )"lost rgb to gray");
  }
#line 3411
  if ((png_ptr->transformations & 0x0080U) != 0U) {
#line 3412
    png_error((png_const_structrp )png_ptr, (png_const_charp )"unexpected compose");
  }
#line 3414
  tmp = png_get_channels((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
#line 3414
  if ((int )tmp != 2) {
#line 3415
    png_error((png_const_structrp )png_ptr, (png_const_charp )"lost/gained channels");
  }
#line 3418
  if ((image->format & 0x04U) == 0U) {
#line 3418
    if ((image->format & 0x01U) != 0U) {
#line 3420
      png_error((png_const_structrp )png_ptr, (png_const_charp )"unexpected 8-bit transformation");
    }
  }
  {
#line 3424
  if ((int )png_ptr->interlaced == 0) {
#line 3424
    goto case_0;
  }
#line 3428
  if ((int )png_ptr->interlaced == 1) {
#line 3428
    goto case_1;
  }
#line 3432
  goto switch_default;
  case_0: /* CIL Label */
#line 3425
  passes = 1;
#line 3426
  goto switch_break;
  case_1: /* CIL Label */
#line 3429
  passes = 7;
#line 3430
  goto switch_break;
  switch_default: /* CIL Label */
#line 3433
  png_error((png_const_structrp )png_ptr, (png_const_charp )"unknown interlace type");
  switch_break: /* CIL Label */ ;
  }
  {
#line 3443
  if ((int )info_ptr->bit_depth == 8) {
#line 3443
    goto case_8;
  }
#line 3565
  if ((int )info_ptr->bit_depth == 16) {
#line 3565
    goto case_16;
  }
#line 3659
  goto switch_default___0;
  case_8: /* CIL Label */
#line 3450
  first_row = (png_bytep )display->first_row;
#line 3451
  step_row = display->row_bytes;
#line 3453
  pass = 0;
  {
#line 3453
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3453
    if (! (pass < passes)) {
#line 3453
      goto while_break;
    }
#line 3458
    if ((int )png_ptr->interlaced == 1) {
#line 3461
      if (pass > 1) {
#line 3461
        tmp___0 = (7 - pass) >> 1;
      } else {
#line 3461
        tmp___0 = 3;
      }
#line 3461
      if (pass > 1) {
#line 3461
        tmp___1 = (7 - pass) >> 1;
      } else {
#line 3461
        tmp___1 = 3;
      }
#line 3461
      if ((width + (png_uint_32 )(((1 << tmp___0) - 1) - (((1 & pass) << (3 - ((pass + 1) >> 1))) & 7))) >> tmp___1 == 0U) {
#line 3462
        goto __Cont;
      }
#line 3464
      startx = (unsigned int )(((1 & pass) << (3 - ((pass + 1) >> 1))) & 7);
#line 3465
      stepx = (unsigned int )(1 << ((7 - pass) >> 1));
#line 3466
      y = (png_uint_32 )(((1 & ~ pass) << (3 - (pass >> 1))) & 7);
#line 3467
      if (pass > 2) {
#line 3467
        stepy = (unsigned int )(8 >> ((pass - 1) >> 1));
      } else {
#line 3467
        stepy = 8U;
      }
    } else {
#line 3472
      y = (png_uint_32 )0;
#line 3473
      startx = 0U;
#line 3474
      stepy = 1U;
#line 3474
      stepx = stepy;
    }
#line 3477
    if ((unsigned long )display->background == (unsigned long )((void *)0)) {
      {
#line 3479
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3479
        if (! (y < height)) {
#line 3479
          goto while_break___0;
        }
#line 3481
        inrow = (png_bytep )display->local_row;
#line 3483
        outrow = first_row + (ptrdiff_t )y * step_row;
#line 3484
        end_row = (png_const_bytep )(outrow + width);
#line 3487
        png_read_row(png_ptr, inrow, (png_bytep )((void *)0));
#line 3490
        outrow += startx;
        {
#line 3491
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 3491
          if (! ((unsigned long )outrow < (unsigned long )end_row)) {
#line 3491
            goto while_break___1;
          }
#line 3493
          alpha = *(inrow + 1);
#line 3495
          if ((int )alpha > 0) {
#line 3497
            component = (png_uint_32 )*(inrow + 0);
#line 3499
            if ((int )alpha < 255) {
#line 3505
              component = (png_uint_32 )((int const   )png_sRGB_table[component] * (int const   )alpha);
#line 3506
              component += (png_uint_32 )((int const   )png_sRGB_table[*(outrow + 0)] * (int const   )(255 - (int )alpha));
#line 3508
              component = (png_uint_32 )((png_byte )(255U & (((unsigned int )png_sRGB_base[component >> 15] + ((component & 32767U) * (unsigned int )png_sRGB_delta[component >> 15] >> 12)) >> 8)));
            }
#line 3511
            *(outrow + 0) = (png_byte )component;
          }
#line 3514
          inrow += 2;
#line 3491
          outrow += stepx;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 3479
        y += stepy;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 3521
      background8 = (png_byte )(display->background)->green;
#line 3522
      background = (png_uint_16 )png_sRGB_table[background8];
      {
#line 3524
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 3524
        if (! (y < height)) {
#line 3524
          goto while_break___2;
        }
#line 3526
        inrow___0 = (png_bytep )display->local_row;
#line 3528
        outrow___0 = first_row + (ptrdiff_t )y * step_row;
#line 3529
        end_row___0 = (png_const_bytep )(outrow___0 + width);
#line 3532
        png_read_row(png_ptr, inrow___0, (png_bytep )((void *)0));
#line 3535
        outrow___0 += startx;
        {
#line 3536
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 3536
          if (! ((unsigned long )outrow___0 < (unsigned long )end_row___0)) {
#line 3536
            goto while_break___3;
          }
#line 3538
          alpha___0 = *(inrow___0 + 1);
#line 3540
          if ((int )alpha___0 > 0) {
#line 3542
            component___0 = (png_uint_32 )*(inrow___0 + 0);
#line 3544
            if ((int )alpha___0 < 255) {
#line 3546
              component___0 = (png_uint_32 )((int const   )png_sRGB_table[component___0] * (int const   )alpha___0);
#line 3547
              component___0 += (png_uint_32 )((int )background * (255 - (int )alpha___0));
#line 3548
              component___0 = (png_uint_32 )((png_byte )(255U & (((unsigned int )png_sRGB_base[component___0 >> 15] + ((component___0 & 32767U) * (unsigned int )png_sRGB_delta[component___0 >> 15] >> 12)) >> 8)));
            }
#line 3551
            *(outrow___0 + 0) = (png_byte )component___0;
          } else {
#line 3555
            *(outrow___0 + 0) = background8;
          }
#line 3557
          inrow___0 += 2;
#line 3536
          outrow___0 += stepx;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 3524
        y += stepy;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */
#line 3453
    pass ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3563
  goto switch_break___0;
  case_16: /* CIL Label */
#line 3571
  first_row___0 = (png_uint_16p )display->first_row;
#line 3576
  step_row___0 = display->row_bytes / 2L;
#line 3577
  preserve_alpha = (unsigned int )((image->format & 0x01U) != 0U);
#line 3579
  outchannels = 1U + preserve_alpha;
#line 3580
  swap_alpha = 0;
#line 3583
  if (preserve_alpha != 0U) {
#line 3583
    if ((image->format & 0x20U) != 0U) {
#line 3585
      swap_alpha = 1;
    }
  }
#line 3588
  pass = 0;
  {
#line 3588
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 3588
    if (! (pass < passes)) {
#line 3588
      goto while_break___4;
    }
#line 3595
    if ((int )png_ptr->interlaced == 1) {
#line 3598
      if (pass > 1) {
#line 3598
        tmp___2 = (7 - pass) >> 1;
      } else {
#line 3598
        tmp___2 = 3;
      }
#line 3598
      if (pass > 1) {
#line 3598
        tmp___3 = (7 - pass) >> 1;
      } else {
#line 3598
        tmp___3 = 3;
      }
#line 3598
      if ((width + (png_uint_32 )(((1 << tmp___2) - 1) - (((1 & pass) << (3 - ((pass + 1) >> 1))) & 7))) >> tmp___3 == 0U) {
#line 3599
        goto __Cont___0;
      }
#line 3601
      startx___0 = (unsigned int )(((1 & pass) << (3 - ((pass + 1) >> 1))) & 7) * outchannels;
#line 3602
      stepx___0 = (unsigned int )(1 << ((7 - pass) >> 1)) * outchannels;
#line 3603
      y___0 = (png_uint_32 )(((1 & ~ pass) << (3 - (pass >> 1))) & 7);
#line 3604
      if (pass > 2) {
#line 3604
        stepy___0 = (unsigned int )(8 >> ((pass - 1) >> 1));
      } else {
#line 3604
        stepy___0 = 8U;
      }
    } else {
#line 3609
      y___0 = (png_uint_32 )0;
#line 3610
      startx___0 = 0U;
#line 3611
      stepx___0 = outchannels;
#line 3612
      stepy___0 = 1U;
    }
    {
#line 3615
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 3615
      if (! (y___0 < height)) {
#line 3615
        goto while_break___5;
      }
#line 3618
      outrow___1 = first_row___0 + (ptrdiff_t )y___0 * step_row___0;
#line 3619
      end_row___1 = outrow___1 + width * outchannels;
#line 3622
      png_read_row(png_ptr, (png_bytep )display->local_row, (png_bytep )((void *)0));
#line 3624
      inrow___1 = (png_const_uint_16p )display->local_row;
#line 3628
      outrow___1 += startx___0;
      {
#line 3629
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 3629
        if (! ((unsigned long )outrow___1 < (unsigned long )end_row___1)) {
#line 3629
          goto while_break___6;
        }
#line 3631
        component___1 = (png_uint_32 )*(inrow___1 + 0);
#line 3632
        alpha___1 = (png_uint_16 )*(inrow___1 + 1);
#line 3634
        if ((int )alpha___1 > 0) {
#line 3636
          if ((int )alpha___1 < 65535) {
#line 3638
            component___1 *= (png_uint_32 )alpha___1;
#line 3639
            component___1 += 32767U;
#line 3640
            component___1 /= 65535U;
          }
        } else {
#line 3645
          component___1 = (png_uint_32 )0;
        }
#line 3647
        *(outrow___1 + swap_alpha) = (png_uint_16 )component___1;
#line 3648
        if (preserve_alpha != 0U) {
#line 3649
          *(outrow___1 + (1 ^ swap_alpha)) = alpha___1;
        }
#line 3651
        inrow___1 += 2;
#line 3629
        outrow___1 += stepx___0;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 3615
      y___0 += stepy___0;
    }
    while_break___5: /* CIL Label */ ;
    }
    __Cont___0: /* CIL Label */
#line 3588
    pass ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 3656
  goto switch_break___0;
  switch_default___0: /* CIL Label */
#line 3660
  png_error((png_const_structrp )png_ptr, (png_const_charp )"unexpected bit depth");
  switch_break___0: /* CIL Label */ ;
  }
#line 3664
  return (1);
}
}
#line 3668 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
static int png_image_read_direct(png_voidp argument )
{
  png_image_read_control *display ;
  png_imagep image ;
  png_structrp png_ptr ;
  png_inforp info_ptr ;
  png_uint_32 format ;
  int linear ;
  int do_local_compose ;
  int do_local_background ;
  int passes ;
  png_uint_32 base_format ;
  png_uint_32 tmp ;
  png_uint_32 change ;
  png_fixed_point output_gamma ;
  int mode ;
  png_fixed_point input_gamma_default ;
  png_fixed_point gtest ;
  int tmp___0 ;
  int tmp___1 ;
  png_color_16 c ;
  png_uint_32 filler ;
  int where ;
  png_uint_16 le ;
  png_uint_32 info_format ;
  png_voidp first_row ;
  ptrdiff_t row_bytes ;
  char *ptr ;
  int result ;
  png_voidp row ;
  size_t tmp___2 ;
  png_voidp __attribute__((__malloc__))  tmp___3 ;
  int result___0 ;
  png_voidp row___0 ;
  size_t tmp___4 ;
  png_voidp __attribute__((__malloc__))  tmp___5 ;
  png_alloc_size_t row_bytes___0 ;
  png_uint_32 y ;
  png_bytep row___1 ;

  {
#line 3671
  display = (png_image_read_control *)argument;
#line 3673
  image = display->image;
#line 3674
  png_ptr = (png_structrp )(image->opaque)->png_ptr;
#line 3675
  info_ptr = (png_inforp )(image->opaque)->info_ptr;
#line 3677
  format = image->format;
#line 3678
  linear = (format & 0x04U) != 0U;
#line 3679
  do_local_compose = 0;
#line 3680
  do_local_background = 0;
#line 3681
  passes = 0;
#line 3687
  png_set_expand(png_ptr);
#line 3691
  tmp = png_image_format(png_ptr);
#line 3691
  base_format = tmp & 4294967287U;
#line 3693
  change = format ^ base_format;
#line 3698
  if ((change & 0x02U) != 0U) {
#line 3701
    if ((format & 0x02U) != 0U) {
#line 3702
      png_set_gray_to_rgb(png_ptr);
    } else {
#line 3719
      if ((base_format & 0x01U) != 0U) {
#line 3720
        do_local_background = 1;
      }
#line 3722
      png_set_rgb_to_gray_fixed(png_ptr, 1, -1, -1);
    }
#line 3726
    change &= 4294967293U;
  }
#line 3734
  if ((base_format & 0x04U) != 0U) {
#line 3734
    if ((image->flags & 4U) == 0U) {
#line 3736
      input_gamma_default = 100000;
    } else {
#line 3738
      input_gamma_default = -1;
    }
  } else {
#line 3738
    input_gamma_default = -1;
  }
#line 3743
  png_set_alpha_mode_fixed(png_ptr, 0, input_gamma_default);
#line 3746
  if (linear != 0) {
#line 3751
    if ((base_format & 0x01U) != 0U) {
#line 3752
      mode = 1;
    } else {
#line 3755
      mode = 0;
    }
#line 3757
    output_gamma = 100000;
  } else {
#line 3762
    mode = 0;
#line 3763
    output_gamma = -1;
  }
#line 3766
  if ((change & 0x40U) != 0U) {
#line 3768
    mode = 2;
#line 3769
    change &= 4294967231U;
  }
#line 3778
  if (do_local_background != 0) {
#line 3787
    tmp___0 = png_muldiv(& gtest, output_gamma, png_ptr->colorspace.gamma, 100000);
#line 3787
    if (tmp___0 != 0) {
#line 3787
      tmp___1 = png_gamma_significant(gtest);
#line 3787
      if (tmp___1 == 0) {
#line 3789
        do_local_background = 0;
      } else {
#line 3787
        goto _L;
      }
    } else
    _L: /* CIL Label */
#line 3791
    if (mode == 1) {
#line 3793
      do_local_background = 2;
#line 3794
      mode = 0;
    }
  }
#line 3801
  if ((change & 0x04U) != 0U) {
#line 3803
    if (linear != 0) {
#line 3804
      png_set_expand_16(png_ptr);
    } else {
#line 3807
      png_set_scale_16(png_ptr);
    }
#line 3809
    change &= 4294967291U;
  }
#line 3813
  if ((change & 0x01U) != 0U) {
#line 3819
    if ((base_format & 0x01U) != 0U) {
#line 3826
      if (do_local_background != 0) {
#line 3827
        do_local_background = 2;
      } else
#line 3830
      if (linear != 0) {
#line 3831
        png_set_strip_alpha(png_ptr);
      } else
#line 3834
      if ((unsigned long )display->background != (unsigned long )((void *)0)) {
#line 3838
        c.index = (png_byte )0;
#line 3839
        c.red = (png_uint_16 )(display->background)->red;
#line 3840
        c.green = (png_uint_16 )(display->background)->green;
#line 3841
        c.blue = (png_uint_16 )(display->background)->blue;
#line 3842
        c.gray = (png_uint_16 )(display->background)->green;
#line 3850
        png_set_background_fixed(png_ptr, (png_const_color_16p )(& c), 1, 0, 0);
      } else {
#line 3857
        do_local_compose = 1;
#line 3863
        mode = 2;
      }
    } else {
#line 3877
      if (linear != 0) {
#line 3878
        filler = (png_uint_32 )65535;
      } else {
#line 3881
        filler = (png_uint_32 )255;
      }
#line 3884
      if ((format & 0x20U) != 0U) {
#line 3886
        where = 0;
#line 3887
        change &= 4294967263U;
      } else {
#line 3892
        where = 1;
      }
#line 3894
      png_set_add_alpha(png_ptr, filler, where);
    }
#line 3898
    change &= 4294967294U;
  }
#line 3905
  png_set_alpha_mode_fixed(png_ptr, mode, output_gamma);
#line 3908
  if ((change & 0x10U) != 0U) {
#line 3913
    if ((format & 0x02U) != 0U) {
#line 3914
      png_set_bgr(png_ptr);
    } else {
#line 3917
      format &= 4294967279U;
    }
#line 3919
    change &= 4294967279U;
  }
#line 3924
  if ((change & 0x20U) != 0U) {
#line 3931
    if ((format & 0x01U) != 0U) {
#line 3936
      if (do_local_background != 2) {
#line 3937
        png_set_swap_alpha(png_ptr);
      }
    } else {
#line 3941
      format &= 4294967263U;
    }
#line 3943
    change &= 4294967263U;
  }
#line 3950
  if (linear != 0) {
#line 3952
    le = (png_uint_16 )0x0001;
#line 3954
    if ((int const   )*((png_const_bytep )(& le)) != 0) {
#line 3955
      png_set_swap(png_ptr);
    }
  }
#line 3959
  if (change != 0U) {
#line 3960
    png_error((png_const_structrp )png_ptr, (png_const_charp )"png_read_image: unsupported transformation");
  }
#line 3963
  png_image_skip_unused_chunks(png_ptr);
#line 3971
  if (do_local_compose == 0) {
#line 3971
    if (do_local_background != 2) {
#line 3972
      passes = png_set_interlace_handling(png_ptr);
    }
  }
#line 3974
  png_read_update_info(png_ptr, info_ptr);
#line 3977
  info_format = (png_uint_32 )0;
#line 3979
  if (((int )info_ptr->color_type & 2) != 0) {
#line 3980
    info_format |= 0x02U;
  }
#line 3982
  if (((int )info_ptr->color_type & 4) != 0) {
#line 3985
    if (do_local_compose == 0) {
#line 3988
      if (do_local_background != 2) {
#line 3990
        info_format |= 0x01U;
      } else
#line 3988
      if ((format & 0x01U) != 0U) {
#line 3990
        info_format |= 0x01U;
      }
    }
  } else
#line 3994
  if (do_local_compose != 0) {
#line 3995
    png_error((png_const_structrp )png_ptr, (png_const_charp )"png_image_read: alpha channel lost");
  }
#line 3997
  if ((format & 0x40U) != 0U) {
#line 3998
    info_format |= 0x40U;
  }
#line 4001
  if ((int )info_ptr->bit_depth == 16) {
#line 4002
    info_format |= 0x04U;
  }
#line 4005
  if ((png_ptr->transformations & 0x0001U) != 0U) {
#line 4006
    info_format |= 0x10U;
  }
#line 4010
  if (do_local_background == 2) {
#line 4012
    if ((format & 0x20U) != 0U) {
#line 4013
      info_format |= 0x20U;
    }
  }
#line 4016
  if ((png_ptr->transformations & 0x20000U) != 0U) {
#line 4016
    goto _L___0;
  } else
#line 4016
  if ((png_ptr->transformations & 0x1000000U) != 0U) {
#line 4016
    if ((png_ptr->flags & 0x0080U) == 0U) {
      _L___0: /* CIL Label */
#line 4020
      if (do_local_background == 2) {
#line 4021
        png_error((png_const_structrp )png_ptr, (png_const_charp )"unexpected alpha swap transformation");
      }
#line 4023
      info_format |= 0x20U;
    }
  }
#line 4028
  if (info_format != format) {
#line 4029
    png_error((png_const_structrp )png_ptr, (png_const_charp )"png_read_image: invalid transformations");
  }
#line 4038
  first_row = display->buffer;
#line 4039
  row_bytes = (ptrdiff_t )display->row_stride;
#line 4041
  if (linear != 0) {
#line 4042
    row_bytes *= 2L;
  }
#line 4047
  if (row_bytes < 0L) {
#line 4049
    ptr = (char *)first_row;
#line 4050
    ptr += (ptrdiff_t )(image->height - 1U) * - row_bytes;
#line 4051
    first_row = (png_voidp )ptr;
  }
#line 4054
  display->first_row = first_row;
#line 4055
  display->row_bytes = row_bytes;
#line 4058
  if (do_local_compose != 0) {
#line 4061
    tmp___2 = png_get_rowbytes((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
#line 4061
    tmp___3 = png_malloc((png_const_structrp )png_ptr, tmp___2);
#line 4061
    row = (png_voidp )tmp___3;
#line 4063
    display->local_row = row;
#line 4064
    result = png_safe_execute(image, & png_image_read_composite, (png_voidp )display);
#line 4065
    display->local_row = (void *)0;
#line 4066
    png_free((png_const_structrp )png_ptr, row);
#line 4068
    return (result);
  } else
#line 4071
  if (do_local_background == 2) {
#line 4074
    tmp___4 = png_get_rowbytes((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
#line 4074
    tmp___5 = png_malloc((png_const_structrp )png_ptr, tmp___4);
#line 4074
    row___0 = (png_voidp )tmp___5;
#line 4076
    display->local_row = row___0;
#line 4077
    result___0 = png_safe_execute(image, & png_image_read_background, (png_voidp )display);
#line 4078
    display->local_row = (void *)0;
#line 4079
    png_free((png_const_structrp )png_ptr, row___0);
#line 4081
    return (result___0);
  } else {
#line 4086
    row_bytes___0 = (png_alloc_size_t )display->row_bytes;
    {
#line 4088
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4088
      passes --;
#line 4088
      if (! (passes >= 0)) {
#line 4088
        goto while_break;
      }
#line 4090
      y = image->height;
#line 4091
      row___1 = (png_bytep )display->first_row;
      {
#line 4093
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 4093
        if (! (y > 0U)) {
#line 4093
          goto while_break___0;
        }
#line 4095
        png_read_row(png_ptr, row___1, (png_bytep )((void *)0));
#line 4096
        row___1 += row_bytes___0;
#line 4093
        y --;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 4100
    return (1);
  }
}
}
#line 4104 "/home/goblint2/bench/libpng-1.6.39/pngread.c"
int png_image_finish_read(png_imagep image , png_const_colorp background , void *buffer___0 ,
                          png_int_32 row_stride , void *colormap )
{
  unsigned int channels ;
  unsigned int tmp ;
  png_uint_32 check___0 ;
  png_uint_32 png_row_stride ;
  int result ;
  png_image_read_control display ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 4108
  if ((unsigned long )image != (unsigned long )((void *)0)) {
#line 4108
    if (image->version == 1U) {
#line 4114
      if (image->format & 0x08U) {
#line 4114
        tmp = 1U;
      } else {
#line 4114
        tmp = (image->format & 3U) + 1U;
      }
#line 4114
      channels = tmp;
#line 4122
      if (image->width <= 0x7fffffffU / channels) {
#line 4125
        png_row_stride = image->width * channels;
#line 4127
        if (row_stride == 0) {
#line 4128
          row_stride = (png_int_32 )png_row_stride;
        }
#line 4130
        if (row_stride < 0) {
#line 4131
          check___0 = (png_uint_32 )(- row_stride);
        } else {
#line 4134
          check___0 = (png_uint_32 )row_stride;
        }
#line 4140
        if ((unsigned long )image->opaque != (unsigned long )((void *)0)) {
#line 4140
          if ((unsigned long )buffer___0 != (unsigned long )((void *)0)) {
#line 4140
            if (check___0 >= png_row_stride) {
#line 4158
              if (image->format & 0x08U) {
#line 4158
                tmp___5 = 1U;
              } else {
#line 4158
                tmp___5 = ((image->format & 0x04U) >> 2) + 1U;
              }
#line 4158
              if (image->height <= (0xffffffffU / tmp___5) / check___0) {
#line 4161
                if ((image->format & 0x08U) == 0U) {
#line 4161
                  goto _L;
                } else
#line 4161
                if (image->colormap_entries > 0U) {
#line 4161
                  if ((unsigned long )colormap != (unsigned long )((void *)0)) {
                    _L: /* CIL Label */
#line 4167
                    memset((void *)(& display), 0, sizeof(display));
#line 4168
                    display.image = image;
#line 4169
                    display.buffer = buffer___0;
#line 4170
                    display.row_stride = row_stride;
#line 4171
                    display.colormap = colormap;
#line 4172
                    display.background = background;
#line 4173
                    display.local_row = (void *)0;
#line 4178
                    if ((image->format & 0x08U) != 0U) {
#line 4179
                      tmp___0 = png_safe_execute(image, & png_image_read_colormap,
                                                 (png_voidp )(& display));
#line 4179
                      if (tmp___0) {
#line 4179
                        tmp___1 = png_safe_execute(image, & png_image_read_colormapped,
                                                   (png_voidp )(& display));
#line 4179
                        if (tmp___1) {
#line 4179
                          tmp___2 = 1;
                        } else {
#line 4179
                          tmp___2 = 0;
                        }
                      } else {
#line 4179
                        tmp___2 = 0;
                      }
#line 4179
                      result = tmp___2;
                    } else {
#line 4186
                      result = png_safe_execute(image, & png_image_read_direct, (png_voidp )(& display));
                    }
#line 4190
                    png_image_free(image);
#line 4191
                    return (result);
                  } else {
#line 4195
                    tmp___3 = png_image_error(image, (png_const_charp )"png_image_finish_read[color-map]: no color-map");
#line 4195
                    return (tmp___3);
                  }
                } else {
#line 4195
                  tmp___3 = png_image_error(image, (png_const_charp )"png_image_finish_read[color-map]: no color-map");
#line 4195
                  return (tmp___3);
                }
              } else {
#line 4200
                tmp___4 = png_image_error(image, (png_const_charp )"png_image_finish_read: image too large");
#line 4200
                return (tmp___4);
              }
            } else {
#line 4205
              tmp___6 = png_image_error(image, (png_const_charp )"png_image_finish_read: invalid argument");
#line 4205
              return (tmp___6);
            }
          } else {
#line 4205
            tmp___6 = png_image_error(image, (png_const_charp )"png_image_finish_read: invalid argument");
#line 4205
            return (tmp___6);
          }
        } else {
#line 4205
          tmp___6 = png_image_error(image, (png_const_charp )"png_image_finish_read: invalid argument");
#line 4205
          return (tmp___6);
        }
      } else {
#line 4210
        tmp___7 = png_image_error(image, (png_const_charp )"png_image_finish_read: row_stride too large");
#line 4210
        return (tmp___7);
      }
    } else {
#line 4108
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */
#line 4214
  if ((unsigned long )image != (unsigned long )((void *)0)) {
#line 4215
    tmp___8 = png_image_error(image, (png_const_charp )"png_image_finish_read: damaged PNG_IMAGE_VERSION");
#line 4215
    return (tmp___8);
  }
#line 4218
  return (0);
}
}
#line 101 "/usr/include/stdlib.h"
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 104
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 107
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 112
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__leaf__, __gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__,
__nothrow__)) ;
#line 820
__inline extern void *( __attribute__((__warn_unused_result__, __nonnull__(1,2,5),
__gnu_inline__)) bsearch)(void const   *__key , void const   *__base , size_t __nmemb ,
                          size_t __size , int (*__compar)(void const   * , void const   * ) ) ;
#line 929
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar )  __attribute__((__nothrow__)) ;
#line 933
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t *__dst , char const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 936
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) wcstombs)(char *__dst , wchar_t const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 43 "/usr/include/string.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memcpy)(void *__dest , void const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 47
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 61
__inline extern void *( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) memset)(void *__dest , int __ch , size_t __len )  __attribute__((__nothrow__)) ;
#line 122
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcpy)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 125
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncpy)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 130
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcat)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 133
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncat)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 326 "/usr/include/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) fprintf)(FILE *__stream ,
                                                                                                  char const   *__fmt
                                                                                                  , ...) ;
#line 332
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) printf)(char const   *__fmt
                                                                                                 , ...) ;
#line 334
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) sprintf)(char *__s ,
                                                                                                            char const   *__fmt
                                                                                                            , ...)  __attribute__((__nothrow__)) ;
#line 341
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vfprintf)(FILE *__stream ,
                                                                                                   char const   *__fmt ,
                                                                                                   __gnuc_va_list __ap ) ;
#line 347
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vprintf)(char const   *__fmt ,
                                                                                                  __gnuc_va_list __ap ) ;
#line 349
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vsprintf)(char *__s ,
                                                                                                             char const   *__fmt ,
                                                                                                             __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 354
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) snprintf)(char *__s , size_t __n , char const   *__fmt
                                              , ...)  __attribute__((__nothrow__)) ;
#line 358
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) vsnprintf)(char *__s , size_t __n , char const   *__fmt ,
                                               __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 492
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
#line 528
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
#line 564
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fgets)(char *__s , int __n , FILE *__stream ) ;
#line 646
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fread)(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 360 "/usr/include/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) read)(int __fd , void *__buf , size_t __nbytes ) ;
#line 511
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size )  __attribute__((__nothrow__)) ;
#line 689
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list )  __attribute__((__nothrow__)) ;
#line 774
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                               size_t __buflen )  __attribute__((__nothrow__)) ;
#line 31 "/home/goblint2/bench/libpng-1.6.39/pngrio.c"
void png_read_data(png_structrp png_ptr , png_bytep data , size_t length )
{


  {
#line 36
  if ((unsigned long )png_ptr->read_data_fn != (unsigned long )((void *)0)) {
#line 37
    (*(png_ptr->read_data_fn))((png_structp )png_ptr, data, length);
  } else {
#line 40
    png_error((png_const_structrp )png_ptr, (png_const_charp )"Call to NULL read function");
  }
#line 41
  return;
}
}
#line 49 "/home/goblint2/bench/libpng-1.6.39/pngrio.c"
void png_default_read_data(png_structp png_ptr , png_bytep data , size_t length )
{
  size_t check___0 ;

  {
#line 54
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 55
    return;
  }
#line 60
  check___0 = fread((void *)data, (size_t )1, length, (FILE *)png_ptr->io_ptr);
#line 62
  if (check___0 != length) {
#line 63
    png_error((png_const_structrp )png_ptr, (png_const_charp )"Read Error");
  }
#line 64
  return;
}
}
#line 86 "/home/goblint2/bench/libpng-1.6.39/pngrio.c"
void png_set_read_fn(png_structrp png_ptr , png_voidp io_ptr , void (*read_data_fn)(png_structp  ,
                                                                                    png_bytep  ,
                                                                                    size_t  ) )
{


  {
#line 90
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 91
    return;
  }
#line 93
  png_ptr->io_ptr = io_ptr;
#line 96
  if ((unsigned long )read_data_fn != (unsigned long )((void *)0)) {
#line 97
    png_ptr->read_data_fn = read_data_fn;
  } else {
#line 100
    png_ptr->read_data_fn = & png_default_read_data;
  }
#line 107
  if ((unsigned long )png_ptr->write_data_fn != (unsigned long )((void *)0)) {
#line 109
    png_ptr->write_data_fn = (void (*)(png_structp  , png_bytep  , size_t  ))((void *)0);
#line 110
    png_warning((png_const_structrp )png_ptr, (png_const_charp )"Can\'t set both read_data_fn and write_data_fn in the same structure");
  }
#line 117
  png_ptr->output_flush_fn = (void (*)(png_structp  ))((void *)0);
#line 119
  return;
}
}
#line 101 "/usr/include/stdlib.h"
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 104
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 107
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 112
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__leaf__, __gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__,
__nothrow__)) ;
#line 820
__inline extern void *( __attribute__((__warn_unused_result__, __nonnull__(1,2,5),
__gnu_inline__)) bsearch)(void const   *__key , void const   *__base , size_t __nmemb ,
                          size_t __size , int (*__compar)(void const   * , void const   * ) ) ;
#line 929
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar )  __attribute__((__nothrow__)) ;
#line 933
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t *__dst , char const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 936
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) wcstombs)(char *__dst , wchar_t const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 43 "/usr/include/string.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memcpy)(void *__dest , void const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 47
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 61
__inline extern void *( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) memset)(void *__dest , int __ch , size_t __len )  __attribute__((__nothrow__)) ;
#line 122
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcpy)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 125
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncpy)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 130
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcat)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 133
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncat)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 326 "/usr/include/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) fprintf)(FILE *__stream ,
                                                                                                  char const   *__fmt
                                                                                                  , ...) ;
#line 332
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) printf)(char const   *__fmt
                                                                                                 , ...) ;
#line 334
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) sprintf)(char *__s ,
                                                                                                            char const   *__fmt
                                                                                                            , ...)  __attribute__((__nothrow__)) ;
#line 341
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vfprintf)(FILE *__stream ,
                                                                                                   char const   *__fmt ,
                                                                                                   __gnuc_va_list __ap ) ;
#line 347
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vprintf)(char const   *__fmt ,
                                                                                                  __gnuc_va_list __ap ) ;
#line 349
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vsprintf)(char *__s ,
                                                                                                             char const   *__fmt ,
                                                                                                             __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 354
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) snprintf)(char *__s , size_t __n , char const   *__fmt
                                              , ...)  __attribute__((__nothrow__)) ;
#line 358
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) vsnprintf)(char *__s , size_t __n , char const   *__fmt ,
                                               __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 492
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
#line 528
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
#line 564
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fgets)(char *__s , int __n , FILE *__stream ) ;
#line 646
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fread)(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 360 "/usr/include/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) read)(int __fd , void *__buf , size_t __nbytes ) ;
#line 511
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size )  __attribute__((__nothrow__)) ;
#line 689
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list )  __attribute__((__nothrow__)) ;
#line 774
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                               size_t __buflen )  __attribute__((__nothrow__)) ;
#line 35 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
void png_set_crc_action(png_structrp png_ptr , int crit_action , int ancil_action )
{


  {
#line 40
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 41
    return;
  }
  {
#line 46
  if (crit_action == 5) {
#line 46
    goto case_5;
  }
#line 49
  if (crit_action == 3) {
#line 49
    goto case_3;
  }
#line 54
  if (crit_action == 4) {
#line 54
    goto case_4;
  }
#line 60
  if (crit_action == 2) {
#line 60
    goto case_2;
  }
#line 67
  goto switch_default;
  case_5: /* CIL Label */
#line 47
  goto switch_break;
  case_3: /* CIL Label */
#line 50
  png_ptr->flags &= 4294964223U;
#line 51
  png_ptr->flags |= 0x0400U;
#line 52
  goto switch_break;
  case_4: /* CIL Label */
#line 55
  png_ptr->flags &= 4294964223U;
#line 56
  png_ptr->flags |= 3072U;
#line 58
  goto switch_break;
  case_2: /* CIL Label */
#line 61
  png_warning((png_const_structrp )png_ptr, (png_const_charp )"Can\'t discard critical data on CRC error");
  switch_default: /* CIL Label */
  case_0: /* CIL Label */
  case_1: /* CIL Label */
#line 68
  png_ptr->flags &= 4294964223U;
#line 69
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 75
  if (ancil_action == 5) {
#line 75
    goto case_5___0;
  }
#line 78
  if (ancil_action == 3) {
#line 78
    goto case_3___0;
  }
#line 83
  if (ancil_action == 4) {
#line 83
    goto case_4___0;
  }
#line 89
  if (ancil_action == 1) {
#line 89
    goto case_1___0;
  }
#line 97
  goto switch_default___0;
  case_5___0: /* CIL Label */
#line 76
  goto switch_break___0;
  case_3___0: /* CIL Label */
#line 79
  png_ptr->flags &= 4294966527U;
#line 80
  png_ptr->flags |= 0x0100U;
#line 81
  goto switch_break___0;
  case_4___0: /* CIL Label */
#line 84
  png_ptr->flags &= 4294966527U;
#line 85
  png_ptr->flags |= 768U;
#line 87
  goto switch_break___0;
  case_1___0: /* CIL Label */
#line 90
  png_ptr->flags &= 4294966527U;
#line 91
  png_ptr->flags |= 0x0200U;
#line 92
  goto switch_break___0;
  switch_default___0: /* CIL Label */
  case_0___0: /* CIL Label */
  case_2___0: /* CIL Label */
#line 98
  png_ptr->flags &= 4294966527U;
#line 99
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 101
  return;
}
}
#line 109 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
static int png_rtran_ok(png_structrp png_ptr , int need_IHDR )
{


  {
#line 112
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 114
    if ((png_ptr->flags & 0x0040U) != 0U) {
#line 115
      png_app_error((png_const_structrp )png_ptr, (png_const_charp )"invalid after png_start_read_image or png_read_update_info");
    } else
#line 118
    if (need_IHDR) {
#line 118
      if ((png_ptr->mode & 1U) == 0U) {
#line 119
        png_app_error((png_const_structrp )png_ptr, (png_const_charp )"invalid before the PNG header has been read");
      } else {
#line 124
        png_ptr->flags |= 0x4000U;
#line 126
        return (1);
      }
    } else {
#line 124
      png_ptr->flags |= 0x4000U;
#line 126
      return (1);
    }
  }
#line 130
  return (0);
}
}
#line 136 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
void png_set_background_fixed(png_structrp png_ptr , png_const_color_16p background_color ,
                              int background_gamma_code , int need_expand , png_fixed_point background_gamma )
{
  int tmp ;

  {
#line 143
  tmp = png_rtran_ok(png_ptr, 0);
#line 143
  if (tmp == 0) {
#line 144
    return;
  } else
#line 143
  if ((unsigned long )background_color == (unsigned long )((void *)0)) {
#line 144
    return;
  }
#line 146
  if (background_gamma_code == 0) {
#line 148
    png_warning((png_const_structrp )png_ptr, (png_const_charp )"Application must supply a known background gamma");
#line 149
    return;
  }
#line 152
  png_ptr->transformations |= 262272U;
#line 153
  png_ptr->transformations &= 4286578687U;
#line 154
  png_ptr->flags &= 4294959103U;
#line 156
  png_ptr->background = (png_color_16 )*background_color;
#line 157
  png_ptr->background_gamma = background_gamma;
#line 158
  png_ptr->background_gamma_type = (png_byte )background_gamma_code;
#line 159
  if (need_expand != 0) {
#line 160
    png_ptr->transformations |= 0x0100U;
  } else {
#line 162
    png_ptr->transformations &= 4294967039U;
  }
#line 163
  return;
}
}
#line 166 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
void png_set_background(png_structrp png_ptr , png_const_color_16p background_color ,
                        int background_gamma_code , int need_expand , double background_gamma )
{
  png_fixed_point tmp ;

  {
#line 171
  tmp = png_fixed((png_const_structrp )png_ptr, background_gamma, (png_const_charp )"png_set_background");
#line 171
  png_set_background_fixed(png_ptr, background_color, background_gamma_code, need_expand,
                           tmp);
#line 173
  return;
}
}
#line 182 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
void png_set_scale_16(png_structrp png_ptr )
{
  int tmp ;

  {
#line 187
  tmp = png_rtran_ok(png_ptr, 0);
#line 187
  if (tmp == 0) {
#line 188
    return;
  }
#line 190
  png_ptr->transformations |= 0x4000000U;
#line 191
  return;
}
}
#line 196 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
void png_set_strip_16(png_structrp png_ptr )
{
  int tmp ;

  {
#line 201
  tmp = png_rtran_ok(png_ptr, 0);
#line 201
  if (tmp == 0) {
#line 202
    return;
  }
#line 204
  png_ptr->transformations |= 0x0400U;
#line 205
  return;
}
}
#line 209 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
void png_set_strip_alpha(png_structrp png_ptr )
{
  int tmp ;

  {
#line 214
  tmp = png_rtran_ok(png_ptr, 0);
#line 214
  if (tmp == 0) {
#line 215
    return;
  }
#line 217
  png_ptr->transformations |= 0x40000U;
#line 218
  return;
}
}
#line 222 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
static png_fixed_point translate_gamma_flags(png_structrp png_ptr , png_fixed_point output_gamma ,
                                             int is_screen )
{


  {
#line 231
  if (output_gamma == -1) {
#line 231
    goto _L___0;
  } else
#line 231
  if (output_gamma == -100000) {
    _L___0: /* CIL Label */
#line 238
    png_ptr->flags |= 0x1000U;
#line 242
    if (is_screen != 0) {
#line 243
      output_gamma = 220000;
    } else {
#line 245
      output_gamma = 45455;
    }
  } else
#line 248
  if (output_gamma == -2) {
#line 248
    goto _L;
  } else
#line 248
  if (output_gamma == -50000) {
    _L: /* CIL Label */
#line 251
    if (is_screen != 0) {
#line 252
      output_gamma = 151724;
    } else {
#line 254
      output_gamma = 65909;
    }
  }
#line 257
  return (output_gamma);
}
}
#line 261 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
static png_fixed_point convert_gamma_value(png_structrp png_ptr , double output_gamma )
{


  {
#line 271
  if (output_gamma > (double )0) {
#line 271
    if (output_gamma < (double )128) {
#line 272
      output_gamma *= (double )100000;
    }
  }
#line 275
  output_gamma = floor(output_gamma + .5);
#line 277
  if (output_gamma > (double )2147483647) {
#line 278
    png_fixed_error((png_const_structrp )png_ptr, (png_const_charp )"gamma value");
  } else
#line 277
  if (output_gamma < (double )-2147483647) {
#line 278
    png_fixed_error((png_const_structrp )png_ptr, (png_const_charp )"gamma value");
  }
#line 280
  return ((png_fixed_point )output_gamma);
}
}
#line 286 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
void png_set_alpha_mode_fixed(png_structrp png_ptr , int mode , png_fixed_point output_gamma )
{
  int compose ;
  png_fixed_point file_gamma ;
  int tmp ;

  {
#line 290
  compose = 0;
#line 295
  tmp = png_rtran_ok(png_ptr, 0);
#line 295
  if (tmp == 0) {
#line 296
    return;
  }
#line 298
  output_gamma = translate_gamma_flags(png_ptr, output_gamma, 1);
#line 309
  if (output_gamma < 1000) {
#line 310
    png_error((png_const_structrp )png_ptr, (png_const_charp )"output gamma out of expected range");
  } else
#line 309
  if (output_gamma > 10000000) {
#line 310
    png_error((png_const_structrp )png_ptr, (png_const_charp )"output gamma out of expected range");
  }
#line 315
  file_gamma = png_reciprocal(output_gamma);
  {
#line 335
  if (mode == 0) {
#line 335
    goto case_0;
  }
#line 341
  if (mode == 1) {
#line 341
    goto case_1;
  }
#line 349
  if (mode == 2) {
#line 349
    goto case_2;
  }
#line 356
  if (mode == 3) {
#line 356
    goto case_3;
  }
#line 362
  goto switch_default;
  case_0: /* CIL Label */
#line 337
  png_ptr->transformations &= 4286578687U;
#line 338
  png_ptr->flags &= 4294959103U;
#line 339
  goto switch_break;
  case_1: /* CIL Label */
#line 342
  compose = 1;
#line 343
  png_ptr->transformations &= 4286578687U;
#line 344
  png_ptr->flags &= 4294959103U;
#line 346
  output_gamma = 100000;
#line 347
  goto switch_break;
  case_2: /* CIL Label */
#line 350
  compose = 1;
#line 351
  png_ptr->transformations &= 4286578687U;
#line 352
  png_ptr->flags |= 0x2000U;
#line 354
  goto switch_break;
  case_3: /* CIL Label */
#line 357
  compose = 1;
#line 358
  png_ptr->transformations |= 0x800000U;
#line 359
  png_ptr->flags &= 4294959103U;
#line 360
  goto switch_break;
  switch_default: /* CIL Label */
#line 363
  png_error((png_const_structrp )png_ptr, (png_const_charp )"invalid alpha mode");
  switch_break: /* CIL Label */ ;
  }
#line 370
  if (png_ptr->colorspace.gamma == 0) {
#line 372
    png_ptr->colorspace.gamma = file_gamma;
#line 373
    png_ptr->colorspace.flags = (png_uint_16 )((int )png_ptr->colorspace.flags | 0x0001);
  }
#line 377
  png_ptr->screen_gamma = output_gamma;
#line 382
  if (compose != 0) {
#line 385
    memset((void *)(& png_ptr->background), 0, sizeof(png_ptr->background));
#line 386
    png_ptr->background_gamma = png_ptr->colorspace.gamma;
#line 387
    png_ptr->background_gamma_type = (png_byte )2;
#line 388
    png_ptr->transformations &= 4294967039U;
#line 390
    if ((png_ptr->transformations & 0x0080U) != 0U) {
#line 391
      png_error((png_const_structrp )png_ptr, (png_const_charp )"conflicting calls to set alpha mode and background");
    }
#line 394
    png_ptr->transformations |= 0x0080U;
  }
#line 396
  return;
}
}
#line 399 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
void png_set_alpha_mode(png_structrp png_ptr , int mode , double output_gamma )
{
  png_fixed_point tmp ;

  {
#line 402
  tmp = convert_gamma_value(png_ptr, output_gamma);
#line 402
  png_set_alpha_mode_fixed(png_ptr, mode, tmp);
#line 404
  return;
}
}
#line 427 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
void png_set_quantize(png_structrp png_ptr , png_colorp palette , int num_palette ,
                      int maximum_colors , png_const_uint_16p histogram , int full_quantize )
{
  int tmp ;
  int i ;
  png_voidp __attribute__((__malloc__))  tmp___0 ;
  int i___0 ;
  png_voidp __attribute__((__malloc__))  tmp___1 ;
  int done ;
  int j ;
  png_byte t ;
  int j___0 ;
  int j___1 ;
  png_color tmp_color ;
  int min_d ;
  int k ;
  int min_k ;
  int d_index ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int d ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int i___1 ;
  int max_d ;
  int num_new_palette ;
  png_dsortp t___0 ;
  png_dsortpp hash ;
  png_voidp __attribute__((__malloc__))  tmp___8 ;
  png_voidp __attribute__((__malloc__))  tmp___9 ;
  png_voidp __attribute__((__malloc__))  tmp___10 ;
  int j___2 ;
  int d___0 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  png_voidp __attribute__((__malloc__))  tmp___14 ;
  png_dsortp p ;
  int j___3 ;
  int next_j ;
  int k___0 ;
  png_dsortp p___0 ;
  int i___2 ;
  png_bytep distance ;
  int total_bits ;
  int num_red ;
  int num_green ;
  int num_blue ;
  size_t num_entries ;
  png_voidp __attribute__((__malloc__))  tmp___15 ;
  png_voidp __attribute__((__malloc__))  tmp___16 ;
  int ir ;
  int ig ;
  int ib ;
  int r ;
  int g ;
  int b ;
  int dr ;
  int tmp___17 ;
  int index_r ;
  int dg ;
  int tmp___18 ;
  int dt ;
  int dm ;
  int tmp___19 ;
  int index_g ;
  int d_index___0 ;
  int db ;
  int tmp___20 ;
  int dmax ;
  int tmp___21 ;
  int d___1 ;

  {
#line 434
  tmp = png_rtran_ok(png_ptr, 0);
#line 434
  if (tmp == 0) {
#line 435
    return;
  }
#line 437
  png_ptr->transformations |= 0x0040U;
#line 439
  if (full_quantize == 0) {
#line 443
    tmp___0 = png_malloc((png_const_structrp )png_ptr, (unsigned long )((png_uint_32 )num_palette) * sizeof(png_byte ));
#line 443
    png_ptr->quantize_index = (png_bytep )tmp___0;
#line 445
    i = 0;
    {
#line 445
    while (1) {
      while_continue: /* CIL Label */ ;
#line 445
      if (! (i < num_palette)) {
#line 445
        goto while_break;
      }
#line 446
      *(png_ptr->quantize_index + i) = (png_byte )i;
#line 445
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 449
  if (num_palette > maximum_colors) {
#line 451
    if ((unsigned long )histogram != (unsigned long )((void *)0)) {
#line 460
      tmp___1 = png_malloc((png_const_structrp )png_ptr, (unsigned long )((png_uint_32 )num_palette) * sizeof(png_byte ));
#line 460
      png_ptr->quantize_sort = (png_bytep )tmp___1;
#line 464
      i___0 = 0;
      {
#line 464
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 464
        if (! (i___0 < num_palette)) {
#line 464
          goto while_break___0;
        }
#line 465
        *(png_ptr->quantize_sort + i___0) = (png_byte )i___0;
#line 464
        i___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 474
      i___0 = num_palette - 1;
      {
#line 474
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 474
        if (! (i___0 >= maximum_colors)) {
#line 474
          goto while_break___1;
        }
#line 479
        done = 1;
#line 480
        j = 0;
        {
#line 480
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 480
          if (! (j < i___0)) {
#line 480
            goto while_break___2;
          }
#line 482
          if ((int const   )*(histogram + *(png_ptr->quantize_sort + j)) < (int const   )*(histogram + *(png_ptr->quantize_sort + (j + 1)))) {
#line 487
            t = *(png_ptr->quantize_sort + j);
#line 488
            *(png_ptr->quantize_sort + j) = *(png_ptr->quantize_sort + (j + 1));
#line 489
            *(png_ptr->quantize_sort + (j + 1)) = t;
#line 490
            done = 0;
          }
#line 480
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 494
        if (done != 0) {
#line 495
          goto while_break___1;
        }
#line 474
        i___0 --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 499
      if (full_quantize != 0) {
#line 501
        j___0 = num_palette;
#line 506
        i___0 = 0;
        {
#line 506
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 506
          if (! (i___0 < maximum_colors)) {
#line 506
            goto while_break___3;
          }
#line 508
          if ((int )*(png_ptr->quantize_sort + i___0) >= maximum_colors) {
            {
#line 510
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 511
              j___0 --;
#line 510
              if (! ((int )*(png_ptr->quantize_sort + j___0) >= maximum_colors)) {
#line 510
                goto while_break___4;
              }
            }
            while_break___4: /* CIL Label */ ;
            }
#line 514
            *(palette + i___0) = *(palette + j___0);
          }
#line 506
          i___0 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else {
#line 520
        j___1 = num_palette;
#line 525
        i___0 = 0;
        {
#line 525
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 525
          if (! (i___0 < maximum_colors)) {
#line 525
            goto while_break___5;
          }
#line 528
          if ((int )*(png_ptr->quantize_sort + i___0) >= maximum_colors) {
            {
#line 532
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 533
              j___1 --;
#line 532
              if (! ((int )*(png_ptr->quantize_sort + j___1) >= maximum_colors)) {
#line 532
                goto while_break___6;
              }
            }
            while_break___6: /* CIL Label */ ;
            }
#line 536
            tmp_color = *(palette + j___1);
#line 537
            *(palette + j___1) = *(palette + i___0);
#line 538
            *(palette + i___0) = tmp_color;
#line 540
            *(png_ptr->quantize_index + j___1) = (png_byte )i___0;
#line 541
            *(png_ptr->quantize_index + i___0) = (png_byte )j___1;
          }
#line 525
          i___0 ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 546
        i___0 = 0;
        {
#line 546
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 546
          if (! (i___0 < num_palette)) {
#line 546
            goto while_break___7;
          }
#line 548
          if ((int )*(png_ptr->quantize_index + i___0) >= maximum_colors) {
#line 553
            d_index = (int )*(png_ptr->quantize_index + i___0);
#line 554
            tmp___2 = abs((int )(palette + d_index)->red - (int )(palette + 0)->red);
#line 554
            tmp___3 = abs((int )(palette + d_index)->green - (int )(palette + 0)->green);
#line 554
            tmp___4 = abs((int )(palette + d_index)->blue - (int )(palette + 0)->blue);
#line 554
            min_d = (tmp___2 + tmp___3) + tmp___4;
#line 555
            k = 1;
#line 555
            min_k = 0;
            {
#line 555
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 555
              if (! (k < maximum_colors)) {
#line 555
                goto while_break___8;
              }
#line 559
              tmp___5 = abs((int )(palette + d_index)->red - (int )(palette + k)->red);
#line 559
              tmp___6 = abs((int )(palette + d_index)->green - (int )(palette + k)->green);
#line 559
              tmp___7 = abs((int )(palette + d_index)->blue - (int )(palette + k)->blue);
#line 559
              d = (tmp___5 + tmp___6) + tmp___7;
#line 561
              if (d < min_d) {
#line 563
                min_d = d;
#line 564
                min_k = k;
              }
#line 555
              k ++;
            }
            while_break___8: /* CIL Label */ ;
            }
#line 568
            *(png_ptr->quantize_index + i___0) = (png_byte )min_k;
          }
#line 546
          i___0 ++;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
#line 572
      png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->quantize_sort);
#line 573
      png_ptr->quantize_sort = (png_bytep )((void *)0);
    } else {
#line 591
      t___0 = (png_dsortp )((void *)0);
#line 594
      tmp___8 = png_malloc((png_const_structrp )png_ptr, (unsigned long )((png_uint_32 )num_palette) * sizeof(png_byte ));
#line 594
      png_ptr->index_to_palette = (png_bytep )tmp___8;
#line 597
      tmp___9 = png_malloc((png_const_structrp )png_ptr, (unsigned long )((png_uint_32 )num_palette) * sizeof(png_byte ));
#line 597
      png_ptr->palette_to_index = (png_bytep )tmp___9;
#line 602
      i___1 = 0;
      {
#line 602
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 602
        if (! (i___1 < num_palette)) {
#line 602
          goto while_break___9;
        }
#line 604
        *(png_ptr->index_to_palette + i___1) = (png_byte )i___1;
#line 605
        *(png_ptr->palette_to_index + i___1) = (png_byte )i___1;
#line 602
        i___1 ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 608
      tmp___10 = png_calloc((png_const_structrp )png_ptr, 769UL * sizeof(png_dsortp ));
#line 608
      hash = (png_dsortpp )tmp___10;
#line 611
      num_new_palette = num_palette;
#line 621
      max_d = 96;
      {
#line 623
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 623
        if (! (num_new_palette > maximum_colors)) {
#line 623
          goto while_break___10;
        }
#line 625
        i___1 = 0;
        {
#line 625
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 625
          if (! (i___1 < num_new_palette - 1)) {
#line 625
            goto while_break___11;
          }
#line 629
          j___2 = i___1 + 1;
          {
#line 629
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 629
            if (! (j___2 < num_new_palette)) {
#line 629
              goto while_break___12;
            }
#line 633
            tmp___11 = abs((int )(palette + i___1)->red - (int )(palette + j___2)->red);
#line 633
            tmp___12 = abs((int )(palette + i___1)->green - (int )(palette + j___2)->green);
#line 633
            tmp___13 = abs((int )(palette + i___1)->blue - (int )(palette + j___2)->blue);
#line 633
            d___0 = (tmp___11 + tmp___12) + tmp___13;
#line 635
            if (d___0 <= max_d) {
#line 638
              tmp___14 = png_malloc_warn((png_const_structrp )png_ptr, sizeof(png_dsort ));
#line 638
              t___0 = (png_dsortp )tmp___14;
#line 641
              if ((unsigned long )t___0 == (unsigned long )((void *)0)) {
#line 642
                goto while_break___12;
              }
#line 644
              t___0->next = *(hash + d___0);
#line 645
              t___0->left = (png_byte )i___1;
#line 646
              t___0->right = (png_byte )j___2;
#line 647
              *(hash + d___0) = t___0;
            }
#line 629
            j___2 ++;
          }
          while_break___12: /* CIL Label */ ;
          }
#line 650
          if ((unsigned long )t___0 == (unsigned long )((void *)0)) {
#line 651
            goto while_break___11;
          }
#line 625
          i___1 ++;
        }
        while_break___11: /* CIL Label */ ;
        }
#line 654
        if ((unsigned long )t___0 != (unsigned long )((void *)0)) {
#line 655
          i___1 = 0;
          {
#line 655
          while (1) {
            while_continue___13: /* CIL Label */ ;
#line 655
            if (! (i___1 <= max_d)) {
#line 655
              goto while_break___13;
            }
#line 657
            if ((unsigned long )*(hash + i___1) != (unsigned long )((void *)0)) {
#line 661
              p = *(hash + i___1);
              {
#line 661
              while (1) {
                while_continue___14: /* CIL Label */ ;
#line 661
                if (! p) {
#line 661
                  goto while_break___14;
                }
#line 663
                if ((int )*(png_ptr->index_to_palette + p->left) < num_new_palette) {
#line 663
                  if ((int )*(png_ptr->index_to_palette + p->right) < num_new_palette) {
#line 670
                    if (num_new_palette & 0x01) {
#line 672
                      j___3 = (int )p->left;
#line 673
                      next_j = (int )p->right;
                    } else {
#line 677
                      j___3 = (int )p->right;
#line 678
                      next_j = (int )p->left;
                    }
#line 681
                    num_new_palette --;
#line 682
                    *(palette + *(png_ptr->index_to_palette + j___3)) = *(palette + num_new_palette);
#line 684
                    if (full_quantize == 0) {
#line 688
                      k___0 = 0;
                      {
#line 688
                      while (1) {
                        while_continue___15: /* CIL Label */ ;
#line 688
                        if (! (k___0 < num_palette)) {
#line 688
                          goto while_break___15;
                        }
#line 690
                        if ((int )*(png_ptr->quantize_index + k___0) == (int )*(png_ptr->index_to_palette + j___3)) {
#line 692
                          *(png_ptr->quantize_index + k___0) = *(png_ptr->index_to_palette + next_j);
                        }
#line 695
                        if ((int )*(png_ptr->quantize_index + k___0) == num_new_palette) {
#line 697
                          *(png_ptr->quantize_index + k___0) = *(png_ptr->index_to_palette + j___3);
                        }
#line 688
                        k___0 ++;
                      }
                      while_break___15: /* CIL Label */ ;
                      }
                    }
#line 702
                    *(png_ptr->index_to_palette + *(png_ptr->palette_to_index + num_new_palette)) = *(png_ptr->index_to_palette + j___3);
#line 705
                    *(png_ptr->palette_to_index + *(png_ptr->index_to_palette + j___3)) = *(png_ptr->palette_to_index + num_new_palette);
#line 708
                    *(png_ptr->index_to_palette + j___3) = (png_byte )num_new_palette;
#line 711
                    *(png_ptr->palette_to_index + num_new_palette) = (png_byte )j___3;
                  }
                }
#line 714
                if (num_new_palette <= maximum_colors) {
#line 715
                  goto while_break___14;
                }
#line 661
                p = p->next;
              }
              while_break___14: /* CIL Label */ ;
              }
#line 717
              if (num_new_palette <= maximum_colors) {
#line 718
                goto while_break___13;
              }
            }
#line 655
            i___1 ++;
          }
          while_break___13: /* CIL Label */ ;
          }
        }
#line 722
        i___1 = 0;
        {
#line 722
        while (1) {
          while_continue___16: /* CIL Label */ ;
#line 722
          if (! (i___1 < 769)) {
#line 722
            goto while_break___16;
          }
#line 724
          if ((unsigned long )*(hash + i___1) != (unsigned long )((void *)0)) {
#line 726
            p___0 = *(hash + i___1);
            {
#line 727
            while (1) {
              while_continue___17: /* CIL Label */ ;
#line 727
              if (! p___0) {
#line 727
                goto while_break___17;
              }
#line 729
              t___0 = p___0->next;
#line 730
              png_free((png_const_structrp )png_ptr, (png_voidp )p___0);
#line 731
              p___0 = t___0;
            }
            while_break___17: /* CIL Label */ ;
            }
          }
#line 734
          *(hash + i___1) = (png_dsort *)0;
#line 722
          i___1 ++;
        }
        while_break___16: /* CIL Label */ ;
        }
#line 736
        max_d += 96;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 738
      png_free((png_const_structrp )png_ptr, (png_voidp )hash);
#line 739
      png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->palette_to_index);
#line 740
      png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->index_to_palette);
#line 741
      png_ptr->palette_to_index = (png_bytep )((void *)0);
#line 742
      png_ptr->index_to_palette = (png_bytep )((void *)0);
    }
#line 744
    num_palette = maximum_colors;
  }
#line 746
  if ((unsigned long )png_ptr->palette == (unsigned long )((void *)0)) {
#line 748
    png_ptr->palette = palette;
  }
#line 750
  png_ptr->num_palette = (png_uint_16 )num_palette;
#line 752
  if (full_quantize != 0) {
#line 756
    total_bits = 15;
#line 758
    num_red = 1 << 5;
#line 759
    num_green = 1 << 5;
#line 760
    num_blue = 1 << 5;
#line 761
    num_entries = 1UL << total_bits;
#line 763
    tmp___15 = png_calloc((png_const_structrp )png_ptr, num_entries * sizeof(png_byte ));
#line 763
    png_ptr->palette_lookup = (png_bytep )tmp___15;
#line 766
    tmp___16 = png_malloc((png_const_structrp )png_ptr, num_entries * sizeof(png_byte ));
#line 766
    distance = (png_bytep )tmp___16;
#line 769
    memset((void *)distance, 0xff, num_entries * sizeof(png_byte ));
#line 771
    i___2 = 0;
    {
#line 771
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 771
      if (! (i___2 < num_palette)) {
#line 771
        goto while_break___18;
      }
#line 774
      r = (int )(palette + i___2)->red >> 3;
#line 775
      g = (int )(palette + i___2)->green >> 3;
#line 776
      b = (int )(palette + i___2)->blue >> 3;
#line 778
      ir = 0;
      {
#line 778
      while (1) {
        while_continue___19: /* CIL Label */ ;
#line 778
        if (! (ir < num_red)) {
#line 778
          goto while_break___19;
        }
#line 781
        if (ir > r) {
#line 781
          tmp___17 = ir - r;
        } else {
#line 781
          tmp___17 = r - ir;
        }
#line 781
        dr = tmp___17;
#line 782
        index_r = ir << 10;
#line 785
        ig = 0;
        {
#line 785
        while (1) {
          while_continue___20: /* CIL Label */ ;
#line 785
          if (! (ig < num_green)) {
#line 785
            goto while_break___20;
          }
#line 788
          if (ig > g) {
#line 788
            tmp___18 = ig - g;
          } else {
#line 788
            tmp___18 = g - ig;
          }
#line 788
          dg = tmp___18;
#line 789
          dt = dr + dg;
#line 790
          if (dr > dg) {
#line 790
            tmp___19 = dr;
          } else {
#line 790
            tmp___19 = dg;
          }
#line 790
          dm = tmp___19;
#line 791
          index_g = index_r | (ig << 5);
#line 793
          ib = 0;
          {
#line 793
          while (1) {
            while_continue___21: /* CIL Label */ ;
#line 793
            if (! (ib < num_blue)) {
#line 793
              goto while_break___21;
            }
#line 795
            d_index___0 = index_g | ib;
#line 797
            if (ib > b) {
#line 797
              tmp___20 = ib - b;
            } else {
#line 797
              tmp___20 = b - ib;
            }
#line 797
            db = tmp___20;
#line 798
            if (dm > db) {
#line 798
              tmp___21 = dm;
            } else {
#line 798
              tmp___21 = db;
            }
#line 798
            dmax = tmp___21;
#line 799
            d___1 = (dmax + dt) + db;
#line 801
            if (d___1 < (int )*(distance + d_index___0)) {
#line 803
              *(distance + d_index___0) = (png_byte )d___1;
#line 804
              *(png_ptr->palette_lookup + d_index___0) = (png_byte )i___2;
            }
#line 793
            ib ++;
          }
          while_break___21: /* CIL Label */ ;
          }
#line 785
          ig ++;
        }
        while_break___20: /* CIL Label */ ;
        }
#line 778
        ir ++;
      }
      while_break___19: /* CIL Label */ ;
      }
#line 771
      i___2 ++;
    }
    while_break___18: /* CIL Label */ ;
    }
#line 811
    png_free((png_const_structrp )png_ptr, (png_voidp )distance);
  }
#line 813
  return;
}
}
#line 817 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
void png_set_gamma_fixed(png_structrp png_ptr , png_fixed_point scrn_gamma , png_fixed_point file_gamma )
{
  int tmp ;

  {
#line 823
  tmp = png_rtran_ok(png_ptr, 0);
#line 823
  if (tmp == 0) {
#line 824
    return;
  }
#line 827
  scrn_gamma = translate_gamma_flags(png_ptr, scrn_gamma, 1);
#line 828
  file_gamma = translate_gamma_flags(png_ptr, file_gamma, 0);
#line 841
  if (file_gamma <= 0) {
#line 842
    png_error((png_const_structrp )png_ptr, (png_const_charp )"invalid file gamma in png_set_gamma");
  }
#line 844
  if (scrn_gamma <= 0) {
#line 845
    png_error((png_const_structrp )png_ptr, (png_const_charp )"invalid screen gamma in png_set_gamma");
  }
#line 851
  png_ptr->colorspace.gamma = file_gamma;
#line 852
  png_ptr->colorspace.flags = (png_uint_16 )((int )png_ptr->colorspace.flags | 0x0001);
#line 853
  png_ptr->screen_gamma = scrn_gamma;
#line 854
  return;
}
}
#line 857 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
void png_set_gamma(png_structrp png_ptr , double scrn_gamma , double file_gamma )
{
  png_fixed_point tmp ;
  png_fixed_point tmp___0 ;

  {
#line 860
  tmp = convert_gamma_value(png_ptr, file_gamma);
#line 860
  tmp___0 = convert_gamma_value(png_ptr, scrn_gamma);
#line 860
  png_set_gamma_fixed(png_ptr, tmp___0, tmp);
#line 862
  return;
}
}
#line 871 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
void png_set_expand(png_structrp png_ptr )
{
  int tmp ;

  {
#line 876
  tmp = png_rtran_ok(png_ptr, 0);
#line 876
  if (tmp == 0) {
#line 877
    return;
  }
#line 879
  png_ptr->transformations |= 33558528U;
#line 880
  return;
}
}
#line 901 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
void png_set_palette_to_rgb(png_structrp png_ptr )
{
  int tmp ;

  {
#line 906
  tmp = png_rtran_ok(png_ptr, 0);
#line 906
  if (tmp == 0) {
#line 907
    return;
  }
#line 909
  png_ptr->transformations |= 33558528U;
#line 910
  return;
}
}
#line 913 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
void png_set_expand_gray_1_2_4_to_8(png_structrp png_ptr )
{
  int tmp ;

  {
#line 918
  tmp = png_rtran_ok(png_ptr, 0);
#line 918
  if (tmp == 0) {
#line 919
    return;
  }
#line 921
  png_ptr->transformations |= 0x1000U;
#line 922
  return;
}
}
#line 925 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
void png_set_tRNS_to_alpha(png_structrp png_ptr )
{
  int tmp ;

  {
#line 930
  tmp = png_rtran_ok(png_ptr, 0);
#line 930
  if (tmp == 0) {
#line 931
    return;
  }
#line 933
  png_ptr->transformations |= 33558528U;
#line 934
  return;
}
}
#line 941 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
void png_set_expand_16(png_structrp png_ptr )
{
  int tmp ;

  {
#line 946
  tmp = png_rtran_ok(png_ptr, 0);
#line 946
  if (tmp == 0) {
#line 947
    return;
  }
#line 949
  png_ptr->transformations |= 33559040U;
#line 950
  return;
}
}
#line 954 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
void png_set_gray_to_rgb(png_structrp png_ptr )
{
  int tmp ;

  {
#line 959
  tmp = png_rtran_ok(png_ptr, 0);
#line 959
  if (tmp == 0) {
#line 960
    return;
  }
#line 963
  png_set_expand_gray_1_2_4_to_8(png_ptr);
#line 964
  png_ptr->transformations |= 0x4000U;
#line 965
  return;
}
}
#line 969 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
void png_set_rgb_to_gray_fixed(png_structrp png_ptr , int error_action , png_fixed_point red ,
                               png_fixed_point green )
{
  int tmp ;
  png_uint_16 red_int ;
  png_uint_16 green_int ;

  {
#line 977
  tmp = png_rtran_ok(png_ptr, 1);
#line 977
  if (tmp == 0) {
#line 978
    return;
  }
  {
#line 982
  if (error_action == 1) {
#line 982
    goto case_1;
  }
#line 986
  if (error_action == 2) {
#line 986
    goto case_2;
  }
#line 990
  if (error_action == 3) {
#line 990
    goto case_3;
  }
#line 994
  goto switch_default;
  case_1: /* CIL Label */
#line 983
  png_ptr->transformations |= 0x600000U;
#line 984
  goto switch_break;
  case_2: /* CIL Label */
#line 987
  png_ptr->transformations |= 0x400000U;
#line 988
  goto switch_break;
  case_3: /* CIL Label */
#line 991
  png_ptr->transformations |= 0x200000U;
#line 992
  goto switch_break;
  switch_default: /* CIL Label */
#line 995
  png_error((png_const_structrp )png_ptr, (png_const_charp )"invalid error action to rgb_to_gray");
  switch_break: /* CIL Label */ ;
  }
#line 998
  if ((int )png_ptr->color_type == 3) {
#line 1000
    png_ptr->transformations |= 0x1000U;
  }
#line 1013
  if (red >= 0) {
#line 1013
    if (green >= 0) {
#line 1013
      if (red + green <= 100000) {
#line 1022
        red_int = (png_uint_16 )(((png_uint_32 )red * 32768U) / 100000U);
#line 1023
        green_int = (png_uint_16 )(((png_uint_32 )green * 32768U) / 100000U);
#line 1025
        png_ptr->rgb_to_gray_red_coeff = red_int;
#line 1026
        png_ptr->rgb_to_gray_green_coeff = green_int;
#line 1027
        png_ptr->rgb_to_gray_coefficients_set = (png_byte )1;
      } else {
#line 1013
        goto _L___0;
      }
    } else {
#line 1013
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */
    _L: /* CIL Label */
#line 1032
    if (red >= 0) {
#line 1032
      if (green >= 0) {
#line 1033
        png_app_warning((png_const_structrp )png_ptr, (png_const_charp )"ignoring out of range rgb_to_gray coefficients");
      }
    }
#line 1042
    if ((int )png_ptr->rgb_to_gray_red_coeff == 0) {
#line 1042
      if ((int )png_ptr->rgb_to_gray_green_coeff == 0) {
#line 1045
        png_ptr->rgb_to_gray_red_coeff = (png_uint_16 )6968;
#line 1046
        png_ptr->rgb_to_gray_green_coeff = (png_uint_16 )23434;
      }
    }
  }
#line 1051
  return;
}
}
#line 1058 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
void png_set_rgb_to_gray(png_structrp png_ptr , int error_action , double red , double green )
{
  png_fixed_point tmp ;
  png_fixed_point tmp___0 ;

  {
#line 1062
  tmp = png_fixed((png_const_structrp )png_ptr, green, (png_const_charp )"rgb to gray green coefficient");
#line 1062
  tmp___0 = png_fixed((png_const_structrp )png_ptr, red, (png_const_charp )"rgb to gray red coefficient");
#line 1062
  png_set_rgb_to_gray_fixed(png_ptr, error_action, tmp___0, tmp);
#line 1065
  return;
}
}
#line 1072 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
void png_set_read_user_transform_fn(png_structrp png_ptr , void (*read_user_transform_fn)(png_structp  ,
                                                                                          png_row_infop  ,
                                                                                          png_bytep  ) )
{


  {
#line 1079
  png_ptr->transformations |= 0x100000U;
#line 1080
  png_ptr->read_user_transform_fn = read_user_transform_fn;
#line 1082
  return;
}
}
#line 1091 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
static int png_gamma_threshold(png_fixed_point screen_gamma , png_fixed_point file_gamma )
{
  png_fixed_point gtest ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1102
  tmp = png_muldiv(& gtest, screen_gamma, file_gamma, 100000);
#line 1102
  if (tmp) {
#line 1102
    tmp___0 = png_gamma_significant(gtest);
#line 1102
    if (tmp___0) {
#line 1102
      tmp___1 = 1;
    } else {
#line 1102
      tmp___1 = 0;
    }
  } else {
#line 1102
    tmp___1 = 1;
  }
#line 1102
  return (tmp___1);
}
}
#line 1116 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
static void png_init_palette_transformations(png_structrp png_ptr )
{
  int input_has_alpha ;
  int input_has_transparency ;
  int i ;
  int i___0 ;
  int istop ;

  {
#line 1127
  input_has_alpha = 0;
#line 1128
  input_has_transparency = 0;
#line 1130
  if ((int )png_ptr->num_trans > 0) {
#line 1135
    i = 0;
    {
#line 1135
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1135
      if (! (i < (int )png_ptr->num_trans)) {
#line 1135
        goto while_break;
      }
#line 1137
      if (! ((int )*(png_ptr->trans_alpha + i) == 255)) {
#line 1139
        if ((int )*(png_ptr->trans_alpha + i) == 0) {
#line 1140
          input_has_transparency = 1;
        } else {
#line 1143
          input_has_transparency = 1;
#line 1144
          input_has_alpha = 1;
#line 1145
          goto while_break;
        }
      }
      __Cont: /* CIL Label */
#line 1135
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1151
  if (input_has_alpha == 0) {
#line 1157
    png_ptr->transformations &= 4286578687U;
#line 1158
    png_ptr->flags &= 4294959103U;
#line 1160
    if (input_has_transparency == 0) {
#line 1161
      png_ptr->transformations &= 4294966911U;
    }
  }
#line 1173
  if ((png_ptr->transformations & 0x0100U) != 0U) {
#line 1173
    if ((png_ptr->transformations & 0x1000U) != 0U) {
#line 1177
      png_ptr->background.red = (png_uint_16 )(png_ptr->palette + png_ptr->background.index)->red;
#line 1179
      png_ptr->background.green = (png_uint_16 )(png_ptr->palette + png_ptr->background.index)->green;
#line 1181
      png_ptr->background.blue = (png_uint_16 )(png_ptr->palette + png_ptr->background.index)->blue;
#line 1185
      if ((png_ptr->transformations & 0x80000U) != 0U) {
#line 1187
        if ((png_ptr->transformations & 0x2000000U) == 0U) {
#line 1192
          istop = (int )png_ptr->num_trans;
#line 1194
          i___0 = 0;
          {
#line 1194
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1194
            if (! (i___0 < istop)) {
#line 1194
              goto while_break___0;
            }
#line 1195
            *(png_ptr->trans_alpha + i___0) = (png_byte )(255 - (int )*(png_ptr->trans_alpha + i___0));
#line 1194
            i___0 ++;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
    }
  }
#line 1203
  return;
}
}
#line 1205 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
static void png_init_rgb_transformations(png_structrp png_ptr )
{
  int input_has_alpha ;
  int input_has_transparency ;
  int gray ;
  int trans_gray ;
  png_uint_16 tmp ;
  png_uint_16 tmp___0 ;
  png_uint_16 tmp___1 ;
  png_uint_16 tmp___2 ;

  {
#line 1212
  input_has_alpha = ((int )png_ptr->color_type & 4) != 0;
#line 1213
  input_has_transparency = (int )png_ptr->num_trans > 0;
#line 1216
  if (input_has_alpha == 0) {
#line 1223
    png_ptr->transformations &= 4286578687U;
#line 1224
    png_ptr->flags &= 4294959103U;
#line 1227
    if (input_has_transparency == 0) {
#line 1228
      png_ptr->transformations &= 4294966911U;
    }
  }
#line 1240
  if ((png_ptr->transformations & 0x0100U) != 0U) {
#line 1240
    if ((png_ptr->transformations & 0x1000U) != 0U) {
#line 1240
      if (((int )png_ptr->color_type & 2) == 0) {
#line 1247
        gray = (int )png_ptr->background.gray;
#line 1248
        trans_gray = (int )png_ptr->trans_color.gray;
        {
#line 1252
        if ((int )png_ptr->bit_depth == 1) {
#line 1252
          goto case_1;
        }
#line 1257
        if ((int )png_ptr->bit_depth == 2) {
#line 1257
          goto case_2;
        }
#line 1262
        if ((int )png_ptr->bit_depth == 4) {
#line 1262
          goto case_4;
        }
#line 1267
        goto case_16;
        case_1: /* CIL Label */
#line 1253
        gray *= 0xff;
#line 1254
        trans_gray *= 0xff;
#line 1255
        goto switch_break;
        case_2: /* CIL Label */
#line 1258
        gray *= 0x55;
#line 1259
        trans_gray *= 0x55;
#line 1260
        goto switch_break;
        case_4: /* CIL Label */
#line 1263
        gray *= 0x11;
#line 1264
        trans_gray *= 0x11;
#line 1265
        goto switch_break;
        case_16: /* CIL Label */
        case_8: /* CIL Label */
        switch_default: /* CIL Label */
#line 1274
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 1277
        tmp___0 = (png_uint_16 )gray;
#line 1277
        png_ptr->background.blue = tmp___0;
#line 1277
        tmp = tmp___0;
#line 1277
        png_ptr->background.green = tmp;
#line 1277
        png_ptr->background.red = tmp;
#line 1280
        if ((png_ptr->transformations & 0x2000000U) == 0U) {
#line 1282
          tmp___2 = (png_uint_16 )trans_gray;
#line 1282
          png_ptr->trans_color.blue = tmp___2;
#line 1282
          tmp___1 = tmp___2;
#line 1282
          png_ptr->trans_color.green = tmp___1;
#line 1282
          png_ptr->trans_color.red = tmp___1;
        }
      }
    }
  }
#line 1288
  return;
}
}
#line 1290 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
void png_init_read_transformations(png_structrp png_ptr )
{
  int gamma_correction ;
  png_fixed_point tmp ;
  int tmp___0 ;
  png_color back ;
  png_color back_1 ;
  png_colorp palette ;
  int num_palette ;
  int i ;
  png_fixed_point g ;
  png_fixed_point gs ;
  int tmp___1 ;
  int tmp___2 ;
  png_byte v ;
  png_byte w ;
  png_uint_16 temp ;
  png_uint_16 temp___0 ;
  png_uint_16 temp___1 ;
  int gs_sig ;
  int g_sig ;
  png_fixed_point g___0 ;
  png_fixed_point gs___0 ;
  png_uint_16 tmp___3 ;
  png_uint_16 tmp___4 ;
  png_uint_16 tmp___5 ;
  png_uint_16 tmp___6 ;
  png_colorp palette___0 ;
  int num_palette___0 ;
  int i___0 ;
  int i___1 ;
  int istop ;
  png_color back___0 ;
  png_colorp palette___1 ;
  png_uint_16 temp___2 ;
  png_uint_16 temp___3 ;
  png_uint_16 temp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int i___2 ;
  int istop___0 ;
  int shift ;
  int component ;
  int component___0 ;
  int component___1 ;

  {
#line 1314
  gamma_correction = 0;
#line 1316
  if (png_ptr->colorspace.gamma != 0) {
#line 1318
    if (png_ptr->screen_gamma != 0) {
#line 1319
      gamma_correction = png_gamma_threshold(png_ptr->colorspace.gamma, png_ptr->screen_gamma);
    } else {
#line 1326
      png_ptr->screen_gamma = png_reciprocal(png_ptr->colorspace.gamma);
    }
  } else
#line 1329
  if (png_ptr->screen_gamma != 0) {
#line 1335
    png_ptr->colorspace.gamma = png_reciprocal(png_ptr->screen_gamma);
  } else {
#line 1343
    tmp = 100000;
#line 1343
    png_ptr->colorspace.gamma = tmp;
#line 1343
    png_ptr->screen_gamma = tmp;
  }
#line 1346
  png_ptr->colorspace.flags = (png_uint_16 )((int )png_ptr->colorspace.flags | 0x0001);
#line 1356
  if (gamma_correction != 0) {
#line 1357
    png_ptr->transformations |= 0x2000U;
  } else {
#line 1360
    png_ptr->transformations &= 4294959103U;
  }
#line 1394
  if ((png_ptr->transformations & 0x40000U) != 0U) {
#line 1394
    if ((png_ptr->transformations & 0x0080U) == 0U) {
#line 1402
      png_ptr->transformations &= 4253023999U;
#line 1404
      png_ptr->flags &= 4294959103U;
#line 1413
      png_ptr->num_trans = (png_uint_16 )0;
    }
  }
#line 1421
  tmp___0 = png_gamma_significant(png_ptr->screen_gamma);
#line 1421
  if (tmp___0 == 0) {
#line 1423
    png_ptr->transformations &= 4286578687U;
#line 1424
    png_ptr->flags &= 4294959103U;
  }
#line 1432
  if ((png_ptr->transformations & 0x600000U) != 0U) {
#line 1433
    png_colorspace_set_rgb_coefficients(png_ptr);
  }
#line 1453
  if ((png_ptr->transformations & 0x0100U) != 0U) {
#line 1458
    if (((int )png_ptr->color_type & 2) == 0) {
#line 1459
      png_ptr->mode |= 0x800U;
    }
  } else
#line 1462
  if ((png_ptr->transformations & 0x0080U) != 0U) {
#line 1469
    if ((png_ptr->transformations & 0x4000U) != 0U) {
#line 1471
      if ((int )png_ptr->background.red == (int )png_ptr->background.green) {
#line 1471
        if ((int )png_ptr->background.red == (int )png_ptr->background.blue) {
#line 1474
          png_ptr->mode |= 0x800U;
#line 1475
          png_ptr->background.gray = png_ptr->background.red;
        }
      }
    }
  }
#line 1493
  if ((int )png_ptr->color_type == 3) {
#line 1494
    png_init_palette_transformations(png_ptr);
  } else {
#line 1497
    png_init_rgb_transformations(png_ptr);
  }
#line 1501
  if ((png_ptr->transformations & 0x0200U) != 0U) {
#line 1501
    if ((png_ptr->transformations & 0x0080U) != 0U) {
#line 1501
      if ((png_ptr->transformations & 0x0100U) == 0U) {
#line 1501
        if ((int )png_ptr->bit_depth != 16) {
#line 1517
          png_ptr->background.red = (png_uint_16 )(((png_uint_32 )png_ptr->background.red * 255U + 32895U) >> 16);
#line 1518
          png_ptr->background.green = (png_uint_16 )(((png_uint_32 )png_ptr->background.green * 255U + 32895U) >> 16);
#line 1519
          png_ptr->background.blue = (png_uint_16 )(((png_uint_32 )png_ptr->background.blue * 255U + 32895U) >> 16);
#line 1520
          png_ptr->background.gray = (png_uint_16 )(((png_uint_32 )png_ptr->background.gray * 255U + 32895U) >> 16);
        }
      }
    }
  }
#line 1528
  if ((png_ptr->transformations & 67109888U) != 0U) {
#line 1528
    if ((png_ptr->transformations & 0x0080U) != 0U) {
#line 1528
      if ((png_ptr->transformations & 0x0100U) == 0U) {
#line 1528
        if ((int )png_ptr->bit_depth == 16) {
#line 1539
          png_ptr->background.red = (png_uint_16 )((int )png_ptr->background.red * 257);
#line 1540
          png_ptr->background.green = (png_uint_16 )((int )png_ptr->background.green * 257);
#line 1542
          png_ptr->background.blue = (png_uint_16 )((int )png_ptr->background.blue * 257);
#line 1543
          png_ptr->background.gray = (png_uint_16 )((int )png_ptr->background.gray * 257);
        }
      }
    }
  }
#line 1558
  png_ptr->background_1 = png_ptr->background;
#line 1574
  if ((png_ptr->transformations & 0x2000U) != 0U) {
#line 1574
    goto _L___1;
  } else
#line 1574
  if ((png_ptr->transformations & 0x600000U) != 0U) {
#line 1574
    tmp___7 = png_gamma_significant(png_ptr->colorspace.gamma);
#line 1574
    if (tmp___7 != 0) {
#line 1574
      goto _L___1;
    } else {
#line 1574
      tmp___8 = png_gamma_significant(png_ptr->screen_gamma);
#line 1574
      if (tmp___8 != 0) {
#line 1574
        goto _L___1;
      } else {
#line 1574
        goto _L___4;
      }
    }
  } else
  _L___4: /* CIL Label */
#line 1574
  if ((png_ptr->transformations & 0x0080U) != 0U) {
#line 1574
    tmp___9 = png_gamma_significant(png_ptr->colorspace.gamma);
#line 1574
    if (tmp___9 != 0) {
#line 1574
      goto _L___1;
    } else {
#line 1574
      tmp___10 = png_gamma_significant(png_ptr->screen_gamma);
#line 1574
      if (tmp___10 != 0) {
#line 1574
        goto _L___1;
      } else
#line 1574
      if ((int )png_ptr->background_gamma_type == 3) {
#line 1574
        tmp___11 = png_gamma_significant(png_ptr->background_gamma);
#line 1574
        if (tmp___11 != 0) {
#line 1574
          goto _L___1;
        } else {
#line 1574
          goto _L___3;
        }
      } else {
#line 1574
        goto _L___3;
      }
    }
  } else
  _L___3: /* CIL Label */
#line 1574
  if ((png_ptr->transformations & 0x800000U) != 0U) {
#line 1574
    tmp___12 = png_gamma_significant(png_ptr->screen_gamma);
#line 1574
    if (tmp___12 != 0) {
      _L___1: /* CIL Label */
#line 1588
      png_build_gamma_table(png_ptr, (int )png_ptr->bit_depth);
#line 1591
      if ((png_ptr->transformations & 0x0080U) != 0U) {
#line 1599
        if ((png_ptr->transformations & 0x600000U) != 0U) {
#line 1600
          png_warning((png_const_structrp )png_ptr, (png_const_charp )"libpng does not support gamma+background+rgb_to_gray");
        }
#line 1603
        if (((int )png_ptr->color_type == 3) != 0) {
#line 1609
          palette = png_ptr->palette;
#line 1610
          num_palette = (int )png_ptr->num_palette;
#line 1612
          if ((int )png_ptr->background_gamma_type == 2) {
#line 1615
            back.red = *(png_ptr->gamma_table + png_ptr->background.red);
#line 1616
            back.green = *(png_ptr->gamma_table + png_ptr->background.green);
#line 1617
            back.blue = *(png_ptr->gamma_table + png_ptr->background.blue);
#line 1619
            back_1.red = *(png_ptr->gamma_to_1 + png_ptr->background.red);
#line 1620
            back_1.green = *(png_ptr->gamma_to_1 + png_ptr->background.green);
#line 1621
            back_1.blue = *(png_ptr->gamma_to_1 + png_ptr->background.blue);
          } else {
            {
#line 1629
            if ((int )png_ptr->background_gamma_type == 1) {
#line 1629
              goto case_1;
            }
#line 1634
            if ((int )png_ptr->background_gamma_type == 2) {
#line 1634
              goto case_2;
            }
#line 1640
            if ((int )png_ptr->background_gamma_type == 3) {
#line 1640
              goto case_3;
            }
#line 1645
            goto switch_default;
            case_1: /* CIL Label */
#line 1630
            g = png_ptr->screen_gamma;
#line 1631
            gs = 100000;
#line 1632
            goto switch_break;
            case_2: /* CIL Label */
#line 1635
            g = png_reciprocal(png_ptr->colorspace.gamma);
#line 1636
            gs = png_reciprocal2(png_ptr->colorspace.gamma, png_ptr->screen_gamma);
#line 1638
            goto switch_break;
            case_3: /* CIL Label */
#line 1641
            g = png_reciprocal(png_ptr->background_gamma);
#line 1642
            gs = png_reciprocal2(png_ptr->background_gamma, png_ptr->screen_gamma);
#line 1644
            goto switch_break;
            switch_default: /* CIL Label */
#line 1646
            g = 100000;
#line 1647
            gs = 100000;
#line 1648
            goto switch_break;
            switch_break: /* CIL Label */ ;
            }
#line 1651
            tmp___1 = png_gamma_significant(gs);
#line 1651
            if (tmp___1 != 0) {
#line 1653
              back.red = png_gamma_8bit_correct((unsigned int )png_ptr->background.red,
                                                gs);
#line 1655
              back.green = png_gamma_8bit_correct((unsigned int )png_ptr->background.green,
                                                  gs);
#line 1657
              back.blue = png_gamma_8bit_correct((unsigned int )png_ptr->background.blue,
                                                 gs);
            } else {
#line 1663
              back.red = (png_byte )png_ptr->background.red;
#line 1664
              back.green = (png_byte )png_ptr->background.green;
#line 1665
              back.blue = (png_byte )png_ptr->background.blue;
            }
#line 1668
            tmp___2 = png_gamma_significant(g);
#line 1668
            if (tmp___2 != 0) {
#line 1670
              back_1.red = png_gamma_8bit_correct((unsigned int )png_ptr->background.red,
                                                  g);
#line 1672
              back_1.green = png_gamma_8bit_correct((unsigned int )png_ptr->background.green,
                                                    g);
#line 1674
              back_1.blue = png_gamma_8bit_correct((unsigned int )png_ptr->background.blue,
                                                   g);
            } else {
#line 1680
              back_1.red = (png_byte )png_ptr->background.red;
#line 1681
              back_1.green = (png_byte )png_ptr->background.green;
#line 1682
              back_1.blue = (png_byte )png_ptr->background.blue;
            }
          }
#line 1686
          i = 0;
          {
#line 1686
          while (1) {
            while_continue: /* CIL Label */ ;
#line 1686
            if (! (i < num_palette)) {
#line 1686
              goto while_break;
            }
#line 1688
            if (i < (int )png_ptr->num_trans) {
#line 1688
              if ((int )*(png_ptr->trans_alpha + i) != 0xff) {
#line 1691
                if ((int )*(png_ptr->trans_alpha + i) == 0) {
#line 1693
                  *(palette + i) = back;
                } else {
#line 1699
                  v = *(png_ptr->gamma_to_1 + (palette + i)->red);
#line 1700
                  temp = (png_uint_16 )(((int )((png_uint_16 )v) * (int )((png_uint_16 )*(png_ptr->trans_alpha + i)) + (int )((png_uint_16 )back_1.red) * (int )((png_uint_16 )(255 - (int )((png_uint_16 )*(png_ptr->trans_alpha + i))))) + 128);
#line 1700
                  w = (png_byte )((((int )temp + ((int )temp >> 8)) >> 8) & 0xff);
#line 1701
                  (palette + i)->red = *(png_ptr->gamma_from_1 + w);
#line 1703
                  v = *(png_ptr->gamma_to_1 + (palette + i)->green);
#line 1704
                  temp___0 = (png_uint_16 )(((int )((png_uint_16 )v) * (int )((png_uint_16 )*(png_ptr->trans_alpha + i)) + (int )((png_uint_16 )back_1.green) * (int )((png_uint_16 )(255 - (int )((png_uint_16 )*(png_ptr->trans_alpha + i))))) + 128);
#line 1704
                  w = (png_byte )((((int )temp___0 + ((int )temp___0 >> 8)) >> 8) & 0xff);
#line 1705
                  (palette + i)->green = *(png_ptr->gamma_from_1 + w);
#line 1707
                  v = *(png_ptr->gamma_to_1 + (palette + i)->blue);
#line 1708
                  temp___1 = (png_uint_16 )(((int )((png_uint_16 )v) * (int )((png_uint_16 )*(png_ptr->trans_alpha + i)) + (int )((png_uint_16 )back_1.blue) * (int )((png_uint_16 )(255 - (int )((png_uint_16 )*(png_ptr->trans_alpha + i))))) + 128);
#line 1708
                  w = (png_byte )((((int )temp___1 + ((int )temp___1 >> 8)) >> 8) & 0xff);
#line 1709
                  (palette + i)->blue = *(png_ptr->gamma_from_1 + w);
                }
              } else {
#line 1714
                (palette + i)->red = *(png_ptr->gamma_table + (palette + i)->red);
#line 1715
                (palette + i)->green = *(png_ptr->gamma_table + (palette + i)->green);
#line 1716
                (palette + i)->blue = *(png_ptr->gamma_table + (palette + i)->blue);
              }
            } else {
#line 1714
              (palette + i)->red = *(png_ptr->gamma_table + (palette + i)->red);
#line 1715
              (palette + i)->green = *(png_ptr->gamma_table + (palette + i)->green);
#line 1716
              (palette + i)->blue = *(png_ptr->gamma_table + (palette + i)->blue);
            }
#line 1686
            i ++;
          }
          while_break: /* CIL Label */ ;
          }
#line 1726
          png_ptr->transformations &= 4294958975U;
        } else {
#line 1733
          g___0 = 100000;
#line 1734
          gs___0 = 100000;
          {
#line 1738
          if ((int )png_ptr->background_gamma_type == 1) {
#line 1738
            goto case_1___0;
          }
#line 1743
          if ((int )png_ptr->background_gamma_type == 2) {
#line 1743
            goto case_2___0;
          }
#line 1749
          if ((int )png_ptr->background_gamma_type == 3) {
#line 1749
            goto case_3___0;
          }
#line 1755
          goto switch_default___0;
          case_1___0: /* CIL Label */
#line 1739
          g___0 = png_ptr->screen_gamma;
#line 1741
          goto switch_break___0;
          case_2___0: /* CIL Label */
#line 1744
          g___0 = png_reciprocal(png_ptr->colorspace.gamma);
#line 1745
          gs___0 = png_reciprocal2(png_ptr->colorspace.gamma, png_ptr->screen_gamma);
#line 1747
          goto switch_break___0;
          case_3___0: /* CIL Label */
#line 1750
          g___0 = png_reciprocal(png_ptr->background_gamma);
#line 1751
          gs___0 = png_reciprocal2(png_ptr->background_gamma, png_ptr->screen_gamma);
#line 1753
          goto switch_break___0;
          switch_default___0: /* CIL Label */
#line 1756
          png_error((png_const_structrp )png_ptr, (png_const_charp )"invalid background gamma type");
          switch_break___0: /* CIL Label */ ;
          }
#line 1759
          g_sig = png_gamma_significant(g___0);
#line 1760
          gs_sig = png_gamma_significant(gs___0);
#line 1762
          if (g_sig != 0) {
#line 1763
            png_ptr->background_1.gray = png_gamma_correct(png_ptr, (unsigned int )png_ptr->background.gray,
                                                           g___0);
          }
#line 1766
          if (gs_sig != 0) {
#line 1767
            png_ptr->background.gray = png_gamma_correct(png_ptr, (unsigned int )png_ptr->background.gray,
                                                         gs___0);
          }
#line 1770
          if ((int )png_ptr->background.red != (int )png_ptr->background.green) {
#line 1770
            goto _L;
          } else
#line 1770
          if ((int )png_ptr->background.red != (int )png_ptr->background.blue) {
#line 1770
            goto _L;
          } else
#line 1770
          if ((int )png_ptr->background.red != (int )png_ptr->background.gray) {
            _L: /* CIL Label */
#line 1775
            if (g_sig != 0) {
#line 1777
              png_ptr->background_1.red = png_gamma_correct(png_ptr, (unsigned int )png_ptr->background.red,
                                                            g___0);
#line 1780
              png_ptr->background_1.green = png_gamma_correct(png_ptr, (unsigned int )png_ptr->background.green,
                                                              g___0);
#line 1783
              png_ptr->background_1.blue = png_gamma_correct(png_ptr, (unsigned int )png_ptr->background.blue,
                                                             g___0);
            }
#line 1787
            if (gs_sig != 0) {
#line 1789
              png_ptr->background.red = png_gamma_correct(png_ptr, (unsigned int )png_ptr->background.red,
                                                          gs___0);
#line 1792
              png_ptr->background.green = png_gamma_correct(png_ptr, (unsigned int )png_ptr->background.green,
                                                            gs___0);
#line 1795
              png_ptr->background.blue = png_gamma_correct(png_ptr, (unsigned int )png_ptr->background.blue,
                                                           gs___0);
            }
          } else {
#line 1803
            tmp___4 = png_ptr->background_1.gray;
#line 1803
            png_ptr->background_1.blue = tmp___4;
#line 1803
            tmp___3 = tmp___4;
#line 1803
            png_ptr->background_1.green = tmp___3;
#line 1803
            png_ptr->background_1.red = tmp___3;
#line 1806
            tmp___6 = png_ptr->background.gray;
#line 1806
            png_ptr->background.blue = tmp___6;
#line 1806
            tmp___5 = tmp___6;
#line 1806
            png_ptr->background.green = tmp___5;
#line 1806
            png_ptr->background.red = tmp___5;
          }
#line 1811
          png_ptr->background_gamma_type = (png_byte )1;
        }
      } else
#line 1818
      if ((int )png_ptr->color_type == 3) {
#line 1818
        if ((png_ptr->transformations & 0x1000U) == 0U) {
#line 1818
          goto _L___0;
        } else
#line 1818
        if ((png_ptr->transformations & 0x600000U) == 0U) {
          _L___0: /* CIL Label */
#line 1826
          palette___0 = png_ptr->palette;
#line 1827
          num_palette___0 = (int )png_ptr->num_palette;
#line 1833
          i___0 = 0;
          {
#line 1833
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1833
            if (! (i___0 < num_palette___0)) {
#line 1833
              goto while_break___0;
            }
#line 1835
            (palette___0 + i___0)->red = *(png_ptr->gamma_table + (palette___0 + i___0)->red);
#line 1836
            (palette___0 + i___0)->green = *(png_ptr->gamma_table + (palette___0 + i___0)->green);
#line 1837
            (palette___0 + i___0)->blue = *(png_ptr->gamma_table + (palette___0 + i___0)->blue);
#line 1833
            i___0 ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 1841
          png_ptr->transformations &= 4294959103U;
        }
      }
    } else {
#line 1574
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */
#line 1851
  if ((png_ptr->transformations & 0x0080U) != 0U) {
#line 1851
    if ((int )png_ptr->color_type == 3) {
#line 1855
      istop = (int )png_ptr->num_trans;
#line 1857
      palette___1 = png_ptr->palette;
#line 1859
      back___0.red = (png_byte )png_ptr->background.red;
#line 1860
      back___0.green = (png_byte )png_ptr->background.green;
#line 1861
      back___0.blue = (png_byte )png_ptr->background.blue;
#line 1863
      i___1 = 0;
      {
#line 1863
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1863
        if (! (i___1 < istop)) {
#line 1863
          goto while_break___1;
        }
#line 1865
        if ((int )*(png_ptr->trans_alpha + i___1) == 0) {
#line 1867
          *(palette___1 + i___1) = back___0;
        } else
#line 1870
        if ((int )*(png_ptr->trans_alpha + i___1) != 0xff) {
#line 1873
          temp___2 = (png_uint_16 )(((int )((png_uint_16 )(palette___1 + i___1)->red) * (int )((png_uint_16 )*(png_ptr->trans_alpha + i___1)) + (int )((png_uint_16 )back___0.red) * (int )((png_uint_16 )(255 - (int )((png_uint_16 )*(png_ptr->trans_alpha + i___1))))) + 128);
#line 1873
          (palette___1 + i___1)->red = (png_byte )((((int )temp___2 + ((int )temp___2 >> 8)) >> 8) & 0xff);
#line 1876
          temp___3 = (png_uint_16 )(((int )((png_uint_16 )(palette___1 + i___1)->green) * (int )((png_uint_16 )*(png_ptr->trans_alpha + i___1)) + (int )((png_uint_16 )back___0.green) * (int )((png_uint_16 )(255 - (int )((png_uint_16 )*(png_ptr->trans_alpha + i___1))))) + 128);
#line 1876
          (palette___1 + i___1)->green = (png_byte )((((int )temp___3 + ((int )temp___3 >> 8)) >> 8) & 0xff);
#line 1879
          temp___4 = (png_uint_16 )(((int )((png_uint_16 )(palette___1 + i___1)->blue) * (int )((png_uint_16 )*(png_ptr->trans_alpha + i___1)) + (int )((png_uint_16 )back___0.blue) * (int )((png_uint_16 )(255 - (int )((png_uint_16 )*(png_ptr->trans_alpha + i___1))))) + 128);
#line 1879
          (palette___1 + i___1)->blue = (png_byte )((((int )temp___4 + ((int )temp___4 >> 8)) >> 8) & 0xff);
        }
#line 1863
        i___1 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1884
      png_ptr->transformations &= 4294967167U;
    }
  }
#line 1889
  if ((png_ptr->transformations & 0x0008U) != 0U) {
#line 1889
    if ((png_ptr->transformations & 0x1000U) == 0U) {
#line 1889
      if ((int )png_ptr->color_type == 3) {
#line 1894
        istop___0 = (int )png_ptr->num_palette;
#line 1895
        shift = 8 - (int )png_ptr->sig_bit.red;
#line 1897
        png_ptr->transformations &= 4294967287U;
#line 1903
        if (shift > 0) {
#line 1903
          if (shift < 8) {
#line 1904
            i___2 = 0;
            {
#line 1904
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 1904
              if (! (i___2 < istop___0)) {
#line 1904
                goto while_break___2;
              }
#line 1906
              component = (int )(png_ptr->palette + i___2)->red;
#line 1908
              component >>= shift;
#line 1909
              (png_ptr->palette + i___2)->red = (png_byte )component;
#line 1904
              i___2 ++;
            }
            while_break___2: /* CIL Label */ ;
            }
          }
        }
#line 1912
        shift = 8 - (int )png_ptr->sig_bit.green;
#line 1913
        if (shift > 0) {
#line 1913
          if (shift < 8) {
#line 1914
            i___2 = 0;
            {
#line 1914
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 1914
              if (! (i___2 < istop___0)) {
#line 1914
                goto while_break___3;
              }
#line 1916
              component___0 = (int )(png_ptr->palette + i___2)->green;
#line 1918
              component___0 >>= shift;
#line 1919
              (png_ptr->palette + i___2)->green = (png_byte )component___0;
#line 1914
              i___2 ++;
            }
            while_break___3: /* CIL Label */ ;
            }
          }
        }
#line 1922
        shift = 8 - (int )png_ptr->sig_bit.blue;
#line 1923
        if (shift > 0) {
#line 1923
          if (shift < 8) {
#line 1924
            i___2 = 0;
            {
#line 1924
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 1924
              if (! (i___2 < istop___0)) {
#line 1924
                goto while_break___4;
              }
#line 1926
              component___1 = (int )(png_ptr->palette + i___2)->blue;
#line 1928
              component___1 >>= shift;
#line 1929
              (png_ptr->palette + i___2)->blue = (png_byte )component___1;
#line 1924
              i___2 ++;
            }
            while_break___4: /* CIL Label */ ;
            }
          }
        }
      }
    }
  }
#line 1933
  return;
}
}
#line 1939 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
void png_read_transform_info(png_structrp png_ptr , png_inforp info_ptr )
{


  {
#line 1945
  if ((png_ptr->transformations & 0x1000U) != 0U) {
#line 1947
    if ((int )info_ptr->color_type == 3) {
#line 1953
      if ((int )png_ptr->num_trans > 0) {
#line 1954
        info_ptr->color_type = (png_byte )6;
      } else {
#line 1957
        info_ptr->color_type = (png_byte )2;
      }
#line 1959
      info_ptr->bit_depth = (png_byte )8;
#line 1960
      info_ptr->num_trans = (png_uint_16 )0;
#line 1962
      if ((unsigned long )png_ptr->palette == (unsigned long )((void *)0)) {
#line 1963
        png_error((png_const_structrp )png_ptr, (png_const_charp )"Palette is NULL in indexed image");
      }
    } else {
#line 1967
      if ((int )png_ptr->num_trans != 0) {
#line 1969
        if ((png_ptr->transformations & 0x2000000U) != 0U) {
#line 1970
          info_ptr->color_type = (png_byte )((int )info_ptr->color_type | 4);
        }
      }
#line 1972
      if ((int )info_ptr->bit_depth < 8) {
#line 1973
        info_ptr->bit_depth = (png_byte )8;
      }
#line 1975
      info_ptr->num_trans = (png_uint_16 )0;
    }
  }
#line 1985
  if ((png_ptr->transformations & 0x0080U) != 0U) {
#line 1986
    info_ptr->background = png_ptr->background;
  }
#line 1999
  info_ptr->colorspace.gamma = png_ptr->colorspace.gamma;
#line 2002
  if ((int )info_ptr->bit_depth == 16) {
#line 2006
    if ((png_ptr->transformations & 0x4000000U) != 0U) {
#line 2007
      info_ptr->bit_depth = (png_byte )8;
    }
#line 2011
    if ((png_ptr->transformations & 0x0400U) != 0U) {
#line 2012
      info_ptr->bit_depth = (png_byte )8;
    }
  }
#line 2041
  if ((png_ptr->transformations & 0x4000U) != 0U) {
#line 2042
    info_ptr->color_type = (png_byte )((int )info_ptr->color_type | 2);
  }
#line 2047
  if ((png_ptr->transformations & 0x600000U) != 0U) {
#line 2048
    info_ptr->color_type = (png_byte )((int )info_ptr->color_type & -3);
  }
#line 2053
  if ((png_ptr->transformations & 0x0040U) != 0U) {
#line 2055
    if ((int )info_ptr->color_type == 2) {
#line 2055
      goto _L;
    } else
#line 2055
    if ((int )info_ptr->color_type == 6) {
      _L: /* CIL Label */
#line 2055
      if ((unsigned long )png_ptr->palette_lookup != (unsigned long )((png_bytep )0)) {
#line 2055
        if ((int )info_ptr->bit_depth == 8) {
#line 2059
          info_ptr->color_type = (png_byte )3;
        }
      }
    }
  }
#line 2065
  if ((png_ptr->transformations & 0x0200U) != 0U) {
#line 2065
    if ((int )info_ptr->bit_depth == 8) {
#line 2065
      if ((int )info_ptr->color_type != 3) {
#line 2069
        info_ptr->bit_depth = (png_byte )16;
      }
    }
  }
#line 2074
  if ((png_ptr->transformations & 0x0004U) != 0U) {
#line 2074
    if ((int )info_ptr->bit_depth < 8) {
#line 2076
      info_ptr->bit_depth = (png_byte )8;
    }
  }
#line 2079
  if ((int )info_ptr->color_type == 3) {
#line 2080
    info_ptr->channels = (png_byte )1;
  } else
#line 2082
  if (((int )info_ptr->color_type & 2) != 0) {
#line 2083
    info_ptr->channels = (png_byte )3;
  } else {
#line 2086
    info_ptr->channels = (png_byte )1;
  }
#line 2089
  if ((png_ptr->transformations & 0x40000U) != 0U) {
#line 2091
    info_ptr->color_type = (png_byte )((int )info_ptr->color_type & -5);
#line 2093
    info_ptr->num_trans = (png_uint_16 )0;
  }
#line 2097
  if (((int )info_ptr->color_type & 4) != 0) {
#line 2098
    info_ptr->channels = (png_byte )((int )info_ptr->channels + 1);
  }
#line 2102
  if ((png_ptr->transformations & 0x8000U) != 0U) {
#line 2102
    if ((int )info_ptr->color_type == 2) {
#line 2102
      goto _L___0;
    } else
#line 2102
    if ((int )info_ptr->color_type == 0) {
      _L___0: /* CIL Label */
#line 2106
      info_ptr->channels = (png_byte )((int )info_ptr->channels + 1);
#line 2108
      if ((png_ptr->transformations & 0x1000000U) != 0U) {
#line 2109
        info_ptr->color_type = (png_byte )((int )info_ptr->color_type | 4);
      }
    }
  }
#line 2115
  if ((png_ptr->transformations & 0x100000U) != 0U) {
#line 2117
    if ((int )png_ptr->user_transform_depth != 0) {
#line 2118
      info_ptr->bit_depth = png_ptr->user_transform_depth;
    }
#line 2120
    if ((int )png_ptr->user_transform_channels != 0) {
#line 2121
      info_ptr->channels = png_ptr->user_transform_channels;
    }
  }
#line 2125
  info_ptr->pixel_depth = (png_byte )((int )info_ptr->channels * (int )info_ptr->bit_depth);
#line 2128
  if ((int )info_ptr->pixel_depth >= 8) {
#line 2128
    info_ptr->rowbytes = (size_t )info_ptr->width * ((size_t )info_ptr->pixel_depth >> 3);
  } else {
#line 2128
    info_ptr->rowbytes = ((size_t )info_ptr->width * (size_t )info_ptr->pixel_depth + 7UL) >> 3;
  }
#line 2136
  png_ptr->info_rowbytes = info_ptr->rowbytes;
#line 2142
  return;
}
}
#line 2151 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
static void png_do_unpack(png_row_infop row_info , png_bytep row )
{
  png_uint_32 i ;
  png_uint_32 row_width ;
  png_bytep sp ;
  png_bytep dp ;
  png_uint_32 shift ;
  png_bytep sp___0 ;
  png_bytep dp___0 ;
  png_uint_32 shift___0 ;
  png_bytep sp___1 ;
  png_bytep dp___1 ;
  png_uint_32 shift___1 ;

  {
#line 2156
  if ((int )row_info->bit_depth < 8) {
#line 2159
    row_width = row_info->width;
    {
#line 2163
    if ((int )row_info->bit_depth == 1) {
#line 2163
      goto case_1;
    }
#line 2186
    if ((int )row_info->bit_depth == 2) {
#line 2186
      goto case_2;
    }
#line 2210
    if ((int )row_info->bit_depth == 4) {
#line 2210
      goto case_4;
    }
#line 2233
    goto switch_default;
    case_1: /* CIL Label */
#line 2165
    sp = row + (size_t )((row_width - 1U) >> 3);
#line 2166
    dp = (row + (size_t )row_width) - 1;
#line 2167
    shift = 7U - ((row_width + 7U) & 7U);
#line 2168
    i = (png_uint_32 )0;
    {
#line 2168
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2168
      if (! (i < row_width)) {
#line 2168
        goto while_break;
      }
#line 2170
      *dp = (png_byte )(((int )*sp >> shift) & 0x01);
#line 2172
      if (shift == 7U) {
#line 2174
        shift = (png_uint_32 )0;
#line 2175
        sp --;
      } else {
#line 2179
        shift ++;
      }
#line 2181
      dp --;
#line 2168
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 2183
    goto switch_break;
    case_2: /* CIL Label */
#line 2189
    sp___0 = row + (size_t )((row_width - 1U) >> 2);
#line 2190
    dp___0 = (row + (size_t )row_width) - 1;
#line 2191
    shift___0 = (3U - ((row_width + 3U) & 3U)) << 1;
#line 2192
    i = (png_uint_32 )0;
    {
#line 2192
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2192
      if (! (i < row_width)) {
#line 2192
        goto while_break___0;
      }
#line 2194
      *dp___0 = (png_byte )(((int )*sp___0 >> shift___0) & 0x03);
#line 2196
      if (shift___0 == 6U) {
#line 2198
        shift___0 = (png_uint_32 )0;
#line 2199
        sp___0 --;
      } else {
#line 2203
        shift___0 += 2U;
      }
#line 2205
      dp___0 --;
#line 2192
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2207
    goto switch_break;
    case_4: /* CIL Label */
#line 2212
    sp___1 = row + (size_t )((row_width - 1U) >> 1);
#line 2213
    dp___1 = (row + (size_t )row_width) - 1;
#line 2214
    shift___1 = (1U - ((row_width + 1U) & 1U)) << 2;
#line 2215
    i = (png_uint_32 )0;
    {
#line 2215
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2215
      if (! (i < row_width)) {
#line 2215
        goto while_break___1;
      }
#line 2217
      *dp___1 = (png_byte )(((int )*sp___1 >> shift___1) & 0x0f);
#line 2219
      if (shift___1 == 4U) {
#line 2221
        shift___1 = (png_uint_32 )0;
#line 2222
        sp___1 --;
      } else {
#line 2226
        shift___1 = (png_uint_32 )4;
      }
#line 2228
      dp___1 --;
#line 2215
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2230
    goto switch_break;
    switch_default: /* CIL Label */
#line 2234
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2236
    row_info->bit_depth = (png_byte )8;
#line 2237
    row_info->pixel_depth = (png_byte )(8 * (int )row_info->channels);
#line 2238
    row_info->rowbytes = (size_t )(row_width * (png_uint_32 )row_info->channels);
  }
#line 2240
  return;
}
}
#line 2249 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
static void png_do_unshift(png_row_infop row_info , png_bytep row , png_const_color_8p sig_bits )
{
  int color_type ;
  int shift[4] ;
  int channels ;
  int bit_depth ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int c ;
  int have_shift ;
  png_bytep bp ;
  png_bytep bp_end ;
  int b ;
  png_bytep tmp___4 ;
  png_bytep bp___0 ;
  png_bytep bp_end___0 ;
  int gray_shift ;
  int mask ;
  int b___0 ;
  png_bytep tmp___5 ;
  png_bytep bp___1 ;
  png_bytep bp_end___1 ;
  int channel ;
  int b___1 ;
  png_bytep tmp___6 ;
  png_bytep bp___2 ;
  png_bytep bp_end___2 ;
  int channel___0 ;
  int value ;
  png_bytep tmp___7 ;
  png_bytep tmp___8 ;

  {
#line 2258
  color_type = (int )row_info->color_type;
#line 2260
  if (color_type != 3) {
#line 2263
    channels = 0;
#line 2264
    bit_depth = (int )row_info->bit_depth;
#line 2266
    if ((color_type & 2) != 0) {
#line 2268
      tmp = channels;
#line 2268
      channels ++;
#line 2268
      shift[tmp] = bit_depth - (int )sig_bits->red;
#line 2269
      tmp___0 = channels;
#line 2269
      channels ++;
#line 2269
      shift[tmp___0] = bit_depth - (int )sig_bits->green;
#line 2270
      tmp___1 = channels;
#line 2270
      channels ++;
#line 2270
      shift[tmp___1] = bit_depth - (int )sig_bits->blue;
    } else {
#line 2275
      tmp___2 = channels;
#line 2275
      channels ++;
#line 2275
      shift[tmp___2] = bit_depth - (int )sig_bits->gray;
    }
#line 2278
    if ((color_type & 4) != 0) {
#line 2280
      tmp___3 = channels;
#line 2280
      channels ++;
#line 2280
      shift[tmp___3] = bit_depth - (int )sig_bits->alpha;
    }
#line 2286
    have_shift = 0;
#line 2286
    c = have_shift;
    {
#line 2286
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2286
      if (! (c < channels)) {
#line 2286
        goto while_break;
      }
#line 2291
      if (shift[c] <= 0) {
#line 2292
        shift[c] = 0;
      } else
#line 2291
      if (shift[c] >= bit_depth) {
#line 2292
        shift[c] = 0;
      } else {
#line 2295
        have_shift = 1;
      }
#line 2286
      c ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 2298
    if (have_shift == 0) {
#line 2299
      return;
    }
    {
#line 2309
    if (bit_depth == 2) {
#line 2309
      goto case_2;
    }
#line 2324
    if (bit_depth == 4) {
#line 2324
      goto case_4;
    }
#line 2343
    if (bit_depth == 8) {
#line 2343
      goto case_8;
    }
#line 2361
    if (bit_depth == 16) {
#line 2361
      goto case_16;
    }
#line 2304
    goto switch_default;
    switch_default: /* CIL Label */
#line 2307
    goto switch_break;
    case_2: /* CIL Label */
#line 2313
    bp = row;
#line 2314
    bp_end = bp + row_info->rowbytes;
    {
#line 2316
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2316
      if (! ((unsigned long )bp < (unsigned long )bp_end)) {
#line 2316
        goto while_break___0;
      }
#line 2318
      b = ((int )*bp >> 1) & 0x55;
#line 2319
      tmp___4 = bp;
#line 2319
      bp ++;
#line 2319
      *tmp___4 = (png_byte )b;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2321
    goto switch_break;
    case_4: /* CIL Label */
#line 2328
    bp___0 = row;
#line 2329
    bp_end___0 = bp___0 + row_info->rowbytes;
#line 2330
    gray_shift = shift[0];
#line 2331
    mask = 0xf >> gray_shift;
#line 2333
    mask |= mask << 4;
    {
#line 2335
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2335
      if (! ((unsigned long )bp___0 < (unsigned long )bp_end___0)) {
#line 2335
        goto while_break___1;
      }
#line 2337
      b___0 = ((int )*bp___0 >> gray_shift) & mask;
#line 2338
      tmp___5 = bp___0;
#line 2338
      bp___0 ++;
#line 2338
      *tmp___5 = (png_byte )b___0;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2340
    goto switch_break;
    case_8: /* CIL Label */
#line 2346
    bp___1 = row;
#line 2347
    bp_end___1 = bp___1 + row_info->rowbytes;
#line 2348
    channel = 0;
    {
#line 2350
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2350
      if (! ((unsigned long )bp___1 < (unsigned long )bp_end___1)) {
#line 2350
        goto while_break___2;
      }
#line 2352
      b___1 = (int )*bp___1 >> shift[channel];
#line 2353
      channel ++;
#line 2353
      if (channel >= channels) {
#line 2354
        channel = 0;
      }
#line 2355
      tmp___6 = bp___1;
#line 2355
      bp___1 ++;
#line 2355
      *tmp___6 = (png_byte )b___1;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2357
    goto switch_break;
    case_16: /* CIL Label */
#line 2364
    bp___2 = row;
#line 2365
    bp_end___2 = bp___2 + row_info->rowbytes;
#line 2366
    channel___0 = 0;
    {
#line 2368
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2368
      if (! ((unsigned long )bp___2 < (unsigned long )bp_end___2)) {
#line 2368
        goto while_break___3;
      }
#line 2370
      value = ((int )*(bp___2 + 0) << 8) + (int )*(bp___2 + 1);
#line 2372
      value >>= shift[channel___0];
#line 2373
      channel___0 ++;
#line 2373
      if (channel___0 >= channels) {
#line 2374
        channel___0 = 0;
      }
#line 2375
      tmp___7 = bp___2;
#line 2375
      bp___2 ++;
#line 2375
      *tmp___7 = (png_byte )(value >> 8);
#line 2376
      tmp___8 = bp___2;
#line 2376
      bp___2 ++;
#line 2376
      *tmp___8 = (png_byte )value;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2378
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 2383
  return;
}
}
#line 2388 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
static void png_do_scale_16_to_8(png_row_infop row_info , png_bytep row )
{
  png_bytep sp ;
  png_bytep dp ;
  png_bytep ep ;
  png_int_32 tmp ;
  png_bytep tmp___0 ;
  png_bytep tmp___1 ;
  png_bytep tmp___2 ;

  {
#line 2393
  if ((int )row_info->bit_depth == 16) {
#line 2395
    sp = row;
#line 2396
    dp = row;
#line 2397
    ep = sp + row_info->rowbytes;
    {
#line 2399
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2399
      if (! ((unsigned long )sp < (unsigned long )ep)) {
#line 2399
        goto while_break;
      }
#line 2433
      tmp___0 = sp;
#line 2433
      sp ++;
#line 2433
      tmp = (png_int_32 )*tmp___0;
#line 2434
      tmp___1 = sp;
#line 2434
      sp ++;
#line 2434
      tmp += (((int )*tmp___1 - tmp) + 128) * 65535 >> 24;
#line 2435
      tmp___2 = dp;
#line 2435
      dp ++;
#line 2435
      *tmp___2 = (png_byte )tmp;
    }
    while_break: /* CIL Label */ ;
    }
#line 2438
    row_info->bit_depth = (png_byte )8;
#line 2439
    row_info->pixel_depth = (png_byte )(8 * (int )row_info->channels);
#line 2440
    row_info->rowbytes = (size_t )(row_info->width * (png_uint_32 )row_info->channels);
  }
#line 2442
  return;
}
}
#line 2446 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
static void png_do_chop(png_row_infop row_info , png_bytep row )
{
  png_bytep sp ;
  png_bytep dp ;
  png_bytep ep ;
  png_bytep tmp ;

  {
#line 2454
  if ((int )row_info->bit_depth == 16) {
#line 2456
    sp = row;
#line 2457
    dp = row;
#line 2458
    ep = sp + row_info->rowbytes;
    {
#line 2460
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2460
      if (! ((unsigned long )sp < (unsigned long )ep)) {
#line 2460
        goto while_break;
      }
#line 2462
      tmp = dp;
#line 2462
      dp ++;
#line 2462
      *tmp = *sp;
#line 2463
      sp += 2;
    }
    while_break: /* CIL Label */ ;
    }
#line 2466
    row_info->bit_depth = (png_byte )8;
#line 2467
    row_info->pixel_depth = (png_byte )(8 * (int )row_info->channels);
#line 2468
    row_info->rowbytes = (size_t )(row_info->width * (png_uint_32 )row_info->channels);
  }
#line 2470
  return;
}
}
#line 2474 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
static void png_do_read_swap_alpha(png_row_infop row_info , png_bytep row )
{
  png_uint_32 row_width ;
  png_bytep sp ;
  png_bytep dp ;
  png_byte save ;
  png_uint_32 i ;
  png_bytep sp___0 ;
  png_bytep dp___0 ;
  png_byte save___0[2] ;
  png_uint_32 i___0 ;
  png_bytep sp___1 ;
  png_bytep dp___1 ;
  png_byte save___1 ;
  png_uint_32 i___1 ;
  png_bytep sp___2 ;
  png_bytep dp___2 ;
  png_byte save___2[2] ;
  png_uint_32 i___2 ;

  {
#line 2477
  row_width = row_info->width;
#line 2481
  if ((int )row_info->color_type == 6) {
#line 2484
    if ((int )row_info->bit_depth == 8) {
#line 2486
      sp = row + row_info->rowbytes;
#line 2487
      dp = sp;
#line 2491
      i = (png_uint_32 )0;
      {
#line 2491
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2491
        if (! (i < row_width)) {
#line 2491
          goto while_break;
        }
#line 2493
        sp --;
#line 2493
        save = *sp;
#line 2494
        dp --;
#line 2494
        sp --;
#line 2494
        *dp = *sp;
#line 2495
        dp --;
#line 2495
        sp --;
#line 2495
        *dp = *sp;
#line 2496
        dp --;
#line 2496
        sp --;
#line 2496
        *dp = *sp;
#line 2497
        dp --;
#line 2497
        *dp = save;
#line 2491
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 2505
      sp___0 = row + row_info->rowbytes;
#line 2506
      dp___0 = sp___0;
#line 2510
      i___0 = (png_uint_32 )0;
      {
#line 2510
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2510
        if (! (i___0 < row_width)) {
#line 2510
          goto while_break___0;
        }
#line 2512
        sp___0 --;
#line 2512
        save___0[0] = *sp___0;
#line 2513
        sp___0 --;
#line 2513
        save___0[1] = *sp___0;
#line 2514
        dp___0 --;
#line 2514
        sp___0 --;
#line 2514
        *dp___0 = *sp___0;
#line 2515
        dp___0 --;
#line 2515
        sp___0 --;
#line 2515
        *dp___0 = *sp___0;
#line 2516
        dp___0 --;
#line 2516
        sp___0 --;
#line 2516
        *dp___0 = *sp___0;
#line 2517
        dp___0 --;
#line 2517
        sp___0 --;
#line 2517
        *dp___0 = *sp___0;
#line 2518
        dp___0 --;
#line 2518
        sp___0 --;
#line 2518
        *dp___0 = *sp___0;
#line 2519
        dp___0 --;
#line 2519
        sp___0 --;
#line 2519
        *dp___0 = *sp___0;
#line 2520
        dp___0 --;
#line 2520
        *dp___0 = save___0[0];
#line 2521
        dp___0 --;
#line 2521
        *dp___0 = save___0[1];
#line 2510
        i___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else
#line 2527
  if ((int )row_info->color_type == 4) {
#line 2530
    if ((int )row_info->bit_depth == 8) {
#line 2532
      sp___1 = row + row_info->rowbytes;
#line 2533
      dp___1 = sp___1;
#line 2537
      i___1 = (png_uint_32 )0;
      {
#line 2537
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2537
        if (! (i___1 < row_width)) {
#line 2537
          goto while_break___1;
        }
#line 2539
        sp___1 --;
#line 2539
        save___1 = *sp___1;
#line 2540
        dp___1 --;
#line 2540
        sp___1 --;
#line 2540
        *dp___1 = *sp___1;
#line 2541
        dp___1 --;
#line 2541
        *dp___1 = save___1;
#line 2537
        i___1 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
#line 2549
      sp___2 = row + row_info->rowbytes;
#line 2550
      dp___2 = sp___2;
#line 2554
      i___2 = (png_uint_32 )0;
      {
#line 2554
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2554
        if (! (i___2 < row_width)) {
#line 2554
          goto while_break___2;
        }
#line 2556
        sp___2 --;
#line 2556
        save___2[0] = *sp___2;
#line 2557
        sp___2 --;
#line 2557
        save___2[1] = *sp___2;
#line 2558
        dp___2 --;
#line 2558
        sp___2 --;
#line 2558
        *dp___2 = *sp___2;
#line 2559
        dp___2 --;
#line 2559
        sp___2 --;
#line 2559
        *dp___2 = *sp___2;
#line 2560
        dp___2 --;
#line 2560
        *dp___2 = save___2[0];
#line 2561
        dp___2 --;
#line 2561
        *dp___2 = save___2[1];
#line 2554
        i___2 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
#line 2566
  return;
}
}
#line 2570 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
static void png_do_read_invert_alpha(png_row_infop row_info , png_bytep row )
{
  png_uint_32 row_width ;
  png_bytep sp ;
  png_bytep dp ;
  png_uint_32 i ;
  png_bytep sp___0 ;
  png_bytep dp___0 ;
  png_uint_32 i___0 ;
  png_bytep sp___1 ;
  png_bytep dp___1 ;
  png_uint_32 i___1 ;
  png_bytep sp___2 ;
  png_bytep dp___2 ;
  png_uint_32 i___2 ;

  {
#line 2576
  row_width = row_info->width;
#line 2577
  if ((int )row_info->color_type == 6) {
#line 2579
    if ((int )row_info->bit_depth == 8) {
#line 2582
      sp = row + row_info->rowbytes;
#line 2583
      dp = sp;
#line 2586
      i = (png_uint_32 )0;
      {
#line 2586
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2586
        if (! (i < row_width)) {
#line 2586
          goto while_break;
        }
#line 2588
        dp --;
#line 2588
        sp --;
#line 2588
        *dp = (png_byte )(255 - (int )*sp);
#line 2596
        sp -= 3;
#line 2597
        dp = sp;
#line 2586
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 2605
      sp___0 = row + row_info->rowbytes;
#line 2606
      dp___0 = sp___0;
#line 2609
      i___0 = (png_uint_32 )0;
      {
#line 2609
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2609
        if (! (i___0 < row_width)) {
#line 2609
          goto while_break___0;
        }
#line 2611
        dp___0 --;
#line 2611
        sp___0 --;
#line 2611
        *dp___0 = (png_byte )(255 - (int )*sp___0);
#line 2612
        dp___0 --;
#line 2612
        sp___0 --;
#line 2612
        *dp___0 = (png_byte )(255 - (int )*sp___0);
#line 2623
        sp___0 -= 6;
#line 2624
        dp___0 = sp___0;
#line 2609
        i___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else
#line 2629
  if ((int )row_info->color_type == 4) {
#line 2631
    if ((int )row_info->bit_depth == 8) {
#line 2634
      sp___1 = row + row_info->rowbytes;
#line 2635
      dp___1 = sp___1;
#line 2638
      i___1 = (png_uint_32 )0;
      {
#line 2638
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2638
        if (! (i___1 < row_width)) {
#line 2638
          goto while_break___1;
        }
#line 2640
        dp___1 --;
#line 2640
        sp___1 --;
#line 2640
        *dp___1 = (png_byte )(255 - (int )*sp___1);
#line 2641
        dp___1 --;
#line 2641
        sp___1 --;
#line 2641
        *dp___1 = *sp___1;
#line 2638
        i___1 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
#line 2649
      sp___2 = row + row_info->rowbytes;
#line 2650
      dp___2 = sp___2;
#line 2653
      i___2 = (png_uint_32 )0;
      {
#line 2653
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2653
        if (! (i___2 < row_width)) {
#line 2653
          goto while_break___2;
        }
#line 2655
        dp___2 --;
#line 2655
        sp___2 --;
#line 2655
        *dp___2 = (png_byte )(255 - (int )*sp___2);
#line 2656
        dp___2 --;
#line 2656
        sp___2 --;
#line 2656
        *dp___2 = (png_byte )(255 - (int )*sp___2);
#line 2661
        sp___2 -= 2;
#line 2662
        dp___2 = sp___2;
#line 2653
        i___2 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
#line 2667
  return;
}
}
#line 2672 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
static void png_do_read_filler(png_row_infop row_info , png_bytep row , png_uint_32 filler ,
                               png_uint_32 flags )
{
  png_uint_32 i ;
  png_uint_32 row_width ;
  png_byte hi_filler ;
  png_byte lo_filler ;
  png_bytep sp ;
  png_bytep dp ;
  png_bytep sp___0 ;
  png_bytep dp___0 ;
  png_bytep sp___1 ;
  png_bytep dp___1 ;
  png_bytep sp___2 ;
  png_bytep dp___2 ;
  png_bytep sp___3 ;
  png_bytep dp___3 ;
  png_bytep sp___4 ;
  png_bytep dp___4 ;
  png_bytep sp___5 ;
  png_bytep dp___5 ;
  png_bytep sp___6 ;
  png_bytep dp___6 ;

  {
#line 2677
  row_width = row_info->width;
#line 2680
  hi_filler = (png_byte )(filler >> 8);
#line 2682
  lo_filler = (png_byte )filler;
#line 2686
  if ((int )row_info->color_type == 0) {
#line 2689
    if ((int )row_info->bit_depth == 8) {
#line 2691
      if ((flags & 0x0080U) != 0U) {
#line 2694
        sp = row + (size_t )row_width;
#line 2695
        dp = sp + (size_t )row_width;
#line 2696
        i = (png_uint_32 )1;
        {
#line 2696
        while (1) {
          while_continue: /* CIL Label */ ;
#line 2696
          if (! (i < row_width)) {
#line 2696
            goto while_break;
          }
#line 2698
          dp --;
#line 2698
          *dp = lo_filler;
#line 2699
          dp --;
#line 2699
          sp --;
#line 2699
          *dp = *sp;
#line 2696
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 2701
        dp --;
#line 2701
        *dp = lo_filler;
#line 2702
        row_info->channels = (png_byte )2;
#line 2703
        row_info->pixel_depth = (png_byte )16;
#line 2704
        row_info->rowbytes = (size_t )(row_width * 2U);
      } else {
#line 2710
        sp___0 = row + (size_t )row_width;
#line 2711
        dp___0 = sp___0 + (size_t )row_width;
#line 2712
        i = (png_uint_32 )0;
        {
#line 2712
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2712
          if (! (i < row_width)) {
#line 2712
            goto while_break___0;
          }
#line 2714
          dp___0 --;
#line 2714
          sp___0 --;
#line 2714
          *dp___0 = *sp___0;
#line 2715
          dp___0 --;
#line 2715
          *dp___0 = lo_filler;
#line 2712
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 2717
        row_info->channels = (png_byte )2;
#line 2718
        row_info->pixel_depth = (png_byte )16;
#line 2719
        row_info->rowbytes = (size_t )(row_width * 2U);
      }
    } else
#line 2724
    if ((int )row_info->bit_depth == 16) {
#line 2726
      if ((flags & 0x0080U) != 0U) {
#line 2729
        sp___1 = row + (size_t )row_width * 2UL;
#line 2730
        dp___1 = sp___1 + (size_t )row_width * 2UL;
#line 2731
        i = (png_uint_32 )1;
        {
#line 2731
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2731
          if (! (i < row_width)) {
#line 2731
            goto while_break___1;
          }
#line 2733
          dp___1 --;
#line 2733
          *dp___1 = lo_filler;
#line 2734
          dp___1 --;
#line 2734
          *dp___1 = hi_filler;
#line 2735
          dp___1 --;
#line 2735
          sp___1 --;
#line 2735
          *dp___1 = *sp___1;
#line 2736
          dp___1 --;
#line 2736
          sp___1 --;
#line 2736
          *dp___1 = *sp___1;
#line 2731
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 2738
        dp___1 --;
#line 2738
        *dp___1 = lo_filler;
#line 2739
        dp___1 --;
#line 2739
        *dp___1 = hi_filler;
#line 2740
        row_info->channels = (png_byte )2;
#line 2741
        row_info->pixel_depth = (png_byte )32;
#line 2742
        row_info->rowbytes = (size_t )(row_width * 4U);
      } else {
#line 2748
        sp___2 = row + (size_t )row_width * 2UL;
#line 2749
        dp___2 = sp___2 + (size_t )row_width * 2UL;
#line 2750
        i = (png_uint_32 )0;
        {
#line 2750
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2750
          if (! (i < row_width)) {
#line 2750
            goto while_break___2;
          }
#line 2752
          dp___2 --;
#line 2752
          sp___2 --;
#line 2752
          *dp___2 = *sp___2;
#line 2753
          dp___2 --;
#line 2753
          sp___2 --;
#line 2753
          *dp___2 = *sp___2;
#line 2754
          dp___2 --;
#line 2754
          *dp___2 = lo_filler;
#line 2755
          dp___2 --;
#line 2755
          *dp___2 = hi_filler;
#line 2750
          i ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 2757
        row_info->channels = (png_byte )2;
#line 2758
        row_info->pixel_depth = (png_byte )32;
#line 2759
        row_info->rowbytes = (size_t )(row_width * 4U);
      }
    }
  } else
#line 2764
  if ((int )row_info->color_type == 2) {
#line 2766
    if ((int )row_info->bit_depth == 8) {
#line 2768
      if ((flags & 0x0080U) != 0U) {
#line 2771
        sp___3 = row + (size_t )row_width * 3UL;
#line 2772
        dp___3 = sp___3 + (size_t )row_width;
#line 2773
        i = (png_uint_32 )1;
        {
#line 2773
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 2773
          if (! (i < row_width)) {
#line 2773
            goto while_break___3;
          }
#line 2775
          dp___3 --;
#line 2775
          *dp___3 = lo_filler;
#line 2776
          dp___3 --;
#line 2776
          sp___3 --;
#line 2776
          *dp___3 = *sp___3;
#line 2777
          dp___3 --;
#line 2777
          sp___3 --;
#line 2777
          *dp___3 = *sp___3;
#line 2778
          dp___3 --;
#line 2778
          sp___3 --;
#line 2778
          *dp___3 = *sp___3;
#line 2773
          i ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 2780
        dp___3 --;
#line 2780
        *dp___3 = lo_filler;
#line 2781
        row_info->channels = (png_byte )4;
#line 2782
        row_info->pixel_depth = (png_byte )32;
#line 2783
        row_info->rowbytes = (size_t )(row_width * 4U);
      } else {
#line 2789
        sp___4 = row + (size_t )row_width * 3UL;
#line 2790
        dp___4 = sp___4 + (size_t )row_width;
#line 2791
        i = (png_uint_32 )0;
        {
#line 2791
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 2791
          if (! (i < row_width)) {
#line 2791
            goto while_break___4;
          }
#line 2793
          dp___4 --;
#line 2793
          sp___4 --;
#line 2793
          *dp___4 = *sp___4;
#line 2794
          dp___4 --;
#line 2794
          sp___4 --;
#line 2794
          *dp___4 = *sp___4;
#line 2795
          dp___4 --;
#line 2795
          sp___4 --;
#line 2795
          *dp___4 = *sp___4;
#line 2796
          dp___4 --;
#line 2796
          *dp___4 = lo_filler;
#line 2791
          i ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 2798
        row_info->channels = (png_byte )4;
#line 2799
        row_info->pixel_depth = (png_byte )32;
#line 2800
        row_info->rowbytes = (size_t )(row_width * 4U);
      }
    } else
#line 2805
    if ((int )row_info->bit_depth == 16) {
#line 2807
      if ((flags & 0x0080U) != 0U) {
#line 2810
        sp___5 = row + (size_t )row_width * 6UL;
#line 2811
        dp___5 = sp___5 + (size_t )row_width * 2UL;
#line 2812
        i = (png_uint_32 )1;
        {
#line 2812
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 2812
          if (! (i < row_width)) {
#line 2812
            goto while_break___5;
          }
#line 2814
          dp___5 --;
#line 2814
          *dp___5 = lo_filler;
#line 2815
          dp___5 --;
#line 2815
          *dp___5 = hi_filler;
#line 2816
          dp___5 --;
#line 2816
          sp___5 --;
#line 2816
          *dp___5 = *sp___5;
#line 2817
          dp___5 --;
#line 2817
          sp___5 --;
#line 2817
          *dp___5 = *sp___5;
#line 2818
          dp___5 --;
#line 2818
          sp___5 --;
#line 2818
          *dp___5 = *sp___5;
#line 2819
          dp___5 --;
#line 2819
          sp___5 --;
#line 2819
          *dp___5 = *sp___5;
#line 2820
          dp___5 --;
#line 2820
          sp___5 --;
#line 2820
          *dp___5 = *sp___5;
#line 2821
          dp___5 --;
#line 2821
          sp___5 --;
#line 2821
          *dp___5 = *sp___5;
#line 2812
          i ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 2823
        dp___5 --;
#line 2823
        *dp___5 = lo_filler;
#line 2824
        dp___5 --;
#line 2824
        *dp___5 = hi_filler;
#line 2825
        row_info->channels = (png_byte )4;
#line 2826
        row_info->pixel_depth = (png_byte )64;
#line 2827
        row_info->rowbytes = (size_t )(row_width * 8U);
      } else {
#line 2833
        sp___6 = row + (size_t )row_width * 6UL;
#line 2834
        dp___6 = sp___6 + (size_t )row_width * 2UL;
#line 2835
        i = (png_uint_32 )0;
        {
#line 2835
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 2835
          if (! (i < row_width)) {
#line 2835
            goto while_break___6;
          }
#line 2837
          dp___6 --;
#line 2837
          sp___6 --;
#line 2837
          *dp___6 = *sp___6;
#line 2838
          dp___6 --;
#line 2838
          sp___6 --;
#line 2838
          *dp___6 = *sp___6;
#line 2839
          dp___6 --;
#line 2839
          sp___6 --;
#line 2839
          *dp___6 = *sp___6;
#line 2840
          dp___6 --;
#line 2840
          sp___6 --;
#line 2840
          *dp___6 = *sp___6;
#line 2841
          dp___6 --;
#line 2841
          sp___6 --;
#line 2841
          *dp___6 = *sp___6;
#line 2842
          dp___6 --;
#line 2842
          sp___6 --;
#line 2842
          *dp___6 = *sp___6;
#line 2843
          dp___6 --;
#line 2843
          *dp___6 = lo_filler;
#line 2844
          dp___6 --;
#line 2844
          *dp___6 = hi_filler;
#line 2835
          i ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 2847
        row_info->channels = (png_byte )4;
#line 2848
        row_info->pixel_depth = (png_byte )64;
#line 2849
        row_info->rowbytes = (size_t )(row_width * 8U);
      }
    }
  }
#line 2854
  return;
}
}
#line 2859 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
static void png_do_gray_to_rgb(png_row_infop row_info , png_bytep row )
{
  png_uint_32 i ;
  png_uint_32 row_width ;
  png_bytep sp ;
  png_bytep dp ;
  png_bytep tmp ;
  png_bytep tmp___0 ;
  png_bytep tmp___1 ;
  png_bytep tmp___2 ;
  png_bytep sp___0 ;
  png_bytep dp___0 ;
  png_bytep tmp___3 ;
  png_bytep tmp___4 ;
  png_bytep tmp___5 ;
  png_bytep tmp___6 ;
  png_bytep tmp___7 ;
  png_bytep tmp___8 ;
  png_bytep tmp___9 ;
  png_bytep tmp___10 ;
  png_bytep sp___1 ;
  png_bytep dp___1 ;
  png_bytep tmp___11 ;
  png_bytep tmp___12 ;
  png_bytep tmp___13 ;
  png_bytep tmp___14 ;
  png_bytep tmp___15 ;
  png_bytep tmp___16 ;
  png_bytep sp___2 ;
  png_bytep dp___2 ;
  png_bytep tmp___17 ;
  png_bytep tmp___18 ;
  png_bytep tmp___19 ;
  png_bytep tmp___20 ;
  png_bytep tmp___21 ;
  png_bytep tmp___22 ;
  png_bytep tmp___23 ;
  png_bytep tmp___24 ;
  png_bytep tmp___25 ;
  png_bytep tmp___26 ;
  png_bytep tmp___27 ;
  png_bytep tmp___28 ;

  {
#line 2863
  row_width = row_info->width;
#line 2867
  if ((int )row_info->bit_depth >= 8) {
#line 2867
    if (((int )row_info->color_type & 2) == 0) {
#line 2870
      if ((int )row_info->color_type == 0) {
#line 2872
        if ((int )row_info->bit_depth == 8) {
#line 2875
          sp = (row + (size_t )row_width) - 1;
#line 2876
          dp = sp + (size_t )row_width * 2UL;
#line 2877
          i = (png_uint_32 )0;
          {
#line 2877
          while (1) {
            while_continue: /* CIL Label */ ;
#line 2877
            if (! (i < row_width)) {
#line 2877
              goto while_break;
            }
#line 2879
            tmp = dp;
#line 2879
            dp --;
#line 2879
            *tmp = *sp;
#line 2880
            tmp___0 = dp;
#line 2880
            dp --;
#line 2880
            *tmp___0 = *sp;
#line 2881
            tmp___1 = dp;
#line 2881
            dp --;
#line 2881
            tmp___2 = sp;
#line 2881
            sp --;
#line 2881
            *tmp___1 = *tmp___2;
#line 2877
            i ++;
          }
          while_break: /* CIL Label */ ;
          }
        } else {
#line 2888
          sp___0 = (row + (size_t )row_width * 2UL) - 1;
#line 2889
          dp___0 = sp___0 + (size_t )row_width * 4UL;
#line 2890
          i = (png_uint_32 )0;
          {
#line 2890
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 2890
            if (! (i < row_width)) {
#line 2890
              goto while_break___0;
            }
#line 2892
            tmp___3 = dp___0;
#line 2892
            dp___0 --;
#line 2892
            *tmp___3 = *sp___0;
#line 2893
            tmp___4 = dp___0;
#line 2893
            dp___0 --;
#line 2893
            *tmp___4 = *(sp___0 - 1);
#line 2894
            tmp___5 = dp___0;
#line 2894
            dp___0 --;
#line 2894
            *tmp___5 = *sp___0;
#line 2895
            tmp___6 = dp___0;
#line 2895
            dp___0 --;
#line 2895
            *tmp___6 = *(sp___0 - 1);
#line 2896
            tmp___7 = dp___0;
#line 2896
            dp___0 --;
#line 2896
            tmp___8 = sp___0;
#line 2896
            sp___0 --;
#line 2896
            *tmp___7 = *tmp___8;
#line 2897
            tmp___9 = dp___0;
#line 2897
            dp___0 --;
#line 2897
            tmp___10 = sp___0;
#line 2897
            sp___0 --;
#line 2897
            *tmp___9 = *tmp___10;
#line 2890
            i ++;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      } else
#line 2902
      if ((int )row_info->color_type == 4) {
#line 2904
        if ((int )row_info->bit_depth == 8) {
#line 2907
          sp___1 = (row + (size_t )row_width * 2UL) - 1;
#line 2908
          dp___1 = sp___1 + (size_t )row_width * 2UL;
#line 2909
          i = (png_uint_32 )0;
          {
#line 2909
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 2909
            if (! (i < row_width)) {
#line 2909
              goto while_break___1;
            }
#line 2911
            tmp___11 = dp___1;
#line 2911
            dp___1 --;
#line 2911
            tmp___12 = sp___1;
#line 2911
            sp___1 --;
#line 2911
            *tmp___11 = *tmp___12;
#line 2912
            tmp___13 = dp___1;
#line 2912
            dp___1 --;
#line 2912
            *tmp___13 = *sp___1;
#line 2913
            tmp___14 = dp___1;
#line 2913
            dp___1 --;
#line 2913
            *tmp___14 = *sp___1;
#line 2914
            tmp___15 = dp___1;
#line 2914
            dp___1 --;
#line 2914
            tmp___16 = sp___1;
#line 2914
            sp___1 --;
#line 2914
            *tmp___15 = *tmp___16;
#line 2909
            i ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        } else {
#line 2921
          sp___2 = (row + (size_t )row_width * 4UL) - 1;
#line 2922
          dp___2 = sp___2 + (size_t )row_width * 4UL;
#line 2923
          i = (png_uint_32 )0;
          {
#line 2923
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 2923
            if (! (i < row_width)) {
#line 2923
              goto while_break___2;
            }
#line 2925
            tmp___17 = dp___2;
#line 2925
            dp___2 --;
#line 2925
            tmp___18 = sp___2;
#line 2925
            sp___2 --;
#line 2925
            *tmp___17 = *tmp___18;
#line 2926
            tmp___19 = dp___2;
#line 2926
            dp___2 --;
#line 2926
            tmp___20 = sp___2;
#line 2926
            sp___2 --;
#line 2926
            *tmp___19 = *tmp___20;
#line 2927
            tmp___21 = dp___2;
#line 2927
            dp___2 --;
#line 2927
            *tmp___21 = *sp___2;
#line 2928
            tmp___22 = dp___2;
#line 2928
            dp___2 --;
#line 2928
            *tmp___22 = *(sp___2 - 1);
#line 2929
            tmp___23 = dp___2;
#line 2929
            dp___2 --;
#line 2929
            *tmp___23 = *sp___2;
#line 2930
            tmp___24 = dp___2;
#line 2930
            dp___2 --;
#line 2930
            *tmp___24 = *(sp___2 - 1);
#line 2931
            tmp___25 = dp___2;
#line 2931
            dp___2 --;
#line 2931
            tmp___26 = sp___2;
#line 2931
            sp___2 --;
#line 2931
            *tmp___25 = *tmp___26;
#line 2932
            tmp___27 = dp___2;
#line 2932
            dp___2 --;
#line 2932
            tmp___28 = sp___2;
#line 2932
            sp___2 --;
#line 2932
            *tmp___27 = *tmp___28;
#line 2923
            i ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      }
#line 2936
      row_info->channels = (png_byte )((int )row_info->channels + 2);
#line 2937
      row_info->color_type = (png_byte )((int )row_info->color_type | 2);
#line 2938
      row_info->pixel_depth = (png_byte )((int )row_info->channels * (int )row_info->bit_depth);
#line 2940
      if ((int )row_info->pixel_depth >= 8) {
#line 2940
        row_info->rowbytes = (size_t )row_width * ((size_t )row_info->pixel_depth >> 3);
      } else {
#line 2940
        row_info->rowbytes = ((size_t )row_width * (size_t )row_info->pixel_depth + 7UL) >> 3;
      }
    }
  }
#line 2942
  return;
}
}
#line 2998 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
static int png_do_rgb_to_gray(png_structrp png_ptr , png_row_infop row_info , png_bytep row )
{
  int rgb_error ;
  png_uint_32 rc ;
  png_uint_32 gc ;
  png_uint_32 bc ;
  png_uint_32 row_width ;
  int have_alpha ;
  png_bytep sp ;
  png_bytep dp ;
  png_uint_32 i ;
  png_byte red ;
  png_bytep tmp ;
  png_byte green ;
  png_bytep tmp___0 ;
  png_byte blue ;
  png_bytep tmp___1 ;
  png_bytep tmp___2 ;
  png_bytep tmp___3 ;
  png_bytep tmp___4 ;
  png_bytep tmp___5 ;
  png_bytep sp___0 ;
  png_bytep dp___0 ;
  png_uint_32 i___0 ;
  png_byte red___0 ;
  png_bytep tmp___6 ;
  png_byte green___0 ;
  png_bytep tmp___7 ;
  png_byte blue___0 ;
  png_bytep tmp___8 ;
  png_bytep tmp___9 ;
  png_bytep tmp___10 ;
  png_bytep tmp___11 ;
  png_bytep tmp___12 ;
  png_bytep sp___1 ;
  png_bytep dp___1 ;
  png_uint_32 i___1 ;
  png_uint_16 red___1 ;
  png_uint_16 green___1 ;
  png_uint_16 blue___1 ;
  png_uint_16 w ;
  png_byte hi ;
  png_byte lo ;
  png_bytep tmp___13 ;
  png_bytep tmp___14 ;
  png_bytep tmp___15 ;
  png_bytep tmp___16 ;
  png_bytep tmp___17 ;
  png_bytep tmp___18 ;
  png_uint_16 red_1 ;
  png_uint_16 green_1 ;
  png_uint_16 blue_1 ;
  png_uint_16 gray16 ;
  png_bytep tmp___19 ;
  png_bytep tmp___20 ;
  png_bytep tmp___21 ;
  png_bytep tmp___22 ;
  png_bytep tmp___23 ;
  png_bytep tmp___24 ;
  png_bytep sp___2 ;
  png_bytep dp___2 ;
  png_uint_32 i___2 ;
  png_uint_16 red___2 ;
  png_uint_16 green___2 ;
  png_uint_16 blue___2 ;
  png_uint_16 gray16___0 ;
  png_byte hi___0 ;
  png_byte lo___0 ;
  png_bytep tmp___25 ;
  png_bytep tmp___26 ;
  png_bytep tmp___27 ;
  png_bytep tmp___28 ;
  png_bytep tmp___29 ;
  png_bytep tmp___30 ;
  png_bytep tmp___31 ;
  png_bytep tmp___32 ;
  png_bytep tmp___33 ;
  png_bytep tmp___34 ;
  png_bytep tmp___35 ;
  png_bytep tmp___36 ;

  {
#line 3001
  rgb_error = 0;
#line 3005
  if (((int )row_info->color_type & 1) == 0) {
#line 3005
    if (((int )row_info->color_type & 2) != 0) {
#line 3008
      rc = (png_uint_32 )png_ptr->rgb_to_gray_red_coeff;
#line 3009
      gc = (png_uint_32 )png_ptr->rgb_to_gray_green_coeff;
#line 3010
      bc = (32768U - rc) - gc;
#line 3011
      row_width = row_info->width;
#line 3012
      have_alpha = ((int )row_info->color_type & 4) != 0;
#line 3014
      if ((int )row_info->bit_depth == 8) {
#line 3022
        if ((unsigned long )png_ptr->gamma_from_1 != (unsigned long )((void *)0)) {
#line 3022
          if ((unsigned long )png_ptr->gamma_to_1 != (unsigned long )((void *)0)) {
#line 3024
            sp = row;
#line 3025
            dp = row;
#line 3028
            i = (png_uint_32 )0;
            {
#line 3028
            while (1) {
              while_continue: /* CIL Label */ ;
#line 3028
              if (! (i < row_width)) {
#line 3028
                goto while_break;
              }
#line 3030
              tmp = sp;
#line 3030
              sp ++;
#line 3030
              red = *tmp;
#line 3031
              tmp___0 = sp;
#line 3031
              sp ++;
#line 3031
              green = *tmp___0;
#line 3032
              tmp___1 = sp;
#line 3032
              sp ++;
#line 3032
              blue = *tmp___1;
#line 3034
              if ((int )red != (int )green) {
#line 3034
                goto _L;
              } else
#line 3034
              if ((int )red != (int )blue) {
                _L: /* CIL Label */
#line 3036
                red = *(png_ptr->gamma_to_1 + red);
#line 3037
                green = *(png_ptr->gamma_to_1 + green);
#line 3038
                blue = *(png_ptr->gamma_to_1 + blue);
#line 3040
                rgb_error |= 1;
#line 3041
                tmp___2 = dp;
#line 3041
                dp ++;
#line 3041
                *tmp___2 = *(png_ptr->gamma_from_1 + ((((rc * (png_uint_32 )red + gc * (png_uint_32 )green) + bc * (png_uint_32 )blue) + 16384U) >> 15));
              } else {
#line 3050
                if ((unsigned long )png_ptr->gamma_table != (unsigned long )((void *)0)) {
#line 3051
                  red = *(png_ptr->gamma_table + red);
                }
#line 3053
                tmp___3 = dp;
#line 3053
                dp ++;
#line 3053
                *tmp___3 = red;
              }
#line 3056
              if (have_alpha != 0) {
#line 3057
                tmp___4 = dp;
#line 3057
                dp ++;
#line 3057
                tmp___5 = sp;
#line 3057
                sp ++;
#line 3057
                *tmp___4 = *tmp___5;
              }
#line 3028
              i ++;
            }
            while_break: /* CIL Label */ ;
            }
          } else {
#line 3022
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */
#line 3063
          sp___0 = row;
#line 3064
          dp___0 = row;
#line 3067
          i___0 = (png_uint_32 )0;
          {
#line 3067
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 3067
            if (! (i___0 < row_width)) {
#line 3067
              goto while_break___0;
            }
#line 3069
            tmp___6 = sp___0;
#line 3069
            sp___0 ++;
#line 3069
            red___0 = *tmp___6;
#line 3070
            tmp___7 = sp___0;
#line 3070
            sp___0 ++;
#line 3070
            green___0 = *tmp___7;
#line 3071
            tmp___8 = sp___0;
#line 3071
            sp___0 ++;
#line 3071
            blue___0 = *tmp___8;
#line 3073
            if ((int )red___0 != (int )green___0) {
#line 3075
              rgb_error |= 1;
#line 3079
              tmp___9 = dp___0;
#line 3079
              dp___0 ++;
#line 3079
              *tmp___9 = (png_byte )(((rc * (png_uint_32 )red___0 + gc * (png_uint_32 )green___0) + bc * (png_uint_32 )blue___0) >> 15);
            } else
#line 3073
            if ((int )red___0 != (int )blue___0) {
#line 3075
              rgb_error |= 1;
#line 3079
              tmp___9 = dp___0;
#line 3079
              dp___0 ++;
#line 3079
              *tmp___9 = (png_byte )(((rc * (png_uint_32 )red___0 + gc * (png_uint_32 )green___0) + bc * (png_uint_32 )blue___0) >> 15);
            } else {
#line 3083
              tmp___10 = dp___0;
#line 3083
              dp___0 ++;
#line 3083
              *tmp___10 = red___0;
            }
#line 3085
            if (have_alpha != 0) {
#line 3086
              tmp___11 = dp___0;
#line 3086
              dp___0 ++;
#line 3086
              tmp___12 = sp___0;
#line 3086
              sp___0 ++;
#line 3086
              *tmp___11 = *tmp___12;
            }
#line 3067
            i___0 ++;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      } else
#line 3094
      if ((unsigned long )png_ptr->gamma_16_to_1 != (unsigned long )((void *)0)) {
#line 3094
        if ((unsigned long )png_ptr->gamma_16_from_1 != (unsigned long )((void *)0)) {
#line 3096
          sp___1 = row;
#line 3097
          dp___1 = row;
#line 3100
          i___1 = (png_uint_32 )0;
          {
#line 3100
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 3100
            if (! (i___1 < row_width)) {
#line 3100
              goto while_break___1;
            }
#line 3105
            tmp___13 = sp___1;
#line 3105
            sp___1 ++;
#line 3105
            hi = *tmp___13;
#line 3105
            tmp___14 = sp___1;
#line 3105
            sp___1 ++;
#line 3105
            lo = *tmp___14;
#line 3105
            red___1 = (png_uint_16 )(((int )hi << 8) | (int )lo);
#line 3106
            tmp___15 = sp___1;
#line 3106
            sp___1 ++;
#line 3106
            hi = *tmp___15;
#line 3106
            tmp___16 = sp___1;
#line 3106
            sp___1 ++;
#line 3106
            lo = *tmp___16;
#line 3106
            green___1 = (png_uint_16 )(((int )hi << 8) | (int )lo);
#line 3107
            tmp___17 = sp___1;
#line 3107
            sp___1 ++;
#line 3107
            hi = *tmp___17;
#line 3107
            tmp___18 = sp___1;
#line 3107
            sp___1 ++;
#line 3107
            lo = *tmp___18;
#line 3107
            blue___1 = (png_uint_16 )(((int )hi << 8) | (int )lo);
#line 3109
            if ((int )red___1 == (int )green___1) {
#line 3109
              if ((int )red___1 == (int )blue___1) {
#line 3111
                if ((unsigned long )png_ptr->gamma_16_table != (unsigned long )((void *)0)) {
#line 3112
                  w = *(*(png_ptr->gamma_16_table + (((int )red___1 & 0xff) >> png_ptr->gamma_shift)) + ((int )red___1 >> 8));
                } else {
#line 3116
                  w = red___1;
                }
              } else {
#line 3109
                goto _L___1;
              }
            } else {
              _L___1: /* CIL Label */
#line 3121
              red_1 = *(*(png_ptr->gamma_16_to_1 + (((int )red___1 & 0xff) >> png_ptr->gamma_shift)) + ((int )red___1 >> 8));
#line 3123
              green_1 = *(*(png_ptr->gamma_16_to_1 + (((int )green___1 & 0xff) >> png_ptr->gamma_shift)) + ((int )green___1 >> 8));
#line 3126
              blue_1 = *(*(png_ptr->gamma_16_to_1 + (((int )blue___1 & 0xff) >> png_ptr->gamma_shift)) + ((int )blue___1 >> 8));
#line 3128
              gray16 = (png_uint_16 )((((rc * (png_uint_32 )red_1 + gc * (png_uint_32 )green_1) + bc * (png_uint_32 )blue_1) + 16384U) >> 15);
#line 3130
              w = *(*(png_ptr->gamma_16_from_1 + (((int )gray16 & 0xff) >> png_ptr->gamma_shift)) + ((int )gray16 >> 8));
#line 3132
              rgb_error |= 1;
            }
#line 3135
            tmp___19 = dp___1;
#line 3135
            dp___1 ++;
#line 3135
            *tmp___19 = (png_byte )(((int )w >> 8) & 0xff);
#line 3136
            tmp___20 = dp___1;
#line 3136
            dp___1 ++;
#line 3136
            *tmp___20 = (png_byte )((int )w & 0xff);
#line 3138
            if (have_alpha != 0) {
#line 3140
              tmp___21 = dp___1;
#line 3140
              dp___1 ++;
#line 3140
              tmp___22 = sp___1;
#line 3140
              sp___1 ++;
#line 3140
              *tmp___21 = *tmp___22;
#line 3141
              tmp___23 = dp___1;
#line 3141
              dp___1 ++;
#line 3141
              tmp___24 = sp___1;
#line 3141
              sp___1 ++;
#line 3141
              *tmp___23 = *tmp___24;
            }
#line 3100
            i___1 ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        } else {
#line 3094
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */
#line 3148
        sp___2 = row;
#line 3149
        dp___2 = row;
#line 3152
        i___2 = (png_uint_32 )0;
        {
#line 3152
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 3152
          if (! (i___2 < row_width)) {
#line 3152
            goto while_break___2;
          }
#line 3157
          tmp___25 = sp___2;
#line 3157
          sp___2 ++;
#line 3157
          hi___0 = *tmp___25;
#line 3157
          tmp___26 = sp___2;
#line 3157
          sp___2 ++;
#line 3157
          lo___0 = *tmp___26;
#line 3157
          red___2 = (png_uint_16 )(((int )hi___0 << 8) | (int )lo___0);
#line 3158
          tmp___27 = sp___2;
#line 3158
          sp___2 ++;
#line 3158
          hi___0 = *tmp___27;
#line 3158
          tmp___28 = sp___2;
#line 3158
          sp___2 ++;
#line 3158
          lo___0 = *tmp___28;
#line 3158
          green___2 = (png_uint_16 )(((int )hi___0 << 8) | (int )lo___0);
#line 3159
          tmp___29 = sp___2;
#line 3159
          sp___2 ++;
#line 3159
          hi___0 = *tmp___29;
#line 3159
          tmp___30 = sp___2;
#line 3159
          sp___2 ++;
#line 3159
          lo___0 = *tmp___30;
#line 3159
          blue___2 = (png_uint_16 )(((int )hi___0 << 8) | (int )lo___0);
#line 3161
          if ((int )red___2 != (int )green___2) {
#line 3162
            rgb_error |= 1;
          } else
#line 3161
          if ((int )red___2 != (int )blue___2) {
#line 3162
            rgb_error |= 1;
          }
#line 3168
          gray16___0 = (png_uint_16 )((((rc * (png_uint_32 )red___2 + gc * (png_uint_32 )green___2) + bc * (png_uint_32 )blue___2) + 16384U) >> 15);
#line 3170
          tmp___31 = dp___2;
#line 3170
          dp___2 ++;
#line 3170
          *tmp___31 = (png_byte )(((int )gray16___0 >> 8) & 0xff);
#line 3171
          tmp___32 = dp___2;
#line 3171
          dp___2 ++;
#line 3171
          *tmp___32 = (png_byte )((int )gray16___0 & 0xff);
#line 3173
          if (have_alpha != 0) {
#line 3175
            tmp___33 = dp___2;
#line 3175
            dp___2 ++;
#line 3175
            tmp___34 = sp___2;
#line 3175
            sp___2 ++;
#line 3175
            *tmp___33 = *tmp___34;
#line 3176
            tmp___35 = dp___2;
#line 3176
            dp___2 ++;
#line 3176
            tmp___36 = sp___2;
#line 3176
            sp___2 ++;
#line 3176
            *tmp___35 = *tmp___36;
          }
#line 3152
          i___2 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 3182
      row_info->channels = (png_byte )((int )row_info->channels - 2);
#line 3183
      row_info->color_type = (png_byte )((int )row_info->color_type & -3);
#line 3185
      row_info->pixel_depth = (png_byte )((int )row_info->channels * (int )row_info->bit_depth);
#line 3187
      if ((int )row_info->pixel_depth >= 8) {
#line 3187
        row_info->rowbytes = (size_t )row_width * ((size_t )row_info->pixel_depth >> 3);
      } else {
#line 3187
        row_info->rowbytes = ((size_t )row_width * (size_t )row_info->pixel_depth + 7UL) >> 3;
      }
    }
  }
#line 3189
  return (rgb_error);
}
}
#line 3199 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
static void png_do_compose(png_row_infop row_info , png_bytep row , png_structrp png_ptr )
{
  png_const_bytep gamma_table ;
  png_const_bytep gamma_from_1 ;
  png_const_bytep gamma_to_1 ;
  png_const_uint_16pp gamma_16 ;
  png_const_uint_16pp gamma_16_from_1 ;
  png_const_uint_16pp gamma_16_to_1 ;
  int gamma_shift ;
  int optimize ;
  png_bytep sp ;
  png_uint_32 i ;
  png_uint_32 row_width ;
  int shift ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int p ;
  unsigned int g ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int p___0 ;
  unsigned int g___0 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  png_uint_16 v ;
  png_uint_16 v___0 ;
  png_uint_16 r ;
  png_uint_16 g___1 ;
  png_uint_16 b ;
  png_uint_16 v___1 ;
  png_uint_16 r___0 ;
  png_uint_16 g___2 ;
  png_uint_16 b___0 ;
  png_uint_16 a ;
  png_byte v___2 ;
  png_byte w ;
  png_uint_16 temp ;
  png_byte a___0 ;
  png_uint_16 temp___0 ;
  png_uint_16 a___1 ;
  png_uint_16 v___3 ;
  png_uint_16 g___3 ;
  png_uint_16 v___4 ;
  png_uint_16 w___0 ;
  png_uint_32 temp___1 ;
  png_uint_16 a___2 ;
  png_uint_16 g___4 ;
  png_uint_16 v___5 ;
  png_uint_32 temp___2 ;
  png_byte a___3 ;
  png_byte v___6 ;
  png_byte w___1 ;
  png_uint_16 temp___3 ;
  png_uint_16 temp___4 ;
  png_uint_16 temp___5 ;
  png_byte a___4 ;
  png_uint_16 temp___6 ;
  png_uint_16 temp___7 ;
  png_uint_16 temp___8 ;
  png_uint_16 a___5 ;
  png_uint_16 v___7 ;
  png_uint_16 v___8 ;
  png_uint_16 w___2 ;
  png_uint_32 temp___9 ;
  png_uint_32 temp___10 ;
  png_uint_32 temp___11 ;
  png_uint_16 a___6 ;
  png_uint_16 v___9 ;
  png_uint_16 r___1 ;
  png_uint_16 g___5 ;
  png_uint_16 b___1 ;
  png_uint_32 temp___12 ;
  png_uint_32 temp___13 ;
  png_uint_32 temp___14 ;

  {
#line 3203
  gamma_table = (png_const_bytep )png_ptr->gamma_table;
#line 3204
  gamma_from_1 = (png_const_bytep )png_ptr->gamma_from_1;
#line 3205
  gamma_to_1 = (png_const_bytep )png_ptr->gamma_to_1;
#line 3206
  gamma_16 = (png_const_uint_16pp )png_ptr->gamma_16_table;
#line 3207
  gamma_16_from_1 = (png_const_uint_16pp )png_ptr->gamma_16_from_1;
#line 3208
  gamma_16_to_1 = (png_const_uint_16pp )png_ptr->gamma_16_to_1;
#line 3209
  gamma_shift = png_ptr->gamma_shift;
#line 3210
  optimize = (png_ptr->flags & 0x2000U) != 0U;
#line 3215
  row_width = row_info->width;
  {
#line 3222
  if ((int )row_info->color_type == 0) {
#line 3222
    goto case_0;
  }
#line 3474
  if ((int )row_info->color_type == 2) {
#line 3474
    goto case_2___0;
  }
#line 3601
  if ((int )row_info->color_type == 4) {
#line 3601
    goto case_4___0;
  }
#line 3727
  if ((int )row_info->color_type == 6) {
#line 3727
    goto case_6;
  }
#line 3930
  goto switch_default___0;
  case_0: /* CIL Label */
  {
#line 3226
  if ((int )row_info->bit_depth == 1) {
#line 3226
    goto case_1;
  }
#line 3253
  if ((int )row_info->bit_depth == 2) {
#line 3253
    goto case_2;
  }
#line 3321
  if ((int )row_info->bit_depth == 4) {
#line 3321
    goto case_4;
  }
#line 3389
  if ((int )row_info->bit_depth == 8) {
#line 3389
    goto case_8;
  }
#line 3417
  if ((int )row_info->bit_depth == 16) {
#line 3417
    goto case_16;
  }
#line 3468
  goto switch_default;
  case_1: /* CIL Label */
#line 3228
  sp = row;
#line 3229
  shift = 7;
#line 3230
  i = (png_uint_32 )0;
  {
#line 3230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3230
    if (! (i < row_width)) {
#line 3230
      goto while_break;
    }
#line 3232
    if ((int )((png_uint_16 )(((int )*sp >> shift) & 0x01)) == (int )png_ptr->trans_color.gray) {
#line 3235
      tmp = (unsigned int )((int )*sp & (0x7f7f >> (7 - shift)));
#line 3236
      tmp |= (unsigned int )((int )png_ptr->background.gray << shift);
#line 3238
      *sp = (png_byte )(tmp & 255U);
    }
#line 3241
    if (shift == 0) {
#line 3243
      shift = 7;
#line 3244
      sp ++;
    } else {
#line 3248
      shift --;
    }
#line 3230
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3250
  goto switch_break___0;
  case_2: /* CIL Label */
#line 3256
  if ((unsigned long )gamma_table != (unsigned long )((void *)0)) {
#line 3258
    sp = row;
#line 3259
    shift = 6;
#line 3260
    i = (png_uint_32 )0;
    {
#line 3260
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3260
      if (! (i < row_width)) {
#line 3260
        goto while_break___0;
      }
#line 3262
      if ((int )((png_uint_16 )(((int )*sp >> shift) & 0x03)) == (int )png_ptr->trans_color.gray) {
#line 3265
        tmp___0 = (unsigned int )((int )*sp & (0x3f3f >> (6 - shift)));
#line 3266
        tmp___0 |= (unsigned int )png_ptr->background.gray << shift;
#line 3268
        *sp = (png_byte )(tmp___0 & 255U);
      } else {
#line 3273
        p = (unsigned int )(((int )*sp >> shift) & 0x03);
#line 3274
        g = (unsigned int )(((int const   )*(gamma_table + (((p | (p << 2)) | (p << 4)) | (p << 6))) >> 6) & 3);
#line 3276
        tmp___1 = (unsigned int )((int )*sp & (0x3f3f >> (6 - shift)));
#line 3277
        tmp___1 |= g << shift;
#line 3278
        *sp = (png_byte )(tmp___1 & 255U);
      }
#line 3281
      if (shift == 0) {
#line 3283
        shift = 6;
#line 3284
        sp ++;
      } else {
#line 3288
        shift -= 2;
      }
#line 3260
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 3295
    sp = row;
#line 3296
    shift = 6;
#line 3297
    i = (png_uint_32 )0;
    {
#line 3297
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3297
      if (! (i < row_width)) {
#line 3297
        goto while_break___1;
      }
#line 3299
      if ((int )((png_uint_16 )(((int )*sp >> shift) & 0x03)) == (int )png_ptr->trans_color.gray) {
#line 3302
        tmp___2 = (unsigned int )((int )*sp & (0x3f3f >> (6 - shift)));
#line 3303
        tmp___2 |= (unsigned int )png_ptr->background.gray << shift;
#line 3305
        *sp = (png_byte )(tmp___2 & 255U);
      }
#line 3308
      if (shift == 0) {
#line 3310
        shift = 6;
#line 3311
        sp ++;
      } else {
#line 3315
        shift -= 2;
      }
#line 3297
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 3318
  goto switch_break___0;
  case_4: /* CIL Label */
#line 3324
  if ((unsigned long )gamma_table != (unsigned long )((void *)0)) {
#line 3326
    sp = row;
#line 3327
    shift = 4;
#line 3328
    i = (png_uint_32 )0;
    {
#line 3328
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3328
      if (! (i < row_width)) {
#line 3328
        goto while_break___2;
      }
#line 3330
      if ((int )((png_uint_16 )(((int )*sp >> shift) & 0x0f)) == (int )png_ptr->trans_color.gray) {
#line 3333
        tmp___3 = (unsigned int )((int )*sp & (0x0f0f >> (4 - shift)));
#line 3334
        tmp___3 |= (unsigned int )((int )png_ptr->background.gray << shift);
#line 3336
        *sp = (png_byte )(tmp___3 & 255U);
      } else {
#line 3341
        p___0 = (unsigned int )(((int )*sp >> shift) & 0x0f);
#line 3342
        g___0 = (unsigned int )(((int const   )*(gamma_table + (p___0 | (p___0 << 4))) >> 4) & 15);
#line 3344
        tmp___4 = (unsigned int )((int )*sp & (0x0f0f >> (4 - shift)));
#line 3345
        tmp___4 |= g___0 << shift;
#line 3346
        *sp = (png_byte )(tmp___4 & 255U);
      }
#line 3349
      if (shift == 0) {
#line 3351
        shift = 4;
#line 3352
        sp ++;
      } else {
#line 3356
        shift -= 4;
      }
#line 3328
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
#line 3363
    sp = row;
#line 3364
    shift = 4;
#line 3365
    i = (png_uint_32 )0;
    {
#line 3365
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 3365
      if (! (i < row_width)) {
#line 3365
        goto while_break___3;
      }
#line 3367
      if ((int )((png_uint_16 )(((int )*sp >> shift) & 0x0f)) == (int )png_ptr->trans_color.gray) {
#line 3370
        tmp___5 = (unsigned int )((int )*sp & (0x0f0f >> (4 - shift)));
#line 3371
        tmp___5 |= (unsigned int )((int )png_ptr->background.gray << shift);
#line 3373
        *sp = (png_byte )(tmp___5 & 255U);
      }
#line 3376
      if (shift == 0) {
#line 3378
        shift = 4;
#line 3379
        sp ++;
      } else {
#line 3383
        shift -= 4;
      }
#line 3365
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 3386
  goto switch_break___0;
  case_8: /* CIL Label */
#line 3392
  if ((unsigned long )gamma_table != (unsigned long )((void *)0)) {
#line 3394
    sp = row;
#line 3395
    i = (png_uint_32 )0;
    {
#line 3395
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 3395
      if (! (i < row_width)) {
#line 3395
        goto while_break___4;
      }
#line 3397
      if ((int )*sp == (int )png_ptr->trans_color.gray) {
#line 3398
        *sp = (png_byte )png_ptr->background.gray;
      } else {
#line 3401
        *sp = (png_byte )*(gamma_table + *sp);
      }
#line 3395
      i ++;
#line 3395
      sp ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  } else {
#line 3407
    sp = row;
#line 3408
    i = (png_uint_32 )0;
    {
#line 3408
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 3408
      if (! (i < row_width)) {
#line 3408
        goto while_break___5;
      }
#line 3410
      if ((int )*sp == (int )png_ptr->trans_color.gray) {
#line 3411
        *sp = (png_byte )png_ptr->background.gray;
      }
#line 3408
      i ++;
#line 3408
      sp ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 3414
  goto switch_break___0;
  case_16: /* CIL Label */
#line 3420
  if ((unsigned long )gamma_16 != (unsigned long )((void *)0)) {
#line 3422
    sp = row;
#line 3423
    i = (png_uint_32 )0;
    {
#line 3423
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 3423
      if (! (i < row_width)) {
#line 3423
        goto while_break___6;
      }
#line 3427
      v = (png_uint_16 )(((int )*sp << 8) + (int )*(sp + 1));
#line 3429
      if ((int )v == (int )png_ptr->trans_color.gray) {
#line 3432
        *sp = (png_byte )(((int )png_ptr->background.gray >> 8) & 0xff);
#line 3434
        *(sp + 1) = (png_byte )((int )png_ptr->background.gray & 0xff);
      } else {
#line 3440
        v = *(*(gamma_16 + ((int )*(sp + 1) >> gamma_shift)) + *sp);
#line 3441
        *sp = (png_byte )(((int )v >> 8) & 0xff);
#line 3442
        *(sp + 1) = (png_byte )((int )v & 0xff);
      }
#line 3423
      i ++;
#line 3423
      sp += 2;
    }
    while_break___6: /* CIL Label */ ;
    }
  } else {
#line 3449
    sp = row;
#line 3450
    i = (png_uint_32 )0;
    {
#line 3450
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 3450
      if (! (i < row_width)) {
#line 3450
        goto while_break___7;
      }
#line 3454
      v___0 = (png_uint_16 )(((int )*sp << 8) + (int )*(sp + 1));
#line 3456
      if ((int )v___0 == (int )png_ptr->trans_color.gray) {
#line 3458
        *sp = (png_byte )(((int )png_ptr->background.gray >> 8) & 0xff);
#line 3460
        *(sp + 1) = (png_byte )((int )png_ptr->background.gray & 0xff);
      }
#line 3450
      i ++;
#line 3450
      sp += 2;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
#line 3465
  goto switch_break___0;
  switch_default: /* CIL Label */
#line 3469
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 3471
  goto switch_break;
  case_2___0: /* CIL Label */
#line 3476
  if ((int )row_info->bit_depth == 8) {
#line 3479
    if ((unsigned long )gamma_table != (unsigned long )((void *)0)) {
#line 3481
      sp = row;
#line 3482
      i = (png_uint_32 )0;
      {
#line 3482
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 3482
        if (! (i < row_width)) {
#line 3482
          goto while_break___8;
        }
#line 3484
        if ((int )*sp == (int )png_ptr->trans_color.red) {
#line 3484
          if ((int )*(sp + 1) == (int )png_ptr->trans_color.green) {
#line 3484
            if ((int )*(sp + 2) == (int )png_ptr->trans_color.blue) {
#line 3488
              *sp = (png_byte )png_ptr->background.red;
#line 3489
              *(sp + 1) = (png_byte )png_ptr->background.green;
#line 3490
              *(sp + 2) = (png_byte )png_ptr->background.blue;
            } else {
#line 3495
              *sp = (png_byte )*(gamma_table + *sp);
#line 3496
              *(sp + 1) = (png_byte )*(gamma_table + *(sp + 1));
#line 3497
              *(sp + 2) = (png_byte )*(gamma_table + *(sp + 2));
            }
          } else {
#line 3495
            *sp = (png_byte )*(gamma_table + *sp);
#line 3496
            *(sp + 1) = (png_byte )*(gamma_table + *(sp + 1));
#line 3497
            *(sp + 2) = (png_byte )*(gamma_table + *(sp + 2));
          }
        } else {
#line 3495
          *sp = (png_byte )*(gamma_table + *sp);
#line 3496
          *(sp + 1) = (png_byte )*(gamma_table + *(sp + 1));
#line 3497
          *(sp + 2) = (png_byte )*(gamma_table + *(sp + 2));
        }
#line 3482
        i ++;
#line 3482
        sp += 3;
      }
      while_break___8: /* CIL Label */ ;
      }
    } else {
#line 3504
      sp = row;
#line 3505
      i = (png_uint_32 )0;
      {
#line 3505
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 3505
        if (! (i < row_width)) {
#line 3505
          goto while_break___9;
        }
#line 3507
        if ((int )*sp == (int )png_ptr->trans_color.red) {
#line 3507
          if ((int )*(sp + 1) == (int )png_ptr->trans_color.green) {
#line 3507
            if ((int )*(sp + 2) == (int )png_ptr->trans_color.blue) {
#line 3511
              *sp = (png_byte )png_ptr->background.red;
#line 3512
              *(sp + 1) = (png_byte )png_ptr->background.green;
#line 3513
              *(sp + 2) = (png_byte )png_ptr->background.blue;
            }
          }
        }
#line 3505
        i ++;
#line 3505
        sp += 3;
      }
      while_break___9: /* CIL Label */ ;
      }
    }
  } else
#line 3521
  if ((unsigned long )gamma_16 != (unsigned long )((void *)0)) {
#line 3523
    sp = row;
#line 3524
    i = (png_uint_32 )0;
    {
#line 3524
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 3524
      if (! (i < row_width)) {
#line 3524
        goto while_break___10;
      }
#line 3526
      r = (png_uint_16 )(((int )*sp << 8) + (int )*(sp + 1));
#line 3528
      g___1 = (png_uint_16 )(((int )*(sp + 2) << 8) + (int )*(sp + 3));
#line 3531
      b = (png_uint_16 )(((int )*(sp + 4) << 8) + (int )*(sp + 5));
#line 3534
      if ((int )r == (int )png_ptr->trans_color.red) {
#line 3534
        if ((int )g___1 == (int )png_ptr->trans_color.green) {
#line 3534
          if ((int )b == (int )png_ptr->trans_color.blue) {
#line 3539
            *sp = (png_byte )(((int )png_ptr->background.red >> 8) & 0xff);
#line 3540
            *(sp + 1) = (png_byte )((int )png_ptr->background.red & 0xff);
#line 3541
            *(sp + 2) = (png_byte )(((int )png_ptr->background.green >> 8) & 0xff);
#line 3543
            *(sp + 3) = (png_byte )((int )png_ptr->background.green & 0xff);
#line 3545
            *(sp + 4) = (png_byte )(((int )png_ptr->background.blue >> 8) & 0xff);
#line 3547
            *(sp + 5) = (png_byte )((int )png_ptr->background.blue & 0xff);
          } else {
#line 3534
            goto _L___0;
          }
        } else {
#line 3534
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */
        _L: /* CIL Label */
#line 3552
        v___1 = *(*(gamma_16 + ((int )*(sp + 1) >> gamma_shift)) + *sp);
#line 3553
        *sp = (png_byte )(((int )v___1 >> 8) & 0xff);
#line 3554
        *(sp + 1) = (png_byte )((int )v___1 & 0xff);
#line 3556
        v___1 = *(*(gamma_16 + ((int )*(sp + 3) >> gamma_shift)) + *(sp + 2));
#line 3557
        *(sp + 2) = (png_byte )(((int )v___1 >> 8) & 0xff);
#line 3558
        *(sp + 3) = (png_byte )((int )v___1 & 0xff);
#line 3560
        v___1 = *(*(gamma_16 + ((int )*(sp + 5) >> gamma_shift)) + *(sp + 4));
#line 3561
        *(sp + 4) = (png_byte )(((int )v___1 >> 8) & 0xff);
#line 3562
        *(sp + 5) = (png_byte )((int )v___1 & 0xff);
      }
#line 3524
      i ++;
#line 3524
      sp += 6;
    }
    while_break___10: /* CIL Label */ ;
    }
  } else {
#line 3570
    sp = row;
#line 3571
    i = (png_uint_32 )0;
    {
#line 3571
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 3571
      if (! (i < row_width)) {
#line 3571
        goto while_break___11;
      }
#line 3573
      r___0 = (png_uint_16 )(((int )*sp << 8) + (int )*(sp + 1));
#line 3575
      g___2 = (png_uint_16 )(((int )*(sp + 2) << 8) + (int )*(sp + 3));
#line 3578
      b___0 = (png_uint_16 )(((int )*(sp + 4) << 8) + (int )*(sp + 5));
#line 3581
      if ((int )r___0 == (int )png_ptr->trans_color.red) {
#line 3581
        if ((int )g___2 == (int )png_ptr->trans_color.green) {
#line 3581
          if ((int )b___0 == (int )png_ptr->trans_color.blue) {
#line 3585
            *sp = (png_byte )(((int )png_ptr->background.red >> 8) & 0xff);
#line 3586
            *(sp + 1) = (png_byte )((int )png_ptr->background.red & 0xff);
#line 3587
            *(sp + 2) = (png_byte )(((int )png_ptr->background.green >> 8) & 0xff);
#line 3589
            *(sp + 3) = (png_byte )((int )png_ptr->background.green & 0xff);
#line 3591
            *(sp + 4) = (png_byte )(((int )png_ptr->background.blue >> 8) & 0xff);
#line 3593
            *(sp + 5) = (png_byte )((int )png_ptr->background.blue & 0xff);
          }
        }
      }
#line 3571
      i ++;
#line 3571
      sp += 6;
    }
    while_break___11: /* CIL Label */ ;
    }
  }
#line 3598
  goto switch_break;
  case_4___0: /* CIL Label */
#line 3603
  if ((int )row_info->bit_depth == 8) {
#line 3606
    if ((unsigned long )gamma_to_1 != (unsigned long )((void *)0)) {
#line 3606
      if ((unsigned long )gamma_from_1 != (unsigned long )((void *)0)) {
#line 3606
        if ((unsigned long )gamma_table != (unsigned long )((void *)0)) {
#line 3609
          sp = row;
#line 3610
          i = (png_uint_32 )0;
          {
#line 3610
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 3610
            if (! (i < row_width)) {
#line 3610
              goto while_break___12;
            }
#line 3612
            a = (png_uint_16 )*(sp + 1);
#line 3614
            if ((int )a == 0xff) {
#line 3615
              *sp = (png_byte )*(gamma_table + *sp);
            } else
#line 3617
            if ((int )a == 0) {
#line 3620
              *sp = (png_byte )png_ptr->background.gray;
            } else {
#line 3627
              v___2 = (png_byte )*(gamma_to_1 + *sp);
#line 3628
              temp = (png_uint_16 )(((int )((png_uint_16 )v___2) * (int )a + (int )png_ptr->background_1.gray * (int )((png_uint_16 )(255 - (int )a))) + 128);
#line 3628
              w = (png_byte )((((int )temp + ((int )temp >> 8)) >> 8) & 0xff);
#line 3629
              if (optimize == 0) {
#line 3630
                w = (png_byte )*(gamma_from_1 + w);
              }
#line 3631
              *sp = w;
            }
#line 3610
            i ++;
#line 3610
            sp += 2;
          }
          while_break___12: /* CIL Label */ ;
          }
        } else {
#line 3606
          goto _L___2;
        }
      } else {
#line 3606
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */
      _L___1: /* CIL Label */
#line 3638
      sp = row;
#line 3639
      i = (png_uint_32 )0;
      {
#line 3639
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 3639
        if (! (i < row_width)) {
#line 3639
          goto while_break___13;
        }
#line 3641
        a___0 = *(sp + 1);
#line 3643
        if ((int )a___0 == 0) {
#line 3644
          *sp = (png_byte )png_ptr->background.gray;
        } else
#line 3646
        if ((int )a___0 < 0xff) {
#line 3647
          temp___0 = (png_uint_16 )(((int )((png_uint_16 )*sp) * (int )((png_uint_16 )a___0) + (int )png_ptr->background.gray * (int )((png_uint_16 )(255 - (int )((png_uint_16 )a___0)))) + 128);
#line 3647
          *sp = (png_byte )((((int )temp___0 + ((int )temp___0 >> 8)) >> 8) & 0xff);
        }
#line 3639
        i ++;
#line 3639
        sp += 2;
      }
      while_break___13: /* CIL Label */ ;
      }
    }
  } else
#line 3654
  if ((unsigned long )gamma_16 != (unsigned long )((void *)0)) {
#line 3654
    if ((unsigned long )gamma_16_from_1 != (unsigned long )((void *)0)) {
#line 3654
      if ((unsigned long )gamma_16_to_1 != (unsigned long )((void *)0)) {
#line 3657
        sp = row;
#line 3658
        i = (png_uint_32 )0;
        {
#line 3658
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 3658
          if (! (i < row_width)) {
#line 3658
            goto while_break___14;
          }
#line 3660
          a___1 = (png_uint_16 )(((int )*(sp + 2) << 8) + (int )*(sp + 3));
#line 3663
          if ((int )a___1 == 65535) {
#line 3667
            v___3 = *(*(gamma_16 + ((int )*(sp + 1) >> gamma_shift)) + *sp);
#line 3668
            *sp = (png_byte )(((int )v___3 >> 8) & 0xff);
#line 3669
            *(sp + 1) = (png_byte )((int )v___3 & 0xff);
          } else
#line 3672
          if ((int )a___1 == 0) {
#line 3675
            *sp = (png_byte )(((int )png_ptr->background.gray >> 8) & 0xff);
#line 3677
            *(sp + 1) = (png_byte )((int )png_ptr->background.gray & 0xff);
          } else {
#line 3684
            g___3 = *(*(gamma_16_to_1 + ((int )*(sp + 1) >> gamma_shift)) + *sp);
#line 3685
            temp___1 = ((png_uint_32 )g___3 * (png_uint_32 )a___1 + (png_uint_32 )png_ptr->background_1.gray * (65535U - (png_uint_32 )a___1)) + 32768U;
#line 3685
            v___4 = (png_uint_16 )(65535U & ((temp___1 + (temp___1 >> 16)) >> 16));
#line 3686
            if (optimize != 0) {
#line 3687
              w___0 = v___4;
            } else {
#line 3689
              w___0 = *(*(gamma_16_from_1 + (((int )v___4 & 0xff) >> gamma_shift)) + ((int )v___4 >> 8));
            }
#line 3691
            *sp = (png_byte )(((int )w___0 >> 8) & 0xff);
#line 3692
            *(sp + 1) = (png_byte )((int )w___0 & 0xff);
          }
#line 3658
          i ++;
#line 3658
          sp += 4;
        }
        while_break___14: /* CIL Label */ ;
        }
      } else {
#line 3654
        goto _L___4;
      }
    } else {
#line 3654
      goto _L___4;
    }
  } else {
    _L___4: /* CIL Label */
    _L___3: /* CIL Label */
#line 3699
    sp = row;
#line 3700
    i = (png_uint_32 )0;
    {
#line 3700
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 3700
      if (! (i < row_width)) {
#line 3700
        goto while_break___15;
      }
#line 3702
      a___2 = (png_uint_16 )(((int )*(sp + 2) << 8) + (int )*(sp + 3));
#line 3705
      if ((int )a___2 == 0) {
#line 3707
        *sp = (png_byte )(((int )png_ptr->background.gray >> 8) & 0xff);
#line 3709
        *(sp + 1) = (png_byte )((int )png_ptr->background.gray & 0xff);
      } else
#line 3712
      if ((int )a___2 < 0xffff) {
#line 3716
        g___4 = (png_uint_16 )(((int )*sp << 8) + (int )*(sp + 1));
#line 3717
        temp___2 = ((png_uint_32 )g___4 * (png_uint_32 )a___2 + (png_uint_32 )png_ptr->background.gray * (65535U - (png_uint_32 )a___2)) + 32768U;
#line 3717
        v___5 = (png_uint_16 )(65535U & ((temp___2 + (temp___2 >> 16)) >> 16));
#line 3718
        *sp = (png_byte )(((int )v___5 >> 8) & 0xff);
#line 3719
        *(sp + 1) = (png_byte )((int )v___5 & 0xff);
      }
#line 3700
      i ++;
#line 3700
      sp += 4;
    }
    while_break___15: /* CIL Label */ ;
    }
  }
#line 3724
  goto switch_break;
  case_6: /* CIL Label */
#line 3729
  if ((int )row_info->bit_depth == 8) {
#line 3732
    if ((unsigned long )gamma_to_1 != (unsigned long )((void *)0)) {
#line 3732
      if ((unsigned long )gamma_from_1 != (unsigned long )((void *)0)) {
#line 3732
        if ((unsigned long )gamma_table != (unsigned long )((void *)0)) {
#line 3735
          sp = row;
#line 3736
          i = (png_uint_32 )0;
          {
#line 3736
          while (1) {
            while_continue___16: /* CIL Label */ ;
#line 3736
            if (! (i < row_width)) {
#line 3736
              goto while_break___16;
            }
#line 3738
            a___3 = *(sp + 3);
#line 3740
            if ((int )a___3 == 0xff) {
#line 3742
              *sp = (png_byte )*(gamma_table + *sp);
#line 3743
              *(sp + 1) = (png_byte )*(gamma_table + *(sp + 1));
#line 3744
              *(sp + 2) = (png_byte )*(gamma_table + *(sp + 2));
            } else
#line 3747
            if ((int )a___3 == 0) {
#line 3750
              *sp = (png_byte )png_ptr->background.red;
#line 3751
              *(sp + 1) = (png_byte )png_ptr->background.green;
#line 3752
              *(sp + 2) = (png_byte )png_ptr->background.blue;
            } else {
#line 3759
              v___6 = (png_byte )*(gamma_to_1 + *sp);
#line 3760
              temp___3 = (png_uint_16 )(((int )((png_uint_16 )v___6) * (int )((png_uint_16 )a___3) + (int )png_ptr->background_1.red * (int )((png_uint_16 )(255 - (int )((png_uint_16 )a___3)))) + 128);
#line 3760
              w___1 = (png_byte )((((int )temp___3 + ((int )temp___3 >> 8)) >> 8) & 0xff);
#line 3761
              if (optimize == 0) {
#line 3761
                w___1 = (png_byte )*(gamma_from_1 + w___1);
              }
#line 3762
              *sp = w___1;
#line 3764
              v___6 = (png_byte )*(gamma_to_1 + *(sp + 1));
#line 3765
              temp___4 = (png_uint_16 )(((int )((png_uint_16 )v___6) * (int )((png_uint_16 )a___3) + (int )png_ptr->background_1.green * (int )((png_uint_16 )(255 - (int )((png_uint_16 )a___3)))) + 128);
#line 3765
              w___1 = (png_byte )((((int )temp___4 + ((int )temp___4 >> 8)) >> 8) & 0xff);
#line 3766
              if (optimize == 0) {
#line 3766
                w___1 = (png_byte )*(gamma_from_1 + w___1);
              }
#line 3767
              *(sp + 1) = w___1;
#line 3769
              v___6 = (png_byte )*(gamma_to_1 + *(sp + 2));
#line 3770
              temp___5 = (png_uint_16 )(((int )((png_uint_16 )v___6) * (int )((png_uint_16 )a___3) + (int )png_ptr->background_1.blue * (int )((png_uint_16 )(255 - (int )((png_uint_16 )a___3)))) + 128);
#line 3770
              w___1 = (png_byte )((((int )temp___5 + ((int )temp___5 >> 8)) >> 8) & 0xff);
#line 3771
              if (optimize == 0) {
#line 3771
                w___1 = (png_byte )*(gamma_from_1 + w___1);
              }
#line 3772
              *(sp + 2) = w___1;
            }
#line 3736
            i ++;
#line 3736
            sp += 4;
          }
          while_break___16: /* CIL Label */ ;
          }
        } else {
#line 3732
          goto _L___6;
        }
      } else {
#line 3732
        goto _L___6;
      }
    } else {
      _L___6: /* CIL Label */
      _L___5: /* CIL Label */
#line 3779
      sp = row;
#line 3780
      i = (png_uint_32 )0;
      {
#line 3780
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 3780
        if (! (i < row_width)) {
#line 3780
          goto while_break___17;
        }
#line 3782
        a___4 = *(sp + 3);
#line 3784
        if ((int )a___4 == 0) {
#line 3786
          *sp = (png_byte )png_ptr->background.red;
#line 3787
          *(sp + 1) = (png_byte )png_ptr->background.green;
#line 3788
          *(sp + 2) = (png_byte )png_ptr->background.blue;
        } else
#line 3791
        if ((int )a___4 < 0xff) {
#line 3793
          temp___6 = (png_uint_16 )(((int )((png_uint_16 )*sp) * (int )((png_uint_16 )a___4) + (int )png_ptr->background.red * (int )((png_uint_16 )(255 - (int )((png_uint_16 )a___4)))) + 128);
#line 3793
          *sp = (png_byte )((((int )temp___6 + ((int )temp___6 >> 8)) >> 8) & 0xff);
#line 3795
          temp___7 = (png_uint_16 )(((int )((png_uint_16 )*(sp + 1)) * (int )((png_uint_16 )a___4) + (int )png_ptr->background.green * (int )((png_uint_16 )(255 - (int )((png_uint_16 )a___4)))) + 128);
#line 3795
          *(sp + 1) = (png_byte )((((int )temp___7 + ((int )temp___7 >> 8)) >> 8) & 0xff);
#line 3798
          temp___8 = (png_uint_16 )(((int )((png_uint_16 )*(sp + 2)) * (int )((png_uint_16 )a___4) + (int )png_ptr->background.blue * (int )((png_uint_16 )(255 - (int )((png_uint_16 )a___4)))) + 128);
#line 3798
          *(sp + 2) = (png_byte )((((int )temp___8 + ((int )temp___8 >> 8)) >> 8) & 0xff);
        }
#line 3780
        i ++;
#line 3780
        sp += 4;
      }
      while_break___17: /* CIL Label */ ;
      }
    }
  } else
#line 3807
  if ((unsigned long )gamma_16 != (unsigned long )((void *)0)) {
#line 3807
    if ((unsigned long )gamma_16_from_1 != (unsigned long )((void *)0)) {
#line 3807
      if ((unsigned long )gamma_16_to_1 != (unsigned long )((void *)0)) {
#line 3810
        sp = row;
#line 3811
        i = (png_uint_32 )0;
        {
#line 3811
        while (1) {
          while_continue___18: /* CIL Label */ ;
#line 3811
          if (! (i < row_width)) {
#line 3811
            goto while_break___18;
          }
#line 3813
          a___5 = (png_uint_16 )(((int )((png_uint_16 )*(sp + 6)) << 8) + (int )((png_uint_16 )*(sp + 7)));
#line 3816
          if ((int )a___5 == 65535) {
#line 3820
            v___7 = *(*(gamma_16 + ((int )*(sp + 1) >> gamma_shift)) + *sp);
#line 3821
            *sp = (png_byte )(((int )v___7 >> 8) & 0xff);
#line 3822
            *(sp + 1) = (png_byte )((int )v___7 & 0xff);
#line 3824
            v___7 = *(*(gamma_16 + ((int )*(sp + 3) >> gamma_shift)) + *(sp + 2));
#line 3825
            *(sp + 2) = (png_byte )(((int )v___7 >> 8) & 0xff);
#line 3826
            *(sp + 3) = (png_byte )((int )v___7 & 0xff);
#line 3828
            v___7 = *(*(gamma_16 + ((int )*(sp + 5) >> gamma_shift)) + *(sp + 4));
#line 3829
            *(sp + 4) = (png_byte )(((int )v___7 >> 8) & 0xff);
#line 3830
            *(sp + 5) = (png_byte )((int )v___7 & 0xff);
          } else
#line 3833
          if ((int )a___5 == 0) {
#line 3836
            *sp = (png_byte )(((int )png_ptr->background.red >> 8) & 0xff);
#line 3837
            *(sp + 1) = (png_byte )((int )png_ptr->background.red & 0xff);
#line 3838
            *(sp + 2) = (png_byte )(((int )png_ptr->background.green >> 8) & 0xff);
#line 3840
            *(sp + 3) = (png_byte )((int )png_ptr->background.green & 0xff);
#line 3842
            *(sp + 4) = (png_byte )(((int )png_ptr->background.blue >> 8) & 0xff);
#line 3844
            *(sp + 5) = (png_byte )((int )png_ptr->background.blue & 0xff);
          } else {
#line 3851
            v___8 = *(*(gamma_16_to_1 + ((int )*(sp + 1) >> gamma_shift)) + *sp);
#line 3852
            temp___9 = ((png_uint_32 )v___8 * (png_uint_32 )a___5 + (png_uint_32 )png_ptr->background_1.red * (65535U - (png_uint_32 )a___5)) + 32768U;
#line 3852
            w___2 = (png_uint_16 )(65535U & ((temp___9 + (temp___9 >> 16)) >> 16));
#line 3853
            if (optimize == 0) {
#line 3854
              w___2 = *(*(gamma_16_from_1 + (((int )w___2 & 0xff) >> gamma_shift)) + ((int )w___2 >> 8));
            }
#line 3856
            *sp = (png_byte )(((int )w___2 >> 8) & 0xff);
#line 3857
            *(sp + 1) = (png_byte )((int )w___2 & 0xff);
#line 3859
            v___8 = *(*(gamma_16_to_1 + ((int )*(sp + 3) >> gamma_shift)) + *(sp + 2));
#line 3860
            temp___10 = ((png_uint_32 )v___8 * (png_uint_32 )a___5 + (png_uint_32 )png_ptr->background_1.green * (65535U - (png_uint_32 )a___5)) + 32768U;
#line 3860
            w___2 = (png_uint_16 )(65535U & ((temp___10 + (temp___10 >> 16)) >> 16));
#line 3861
            if (optimize == 0) {
#line 3862
              w___2 = *(*(gamma_16_from_1 + (((int )w___2 & 0xff) >> gamma_shift)) + ((int )w___2 >> 8));
            }
#line 3865
            *(sp + 2) = (png_byte )(((int )w___2 >> 8) & 0xff);
#line 3866
            *(sp + 3) = (png_byte )((int )w___2 & 0xff);
#line 3868
            v___8 = *(*(gamma_16_to_1 + ((int )*(sp + 5) >> gamma_shift)) + *(sp + 4));
#line 3869
            temp___11 = ((png_uint_32 )v___8 * (png_uint_32 )a___5 + (png_uint_32 )png_ptr->background_1.blue * (65535U - (png_uint_32 )a___5)) + 32768U;
#line 3869
            w___2 = (png_uint_16 )(65535U & ((temp___11 + (temp___11 >> 16)) >> 16));
#line 3870
            if (optimize == 0) {
#line 3871
              w___2 = *(*(gamma_16_from_1 + (((int )w___2 & 0xff) >> gamma_shift)) + ((int )w___2 >> 8));
            }
#line 3874
            *(sp + 4) = (png_byte )(((int )w___2 >> 8) & 0xff);
#line 3875
            *(sp + 5) = (png_byte )((int )w___2 & 0xff);
          }
#line 3811
          i ++;
#line 3811
          sp += 8;
        }
        while_break___18: /* CIL Label */ ;
        }
      } else {
#line 3807
        goto _L___8;
      }
    } else {
#line 3807
      goto _L___8;
    }
  } else {
    _L___8: /* CIL Label */
    _L___7: /* CIL Label */
#line 3883
    sp = row;
#line 3884
    i = (png_uint_32 )0;
    {
#line 3884
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 3884
      if (! (i < row_width)) {
#line 3884
        goto while_break___19;
      }
#line 3886
      a___6 = (png_uint_16 )(((int )((png_uint_16 )*(sp + 6)) << 8) + (int )((png_uint_16 )*(sp + 7)));
#line 3889
      if ((int )a___6 == 0) {
#line 3891
        *sp = (png_byte )(((int )png_ptr->background.red >> 8) & 0xff);
#line 3892
        *(sp + 1) = (png_byte )((int )png_ptr->background.red & 0xff);
#line 3893
        *(sp + 2) = (png_byte )(((int )png_ptr->background.green >> 8) & 0xff);
#line 3895
        *(sp + 3) = (png_byte )((int )png_ptr->background.green & 0xff);
#line 3897
        *(sp + 4) = (png_byte )(((int )png_ptr->background.blue >> 8) & 0xff);
#line 3899
        *(sp + 5) = (png_byte )((int )png_ptr->background.blue & 0xff);
      } else
#line 3902
      if ((int )a___6 < 0xffff) {
#line 3906
        r___1 = (png_uint_16 )(((int )*sp << 8) + (int )*(sp + 1));
#line 3907
        g___5 = (png_uint_16 )(((int )*(sp + 2) << 8) + (int )*(sp + 3));
#line 3909
        b___1 = (png_uint_16 )(((int )*(sp + 4) << 8) + (int )*(sp + 5));
#line 3912
        temp___12 = ((png_uint_32 )r___1 * (png_uint_32 )a___6 + (png_uint_32 )png_ptr->background.red * (65535U - (png_uint_32 )a___6)) + 32768U;
#line 3912
        v___9 = (png_uint_16 )(65535U & ((temp___12 + (temp___12 >> 16)) >> 16));
#line 3913
        *sp = (png_byte )(((int )v___9 >> 8) & 0xff);
#line 3914
        *(sp + 1) = (png_byte )((int )v___9 & 0xff);
#line 3916
        temp___13 = ((png_uint_32 )g___5 * (png_uint_32 )a___6 + (png_uint_32 )png_ptr->background.green * (65535U - (png_uint_32 )a___6)) + 32768U;
#line 3916
        v___9 = (png_uint_16 )(65535U & ((temp___13 + (temp___13 >> 16)) >> 16));
#line 3917
        *(sp + 2) = (png_byte )(((int )v___9 >> 8) & 0xff);
#line 3918
        *(sp + 3) = (png_byte )((int )v___9 & 0xff);
#line 3920
        temp___14 = ((png_uint_32 )b___1 * (png_uint_32 )a___6 + (png_uint_32 )png_ptr->background.blue * (65535U - (png_uint_32 )a___6)) + 32768U;
#line 3920
        v___9 = (png_uint_16 )(65535U & ((temp___14 + (temp___14 >> 16)) >> 16));
#line 3921
        *(sp + 4) = (png_byte )(((int )v___9 >> 8) & 0xff);
#line 3922
        *(sp + 5) = (png_byte )((int )v___9 & 0xff);
      }
#line 3884
      i ++;
#line 3884
      sp += 8;
    }
    while_break___19: /* CIL Label */ ;
    }
  }
#line 3927
  goto switch_break;
  switch_default___0: /* CIL Label */
#line 3931
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3933
  return;
}
}
#line 3943 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
static void png_do_gamma(png_row_infop row_info , png_bytep row , png_structrp png_ptr )
{
  png_const_bytep gamma_table ;
  png_const_uint_16pp gamma_16_table ;
  int gamma_shift ;
  png_bytep sp ;
  png_uint_32 i ;
  png_uint_32 row_width ;
  png_uint_16 v ;
  png_uint_16 v___0 ;
  png_uint_16 v___1 ;
  int a ;
  int b ;
  int c ;
  int d ;
  int msb ;
  int lsb ;
  png_uint_16 v___2 ;

  {
#line 3946
  gamma_table = (png_const_bytep )png_ptr->gamma_table;
#line 3947
  gamma_16_table = (png_const_uint_16pp )png_ptr->gamma_16_table;
#line 3948
  gamma_shift = png_ptr->gamma_shift;
#line 3952
  row_width = row_info->width;
#line 3956
  if ((int )row_info->bit_depth <= 8) {
#line 3956
    if ((unsigned long )gamma_table != (unsigned long )((void *)0)) {
#line 3956
      goto _L;
    } else {
#line 3956
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */
#line 3956
  if ((int )row_info->bit_depth == 16) {
#line 3956
    if ((unsigned long )gamma_16_table != (unsigned long )((void *)0)) {
      _L: /* CIL Label */
      {
#line 3961
      if ((int )row_info->color_type == 2) {
#line 3961
        goto case_2;
      }
#line 4003
      if ((int )row_info->color_type == 6) {
#line 4003
        goto case_6;
      }
#line 4047
      if ((int )row_info->color_type == 4) {
#line 4047
        goto case_4;
      }
#line 4073
      if ((int )row_info->color_type == 0) {
#line 4073
        goto case_0;
      }
#line 4132
      goto switch_default;
      case_2: /* CIL Label */
#line 3963
      if ((int )row_info->bit_depth == 8) {
#line 3965
        sp = row;
#line 3966
        i = (png_uint_32 )0;
        {
#line 3966
        while (1) {
          while_continue: /* CIL Label */ ;
#line 3966
          if (! (i < row_width)) {
#line 3966
            goto while_break;
          }
#line 3968
          *sp = (png_byte )*(gamma_table + *sp);
#line 3969
          sp ++;
#line 3970
          *sp = (png_byte )*(gamma_table + *sp);
#line 3971
          sp ++;
#line 3972
          *sp = (png_byte )*(gamma_table + *sp);
#line 3973
          sp ++;
#line 3966
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
      } else {
#line 3979
        sp = row;
#line 3980
        i = (png_uint_32 )0;
        {
#line 3980
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 3980
          if (! (i < row_width)) {
#line 3980
            goto while_break___0;
          }
#line 3984
          v = *(*(gamma_16_table + ((int )*(sp + 1) >> gamma_shift)) + *sp);
#line 3985
          *sp = (png_byte )(((int )v >> 8) & 0xff);
#line 3986
          *(sp + 1) = (png_byte )((int )v & 0xff);
#line 3987
          sp += 2;
#line 3989
          v = *(*(gamma_16_table + ((int )*(sp + 1) >> gamma_shift)) + *sp);
#line 3990
          *sp = (png_byte )(((int )v >> 8) & 0xff);
#line 3991
          *(sp + 1) = (png_byte )((int )v & 0xff);
#line 3992
          sp += 2;
#line 3994
          v = *(*(gamma_16_table + ((int )*(sp + 1) >> gamma_shift)) + *sp);
#line 3995
          *sp = (png_byte )(((int )v >> 8) & 0xff);
#line 3996
          *(sp + 1) = (png_byte )((int )v & 0xff);
#line 3997
          sp += 2;
#line 3980
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 4000
      goto switch_break;
      case_6: /* CIL Label */
#line 4005
      if ((int )row_info->bit_depth == 8) {
#line 4007
        sp = row;
#line 4008
        i = (png_uint_32 )0;
        {
#line 4008
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 4008
          if (! (i < row_width)) {
#line 4008
            goto while_break___1;
          }
#line 4010
          *sp = (png_byte )*(gamma_table + *sp);
#line 4011
          sp ++;
#line 4013
          *sp = (png_byte )*(gamma_table + *sp);
#line 4014
          sp ++;
#line 4016
          *sp = (png_byte )*(gamma_table + *sp);
#line 4017
          sp ++;
#line 4019
          sp ++;
#line 4008
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
#line 4025
        sp = row;
#line 4026
        i = (png_uint_32 )0;
        {
#line 4026
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 4026
          if (! (i < row_width)) {
#line 4026
            goto while_break___2;
          }
#line 4028
          v___0 = *(*(gamma_16_table + ((int )*(sp + 1) >> gamma_shift)) + *sp);
#line 4029
          *sp = (png_byte )(((int )v___0 >> 8) & 0xff);
#line 4030
          *(sp + 1) = (png_byte )((int )v___0 & 0xff);
#line 4031
          sp += 2;
#line 4033
          v___0 = *(*(gamma_16_table + ((int )*(sp + 1) >> gamma_shift)) + *sp);
#line 4034
          *sp = (png_byte )(((int )v___0 >> 8) & 0xff);
#line 4035
          *(sp + 1) = (png_byte )((int )v___0 & 0xff);
#line 4036
          sp += 2;
#line 4038
          v___0 = *(*(gamma_16_table + ((int )*(sp + 1) >> gamma_shift)) + *sp);
#line 4039
          *sp = (png_byte )(((int )v___0 >> 8) & 0xff);
#line 4040
          *(sp + 1) = (png_byte )((int )v___0 & 0xff);
#line 4041
          sp += 4;
#line 4026
          i ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 4044
      goto switch_break;
      case_4: /* CIL Label */
#line 4049
      if ((int )row_info->bit_depth == 8) {
#line 4051
        sp = row;
#line 4052
        i = (png_uint_32 )0;
        {
#line 4052
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 4052
          if (! (i < row_width)) {
#line 4052
            goto while_break___3;
          }
#line 4054
          *sp = (png_byte )*(gamma_table + *sp);
#line 4055
          sp += 2;
#line 4052
          i ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else {
#line 4061
        sp = row;
#line 4062
        i = (png_uint_32 )0;
        {
#line 4062
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 4062
          if (! (i < row_width)) {
#line 4062
            goto while_break___4;
          }
#line 4064
          v___1 = *(*(gamma_16_table + ((int )*(sp + 1) >> gamma_shift)) + *sp);
#line 4065
          *sp = (png_byte )(((int )v___1 >> 8) & 0xff);
#line 4066
          *(sp + 1) = (png_byte )((int )v___1 & 0xff);
#line 4067
          sp += 4;
#line 4062
          i ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
#line 4070
      goto switch_break;
      case_0: /* CIL Label */
#line 4075
      if ((int )row_info->bit_depth == 2) {
#line 4077
        sp = row;
#line 4078
        i = (png_uint_32 )0;
        {
#line 4078
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 4078
          if (! (i < row_width)) {
#line 4078
            goto while_break___5;
          }
#line 4080
          a = (int )*sp & 0xc0;
#line 4081
          b = (int )*sp & 0x30;
#line 4082
          c = (int )*sp & 0x0c;
#line 4083
          d = (int )*sp & 0x03;
#line 4085
          *sp = (png_byte )(((((int )*(gamma_table + (((a | (a >> 2)) | (a >> 4)) | (a >> 6))) & 0xc0) | (((int )*(gamma_table + ((((b << 2) | b) | (b >> 2)) | (b >> 4))) >> 2) & 0x30)) | (((int )*(gamma_table + ((((c << 4) | (c << 2)) | c) | (c >> 2))) >> 4) & 0x0c)) | ((int )*(gamma_table + ((((d << 6) | (d << 4)) | (d << 2)) | d)) >> 6));
#line 4090
          sp ++;
#line 4078
          i += 4U;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
#line 4094
      if ((int )row_info->bit_depth == 4) {
#line 4096
        sp = row;
#line 4097
        i = (png_uint_32 )0;
        {
#line 4097
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 4097
          if (! (i < row_width)) {
#line 4097
            goto while_break___6;
          }
#line 4099
          msb = (int )*sp & 0xf0;
#line 4100
          lsb = (int )*sp & 0x0f;
#line 4102
          *sp = (png_byte )(((int )*(gamma_table + (msb | (msb >> 4))) & 0xf0) | ((int )*(gamma_table + ((lsb << 4) | lsb)) >> 4));
#line 4104
          sp ++;
#line 4097
          i += 2U;
        }
        while_break___6: /* CIL Label */ ;
        }
      } else
#line 4108
      if ((int )row_info->bit_depth == 8) {
#line 4110
        sp = row;
#line 4111
        i = (png_uint_32 )0;
        {
#line 4111
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 4111
          if (! (i < row_width)) {
#line 4111
            goto while_break___7;
          }
#line 4113
          *sp = (png_byte )*(gamma_table + *sp);
#line 4114
          sp ++;
#line 4111
          i ++;
        }
        while_break___7: /* CIL Label */ ;
        }
      } else
#line 4118
      if ((int )row_info->bit_depth == 16) {
#line 4120
        sp = row;
#line 4121
        i = (png_uint_32 )0;
        {
#line 4121
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 4121
          if (! (i < row_width)) {
#line 4121
            goto while_break___8;
          }
#line 4123
          v___2 = *(*(gamma_16_table + ((int )*(sp + 1) >> gamma_shift)) + *sp);
#line 4124
          *sp = (png_byte )(((int )v___2 >> 8) & 0xff);
#line 4125
          *(sp + 1) = (png_byte )((int )v___2 & 0xff);
#line 4126
          sp += 2;
#line 4121
          i ++;
        }
        while_break___8: /* CIL Label */ ;
        }
      }
#line 4129
      goto switch_break;
      switch_default: /* CIL Label */
#line 4133
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 4136
  return;
}
}
#line 4144 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
static void png_do_encode_alpha(png_row_infop row_info , png_bytep row , png_structrp png_ptr )
{
  png_uint_32 row_width ;
  png_bytep table ;
  int step ;
  int tmp ;
  png_uint_16pp table___0 ;
  int gamma_shift ;
  int step___0 ;
  int tmp___0 ;
  png_uint_16 v ;

  {
#line 4147
  row_width = row_info->width;
#line 4151
  if (((int )row_info->color_type & 4) != 0) {
#line 4153
    if ((int )row_info->bit_depth == 8) {
#line 4155
      table = png_ptr->gamma_from_1;
#line 4157
      if ((unsigned long )table != (unsigned long )((void *)0)) {
#line 4159
        if ((int )row_info->color_type & 2) {
#line 4159
          tmp = 4;
        } else {
#line 4159
          tmp = 2;
        }
#line 4159
        step = tmp;
#line 4162
        row += step - 1;
        {
#line 4164
        while (1) {
          while_continue: /* CIL Label */ ;
#line 4164
          if (! (row_width > 0U)) {
#line 4164
            goto while_break;
          }
#line 4165
          *row = *(table + *row);
#line 4164
          row_width --;
#line 4164
          row += step;
        }
        while_break: /* CIL Label */ ;
        }
#line 4167
        return;
      }
    } else
#line 4171
    if ((int )row_info->bit_depth == 16) {
#line 4173
      table___0 = png_ptr->gamma_16_from_1;
#line 4174
      gamma_shift = png_ptr->gamma_shift;
#line 4176
      if ((unsigned long )table___0 != (unsigned long )((void *)0)) {
#line 4178
        if ((int )row_info->color_type & 2) {
#line 4178
          tmp___0 = 8;
        } else {
#line 4178
          tmp___0 = 4;
        }
#line 4178
        step___0 = tmp___0;
#line 4181
        row += step___0 - 2;
        {
#line 4183
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 4183
          if (! (row_width > 0U)) {
#line 4183
            goto while_break___0;
          }
#line 4187
          v = *(*(table___0 + ((int )*(row + 1) >> gamma_shift)) + *row);
#line 4188
          *row = (png_byte )(((int )v >> 8) & 0xff);
#line 4189
          *(row + 1) = (png_byte )((int )v & 0xff);
#line 4183
          row_width --;
#line 4183
          row += step___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 4192
        return;
      }
    }
  }
#line 4200
  png_warning((png_const_structrp )png_ptr, (png_const_charp )"png_do_encode_alpha: unexpected call");
#line 4201
  return;
}
}
#line 4208 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
static void png_do_expand_palette(png_structrp png_ptr , png_row_infop row_info ,
                                  png_bytep row , png_const_colorp palette , png_const_bytep trans_alpha ,
                                  int num_trans )
{
  int shift ;
  int value ;
  png_bytep sp ;
  png_bytep dp ;
  png_uint_32 i ;
  png_uint_32 row_width ;
  png_bytep tmp ;
  png_bytep tmp___0 ;
  png_bytep tmp___1 ;
  png_bytep tmp___2 ;
  png_bytep tmp___3 ;
  png_bytep tmp___4 ;
  png_bytep tmp___5 ;
  png_bytep tmp___6 ;

  {
#line 4216
  row_width = row_info->width;
#line 4220
  if ((int )row_info->color_type == 3) {
#line 4222
    if ((int )row_info->bit_depth < 8) {
      {
#line 4226
      if ((int )row_info->bit_depth == 1) {
#line 4226
        goto case_1;
      }
#line 4253
      if ((int )row_info->bit_depth == 2) {
#line 4253
        goto case_2;
      }
#line 4276
      if ((int )row_info->bit_depth == 4) {
#line 4276
        goto case_4;
      }
#line 4299
      goto switch_default;
      case_1: /* CIL Label */
#line 4228
      sp = row + (size_t )((row_width - 1U) >> 3);
#line 4229
      dp = (row + (size_t )row_width) - 1;
#line 4230
      shift = 7 - (int )((row_width + 7U) & 7U);
#line 4231
      i = (png_uint_32 )0;
      {
#line 4231
      while (1) {
        while_continue: /* CIL Label */ ;
#line 4231
        if (! (i < row_width)) {
#line 4231
          goto while_break;
        }
#line 4233
        if (((int )*sp >> shift) & 0x01) {
#line 4234
          *dp = (png_byte )1;
        } else {
#line 4237
          *dp = (png_byte )0;
        }
#line 4239
        if (shift == 7) {
#line 4241
          shift = 0;
#line 4242
          sp --;
        } else {
#line 4246
          shift ++;
        }
#line 4248
        dp --;
#line 4231
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 4250
      goto switch_break;
      case_2: /* CIL Label */
#line 4255
      sp = row + (size_t )((row_width - 1U) >> 2);
#line 4256
      dp = (row + (size_t )row_width) - 1;
#line 4257
      shift = (int )((3U - ((row_width + 3U) & 3U)) << 1);
#line 4258
      i = (png_uint_32 )0;
      {
#line 4258
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 4258
        if (! (i < row_width)) {
#line 4258
          goto while_break___0;
        }
#line 4260
        value = ((int )*sp >> shift) & 0x03;
#line 4261
        *dp = (png_byte )value;
#line 4262
        if (shift == 6) {
#line 4264
          shift = 0;
#line 4265
          sp --;
        } else {
#line 4269
          shift += 2;
        }
#line 4271
        dp --;
#line 4258
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 4273
      goto switch_break;
      case_4: /* CIL Label */
#line 4278
      sp = row + (size_t )((row_width - 1U) >> 1);
#line 4279
      dp = (row + (size_t )row_width) - 1;
#line 4280
      shift = (int )((row_width & 1U) << 2);
#line 4281
      i = (png_uint_32 )0;
      {
#line 4281
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 4281
        if (! (i < row_width)) {
#line 4281
          goto while_break___1;
        }
#line 4283
        value = ((int )*sp >> shift) & 0x0f;
#line 4284
        *dp = (png_byte )value;
#line 4285
        if (shift == 4) {
#line 4287
          shift = 0;
#line 4288
          sp --;
        } else {
#line 4292
          shift += 4;
        }
#line 4294
        dp --;
#line 4281
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 4296
      goto switch_break;
      switch_default: /* CIL Label */
#line 4300
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 4302
      row_info->bit_depth = (png_byte )8;
#line 4303
      row_info->pixel_depth = (png_byte )8;
#line 4304
      row_info->rowbytes = (size_t )row_width;
    }
#line 4307
    if ((int )row_info->bit_depth == 8) {
#line 4310
      if (num_trans > 0) {
#line 4312
        sp = (row + (size_t )row_width) - 1;
#line 4313
        dp = (row + ((size_t )row_width << 2)) - 1;
#line 4315
        i = (png_uint_32 )0;
        {
#line 4330
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 4330
          if (! (i < row_width)) {
#line 4330
            goto while_break___2;
          }
#line 4332
          if ((int )*sp >= num_trans) {
#line 4333
            tmp = dp;
#line 4333
            dp --;
#line 4333
            *tmp = (png_byte )0xff;
          } else {
#line 4335
            tmp___0 = dp;
#line 4335
            dp --;
#line 4335
            *tmp___0 = (png_byte )*(trans_alpha + *sp);
          }
#line 4336
          tmp___1 = dp;
#line 4336
          dp --;
#line 4336
          *tmp___1 = (png_byte )(palette + *sp)->blue;
#line 4337
          tmp___2 = dp;
#line 4337
          dp --;
#line 4337
          *tmp___2 = (png_byte )(palette + *sp)->green;
#line 4338
          tmp___3 = dp;
#line 4338
          dp --;
#line 4338
          *tmp___3 = (png_byte )(palette + *sp)->red;
#line 4339
          sp --;
#line 4330
          i ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 4341
        row_info->bit_depth = (png_byte )8;
#line 4342
        row_info->pixel_depth = (png_byte )32;
#line 4343
        row_info->rowbytes = (size_t )(row_width * 4U);
#line 4344
        row_info->color_type = (png_byte )6;
#line 4345
        row_info->channels = (png_byte )4;
      } else {
#line 4350
        sp = (row + (size_t )row_width) - 1;
#line 4351
        dp = (row + (size_t )(row_width * 3U)) - 1;
#line 4352
        i = (png_uint_32 )0;
        {
#line 4360
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 4360
          if (! (i < row_width)) {
#line 4360
            goto while_break___3;
          }
#line 4362
          tmp___4 = dp;
#line 4362
          dp --;
#line 4362
          *tmp___4 = (png_byte )(palette + *sp)->blue;
#line 4363
          tmp___5 = dp;
#line 4363
          dp --;
#line 4363
          *tmp___5 = (png_byte )(palette + *sp)->green;
#line 4364
          tmp___6 = dp;
#line 4364
          dp --;
#line 4364
          *tmp___6 = (png_byte )(palette + *sp)->red;
#line 4365
          sp --;
#line 4360
          i ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 4368
        row_info->bit_depth = (png_byte )8;
#line 4369
        row_info->pixel_depth = (png_byte )24;
#line 4370
        row_info->rowbytes = (size_t )(row_width * 3U);
#line 4371
        row_info->color_type = (png_byte )2;
#line 4372
        row_info->channels = (png_byte )3;
      }
    }
  }
#line 4377
  return;
}
}
#line 4382 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
static void png_do_expand(png_row_infop row_info , png_bytep row , png_const_color_16p trans_color )
{
  int shift ;
  int value ;
  png_bytep sp ;
  png_bytep dp ;
  png_uint_32 i ;
  png_uint_32 row_width ;
  unsigned int gray ;
  int tmp ;
  png_bytep tmp___0 ;
  png_bytep tmp___1 ;
  png_bytep tmp___2 ;
  png_bytep tmp___3 ;
  unsigned int gray_high ;
  unsigned int gray_low ;
  png_bytep tmp___4 ;
  png_bytep tmp___5 ;
  png_bytep tmp___6 ;
  png_bytep tmp___7 ;
  png_bytep tmp___8 ;
  png_bytep tmp___9 ;
  png_bytep tmp___10 ;
  png_bytep tmp___11 ;
  png_byte red ;
  png_byte green ;
  png_byte blue ;
  png_bytep tmp___12 ;
  png_bytep tmp___13 ;
  png_bytep tmp___14 ;
  png_bytep tmp___15 ;
  png_bytep tmp___16 ;
  png_bytep tmp___17 ;
  png_bytep tmp___18 ;
  png_bytep tmp___19 ;
  png_byte red_high ;
  png_byte green_high ;
  png_byte blue_high ;
  png_byte red_low ;
  png_byte green_low ;
  png_byte blue_low ;
  png_bytep tmp___20 ;
  png_bytep tmp___21 ;
  png_bytep tmp___22 ;
  png_bytep tmp___23 ;
  png_bytep tmp___24 ;
  png_bytep tmp___25 ;
  png_bytep tmp___26 ;
  png_bytep tmp___27 ;
  png_bytep tmp___28 ;
  png_bytep tmp___29 ;
  png_bytep tmp___30 ;
  png_bytep tmp___31 ;
  png_bytep tmp___32 ;
  png_bytep tmp___33 ;
  png_bytep tmp___34 ;
  png_bytep tmp___35 ;

  {
#line 4389
  row_width = row_info->width;
#line 4393
  if ((int )row_info->color_type == 0) {
#line 4395
    if ((unsigned long )trans_color != (unsigned long )((void *)0)) {
#line 4395
      tmp = (int )trans_color->gray;
    } else {
#line 4395
      tmp = (int )0;
    }
#line 4395
    gray = (unsigned int )tmp;
#line 4397
    if ((int )row_info->bit_depth < 8) {
      {
#line 4401
      if ((int )row_info->bit_depth == 1) {
#line 4401
        goto case_1;
      }
#line 4429
      if ((int )row_info->bit_depth == 2) {
#line 4429
        goto case_2;
      }
#line 4454
      if ((int )row_info->bit_depth == 4) {
#line 4454
        goto case_4;
      }
#line 4478
      goto switch_default;
      case_1: /* CIL Label */
#line 4403
      gray = (gray & 1U) * 255U;
#line 4404
      sp = row + (size_t )((row_width - 1U) >> 3);
#line 4405
      dp = (row + (size_t )row_width) - 1;
#line 4406
      shift = 7 - (int )((row_width + 7U) & 7U);
#line 4407
      i = (png_uint_32 )0;
      {
#line 4407
      while (1) {
        while_continue: /* CIL Label */ ;
#line 4407
        if (! (i < row_width)) {
#line 4407
          goto while_break;
        }
#line 4409
        if (((int )*sp >> shift) & 0x01) {
#line 4410
          *dp = (png_byte )0xff;
        } else {
#line 4413
          *dp = (png_byte )0;
        }
#line 4415
        if (shift == 7) {
#line 4417
          shift = 0;
#line 4418
          sp --;
        } else {
#line 4422
          shift ++;
        }
#line 4424
        dp --;
#line 4407
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 4426
      goto switch_break;
      case_2: /* CIL Label */
#line 4431
      gray = (gray & 3U) * 85U;
#line 4432
      sp = row + (size_t )((row_width - 1U) >> 2);
#line 4433
      dp = (row + (size_t )row_width) - 1;
#line 4434
      shift = (int )((3U - ((row_width + 3U) & 3U)) << 1);
#line 4435
      i = (png_uint_32 )0;
      {
#line 4435
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 4435
        if (! (i < row_width)) {
#line 4435
          goto while_break___0;
        }
#line 4437
        value = ((int )*sp >> shift) & 0x03;
#line 4438
        *dp = (png_byte )(((value | (value << 2)) | (value << 4)) | (value << 6));
#line 4440
        if (shift == 6) {
#line 4442
          shift = 0;
#line 4443
          sp --;
        } else {
#line 4447
          shift += 2;
        }
#line 4449
        dp --;
#line 4435
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 4451
      goto switch_break;
      case_4: /* CIL Label */
#line 4456
      gray = (gray & 15U) * 17U;
#line 4457
      sp = row + (size_t )((row_width - 1U) >> 1);
#line 4458
      dp = (row + (size_t )row_width) - 1;
#line 4459
      shift = (int )((1U - ((row_width + 1U) & 1U)) << 2);
#line 4460
      i = (png_uint_32 )0;
      {
#line 4460
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 4460
        if (! (i < row_width)) {
#line 4460
          goto while_break___1;
        }
#line 4462
        value = ((int )*sp >> shift) & 0x0f;
#line 4463
        *dp = (png_byte )(value | (value << 4));
#line 4464
        if (shift == 4) {
#line 4466
          shift = 0;
#line 4467
          sp --;
        } else {
#line 4471
          shift = 4;
        }
#line 4473
        dp --;
#line 4460
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 4475
      goto switch_break;
      switch_default: /* CIL Label */
#line 4479
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 4482
      row_info->bit_depth = (png_byte )8;
#line 4483
      row_info->pixel_depth = (png_byte )8;
#line 4484
      row_info->rowbytes = (size_t )row_width;
    }
#line 4487
    if ((unsigned long )trans_color != (unsigned long )((void *)0)) {
#line 4489
      if ((int )row_info->bit_depth == 8) {
#line 4491
        gray &= 255U;
#line 4492
        sp = (row + (size_t )row_width) - 1;
#line 4493
        dp = (row + ((size_t )row_width << 1)) - 1;
#line 4495
        i = (png_uint_32 )0;
        {
#line 4495
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 4495
          if (! (i < row_width)) {
#line 4495
            goto while_break___2;
          }
#line 4497
          if (((unsigned int )*sp & 0xffU) == gray) {
#line 4498
            tmp___0 = dp;
#line 4498
            dp --;
#line 4498
            *tmp___0 = (png_byte )0;
          } else {
#line 4501
            tmp___1 = dp;
#line 4501
            dp --;
#line 4501
            *tmp___1 = (png_byte )0xff;
          }
#line 4503
          tmp___2 = dp;
#line 4503
          dp --;
#line 4503
          tmp___3 = sp;
#line 4503
          sp --;
#line 4503
          *tmp___2 = *tmp___3;
#line 4495
          i ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      } else
#line 4507
      if ((int )row_info->bit_depth == 16) {
#line 4509
        gray_high = (gray >> 8) & 255U;
#line 4510
        gray_low = gray & 255U;
#line 4511
        sp = (row + row_info->rowbytes) - 1;
#line 4512
        dp = (row + (row_info->rowbytes << 1)) - 1;
#line 4513
        i = (png_uint_32 )0;
        {
#line 4513
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 4513
          if (! (i < row_width)) {
#line 4513
            goto while_break___3;
          }
#line 4515
          if (((unsigned int )*(sp - 1) & 0xffU) == gray_high) {
#line 4515
            if (((unsigned int )*sp & 0xffU) == gray_low) {
#line 4518
              tmp___4 = dp;
#line 4518
              dp --;
#line 4518
              *tmp___4 = (png_byte )0;
#line 4519
              tmp___5 = dp;
#line 4519
              dp --;
#line 4519
              *tmp___5 = (png_byte )0;
            } else {
#line 4515
              goto _L;
            }
          } else {
            _L: /* CIL Label */
#line 4524
            tmp___6 = dp;
#line 4524
            dp --;
#line 4524
            *tmp___6 = (png_byte )0xff;
#line 4525
            tmp___7 = dp;
#line 4525
            dp --;
#line 4525
            *tmp___7 = (png_byte )0xff;
          }
#line 4528
          tmp___8 = dp;
#line 4528
          dp --;
#line 4528
          tmp___9 = sp;
#line 4528
          sp --;
#line 4528
          *tmp___8 = *tmp___9;
#line 4529
          tmp___10 = dp;
#line 4529
          dp --;
#line 4529
          tmp___11 = sp;
#line 4529
          sp --;
#line 4529
          *tmp___10 = *tmp___11;
#line 4513
          i ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 4533
      row_info->color_type = (png_byte )4;
#line 4534
      row_info->channels = (png_byte )2;
#line 4535
      row_info->pixel_depth = (png_byte )((int )row_info->bit_depth << 1);
#line 4536
      if ((int )row_info->pixel_depth >= 8) {
#line 4536
        row_info->rowbytes = (size_t )row_width * ((size_t )row_info->pixel_depth >> 3);
      } else {
#line 4536
        row_info->rowbytes = ((size_t )row_width * (size_t )row_info->pixel_depth + 7UL) >> 3;
      }
    }
  } else
#line 4540
  if ((int )row_info->color_type == 2) {
#line 4540
    if ((unsigned long )trans_color != (unsigned long )((void *)0)) {
#line 4543
      if ((int )row_info->bit_depth == 8) {
#line 4545
        red = (png_byte )((int )trans_color->red & 255);
#line 4546
        green = (png_byte )((int )trans_color->green & 255);
#line 4547
        blue = (png_byte )((int )trans_color->blue & 255);
#line 4548
        sp = (row + row_info->rowbytes) - 1;
#line 4549
        dp = (row + ((size_t )row_width << 2)) - 1;
#line 4550
        i = (png_uint_32 )0;
        {
#line 4550
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 4550
          if (! (i < row_width)) {
#line 4550
            goto while_break___4;
          }
#line 4552
          if ((int )*(sp - 2) == (int )red) {
#line 4552
            if ((int )*(sp - 1) == (int )green) {
#line 4552
              if ((int )*sp == (int )blue) {
#line 4553
                tmp___12 = dp;
#line 4553
                dp --;
#line 4553
                *tmp___12 = (png_byte )0;
              } else {
#line 4556
                tmp___13 = dp;
#line 4556
                dp --;
#line 4556
                *tmp___13 = (png_byte )0xff;
              }
            } else {
#line 4556
              tmp___13 = dp;
#line 4556
              dp --;
#line 4556
              *tmp___13 = (png_byte )0xff;
            }
          } else {
#line 4556
            tmp___13 = dp;
#line 4556
            dp --;
#line 4556
            *tmp___13 = (png_byte )0xff;
          }
#line 4558
          tmp___14 = dp;
#line 4558
          dp --;
#line 4558
          tmp___15 = sp;
#line 4558
          sp --;
#line 4558
          *tmp___14 = *tmp___15;
#line 4559
          tmp___16 = dp;
#line 4559
          dp --;
#line 4559
          tmp___17 = sp;
#line 4559
          sp --;
#line 4559
          *tmp___16 = *tmp___17;
#line 4560
          tmp___18 = dp;
#line 4560
          dp --;
#line 4560
          tmp___19 = sp;
#line 4560
          sp --;
#line 4560
          *tmp___18 = *tmp___19;
#line 4550
          i ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      } else
#line 4563
      if ((int )row_info->bit_depth == 16) {
#line 4565
        red_high = (png_byte )(((int )trans_color->red >> 8) & 255);
#line 4566
        green_high = (png_byte )(((int )trans_color->green >> 8) & 255);
#line 4567
        blue_high = (png_byte )(((int )trans_color->blue >> 8) & 255);
#line 4568
        red_low = (png_byte )((int )trans_color->red & 255);
#line 4569
        green_low = (png_byte )((int )trans_color->green & 255);
#line 4570
        blue_low = (png_byte )((int )trans_color->blue & 255);
#line 4571
        sp = (row + row_info->rowbytes) - 1;
#line 4572
        dp = (row + ((size_t )row_width << 3)) - 1;
#line 4573
        i = (png_uint_32 )0;
        {
#line 4573
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 4573
          if (! (i < row_width)) {
#line 4573
            goto while_break___5;
          }
#line 4575
          if ((int )*(sp - 5) == (int )red_high) {
#line 4575
            if ((int )*(sp - 4) == (int )red_low) {
#line 4575
              if ((int )*(sp - 3) == (int )green_high) {
#line 4575
                if ((int )*(sp - 2) == (int )green_low) {
#line 4575
                  if ((int )*(sp - 1) == (int )blue_high) {
#line 4575
                    if ((int )*sp == (int )blue_low) {
#line 4582
                      tmp___20 = dp;
#line 4582
                      dp --;
#line 4582
                      *tmp___20 = (png_byte )0;
#line 4583
                      tmp___21 = dp;
#line 4583
                      dp --;
#line 4583
                      *tmp___21 = (png_byte )0;
                    } else {
#line 4575
                      goto _L___4;
                    }
                  } else {
#line 4575
                    goto _L___4;
                  }
                } else {
#line 4575
                  goto _L___4;
                }
              } else {
#line 4575
                goto _L___4;
              }
            } else {
#line 4575
              goto _L___4;
            }
          } else {
            _L___4: /* CIL Label */
            _L___3: /* CIL Label */
            _L___2: /* CIL Label */
            _L___1: /* CIL Label */
            _L___0: /* CIL Label */
#line 4588
            tmp___22 = dp;
#line 4588
            dp --;
#line 4588
            *tmp___22 = (png_byte )0xff;
#line 4589
            tmp___23 = dp;
#line 4589
            dp --;
#line 4589
            *tmp___23 = (png_byte )0xff;
          }
#line 4592
          tmp___24 = dp;
#line 4592
          dp --;
#line 4592
          tmp___25 = sp;
#line 4592
          sp --;
#line 4592
          *tmp___24 = *tmp___25;
#line 4593
          tmp___26 = dp;
#line 4593
          dp --;
#line 4593
          tmp___27 = sp;
#line 4593
          sp --;
#line 4593
          *tmp___26 = *tmp___27;
#line 4594
          tmp___28 = dp;
#line 4594
          dp --;
#line 4594
          tmp___29 = sp;
#line 4594
          sp --;
#line 4594
          *tmp___28 = *tmp___29;
#line 4595
          tmp___30 = dp;
#line 4595
          dp --;
#line 4595
          tmp___31 = sp;
#line 4595
          sp --;
#line 4595
          *tmp___30 = *tmp___31;
#line 4596
          tmp___32 = dp;
#line 4596
          dp --;
#line 4596
          tmp___33 = sp;
#line 4596
          sp --;
#line 4596
          *tmp___32 = *tmp___33;
#line 4597
          tmp___34 = dp;
#line 4597
          dp --;
#line 4597
          tmp___35 = sp;
#line 4597
          sp --;
#line 4597
          *tmp___34 = *tmp___35;
#line 4573
          i ++;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
#line 4600
      row_info->color_type = (png_byte )6;
#line 4601
      row_info->channels = (png_byte )4;
#line 4602
      row_info->pixel_depth = (png_byte )((int )row_info->bit_depth << 2);
#line 4603
      if ((int )row_info->pixel_depth >= 8) {
#line 4603
        row_info->rowbytes = (size_t )row_width * ((size_t )row_info->pixel_depth >> 3);
      } else {
#line 4603
        row_info->rowbytes = ((size_t )row_width * (size_t )row_info->pixel_depth + 7UL) >> 3;
      }
    }
  }
#line 4605
  return;
}
}
#line 4612 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
static void png_do_expand_16(png_row_infop row_info , png_bytep row )
{
  png_byte *sp ;
  png_byte *dp ;
  png_byte tmp ;

  {
#line 4615
  if ((int )row_info->bit_depth == 8) {
#line 4615
    if ((int )row_info->color_type != 3) {
#line 4627
      sp = row + row_info->rowbytes;
#line 4628
      dp = sp + row_info->rowbytes;
      {
#line 4629
      while (1) {
        while_continue: /* CIL Label */ ;
#line 4629
        if (! ((unsigned long )dp > (unsigned long )sp)) {
#line 4629
          goto while_break;
        }
#line 4631
        sp --;
#line 4631
        tmp = *sp;
#line 4631
        *(dp + -1) = tmp;
#line 4631
        *(dp + -2) = tmp;
#line 4631
        dp -= 2;
      }
      while_break: /* CIL Label */ ;
      }
#line 4634
      row_info->rowbytes *= 2UL;
#line 4635
      row_info->bit_depth = (png_byte )16;
#line 4636
      row_info->pixel_depth = (png_byte )((int )row_info->channels * 16);
    }
  }
#line 4638
  return;
}
}
#line 4642 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
static void png_do_quantize(png_row_infop row_info , png_bytep row , png_const_bytep palette_lookup ,
                            png_const_bytep quantize_lookup )
{
  png_bytep sp ;
  png_bytep dp ;
  png_uint_32 i ;
  png_uint_32 row_width ;
  int r ;
  int g ;
  int b ;
  int p ;
  png_bytep tmp ;
  png_bytep tmp___0 ;
  png_bytep tmp___1 ;
  png_bytep tmp___2 ;
  int r___0 ;
  int g___0 ;
  int b___0 ;
  int p___0 ;
  png_bytep tmp___3 ;
  png_bytep tmp___4 ;
  png_bytep tmp___5 ;
  png_bytep tmp___6 ;

  {
#line 4648
  row_width = row_info->width;
#line 4652
  if ((int )row_info->bit_depth == 8) {
#line 4654
    if ((int )row_info->color_type == 2) {
#line 4654
      if (palette_lookup) {
#line 4657
        sp = row;
#line 4658
        dp = row;
#line 4659
        i = (png_uint_32 )0;
        {
#line 4659
        while (1) {
          while_continue: /* CIL Label */ ;
#line 4659
          if (! (i < row_width)) {
#line 4659
            goto while_break;
          }
#line 4661
          tmp = sp;
#line 4661
          sp ++;
#line 4661
          r = (int )*tmp;
#line 4662
          tmp___0 = sp;
#line 4662
          sp ++;
#line 4662
          g = (int )*tmp___0;
#line 4663
          tmp___1 = sp;
#line 4663
          sp ++;
#line 4663
          b = (int )*tmp___1;
#line 4672
          p = ((((r >> 3) & ((1 << 5) - 1)) << 10) | (((g >> 3) & ((1 << 5) - 1)) << 5)) | ((b >> 3) & ((1 << 5) - 1));
#line 4681
          tmp___2 = dp;
#line 4681
          dp ++;
#line 4681
          *tmp___2 = (png_byte )*(palette_lookup + p);
#line 4659
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 4684
        row_info->color_type = (png_byte )3;
#line 4685
        row_info->channels = (png_byte )1;
#line 4686
        row_info->pixel_depth = row_info->bit_depth;
#line 4687
        if ((int )row_info->pixel_depth >= 8) {
#line 4687
          row_info->rowbytes = (size_t )row_width * ((size_t )row_info->pixel_depth >> 3);
        } else {
#line 4687
          row_info->rowbytes = ((size_t )row_width * (size_t )row_info->pixel_depth + 7UL) >> 3;
        }
      } else {
#line 4654
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */
#line 4690
    if ((int )row_info->color_type == 6) {
#line 4690
      if ((unsigned long )palette_lookup != (unsigned long )((void *)0)) {
#line 4694
        sp = row;
#line 4695
        dp = row;
#line 4696
        i = (png_uint_32 )0;
        {
#line 4696
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 4696
          if (! (i < row_width)) {
#line 4696
            goto while_break___0;
          }
#line 4698
          tmp___3 = sp;
#line 4698
          sp ++;
#line 4698
          r___0 = (int )*tmp___3;
#line 4699
          tmp___4 = sp;
#line 4699
          sp ++;
#line 4699
          g___0 = (int )*tmp___4;
#line 4700
          tmp___5 = sp;
#line 4700
          sp ++;
#line 4700
          b___0 = (int )*tmp___5;
#line 4701
          sp ++;
#line 4703
          p___0 = ((((r___0 >> 3) & ((1 << 5) - 1)) << 10) | (((g___0 >> 3) & ((1 << 5) - 1)) << 5)) | ((b___0 >> 3) & ((1 << 5) - 1));
#line 4712
          tmp___6 = dp;
#line 4712
          dp ++;
#line 4712
          *tmp___6 = (png_byte )*(palette_lookup + p___0);
#line 4696
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 4715
        row_info->color_type = (png_byte )3;
#line 4716
        row_info->channels = (png_byte )1;
#line 4717
        row_info->pixel_depth = row_info->bit_depth;
#line 4718
        if ((int )row_info->pixel_depth >= 8) {
#line 4718
          row_info->rowbytes = (size_t )row_width * ((size_t )row_info->pixel_depth >> 3);
        } else {
#line 4718
          row_info->rowbytes = ((size_t )row_width * (size_t )row_info->pixel_depth + 7UL) >> 3;
        }
      } else {
#line 4690
        goto _L;
      }
    } else
    _L: /* CIL Label */
#line 4721
    if ((int )row_info->color_type == 3) {
#line 4721
      if (quantize_lookup) {
#line 4724
        sp = row;
#line 4726
        i = (png_uint_32 )0;
        {
#line 4726
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 4726
          if (! (i < row_width)) {
#line 4726
            goto while_break___1;
          }
#line 4728
          *sp = (png_byte )*(quantize_lookup + *sp);
#line 4726
          i ++;
#line 4726
          sp ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
  }
#line 4732
  return;
}
}
#line 4739 "/home/goblint2/bench/libpng-1.6.39/pngrtran.c"
void png_do_read_transformations(png_structrp png_ptr , png_row_infop row_info )
{
  int rgb_error ;
  int tmp ;

  {
#line 4744
  if ((unsigned long )png_ptr->row_buf == (unsigned long )((void *)0)) {
#line 4750
    png_error((png_const_structrp )png_ptr, (png_const_charp )"NULL row buffer");
  }
#line 4759
  if ((png_ptr->flags & 0x4000U) != 0U) {
#line 4759
    if ((png_ptr->flags & 0x0040U) == 0U) {
#line 4766
      png_error((png_const_structrp )png_ptr, (png_const_charp )"Uninitialized row");
    }
  }
#line 4770
  if ((png_ptr->transformations & 0x1000U) != 0U) {
#line 4772
    if ((int )row_info->color_type == 3) {
#line 4786
      png_do_expand_palette(png_ptr, row_info, png_ptr->row_buf + 1, (png_const_colorp )png_ptr->palette,
                            (png_const_bytep )png_ptr->trans_alpha, (int )png_ptr->num_trans);
    } else
#line 4792
    if ((int )png_ptr->num_trans != 0) {
#line 4792
      if ((png_ptr->transformations & 0x2000000U) != 0U) {
#line 4794
        png_do_expand(row_info, png_ptr->row_buf + 1, (png_const_color_16p )(& png_ptr->trans_color));
      } else {
#line 4798
        png_do_expand(row_info, png_ptr->row_buf + 1, (png_const_color_16p )((void *)0));
      }
    } else {
#line 4798
      png_do_expand(row_info, png_ptr->row_buf + 1, (png_const_color_16p )((void *)0));
    }
  }
#line 4804
  if ((png_ptr->transformations & 0x40000U) != 0U) {
#line 4804
    if ((png_ptr->transformations & 0x0080U) == 0U) {
#line 4804
      if ((int )row_info->color_type == 6) {
#line 4808
        png_do_strip_channel(row_info, png_ptr->row_buf + 1, 0);
      } else
#line 4804
      if ((int )row_info->color_type == 4) {
#line 4808
        png_do_strip_channel(row_info, png_ptr->row_buf + 1, 0);
      }
    }
  }
#line 4813
  if ((png_ptr->transformations & 0x600000U) != 0U) {
#line 4815
    tmp = png_do_rgb_to_gray(png_ptr, row_info, png_ptr->row_buf + 1);
#line 4815
    rgb_error = tmp;
#line 4819
    if (rgb_error != 0) {
#line 4821
      png_ptr->rgb_to_gray_status = (png_byte )1;
#line 4822
      if ((png_ptr->transformations & 0x600000U) == 0x400000U) {
#line 4824
        png_warning((png_const_structrp )png_ptr, (png_const_charp )"png_do_rgb_to_gray found nongray pixel");
      }
#line 4826
      if ((png_ptr->transformations & 0x600000U) == 0x200000U) {
#line 4828
        png_error((png_const_structrp )png_ptr, (png_const_charp )"png_do_rgb_to_gray found nongray pixel");
      }
    }
  }
#line 4868
  if ((png_ptr->transformations & 0x4000U) != 0U) {
#line 4868
    if ((png_ptr->mode & 0x800U) == 0U) {
#line 4870
      png_do_gray_to_rgb(row_info, png_ptr->row_buf + 1);
    }
  }
#line 4875
  if ((png_ptr->transformations & 0x0080U) != 0U) {
#line 4876
    png_do_compose(row_info, png_ptr->row_buf + 1, png_ptr);
  }
#line 4880
  if ((png_ptr->transformations & 0x2000U) != 0U) {
#line 4880
    if ((png_ptr->transformations & 0x600000U) == 0U) {
#line 4880
      if ((png_ptr->transformations & 0x0080U) != 0U) {
#line 4880
        if (! ((int )png_ptr->num_trans != 0)) {
#line 4880
          if (! (((int )png_ptr->color_type & 4) != 0)) {
#line 4880
            goto _L;
          }
        }
      } else
      _L: /* CIL Label */
#line 4880
      if ((int )png_ptr->color_type != 3) {
#line 4898
        png_do_gamma(row_info, png_ptr->row_buf + 1, png_ptr);
      }
    }
  }
#line 4902
  if ((png_ptr->transformations & 0x40000U) != 0U) {
#line 4902
    if ((png_ptr->transformations & 0x0080U) != 0U) {
#line 4902
      if ((int )row_info->color_type == 6) {
#line 4906
        png_do_strip_channel(row_info, png_ptr->row_buf + 1, 0);
      } else
#line 4902
      if ((int )row_info->color_type == 4) {
#line 4906
        png_do_strip_channel(row_info, png_ptr->row_buf + 1, 0);
      }
    }
  }
#line 4911
  if ((png_ptr->transformations & 0x800000U) != 0U) {
#line 4911
    if (((int )row_info->color_type & 4) != 0) {
#line 4913
      png_do_encode_alpha(row_info, png_ptr->row_buf + 1, png_ptr);
    }
  }
#line 4917
  if ((png_ptr->transformations & 0x4000000U) != 0U) {
#line 4918
    png_do_scale_16_to_8(row_info, png_ptr->row_buf + 1);
  }
#line 4926
  if ((png_ptr->transformations & 0x0400U) != 0U) {
#line 4927
    png_do_chop(row_info, png_ptr->row_buf + 1);
  }
#line 4931
  if ((png_ptr->transformations & 0x0040U) != 0U) {
#line 4933
    png_do_quantize(row_info, png_ptr->row_buf + 1, (png_const_bytep )png_ptr->palette_lookup,
                    (png_const_bytep )png_ptr->quantize_index);
#line 4936
    if (row_info->rowbytes == 0UL) {
#line 4937
      png_error((png_const_structrp )png_ptr, (png_const_charp )"png_do_quantize returned rowbytes=0");
    }
  }
#line 4947
  if ((png_ptr->transformations & 0x0200U) != 0U) {
#line 4948
    png_do_expand_16(row_info, png_ptr->row_buf + 1);
  }
#line 4953
  if ((png_ptr->transformations & 0x4000U) != 0U) {
#line 4953
    if ((png_ptr->mode & 0x800U) != 0U) {
#line 4955
      png_do_gray_to_rgb(row_info, png_ptr->row_buf + 1);
    }
  }
#line 4959
  if ((png_ptr->transformations & 0x0020U) != 0U) {
#line 4960
    png_do_invert(row_info, png_ptr->row_buf + 1);
  }
#line 4964
  if ((png_ptr->transformations & 0x80000U) != 0U) {
#line 4965
    png_do_read_invert_alpha(row_info, png_ptr->row_buf + 1);
  }
#line 4969
  if ((png_ptr->transformations & 0x0008U) != 0U) {
#line 4970
    png_do_unshift(row_info, png_ptr->row_buf + 1, (png_const_color_8p )(& png_ptr->shift));
  }
#line 4975
  if ((png_ptr->transformations & 0x0004U) != 0U) {
#line 4976
    png_do_unpack(row_info, png_ptr->row_buf + 1);
  }
#line 4981
  if ((int )row_info->color_type == 3) {
#line 4981
    if (png_ptr->num_palette_max >= 0) {
#line 4983
      png_do_check_palette_indexes(png_ptr, row_info);
    }
  }
#line 4987
  if ((png_ptr->transformations & 0x0001U) != 0U) {
#line 4988
    png_do_bgr(row_info, png_ptr->row_buf + 1);
  }
#line 4992
  if ((png_ptr->transformations & 0x10000U) != 0U) {
#line 4993
    png_do_packswap(row_info, png_ptr->row_buf + 1);
  }
#line 4997
  if ((png_ptr->transformations & 0x8000U) != 0U) {
#line 4998
    png_do_read_filler(row_info, png_ptr->row_buf + 1, (png_uint_32 )png_ptr->filler,
                       png_ptr->flags);
  }
#line 5003
  if ((png_ptr->transformations & 0x20000U) != 0U) {
#line 5004
    png_do_read_swap_alpha(row_info, png_ptr->row_buf + 1);
  }
#line 5009
  if ((png_ptr->transformations & 0x0010U) != 0U) {
#line 5010
    png_do_swap(row_info, png_ptr->row_buf + 1);
  }
#line 5015
  if ((png_ptr->transformations & 0x100000U) != 0U) {
#line 5017
    if ((unsigned long )png_ptr->read_user_transform_fn != (unsigned long )((void *)0)) {
#line 5018
      (*(png_ptr->read_user_transform_fn))((png_structp )png_ptr, row_info, png_ptr->row_buf + 1);
    }
#line 5029
    if ((int )png_ptr->user_transform_depth != 0) {
#line 5030
      row_info->bit_depth = png_ptr->user_transform_depth;
    }
#line 5032
    if ((int )png_ptr->user_transform_channels != 0) {
#line 5033
      row_info->channels = png_ptr->user_transform_channels;
    }
#line 5035
    row_info->pixel_depth = (png_byte )((int )row_info->bit_depth * (int )row_info->channels);
#line 5038
    if ((int )row_info->pixel_depth >= 8) {
#line 5038
      row_info->rowbytes = (size_t )row_info->width * ((size_t )row_info->pixel_depth >> 3);
    } else {
#line 5038
      row_info->rowbytes = ((size_t )row_info->width * (size_t )row_info->pixel_depth + 7UL) >> 3;
    }
  }
#line 5041
  return;
}
}
#line 101 "/usr/include/stdlib.h"
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 104
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 107
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 112
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__leaf__, __gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__,
__nothrow__)) ;
#line 820
__inline extern void *( __attribute__((__warn_unused_result__, __nonnull__(1,2,5),
__gnu_inline__)) bsearch)(void const   *__key , void const   *__base , size_t __nmemb ,
                          size_t __size , int (*__compar)(void const   * , void const   * ) ) ;
#line 929
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar )  __attribute__((__nothrow__)) ;
#line 933
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t *__dst , char const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 936
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) wcstombs)(char *__dst , wchar_t const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 43 "/usr/include/string.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memcpy)(void *__dest , void const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 47
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 61
__inline extern void *( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) memset)(void *__dest , int __ch , size_t __len )  __attribute__((__nothrow__)) ;
#line 122
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcpy)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 125
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncpy)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 130
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcat)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 133
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncat)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 326 "/usr/include/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) fprintf)(FILE *__stream ,
                                                                                                  char const   *__fmt
                                                                                                  , ...) ;
#line 332
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) printf)(char const   *__fmt
                                                                                                 , ...) ;
#line 334
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) sprintf)(char *__s ,
                                                                                                            char const   *__fmt
                                                                                                            , ...)  __attribute__((__nothrow__)) ;
#line 341
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vfprintf)(FILE *__stream ,
                                                                                                   char const   *__fmt ,
                                                                                                   __gnuc_va_list __ap ) ;
#line 347
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vprintf)(char const   *__fmt ,
                                                                                                  __gnuc_va_list __ap ) ;
#line 349
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vsprintf)(char *__s ,
                                                                                                             char const   *__fmt ,
                                                                                                             __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 354
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) snprintf)(char *__s , size_t __n , char const   *__fmt
                                              , ...)  __attribute__((__nothrow__)) ;
#line 358
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) vsnprintf)(char *__s , size_t __n , char const   *__fmt ,
                                               __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 492
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
#line 528
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
#line 564
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fgets)(char *__s , int __n , FILE *__stream ) ;
#line 646
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fread)(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 360 "/usr/include/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) read)(int __fd , void *__buf , size_t __nbytes ) ;
#line 511
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size )  __attribute__((__nothrow__)) ;
#line 689
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list )  __attribute__((__nothrow__)) ;
#line 774
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                               size_t __buflen )  __attribute__((__nothrow__)) ;
#line 21 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
png_uint_32 png_get_uint_31(png_const_structrp png_ptr , png_const_bytep buf )
{
  png_uint_32 uval ;

  {
#line 24
  uval = ((((png_uint_32 )*buf << 24) + ((png_uint_32 )*(buf + 1) << 16)) + ((png_uint_32 )*(buf + 2) << 8)) + (png_uint_32 )*(buf + 3);
#line 26
  if (uval > 2147483647U) {
#line 27
    png_error(png_ptr, (png_const_charp )"PNG unsigned integer out of range");
  }
#line 29
  return (uval);
}
}
#line 40 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
static png_fixed_point png_get_fixed_point(png_structrp png_ptr , png_const_bytep buf )
{
  png_uint_32 uval ;

  {
#line 43
  uval = ((((png_uint_32 )*buf << 24) + ((png_uint_32 )*(buf + 1) << 16)) + ((png_uint_32 )*(buf + 2) << 8)) + (png_uint_32 )*(buf + 3);
#line 45
  if (uval <= 2147483647U) {
#line 46
    return ((png_fixed_point )uval);
  }
#line 49
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 50
    png_warning((png_const_structrp )png_ptr, (png_const_charp )"PNG fixed point integer out of range");
  }
#line 52
  return (-1);
}
}
#line 67 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
png_uint_32 png_get_uint_32(png_const_bytep buf )
{
  png_uint_32 uval ;

  {
#line 70
  uval = ((((png_uint_32 )*buf << 24) + ((png_uint_32 )*(buf + 1) << 16)) + ((png_uint_32 )*(buf + 2) << 8)) + (png_uint_32 )*(buf + 3);
#line 76
  return (uval);
}
}
#line 84 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
png_int_32 png_get_int_32(png_const_bytep buf )
{
  png_uint_32 uval ;

  {
#line 87
  uval = ((((png_uint_32 )*buf << 24) + ((png_uint_32 )*(buf + 1) << 16)) + ((png_uint_32 )*(buf + 2) << 8)) + (png_uint_32 )*(buf + 3);
#line 88
  if ((uval & 0x80000000) == 0U) {
#line 89
    return ((png_int_32 )uval);
  }
#line 91
  uval = (uval ^ 0xffffffff) + 1U;
#line 92
  if ((uval & 0x80000000) == 0U) {
#line 93
    return (- ((png_int_32 )uval));
  }
#line 98
  return (0);
}
}
#line 102 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
png_uint_16 png_get_uint_16(png_const_bytep buf )
{
  unsigned int val ;

  {
#line 110
  val = ((unsigned int )*buf << 8) + (unsigned int )*(buf + 1);
#line 114
  return ((png_uint_16 )val);
}
}
#line 120 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
void png_read_sig(png_structrp png_ptr , png_inforp info_ptr )
{
  size_t num_checked ;
  size_t num_to_check ;
  int tmp ;
  int tmp___0 ;

  {
#line 126
  if ((int )png_ptr->sig_bytes >= 8) {
#line 127
    return;
  }
#line 129
  num_checked = (size_t )png_ptr->sig_bytes;
#line 130
  num_to_check = 8UL - num_checked;
#line 133
  png_ptr->io_state = (png_uint_32 )17;
#line 137
  png_read_data(png_ptr, & info_ptr->signature[num_checked], num_to_check);
#line 138
  png_ptr->sig_bytes = (png_byte )8;
#line 140
  tmp___0 = png_sig_cmp((png_const_bytep )(info_ptr->signature), num_checked, num_to_check);
#line 140
  if (tmp___0 != 0) {
#line 142
    if (num_checked < 4UL) {
#line 142
      tmp = png_sig_cmp((png_const_bytep )(info_ptr->signature), num_checked, num_to_check - 4UL);
#line 142
      if (tmp) {
#line 144
        png_error((png_const_structrp )png_ptr, (png_const_charp )"Not a PNG file");
      } else {
#line 146
        png_error((png_const_structrp )png_ptr, (png_const_charp )"PNG file corrupted by ASCII conversion");
      }
    } else {
#line 146
      png_error((png_const_structrp )png_ptr, (png_const_charp )"PNG file corrupted by ASCII conversion");
    }
  }
#line 148
  if (num_checked < 3UL) {
#line 149
    png_ptr->mode |= 0x1000U;
  }
#line 150
  return;
}
}
#line 155 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
png_uint_32 png_read_chunk_header(png_structrp png_ptr )
{
  png_byte buf[8] ;
  png_uint_32 length ;

  {
#line 162
  png_ptr->io_state = (png_uint_32 )33;
#line 168
  png_read_data(png_ptr, buf, (size_t )8);
#line 169
  length = png_get_uint_31((png_const_structrp )png_ptr, (png_const_bytep )(buf));
#line 172
  png_ptr->chunk_name = ((((png_uint_32 )(0xff & (int )*((buf + 4) + 0)) << 24) | ((png_uint_32 )(0xff & (int )*((buf + 4) + 1)) << 16)) | ((png_uint_32 )(0xff & (int )*((buf + 4) + 2)) << 8)) | (png_uint_32 )(0xff & (int )*((buf + 4) + 3));
#line 178
  png_reset_crc(png_ptr);
#line 179
  png_calculate_crc(png_ptr, (png_const_bytep )(buf + 4), (size_t )4);
#line 182
  png_check_chunk_name((png_const_structrp )png_ptr, png_ptr->chunk_name);
#line 185
  png_check_chunk_length((png_const_structrp )png_ptr, length);
#line 188
  png_ptr->io_state = (png_uint_32 )65;
#line 191
  return (length);
}
}
#line 195 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
void png_crc_read(png_structrp png_ptr , png_bytep buf , png_uint_32 length )
{


  {
#line 198
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 199
    return;
  }
#line 201
  png_read_data(png_ptr, buf, (size_t )length);
#line 202
  png_calculate_crc(png_ptr, (png_const_bytep )buf, (size_t )length);
#line 203
  return;
}
}
#line 210 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
int png_crc_finish(png_structrp png_ptr , png_uint_32 skip )
{
  png_uint_32 len ;
  png_byte tmpbuf[1024] ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 216
    if (! (skip > 0U)) {
#line 216
      goto while_break;
    }
#line 221
    len = (png_uint_32 )sizeof(tmpbuf);
#line 222
    if (len > skip) {
#line 223
      len = skip;
    }
#line 224
    skip -= len;
#line 226
    png_crc_read(png_ptr, tmpbuf, len);
  }
  while_break: /* CIL Label */ ;
  }
#line 229
  tmp___0 = png_crc_error(png_ptr);
#line 229
  if (tmp___0 != 0) {
#line 231
    if ((1U & (png_ptr->chunk_name >> 29)) != 0U) {
#line 231
      tmp = (png_ptr->flags & 0x0200U) == 0U;
    } else {
#line 231
      tmp = (png_ptr->flags & 0x0400U) != 0U;
    }
#line 231
    if (tmp) {
#line 235
      png_chunk_warning((png_const_structrp )png_ptr, (png_const_charp )"CRC error");
    } else {
#line 239
      png_chunk_error((png_const_structrp )png_ptr, (png_const_charp )"CRC error");
    }
#line 241
    return (1);
  }
#line 244
  return (0);
}
}
#line 250 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
int png_crc_error(png_structrp png_ptr )
{
  png_byte crc_bytes[4] ;
  png_uint_32 crc ;
  int need_crc ;

  {
#line 255
  need_crc = 1;
#line 257
  if ((1U & (png_ptr->chunk_name >> 29)) != 0U) {
#line 259
    if ((png_ptr->flags & 768U) == 768U) {
#line 261
      need_crc = 0;
    }
  } else
#line 266
  if ((png_ptr->flags & 0x0800U) != 0U) {
#line 267
    need_crc = 0;
  }
#line 271
  png_ptr->io_state = (png_uint_32 )129;
#line 275
  png_read_data(png_ptr, crc_bytes, (size_t )4);
#line 277
  if (need_crc != 0) {
#line 279
    crc = ((((png_uint_32 )crc_bytes[0] << 24) + ((png_uint_32 )*(crc_bytes + 1) << 16)) + ((png_uint_32 )*(crc_bytes + 2) << 8)) + (png_uint_32 )*(crc_bytes + 3);
#line 280
    return (crc != png_ptr->crc);
  } else {
#line 284
    return (0);
  }
}
}
#line 297 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
static png_bytep png_read_buffer(png_structrp png_ptr , png_alloc_size_t new_size ,
                                 int warn )
{
  png_bytep buffer___0 ;
  png_voidp __attribute__((__malloc__))  tmp ;

  {
#line 300
  buffer___0 = png_ptr->read_buffer;
#line 302
  if ((unsigned long )buffer___0 != (unsigned long )((void *)0)) {
#line 302
    if (new_size > png_ptr->read_buffer_size) {
#line 304
      png_ptr->read_buffer = (png_bytep )((void *)0);
#line 305
      png_ptr->read_buffer_size = (png_alloc_size_t )0;
#line 306
      png_free((png_const_structrp )png_ptr, (png_voidp )buffer___0);
#line 307
      buffer___0 = (png_bytep )((void *)0);
    }
  }
#line 310
  if ((unsigned long )buffer___0 == (unsigned long )((void *)0)) {
#line 312
    tmp = png_malloc_base((png_const_structrp )png_ptr, new_size);
#line 312
    buffer___0 = (png_bytep )tmp;
#line 314
    if ((unsigned long )buffer___0 != (unsigned long )((void *)0)) {
#line 316
      memset((void *)buffer___0, 0, new_size);
#line 317
      png_ptr->read_buffer = buffer___0;
#line 318
      png_ptr->read_buffer_size = new_size;
    } else
#line 321
    if (warn < 2) {
#line 323
      if (warn != 0) {
#line 324
        png_chunk_warning((png_const_structrp )png_ptr, (png_const_charp )"insufficient memory to read chunk");
      } else {
#line 327
        png_chunk_error((png_const_structrp )png_ptr, (png_const_charp )"insufficient memory to read chunk");
      }
    }
  }
#line 331
  return (buffer___0);
}
}
#line 340 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
static int png_inflate_claim(png_structrp png_ptr , png_uint_32 owner )
{
  char msg[64] ;
  int ret ;
  int window_bits ;

  {
#line 343
  if (png_ptr->zowner != 0U) {
#line 347
    msg[0] = (char )((png_ptr->zowner >> 24) & 255U);
#line 347
    msg[1] = (char )((png_ptr->zowner >> 16) & 255U);
#line 347
    msg[2] = (char )((png_ptr->zowner >> 8) & 255U);
#line 347
    msg[3] = (char )(png_ptr->zowner & 255U);
#line 352
    png_safecat(msg, sizeof(msg), (size_t )4, (png_const_charp )" using zstream");
#line 354
    png_chunk_warning((png_const_structrp )png_ptr, (png_const_charp )(msg));
#line 355
    png_ptr->zowner = (png_uint_32 )0;
  }
#line 377
  window_bits = 0;
#line 380
  if (((png_ptr->options >> 2) & 3U) == 3U) {
#line 383
    window_bits = 15;
#line 384
    png_ptr->zstream_start = (png_byte )0;
  } else {
#line 389
    png_ptr->zstream_start = (png_byte )1;
  }
#line 398
  png_ptr->zstream.next_in = (Bytef const   *)((void *)0);
#line 399
  png_ptr->zstream.avail_in = (uInt )0;
#line 400
  png_ptr->zstream.next_out = (Bytef *)((void *)0);
#line 401
  png_ptr->zstream.avail_out = (uInt )0;
#line 403
  if ((png_ptr->flags & 0x0002U) != 0U) {
#line 406
    ret = inflateReset2(& png_ptr->zstream, window_bits);
  } else {
#line 415
    ret = inflateInit2_(& png_ptr->zstream, window_bits, (char const   *)"1.2.11",
                        (int )sizeof(z_stream ));
#line 420
    if (ret == 0) {
#line 421
      png_ptr->flags |= 0x0002U;
    }
  }
#line 426
  if (((png_ptr->options >> 8) & 3U) == 3U) {
#line 428
    ret = inflateValidate(& png_ptr->zstream, 0);
  }
#line 431
  if (ret == 0) {
#line 432
    png_ptr->zowner = owner;
  } else {
#line 435
    png_zstream_error(png_ptr, ret);
  }
#line 437
  return (ret);
}
}
#line 452 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
int png_zlib_inflate(png_structrp png_ptr , int flush )
{
  int tmp ;

  {
#line 455
  if (png_ptr->zstream_start) {
#line 455
    if (png_ptr->zstream.avail_in > 0U) {
#line 457
      if ((int const   )*(png_ptr->zstream.next_in) >> 4 > 7) {
#line 459
        png_ptr->zstream.msg = (char const   *)"invalid window size (libpng)";
#line 460
        return (-3);
      }
#line 463
      png_ptr->zstream_start = (png_byte )0;
    }
  }
#line 466
  tmp = inflate(& png_ptr->zstream, flush);
#line 466
  return (tmp);
}
}
#line 483 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
static int png_inflate(png_structrp png_ptr , png_uint_32 owner , int finish , png_const_bytep input ,
                       png_uint_32p input_size_ptr , png_bytep output , png_alloc_size_t *output_size_ptr )
{
  int ret ;
  png_alloc_size_t avail_out ;
  png_uint_32 avail_in ;
  uInt avail ;
  Byte local_buffer[1024] ;
  int tmp ;
  int tmp___0 ;

  {
#line 488
  if (png_ptr->zowner == owner) {
#line 491
    avail_out = *output_size_ptr;
#line 492
    avail_in = *input_size_ptr;
#line 503
    png_ptr->zstream.next_in = input;
#line 505
    png_ptr->zstream.avail_in = (uInt )0;
#line 506
    png_ptr->zstream.avail_out = (uInt )0;
#line 511
    if ((unsigned long )output != (unsigned long )((void *)0)) {
#line 512
      png_ptr->zstream.next_out = output;
    }
    {
#line 514
    while (1) {
      while_continue: /* CIL Label */ ;
#line 527
      avail_in += png_ptr->zstream.avail_in;
#line 529
      avail = (uInt )-1;
#line 531
      if (avail_in < avail) {
#line 532
        avail = avail_in;
      }
#line 534
      avail_in -= avail;
#line 535
      png_ptr->zstream.avail_in = avail;
#line 538
      avail_out += (png_alloc_size_t )png_ptr->zstream.avail_out;
#line 540
      avail = (uInt )-1;
#line 542
      if ((unsigned long )output == (unsigned long )((void *)0)) {
#line 547
        png_ptr->zstream.next_out = local_buffer;
#line 548
        if (sizeof(local_buffer) < (unsigned long )avail) {
#line 549
          avail = (uInt )sizeof(local_buffer);
        }
      }
#line 552
      if (avail_out < (png_alloc_size_t )avail) {
#line 553
        avail = (uInt )avail_out;
      }
#line 555
      png_ptr->zstream.avail_out = avail;
#line 556
      avail_out -= (png_alloc_size_t )avail;
#line 564
      if (avail_out > 0UL) {
#line 564
        tmp___0 = 0;
      } else {
#line 564
        if (finish) {
#line 564
          tmp = 4;
        } else {
#line 564
          tmp = 2;
        }
#line 564
        tmp___0 = tmp;
      }
#line 564
      ret = png_zlib_inflate(png_ptr, tmp___0);
#line 514
      if (! (ret == 0)) {
#line 514
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 569
    if ((unsigned long )output == (unsigned long )((void *)0)) {
#line 570
      png_ptr->zstream.next_out = (Bytef *)((void *)0);
    }
#line 573
    avail_in += png_ptr->zstream.avail_in;
#line 574
    avail_out += (png_alloc_size_t )png_ptr->zstream.avail_out;
#line 579
    if (avail_out > 0UL) {
#line 580
      *output_size_ptr -= avail_out;
    }
#line 582
    if (avail_in > 0U) {
#line 583
      *input_size_ptr -= avail_in;
    }
#line 586
    png_zstream_error(png_ptr, ret);
#line 587
    return (ret);
  } else {
#line 596
    png_ptr->zstream.msg = (char const   *)"zstream unclaimed";
#line 597
    return (-2);
  }
}
}
#line 608 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
static int png_decompress_chunk(png_structrp png_ptr , png_uint_32 chunklength , png_uint_32 prefix_size ,
                                png_alloc_size_t *newlength , int terminate )
{
  png_alloc_size_t limit ;
  int ret ;
  png_uint_32 lzsize ;
  png_alloc_size_t new_size ;
  png_alloc_size_t buffer_size ;
  png_bytep text ;
  png_voidp __attribute__((__malloc__))  tmp ;
  png_bytep old_ptr ;
  int tmp___0 ;

  {
#line 621
  limit = (size_t )-1;
#line 624
  if (png_ptr->user_chunk_malloc_max > 0UL) {
#line 624
    if (png_ptr->user_chunk_malloc_max < limit) {
#line 626
      limit = png_ptr->user_chunk_malloc_max;
    }
  }
#line 632
  if (limit >= (png_alloc_size_t )(prefix_size + (png_uint_32 )(terminate != 0))) {
#line 636
    limit -= (png_alloc_size_t )(prefix_size + (png_uint_32 )(terminate != 0));
#line 638
    if (limit < *newlength) {
#line 639
      *newlength = limit;
    }
#line 642
    ret = png_inflate_claim(png_ptr, png_ptr->chunk_name);
#line 644
    if (ret == 0) {
#line 646
      lzsize = chunklength - prefix_size;
#line 648
      ret = png_inflate(png_ptr, png_ptr->chunk_name, 1, (png_const_bytep )(png_ptr->read_buffer + prefix_size),
                        & lzsize, (png_bytep )((void *)0), newlength);
#line 652
      if (ret == 1) {
#line 661
        tmp___0 = inflateReset(& png_ptr->zstream);
#line 661
        if (tmp___0 == 0) {
#line 668
          new_size = *newlength;
#line 669
          buffer_size = ((png_alloc_size_t )prefix_size + new_size) + (png_alloc_size_t )(terminate != 0);
#line 671
          tmp = png_malloc_base((png_const_structrp )png_ptr, buffer_size);
#line 671
          text = (png_bytep )tmp;
#line 674
          if ((unsigned long )text != (unsigned long )((void *)0)) {
#line 676
            memset((void *)text, 0, buffer_size);
#line 678
            ret = png_inflate(png_ptr, png_ptr->chunk_name, 1, (png_const_bytep )(png_ptr->read_buffer + prefix_size),
                              & lzsize, text + prefix_size, newlength);
#line 682
            if (ret == 1) {
#line 684
              if (new_size == *newlength) {
#line 686
                if (terminate != 0) {
#line 687
                  *(text + ((png_alloc_size_t )prefix_size + *newlength)) = (png_byte )0;
                }
#line 689
                if (prefix_size > 0U) {
#line 690
                  memcpy((void *)text, (void const   *)png_ptr->read_buffer, (size_t )prefix_size);
                }
#line 693
                old_ptr = png_ptr->read_buffer;
#line 695
                png_ptr->read_buffer = text;
#line 696
                png_ptr->read_buffer_size = buffer_size;
#line 697
                text = old_ptr;
              } else {
#line 709
                ret = -7;
              }
            } else
#line 713
            if (ret == 0) {
#line 714
              ret = -7;
            }
#line 719
            png_free((png_const_structrp )png_ptr, (png_voidp )text);
#line 724
            if (ret == 1) {
#line 724
              if (chunklength - prefix_size != lzsize) {
#line 726
                png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"extra compressed data");
              }
            }
          } else {
#line 732
            ret = -4;
#line 733
            png_zstream_error(png_ptr, -4);
          }
        } else {
#line 740
          png_zstream_error(png_ptr, ret);
#line 741
          ret = -7;
        }
      } else
#line 745
      if (ret == 0) {
#line 746
        ret = -7;
      }
#line 749
      png_ptr->zowner = (png_uint_32 )0;
    } else
#line 752
    if (ret == 1) {
#line 753
      ret = -7;
    }
#line 755
    return (ret);
  } else {
#line 761
    png_zstream_error(png_ptr, -4);
#line 762
    return (-4);
  }
}
}
#line 772 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
static int png_inflate_read(png_structrp png_ptr , png_bytep read_buffer , uInt read_size ,
                            png_uint_32p chunk_bytes , png_bytep next_out , png_alloc_size_t *out_size ,
                            int finish )
{
  int ret ;
  uInt avail ;
  int tmp ;
  int tmp___0 ;

  {
#line 777
  if (png_ptr->zowner == png_ptr->chunk_name) {
#line 782
    png_ptr->zstream.next_out = next_out;
#line 783
    png_ptr->zstream.avail_out = (uInt )0;
    {
#line 785
    while (1) {
      while_continue: /* CIL Label */ ;
#line 787
      if (png_ptr->zstream.avail_in == 0U) {
#line 789
        if (read_size > *chunk_bytes) {
#line 790
          read_size = *chunk_bytes;
        }
#line 791
        *chunk_bytes -= read_size;
#line 793
        if (read_size > 0U) {
#line 794
          png_crc_read(png_ptr, read_buffer, read_size);
        }
#line 796
        png_ptr->zstream.next_in = (Bytef const   *)read_buffer;
#line 797
        png_ptr->zstream.avail_in = read_size;
      }
#line 800
      if (png_ptr->zstream.avail_out == 0U) {
#line 802
        avail = (uInt )-1;
#line 803
        if ((png_alloc_size_t )avail > *out_size) {
#line 804
          avail = (uInt )*out_size;
        }
#line 805
        *out_size -= (png_alloc_size_t )avail;
#line 807
        png_ptr->zstream.avail_out = avail;
      }
#line 814
      if (*chunk_bytes > 0U) {
#line 814
        tmp___0 = 0;
      } else {
#line 814
        if (finish) {
#line 814
          tmp = 4;
        } else {
#line 814
          tmp = 2;
        }
#line 814
        tmp___0 = tmp;
      }
#line 814
      ret = png_zlib_inflate(png_ptr, tmp___0);
#line 785
      if (ret == 0) {
#line 785
        if (! (*out_size > 0UL)) {
#line 785
          if (! (png_ptr->zstream.avail_out > 0U)) {
#line 785
            goto while_break;
          }
        }
      } else {
#line 785
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 819
    *out_size += (png_alloc_size_t )png_ptr->zstream.avail_out;
#line 820
    png_ptr->zstream.avail_out = (uInt )0;
#line 823
    png_zstream_error(png_ptr, ret);
#line 824
    return (ret);
  } else {
#line 829
    png_ptr->zstream.msg = (char const   *)"zstream unclaimed";
#line 830
    return (-2);
  }
}
}
#line 837 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
void png_handle_IHDR(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length )
{
  png_byte buf[13] ;
  png_uint_32 width ;
  png_uint_32 height ;
  int bit_depth ;
  int color_type ;
  int compression_type ;
  int filter_type ;
  int interlace_type ;

  {
#line 847
  if ((png_ptr->mode & 1U) != 0U) {
#line 848
    png_chunk_error((png_const_structrp )png_ptr, (png_const_charp )"out of place");
  }
#line 851
  if (length != 13U) {
#line 852
    png_chunk_error((png_const_structrp )png_ptr, (png_const_charp )"invalid");
  }
#line 854
  png_ptr->mode |= 1U;
#line 856
  png_crc_read(png_ptr, buf, (png_uint_32 )13);
#line 857
  png_crc_finish(png_ptr, (png_uint_32 )0);
#line 859
  width = png_get_uint_31((png_const_structrp )png_ptr, (png_const_bytep )(buf));
#line 860
  height = png_get_uint_31((png_const_structrp )png_ptr, (png_const_bytep )(buf + 4));
#line 861
  bit_depth = (int )buf[8];
#line 862
  color_type = (int )buf[9];
#line 863
  compression_type = (int )buf[10];
#line 864
  filter_type = (int )buf[11];
#line 865
  interlace_type = (int )buf[12];
#line 868
  png_ptr->width = width;
#line 869
  png_ptr->height = height;
#line 870
  png_ptr->bit_depth = (png_byte )bit_depth;
#line 871
  png_ptr->interlaced = (png_byte )interlace_type;
#line 872
  png_ptr->color_type = (png_byte )color_type;
#line 874
  png_ptr->filter_type = (png_byte )filter_type;
#line 876
  png_ptr->compression_type = (png_byte )compression_type;
  {
#line 887
  if ((int )png_ptr->color_type == 2) {
#line 887
    goto case_2;
  }
#line 891
  if ((int )png_ptr->color_type == 4) {
#line 891
    goto case_4;
  }
#line 895
  if ((int )png_ptr->color_type == 6) {
#line 895
    goto case_6;
  }
#line 881
  goto case_3;
  case_3: /* CIL Label */
  case_0: /* CIL Label */
  switch_default: /* CIL Label */
#line 884
  png_ptr->channels = (png_byte )1;
#line 885
  goto switch_break;
  case_2: /* CIL Label */
#line 888
  png_ptr->channels = (png_byte )3;
#line 889
  goto switch_break;
  case_4: /* CIL Label */
#line 892
  png_ptr->channels = (png_byte )2;
#line 893
  goto switch_break;
  case_6: /* CIL Label */
#line 896
  png_ptr->channels = (png_byte )4;
#line 897
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 901
  png_ptr->pixel_depth = (png_byte )((int )png_ptr->bit_depth * (int )png_ptr->channels);
#line 902
  if ((int )png_ptr->pixel_depth >= 8) {
#line 902
    png_ptr->rowbytes = (size_t )png_ptr->width * ((size_t )png_ptr->pixel_depth >> 3);
  } else {
#line 902
    png_ptr->rowbytes = ((size_t )png_ptr->width * (size_t )png_ptr->pixel_depth + 7UL) >> 3;
  }
#line 906
  png_set_IHDR((png_const_structrp )png_ptr, info_ptr, width, height, bit_depth, color_type,
               interlace_type, compression_type, filter_type);
#line 908
  return;
}
}
#line 911 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
void png_handle_PLTE(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length )
{
  png_color palette[256] ;
  int max_palette_length ;
  int num ;
  int i ;
  png_colorp pal_ptr ;
  png_byte buf[3] ;

  {
#line 922
  if ((png_ptr->mode & 1U) == 0U) {
#line 923
    png_chunk_error((png_const_structrp )png_ptr, (png_const_charp )"missing IHDR");
  } else
#line 930
  if ((png_ptr->mode & 2U) != 0U) {
#line 931
    png_chunk_error((png_const_structrp )png_ptr, (png_const_charp )"duplicate");
  } else
#line 933
  if ((png_ptr->mode & 0x04U) != 0U) {
#line 938
    png_crc_finish(png_ptr, length);
#line 939
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"out of place");
#line 940
    return;
  }
#line 943
  png_ptr->mode |= 2U;
#line 945
  if (((int )png_ptr->color_type & 2) == 0) {
#line 947
    png_crc_finish(png_ptr, length);
#line 948
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"ignored in grayscale PNG");
#line 949
    return;
  }
#line 960
  if (length > 768U) {
#line 960
    goto _L;
  } else
#line 960
  if (length % 3U) {
    _L: /* CIL Label */
#line 962
    png_crc_finish(png_ptr, length);
#line 964
    if ((int )png_ptr->color_type != 3) {
#line 965
      png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid");
    } else {
#line 968
      png_chunk_error((png_const_structrp )png_ptr, (png_const_charp )"invalid");
    }
#line 970
    return;
  }
#line 974
  num = (int )length / 3;
#line 981
  if ((int )png_ptr->color_type == 3) {
#line 982
    max_palette_length = 1 << (int )png_ptr->bit_depth;
  } else {
#line 984
    max_palette_length = 256;
  }
#line 986
  if (num > max_palette_length) {
#line 987
    num = max_palette_length;
  }
#line 990
  i = 0;
#line 990
  pal_ptr = palette;
  {
#line 990
  while (1) {
    while_continue: /* CIL Label */ ;
#line 990
    if (! (i < num)) {
#line 990
      goto while_break;
    }
#line 994
    png_crc_read(png_ptr, buf, (png_uint_32 )3);
#line 995
    pal_ptr->red = buf[0];
#line 996
    pal_ptr->green = buf[1];
#line 997
    pal_ptr->blue = buf[2];
#line 990
    i ++;
#line 990
    pal_ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1021
  png_crc_finish(png_ptr, length - (unsigned int )num * 3U);
#line 1059
  png_set_PLTE(png_ptr, info_ptr, (png_const_colorp )(palette), num);
#line 1071
  if ((int )png_ptr->num_trans > 0) {
#line 1071
    goto _L___0;
  } else
#line 1071
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1071
    if ((info_ptr->valid & 0x0010U) != 0U) {
      _L___0: /* CIL Label */
#line 1078
      png_ptr->num_trans = (png_uint_16 )0;
#line 1080
      if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1081
        info_ptr->num_trans = (png_uint_16 )0;
      }
#line 1083
      png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"tRNS must be after");
    }
  }
#line 1088
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1088
    if ((info_ptr->valid & 0x0040U) != 0U) {
#line 1089
      png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"hIST must be after");
    }
  }
#line 1093
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1093
    if ((info_ptr->valid & 0x0020U) != 0U) {
#line 1094
      png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"bKGD must be after");
    }
  }
#line 1096
  return;
}
}
#line 1098 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
void png_handle_IEND(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length )
{


  {
#line 1103
  if ((png_ptr->mode & 1U) == 0U) {
#line 1105
    png_chunk_error((png_const_structrp )png_ptr, (png_const_charp )"out of place");
  } else
#line 1103
  if ((png_ptr->mode & 0x04U) == 0U) {
#line 1105
    png_chunk_error((png_const_structrp )png_ptr, (png_const_charp )"out of place");
  }
#line 1107
  png_ptr->mode |= 24U;
#line 1109
  png_crc_finish(png_ptr, length);
#line 1111
  if (length != 0U) {
#line 1112
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid");
  }
#line 1115
  return;
}
}
#line 1118 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
void png_handle_gAMA(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length )
{
  png_fixed_point igamma ;
  png_byte buf[4] ;
  int tmp ;

  {
#line 1126
  if ((png_ptr->mode & 1U) == 0U) {
#line 1127
    png_chunk_error((png_const_structrp )png_ptr, (png_const_charp )"missing IHDR");
  } else
#line 1129
  if ((png_ptr->mode & 6U) != 0U) {
#line 1131
    png_crc_finish(png_ptr, length);
#line 1132
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"out of place");
#line 1133
    return;
  }
#line 1136
  if (length != 4U) {
#line 1138
    png_crc_finish(png_ptr, length);
#line 1139
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid");
#line 1140
    return;
  }
#line 1143
  png_crc_read(png_ptr, buf, (png_uint_32 )4);
#line 1145
  tmp = png_crc_finish(png_ptr, (png_uint_32 )0);
#line 1145
  if (tmp != 0) {
#line 1146
    return;
  }
#line 1148
  igamma = png_get_fixed_point((png_structrp )((void *)0), (png_const_bytep )(buf));
#line 1150
  png_colorspace_set_gamma((png_const_structrp )png_ptr, (png_colorspacerp )(& png_ptr->colorspace),
                           igamma);
#line 1151
  png_colorspace_sync((png_const_structrp )png_ptr, info_ptr);
#line 1152
  return;
}
}
#line 1156 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
void png_handle_sBIT(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length )
{
  unsigned int truelen ;
  unsigned int i ;
  png_byte sample_depth ;
  png_byte buf[4] ;
  int tmp ;

  {
#line 1165
  if ((png_ptr->mode & 1U) == 0U) {
#line 1166
    png_chunk_error((png_const_structrp )png_ptr, (png_const_charp )"missing IHDR");
  } else
#line 1168
  if ((png_ptr->mode & 6U) != 0U) {
#line 1170
    png_crc_finish(png_ptr, length);
#line 1171
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"out of place");
#line 1172
    return;
  }
#line 1175
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1175
    if ((info_ptr->valid & 0x0002U) != 0U) {
#line 1177
      png_crc_finish(png_ptr, length);
#line 1178
      png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"duplicate");
#line 1179
      return;
    }
  }
#line 1182
  if ((int )png_ptr->color_type == 3) {
#line 1184
    truelen = 3U;
#line 1185
    sample_depth = (png_byte )8;
  } else {
#line 1190
    truelen = (unsigned int )png_ptr->channels;
#line 1191
    sample_depth = png_ptr->bit_depth;
  }
#line 1194
  if (length != truelen) {
#line 1196
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid");
#line 1197
    png_crc_finish(png_ptr, length);
#line 1198
    return;
  } else
#line 1194
  if (length > 4U) {
#line 1196
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid");
#line 1197
    png_crc_finish(png_ptr, length);
#line 1198
    return;
  }
#line 1201
  buf[3] = sample_depth;
#line 1201
  buf[2] = buf[3];
#line 1201
  buf[1] = buf[2];
#line 1201
  buf[0] = buf[1];
#line 1202
  png_crc_read(png_ptr, buf, truelen);
#line 1204
  tmp = png_crc_finish(png_ptr, (png_uint_32 )0);
#line 1204
  if (tmp != 0) {
#line 1205
    return;
  }
#line 1207
  i = 0U;
  {
#line 1207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1207
    if (! (i < truelen)) {
#line 1207
      goto while_break;
    }
#line 1209
    if ((int )buf[i] == 0) {
#line 1211
      png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid");
#line 1212
      return;
    } else
#line 1209
    if ((int )buf[i] > (int )sample_depth) {
#line 1211
      png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid");
#line 1212
      return;
    }
#line 1207
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1216
  if (((int )png_ptr->color_type & 2) != 0) {
#line 1218
    png_ptr->sig_bit.red = buf[0];
#line 1219
    png_ptr->sig_bit.green = buf[1];
#line 1220
    png_ptr->sig_bit.blue = buf[2];
#line 1221
    png_ptr->sig_bit.alpha = buf[3];
  } else {
#line 1226
    png_ptr->sig_bit.gray = buf[0];
#line 1227
    png_ptr->sig_bit.red = buf[0];
#line 1228
    png_ptr->sig_bit.green = buf[0];
#line 1229
    png_ptr->sig_bit.blue = buf[0];
#line 1230
    png_ptr->sig_bit.alpha = buf[1];
  }
#line 1233
  png_set_sBIT((png_const_structrp )png_ptr, info_ptr, (png_const_color_8p )(& png_ptr->sig_bit));
#line 1234
  return;
}
}
#line 1238 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
void png_handle_cHRM(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length )
{
  png_byte buf[32] ;
  png_xy xy ;
  int tmp ;

  {
#line 1246
  if ((png_ptr->mode & 1U) == 0U) {
#line 1247
    png_chunk_error((png_const_structrp )png_ptr, (png_const_charp )"missing IHDR");
  } else
#line 1249
  if ((png_ptr->mode & 6U) != 0U) {
#line 1251
    png_crc_finish(png_ptr, length);
#line 1252
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"out of place");
#line 1253
    return;
  }
#line 1256
  if (length != 32U) {
#line 1258
    png_crc_finish(png_ptr, length);
#line 1259
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid");
#line 1260
    return;
  }
#line 1263
  png_crc_read(png_ptr, buf, (png_uint_32 )32);
#line 1265
  tmp = png_crc_finish(png_ptr, (png_uint_32 )0);
#line 1265
  if (tmp != 0) {
#line 1266
    return;
  }
#line 1268
  xy.whitex = png_get_fixed_point((png_structrp )((void *)0), (png_const_bytep )(buf));
#line 1269
  xy.whitey = png_get_fixed_point((png_structrp )((void *)0), (png_const_bytep )(buf + 4));
#line 1270
  xy.redx = png_get_fixed_point((png_structrp )((void *)0), (png_const_bytep )(buf + 8));
#line 1271
  xy.redy = png_get_fixed_point((png_structrp )((void *)0), (png_const_bytep )(buf + 12));
#line 1272
  xy.greenx = png_get_fixed_point((png_structrp )((void *)0), (png_const_bytep )(buf + 16));
#line 1273
  xy.greeny = png_get_fixed_point((png_structrp )((void *)0), (png_const_bytep )(buf + 20));
#line 1274
  xy.bluex = png_get_fixed_point((png_structrp )((void *)0), (png_const_bytep )(buf + 24));
#line 1275
  xy.bluey = png_get_fixed_point((png_structrp )((void *)0), (png_const_bytep )(buf + 28));
#line 1277
  if (xy.whitex == -1) {
#line 1286
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid values");
#line 1287
    return;
  } else
#line 1277
  if (xy.whitey == -1) {
#line 1286
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid values");
#line 1287
    return;
  } else
#line 1277
  if (xy.redx == -1) {
#line 1286
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid values");
#line 1287
    return;
  } else
#line 1277
  if (xy.redy == -1) {
#line 1286
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid values");
#line 1287
    return;
  } else
#line 1277
  if (xy.greenx == -1) {
#line 1286
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid values");
#line 1287
    return;
  } else
#line 1277
  if (xy.greeny == -1) {
#line 1286
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid values");
#line 1287
    return;
  } else
#line 1277
  if (xy.bluex == -1) {
#line 1286
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid values");
#line 1287
    return;
  } else
#line 1277
  if (xy.bluey == -1) {
#line 1286
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid values");
#line 1287
    return;
  }
#line 1291
  if (((int )png_ptr->colorspace.flags & 0x8000) != 0) {
#line 1292
    return;
  }
#line 1294
  if (((int )png_ptr->colorspace.flags & 0x0010) != 0) {
#line 1296
    png_ptr->colorspace.flags = (png_uint_16 )((int )png_ptr->colorspace.flags | 0x8000);
#line 1297
    png_colorspace_sync((png_const_structrp )png_ptr, info_ptr);
#line 1298
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"duplicate");
#line 1299
    return;
  }
#line 1302
  png_ptr->colorspace.flags = (png_uint_16 )((int )png_ptr->colorspace.flags | 0x0010);
#line 1303
  png_colorspace_set_chromaticities((png_const_structrp )png_ptr, (png_colorspacerp )(& png_ptr->colorspace),
                                    (png_xy const   *)(& xy), 1);
#line 1305
  png_colorspace_sync((png_const_structrp )png_ptr, info_ptr);
#line 1306
  return;
}
}
#line 1310 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
void png_handle_sRGB(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length )
{
  png_byte intent ;
  int tmp ;

  {
#line 1317
  if ((png_ptr->mode & 1U) == 0U) {
#line 1318
    png_chunk_error((png_const_structrp )png_ptr, (png_const_charp )"missing IHDR");
  } else
#line 1320
  if ((png_ptr->mode & 6U) != 0U) {
#line 1322
    png_crc_finish(png_ptr, length);
#line 1323
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"out of place");
#line 1324
    return;
  }
#line 1327
  if (length != 1U) {
#line 1329
    png_crc_finish(png_ptr, length);
#line 1330
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid");
#line 1331
    return;
  }
#line 1334
  png_crc_read(png_ptr, & intent, (png_uint_32 )1);
#line 1336
  tmp = png_crc_finish(png_ptr, (png_uint_32 )0);
#line 1336
  if (tmp != 0) {
#line 1337
    return;
  }
#line 1340
  if (((int )png_ptr->colorspace.flags & 0x8000) != 0) {
#line 1341
    return;
  }
#line 1346
  if (((int )png_ptr->colorspace.flags & 0x0004) != 0) {
#line 1348
    png_ptr->colorspace.flags = (png_uint_16 )((int )png_ptr->colorspace.flags | 0x8000);
#line 1349
    png_colorspace_sync((png_const_structrp )png_ptr, info_ptr);
#line 1350
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"too many profiles");
#line 1351
    return;
  }
#line 1354
  png_colorspace_set_sRGB((png_const_structrp )png_ptr, (png_colorspacerp )(& png_ptr->colorspace),
                          (int )intent);
#line 1355
  png_colorspace_sync((png_const_structrp )png_ptr, info_ptr);
#line 1356
  return;
}
}
#line 1360 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
void png_handle_iCCP(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length )
{
  png_const_charp errmsg ;
  int finished ;
  uInt read_length ;
  uInt keyword_length ;
  char keyword[81] ;
  Byte profile_header[132] ;
  unsigned int tmp ;
  Byte local_buffer[1024] ;
  png_alloc_size_t size ;
  png_uint_32 profile_length ;
  png_uint_32 tag_count ;
  png_bytep profile ;
  png_bytep tmp___0 ;
  png_voidp __attribute__((__malloc__))  tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1364
  errmsg = (png_const_charp )((void *)0);
#line 1365
  finished = 0;
#line 1369
  if ((png_ptr->mode & 1U) == 0U) {
#line 1370
    png_chunk_error((png_const_structrp )png_ptr, (png_const_charp )"missing IHDR");
  } else
#line 1372
  if ((png_ptr->mode & 6U) != 0U) {
#line 1374
    png_crc_finish(png_ptr, length);
#line 1375
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"out of place");
#line 1376
    return;
  }
#line 1389
  if (length < 14U) {
#line 1391
    png_crc_finish(png_ptr, length);
#line 1392
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"too short");
#line 1393
    return;
  }
#line 1397
  if (((int )png_ptr->colorspace.flags & 0x8000) != 0) {
#line 1399
    png_crc_finish(png_ptr, length);
#line 1400
    return;
  }
#line 1406
  if (((int )png_ptr->colorspace.flags & 0x0004) == 0) {
#line 1414
    read_length = (uInt )81;
#line 1415
    if (read_length > length) {
#line 1416
      read_length = length;
    }
#line 1418
    png_crc_read(png_ptr, (png_bytep )(keyword), read_length);
#line 1419
    length -= read_length;
#line 1424
    if (length < 11U) {
#line 1426
      png_crc_finish(png_ptr, length);
#line 1427
      png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"too short");
#line 1428
      return;
    }
#line 1431
    keyword_length = (uInt )0;
    {
#line 1432
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1432
      if (keyword_length < 80U) {
#line 1432
        if (keyword_length < read_length) {
#line 1432
          if (! ((int )keyword[keyword_length] != 0)) {
#line 1432
            goto while_break;
          }
        } else {
#line 1432
          goto while_break;
        }
      } else {
#line 1432
        goto while_break;
      }
#line 1434
      keyword_length ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1437
    if (keyword_length >= 1U) {
#line 1437
      if (keyword_length <= 79U) {
#line 1442
        if (keyword_length + 1U < read_length) {
#line 1442
          if ((int )keyword[keyword_length + 1U] == 0) {
#line 1445
            read_length -= keyword_length + 2U;
#line 1447
            tmp___5 = png_inflate_claim(png_ptr, (((105U << 24) | (67U << 16)) | (67U << 8)) | 80U);
#line 1447
            if (tmp___5 == 0) {
#line 1449
              profile_header[0] = (Byte )0;
#line 1449
              tmp = 1U;
              {
#line 1449
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 1449
                if (tmp >= 132U) {
#line 1449
                  goto while_break___0;
                }
#line 1449
                profile_header[tmp] = (unsigned char)0;
#line 1449
                tmp ++;
              }
              while_break___0: /* CIL Label */ ;
              }
#line 1451
              size = sizeof(profile_header);
#line 1453
              png_ptr->zstream.next_in = (Bytef const   *)((Bytef *)(keyword) + (keyword_length + 2U));
#line 1454
              png_ptr->zstream.avail_in = read_length;
#line 1455
              png_inflate_read(png_ptr, local_buffer, (uInt )sizeof(local_buffer),
                               & length, profile_header, & size, 0);
#line 1459
              if (size == 0UL) {
#line 1463
                profile_length = ((((png_uint_32 )profile_header[0] << 24) + ((png_uint_32 )*(profile_header + 1) << 16)) + ((png_uint_32 )*(profile_header + 2) << 8)) + (png_uint_32 )*(profile_header + 3);
#line 1465
                tmp___4 = png_icc_check_length((png_const_structrp )png_ptr, (png_colorspacerp )(& png_ptr->colorspace),
                                               (png_const_charp )(keyword), profile_length);
#line 1465
                if (tmp___4 != 0) {
#line 1471
                  tmp___3 = png_icc_check_header((png_const_structrp )png_ptr, (png_colorspacerp )(& png_ptr->colorspace),
                                                 (png_const_charp )(keyword), profile_length,
                                                 (png_const_bytep )(profile_header),
                                                 (int )png_ptr->color_type);
#line 1471
                  if (tmp___3 != 0) {
#line 1480
                    tag_count = ((((png_uint_32 )*(profile_header + 128) << 24) + ((png_uint_32 )*((profile_header + 128) + 1) << 16)) + ((png_uint_32 )*((profile_header + 128) + 2) << 8)) + (png_uint_32 )*((profile_header + 128) + 3);
#line 1482
                    tmp___0 = png_read_buffer(png_ptr, (png_alloc_size_t )profile_length,
                                              2);
#line 1482
                    profile = tmp___0;
#line 1485
                    if ((unsigned long )profile != (unsigned long )((void *)0)) {
#line 1487
                      memcpy((void *)profile, (void const   *)(profile_header), sizeof(profile_header));
#line 1490
                      size = (png_alloc_size_t )(12U * tag_count);
#line 1492
                      png_inflate_read(png_ptr, local_buffer, (uInt )sizeof(local_buffer),
                                       & length, profile + sizeof(profile_header),
                                       & size, 0);
#line 1499
                      if (size == 0UL) {
#line 1501
                        tmp___2 = png_icc_check_tag_table((png_const_structrp )png_ptr,
                                                          (png_colorspacerp )(& png_ptr->colorspace),
                                                          (png_const_charp )(keyword),
                                                          profile_length, (png_const_bytep )profile);
#line 1501
                        if (tmp___2 != 0) {
#line 1508
                          size = ((unsigned long )profile_length - sizeof(profile_header)) - (unsigned long )(12U * tag_count);
#line 1511
                          png_inflate_read(png_ptr, local_buffer, (uInt )sizeof(local_buffer),
                                           & length, (profile + sizeof(profile_header)) + 12U * tag_count,
                                           & size, 1);
#line 1516
                          if (length > 0U) {
#line 1516
                            if (! (png_ptr->flags & 0x100000U)) {
#line 1518
                              errmsg = (png_const_charp )"extra compressed data";
                            } else {
#line 1516
                              goto _L;
                            }
                          } else
                          _L: /* CIL Label */
#line 1521
                          if (size == 0UL) {
#line 1523
                            if (length > 0U) {
#line 1528
                              png_chunk_warning((png_const_structrp )png_ptr, (png_const_charp )"extra compressed data");
                            }
#line 1532
                            png_crc_finish(png_ptr, length);
#line 1533
                            finished = 1;
#line 1537
                            png_icc_set_sRGB((png_const_structrp )png_ptr, (png_colorspacerp )(& png_ptr->colorspace),
                                             (png_const_bytep )profile, png_ptr->zstream.adler);
#line 1543
                            if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1545
                              png_free_data((png_const_structrp )png_ptr, info_ptr,
                                            0x0010U, 0);
#line 1548
                              tmp___1 = png_malloc_base((png_const_structrp )png_ptr,
                                                        (png_alloc_size_t )(keyword_length + 1U));
#line 1548
                              info_ptr->iccp_name = (png_charp )tmp___1;
#line 1551
                              if ((unsigned long )info_ptr->iccp_name != (unsigned long )((void *)0)) {
#line 1553
                                memcpy((void *)info_ptr->iccp_name, (void const   *)(keyword),
                                       (size_t )(keyword_length + 1U));
#line 1555
                                info_ptr->iccp_proflen = profile_length;
#line 1557
                                info_ptr->iccp_profile = profile;
#line 1558
                                png_ptr->read_buffer = (png_bytep )((void *)0);
#line 1559
                                info_ptr->free_me |= 0x0010U;
#line 1560
                                info_ptr->valid |= 0x1000U;
                              } else {
#line 1565
                                png_ptr->colorspace.flags = (png_uint_16 )((int )png_ptr->colorspace.flags | 0x8000);
#line 1567
                                errmsg = (png_const_charp )"out of memory";
                              }
                            }
#line 1576
                            if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1577
                              png_colorspace_sync((png_const_structrp )png_ptr, info_ptr);
                            }
#line 1579
                            if ((unsigned long )errmsg == (unsigned long )((void *)0)) {
#line 1581
                              png_ptr->zowner = (png_uint_32 )0;
#line 1582
                              return;
                            }
                          }
#line 1585
                          if ((unsigned long )errmsg == (unsigned long )((void *)0)) {
#line 1586
                            errmsg = png_ptr->zstream.msg;
                          }
                        }
                      } else {
#line 1591
                        errmsg = png_ptr->zstream.msg;
                      }
                    } else {
#line 1595
                      errmsg = (png_const_charp )"out of memory";
                    }
                  }
                }
              } else {
#line 1605
                errmsg = png_ptr->zstream.msg;
              }
#line 1608
              png_ptr->zowner = (png_uint_32 )0;
            } else {
#line 1612
              errmsg = png_ptr->zstream.msg;
            }
          } else {
#line 1616
            errmsg = (png_const_charp )"bad compression method";
          }
        } else {
#line 1616
          errmsg = (png_const_charp )"bad compression method";
        }
      } else {
#line 1620
        errmsg = (png_const_charp )"bad keyword";
      }
    } else {
#line 1620
      errmsg = (png_const_charp )"bad keyword";
    }
  } else {
#line 1624
    errmsg = (png_const_charp )"too many profiles";
  }
#line 1627
  if (finished == 0) {
#line 1628
    png_crc_finish(png_ptr, length);
  }
#line 1630
  png_ptr->colorspace.flags = (png_uint_16 )((int )png_ptr->colorspace.flags | 0x8000);
#line 1631
  png_colorspace_sync((png_const_structrp )png_ptr, info_ptr);
#line 1632
  if ((unsigned long )errmsg != (unsigned long )((void *)0)) {
#line 1633
    png_chunk_benign_error((png_const_structrp )png_ptr, errmsg);
  }
#line 1634
  return;
}
}
#line 1638 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
void png_handle_sPLT(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length )
{
  png_bytep entry_start ;
  png_bytep buffer___0 ;
  png_sPLT_t new_palette ;
  png_sPLT_entryp pp ;
  png_uint_32 data_length ;
  int entry_size ;
  int i ;
  png_uint_32 skip ;
  png_uint_32 dl ;
  size_t max_dl ;
  int tmp ;
  png_bytep tmp___0 ;
  png_voidp __attribute__((__malloc__))  tmp___1 ;
  png_bytep tmp___2 ;
  png_bytep tmp___3 ;
  png_bytep tmp___4 ;
  png_bytep tmp___5 ;

  {
#line 1647
  skip = (png_uint_32 )0;
#line 1654
  if (png_ptr->user_chunk_cache_max != 0U) {
#line 1656
    if (png_ptr->user_chunk_cache_max == 1U) {
#line 1658
      png_crc_finish(png_ptr, length);
#line 1659
      return;
    }
#line 1662
    (png_ptr->user_chunk_cache_max) --;
#line 1662
    if (png_ptr->user_chunk_cache_max == 1U) {
#line 1664
      png_warning((png_const_structrp )png_ptr, (png_const_charp )"No space in chunk cache for sPLT");
#line 1665
      png_crc_finish(png_ptr, length);
#line 1666
      return;
    }
  }
#line 1671
  if ((png_ptr->mode & 1U) == 0U) {
#line 1672
    png_chunk_error((png_const_structrp )png_ptr, (png_const_charp )"missing IHDR");
  } else
#line 1674
  if ((png_ptr->mode & 0x04U) != 0U) {
#line 1676
    png_crc_finish(png_ptr, length);
#line 1677
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"out of place");
#line 1678
    return;
  }
#line 1690
  buffer___0 = png_read_buffer(png_ptr, (png_alloc_size_t )(length + 1U), 2);
#line 1691
  if ((unsigned long )buffer___0 == (unsigned long )((void *)0)) {
#line 1693
    png_crc_finish(png_ptr, length);
#line 1694
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"out of memory");
#line 1695
    return;
  }
#line 1703
  png_crc_read(png_ptr, buffer___0, length);
#line 1705
  tmp = png_crc_finish(png_ptr, skip);
#line 1705
  if (tmp != 0) {
#line 1706
    return;
  }
#line 1708
  *(buffer___0 + length) = (png_byte )0;
#line 1710
  entry_start = buffer___0;
  {
#line 1710
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1710
    if (! *entry_start) {
#line 1710
      goto while_break;
    }
#line 1710
    entry_start ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1713
  entry_start ++;
#line 1716
  if (length < 2U) {
#line 1718
    png_warning((png_const_structrp )png_ptr, (png_const_charp )"malformed sPLT chunk");
#line 1719
    return;
  } else
#line 1716
  if ((unsigned long )entry_start > (unsigned long )(buffer___0 + (length - 2U))) {
#line 1718
    png_warning((png_const_structrp )png_ptr, (png_const_charp )"malformed sPLT chunk");
#line 1719
    return;
  }
#line 1722
  tmp___0 = entry_start;
#line 1722
  entry_start ++;
#line 1722
  new_palette.depth = *tmp___0;
#line 1723
  if ((int )new_palette.depth == 8) {
#line 1723
    entry_size = 6;
  } else {
#line 1723
    entry_size = 10;
  }
#line 1727
  data_length = length - (png_uint_32 )(entry_start - buffer___0);
#line 1730
  if (data_length % (unsigned int )entry_size != 0U) {
#line 1732
    png_warning((png_const_structrp )png_ptr, (png_const_charp )"sPLT chunk has bad length");
#line 1733
    return;
  }
#line 1736
  dl = data_length / (unsigned int )entry_size;
#line 1737
  max_dl = 18446744073709551615UL / sizeof(png_sPLT_entry );
#line 1739
  if ((size_t )dl > max_dl) {
#line 1741
    png_warning((png_const_structrp )png_ptr, (png_const_charp )"sPLT chunk too long");
#line 1742
    return;
  }
#line 1745
  new_palette.nentries = (png_int_32 )(data_length / (unsigned int )entry_size);
#line 1747
  tmp___1 = png_malloc_warn((png_const_structrp )png_ptr, (png_alloc_size_t )new_palette.nentries * sizeof(png_sPLT_entry ));
#line 1747
  new_palette.entries = (png_sPLT_entryp )tmp___1;
#line 1750
  if ((unsigned long )new_palette.entries == (unsigned long )((void *)0)) {
#line 1752
    png_warning((png_const_structrp )png_ptr, (png_const_charp )"sPLT chunk requires too much memory");
#line 1753
    return;
  }
#line 1757
  i = 0;
  {
#line 1757
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1757
    if (! (i < new_palette.nentries)) {
#line 1757
      goto while_break___0;
    }
#line 1759
    pp = new_palette.entries + i;
#line 1761
    if ((int )new_palette.depth == 8) {
#line 1763
      tmp___2 = entry_start;
#line 1763
      entry_start ++;
#line 1763
      pp->red = (png_uint_16 )*tmp___2;
#line 1764
      tmp___3 = entry_start;
#line 1764
      entry_start ++;
#line 1764
      pp->green = (png_uint_16 )*tmp___3;
#line 1765
      tmp___4 = entry_start;
#line 1765
      entry_start ++;
#line 1765
      pp->blue = (png_uint_16 )*tmp___4;
#line 1766
      tmp___5 = entry_start;
#line 1766
      entry_start ++;
#line 1766
      pp->alpha = (png_uint_16 )*tmp___5;
    } else {
#line 1771
      pp->red = (png_uint_16 )(((unsigned int )*entry_start << 8) + (unsigned int )*(entry_start + 1));
#line 1771
      entry_start += 2;
#line 1772
      pp->green = (png_uint_16 )(((unsigned int )*entry_start << 8) + (unsigned int )*(entry_start + 1));
#line 1772
      entry_start += 2;
#line 1773
      pp->blue = (png_uint_16 )(((unsigned int )*entry_start << 8) + (unsigned int )*(entry_start + 1));
#line 1773
      entry_start += 2;
#line 1774
      pp->alpha = (png_uint_16 )(((unsigned int )*entry_start << 8) + (unsigned int )*(entry_start + 1));
#line 1774
      entry_start += 2;
    }
#line 1777
    pp->frequency = (png_uint_16 )(((unsigned int )*entry_start << 8) + (unsigned int )*(entry_start + 1));
#line 1777
    entry_start += 2;
#line 1757
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1806
  new_palette.name = (png_charp )buffer___0;
#line 1808
  png_set_sPLT((png_const_structrp )png_ptr, info_ptr, (png_const_sPLT_tp )(& new_palette),
               1);
#line 1810
  png_free((png_const_structrp )png_ptr, (png_voidp )new_palette.entries);
#line 1811
  return;
}
}
#line 1815 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
void png_handle_tRNS(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length )
{
  png_byte readbuf[256] ;
  png_byte buf[2] ;
  png_byte buf___0[6] ;
  int tmp ;

  {
#line 1822
  if ((png_ptr->mode & 1U) == 0U) {
#line 1823
    png_chunk_error((png_const_structrp )png_ptr, (png_const_charp )"missing IHDR");
  } else
#line 1825
  if ((png_ptr->mode & 0x04U) != 0U) {
#line 1827
    png_crc_finish(png_ptr, length);
#line 1828
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"out of place");
#line 1829
    return;
  } else
#line 1832
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1832
    if ((info_ptr->valid & 0x0010U) != 0U) {
#line 1834
      png_crc_finish(png_ptr, length);
#line 1835
      png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"duplicate");
#line 1836
      return;
    }
  }
#line 1839
  if ((int )png_ptr->color_type == 0) {
#line 1843
    if (length != 2U) {
#line 1845
      png_crc_finish(png_ptr, length);
#line 1846
      png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid");
#line 1847
      return;
    }
#line 1850
    png_crc_read(png_ptr, buf, (png_uint_32 )2);
#line 1851
    png_ptr->num_trans = (png_uint_16 )1;
#line 1852
    png_ptr->trans_color.gray = (png_uint_16 )(((unsigned int )buf[0] << 8) + (unsigned int )*(buf + 1));
  } else
#line 1855
  if ((int )png_ptr->color_type == 2) {
#line 1859
    if (length != 6U) {
#line 1861
      png_crc_finish(png_ptr, length);
#line 1862
      png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid");
#line 1863
      return;
    }
#line 1866
    png_crc_read(png_ptr, buf___0, length);
#line 1867
    png_ptr->num_trans = (png_uint_16 )1;
#line 1868
    png_ptr->trans_color.red = (png_uint_16 )(((unsigned int )buf___0[0] << 8) + (unsigned int )*(buf___0 + 1));
#line 1869
    png_ptr->trans_color.green = (png_uint_16 )(((unsigned int )*(buf___0 + 2) << 8) + (unsigned int )*((buf___0 + 2) + 1));
#line 1870
    png_ptr->trans_color.blue = (png_uint_16 )(((unsigned int )*(buf___0 + 4) << 8) + (unsigned int )*((buf___0 + 4) + 1));
  } else
#line 1873
  if ((int )png_ptr->color_type == 3) {
#line 1875
    if ((png_ptr->mode & 2U) == 0U) {
#line 1878
      png_crc_finish(png_ptr, length);
#line 1879
      png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"out of place");
#line 1880
      return;
    }
#line 1883
    if (length > (unsigned int )png_ptr->num_palette) {
#line 1887
      png_crc_finish(png_ptr, length);
#line 1888
      png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid");
#line 1889
      return;
    } else
#line 1883
    if (length > 256U) {
#line 1887
      png_crc_finish(png_ptr, length);
#line 1888
      png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid");
#line 1889
      return;
    } else
#line 1883
    if (length == 0U) {
#line 1887
      png_crc_finish(png_ptr, length);
#line 1888
      png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid");
#line 1889
      return;
    }
#line 1892
    png_crc_read(png_ptr, readbuf, length);
#line 1893
    png_ptr->num_trans = (png_uint_16 )length;
  } else {
#line 1898
    png_crc_finish(png_ptr, length);
#line 1899
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid with alpha channel");
#line 1900
    return;
  }
#line 1903
  tmp = png_crc_finish(png_ptr, (png_uint_32 )0);
#line 1903
  if (tmp != 0) {
#line 1905
    png_ptr->num_trans = (png_uint_16 )0;
#line 1906
    return;
  }
#line 1913
  png_set_tRNS(png_ptr, info_ptr, (png_const_bytep )(readbuf), (int )png_ptr->num_trans,
               (png_const_color_16p )(& png_ptr->trans_color));
#line 1915
  return;
}
}
#line 1919 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
void png_handle_bKGD(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length )
{
  unsigned int truelen ;
  png_byte buf[6] ;
  png_color_16 background ;
  int tmp ;

  {
#line 1928
  if ((png_ptr->mode & 1U) == 0U) {
#line 1929
    png_chunk_error((png_const_structrp )png_ptr, (png_const_charp )"missing IHDR");
  } else
#line 1931
  if ((png_ptr->mode & 0x04U) != 0U) {
#line 1935
    png_crc_finish(png_ptr, length);
#line 1936
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"out of place");
#line 1937
    return;
  } else
#line 1931
  if ((int )png_ptr->color_type == 3) {
#line 1931
    if ((png_ptr->mode & 2U) == 0U) {
#line 1935
      png_crc_finish(png_ptr, length);
#line 1936
      png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"out of place");
#line 1937
      return;
    } else {
#line 1931
      goto _L;
    }
  } else
  _L: /* CIL Label */
#line 1940
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1940
    if ((info_ptr->valid & 0x0020U) != 0U) {
#line 1942
      png_crc_finish(png_ptr, length);
#line 1943
      png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"duplicate");
#line 1944
      return;
    }
  }
#line 1947
  if ((int )png_ptr->color_type == 3) {
#line 1948
    truelen = 1U;
  } else
#line 1950
  if (((int )png_ptr->color_type & 2) != 0) {
#line 1951
    truelen = 6U;
  } else {
#line 1954
    truelen = 2U;
  }
#line 1956
  if (length != truelen) {
#line 1958
    png_crc_finish(png_ptr, length);
#line 1959
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid");
#line 1960
    return;
  }
#line 1963
  png_crc_read(png_ptr, buf, truelen);
#line 1965
  tmp = png_crc_finish(png_ptr, (png_uint_32 )0);
#line 1965
  if (tmp != 0) {
#line 1966
    return;
  }
#line 1973
  if ((int )png_ptr->color_type == 3) {
#line 1975
    background.index = buf[0];
#line 1977
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1977
      if ((int )info_ptr->num_palette != 0) {
#line 1979
        if ((int )buf[0] >= (int )info_ptr->num_palette) {
#line 1981
          png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid index");
#line 1982
          return;
        }
#line 1985
        background.red = (png_uint_16 )(png_ptr->palette + buf[0])->red;
#line 1986
        background.green = (png_uint_16 )(png_ptr->palette + buf[0])->green;
#line 1987
        background.blue = (png_uint_16 )(png_ptr->palette + buf[0])->blue;
      } else {
#line 1991
        background.blue = (png_uint_16 )0;
#line 1991
        background.green = background.blue;
#line 1991
        background.red = background.green;
      }
    } else {
#line 1991
      background.blue = (png_uint_16 )0;
#line 1991
      background.green = background.blue;
#line 1991
      background.red = background.green;
    }
#line 1993
    background.gray = (png_uint_16 )0;
  } else
#line 1996
  if (((int )png_ptr->color_type & 2) == 0) {
#line 1998
    if ((int )png_ptr->bit_depth <= 8) {
#line 2000
      if ((int )buf[0] != 0) {
#line 2002
        png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid gray level");
#line 2003
        return;
      } else
#line 2000
      if ((unsigned int )buf[1] >= (unsigned int )(1 << (int )png_ptr->bit_depth)) {
#line 2002
        png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid gray level");
#line 2003
        return;
      }
    }
#line 2007
    background.index = (png_byte )0;
#line 2008
    background.gray = (png_uint_16 )(((unsigned int )buf[0] << 8) + (unsigned int )*(buf + 1));
#line 2008
    background.blue = background.gray;
#line 2008
    background.green = background.blue;
#line 2008
    background.red = background.green;
  } else {
#line 2016
    if ((int )png_ptr->bit_depth <= 8) {
#line 2018
      if ((int )buf[0] != 0) {
#line 2020
        png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid color");
#line 2021
        return;
      } else
#line 2018
      if ((int )buf[2] != 0) {
#line 2020
        png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid color");
#line 2021
        return;
      } else
#line 2018
      if ((int )buf[4] != 0) {
#line 2020
        png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid color");
#line 2021
        return;
      }
    }
#line 2025
    background.index = (png_byte )0;
#line 2026
    background.red = (png_uint_16 )(((unsigned int )buf[0] << 8) + (unsigned int )*(buf + 1));
#line 2027
    background.green = (png_uint_16 )(((unsigned int )*(buf + 2) << 8) + (unsigned int )*((buf + 2) + 1));
#line 2028
    background.blue = (png_uint_16 )(((unsigned int )*(buf + 4) << 8) + (unsigned int )*((buf + 4) + 1));
#line 2029
    background.gray = (png_uint_16 )0;
  }
#line 2032
  png_set_bKGD((png_const_structrp )png_ptr, info_ptr, (png_const_color_16p )(& background));
#line 2033
  return;
}
}
#line 2037 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
void png_handle_eXIf(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length )
{
  unsigned int i ;
  png_voidp __attribute__((__malloc__))  tmp ;
  png_byte buf[1] ;
  int tmp___0 ;

  {
#line 2044
  if ((png_ptr->mode & 1U) == 0U) {
#line 2045
    png_chunk_error((png_const_structrp )png_ptr, (png_const_charp )"missing IHDR");
  }
#line 2047
  if (length < 2U) {
#line 2049
    png_crc_finish(png_ptr, length);
#line 2050
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"too short");
#line 2051
    return;
  } else
#line 2054
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 2056
    png_crc_finish(png_ptr, length);
#line 2057
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"duplicate");
#line 2058
    return;
  } else
#line 2054
  if ((info_ptr->valid & 0x10000U) != 0U) {
#line 2056
    png_crc_finish(png_ptr, length);
#line 2057
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"duplicate");
#line 2058
    return;
  }
#line 2061
  info_ptr->free_me |= 0x8000U;
#line 2063
  tmp = png_malloc_warn((png_const_structrp )png_ptr, (png_alloc_size_t )length);
#line 2063
  info_ptr->eXIf_buf = (png_bytep )tmp;
#line 2066
  if ((unsigned long )info_ptr->eXIf_buf == (unsigned long )((void *)0)) {
#line 2068
    png_crc_finish(png_ptr, length);
#line 2069
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"out of memory");
#line 2070
    return;
  }
#line 2073
  i = 0U;
  {
#line 2073
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2073
    if (! (i < length)) {
#line 2073
      goto while_break;
    }
#line 2076
    png_crc_read(png_ptr, buf, (png_uint_32 )1);
#line 2077
    *(info_ptr->eXIf_buf + i) = buf[0];
#line 2078
    if (i == 1U) {
#line 2080
      if ((int )buf[0] != 77) {
#line 2080
        if ((int )buf[0] != 73) {
#line 2083
          png_crc_finish(png_ptr, length - 2U);
#line 2084
          png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"incorrect byte-order specifier");
#line 2085
          png_free((png_const_structrp )png_ptr, (png_voidp )info_ptr->eXIf_buf);
#line 2086
          info_ptr->eXIf_buf = (png_bytep )((void *)0);
#line 2087
          return;
        } else {
#line 2080
          goto _L;
        }
      } else
      _L: /* CIL Label */
#line 2080
      if ((int )*(info_ptr->eXIf_buf + 0) != (int )buf[0]) {
#line 2083
        png_crc_finish(png_ptr, length - 2U);
#line 2084
        png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"incorrect byte-order specifier");
#line 2085
        png_free((png_const_structrp )png_ptr, (png_voidp )info_ptr->eXIf_buf);
#line 2086
        info_ptr->eXIf_buf = (png_bytep )((void *)0);
#line 2087
        return;
      }
    }
#line 2073
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2092
  tmp___0 = png_crc_finish(png_ptr, (png_uint_32 )0);
#line 2092
  if (tmp___0 == 0) {
#line 2093
    png_set_eXIf_1((png_const_structrp )png_ptr, info_ptr, length, info_ptr->eXIf_buf);
  }
#line 2095
  png_free((png_const_structrp )png_ptr, (png_voidp )info_ptr->eXIf_buf);
#line 2096
  info_ptr->eXIf_buf = (png_bytep )((void *)0);
#line 2097
  return;
}
}
#line 2101 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
void png_handle_hIST(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length )
{
  unsigned int num ;
  unsigned int i ;
  png_uint_16 readbuf[256] ;
  png_byte buf[2] ;
  int tmp ;

  {
#line 2109
  if ((png_ptr->mode & 1U) == 0U) {
#line 2110
    png_chunk_error((png_const_structrp )png_ptr, (png_const_charp )"missing IHDR");
  } else
#line 2112
  if ((png_ptr->mode & 0x04U) != 0U) {
#line 2115
    png_crc_finish(png_ptr, length);
#line 2116
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"out of place");
#line 2117
    return;
  } else
#line 2112
  if ((png_ptr->mode & 2U) == 0U) {
#line 2115
    png_crc_finish(png_ptr, length);
#line 2116
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"out of place");
#line 2117
    return;
  } else
#line 2120
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 2120
    if ((info_ptr->valid & 0x0040U) != 0U) {
#line 2122
      png_crc_finish(png_ptr, length);
#line 2123
      png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"duplicate");
#line 2124
      return;
    }
  }
#line 2127
  num = length / 2U;
#line 2129
  if (length != num * 2U) {
#line 2133
    png_crc_finish(png_ptr, length);
#line 2134
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid");
#line 2135
    return;
  } else
#line 2129
  if (num != (unsigned int )png_ptr->num_palette) {
#line 2133
    png_crc_finish(png_ptr, length);
#line 2134
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid");
#line 2135
    return;
  } else
#line 2129
  if (num > 256U) {
#line 2133
    png_crc_finish(png_ptr, length);
#line 2134
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid");
#line 2135
    return;
  }
#line 2138
  i = 0U;
  {
#line 2138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2138
    if (! (i < num)) {
#line 2138
      goto while_break;
    }
#line 2142
    png_crc_read(png_ptr, buf, (png_uint_32 )2);
#line 2143
    readbuf[i] = (png_uint_16 )(((unsigned int )buf[0] << 8) + (unsigned int )*(buf + 1));
#line 2138
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2146
  tmp = png_crc_finish(png_ptr, (png_uint_32 )0);
#line 2146
  if (tmp != 0) {
#line 2147
    return;
  }
#line 2149
  png_set_hIST((png_const_structrp )png_ptr, info_ptr, (png_const_uint_16p )(readbuf));
#line 2150
  return;
}
}
#line 2154 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
void png_handle_pHYs(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length )
{
  png_byte buf[9] ;
  png_uint_32 res_x ;
  png_uint_32 res_y ;
  int unit_type ;
  int tmp ;

  {
#line 2163
  if ((png_ptr->mode & 1U) == 0U) {
#line 2164
    png_chunk_error((png_const_structrp )png_ptr, (png_const_charp )"missing IHDR");
  } else
#line 2166
  if ((png_ptr->mode & 0x04U) != 0U) {
#line 2168
    png_crc_finish(png_ptr, length);
#line 2169
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"out of place");
#line 2170
    return;
  } else
#line 2173
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 2173
    if ((info_ptr->valid & 0x0080U) != 0U) {
#line 2175
      png_crc_finish(png_ptr, length);
#line 2176
      png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"duplicate");
#line 2177
      return;
    }
  }
#line 2180
  if (length != 9U) {
#line 2182
    png_crc_finish(png_ptr, length);
#line 2183
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid");
#line 2184
    return;
  }
#line 2187
  png_crc_read(png_ptr, buf, (png_uint_32 )9);
#line 2189
  tmp = png_crc_finish(png_ptr, (png_uint_32 )0);
#line 2189
  if (tmp != 0) {
#line 2190
    return;
  }
#line 2192
  res_x = ((((png_uint_32 )buf[0] << 24) + ((png_uint_32 )*(buf + 1) << 16)) + ((png_uint_32 )*(buf + 2) << 8)) + (png_uint_32 )*(buf + 3);
#line 2193
  res_y = ((((png_uint_32 )*(buf + 4) << 24) + ((png_uint_32 )*((buf + 4) + 1) << 16)) + ((png_uint_32 )*((buf + 4) + 2) << 8)) + (png_uint_32 )*((buf + 4) + 3);
#line 2194
  unit_type = (int )buf[8];
#line 2195
  png_set_pHYs((png_const_structrp )png_ptr, info_ptr, res_x, res_y, unit_type);
#line 2196
  return;
}
}
#line 2200 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
void png_handle_oFFs(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length )
{
  png_byte buf[9] ;
  png_int_32 offset_x ;
  png_int_32 offset_y ;
  int unit_type ;
  int tmp ;
  png_int_32 tmp___0 ;
  png_int_32 tmp___1 ;

  {
#line 2209
  if ((png_ptr->mode & 1U) == 0U) {
#line 2210
    png_chunk_error((png_const_structrp )png_ptr, (png_const_charp )"missing IHDR");
  } else
#line 2212
  if ((png_ptr->mode & 0x04U) != 0U) {
#line 2214
    png_crc_finish(png_ptr, length);
#line 2215
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"out of place");
#line 2216
    return;
  } else
#line 2219
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 2219
    if ((info_ptr->valid & 0x0100U) != 0U) {
#line 2221
      png_crc_finish(png_ptr, length);
#line 2222
      png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"duplicate");
#line 2223
      return;
    }
  }
#line 2226
  if (length != 9U) {
#line 2228
    png_crc_finish(png_ptr, length);
#line 2229
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid");
#line 2230
    return;
  }
#line 2233
  png_crc_read(png_ptr, buf, (png_uint_32 )9);
#line 2235
  tmp = png_crc_finish(png_ptr, (png_uint_32 )0);
#line 2235
  if (tmp != 0) {
#line 2236
    return;
  }
#line 2238
  if ((int )buf[0] & 0x80) {
#line 2238
    tmp___0 = - ((png_int_32 )((((((((png_uint_32 )buf[0] << 24) + ((png_uint_32 )*(buf + 1) << 16)) + ((png_uint_32 )*(buf + 2) << 8)) + (png_uint_32 )*(buf + 3)) ^ 0xffffffffU) + 1U) & 0x7fffffffU));
  } else {
#line 2238
    tmp___0 = (png_int_32 )(((((png_uint_32 )buf[0] << 24) + ((png_uint_32 )*(buf + 1) << 16)) + ((png_uint_32 )*(buf + 2) << 8)) + (png_uint_32 )*(buf + 3));
  }
#line 2238
  offset_x = tmp___0;
#line 2239
  if ((int )*(buf + 4) & 0x80) {
#line 2239
    tmp___1 = - ((png_int_32 )((((((((png_uint_32 )*(buf + 4) << 24) + ((png_uint_32 )*((buf + 4) + 1) << 16)) + ((png_uint_32 )*((buf + 4) + 2) << 8)) + (png_uint_32 )*((buf + 4) + 3)) ^ 0xffffffffU) + 1U) & 0x7fffffffU));
  } else {
#line 2239
    tmp___1 = (png_int_32 )(((((png_uint_32 )*(buf + 4) << 24) + ((png_uint_32 )*((buf + 4) + 1) << 16)) + ((png_uint_32 )*((buf + 4) + 2) << 8)) + (png_uint_32 )*((buf + 4) + 3));
  }
#line 2239
  offset_y = tmp___1;
#line 2240
  unit_type = (int )buf[8];
#line 2241
  png_set_oFFs((png_const_structrp )png_ptr, info_ptr, offset_x, offset_y, unit_type);
#line 2242
  return;
}
}
#line 2247 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
void png_handle_pCAL(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length )
{
  png_int_32 X0 ;
  png_int_32 X1 ;
  png_byte type ;
  png_byte nparams ;
  png_bytep buffer___0 ;
  png_bytep buf ;
  png_bytep units ;
  png_bytep endptr ;
  png_charpp params ;
  int i ;
  int tmp ;
  png_int_32 tmp___0 ;
  png_int_32 tmp___1 ;
  png_voidp __attribute__((__malloc__))  tmp___2 ;

  {
#line 2258
  if ((png_ptr->mode & 1U) == 0U) {
#line 2259
    png_chunk_error((png_const_structrp )png_ptr, (png_const_charp )"missing IHDR");
  } else
#line 2261
  if ((png_ptr->mode & 0x04U) != 0U) {
#line 2263
    png_crc_finish(png_ptr, length);
#line 2264
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"out of place");
#line 2265
    return;
  } else
#line 2268
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 2268
    if ((info_ptr->valid & 0x0400U) != 0U) {
#line 2270
      png_crc_finish(png_ptr, length);
#line 2271
      png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"duplicate");
#line 2272
      return;
    }
  }
#line 2278
  buffer___0 = png_read_buffer(png_ptr, (png_alloc_size_t )(length + 1U), 2);
#line 2280
  if ((unsigned long )buffer___0 == (unsigned long )((void *)0)) {
#line 2282
    png_crc_finish(png_ptr, length);
#line 2283
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"out of memory");
#line 2284
    return;
  }
#line 2287
  png_crc_read(png_ptr, buffer___0, length);
#line 2289
  tmp = png_crc_finish(png_ptr, (png_uint_32 )0);
#line 2289
  if (tmp != 0) {
#line 2290
    return;
  }
#line 2292
  *(buffer___0 + length) = (png_byte )0;
#line 2295
  buf = buffer___0;
  {
#line 2295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2295
    if (! *buf) {
#line 2295
      goto while_break;
    }
#line 2295
    buf ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2298
  endptr = buffer___0 + length;
#line 2303
  if (endptr - buf <= 12L) {
#line 2305
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid");
#line 2306
    return;
  }
#line 2310
  if ((int )*(buf + 1) & 0x80) {
#line 2310
    tmp___0 = - ((png_int_32 )((((((((png_uint_32 )*(buf + 1) << 24) + ((png_uint_32 )*((buf + 1) + 1) << 16)) + ((png_uint_32 )*((buf + 1) + 2) << 8)) + (png_uint_32 )*((buf + 1) + 3)) ^ 0xffffffffU) + 1U) & 0x7fffffffU));
  } else {
#line 2310
    tmp___0 = (png_int_32 )(((((png_uint_32 )*(buf + 1) << 24) + ((png_uint_32 )*((buf + 1) + 1) << 16)) + ((png_uint_32 )*((buf + 1) + 2) << 8)) + (png_uint_32 )*((buf + 1) + 3));
  }
#line 2310
  X0 = tmp___0;
#line 2311
  if ((int )*(buf + 5) & 0x80) {
#line 2311
    tmp___1 = - ((png_int_32 )((((((((png_uint_32 )*(buf + 5) << 24) + ((png_uint_32 )*((buf + 5) + 1) << 16)) + ((png_uint_32 )*((buf + 5) + 2) << 8)) + (png_uint_32 )*((buf + 5) + 3)) ^ 0xffffffffU) + 1U) & 0x7fffffffU));
  } else {
#line 2311
    tmp___1 = (png_int_32 )(((((png_uint_32 )*(buf + 5) << 24) + ((png_uint_32 )*((buf + 5) + 1) << 16)) + ((png_uint_32 )*((buf + 5) + 2) << 8)) + (png_uint_32 )*((buf + 5) + 3));
  }
#line 2311
  X1 = tmp___1;
#line 2312
  type = *(buf + 9);
#line 2313
  nparams = *(buf + 10);
#line 2314
  units = buf + 11;
#line 2320
  if ((int )type == 0) {
#line 2320
    if ((int )nparams != 2) {
#line 2325
      png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid parameter count");
#line 2326
      return;
    } else {
#line 2320
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */
#line 2320
  if ((int )type == 1) {
#line 2320
    if ((int )nparams != 3) {
#line 2325
      png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid parameter count");
#line 2326
      return;
    } else {
#line 2320
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */
#line 2320
  if ((int )type == 2) {
#line 2320
    if ((int )nparams != 3) {
#line 2325
      png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid parameter count");
#line 2326
      return;
    } else {
#line 2320
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */
#line 2320
  if ((int )type == 3) {
#line 2320
    if ((int )nparams != 4) {
#line 2325
      png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid parameter count");
#line 2326
      return;
    } else {
#line 2320
      goto _L;
    }
  } else
  _L: /* CIL Label */
#line 2329
  if ((int )type >= 4) {
#line 2331
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"unrecognized equation type");
  }
#line 2334
  buf = units;
  {
#line 2334
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2334
    if (! *buf) {
#line 2334
      goto while_break___0;
    }
#line 2334
    buf ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2339
  tmp___2 = png_malloc_warn((png_const_structrp )png_ptr, (unsigned long )nparams * sizeof(png_charp ));
#line 2339
  params = (png_charpp )tmp___2;
#line 2342
  if ((unsigned long )params == (unsigned long )((void *)0)) {
#line 2344
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"out of memory");
#line 2345
    return;
  }
#line 2349
  i = 0;
  {
#line 2349
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2349
    if (! (i < (int )nparams)) {
#line 2349
      goto while_break___1;
    }
#line 2351
    buf ++;
#line 2355
    *(params + i) = (png_charp )buf;
    {
#line 2355
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2355
      if ((unsigned long )buf <= (unsigned long )endptr) {
#line 2355
        if (! ((int )*buf != 0)) {
#line 2355
          goto while_break___2;
        }
      } else {
#line 2355
        goto while_break___2;
      }
#line 2355
      buf ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2359
    if ((unsigned long )buf > (unsigned long )endptr) {
#line 2361
      png_free((png_const_structrp )png_ptr, (png_voidp )params);
#line 2362
      png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid data");
#line 2363
      return;
    }
#line 2349
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2367
  png_set_pCAL((png_const_structrp )png_ptr, info_ptr, (png_const_charp )((png_charp )buffer___0),
               X0, X1, (int )type, (int )nparams, (png_const_charp )((png_charp )units),
               params);
#line 2370
  png_free((png_const_structrp )png_ptr, (png_voidp )params);
#line 2371
  return;
}
}
#line 2376 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
void png_handle_sCAL(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length )
{
  png_bytep buffer___0 ;
  size_t i ;
  int state ;
  int tmp ;
  size_t heighti ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
#line 2385
  if ((png_ptr->mode & 1U) == 0U) {
#line 2386
    png_chunk_error((png_const_structrp )png_ptr, (png_const_charp )"missing IHDR");
  } else
#line 2388
  if ((png_ptr->mode & 0x04U) != 0U) {
#line 2390
    png_crc_finish(png_ptr, length);
#line 2391
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"out of place");
#line 2392
    return;
  } else
#line 2395
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 2395
    if ((info_ptr->valid & 0x4000U) != 0U) {
#line 2397
      png_crc_finish(png_ptr, length);
#line 2398
      png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"duplicate");
#line 2399
      return;
    } else {
#line 2395
      goto _L;
    }
  } else
  _L: /* CIL Label */
#line 2403
  if (length < 4U) {
#line 2405
    png_crc_finish(png_ptr, length);
#line 2406
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid");
#line 2407
    return;
  }
#line 2413
  buffer___0 = png_read_buffer(png_ptr, (png_alloc_size_t )(length + 1U), 2);
#line 2415
  if ((unsigned long )buffer___0 == (unsigned long )((void *)0)) {
#line 2417
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"out of memory");
#line 2418
    png_crc_finish(png_ptr, length);
#line 2419
    return;
  }
#line 2422
  png_crc_read(png_ptr, buffer___0, length);
#line 2423
  *(buffer___0 + length) = (png_byte )0;
#line 2425
  tmp = png_crc_finish(png_ptr, (png_uint_32 )0);
#line 2425
  if (tmp != 0) {
#line 2426
    return;
  }
#line 2429
  if ((int )*(buffer___0 + 0) != 1) {
#line 2429
    if ((int )*(buffer___0 + 0) != 2) {
#line 2431
      png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid unit");
#line 2432
      return;
    }
  }
#line 2438
  i = (size_t )1;
#line 2439
  state = 0;
#line 2441
  tmp___1 = png_check_fp_number((png_const_charp )buffer___0, (size_t )length, & state,
                                & i);
#line 2441
  if (tmp___1 == 0) {
#line 2443
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"bad width format");
  } else
#line 2441
  if (i >= (size_t )length) {
#line 2443
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"bad width format");
  } else {
#line 2441
    tmp___2 = i;
#line 2441
    i ++;
#line 2441
    if ((int )*(buffer___0 + tmp___2) != 0) {
#line 2443
      png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"bad width format");
    } else
#line 2445
    if (((state & 392) == 264) == 0) {
#line 2446
      png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"non-positive width");
    } else {
#line 2450
      heighti = i;
#line 2452
      state = 0;
#line 2453
      tmp___0 = png_check_fp_number((png_const_charp )buffer___0, (size_t )length,
                                    & state, & i);
#line 2453
      if (tmp___0 == 0) {
#line 2455
        png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"bad height format");
      } else
#line 2453
      if (i != (size_t )length) {
#line 2455
        png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"bad height format");
      } else
#line 2457
      if (((state & 392) == 264) == 0) {
#line 2458
        png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"non-positive height");
      } else {
#line 2462
        png_set_sCAL_s((png_const_structrp )png_ptr, info_ptr, (int )*(buffer___0 + 0),
                       (png_const_charp )((png_charp )buffer___0 + 1), (png_const_charp )((png_charp )buffer___0 + heighti));
      }
    }
  }
#line 2465
  return;
}
}
#line 2469 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
void png_handle_tIME(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length )
{
  png_byte buf[7] ;
  png_time mod_time ;
  int tmp ;

  {
#line 2477
  if ((png_ptr->mode & 1U) == 0U) {
#line 2478
    png_chunk_error((png_const_structrp )png_ptr, (png_const_charp )"missing IHDR");
  } else
#line 2480
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 2480
    if ((info_ptr->valid & 0x0200U) != 0U) {
#line 2482
      png_crc_finish(png_ptr, length);
#line 2483
      png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"duplicate");
#line 2484
      return;
    }
  }
#line 2487
  if ((png_ptr->mode & 0x04U) != 0U) {
#line 2488
    png_ptr->mode |= 8U;
  }
#line 2490
  if (length != 7U) {
#line 2492
    png_crc_finish(png_ptr, length);
#line 2493
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"invalid");
#line 2494
    return;
  }
#line 2497
  png_crc_read(png_ptr, buf, (png_uint_32 )7);
#line 2499
  tmp = png_crc_finish(png_ptr, (png_uint_32 )0);
#line 2499
  if (tmp != 0) {
#line 2500
    return;
  }
#line 2502
  mod_time.second = buf[6];
#line 2503
  mod_time.minute = buf[5];
#line 2504
  mod_time.hour = buf[4];
#line 2505
  mod_time.day = buf[3];
#line 2506
  mod_time.month = buf[2];
#line 2507
  mod_time.year = (png_uint_16 )(((unsigned int )buf[0] << 8) + (unsigned int )*(buf + 1));
#line 2509
  png_set_tIME((png_const_structrp )png_ptr, info_ptr, (png_const_timep )(& mod_time));
#line 2510
  return;
}
}
#line 2515 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
void png_handle_tEXt(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length )
{
  png_text text_info ;
  png_bytep buffer___0 ;
  png_charp key___3 ;
  png_charp text ;
  png_uint_32 skip ;
  int tmp ;
  int tmp___0 ;

  {
#line 2522
  skip = (png_uint_32 )0;
#line 2527
  if (png_ptr->user_chunk_cache_max != 0U) {
#line 2529
    if (png_ptr->user_chunk_cache_max == 1U) {
#line 2531
      png_crc_finish(png_ptr, length);
#line 2532
      return;
    }
#line 2535
    (png_ptr->user_chunk_cache_max) --;
#line 2535
    if (png_ptr->user_chunk_cache_max == 1U) {
#line 2537
      png_crc_finish(png_ptr, length);
#line 2538
      png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"no space in chunk cache");
#line 2539
      return;
    }
  }
#line 2544
  if ((png_ptr->mode & 1U) == 0U) {
#line 2545
    png_chunk_error((png_const_structrp )png_ptr, (png_const_charp )"missing IHDR");
  }
#line 2547
  if ((png_ptr->mode & 0x04U) != 0U) {
#line 2548
    png_ptr->mode |= 8U;
  }
#line 2559
  buffer___0 = png_read_buffer(png_ptr, (png_alloc_size_t )(length + 1U), 1);
#line 2561
  if ((unsigned long )buffer___0 == (unsigned long )((void *)0)) {
#line 2563
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"out of memory");
#line 2564
    return;
  }
#line 2567
  png_crc_read(png_ptr, buffer___0, length);
#line 2569
  tmp = png_crc_finish(png_ptr, skip);
#line 2569
  if (tmp != 0) {
#line 2570
    return;
  }
#line 2572
  key___3 = (png_charp )buffer___0;
#line 2573
  *(key___3 + length) = (char)0;
#line 2575
  text = key___3;
  {
#line 2575
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2575
    if (! *text) {
#line 2575
      goto while_break;
    }
#line 2575
    text ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2578
  if ((unsigned long )text != (unsigned long )(key___3 + length)) {
#line 2579
    text ++;
  }
#line 2581
  text_info.compression = -1;
#line 2582
  text_info.key = key___3;
#line 2583
  text_info.lang = (png_charp )((void *)0);
#line 2584
  text_info.lang_key = (png_charp )((void *)0);
#line 2585
  text_info.itxt_length = (size_t )0;
#line 2586
  text_info.text = text;
#line 2587
  text_info.text_length = strlen((char const   *)text);
#line 2589
  tmp___0 = png_set_text_2((png_const_structrp )png_ptr, info_ptr, (png_const_textp )(& text_info),
                           1);
#line 2589
  if (tmp___0 != 0) {
#line 2590
    png_warning((png_const_structrp )png_ptr, (png_const_charp )"Insufficient memory to process text chunk");
  }
#line 2591
  return;
}
}
#line 2596 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
void png_handle_zTXt(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length )
{
  png_const_charp errmsg ;
  png_bytep buffer___0 ;
  png_uint_32 keyword_length ;
  int tmp ;
  png_alloc_size_t uncompressed_length ;
  png_text text ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2599
  errmsg = (png_const_charp )((void *)0);
#line 2606
  if (png_ptr->user_chunk_cache_max != 0U) {
#line 2608
    if (png_ptr->user_chunk_cache_max == 1U) {
#line 2610
      png_crc_finish(png_ptr, length);
#line 2611
      return;
    }
#line 2614
    (png_ptr->user_chunk_cache_max) --;
#line 2614
    if (png_ptr->user_chunk_cache_max == 1U) {
#line 2616
      png_crc_finish(png_ptr, length);
#line 2617
      png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"no space in chunk cache");
#line 2618
      return;
    }
  }
#line 2623
  if ((png_ptr->mode & 1U) == 0U) {
#line 2624
    png_chunk_error((png_const_structrp )png_ptr, (png_const_charp )"missing IHDR");
  }
#line 2626
  if ((png_ptr->mode & 0x04U) != 0U) {
#line 2627
    png_ptr->mode |= 8U;
  }
#line 2632
  buffer___0 = png_read_buffer(png_ptr, (png_alloc_size_t )length, 2);
#line 2634
  if ((unsigned long )buffer___0 == (unsigned long )((void *)0)) {
#line 2636
    png_crc_finish(png_ptr, length);
#line 2637
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"out of memory");
#line 2638
    return;
  }
#line 2641
  png_crc_read(png_ptr, buffer___0, length);
#line 2643
  tmp = png_crc_finish(png_ptr, (png_uint_32 )0);
#line 2643
  if (tmp != 0) {
#line 2644
    return;
  }
#line 2647
  keyword_length = (png_uint_32 )0;
  {
#line 2647
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2647
    if (keyword_length < length) {
#line 2647
      if (! ((int )*(buffer___0 + keyword_length) != 0)) {
#line 2647
        goto while_break;
      }
    } else {
#line 2647
      goto while_break;
    }
#line 2647
    keyword_length ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2652
  if (keyword_length > 79U) {
#line 2653
    errmsg = (png_const_charp )"bad keyword";
  } else
#line 2652
  if (keyword_length < 1U) {
#line 2653
    errmsg = (png_const_charp )"bad keyword";
  } else
#line 2659
  if (keyword_length + 3U > length) {
#line 2660
    errmsg = (png_const_charp )"truncated";
  } else
#line 2662
  if ((int )*(buffer___0 + (keyword_length + 1U)) != 0) {
#line 2663
    errmsg = (png_const_charp )"unknown compression type";
  } else {
#line 2667
    uncompressed_length = (size_t )-1;
#line 2673
    tmp___1 = png_decompress_chunk(png_ptr, length, keyword_length + 2U, & uncompressed_length,
                                   1);
#line 2673
    if (tmp___1 == 1) {
#line 2678
      if ((unsigned long )png_ptr->read_buffer == (unsigned long )((void *)0)) {
#line 2679
        errmsg = (png_const_charp )"Read failure in png_handle_zTXt";
      } else {
#line 2686
        buffer___0 = png_ptr->read_buffer;
#line 2687
        *(buffer___0 + (uncompressed_length + (png_alloc_size_t )(keyword_length + 2U))) = (png_byte )0;
#line 2689
        text.compression = 0;
#line 2690
        text.key = (png_charp )buffer___0;
#line 2691
        text.text = (png_charp )((buffer___0 + keyword_length) + 2);
#line 2692
        text.text_length = uncompressed_length;
#line 2693
        text.itxt_length = (size_t )0;
#line 2694
        text.lang = (png_charp )((void *)0);
#line 2695
        text.lang_key = (png_charp )((void *)0);
#line 2697
        tmp___0 = png_set_text_2((png_const_structrp )png_ptr, info_ptr, (png_const_textp )(& text),
                                 1);
#line 2697
        if (tmp___0 != 0) {
#line 2698
          errmsg = (png_const_charp )"insufficient memory";
        }
      }
    } else {
#line 2703
      errmsg = png_ptr->zstream.msg;
    }
  }
#line 2706
  if ((unsigned long )errmsg != (unsigned long )((void *)0)) {
#line 2707
    png_chunk_benign_error((png_const_structrp )png_ptr, errmsg);
  }
#line 2708
  return;
}
}
#line 2713 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
void png_handle_iTXt(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length )
{
  png_const_charp errmsg ;
  png_bytep buffer___0 ;
  png_uint_32 prefix_length ;
  int tmp ;
  int compressed ;
  png_uint_32 language_offset ;
  png_uint_32 translated_keyword_offset ;
  png_alloc_size_t uncompressed_length ;
  int tmp___0 ;
  png_text text ;
  int tmp___1 ;

  {
#line 2716
  errmsg = (png_const_charp )((void *)0);
#line 2723
  if (png_ptr->user_chunk_cache_max != 0U) {
#line 2725
    if (png_ptr->user_chunk_cache_max == 1U) {
#line 2727
      png_crc_finish(png_ptr, length);
#line 2728
      return;
    }
#line 2731
    (png_ptr->user_chunk_cache_max) --;
#line 2731
    if (png_ptr->user_chunk_cache_max == 1U) {
#line 2733
      png_crc_finish(png_ptr, length);
#line 2734
      png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"no space in chunk cache");
#line 2735
      return;
    }
  }
#line 2740
  if ((png_ptr->mode & 1U) == 0U) {
#line 2741
    png_chunk_error((png_const_structrp )png_ptr, (png_const_charp )"missing IHDR");
  }
#line 2743
  if ((png_ptr->mode & 0x04U) != 0U) {
#line 2744
    png_ptr->mode |= 8U;
  }
#line 2746
  buffer___0 = png_read_buffer(png_ptr, (png_alloc_size_t )(length + 1U), 1);
#line 2748
  if ((unsigned long )buffer___0 == (unsigned long )((void *)0)) {
#line 2750
    png_crc_finish(png_ptr, length);
#line 2751
    png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"out of memory");
#line 2752
    return;
  }
#line 2755
  png_crc_read(png_ptr, buffer___0, length);
#line 2757
  tmp = png_crc_finish(png_ptr, (png_uint_32 )0);
#line 2757
  if (tmp != 0) {
#line 2758
    return;
  }
#line 2761
  prefix_length = (png_uint_32 )0;
  {
#line 2761
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2761
    if (prefix_length < length) {
#line 2761
      if (! ((int )*(buffer___0 + prefix_length) != 0)) {
#line 2761
        goto while_break;
      }
    } else {
#line 2761
      goto while_break;
    }
#line 2761
    prefix_length ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2767
  if (prefix_length > 79U) {
#line 2768
    errmsg = (png_const_charp )"bad keyword";
  } else
#line 2767
  if (prefix_length < 1U) {
#line 2768
    errmsg = (png_const_charp )"bad keyword";
  } else
#line 2774
  if (prefix_length + 5U > length) {
#line 2775
    errmsg = (png_const_charp )"truncated";
  } else
#line 2777
  if ((int )*(buffer___0 + (prefix_length + 1U)) == 0) {
#line 2777
    goto _L___0;
  } else
#line 2777
  if ((int )*(buffer___0 + (prefix_length + 1U)) == 1) {
#line 2777
    if ((int )*(buffer___0 + (prefix_length + 2U)) == 0) {
      _L___0: /* CIL Label */
#line 2781
      compressed = (int )*(buffer___0 + (prefix_length + 1U)) != 0;
#line 2783
      uncompressed_length = (png_alloc_size_t )0;
#line 2786
      prefix_length += 3U;
#line 2787
      language_offset = prefix_length;
      {
#line 2789
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2789
        if (prefix_length < length) {
#line 2789
          if (! ((int )*(buffer___0 + prefix_length) != 0)) {
#line 2789
            goto while_break___0;
          }
        } else {
#line 2789
          goto while_break___0;
        }
#line 2789
        prefix_length ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2794
      prefix_length ++;
#line 2794
      translated_keyword_offset = prefix_length;
      {
#line 2796
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2796
        if (prefix_length < length) {
#line 2796
          if (! ((int )*(buffer___0 + prefix_length) != 0)) {
#line 2796
            goto while_break___1;
          }
        } else {
#line 2796
          goto while_break___1;
        }
#line 2796
        prefix_length ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2805
      prefix_length ++;
#line 2807
      if (compressed == 0) {
#line 2807
        if (prefix_length <= length) {
#line 2808
          uncompressed_length = (png_alloc_size_t )(length - prefix_length);
        } else {
#line 2807
          goto _L;
        }
      } else
      _L: /* CIL Label */
#line 2810
      if (compressed != 0) {
#line 2810
        if (prefix_length < length) {
#line 2812
          uncompressed_length = (size_t )-1;
#line 2818
          tmp___0 = png_decompress_chunk(png_ptr, length, prefix_length, & uncompressed_length,
                                         1);
#line 2818
          if (tmp___0 == 1) {
#line 2820
            buffer___0 = png_ptr->read_buffer;
          } else {
#line 2823
            errmsg = png_ptr->zstream.msg;
          }
        } else {
#line 2827
          errmsg = (png_const_charp )"truncated";
        }
      } else {
#line 2827
        errmsg = (png_const_charp )"truncated";
      }
#line 2829
      if ((unsigned long )errmsg == (unsigned long )((void *)0)) {
#line 2833
        *(buffer___0 + (uncompressed_length + (png_alloc_size_t )prefix_length)) = (png_byte )0;
#line 2835
        if (compressed == 0) {
#line 2836
          text.compression = 1;
        } else {
#line 2839
          text.compression = 2;
        }
#line 2841
        text.key = (png_charp )buffer___0;
#line 2842
        text.lang = (png_charp )buffer___0 + language_offset;
#line 2843
        text.lang_key = (png_charp )buffer___0 + translated_keyword_offset;
#line 2844
        text.text = (png_charp )buffer___0 + prefix_length;
#line 2845
        text.text_length = (size_t )0;
#line 2846
        text.itxt_length = uncompressed_length;
#line 2848
        tmp___1 = png_set_text_2((png_const_structrp )png_ptr, info_ptr, (png_const_textp )(& text),
                                 1);
#line 2848
        if (tmp___1 != 0) {
#line 2849
          errmsg = (png_const_charp )"insufficient memory";
        }
      }
    } else {
#line 2854
      errmsg = (png_const_charp )"bad compression info";
    }
  } else {
#line 2854
    errmsg = (png_const_charp )"bad compression info";
  }
#line 2856
  if ((unsigned long )errmsg != (unsigned long )((void *)0)) {
#line 2857
    png_chunk_benign_error((png_const_structrp )png_ptr, errmsg);
  }
#line 2858
  return;
}
}
#line 2863 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
static int png_cache_unknown_chunk(png_structrp png_ptr , png_uint_32 length )
{
  png_alloc_size_t limit ;
  png_voidp __attribute__((__malloc__))  tmp ;

  {
#line 2866
  limit = (size_t )-1;
#line 2868
  if ((unsigned long )png_ptr->unknown_chunk.data != (unsigned long )((void *)0)) {
#line 2870
    png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->unknown_chunk.data);
#line 2871
    png_ptr->unknown_chunk.data = (png_byte *)((void *)0);
  }
#line 2875
  if (png_ptr->user_chunk_malloc_max > 0UL) {
#line 2875
    if (png_ptr->user_chunk_malloc_max < limit) {
#line 2877
      limit = png_ptr->user_chunk_malloc_max;
    }
  }
#line 2884
  if ((png_alloc_size_t )length <= limit) {
#line 2886
    *((char *)(png_ptr->unknown_chunk.name) + 0) = (char )((png_ptr->chunk_name >> 24) & 255U);
#line 2886
    *((char *)(png_ptr->unknown_chunk.name) + 1) = (char )((png_ptr->chunk_name >> 16) & 255U);
#line 2886
    *((char *)(png_ptr->unknown_chunk.name) + 2) = (char )((png_ptr->chunk_name >> 8) & 255U);
#line 2886
    *((char *)(png_ptr->unknown_chunk.name) + 3) = (char )(png_ptr->chunk_name & 255U);
#line 2886
    *((char *)(png_ptr->unknown_chunk.name) + 4) = (char)0;
#line 2888
    png_ptr->unknown_chunk.size = (size_t )length;
#line 2890
    png_ptr->unknown_chunk.location = (png_byte )png_ptr->mode;
#line 2892
    if (length == 0U) {
#line 2893
      png_ptr->unknown_chunk.data = (png_byte *)((void *)0);
    } else {
#line 2898
      tmp = png_malloc_warn((png_const_structrp )png_ptr, (png_alloc_size_t )length);
#line 2898
      png_ptr->unknown_chunk.data = (png_byte *)tmp;
    }
  }
#line 2903
  if ((unsigned long )png_ptr->unknown_chunk.data == (unsigned long )((void *)0)) {
#line 2903
    if (length > 0U) {
#line 2906
      png_crc_finish(png_ptr, length);
#line 2907
      png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"unknown chunk exceeds memory limits");
#line 2908
      return (0);
    } else {
#line 2903
      goto _L;
    }
  } else {
    _L: /* CIL Label */
#line 2913
    if (length > 0U) {
#line 2914
      png_crc_read(png_ptr, png_ptr->unknown_chunk.data, length);
    }
#line 2915
    png_crc_finish(png_ptr, (png_uint_32 )0);
#line 2916
    return (1);
  }
}
}
#line 2922 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
void png_handle_unknown(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ,
                        int keep )
{
  int handled ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2926
  handled = 0;
#line 2956
  if ((unsigned long )png_ptr->read_user_chunk_fn != (unsigned long )((void *)0)) {
#line 2958
    tmp___0 = png_cache_unknown_chunk(png_ptr, length);
#line 2958
    if (tmp___0 != 0) {
#line 2961
      tmp = (*(png_ptr->read_user_chunk_fn))((png_structp )png_ptr, & png_ptr->unknown_chunk);
#line 2961
      ret = tmp;
#line 2973
      if (ret < 0) {
#line 2974
        png_chunk_error((png_const_structrp )png_ptr, (png_const_charp )"error in user chunk");
      } else
#line 2976
      if (ret == 0) {
#line 2989
        if (keep < 2) {
#line 2992
          if (png_ptr->unknown_default < 2) {
#line 2994
            png_chunk_warning((png_const_structrp )png_ptr, (png_const_charp )"Saving unknown chunk:");
#line 2995
            png_app_warning((png_const_structrp )png_ptr, (png_const_charp )"forcing save of an unhandled chunk; please call png_set_keep_unknown_chunks");
          }
#line 3001
          keep = 2;
        }
      } else {
#line 3007
        handled = 1;
#line 3009
        keep = 1;
      }
    } else {
#line 3014
      keep = 1;
    }
  } else {
#line 3028
    if (keep == 0) {
#line 3029
      keep = png_ptr->unknown_default;
    }
#line 3031
    if (keep == 3) {
#line 3031
      goto _L;
    } else
#line 3031
    if (keep == 2) {
#line 3031
      if (1U & (png_ptr->chunk_name >> 29)) {
        _L: /* CIL Label */
#line 3035
        tmp___1 = png_cache_unknown_chunk(png_ptr, length);
#line 3035
        if (tmp___1 == 0) {
#line 3036
          keep = 1;
        }
      } else {
#line 3040
        png_crc_finish(png_ptr, length);
      }
    } else {
#line 3040
      png_crc_finish(png_ptr, length);
    }
  }
#line 3065
  if (keep == 3) {
#line 3065
    goto _L___0;
  } else
#line 3065
  if (keep == 2) {
#line 3065
    if (1U & (png_ptr->chunk_name >> 29)) {
      _L___0: /* CIL Label */
      {
#line 3072
      if (png_ptr->user_chunk_cache_max == 2U) {
#line 3072
        goto case_2;
      }
#line 3076
      if (png_ptr->user_chunk_cache_max == 1U) {
#line 3076
        goto case_1;
      }
#line 3085
      if (png_ptr->user_chunk_cache_max == 0U) {
#line 3085
        goto case_0;
      }
#line 3082
      goto switch_default;
      case_2: /* CIL Label */
#line 3073
      png_ptr->user_chunk_cache_max = (png_uint_32 )1;
#line 3074
      png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"no space in chunk cache");
      case_1: /* CIL Label */
#line 3080
      goto switch_break;
      switch_default: /* CIL Label */
#line 3083
      (png_ptr->user_chunk_cache_max) --;
      case_0: /* CIL Label */
#line 3090
      png_set_unknown_chunks((png_const_structrp )png_ptr, info_ptr, (png_const_unknown_chunkp )(& png_ptr->unknown_chunk),
                             1);
#line 3092
      handled = 1;
#line 3094
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 3106
  if ((unsigned long )png_ptr->unknown_chunk.data != (unsigned long )((void *)0)) {
#line 3107
    png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->unknown_chunk.data);
  }
#line 3108
  png_ptr->unknown_chunk.data = (png_byte *)((void *)0);
#line 3118
  if (handled == 0) {
#line 3118
    if (! (1U & (png_ptr->chunk_name >> 29))) {
#line 3119
      png_chunk_error((png_const_structrp )png_ptr, (png_const_charp )"unhandled critical chunk");
    }
  }
#line 3120
  return;
}
}
#line 3134 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
void png_check_chunk_name(png_const_structrp png_ptr , png_uint_32 chunk_name )
{
  int i ;
  png_uint_32 cn ;
  int c ;

  {
#line 3138
  cn = chunk_name;
#line 3142
  i = 1;
  {
#line 3142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3142
    if (! (i <= 4)) {
#line 3142
      goto while_break;
    }
#line 3144
    c = (int )(cn & 255U);
#line 3146
    if (c < 65) {
#line 3147
      png_chunk_error(png_ptr, (png_const_charp )"invalid chunk type");
    } else
#line 3146
    if (c > 122) {
#line 3147
      png_chunk_error(png_ptr, (png_const_charp )"invalid chunk type");
    } else
#line 3146
    if (c > 90) {
#line 3146
      if (c < 97) {
#line 3147
        png_chunk_error(png_ptr, (png_const_charp )"invalid chunk type");
      }
    }
#line 3149
    cn >>= 8;
#line 3142
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3151
  return;
}
}
#line 3153 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
void png_check_chunk_length(png_const_structrp png_ptr , png_uint_32 length )
{
  png_alloc_size_t limit ;
  png_alloc_size_t idat_limit ;
  size_t row_factor ;
  int tmp ;
  int tmp___0 ;

  {
#line 3156
  limit = (png_alloc_size_t )((png_uint_32 )0x7fffffffL);
#line 3159
  if (png_ptr->user_chunk_malloc_max > 0UL) {
#line 3159
    if (png_ptr->user_chunk_malloc_max < (png_alloc_size_t )limit) {
#line 3161
      limit = (png_alloc_size_t )png_ptr->user_chunk_malloc_max;
    }
  }
#line 3166
  if (png_ptr->chunk_name == (png_uint_32 )((((73U << 24) | (68U << 16)) | (65U << 8)) | 84U)) {
#line 3168
    idat_limit = (png_alloc_size_t )((png_uint_32 )0x7fffffffL);
#line 3169
    if ((int )png_ptr->bit_depth > 8) {
#line 3169
      tmp = 2;
    } else {
#line 3169
      tmp = 1;
    }
#line 3169
    if (png_ptr->interlaced) {
#line 3169
      tmp___0 = 6;
    } else {
#line 3169
      tmp___0 = 0;
    }
#line 3169
    row_factor = (((size_t )png_ptr->width * (size_t )png_ptr->channels) * (size_t )tmp + 1UL) + (size_t )tmp___0;
#line 3175
    if ((size_t )png_ptr->height > 4294967295UL / row_factor) {
#line 3176
      idat_limit = (png_alloc_size_t )((png_uint_32 )0x7fffffffL);
    } else {
#line 3178
      idat_limit = (size_t )png_ptr->height * row_factor;
    }
#line 3179
    if (row_factor > 32566UL) {
#line 3179
      row_factor = (size_t )32566;
    } else {
#line 3179
      row_factor = row_factor;
    }
#line 3180
    idat_limit += 6UL + 5UL * (idat_limit / row_factor + 1UL);
#line 3181
    if (idat_limit < 2147483647UL) {
#line 3181
      idat_limit = idat_limit;
    } else {
#line 3181
      idat_limit = (png_alloc_size_t )((png_uint_32 )0x7fffffffL);
    }
#line 3182
    if (limit < idat_limit) {
#line 3182
      limit = idat_limit;
    } else {
#line 3182
      limit = limit;
    }
  }
#line 3185
  if ((png_alloc_size_t )length > limit) {
#line 3189
    png_benign_error(png_ptr, (png_const_charp )"chunk data is too large");
  }
#line 3191
  return;
}
}
#line 3366 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
static png_uint_32 const   row_mask[2][3][6]  = { { {          (png_uint_32 const   )(((1U << 1) - 1U) * 16843009U),          (png_uint_32 const   )((((1U << 1) - 1U) << 4) * 16843009U),          (png_uint_32 const   )((((1U << 1) - 1U) + (((1U << 1) - 1U) << 4)) * 16843009U),          (png_uint_32 const   )(((((1U << 1) - 1U) << 2) + (((1U << 1) - 1U) << 6)) * 16843009U),
                (png_uint_32 const   )((((((1U << 1) - 1U) + (((1U << 1) - 1U) << 2)) + (((1U << 1) - 1U) << 4)) + (((1U << 1) - 1U) << 6)) * 16843009U),          (png_uint_32 const   )(((((((1U << 1) - 1U) << 1) + (((1U << 1) - 1U) << 3)) + (((1U << 1) - 1U) << 5)) + (((1U << 1) - 1U) << 7)) * 16843009U)},
     {          (png_uint_32 const   )(((1U << 2) - 1U) * 65537U),          (png_uint_32 const   )((((1U << 2) - 1U) << 8) * 65537U),          (png_uint_32 const   )((((1U << 2) - 1U) + (((1U << 2) - 1U) << 8)) * 65537U),          (png_uint_32 const   )(((((1U << 2) - 1U) << 4) + (((1U << 2) - 1U) << 12)) * 65537U),
                (png_uint_32 const   )((((((1U << 2) - 1U) + (((1U << 2) - 1U) << 4)) + (((1U << 2) - 1U) << 8)) + (((1U << 2) - 1U) << 12)) * 65537U),          (png_uint_32 const   )(((((((1U << 2) - 1U) << 2) + (((1U << 2) - 1U) << 6)) + (((1U << 2) - 1U) << 10)) + (((1U << 2) - 1U) << 14)) * 65537U)},
     {          (png_uint_32 const   )((1U << 4) - 1U),          (png_uint_32 const   )(((1U << 4) - 1U) << 16),          (png_uint_32 const   )(((1U << 4) - 1U) + (((1U << 4) - 1U) << 16)),          (png_uint_32 const   )((((1U << 4) - 1U) << 8) + (((1U << 4) - 1U) << 24)),
                (png_uint_32 const   )(((((1U << 4) - 1U) + (((1U << 4) - 1U) << 8)) + (((1U << 4) - 1U) << 16)) + (((1U << 4) - 1U) << 24)),          (png_uint_32 const   )((((((1U << 4) - 1U) << 4) + (((1U << 4) - 1U) << 12)) + (((1U << 4) - 1U) << 20)) + (((1U << 4) - 1U) << 28))}},
   { {          (png_uint_32 const   )((((1U << 1) - 1U) << 7) * 16843009U),          (png_uint_32 const   )((((1U << 1) - 1U) << 3) * 16843009U),          (png_uint_32 const   )(((((1U << 1) - 1U) << 7) + (((1U << 1) - 1U) << 3)) * 16843009U),          (png_uint_32 const   )(((((1U << 1) - 1U) << 5) + (((1U << 1) - 1U) << 1)) * 16843009U),
                (png_uint_32 const   )(((((((1U << 1) - 1U) << 7) + (((1U << 1) - 1U) << 5)) + (((1U << 1) - 1U) << 3)) + (((1U << 1) - 1U) << 1)) * 16843009U),          (png_uint_32 const   )(((((((1U << 1) - 1U) << 6) + (((1U << 1) - 1U) << 4)) + (((1U << 1) - 1U) << 2)) + ((1U << 1) - 1U)) * 16843009U)},
     {          (png_uint_32 const   )((((1U << 2) - 1U) << 6) * 65537U),          (png_uint_32 const   )((((1U << 2) - 1U) << 14) * 65537U),          (png_uint_32 const   )(((((1U << 2) - 1U) << 6) + (((1U << 2) - 1U) << 14)) * 65537U),          (png_uint_32 const   )(((((1U << 2) - 1U) << 2) + (((1U << 2) - 1U) << 10)) * 65537U),
                (png_uint_32 const   )(((((((1U << 2) - 1U) << 6) + (((1U << 2) - 1U) << 2)) + (((1U << 2) - 1U) << 14)) + (((1U << 2) - 1U) << 10)) * 65537U),          (png_uint_32 const   )(((((((1U << 2) - 1U) << 4) + ((1U << 2) - 1U)) + (((1U << 2) - 1U) << 12)) + (((1U << 2) - 1U) << 8)) * 65537U)},
     {          (png_uint_32 const   )(((1U << 4) - 1U) << 4),          (png_uint_32 const   )(((1U << 4) - 1U) << 20),          (png_uint_32 const   )((((1U << 4) - 1U) << 4) + (((1U << 4) - 1U) << 20)),          (png_uint_32 const   )((((1U << 4) - 1U) << 12) + (((1U << 4) - 1U) << 28)),
                (png_uint_32 const   )((((((1U << 4) - 1U) << 4) + (((1U << 4) - 1U) << 12)) + (((1U << 4) - 1U) << 20)) + (((1U << 4) - 1U) << 28)),          (png_uint_32 const   )(((((1U << 4) - 1U) + (((1U << 4) - 1U) << 8)) + (((1U << 4) - 1U) << 16)) + (((1U << 4) - 1U) << 24))}}};
#line 3377 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
static png_uint_32 const   display_mask[2][3][3]  = { { {          (png_uint_32 const   )(((((((1U << 1) - 1U) << 4) + (((1U << 1) - 1U) << 5)) + (((1U << 1) - 1U) << 6)) + (((1U << 1) - 1U) << 7)) * 16843009U),          (png_uint_32 const   )(((((((1U << 1) - 1U) << 2) + (((1U << 1) - 1U) << 3)) + (((1U << 1) - 1U) << 6)) + (((1U << 1) - 1U) << 7)) * 16843009U),          (png_uint_32 const   )(((((((1U << 1) - 1U) << 1) + (((1U << 1) - 1U) << 3)) + (((1U << 1) - 1U) << 5)) + (((1U << 1) - 1U) << 7)) * 16843009U)},
     {          (png_uint_32 const   )(((((((1U << 2) - 1U) << 8) + (((1U << 2) - 1U) << 10)) + (((1U << 2) - 1U) << 12)) + (((1U << 2) - 1U) << 14)) * 65537U),          (png_uint_32 const   )(((((((1U << 2) - 1U) << 4) + (((1U << 2) - 1U) << 6)) + (((1U << 2) - 1U) << 12)) + (((1U << 2) - 1U) << 14)) * 65537U),          (png_uint_32 const   )(((((((1U << 2) - 1U) << 2) + (((1U << 2) - 1U) << 6)) + (((1U << 2) - 1U) << 10)) + (((1U << 2) - 1U) << 14)) * 65537U)},
     {          (png_uint_32 const   )((((((1U << 4) - 1U) << 16) + (((1U << 4) - 1U) << 20)) + (((1U << 4) - 1U) << 24)) + (((1U << 4) - 1U) << 28)),          (png_uint_32 const   )((((((1U << 4) - 1U) << 8) + (((1U << 4) - 1U) << 12)) + (((1U << 4) - 1U) << 24)) + (((1U << 4) - 1U) << 28)),          (png_uint_32 const   )((((((1U << 4) - 1U) << 4) + (((1U << 4) - 1U) << 12)) + (((1U << 4) - 1U) << 20)) + (((1U << 4) - 1U) << 28))}},
   { {          (png_uint_32 const   )(((((((1U << 1) - 1U) << 3) + (((1U << 1) - 1U) << 2)) + (((1U << 1) - 1U) << 1)) + ((1U << 1) - 1U)) * 16843009U),          (png_uint_32 const   )(((((((1U << 1) - 1U) << 5) + (((1U << 1) - 1U) << 4)) + (((1U << 1) - 1U) << 1)) + ((1U << 1) - 1U)) * 16843009U),          (png_uint_32 const   )(((((((1U << 1) - 1U) << 6) + (((1U << 1) - 1U) << 4)) + (((1U << 1) - 1U) << 2)) + ((1U << 1) - 1U)) * 16843009U)},
     {          (png_uint_32 const   )(((((((1U << 2) - 1U) << 14) + (((1U << 2) - 1U) << 12)) + (((1U << 2) - 1U) << 10)) + (((1U << 2) - 1U) << 8)) * 65537U),          (png_uint_32 const   )(((((((1U << 2) - 1U) << 2) + ((1U << 2) - 1U)) + (((1U << 2) - 1U) << 10)) + (((1U << 2) - 1U) << 8)) * 65537U),          (png_uint_32 const   )(((((((1U << 2) - 1U) << 4) + ((1U << 2) - 1U)) + (((1U << 2) - 1U) << 12)) + (((1U << 2) - 1U) << 8)) * 65537U)},
     {          (png_uint_32 const   )((((((1U << 4) - 1U) << 20) + (((1U << 4) - 1U) << 16)) + (((1U << 4) - 1U) << 28)) + (((1U << 4) - 1U) << 24)),          (png_uint_32 const   )((((((1U << 4) - 1U) << 12) + (((1U << 4) - 1U) << 8)) + (((1U << 4) - 1U) << 28)) + (((1U << 4) - 1U) << 24)),          (png_uint_32 const   )(((((1U << 4) - 1U) + (((1U << 4) - 1U) << 8)) + (((1U << 4) - 1U) << 16)) + (((1U << 4) - 1U) << 24))}}};
#line 3200 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
void png_combine_row(png_const_structrp png_ptr , png_bytep dp , int display )
{
  unsigned int pixel_depth ;
  png_const_bytep sp ;
  png_alloc_size_t row_width ;
  unsigned int pass ;
  png_bytep end_ptr ;
  png_byte end_byte ;
  unsigned int end_mask ;
  size_t tmp ;
  size_t tmp___0 ;
  png_uint_32 pixels_per_byte ;
  png_uint_32 mask ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  png_uint_32 m ;
  unsigned int bytes_to_copy ;
  unsigned int bytes_to_jump ;
  unsigned int offset ;
  png_uint_32p dp32 ;
  png_const_uint_32p sp32 ;
  size_t skip ;
  size_t c ;
  png_uint_32p tmp___9 ;
  png_const_uint_32p tmp___10 ;
  png_bytep tmp___11 ;
  png_const_bytep tmp___12 ;
  png_uint_16p dp16 ;
  png_const_uint_16p sp16 ;
  size_t skip___0 ;
  size_t c___0 ;
  png_uint_16p tmp___13 ;
  png_const_uint_16p tmp___14 ;
  png_bytep tmp___15 ;
  png_const_bytep tmp___16 ;
  size_t tmp___17 ;

  {
#line 3203
  pixel_depth = (unsigned int )png_ptr->transformed_pixel_depth;
#line 3204
  sp = (png_const_bytep )(png_ptr->row_buf + 1);
#line 3205
  row_width = (png_alloc_size_t )png_ptr->width;
#line 3206
  pass = (unsigned int )png_ptr->pass;
#line 3207
  end_ptr = (png_bytep )0;
#line 3208
  end_byte = (png_byte )0;
#line 3216
  if (pixel_depth == 0U) {
#line 3217
    png_error(png_ptr, (png_const_charp )"internal row logic error");
  }
#line 3223
  if (png_ptr->info_rowbytes != 0UL) {
#line 3223
    if (pixel_depth >= 8U) {
#line 3223
      tmp = row_width * ((size_t )pixel_depth >> 3);
    } else {
#line 3223
      tmp = (row_width * (size_t )pixel_depth + 7UL) >> 3;
    }
#line 3223
    if (png_ptr->info_rowbytes != (size_t )tmp) {
#line 3225
      png_error(png_ptr, (png_const_charp )"internal row size calculation error");
    }
  }
#line 3228
  if (row_width == 0UL) {
#line 3229
    png_error(png_ptr, (png_const_charp )"internal row width error");
  }
#line 3235
  end_mask = (unsigned int )((png_alloc_size_t )pixel_depth * row_width & 7UL);
#line 3236
  if (end_mask != 0U) {
#line 3239
    if (pixel_depth >= 8U) {
#line 3239
      tmp___0 = row_width * ((size_t )pixel_depth >> 3);
    } else {
#line 3239
      tmp___0 = (row_width * (size_t )pixel_depth + 7UL) >> 3;
    }
#line 3239
    end_ptr = (dp + tmp___0) - 1;
#line 3240
    end_byte = *end_ptr;
#line 3242
    if ((png_ptr->transformations & 65536U) != 0U) {
#line 3244
      end_mask = (unsigned int )(0xff << end_mask);
    } else {
#line 3248
      end_mask = (unsigned int )(0xff >> end_mask);
    }
  }
#line 3259
  if ((int )png_ptr->interlaced != 0) {
#line 3259
    if ((png_ptr->transformations & 2U) != 0U) {
#line 3259
      if (pass < 6U) {
#line 3259
        if (display == 0) {
#line 3259
          goto _L___3;
        } else
#line 3259
        if (display == 1) {
#line 3259
          if ((pass & 1U) != 0U) {
            _L___3: /* CIL Label */
#line 3268
            if (row_width <= (png_alloc_size_t )(((1U & pass) << (3U - ((pass + 1U) >> 1))) & 7U)) {
#line 3269
              return;
            }
#line 3271
            if (pixel_depth < 8U) {
#line 3402
              pixels_per_byte = 8U / pixel_depth;
#line 3406
              if ((png_ptr->transformations & 65536U) != 0U) {
#line 3407
                if (display) {
#line 3407
                  if (pixel_depth == 1U) {
#line 3407
                    tmp___2 = 0;
                  } else {
#line 3407
                    if (pixel_depth == 2U) {
#line 3407
                      tmp___1 = 1;
                    } else {
#line 3407
                      tmp___1 = 2;
                    }
#line 3407
                    tmp___2 = tmp___1;
                  }
#line 3407
                  mask = (png_uint_32 )display_mask[0][tmp___2][pass >> 1];
                } else {
#line 3407
                  if (pixel_depth == 1U) {
#line 3407
                    tmp___4 = 0;
                  } else {
#line 3407
                    if (pixel_depth == 2U) {
#line 3407
                      tmp___3 = 1;
                    } else {
#line 3407
                      tmp___3 = 2;
                    }
#line 3407
                    tmp___4 = tmp___3;
                  }
#line 3407
                  mask = (png_uint_32 )row_mask[0][tmp___4][pass];
                }
              } else
#line 3411
              if (display) {
#line 3411
                if (pixel_depth == 1U) {
#line 3411
                  tmp___6 = 0;
                } else {
#line 3411
                  if (pixel_depth == 2U) {
#line 3411
                    tmp___5 = 1;
                  } else {
#line 3411
                    tmp___5 = 2;
                  }
#line 3411
                  tmp___6 = tmp___5;
                }
#line 3411
                mask = (png_uint_32 )display_mask[1][tmp___6][pass >> 1];
              } else {
#line 3411
                if (pixel_depth == 1U) {
#line 3411
                  tmp___8 = 0;
                } else {
#line 3411
                  if (pixel_depth == 2U) {
#line 3411
                    tmp___7 = 1;
                  } else {
#line 3411
                    tmp___7 = 2;
                  }
#line 3411
                  tmp___8 = tmp___7;
                }
#line 3411
                mask = (png_uint_32 )row_mask[1][tmp___8][pass];
              }
              {
#line 3413
              while (1) {
                while_continue: /* CIL Label */ ;
#line 3421
                m = mask;
#line 3422
                mask = (m >> 8) | (m << 24);
#line 3423
                m &= 255U;
#line 3425
                if (m != 0U) {
#line 3427
                  if (m != 255U) {
#line 3428
                    *dp = (png_byte )(((unsigned int )*dp & ~ m) | ((unsigned int )*sp & m));
                  } else {
#line 3430
                    *dp = (png_byte )*sp;
                  }
                }
#line 3437
                if (row_width <= (png_alloc_size_t )pixels_per_byte) {
#line 3438
                  goto while_break;
                }
#line 3440
                row_width -= (png_alloc_size_t )pixels_per_byte;
#line 3441
                dp ++;
#line 3442
                sp ++;
              }
              while_break: /* CIL Label */ ;
              }
            } else {
#line 3451
              if (pixel_depth & 7U) {
#line 3452
                png_error(png_ptr, (png_const_charp )"invalid user transform pixel depth");
              }
#line 3454
              pixel_depth >>= 3;
#line 3455
              row_width *= (png_alloc_size_t )pixel_depth;
#line 3462
              offset = (((1U & pass) << (3U - ((pass + 1U) >> 1))) & 7U) * pixel_depth;
#line 3464
              row_width -= (png_alloc_size_t )offset;
#line 3465
              dp += offset;
#line 3466
              sp += offset;
#line 3470
              if (display != 0) {
#line 3476
                bytes_to_copy = (unsigned int )(1 << ((6U - pass) >> 1)) * pixel_depth;
#line 3479
                if ((png_alloc_size_t )bytes_to_copy > row_width) {
#line 3480
                  bytes_to_copy = (unsigned int )row_width;
                }
              } else {
#line 3484
                bytes_to_copy = pixel_depth;
              }
#line 3487
              bytes_to_jump = (unsigned int )(1 << ((7U - pass) >> 1)) * pixel_depth;
              {
#line 3499
              if (bytes_to_copy == 1U) {
#line 3499
                goto case_1;
              }
#line 3512
              if (bytes_to_copy == 2U) {
#line 3512
                goto case_2;
              }
#line 3533
              if (bytes_to_copy == 3U) {
#line 3533
                goto case_3;
              }
#line 3549
              goto switch_default;
              case_1: /* CIL Label */
              {
#line 3500
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 3502
                *dp = (png_byte )*sp;
#line 3504
                if (row_width <= (png_alloc_size_t )bytes_to_jump) {
#line 3505
                  return;
                }
#line 3507
                dp += bytes_to_jump;
#line 3508
                sp += bytes_to_jump;
#line 3509
                row_width -= (png_alloc_size_t )bytes_to_jump;
              }
              while_break___0: /* CIL Label */ ;
              }
              case_2: /* CIL Label */
              {
#line 3516
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 3518
                *(dp + 0) = (png_byte )*(sp + 0);
#line 3518
                *(dp + 1) = (png_byte )*(sp + 1);
#line 3520
                if (row_width <= (png_alloc_size_t )bytes_to_jump) {
#line 3521
                  return;
                }
#line 3523
                sp += bytes_to_jump;
#line 3524
                dp += bytes_to_jump;
#line 3525
                row_width -= (png_alloc_size_t )bytes_to_jump;
#line 3516
                if (! (row_width > 1UL)) {
#line 3516
                  goto while_break___1;
                }
              }
              while_break___1: /* CIL Label */ ;
              }
#line 3530
              *dp = (png_byte )*sp;
#line 3531
              return;
              case_3: /* CIL Label */
              {
#line 3537
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 3539
                *(dp + 0) = (png_byte )*(sp + 0);
#line 3539
                *(dp + 1) = (png_byte )*(sp + 1);
#line 3539
                *(dp + 2) = (png_byte )*(sp + 2);
#line 3541
                if (row_width <= (png_alloc_size_t )bytes_to_jump) {
#line 3542
                  return;
                }
#line 3544
                sp += bytes_to_jump;
#line 3545
                dp += bytes_to_jump;
#line 3546
                row_width -= (png_alloc_size_t )bytes_to_jump;
              }
              while_break___2: /* CIL Label */ ;
              }
              switch_default: /* CIL Label */
#line 3556
              if (bytes_to_copy < 16U) {
#line 3556
                if (((int )((png_uint_16 )((size_t )((void const   *)dp))) & (int )((png_uint_16 )(sizeof(png_uint_16 ) - 1UL))) == 0) {
#line 3556
                  if (((int )((png_uint_16 )((size_t )((void const   *)sp))) & (int )((png_uint_16 )(sizeof(png_uint_16 ) - 1UL))) == 0) {
#line 3556
                    if ((unsigned long )bytes_to_copy % sizeof(png_uint_16 ) == 0UL) {
#line 3556
                      if ((unsigned long )bytes_to_jump % sizeof(png_uint_16 ) == 0UL) {
#line 3565
                        if (((png_uint_32 )((size_t )((void const   *)dp)) & (png_uint_32 )(sizeof(png_uint_32 ) - 1UL)) == 0U) {
#line 3565
                          if (((png_uint_32 )((size_t )((void const   *)sp)) & (png_uint_32 )(sizeof(png_uint_32 ) - 1UL)) == 0U) {
#line 3565
                            if ((unsigned long )bytes_to_copy % sizeof(png_uint_32 ) == 0UL) {
#line 3565
                              if ((unsigned long )bytes_to_jump % sizeof(png_uint_32 ) == 0UL) {
#line 3570
                                dp32 = (png_uint_32p )((void *)dp);
#line 3571
                                sp32 = (png_const_uint_32p )((void const   *)sp);
#line 3573
                                skip = (unsigned long )(bytes_to_jump - bytes_to_copy) / sizeof(png_uint_32 );
                                {
#line 3576
                                while (1) {
                                  while_continue___3: /* CIL Label */ ;
#line 3578
                                  c = (size_t )bytes_to_copy;
                                  {
#line 3579
                                  while (1) {
                                    while_continue___4: /* CIL Label */ ;
#line 3581
                                    tmp___9 = dp32;
#line 3581
                                    dp32 ++;
#line 3581
                                    tmp___10 = sp32;
#line 3581
                                    sp32 ++;
#line 3581
                                    *tmp___9 = (png_uint_32 )*tmp___10;
#line 3582
                                    c -= sizeof(png_uint_32 );
#line 3579
                                    if (! (c > 0UL)) {
#line 3579
                                      goto while_break___4;
                                    }
                                  }
                                  while_break___4: /* CIL Label */ ;
                                  }
#line 3586
                                  if (row_width <= (png_alloc_size_t )bytes_to_jump) {
#line 3587
                                    return;
                                  }
#line 3589
                                  dp32 += skip;
#line 3590
                                  sp32 += skip;
#line 3591
                                  row_width -= (png_alloc_size_t )bytes_to_jump;
#line 3576
                                  if (! ((png_alloc_size_t )bytes_to_copy <= row_width)) {
#line 3576
                                    goto while_break___3;
                                  }
                                }
                                while_break___3: /* CIL Label */ ;
                                }
#line 3599
                                dp = (png_bytep )dp32;
#line 3600
                                sp = (png_const_bytep )sp32;
                                {
#line 3601
                                while (1) {
                                  while_continue___5: /* CIL Label */ ;
#line 3602
                                  tmp___11 = dp;
#line 3602
                                  dp ++;
#line 3602
                                  tmp___12 = sp;
#line 3602
                                  sp ++;
#line 3602
                                  *tmp___11 = (png_byte )*tmp___12;
#line 3601
                                  row_width --;
#line 3601
                                  if (! (row_width > 0UL)) {
#line 3601
                                    goto while_break___5;
                                  }
                                }
                                while_break___5: /* CIL Label */ ;
                                }
#line 3604
                                return;
                              } else {
#line 3565
                                goto _L___1;
                              }
                            } else {
#line 3565
                              goto _L___1;
                            }
                          } else {
#line 3565
                            goto _L___1;
                          }
                        } else {
                          _L___1: /* CIL Label */
                          _L___0: /* CIL Label */
                          _L: /* CIL Label */
#line 3612
                          dp16 = (png_uint_16p )((void *)dp);
#line 3613
                          sp16 = (png_const_uint_16p )((void const   *)sp);
#line 3615
                          skip___0 = (unsigned long )(bytes_to_jump - bytes_to_copy) / sizeof(png_uint_16 );
                          {
#line 3618
                          while (1) {
                            while_continue___6: /* CIL Label */ ;
#line 3620
                            c___0 = (size_t )bytes_to_copy;
                            {
#line 3621
                            while (1) {
                              while_continue___7: /* CIL Label */ ;
#line 3623
                              tmp___13 = dp16;
#line 3623
                              dp16 ++;
#line 3623
                              tmp___14 = sp16;
#line 3623
                              sp16 ++;
#line 3623
                              *tmp___13 = (png_uint_16 )*tmp___14;
#line 3624
                              c___0 -= sizeof(png_uint_16 );
#line 3621
                              if (! (c___0 > 0UL)) {
#line 3621
                                goto while_break___7;
                              }
                            }
                            while_break___7: /* CIL Label */ ;
                            }
#line 3628
                            if (row_width <= (png_alloc_size_t )bytes_to_jump) {
#line 3629
                              return;
                            }
#line 3631
                            dp16 += skip___0;
#line 3632
                            sp16 += skip___0;
#line 3633
                            row_width -= (png_alloc_size_t )bytes_to_jump;
#line 3618
                            if (! ((png_alloc_size_t )bytes_to_copy <= row_width)) {
#line 3618
                              goto while_break___6;
                            }
                          }
                          while_break___6: /* CIL Label */ ;
                          }
#line 3638
                          dp = (png_bytep )dp16;
#line 3639
                          sp = (png_const_bytep )sp16;
                          {
#line 3640
                          while (1) {
                            while_continue___8: /* CIL Label */ ;
#line 3641
                            tmp___15 = dp;
#line 3641
                            dp ++;
#line 3641
                            tmp___16 = sp;
#line 3641
                            sp ++;
#line 3641
                            *tmp___15 = (png_byte )*tmp___16;
#line 3640
                            row_width --;
#line 3640
                            if (! (row_width > 0UL)) {
#line 3640
                              goto while_break___8;
                            }
                          }
                          while_break___8: /* CIL Label */ ;
                          }
#line 3643
                          return;
                        }
                      }
                    }
                  }
                }
              }
              {
#line 3649
              while (1) {
                while_continue___9: /* CIL Label */ ;
#line 3651
                memcpy((void *)dp, (void const   *)sp, (size_t )bytes_to_copy);
#line 3653
                if (row_width <= (png_alloc_size_t )bytes_to_jump) {
#line 3654
                  return;
                }
#line 3656
                sp += bytes_to_jump;
#line 3657
                dp += bytes_to_jump;
#line 3658
                row_width -= (png_alloc_size_t )bytes_to_jump;
#line 3659
                if ((png_alloc_size_t )bytes_to_copy > row_width) {
#line 3660
                  bytes_to_copy = (unsigned int )row_width;
                }
              }
              while_break___9: /* CIL Label */ ;
              }
              switch_break: /* CIL Label */ ;
              }
            }
          } else {
#line 3259
            goto _L___5;
          }
        } else {
#line 3259
          goto _L___5;
        }
      } else {
#line 3259
        goto _L___5;
      }
    } else {
#line 3259
      goto _L___5;
    }
  } else {
    _L___5: /* CIL Label */
    _L___4: /* CIL Label */
    _L___2: /* CIL Label */
#line 3676
    if (pixel_depth >= 8U) {
#line 3676
      tmp___17 = row_width * ((size_t )pixel_depth >> 3);
    } else {
#line 3676
      tmp___17 = (row_width * (size_t )pixel_depth + 7UL) >> 3;
    }
#line 3676
    memcpy((void *)dp, (void const   *)sp, tmp___17);
  }
#line 3679
  if ((unsigned long )end_ptr != (unsigned long )((void *)0)) {
#line 3680
    *end_ptr = (png_byte )(((unsigned int )end_byte & end_mask) | ((unsigned int )*end_ptr & ~ end_mask));
  }
#line 3681
  return;
}
}
#line 3690 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
static unsigned int const   png_pass_inc___0[7]  = {      (unsigned int const   )8,      (unsigned int const   )8,      (unsigned int const   )4,      (unsigned int const   )4,
        (unsigned int const   )2,      (unsigned int const   )2,      (unsigned int const   )1};
#line 3684 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
void png_do_read_interlace(png_row_infop row_info , png_bytep row , int pass , png_uint_32 transformations )
{
  png_uint_32 final_width ;
  png_bytep sp ;
  png_bytep dp ;
  unsigned int sshift ;
  unsigned int dshift ;
  unsigned int s_start ;
  unsigned int s_end ;
  int s_inc ;
  int jstop ;
  png_byte v ;
  png_uint_32 i ;
  int j ;
  unsigned int tmp ;
  png_bytep sp___0 ;
  png_bytep dp___0 ;
  unsigned int sshift___0 ;
  unsigned int dshift___0 ;
  unsigned int s_start___0 ;
  unsigned int s_end___0 ;
  int s_inc___0 ;
  int jstop___0 ;
  png_uint_32 i___0 ;
  png_byte v___0 ;
  int j___0 ;
  unsigned int tmp___0 ;
  png_bytep sp___1 ;
  png_bytep dp___1 ;
  unsigned int sshift___1 ;
  unsigned int dshift___1 ;
  unsigned int s_start___1 ;
  unsigned int s_end___1 ;
  int s_inc___1 ;
  png_uint_32 i___1 ;
  int jstop___1 ;
  png_byte v___1 ;
  int j___1 ;
  unsigned int tmp___1 ;
  size_t pixel_bytes ;
  png_bytep sp___2 ;
  png_bytep dp___2 ;
  int jstop___2 ;
  png_uint_32 i___2 ;
  png_byte v___2[8] ;
  int j___2 ;

  {
#line 3693
  if ((unsigned long )row != (unsigned long )((void *)0)) {
#line 3693
    if ((unsigned long )row_info != (unsigned long )((void *)0)) {
#line 3697
      final_width = row_info->width * (png_uint_32 )png_pass_inc___0[pass];
      {
#line 3701
      if ((int )row_info->pixel_depth == 1) {
#line 3701
        goto case_1;
      }
#line 3764
      if ((int )row_info->pixel_depth == 2) {
#line 3764
        goto case_2;
      }
#line 3828
      if ((int )row_info->pixel_depth == 4) {
#line 3828
        goto case_4;
      }
#line 3891
      goto switch_default;
      case_1: /* CIL Label */
#line 3703
      sp = row + (size_t )((row_info->width - 1U) >> 3);
#line 3704
      dp = row + (size_t )((final_width - 1U) >> 3);
#line 3708
      jstop = (int )png_pass_inc___0[pass];
#line 3714
      if ((transformations & 0x10000U) != 0U) {
#line 3716
        sshift = (row_info->width + 7U) & 7U;
#line 3717
        dshift = (final_width + 7U) & 7U;
#line 3718
        s_start = 7U;
#line 3719
        s_end = 0U;
#line 3720
        s_inc = -1;
      } else {
#line 3726
        sshift = 7U - ((row_info->width + 7U) & 7U);
#line 3727
        dshift = 7U - ((final_width + 7U) & 7U);
#line 3728
        s_start = 0U;
#line 3729
        s_end = 7U;
#line 3730
        s_inc = 1;
      }
#line 3733
      i = (png_uint_32 )0;
      {
#line 3733
      while (1) {
        while_continue: /* CIL Label */ ;
#line 3733
        if (! (i < row_info->width)) {
#line 3733
          goto while_break;
        }
#line 3735
        v = (png_byte )(((int )*sp >> sshift) & 0x01);
#line 3736
        j = 0;
        {
#line 3736
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 3736
          if (! (j < jstop)) {
#line 3736
            goto while_break___0;
          }
#line 3738
          tmp = (unsigned int )((int )*dp & (0x7f7f >> (7U - dshift)));
#line 3739
          tmp |= (unsigned int )((int )v << dshift);
#line 3740
          *dp = (png_byte )(tmp & 255U);
#line 3742
          if (dshift == s_end) {
#line 3744
            dshift = s_start;
#line 3745
            dp --;
          } else {
#line 3749
            dshift = (unsigned int )((int )dshift + s_inc);
          }
#line 3736
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 3752
        if (sshift == s_end) {
#line 3754
          sshift = s_start;
#line 3755
          sp --;
        } else {
#line 3759
          sshift = (unsigned int )((int )sshift + s_inc);
        }
#line 3733
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 3761
      goto switch_break;
      case_2: /* CIL Label */
#line 3766
      sp___0 = row + ((row_info->width - 1U) >> 2);
#line 3767
      dp___0 = row + ((final_width - 1U) >> 2);
#line 3771
      jstop___0 = (int )png_pass_inc___0[pass];
#line 3775
      if ((transformations & 0x10000U) != 0U) {
#line 3777
        sshift___0 = ((row_info->width + 3U) & 3U) << 1;
#line 3778
        dshift___0 = ((final_width + 3U) & 3U) << 1;
#line 3779
        s_start___0 = 6U;
#line 3780
        s_end___0 = 0U;
#line 3781
        s_inc___0 = -2;
      } else {
#line 3787
        sshift___0 = (3U - ((row_info->width + 3U) & 3U)) << 1;
#line 3788
        dshift___0 = (3U - ((final_width + 3U) & 3U)) << 1;
#line 3789
        s_start___0 = 0U;
#line 3790
        s_end___0 = 6U;
#line 3791
        s_inc___0 = 2;
      }
#line 3794
      i___0 = (png_uint_32 )0;
      {
#line 3794
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3794
        if (! (i___0 < row_info->width)) {
#line 3794
          goto while_break___1;
        }
#line 3799
        v___0 = (png_byte )(((int )*sp___0 >> sshift___0) & 0x03);
#line 3800
        j___0 = 0;
        {
#line 3800
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 3800
          if (! (j___0 < jstop___0)) {
#line 3800
            goto while_break___2;
          }
#line 3802
          tmp___0 = (unsigned int )((int )*dp___0 & (0x3f3f >> (6U - dshift___0)));
#line 3803
          tmp___0 |= (unsigned int )((int )v___0 << dshift___0);
#line 3804
          *dp___0 = (png_byte )(tmp___0 & 255U);
#line 3806
          if (dshift___0 == s_end___0) {
#line 3808
            dshift___0 = s_start___0;
#line 3809
            dp___0 --;
          } else {
#line 3813
            dshift___0 = (unsigned int )((int )dshift___0 + s_inc___0);
          }
#line 3800
          j___0 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 3816
        if (sshift___0 == s_end___0) {
#line 3818
          sshift___0 = s_start___0;
#line 3819
          sp___0 --;
        } else {
#line 3823
          sshift___0 = (unsigned int )((int )sshift___0 + s_inc___0);
        }
#line 3794
        i___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3825
      goto switch_break;
      case_4: /* CIL Label */
#line 3830
      sp___1 = row + (size_t )((row_info->width - 1U) >> 1);
#line 3831
      dp___1 = row + (size_t )((final_width - 1U) >> 1);
#line 3836
      jstop___1 = (int )png_pass_inc___0[pass];
#line 3839
      if ((transformations & 0x10000U) != 0U) {
#line 3841
        sshift___1 = ((row_info->width + 1U) & 1U) << 2;
#line 3842
        dshift___1 = ((final_width + 1U) & 1U) << 2;
#line 3843
        s_start___1 = 4U;
#line 3844
        s_end___1 = 0U;
#line 3845
        s_inc___1 = -4;
      } else {
#line 3851
        sshift___1 = (1U - ((row_info->width + 1U) & 1U)) << 2;
#line 3852
        dshift___1 = (1U - ((final_width + 1U) & 1U)) << 2;
#line 3853
        s_start___1 = 0U;
#line 3854
        s_end___1 = 4U;
#line 3855
        s_inc___1 = 4;
      }
#line 3858
      i___1 = (png_uint_32 )0;
      {
#line 3858
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 3858
        if (! (i___1 < row_info->width)) {
#line 3858
          goto while_break___3;
        }
#line 3860
        v___1 = (png_byte )(((int )*sp___1 >> sshift___1) & 0x0f);
#line 3863
        j___1 = 0;
        {
#line 3863
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 3863
          if (! (j___1 < jstop___1)) {
#line 3863
            goto while_break___4;
          }
#line 3865
          tmp___1 = (unsigned int )((int )*dp___1 & (0xf0f >> (4U - dshift___1)));
#line 3866
          tmp___1 |= (unsigned int )((int )v___1 << dshift___1);
#line 3867
          *dp___1 = (png_byte )(tmp___1 & 255U);
#line 3869
          if (dshift___1 == s_end___1) {
#line 3871
            dshift___1 = s_start___1;
#line 3872
            dp___1 --;
          } else {
#line 3876
            dshift___1 = (unsigned int )((int )dshift___1 + s_inc___1);
          }
#line 3863
          j___1 ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 3879
        if (sshift___1 == s_end___1) {
#line 3881
          sshift___1 = s_start___1;
#line 3882
          sp___1 --;
        } else {
#line 3886
          sshift___1 = (unsigned int )((int )sshift___1 + s_inc___1);
        }
#line 3858
        i___1 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 3888
      goto switch_break;
      switch_default: /* CIL Label */
#line 3893
      pixel_bytes = (size_t )((int )row_info->pixel_depth >> 3);
#line 3895
      sp___2 = row + (size_t )(row_info->width - 1U) * pixel_bytes;
#line 3898
      dp___2 = row + (size_t )(final_width - 1U) * pixel_bytes;
#line 3900
      jstop___2 = (int )png_pass_inc___0[pass];
#line 3903
      i___2 = (png_uint_32 )0;
      {
#line 3903
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 3903
        if (! (i___2 < row_info->width)) {
#line 3903
          goto while_break___5;
        }
#line 3908
        memcpy((void *)(v___2), (void const   *)sp___2, pixel_bytes);
#line 3910
        j___2 = 0;
        {
#line 3910
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 3910
          if (! (j___2 < jstop___2)) {
#line 3910
            goto while_break___6;
          }
#line 3912
          memcpy((void *)dp___2, (void const   *)(v___2), pixel_bytes);
#line 3913
          dp___2 -= pixel_bytes;
#line 3910
          j___2 ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 3916
        sp___2 -= pixel_bytes;
#line 3903
        i___2 ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 3918
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 3922
      row_info->width = final_width;
#line 3923
      if ((int )row_info->pixel_depth >= 8) {
#line 3923
        row_info->rowbytes = (size_t )final_width * ((size_t )row_info->pixel_depth >> 3);
      } else {
#line 3923
        row_info->rowbytes = ((size_t )final_width * (size_t )row_info->pixel_depth + 7UL) >> 3;
      }
    }
  }
#line 3928
  return;
}
}
#line 3931 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
static void png_read_filter_row_sub(png_row_infop row_info , png_bytep row , png_const_bytep prev_row )
{
  size_t i ;
  size_t istop ;
  unsigned int bpp ;
  png_bytep rp ;

  {
#line 3936
  istop = row_info->rowbytes;
#line 3937
  bpp = (unsigned int )(((int )row_info->pixel_depth + 7) >> 3);
#line 3938
  rp = row + bpp;
#line 3942
  i = (size_t )bpp;
  {
#line 3942
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3942
    if (! (i < istop)) {
#line 3942
      goto while_break;
    }
#line 3944
    *rp = (png_byte )(((int )*rp + (int )*(rp - bpp)) & 0xff);
#line 3945
    rp ++;
#line 3942
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3947
  return;
}
}
#line 3949 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
static void png_read_filter_row_up(png_row_infop row_info , png_bytep row , png_const_bytep prev_row )
{
  size_t i ;
  size_t istop ;
  png_bytep rp ;
  png_const_bytep pp ;
  png_const_bytep tmp ;

  {
#line 3954
  istop = row_info->rowbytes;
#line 3955
  rp = row;
#line 3956
  pp = prev_row;
#line 3958
  i = (size_t )0;
  {
#line 3958
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3958
    if (! (i < istop)) {
#line 3958
      goto while_break;
    }
#line 3960
    tmp = pp;
#line 3960
    pp ++;
#line 3960
    *rp = (png_byte )(((int )*rp + (int )*tmp) & 0xff);
#line 3961
    rp ++;
#line 3958
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3963
  return;
}
}
#line 3965 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
static void png_read_filter_row_avg(png_row_infop row_info , png_bytep row , png_const_bytep prev_row )
{
  size_t i ;
  png_bytep rp ;
  png_const_bytep pp ;
  unsigned int bpp ;
  size_t istop ;
  png_const_bytep tmp ;
  png_const_bytep tmp___0 ;

  {
#line 3970
  rp = row;
#line 3971
  pp = prev_row;
#line 3972
  bpp = (unsigned int )(((int )row_info->pixel_depth + 7) >> 3);
#line 3973
  istop = row_info->rowbytes - (size_t )bpp;
#line 3975
  i = (size_t )0;
  {
#line 3975
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3975
    if (! (i < (size_t )bpp)) {
#line 3975
      goto while_break;
    }
#line 3977
    tmp = pp;
#line 3977
    pp ++;
#line 3977
    *rp = (png_byte )(((int )*rp + (int )*tmp / 2) & 0xff);
#line 3980
    rp ++;
#line 3975
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3983
  i = (size_t )0;
  {
#line 3983
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3983
    if (! (i < istop)) {
#line 3983
      goto while_break___0;
    }
#line 3985
    tmp___0 = pp;
#line 3985
    pp ++;
#line 3985
    *rp = (png_byte )(((int )*rp + (int )((int const   )*tmp___0 + (int const   )*(rp - bpp)) / 2) & 0xff);
#line 3988
    rp ++;
#line 3983
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3990
  return;
}
}
#line 3992 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
static void png_read_filter_row_paeth_1byte_pixel(png_row_infop row_info , png_bytep row ,
                                                  png_const_bytep prev_row )
{
  png_bytep rp_end ;
  int a ;
  int c ;
  png_const_bytep tmp ;
  png_bytep tmp___0 ;
  int b ;
  int pa ;
  int pb ;
  int pc ;
  int p ;
  png_const_bytep tmp___1 ;
  png_bytep tmp___2 ;

  {
#line 3996
  rp_end = row + row_info->rowbytes;
#line 4000
  tmp = prev_row;
#line 4000
  prev_row ++;
#line 4000
  c = (int )*tmp;
#line 4001
  a = (int )*row + c;
#line 4002
  tmp___0 = row;
#line 4002
  row ++;
#line 4002
  *tmp___0 = (png_byte )a;
  {
#line 4005
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4005
    if (! ((unsigned long )row < (unsigned long )rp_end)) {
#line 4005
      goto while_break;
    }
#line 4009
    a &= 0xff;
#line 4010
    tmp___1 = prev_row;
#line 4010
    prev_row ++;
#line 4010
    b = (int )*tmp___1;
#line 4012
    p = b - c;
#line 4013
    pc = a - c;
#line 4020
    if (p < 0) {
#line 4020
      pa = - p;
    } else {
#line 4020
      pa = p;
    }
#line 4021
    if (pc < 0) {
#line 4021
      pb = - pc;
    } else {
#line 4021
      pb = pc;
    }
#line 4022
    if (p + pc < 0) {
#line 4022
      pc = - (p + pc);
    } else {
#line 4022
      pc = p + pc;
    }
#line 4028
    if (pb < pa) {
#line 4030
      pa = pb;
#line 4030
      a = b;
    }
#line 4032
    if (pc < pa) {
#line 4032
      a = c;
    }
#line 4037
    c = b;
#line 4038
    a += (int )*row;
#line 4039
    tmp___2 = row;
#line 4039
    row ++;
#line 4039
    *tmp___2 = (png_byte )a;
  }
  while_break: /* CIL Label */ ;
  }
#line 4041
  return;
}
}
#line 4043 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
static void png_read_filter_row_paeth_multibyte_pixel(png_row_infop row_info , png_bytep row ,
                                                      png_const_bytep prev_row )
{
  unsigned int bpp ;
  png_bytep rp_end ;
  int a ;
  png_const_bytep tmp ;
  png_bytep tmp___0 ;
  int a___0 ;
  int b ;
  int c ;
  int pa ;
  int pb ;
  int pc ;
  int p ;
  png_const_bytep tmp___1 ;
  png_bytep tmp___2 ;

  {
#line 4047
  bpp = (unsigned int )(((int )row_info->pixel_depth + 7) >> 3);
#line 4048
  rp_end = row + bpp;
  {
#line 4053
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4053
    if (! ((unsigned long )row < (unsigned long )rp_end)) {
#line 4053
      goto while_break;
    }
#line 4055
    tmp = prev_row;
#line 4055
    prev_row ++;
#line 4055
    a = (int )*row + (int )*tmp;
#line 4056
    tmp___0 = row;
#line 4056
    row ++;
#line 4056
    *tmp___0 = (png_byte )a;
  }
  while_break: /* CIL Label */ ;
  }
#line 4060
  rp_end += row_info->rowbytes - (size_t )bpp;
  {
#line 4062
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4062
    if (! ((unsigned long )row < (unsigned long )rp_end)) {
#line 4062
      goto while_break___0;
    }
#line 4066
    c = (int )*(prev_row - bpp);
#line 4067
    a___0 = (int )*(row - bpp);
#line 4068
    tmp___1 = prev_row;
#line 4068
    prev_row ++;
#line 4068
    b = (int )*tmp___1;
#line 4070
    p = b - c;
#line 4071
    pc = a___0 - c;
#line 4078
    if (p < 0) {
#line 4078
      pa = - p;
    } else {
#line 4078
      pa = p;
    }
#line 4079
    if (pc < 0) {
#line 4079
      pb = - pc;
    } else {
#line 4079
      pb = pc;
    }
#line 4080
    if (p + pc < 0) {
#line 4080
      pc = - (p + pc);
    } else {
#line 4080
      pc = p + pc;
    }
#line 4083
    if (pb < pa) {
#line 4085
      pa = pb;
#line 4085
      a___0 = b;
    }
#line 4087
    if (pc < pa) {
#line 4087
      a___0 = c;
    }
#line 4089
    a___0 += (int )*row;
#line 4090
    tmp___2 = row;
#line 4090
    row ++;
#line 4090
    *tmp___2 = (png_byte )a___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4092
  return;
}
}
#line 4094 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
static void png_init_filter_functions(png_structrp pp )
{
  unsigned int bpp ;

  {
#line 4106
  bpp = (unsigned int )(((int )pp->pixel_depth + 7) >> 3);
#line 4108
  pp->read_filter[0] = & png_read_filter_row_sub;
#line 4109
  pp->read_filter[1] = & png_read_filter_row_up;
#line 4110
  pp->read_filter[2] = & png_read_filter_row_avg;
#line 4111
  if (bpp == 1U) {
#line 4112
    pp->read_filter[3] = & png_read_filter_row_paeth_1byte_pixel;
  } else {
#line 4115
    pp->read_filter[3] = & png_read_filter_row_paeth_multibyte_pixel;
  }
#line 4129
  return;
}
}
#line 4131 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
void png_read_filter_row(png_structrp pp , png_row_infop row_info , png_bytep row ,
                         png_const_bytep prev_row , int filter )
{


  {
#line 4139
  if (filter > 0) {
#line 4139
    if (filter < 5) {
#line 4141
      if ((unsigned long )pp->read_filter[0] == (unsigned long )((void *)0)) {
#line 4142
        png_init_filter_functions(pp);
      }
#line 4144
      (*(pp->read_filter[filter - 1]))(row_info, row, prev_row);
    }
  }
#line 4146
  return;
}
}
#line 4149 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
void png_read_IDAT_data(png_structrp png_ptr , png_bytep output , png_alloc_size_t avail_out )
{
  int ret ;
  png_byte tmpbuf[1024] ;
  uInt avail_in ;
  png_bytep buffer___0 ;
  uInt out ;

  {
#line 4154
  png_ptr->zstream.next_out = output;
#line 4155
  png_ptr->zstream.avail_out = (uInt )0;
#line 4157
  if ((unsigned long )output == (unsigned long )((void *)0)) {
#line 4158
    avail_out = (png_alloc_size_t )0;
  }
  {
#line 4160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4165
    if (png_ptr->zstream.avail_in == 0U) {
      {
#line 4170
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 4170
        if (! (png_ptr->idat_size == 0U)) {
#line 4170
          goto while_break___0;
        }
#line 4172
        png_crc_finish(png_ptr, (png_uint_32 )0);
#line 4174
        png_ptr->idat_size = png_read_chunk_header(png_ptr);
#line 4178
        if (png_ptr->chunk_name != ((((73U << 24) | (68U << 16)) | (65U << 8)) | 84U)) {
#line 4179
          png_error((png_const_structrp )png_ptr, (png_const_charp )"Not enough image data");
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 4182
      avail_in = png_ptr->IDAT_read_size;
#line 4184
      if (avail_in > png_ptr->idat_size) {
#line 4185
        avail_in = png_ptr->idat_size;
      }
#line 4192
      buffer___0 = png_read_buffer(png_ptr, (png_alloc_size_t )avail_in, 0);
#line 4194
      png_crc_read(png_ptr, buffer___0, avail_in);
#line 4195
      png_ptr->idat_size -= avail_in;
#line 4197
      png_ptr->zstream.next_in = (Bytef const   *)buffer___0;
#line 4198
      png_ptr->zstream.avail_in = avail_in;
    }
#line 4202
    if ((unsigned long )output != (unsigned long )((void *)0)) {
#line 4204
      out = (uInt )-1;
#line 4206
      if ((png_alloc_size_t )out > avail_out) {
#line 4207
        out = (uInt )avail_out;
      }
#line 4209
      avail_out -= (png_alloc_size_t )out;
#line 4210
      png_ptr->zstream.avail_out = out;
    } else {
#line 4215
      png_ptr->zstream.next_out = tmpbuf;
#line 4216
      png_ptr->zstream.avail_out = (uInt )sizeof(tmpbuf);
    }
#line 4226
    ret = png_zlib_inflate(png_ptr, 0);
#line 4229
    if ((unsigned long )output != (unsigned long )((void *)0)) {
#line 4230
      avail_out += (png_alloc_size_t )png_ptr->zstream.avail_out;
    } else {
#line 4233
      avail_out += sizeof(tmpbuf) - (unsigned long )png_ptr->zstream.avail_out;
    }
#line 4235
    png_ptr->zstream.avail_out = (uInt )0;
#line 4237
    if (ret == 1) {
#line 4240
      png_ptr->zstream.next_out = (Bytef *)((void *)0);
#line 4242
      png_ptr->mode |= 8U;
#line 4243
      png_ptr->flags |= 0x0008U;
#line 4245
      if (png_ptr->zstream.avail_in > 0U) {
#line 4246
        png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"Extra compressed data");
      } else
#line 4245
      if (png_ptr->idat_size > 0U) {
#line 4246
        png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"Extra compressed data");
      }
#line 4247
      goto while_break;
    }
#line 4250
    if (ret != 0) {
#line 4252
      png_zstream_error(png_ptr, ret);
#line 4254
      if ((unsigned long )output != (unsigned long )((void *)0)) {
#line 4255
        png_chunk_error((png_const_structrp )png_ptr, png_ptr->zstream.msg);
      } else {
#line 4259
        png_chunk_benign_error((png_const_structrp )png_ptr, png_ptr->zstream.msg);
#line 4260
        return;
      }
    }
#line 4160
    if (! (avail_out > 0UL)) {
#line 4160
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4265
  if (avail_out > 0UL) {
#line 4270
    if ((unsigned long )output != (unsigned long )((void *)0)) {
#line 4271
      png_error((png_const_structrp )png_ptr, (png_const_charp )"Not enough image data");
    } else {
#line 4274
      png_chunk_benign_error((png_const_structrp )png_ptr, (png_const_charp )"Too much image data");
    }
  }
#line 4276
  return;
}
}
#line 4278 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
void png_read_finish_IDAT(png_structrp png_ptr )
{


  {
#line 4286
  if ((png_ptr->flags & 0x0008U) == 0U) {
#line 4292
    png_read_IDAT_data(png_ptr, (png_bytep )((void *)0), (png_alloc_size_t )0);
#line 4293
    png_ptr->zstream.next_out = (Bytef *)((void *)0);
#line 4298
    if ((png_ptr->flags & 0x0008U) == 0U) {
#line 4300
      png_ptr->mode |= 8U;
#line 4301
      png_ptr->flags |= 0x0008U;
    }
  }
#line 4308
  if (png_ptr->zowner == ((((73U << 24) | (68U << 16)) | (65U << 8)) | 84U)) {
#line 4311
    png_ptr->zstream.next_in = (Bytef const   *)((void *)0);
#line 4312
    png_ptr->zstream.avail_in = (uInt )0;
#line 4315
    png_ptr->zowner = (png_uint_32 )0;
#line 4322
    png_crc_finish(png_ptr, png_ptr->idat_size);
  }
#line 4324
  return;
}
}
#line 4332 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
static png_byte const   png_pass_start___0[7]  = {      (png_byte const   )0,      (png_byte const   )4,      (png_byte const   )0,      (png_byte const   )2,
        (png_byte const   )0,      (png_byte const   )1,      (png_byte const   )0};
#line 4335 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
static png_byte const   png_pass_inc___1[7]  = {      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )4,      (png_byte const   )4,
        (png_byte const   )2,      (png_byte const   )2,      (png_byte const   )1};
#line 4338 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
static png_byte const   png_pass_ystart___0[7]  = {      (png_byte const   )0,      (png_byte const   )0,      (png_byte const   )4,      (png_byte const   )0,
        (png_byte const   )2,      (png_byte const   )0,      (png_byte const   )1};
#line 4341 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
static png_byte const   png_pass_yinc___0[7]  = {      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )4,
        (png_byte const   )4,      (png_byte const   )2,      (png_byte const   )2};
#line 4326 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
void png_read_finish_row(png_structrp png_ptr )
{


  {
#line 4344
  (png_ptr->row_number) ++;
#line 4345
  if (png_ptr->row_number < png_ptr->num_rows) {
#line 4346
    return;
  }
#line 4348
  if ((int )png_ptr->interlaced != 0) {
#line 4350
    png_ptr->row_number = (png_uint_32 )0;
#line 4355
    memset((void *)png_ptr->prev_row, 0, png_ptr->rowbytes + 1UL);
    {
#line 4357
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4359
      png_ptr->pass = (png_byte )((int )png_ptr->pass + 1);
#line 4361
      if ((int )png_ptr->pass >= 7) {
#line 4362
        goto while_break;
      }
#line 4364
      png_ptr->iwidth = (((png_ptr->width + (png_uint_32 )png_pass_inc___1[png_ptr->pass]) - 1U) - (png_uint_32 )png_pass_start___0[png_ptr->pass]) / (png_uint_32 )png_pass_inc___1[png_ptr->pass];
#line 4369
      if ((png_ptr->transformations & 0x0002U) == 0U) {
#line 4371
        png_ptr->num_rows = (((png_ptr->height + (png_uint_32 )png_pass_yinc___0[png_ptr->pass]) - 1U) - (png_uint_32 )png_pass_ystart___0[png_ptr->pass]) / (png_uint_32 )png_pass_yinc___0[png_ptr->pass];
      } else {
#line 4378
        goto while_break;
      }
#line 4357
      if (! (png_ptr->num_rows == 0U)) {
#line 4357
        if (! (png_ptr->iwidth == 0U)) {
#line 4357
          goto while_break;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 4382
    if ((int )png_ptr->pass < 7) {
#line 4383
      return;
    }
  }
#line 4387
  png_read_finish_IDAT(png_ptr);
#line 4388
  return;
}
}
#line 4397 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
static png_byte const   png_pass_start___1[7]  = {      (png_byte const   )0,      (png_byte const   )4,      (png_byte const   )0,      (png_byte const   )2,
        (png_byte const   )0,      (png_byte const   )1,      (png_byte const   )0};
#line 4400 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
static png_byte const   png_pass_inc___2[7]  = {      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )4,      (png_byte const   )4,
        (png_byte const   )2,      (png_byte const   )2,      (png_byte const   )1};
#line 4403 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
static png_byte const   png_pass_ystart___1[7]  = {      (png_byte const   )0,      (png_byte const   )0,      (png_byte const   )4,      (png_byte const   )0,
        (png_byte const   )2,      (png_byte const   )0,      (png_byte const   )1};
#line 4406 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
static png_byte const   png_pass_yinc___1[7]  = {      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )4,
        (png_byte const   )4,      (png_byte const   )2,      (png_byte const   )2};
#line 4391 "/home/goblint2/bench/libpng-1.6.39/pngrutil.c"
void png_read_start_row(png_structrp png_ptr )
{
  unsigned int max_pixel_depth ;
  size_t row_bytes ;
  unsigned int user_pixel_depth ;
  size_t tmp ;
  png_voidp __attribute__((__malloc__))  tmp___0 ;
  png_voidp __attribute__((__malloc__))  tmp___1 ;
  png_voidp __attribute__((__malloc__))  tmp___2 ;
  png_bytep temp ;
  size_t extra ;
  png_bytep buffer___0 ;
  int tmp___3 ;

  {
#line 4414
  png_init_read_transformations(png_ptr);
#line 4416
  if ((int )png_ptr->interlaced != 0) {
#line 4418
    if ((png_ptr->transformations & 0x0002U) == 0U) {
#line 4419
      png_ptr->num_rows = (((png_ptr->height + (png_uint_32 )png_pass_yinc___1[0]) - 1U) - (png_uint_32 )png_pass_ystart___1[0]) / (png_uint_32 )png_pass_yinc___1[0];
    } else {
#line 4423
      png_ptr->num_rows = png_ptr->height;
    }
#line 4425
    png_ptr->iwidth = (((png_ptr->width + (png_uint_32 )png_pass_inc___2[png_ptr->pass]) - 1U) - (png_uint_32 )png_pass_start___1[png_ptr->pass]) / (png_uint_32 )png_pass_inc___2[png_ptr->pass];
  } else {
#line 4433
    png_ptr->num_rows = png_ptr->height;
#line 4434
    png_ptr->iwidth = png_ptr->width;
  }
#line 4437
  max_pixel_depth = (unsigned int )png_ptr->pixel_depth;
#line 4450
  if ((png_ptr->transformations & 0x0004U) != 0U) {
#line 4450
    if ((int )png_ptr->bit_depth < 8) {
#line 4451
      max_pixel_depth = 8U;
    }
  }
#line 4455
  if ((png_ptr->transformations & 0x1000U) != 0U) {
#line 4457
    if ((int )png_ptr->color_type == 3) {
#line 4459
      if ((int )png_ptr->num_trans != 0) {
#line 4460
        max_pixel_depth = 32U;
      } else {
#line 4463
        max_pixel_depth = 24U;
      }
    } else
#line 4466
    if ((int )png_ptr->color_type == 0) {
#line 4468
      if (max_pixel_depth < 8U) {
#line 4469
        max_pixel_depth = 8U;
      }
#line 4471
      if ((int )png_ptr->num_trans != 0) {
#line 4472
        max_pixel_depth *= 2U;
      }
    } else
#line 4475
    if ((int )png_ptr->color_type == 2) {
#line 4477
      if ((int )png_ptr->num_trans != 0) {
#line 4479
        max_pixel_depth *= 4U;
#line 4480
        max_pixel_depth /= 3U;
      }
    }
  }
#line 4487
  if ((png_ptr->transformations & 0x0200U) != 0U) {
#line 4493
    if ((png_ptr->transformations & 0x1000U) != 0U) {
#line 4495
      if ((int )png_ptr->bit_depth < 16) {
#line 4496
        max_pixel_depth *= 2U;
      }
    } else {
#line 4500
      png_ptr->transformations &= 4294966783U;
    }
  }
#line 4505
  if ((png_ptr->transformations & 0x8000U) != 0U) {
#line 4507
    if ((int )png_ptr->color_type == 0) {
#line 4509
      if (max_pixel_depth <= 8U) {
#line 4510
        max_pixel_depth = 16U;
      } else {
#line 4513
        max_pixel_depth = 32U;
      }
    } else
#line 4516
    if ((int )png_ptr->color_type == 2) {
#line 4516
      goto _L;
    } else
#line 4516
    if ((int )png_ptr->color_type == 3) {
      _L: /* CIL Label */
#line 4519
      if (max_pixel_depth <= 32U) {
#line 4520
        max_pixel_depth = 32U;
      } else {
#line 4523
        max_pixel_depth = 64U;
      }
    }
  }
#line 4529
  if ((png_ptr->transformations & 0x4000U) != 0U) {
#line 4531
    if ((int )png_ptr->num_trans != 0) {
#line 4531
      if ((png_ptr->transformations & 0x1000U) != 0U) {
#line 4531
        goto _L___0;
      } else {
#line 4531
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */
#line 4531
    if ((png_ptr->transformations & 0x8000U) != 0U) {
#line 4531
      goto _L___0;
    } else
#line 4531
    if ((int )png_ptr->color_type == 4) {
      _L___0: /* CIL Label */
#line 4541
      if (max_pixel_depth <= 16U) {
#line 4542
        max_pixel_depth = 32U;
      } else {
#line 4545
        max_pixel_depth = 64U;
      }
    } else
#line 4550
    if (max_pixel_depth <= 8U) {
#line 4552
      if ((int )png_ptr->color_type == 6) {
#line 4553
        max_pixel_depth = 32U;
      } else {
#line 4556
        max_pixel_depth = 24U;
      }
    } else
#line 4559
    if ((int )png_ptr->color_type == 6) {
#line 4560
      max_pixel_depth = 64U;
    } else {
#line 4563
      max_pixel_depth = 48U;
    }
  }
#line 4570
  if ((png_ptr->transformations & 0x100000U) != 0U) {
#line 4572
    user_pixel_depth = (unsigned int )((int )png_ptr->user_transform_depth * (int )png_ptr->user_transform_channels);
#line 4575
    if (user_pixel_depth > max_pixel_depth) {
#line 4576
      max_pixel_depth = user_pixel_depth;
    }
  }
#line 4583
  png_ptr->maximum_pixel_depth = (png_byte )max_pixel_depth;
#line 4584
  png_ptr->transformed_pixel_depth = (png_byte )0;
#line 4589
  row_bytes = (size_t )((png_ptr->width + 7U) & 4294967288U);
#line 4593
  if (max_pixel_depth >= 8U) {
#line 4593
    tmp = row_bytes * ((size_t )max_pixel_depth >> 3);
  } else {
#line 4593
    tmp = (row_bytes * (size_t )max_pixel_depth + 7UL) >> 3;
  }
#line 4593
  row_bytes = (tmp + 1UL) + (size_t )((max_pixel_depth + 7U) >> 3U);
#line 4601
  if (row_bytes + 48UL > png_ptr->old_big_row_buf_size) {
#line 4603
    png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->big_row_buf);
#line 4604
    png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->big_prev_row);
#line 4606
    if ((int )png_ptr->interlaced != 0) {
#line 4607
      tmp___0 = png_calloc((png_const_structrp )png_ptr, row_bytes + 48UL);
#line 4607
      png_ptr->big_row_buf = (png_bytep )tmp___0;
    } else {
#line 4611
      tmp___1 = png_malloc((png_const_structrp )png_ptr, row_bytes + 48UL);
#line 4611
      png_ptr->big_row_buf = (png_bytep )tmp___1;
    }
#line 4613
    tmp___2 = png_malloc((png_const_structrp )png_ptr, row_bytes + 48UL);
#line 4613
    png_ptr->big_prev_row = (png_bytep )tmp___2;
#line 4624
    temp = png_ptr->big_row_buf + 32;
#line 4625
    extra = (size_t )temp & 15UL;
#line 4626
    png_ptr->row_buf = (temp - extra) - 1;
#line 4628
    temp = png_ptr->big_prev_row + 32;
#line 4629
    extra = (size_t )temp & 15UL;
#line 4630
    png_ptr->prev_row = (temp - extra) - 1;
#line 4637
    png_ptr->old_big_row_buf_size = row_bytes + 48UL;
  }
#line 4645
  if (png_ptr->rowbytes > 18446744073709551614UL) {
#line 4646
    png_error((png_const_structrp )png_ptr, (png_const_charp )"Row has too many bytes to allocate in memory");
  }
#line 4648
  memset((void *)png_ptr->prev_row, 0, png_ptr->rowbytes + 1UL);
#line 4662
  if ((unsigned long )png_ptr->read_buffer != (unsigned long )((void *)0)) {
#line 4664
    buffer___0 = png_ptr->read_buffer;
#line 4666
    png_ptr->read_buffer_size = (png_alloc_size_t )0;
#line 4667
    png_ptr->read_buffer = (png_bytep )((void *)0);
#line 4668
    png_free((png_const_structrp )png_ptr, (png_voidp )buffer___0);
  }
#line 4676
  tmp___3 = png_inflate_claim(png_ptr, (((73U << 24) | (68U << 16)) | (65U << 8)) | 84U);
#line 4676
  if (tmp___3 != 0) {
#line 4677
    png_error((png_const_structrp )png_ptr, png_ptr->zstream.msg);
  }
#line 4679
  png_ptr->flags |= 0x0040U;
#line 4680
  return;
}
}
#line 101 "/usr/include/stdlib.h"
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 104
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 107
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 112
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__leaf__, __gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__,
__nothrow__)) ;
#line 820
__inline extern void *( __attribute__((__warn_unused_result__, __nonnull__(1,2,5),
__gnu_inline__)) bsearch)(void const   *__key , void const   *__base , size_t __nmemb ,
                          size_t __size , int (*__compar)(void const   * , void const   * ) ) ;
#line 929
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar )  __attribute__((__nothrow__)) ;
#line 933
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t *__dst , char const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 936
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) wcstombs)(char *__dst , wchar_t const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 43 "/usr/include/string.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memcpy)(void *__dest , void const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 47
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 61
__inline extern void *( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) memset)(void *__dest , int __ch , size_t __len )  __attribute__((__nothrow__)) ;
#line 122
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcpy)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 125
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncpy)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 130
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcat)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 133
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncat)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 326 "/usr/include/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) fprintf)(FILE *__stream ,
                                                                                                  char const   *__fmt
                                                                                                  , ...) ;
#line 332
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) printf)(char const   *__fmt
                                                                                                 , ...) ;
#line 334
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) sprintf)(char *__s ,
                                                                                                            char const   *__fmt
                                                                                                            , ...)  __attribute__((__nothrow__)) ;
#line 341
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vfprintf)(FILE *__stream ,
                                                                                                   char const   *__fmt ,
                                                                                                   __gnuc_va_list __ap ) ;
#line 347
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vprintf)(char const   *__fmt ,
                                                                                                  __gnuc_va_list __ap ) ;
#line 349
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vsprintf)(char *__s ,
                                                                                                             char const   *__fmt ,
                                                                                                             __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 354
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) snprintf)(char *__s , size_t __n , char const   *__fmt
                                              , ...)  __attribute__((__nothrow__)) ;
#line 358
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) vsnprintf)(char *__s , size_t __n , char const   *__fmt ,
                                               __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 492
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
#line 528
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
#line 564
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fgets)(char *__s , int __n , FILE *__stream ) ;
#line 646
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fread)(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 360 "/usr/include/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) read)(int __fd , void *__buf , size_t __nbytes ) ;
#line 511
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size )  __attribute__((__nothrow__)) ;
#line 689
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list )  __attribute__((__nothrow__)) ;
#line 774
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                               size_t __buflen )  __attribute__((__nothrow__)) ;
#line 24 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
void png_set_bKGD(png_const_structrp png_ptr , png_inforp info_ptr , png_const_color_16p background )
{


  {
#line 30
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 31
    return;
  } else
#line 30
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 31
    return;
  } else
#line 30
  if ((unsigned long )background == (unsigned long )((void *)0)) {
#line 31
    return;
  }
#line 33
  info_ptr->background = (png_color_16 )*background;
#line 34
  info_ptr->valid |= 0x0020U;
#line 35
  return;
}
}
#line 39 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
void png_set_cHRM_fixed(png_const_structrp png_ptr , png_inforp info_ptr , png_fixed_point white_x ,
                        png_fixed_point white_y , png_fixed_point red_x , png_fixed_point red_y ,
                        png_fixed_point green_x , png_fixed_point green_y , png_fixed_point blue_x ,
                        png_fixed_point blue_y )
{
  png_xy xy ;
  int tmp ;

  {
#line 49
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 50
    return;
  } else
#line 49
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 50
    return;
  }
#line 52
  xy.redx = red_x;
#line 53
  xy.redy = red_y;
#line 54
  xy.greenx = green_x;
#line 55
  xy.greeny = green_y;
#line 56
  xy.bluex = blue_x;
#line 57
  xy.bluey = blue_y;
#line 58
  xy.whitex = white_x;
#line 59
  xy.whitey = white_y;
#line 61
  tmp = png_colorspace_set_chromaticities(png_ptr, (png_colorspacerp )(& info_ptr->colorspace),
                                          (png_xy const   *)(& xy), 2);
#line 61
  if (tmp != 0) {
#line 63
    info_ptr->colorspace.flags = (png_uint_16 )((int )info_ptr->colorspace.flags | 0x0010);
  }
#line 65
  png_colorspace_sync_info(png_ptr, info_ptr);
#line 66
  return;
}
}
#line 68 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
void png_set_cHRM_XYZ_fixed(png_const_structrp png_ptr , png_inforp info_ptr , png_fixed_point int_red_X ,
                            png_fixed_point int_red_Y , png_fixed_point int_red_Z ,
                            png_fixed_point int_green_X , png_fixed_point int_green_Y ,
                            png_fixed_point int_green_Z , png_fixed_point int_blue_X ,
                            png_fixed_point int_blue_Y , png_fixed_point int_blue_Z )
{
  png_XYZ XYZ ;
  int tmp ;

  {
#line 80
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 81
    return;
  } else
#line 80
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 81
    return;
  }
#line 83
  XYZ.red_X = int_red_X;
#line 84
  XYZ.red_Y = int_red_Y;
#line 85
  XYZ.red_Z = int_red_Z;
#line 86
  XYZ.green_X = int_green_X;
#line 87
  XYZ.green_Y = int_green_Y;
#line 88
  XYZ.green_Z = int_green_Z;
#line 89
  XYZ.blue_X = int_blue_X;
#line 90
  XYZ.blue_Y = int_blue_Y;
#line 91
  XYZ.blue_Z = int_blue_Z;
#line 93
  tmp = png_colorspace_set_endpoints(png_ptr, (png_colorspacerp )(& info_ptr->colorspace),
                                     (png_XYZ const   *)(& XYZ), 2);
#line 93
  if (tmp != 0) {
#line 95
    info_ptr->colorspace.flags = (png_uint_16 )((int )info_ptr->colorspace.flags | 0x0010);
  }
#line 97
  png_colorspace_sync_info(png_ptr, info_ptr);
#line 98
  return;
}
}
#line 101 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
void png_set_cHRM(png_const_structrp png_ptr , png_inforp info_ptr , double white_x ,
                  double white_y , double red_x , double red_y , double green_x ,
                  double green_y , double blue_x , double blue_y )
{
  png_fixed_point tmp ;
  png_fixed_point tmp___0 ;
  png_fixed_point tmp___1 ;
  png_fixed_point tmp___2 ;
  png_fixed_point tmp___3 ;
  png_fixed_point tmp___4 ;
  png_fixed_point tmp___5 ;
  png_fixed_point tmp___6 ;

  {
#line 106
  tmp = png_fixed(png_ptr, blue_y, (png_const_charp )"cHRM Blue Y");
#line 106
  tmp___0 = png_fixed(png_ptr, blue_x, (png_const_charp )"cHRM Blue X");
#line 106
  tmp___1 = png_fixed(png_ptr, green_y, (png_const_charp )"cHRM Green Y");
#line 106
  tmp___2 = png_fixed(png_ptr, green_x, (png_const_charp )"cHRM Green X");
#line 106
  tmp___3 = png_fixed(png_ptr, red_y, (png_const_charp )"cHRM Red Y");
#line 106
  tmp___4 = png_fixed(png_ptr, red_x, (png_const_charp )"cHRM Red X");
#line 106
  tmp___5 = png_fixed(png_ptr, white_y, (png_const_charp )"cHRM White Y");
#line 106
  tmp___6 = png_fixed(png_ptr, white_x, (png_const_charp )"cHRM White X");
#line 106
  png_set_cHRM_fixed(png_ptr, info_ptr, tmp___6, tmp___5, tmp___4, tmp___3, tmp___2,
                     tmp___1, tmp___0, tmp);
#line 115
  return;
}
}
#line 117 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
void png_set_cHRM_XYZ(png_const_structrp png_ptr , png_inforp info_ptr , double red_X ,
                      double red_Y , double red_Z , double green_X , double green_Y ,
                      double green_Z , double blue_X , double blue_Y , double blue_Z )
{
  png_fixed_point tmp ;
  png_fixed_point tmp___0 ;
  png_fixed_point tmp___1 ;
  png_fixed_point tmp___2 ;
  png_fixed_point tmp___3 ;
  png_fixed_point tmp___4 ;
  png_fixed_point tmp___5 ;
  png_fixed_point tmp___6 ;
  png_fixed_point tmp___7 ;

  {
#line 122
  tmp = png_fixed(png_ptr, blue_Z, (png_const_charp )"cHRM Blue Z");
#line 122
  tmp___0 = png_fixed(png_ptr, blue_Y, (png_const_charp )"cHRM Blue Y");
#line 122
  tmp___1 = png_fixed(png_ptr, blue_X, (png_const_charp )"cHRM Blue X");
#line 122
  tmp___2 = png_fixed(png_ptr, green_Z, (png_const_charp )"cHRM Green Z");
#line 122
  tmp___3 = png_fixed(png_ptr, green_Y, (png_const_charp )"cHRM Green Y");
#line 122
  tmp___4 = png_fixed(png_ptr, green_X, (png_const_charp )"cHRM Green X");
#line 122
  tmp___5 = png_fixed(png_ptr, red_Z, (png_const_charp )"cHRM Red Z");
#line 122
  tmp___6 = png_fixed(png_ptr, red_Y, (png_const_charp )"cHRM Red Y");
#line 122
  tmp___7 = png_fixed(png_ptr, red_X, (png_const_charp )"cHRM Red X");
#line 122
  png_set_cHRM_XYZ_fixed(png_ptr, info_ptr, tmp___7, tmp___6, tmp___5, tmp___4, tmp___3,
                         tmp___2, tmp___1, tmp___0, tmp);
#line 132
  return;
}
}
#line 138 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
void png_set_eXIf(png_const_structrp png_ptr , png_inforp info_ptr , png_bytep eXIf_buf )
{


  {
#line 142
  png_warning(png_ptr, (png_const_charp )"png_set_eXIf does not work; use png_set_eXIf_1");
#line 145
  return;
}
}
#line 147 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
void png_set_eXIf_1(png_const_structrp png_ptr , png_inforp info_ptr , png_uint_32 num_exif ,
                    png_bytep eXIf_buf )
{
  int i ;
  png_voidp __attribute__((__malloc__))  tmp ;

  {
#line 155
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 156
    return;
  } else
#line 155
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 156
    return;
  }
#line 158
  if (info_ptr->exif) {
#line 160
    png_free(png_ptr, (png_voidp )info_ptr->exif);
#line 161
    info_ptr->exif = (png_bytep )((void *)0);
  }
#line 164
  info_ptr->num_exif = (int )num_exif;
#line 166
  tmp = png_malloc_warn(png_ptr, (png_alloc_size_t )info_ptr->num_exif);
#line 166
  info_ptr->exif = (png_bytep )tmp;
#line 169
  if ((unsigned long )info_ptr->exif == (unsigned long )((void *)0)) {
#line 171
    png_warning(png_ptr, (png_const_charp )"Insufficient memory for eXIf chunk data");
#line 172
    return;
  }
#line 175
  info_ptr->free_me |= 0x8000U;
#line 177
  i = 0;
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if (! (i < info_ptr->num_exif)) {
#line 177
      goto while_break;
    }
#line 178
    *(info_ptr->exif + i) = *(eXIf_buf + i);
#line 177
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 180
  info_ptr->valid |= 0x10000U;
#line 181
  return;
}
}
#line 185 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
void png_set_gAMA_fixed(png_const_structrp png_ptr , png_inforp info_ptr , png_fixed_point file_gamma )
{


  {
#line 191
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 192
    return;
  } else
#line 191
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 192
    return;
  }
#line 194
  png_colorspace_set_gamma(png_ptr, (png_colorspacerp )(& info_ptr->colorspace), file_gamma);
#line 195
  png_colorspace_sync_info(png_ptr, info_ptr);
#line 196
  return;
}
}
#line 199 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
void png_set_gAMA(png_const_structrp png_ptr , png_inforp info_ptr , double file_gamma )
{
  png_fixed_point tmp ;

  {
#line 202
  tmp = png_fixed(png_ptr, file_gamma, (png_const_charp )"png_set_gAMA");
#line 202
  png_set_gAMA_fixed(png_ptr, info_ptr, tmp);
#line 204
  return;
}
}
#line 209 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
void png_set_hIST(png_const_structrp png_ptr , png_inforp info_ptr , png_const_uint_16p hist )
{
  int i ;
  png_voidp __attribute__((__malloc__))  tmp ;

  {
#line 217
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 218
    return;
  } else
#line 217
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 218
    return;
  }
#line 220
  if ((int )info_ptr->num_palette == 0) {
#line 223
    png_warning(png_ptr, (png_const_charp )"Invalid palette size, hIST allocation skipped");
#line 226
    return;
  } else
#line 220
  if ((int )info_ptr->num_palette > 256) {
#line 223
    png_warning(png_ptr, (png_const_charp )"Invalid palette size, hIST allocation skipped");
#line 226
    return;
  }
#line 229
  png_free_data(png_ptr, info_ptr, 0x0008U, 0);
#line 234
  tmp = png_malloc_warn(png_ptr, 256UL * sizeof(png_uint_16 ));
#line 234
  info_ptr->hist = (png_uint_16p )tmp;
#line 237
  if ((unsigned long )info_ptr->hist == (unsigned long )((void *)0)) {
#line 239
    png_warning(png_ptr, (png_const_charp )"Insufficient memory for hIST chunk data");
#line 241
    return;
  }
#line 244
  info_ptr->free_me |= 0x0008U;
#line 246
  i = 0;
  {
#line 246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 246
    if (! (i < (int )info_ptr->num_palette)) {
#line 246
      goto while_break;
    }
#line 247
    *(info_ptr->hist + i) = (png_uint_16 )*(hist + i);
#line 246
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 249
  info_ptr->valid |= 0x0040U;
#line 250
  return;
}
}
#line 253 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
void png_set_IHDR(png_const_structrp png_ptr , png_inforp info_ptr , png_uint_32 width ,
                  png_uint_32 height , int bit_depth , int color_type , int interlace_type ,
                  int compression_type , int filter_type )
{


  {
#line 261
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 262
    return;
  } else
#line 261
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 262
    return;
  }
#line 264
  info_ptr->width = width;
#line 265
  info_ptr->height = height;
#line 266
  info_ptr->bit_depth = (png_byte )bit_depth;
#line 267
  info_ptr->color_type = (png_byte )color_type;
#line 268
  info_ptr->compression_type = (png_byte )compression_type;
#line 269
  info_ptr->filter_type = (png_byte )filter_type;
#line 270
  info_ptr->interlace_type = (png_byte )interlace_type;
#line 272
  png_check_IHDR(png_ptr, info_ptr->width, info_ptr->height, (int )info_ptr->bit_depth,
                 (int )info_ptr->color_type, (int )info_ptr->interlace_type, (int )info_ptr->compression_type,
                 (int )info_ptr->filter_type);
#line 276
  if ((int )info_ptr->color_type == 3) {
#line 277
    info_ptr->channels = (png_byte )1;
  } else
#line 279
  if (((int )info_ptr->color_type & 2) != 0) {
#line 280
    info_ptr->channels = (png_byte )3;
  } else {
#line 283
    info_ptr->channels = (png_byte )1;
  }
#line 285
  if (((int )info_ptr->color_type & 4) != 0) {
#line 286
    info_ptr->channels = (png_byte )((int )info_ptr->channels + 1);
  }
#line 288
  info_ptr->pixel_depth = (png_byte )((int )info_ptr->channels * (int )info_ptr->bit_depth);
#line 290
  if ((int )info_ptr->pixel_depth >= 8) {
#line 290
    info_ptr->rowbytes = (size_t )width * ((size_t )info_ptr->pixel_depth >> 3);
  } else {
#line 290
    info_ptr->rowbytes = ((size_t )width * (size_t )info_ptr->pixel_depth + 7UL) >> 3;
  }
#line 291
  return;
}
}
#line 294 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
void png_set_oFFs(png_const_structrp png_ptr , png_inforp info_ptr , png_int_32 offset_x ,
                  png_int_32 offset_y , int unit_type )
{


  {
#line 300
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 301
    return;
  } else
#line 300
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 301
    return;
  }
#line 303
  info_ptr->x_offset = offset_x;
#line 304
  info_ptr->y_offset = offset_y;
#line 305
  info_ptr->offset_unit_type = (png_byte )unit_type;
#line 306
  info_ptr->valid |= 0x0100U;
#line 307
  return;
}
}
#line 311 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
void png_set_pCAL(png_const_structrp png_ptr , png_inforp info_ptr , png_const_charp purpose ,
                  png_int_32 X0 , png_int_32 X1 , int type , int nparams , png_const_charp units ,
                  png_charpp params )
{
  size_t length ;
  int i ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  png_voidp __attribute__((__malloc__))  tmp___2 ;
  size_t tmp___3 ;
  png_voidp __attribute__((__malloc__))  tmp___4 ;
  png_voidp __attribute__((__malloc__))  tmp___5 ;
  size_t tmp___6 ;
  png_voidp __attribute__((__malloc__))  tmp___7 ;

  {
#line 321
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 323
    return;
  } else
#line 321
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 323
    return;
  } else
#line 321
  if ((unsigned long )purpose == (unsigned long )((void *)0)) {
#line 323
    return;
  } else
#line 321
  if ((unsigned long )units == (unsigned long )((void *)0)) {
#line 323
    return;
  } else
#line 321
  if (nparams > 0) {
#line 321
    if ((unsigned long )params == (unsigned long )((void *)0)) {
#line 323
      return;
    }
  }
#line 325
  tmp = strlen(purpose);
#line 325
  length = tmp + 1UL;
#line 332
  if (type < 0) {
#line 334
    png_chunk_report(png_ptr, (png_const_charp )"Invalid pCAL equation type", 1);
#line 336
    return;
  } else
#line 332
  if (type > 3) {
#line 334
    png_chunk_report(png_ptr, (png_const_charp )"Invalid pCAL equation type", 1);
#line 336
    return;
  }
#line 339
  if (nparams < 0) {
#line 341
    png_chunk_report(png_ptr, (png_const_charp )"Invalid pCAL parameter count", 1);
#line 343
    return;
  } else
#line 339
  if (nparams > 255) {
#line 341
    png_chunk_report(png_ptr, (png_const_charp )"Invalid pCAL parameter count", 1);
#line 343
    return;
  }
#line 347
  i = 0;
  {
#line 347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 347
    if (! (i < nparams)) {
#line 347
      goto while_break;
    }
#line 349
    if ((unsigned long )*(params + i) == (unsigned long )((void *)0)) {
#line 352
      png_chunk_report(png_ptr, (png_const_charp )"Invalid format for pCAL parameter",
                       1);
#line 354
      return;
    } else {
#line 349
      tmp___0 = strlen((char const   *)*(params + i));
#line 349
      tmp___1 = png_check_fp_string((png_const_charp )*(params + i), tmp___0);
#line 349
      if (! tmp___1) {
#line 352
        png_chunk_report(png_ptr, (png_const_charp )"Invalid format for pCAL parameter",
                         1);
#line 354
        return;
      }
    }
#line 347
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 358
  tmp___2 = png_malloc_warn(png_ptr, length);
#line 358
  info_ptr->pcal_purpose = (png_charp )tmp___2;
#line 361
  if ((unsigned long )info_ptr->pcal_purpose == (unsigned long )((void *)0)) {
#line 363
    png_chunk_report(png_ptr, (png_const_charp )"Insufficient memory for pCAL purpose",
                     1);
#line 365
    return;
  }
#line 368
  memcpy((void *)info_ptr->pcal_purpose, (void const   *)purpose, length);
#line 371
  info_ptr->pcal_X0 = X0;
#line 372
  info_ptr->pcal_X1 = X1;
#line 373
  info_ptr->pcal_type = (png_byte )type;
#line 374
  info_ptr->pcal_nparams = (png_byte )nparams;
#line 376
  tmp___3 = strlen(units);
#line 376
  length = tmp___3 + 1UL;
#line 380
  tmp___4 = png_malloc_warn(png_ptr, length);
#line 380
  info_ptr->pcal_units = (png_charp )tmp___4;
#line 383
  if ((unsigned long )info_ptr->pcal_units == (unsigned long )((void *)0)) {
#line 385
    png_warning(png_ptr, (png_const_charp )"Insufficient memory for pCAL units");
#line 387
    return;
  }
#line 390
  memcpy((void *)info_ptr->pcal_units, (void const   *)units, length);
#line 392
  tmp___5 = png_malloc_warn(png_ptr, (unsigned long )((unsigned int )nparams + 1U) * sizeof(png_charp ));
#line 392
  info_ptr->pcal_params = (png_charpp )tmp___5;
#line 395
  if ((unsigned long )info_ptr->pcal_params == (unsigned long )((void *)0)) {
#line 397
    png_warning(png_ptr, (png_const_charp )"Insufficient memory for pCAL params");
#line 399
    return;
  }
#line 402
  memset((void *)info_ptr->pcal_params, 0, (unsigned long )((unsigned int )nparams + 1U) * sizeof(png_charp ));
#line 405
  i = 0;
  {
#line 405
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 405
    if (! (i < nparams)) {
#line 405
      goto while_break___0;
    }
#line 407
    tmp___6 = strlen((char const   *)*(params + i));
#line 407
    length = tmp___6 + 1UL;
#line 411
    tmp___7 = png_malloc_warn(png_ptr, length);
#line 411
    *(info_ptr->pcal_params + i) = (png_charp )tmp___7;
#line 413
    if ((unsigned long )*(info_ptr->pcal_params + i) == (unsigned long )((void *)0)) {
#line 415
      png_warning(png_ptr, (png_const_charp )"Insufficient memory for pCAL parameter");
#line 417
      return;
    }
#line 420
    memcpy((void *)*(info_ptr->pcal_params + i), (void const   *)*(params + i), length);
#line 405
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 423
  info_ptr->valid |= 0x0400U;
#line 424
  info_ptr->free_me |= 0x0080U;
#line 425
  return;
}
}
#line 429 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
void png_set_sCAL_s(png_const_structrp png_ptr , png_inforp info_ptr , int unit ,
                    png_const_charp swidth , png_const_charp sheight )
{
  size_t lengthw ;
  size_t lengthh ;
  int tmp ;
  int tmp___0 ;
  png_voidp __attribute__((__malloc__))  tmp___1 ;
  png_voidp __attribute__((__malloc__))  tmp___2 ;

  {
#line 433
  lengthw = (size_t )0;
#line 433
  lengthh = (size_t )0;
#line 437
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 438
    return;
  } else
#line 437
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 438
    return;
  }
#line 443
  if (unit != 1) {
#line 443
    if (unit != 2) {
#line 444
      png_error(png_ptr, (png_const_charp )"Invalid sCAL unit");
    }
  }
#line 446
  if ((unsigned long )swidth == (unsigned long )((void *)0)) {
#line 448
    png_error(png_ptr, (png_const_charp )"Invalid sCAL width");
  } else {
#line 446
    lengthw = strlen(swidth);
#line 446
    if (lengthw == 0UL) {
#line 448
      png_error(png_ptr, (png_const_charp )"Invalid sCAL width");
    } else
#line 446
    if ((int const   )*(swidth + 0) == 45) {
#line 448
      png_error(png_ptr, (png_const_charp )"Invalid sCAL width");
    } else {
#line 446
      tmp = png_check_fp_string(swidth, lengthw);
#line 446
      if (! tmp) {
#line 448
        png_error(png_ptr, (png_const_charp )"Invalid sCAL width");
      }
    }
  }
#line 450
  if ((unsigned long )sheight == (unsigned long )((void *)0)) {
#line 452
    png_error(png_ptr, (png_const_charp )"Invalid sCAL height");
  } else {
#line 450
    lengthh = strlen(sheight);
#line 450
    if (lengthh == 0UL) {
#line 452
      png_error(png_ptr, (png_const_charp )"Invalid sCAL height");
    } else
#line 450
    if ((int const   )*(sheight + 0) == 45) {
#line 452
      png_error(png_ptr, (png_const_charp )"Invalid sCAL height");
    } else {
#line 450
      tmp___0 = png_check_fp_string(sheight, lengthh);
#line 450
      if (! tmp___0) {
#line 452
        png_error(png_ptr, (png_const_charp )"Invalid sCAL height");
      }
    }
  }
#line 454
  info_ptr->scal_unit = (png_byte )unit;
#line 456
  lengthw ++;
#line 460
  tmp___1 = png_malloc_warn(png_ptr, lengthw);
#line 460
  info_ptr->scal_s_width = (png_charp )tmp___1;
#line 463
  if ((unsigned long )info_ptr->scal_s_width == (unsigned long )((void *)0)) {
#line 465
    png_warning(png_ptr, (png_const_charp )"Memory allocation failed while processing sCAL");
#line 467
    return;
  }
#line 470
  memcpy((void *)info_ptr->scal_s_width, (void const   *)swidth, lengthw);
#line 472
  lengthh ++;
#line 476
  tmp___2 = png_malloc_warn(png_ptr, lengthh);
#line 476
  info_ptr->scal_s_height = (png_charp )tmp___2;
#line 479
  if ((unsigned long )info_ptr->scal_s_height == (unsigned long )((void *)0)) {
#line 481
    png_free(png_ptr, (png_voidp )info_ptr->scal_s_width);
#line 482
    info_ptr->scal_s_width = (png_charp )((void *)0);
#line 484
    png_warning(png_ptr, (png_const_charp )"Memory allocation failed while processing sCAL");
#line 486
    return;
  }
#line 489
  memcpy((void *)info_ptr->scal_s_height, (void const   *)sheight, lengthh);
#line 491
  info_ptr->valid |= 0x4000U;
#line 492
  info_ptr->free_me |= 0x0100U;
#line 493
  return;
}
}
#line 496 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
void png_set_sCAL(png_const_structrp png_ptr , png_inforp info_ptr , int unit , double width ,
                  double height )
{
  char swidth[18] ;
  char sheight[18] ;

  {
#line 503
  if (width <= (double )0) {
#line 504
    png_warning(png_ptr, (png_const_charp )"Invalid sCAL width ignored");
  } else
#line 506
  if (height <= (double )0) {
#line 507
    png_warning(png_ptr, (png_const_charp )"Invalid sCAL height ignored");
  } else {
#line 515
    png_ascii_from_fp(png_ptr, swidth, sizeof(swidth), width, 5U);
#line 517
    png_ascii_from_fp(png_ptr, sheight, sizeof(sheight), height, 5U);
#line 520
    png_set_sCAL_s(png_ptr, info_ptr, unit, (png_const_charp )(swidth), (png_const_charp )(sheight));
  }
#line 522
  return;
}
}
#line 526 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
void png_set_sCAL_fixed(png_const_structrp png_ptr , png_inforp info_ptr , int unit ,
                        png_fixed_point width , png_fixed_point height )
{
  char swidth[18] ;
  char sheight[18] ;

  {
#line 533
  if (width <= 0) {
#line 534
    png_warning(png_ptr, (png_const_charp )"Invalid sCAL width ignored");
  } else
#line 536
  if (height <= 0) {
#line 537
    png_warning(png_ptr, (png_const_charp )"Invalid sCAL height ignored");
  } else {
#line 545
    png_ascii_from_fixed(png_ptr, swidth, sizeof(swidth), width);
#line 546
    png_ascii_from_fixed(png_ptr, sheight, sizeof(sheight), height);
#line 548
    png_set_sCAL_s(png_ptr, info_ptr, unit, (png_const_charp )(swidth), (png_const_charp )(sheight));
  }
#line 550
  return;
}
}
#line 555 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
void png_set_pHYs(png_const_structrp png_ptr , png_inforp info_ptr , png_uint_32 res_x ,
                  png_uint_32 res_y , int unit_type )
{


  {
#line 561
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 562
    return;
  } else
#line 561
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 562
    return;
  }
#line 564
  info_ptr->x_pixels_per_unit = res_x;
#line 565
  info_ptr->y_pixels_per_unit = res_y;
#line 566
  info_ptr->phys_unit_type = (png_byte )unit_type;
#line 567
  info_ptr->valid |= 0x0080U;
#line 568
  return;
}
}
#line 571 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
void png_set_PLTE(png_structrp png_ptr , png_inforp info_ptr , png_const_colorp palette ,
                  int num_palette )
{
  png_uint_32 max_palette_length ;
  png_voidp __attribute__((__malloc__))  tmp ;
  png_uint_16 tmp___0 ;

  {
#line 580
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 581
    return;
  } else
#line 580
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 581
    return;
  }
#line 583
  if ((int )info_ptr->color_type == 3) {
#line 583
    max_palette_length = (png_uint_32 )(1 << (int )info_ptr->bit_depth);
  } else {
#line 583
    max_palette_length = (png_uint_32 )256;
  }
#line 586
  if (num_palette < 0) {
#line 586
    goto _L;
  } else
#line 586
  if (num_palette > (int )max_palette_length) {
    _L: /* CIL Label */
#line 588
    if ((int )info_ptr->color_type == 3) {
#line 589
      png_error((png_const_structrp )png_ptr, (png_const_charp )"Invalid palette length");
    } else {
#line 593
      png_warning((png_const_structrp )png_ptr, (png_const_charp )"Invalid palette length");
#line 595
      return;
    }
  }
#line 599
  if (num_palette > 0) {
#line 599
    if ((unsigned long )palette == (unsigned long )((void *)0)) {
#line 606
      png_error((png_const_structrp )png_ptr, (png_const_charp )"Invalid palette");
    } else {
#line 599
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */
#line 599
  if (num_palette == 0) {
#line 599
    if ((png_ptr->mng_features_permitted & 1U) == 0U) {
#line 606
      png_error((png_const_structrp )png_ptr, (png_const_charp )"Invalid palette");
    }
  }
#line 616
  png_free_data((png_const_structrp )png_ptr, info_ptr, 0x1000U, 0);
#line 622
  tmp = png_calloc((png_const_structrp )png_ptr, 256UL * sizeof(png_color ));
#line 622
  png_ptr->palette = (png_colorp )tmp;
#line 625
  if (num_palette > 0) {
#line 626
    memcpy((void *)png_ptr->palette, (void const   *)palette, (unsigned long )((unsigned int )num_palette) * sizeof(png_color ));
  }
#line 628
  info_ptr->palette = png_ptr->palette;
#line 629
  tmp___0 = (png_uint_16 )num_palette;
#line 629
  png_ptr->num_palette = tmp___0;
#line 629
  info_ptr->num_palette = tmp___0;
#line 631
  info_ptr->free_me |= 0x1000U;
#line 633
  info_ptr->valid |= 0x0008U;
#line 634
  return;
}
}
#line 637 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
void png_set_sBIT(png_const_structrp png_ptr , png_inforp info_ptr , png_const_color_8p sig_bit )
{


  {
#line 643
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 644
    return;
  } else
#line 643
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 644
    return;
  } else
#line 643
  if ((unsigned long )sig_bit == (unsigned long )((void *)0)) {
#line 644
    return;
  }
#line 646
  info_ptr->sig_bit = (png_color_8 )*sig_bit;
#line 647
  info_ptr->valid |= 0x0002U;
#line 648
  return;
}
}
#line 652 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
void png_set_sRGB(png_const_structrp png_ptr , png_inforp info_ptr , int srgb_intent )
{


  {
#line 657
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 658
    return;
  } else
#line 657
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 658
    return;
  }
#line 660
  png_colorspace_set_sRGB(png_ptr, (png_colorspacerp )(& info_ptr->colorspace), srgb_intent);
#line 661
  png_colorspace_sync_info(png_ptr, info_ptr);
#line 662
  return;
}
}
#line 664 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
void png_set_sRGB_gAMA_and_cHRM(png_const_structrp png_ptr , png_inforp info_ptr ,
                                int srgb_intent )
{
  int tmp ;

  {
#line 670
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 671
    return;
  } else
#line 670
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 671
    return;
  }
#line 673
  tmp = png_colorspace_set_sRGB(png_ptr, (png_colorspacerp )(& info_ptr->colorspace),
                                srgb_intent);
#line 673
  if (tmp != 0) {
#line 677
    info_ptr->colorspace.flags = (png_uint_16 )((int )info_ptr->colorspace.flags | 24);
  }
#line 681
  png_colorspace_sync_info(png_ptr, info_ptr);
#line 682
  return;
}
}
#line 687 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
void png_set_iCCP(png_const_structrp png_ptr , png_inforp info_ptr , png_const_charp name ,
                  int compression_type , png_const_bytep profile , png_uint_32 proflen )
{
  png_charp new_iccp_name ;
  png_bytep new_iccp_profile ;
  size_t length ;
  int result ;
  int tmp ;
  size_t tmp___0 ;
  png_voidp __attribute__((__malloc__))  tmp___1 ;
  png_voidp __attribute__((__malloc__))  tmp___2 ;

  {
#line 698
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 699
    return;
  } else
#line 698
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 699
    return;
  } else
#line 698
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 699
    return;
  } else
#line 698
  if ((unsigned long )profile == (unsigned long )((void *)0)) {
#line 699
    return;
  }
#line 701
  if (compression_type != 0) {
#line 702
    png_app_error(png_ptr, (png_const_charp )"Invalid iCCP compression method");
  }
#line 711
  tmp = png_colorspace_set_ICC(png_ptr, (png_colorspacerp )(& info_ptr->colorspace),
                               name, proflen, profile, (int )info_ptr->color_type);
#line 711
  result = tmp;
#line 714
  png_colorspace_sync_info(png_ptr, info_ptr);
#line 717
  if (result == 0) {
#line 718
    return;
  }
#line 721
  info_ptr->colorspace.flags = (png_uint_16 )((int )info_ptr->colorspace.flags | 24);
#line 725
  tmp___0 = strlen(name);
#line 725
  length = tmp___0 + 1UL;
#line 726
  tmp___1 = png_malloc_warn(png_ptr, length);
#line 726
  new_iccp_name = (png_charp )tmp___1;
#line 728
  if ((unsigned long )new_iccp_name == (unsigned long )((void *)0)) {
#line 730
    png_benign_error(png_ptr, (png_const_charp )"Insufficient memory to process iCCP chunk");
#line 732
    return;
  }
#line 735
  memcpy((void *)new_iccp_name, (void const   *)name, length);
#line 736
  tmp___2 = png_malloc_warn(png_ptr, (png_alloc_size_t )proflen);
#line 736
  new_iccp_profile = (png_bytep )tmp___2;
#line 739
  if ((unsigned long )new_iccp_profile == (unsigned long )((void *)0)) {
#line 741
    png_free(png_ptr, (png_voidp )new_iccp_name);
#line 742
    png_benign_error(png_ptr, (png_const_charp )"Insufficient memory to process iCCP profile");
#line 745
    return;
  }
#line 748
  memcpy((void *)new_iccp_profile, (void const   *)profile, (size_t )proflen);
#line 750
  png_free_data(png_ptr, info_ptr, 0x0010U, 0);
#line 752
  info_ptr->iccp_proflen = proflen;
#line 753
  info_ptr->iccp_name = new_iccp_name;
#line 754
  info_ptr->iccp_profile = new_iccp_profile;
#line 755
  info_ptr->free_me |= 0x0010U;
#line 756
  info_ptr->valid |= 0x1000U;
#line 757
  return;
}
}
#line 761 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
void png_set_text(png_const_structrp png_ptr , png_inforp info_ptr , png_const_textp text_ptr ,
                  int num_text )
{
  int ret ;

  {
#line 766
  ret = png_set_text_2(png_ptr, info_ptr, text_ptr, num_text);
#line 768
  if (ret != 0) {
#line 769
    png_error(png_ptr, (png_const_charp )"Insufficient memory to store text");
  }
#line 770
  return;
}
}
#line 772 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
int png_set_text_2(png_const_structrp png_ptr , png_inforp info_ptr , png_const_textp text_ptr ,
                   int num_text )
{
  int i ;
  int old_num_text ;
  int max_text ;
  png_textp new_text ;
  png_voidp __attribute__((__malloc__))  tmp ;
  size_t text_length ;
  size_t key_len ;
  size_t lang_len ;
  size_t lang_key_len ;
  png_textp textp ;
  png_voidp __attribute__((__malloc__))  tmp___0 ;

  {
#line 781
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 782
    return (0);
  } else
#line 781
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 782
    return (0);
  } else
#line 781
  if (num_text <= 0) {
#line 782
    return (0);
  } else
#line 781
  if ((unsigned long )text_ptr == (unsigned long )((void *)0)) {
#line 782
    return (0);
  }
#line 789
  if (num_text > info_ptr->max_text - info_ptr->num_text) {
#line 791
    old_num_text = info_ptr->num_text;
#line 793
    new_text = (png_textp )((void *)0);
#line 796
    max_text = old_num_text;
#line 797
    if (num_text <= 0x7fffffff - max_text) {
#line 799
      max_text += num_text;
#line 802
      if (max_text < 2147483639) {
#line 803
        max_text = (max_text + 8) & -8;
      } else {
#line 806
        max_text = 0x7fffffff;
      }
#line 811
      tmp = png_realloc_array(png_ptr, (png_const_voidp )info_ptr->text, old_num_text,
                              max_text - old_num_text, sizeof(*new_text));
#line 811
      new_text = (png_textp )tmp;
    }
#line 816
    if ((unsigned long )new_text == (unsigned long )((void *)0)) {
#line 818
      png_chunk_report(png_ptr, (png_const_charp )"too many text chunks", 1);
#line 821
      return (1);
    }
#line 824
    png_free(png_ptr, (png_voidp )info_ptr->text);
#line 826
    info_ptr->text = new_text;
#line 827
    info_ptr->free_me |= 0x4000U;
#line 828
    info_ptr->max_text = max_text;
  }
#line 834
  i = 0;
  {
#line 834
  while (1) {
    while_continue: /* CIL Label */ ;
#line 834
    if (! (i < num_text)) {
#line 834
      goto while_break;
    }
#line 838
    textp = info_ptr->text + info_ptr->num_text;
#line 840
    if ((unsigned long )(text_ptr + i)->key == (unsigned long )((void *)0)) {
#line 841
      goto __Cont;
    }
#line 843
    if ((text_ptr + i)->compression < -1) {
#line 846
      png_chunk_report(png_ptr, (png_const_charp )"text compression mode is out of range",
                       1);
#line 848
      goto __Cont;
    } else
#line 843
    if ((text_ptr + i)->compression >= 3) {
#line 846
      png_chunk_report(png_ptr, (png_const_charp )"text compression mode is out of range",
                       1);
#line 848
      goto __Cont;
    }
#line 851
    key_len = strlen((char const   *)(text_ptr + i)->key);
#line 853
    if ((text_ptr + i)->compression <= 0) {
#line 855
      lang_len = (size_t )0;
#line 856
      lang_key_len = (size_t )0;
    } else {
#line 864
      if ((unsigned long )(text_ptr + i)->lang != (unsigned long )((void *)0)) {
#line 865
        lang_len = strlen((char const   *)(text_ptr + i)->lang);
      } else {
#line 868
        lang_len = (size_t )0;
      }
#line 870
      if ((unsigned long )(text_ptr + i)->lang_key != (unsigned long )((void *)0)) {
#line 871
        lang_key_len = strlen((char const   *)(text_ptr + i)->lang_key);
      } else {
#line 874
        lang_key_len = (size_t )0;
      }
    }
#line 884
    if ((unsigned long )(text_ptr + i)->text == (unsigned long )((void *)0)) {
#line 884
      goto _L;
    } else
#line 884
    if ((int )*((text_ptr + i)->text + 0) == 0) {
      _L: /* CIL Label */
#line 886
      text_length = (size_t )0;
#line 888
      if ((text_ptr + i)->compression > 0) {
#line 889
        textp->compression = 1;
      } else {
#line 893
        textp->compression = -1;
      }
    } else {
#line 898
      text_length = strlen((char const   *)(text_ptr + i)->text);
#line 899
      textp->compression = (int )(text_ptr + i)->compression;
    }
#line 902
    tmp___0 = png_malloc_base(png_ptr, (((key_len + text_length) + lang_len) + lang_key_len) + 4UL);
#line 902
    textp->key = (png_charp )tmp___0;
#line 905
    if ((unsigned long )textp->key == (unsigned long )((void *)0)) {
#line 907
      png_chunk_report(png_ptr, (png_const_charp )"text chunk: out of memory", 1);
#line 910
      return (1);
    }
#line 918
    memcpy((void *)textp->key, (void const   *)(text_ptr + i)->key, key_len);
#line 919
    *(textp->key + key_len) = (char )'\000';
#line 921
    if ((text_ptr + i)->compression > 0) {
#line 923
      textp->lang = (textp->key + key_len) + 1;
#line 924
      memcpy((void *)textp->lang, (void const   *)(text_ptr + i)->lang, lang_len);
#line 925
      *(textp->lang + lang_len) = (char )'\000';
#line 926
      textp->lang_key = (textp->lang + lang_len) + 1;
#line 927
      memcpy((void *)textp->lang_key, (void const   *)(text_ptr + i)->lang_key, lang_key_len);
#line 928
      *(textp->lang_key + lang_key_len) = (char )'\000';
#line 929
      textp->text = (textp->lang_key + lang_key_len) + 1;
    } else {
#line 934
      textp->lang = (png_charp )((void *)0);
#line 935
      textp->lang_key = (png_charp )((void *)0);
#line 936
      textp->text = (textp->key + key_len) + 1;
    }
#line 939
    if (text_length != 0UL) {
#line 940
      memcpy((void *)textp->text, (void const   *)(text_ptr + i)->text, text_length);
    }
#line 942
    *(textp->text + text_length) = (char )'\000';
#line 945
    if (textp->compression > 0) {
#line 947
      textp->text_length = (size_t )0;
#line 948
      textp->itxt_length = text_length;
    } else {
#line 954
      textp->text_length = text_length;
#line 955
      textp->itxt_length = (size_t )0;
    }
#line 958
    (info_ptr->num_text) ++;
    __Cont: /* CIL Label */
#line 834
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 962
  return (0);
}
}
#line 967 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
void png_set_tIME(png_const_structrp png_ptr , png_inforp info_ptr , png_const_timep mod_time )
{


  {
#line 973
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 975
    return;
  } else
#line 973
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 975
    return;
  } else
#line 973
  if ((unsigned long )mod_time == (unsigned long )((void *)0)) {
#line 975
    return;
  } else
#line 973
  if ((png_ptr->mode & 512U) != 0U) {
#line 975
    return;
  }
#line 977
  if ((int )mod_time->month == 0) {
#line 982
    png_warning(png_ptr, (png_const_charp )"Ignoring invalid time value");
#line 984
    return;
  } else
#line 977
  if ((int )mod_time->month > 12) {
#line 982
    png_warning(png_ptr, (png_const_charp )"Ignoring invalid time value");
#line 984
    return;
  } else
#line 977
  if ((int )mod_time->day == 0) {
#line 982
    png_warning(png_ptr, (png_const_charp )"Ignoring invalid time value");
#line 984
    return;
  } else
#line 977
  if ((int )mod_time->day > 31) {
#line 982
    png_warning(png_ptr, (png_const_charp )"Ignoring invalid time value");
#line 984
    return;
  } else
#line 977
  if ((int )mod_time->hour > 23) {
#line 982
    png_warning(png_ptr, (png_const_charp )"Ignoring invalid time value");
#line 984
    return;
  } else
#line 977
  if ((int )mod_time->minute > 59) {
#line 982
    png_warning(png_ptr, (png_const_charp )"Ignoring invalid time value");
#line 984
    return;
  } else
#line 977
  if ((int )mod_time->second > 60) {
#line 982
    png_warning(png_ptr, (png_const_charp )"Ignoring invalid time value");
#line 984
    return;
  }
#line 987
  info_ptr->mod_time = (png_time )*mod_time;
#line 988
  info_ptr->valid |= 0x0200U;
#line 989
  return;
}
}
#line 993 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
void png_set_tRNS(png_structrp png_ptr , png_inforp info_ptr , png_const_bytep trans_alpha ,
                  int num_trans , png_const_color_16p trans_color )
{
  png_voidp __attribute__((__malloc__))  tmp ;
  int sample_max ;

  {
#line 999
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1001
    return;
  } else
#line 999
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 1001
    return;
  }
#line 1003
  if ((unsigned long )trans_alpha != (unsigned long )((void *)0)) {
#line 1014
    png_free_data((png_const_structrp )png_ptr, info_ptr, 0x2000U, 0);
#line 1016
    if (num_trans > 0) {
#line 1016
      if (num_trans <= 256) {
#line 1019
        tmp = png_malloc((png_const_structrp )png_ptr, (png_alloc_size_t )256);
#line 1019
        info_ptr->trans_alpha = (png_bytep )tmp;
#line 1021
        memcpy((void *)info_ptr->trans_alpha, (void const   *)trans_alpha, (size_t )num_trans);
#line 1023
        info_ptr->valid |= 0x0010U;
#line 1024
        info_ptr->free_me |= 0x2000U;
      }
    }
#line 1026
    png_ptr->trans_alpha = info_ptr->trans_alpha;
  }
#line 1029
  if ((unsigned long )trans_color != (unsigned long )((void *)0)) {
#line 1032
    if ((int )info_ptr->bit_depth < 16) {
#line 1034
      sample_max = (1 << (int )info_ptr->bit_depth) - 1;
#line 1036
      if ((int )info_ptr->color_type == 0) {
#line 1036
        if ((int )trans_color->gray > (int )sample_max) {
#line 1042
          png_warning((png_const_structrp )png_ptr, (png_const_charp )"tRNS chunk has out-of-range samples for bit_depth");
        } else {
#line 1036
          goto _L;
        }
      } else
      _L: /* CIL Label */
#line 1036
      if ((int )info_ptr->color_type == 2) {
#line 1036
        if ((int )trans_color->red > (int )sample_max) {
#line 1042
          png_warning((png_const_structrp )png_ptr, (png_const_charp )"tRNS chunk has out-of-range samples for bit_depth");
        } else
#line 1036
        if ((int )trans_color->green > (int )sample_max) {
#line 1042
          png_warning((png_const_structrp )png_ptr, (png_const_charp )"tRNS chunk has out-of-range samples for bit_depth");
        } else
#line 1036
        if ((int )trans_color->blue > (int )sample_max) {
#line 1042
          png_warning((png_const_structrp )png_ptr, (png_const_charp )"tRNS chunk has out-of-range samples for bit_depth");
        }
      }
    }
#line 1047
    info_ptr->trans_color = (png_color_16 )*trans_color;
#line 1049
    if (num_trans == 0) {
#line 1050
      num_trans = 1;
    }
  }
#line 1053
  info_ptr->num_trans = (png_uint_16 )num_trans;
#line 1055
  if (num_trans != 0) {
#line 1057
    info_ptr->valid |= 0x0010U;
#line 1058
    info_ptr->free_me |= 0x2000U;
  }
#line 1060
  return;
}
}
#line 1064 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
void png_set_sPLT(png_const_structrp png_ptr , png_inforp info_ptr , png_const_sPLT_tp entries ,
                  int nentries )
{
  png_sPLT_tp np ;
  png_voidp __attribute__((__malloc__))  tmp ;
  size_t length ;
  size_t tmp___0 ;
  png_voidp __attribute__((__malloc__))  tmp___1 ;
  png_voidp __attribute__((__malloc__))  tmp___2 ;

  {
#line 1078
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1079
    return;
  } else
#line 1078
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 1079
    return;
  } else
#line 1078
  if (nentries <= 0) {
#line 1079
    return;
  } else
#line 1078
  if ((unsigned long )entries == (unsigned long )((void *)0)) {
#line 1079
    return;
  }
#line 1084
  tmp = png_realloc_array(png_ptr, (png_const_voidp )info_ptr->splt_palettes, info_ptr->splt_palettes_num,
                          nentries, sizeof(*np));
#line 1084
  np = (png_sPLT_tp )tmp;
#line 1088
  if ((unsigned long )np == (unsigned long )((void *)0)) {
#line 1091
    png_chunk_report(png_ptr, (png_const_charp )"too many sPLT chunks", 1);
#line 1093
    return;
  }
#line 1096
  png_free(png_ptr, (png_voidp )info_ptr->splt_palettes);
#line 1097
  info_ptr->splt_palettes = np;
#line 1098
  info_ptr->free_me |= 0x0020U;
#line 1100
  np += info_ptr->splt_palettes_num;
  {
#line 1102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1107
    if ((unsigned long )entries->name == (unsigned long )((void *)0)) {
#line 1110
      png_app_error(png_ptr, (png_const_charp )"png_set_sPLT: invalid sPLT");
#line 1112
      goto __Cont;
    } else
#line 1107
    if ((unsigned long )entries->entries == (unsigned long )((void *)0)) {
#line 1110
      png_app_error(png_ptr, (png_const_charp )"png_set_sPLT: invalid sPLT");
#line 1112
      goto __Cont;
    }
#line 1115
    np->depth = (png_byte )entries->depth;
#line 1120
    tmp___0 = strlen((char const   *)entries->name);
#line 1120
    length = tmp___0 + 1UL;
#line 1121
    tmp___1 = png_malloc_base(png_ptr, length);
#line 1121
    np->name = (png_charp )tmp___1;
#line 1123
    if ((unsigned long )np->name == (unsigned long )((void *)0)) {
#line 1124
      goto while_break;
    }
#line 1126
    memcpy((void *)np->name, (void const   *)entries->name, length);
#line 1132
    tmp___2 = png_malloc_array(png_ptr, (int )entries->nentries, sizeof(png_sPLT_entry ));
#line 1132
    np->entries = (png_sPLT_entryp )tmp___2;
#line 1135
    if ((unsigned long )np->entries == (unsigned long )((void *)0)) {
#line 1137
      png_free(png_ptr, (png_voidp )np->name);
#line 1138
      np->name = (png_charp )((void *)0);
#line 1139
      goto while_break;
    }
#line 1142
    np->nentries = (png_int_32 )entries->nentries;
#line 1146
    memcpy((void *)np->entries, (void const   *)entries->entries, (unsigned long )((unsigned int )entries->nentries) * sizeof(png_sPLT_entry ));
#line 1152
    info_ptr->valid |= 0x2000U;
#line 1153
    (info_ptr->splt_palettes_num) ++;
#line 1154
    np ++;
#line 1155
    entries ++;
    __Cont: /* CIL Label */
#line 1102
    nentries --;
#line 1102
    if (! nentries) {
#line 1102
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1159
  if (nentries > 0) {
#line 1160
    png_chunk_report(png_ptr, (png_const_charp )"sPLT out of memory", 1);
  }
#line 1161
  return;
}
}
#line 1165 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
static png_byte check_location(png_const_structrp png_ptr , int location )
{


  {
#line 1168
  location &= 11;
#line 1174
  if (location == 0) {
#line 1174
    if ((png_ptr->mode & 32768U) == 0U) {
#line 1177
      png_app_warning(png_ptr, (png_const_charp )"png_set_unknown_chunks now expects a valid location");
#line 1180
      location = (int )((png_byte )(png_ptr->mode & 11U));
    }
  }
#line 1187
  if (location == 0) {
#line 1188
    png_error(png_ptr, (png_const_charp )"invalid location in png_set_unknown_chunks");
  }
  {
#line 1193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1193
    if (! (location != (location & - location))) {
#line 1193
      goto while_break;
    }
#line 1194
    location &= ~ (location & - location);
  }
  while_break: /* CIL Label */ ;
  }
#line 1199
  return ((png_byte )location);
}
}
#line 1202 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
void png_set_unknown_chunks(png_const_structrp png_ptr , png_inforp info_ptr , png_const_unknown_chunkp unknowns ,
                            int num_unknowns )
{
  png_unknown_chunkp np ;
  png_voidp __attribute__((__malloc__))  tmp ;
  png_voidp __attribute__((__malloc__))  tmp___0 ;

  {
#line 1208
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1210
    return;
  } else
#line 1208
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 1210
    return;
  } else
#line 1208
  if (num_unknowns <= 0) {
#line 1210
    return;
  } else
#line 1208
  if ((unsigned long )unknowns == (unsigned long )((void *)0)) {
#line 1210
    return;
  }
#line 1242
  tmp = png_realloc_array(png_ptr, (png_const_voidp )info_ptr->unknown_chunks, info_ptr->unknown_chunks_num,
                          num_unknowns, sizeof(*np));
#line 1242
  np = (png_unknown_chunkp )tmp;
#line 1246
  if ((unsigned long )np == (unsigned long )((void *)0)) {
#line 1248
    png_chunk_report(png_ptr, (png_const_charp )"too many unknown chunks", 1);
#line 1251
    return;
  }
#line 1254
  png_free(png_ptr, (png_voidp )info_ptr->unknown_chunks);
#line 1255
  info_ptr->unknown_chunks = np;
#line 1256
  info_ptr->free_me |= 0x0200U;
#line 1258
  np += info_ptr->unknown_chunks_num;
  {
#line 1263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1263
    if (! (num_unknowns > 0)) {
#line 1263
      goto while_break;
    }
#line 1265
    memcpy((void *)(np->name), (void const   *)(unknowns->name), sizeof(np->name));
#line 1266
    np->name[sizeof(np->name) - 1UL] = (png_byte )'\000';
#line 1267
    np->location = check_location(png_ptr, (int )unknowns->location);
#line 1269
    if (unknowns->size == 0UL) {
#line 1271
      np->data = (png_byte *)((void *)0);
#line 1272
      np->size = (size_t )0;
    } else {
#line 1277
      tmp___0 = png_malloc_base(png_ptr, (png_alloc_size_t )unknowns->size);
#line 1277
      np->data = (png_byte *)tmp___0;
#line 1280
      if ((unsigned long )np->data == (unsigned long )((void *)0)) {
#line 1282
        png_chunk_report(png_ptr, (png_const_charp )"unknown chunk: out of memory",
                         1);
#line 1285
        goto __Cont;
      }
#line 1288
      memcpy((void *)np->data, (void const   *)unknowns->data, (size_t )unknowns->size);
#line 1289
      np->size = (size_t )unknowns->size;
    }
#line 1296
    np ++;
#line 1297
    (info_ptr->unknown_chunks_num) ++;
    __Cont: /* CIL Label */
#line 1263
    num_unknowns --;
#line 1263
    unknowns ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1299
  return;
}
}
#line 1301 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
void png_set_unknown_chunk_location(png_const_structrp png_ptr , png_inforp info_ptr ,
                                    int chunk , int location )
{


  {
#line 1310
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 1310
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1310
      if (chunk >= 0) {
#line 1310
        if (chunk < info_ptr->unknown_chunks_num) {
#line 1313
          if ((location & 11) == 0) {
#line 1315
            png_app_error(png_ptr, (png_const_charp )"invalid unknown chunk location");
#line 1317
            if (((unsigned int )location & 0x04U) != 0U) {
#line 1318
              location = 0x08;
            } else {
#line 1321
              location = 0x01;
            }
          }
#line 1324
          (info_ptr->unknown_chunks + chunk)->location = check_location(png_ptr, location);
        }
      }
    }
  }
#line 1327
  return;
}
}
#line 1331 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
png_uint_32 png_permit_mng_features(png_structrp png_ptr , png_uint_32 mng_features )
{


  {
#line 1336
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1337
    return ((png_uint_32 )0);
  }
#line 1339
  png_ptr->mng_features_permitted = mng_features & 5U;
#line 1341
  return (png_ptr->mng_features_permitted);
}
}
#line 1346 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
static unsigned int add_one_chunk(png_bytep list , unsigned int count , png_const_bytep add ,
                                  int keep )
{
  unsigned int i ;
  int tmp ;

  {
#line 1354
  i = 0U;
  {
#line 1354
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1354
    if (! (i < count)) {
#line 1354
      goto while_break;
    }
#line 1356
    tmp = memcmp((void const   *)list, (void const   *)add, (size_t )4);
#line 1356
    if (tmp == 0) {
#line 1358
      *(list + 4) = (png_byte )keep;
#line 1360
      return (count);
    }
#line 1354
    i ++;
#line 1354
    list += 5;
  }
  while_break: /* CIL Label */ ;
  }
#line 1364
  if (keep != 0) {
#line 1366
    count ++;
#line 1367
    memcpy((void *)list, (void const   *)add, (size_t )4);
#line 1368
    *(list + 4) = (png_byte )keep;
  }
#line 1371
  return (count);
}
}
#line 1405 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
static png_byte const   chunks_to_ignore[90]  =
#line 1405
  {      (png_byte const   )98,      (png_byte const   )75,      (png_byte const   )71,      (png_byte const   )68,
        (png_byte const   )'\000',      (png_byte const   )99,      (png_byte const   )72,      (png_byte const   )82,
        (png_byte const   )77,      (png_byte const   )'\000',      (png_byte const   )101,      (png_byte const   )88,
        (png_byte const   )73,      (png_byte const   )102,      (png_byte const   )'\000',      (png_byte const   )103,
        (png_byte const   )65,      (png_byte const   )77,      (png_byte const   )65,      (png_byte const   )'\000',
        (png_byte const   )104,      (png_byte const   )73,      (png_byte const   )83,      (png_byte const   )84,
        (png_byte const   )'\000',      (png_byte const   )105,      (png_byte const   )67,      (png_byte const   )67,
        (png_byte const   )80,      (png_byte const   )'\000',      (png_byte const   )105,      (png_byte const   )84,
        (png_byte const   )88,      (png_byte const   )116,      (png_byte const   )'\000',      (png_byte const   )111,
        (png_byte const   )70,      (png_byte const   )70,      (png_byte const   )115,      (png_byte const   )'\000',
        (png_byte const   )112,      (png_byte const   )67,      (png_byte const   )65,      (png_byte const   )76,
        (png_byte const   )'\000',      (png_byte const   )112,      (png_byte const   )72,      (png_byte const   )89,
        (png_byte const   )115,      (png_byte const   )'\000',      (png_byte const   )115,      (png_byte const   )66,
        (png_byte const   )73,      (png_byte const   )84,      (png_byte const   )'\000',      (png_byte const   )115,
        (png_byte const   )67,      (png_byte const   )65,      (png_byte const   )76,      (png_byte const   )'\000',
        (png_byte const   )115,      (png_byte const   )80,      (png_byte const   )76,      (png_byte const   )84,
        (png_byte const   )'\000',      (png_byte const   )115,      (png_byte const   )84,      (png_byte const   )69,
        (png_byte const   )82,      (png_byte const   )'\000',      (png_byte const   )115,      (png_byte const   )82,
        (png_byte const   )71,      (png_byte const   )66,      (png_byte const   )'\000',      (png_byte const   )116,
        (png_byte const   )69,      (png_byte const   )88,      (png_byte const   )116,      (png_byte const   )'\000',
        (png_byte const   )116,      (png_byte const   )73,      (png_byte const   )77,      (png_byte const   )69,
        (png_byte const   )'\000',      (png_byte const   )122,      (png_byte const   )84,      (png_byte const   )88,
        (png_byte const   )116,      (png_byte const   )'\000'};
#line 1374 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
void png_set_keep_unknown_chunks(png_structrp png_ptr , int keep , png_const_bytep chunk_list ,
                                 int num_chunks_in )
{
  png_bytep new_list ;
  unsigned int num_chunks ;
  unsigned int old_num_chunks ;
  png_voidp __attribute__((__malloc__))  tmp ;
  png_const_bytep inlist ;
  png_bytep outlist ;
  unsigned int i ;

  {
#line 1381
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1382
    return;
  }
#line 1384
  if (keep < 0) {
#line 1386
    png_app_error((png_const_structrp )png_ptr, (png_const_charp )"png_set_keep_unknown_chunks: invalid keep");
#line 1388
    return;
  } else
#line 1384
  if (keep >= 4) {
#line 1386
    png_app_error((png_const_structrp )png_ptr, (png_const_charp )"png_set_keep_unknown_chunks: invalid keep");
#line 1388
    return;
  }
#line 1391
  if (num_chunks_in <= 0) {
#line 1393
    png_ptr->unknown_default = keep;
#line 1396
    if (num_chunks_in == 0) {
#line 1397
      return;
    }
  }
#line 1400
  if (num_chunks_in < 0) {
#line 1426
    chunk_list = chunks_to_ignore;
#line 1427
    num_chunks = (unsigned int )sizeof(chunks_to_ignore) / 5U;
  } else {
#line 1432
    if ((unsigned long )chunk_list == (unsigned long )((void *)0)) {
#line 1437
      png_app_error((png_const_structrp )png_ptr, (png_const_charp )"png_set_keep_unknown_chunks: no chunk list");
#line 1439
      return;
    }
#line 1442
    num_chunks = (unsigned int )num_chunks_in;
  }
#line 1445
  old_num_chunks = png_ptr->num_chunk_list;
#line 1446
  if ((unsigned long )png_ptr->chunk_list == (unsigned long )((void *)0)) {
#line 1447
    old_num_chunks = 0U;
  }
#line 1451
  if (num_chunks + old_num_chunks > 858993459U) {
#line 1453
    png_app_error((png_const_structrp )png_ptr, (png_const_charp )"png_set_keep_unknown_chunks: too many chunks");
#line 1455
    return;
  }
#line 1462
  if (keep != 0) {
#line 1464
    tmp = png_malloc((png_const_structrp )png_ptr, (png_alloc_size_t )(5U * (num_chunks + old_num_chunks)));
#line 1464
    new_list = (png_bytep )tmp;
#line 1467
    if (old_num_chunks > 0U) {
#line 1468
      memcpy((void *)new_list, (void const   *)png_ptr->chunk_list, (size_t )(5U * old_num_chunks));
    }
  } else
#line 1471
  if (old_num_chunks > 0U) {
#line 1472
    new_list = png_ptr->chunk_list;
  } else {
#line 1475
    new_list = (png_bytep )((void *)0);
  }
#line 1482
  if ((unsigned long )new_list != (unsigned long )((void *)0)) {
#line 1488
    i = 0U;
    {
#line 1488
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1488
      if (! (i < num_chunks)) {
#line 1488
        goto while_break;
      }
#line 1490
      old_num_chunks = add_one_chunk(new_list, old_num_chunks, chunk_list + 5U * i,
                                     keep);
#line 1488
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1495
    num_chunks = 0U;
#line 1496
    i = 0U;
#line 1496
    outlist = new_list;
#line 1496
    inlist = (png_const_bytep )outlist;
    {
#line 1496
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1496
      if (! (i < old_num_chunks)) {
#line 1496
        goto while_break___0;
      }
#line 1498
      if (*(inlist + 4)) {
#line 1500
        if ((unsigned long )outlist != (unsigned long )inlist) {
#line 1501
          memcpy((void *)outlist, (void const   *)inlist, (size_t )5);
        }
#line 1502
        outlist += 5;
#line 1503
        num_chunks ++;
      }
#line 1496
      i ++;
#line 1496
      inlist += 5;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1508
    if (num_chunks == 0U) {
#line 1510
      if ((unsigned long )png_ptr->chunk_list != (unsigned long )new_list) {
#line 1511
        png_free((png_const_structrp )png_ptr, (png_voidp )new_list);
      }
#line 1513
      new_list = (png_bytep )((void *)0);
    }
  } else {
#line 1518
    num_chunks = 0U;
  }
#line 1520
  png_ptr->num_chunk_list = num_chunks;
#line 1522
  if ((unsigned long )png_ptr->chunk_list != (unsigned long )new_list) {
#line 1524
    if ((unsigned long )png_ptr->chunk_list != (unsigned long )((void *)0)) {
#line 1525
      png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->chunk_list);
    }
#line 1527
    png_ptr->chunk_list = new_list;
  }
#line 1529
  return;
}
}
#line 1533 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
void png_set_read_user_chunk_fn(png_structrp png_ptr , png_voidp user_chunk_ptr ,
                                int (*read_user_chunk_fn)(png_structp  , png_unknown_chunkp  ) )
{


  {
#line 1539
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1540
    return;
  }
#line 1542
  png_ptr->read_user_chunk_fn = read_user_chunk_fn;
#line 1543
  png_ptr->user_chunk_ptr = user_chunk_ptr;
#line 1544
  return;
}
}
#line 1548 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
void png_set_rows(png_const_structrp png_ptr , png_inforp info_ptr , png_bytepp row_pointers )
{


  {
#line 1554
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1555
    return;
  } else
#line 1554
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 1555
    return;
  }
#line 1557
  if ((unsigned long )info_ptr->row_pointers != (unsigned long )((void *)0)) {
#line 1557
    if ((unsigned long )info_ptr->row_pointers != (unsigned long )row_pointers) {
#line 1559
      png_free_data(png_ptr, info_ptr, 0x0040U, 0);
    }
  }
#line 1561
  info_ptr->row_pointers = row_pointers;
#line 1563
  if ((unsigned long )row_pointers != (unsigned long )((void *)0)) {
#line 1564
    info_ptr->valid |= 0x8000U;
  }
#line 1565
  return;
}
}
#line 1568 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
void png_set_compression_buffer_size(png_structrp png_ptr , size_t size )
{


  {
#line 1571
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1572
    return;
  }
#line 1574
  if (size == 0UL) {
#line 1575
    png_error((png_const_structrp )png_ptr, (png_const_charp )"invalid compression buffer size");
  } else
#line 1574
  if (size > 2147483647UL) {
#line 1575
    png_error((png_const_structrp )png_ptr, (png_const_charp )"invalid compression buffer size");
  }
#line 1578
  if ((png_ptr->mode & 0x8000U) != 0U) {
#line 1580
    png_ptr->IDAT_read_size = (png_uint_32 )size;
#line 1581
    return;
  }
#line 1586
  if ((png_ptr->mode & 0x8000U) == 0U) {
#line 1588
    if (png_ptr->zowner != 0U) {
#line 1590
      png_warning((png_const_structrp )png_ptr, (png_const_charp )"Compression buffer size cannot be changed because it is in use");
#line 1593
      return;
    }
#line 1600
    if (size > 4294967295UL) {
#line 1602
      png_warning((png_const_structrp )png_ptr, (png_const_charp )"Compression buffer size limited to system maximum");
#line 1604
      size = (size_t )((uInt )-1);
    }
#line 1608
    if (size < 6UL) {
#line 1613
      png_warning((png_const_structrp )png_ptr, (png_const_charp )"Compression buffer size cannot be reduced below 6");
#line 1616
      return;
    }
#line 1619
    if ((size_t )png_ptr->zbuffer_size != size) {
#line 1621
      png_free_buffer_list(png_ptr, & png_ptr->zbuffer_list);
#line 1622
      png_ptr->zbuffer_size = (uInt )size;
    }
  }
#line 1626
  return;
}
}
#line 1628 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
void png_set_invalid(png_const_structrp png_ptr , png_inforp info_ptr , int mask )
{


  {
#line 1631
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 1631
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1632
      info_ptr->valid &= (unsigned int )(~ mask);
    }
  }
#line 1633
  return;
}
}
#line 1638 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
void png_set_user_limits(png_structrp png_ptr , png_uint_32 user_width_max , png_uint_32 user_height_max )
{


  {
#line 1646
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1647
    return;
  }
#line 1649
  png_ptr->user_width_max = user_width_max;
#line 1650
  png_ptr->user_height_max = user_height_max;
#line 1651
  return;
}
}
#line 1654 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
void png_set_chunk_cache_max(png_structrp png_ptr , png_uint_32 user_chunk_cache_max )
{


  {
#line 1657
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 1658
    png_ptr->user_chunk_cache_max = user_chunk_cache_max;
  }
#line 1659
  return;
}
}
#line 1662 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
void png_set_chunk_malloc_max(png_structrp png_ptr , png_alloc_size_t user_chunk_malloc_max )
{


  {
#line 1666
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 1667
    png_ptr->user_chunk_malloc_max = user_chunk_malloc_max;
  }
#line 1668
  return;
}
}
#line 1673 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
void png_set_benign_errors(png_structrp png_ptr , int allowed )
{


  {
#line 1684
  if (allowed != 0) {
#line 1685
    png_ptr->flags |= 7340032U;
  } else {
#line 1689
    png_ptr->flags &= 4287627263U;
  }
#line 1691
  return;
}
}
#line 1703 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
void png_set_check_for_invalid_index(png_structrp png_ptr , int allowed )
{


  {
#line 1708
  if (allowed > 0) {
#line 1709
    png_ptr->num_palette_max = 0;
  } else {
#line 1712
    png_ptr->num_palette_max = -1;
  }
#line 1713
  return;
}
}
#line 1728 "/home/goblint2/bench/libpng-1.6.39/pngset.c"
png_uint_32 png_check_keyword(png_structrp png_ptr , png_const_charp key___3 , png_bytep new_key )
{
  png_const_charp orig_key ;
  png_uint_32 key_len ;
  int bad_character ;
  int space ;
  png_byte ch ;
  png_const_charp tmp ;
  png_bytep tmp___0 ;
  png_bytep tmp___1 ;
  png_warning_parameters p ;

  {
#line 1732
  orig_key = key___3;
#line 1734
  key_len = (png_uint_32 )0;
#line 1735
  bad_character = 0;
#line 1736
  space = 1;
#line 1740
  if ((unsigned long )key___3 == (unsigned long )((void *)0)) {
#line 1742
    *new_key = (png_byte )0;
#line 1743
    return ((png_uint_32 )0);
  }
  {
#line 1746
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1746
    if (*key___3) {
#line 1746
      if (! (key_len < 79U)) {
#line 1746
        goto while_break;
      }
    } else {
#line 1746
      goto while_break;
    }
#line 1748
    tmp = key___3;
#line 1748
    key___3 ++;
#line 1748
    ch = (png_byte )*tmp;
#line 1750
    if ((int )ch > 32) {
#line 1750
      if ((int )ch <= 126) {
#line 1752
        tmp___0 = new_key;
#line 1752
        new_key ++;
#line 1752
        *tmp___0 = ch;
#line 1752
        key_len ++;
#line 1752
        space = 0;
      } else {
#line 1750
        goto _L;
      }
    } else
    _L: /* CIL Label */
#line 1750
    if ((int )ch >= 161) {
#line 1752
      tmp___0 = new_key;
#line 1752
      new_key ++;
#line 1752
      *tmp___0 = ch;
#line 1752
      key_len ++;
#line 1752
      space = 0;
    } else
#line 1755
    if (space == 0) {
#line 1760
      tmp___1 = new_key;
#line 1760
      new_key ++;
#line 1760
      *tmp___1 = (png_byte )32;
#line 1760
      key_len ++;
#line 1760
      space = 1;
#line 1763
      if ((int )ch != 32) {
#line 1764
        bad_character = (int )ch;
      }
    } else
#line 1767
    if (bad_character == 0) {
#line 1768
      bad_character = (int )ch;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1771
  if (key_len > 0U) {
#line 1771
    if (space != 0) {
#line 1773
      key_len --;
#line 1773
      new_key --;
#line 1774
      if (bad_character == 0) {
#line 1775
        bad_character = 32;
      }
    }
  }
#line 1779
  *new_key = (png_byte )0;
#line 1781
  if (key_len == 0U) {
#line 1782
    return ((png_uint_32 )0);
  }
#line 1786
  if ((int const   )*key___3 != 0) {
#line 1787
    png_warning((png_const_structrp )png_ptr, (png_const_charp )"keyword truncated");
  } else
#line 1789
  if (bad_character != 0) {
#line 1793
    png_warning_parameter((char (*)[32])(p), 1, orig_key);
#line 1794
    png_warning_parameter_signed((char (*)[32])(p), 2, 4, bad_character);
#line 1796
    png_formatted_warning((png_const_structrp )png_ptr, (char (*)[32])(p), (png_const_charp )"keyword \"@1\": bad character \'0x@2\'");
  }
#line 1802
  return (key_len);
}
}
#line 101 "/usr/include/stdlib.h"
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 104
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 107
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 112
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__leaf__, __gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__,
__nothrow__)) ;
#line 820
__inline extern void *( __attribute__((__warn_unused_result__, __nonnull__(1,2,5),
__gnu_inline__)) bsearch)(void const   *__key , void const   *__base , size_t __nmemb ,
                          size_t __size , int (*__compar)(void const   * , void const   * ) ) ;
#line 929
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar )  __attribute__((__nothrow__)) ;
#line 933
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t *__dst , char const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 936
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) wcstombs)(char *__dst , wchar_t const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 43 "/usr/include/string.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memcpy)(void *__dest , void const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 47
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 61
__inline extern void *( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) memset)(void *__dest , int __ch , size_t __len )  __attribute__((__nothrow__)) ;
#line 122
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcpy)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 125
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncpy)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 130
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcat)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 133
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncat)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 326 "/usr/include/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) fprintf)(FILE *__stream ,
                                                                                                  char const   *__fmt
                                                                                                  , ...) ;
#line 332
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) printf)(char const   *__fmt
                                                                                                 , ...) ;
#line 334
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) sprintf)(char *__s ,
                                                                                                            char const   *__fmt
                                                                                                            , ...)  __attribute__((__nothrow__)) ;
#line 341
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vfprintf)(FILE *__stream ,
                                                                                                   char const   *__fmt ,
                                                                                                   __gnuc_va_list __ap ) ;
#line 347
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vprintf)(char const   *__fmt ,
                                                                                                  __gnuc_va_list __ap ) ;
#line 349
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vsprintf)(char *__s ,
                                                                                                             char const   *__fmt ,
                                                                                                             __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 354
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) snprintf)(char *__s , size_t __n , char const   *__fmt
                                              , ...)  __attribute__((__nothrow__)) ;
#line 358
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) vsnprintf)(char *__s , size_t __n , char const   *__fmt ,
                                               __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 492
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
#line 528
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
#line 564
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fgets)(char *__s , int __n , FILE *__stream ) ;
#line 646
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fread)(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 360 "/usr/include/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) read)(int __fd , void *__buf , size_t __nbytes ) ;
#line 511
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size )  __attribute__((__nothrow__)) ;
#line 689
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list )  __attribute__((__nothrow__)) ;
#line 774
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                               size_t __buflen )  __attribute__((__nothrow__)) ;
#line 20 "/home/goblint2/bench/libpng-1.6.39/pngtrans.c"
void png_set_bgr(png_structrp png_ptr )
{


  {
#line 25
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 26
    return;
  }
#line 28
  png_ptr->transformations |= 0x0001U;
#line 29
  return;
}
}
#line 34 "/home/goblint2/bench/libpng-1.6.39/pngtrans.c"
void png_set_swap(png_structrp png_ptr )
{


  {
#line 39
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 40
    return;
  }
#line 42
  if ((int )png_ptr->bit_depth == 16) {
#line 43
    png_ptr->transformations |= 0x0010U;
  }
#line 44
  return;
}
}
#line 49 "/home/goblint2/bench/libpng-1.6.39/pngtrans.c"
void png_set_packing(png_structrp png_ptr )
{


  {
#line 54
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 55
    return;
  }
#line 57
  if ((int )png_ptr->bit_depth < 8) {
#line 59
    png_ptr->transformations |= 0x0004U;
#line 61
    png_ptr->usr_bit_depth = (png_byte )8;
  }
#line 64
  return;
}
}
#line 69 "/home/goblint2/bench/libpng-1.6.39/pngtrans.c"
void png_set_packswap(png_structrp png_ptr )
{


  {
#line 74
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 75
    return;
  }
#line 77
  if ((int )png_ptr->bit_depth < 8) {
#line 78
    png_ptr->transformations |= 0x10000U;
  }
#line 79
  return;
}
}
#line 83 "/home/goblint2/bench/libpng-1.6.39/pngtrans.c"
void png_set_shift(png_structrp png_ptr , png_const_color_8p true_bits )
{


  {
#line 88
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 89
    return;
  }
#line 91
  png_ptr->transformations |= 0x0008U;
#line 92
  png_ptr->shift = (png_color_8 )*true_bits;
#line 93
  return;
}
}
#line 98 "/home/goblint2/bench/libpng-1.6.39/pngtrans.c"
int png_set_interlace_handling(png_structrp png_ptr )
{


  {
#line 103
  if ((unsigned long )png_ptr != (unsigned long )((png_structrp )0)) {
#line 103
    if ((int )png_ptr->interlaced != 0) {
#line 105
      png_ptr->transformations |= 0x0002U;
#line 106
      return (7);
    }
  }
#line 109
  return (1);
}
}
#line 119 "/home/goblint2/bench/libpng-1.6.39/pngtrans.c"
void png_set_filler(png_structrp png_ptr , png_uint_32 filler , int filler_loc )
{


  {
#line 124
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 125
    return;
  }
#line 130
  if ((png_ptr->mode & 0x8000U) != 0U) {
#line 141
    png_ptr->filler = (png_uint_16 )filler;
  } else {
    {
#line 157
    if ((int )png_ptr->color_type == 2) {
#line 157
      goto case_2;
    }
#line 161
    if ((int )png_ptr->color_type == 0) {
#line 161
      goto case_0;
    }
#line 180
    goto switch_default;
    case_2: /* CIL Label */
#line 158
    png_ptr->usr_channels = (png_byte )4;
#line 159
    goto switch_break;
    case_0: /* CIL Label */
#line 162
    if ((int )png_ptr->bit_depth >= 8) {
#line 164
      png_ptr->usr_channels = (png_byte )2;
#line 165
      goto switch_break;
    } else {
#line 174
      png_app_error((png_const_structrp )png_ptr, (png_const_charp )"png_set_filler is invalid for low bit depth gray output");
#line 177
      return;
    }
    switch_default: /* CIL Label */
#line 181
    png_app_error((png_const_structrp )png_ptr, (png_const_charp )"png_set_filler: inappropriate color type");
#line 183
    return;
    switch_break: /* CIL Label */ ;
    }
  }
#line 194
  png_ptr->transformations |= 0x8000U;
#line 196
  if (filler_loc == 1) {
#line 197
    png_ptr->flags |= 0x0080U;
  } else {
#line 200
    png_ptr->flags &= 4294967167U;
  }
#line 201
  return;
}
}
#line 204 "/home/goblint2/bench/libpng-1.6.39/pngtrans.c"
void png_set_add_alpha(png_structrp png_ptr , png_uint_32 filler , int filler_loc )
{


  {
#line 209
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 210
    return;
  }
#line 212
  png_set_filler(png_ptr, filler, filler_loc);
#line 214
  if ((png_ptr->transformations & 0x8000U) != 0U) {
#line 215
    png_ptr->transformations |= 0x1000000U;
  }
#line 216
  return;
}
}
#line 222 "/home/goblint2/bench/libpng-1.6.39/pngtrans.c"
void png_set_swap_alpha(png_structrp png_ptr )
{


  {
#line 227
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 228
    return;
  }
#line 230
  png_ptr->transformations |= 0x20000U;
#line 231
  return;
}
}
#line 236 "/home/goblint2/bench/libpng-1.6.39/pngtrans.c"
void png_set_invert_alpha(png_structrp png_ptr )
{


  {
#line 241
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 242
    return;
  }
#line 244
  png_ptr->transformations |= 0x80000U;
#line 245
  return;
}
}
#line 249 "/home/goblint2/bench/libpng-1.6.39/pngtrans.c"
void png_set_invert_mono(png_structrp png_ptr )
{


  {
#line 254
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 255
    return;
  }
#line 257
  png_ptr->transformations |= 0x0020U;
#line 258
  return;
}
}
#line 261 "/home/goblint2/bench/libpng-1.6.39/pngtrans.c"
void png_do_invert(png_row_infop row_info , png_bytep row )
{
  png_bytep rp ;
  size_t i ;
  size_t istop ;
  png_bytep rp___0 ;
  size_t i___0 ;
  size_t istop___0 ;
  png_bytep rp___1 ;
  size_t i___1 ;
  size_t istop___1 ;

  {
#line 269
  if ((int )row_info->color_type == 0) {
#line 271
    rp = row;
#line 273
    istop = row_info->rowbytes;
#line 275
    i = (size_t )0;
    {
#line 275
    while (1) {
      while_continue: /* CIL Label */ ;
#line 275
      if (! (i < istop)) {
#line 275
        goto while_break;
      }
#line 277
      *rp = (png_byte )(~ ((int )*rp));
#line 278
      rp ++;
#line 275
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 282
  if ((int )row_info->color_type == 4) {
#line 282
    if ((int )row_info->bit_depth == 8) {
#line 285
      rp___0 = row;
#line 287
      istop___0 = row_info->rowbytes;
#line 289
      i___0 = (size_t )0;
      {
#line 289
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 289
        if (! (i___0 < istop___0)) {
#line 289
          goto while_break___0;
        }
#line 291
        *rp___0 = (png_byte )(~ ((int )*rp___0));
#line 292
        rp___0 += 2;
#line 289
        i___0 += 2UL;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 282
      goto _L;
    }
  } else
  _L: /* CIL Label */
#line 297
  if ((int )row_info->color_type == 4) {
#line 297
    if ((int )row_info->bit_depth == 16) {
#line 300
      rp___1 = row;
#line 302
      istop___1 = row_info->rowbytes;
#line 304
      i___1 = (size_t )0;
      {
#line 304
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 304
        if (! (i___1 < istop___1)) {
#line 304
          goto while_break___1;
        }
#line 306
        *rp___1 = (png_byte )(~ ((int )*rp___1));
#line 307
        *(rp___1 + 1) = (png_byte )(~ ((int )*(rp___1 + 1)));
#line 308
        rp___1 += 4;
#line 304
        i___1 += 4UL;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 312
  return;
}
}
#line 318 "/home/goblint2/bench/libpng-1.6.39/pngtrans.c"
void png_do_swap(png_row_infop row_info , png_bytep row )
{
  png_bytep rp ;
  png_uint_32 i ;
  png_uint_32 istop ;
  png_byte t ;

  {
#line 323
  if ((int )row_info->bit_depth == 16) {
#line 325
    rp = row;
#line 327
    istop = row_info->width * (png_uint_32 )row_info->channels;
#line 329
    i = (png_uint_32 )0;
    {
#line 329
    while (1) {
      while_continue: /* CIL Label */ ;
#line 329
      if (! (i < istop)) {
#line 329
        goto while_break;
      }
#line 337
      t = *rp;
#line 338
      *rp = *(rp + 1);
#line 339
      *(rp + 1) = t;
#line 329
      i ++;
#line 329
      rp += 2;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 343
  return;
}
}
#line 348 "/home/goblint2/bench/libpng-1.6.39/pngtrans.c"
static png_byte const   onebppswaptable[256]  =
#line 348
  {      (png_byte const   )0x00,      (png_byte const   )0x80,      (png_byte const   )0x40,      (png_byte const   )0xC0,
        (png_byte const   )0x20,      (png_byte const   )0xA0,      (png_byte const   )0x60,      (png_byte const   )0xE0,
        (png_byte const   )0x10,      (png_byte const   )0x90,      (png_byte const   )0x50,      (png_byte const   )0xD0,
        (png_byte const   )0x30,      (png_byte const   )0xB0,      (png_byte const   )0x70,      (png_byte const   )0xF0,
        (png_byte const   )0x08,      (png_byte const   )0x88,      (png_byte const   )0x48,      (png_byte const   )0xC8,
        (png_byte const   )0x28,      (png_byte const   )0xA8,      (png_byte const   )0x68,      (png_byte const   )0xE8,
        (png_byte const   )0x18,      (png_byte const   )0x98,      (png_byte const   )0x58,      (png_byte const   )0xD8,
        (png_byte const   )0x38,      (png_byte const   )0xB8,      (png_byte const   )0x78,      (png_byte const   )0xF8,
        (png_byte const   )0x04,      (png_byte const   )0x84,      (png_byte const   )0x44,      (png_byte const   )0xC4,
        (png_byte const   )0x24,      (png_byte const   )0xA4,      (png_byte const   )0x64,      (png_byte const   )0xE4,
        (png_byte const   )0x14,      (png_byte const   )0x94,      (png_byte const   )0x54,      (png_byte const   )0xD4,
        (png_byte const   )0x34,      (png_byte const   )0xB4,      (png_byte const   )0x74,      (png_byte const   )0xF4,
        (png_byte const   )0x0C,      (png_byte const   )0x8C,      (png_byte const   )0x4C,      (png_byte const   )0xCC,
        (png_byte const   )0x2C,      (png_byte const   )0xAC,      (png_byte const   )0x6C,      (png_byte const   )0xEC,
        (png_byte const   )0x1C,      (png_byte const   )0x9C,      (png_byte const   )0x5C,      (png_byte const   )0xDC,
        (png_byte const   )0x3C,      (png_byte const   )0xBC,      (png_byte const   )0x7C,      (png_byte const   )0xFC,
        (png_byte const   )0x02,      (png_byte const   )0x82,      (png_byte const   )0x42,      (png_byte const   )0xC2,
        (png_byte const   )0x22,      (png_byte const   )0xA2,      (png_byte const   )0x62,      (png_byte const   )0xE2,
        (png_byte const   )0x12,      (png_byte const   )0x92,      (png_byte const   )0x52,      (png_byte const   )0xD2,
        (png_byte const   )0x32,      (png_byte const   )0xB2,      (png_byte const   )0x72,      (png_byte const   )0xF2,
        (png_byte const   )0x0A,      (png_byte const   )0x8A,      (png_byte const   )0x4A,      (png_byte const   )0xCA,
        (png_byte const   )0x2A,      (png_byte const   )0xAA,      (png_byte const   )0x6A,      (png_byte const   )0xEA,
        (png_byte const   )0x1A,      (png_byte const   )0x9A,      (png_byte const   )0x5A,      (png_byte const   )0xDA,
        (png_byte const   )0x3A,      (png_byte const   )0xBA,      (png_byte const   )0x7A,      (png_byte const   )0xFA,
        (png_byte const   )0x06,      (png_byte const   )0x86,      (png_byte const   )0x46,      (png_byte const   )0xC6,
        (png_byte const   )0x26,      (png_byte const   )0xA6,      (png_byte const   )0x66,      (png_byte const   )0xE6,
        (png_byte const   )0x16,      (png_byte const   )0x96,      (png_byte const   )0x56,      (png_byte const   )0xD6,
        (png_byte const   )0x36,      (png_byte const   )0xB6,      (png_byte const   )0x76,      (png_byte const   )0xF6,
        (png_byte const   )0x0E,      (png_byte const   )0x8E,      (png_byte const   )0x4E,      (png_byte const   )0xCE,
        (png_byte const   )0x2E,      (png_byte const   )0xAE,      (png_byte const   )0x6E,      (png_byte const   )0xEE,
        (png_byte const   )0x1E,      (png_byte const   )0x9E,      (png_byte const   )0x5E,      (png_byte const   )0xDE,
        (png_byte const   )0x3E,      (png_byte const   )0xBE,      (png_byte const   )0x7E,      (png_byte const   )0xFE,
        (png_byte const   )0x01,      (png_byte const   )0x81,      (png_byte const   )0x41,      (png_byte const   )0xC1,
        (png_byte const   )0x21,      (png_byte const   )0xA1,      (png_byte const   )0x61,      (png_byte const   )0xE1,
        (png_byte const   )0x11,      (png_byte const   )0x91,      (png_byte const   )0x51,      (png_byte const   )0xD1,
        (png_byte const   )0x31,      (png_byte const   )0xB1,      (png_byte const   )0x71,      (png_byte const   )0xF1,
        (png_byte const   )0x09,      (png_byte const   )0x89,      (png_byte const   )0x49,      (png_byte const   )0xC9,
        (png_byte const   )0x29,      (png_byte const   )0xA9,      (png_byte const   )0x69,      (png_byte const   )0xE9,
        (png_byte const   )0x19,      (png_byte const   )0x99,      (png_byte const   )0x59,      (png_byte const   )0xD9,
        (png_byte const   )0x39,      (png_byte const   )0xB9,      (png_byte const   )0x79,      (png_byte const   )0xF9,
        (png_byte const   )0x05,      (png_byte const   )0x85,      (png_byte const   )0x45,      (png_byte const   )0xC5,
        (png_byte const   )0x25,      (png_byte const   )0xA5,      (png_byte const   )0x65,      (png_byte const   )0xE5,
        (png_byte const   )0x15,      (png_byte const   )0x95,      (png_byte const   )0x55,      (png_byte const   )0xD5,
        (png_byte const   )0x35,      (png_byte const   )0xB5,      (png_byte const   )0x75,      (png_byte const   )0xF5,
        (png_byte const   )0x0D,      (png_byte const   )0x8D,      (png_byte const   )0x4D,      (png_byte const   )0xCD,
        (png_byte const   )0x2D,      (png_byte const   )0xAD,      (png_byte const   )0x6D,      (png_byte const   )0xED,
        (png_byte const   )0x1D,      (png_byte const   )0x9D,      (png_byte const   )0x5D,      (png_byte const   )0xDD,
        (png_byte const   )0x3D,      (png_byte const   )0xBD,      (png_byte const   )0x7D,      (png_byte const   )0xFD,
        (png_byte const   )0x03,      (png_byte const   )0x83,      (png_byte const   )0x43,      (png_byte const   )0xC3,
        (png_byte const   )0x23,      (png_byte const   )0xA3,      (png_byte const   )0x63,      (png_byte const   )0xE3,
        (png_byte const   )0x13,      (png_byte const   )0x93,      (png_byte const   )0x53,      (png_byte const   )0xD3,
        (png_byte const   )0x33,      (png_byte const   )0xB3,      (png_byte const   )0x73,      (png_byte const   )0xF3,
        (png_byte const   )0x0B,      (png_byte const   )0x8B,      (png_byte const   )0x4B,      (png_byte const   )0xCB,
        (png_byte const   )0x2B,      (png_byte const   )0xAB,      (png_byte const   )0x6B,      (png_byte const   )0xEB,
        (png_byte const   )0x1B,      (png_byte const   )0x9B,      (png_byte const   )0x5B,      (png_byte const   )0xDB,
        (png_byte const   )0x3B,      (png_byte const   )0xBB,      (png_byte const   )0x7B,      (png_byte const   )0xFB,
        (png_byte const   )0x07,      (png_byte const   )0x87,      (png_byte const   )0x47,      (png_byte const   )0xC7,
        (png_byte const   )0x27,      (png_byte const   )0xA7,      (png_byte const   )0x67,      (png_byte const   )0xE7,
        (png_byte const   )0x17,      (png_byte const   )0x97,      (png_byte const   )0x57,      (png_byte const   )0xD7,
        (png_byte const   )0x37,      (png_byte const   )0xB7,      (png_byte const   )0x77,      (png_byte const   )0xF7,
        (png_byte const   )0x0F,      (png_byte const   )0x8F,      (png_byte const   )0x4F,      (png_byte const   )0xCF,
        (png_byte const   )0x2F,      (png_byte const   )0xAF,      (png_byte const   )0x6F,      (png_byte const   )0xEF,
        (png_byte const   )0x1F,      (png_byte const   )0x9F,      (png_byte const   )0x5F,      (png_byte const   )0xDF,
        (png_byte const   )0x3F,      (png_byte const   )0xBF,      (png_byte const   )0x7F,      (png_byte const   )0xFF};
#line 383 "/home/goblint2/bench/libpng-1.6.39/pngtrans.c"
static png_byte const   twobppswaptable[256]  =
#line 383
  {      (png_byte const   )0x00,      (png_byte const   )0x40,      (png_byte const   )0x80,      (png_byte const   )0xC0,
        (png_byte const   )0x10,      (png_byte const   )0x50,      (png_byte const   )0x90,      (png_byte const   )0xD0,
        (png_byte const   )0x20,      (png_byte const   )0x60,      (png_byte const   )0xA0,      (png_byte const   )0xE0,
        (png_byte const   )0x30,      (png_byte const   )0x70,      (png_byte const   )0xB0,      (png_byte const   )0xF0,
        (png_byte const   )0x04,      (png_byte const   )0x44,      (png_byte const   )0x84,      (png_byte const   )0xC4,
        (png_byte const   )0x14,      (png_byte const   )0x54,      (png_byte const   )0x94,      (png_byte const   )0xD4,
        (png_byte const   )0x24,      (png_byte const   )0x64,      (png_byte const   )0xA4,      (png_byte const   )0xE4,
        (png_byte const   )0x34,      (png_byte const   )0x74,      (png_byte const   )0xB4,      (png_byte const   )0xF4,
        (png_byte const   )0x08,      (png_byte const   )0x48,      (png_byte const   )0x88,      (png_byte const   )0xC8,
        (png_byte const   )0x18,      (png_byte const   )0x58,      (png_byte const   )0x98,      (png_byte const   )0xD8,
        (png_byte const   )0x28,      (png_byte const   )0x68,      (png_byte const   )0xA8,      (png_byte const   )0xE8,
        (png_byte const   )0x38,      (png_byte const   )0x78,      (png_byte const   )0xB8,      (png_byte const   )0xF8,
        (png_byte const   )0x0C,      (png_byte const   )0x4C,      (png_byte const   )0x8C,      (png_byte const   )0xCC,
        (png_byte const   )0x1C,      (png_byte const   )0x5C,      (png_byte const   )0x9C,      (png_byte const   )0xDC,
        (png_byte const   )0x2C,      (png_byte const   )0x6C,      (png_byte const   )0xAC,      (png_byte const   )0xEC,
        (png_byte const   )0x3C,      (png_byte const   )0x7C,      (png_byte const   )0xBC,      (png_byte const   )0xFC,
        (png_byte const   )0x01,      (png_byte const   )0x41,      (png_byte const   )0x81,      (png_byte const   )0xC1,
        (png_byte const   )0x11,      (png_byte const   )0x51,      (png_byte const   )0x91,      (png_byte const   )0xD1,
        (png_byte const   )0x21,      (png_byte const   )0x61,      (png_byte const   )0xA1,      (png_byte const   )0xE1,
        (png_byte const   )0x31,      (png_byte const   )0x71,      (png_byte const   )0xB1,      (png_byte const   )0xF1,
        (png_byte const   )0x05,      (png_byte const   )0x45,      (png_byte const   )0x85,      (png_byte const   )0xC5,
        (png_byte const   )0x15,      (png_byte const   )0x55,      (png_byte const   )0x95,      (png_byte const   )0xD5,
        (png_byte const   )0x25,      (png_byte const   )0x65,      (png_byte const   )0xA5,      (png_byte const   )0xE5,
        (png_byte const   )0x35,      (png_byte const   )0x75,      (png_byte const   )0xB5,      (png_byte const   )0xF5,
        (png_byte const   )0x09,      (png_byte const   )0x49,      (png_byte const   )0x89,      (png_byte const   )0xC9,
        (png_byte const   )0x19,      (png_byte const   )0x59,      (png_byte const   )0x99,      (png_byte const   )0xD9,
        (png_byte const   )0x29,      (png_byte const   )0x69,      (png_byte const   )0xA9,      (png_byte const   )0xE9,
        (png_byte const   )0x39,      (png_byte const   )0x79,      (png_byte const   )0xB9,      (png_byte const   )0xF9,
        (png_byte const   )0x0D,      (png_byte const   )0x4D,      (png_byte const   )0x8D,      (png_byte const   )0xCD,
        (png_byte const   )0x1D,      (png_byte const   )0x5D,      (png_byte const   )0x9D,      (png_byte const   )0xDD,
        (png_byte const   )0x2D,      (png_byte const   )0x6D,      (png_byte const   )0xAD,      (png_byte const   )0xED,
        (png_byte const   )0x3D,      (png_byte const   )0x7D,      (png_byte const   )0xBD,      (png_byte const   )0xFD,
        (png_byte const   )0x02,      (png_byte const   )0x42,      (png_byte const   )0x82,      (png_byte const   )0xC2,
        (png_byte const   )0x12,      (png_byte const   )0x52,      (png_byte const   )0x92,      (png_byte const   )0xD2,
        (png_byte const   )0x22,      (png_byte const   )0x62,      (png_byte const   )0xA2,      (png_byte const   )0xE2,
        (png_byte const   )0x32,      (png_byte const   )0x72,      (png_byte const   )0xB2,      (png_byte const   )0xF2,
        (png_byte const   )0x06,      (png_byte const   )0x46,      (png_byte const   )0x86,      (png_byte const   )0xC6,
        (png_byte const   )0x16,      (png_byte const   )0x56,      (png_byte const   )0x96,      (png_byte const   )0xD6,
        (png_byte const   )0x26,      (png_byte const   )0x66,      (png_byte const   )0xA6,      (png_byte const   )0xE6,
        (png_byte const   )0x36,      (png_byte const   )0x76,      (png_byte const   )0xB6,      (png_byte const   )0xF6,
        (png_byte const   )0x0A,      (png_byte const   )0x4A,      (png_byte const   )0x8A,      (png_byte const   )0xCA,
        (png_byte const   )0x1A,      (png_byte const   )0x5A,      (png_byte const   )0x9A,      (png_byte const   )0xDA,
        (png_byte const   )0x2A,      (png_byte const   )0x6A,      (png_byte const   )0xAA,      (png_byte const   )0xEA,
        (png_byte const   )0x3A,      (png_byte const   )0x7A,      (png_byte const   )0xBA,      (png_byte const   )0xFA,
        (png_byte const   )0x0E,      (png_byte const   )0x4E,      (png_byte const   )0x8E,      (png_byte const   )0xCE,
        (png_byte const   )0x1E,      (png_byte const   )0x5E,      (png_byte const   )0x9E,      (png_byte const   )0xDE,
        (png_byte const   )0x2E,      (png_byte const   )0x6E,      (png_byte const   )0xAE,      (png_byte const   )0xEE,
        (png_byte const   )0x3E,      (png_byte const   )0x7E,      (png_byte const   )0xBE,      (png_byte const   )0xFE,
        (png_byte const   )0x03,      (png_byte const   )0x43,      (png_byte const   )0x83,      (png_byte const   )0xC3,
        (png_byte const   )0x13,      (png_byte const   )0x53,      (png_byte const   )0x93,      (png_byte const   )0xD3,
        (png_byte const   )0x23,      (png_byte const   )0x63,      (png_byte const   )0xA3,      (png_byte const   )0xE3,
        (png_byte const   )0x33,      (png_byte const   )0x73,      (png_byte const   )0xB3,      (png_byte const   )0xF3,
        (png_byte const   )0x07,      (png_byte const   )0x47,      (png_byte const   )0x87,      (png_byte const   )0xC7,
        (png_byte const   )0x17,      (png_byte const   )0x57,      (png_byte const   )0x97,      (png_byte const   )0xD7,
        (png_byte const   )0x27,      (png_byte const   )0x67,      (png_byte const   )0xA7,      (png_byte const   )0xE7,
        (png_byte const   )0x37,      (png_byte const   )0x77,      (png_byte const   )0xB7,      (png_byte const   )0xF7,
        (png_byte const   )0x0B,      (png_byte const   )0x4B,      (png_byte const   )0x8B,      (png_byte const   )0xCB,
        (png_byte const   )0x1B,      (png_byte const   )0x5B,      (png_byte const   )0x9B,      (png_byte const   )0xDB,
        (png_byte const   )0x2B,      (png_byte const   )0x6B,      (png_byte const   )0xAB,      (png_byte const   )0xEB,
        (png_byte const   )0x3B,      (png_byte const   )0x7B,      (png_byte const   )0xBB,      (png_byte const   )0xFB,
        (png_byte const   )0x0F,      (png_byte const   )0x4F,      (png_byte const   )0x8F,      (png_byte const   )0xCF,
        (png_byte const   )0x1F,      (png_byte const   )0x5F,      (png_byte const   )0x9F,      (png_byte const   )0xDF,
        (png_byte const   )0x2F,      (png_byte const   )0x6F,      (png_byte const   )0xAF,      (png_byte const   )0xEF,
        (png_byte const   )0x3F,      (png_byte const   )0x7F,      (png_byte const   )0xBF,      (png_byte const   )0xFF};
#line 418 "/home/goblint2/bench/libpng-1.6.39/pngtrans.c"
static png_byte const   fourbppswaptable[256]  =
#line 418
  {      (png_byte const   )0x00,      (png_byte const   )0x10,      (png_byte const   )0x20,      (png_byte const   )0x30,
        (png_byte const   )0x40,      (png_byte const   )0x50,      (png_byte const   )0x60,      (png_byte const   )0x70,
        (png_byte const   )0x80,      (png_byte const   )0x90,      (png_byte const   )0xA0,      (png_byte const   )0xB0,
        (png_byte const   )0xC0,      (png_byte const   )0xD0,      (png_byte const   )0xE0,      (png_byte const   )0xF0,
        (png_byte const   )0x01,      (png_byte const   )0x11,      (png_byte const   )0x21,      (png_byte const   )0x31,
        (png_byte const   )0x41,      (png_byte const   )0x51,      (png_byte const   )0x61,      (png_byte const   )0x71,
        (png_byte const   )0x81,      (png_byte const   )0x91,      (png_byte const   )0xA1,      (png_byte const   )0xB1,
        (png_byte const   )0xC1,      (png_byte const   )0xD1,      (png_byte const   )0xE1,      (png_byte const   )0xF1,
        (png_byte const   )0x02,      (png_byte const   )0x12,      (png_byte const   )0x22,      (png_byte const   )0x32,
        (png_byte const   )0x42,      (png_byte const   )0x52,      (png_byte const   )0x62,      (png_byte const   )0x72,
        (png_byte const   )0x82,      (png_byte const   )0x92,      (png_byte const   )0xA2,      (png_byte const   )0xB2,
        (png_byte const   )0xC2,      (png_byte const   )0xD2,      (png_byte const   )0xE2,      (png_byte const   )0xF2,
        (png_byte const   )0x03,      (png_byte const   )0x13,      (png_byte const   )0x23,      (png_byte const   )0x33,
        (png_byte const   )0x43,      (png_byte const   )0x53,      (png_byte const   )0x63,      (png_byte const   )0x73,
        (png_byte const   )0x83,      (png_byte const   )0x93,      (png_byte const   )0xA3,      (png_byte const   )0xB3,
        (png_byte const   )0xC3,      (png_byte const   )0xD3,      (png_byte const   )0xE3,      (png_byte const   )0xF3,
        (png_byte const   )0x04,      (png_byte const   )0x14,      (png_byte const   )0x24,      (png_byte const   )0x34,
        (png_byte const   )0x44,      (png_byte const   )0x54,      (png_byte const   )0x64,      (png_byte const   )0x74,
        (png_byte const   )0x84,      (png_byte const   )0x94,      (png_byte const   )0xA4,      (png_byte const   )0xB4,
        (png_byte const   )0xC4,      (png_byte const   )0xD4,      (png_byte const   )0xE4,      (png_byte const   )0xF4,
        (png_byte const   )0x05,      (png_byte const   )0x15,      (png_byte const   )0x25,      (png_byte const   )0x35,
        (png_byte const   )0x45,      (png_byte const   )0x55,      (png_byte const   )0x65,      (png_byte const   )0x75,
        (png_byte const   )0x85,      (png_byte const   )0x95,      (png_byte const   )0xA5,      (png_byte const   )0xB5,
        (png_byte const   )0xC5,      (png_byte const   )0xD5,      (png_byte const   )0xE5,      (png_byte const   )0xF5,
        (png_byte const   )0x06,      (png_byte const   )0x16,      (png_byte const   )0x26,      (png_byte const   )0x36,
        (png_byte const   )0x46,      (png_byte const   )0x56,      (png_byte const   )0x66,      (png_byte const   )0x76,
        (png_byte const   )0x86,      (png_byte const   )0x96,      (png_byte const   )0xA6,      (png_byte const   )0xB6,
        (png_byte const   )0xC6,      (png_byte const   )0xD6,      (png_byte const   )0xE6,      (png_byte const   )0xF6,
        (png_byte const   )0x07,      (png_byte const   )0x17,      (png_byte const   )0x27,      (png_byte const   )0x37,
        (png_byte const   )0x47,      (png_byte const   )0x57,      (png_byte const   )0x67,      (png_byte const   )0x77,
        (png_byte const   )0x87,      (png_byte const   )0x97,      (png_byte const   )0xA7,      (png_byte const   )0xB7,
        (png_byte const   )0xC7,      (png_byte const   )0xD7,      (png_byte const   )0xE7,      (png_byte const   )0xF7,
        (png_byte const   )0x08,      (png_byte const   )0x18,      (png_byte const   )0x28,      (png_byte const   )0x38,
        (png_byte const   )0x48,      (png_byte const   )0x58,      (png_byte const   )0x68,      (png_byte const   )0x78,
        (png_byte const   )0x88,      (png_byte const   )0x98,      (png_byte const   )0xA8,      (png_byte const   )0xB8,
        (png_byte const   )0xC8,      (png_byte const   )0xD8,      (png_byte const   )0xE8,      (png_byte const   )0xF8,
        (png_byte const   )0x09,      (png_byte const   )0x19,      (png_byte const   )0x29,      (png_byte const   )0x39,
        (png_byte const   )0x49,      (png_byte const   )0x59,      (png_byte const   )0x69,      (png_byte const   )0x79,
        (png_byte const   )0x89,      (png_byte const   )0x99,      (png_byte const   )0xA9,      (png_byte const   )0xB9,
        (png_byte const   )0xC9,      (png_byte const   )0xD9,      (png_byte const   )0xE9,      (png_byte const   )0xF9,
        (png_byte const   )0x0A,      (png_byte const   )0x1A,      (png_byte const   )0x2A,      (png_byte const   )0x3A,
        (png_byte const   )0x4A,      (png_byte const   )0x5A,      (png_byte const   )0x6A,      (png_byte const   )0x7A,
        (png_byte const   )0x8A,      (png_byte const   )0x9A,      (png_byte const   )0xAA,      (png_byte const   )0xBA,
        (png_byte const   )0xCA,      (png_byte const   )0xDA,      (png_byte const   )0xEA,      (png_byte const   )0xFA,
        (png_byte const   )0x0B,      (png_byte const   )0x1B,      (png_byte const   )0x2B,      (png_byte const   )0x3B,
        (png_byte const   )0x4B,      (png_byte const   )0x5B,      (png_byte const   )0x6B,      (png_byte const   )0x7B,
        (png_byte const   )0x8B,      (png_byte const   )0x9B,      (png_byte const   )0xAB,      (png_byte const   )0xBB,
        (png_byte const   )0xCB,      (png_byte const   )0xDB,      (png_byte const   )0xEB,      (png_byte const   )0xFB,
        (png_byte const   )0x0C,      (png_byte const   )0x1C,      (png_byte const   )0x2C,      (png_byte const   )0x3C,
        (png_byte const   )0x4C,      (png_byte const   )0x5C,      (png_byte const   )0x6C,      (png_byte const   )0x7C,
        (png_byte const   )0x8C,      (png_byte const   )0x9C,      (png_byte const   )0xAC,      (png_byte const   )0xBC,
        (png_byte const   )0xCC,      (png_byte const   )0xDC,      (png_byte const   )0xEC,      (png_byte const   )0xFC,
        (png_byte const   )0x0D,      (png_byte const   )0x1D,      (png_byte const   )0x2D,      (png_byte const   )0x3D,
        (png_byte const   )0x4D,      (png_byte const   )0x5D,      (png_byte const   )0x6D,      (png_byte const   )0x7D,
        (png_byte const   )0x8D,      (png_byte const   )0x9D,      (png_byte const   )0xAD,      (png_byte const   )0xBD,
        (png_byte const   )0xCD,      (png_byte const   )0xDD,      (png_byte const   )0xED,      (png_byte const   )0xFD,
        (png_byte const   )0x0E,      (png_byte const   )0x1E,      (png_byte const   )0x2E,      (png_byte const   )0x3E,
        (png_byte const   )0x4E,      (png_byte const   )0x5E,      (png_byte const   )0x6E,      (png_byte const   )0x7E,
        (png_byte const   )0x8E,      (png_byte const   )0x9E,      (png_byte const   )0xAE,      (png_byte const   )0xBE,
        (png_byte const   )0xCE,      (png_byte const   )0xDE,      (png_byte const   )0xEE,      (png_byte const   )0xFE,
        (png_byte const   )0x0F,      (png_byte const   )0x1F,      (png_byte const   )0x2F,      (png_byte const   )0x3F,
        (png_byte const   )0x4F,      (png_byte const   )0x5F,      (png_byte const   )0x6F,      (png_byte const   )0x7F,
        (png_byte const   )0x8F,      (png_byte const   )0x9F,      (png_byte const   )0xAF,      (png_byte const   )0xBF,
        (png_byte const   )0xCF,      (png_byte const   )0xDF,      (png_byte const   )0xEF,      (png_byte const   )0xFF};
#line 454 "/home/goblint2/bench/libpng-1.6.39/pngtrans.c"
void png_do_packswap(png_row_infop row_info , png_bytep row )
{
  png_bytep rp ;
  png_const_bytep end ;
  png_const_bytep table ;

  {
#line 459
  if ((int )row_info->bit_depth < 8) {
#line 464
    end = (png_const_bytep )(row + row_info->rowbytes);
#line 466
    if ((int )row_info->bit_depth == 1) {
#line 467
      table = onebppswaptable;
    } else
#line 469
    if ((int )row_info->bit_depth == 2) {
#line 470
      table = twobppswaptable;
    } else
#line 472
    if ((int )row_info->bit_depth == 4) {
#line 473
      table = fourbppswaptable;
    } else {
#line 476
      return;
    }
#line 478
    rp = row;
    {
#line 478
    while (1) {
      while_continue: /* CIL Label */ ;
#line 478
      if (! ((unsigned long )rp < (unsigned long )end)) {
#line 478
        goto while_break;
      }
#line 479
      *rp = (png_byte )*(table + *rp);
#line 478
      rp ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 481
  return;
}
}
#line 494 "/home/goblint2/bench/libpng-1.6.39/pngtrans.c"
void png_do_strip_channel(png_row_infop row_info , png_bytep row , int at_start )
{
  png_bytep sp ;
  png_bytep dp ;
  png_bytep ep ;
  png_bytep tmp ;
  png_bytep tmp___0 ;
  png_bytep tmp___1 ;
  png_bytep tmp___2 ;
  png_bytep tmp___3 ;
  png_bytep tmp___4 ;
  png_bytep tmp___5 ;
  png_bytep tmp___6 ;
  png_bytep tmp___7 ;
  png_bytep tmp___8 ;
  png_bytep tmp___9 ;
  png_bytep tmp___10 ;
  png_bytep tmp___11 ;
  png_bytep tmp___12 ;
  png_bytep tmp___13 ;
  png_bytep tmp___14 ;
  png_bytep tmp___15 ;
  png_bytep tmp___16 ;
  png_bytep tmp___17 ;
  png_bytep tmp___18 ;

  {
#line 497
  sp = row;
#line 498
  dp = row;
#line 499
  ep = row + row_info->rowbytes;
#line 510
  if ((int )row_info->channels == 2) {
#line 512
    if ((int )row_info->bit_depth == 8) {
#line 514
      if (at_start != 0) {
#line 515
        sp ++;
      } else {
#line 518
        sp += 2;
#line 518
        dp ++;
      }
      {
#line 522
      while (1) {
        while_continue: /* CIL Label */ ;
#line 522
        if (! ((unsigned long )sp < (unsigned long )ep)) {
#line 522
          goto while_break;
        }
#line 524
        tmp = dp;
#line 524
        dp ++;
#line 524
        *tmp = *sp;
#line 524
        sp += 2;
      }
      while_break: /* CIL Label */ ;
      }
#line 527
      row_info->pixel_depth = (png_byte )8;
    } else
#line 530
    if ((int )row_info->bit_depth == 16) {
#line 532
      if (at_start != 0) {
#line 533
        sp += 2;
      } else {
#line 536
        sp += 4;
#line 536
        dp += 2;
      }
      {
#line 539
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 539
        if (! ((unsigned long )sp < (unsigned long )ep)) {
#line 539
          goto while_break___0;
        }
#line 541
        tmp___0 = dp;
#line 541
        dp ++;
#line 541
        tmp___1 = sp;
#line 541
        sp ++;
#line 541
        *tmp___0 = *tmp___1;
#line 541
        tmp___2 = dp;
#line 541
        dp ++;
#line 541
        *tmp___2 = *sp;
#line 541
        sp += 3;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 544
      row_info->pixel_depth = (png_byte )16;
    } else {
#line 548
      return;
    }
#line 550
    row_info->channels = (png_byte )1;
#line 553
    if ((int )row_info->color_type == 4) {
#line 554
      row_info->color_type = (png_byte )0;
    }
  } else
#line 558
  if ((int )row_info->channels == 4) {
#line 560
    if ((int )row_info->bit_depth == 8) {
#line 562
      if (at_start != 0) {
#line 563
        sp ++;
      } else {
#line 566
        sp += 4;
#line 566
        dp += 3;
      }
      {
#line 570
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 570
        if (! ((unsigned long )sp < (unsigned long )ep)) {
#line 570
          goto while_break___1;
        }
#line 572
        tmp___3 = dp;
#line 572
        dp ++;
#line 572
        tmp___4 = sp;
#line 572
        sp ++;
#line 572
        *tmp___3 = *tmp___4;
#line 572
        tmp___5 = dp;
#line 572
        dp ++;
#line 572
        tmp___6 = sp;
#line 572
        sp ++;
#line 572
        *tmp___5 = *tmp___6;
#line 572
        tmp___7 = dp;
#line 572
        dp ++;
#line 572
        *tmp___7 = *sp;
#line 572
        sp += 2;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 575
      row_info->pixel_depth = (png_byte )24;
    } else
#line 578
    if ((int )row_info->bit_depth == 16) {
#line 580
      if (at_start != 0) {
#line 581
        sp += 2;
      } else {
#line 584
        sp += 8;
#line 584
        dp += 6;
      }
      {
#line 587
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 587
        if (! ((unsigned long )sp < (unsigned long )ep)) {
#line 587
          goto while_break___2;
        }
#line 590
        tmp___8 = dp;
#line 590
        dp ++;
#line 590
        tmp___9 = sp;
#line 590
        sp ++;
#line 590
        *tmp___8 = *tmp___9;
#line 590
        tmp___10 = dp;
#line 590
        dp ++;
#line 590
        tmp___11 = sp;
#line 590
        sp ++;
#line 590
        *tmp___10 = *tmp___11;
#line 591
        tmp___12 = dp;
#line 591
        dp ++;
#line 591
        tmp___13 = sp;
#line 591
        sp ++;
#line 591
        *tmp___12 = *tmp___13;
#line 591
        tmp___14 = dp;
#line 591
        dp ++;
#line 591
        tmp___15 = sp;
#line 591
        sp ++;
#line 591
        *tmp___14 = *tmp___15;
#line 592
        tmp___16 = dp;
#line 592
        dp ++;
#line 592
        tmp___17 = sp;
#line 592
        sp ++;
#line 592
        *tmp___16 = *tmp___17;
#line 592
        tmp___18 = dp;
#line 592
        dp ++;
#line 592
        *tmp___18 = *sp;
#line 592
        sp += 3;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 595
      row_info->pixel_depth = (png_byte )48;
    } else {
#line 599
      return;
    }
#line 601
    row_info->channels = (png_byte )3;
#line 604
    if ((int )row_info->color_type == 6) {
#line 605
      row_info->color_type = (png_byte )2;
    }
  } else {
#line 609
    return;
  }
#line 612
  row_info->rowbytes = (size_t )(dp - row);
#line 613
  return;
}
}
#line 618 "/home/goblint2/bench/libpng-1.6.39/pngtrans.c"
void png_do_bgr(png_row_infop row_info , png_bytep row )
{
  png_uint_32 row_width ;
  png_bytep rp ;
  png_uint_32 i ;
  png_byte save ;
  png_bytep rp___0 ;
  png_uint_32 i___0 ;
  png_byte save___0 ;
  png_bytep rp___1 ;
  png_uint_32 i___1 ;
  png_byte save___1 ;
  png_bytep rp___2 ;
  png_uint_32 i___2 ;
  png_byte save___2 ;

  {
#line 623
  if (((int )row_info->color_type & 2) != 0) {
#line 625
    row_width = row_info->width;
#line 626
    if ((int )row_info->bit_depth == 8) {
#line 628
      if ((int )row_info->color_type == 2) {
#line 633
        i = (png_uint_32 )0;
#line 633
        rp = row;
        {
#line 633
        while (1) {
          while_continue: /* CIL Label */ ;
#line 633
          if (! (i < row_width)) {
#line 633
            goto while_break;
          }
#line 635
          save = *rp;
#line 636
          *rp = *(rp + 2);
#line 637
          *(rp + 2) = save;
#line 633
          i ++;
#line 633
          rp += 3;
        }
        while_break: /* CIL Label */ ;
        }
      } else
#line 641
      if ((int )row_info->color_type == 6) {
#line 646
        i___0 = (png_uint_32 )0;
#line 646
        rp___0 = row;
        {
#line 646
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 646
          if (! (i___0 < row_width)) {
#line 646
            goto while_break___0;
          }
#line 648
          save___0 = *rp___0;
#line 649
          *rp___0 = *(rp___0 + 2);
#line 650
          *(rp___0 + 2) = save___0;
#line 646
          i___0 ++;
#line 646
          rp___0 += 4;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    } else
#line 656
    if ((int )row_info->bit_depth == 16) {
#line 658
      if ((int )row_info->color_type == 2) {
#line 663
        i___1 = (png_uint_32 )0;
#line 663
        rp___1 = row;
        {
#line 663
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 663
          if (! (i___1 < row_width)) {
#line 663
            goto while_break___1;
          }
#line 665
          save___1 = *rp___1;
#line 666
          *rp___1 = *(rp___1 + 4);
#line 667
          *(rp___1 + 4) = save___1;
#line 668
          save___1 = *(rp___1 + 1);
#line 669
          *(rp___1 + 1) = *(rp___1 + 5);
#line 670
          *(rp___1 + 5) = save___1;
#line 663
          i___1 ++;
#line 663
          rp___1 += 6;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else
#line 674
      if ((int )row_info->color_type == 6) {
#line 679
        i___2 = (png_uint_32 )0;
#line 679
        rp___2 = row;
        {
#line 679
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 679
          if (! (i___2 < row_width)) {
#line 679
            goto while_break___2;
          }
#line 681
          save___2 = *rp___2;
#line 682
          *rp___2 = *(rp___2 + 4);
#line 683
          *(rp___2 + 4) = save___2;
#line 684
          save___2 = *(rp___2 + 1);
#line 685
          *(rp___2 + 1) = *(rp___2 + 5);
#line 686
          *(rp___2 + 5) = save___2;
#line 679
          i___2 ++;
#line 679
          rp___2 += 8;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
  }
#line 692
  return;
}
}
#line 698 "/home/goblint2/bench/libpng-1.6.39/pngtrans.c"
void png_do_check_palette_indexes(png_structrp png_ptr , png_row_infop row_info )
{
  int padding ;
  png_bytep rp ;
  int i ;
  int i___0 ;

  {
#line 701
  if ((int )png_ptr->num_palette < 1 << (int )row_info->bit_depth) {
#line 701
    if ((int )png_ptr->num_palette > 0) {
#line 710
      padding = (int )((8U - ((unsigned int )row_info->pixel_depth * (row_info->width % 8U)) % 8U) % 8U);
#line 711
      rp = (png_ptr->row_buf + row_info->rowbytes) - 1;
      {
#line 715
      if ((int )row_info->bit_depth == 1) {
#line 715
        goto case_1;
      }
#line 730
      if ((int )row_info->bit_depth == 2) {
#line 730
        goto case_2;
      }
#line 760
      if ((int )row_info->bit_depth == 4) {
#line 760
        goto case_4;
      }
#line 780
      if ((int )row_info->bit_depth == 8) {
#line 780
        goto case_8;
      }
#line 791
      goto switch_default;
      case_1: /* CIL Label */
      {
#line 720
      while (1) {
        while_continue: /* CIL Label */ ;
#line 720
        if (! ((unsigned long )rp > (unsigned long )png_ptr->row_buf)) {
#line 720
          goto while_break;
        }
#line 722
        if ((int )*rp >> padding != 0) {
#line 723
          png_ptr->num_palette_max = 1;
        }
#line 724
        padding = 0;
#line 720
        rp --;
      }
      while_break: /* CIL Label */ ;
      }
#line 727
      goto switch_break;
      case_2: /* CIL Label */
      {
#line 732
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 732
        if (! ((unsigned long )rp > (unsigned long )png_ptr->row_buf)) {
#line 732
          goto while_break___0;
        }
#line 734
        i = ((int )*rp >> padding) & 0x03;
#line 736
        if (i > png_ptr->num_palette_max) {
#line 737
          png_ptr->num_palette_max = i;
        }
#line 739
        i = (((int )*rp >> padding) >> 2) & 0x03;
#line 741
        if (i > png_ptr->num_palette_max) {
#line 742
          png_ptr->num_palette_max = i;
        }
#line 744
        i = (((int )*rp >> padding) >> 4) & 0x03;
#line 746
        if (i > png_ptr->num_palette_max) {
#line 747
          png_ptr->num_palette_max = i;
        }
#line 749
        i = (((int )*rp >> padding) >> 6) & 0x03;
#line 751
        if (i > png_ptr->num_palette_max) {
#line 752
          png_ptr->num_palette_max = i;
        }
#line 754
        padding = 0;
#line 732
        rp --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 757
      goto switch_break;
      case_4: /* CIL Label */
      {
#line 762
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 762
        if (! ((unsigned long )rp > (unsigned long )png_ptr->row_buf)) {
#line 762
          goto while_break___1;
        }
#line 764
        i___0 = ((int )*rp >> padding) & 0x0f;
#line 766
        if (i___0 > png_ptr->num_palette_max) {
#line 767
          png_ptr->num_palette_max = i___0;
        }
#line 769
        i___0 = (((int )*rp >> padding) >> 4) & 0x0f;
#line 771
        if (i___0 > png_ptr->num_palette_max) {
#line 772
          png_ptr->num_palette_max = i___0;
        }
#line 774
        padding = 0;
#line 762
        rp --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 777
      goto switch_break;
      case_8: /* CIL Label */
      {
#line 782
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 782
        if (! ((unsigned long )rp > (unsigned long )png_ptr->row_buf)) {
#line 782
          goto while_break___2;
        }
#line 784
        if ((int )*rp > png_ptr->num_palette_max) {
#line 785
          png_ptr->num_palette_max = (int )*rp;
        }
#line 782
        rp --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 788
      goto switch_break;
      switch_default: /* CIL Label */
#line 792
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 795
  return;
}
}
#line 801 "/home/goblint2/bench/libpng-1.6.39/pngtrans.c"
void png_set_user_transform_info(png_structrp png_ptr , png_voidp user_transform_ptr ,
                                 int user_transform_depth , int user_transform_channels )
{


  {
#line 807
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 808
    return;
  }
#line 811
  if ((png_ptr->mode & 0x8000U) != 0U) {
#line 811
    if ((png_ptr->flags & 0x0040U) != 0U) {
#line 814
      png_app_error((png_const_structrp )png_ptr, (png_const_charp )"info change after png_start_read_image or png_read_update_info");
#line 816
      return;
    }
  }
#line 820
  png_ptr->user_transform_ptr = user_transform_ptr;
#line 821
  png_ptr->user_transform_depth = (png_byte )user_transform_depth;
#line 822
  png_ptr->user_transform_channels = (png_byte )user_transform_channels;
#line 823
  return;
}
}
#line 832 "/home/goblint2/bench/libpng-1.6.39/pngtrans.c"
png_voidp png_get_user_transform_ptr(png_const_structrp png_ptr )
{


  {
#line 835
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 836
    return ((void *)0);
  }
#line 838
  return ((png_voidp )png_ptr->user_transform_ptr);
}
}
#line 843 "/home/goblint2/bench/libpng-1.6.39/pngtrans.c"
png_uint_32 png_get_current_row_number(png_const_structrp png_ptr )
{


  {
#line 849
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 850
    return ((png_uint_32 )png_ptr->row_number);
  }
#line 852
  return ((png_uint_32 )-1);
}
}
#line 855 "/home/goblint2/bench/libpng-1.6.39/pngtrans.c"
png_byte png_get_current_pass_number(png_const_structrp png_ptr )
{


  {
#line 858
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 859
    return ((png_byte )png_ptr->pass);
  }
#line 860
  return ((png_byte )8);
}
}
#line 101 "/usr/include/stdlib.h"
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 104
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 107
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 112
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__leaf__, __gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__,
__nothrow__)) ;
#line 820
__inline extern void *( __attribute__((__warn_unused_result__, __nonnull__(1,2,5),
__gnu_inline__)) bsearch)(void const   *__key , void const   *__base , size_t __nmemb ,
                          size_t __size , int (*__compar)(void const   * , void const   * ) ) ;
#line 929
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar )  __attribute__((__nothrow__)) ;
#line 933
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t *__dst , char const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 936
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) wcstombs)(char *__dst , wchar_t const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 43 "/usr/include/string.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memcpy)(void *__dest , void const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 47
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 61
__inline extern void *( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) memset)(void *__dest , int __ch , size_t __len )  __attribute__((__nothrow__)) ;
#line 122
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcpy)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 125
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncpy)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 130
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcat)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 133
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncat)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 326 "/usr/include/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) fprintf)(FILE *__stream ,
                                                                                                  char const   *__fmt
                                                                                                  , ...) ;
#line 332
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) printf)(char const   *__fmt
                                                                                                 , ...) ;
#line 334
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) sprintf)(char *__s ,
                                                                                                            char const   *__fmt
                                                                                                            , ...)  __attribute__((__nothrow__)) ;
#line 341
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vfprintf)(FILE *__stream ,
                                                                                                   char const   *__fmt ,
                                                                                                   __gnuc_va_list __ap ) ;
#line 347
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vprintf)(char const   *__fmt ,
                                                                                                  __gnuc_va_list __ap ) ;
#line 349
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vsprintf)(char *__s ,
                                                                                                             char const   *__fmt ,
                                                                                                             __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 354
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) snprintf)(char *__s , size_t __n , char const   *__fmt
                                              , ...)  __attribute__((__nothrow__)) ;
#line 358
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) vsnprintf)(char *__s , size_t __n , char const   *__fmt ,
                                               __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 492
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
#line 528
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
#line 564
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fgets)(char *__s , int __n , FILE *__stream ) ;
#line 646
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fread)(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 360 "/usr/include/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) read)(int __fd , void *__buf , size_t __nbytes ) ;
#line 511
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size )  __attribute__((__nothrow__)) ;
#line 689
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list )  __attribute__((__nothrow__)) ;
#line 774
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                               size_t __buflen )  __attribute__((__nothrow__)) ;
#line 32 "/home/goblint2/bench/libpng-1.6.39/pngwio.c"
void png_write_data(png_structrp png_ptr , png_const_bytep data , size_t length )
{


  {
#line 36
  if ((unsigned long )png_ptr->write_data_fn != (unsigned long )((void *)0)) {
#line 37
    (*(png_ptr->write_data_fn))((png_structp )png_ptr, (png_bytep )((void *)((void const   *)data)),
                                length);
  } else {
#line 41
    png_error((png_const_structrp )png_ptr, (png_const_charp )"Call to NULL write function");
  }
#line 42
  return;
}
}
#line 50 "/home/goblint2/bench/libpng-1.6.39/pngwio.c"
void png_default_write_data(png_structp png_ptr , png_bytep data , size_t length )
{
  size_t check___0 ;

  {
#line 55
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 56
    return;
  }
#line 58
  check___0 = fwrite((void const   * __restrict  )data, (size_t )1, length, (FILE * __restrict  )((png_FILE_p )png_ptr->io_ptr));
#line 60
  if (check___0 != length) {
#line 61
    png_error((png_const_structrp )png_ptr, (png_const_charp )"Write Error");
  }
#line 62
  return;
}
}
#line 70 "/home/goblint2/bench/libpng-1.6.39/pngwio.c"
void png_flush(png_structrp png_ptr )
{


  {
#line 73
  if ((unsigned long )png_ptr->output_flush_fn != (unsigned long )((void *)0)) {
#line 74
    (*(png_ptr->output_flush_fn))((png_structp )png_ptr);
  }
#line 75
  return;
}
}
#line 78 "/home/goblint2/bench/libpng-1.6.39/pngwio.c"
void png_default_flush(png_structp png_ptr )
{
  png_FILE_p io_ptr ;

  {
#line 83
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 84
    return;
  }
#line 86
  io_ptr = (png_FILE_p )png_ptr->io_ptr;
#line 87
  fflush(io_ptr);
#line 88
  return;
}
}
#line 121 "/home/goblint2/bench/libpng-1.6.39/pngwio.c"
void png_set_write_fn(png_structrp png_ptr , png_voidp io_ptr , void (*write_data_fn)(png_structp  ,
                                                                                      png_bytep  ,
                                                                                      size_t  ) ,
                      void (*output_flush_fn)(png_structp  ) )
{


  {
#line 125
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 126
    return;
  }
#line 128
  png_ptr->io_ptr = io_ptr;
#line 131
  if ((unsigned long )write_data_fn != (unsigned long )((void *)0)) {
#line 132
    png_ptr->write_data_fn = write_data_fn;
  } else {
#line 135
    png_ptr->write_data_fn = & png_default_write_data;
  }
#line 143
  if ((unsigned long )output_flush_fn != (unsigned long )((void *)0)) {
#line 144
    png_ptr->output_flush_fn = output_flush_fn;
  } else {
#line 147
    png_ptr->output_flush_fn = & png_default_flush;
  }
#line 158
  if ((unsigned long )png_ptr->read_data_fn != (unsigned long )((void *)0)) {
#line 160
    png_ptr->read_data_fn = (void (*)(png_structp  , png_bytep  , size_t  ))((void *)0);
#line 162
    png_warning((png_const_structrp )png_ptr, (png_const_charp )"Can\'t set both read_data_fn and write_data_fn in the same structure");
  }
#line 167
  return;
}
}
#line 101 "/usr/include/stdlib.h"
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 104
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 107
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 112
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__leaf__, __gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__,
__nothrow__)) ;
#line 820
__inline extern void *( __attribute__((__warn_unused_result__, __nonnull__(1,2,5),
__gnu_inline__)) bsearch)(void const   *__key , void const   *__base , size_t __nmemb ,
                          size_t __size , int (*__compar)(void const   * , void const   * ) ) ;
#line 929
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar )  __attribute__((__nothrow__)) ;
#line 933
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t *__dst , char const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 936
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) wcstombs)(char *__dst , wchar_t const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 43 "/usr/include/string.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memcpy)(void *__dest , void const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 47
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 61
__inline extern void *( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) memset)(void *__dest , int __ch , size_t __len )  __attribute__((__nothrow__)) ;
#line 122
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcpy)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 125
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncpy)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 130
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcat)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 133
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncat)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 326 "/usr/include/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) fprintf)(FILE *__stream ,
                                                                                                  char const   *__fmt
                                                                                                  , ...) ;
#line 332
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) printf)(char const   *__fmt
                                                                                                 , ...) ;
#line 334
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) sprintf)(char *__s ,
                                                                                                            char const   *__fmt
                                                                                                            , ...)  __attribute__((__nothrow__)) ;
#line 341
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vfprintf)(FILE *__stream ,
                                                                                                   char const   *__fmt ,
                                                                                                   __gnuc_va_list __ap ) ;
#line 347
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vprintf)(char const   *__fmt ,
                                                                                                  __gnuc_va_list __ap ) ;
#line 349
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vsprintf)(char *__s ,
                                                                                                             char const   *__fmt ,
                                                                                                             __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 354
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) snprintf)(char *__s , size_t __n , char const   *__fmt
                                              , ...)  __attribute__((__nothrow__)) ;
#line 358
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) vsnprintf)(char *__s , size_t __n , char const   *__fmt ,
                                               __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 492
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
#line 528
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
#line 564
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fgets)(char *__s , int __n , FILE *__stream ) ;
#line 646
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fread)(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 360 "/usr/include/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) read)(int __fd , void *__buf , size_t __nbytes ) ;
#line 511
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size )  __attribute__((__nothrow__)) ;
#line 689
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list )  __attribute__((__nothrow__)) ;
#line 774
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                               size_t __buflen )  __attribute__((__nothrow__)) ;
#line 23 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
static void write_unknown_chunks(png_structrp png_ptr , png_const_inforp info_ptr ,
                                 unsigned int where )
{
  png_const_unknown_chunkp up ;
  int keep ;
  int tmp ;

  {
#line 27
  if (info_ptr->unknown_chunks_num != 0) {
#line 33
    up = (png_const_unknown_chunkp )info_ptr->unknown_chunks;
    {
#line 33
    while (1) {
      while_continue: /* CIL Label */ ;
#line 33
      if (! ((unsigned long )up < (unsigned long )(info_ptr->unknown_chunks + info_ptr->unknown_chunks_num))) {
#line 33
        goto while_break;
      }
#line 36
      if (((unsigned int )up->location & where) != 0U) {
#line 42
        tmp = png_handle_as_unknown((png_const_structrp )png_ptr, (png_const_bytep )(up->name));
#line 42
        keep = tmp;
#line 56
        if (keep != 1) {
#line 56
          if ((int )up->name[3] & 0x20) {
#line 56
            goto _L;
          } else
#line 56
          if (keep == 3) {
#line 56
            goto _L;
          } else
#line 56
          if (keep == 0) {
#line 56
            if (png_ptr->unknown_default == 3) {
              _L: /* CIL Label */
#line 64
              if (up->size == 0UL) {
#line 65
                png_warning((png_const_structrp )png_ptr, (png_const_charp )"Writing zero-length unknown chunk");
              }
#line 67
              png_write_chunk(png_ptr, (png_const_bytep )(up->name), (png_const_bytep )up->data,
                              (size_t )up->size);
            }
          }
        }
      }
#line 33
      up ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 71
  return;
}
}
#line 83 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
void png_write_info_before_PLTE(png_structrp png_ptr , png_const_inforp info_ptr )
{


  {
#line 88
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 89
    return;
  } else
#line 88
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 89
    return;
  }
#line 91
  if ((png_ptr->mode & 0x400U) == 0U) {
#line 94
    png_write_sig(png_ptr);
#line 97
    if ((png_ptr->mode & 0x1000U) != 0U) {
#line 97
      if (png_ptr->mng_features_permitted != 0U) {
#line 100
        png_warning((png_const_structrp )png_ptr, (png_const_charp )"MNG features are not allowed in a PNG datastream");
#line 102
        png_ptr->mng_features_permitted = (png_uint_32 )0;
      }
    }
#line 107
    png_write_IHDR(png_ptr, (png_uint_32 )info_ptr->width, (png_uint_32 )info_ptr->height,
                   (int )info_ptr->bit_depth, (int )info_ptr->color_type, (int )info_ptr->compression_type,
                   (int )info_ptr->filter_type, (int )info_ptr->interlace_type);
#line 133
    if (((int )info_ptr->colorspace.flags & 32768) == 0) {
#line 133
      if (((int )info_ptr->colorspace.flags & 8) != 0) {
#line 133
        if ((info_ptr->valid & 1U) != 0U) {
#line 136
          png_write_gAMA_fixed(png_ptr, (png_fixed_point )info_ptr->colorspace.gamma);
        }
      }
    }
#line 145
    if (((int )info_ptr->colorspace.flags & 32768) == 0) {
#line 145
      if ((info_ptr->valid & 4096U) != 0U) {
#line 149
        if ((info_ptr->valid & 2048U) != 0U) {
#line 150
          png_app_warning((png_const_structrp )png_ptr, (png_const_charp )"profile matches sRGB but writing iCCP instead");
        }
#line 154
        png_write_iCCP(png_ptr, (png_const_charp )info_ptr->iccp_name, (png_const_bytep )info_ptr->iccp_profile);
      } else {
#line 145
        goto _L;
      }
    } else
    _L: /* CIL Label */
#line 163
    if (((int )info_ptr->colorspace.flags & 32768) == 0) {
#line 163
      if ((info_ptr->valid & 2048U) != 0U) {
#line 165
        png_write_sRGB(png_ptr, (int )info_ptr->colorspace.rendering_intent);
      }
    }
#line 170
    if ((info_ptr->valid & 2U) != 0U) {
#line 171
      png_write_sBIT(png_ptr, (png_const_color_8p )(& info_ptr->sig_bit), (int )info_ptr->color_type);
    }
#line 176
    if (((int )info_ptr->colorspace.flags & 32768) == 0) {
#line 176
      if (((int )info_ptr->colorspace.flags & 16) != 0) {
#line 176
        if ((info_ptr->valid & 4U) != 0U) {
#line 179
          png_write_cHRM_fixed(png_ptr, (png_xy const   *)(& info_ptr->colorspace.end_points_xy));
        }
      }
    }
#line 184
    write_unknown_chunks(png_ptr, info_ptr, 1U);
#line 187
    png_ptr->mode |= 0x400U;
  }
#line 189
  return;
}
}
#line 191 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
void png_write_info(png_structrp png_ptr , png_const_inforp info_ptr )
{
  int i ;
  int j ;
  int jend ;

  {
#line 200
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 201
    return;
  } else
#line 200
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 201
    return;
  }
#line 203
  png_write_info_before_PLTE(png_ptr, info_ptr);
#line 205
  if ((info_ptr->valid & 8U) != 0U) {
#line 206
    png_write_PLTE(png_ptr, (png_const_colorp )info_ptr->palette, (png_uint_32 )info_ptr->num_palette);
  } else
#line 209
  if ((int )info_ptr->color_type == 3) {
#line 210
    png_error((png_const_structrp )png_ptr, (png_const_charp )"Valid palette required for paletted images");
  }
#line 213
  if ((info_ptr->valid & 16U) != 0U) {
#line 217
    if ((png_ptr->transformations & 0x80000U) != 0U) {
#line 217
      if ((int )info_ptr->color_type == 3) {
#line 222
        jend = (int )info_ptr->num_trans;
#line 223
        if (jend > 256) {
#line 224
          jend = 256;
        }
#line 226
        j = 0;
        {
#line 226
        while (1) {
          while_continue: /* CIL Label */ ;
#line 226
          if (! (j < jend)) {
#line 226
            goto while_break;
          }
#line 227
          *(info_ptr->trans_alpha + j) = (png_byte )(255 - (int )*(info_ptr->trans_alpha + j));
#line 226
          j ++;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
#line 231
    png_write_tRNS(png_ptr, (png_const_bytep )info_ptr->trans_alpha, (png_const_color_16p )(& info_ptr->trans_color),
                   (int )info_ptr->num_trans, (int )info_ptr->color_type);
  }
#line 236
  if ((info_ptr->valid & 32U) != 0U) {
#line 237
    png_write_bKGD(png_ptr, (png_const_color_16p )(& info_ptr->background), (int )info_ptr->color_type);
  }
#line 241
  if ((info_ptr->valid & 65536U) != 0U) {
#line 242
    png_write_eXIf(png_ptr, (png_bytep )info_ptr->exif, (int )info_ptr->num_exif);
  }
#line 246
  if ((info_ptr->valid & 64U) != 0U) {
#line 247
    png_write_hIST(png_ptr, (png_const_uint_16p )info_ptr->hist, (int )info_ptr->num_palette);
  }
#line 251
  if ((info_ptr->valid & 256U) != 0U) {
#line 252
    png_write_oFFs(png_ptr, (png_int_32 )info_ptr->x_offset, (png_int_32 )info_ptr->y_offset,
                   (int )info_ptr->offset_unit_type);
  }
#line 257
  if ((info_ptr->valid & 1024U) != 0U) {
#line 258
    png_write_pCAL(png_ptr, (png_charp )info_ptr->pcal_purpose, (png_int_32 )info_ptr->pcal_X0,
                   (png_int_32 )info_ptr->pcal_X1, (int )info_ptr->pcal_type, (int )info_ptr->pcal_nparams,
                   (png_const_charp )info_ptr->pcal_units, (png_charpp )info_ptr->pcal_params);
  }
#line 264
  if ((info_ptr->valid & 16384U) != 0U) {
#line 265
    png_write_sCAL_s(png_ptr, (int )info_ptr->scal_unit, (png_const_charp )info_ptr->scal_s_width,
                     (png_const_charp )info_ptr->scal_s_height);
  }
#line 270
  if ((info_ptr->valid & 128U) != 0U) {
#line 271
    png_write_pHYs(png_ptr, (png_uint_32 )info_ptr->x_pixels_per_unit, (png_uint_32 )info_ptr->y_pixels_per_unit,
                   (int )info_ptr->phys_unit_type);
  }
#line 276
  if ((info_ptr->valid & 512U) != 0U) {
#line 278
    png_write_tIME(png_ptr, (png_const_timep )(& info_ptr->mod_time));
#line 279
    png_ptr->mode |= 0x200U;
  }
#line 284
  if ((info_ptr->valid & 8192U) != 0U) {
#line 285
    i = 0;
    {
#line 285
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 285
      if (! (i < (int )info_ptr->splt_palettes_num)) {
#line 285
        goto while_break___0;
      }
#line 286
      png_write_sPLT(png_ptr, (png_const_sPLT_tp )(info_ptr->splt_palettes + i));
#line 285
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 291
  i = 0;
  {
#line 291
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 291
    if (! (i < (int )info_ptr->num_text)) {
#line 291
      goto while_break___1;
    }
#line 296
    if ((info_ptr->text + i)->compression > 0) {
#line 300
      png_write_iTXt(png_ptr, (info_ptr->text + i)->compression, (png_const_charp )(info_ptr->text + i)->key,
                     (png_const_charp )(info_ptr->text + i)->lang, (png_const_charp )(info_ptr->text + i)->lang_key,
                     (png_const_charp )(info_ptr->text + i)->text);
#line 307
      if ((info_ptr->text + i)->compression == -1) {
#line 308
        (info_ptr->text + i)->compression = -3;
      } else {
#line 310
        (info_ptr->text + i)->compression = -2;
      }
    } else
#line 317
    if ((info_ptr->text + i)->compression == 0) {
#line 321
      png_write_zTXt(png_ptr, (png_const_charp )(info_ptr->text + i)->key, (png_const_charp )(info_ptr->text + i)->text,
                     (info_ptr->text + i)->compression);
#line 324
      (info_ptr->text + i)->compression = -2;
    } else
#line 330
    if ((info_ptr->text + i)->compression == -1) {
#line 334
      png_write_tEXt(png_ptr, (png_const_charp )(info_ptr->text + i)->key, (png_const_charp )(info_ptr->text + i)->text,
                     (size_t )0);
#line 338
      (info_ptr->text + i)->compression = -3;
    }
#line 291
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 348
  write_unknown_chunks(png_ptr, info_ptr, 2U);
#line 350
  return;
}
}
#line 357 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
void png_write_end(png_structrp png_ptr , png_inforp info_ptr )
{
  int i ;

  {
#line 362
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 363
    return;
  }
#line 365
  if ((png_ptr->mode & 0x04U) == 0U) {
#line 366
    png_error((png_const_structrp )png_ptr, (png_const_charp )"No IDATs written into file");
  }
#line 369
  if (png_ptr->num_palette_max > (int )png_ptr->num_palette) {
#line 370
    png_benign_error((png_const_structrp )png_ptr, (png_const_charp )"Wrote palette index exceeding num_palette");
  }
#line 374
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 381
    if ((info_ptr->valid & 0x0200U) != 0U) {
#line 381
      if ((png_ptr->mode & 0x200U) == 0U) {
#line 383
        png_write_tIME(png_ptr, (png_const_timep )(& info_ptr->mod_time));
      }
    }
#line 388
    i = 0;
    {
#line 388
    while (1) {
      while_continue: /* CIL Label */ ;
#line 388
      if (! (i < info_ptr->num_text)) {
#line 388
        goto while_break;
      }
#line 393
      if ((info_ptr->text + i)->compression > 0) {
#line 397
        png_write_iTXt(png_ptr, (info_ptr->text + i)->compression, (png_const_charp )(info_ptr->text + i)->key,
                       (png_const_charp )(info_ptr->text + i)->lang, (png_const_charp )(info_ptr->text + i)->lang_key,
                       (png_const_charp )(info_ptr->text + i)->text);
#line 404
        if ((info_ptr->text + i)->compression == -1) {
#line 405
          (info_ptr->text + i)->compression = -3;
        } else {
#line 407
          (info_ptr->text + i)->compression = -2;
        }
      } else
#line 413
      if ((info_ptr->text + i)->compression >= 0) {
#line 417
        png_write_zTXt(png_ptr, (png_const_charp )(info_ptr->text + i)->key, (png_const_charp )(info_ptr->text + i)->text,
                       (info_ptr->text + i)->compression);
#line 420
        (info_ptr->text + i)->compression = -2;
      } else
#line 426
      if ((info_ptr->text + i)->compression == -1) {
#line 430
        png_write_tEXt(png_ptr, (png_const_charp )(info_ptr->text + i)->key, (png_const_charp )(info_ptr->text + i)->text,
                       (size_t )0);
#line 433
        (info_ptr->text + i)->compression = -3;
      }
#line 388
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 442
    if ((info_ptr->valid & 0x10000U) != 0U) {
#line 443
      png_write_eXIf(png_ptr, info_ptr->exif, info_ptr->num_exif);
    }
#line 447
    write_unknown_chunks(png_ptr, (png_const_inforp )info_ptr, 8U);
  }
#line 451
  png_ptr->mode |= 8U;
#line 454
  png_write_IEND(png_ptr);
#line 468
  return;
}
}
#line 471 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
void png_convert_from_struct_tm(png_timep ptime , struct tm  const  *ttime )
{


  {
#line 476
  ptime->year = (png_uint_16 )(1900 + (int )ttime->tm_year);
#line 477
  ptime->month = (png_byte )(ttime->tm_mon + 1);
#line 478
  ptime->day = (png_byte )ttime->tm_mday;
#line 479
  ptime->hour = (png_byte )ttime->tm_hour;
#line 480
  ptime->minute = (png_byte )ttime->tm_min;
#line 481
  ptime->second = (png_byte )ttime->tm_sec;
#line 482
  return;
}
}
#line 484 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
void png_convert_from_time_t(png_timep ptime , time_t ttime )
{
  struct tm *tbuf ;

  {
#line 491
  tbuf = gmtime((time_t const   *)(& ttime));
#line 492
  if ((unsigned long )tbuf == (unsigned long )((void *)0)) {
#line 498
    memset((void *)ptime, 0, sizeof(*ptime));
#line 499
    return;
  }
#line 502
  png_convert_from_struct_tm(ptime, (struct tm  const  *)tbuf);
#line 503
  return;
}
}
#line 507 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
png_structp __attribute__((__malloc__))  png_create_write_struct(png_const_charp user_png_ver ,
                                                                 png_voidp error_ptr ,
                                                                 void (*error_fn)(png_structp  ,
                                                                                  png_const_charp  ) ,
                                                                 void (*warn_fn)(png_structp  ,
                                                                                 png_const_charp  ) )
{
  png_structp __attribute__((__malloc__))  tmp ;

  {
#line 515
  tmp = png_create_write_struct_2(user_png_ver, error_ptr, error_fn, warn_fn, (void *)0,
                                  (png_voidp (*)(png_structp  , png_alloc_size_t  ))((void *)0),
                                  (void (*)(png_structp  , png_voidp  ))((void *)0));
#line 515
  return (tmp);
}
}
#line 520 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
png_structp __attribute__((__malloc__))  png_create_write_struct_2(png_const_charp user_png_ver ,
                                                                   png_voidp error_ptr ,
                                                                   void (*error_fn)(png_structp  ,
                                                                                    png_const_charp  ) ,
                                                                   void (*warn_fn)(png_structp  ,
                                                                                   png_const_charp  ) ,
                                                                   png_voidp mem_ptr ,
                                                                   png_voidp (*malloc_fn)(png_structp  ,
                                                                                          png_alloc_size_t  ) ,
                                                                   void (*free_fn)(png_structp  ,
                                                                                   png_voidp  ) )
{
  png_structrp png_ptr ;
  png_structp __attribute__((__malloc__))  tmp ;

  {
#line 525
  tmp = png_create_png_struct(user_png_ver, error_ptr, error_fn, warn_fn, mem_ptr,
                              malloc_fn, free_fn);
#line 525
  png_ptr = (png_structrp )tmp;
#line 528
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 533
    png_ptr->zbuffer_size = (uInt )8192;
#line 539
    png_ptr->zlib_strategy = 1;
#line 540
    png_ptr->zlib_level = -1;
#line 541
    png_ptr->zlib_mem_level = 8;
#line 542
    png_ptr->zlib_window_bits = 15;
#line 543
    png_ptr->zlib_method = 8;
#line 546
    png_ptr->zlib_text_strategy = 0;
#line 547
    png_ptr->zlib_text_level = -1;
#line 548
    png_ptr->zlib_text_mem_level = 8;
#line 549
    png_ptr->zlib_text_window_bits = 15;
#line 550
    png_ptr->zlib_text_method = 8;
#line 569
    png_ptr->flags |= 0x200000U;
#line 576
    png_set_write_fn(png_ptr, (void *)0, (void (*)(png_structp  , png_bytep  , size_t  ))((void *)0),
                     (void (*)(png_structp  ))((void *)0));
  }
#line 579
  return ((png_structp __attribute__((__malloc__))  )png_ptr);
}
}
#line 588 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
void png_write_rows(png_structrp png_ptr , png_bytepp row , png_uint_32 num_rows )
{
  png_uint_32 i ;
  png_bytepp rp ;

  {
#line 597
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 598
    return;
  }
#line 601
  i = (png_uint_32 )0;
#line 601
  rp = row;
  {
#line 601
  while (1) {
    while_continue: /* CIL Label */ ;
#line 601
    if (! (i < num_rows)) {
#line 601
      goto while_break;
    }
#line 603
    png_write_row(png_ptr, (png_const_bytep )*rp);
#line 601
    i ++;
#line 601
    rp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 605
  return;
}
}
#line 610 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
void png_write_image(png_structrp png_ptr , png_bytepp image )
{
  png_uint_32 i ;
  int pass ;
  int num_pass ;
  png_bytepp rp ;

  {
#line 617
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 618
    return;
  }
#line 626
  num_pass = png_set_interlace_handling(png_ptr);
#line 631
  pass = 0;
  {
#line 631
  while (1) {
    while_continue: /* CIL Label */ ;
#line 631
    if (! (pass < num_pass)) {
#line 631
      goto while_break;
    }
#line 634
    i = (png_uint_32 )0;
#line 634
    rp = image;
    {
#line 634
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 634
      if (! (i < png_ptr->height)) {
#line 634
        goto while_break___0;
      }
#line 636
      png_write_row(png_ptr, (png_const_bytep )*rp);
#line 634
      i ++;
#line 634
      rp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 631
    pass ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 639
  return;
}
}
#line 643 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
static void png_do_write_intrapixel(png_row_infop row_info , png_bytep row )
{
  int bytes_per_pixel ;
  png_uint_32 row_width ;
  png_bytep rp ;
  png_uint_32 i ;
  png_bytep rp___0 ;
  png_uint_32 i___0 ;
  png_uint_32 s0 ;
  png_uint_32 s1 ;
  png_uint_32 s2 ;
  png_uint_32 red ;
  png_uint_32 blue ;

  {
#line 648
  if (((int )row_info->color_type & 2) != 0) {
#line 651
    row_width = row_info->width;
#line 652
    if ((int )row_info->bit_depth == 8) {
#line 657
      if ((int )row_info->color_type == 2) {
#line 658
        bytes_per_pixel = 3;
      } else
#line 660
      if ((int )row_info->color_type == 6) {
#line 661
        bytes_per_pixel = 4;
      } else {
#line 664
        return;
      }
#line 666
      i = (png_uint_32 )0;
#line 666
      rp = row;
      {
#line 666
      while (1) {
        while_continue: /* CIL Label */ ;
#line 666
        if (! (i < row_width)) {
#line 666
          goto while_break;
        }
#line 668
        *rp = (png_byte )((int )*rp - (int )*(rp + 1));
#line 669
        *(rp + 2) = (png_byte )((int )*(rp + 2) - (int )*(rp + 1));
#line 666
        i ++;
#line 666
        rp += bytes_per_pixel;
      }
      while_break: /* CIL Label */ ;
      }
    } else
#line 674
    if ((int )row_info->bit_depth == 16) {
#line 679
      if ((int )row_info->color_type == 2) {
#line 680
        bytes_per_pixel = 6;
      } else
#line 682
      if ((int )row_info->color_type == 6) {
#line 683
        bytes_per_pixel = 8;
      } else {
#line 686
        return;
      }
#line 688
      i___0 = (png_uint_32 )0;
#line 688
      rp___0 = row;
      {
#line 688
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 688
        if (! (i___0 < row_width)) {
#line 688
          goto while_break___0;
        }
#line 690
        s0 = (png_uint_32 )((int )*rp___0 << 8) | (unsigned int )*(rp___0 + 1);
#line 691
        s1 = (png_uint_32 )((int )*(rp___0 + 2) << 8) | (unsigned int )*(rp___0 + 3);
#line 692
        s2 = (png_uint_32 )((int )*(rp___0 + 4) << 8) | (unsigned int )*(rp___0 + 5);
#line 693
        red = (png_uint_32 )((long )(s0 - s1) & 0xffffL);
#line 694
        blue = (png_uint_32 )((long )(s2 - s1) & 0xffffL);
#line 695
        *rp___0 = (png_byte )(red >> 8);
#line 696
        *(rp___0 + 1) = (png_byte )red;
#line 697
        *(rp___0 + 4) = (png_byte )(blue >> 8);
#line 698
        *(rp___0 + 5) = (png_byte )blue;
#line 688
        i___0 ++;
#line 688
        rp___0 += bytes_per_pixel;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 703
  return;
}
}
#line 707 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
void png_write_row(png_structrp png_ptr , png_const_bytep row )
{
  png_row_info row_info ;

  {
#line 713
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 714
    return;
  }
#line 720
  if (png_ptr->row_number == 0U) {
#line 720
    if ((int )png_ptr->pass == 0) {
#line 723
      if ((png_ptr->mode & 0x400U) == 0U) {
#line 724
        png_error((png_const_structrp )png_ptr, (png_const_charp )"png_write_info was never called before png_write_row");
      }
#line 764
      png_write_start_row(png_ptr);
    }
  }
#line 769
  if ((int )png_ptr->interlaced != 0) {
#line 769
    if ((png_ptr->transformations & 0x0002U) != 0U) {
      {
#line 774
      if ((int )png_ptr->pass == 0) {
#line 774
        goto case_0;
      }
#line 782
      if ((int )png_ptr->pass == 1) {
#line 782
        goto case_1;
      }
#line 790
      if ((int )png_ptr->pass == 2) {
#line 790
        goto case_2;
      }
#line 798
      if ((int )png_ptr->pass == 3) {
#line 798
        goto case_3;
      }
#line 806
      if ((int )png_ptr->pass == 4) {
#line 806
        goto case_4;
      }
#line 814
      if ((int )png_ptr->pass == 5) {
#line 814
        goto case_5;
      }
#line 822
      if ((int )png_ptr->pass == 6) {
#line 822
        goto case_6;
      }
#line 830
      goto switch_default;
      case_0: /* CIL Label */
#line 775
      if ((png_ptr->row_number & 7U) != 0U) {
#line 777
        png_write_finish_row(png_ptr);
#line 778
        return;
      }
#line 780
      goto switch_break;
      case_1: /* CIL Label */
#line 783
      if ((png_ptr->row_number & 7U) != 0U) {
#line 785
        png_write_finish_row(png_ptr);
#line 786
        return;
      } else
#line 783
      if (png_ptr->width < 5U) {
#line 785
        png_write_finish_row(png_ptr);
#line 786
        return;
      }
#line 788
      goto switch_break;
      case_2: /* CIL Label */
#line 791
      if ((png_ptr->row_number & 7U) != 4U) {
#line 793
        png_write_finish_row(png_ptr);
#line 794
        return;
      }
#line 796
      goto switch_break;
      case_3: /* CIL Label */
#line 799
      if ((png_ptr->row_number & 3U) != 0U) {
#line 801
        png_write_finish_row(png_ptr);
#line 802
        return;
      } else
#line 799
      if (png_ptr->width < 3U) {
#line 801
        png_write_finish_row(png_ptr);
#line 802
        return;
      }
#line 804
      goto switch_break;
      case_4: /* CIL Label */
#line 807
      if ((png_ptr->row_number & 3U) != 2U) {
#line 809
        png_write_finish_row(png_ptr);
#line 810
        return;
      }
#line 812
      goto switch_break;
      case_5: /* CIL Label */
#line 815
      if ((png_ptr->row_number & 1U) != 0U) {
#line 817
        png_write_finish_row(png_ptr);
#line 818
        return;
      } else
#line 815
      if (png_ptr->width < 2U) {
#line 817
        png_write_finish_row(png_ptr);
#line 818
        return;
      }
#line 820
      goto switch_break;
      case_6: /* CIL Label */
#line 823
      if ((png_ptr->row_number & 1U) == 0U) {
#line 825
        png_write_finish_row(png_ptr);
#line 826
        return;
      }
#line 828
      goto switch_break;
      switch_default: /* CIL Label */
#line 831
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 837
  row_info.color_type = png_ptr->color_type;
#line 838
  row_info.width = png_ptr->usr_width;
#line 839
  row_info.channels = png_ptr->usr_channels;
#line 840
  row_info.bit_depth = png_ptr->usr_bit_depth;
#line 841
  row_info.pixel_depth = (png_byte )((int )row_info.bit_depth * (int )row_info.channels);
#line 842
  if ((int )row_info.pixel_depth >= 8) {
#line 842
    row_info.rowbytes = (size_t )row_info.width * ((size_t )row_info.pixel_depth >> 3);
  } else {
#line 842
    row_info.rowbytes = ((size_t )row_info.width * (size_t )row_info.pixel_depth + 7UL) >> 3;
  }
#line 852
  memcpy((void *)(png_ptr->row_buf + 1), (void const   *)row, row_info.rowbytes);
#line 856
  if (png_ptr->interlaced) {
#line 856
    if ((int )png_ptr->pass < 6) {
#line 856
      if ((png_ptr->transformations & 0x0002U) != 0U) {
#line 859
        png_do_write_interlace(& row_info, png_ptr->row_buf + 1, (int )png_ptr->pass);
#line 861
        if (row_info.width == 0U) {
#line 863
          png_write_finish_row(png_ptr);
#line 864
          return;
        }
      }
    }
  }
#line 871
  if (png_ptr->transformations != 0U) {
#line 872
    png_do_write_transformations(png_ptr, & row_info);
  }
#line 878
  if ((int )row_info.pixel_depth != (int )png_ptr->pixel_depth) {
#line 880
    png_error((png_const_structrp )png_ptr, (png_const_charp )"internal write transform logic error");
  } else
#line 878
  if ((int )row_info.pixel_depth != (int )png_ptr->transformed_pixel_depth) {
#line 880
    png_error((png_const_structrp )png_ptr, (png_const_charp )"internal write transform logic error");
  }
#line 892
  if ((png_ptr->mng_features_permitted & 4U) != 0U) {
#line 892
    if ((int )png_ptr->filter_type == 64) {
#line 896
      png_do_write_intrapixel(& row_info, png_ptr->row_buf + 1);
    }
  }
#line 903
  if ((int )row_info.color_type == 3) {
#line 903
    if (png_ptr->num_palette_max >= 0) {
#line 905
      png_do_check_palette_indexes(png_ptr, & row_info);
    }
  }
#line 909
  png_write_find_filter(png_ptr, & row_info);
#line 911
  if ((unsigned long )png_ptr->write_row_fn != (unsigned long )((void *)0)) {
#line 912
    (*(png_ptr->write_row_fn))((png_structp )png_ptr, png_ptr->row_number, (int )png_ptr->pass);
  }
#line 913
  return;
}
}
#line 917 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
void png_set_flush(png_structrp png_ptr , int nrows )
{


  {
#line 922
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 923
    return;
  }
#line 925
  if (nrows < 0) {
#line 925
    png_ptr->flush_dist = (png_uint_32 )0;
  } else {
#line 925
    png_ptr->flush_dist = (png_uint_32 )nrows;
  }
#line 926
  return;
}
}
#line 929 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
void png_write_flush(png_structrp png_ptr )
{


  {
#line 934
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 935
    return;
  }
#line 938
  if (png_ptr->row_number >= png_ptr->num_rows) {
#line 939
    return;
  }
#line 941
  png_compress_IDAT(png_ptr, (png_const_bytep )((void *)0), (png_alloc_size_t )0,
                    2);
#line 942
  png_ptr->flush_rows = (png_uint_32 )0;
#line 943
  png_flush(png_ptr);
#line 944
  return;
}
}
#line 948 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
static void png_write_destroy(png_structrp png_ptr )
{


  {
#line 954
  if ((png_ptr->flags & 0x0002U) != 0U) {
#line 955
    deflateEnd(& png_ptr->zstream);
  }
#line 958
  png_free_buffer_list(png_ptr, & png_ptr->zbuffer_list);
#line 959
  png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->row_buf);
#line 960
  png_ptr->row_buf = (png_bytep )((void *)0);
#line 962
  png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->prev_row);
#line 963
  png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->try_row);
#line 964
  png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->tst_row);
#line 965
  png_ptr->prev_row = (png_bytep )((void *)0);
#line 966
  png_ptr->try_row = (png_bytep )((void *)0);
#line 967
  png_ptr->tst_row = (png_bytep )((void *)0);
#line 971
  png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->chunk_list);
#line 972
  png_ptr->chunk_list = (png_bytep )((void *)0);
#line 979
  return;
}
}
#line 988 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
void png_destroy_write_struct(png_structpp png_ptr_ptr , png_infopp info_ptr_ptr )
{
  png_structrp png_ptr ;

  {
#line 993
  if ((unsigned long )png_ptr_ptr != (unsigned long )((void *)0)) {
#line 995
    png_ptr = (png_structrp )*png_ptr_ptr;
#line 997
    if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 999
      png_destroy_info_struct((png_const_structrp )png_ptr, info_ptr_ptr);
#line 1001
      *png_ptr_ptr = (png_struct *)((void *)0);
#line 1002
      png_write_destroy(png_ptr);
#line 1003
      png_destroy_png_struct(png_ptr);
    }
  }
#line 1006
  return;
}
}
#line 1009 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
void png_set_filter(png_structrp png_ptr , int method , int filters )
{
  int num_filters ;
  png_alloc_size_t buf_size ;
  size_t tmp ;
  png_voidp __attribute__((__malloc__))  tmp___0 ;
  png_voidp __attribute__((__malloc__))  tmp___1 ;

  {
#line 1014
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1015
    return;
  }
#line 1018
  if ((png_ptr->mng_features_permitted & 4U) != 0U) {
#line 1018
    if (method == 64) {
#line 1020
      method = 0;
    }
  }
#line 1023
  if (method == 0) {
    {
#line 1030
    if ((filters & 255) == 7) {
#line 1030
      goto case_7;
    }
#line 1030
    if ((filters & 255) == 6) {
#line 1030
      goto case_7;
    }
#line 1030
    if ((filters & 255) == 5) {
#line 1030
      goto case_7;
    }
#line 1033
    if ((filters & 255) == 0) {
#line 1033
      goto case_0;
    }
#line 1037
    if ((filters & 255) == 1) {
#line 1037
      goto case_1;
    }
#line 1040
    if ((filters & 255) == 2) {
#line 1040
      goto case_2;
    }
#line 1043
    if ((filters & 255) == 3) {
#line 1043
      goto case_3;
    }
#line 1046
    if ((filters & 255) == 4) {
#line 1046
      goto case_4;
    }
#line 1049
    goto switch_default;
    case_7: /* CIL Label */
    case_6: /* CIL Label */
    case_5: /* CIL Label */
#line 1030
    png_app_error((png_const_structrp )png_ptr, (png_const_charp )"Unknown row filter for method 0");
    case_0: /* CIL Label */
#line 1034
    png_ptr->do_filter = (png_byte )0x08;
#line 1034
    goto switch_break;
    case_1: /* CIL Label */
#line 1038
    png_ptr->do_filter = (png_byte )0x10;
#line 1038
    goto switch_break;
    case_2: /* CIL Label */
#line 1041
    png_ptr->do_filter = (png_byte )0x20;
#line 1041
    goto switch_break;
    case_3: /* CIL Label */
#line 1044
    png_ptr->do_filter = (png_byte )0x40;
#line 1044
    goto switch_break;
    case_4: /* CIL Label */
#line 1047
    png_ptr->do_filter = (png_byte )0x80;
#line 1047
    goto switch_break;
    switch_default: /* CIL Label */
#line 1050
    png_ptr->do_filter = (png_byte )filters;
#line 1050
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1071
    if ((unsigned long )png_ptr->row_buf != (unsigned long )((void *)0)) {
#line 1080
      if (png_ptr->height == 1U) {
#line 1081
        filters &= -225;
      }
#line 1083
      if (png_ptr->width == 1U) {
#line 1084
        filters &= -209;
      }
#line 1086
      if ((filters & 224) != 0) {
#line 1086
        if ((unsigned long )png_ptr->prev_row == (unsigned long )((void *)0)) {
#line 1092
          png_app_warning((png_const_structrp )png_ptr, (png_const_charp )"png_set_filter: UP/AVG/PAETH cannot be added after start");
#line 1094
          filters &= -225;
        }
      }
#line 1097
      num_filters = 0;
#line 1099
      if (filters & 0x10) {
#line 1100
        num_filters ++;
      }
#line 1102
      if (filters & 0x20) {
#line 1103
        num_filters ++;
      }
#line 1105
      if (filters & 0x40) {
#line 1106
        num_filters ++;
      }
#line 1108
      if (filters & 0x80) {
#line 1109
        num_filters ++;
      }
#line 1114
      if ((int )png_ptr->usr_channels * (int )png_ptr->usr_bit_depth >= 8) {
#line 1114
        tmp = (size_t )png_ptr->width * ((size_t )((int )png_ptr->usr_channels * (int )png_ptr->usr_bit_depth) >> 3);
      } else {
#line 1114
        tmp = ((size_t )png_ptr->width * (size_t )((int )png_ptr->usr_channels * (int )png_ptr->usr_bit_depth) + 7UL) >> 3;
      }
#line 1114
      buf_size = tmp + 1UL;
#line 1117
      if ((unsigned long )png_ptr->try_row == (unsigned long )((void *)0)) {
#line 1118
        tmp___0 = png_malloc((png_const_structrp )png_ptr, buf_size);
#line 1118
        png_ptr->try_row = (png_bytep )tmp___0;
      }
#line 1121
      if (num_filters > 1) {
#line 1123
        if ((unsigned long )png_ptr->tst_row == (unsigned long )((void *)0)) {
#line 1124
          tmp___1 = png_malloc((png_const_structrp )png_ptr, buf_size);
#line 1124
          png_ptr->tst_row = (png_bytep )tmp___1;
        }
      }
    }
#line 1128
    png_ptr->do_filter = (png_byte )filters;
  } else {
#line 1132
    png_error((png_const_structrp )png_ptr, (png_const_charp )"Unknown custom filter method");
  }
#line 1133
  return;
}
}
#line 1138 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
void png_set_filter_heuristics(png_structrp png_ptr , int heuristic_method , int num_weights ,
                               png_const_doublep filter_weights , png_const_doublep filter_costs )
{


  {
#line 1148
  return;
}
}
#line 1152 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
void png_set_filter_heuristics_fixed(png_structrp png_ptr , int heuristic_method ,
                                     int num_weights , png_const_fixed_point_p filter_weights ,
                                     png_const_fixed_point_p filter_costs )
{


  {
#line 1162
  return;
}
}
#line 1167 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
void png_set_compression_level(png_structrp png_ptr , int level )
{


  {
#line 1172
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1173
    return;
  }
#line 1175
  png_ptr->zlib_level = level;
#line 1176
  return;
}
}
#line 1178 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
void png_set_compression_mem_level(png_structrp png_ptr , int mem_level )
{


  {
#line 1183
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1184
    return;
  }
#line 1186
  png_ptr->zlib_mem_level = mem_level;
#line 1187
  return;
}
}
#line 1189 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
void png_set_compression_strategy(png_structrp png_ptr , int strategy )
{


  {
#line 1194
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1195
    return;
  }
#line 1199
  png_ptr->flags |= 0x0001U;
#line 1200
  png_ptr->zlib_strategy = strategy;
#line 1201
  return;
}
}
#line 1206 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
void png_set_compression_window_bits(png_structrp png_ptr , int window_bits )
{


  {
#line 1209
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1210
    return;
  }
#line 1218
  if (window_bits > 15) {
#line 1220
    png_warning((png_const_structrp )png_ptr, (png_const_charp )"Only compression windows <= 32k supported by PNG");
#line 1221
    window_bits = 15;
  } else
#line 1224
  if (window_bits < 8) {
#line 1226
    png_warning((png_const_structrp )png_ptr, (png_const_charp )"Only compression windows >= 256 supported by PNG");
#line 1227
    window_bits = 8;
  }
#line 1230
  png_ptr->zlib_window_bits = window_bits;
#line 1231
  return;
}
}
#line 1233 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
void png_set_compression_method(png_structrp png_ptr , int method )
{


  {
#line 1238
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1239
    return;
  }
#line 1244
  if (method != 8) {
#line 1245
    png_warning((png_const_structrp )png_ptr, (png_const_charp )"Only compression method 8 is supported by PNG");
  }
#line 1247
  png_ptr->zlib_method = method;
#line 1248
  return;
}
}
#line 1253 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
void png_set_text_compression_level(png_structrp png_ptr , int level )
{


  {
#line 1258
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1259
    return;
  }
#line 1261
  png_ptr->zlib_text_level = level;
#line 1262
  return;
}
}
#line 1264 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
void png_set_text_compression_mem_level(png_structrp png_ptr , int mem_level )
{


  {
#line 1269
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1270
    return;
  }
#line 1272
  png_ptr->zlib_text_mem_level = mem_level;
#line 1273
  return;
}
}
#line 1275 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
void png_set_text_compression_strategy(png_structrp png_ptr , int strategy )
{


  {
#line 1280
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1281
    return;
  }
#line 1283
  png_ptr->zlib_text_strategy = strategy;
#line 1284
  return;
}
}
#line 1289 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
void png_set_text_compression_window_bits(png_structrp png_ptr , int window_bits )
{


  {
#line 1292
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1293
    return;
  }
#line 1295
  if (window_bits > 15) {
#line 1297
    png_warning((png_const_structrp )png_ptr, (png_const_charp )"Only compression windows <= 32k supported by PNG");
#line 1298
    window_bits = 15;
  } else
#line 1301
  if (window_bits < 8) {
#line 1303
    png_warning((png_const_structrp )png_ptr, (png_const_charp )"Only compression windows >= 256 supported by PNG");
#line 1304
    window_bits = 8;
  }
#line 1307
  png_ptr->zlib_text_window_bits = window_bits;
#line 1308
  return;
}
}
#line 1310 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
void png_set_text_compression_method(png_structrp png_ptr , int method )
{


  {
#line 1315
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1316
    return;
  }
#line 1318
  if (method != 8) {
#line 1319
    png_warning((png_const_structrp )png_ptr, (png_const_charp )"Only compression method 8 is supported by PNG");
  }
#line 1321
  png_ptr->zlib_text_method = method;
#line 1322
  return;
}
}
#line 1326 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
void png_set_write_status_fn(png_structrp png_ptr , void (*write_row_fn)(png_structp  ,
                                                                         png_uint_32  ,
                                                                         int  ) )
{


  {
#line 1329
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1330
    return;
  }
#line 1332
  png_ptr->write_row_fn = write_row_fn;
#line 1333
  return;
}
}
#line 1336 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
void png_set_write_user_transform_fn(png_structrp png_ptr , void (*write_user_transform_fn)(png_structp  ,
                                                                                            png_row_infop  ,
                                                                                            png_bytep  ) )
{


  {
#line 1342
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1343
    return;
  }
#line 1345
  png_ptr->transformations |= 0x100000U;
#line 1346
  png_ptr->write_user_transform_fn = write_user_transform_fn;
#line 1347
  return;
}
}
#line 1352 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
void png_write_png(png_structrp png_ptr , png_inforp info_ptr , int transforms , void *params )
{


  {
#line 1356
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1357
    return;
  } else
#line 1356
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 1357
    return;
  }
#line 1359
  if ((info_ptr->valid & 0x8000U) == 0U) {
#line 1361
    png_app_error((png_const_structrp )png_ptr, (png_const_charp )"no rows for png_write_image to write");
#line 1362
    return;
  }
#line 1366
  png_write_info(png_ptr, (png_const_inforp )info_ptr);
#line 1371
  if ((transforms & 0x0020) != 0) {
#line 1373
    png_set_invert_mono(png_ptr);
  }
#line 1381
  if ((transforms & 0x0040) != 0) {
#line 1383
    if ((info_ptr->valid & 0x0002U) != 0U) {
#line 1384
      png_set_shift(png_ptr, (png_const_color_8p )(& info_ptr->sig_bit));
    }
  }
#line 1390
  if ((transforms & 0x0004) != 0) {
#line 1392
    png_set_packing(png_ptr);
  }
#line 1398
  if ((transforms & 0x0100) != 0) {
#line 1400
    png_set_swap_alpha(png_ptr);
  }
#line 1409
  if ((transforms & 6144) != 0) {
#line 1413
    if ((transforms & 0x1000) != 0) {
#line 1415
      if ((transforms & 0x0800) != 0) {
#line 1416
        png_app_error((png_const_structrp )png_ptr, (png_const_charp )"PNG_TRANSFORM_STRIP_FILLER: BEFORE+AFTER not supported");
      }
#line 1420
      png_set_filler(png_ptr, (png_uint_32 )0, 1);
    } else
#line 1423
    if ((transforms & 0x0800) != 0) {
#line 1424
      png_set_filler(png_ptr, (png_uint_32 )0, 0);
    }
  }
#line 1431
  if ((transforms & 0x0080) != 0) {
#line 1433
    png_set_bgr(png_ptr);
  }
#line 1439
  if ((transforms & 0x0200) != 0) {
#line 1441
    png_set_swap(png_ptr);
  }
#line 1447
  if ((transforms & 0x0008) != 0) {
#line 1449
    png_set_packswap(png_ptr);
  }
#line 1455
  if ((transforms & 0x0400) != 0) {
#line 1457
    png_set_invert_alpha(png_ptr);
  }
#line 1465
  png_write_image(png_ptr, info_ptr->row_pointers);
#line 1468
  png_write_end(png_ptr, info_ptr);
#line 1471
  return;
}
}
#line 1477 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
static int png_image_write_init(png_imagep image )
{
  png_structp png_ptr ;
  png_structp __attribute__((__malloc__))  tmp ;
  png_infop info_ptr ;
  png_infop __attribute__((__malloc__))  tmp___0 ;
  png_controlp control ;
  png_voidp __attribute__((__malloc__))  tmp___1 ;
  int tmp___2 ;

  {
#line 1480
  tmp = png_create_write_struct((png_const_charp )"1.6.39", (png_voidp )image, & png_safe_error,
                                & png_safe_warning);
#line 1480
  png_ptr = (png_structp )tmp;
#line 1483
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 1485
    tmp___0 = png_create_info_struct((png_const_structrp )png_ptr);
#line 1485
    info_ptr = (png_infop )tmp___0;
#line 1487
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1489
      tmp___1 = png_malloc_warn((png_const_structrp )png_ptr, sizeof(*control));
#line 1489
      control = (png_controlp )tmp___1;
#line 1492
      if ((unsigned long )control != (unsigned long )((void *)0)) {
#line 1494
        memset((void *)control, 0, sizeof(*control));
#line 1496
        control->png_ptr = png_ptr;
#line 1497
        control->info_ptr = info_ptr;
#line 1498
        control->for_write = 1U;
#line 1500
        image->opaque = control;
#line 1501
        return (1);
      }
#line 1505
      png_destroy_info_struct((png_const_structrp )png_ptr, & info_ptr);
    }
#line 1508
    png_destroy_write_struct(& png_ptr, (png_infopp )((void *)0));
  }
#line 1511
  tmp___2 = png_image_error(image, (png_const_charp )"png_image_write_: out of memory");
#line 1511
  return (tmp___2);
}
}
#line 1537 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
static int png_write_image_16bit(png_voidp argument )
{
  png_image_write_control *display ;
  png_imagep image ;
  png_structrp png_ptr ;
  png_const_uint_16p input_row ;
  png_uint_16p output_row ;
  png_uint_16p row_end ;
  unsigned int channels ;
  int tmp ;
  int aindex ;
  png_uint_32 y ;
  png_const_uint_16p in_ptr ;
  png_uint_16p out_ptr ;
  png_uint_16 alpha ;
  png_uint_32 reciprocal ;
  int c ;
  png_uint_16 component ;
  png_const_uint_16p tmp___0 ;
  png_uint_32 calc ;
  png_uint_16p tmp___1 ;

  {
#line 1540
  display = (png_image_write_control *)argument;
#line 1542
  image = display->image;
#line 1543
  png_ptr = (png_structrp )(image->opaque)->png_ptr;
#line 1545
  input_row = (png_const_uint_16p )display->first_row;
#line 1547
  output_row = (png_uint_16p )display->local_row;
#line 1549
  if ((image->format & 0x02U) != 0U) {
#line 1549
    tmp = 3;
  } else {
#line 1549
    tmp = 1;
  }
#line 1549
  channels = (unsigned int )tmp;
#line 1551
  aindex = 0;
#line 1552
  y = image->height;
#line 1554
  if ((image->format & 0x01U) != 0U) {
#line 1557
    if ((image->format & 0x20U) != 0U) {
#line 1559
      aindex = -1;
#line 1560
      input_row ++;
#line 1561
      output_row ++;
    } else {
#line 1564
      aindex = (int )channels;
    }
  } else {
#line 1571
    png_error((png_const_structrp )png_ptr, (png_const_charp )"png_write_image: internal call error");
  }
#line 1577
  row_end = output_row + image->width * (channels + 1U);
  {
#line 1579
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1579
    if (! (y > 0U)) {
#line 1579
      goto while_break;
    }
#line 1581
    in_ptr = input_row;
#line 1582
    out_ptr = output_row;
    {
#line 1584
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1584
      if (! ((unsigned long )out_ptr < (unsigned long )row_end)) {
#line 1584
        goto while_break___0;
      }
#line 1586
      alpha = (png_uint_16 )*(in_ptr + aindex);
#line 1587
      reciprocal = (png_uint_32 )0;
#line 1590
      *(out_ptr + aindex) = alpha;
#line 1597
      if ((int )alpha > 0) {
#line 1597
        if ((int )alpha < 65535) {
#line 1598
          reciprocal = (png_uint_32 )(((0xffff << 15) + ((int )alpha >> 1)) / (int )alpha);
        }
      }
#line 1600
      c = (int )channels;
      {
#line 1601
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1603
        tmp___0 = in_ptr;
#line 1603
        in_ptr ++;
#line 1603
        component = (png_uint_16 )*tmp___0;
#line 1612
        if ((int )component >= (int )alpha) {
#line 1613
          component = (png_uint_16 )65535;
        } else
#line 1618
        if ((int )component > 0) {
#line 1618
          if ((int )alpha < 65535) {
#line 1620
            calc = (png_uint_32 )component * reciprocal;
#line 1621
            calc += 16384U;
#line 1622
            component = (png_uint_16 )(calc >> 15);
          }
        }
#line 1625
        tmp___1 = out_ptr;
#line 1625
        out_ptr ++;
#line 1625
        *tmp___1 = component;
#line 1601
        c --;
#line 1601
        if (! (c > 0)) {
#line 1601
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1630
      in_ptr ++;
#line 1631
      out_ptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1634
    png_write_row(png_ptr, (png_const_bytep )display->local_row);
#line 1635
    input_row += (unsigned long )((png_uint_16 )display->row_bytes) / sizeof(png_uint_16 );
#line 1579
    y --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1638
  return (1);
}
}
#line 1651 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
static png_byte png_unpremultiply(png_uint_32 component , png_uint_32 alpha , png_uint_32 reciprocal )
{


  {
#line 1665
  if (component >= alpha) {
#line 1666
    return ((png_byte )255);
  } else
#line 1665
  if (alpha < 128U) {
#line 1666
    return ((png_byte )255);
  } else
#line 1671
  if (component > 0U) {
#line 1678
    if (alpha < 65407U) {
#line 1680
      component *= reciprocal;
#line 1681
      component += 64U;
#line 1682
      component >>= 7;
    } else {
#line 1686
      component *= 255U;
    }
#line 1689
    return ((png_byte )(255U & (((unsigned int )png_sRGB_base[component >> 15] + ((component & 32767U) * (unsigned int )png_sRGB_delta[component >> 15] >> 12)) >> 8)));
  } else {
#line 1693
    return ((png_byte )0);
  }
}
}
#line 1696 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
static int png_write_image_8bit(png_voidp argument )
{
  png_image_write_control *display ;
  png_imagep image ;
  png_structrp png_ptr ;
  png_const_uint_16p input_row ;
  png_bytep output_row ;
  png_uint_32 y ;
  unsigned int channels ;
  int tmp ;
  png_bytep row_end ;
  int aindex ;
  png_const_uint_16p in_ptr ;
  png_bytep out_ptr ;
  png_uint_16 alpha ;
  png_byte alphabyte ;
  png_uint_32 reciprocal ;
  int c ;
  png_bytep tmp___0 ;
  png_const_uint_16p tmp___1 ;
  png_bytep row_end___0 ;
  png_const_uint_16p in_ptr___0 ;
  png_bytep out_ptr___0 ;
  png_uint_32 component ;
  png_const_uint_16p tmp___2 ;
  png_bytep tmp___3 ;

  {
#line 1699
  display = (png_image_write_control *)argument;
#line 1701
  image = display->image;
#line 1702
  png_ptr = (png_structrp )(image->opaque)->png_ptr;
#line 1704
  input_row = (png_const_uint_16p )display->first_row;
#line 1706
  output_row = (png_bytep )display->local_row;
#line 1707
  y = image->height;
#line 1708
  if ((image->format & 0x02U) != 0U) {
#line 1708
    tmp = 3;
  } else {
#line 1708
    tmp = 1;
  }
#line 1708
  channels = (unsigned int )tmp;
#line 1711
  if ((image->format & 0x01U) != 0U) {
#line 1717
    if ((image->format & 0x20U) != 0U) {
#line 1719
      aindex = -1;
#line 1720
      input_row ++;
#line 1721
      output_row ++;
    } else {
#line 1726
      aindex = (int )channels;
    }
#line 1729
    row_end = output_row + image->width * (channels + 1U);
    {
#line 1731
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1731
      if (! (y > 0U)) {
#line 1731
        goto while_break;
      }
#line 1733
      in_ptr = input_row;
#line 1734
      out_ptr = output_row;
      {
#line 1736
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1736
        if (! ((unsigned long )out_ptr < (unsigned long )row_end)) {
#line 1736
          goto while_break___0;
        }
#line 1738
        alpha = (png_uint_16 )*(in_ptr + aindex);
#line 1739
        alphabyte = (png_byte )(((png_uint_32 )alpha * 255U + 32895U) >> 16);
#line 1740
        reciprocal = (png_uint_32 )0;
#line 1744
        *(out_ptr + aindex) = alphabyte;
#line 1746
        if ((int )alphabyte > 0) {
#line 1746
          if ((int )alphabyte < 255) {
#line 1747
            reciprocal = (png_uint_32 )(((16711425 << 7) + ((int )alpha >> 1)) / (int )alpha);
          }
        }
#line 1749
        c = (int )channels;
        {
#line 1750
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1751
          tmp___0 = out_ptr;
#line 1751
          out_ptr ++;
#line 1751
          tmp___1 = in_ptr;
#line 1751
          in_ptr ++;
#line 1751
          *tmp___0 = png_unpremultiply((png_uint_32 )*tmp___1, (png_uint_32 )alpha,
                                       reciprocal);
#line 1750
          c --;
#line 1750
          if (! (c > 0)) {
#line 1750
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1755
        in_ptr ++;
#line 1756
        out_ptr ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1759
      png_write_row(png_ptr, (png_const_bytep )display->local_row);
#line 1761
      input_row += (unsigned long )((png_uint_16 )display->row_bytes) / sizeof(png_uint_16 );
#line 1731
      y --;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1770
    row_end___0 = output_row + image->width * channels;
    {
#line 1772
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1772
      if (! (y > 0U)) {
#line 1772
        goto while_break___2;
      }
#line 1774
      in_ptr___0 = input_row;
#line 1775
      out_ptr___0 = output_row;
      {
#line 1777
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1777
        if (! ((unsigned long )out_ptr___0 < (unsigned long )row_end___0)) {
#line 1777
          goto while_break___3;
        }
#line 1779
        tmp___2 = in_ptr___0;
#line 1779
        in_ptr___0 ++;
#line 1779
        component = (png_uint_32 )*tmp___2;
#line 1781
        component *= 255U;
#line 1782
        tmp___3 = out_ptr___0;
#line 1782
        out_ptr___0 ++;
#line 1782
        *tmp___3 = (png_byte )(255U & (((unsigned int )png_sRGB_base[component >> 15] + ((component & 32767U) * (unsigned int )png_sRGB_delta[component >> 15] >> 12)) >> 8));
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1785
      png_write_row(png_ptr, (png_const_bytep )output_row);
#line 1786
      input_row += (unsigned long )((png_uint_16 )display->row_bytes) / sizeof(png_uint_16 );
#line 1772
      y --;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 1790
  return (1);
}
}
#line 1793 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
static void png_image_set_PLTE(png_image_write_control *display )
{
  png_imagep image ;
  void const   *cmap ;
  int entries ;
  int tmp ;
  png_uint_32 format ;
  unsigned int channels ;
  int afirst ;
  int tmp___0 ;
  int bgr ;
  int tmp___1 ;
  int i ;
  int num_trans ;
  png_color palette[256] ;
  png_byte tRNS[256] ;
  png_const_uint_16p entry ;
  png_byte tmp___2 ;
  png_byte tmp___3 ;
  png_uint_16 alpha ;
  unsigned int tmp___4 ;
  png_byte alphabyte ;
  png_uint_32 reciprocal ;
  png_byte tmp___5 ;
  png_byte tmp___6 ;
  png_const_bytep entry___0 ;
  int tmp___7 ;
  png_byte tmp___8 ;
  png_byte tmp___9 ;

  {
#line 1796
  image = display->image;
#line 1797
  cmap = display->colormap;
#line 1798
  if (image->colormap_entries > 256U) {
#line 1798
    tmp = 256;
  } else {
#line 1798
    tmp = (int )image->colormap_entries;
  }
#line 1798
  entries = tmp;
#line 1802
  format = image->format;
#line 1803
  channels = (format & 3U) + 1U;
#line 1807
  if ((format & 0x20U) != 0U) {
#line 1807
    if ((format & 0x01U) != 0U) {
#line 1807
      tmp___0 = 1;
    } else {
#line 1807
      tmp___0 = 0;
    }
  } else {
#line 1807
    tmp___0 = 0;
  }
#line 1807
  afirst = tmp___0;
#line 1814
  if ((format & 0x10U) != 0U) {
#line 1814
    tmp___1 = 2;
  } else {
#line 1814
    tmp___1 = 0;
  }
#line 1814
  bgr = tmp___1;
#line 1823
  memset((void *)(tRNS), 255, sizeof(tRNS));
#line 1824
  memset((void *)(palette), 0, sizeof(palette));
#line 1826
  num_trans = 0;
#line 1826
  i = num_trans;
  {
#line 1826
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1826
    if (! (i < entries)) {
#line 1826
      goto while_break;
    }
#line 1831
    if ((format & 0x04U) != 0U) {
#line 1833
      entry = (png_const_uint_16p )cmap;
#line 1835
      entry += (unsigned int )i * channels;
#line 1837
      if ((channels & 1U) != 0U) {
#line 1839
        if (channels >= 3U) {
#line 1841
          palette[i].blue = (png_byte )(0xff & (int )(((int const   )png_sRGB_base[255 * (int )*(entry + (2 ^ bgr)) >> 15] + (int const   )((255 * (int )*(entry + (2 ^ bgr)) & 0x7fff) * (int )png_sRGB_delta[255 * (int )*(entry + (2 ^ bgr)) >> 15] >> 12)) >> 8));
#line 1843
          palette[i].green = (png_byte )(0xff & (int )(((int const   )png_sRGB_base[255 * (int )*(entry + 1) >> 15] + (int const   )((255 * (int )*(entry + 1) & 0x7fff) * (int )png_sRGB_delta[255 * (int )*(entry + 1) >> 15] >> 12)) >> 8));
#line 1845
          palette[i].red = (png_byte )(0xff & (int )(((int const   )png_sRGB_base[255 * (int )*(entry + bgr) >> 15] + (int const   )((255 * (int )*(entry + bgr) & 0x7fff) * (int )png_sRGB_delta[255 * (int )*(entry + bgr) >> 15] >> 12)) >> 8));
        } else {
#line 1850
          tmp___3 = (png_byte )(0xff & (int )(((int const   )png_sRGB_base[255 * (int )*entry >> 15] + (int const   )((255 * (int )*entry & 0x7fff) * (int )png_sRGB_delta[255 * (int )*entry >> 15] >> 12)) >> 8));
#line 1850
          palette[i].green = tmp___3;
#line 1850
          tmp___2 = tmp___3;
#line 1850
          palette[i].red = tmp___2;
#line 1850
          palette[i].blue = tmp___2;
        }
      } else {
#line 1856
        if (afirst) {
#line 1856
          tmp___4 = 0U;
        } else {
#line 1856
          tmp___4 = channels - 1U;
        }
#line 1856
        alpha = (png_uint_16 )*(entry + tmp___4);
#line 1857
        alphabyte = (png_byte )(((png_uint_32 )alpha * 255U + 32895U) >> 16);
#line 1858
        reciprocal = (png_uint_32 )0;
#line 1864
        if ((int )alphabyte > 0) {
#line 1864
          if ((int )alphabyte < 255) {
#line 1865
            reciprocal = (png_uint_32 )(((16711425 << 7) + ((int )alpha >> 1)) / (int )alpha);
          }
        }
#line 1867
        tRNS[i] = alphabyte;
#line 1868
        if ((int )alphabyte < 255) {
#line 1869
          num_trans = i + 1;
        }
#line 1871
        if (channels >= 3U) {
#line 1873
          palette[i].blue = png_unpremultiply((png_uint_32 )*(entry + (afirst + (2 ^ bgr))),
                                              (png_uint_32 )alpha, reciprocal);
#line 1875
          palette[i].green = png_unpremultiply((png_uint_32 )*(entry + (afirst + 1)),
                                               (png_uint_32 )alpha, reciprocal);
#line 1877
          palette[i].red = png_unpremultiply((png_uint_32 )*(entry + (afirst + bgr)),
                                             (png_uint_32 )alpha, reciprocal);
        } else {
#line 1882
          tmp___6 = png_unpremultiply((png_uint_32 )*(entry + afirst), (png_uint_32 )alpha,
                                      reciprocal);
#line 1882
          palette[i].green = tmp___6;
#line 1882
          tmp___5 = tmp___6;
#line 1882
          palette[i].red = tmp___5;
#line 1882
          palette[i].blue = tmp___5;
        }
      }
    } else {
#line 1889
      entry___0 = (png_const_bytep )cmap;
#line 1891
      entry___0 += (unsigned int )i * channels;
      {
#line 1895
      if (channels == 4U) {
#line 1895
        goto case_4;
      }
#line 1900
      if (channels == 3U) {
#line 1900
        goto case_3;
      }
#line 1906
      if (channels == 2U) {
#line 1906
        goto case_2;
      }
#line 1911
      if (channels == 1U) {
#line 1911
        goto case_1;
      }
#line 1916
      goto switch_default;
      case_4: /* CIL Label */
#line 1896
      if (afirst) {
#line 1896
        tmp___7 = 0;
      } else {
#line 1896
        tmp___7 = 3;
      }
#line 1896
      tRNS[i] = (png_byte )*(entry___0 + tmp___7);
#line 1897
      if ((int )tRNS[i] < 255) {
#line 1898
        num_trans = i + 1;
      }
      case_3: /* CIL Label */
#line 1901
      palette[i].blue = (png_byte )*(entry___0 + (afirst + (2 ^ bgr)));
#line 1902
      palette[i].green = (png_byte )*(entry___0 + (afirst + 1));
#line 1903
      palette[i].red = (png_byte )*(entry___0 + (afirst + bgr));
#line 1904
      goto switch_break;
      case_2: /* CIL Label */
#line 1907
      tRNS[i] = (png_byte )*(entry___0 + (1 ^ afirst));
#line 1908
      if ((int )tRNS[i] < 255) {
#line 1909
        num_trans = i + 1;
      }
      case_1: /* CIL Label */
#line 1912
      tmp___9 = (png_byte )*(entry___0 + afirst);
#line 1912
      palette[i].green = tmp___9;
#line 1912
      tmp___8 = tmp___9;
#line 1912
      palette[i].red = tmp___8;
#line 1912
      palette[i].blue = tmp___8;
#line 1914
      goto switch_break;
      switch_default: /* CIL Label */
#line 1917
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 1826
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1929
  png_set_PLTE((png_structrp )(image->opaque)->png_ptr, (png_inforp )(image->opaque)->info_ptr,
               (png_const_colorp )(palette), entries);
#line 1932
  if (num_trans > 0) {
#line 1933
    png_set_tRNS((png_structrp )(image->opaque)->png_ptr, (png_inforp )(image->opaque)->info_ptr,
                 (png_const_bytep )(tRNS), num_trans, (png_const_color_16p )((void *)0));
  }
#line 1936
  image->colormap_entries = (png_uint_32 )entries;
#line 1937
  return;
}
}
#line 1939 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
static int png_image_write_main(png_voidp argument )
{
  png_image_write_control *display ;
  png_imagep image ;
  png_structrp png_ptr ;
  png_inforp info_ptr ;
  png_uint_32 format ;
  int colormap ;
  int linear ;
  int tmp ;
  int alpha ;
  int tmp___0 ;
  int write_16bit ;
  int tmp___1 ;
  unsigned int channels ;
  unsigned int tmp___2 ;
  png_uint_32 check___0 ;
  png_uint_32 png_row_stride ;
  png_uint_32 entries ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  png_uint_16 le ;
  png_const_bytep row ;
  ptrdiff_t row_bytes ;
  png_bytep row___0 ;
  size_t tmp___9 ;
  png_voidp __attribute__((__malloc__))  tmp___10 ;
  int result ;
  png_const_bytep row___1 ;
  ptrdiff_t row_bytes___0 ;
  png_uint_32 y ;

  {
#line 1942
  display = (png_image_write_control *)argument;
#line 1944
  image = display->image;
#line 1945
  png_ptr = (png_structrp )(image->opaque)->png_ptr;
#line 1946
  info_ptr = (png_inforp )(image->opaque)->info_ptr;
#line 1947
  format = image->format;
#line 1950
  colormap = (int )(format & 0x08U);
#line 1951
  if (! colormap) {
#line 1951
    if (format & 0x04U) {
#line 1951
      tmp = 1;
    } else {
#line 1951
      tmp = 0;
    }
  } else {
#line 1951
    tmp = 0;
  }
#line 1951
  linear = tmp;
#line 1952
  if (! colormap) {
#line 1952
    if (format & 0x01U) {
#line 1952
      tmp___0 = 1;
    } else {
#line 1952
      tmp___0 = 0;
    }
  } else {
#line 1952
    tmp___0 = 0;
  }
#line 1952
  alpha = tmp___0;
#line 1953
  if (linear) {
#line 1953
    if (display->convert_to_8bit == 0) {
#line 1953
      tmp___1 = 1;
    } else {
#line 1953
      tmp___1 = 0;
    }
  } else {
#line 1953
    tmp___1 = 0;
  }
#line 1953
  write_16bit = tmp___1;
#line 1957
  png_set_benign_errors(png_ptr, 0);
#line 1964
  if (image->format & 0x08U) {
#line 1964
    tmp___2 = 1U;
  } else {
#line 1964
    tmp___2 = (image->format & 3U) + 1U;
  }
#line 1964
  channels = tmp___2;
#line 1966
  if (image->width <= 0x7fffffffU / channels) {
#line 1969
    png_row_stride = image->width * channels;
#line 1971
    if (display->row_stride == 0) {
#line 1972
      display->row_stride = (png_int_32 )png_row_stride;
    }
#line 1974
    if (display->row_stride < 0) {
#line 1975
      check___0 = (png_uint_32 )(- display->row_stride);
    } else {
#line 1978
      check___0 = (png_uint_32 )display->row_stride;
    }
#line 1980
    if (check___0 >= png_row_stride) {
#line 1986
      if (image->height > 0xffffffffU / png_row_stride) {
#line 1987
        png_error((png_const_structrp )(image->opaque)->png_ptr, (png_const_charp )"memory image too large");
      }
    } else {
#line 1991
      png_error((png_const_structrp )(image->opaque)->png_ptr, (png_const_charp )"supplied row stride too small");
    }
  } else {
#line 1995
    png_error((png_const_structrp )(image->opaque)->png_ptr, (png_const_charp )"image row stride too large");
  }
#line 1999
  if ((format & 0x08U) != 0U) {
#line 2001
    if ((unsigned long )display->colormap != (unsigned long )((void *)0)) {
#line 2001
      if (image->colormap_entries > 0U) {
#line 2003
        entries = image->colormap_entries;
#line 2005
        if (entries > 16U) {
#line 2005
          tmp___5 = 8;
        } else {
#line 2005
          if (entries > 4U) {
#line 2005
            tmp___4 = 4;
          } else {
#line 2005
            if (entries > 2U) {
#line 2005
              tmp___3 = 2;
            } else {
#line 2005
              tmp___3 = 1;
            }
#line 2005
            tmp___4 = tmp___3;
          }
#line 2005
          tmp___5 = tmp___4;
        }
#line 2005
        png_set_IHDR((png_const_structrp )png_ptr, info_ptr, image->width, image->height,
                     tmp___5, 3, 0, 0, 0);
#line 2010
        png_image_set_PLTE(display);
      } else {
#line 2014
        png_error((png_const_structrp )(image->opaque)->png_ptr, (png_const_charp )"no color-map for color-mapped image");
      }
    } else {
#line 2014
      png_error((png_const_structrp )(image->opaque)->png_ptr, (png_const_charp )"no color-map for color-mapped image");
    }
  } else {
#line 2019
    if (format & 0x02U) {
#line 2019
      tmp___6 = 2;
    } else {
#line 2019
      tmp___6 = 0;
    }
#line 2019
    if (format & 0x01U) {
#line 2019
      tmp___7 = 4;
    } else {
#line 2019
      tmp___7 = 0;
    }
#line 2019
    if (write_16bit) {
#line 2019
      tmp___8 = 16;
    } else {
#line 2019
      tmp___8 = 8;
    }
#line 2019
    png_set_IHDR((png_const_structrp )png_ptr, info_ptr, image->width, image->height,
                 tmp___8, tmp___6 + tmp___7, 0, 0, 0);
  }
#line 2031
  if (write_16bit != 0) {
#line 2034
    png_set_gAMA_fixed((png_const_structrp )png_ptr, info_ptr, 100000);
#line 2036
    if ((image->flags & 1U) == 0U) {
#line 2037
      png_set_cHRM_fixed((png_const_structrp )png_ptr, info_ptr, 31270, 32900, 64000,
                         33000, 30000, 60000, 15000, 6000);
    }
  } else
#line 2046
  if ((image->flags & 1U) == 0U) {
#line 2047
    png_set_sRGB((png_const_structrp )png_ptr, info_ptr, 0);
  } else {
#line 2053
    png_set_gAMA_fixed((png_const_structrp )png_ptr, info_ptr, 45455);
  }
#line 2056
  png_write_info(png_ptr, (png_const_inforp )info_ptr);
#line 2063
  if (write_16bit != 0) {
#line 2065
    le = (png_uint_16 )0x0001;
#line 2067
    if ((int const   )*((png_const_bytep )(& le)) != 0) {
#line 2068
      png_set_swap(png_ptr);
    }
  }
#line 2072
  if ((format & 0x10U) != 0U) {
#line 2074
    if (colormap == 0) {
#line 2074
      if ((format & 0x02U) != 0U) {
#line 2075
        png_set_bgr(png_ptr);
      }
    }
#line 2076
    format &= 4294967279U;
  }
#line 2081
  if ((format & 0x20U) != 0U) {
#line 2083
    if (colormap == 0) {
#line 2083
      if ((format & 0x01U) != 0U) {
#line 2084
        png_set_swap_alpha(png_ptr);
      }
    }
#line 2085
    format &= 4294967263U;
  }
#line 2092
  if (colormap != 0) {
#line 2092
    if (image->colormap_entries <= 16U) {
#line 2093
      png_set_packing(png_ptr);
    }
  }
#line 2096
  if ((format & 4294967280U) != 0U) {
#line 2098
    png_error((png_const_structrp )png_ptr, (png_const_charp )"png_write_image: unsupported transformation");
  }
#line 2101
  row = (png_const_bytep )display->buffer;
#line 2102
  row_bytes = (ptrdiff_t )display->row_stride;
#line 2104
  if (linear != 0) {
#line 2105
    row_bytes = (ptrdiff_t )((unsigned long )row_bytes * sizeof(png_uint_16 ));
  }
#line 2107
  if (row_bytes < 0L) {
#line 2108
    row += (ptrdiff_t )(image->height - 1U) * - row_bytes;
  }
#line 2110
  display->first_row = (png_const_voidp )row;
#line 2111
  display->row_bytes = row_bytes;
#line 2115
  if ((image->flags & 2U) != 0U) {
#line 2117
    png_set_filter(png_ptr, 0, 0x00);
#line 2124
    png_set_compression_level(png_ptr, 3);
  }
#line 2132
  if (linear != 0) {
#line 2132
    if (alpha != 0) {
#line 2132
      goto _L;
    } else {
#line 2132
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */
#line 2132
  if (colormap == 0) {
#line 2132
    if (display->convert_to_8bit != 0) {
      _L: /* CIL Label */
#line 2135
      tmp___9 = png_get_rowbytes((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
#line 2135
      tmp___10 = png_malloc((png_const_structrp )png_ptr, tmp___9);
#line 2135
      row___0 = (png_bytep )tmp___10;
#line 2139
      display->local_row = (png_voidp )row___0;
#line 2140
      if (write_16bit != 0) {
#line 2141
        result = png_safe_execute(image, & png_write_image_16bit, (png_voidp )display);
      } else {
#line 2143
        result = png_safe_execute(image, & png_write_image_8bit, (png_voidp )display);
      }
#line 2144
      display->local_row = (void *)0;
#line 2146
      png_free((png_const_structrp )png_ptr, (png_voidp )row___0);
#line 2149
      if (result == 0) {
#line 2150
        return (0);
      }
    } else {
#line 2132
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */
#line 2158
    row___1 = (png_const_bytep )display->first_row;
#line 2159
    row_bytes___0 = display->row_bytes;
#line 2160
    y = image->height;
    {
#line 2162
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2162
      if (! (y > 0U)) {
#line 2162
        goto while_break;
      }
#line 2164
      png_write_row(png_ptr, row___1);
#line 2165
      row___1 += row_bytes___0;
#line 2162
      y --;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2169
  png_write_end(png_ptr, info_ptr);
#line 2170
  return (1);
}
}
#line 2174 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
static void image_memory_write(png_structp png_ptr , png_bytep data , size_t size )
{
  png_image_write_control *display ;
  png_alloc_size_t ob ;

  {
#line 2177
  display = (png_image_write_control *)png_ptr->io_ptr;
#line 2179
  ob = display->output_bytes;
#line 2182
  if (size <= 18446744073709551615UL - ob) {
#line 2185
    if (size > 0UL) {
#line 2187
      if (display->memory_bytes >= ob + size) {
#line 2188
        memcpy((void *)(display->memory + ob), (void const   *)data, size);
      }
#line 2191
      display->output_bytes = ob + size;
    }
  } else {
#line 2196
    png_error((png_const_structrp )png_ptr, (png_const_charp )"png_image_write_to_memory: PNG too big");
  }
#line 2197
  return;
}
}
#line 2199 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
static void image_memory_flush(png_structp png_ptr )
{


  {
#line 2203
  return;
}
}
#line 2205 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
static int png_image_write_memory(png_voidp argument )
{
  png_image_write_control *display ;
  int tmp ;

  {
#line 2208
  display = (png_image_write_control *)argument;
#line 2215
  png_set_write_fn((png_structrp )((display->image)->opaque)->png_ptr, (png_voidp )display,
                   & image_memory_write, & image_memory_flush);
#line 2218
  tmp = png_image_write_main((png_voidp )display);
#line 2218
  return (tmp);
}
}
#line 2221 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
int png_image_write_to_memory(png_imagep image , void *memory , png_alloc_size_t *memory_bytes ,
                              int convert_to_8bit , void const   *buffer___0 , png_int_32 row_stride ,
                              void const   *colormap )
{
  png_image_write_control display ;
  int result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2227
  if ((unsigned long )image != (unsigned long )((void *)0)) {
#line 2227
    if (image->version == 1U) {
#line 2229
      if ((unsigned long )memory_bytes != (unsigned long )((void *)0)) {
#line 2229
        if ((unsigned long )buffer___0 != (unsigned long )((void *)0)) {
#line 2234
          if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 2235
            *memory_bytes = (png_alloc_size_t )0;
          }
#line 2237
          tmp = png_image_write_init(image);
#line 2237
          if (tmp != 0) {
#line 2242
            memset((void *)(& display), 0, sizeof(display));
#line 2243
            display.image = image;
#line 2244
            display.buffer = buffer___0;
#line 2245
            display.row_stride = row_stride;
#line 2246
            display.colormap = colormap;
#line 2247
            display.convert_to_8bit = convert_to_8bit;
#line 2248
            display.memory = (png_bytep )memory;
#line 2249
            display.memory_bytes = *memory_bytes;
#line 2250
            display.output_bytes = (png_alloc_size_t )0;
#line 2252
            result = png_safe_execute(image, & png_image_write_memory, (png_voidp )(& display));
#line 2253
            png_image_free(image);
#line 2256
            if (result) {
#line 2261
              if ((unsigned long )memory != (unsigned long )((void *)0)) {
#line 2261
                if (display.output_bytes > *memory_bytes) {
#line 2262
                  result = 0;
                }
              }
#line 2264
              *memory_bytes = display.output_bytes;
            }
#line 2267
            return (result);
          } else {
#line 2271
            return (0);
          }
        } else {
#line 2275
          tmp___0 = png_image_error(image, (png_const_charp )"png_image_write_to_memory: invalid argument");
#line 2275
          return (tmp___0);
        }
      } else {
#line 2275
        tmp___0 = png_image_error(image, (png_const_charp )"png_image_write_to_memory: invalid argument");
#line 2275
        return (tmp___0);
      }
    } else {
#line 2227
      goto _L;
    }
  } else
  _L: /* CIL Label */
#line 2279
  if ((unsigned long )image != (unsigned long )((void *)0)) {
#line 2280
    tmp___1 = png_image_error(image, (png_const_charp )"png_image_write_to_memory: incorrect PNG_IMAGE_VERSION");
#line 2280
    return (tmp___1);
  } else {
#line 2284
    return (0);
  }
}
}
#line 2288 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
int png_image_write_to_stdio(png_imagep image , FILE *file , int convert_to_8bit ,
                             void const   *buffer___0 , png_int_32 row_stride , void const   *colormap )
{
  png_image_write_control display ;
  int result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2293
  if ((unsigned long )image != (unsigned long )((void *)0)) {
#line 2293
    if (image->version == 1U) {
#line 2295
      if ((unsigned long )file != (unsigned long )((void *)0)) {
#line 2295
        if ((unsigned long )buffer___0 != (unsigned long )((void *)0)) {
#line 2297
          tmp = png_image_write_init(image);
#line 2297
          if (tmp != 0) {
#line 2306
            ((image->opaque)->png_ptr)->io_ptr = (png_voidp )file;
#line 2308
            memset((void *)(& display), 0, sizeof(display));
#line 2309
            display.image = image;
#line 2310
            display.buffer = buffer___0;
#line 2311
            display.row_stride = row_stride;
#line 2312
            display.colormap = colormap;
#line 2313
            display.convert_to_8bit = convert_to_8bit;
#line 2315
            result = png_safe_execute(image, & png_image_write_main, (png_voidp )(& display));
#line 2316
            png_image_free(image);
#line 2317
            return (result);
          } else {
#line 2321
            return (0);
          }
        } else {
#line 2325
          tmp___0 = png_image_error(image, (png_const_charp )"png_image_write_to_stdio: invalid argument");
#line 2325
          return (tmp___0);
        }
      } else {
#line 2325
        tmp___0 = png_image_error(image, (png_const_charp )"png_image_write_to_stdio: invalid argument");
#line 2325
        return (tmp___0);
      }
    } else {
#line 2293
      goto _L;
    }
  } else
  _L: /* CIL Label */
#line 2329
  if ((unsigned long )image != (unsigned long )((void *)0)) {
#line 2330
    tmp___1 = png_image_error(image, (png_const_charp )"png_image_write_to_stdio: incorrect PNG_IMAGE_VERSION");
#line 2330
    return (tmp___1);
  } else {
#line 2334
    return (0);
  }
}
}
#line 2337 "/home/goblint2/bench/libpng-1.6.39/pngwrite.c"
int png_image_write_to_file(png_imagep image , char const   *file_name , int convert_to_8bit ,
                            void const   *buffer___0 , png_int_32 row_stride , void const   *colormap )
{
  FILE *fp ;
  FILE *tmp ;
  int error___0 ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 2343
  if ((unsigned long )image != (unsigned long )((void *)0)) {
#line 2343
    if (image->version == 1U) {
#line 2345
      if ((unsigned long )file_name != (unsigned long )((void *)0)) {
#line 2345
        if ((unsigned long )buffer___0 != (unsigned long )((void *)0)) {
#line 2347
          tmp = fopen((char const   * __restrict  )file_name, (char const   * __restrict  )"wb");
#line 2347
          fp = tmp;
#line 2349
          if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 2351
            tmp___7 = png_image_write_to_stdio(image, fp, convert_to_8bit, buffer___0,
                                               row_stride, colormap);
#line 2351
            if (tmp___7 != 0) {
#line 2357
              tmp___3 = fflush(fp);
#line 2357
              if (tmp___3 == 0) {
#line 2357
                tmp___4 = ferror(fp);
#line 2357
                if (tmp___4 == 0) {
#line 2359
                  tmp___0 = fclose(fp);
#line 2359
                  if (tmp___0 == 0) {
#line 2360
                    return (1);
                  }
#line 2362
                  tmp___1 = __errno_location();
#line 2362
                  error___0 = *tmp___1;
                } else {
#line 2367
                  tmp___2 = __errno_location();
#line 2367
                  error___0 = *tmp___2;
#line 2368
                  fclose(fp);
                }
              } else {
#line 2367
                tmp___2 = __errno_location();
#line 2367
                error___0 = *tmp___2;
#line 2368
                fclose(fp);
              }
#line 2371
              remove(file_name);
#line 2375
              tmp___5 = strerror(error___0);
#line 2375
              tmp___6 = png_image_error(image, (png_const_charp )tmp___5);
#line 2375
              return (tmp___6);
            } else {
#line 2381
              fclose(fp);
#line 2382
              remove(file_name);
#line 2383
              return (0);
            }
          } else {
#line 2388
            tmp___8 = __errno_location();
#line 2388
            tmp___9 = strerror(*tmp___8);
#line 2388
            tmp___10 = png_image_error(image, (png_const_charp )tmp___9);
#line 2388
            return (tmp___10);
          }
        } else {
#line 2392
          tmp___11 = png_image_error(image, (png_const_charp )"png_image_write_to_file: invalid argument");
#line 2392
          return (tmp___11);
        }
      } else {
#line 2392
        tmp___11 = png_image_error(image, (png_const_charp )"png_image_write_to_file: invalid argument");
#line 2392
        return (tmp___11);
      }
    } else {
#line 2343
      goto _L;
    }
  } else
  _L: /* CIL Label */
#line 2396
  if ((unsigned long )image != (unsigned long )((void *)0)) {
#line 2397
    tmp___12 = png_image_error(image, (png_const_charp )"png_image_write_to_file: incorrect PNG_IMAGE_VERSION");
#line 2397
    return (tmp___12);
  } else {
#line 2401
    return (0);
  }
}
}
#line 101 "/usr/include/stdlib.h"
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 104
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 107
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 112
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__leaf__, __gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__,
__nothrow__)) ;
#line 820
__inline extern void *( __attribute__((__warn_unused_result__, __nonnull__(1,2,5),
__gnu_inline__)) bsearch)(void const   *__key , void const   *__base , size_t __nmemb ,
                          size_t __size , int (*__compar)(void const   * , void const   * ) ) ;
#line 929
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar )  __attribute__((__nothrow__)) ;
#line 933
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t *__dst , char const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 936
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) wcstombs)(char *__dst , wchar_t const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 43 "/usr/include/string.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memcpy)(void *__dest , void const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 47
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 61
__inline extern void *( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) memset)(void *__dest , int __ch , size_t __len )  __attribute__((__nothrow__)) ;
#line 122
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcpy)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 125
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncpy)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 130
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcat)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 133
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncat)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 326 "/usr/include/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) fprintf)(FILE *__stream ,
                                                                                                  char const   *__fmt
                                                                                                  , ...) ;
#line 332
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) printf)(char const   *__fmt
                                                                                                 , ...) ;
#line 334
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) sprintf)(char *__s ,
                                                                                                            char const   *__fmt
                                                                                                            , ...)  __attribute__((__nothrow__)) ;
#line 341
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vfprintf)(FILE *__stream ,
                                                                                                   char const   *__fmt ,
                                                                                                   __gnuc_va_list __ap ) ;
#line 347
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vprintf)(char const   *__fmt ,
                                                                                                  __gnuc_va_list __ap ) ;
#line 349
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vsprintf)(char *__s ,
                                                                                                             char const   *__fmt ,
                                                                                                             __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 354
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) snprintf)(char *__s , size_t __n , char const   *__fmt
                                              , ...)  __attribute__((__nothrow__)) ;
#line 358
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) vsnprintf)(char *__s , size_t __n , char const   *__fmt ,
                                               __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 492
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
#line 528
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
#line 564
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fgets)(char *__s , int __n , FILE *__stream ) ;
#line 646
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fread)(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 360 "/usr/include/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) read)(int __fd , void *__buf , size_t __nbytes ) ;
#line 511
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size )  __attribute__((__nothrow__)) ;
#line 689
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list )  __attribute__((__nothrow__)) ;
#line 774
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                               size_t __buflen )  __attribute__((__nothrow__)) ;
#line 24 "/home/goblint2/bench/libpng-1.6.39/pngwtran.c"
static void png_do_pack(png_row_infop row_info , png_bytep row , png_uint_32 bit_depth )
{
  png_bytep sp ;
  png_bytep dp ;
  int mask ;
  int v ;
  png_uint_32 i ;
  png_uint_32 row_width ;
  png_bytep sp___0 ;
  png_bytep dp___0 ;
  unsigned int shift ;
  int v___0 ;
  png_uint_32 i___0 ;
  png_uint_32 row_width___0 ;
  png_byte value ;
  png_bytep sp___1 ;
  png_bytep dp___1 ;
  unsigned int shift___0 ;
  int v___1 ;
  png_uint_32 i___1 ;
  png_uint_32 row_width___1 ;
  png_byte value___0 ;

  {
#line 29
  if ((int )row_info->bit_depth == 8) {
#line 29
    if ((int )row_info->channels == 1) {
      {
#line 34
      if ((int )bit_depth == 1) {
#line 34
        goto case_1;
      }
#line 71
      if ((int )bit_depth == 2) {
#line 71
        goto case_2;
      }
#line 111
      if ((int )bit_depth == 4) {
#line 111
        goto case_4;
      }
#line 151
      goto switch_default;
      case_1: /* CIL Label */
#line 39
      row_width = row_info->width;
#line 41
      sp = row;
#line 42
      dp = row;
#line 43
      mask = 0x80;
#line 44
      v = 0;
#line 46
      i = (png_uint_32 )0;
      {
#line 46
      while (1) {
        while_continue: /* CIL Label */ ;
#line 46
        if (! (i < row_width)) {
#line 46
          goto while_break;
        }
#line 48
        if ((int )*sp != 0) {
#line 49
          v |= mask;
        }
#line 51
        sp ++;
#line 53
        if (mask > 1) {
#line 54
          mask >>= 1;
        } else {
#line 58
          mask = 0x80;
#line 59
          *dp = (png_byte )v;
#line 60
          dp ++;
#line 61
          v = 0;
        }
#line 46
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 65
      if (mask != 0x80) {
#line 66
        *dp = (png_byte )v;
      }
#line 68
      goto switch_break;
      case_2: /* CIL Label */
#line 77
      row_width___0 = row_info->width;
#line 79
      sp___0 = row;
#line 80
      dp___0 = row;
#line 81
      shift = 6U;
#line 82
      v___0 = 0;
#line 84
      i___0 = (png_uint_32 )0;
      {
#line 84
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 84
        if (! (i___0 < row_width___0)) {
#line 84
          goto while_break___0;
        }
#line 88
        value = (png_byte )((int )*sp___0 & 0x03);
#line 89
        v___0 |= (int )value << shift;
#line 91
        if (shift == 0U) {
#line 93
          shift = 6U;
#line 94
          *dp___0 = (png_byte )v___0;
#line 95
          dp___0 ++;
#line 96
          v___0 = 0;
        } else {
#line 100
          shift -= 2U;
        }
#line 102
        sp___0 ++;
#line 84
        i___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 105
      if (shift != 6U) {
#line 106
        *dp___0 = (png_byte )v___0;
      }
#line 108
      goto switch_break;
      case_4: /* CIL Label */
#line 117
      row_width___1 = row_info->width;
#line 119
      sp___1 = row;
#line 120
      dp___1 = row;
#line 121
      shift___0 = 4U;
#line 122
      v___1 = 0;
#line 124
      i___1 = (png_uint_32 )0;
      {
#line 124
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 124
        if (! (i___1 < row_width___1)) {
#line 124
          goto while_break___1;
        }
#line 128
        value___0 = (png_byte )((int )*sp___1 & 0x0f);
#line 129
        v___1 |= (int )value___0 << shift___0;
#line 131
        if (shift___0 == 0U) {
#line 133
          shift___0 = 4U;
#line 134
          *dp___1 = (png_byte )v___1;
#line 135
          dp___1 ++;
#line 136
          v___1 = 0;
        } else {
#line 140
          shift___0 -= 4U;
        }
#line 142
        sp___1 ++;
#line 124
        i___1 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 145
      if (shift___0 != 4U) {
#line 146
        *dp___1 = (png_byte )v___1;
      }
#line 148
      goto switch_break;
      switch_default: /* CIL Label */
#line 152
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 155
      row_info->bit_depth = (png_byte )bit_depth;
#line 156
      row_info->pixel_depth = (png_byte )(bit_depth * (png_uint_32 )row_info->channels);
#line 157
      if ((int )row_info->pixel_depth >= 8) {
#line 157
        row_info->rowbytes = (size_t )row_info->width * ((size_t )row_info->pixel_depth >> 3);
      } else {
#line 157
        row_info->rowbytes = ((size_t )row_info->width * (size_t )row_info->pixel_depth + 7UL) >> 3;
      }
    }
  }
#line 160
  return;
}
}
#line 171 "/home/goblint2/bench/libpng-1.6.39/pngwtran.c"
static void png_do_shift(png_row_infop row_info , png_bytep row , png_const_color_8p bit_depth )
{
  int shift_start[4] ;
  int shift_dec[4] ;
  unsigned int channels ;
  png_bytep bp ;
  size_t i ;
  unsigned int mask ;
  size_t row_bytes ;
  int j ;
  unsigned int v ;
  unsigned int out ;
  png_bytep bp___0 ;
  png_uint_32 i___0 ;
  png_uint_32 istop ;
  unsigned int c ;
  int j___0 ;
  unsigned int v___0 ;
  unsigned int out___0 ;
  png_bytep bp___1 ;
  png_uint_32 i___1 ;
  png_uint_32 istop___0 ;
  unsigned int c___0 ;
  int j___1 ;
  unsigned int value ;
  unsigned int v___1 ;
  png_bytep tmp ;
  png_bytep tmp___0 ;

  {
#line 177
  if ((int )row_info->color_type != 3) {
#line 180
    channels = 0U;
#line 182
    if (((int )row_info->color_type & 2) != 0) {
#line 184
      shift_start[channels] = (int )row_info->bit_depth - (int )bit_depth->red;
#line 185
      shift_dec[channels] = (int )bit_depth->red;
#line 186
      channels ++;
#line 188
      shift_start[channels] = (int )row_info->bit_depth - (int )bit_depth->green;
#line 189
      shift_dec[channels] = (int )bit_depth->green;
#line 190
      channels ++;
#line 192
      shift_start[channels] = (int )row_info->bit_depth - (int )bit_depth->blue;
#line 193
      shift_dec[channels] = (int )bit_depth->blue;
#line 194
      channels ++;
    } else {
#line 199
      shift_start[channels] = (int )row_info->bit_depth - (int )bit_depth->gray;
#line 200
      shift_dec[channels] = (int )bit_depth->gray;
#line 201
      channels ++;
    }
#line 204
    if (((int )row_info->color_type & 4) != 0) {
#line 206
      shift_start[channels] = (int )row_info->bit_depth - (int )bit_depth->alpha;
#line 207
      shift_dec[channels] = (int )bit_depth->alpha;
#line 208
      channels ++;
    }
#line 212
    if ((int )row_info->bit_depth < 8) {
#line 214
      bp = row;
#line 217
      row_bytes = row_info->rowbytes;
#line 219
      if ((int )bit_depth->gray == 1) {
#line 219
        if ((int )row_info->bit_depth == 2) {
#line 220
          mask = 85U;
        } else {
#line 219
          goto _L;
        }
      } else
      _L: /* CIL Label */
#line 222
      if ((int )row_info->bit_depth == 4) {
#line 222
        if ((int )bit_depth->gray == 3) {
#line 223
          mask = 17U;
        } else {
#line 226
          mask = 255U;
        }
      } else {
#line 226
        mask = 255U;
      }
#line 228
      i = (size_t )0;
      {
#line 228
      while (1) {
        while_continue: /* CIL Label */ ;
#line 228
        if (! (i < row_bytes)) {
#line 228
          goto while_break;
        }
#line 233
        v = (unsigned int )*bp;
#line 234
        out = 0U;
#line 236
        j = shift_start[0];
        {
#line 236
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 236
          if (! (j > - shift_dec[0])) {
#line 236
            goto while_break___0;
          }
#line 238
          if (j > 0) {
#line 239
            out |= v << j;
          } else {
#line 242
            out |= (v >> - j) & mask;
          }
#line 236
          j -= shift_dec[0];
        }
        while_break___0: /* CIL Label */ ;
        }
#line 245
        *bp = (png_byte )(out & 255U);
#line 228
        i ++;
#line 228
        bp ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else
#line 249
    if ((int )row_info->bit_depth == 8) {
#line 251
      bp___0 = row;
#line 253
      istop = channels * row_info->width;
#line 255
      i___0 = (png_uint_32 )0;
      {
#line 255
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 255
        if (! (i___0 < istop)) {
#line 255
          goto while_break___1;
        }
#line 257
        c = i___0 % channels;
#line 261
        v___0 = (unsigned int )*bp___0;
#line 262
        out___0 = 0U;
#line 264
        j___0 = shift_start[c];
        {
#line 264
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 264
          if (! (j___0 > - shift_dec[c])) {
#line 264
            goto while_break___2;
          }
#line 266
          if (j___0 > 0) {
#line 267
            out___0 |= v___0 << j___0;
          } else {
#line 270
            out___0 |= v___0 >> - j___0;
          }
#line 264
          j___0 -= shift_dec[c];
        }
        while_break___2: /* CIL Label */ ;
        }
#line 273
        *bp___0 = (png_byte )(out___0 & 255U);
#line 255
        i___0 ++;
#line 255
        bp___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
#line 281
      istop___0 = channels * row_info->width;
#line 283
      bp___1 = row;
#line 283
      i___1 = (png_uint_32 )0;
      {
#line 283
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 283
        if (! (i___1 < istop___0)) {
#line 283
          goto while_break___3;
        }
#line 285
        c___0 = i___1 % channels;
#line 289
        v___1 = (unsigned int )((png_uint_16 )(((unsigned int )*bp___1 << 8) + (unsigned int )*(bp___1 + 1)));
#line 290
        value = 0U;
#line 292
        j___1 = shift_start[c___0];
        {
#line 292
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 292
          if (! (j___1 > - shift_dec[c___0])) {
#line 292
            goto while_break___4;
          }
#line 294
          if (j___1 > 0) {
#line 295
            value |= v___1 << j___1;
          } else {
#line 298
            value |= v___1 >> - j___1;
          }
#line 292
          j___1 -= shift_dec[c___0];
        }
        while_break___4: /* CIL Label */ ;
        }
#line 300
        tmp = bp___1;
#line 300
        bp___1 ++;
#line 300
        *tmp = (png_byte )((value >> 8) & 255U);
#line 301
        tmp___0 = bp___1;
#line 301
        bp___1 ++;
#line 301
        *tmp___0 = (png_byte )(value & 255U);
#line 283
        i___1 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
  }
#line 305
  return;
}
}
#line 309 "/home/goblint2/bench/libpng-1.6.39/pngwtran.c"
static void png_do_write_swap_alpha(png_row_infop row_info , png_bytep row )
{
  png_bytep sp ;
  png_bytep dp ;
  png_uint_32 i ;
  png_uint_32 row_width ;
  png_byte save ;
  png_bytep tmp ;
  png_bytep tmp___0 ;
  png_bytep tmp___1 ;
  png_bytep tmp___2 ;
  png_bytep tmp___3 ;
  png_bytep tmp___4 ;
  png_bytep tmp___5 ;
  png_bytep tmp___6 ;
  png_bytep sp___0 ;
  png_bytep dp___0 ;
  png_uint_32 i___0 ;
  png_uint_32 row_width___0 ;
  png_byte save___0[2] ;
  png_bytep tmp___7 ;
  png_bytep tmp___8 ;
  png_bytep tmp___9 ;
  png_bytep tmp___10 ;
  png_bytep tmp___11 ;
  png_bytep tmp___12 ;
  png_bytep tmp___13 ;
  png_bytep tmp___14 ;
  png_bytep tmp___15 ;
  png_bytep tmp___16 ;
  png_bytep tmp___17 ;
  png_bytep tmp___18 ;
  png_bytep tmp___19 ;
  png_bytep tmp___20 ;
  png_bytep tmp___21 ;
  png_bytep tmp___22 ;
  png_bytep sp___1 ;
  png_bytep dp___1 ;
  png_uint_32 i___1 ;
  png_uint_32 row_width___1 ;
  png_byte save___1 ;
  png_bytep tmp___23 ;
  png_bytep tmp___24 ;
  png_bytep tmp___25 ;
  png_bytep tmp___26 ;
  png_bytep sp___2 ;
  png_bytep dp___2 ;
  png_uint_32 i___2 ;
  png_uint_32 row_width___2 ;
  png_byte save___2[2] ;
  png_bytep tmp___27 ;
  png_bytep tmp___28 ;
  png_bytep tmp___29 ;
  png_bytep tmp___30 ;
  png_bytep tmp___31 ;
  png_bytep tmp___32 ;
  png_bytep tmp___33 ;
  png_bytep tmp___34 ;

  {
#line 315
  if ((int )row_info->color_type == 6) {
#line 317
    if ((int )row_info->bit_depth == 8) {
#line 322
      row_width = row_info->width;
#line 324
      i = (png_uint_32 )0;
#line 324
      dp = row;
#line 324
      sp = dp;
      {
#line 324
      while (1) {
        while_continue: /* CIL Label */ ;
#line 324
        if (! (i < row_width)) {
#line 324
          goto while_break;
        }
#line 326
        tmp = sp;
#line 326
        sp ++;
#line 326
        save = *tmp;
#line 327
        tmp___0 = dp;
#line 327
        dp ++;
#line 327
        tmp___1 = sp;
#line 327
        sp ++;
#line 327
        *tmp___0 = *tmp___1;
#line 328
        tmp___2 = dp;
#line 328
        dp ++;
#line 328
        tmp___3 = sp;
#line 328
        sp ++;
#line 328
        *tmp___2 = *tmp___3;
#line 329
        tmp___4 = dp;
#line 329
        dp ++;
#line 329
        tmp___5 = sp;
#line 329
        sp ++;
#line 329
        *tmp___4 = *tmp___5;
#line 330
        tmp___6 = dp;
#line 330
        dp ++;
#line 330
        *tmp___6 = save;
#line 324
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 340
      row_width___0 = row_info->width;
#line 342
      i___0 = (png_uint_32 )0;
#line 342
      dp___0 = row;
#line 342
      sp___0 = dp___0;
      {
#line 342
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 342
        if (! (i___0 < row_width___0)) {
#line 342
          goto while_break___0;
        }
#line 345
        tmp___7 = sp___0;
#line 345
        sp___0 ++;
#line 345
        save___0[0] = *tmp___7;
#line 346
        tmp___8 = sp___0;
#line 346
        sp___0 ++;
#line 346
        save___0[1] = *tmp___8;
#line 347
        tmp___9 = dp___0;
#line 347
        dp___0 ++;
#line 347
        tmp___10 = sp___0;
#line 347
        sp___0 ++;
#line 347
        *tmp___9 = *tmp___10;
#line 348
        tmp___11 = dp___0;
#line 348
        dp___0 ++;
#line 348
        tmp___12 = sp___0;
#line 348
        sp___0 ++;
#line 348
        *tmp___11 = *tmp___12;
#line 349
        tmp___13 = dp___0;
#line 349
        dp___0 ++;
#line 349
        tmp___14 = sp___0;
#line 349
        sp___0 ++;
#line 349
        *tmp___13 = *tmp___14;
#line 350
        tmp___15 = dp___0;
#line 350
        dp___0 ++;
#line 350
        tmp___16 = sp___0;
#line 350
        sp___0 ++;
#line 350
        *tmp___15 = *tmp___16;
#line 351
        tmp___17 = dp___0;
#line 351
        dp___0 ++;
#line 351
        tmp___18 = sp___0;
#line 351
        sp___0 ++;
#line 351
        *tmp___17 = *tmp___18;
#line 352
        tmp___19 = dp___0;
#line 352
        dp___0 ++;
#line 352
        tmp___20 = sp___0;
#line 352
        sp___0 ++;
#line 352
        *tmp___19 = *tmp___20;
#line 353
        tmp___21 = dp___0;
#line 353
        dp___0 ++;
#line 353
        *tmp___21 = save___0[0];
#line 354
        tmp___22 = dp___0;
#line 354
        dp___0 ++;
#line 354
        *tmp___22 = save___0[1];
#line 342
        i___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else
#line 360
  if ((int )row_info->color_type == 4) {
#line 362
    if ((int )row_info->bit_depth == 8) {
#line 367
      row_width___1 = row_info->width;
#line 369
      i___1 = (png_uint_32 )0;
#line 369
      dp___1 = row;
#line 369
      sp___1 = dp___1;
      {
#line 369
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 369
        if (! (i___1 < row_width___1)) {
#line 369
          goto while_break___1;
        }
#line 371
        tmp___23 = sp___1;
#line 371
        sp___1 ++;
#line 371
        save___1 = *tmp___23;
#line 372
        tmp___24 = dp___1;
#line 372
        dp___1 ++;
#line 372
        tmp___25 = sp___1;
#line 372
        sp___1 ++;
#line 372
        *tmp___24 = *tmp___25;
#line 373
        tmp___26 = dp___1;
#line 373
        dp___1 ++;
#line 373
        *tmp___26 = save___1;
#line 369
        i___1 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
#line 383
      row_width___2 = row_info->width;
#line 385
      i___2 = (png_uint_32 )0;
#line 385
      dp___2 = row;
#line 385
      sp___2 = dp___2;
      {
#line 385
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 385
        if (! (i___2 < row_width___2)) {
#line 385
          goto while_break___2;
        }
#line 388
        tmp___27 = sp___2;
#line 388
        sp___2 ++;
#line 388
        save___2[0] = *tmp___27;
#line 389
        tmp___28 = sp___2;
#line 389
        sp___2 ++;
#line 389
        save___2[1] = *tmp___28;
#line 390
        tmp___29 = dp___2;
#line 390
        dp___2 ++;
#line 390
        tmp___30 = sp___2;
#line 390
        sp___2 ++;
#line 390
        *tmp___29 = *tmp___30;
#line 391
        tmp___31 = dp___2;
#line 391
        dp___2 ++;
#line 391
        tmp___32 = sp___2;
#line 391
        sp___2 ++;
#line 391
        *tmp___31 = *tmp___32;
#line 392
        tmp___33 = dp___2;
#line 392
        dp___2 ++;
#line 392
        *tmp___33 = save___2[0];
#line 393
        tmp___34 = dp___2;
#line 393
        dp___2 ++;
#line 393
        *tmp___34 = save___2[1];
#line 385
        i___2 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
#line 399
  return;
}
}
#line 403 "/home/goblint2/bench/libpng-1.6.39/pngwtran.c"
static void png_do_write_invert_alpha(png_row_infop row_info , png_bytep row )
{
  png_bytep sp ;
  png_bytep dp ;
  png_uint_32 i ;
  png_uint_32 row_width ;
  png_bytep tmp ;
  png_bytep sp___0 ;
  png_bytep dp___0 ;
  png_uint_32 i___0 ;
  png_uint_32 row_width___0 ;
  png_bytep tmp___0 ;
  png_bytep tmp___1 ;
  png_bytep tmp___2 ;
  png_bytep sp___1 ;
  png_bytep dp___1 ;
  png_uint_32 i___1 ;
  png_uint_32 row_width___1 ;
  png_bytep tmp___3 ;
  png_bytep tmp___4 ;
  png_bytep tmp___5 ;
  png_bytep tmp___6 ;
  png_bytep sp___2 ;
  png_bytep dp___2 ;
  png_uint_32 i___2 ;
  png_uint_32 row_width___2 ;
  png_bytep tmp___7 ;
  png_bytep tmp___8 ;
  png_bytep tmp___9 ;

  {
#line 409
  if ((int )row_info->color_type == 6) {
#line 411
    if ((int )row_info->bit_depth == 8) {
#line 416
      row_width = row_info->width;
#line 418
      i = (png_uint_32 )0;
#line 418
      dp = row;
#line 418
      sp = dp;
      {
#line 418
      while (1) {
        while_continue: /* CIL Label */ ;
#line 418
        if (! (i < row_width)) {
#line 418
          goto while_break;
        }
#line 425
        sp += 3;
#line 425
        dp = sp;
#line 426
        tmp = sp;
#line 426
        sp ++;
#line 426
        *dp = (png_byte )(255 - (int )*tmp);
#line 418
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 436
      row_width___0 = row_info->width;
#line 438
      i___0 = (png_uint_32 )0;
#line 438
      dp___0 = row;
#line 438
      sp___0 = dp___0;
      {
#line 438
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 438
        if (! (i___0 < row_width___0)) {
#line 438
          goto while_break___0;
        }
#line 448
        sp___0 += 6;
#line 448
        dp___0 = sp___0;
#line 449
        tmp___0 = dp___0;
#line 449
        dp___0 ++;
#line 449
        tmp___1 = sp___0;
#line 449
        sp___0 ++;
#line 449
        *tmp___0 = (png_byte )(255 - (int )*tmp___1);
#line 450
        tmp___2 = sp___0;
#line 450
        sp___0 ++;
#line 450
        *dp___0 = (png_byte )(255 - (int )*tmp___2);
#line 438
        i___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else
#line 456
  if ((int )row_info->color_type == 4) {
#line 458
    if ((int )row_info->bit_depth == 8) {
#line 463
      row_width___1 = row_info->width;
#line 465
      i___1 = (png_uint_32 )0;
#line 465
      dp___1 = row;
#line 465
      sp___1 = dp___1;
      {
#line 465
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 465
        if (! (i___1 < row_width___1)) {
#line 465
          goto while_break___1;
        }
#line 467
        tmp___3 = dp___1;
#line 467
        dp___1 ++;
#line 467
        tmp___4 = sp___1;
#line 467
        sp___1 ++;
#line 467
        *tmp___3 = *tmp___4;
#line 468
        tmp___5 = dp___1;
#line 468
        dp___1 ++;
#line 468
        tmp___6 = sp___1;
#line 468
        sp___1 ++;
#line 468
        *tmp___5 = (png_byte )(255 - (int )*tmp___6);
#line 465
        i___1 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
#line 478
      row_width___2 = row_info->width;
#line 480
      i___2 = (png_uint_32 )0;
#line 480
      dp___2 = row;
#line 480
      sp___2 = dp___2;
      {
#line 480
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 480
        if (! (i___2 < row_width___2)) {
#line 480
          goto while_break___2;
        }
#line 486
        sp___2 += 2;
#line 486
        dp___2 = sp___2;
#line 487
        tmp___7 = dp___2;
#line 487
        dp___2 ++;
#line 487
        tmp___8 = sp___2;
#line 487
        sp___2 ++;
#line 487
        *tmp___7 = (png_byte )(255 - (int )*tmp___8);
#line 488
        tmp___9 = sp___2;
#line 488
        sp___2 ++;
#line 488
        *dp___2 = (png_byte )(255 - (int )*tmp___9);
#line 480
        i___2 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
#line 494
  return;
}
}
#line 500 "/home/goblint2/bench/libpng-1.6.39/pngwtran.c"
void png_do_write_transformations(png_structrp png_ptr , png_row_infop row_info )
{


  {
#line 505
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 506
    return;
  }
#line 509
  if ((png_ptr->transformations & 0x100000U) != 0U) {
#line 510
    if ((unsigned long )png_ptr->write_user_transform_fn != (unsigned long )((void *)0)) {
#line 511
      (*(png_ptr->write_user_transform_fn))((png_structp )png_ptr, row_info, png_ptr->row_buf + 1);
    }
  }
#line 525
  if ((png_ptr->transformations & 0x8000U) != 0U) {
#line 526
    png_do_strip_channel(row_info, png_ptr->row_buf + 1, ! (png_ptr->flags & 0x0080U));
  }
#line 531
  if ((png_ptr->transformations & 0x10000U) != 0U) {
#line 532
    png_do_packswap(row_info, png_ptr->row_buf + 1);
  }
#line 536
  if ((png_ptr->transformations & 0x0004U) != 0U) {
#line 537
    png_do_pack(row_info, png_ptr->row_buf + 1, (png_uint_32 )png_ptr->bit_depth);
  }
#line 543
  if ((png_ptr->transformations & 0x0010U) != 0U) {
#line 544
    png_do_swap(row_info, png_ptr->row_buf + 1);
  }
#line 549
  if ((png_ptr->transformations & 0x0008U) != 0U) {
#line 550
    png_do_shift(row_info, png_ptr->row_buf + 1, (png_const_color_8p )(& png_ptr->shift));
  }
#line 555
  if ((png_ptr->transformations & 0x20000U) != 0U) {
#line 556
    png_do_write_swap_alpha(row_info, png_ptr->row_buf + 1);
  }
#line 560
  if ((png_ptr->transformations & 0x80000U) != 0U) {
#line 561
    png_do_write_invert_alpha(row_info, png_ptr->row_buf + 1);
  }
#line 565
  if ((png_ptr->transformations & 0x0001U) != 0U) {
#line 566
    png_do_bgr(row_info, png_ptr->row_buf + 1);
  }
#line 570
  if ((png_ptr->transformations & 0x0020U) != 0U) {
#line 571
    png_do_invert(row_info, png_ptr->row_buf + 1);
  }
#line 573
  return;
}
}
#line 101 "/usr/include/stdlib.h"
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 104
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 107
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 112
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__leaf__, __gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__,
__nothrow__)) ;
#line 820
__inline extern void *( __attribute__((__warn_unused_result__, __nonnull__(1,2,5),
__gnu_inline__)) bsearch)(void const   *__key , void const   *__base , size_t __nmemb ,
                          size_t __size , int (*__compar)(void const   * , void const   * ) ) ;
#line 929
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar )  __attribute__((__nothrow__)) ;
#line 933
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t *__dst , char const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 936
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) wcstombs)(char *__dst , wchar_t const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 43 "/usr/include/string.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memcpy)(void *__dest , void const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 47
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 61
__inline extern void *( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) memset)(void *__dest , int __ch , size_t __len )  __attribute__((__nothrow__)) ;
#line 122
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcpy)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 125
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncpy)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 130
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcat)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 133
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncat)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 326 "/usr/include/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) fprintf)(FILE *__stream ,
                                                                                                  char const   *__fmt
                                                                                                  , ...) ;
#line 332
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) printf)(char const   *__fmt
                                                                                                 , ...) ;
#line 334
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) sprintf)(char *__s ,
                                                                                                            char const   *__fmt
                                                                                                            , ...)  __attribute__((__nothrow__)) ;
#line 341
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vfprintf)(FILE *__stream ,
                                                                                                   char const   *__fmt ,
                                                                                                   __gnuc_va_list __ap ) ;
#line 347
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vprintf)(char const   *__fmt ,
                                                                                                  __gnuc_va_list __ap ) ;
#line 349
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vsprintf)(char *__s ,
                                                                                                             char const   *__fmt ,
                                                                                                             __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 354
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) snprintf)(char *__s , size_t __n , char const   *__fmt
                                              , ...)  __attribute__((__nothrow__)) ;
#line 358
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) vsnprintf)(char *__s , size_t __n , char const   *__fmt ,
                                               __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 492
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
#line 528
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
#line 564
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fgets)(char *__s , int __n , FILE *__stream ) ;
#line 646
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fread)(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 360 "/usr/include/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) read)(int __fd , void *__buf , size_t __nbytes ) ;
#line 511
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size )  __attribute__((__nothrow__)) ;
#line 689
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list )  __attribute__((__nothrow__)) ;
#line 774
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                               size_t __buflen )  __attribute__((__nothrow__)) ;
#line 23 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
void png_save_uint_32(png_bytep buf , png_uint_32 i )
{


  {
#line 26
  *(buf + 0) = (png_byte )((i >> 24) & 0xffU);
#line 27
  *(buf + 1) = (png_byte )((i >> 16) & 0xffU);
#line 28
  *(buf + 2) = (png_byte )((i >> 8) & 0xffU);
#line 29
  *(buf + 3) = (png_byte )(i & 0xffU);
#line 30
  return;
}
}
#line 36 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
void png_save_uint_16(png_bytep buf , unsigned int i )
{


  {
#line 39
  *(buf + 0) = (png_byte )((i >> 8) & 0xffU);
#line 40
  *(buf + 1) = (png_byte )(i & 0xffU);
#line 41
  return;
}
}
#line 50 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
void png_write_sig(png_structrp png_ptr )
{
  png_byte png_signature[8] ;

  {
#line 53
  png_signature[0] = (png_byte )137;
#line 53
  png_signature[1] = (png_byte )80;
#line 53
  png_signature[2] = (png_byte )78;
#line 53
  png_signature[3] = (png_byte )71;
#line 53
  png_signature[4] = (png_byte )13;
#line 53
  png_signature[5] = (png_byte )10;
#line 53
  png_signature[6] = (png_byte )26;
#line 53
  png_signature[7] = (png_byte )10;
#line 57
  png_ptr->io_state = (png_uint_32 )18;
#line 61
  png_write_data(png_ptr, (png_const_bytep )(& png_signature[png_ptr->sig_bytes]),
                 (size_t )(8 - (int )png_ptr->sig_bytes));
#line 64
  if ((int )png_ptr->sig_bytes < 3) {
#line 65
    png_ptr->mode |= 0x1000U;
  }
#line 66
  return;
}
}
#line 72 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
static void png_write_chunk_header(png_structrp png_ptr , png_uint_32 chunk_name ,
                                   png_uint_32 length )
{
  png_byte buf[8] ;

  {
#line 83
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 84
    return;
  }
#line 90
  png_ptr->io_state = (png_uint_32 )34;
#line 94
  png_save_uint_32(buf, length);
#line 95
  png_save_uint_32(buf + 4, chunk_name);
#line 96
  png_write_data(png_ptr, (png_const_bytep )(buf), (size_t )8);
#line 99
  png_ptr->chunk_name = chunk_name;
#line 102
  png_reset_crc(png_ptr);
#line 104
  png_calculate_crc(png_ptr, (png_const_bytep )(buf + 4), (size_t )4);
#line 110
  png_ptr->io_state = (png_uint_32 )66;
#line 112
  return;
}
}
#line 114 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
void png_write_chunk_start(png_structrp png_ptr , png_const_bytep chunk_string , png_uint_32 length )
{


  {
#line 118
  png_write_chunk_header(png_ptr, ((((png_uint_32 )(0xff & (int )*(chunk_string + 0)) << 24) | ((png_uint_32 )(0xff & (int )*(chunk_string + 1)) << 16)) | ((png_uint_32 )(0xff & (int )*(chunk_string + 2)) << 8)) | (png_uint_32 )(0xff & (int )*(chunk_string + 3)),
                         length);
#line 119
  return;
}
}
#line 126 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
void png_write_chunk_data(png_structrp png_ptr , png_const_bytep data , size_t length )
{


  {
#line 130
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 131
    return;
  }
#line 133
  if ((unsigned long )data != (unsigned long )((void *)0)) {
#line 133
    if (length > 0UL) {
#line 135
      png_write_data(png_ptr, data, length);
#line 140
      png_calculate_crc(png_ptr, data, length);
    }
  }
#line 142
  return;
}
}
#line 145 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
void png_write_chunk_end(png_structrp png_ptr )
{
  png_byte buf[4] ;

  {
#line 150
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 150
    return;
  }
#line 156
  png_ptr->io_state = (png_uint_32 )130;
#line 160
  png_save_uint_32(buf, png_ptr->crc);
#line 162
  png_write_data(png_ptr, (png_const_bytep )(buf), (size_t )4);
#line 163
  return;
}
}
#line 174 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
static void png_write_complete_chunk(png_structrp png_ptr , png_uint_32 chunk_name ,
                                     png_const_bytep data , size_t length )
{


  {
#line 178
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 179
    return;
  }
#line 182
  if (length > 2147483647UL) {
#line 183
    png_error((png_const_structrp )png_ptr, (png_const_charp )"length exceeds PNG maximum");
  }
#line 185
  png_write_chunk_header(png_ptr, chunk_name, (png_uint_32 )length);
#line 186
  png_write_chunk_data(png_ptr, data, length);
#line 187
  png_write_chunk_end(png_ptr);
#line 188
  return;
}
}
#line 191 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
void png_write_chunk(png_structrp png_ptr , png_const_bytep chunk_string , png_const_bytep data ,
                     size_t length )
{


  {
#line 195
  png_write_complete_chunk(png_ptr, ((((png_uint_32 )(0xff & (int )*(chunk_string + 0)) << 24) | ((png_uint_32 )(0xff & (int )*(chunk_string + 1)) << 16)) | ((png_uint_32 )(0xff & (int )*(chunk_string + 2)) << 8)) | (png_uint_32 )(0xff & (int )*(chunk_string + 3)),
                           data, length);
#line 197
  return;
}
}
#line 203 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
static png_alloc_size_t png_image_size(png_structrp png_ptr )
{
  png_uint_32 h ;
  png_uint_32 w ;
  unsigned int pd ;
  png_alloc_size_t cb_base ;
  int pass ;
  png_uint_32 pw ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 209
  h = png_ptr->height;
#line 211
  if (png_ptr->rowbytes < 32768UL) {
#line 211
    if (h < 32768U) {
#line 213
      if ((int )png_ptr->interlaced != 0) {
#line 218
        w = png_ptr->width;
#line 219
        pd = (unsigned int )png_ptr->pixel_depth;
#line 223
        cb_base = (png_alloc_size_t )0;
#line 223
        pass = 0;
        {
#line 223
        while (1) {
          while_continue: /* CIL Label */ ;
#line 223
          if (! (pass <= 6)) {
#line 223
            goto while_break;
          }
#line 225
          if (pass > 1) {
#line 225
            tmp = (7 - pass) >> 1;
          } else {
#line 225
            tmp = 3;
          }
#line 225
          if (pass > 1) {
#line 225
            tmp___0 = (7 - pass) >> 1;
          } else {
#line 225
            tmp___0 = 3;
          }
#line 225
          pw = (w + (png_uint_32 )(((1 << tmp) - 1) - (((1 & pass) << (3 - ((pass + 1) >> 1))) & 7))) >> tmp___0;
#line 227
          if (pw > 0U) {
#line 228
            if (pd >= 8U) {
#line 228
              tmp___1 = (size_t )pw * ((size_t )pd >> 3);
            } else {
#line 228
              tmp___1 = ((size_t )pw * (size_t )pd + 7UL) >> 3;
            }
#line 228
            if (pass > 2) {
#line 228
              tmp___2 = (8 - pass) >> 1;
            } else {
#line 228
              tmp___2 = 3;
            }
#line 228
            if (pass > 2) {
#line 228
              tmp___3 = (8 - pass) >> 1;
            } else {
#line 228
              tmp___3 = 3;
            }
#line 228
            cb_base += (tmp___1 + 1UL) * (size_t )((h + (png_uint_32 )(((1 << tmp___2) - 1) - (((1 & ~ pass) << (3 - (pass >> 1))) & 7))) >> tmp___3);
          }
#line 223
          pass ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 231
        return (cb_base);
      } else {
#line 235
        return ((png_ptr->rowbytes + 1UL) * (size_t )h);
      }
    } else {
#line 239
      return ((png_alloc_size_t )0xffffffffU);
    }
  } else {
#line 239
    return ((png_alloc_size_t )0xffffffffU);
  }
}
}
#line 249 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
static void optimize_cmf(png_bytep data , png_alloc_size_t data_size )
{
  unsigned int z_cmf ;
  unsigned int z_cinfo ;
  unsigned int half_z_window_size ;
  unsigned int tmp ;

  {
#line 255
  if (data_size <= 16384UL) {
#line 257
    z_cmf = (unsigned int )*(data + 0);
#line 259
    if ((z_cmf & 15U) == 8U) {
#line 259
      if ((z_cmf & 240U) <= 112U) {
#line 264
        z_cinfo = z_cmf >> 4;
#line 265
        half_z_window_size = 1U << (z_cinfo + 7U);
#line 267
        if (data_size <= (png_alloc_size_t )half_z_window_size) {
          {
#line 271
          while (1) {
            while_continue: /* CIL Label */ ;
#line 273
            half_z_window_size >>= 1;
#line 274
            z_cinfo --;
#line 271
            if (z_cinfo > 0U) {
#line 271
              if (! (data_size <= (png_alloc_size_t )half_z_window_size)) {
#line 271
                goto while_break;
              }
            } else {
#line 271
              goto while_break;
            }
          }
          while_break: /* CIL Label */ ;
          }
#line 278
          z_cmf = (z_cmf & 15U) | (z_cinfo << 4);
#line 280
          *(data + 0) = (png_byte )z_cmf;
#line 281
          tmp = (unsigned int )((int )*(data + 1) & 0xe0);
#line 282
          tmp += 31U - ((z_cmf << 8) + tmp) % 31U;
#line 283
          *(data + 1) = (png_byte )tmp;
        }
      }
    }
  }
#line 287
  return;
}
}
#line 291 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
static int png_deflate_claim(png_structrp png_ptr , png_uint_32 owner , png_alloc_size_t data_size )
{
  char msg[64] ;
  int level ;
  int method ;
  int windowBits ;
  int memLevel ;
  int strategy ;
  int ret ;
  unsigned int half_window_size ;
  int tmp ;

  {
#line 295
  if (png_ptr->zowner != 0U) {
#line 300
    msg[0] = (char )((owner >> 24) & 255U);
#line 300
    msg[1] = (char )((owner >> 16) & 255U);
#line 300
    msg[2] = (char )((owner >> 8) & 255U);
#line 300
    msg[3] = (char )(owner & 255U);
#line 301
    msg[4] = (char )':';
#line 302
    msg[5] = (char )' ';
#line 303
    *((msg + 6) + 0) = (char )((png_ptr->zowner >> 24) & 255U);
#line 303
    *((msg + 6) + 1) = (char )((png_ptr->zowner >> 16) & 255U);
#line 303
    *((msg + 6) + 2) = (char )((png_ptr->zowner >> 8) & 255U);
#line 303
    *((msg + 6) + 3) = (char )(png_ptr->zowner & 255U);
#line 308
    png_safecat(msg, sizeof(msg), (size_t )10, (png_const_charp )" using zstream");
#line 311
    png_warning((png_const_structrp )png_ptr, (png_const_charp )(msg));
#line 314
    if (png_ptr->zowner == ((((73U << 24) | (68U << 16)) | (65U << 8)) | 84U)) {
#line 316
      png_ptr->zstream.msg = (char const   *)"in use by IDAT";
#line 317
      return (-2);
    }
#line 320
    png_ptr->zowner = (png_uint_32 )0;
  }
#line 327
  level = png_ptr->zlib_level;
#line 328
  method = png_ptr->zlib_method;
#line 329
  windowBits = png_ptr->zlib_window_bits;
#line 330
  memLevel = png_ptr->zlib_mem_level;
#line 334
  if (owner == ((((73U << 24) | (68U << 16)) | (65U << 8)) | 84U)) {
#line 336
    if ((png_ptr->flags & 0x0001U) != 0U) {
#line 337
      strategy = png_ptr->zlib_strategy;
    } else
#line 339
    if ((int )png_ptr->do_filter != 0x08) {
#line 340
      strategy = 1;
    } else {
#line 343
      strategy = 0;
    }
  } else {
#line 349
    level = png_ptr->zlib_text_level;
#line 350
    method = png_ptr->zlib_text_method;
#line 351
    windowBits = png_ptr->zlib_text_window_bits;
#line 352
    memLevel = png_ptr->zlib_text_mem_level;
#line 353
    strategy = png_ptr->zlib_text_strategy;
  }
#line 371
  if (data_size <= 16384UL) {
#line 378
    half_window_size = 1U << (windowBits - 1);
    {
#line 380
    while (1) {
      while_continue: /* CIL Label */ ;
#line 380
      if (! (data_size + 262UL <= (png_alloc_size_t )half_window_size)) {
#line 380
        goto while_break;
      }
#line 382
      half_window_size >>= 1;
#line 383
      windowBits --;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 388
  if ((png_ptr->flags & 0x0002U) != 0U) {
#line 388
    if (png_ptr->zlib_set_level != level) {
#line 388
      goto _L;
    } else
#line 388
    if (png_ptr->zlib_set_method != method) {
#line 388
      goto _L;
    } else
#line 388
    if (png_ptr->zlib_set_window_bits != windowBits) {
#line 388
      goto _L;
    } else
#line 388
    if (png_ptr->zlib_set_mem_level != memLevel) {
#line 388
      goto _L;
    } else
#line 388
    if (png_ptr->zlib_set_strategy != strategy) {
      _L: /* CIL Label */
#line 395
      tmp = deflateEnd(& png_ptr->zstream);
#line 395
      if (tmp != 0) {
#line 396
        png_warning((png_const_structrp )png_ptr, (png_const_charp )"deflateEnd failed (ignored)");
      }
#line 398
      png_ptr->flags &= 4294967293U;
    }
  }
#line 404
  png_ptr->zstream.next_in = (Bytef const   *)((void *)0);
#line 405
  png_ptr->zstream.avail_in = (uInt )0;
#line 406
  png_ptr->zstream.next_out = (Bytef *)((void *)0);
#line 407
  png_ptr->zstream.avail_out = (uInt )0;
#line 412
  if ((png_ptr->flags & 0x0002U) != 0U) {
#line 413
    ret = deflateReset(& png_ptr->zstream);
  } else {
#line 417
    ret = deflateInit2_(& png_ptr->zstream, level, method, windowBits, memLevel, strategy,
                        (char const   *)"1.2.11", (int )sizeof(z_stream ));
#line 420
    if (ret == 0) {
#line 421
      png_ptr->flags |= 0x0002U;
    }
  }
#line 427
  if (ret == 0) {
#line 428
    png_ptr->zowner = owner;
  } else {
#line 431
    png_zstream_error(png_ptr, ret);
  }
#line 433
  return (ret);
}
}
#line 438 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
void png_free_buffer_list(png_structrp png_ptr , png_compression_bufferp *listp )
{
  png_compression_bufferp list ;
  png_compression_bufferp next ;

  {
#line 441
  list = *listp;
#line 443
  if ((unsigned long )list != (unsigned long )((void *)0)) {
#line 445
    *listp = (png_compression_bufferp )((void *)0);
    {
#line 447
    while (1) {
      while_continue: /* CIL Label */ ;
#line 449
      next = list->next;
#line 451
      png_free((png_const_structrp )png_ptr, (png_voidp )list);
#line 452
      list = next;
#line 447
      if (! ((unsigned long )list != (unsigned long )((void *)0))) {
#line 447
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 456
  return;
}
}
#line 477 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
static void png_text_compress_init(compression_state *comp , png_const_bytep input ,
                                   png_alloc_size_t input_len )
{


  {
#line 481
  comp->input = input;
#line 482
  comp->input_len = input_len;
#line 483
  comp->output_len = (png_uint_32 )0;
#line 484
  return;
}
}
#line 487 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
static int png_text_compress(png_structrp png_ptr , png_uint_32 chunk_name , compression_state *comp ,
                             png_uint_32 prefix_len )
{
  int ret ;
  png_compression_bufferp *end ;
  png_alloc_size_t input_len ;
  png_uint_32 output_len ;
  uInt avail_in ;
  png_compression_buffer *next ;
  png_voidp __attribute__((__malloc__))  tmp ;
  int tmp___0 ;

  {
#line 503
  ret = png_deflate_claim(png_ptr, chunk_name, comp->input_len);
#line 505
  if (ret != 0) {
#line 506
    return (ret);
  }
#line 515
  end = & png_ptr->zbuffer_list;
#line 516
  input_len = comp->input_len;
#line 520
  png_ptr->zstream.next_in = comp->input;
#line 521
  png_ptr->zstream.avail_in = (uInt )0;
#line 522
  png_ptr->zstream.next_out = comp->output;
#line 523
  png_ptr->zstream.avail_out = (uInt )sizeof(comp->output);
#line 525
  output_len = png_ptr->zstream.avail_out;
  {
#line 527
  while (1) {
    while_continue: /* CIL Label */ ;
#line 529
    avail_in = (uInt )-1;
#line 531
    if ((png_alloc_size_t )avail_in > input_len) {
#line 532
      avail_in = (uInt )input_len;
    }
#line 534
    input_len -= (png_alloc_size_t )avail_in;
#line 536
    png_ptr->zstream.avail_in = avail_in;
#line 538
    if (png_ptr->zstream.avail_out == 0U) {
#line 545
      if (output_len + prefix_len > 2147483647U) {
#line 547
        ret = -4;
#line 548
        goto while_break;
      }
#line 554
      next = *end;
#line 555
      if ((unsigned long )next == (unsigned long )((void *)0)) {
#line 557
        tmp = png_malloc_base((png_const_structrp )png_ptr, (unsigned long )(& ((png_compression_buffer *)0)->output) + (unsigned long )png_ptr->zbuffer_size);
#line 557
        next = (png_compression_buffer *)tmp;
#line 560
        if ((unsigned long )next == (unsigned long )((void *)0)) {
#line 562
          ret = -4;
#line 563
          goto while_break;
        }
#line 567
        next->next = (struct png_compression_buffer *)((void *)0);
#line 568
        *end = next;
      }
#line 571
      png_ptr->zstream.next_out = next->output;
#line 572
      png_ptr->zstream.avail_out = png_ptr->zbuffer_size;
#line 573
      output_len += png_ptr->zstream.avail_out;
#line 576
      end = & next->next;
    }
#line 580
    if (input_len > 0UL) {
#line 580
      tmp___0 = 0;
    } else {
#line 580
      tmp___0 = 4;
    }
#line 580
    ret = deflate(& png_ptr->zstream, tmp___0);
#line 586
    input_len += (png_alloc_size_t )png_ptr->zstream.avail_in;
#line 587
    png_ptr->zstream.avail_in = (uInt )0;
#line 527
    if (! (ret == 0)) {
#line 527
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 594
  output_len -= png_ptr->zstream.avail_out;
#line 595
  png_ptr->zstream.avail_out = (uInt )0;
#line 596
  comp->output_len = output_len;
#line 602
  if (output_len + prefix_len >= 2147483647U) {
#line 604
    png_ptr->zstream.msg = (char const   *)"compressed data too long";
#line 605
    ret = -4;
  } else {
#line 609
    png_zstream_error(png_ptr, ret);
  }
#line 612
  png_ptr->zowner = (png_uint_32 )0;
#line 617
  if (ret == 1) {
#line 617
    if (input_len == 0UL) {
#line 621
      optimize_cmf(comp->output, comp->input_len);
#line 627
      return (0);
    } else {
#line 631
      return (ret);
    }
  } else {
#line 631
    return (ret);
  }
}
}
#line 636 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
static void png_write_compressed_data_out(png_structrp png_ptr , compression_state *comp )
{
  png_uint_32 output_len ;
  png_const_bytep output ;
  png_uint_32 avail ;
  png_compression_buffer *next ;

  {
#line 639
  output_len = comp->output_len;
#line 640
  output = (png_const_bytep )(comp->output);
#line 641
  avail = (png_uint_32 )sizeof(comp->output);
#line 642
  next = png_ptr->zbuffer_list;
  {
#line 644
  while (1) {
    while_continue: /* CIL Label */ ;
#line 646
    if (avail > output_len) {
#line 647
      avail = output_len;
    }
#line 649
    png_write_chunk_data(png_ptr, output, (size_t )avail);
#line 651
    output_len -= avail;
#line 653
    if (output_len == 0U) {
#line 654
      goto while_break;
    } else
#line 653
    if ((unsigned long )next == (unsigned long )((void *)0)) {
#line 654
      goto while_break;
    }
#line 656
    avail = png_ptr->zbuffer_size;
#line 657
    output = (png_const_bytep )(next->output);
#line 658
    next = next->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 662
  if (output_len > 0U) {
#line 663
    png_error((png_const_structrp )png_ptr, (png_const_charp )"error writing ancillary chunked compressed data");
  }
#line 664
  return;
}
}
#line 671 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
void png_write_IHDR(png_structrp png_ptr , png_uint_32 width , png_uint_32 height ,
                    int bit_depth , int color_type , int compression_type , int filter_type ,
                    int interlace_type )
{
  png_byte buf[13] ;
  int is_invalid_depth ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 684
  if (color_type == 0) {
#line 684
    goto case_0;
  }
#line 702
  if (color_type == 2) {
#line 702
    goto case_2___0;
  }
#line 713
  if (color_type == 3) {
#line 713
    goto case_3;
  }
#line 728
  if (color_type == 4) {
#line 728
    goto case_4___1;
  }
#line 739
  if (color_type == 6) {
#line 739
    goto case_6;
  }
#line 750
  goto switch_default___1;
  case_0: /* CIL Label */
  {
#line 692
  if (bit_depth == 16) {
#line 692
    goto case_16;
  }
#line 692
  if (bit_depth == 8) {
#line 692
    goto case_16;
  }
#line 692
  if (bit_depth == 4) {
#line 692
    goto case_16;
  }
#line 692
  if (bit_depth == 2) {
#line 692
    goto case_16;
  }
#line 692
  if (bit_depth == 1) {
#line 692
    goto case_16;
  }
#line 696
  goto switch_default;
  case_16: /* CIL Label */
  case_8: /* CIL Label */
  case_4: /* CIL Label */
  case_2: /* CIL Label */
  case_1: /* CIL Label */
#line 694
  png_ptr->channels = (png_byte )1;
#line 694
  goto switch_break___0;
  switch_default: /* CIL Label */
#line 697
  png_error((png_const_structrp )png_ptr, (png_const_charp )"Invalid bit depth for grayscale image");
  switch_break___0: /* CIL Label */ ;
  }
#line 700
  goto switch_break;
  case_2___0: /* CIL Label */
#line 703
  is_invalid_depth = bit_depth != 8;
#line 705
  if (is_invalid_depth) {
#line 705
    if (bit_depth != 16) {
#line 705
      tmp = 1;
    } else {
#line 705
      tmp = 0;
    }
  } else {
#line 705
    tmp = 0;
  }
#line 705
  is_invalid_depth = tmp;
#line 707
  if (is_invalid_depth) {
#line 708
    png_error((png_const_structrp )png_ptr, (png_const_charp )"Invalid bit depth for RGB image");
  }
#line 710
  png_ptr->channels = (png_byte )3;
#line 711
  goto switch_break;
  case_3: /* CIL Label */
  {
#line 719
  if (bit_depth == 8) {
#line 719
    goto case_8___0;
  }
#line 719
  if (bit_depth == 4) {
#line 719
    goto case_8___0;
  }
#line 719
  if (bit_depth == 2) {
#line 719
    goto case_8___0;
  }
#line 719
  if (bit_depth == 1) {
#line 719
    goto case_8___0;
  }
#line 723
  goto switch_default___0;
  case_8___0: /* CIL Label */
  case_4___0: /* CIL Label */
  case_2___1: /* CIL Label */
  case_1___0: /* CIL Label */
#line 720
  png_ptr->channels = (png_byte )1;
#line 721
  goto switch_break___1;
  switch_default___0: /* CIL Label */
#line 724
  png_error((png_const_structrp )png_ptr, (png_const_charp )"Invalid bit depth for paletted image");
  switch_break___1: /* CIL Label */ ;
  }
#line 726
  goto switch_break;
  case_4___1: /* CIL Label */
#line 729
  is_invalid_depth = bit_depth != 8;
#line 731
  if (is_invalid_depth) {
#line 731
    if (bit_depth != 16) {
#line 731
      tmp___0 = 1;
    } else {
#line 731
      tmp___0 = 0;
    }
  } else {
#line 731
    tmp___0 = 0;
  }
#line 731
  is_invalid_depth = tmp___0;
#line 733
  if (is_invalid_depth) {
#line 734
    png_error((png_const_structrp )png_ptr, (png_const_charp )"Invalid bit depth for grayscale+alpha image");
  }
#line 736
  png_ptr->channels = (png_byte )2;
#line 737
  goto switch_break;
  case_6: /* CIL Label */
#line 740
  is_invalid_depth = bit_depth != 8;
#line 742
  if (is_invalid_depth) {
#line 742
    if (bit_depth != 16) {
#line 742
      tmp___1 = 1;
    } else {
#line 742
      tmp___1 = 0;
    }
  } else {
#line 742
    tmp___1 = 0;
  }
#line 742
  is_invalid_depth = tmp___1;
#line 744
  if (is_invalid_depth) {
#line 745
    png_error((png_const_structrp )png_ptr, (png_const_charp )"Invalid bit depth for RGBA image");
  }
#line 747
  png_ptr->channels = (png_byte )4;
#line 748
  goto switch_break;
  switch_default___1: /* CIL Label */
#line 751
  png_error((png_const_structrp )png_ptr, (png_const_charp )"Invalid image color type specified");
  switch_break: /* CIL Label */ ;
  }
#line 754
  if (compression_type != 0) {
#line 756
    png_warning((png_const_structrp )png_ptr, (png_const_charp )"Invalid compression type specified");
#line 757
    compression_type = 0;
  }
#line 769
  if ((png_ptr->mng_features_permitted & 4U) != 0U) {
#line 769
    if ((png_ptr->mode & 0x1000U) == 0U) {
#line 769
      if (color_type == 2) {
#line 769
        goto _L___1;
      } else
#line 769
      if (color_type == 6) {
        _L___1: /* CIL Label */
#line 769
        if (! (filter_type == 64)) {
#line 769
          goto _L___2;
        }
      } else {
#line 769
        goto _L___2;
      }
    } else {
#line 769
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */
  _L___0: /* CIL Label */
  _L: /* CIL Label */
#line 769
  if (filter_type != 0) {
#line 779
    png_warning((png_const_structrp )png_ptr, (png_const_charp )"Invalid filter type specified");
#line 780
    filter_type = 0;
  }
#line 784
  if (interlace_type != 0) {
#line 784
    if (interlace_type != 1) {
#line 787
      png_warning((png_const_structrp )png_ptr, (png_const_charp )"Invalid interlace type specified");
#line 788
      interlace_type = 1;
    }
  }
#line 795
  png_ptr->bit_depth = (png_byte )bit_depth;
#line 796
  png_ptr->color_type = (png_byte )color_type;
#line 797
  png_ptr->interlaced = (png_byte )interlace_type;
#line 799
  png_ptr->filter_type = (png_byte )filter_type;
#line 801
  png_ptr->compression_type = (png_byte )compression_type;
#line 802
  png_ptr->width = width;
#line 803
  png_ptr->height = height;
#line 805
  png_ptr->pixel_depth = (png_byte )(bit_depth * (int )png_ptr->channels);
#line 806
  if ((int )png_ptr->pixel_depth >= 8) {
#line 806
    png_ptr->rowbytes = (size_t )width * ((size_t )png_ptr->pixel_depth >> 3);
  } else {
#line 806
    png_ptr->rowbytes = ((size_t )width * (size_t )png_ptr->pixel_depth + 7UL) >> 3;
  }
#line 808
  png_ptr->usr_width = png_ptr->width;
#line 809
  png_ptr->usr_bit_depth = png_ptr->bit_depth;
#line 810
  png_ptr->usr_channels = png_ptr->channels;
#line 813
  png_save_uint_32(buf, width);
#line 814
  png_save_uint_32(buf + 4, height);
#line 815
  buf[8] = (png_byte )bit_depth;
#line 816
  buf[9] = (png_byte )color_type;
#line 817
  buf[10] = (png_byte )compression_type;
#line 818
  buf[11] = (png_byte )filter_type;
#line 819
  buf[12] = (png_byte )interlace_type;
#line 822
  png_write_complete_chunk(png_ptr, (((73U << 24) | (72U << 16)) | (68U << 8)) | 82U,
                           (png_const_bytep )(buf), (size_t )13);
#line 824
  if ((int )png_ptr->do_filter == 0x00) {
#line 826
    if ((int )png_ptr->color_type == 3) {
#line 828
      png_ptr->do_filter = (png_byte )0x08;
    } else
#line 826
    if ((int )png_ptr->bit_depth < 8) {
#line 828
      png_ptr->do_filter = (png_byte )0x08;
    } else {
#line 831
      png_ptr->do_filter = (png_byte )248;
    }
  }
#line 834
  png_ptr->mode = (png_uint_32 )0x01;
#line 835
  return;
}
}
#line 841 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
void png_write_PLTE(png_structrp png_ptr , png_const_colorp palette , png_uint_32 num_pal )
{
  png_uint_32 max_palette_length ;
  png_uint_32 i ;
  png_const_colorp pal_ptr ;
  png_byte buf[3] ;

  {
#line 851
  if ((int )png_ptr->color_type == 3) {
#line 851
    max_palette_length = (png_uint_32 )(1 << (int )png_ptr->bit_depth);
  } else {
#line 851
    max_palette_length = (png_uint_32 )256;
  }
#line 854
  if ((png_ptr->mng_features_permitted & 1U) == 0U) {
#line 854
    if (num_pal == 0U) {
#line 854
      goto _L;
    } else {
#line 854
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */
#line 854
  if (num_pal > max_palette_length) {
    _L: /* CIL Label */
#line 860
    if ((int )png_ptr->color_type == 3) {
#line 862
      png_error((png_const_structrp )png_ptr, (png_const_charp )"Invalid number of colors in palette");
    } else {
#line 867
      png_warning((png_const_structrp )png_ptr, (png_const_charp )"Invalid number of colors in palette");
#line 868
      return;
    }
  }
#line 872
  if (((int )png_ptr->color_type & 2) == 0) {
#line 874
    png_warning((png_const_structrp )png_ptr, (png_const_charp )"Ignoring request to write a PLTE chunk in grayscale PNG");
#line 877
    return;
  }
#line 880
  png_ptr->num_palette = (png_uint_16 )num_pal;
#line 883
  png_write_chunk_header(png_ptr, (((80U << 24) | (76U << 16)) | (84U << 8)) | 69U,
                         num_pal * 3U);
#line 886
  i = (png_uint_32 )0;
#line 886
  pal_ptr = palette;
  {
#line 886
  while (1) {
    while_continue: /* CIL Label */ ;
#line 886
    if (! (i < num_pal)) {
#line 886
      goto while_break;
    }
#line 888
    buf[0] = (png_byte )pal_ptr->red;
#line 889
    buf[1] = (png_byte )pal_ptr->green;
#line 890
    buf[2] = (png_byte )pal_ptr->blue;
#line 891
    png_write_chunk_data(png_ptr, (png_const_bytep )(buf), (size_t )3);
#line 886
    i ++;
#line 886
    pal_ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 909
  png_write_chunk_end(png_ptr);
#line 910
  png_ptr->mode |= 2U;
#line 911
  return;
}
}
#line 930 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
void png_compress_IDAT(png_structrp png_ptr , png_const_bytep input , png_alloc_size_t input_len ,
                       int flush )
{
  png_voidp __attribute__((__malloc__))  tmp ;
  png_alloc_size_t tmp___0 ;
  int tmp___1 ;
  int ret ;
  uInt avail ;
  int tmp___2 ;
  png_bytep data ;
  uInt size ;
  png_alloc_size_t tmp___3 ;
  png_bytep data___0 ;
  uInt size___0 ;
  png_alloc_size_t tmp___4 ;

  {
#line 934
  if (png_ptr->zowner != ((((73U << 24) | (68U << 16)) | (65U << 8)) | 84U)) {
#line 941
    if ((unsigned long )png_ptr->zbuffer_list == (unsigned long )((void *)0)) {
#line 943
      tmp = png_malloc((png_const_structrp )png_ptr, (unsigned long )(& ((png_compression_buffer *)0)->output) + (unsigned long )png_ptr->zbuffer_size);
#line 943
      png_ptr->zbuffer_list = (png_compression_bufferp )tmp;
#line 945
      (png_ptr->zbuffer_list)->next = (struct png_compression_buffer *)((void *)0);
    } else {
#line 949
      png_free_buffer_list(png_ptr, & (png_ptr->zbuffer_list)->next);
    }
#line 952
    tmp___0 = png_image_size(png_ptr);
#line 952
    tmp___1 = png_deflate_claim(png_ptr, (((73U << 24) | (68U << 16)) | (65U << 8)) | 84U,
                                tmp___0);
#line 952
    if (tmp___1 != 0) {
#line 953
      png_error((png_const_structrp )png_ptr, png_ptr->zstream.msg);
    }
#line 958
    png_ptr->zstream.next_out = (png_ptr->zbuffer_list)->output;
#line 959
    png_ptr->zstream.avail_out = png_ptr->zbuffer_size;
  }
#line 966
  png_ptr->zstream.next_in = input;
#line 967
  png_ptr->zstream.avail_in = (uInt )0;
  {
#line 968
  while (1) {
    while_continue: /* CIL Label */ ;
#line 973
    avail = (uInt )-1;
#line 975
    if ((png_alloc_size_t )avail > input_len) {
#line 976
      avail = (uInt )input_len;
    }
#line 978
    png_ptr->zstream.avail_in = avail;
#line 979
    input_len -= (png_alloc_size_t )avail;
#line 981
    if (input_len > 0UL) {
#line 981
      tmp___2 = 0;
    } else {
#line 981
      tmp___2 = flush;
    }
#line 981
    ret = deflate(& png_ptr->zstream, tmp___2);
#line 984
    input_len += (png_alloc_size_t )png_ptr->zstream.avail_in;
#line 985
    png_ptr->zstream.avail_in = (uInt )0;
#line 991
    if (png_ptr->zstream.avail_out == 0U) {
#line 993
      data = (png_ptr->zbuffer_list)->output;
#line 994
      size = png_ptr->zbuffer_size;
#line 1000
      if ((png_ptr->mode & 0x04U) == 0U) {
#line 1000
        if ((int )png_ptr->compression_type == 0) {
#line 1002
          tmp___3 = png_image_size(png_ptr);
#line 1002
          optimize_cmf(data, tmp___3);
        }
      }
#line 1005
      if (size > 0U) {
#line 1006
        png_write_complete_chunk(png_ptr, (((73U << 24) | (68U << 16)) | (65U << 8)) | 84U,
                                 (png_const_bytep )data, (size_t )size);
      }
#line 1007
      png_ptr->mode |= 0x04U;
#line 1009
      png_ptr->zstream.next_out = data;
#line 1010
      png_ptr->zstream.avail_out = size;
#line 1016
      if (ret == 0) {
#line 1016
        if (flush != 0) {
#line 1017
          goto __Cont;
        }
      }
    }
#line 1023
    if (ret == 0) {
#line 1029
      if (input_len == 0UL) {
#line 1031
        if (flush == 4) {
#line 1032
          png_error((png_const_structrp )png_ptr, (png_const_charp )"Z_OK on Z_FINISH with output space");
        }
#line 1034
        return;
      }
    } else
#line 1038
    if (ret == 1) {
#line 1038
      if (flush == 4) {
#line 1043
        data___0 = (png_ptr->zbuffer_list)->output;
#line 1044
        size___0 = png_ptr->zbuffer_size - png_ptr->zstream.avail_out;
#line 1047
        if ((png_ptr->mode & 0x04U) == 0U) {
#line 1047
          if ((int )png_ptr->compression_type == 0) {
#line 1049
            tmp___4 = png_image_size(png_ptr);
#line 1049
            optimize_cmf(data___0, tmp___4);
          }
        }
#line 1052
        if (size___0 > 0U) {
#line 1053
          png_write_complete_chunk(png_ptr, (((73U << 24) | (68U << 16)) | (65U << 8)) | 84U,
                                   (png_const_bytep )data___0, (size_t )size___0);
        }
#line 1054
        png_ptr->zstream.avail_out = (uInt )0;
#line 1055
        png_ptr->zstream.next_out = (Bytef *)((void *)0);
#line 1056
        png_ptr->mode |= 12U;
#line 1058
        png_ptr->zowner = (png_uint_32 )0;
#line 1059
        return;
      } else {
#line 1065
        png_zstream_error(png_ptr, ret);
#line 1066
        png_error((png_const_structrp )png_ptr, png_ptr->zstream.msg);
      }
    } else {
#line 1065
      png_zstream_error(png_ptr, ret);
#line 1066
      png_error((png_const_structrp )png_ptr, png_ptr->zstream.msg);
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1072 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
void png_write_IEND(png_structrp png_ptr )
{


  {
#line 1077
  png_write_complete_chunk(png_ptr, (((73U << 24) | (69U << 16)) | (78U << 8)) | 68U,
                           (png_const_bytep )((void *)0), (size_t )0);
#line 1078
  png_ptr->mode |= 0x10U;
#line 1079
  return;
}
}
#line 1083 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
void png_write_gAMA_fixed(png_structrp png_ptr , png_fixed_point file_gamma )
{
  png_byte buf[4] ;

  {
#line 1091
  png_save_uint_32(buf, (png_uint_32 )file_gamma);
#line 1092
  png_write_complete_chunk(png_ptr, (((103U << 24) | (65U << 16)) | (77U << 8)) | 65U,
                           (png_const_bytep )(buf), (size_t )4);
#line 1093
  return;
}
}
#line 1098 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
void png_write_sRGB(png_structrp png_ptr , int srgb_intent )
{
  png_byte buf[1] ;

  {
#line 1105
  if (srgb_intent >= 4) {
#line 1106
    png_warning((png_const_structrp )png_ptr, (png_const_charp )"Invalid sRGB rendering intent specified");
  }
#line 1109
  buf[0] = (png_byte )srgb_intent;
#line 1110
  png_write_complete_chunk(png_ptr, (((115U << 24) | (82U << 16)) | (71U << 8)) | 66U,
                           (png_const_bytep )(buf), (size_t )1);
#line 1111
  return;
}
}
#line 1116 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
void png_write_iCCP(png_structrp png_ptr , png_const_charp name , png_const_bytep profile )
{
  png_uint_32 name_len ;
  png_uint_32 profile_len ;
  png_byte new_name[81] ;
  compression_state comp ;
  png_uint_32 temp ;
  png_uint_32 embedded_profile_len ;
  int tmp ;

  {
#line 1131
  if ((unsigned long )profile == (unsigned long )((void *)0)) {
#line 1132
    png_error((png_const_structrp )png_ptr, (png_const_charp )"No profile for iCCP chunk");
  }
#line 1134
  profile_len = ((((png_uint_32 )*profile << 24) + ((png_uint_32 )*(profile + 1) << 16)) + ((png_uint_32 )*(profile + 2) << 8)) + (png_uint_32 )*(profile + 3);
#line 1136
  if (profile_len < 132U) {
#line 1137
    png_error((png_const_structrp )png_ptr, (png_const_charp )"ICC profile too short");
  }
#line 1139
  temp = (png_uint_32 )*(profile + 8);
#line 1140
  if (temp > 3U) {
#line 1140
    if (profile_len & 3U) {
#line 1141
      png_error((png_const_structrp )png_ptr, (png_const_charp )"ICC profile length invalid (not a multiple of 4)");
    }
  }
#line 1144
  embedded_profile_len = ((((png_uint_32 )*profile << 24) + ((png_uint_32 )*(profile + 1) << 16)) + ((png_uint_32 )*(profile + 2) << 8)) + (png_uint_32 )*(profile + 3);
#line 1146
  if (profile_len != embedded_profile_len) {
#line 1147
    png_error((png_const_structrp )png_ptr, (png_const_charp )"Profile length does not match profile");
  }
#line 1150
  name_len = png_check_keyword(png_ptr, name, new_name);
#line 1152
  if (name_len == 0U) {
#line 1153
    png_error((png_const_structrp )png_ptr, (png_const_charp )"iCCP: invalid keyword");
  }
#line 1155
  name_len ++;
#line 1155
  new_name[name_len] = (png_byte )0;
#line 1158
  name_len ++;
#line 1160
  png_text_compress_init(& comp, profile, (png_alloc_size_t )profile_len);
#line 1163
  tmp = png_text_compress(png_ptr, (((105U << 24) | (67U << 16)) | (67U << 8)) | 80U,
                          & comp, name_len);
#line 1163
  if (tmp != 0) {
#line 1164
    png_error((png_const_structrp )png_ptr, png_ptr->zstream.msg);
  }
#line 1166
  png_write_chunk_header(png_ptr, (((105U << 24) | (67U << 16)) | (67U << 8)) | 80U,
                         name_len + comp.output_len);
#line 1168
  png_write_chunk_data(png_ptr, (png_const_bytep )(new_name), (size_t )name_len);
#line 1170
  png_write_compressed_data_out(png_ptr, & comp);
#line 1172
  png_write_chunk_end(png_ptr);
#line 1173
  return;
}
}
#line 1178 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
void png_write_sPLT(png_structrp png_ptr , png_const_sPLT_tp spalette )
{
  png_uint_32 name_len ;
  png_byte new_name[80] ;
  png_byte entrybuf[10] ;
  size_t entry_size ;
  int tmp ;
  size_t palette_size ;
  png_sPLT_entryp ep ;

  {
#line 1184
  if ((int )spalette->depth == 8) {
#line 1184
    tmp = 6;
  } else {
#line 1184
    tmp = 10;
  }
#line 1184
  entry_size = (size_t )tmp;
#line 1185
  palette_size = entry_size * (size_t )spalette->nentries;
#line 1193
  name_len = png_check_keyword(png_ptr, (png_const_charp )spalette->name, new_name);
#line 1195
  if (name_len == 0U) {
#line 1196
    png_error((png_const_structrp )png_ptr, (png_const_charp )"sPLT: invalid keyword");
  }
#line 1199
  png_write_chunk_header(png_ptr, (((115U << 24) | (80U << 16)) | (76U << 8)) | 84U,
                         (png_uint_32 )((size_t )(name_len + 2U) + palette_size));
#line 1202
  png_write_chunk_data(png_ptr, (png_const_bytep )(new_name), (size_t )(name_len + 1U));
#line 1204
  png_write_chunk_data(png_ptr, (png_const_bytep )(& spalette->depth), (size_t )1);
#line 1208
  ep = (png_sPLT_entryp )spalette->entries;
  {
#line 1208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1208
    if (! ((unsigned long )ep < (unsigned long )(spalette->entries + spalette->nentries))) {
#line 1208
      goto while_break;
    }
#line 1210
    if ((int )spalette->depth == 8) {
#line 1212
      entrybuf[0] = (png_byte )ep->red;
#line 1213
      entrybuf[1] = (png_byte )ep->green;
#line 1214
      entrybuf[2] = (png_byte )ep->blue;
#line 1215
      entrybuf[3] = (png_byte )ep->alpha;
#line 1216
      png_save_uint_16(entrybuf + 4, (unsigned int )ep->frequency);
    } else {
#line 1221
      png_save_uint_16(entrybuf + 0, (unsigned int )ep->red);
#line 1222
      png_save_uint_16(entrybuf + 2, (unsigned int )ep->green);
#line 1223
      png_save_uint_16(entrybuf + 4, (unsigned int )ep->blue);
#line 1224
      png_save_uint_16(entrybuf + 6, (unsigned int )ep->alpha);
#line 1225
      png_save_uint_16(entrybuf + 8, (unsigned int )ep->frequency);
    }
#line 1228
    png_write_chunk_data(png_ptr, (png_const_bytep )(entrybuf), entry_size);
#line 1208
    ep ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1256
  png_write_chunk_end(png_ptr);
#line 1257
  return;
}
}
#line 1262 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
void png_write_sBIT(png_structrp png_ptr , png_const_color_8p sbit , int color_type )
{
  png_byte buf[4] ;
  size_t size ;
  png_byte maxbits ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 1271
  if ((color_type & 2) != 0) {
#line 1275
    if (color_type == 3) {
#line 1275
      tmp = 8;
    } else {
#line 1275
      tmp = (int )png_ptr->usr_bit_depth;
    }
#line 1275
    maxbits = (png_byte )tmp;
#line 1278
    if ((int )sbit->red == 0) {
#line 1282
      png_warning((png_const_structrp )png_ptr, (png_const_charp )"Invalid sBIT depth specified");
#line 1283
      return;
    } else
#line 1278
    if ((int )sbit->red > (int )maxbits) {
#line 1282
      png_warning((png_const_structrp )png_ptr, (png_const_charp )"Invalid sBIT depth specified");
#line 1283
      return;
    } else
#line 1278
    if ((int )sbit->green == 0) {
#line 1282
      png_warning((png_const_structrp )png_ptr, (png_const_charp )"Invalid sBIT depth specified");
#line 1283
      return;
    } else
#line 1278
    if ((int )sbit->green > (int )maxbits) {
#line 1282
      png_warning((png_const_structrp )png_ptr, (png_const_charp )"Invalid sBIT depth specified");
#line 1283
      return;
    } else
#line 1278
    if ((int )sbit->blue == 0) {
#line 1282
      png_warning((png_const_structrp )png_ptr, (png_const_charp )"Invalid sBIT depth specified");
#line 1283
      return;
    } else
#line 1278
    if ((int )sbit->blue > (int )maxbits) {
#line 1282
      png_warning((png_const_structrp )png_ptr, (png_const_charp )"Invalid sBIT depth specified");
#line 1283
      return;
    }
#line 1286
    buf[0] = (png_byte )sbit->red;
#line 1287
    buf[1] = (png_byte )sbit->green;
#line 1288
    buf[2] = (png_byte )sbit->blue;
#line 1289
    size = (size_t )3;
  } else {
#line 1294
    if ((int )sbit->gray == 0) {
#line 1296
      png_warning((png_const_structrp )png_ptr, (png_const_charp )"Invalid sBIT depth specified");
#line 1297
      return;
    } else
#line 1294
    if ((int )sbit->gray > (int )png_ptr->usr_bit_depth) {
#line 1296
      png_warning((png_const_structrp )png_ptr, (png_const_charp )"Invalid sBIT depth specified");
#line 1297
      return;
    }
#line 1300
    buf[0] = (png_byte )sbit->gray;
#line 1301
    size = (size_t )1;
  }
#line 1304
  if ((color_type & 4) != 0) {
#line 1306
    if ((int )sbit->alpha == 0) {
#line 1308
      png_warning((png_const_structrp )png_ptr, (png_const_charp )"Invalid sBIT depth specified");
#line 1309
      return;
    } else
#line 1306
    if ((int )sbit->alpha > (int )png_ptr->usr_bit_depth) {
#line 1308
      png_warning((png_const_structrp )png_ptr, (png_const_charp )"Invalid sBIT depth specified");
#line 1309
      return;
    }
#line 1312
    tmp___0 = size;
#line 1312
    size ++;
#line 1312
    buf[tmp___0] = (png_byte )sbit->alpha;
  }
#line 1315
  png_write_complete_chunk(png_ptr, (((115U << 24) | (66U << 16)) | (73U << 8)) | 84U,
                           (png_const_bytep )(buf), size);
#line 1316
  return;
}
}
#line 1321 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
void png_write_cHRM_fixed(png_structrp png_ptr , png_xy const   *xy )
{
  png_byte buf[32] ;

  {
#line 1329
  png_save_int_32(buf, (png_int_32 )xy->whitex);
#line 1330
  png_save_int_32(buf + 4, (png_int_32 )xy->whitey);
#line 1332
  png_save_int_32(buf + 8, (png_int_32 )xy->redx);
#line 1333
  png_save_int_32(buf + 12, (png_int_32 )xy->redy);
#line 1335
  png_save_int_32(buf + 16, (png_int_32 )xy->greenx);
#line 1336
  png_save_int_32(buf + 20, (png_int_32 )xy->greeny);
#line 1338
  png_save_int_32(buf + 24, (png_int_32 )xy->bluex);
#line 1339
  png_save_int_32(buf + 28, (png_int_32 )xy->bluey);
#line 1341
  png_write_complete_chunk(png_ptr, (((99U << 24) | (72U << 16)) | (82U << 8)) | 77U,
                           (png_const_bytep )(buf), (size_t )32);
#line 1342
  return;
}
}
#line 1347 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
void png_write_tRNS(png_structrp png_ptr , png_const_bytep trans_alpha , png_const_color_16p tran ,
                    int num_trans , int color_type )
{
  png_byte buf[6] ;

  {
#line 1355
  if (color_type == 3) {
#line 1357
    if (num_trans <= 0) {
#line 1359
      png_app_warning((png_const_structrp )png_ptr, (png_const_charp )"Invalid number of transparent colors specified");
#line 1361
      return;
    } else
#line 1357
    if (num_trans > (int )png_ptr->num_palette) {
#line 1359
      png_app_warning((png_const_structrp )png_ptr, (png_const_charp )"Invalid number of transparent colors specified");
#line 1361
      return;
    }
#line 1365
    png_write_complete_chunk(png_ptr, (((116U << 24) | (82U << 16)) | (78U << 8)) | 83U,
                             trans_alpha, (size_t )num_trans);
  } else
#line 1369
  if (color_type == 0) {
#line 1372
    if ((int )tran->gray >= (int )(1 << (int )png_ptr->bit_depth)) {
#line 1374
      png_app_warning((png_const_structrp )png_ptr, (png_const_charp )"Ignoring attempt to write tRNS chunk out-of-range for bit_depth");
#line 1377
      return;
    }
#line 1380
    png_save_uint_16(buf, (unsigned int )tran->gray);
#line 1381
    png_write_complete_chunk(png_ptr, (((116U << 24) | (82U << 16)) | (78U << 8)) | 83U,
                             (png_const_bytep )(buf), (size_t )2);
  } else
#line 1384
  if (color_type == 2) {
#line 1387
    png_save_uint_16(buf, (unsigned int )tran->red);
#line 1388
    png_save_uint_16(buf + 2, (unsigned int )tran->green);
#line 1389
    png_save_uint_16(buf + 4, (unsigned int )tran->blue);
#line 1391
    if ((int )png_ptr->bit_depth == 8) {
#line 1391
      if ((((int )buf[0] | (int )buf[2]) | (int )buf[4]) != 0) {
#line 1396
        png_app_warning((png_const_structrp )png_ptr, (png_const_charp )"Ignoring attempt to write 16-bit tRNS chunk when bit_depth is 8");
#line 1398
        return;
      }
    }
#line 1401
    png_write_complete_chunk(png_ptr, (((116U << 24) | (82U << 16)) | (78U << 8)) | 83U,
                             (png_const_bytep )(buf), (size_t )6);
  } else {
#line 1406
    png_app_warning((png_const_structrp )png_ptr, (png_const_charp )"Can\'t write tRNS with an alpha channel");
  }
#line 1408
  return;
}
}
#line 1413 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
void png_write_bKGD(png_structrp png_ptr , png_const_color_16p back , int color_type )
{
  png_byte buf[6] ;

  {
#line 1420
  if (color_type == 3) {
#line 1422
    if ((int )png_ptr->num_palette != 0) {
#line 1422
      goto _L;
    } else
#line 1422
    if ((png_ptr->mng_features_permitted & 1U) == 0U) {
      _L: /* CIL Label */
#line 1422
      if ((int )back->index >= (int )png_ptr->num_palette) {
#line 1429
        png_warning((png_const_structrp )png_ptr, (png_const_charp )"Invalid background palette index");
#line 1430
        return;
      }
    }
#line 1433
    buf[0] = (png_byte )back->index;
#line 1434
    png_write_complete_chunk(png_ptr, (((98U << 24) | (75U << 16)) | (71U << 8)) | 68U,
                             (png_const_bytep )(buf), (size_t )1);
  } else
#line 1437
  if ((color_type & 2) != 0) {
#line 1439
    png_save_uint_16(buf, (unsigned int )back->red);
#line 1440
    png_save_uint_16(buf + 2, (unsigned int )back->green);
#line 1441
    png_save_uint_16(buf + 4, (unsigned int )back->blue);
#line 1443
    if ((int )png_ptr->bit_depth == 8) {
#line 1443
      if ((((int )buf[0] | (int )buf[2]) | (int )buf[4]) != 0) {
#line 1448
        png_warning((png_const_structrp )png_ptr, (png_const_charp )"Ignoring attempt to write 16-bit bKGD chunk when bit_depth is 8");
#line 1452
        return;
      }
    }
#line 1455
    png_write_complete_chunk(png_ptr, (((98U << 24) | (75U << 16)) | (71U << 8)) | 68U,
                             (png_const_bytep )(buf), (size_t )6);
  } else {
#line 1460
    if ((int )back->gray >= (int )(1 << (int )png_ptr->bit_depth)) {
#line 1462
      png_warning((png_const_structrp )png_ptr, (png_const_charp )"Ignoring attempt to write bKGD chunk out-of-range for bit_depth");
#line 1465
      return;
    }
#line 1468
    png_save_uint_16(buf, (unsigned int )back->gray);
#line 1469
    png_write_complete_chunk(png_ptr, (((98U << 24) | (75U << 16)) | (71U << 8)) | 68U,
                             (png_const_bytep )(buf), (size_t )2);
  }
#line 1471
  return;
}
}
#line 1476 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
void png_write_eXIf(png_structrp png_ptr , png_bytep exif , int num_exif )
{
  int i ;
  png_byte buf[1] ;

  {
#line 1484
  png_write_chunk_header(png_ptr, (((101U << 24) | (88U << 16)) | (73U << 8)) | 102U,
                         (png_uint_32 )num_exif);
#line 1486
  i = 0;
  {
#line 1486
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1486
    if (! (i < num_exif)) {
#line 1486
      goto while_break;
    }
#line 1488
    buf[0] = *(exif + i);
#line 1489
    png_write_chunk_data(png_ptr, (png_const_bytep )(buf), (size_t )1);
#line 1486
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1492
  png_write_chunk_end(png_ptr);
#line 1493
  return;
}
}
#line 1498 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
void png_write_hIST(png_structrp png_ptr , png_const_uint_16p hist , int num_hist )
{
  int i ;
  png_byte buf[3] ;

  {
#line 1506
  if (num_hist > (int )png_ptr->num_palette) {
#line 1511
    png_warning((png_const_structrp )png_ptr, (png_const_charp )"Invalid number of histogram entries specified");
#line 1512
    return;
  }
#line 1515
  png_write_chunk_header(png_ptr, (((104U << 24) | (73U << 16)) | (83U << 8)) | 84U,
                         (png_uint_32 )(num_hist * 2));
#line 1517
  i = 0;
  {
#line 1517
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1517
    if (! (i < num_hist)) {
#line 1517
      goto while_break;
    }
#line 1519
    png_save_uint_16(buf, (unsigned int )*(hist + i));
#line 1520
    png_write_chunk_data(png_ptr, (png_const_bytep )(buf), (size_t )2);
#line 1517
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1523
  png_write_chunk_end(png_ptr);
#line 1524
  return;
}
}
#line 1529 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
void png_write_tEXt(png_structrp png_ptr , png_const_charp key___3 , png_const_charp text ,
                    size_t text_len )
{
  png_uint_32 key_len ;
  png_byte new_key[80] ;

  {
#line 1538
  key_len = png_check_keyword(png_ptr, key___3, new_key);
#line 1540
  if (key_len == 0U) {
#line 1541
    png_error((png_const_structrp )png_ptr, (png_const_charp )"tEXt: invalid keyword");
  }
#line 1543
  if ((unsigned long )text == (unsigned long )((void *)0)) {
#line 1544
    text_len = (size_t )0;
  } else
#line 1543
  if ((int const   )*text == 0) {
#line 1544
    text_len = (size_t )0;
  } else {
#line 1547
    text_len = strlen(text);
  }
#line 1549
  if (text_len > (size_t )(2147483647U - (key_len + 1U))) {
#line 1550
    png_error((png_const_structrp )png_ptr, (png_const_charp )"tEXt: text too long");
  }
#line 1553
  png_write_chunk_header(png_ptr, (((116U << 24) | (69U << 16)) | (88U << 8)) | 116U,
                         (png_uint_32 )(((size_t )key_len + text_len) + 1UL));
#line 1561
  png_write_chunk_data(png_ptr, (png_const_bytep )(new_key), (size_t )(key_len + 1U));
#line 1563
  if (text_len != 0UL) {
#line 1564
    png_write_chunk_data(png_ptr, (png_const_bytep )text, text_len);
  }
#line 1566
  png_write_chunk_end(png_ptr);
#line 1567
  return;
}
}
#line 1572 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
void png_write_zTXt(png_structrp png_ptr , png_const_charp key___3 , png_const_charp text ,
                    int compression )
{
  png_uint_32 key_len ;
  png_byte new_key[81] ;
  compression_state comp ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 1582
  if (compression == -1) {
#line 1584
    png_write_tEXt(png_ptr, key___3, text, (size_t )0);
#line 1585
    return;
  }
#line 1588
  if (compression != 0) {
#line 1589
    png_error((png_const_structrp )png_ptr, (png_const_charp )"zTXt: invalid compression type");
  }
#line 1591
  key_len = png_check_keyword(png_ptr, key___3, new_key);
#line 1593
  if (key_len == 0U) {
#line 1594
    png_error((png_const_structrp )png_ptr, (png_const_charp )"zTXt: invalid keyword");
  }
#line 1597
  key_len ++;
#line 1597
  new_key[key_len] = (png_byte )0;
#line 1598
  key_len ++;
#line 1601
  if ((unsigned long )text == (unsigned long )((void *)0)) {
#line 1601
    tmp___0 = (size_t )0;
  } else {
#line 1601
    tmp = strlen(text);
#line 1601
    tmp___0 = tmp;
  }
#line 1601
  png_text_compress_init(& comp, (png_const_bytep )text, tmp___0);
#line 1604
  tmp___1 = png_text_compress(png_ptr, (((122U << 24) | (84U << 16)) | (88U << 8)) | 116U,
                              & comp, key_len);
#line 1604
  if (tmp___1 != 0) {
#line 1605
    png_error((png_const_structrp )png_ptr, png_ptr->zstream.msg);
  }
#line 1608
  png_write_chunk_header(png_ptr, (((122U << 24) | (84U << 16)) | (88U << 8)) | 116U,
                         key_len + comp.output_len);
#line 1611
  png_write_chunk_data(png_ptr, (png_const_bytep )(new_key), (size_t )key_len);
#line 1614
  png_write_compressed_data_out(png_ptr, & comp);
#line 1617
  png_write_chunk_end(png_ptr);
#line 1618
  return;
}
}
#line 1623 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
void png_write_iTXt(png_structrp png_ptr , int compression , png_const_charp key___3 ,
                    png_const_charp lang , png_const_charp lang_key , png_const_charp text )
{
  png_uint_32 key_len ;
  png_uint_32 prefix_len ;
  size_t lang_len ;
  size_t lang_key_len ;
  png_byte new_key[82] ;
  compression_state comp ;
  png_byte tmp ;
  png_byte tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
#line 1634
  key_len = png_check_keyword(png_ptr, key___3, new_key);
#line 1636
  if (key_len == 0U) {
#line 1637
    png_error((png_const_structrp )png_ptr, (png_const_charp )"iTXt: invalid keyword");
  }
  {
#line 1643
  if (compression == -1) {
#line 1643
    goto case_neg_1;
  }
#line 1643
  if (compression == 1) {
#line 1643
    goto case_neg_1;
  }
#line 1648
  if (compression == 2) {
#line 1648
    goto case_2;
  }
#line 1648
  if (compression == 0) {
#line 1648
    goto case_2;
  }
#line 1652
  goto switch_default;
  case_neg_1: /* CIL Label */
  case_1: /* CIL Label */
#line 1644
  key_len ++;
#line 1644
  tmp = (png_byte )0;
#line 1644
  new_key[key_len] = tmp;
#line 1644
  compression = (int )tmp;
#line 1645
  goto switch_break;
  case_2: /* CIL Label */
  case_0: /* CIL Label */
#line 1649
  key_len ++;
#line 1649
  tmp___0 = (png_byte )1;
#line 1649
  new_key[key_len] = tmp___0;
#line 1649
  compression = (int )tmp___0;
#line 1650
  goto switch_break;
  switch_default: /* CIL Label */
#line 1653
  png_error((png_const_structrp )png_ptr, (png_const_charp )"iTXt: invalid compression");
  switch_break: /* CIL Label */ ;
  }
#line 1656
  key_len ++;
#line 1656
  new_key[key_len] = (png_byte )0;
#line 1657
  key_len ++;
#line 1669
  if ((unsigned long )lang == (unsigned long )((void *)0)) {
#line 1669
    lang = (png_const_charp )"";
  }
#line 1670
  tmp___1 = strlen(lang);
#line 1670
  lang_len = tmp___1 + 1UL;
#line 1671
  if ((unsigned long )lang_key == (unsigned long )((void *)0)) {
#line 1671
    lang_key = (png_const_charp )"";
  }
#line 1672
  tmp___2 = strlen(lang_key);
#line 1672
  lang_key_len = tmp___2 + 1UL;
#line 1673
  if ((unsigned long )text == (unsigned long )((void *)0)) {
#line 1673
    text = (png_const_charp )"";
  }
#line 1675
  prefix_len = key_len;
#line 1676
  if (lang_len > (size_t )(2147483647U - prefix_len)) {
#line 1677
    prefix_len = (png_uint_32 )0x7fffffffL;
  } else {
#line 1679
    prefix_len = (png_uint_32 )((size_t )prefix_len + lang_len);
  }
#line 1681
  if (lang_key_len > (size_t )(2147483647U - prefix_len)) {
#line 1682
    prefix_len = (png_uint_32 )0x7fffffffL;
  } else {
#line 1684
    prefix_len = (png_uint_32 )((size_t )prefix_len + lang_key_len);
  }
#line 1686
  tmp___3 = strlen(text);
#line 1686
  png_text_compress_init(& comp, (png_const_bytep )text, tmp___3);
#line 1688
  if (compression != 0) {
#line 1690
    tmp___4 = png_text_compress(png_ptr, (((105U << 24) | (84U << 16)) | (88U << 8)) | 116U,
                                & comp, prefix_len);
#line 1690
    if (tmp___4 != 0) {
#line 1691
      png_error((png_const_structrp )png_ptr, png_ptr->zstream.msg);
    }
  } else {
#line 1696
    if (comp.input_len > (png_alloc_size_t )(2147483647U - prefix_len)) {
#line 1697
      png_error((png_const_structrp )png_ptr, (png_const_charp )"iTXt: uncompressed text too long");
    }
#line 1700
    comp.output_len = (png_uint_32 )comp.input_len;
  }
#line 1703
  png_write_chunk_header(png_ptr, (((105U << 24) | (84U << 16)) | (88U << 8)) | 116U,
                         comp.output_len + prefix_len);
#line 1705
  png_write_chunk_data(png_ptr, (png_const_bytep )(new_key), (size_t )key_len);
#line 1707
  png_write_chunk_data(png_ptr, (png_const_bytep )lang, lang_len);
#line 1709
  png_write_chunk_data(png_ptr, (png_const_bytep )lang_key, lang_key_len);
#line 1711
  if (compression != 0) {
#line 1712
    png_write_compressed_data_out(png_ptr, & comp);
  } else {
#line 1715
    png_write_chunk_data(png_ptr, (png_const_bytep )text, (size_t )comp.output_len);
  }
#line 1717
  png_write_chunk_end(png_ptr);
#line 1718
  return;
}
}
#line 1723 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
void png_write_oFFs(png_structrp png_ptr , png_int_32 x_offset , png_int_32 y_offset ,
                    int unit_type )
{
  png_byte buf[9] ;

  {
#line 1731
  if (unit_type >= 2) {
#line 1732
    png_warning((png_const_structrp )png_ptr, (png_const_charp )"Unrecognized unit type for oFFs chunk");
  }
#line 1734
  png_save_int_32(buf, x_offset);
#line 1735
  png_save_int_32(buf + 4, y_offset);
#line 1736
  buf[8] = (png_byte )unit_type;
#line 1738
  png_write_complete_chunk(png_ptr, (((111U << 24) | (70U << 16)) | (70U << 8)) | 115U,
                           (png_const_bytep )(buf), (size_t )9);
#line 1739
  return;
}
}
#line 1743 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
void png_write_pCAL(png_structrp png_ptr , png_charp purpose , png_int_32 X0 , png_int_32 X1 ,
                    int type , int nparams , png_const_charp units , png_charpp params )
{
  png_uint_32 purpose_len ;
  size_t units_len ;
  size_t total_len ;
  size_t *params_len ;
  png_byte buf[10] ;
  png_byte new_purpose[80] ;
  int i ;
  size_t tmp ;
  int tmp___0 ;
  png_voidp __attribute__((__malloc__))  tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
#line 1757
  if (type >= 4) {
#line 1758
    png_error((png_const_structrp )png_ptr, (png_const_charp )"Unrecognized equation type for pCAL chunk");
  }
#line 1760
  purpose_len = png_check_keyword(png_ptr, (png_const_charp )purpose, new_purpose);
#line 1762
  if (purpose_len == 0U) {
#line 1763
    png_error((png_const_structrp )png_ptr, (png_const_charp )"pCAL: invalid keyword");
  }
#line 1765
  purpose_len ++;
#line 1768
  tmp = strlen(units);
#line 1768
  if (nparams == 0) {
#line 1768
    tmp___0 = 0;
  } else {
#line 1768
    tmp___0 = 1;
  }
#line 1768
  units_len = tmp + (size_t )tmp___0;
#line 1770
  total_len = ((size_t )purpose_len + units_len) + 10UL;
#line 1772
  tmp___1 = png_malloc((png_const_structrp )png_ptr, (png_alloc_size_t )nparams * sizeof(size_t ));
#line 1772
  params_len = (size_t *)tmp___1;
#line 1778
  i = 0;
  {
#line 1778
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1778
    if (! (i < nparams)) {
#line 1778
      goto while_break;
    }
#line 1780
    tmp___2 = strlen((char const   *)*(params + i));
#line 1780
    if (i == nparams - 1) {
#line 1780
      tmp___3 = 0;
    } else {
#line 1780
      tmp___3 = 1;
    }
#line 1780
    *(params_len + i) = tmp___2 + (size_t )tmp___3;
#line 1783
    total_len += *(params_len + i);
#line 1778
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1787
  png_write_chunk_header(png_ptr, (((112U << 24) | (67U << 16)) | (65U << 8)) | 76U,
                         (png_uint_32 )total_len);
#line 1788
  png_write_chunk_data(png_ptr, (png_const_bytep )(new_purpose), (size_t )purpose_len);
#line 1789
  png_save_int_32(buf, X0);
#line 1790
  png_save_int_32(buf + 4, X1);
#line 1791
  buf[8] = (png_byte )type;
#line 1792
  buf[9] = (png_byte )nparams;
#line 1793
  png_write_chunk_data(png_ptr, (png_const_bytep )(buf), (size_t )10);
#line 1794
  png_write_chunk_data(png_ptr, (png_const_bytep )units, units_len);
#line 1796
  i = 0;
  {
#line 1796
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1796
    if (! (i < nparams)) {
#line 1796
      goto while_break___0;
    }
#line 1798
    png_write_chunk_data(png_ptr, (png_const_bytep )*(params + i), *(params_len + i));
#line 1796
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1801
  png_free((png_const_structrp )png_ptr, (png_voidp )params_len);
#line 1802
  png_write_chunk_end(png_ptr);
#line 1803
  return;
}
}
#line 1808 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
void png_write_sCAL_s(png_structrp png_ptr , int unit , png_const_charp width , png_const_charp height )
{
  png_byte buf[64] ;
  size_t wlen ;
  size_t hlen ;
  size_t total_len ;

  {
#line 1817
  wlen = strlen(width);
#line 1818
  hlen = strlen(height);
#line 1819
  total_len = (wlen + hlen) + 2UL;
#line 1821
  if (total_len > 64UL) {
#line 1823
    png_warning((png_const_structrp )png_ptr, (png_const_charp )"Can\'t write sCAL (buffer too small)");
#line 1824
    return;
  }
#line 1827
  buf[0] = (png_byte )unit;
#line 1828
  memcpy((void *)(buf + 1), (void const   *)width, wlen + 1UL);
#line 1829
  memcpy((void *)((buf + wlen) + 2), (void const   *)height, hlen);
#line 1832
  png_write_complete_chunk(png_ptr, (((115U << 24) | (67U << 16)) | (65U << 8)) | 76U,
                           (png_const_bytep )(buf), total_len);
#line 1833
  return;
}
}
#line 1838 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
void png_write_pHYs(png_structrp png_ptr , png_uint_32 x_pixels_per_unit , png_uint_32 y_pixels_per_unit ,
                    int unit_type )
{
  png_byte buf[9] ;

  {
#line 1847
  if (unit_type >= 2) {
#line 1848
    png_warning((png_const_structrp )png_ptr, (png_const_charp )"Unrecognized unit type for pHYs chunk");
  }
#line 1850
  png_save_uint_32(buf, x_pixels_per_unit);
#line 1851
  png_save_uint_32(buf + 4, y_pixels_per_unit);
#line 1852
  buf[8] = (png_byte )unit_type;
#line 1854
  png_write_complete_chunk(png_ptr, (((112U << 24) | (72U << 16)) | (89U << 8)) | 115U,
                           (png_const_bytep )(buf), (size_t )9);
#line 1855
  return;
}
}
#line 1862 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
void png_write_tIME(png_structrp png_ptr , png_const_timep mod_time )
{
  png_byte buf[7] ;

  {
#line 1869
  if ((int )mod_time->month > 12) {
#line 1873
    png_warning((png_const_structrp )png_ptr, (png_const_charp )"Invalid time specified for tIME chunk");
#line 1874
    return;
  } else
#line 1869
  if ((int )mod_time->month < 1) {
#line 1873
    png_warning((png_const_structrp )png_ptr, (png_const_charp )"Invalid time specified for tIME chunk");
#line 1874
    return;
  } else
#line 1869
  if ((int )mod_time->day > 31) {
#line 1873
    png_warning((png_const_structrp )png_ptr, (png_const_charp )"Invalid time specified for tIME chunk");
#line 1874
    return;
  } else
#line 1869
  if ((int )mod_time->day < 1) {
#line 1873
    png_warning((png_const_structrp )png_ptr, (png_const_charp )"Invalid time specified for tIME chunk");
#line 1874
    return;
  } else
#line 1869
  if ((int )mod_time->hour > 23) {
#line 1873
    png_warning((png_const_structrp )png_ptr, (png_const_charp )"Invalid time specified for tIME chunk");
#line 1874
    return;
  } else
#line 1869
  if ((int )mod_time->second > 60) {
#line 1873
    png_warning((png_const_structrp )png_ptr, (png_const_charp )"Invalid time specified for tIME chunk");
#line 1874
    return;
  }
#line 1877
  png_save_uint_16(buf, (unsigned int )mod_time->year);
#line 1878
  buf[2] = (png_byte )mod_time->month;
#line 1879
  buf[3] = (png_byte )mod_time->day;
#line 1880
  buf[4] = (png_byte )mod_time->hour;
#line 1881
  buf[5] = (png_byte )mod_time->minute;
#line 1882
  buf[6] = (png_byte )mod_time->second;
#line 1884
  png_write_complete_chunk(png_ptr, (((116U << 24) | (73U << 16)) | (77U << 8)) | 69U,
                           (png_const_bytep )(buf), (size_t )7);
#line 1885
  return;
}
}
#line 1896 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
static png_byte const   png_pass_start___2[7]  = {      (png_byte const   )0,      (png_byte const   )4,      (png_byte const   )0,      (png_byte const   )2,
        (png_byte const   )0,      (png_byte const   )1,      (png_byte const   )0};
#line 1899 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
static png_byte const   png_pass_inc___3[7]  = {      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )4,      (png_byte const   )4,
        (png_byte const   )2,      (png_byte const   )2,      (png_byte const   )1};
#line 1902 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
static png_byte const   png_pass_ystart___2[7]  = {      (png_byte const   )0,      (png_byte const   )0,      (png_byte const   )4,      (png_byte const   )0,
        (png_byte const   )2,      (png_byte const   )0,      (png_byte const   )1};
#line 1905 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
static png_byte const   png_pass_yinc___2[7]  = {      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )4,
        (png_byte const   )4,      (png_byte const   )2,      (png_byte const   )2};
#line 1889 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
void png_write_start_row(png_structrp png_ptr )
{
  png_alloc_size_t buf_size ;
  int usr_pixel_depth ;
  png_byte filters ;
  size_t tmp ;
  png_voidp __attribute__((__malloc__))  tmp___0 ;
  int num_filters ;
  png_voidp __attribute__((__malloc__))  tmp___1 ;
  png_voidp __attribute__((__malloc__))  tmp___2 ;
  png_voidp __attribute__((__malloc__))  tmp___3 ;

  {
#line 1917
  usr_pixel_depth = (int )png_ptr->usr_channels * (int )png_ptr->usr_bit_depth;
#line 1918
  if (usr_pixel_depth >= 8) {
#line 1918
    tmp = (size_t )png_ptr->width * ((size_t )usr_pixel_depth >> 3);
  } else {
#line 1918
    tmp = ((size_t )png_ptr->width * (size_t )usr_pixel_depth + 7UL) >> 3;
  }
#line 1918
  buf_size = tmp + 1UL;
#line 1921
  png_ptr->transformed_pixel_depth = png_ptr->pixel_depth;
#line 1922
  png_ptr->maximum_pixel_depth = (png_byte )usr_pixel_depth;
#line 1925
  tmp___0 = png_malloc((png_const_structrp )png_ptr, buf_size);
#line 1925
  png_ptr->row_buf = (png_bytep )tmp___0;
#line 1927
  *(png_ptr->row_buf + 0) = (png_byte )0;
#line 1930
  filters = png_ptr->do_filter;
#line 1932
  if (png_ptr->height == 1U) {
#line 1933
    filters = (png_byte )((int )filters & 31);
  }
#line 1935
  if (png_ptr->width == 1U) {
#line 1936
    filters = (png_byte )((int )filters & 47);
  }
#line 1938
  if ((int )filters == 0) {
#line 1939
    filters = (png_byte )0x08;
  }
#line 1941
  png_ptr->do_filter = filters;
#line 1943
  if (((int )filters & 240) != 0) {
#line 1943
    if ((unsigned long )png_ptr->try_row == (unsigned long )((void *)0)) {
#line 1946
      num_filters = 0;
#line 1948
      tmp___1 = png_malloc((png_const_structrp )png_ptr, buf_size);
#line 1948
      png_ptr->try_row = (png_bytep )tmp___1;
#line 1950
      if ((int )filters & 0x10) {
#line 1951
        num_filters ++;
      }
#line 1953
      if ((int )filters & 0x20) {
#line 1954
        num_filters ++;
      }
#line 1956
      if ((int )filters & 0x40) {
#line 1957
        num_filters ++;
      }
#line 1959
      if ((int )filters & 0x80) {
#line 1960
        num_filters ++;
      }
#line 1962
      if (num_filters > 1) {
#line 1963
        tmp___2 = png_malloc((png_const_structrp )png_ptr, buf_size);
#line 1963
        png_ptr->tst_row = (png_bytep )tmp___2;
      }
    }
  }
#line 1970
  if (((int )filters & 224) != 0) {
#line 1971
    tmp___3 = png_calloc((png_const_structrp )png_ptr, buf_size);
#line 1971
    png_ptr->prev_row = (png_bytep )tmp___3;
  }
#line 1977
  if ((int )png_ptr->interlaced != 0) {
#line 1979
    if ((png_ptr->transformations & 0x0002U) == 0U) {
#line 1981
      png_ptr->num_rows = (((png_ptr->height + (png_uint_32 )png_pass_yinc___2[0]) - 1U) - (png_uint_32 )png_pass_ystart___2[0]) / (png_uint_32 )png_pass_yinc___2[0];
#line 1984
      png_ptr->usr_width = (((png_ptr->width + (png_uint_32 )png_pass_inc___3[0]) - 1U) - (png_uint_32 )png_pass_start___2[0]) / (png_uint_32 )png_pass_inc___3[0];
    } else {
#line 1990
      png_ptr->num_rows = png_ptr->height;
#line 1991
      png_ptr->usr_width = png_ptr->width;
    }
  } else {
#line 1998
    png_ptr->num_rows = png_ptr->height;
#line 1999
    png_ptr->usr_width = png_ptr->width;
  }
#line 2001
  return;
}
}
#line 2011 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
static png_byte const   png_pass_start___3[7]  = {      (png_byte const   )0,      (png_byte const   )4,      (png_byte const   )0,      (png_byte const   )2,
        (png_byte const   )0,      (png_byte const   )1,      (png_byte const   )0};
#line 2014 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
static png_byte const   png_pass_inc___4[7]  = {      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )4,      (png_byte const   )4,
        (png_byte const   )2,      (png_byte const   )2,      (png_byte const   )1};
#line 2017 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
static png_byte const   png_pass_ystart___3[7]  = {      (png_byte const   )0,      (png_byte const   )0,      (png_byte const   )4,      (png_byte const   )0,
        (png_byte const   )2,      (png_byte const   )0,      (png_byte const   )1};
#line 2020 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
static png_byte const   png_pass_yinc___3[7]  = {      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )4,
        (png_byte const   )4,      (png_byte const   )2,      (png_byte const   )2};
#line 2004 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
void png_write_finish_row(png_structrp png_ptr )
{
  size_t tmp ;

  {
#line 2026
  (png_ptr->row_number) ++;
#line 2029
  if (png_ptr->row_number < png_ptr->num_rows) {
#line 2030
    return;
  }
#line 2034
  if ((int )png_ptr->interlaced != 0) {
#line 2036
    png_ptr->row_number = (png_uint_32 )0;
#line 2037
    if ((png_ptr->transformations & 0x0002U) != 0U) {
#line 2039
      png_ptr->pass = (png_byte )((int )png_ptr->pass + 1);
    } else {
      {
#line 2045
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2047
        png_ptr->pass = (png_byte )((int )png_ptr->pass + 1);
#line 2049
        if ((int )png_ptr->pass >= 7) {
#line 2050
          goto while_break;
        }
#line 2052
        png_ptr->usr_width = (((png_ptr->width + (png_uint_32 )png_pass_inc___4[png_ptr->pass]) - 1U) - (png_uint_32 )png_pass_start___3[png_ptr->pass]) / (png_uint_32 )png_pass_inc___4[png_ptr->pass];
#line 2057
        png_ptr->num_rows = (((png_ptr->height + (png_uint_32 )png_pass_yinc___3[png_ptr->pass]) - 1U) - (png_uint_32 )png_pass_ystart___3[png_ptr->pass]) / (png_uint_32 )png_pass_yinc___3[png_ptr->pass];
#line 2062
        if ((png_ptr->transformations & 0x0002U) != 0U) {
#line 2063
          goto while_break;
        }
#line 2045
        if (! (png_ptr->usr_width == 0U)) {
#line 2045
          if (! (png_ptr->num_rows == 0U)) {
#line 2045
            goto while_break;
          }
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 2070
    if ((int )png_ptr->pass < 7) {
#line 2072
      if ((unsigned long )png_ptr->prev_row != (unsigned long )((void *)0)) {
#line 2073
        if ((int )png_ptr->usr_channels * (int )png_ptr->usr_bit_depth >= 8) {
#line 2073
          tmp = (size_t )png_ptr->width * ((size_t )((int )png_ptr->usr_channels * (int )png_ptr->usr_bit_depth) >> 3);
        } else {
#line 2073
          tmp = ((size_t )png_ptr->width * (size_t )((int )png_ptr->usr_channels * (int )png_ptr->usr_bit_depth) + 7UL) >> 3;
        }
#line 2073
        memset((void *)png_ptr->prev_row, 0, tmp + 1UL);
      }
#line 2077
      return;
    }
  }
#line 2084
  png_compress_IDAT(png_ptr, (png_const_bytep )((void *)0), (png_alloc_size_t )0,
                    4);
#line 2085
  return;
}
}
#line 2101 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
static png_byte const   png_pass_start___4[7]  = {      (png_byte const   )0,      (png_byte const   )4,      (png_byte const   )0,      (png_byte const   )2,
        (png_byte const   )0,      (png_byte const   )1,      (png_byte const   )0};
#line 2104 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
static png_byte const   png_pass_inc___5[7]  = {      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )4,      (png_byte const   )4,
        (png_byte const   )2,      (png_byte const   )2,      (png_byte const   )1};
#line 2095 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
void png_do_write_interlace(png_row_infop row_info , png_bytep row , int pass )
{
  png_bytep sp ;
  png_bytep dp ;
  unsigned int shift ;
  int d ;
  int value ;
  png_uint_32 i ;
  png_uint_32 row_width ;
  png_bytep tmp ;
  png_bytep sp___0 ;
  png_bytep dp___0 ;
  unsigned int shift___0 ;
  int d___0 ;
  int value___0 ;
  png_uint_32 i___0 ;
  png_uint_32 row_width___0 ;
  png_bytep tmp___0 ;
  png_bytep sp___1 ;
  png_bytep dp___1 ;
  unsigned int shift___1 ;
  int d___1 ;
  int value___1 ;
  png_uint_32 i___1 ;
  png_uint_32 row_width___1 ;
  png_bytep tmp___1 ;
  png_bytep sp___2 ;
  png_bytep dp___2 ;
  png_uint_32 i___2 ;
  png_uint_32 row_width___2 ;
  size_t pixel_bytes ;

  {
#line 2109
  if (pass < 6) {
    {
#line 2114
    if ((int )row_info->pixel_depth == 1) {
#line 2114
      goto case_1;
    }
#line 2152
    if ((int )row_info->pixel_depth == 2) {
#line 2152
      goto case_2;
    }
#line 2189
    if ((int )row_info->pixel_depth == 4) {
#line 2189
      goto case_4;
    }
#line 2225
    goto switch_default;
    case_1: /* CIL Label */
#line 2122
    row_width = row_info->width;
#line 2124
    dp = row;
#line 2125
    d = 0;
#line 2126
    shift = 7U;
#line 2128
    i = (png_uint_32 )png_pass_start___4[pass];
    {
#line 2128
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2128
      if (! (i < row_width)) {
#line 2128
        goto while_break;
      }
#line 2131
      sp = row + (size_t )(i >> 3);
#line 2132
      value = ((int )*sp >> (7 - (int )(i & 7U))) & 0x01;
#line 2133
      d |= value << shift;
#line 2135
      if (shift == 0U) {
#line 2137
        shift = 7U;
#line 2138
        tmp = dp;
#line 2138
        dp ++;
#line 2138
        *tmp = (png_byte )d;
#line 2139
        d = 0;
      } else {
#line 2143
        shift --;
      }
#line 2128
      i += (png_uint_32 )png_pass_inc___5[pass];
    }
    while_break: /* CIL Label */ ;
    }
#line 2146
    if (shift != 7U) {
#line 2147
      *dp = (png_byte )d;
    }
#line 2149
    goto switch_break;
    case_2: /* CIL Label */
#line 2160
    row_width___0 = row_info->width;
#line 2162
    dp___0 = row;
#line 2163
    shift___0 = 6U;
#line 2164
    d___0 = 0;
#line 2166
    i___0 = (png_uint_32 )png_pass_start___4[pass];
    {
#line 2166
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2166
      if (! (i___0 < row_width___0)) {
#line 2166
        goto while_break___0;
      }
#line 2169
      sp___0 = row + (size_t )(i___0 >> 2);
#line 2170
      value___0 = ((int )*sp___0 >> ((3 - (int )(i___0 & 3U)) << 1)) & 0x03;
#line 2171
      d___0 |= value___0 << shift___0;
#line 2173
      if (shift___0 == 0U) {
#line 2175
        shift___0 = 6U;
#line 2176
        tmp___0 = dp___0;
#line 2176
        dp___0 ++;
#line 2176
        *tmp___0 = (png_byte )d___0;
#line 2177
        d___0 = 0;
      } else {
#line 2181
        shift___0 -= 2U;
      }
#line 2166
      i___0 += (png_uint_32 )png_pass_inc___5[pass];
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2183
    if (shift___0 != 6U) {
#line 2184
      *dp___0 = (png_byte )d___0;
    }
#line 2186
    goto switch_break;
    case_4: /* CIL Label */
#line 2197
    row_width___1 = row_info->width;
#line 2199
    dp___1 = row;
#line 2200
    shift___1 = 4U;
#line 2201
    d___1 = 0;
#line 2202
    i___1 = (png_uint_32 )png_pass_start___4[pass];
    {
#line 2202
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2202
      if (! (i___1 < row_width___1)) {
#line 2202
        goto while_break___1;
      }
#line 2205
      sp___1 = row + (size_t )(i___1 >> 1);
#line 2206
      value___1 = ((int )*sp___1 >> ((1 - (int )(i___1 & 1U)) << 2)) & 0x0f;
#line 2207
      d___1 |= value___1 << shift___1;
#line 2209
      if (shift___1 == 0U) {
#line 2211
        shift___1 = 4U;
#line 2212
        tmp___1 = dp___1;
#line 2212
        dp___1 ++;
#line 2212
        *tmp___1 = (png_byte )d___1;
#line 2213
        d___1 = 0;
      } else {
#line 2217
        shift___1 -= 4U;
      }
#line 2202
      i___1 += (png_uint_32 )png_pass_inc___5[pass];
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2219
    if (shift___1 != 4U) {
#line 2220
      *dp___1 = (png_byte )d___1;
    }
#line 2222
    goto switch_break;
    switch_default: /* CIL Label */
#line 2230
    row_width___2 = row_info->width;
#line 2234
    dp___2 = row;
#line 2237
    pixel_bytes = (size_t )((int )row_info->pixel_depth >> 3);
#line 2240
    i___2 = (png_uint_32 )png_pass_start___4[pass];
    {
#line 2240
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2240
      if (! (i___2 < row_width___2)) {
#line 2240
        goto while_break___2;
      }
#line 2244
      sp___2 = row + (size_t )i___2 * pixel_bytes;
#line 2247
      if ((unsigned long )dp___2 != (unsigned long )sp___2) {
#line 2248
        memcpy((void *)dp___2, (void const   *)sp___2, pixel_bytes);
      }
#line 2251
      dp___2 += pixel_bytes;
#line 2240
      i___2 += (png_uint_32 )png_pass_inc___5[pass];
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2253
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2257
    row_info->width = (((row_info->width + (png_uint_32 )png_pass_inc___5[pass]) - 1U) - (png_uint_32 )png_pass_start___4[pass]) / (png_uint_32 )png_pass_inc___5[pass];
#line 2262
    if ((int )row_info->pixel_depth >= 8) {
#line 2262
      row_info->rowbytes = (size_t )row_info->width * ((size_t )row_info->pixel_depth >> 3);
    } else {
#line 2262
      row_info->rowbytes = ((size_t )row_info->width * (size_t )row_info->pixel_depth + 7UL) >> 3;
    }
  }
#line 2265
  return;
}
}
#line 2274
static void png_write_filtered_row(png_structrp png_ptr , png_bytep filtered_row ,
                                   size_t full_row_length ) ;
#line 2278 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
static size_t png_setup_sub_row(png_structrp png_ptr , png_uint_32 bpp , size_t row_bytes ,
                                size_t lmins )
{
  png_bytep rp ;
  png_bytep dp ;
  png_bytep lp ;
  size_t i ;
  size_t sum ;
  unsigned int v ;
  png_byte tmp ;
  unsigned int tmp___0 ;
  png_byte tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 2284
  sum = (size_t )0;
#line 2287
  *(png_ptr->try_row + 0) = (png_byte )1;
#line 2289
  i = (size_t )0;
#line 2289
  rp = png_ptr->row_buf + 1;
#line 2289
  dp = png_ptr->try_row + 1;
  {
#line 2289
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2289
    if (! (i < (size_t )bpp)) {
#line 2289
      goto while_break;
    }
#line 2292
    tmp = *rp;
#line 2292
    *dp = tmp;
#line 2292
    v = (unsigned int )tmp;
#line 2296
    if (v < 128U) {
#line 2296
      tmp___0 = v;
    } else {
#line 2296
      tmp___0 = 256U - v;
    }
#line 2296
    sum += (size_t )tmp___0;
#line 2289
    i ++;
#line 2289
    rp ++;
#line 2289
    dp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2300
  lp = png_ptr->row_buf + 1;
  {
#line 2300
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2300
    if (! (i < row_bytes)) {
#line 2300
      goto while_break___0;
    }
#line 2303
    tmp___1 = (png_byte )(((int )*rp - (int )*lp) & 0xff);
#line 2303
    *dp = tmp___1;
#line 2303
    v = (unsigned int )tmp___1;
#line 2307
    if (v < 128U) {
#line 2307
      tmp___2 = v;
    } else {
#line 2307
      tmp___2 = 256U - v;
    }
#line 2307
    sum += (size_t )tmp___2;
#line 2310
    if (sum > lmins) {
#line 2311
      goto while_break___0;
    }
#line 2300
    i ++;
#line 2300
    rp ++;
#line 2300
    lp ++;
#line 2300
    dp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2314
  return (sum);
}
}
#line 2317 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
static void png_setup_sub_row_only(png_structrp png_ptr , png_uint_32 bpp , size_t row_bytes )
{
  png_bytep rp ;
  png_bytep dp ;
  png_bytep lp ;
  size_t i ;

  {
#line 2324
  *(png_ptr->try_row + 0) = (png_byte )1;
#line 2326
  i = (size_t )0;
#line 2326
  rp = png_ptr->row_buf + 1;
#line 2326
  dp = png_ptr->try_row + 1;
  {
#line 2326
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2326
    if (! (i < (size_t )bpp)) {
#line 2326
      goto while_break;
    }
#line 2329
    *dp = *rp;
#line 2326
    i ++;
#line 2326
    rp ++;
#line 2326
    dp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2332
  lp = png_ptr->row_buf + 1;
  {
#line 2332
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2332
    if (! (i < row_bytes)) {
#line 2332
      goto while_break___0;
    }
#line 2335
    *dp = (png_byte )(((int )*rp - (int )*lp) & 0xff);
#line 2332
    i ++;
#line 2332
    rp ++;
#line 2332
    lp ++;
#line 2332
    dp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2337
  return;
}
}
#line 2339 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
static size_t png_setup_up_row(png_structrp png_ptr , size_t row_bytes , size_t lmins )
{
  png_bytep rp ;
  png_bytep dp ;
  png_bytep pp ;
  size_t i ;
  size_t sum ;
  unsigned int v ;
  png_byte tmp ;
  unsigned int tmp___0 ;

  {
#line 2344
  sum = (size_t )0;
#line 2347
  *(png_ptr->try_row + 0) = (png_byte )2;
#line 2349
  i = (size_t )0;
#line 2349
  rp = png_ptr->row_buf + 1;
#line 2349
  dp = png_ptr->try_row + 1;
#line 2349
  pp = png_ptr->prev_row + 1;
  {
#line 2349
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2349
    if (! (i < row_bytes)) {
#line 2349
      goto while_break;
    }
#line 2353
    tmp = (png_byte )(((int )*rp - (int )*pp) & 0xff);
#line 2353
    *dp = tmp;
#line 2353
    v = (unsigned int )tmp;
#line 2357
    if (v < 128U) {
#line 2357
      tmp___0 = v;
    } else {
#line 2357
      tmp___0 = 256U - v;
    }
#line 2357
    sum += (size_t )tmp___0;
#line 2360
    if (sum > lmins) {
#line 2361
      goto while_break;
    }
#line 2349
    i ++;
#line 2349
    rp ++;
#line 2349
    pp ++;
#line 2349
    dp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2364
  return (sum);
}
}
#line 2366 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
static void png_setup_up_row_only(png_structrp png_ptr , size_t row_bytes )
{
  png_bytep rp ;
  png_bytep dp ;
  png_bytep pp ;
  size_t i ;

  {
#line 2372
  *(png_ptr->try_row + 0) = (png_byte )2;
#line 2374
  i = (size_t )0;
#line 2374
  rp = png_ptr->row_buf + 1;
#line 2374
  dp = png_ptr->try_row + 1;
#line 2374
  pp = png_ptr->prev_row + 1;
  {
#line 2374
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2374
    if (! (i < row_bytes)) {
#line 2374
      goto while_break;
    }
#line 2378
    *dp = (png_byte )(((int )*rp - (int )*pp) & 0xff);
#line 2374
    i ++;
#line 2374
    rp ++;
#line 2374
    pp ++;
#line 2374
    dp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2380
  return;
}
}
#line 2382 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
static size_t png_setup_avg_row(png_structrp png_ptr , png_uint_32 bpp , size_t row_bytes ,
                                size_t lmins )
{
  png_bytep rp ;
  png_bytep dp ;
  png_bytep pp ;
  png_bytep lp ;
  png_uint_32 i ;
  size_t sum ;
  unsigned int v ;
  png_bytep tmp ;
  png_byte tmp___0 ;
  png_bytep tmp___1 ;
  png_bytep tmp___2 ;
  unsigned int tmp___3 ;
  png_bytep tmp___4 ;
  png_byte tmp___5 ;
  png_bytep tmp___6 ;
  png_bytep tmp___7 ;
  png_bytep tmp___8 ;
  unsigned int tmp___9 ;

  {
#line 2388
  sum = (size_t )0;
#line 2391
  *(png_ptr->try_row + 0) = (png_byte )3;
#line 2393
  i = (png_uint_32 )0;
#line 2393
  rp = png_ptr->row_buf + 1;
#line 2393
  dp = png_ptr->try_row + 1;
#line 2393
  pp = png_ptr->prev_row + 1;
  {
#line 2393
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2393
    if (! (i < bpp)) {
#line 2393
      goto while_break;
    }
#line 2396
    tmp = dp;
#line 2396
    dp ++;
#line 2396
    tmp___1 = rp;
#line 2396
    rp ++;
#line 2396
    tmp___2 = pp;
#line 2396
    pp ++;
#line 2396
    tmp___0 = (png_byte )(((int )*tmp___1 - (int )*tmp___2 / 2) & 0xff);
#line 2396
    *tmp = tmp___0;
#line 2396
    v = (unsigned int )tmp___0;
#line 2401
    if (v < 128U) {
#line 2401
      tmp___3 = v;
    } else {
#line 2401
      tmp___3 = 256U - v;
    }
#line 2401
    sum += (size_t )tmp___3;
#line 2393
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2405
  lp = png_ptr->row_buf + 1;
  {
#line 2405
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2405
    if (! ((size_t )i < row_bytes)) {
#line 2405
      goto while_break___0;
    }
#line 2407
    tmp___4 = dp;
#line 2407
    dp ++;
#line 2407
    tmp___6 = rp;
#line 2407
    rp ++;
#line 2407
    tmp___7 = pp;
#line 2407
    pp ++;
#line 2407
    tmp___8 = lp;
#line 2407
    lp ++;
#line 2407
    tmp___5 = (png_byte )(((int )*tmp___6 - ((int )*tmp___7 + (int )*tmp___8) / 2) & 0xff);
#line 2407
    *tmp___4 = tmp___5;
#line 2407
    v = (unsigned int )tmp___5;
#line 2413
    if (v < 128U) {
#line 2413
      tmp___9 = v;
    } else {
#line 2413
      tmp___9 = 256U - v;
    }
#line 2413
    sum += (size_t )tmp___9;
#line 2416
    if (sum > lmins) {
#line 2417
      goto while_break___0;
    }
#line 2405
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2420
  return (sum);
}
}
#line 2422 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
static void png_setup_avg_row_only(png_structrp png_ptr , png_uint_32 bpp , size_t row_bytes )
{
  png_bytep rp ;
  png_bytep dp ;
  png_bytep pp ;
  png_bytep lp ;
  png_uint_32 i ;
  png_bytep tmp ;
  png_bytep tmp___0 ;
  png_bytep tmp___1 ;
  png_bytep tmp___2 ;
  png_bytep tmp___3 ;
  png_bytep tmp___4 ;
  png_bytep tmp___5 ;

  {
#line 2429
  *(png_ptr->try_row + 0) = (png_byte )3;
#line 2431
  i = (png_uint_32 )0;
#line 2431
  rp = png_ptr->row_buf + 1;
#line 2431
  dp = png_ptr->try_row + 1;
#line 2431
  pp = png_ptr->prev_row + 1;
  {
#line 2431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2431
    if (! (i < bpp)) {
#line 2431
      goto while_break;
    }
#line 2434
    tmp = dp;
#line 2434
    dp ++;
#line 2434
    tmp___0 = rp;
#line 2434
    rp ++;
#line 2434
    tmp___1 = pp;
#line 2434
    pp ++;
#line 2434
    *tmp = (png_byte )(((int )*tmp___0 - (int )*tmp___1 / 2) & 0xff);
#line 2431
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2437
  lp = png_ptr->row_buf + 1;
  {
#line 2437
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2437
    if (! ((size_t )i < row_bytes)) {
#line 2437
      goto while_break___0;
    }
#line 2439
    tmp___2 = dp;
#line 2439
    dp ++;
#line 2439
    tmp___3 = rp;
#line 2439
    rp ++;
#line 2439
    tmp___4 = pp;
#line 2439
    pp ++;
#line 2439
    tmp___5 = lp;
#line 2439
    lp ++;
#line 2439
    *tmp___2 = (png_byte )(((int )*tmp___3 - ((int )*tmp___4 + (int )*tmp___5) / 2) & 0xff);
#line 2437
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2442
  return;
}
}
#line 2444 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
static size_t png_setup_paeth_row(png_structrp png_ptr , png_uint_32 bpp , size_t row_bytes ,
                                  size_t lmins )
{
  png_bytep rp ;
  png_bytep dp ;
  png_bytep pp ;
  png_bytep cp ;
  png_bytep lp ;
  size_t i ;
  size_t sum ;
  unsigned int v ;
  png_bytep tmp ;
  png_byte tmp___0 ;
  png_bytep tmp___1 ;
  png_bytep tmp___2 ;
  unsigned int tmp___3 ;
  int a ;
  int b ;
  int c ;
  int pa ;
  int pb ;
  int pc ;
  int p ;
  png_bytep tmp___4 ;
  png_bytep tmp___5 ;
  png_bytep tmp___6 ;
  int tmp___7 ;
  png_bytep tmp___8 ;
  png_byte tmp___9 ;
  png_bytep tmp___10 ;
  unsigned int tmp___11 ;

  {
#line 2450
  sum = (size_t )0;
#line 2453
  *(png_ptr->try_row + 0) = (png_byte )4;
#line 2455
  i = (size_t )0;
#line 2455
  rp = png_ptr->row_buf + 1;
#line 2455
  dp = png_ptr->try_row + 1;
#line 2455
  pp = png_ptr->prev_row + 1;
  {
#line 2455
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2455
    if (! (i < (size_t )bpp)) {
#line 2455
      goto while_break;
    }
#line 2458
    tmp = dp;
#line 2458
    dp ++;
#line 2458
    tmp___1 = rp;
#line 2458
    rp ++;
#line 2458
    tmp___2 = pp;
#line 2458
    pp ++;
#line 2458
    tmp___0 = (png_byte )(((int )*tmp___1 - (int )*tmp___2) & 0xff);
#line 2458
    *tmp = tmp___0;
#line 2458
    v = (unsigned int )tmp___0;
#line 2463
    if (v < 128U) {
#line 2463
      tmp___3 = v;
    } else {
#line 2463
      tmp___3 = 256U - v;
    }
#line 2463
    sum += (size_t )tmp___3;
#line 2455
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2467
  lp = png_ptr->row_buf + 1;
#line 2467
  cp = png_ptr->prev_row + 1;
  {
#line 2467
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2467
    if (! (i < row_bytes)) {
#line 2467
      goto while_break___0;
    }
#line 2472
    tmp___4 = pp;
#line 2472
    pp ++;
#line 2472
    b = (int )*tmp___4;
#line 2473
    tmp___5 = cp;
#line 2473
    cp ++;
#line 2473
    c = (int )*tmp___5;
#line 2474
    tmp___6 = lp;
#line 2474
    lp ++;
#line 2474
    a = (int )*tmp___6;
#line 2476
    p = b - c;
#line 2477
    pc = a - c;
#line 2484
    if (p < 0) {
#line 2484
      pa = - p;
    } else {
#line 2484
      pa = p;
    }
#line 2485
    if (pc < 0) {
#line 2485
      pb = - pc;
    } else {
#line 2485
      pb = pc;
    }
#line 2486
    if (p + pc < 0) {
#line 2486
      pc = - (p + pc);
    } else {
#line 2486
      pc = p + pc;
    }
#line 2489
    if (pa <= pb) {
#line 2489
      if (pa <= pc) {
#line 2489
        p = a;
      } else {
#line 2489
        goto _L;
      }
    } else {
      _L: /* CIL Label */
#line 2489
      if (pb <= pc) {
#line 2489
        tmp___7 = b;
      } else {
#line 2489
        tmp___7 = c;
      }
#line 2489
      p = tmp___7;
    }
#line 2491
    tmp___8 = dp;
#line 2491
    dp ++;
#line 2491
    tmp___10 = rp;
#line 2491
    rp ++;
#line 2491
    tmp___9 = (png_byte )(((int )*tmp___10 - p) & 0xff);
#line 2491
    *tmp___8 = tmp___9;
#line 2491
    v = (unsigned int )tmp___9;
#line 2496
    if (v < 128U) {
#line 2496
      tmp___11 = v;
    } else {
#line 2496
      tmp___11 = 256U - v;
    }
#line 2496
    sum += (size_t )tmp___11;
#line 2499
    if (sum > lmins) {
#line 2500
      goto while_break___0;
    }
#line 2467
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2503
  return (sum);
}
}
#line 2505 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
static void png_setup_paeth_row_only(png_structrp png_ptr , png_uint_32 bpp , size_t row_bytes )
{
  png_bytep rp ;
  png_bytep dp ;
  png_bytep pp ;
  png_bytep cp ;
  png_bytep lp ;
  size_t i ;
  png_bytep tmp ;
  png_bytep tmp___0 ;
  png_bytep tmp___1 ;
  int a ;
  int b ;
  int c ;
  int pa ;
  int pb ;
  int pc ;
  int p ;
  png_bytep tmp___2 ;
  png_bytep tmp___3 ;
  png_bytep tmp___4 ;
  int tmp___5 ;
  png_bytep tmp___6 ;
  png_bytep tmp___7 ;

  {
#line 2512
  *(png_ptr->try_row + 0) = (png_byte )4;
#line 2514
  i = (size_t )0;
#line 2514
  rp = png_ptr->row_buf + 1;
#line 2514
  dp = png_ptr->try_row + 1;
#line 2514
  pp = png_ptr->prev_row + 1;
  {
#line 2514
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2514
    if (! (i < (size_t )bpp)) {
#line 2514
      goto while_break;
    }
#line 2517
    tmp = dp;
#line 2517
    dp ++;
#line 2517
    tmp___0 = rp;
#line 2517
    rp ++;
#line 2517
    tmp___1 = pp;
#line 2517
    pp ++;
#line 2517
    *tmp = (png_byte )(((int )*tmp___0 - (int )*tmp___1) & 0xff);
#line 2514
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2520
  lp = png_ptr->row_buf + 1;
#line 2520
  cp = png_ptr->prev_row + 1;
  {
#line 2520
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2520
    if (! (i < row_bytes)) {
#line 2520
      goto while_break___0;
    }
#line 2525
    tmp___2 = pp;
#line 2525
    pp ++;
#line 2525
    b = (int )*tmp___2;
#line 2526
    tmp___3 = cp;
#line 2526
    cp ++;
#line 2526
    c = (int )*tmp___3;
#line 2527
    tmp___4 = lp;
#line 2527
    lp ++;
#line 2527
    a = (int )*tmp___4;
#line 2529
    p = b - c;
#line 2530
    pc = a - c;
#line 2537
    if (p < 0) {
#line 2537
      pa = - p;
    } else {
#line 2537
      pa = p;
    }
#line 2538
    if (pc < 0) {
#line 2538
      pb = - pc;
    } else {
#line 2538
      pb = pc;
    }
#line 2539
    if (p + pc < 0) {
#line 2539
      pc = - (p + pc);
    } else {
#line 2539
      pc = p + pc;
    }
#line 2542
    if (pa <= pb) {
#line 2542
      if (pa <= pc) {
#line 2542
        p = a;
      } else {
#line 2542
        goto _L;
      }
    } else {
      _L: /* CIL Label */
#line 2542
      if (pb <= pc) {
#line 2542
        tmp___5 = b;
      } else {
#line 2542
        tmp___5 = c;
      }
#line 2542
      p = tmp___5;
    }
#line 2544
    tmp___6 = dp;
#line 2544
    dp ++;
#line 2544
    tmp___7 = rp;
#line 2544
    rp ++;
#line 2544
    *tmp___6 = (png_byte )(((int )*tmp___7 - p) & 0xff);
#line 2520
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2546
  return;
}
}
#line 2549 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
void png_write_find_filter(png_structrp png_ptr , png_row_infop row_info )
{
  unsigned int filter_to_do ;
  png_bytep row_buf ;
  png_bytep best_row ;
  png_uint_32 bpp ;
  size_t mins ;
  size_t row_bytes ;
  png_bytep rp ;
  size_t sum ;
  size_t i ;
  unsigned int v ;
  unsigned int tmp ;
  size_t sum___0 ;
  size_t lmins ;
  size_t sum___1 ;
  size_t lmins___0 ;
  size_t sum___2 ;
  size_t lmins___1 ;
  size_t sum___3 ;
  size_t lmins___2 ;

  {
#line 2555
  filter_to_do = (unsigned int )png_ptr->do_filter;
#line 2560
  row_bytes = row_info->rowbytes;
#line 2565
  bpp = (png_uint_32 )(((int )row_info->pixel_depth + 7) >> 3);
#line 2567
  row_buf = png_ptr->row_buf;
#line 2568
  mins = 18446744073709551359UL;
#line 2599
  best_row = png_ptr->row_buf;
#line 2601
  if (144115188075855871UL <= row_bytes) {
#line 2606
    filter_to_do &= 0U - filter_to_do;
  } else
#line 2608
  if ((filter_to_do & 8U) != 0U) {
#line 2608
    if (filter_to_do != 8U) {
#line 2615
      sum = (size_t )0;
#line 2620
      i = (size_t )0;
#line 2620
      rp = row_buf + 1;
      {
#line 2620
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2620
        if (! (i < row_bytes)) {
#line 2620
          goto while_break;
        }
#line 2622
        v = (unsigned int )*rp;
#line 2626
        if (v < 128U) {
#line 2626
          tmp = v;
        } else {
#line 2626
          tmp = 256U - v;
        }
#line 2626
        sum += (size_t )tmp;
#line 2620
        i ++;
#line 2620
        rp ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 2631
      mins = sum;
    }
  }
#line 2635
  if (filter_to_do == 16U) {
#line 2638
    png_setup_sub_row_only(png_ptr, bpp, row_bytes);
#line 2639
    best_row = png_ptr->try_row;
  } else
#line 2642
  if ((filter_to_do & 16U) != 0U) {
#line 2645
    lmins = mins;
#line 2647
    sum___0 = png_setup_sub_row(png_ptr, bpp, row_bytes, lmins);
#line 2649
    if (sum___0 < mins) {
#line 2651
      mins = sum___0;
#line 2652
      best_row = png_ptr->try_row;
#line 2653
      if ((unsigned long )png_ptr->tst_row != (unsigned long )((void *)0)) {
#line 2655
        png_ptr->try_row = png_ptr->tst_row;
#line 2656
        png_ptr->tst_row = best_row;
      }
    }
  }
#line 2662
  if (filter_to_do == 32U) {
#line 2664
    png_setup_up_row_only(png_ptr, row_bytes);
#line 2665
    best_row = png_ptr->try_row;
  } else
#line 2668
  if ((filter_to_do & 32U) != 0U) {
#line 2671
    lmins___0 = mins;
#line 2673
    sum___1 = png_setup_up_row(png_ptr, row_bytes, lmins___0);
#line 2675
    if (sum___1 < mins) {
#line 2677
      mins = sum___1;
#line 2678
      best_row = png_ptr->try_row;
#line 2679
      if ((unsigned long )png_ptr->tst_row != (unsigned long )((void *)0)) {
#line 2681
        png_ptr->try_row = png_ptr->tst_row;
#line 2682
        png_ptr->tst_row = best_row;
      }
    }
  }
#line 2688
  if (filter_to_do == 64U) {
#line 2690
    png_setup_avg_row_only(png_ptr, bpp, row_bytes);
#line 2691
    best_row = png_ptr->try_row;
  } else
#line 2694
  if ((filter_to_do & 64U) != 0U) {
#line 2697
    lmins___1 = mins;
#line 2699
    sum___2 = png_setup_avg_row(png_ptr, bpp, row_bytes, lmins___1);
#line 2701
    if (sum___2 < mins) {
#line 2703
      mins = sum___2;
#line 2704
      best_row = png_ptr->try_row;
#line 2705
      if ((unsigned long )png_ptr->tst_row != (unsigned long )((void *)0)) {
#line 2707
        png_ptr->try_row = png_ptr->tst_row;
#line 2708
        png_ptr->tst_row = best_row;
      }
    }
  }
#line 2714
  if (filter_to_do == 128U) {
#line 2716
    png_setup_paeth_row_only(png_ptr, bpp, row_bytes);
#line 2717
    best_row = png_ptr->try_row;
  } else
#line 2720
  if ((filter_to_do & 128U) != 0U) {
#line 2723
    lmins___2 = mins;
#line 2725
    sum___3 = png_setup_paeth_row(png_ptr, bpp, row_bytes, lmins___2);
#line 2727
    if (sum___3 < mins) {
#line 2729
      best_row = png_ptr->try_row;
#line 2730
      if ((unsigned long )png_ptr->tst_row != (unsigned long )((void *)0)) {
#line 2732
        png_ptr->try_row = png_ptr->tst_row;
#line 2733
        png_ptr->tst_row = best_row;
      }
    }
  }
#line 2739
  png_write_filtered_row(png_ptr, best_row, row_info->rowbytes + 1UL);
#line 2742
  return;
}
}
#line 2746 "/home/goblint2/bench/libpng-1.6.39/pngwutil.c"
static void png_write_filtered_row(png_structrp png_ptr , png_bytep filtered_row ,
                                   size_t full_row_length )
{
  png_bytep tptr ;

  {
#line 2754
  png_compress_IDAT(png_ptr, (png_const_bytep )filtered_row, full_row_length, 0);
#line 2758
  if ((unsigned long )png_ptr->prev_row != (unsigned long )((void *)0)) {
#line 2762
    tptr = png_ptr->prev_row;
#line 2763
    png_ptr->prev_row = png_ptr->row_buf;
#line 2764
    png_ptr->row_buf = tptr;
  }
#line 2769
  png_write_finish_row(png_ptr);
#line 2772
  (png_ptr->flush_rows) ++;
#line 2774
  if (png_ptr->flush_dist > 0U) {
#line 2774
    if (png_ptr->flush_rows >= png_ptr->flush_dist) {
#line 2777
      png_write_flush(png_ptr);
    }
  }
#line 2780
  return;
}
}
#line 326 "/usr/include/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) fprintf)(FILE *__stream ,
                                                                                                  char const   *__fmt
                                                                                                  , ...) ;
#line 332
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) printf)(char const   *__fmt
                                                                                                 , ...) ;
#line 334
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) sprintf)(char *__s ,
                                                                                                            char const   *__fmt
                                                                                                            , ...)  __attribute__((__nothrow__)) ;
#line 341
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vfprintf)(FILE *__stream ,
                                                                                                   char const   *__fmt ,
                                                                                                   __gnuc_va_list __ap ) ;
#line 347
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vprintf)(char const   *__fmt ,
                                                                                                  __gnuc_va_list __ap ) ;
#line 349
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vsprintf)(char *__s ,
                                                                                                             char const   *__fmt ,
                                                                                                             __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 354
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) snprintf)(char *__s , size_t __n , char const   *__fmt
                                              , ...)  __attribute__((__nothrow__)) ;
#line 358
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) vsnprintf)(char *__s , size_t __n , char const   *__fmt ,
                                               __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 492
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
#line 528
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
#line 564
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fgets)(char *__s , int __n , FILE *__stream ) ;
#line 646
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fread)(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 101 "/usr/include/stdlib.h"
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 104
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 107
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 112
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__leaf__, __gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__,
__nothrow__)) ;
#line 820
__inline extern void *( __attribute__((__warn_unused_result__, __nonnull__(1,2,5),
__gnu_inline__)) bsearch)(void const   *__key , void const   *__base , size_t __nmemb ,
                          size_t __size , int (*__compar)(void const   * , void const   * ) ) ;
#line 929
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar )  __attribute__((__nothrow__)) ;
#line 933
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t *__dst , char const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 936
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) wcstombs)(char *__dst , wchar_t const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 43 "/usr/include/string.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memcpy)(void *__dest , void const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 47
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 61
__inline extern void *( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) memset)(void *__dest , int __ch , size_t __len )  __attribute__((__nothrow__)) ;
#line 122
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcpy)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 125
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncpy)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 130
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcat)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 133
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncat)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 360 "/usr/include/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) read)(int __fd , void *__buf , size_t __nbytes ) ;
#line 511
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size )  __attribute__((__nothrow__)) ;
#line 689
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list )  __attribute__((__nothrow__)) ;
#line 774
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                               size_t __buflen )  __attribute__((__nothrow__)) ;
#line 124 "/home/goblint2/bench/libpng-1.6.39/pngtest.c"
static int tIME_chunk_present  =    0;
#line 125 "/home/goblint2/bench/libpng-1.6.39/pngtest.c"
static char tIME_string[29]  =
#line 125
  {      (char )'t',      (char )'I',      (char )'M',      (char )'E',
        (char )' ',      (char )'c',      (char )'h',      (char )'u',
        (char )'n',      (char )'k',      (char )' ',      (char )'i',
        (char )'s',      (char )' ',      (char )'n',      (char )'o',
        (char )'t',      (char )' ',      (char )'p',      (char )'r',
        (char )'e',      (char )'s',      (char )'e',      (char )'n',
        (char )'t',      (char )'\000'};
#line 144 "/home/goblint2/bench/libpng-1.6.39/pngtest.c"
static int verbose  =    0;
#line 145 "/home/goblint2/bench/libpng-1.6.39/pngtest.c"
static int strict  =    0;
#line 146 "/home/goblint2/bench/libpng-1.6.39/pngtest.c"
static int relaxed  =    0;
#line 147 "/home/goblint2/bench/libpng-1.6.39/pngtest.c"
static int xfail  =    0;
#line 148 "/home/goblint2/bench/libpng-1.6.39/pngtest.c"
static int unsupported_chunks  =    0;
#line 149 "/home/goblint2/bench/libpng-1.6.39/pngtest.c"
static int error_count  =    0;
#line 150 "/home/goblint2/bench/libpng-1.6.39/pngtest.c"
static int warning_count  =    0;
#line 169 "/home/goblint2/bench/libpng-1.6.39/pngtest.c"
static int status_pass  =    1;
#line 170 "/home/goblint2/bench/libpng-1.6.39/pngtest.c"
static int status_dots_requested  =    0;
#line 171 "/home/goblint2/bench/libpng-1.6.39/pngtest.c"
static int status_dots  =    1;
#line 173 "/home/goblint2/bench/libpng-1.6.39/pngtest.c"
static void read_row_callback(png_structp png_ptr , png_uint_32 row_number , int pass )
{


  {
#line 176
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 177
    return;
  } else
#line 176
  if (row_number > 2147483647U) {
#line 177
    return;
  }
#line 179
  if (status_pass != pass) {
#line 181
    fprintf(stdout, (char const   *)"\n Pass %d: ", pass);
#line 182
    status_pass = pass;
#line 183
    status_dots = 31;
  }
#line 186
  status_dots --;
#line 188
  if (status_dots == 0) {
#line 190
    fprintf(stdout, (char const   *)"\n         ");
#line 191
    status_dots = 30;
  }
#line 194
  fprintf(stdout, (char const   *)"r");
#line 195
  return;
}
}
#line 198 "/home/goblint2/bench/libpng-1.6.39/pngtest.c"
static void write_row_callback(png_structp png_ptr , png_uint_32 row_number , int pass )
{


  {
#line 201
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 202
    return;
  } else
#line 201
  if (row_number > 2147483647U) {
#line 202
    return;
  } else
#line 201
  if (pass > 7) {
#line 202
    return;
  }
#line 204
  fprintf(stdout, (char const   *)"w");
#line 205
  return;
}
}
#line 212 "/home/goblint2/bench/libpng-1.6.39/pngtest.c"
static void read_user_callback(png_structp png_ptr , png_row_infop row_info , png_bytep data )
{


  {
#line 218
  return;
}
}
#line 226 "/home/goblint2/bench/libpng-1.6.39/pngtest.c"
static png_uint_32 zero_samples  ;
#line 228 "/home/goblint2/bench/libpng-1.6.39/pngtest.c"
static void count_zero_samples(png_structp png_ptr , png_row_infop row_info , png_bytep data )
{
  png_bytep dp ;
  int pos ;
  png_uint_32 n ;
  png_uint_32 nstop ;
  int tmp ;
  png_bytep tmp___0 ;
  png_uint_32 n___0 ;
  png_uint_32 nstop___0 ;
  int channel ;
  int color_channels ;
  png_bytep tmp___1 ;

  {
#line 231
  dp = data;
#line 232
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 233
    return;
  }
#line 246
  if ((int )row_info->color_type == 0) {
#line 246
    goto _L;
  } else
#line 246
  if ((int )row_info->color_type == 3) {
    _L: /* CIL Label */
#line 248
    pos = 0;
#line 251
    n = (png_uint_32 )0;
#line 251
    nstop = row_info->width;
    {
#line 251
    while (1) {
      while_continue: /* CIL Label */ ;
#line 251
      if (! (n < nstop)) {
#line 251
        goto while_break;
      }
#line 253
      if ((int )row_info->bit_depth == 1) {
#line 255
        tmp = pos;
#line 255
        pos ++;
#line 255
        if ((((int )*dp << tmp) & 0x80) == 0) {
#line 256
          zero_samples ++;
        }
#line 258
        if (pos == 8) {
#line 260
          pos = 0;
#line 261
          dp ++;
        }
      }
#line 265
      if ((int )row_info->bit_depth == 2) {
#line 267
        pos += 2;
#line 267
        if ((((int )*dp << pos) & 0xc0) == 0) {
#line 268
          zero_samples ++;
        }
#line 270
        if (pos == 8) {
#line 272
          pos = 0;
#line 273
          dp ++;
        }
      }
#line 277
      if ((int )row_info->bit_depth == 4) {
#line 279
        pos += 4;
#line 279
        if ((((int )*dp << pos) & 0xf0) == 0) {
#line 280
          zero_samples ++;
        }
#line 282
        if (pos == 8) {
#line 284
          pos = 0;
#line 285
          dp ++;
        }
      }
#line 289
      if ((int )row_info->bit_depth == 8) {
#line 290
        tmp___0 = dp;
#line 290
        dp ++;
#line 290
        if ((int )*tmp___0 == 0) {
#line 291
          zero_samples ++;
        }
      }
#line 293
      if ((int )row_info->bit_depth == 16) {
#line 295
        if (((int )*dp | (int )*(dp + 1)) == 0) {
#line 296
          zero_samples ++;
        }
#line 297
        dp += 2;
      }
#line 251
      n ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 305
    color_channels = (int )row_info->channels;
#line 306
    if ((int )row_info->color_type > 3) {
#line 307
      color_channels --;
    }
#line 309
    n___0 = (png_uint_32 )0;
#line 309
    nstop___0 = row_info->width;
    {
#line 309
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 309
      if (! (n___0 < nstop___0)) {
#line 309
        goto while_break___0;
      }
#line 311
      channel = 0;
      {
#line 311
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 311
        if (! (channel < color_channels)) {
#line 311
          goto while_break___1;
        }
#line 313
        if ((int )row_info->bit_depth == 8) {
#line 314
          tmp___1 = dp;
#line 314
          dp ++;
#line 314
          if ((int )*tmp___1 == 0) {
#line 315
            zero_samples ++;
          }
        }
#line 317
        if ((int )row_info->bit_depth == 16) {
#line 319
          if (((int )*dp | (int )*(dp + 1)) == 0) {
#line 320
            zero_samples ++;
          }
#line 322
          dp += 2;
        }
#line 311
        channel ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 325
      if ((int )row_info->color_type > 3) {
#line 327
        dp ++;
#line 328
        if ((int )row_info->bit_depth == 16) {
#line 329
          dp ++;
        }
      }
#line 309
      n___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 333
  return;
}
}
#line 455 "/home/goblint2/bench/libpng-1.6.39/pngtest.c"
static void pngtest_warning(png_structp png_ptr , png_const_charp message )
{
  char const   *name ;
  pngtest_error_parameters *test ;
  png_voidp tmp ;

  {
#line 458
  name = (char const   *)"UNKNOWN (ERROR!)";
#line 459
  tmp = png_get_error_ptr((png_const_structrp )png_ptr);
#line 459
  test = (pngtest_error_parameters *)tmp;
#line 462
  warning_count ++;
#line 464
  if ((unsigned long )test != (unsigned long )((void *)0)) {
#line 464
    if ((unsigned long )test->file_name != (unsigned long )((void *)0)) {
#line 465
      name = test->file_name;
    }
  }
#line 467
  fprintf(stdout, (char const   *)"\n%s: libpng warning: %s\n", name, message);
#line 468
  return;
}
}
#line 475 "/home/goblint2/bench/libpng-1.6.39/pngtest.c"
static void pngtest_error(png_structp png_ptr , png_const_charp message )
{


  {
#line 478
  error_count ++;
#line 480
  pngtest_warning(png_ptr, message);
#line 484
  return;
}
}
#line 646 "/home/goblint2/bench/libpng-1.6.39/pngtest.c"
static struct user_chunk_data user_chunk_data  ;
#line 655 "/home/goblint2/bench/libpng-1.6.39/pngtest.c"
static void init_callback_info(png_const_infop info_ptr )
{


  {
#line 658
  memset((void *)(& user_chunk_data), 0, sizeof(user_chunk_data));
#line 659
  user_chunk_data.info_ptr = info_ptr;
#line 660
  return;
}
}
#line 662 "/home/goblint2/bench/libpng-1.6.39/pngtest.c"
static int set_location(png_structp png_ptr , struct user_chunk_data *data , int what )
{
  int location ;
  png_uint_32 tmp ;

  {
#line 667
  if ((data->location[0] & what) != 0) {
#line 668
    return (0);
  } else
#line 667
  if ((data->location[1] & what) != 0) {
#line 668
    return (0);
  }
#line 673
  if ((unsigned long )data->info_ptr == (unsigned long )((void *)0)) {
#line 674
    location = what | 0x40;
  } else {
#line 676
    tmp = png_get_valid((png_const_structrp )png_ptr, (png_const_inforp )data->info_ptr,
                        0x0008U);
#line 676
    if (tmp != 0U) {
#line 677
      location = what | 0x20;
    } else {
#line 680
      location = what | 0x10;
    }
  }
#line 682
  if (data->location[0] == 0) {
#line 683
    data->location[0] = location;
  } else {
#line 686
    data->location[1] = location;
  }
#line 688
  return (1);
}
}
#line 691 "/home/goblint2/bench/libpng-1.6.39/pngtest.c"
static int read_user_chunk_callback(png_struct *png_ptr , png_unknown_chunkp chunk )
{
  struct user_chunk_data *my_user_chunk_data ;
  png_voidp tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 694
  tmp = png_get_user_chunk_ptr((png_const_structrp )png_ptr);
#line 694
  my_user_chunk_data = (struct user_chunk_data *)tmp;
#line 697
  if ((unsigned long )my_user_chunk_data == (unsigned long )((void *)0)) {
#line 698
    png_error((png_const_structrp )png_ptr, (png_const_charp )"lost user chunk pointer");
  }
#line 713
  if ((int )chunk->name[0] == 115) {
#line 713
    if ((int )chunk->name[1] == 84) {
#line 713
      if ((int )chunk->name[2] == 69) {
#line 713
        if ((int )chunk->name[3] == 82) {
#line 717
          if (chunk->size != 1UL) {
#line 718
            return (-1);
          }
#line 720
          if ((int )*(chunk->data + 0) != 0) {
#line 720
            if ((int )*(chunk->data + 0) != 1) {
#line 721
              return (-1);
            }
          }
#line 723
          tmp___0 = set_location(png_ptr, my_user_chunk_data, 0x01);
#line 723
          if (tmp___0 != 0) {
#line 725
            my_user_chunk_data->sTER_mode = *(chunk->data + 0);
#line 726
            return (1);
          } else {
#line 730
            return (0);
          }
        }
      }
    }
  }
#line 733
  if ((int )chunk->name[0] != 118) {
#line 735
    return (0);
  } else
#line 733
  if ((int )chunk->name[1] != 112) {
#line 735
    return (0);
  } else
#line 733
  if ((int )chunk->name[2] != 65) {
#line 735
    return (0);
  } else
#line 733
  if ((int )chunk->name[3] != 103) {
#line 735
    return (0);
  }
#line 739
  if (chunk->size != 9UL) {
#line 740
    return (-1);
  }
#line 742
  tmp___1 = set_location(png_ptr, my_user_chunk_data, 0x02);
#line 742
  if (tmp___1 == 0) {
#line 743
    return (0);
  }
#line 745
  my_user_chunk_data->vpAg_width = png_get_uint_31((png_const_structrp )png_ptr, (png_const_bytep )chunk->data);
#line 746
  my_user_chunk_data->vpAg_height = png_get_uint_31((png_const_structrp )png_ptr,
                                                    (png_const_bytep )(chunk->data + 4));
#line 747
  my_user_chunk_data->vpAg_units = *(chunk->data + 8);
#line 749
  return (1);
}
}
#line 753 "/home/goblint2/bench/libpng-1.6.39/pngtest.c"
static void write_sTER_chunk(png_structp write_ptr )
{
  png_byte sTER[5] ;

  {
#line 756
  sTER[0] = (png_byte )115;
#line 756
  sTER[1] = (png_byte )84;
#line 756
  sTER[2] = (png_byte )69;
#line 756
  sTER[3] = (png_byte )82;
#line 756
  sTER[4] = (png_byte )'\000';
#line 758
  if (verbose != 0) {
#line 759
    fprintf(stdout, (char const   *)"\n stereo mode = %d\n", (int )user_chunk_data.sTER_mode);
  }
#line 761
  png_write_chunk((png_structrp )write_ptr, (png_const_bytep )(sTER), (png_const_bytep )(& user_chunk_data.sTER_mode),
                  (size_t )1);
#line 762
  return;
}
}
#line 764 "/home/goblint2/bench/libpng-1.6.39/pngtest.c"
static void write_vpAg_chunk(png_structp write_ptr )
{
  png_byte vpAg[5] ;
  png_byte vpag_chunk_data[9] ;

  {
#line 767
  vpAg[0] = (png_byte )118;
#line 767
  vpAg[1] = (png_byte )112;
#line 767
  vpAg[2] = (png_byte )65;
#line 767
  vpAg[3] = (png_byte )103;
#line 767
  vpAg[4] = (png_byte )'\000';
#line 771
  if (verbose != 0) {
#line 772
    fprintf(stdout, (char const   *)" vpAg = %lu x %lu, units = %d\n", (unsigned long )user_chunk_data.vpAg_width,
            (unsigned long )user_chunk_data.vpAg_height, (int )user_chunk_data.vpAg_units);
  }
#line 777
  png_save_uint_32(vpag_chunk_data, user_chunk_data.vpAg_width);
#line 778
  png_save_uint_32(vpag_chunk_data + 4, user_chunk_data.vpAg_height);
#line 779
  vpag_chunk_data[8] = user_chunk_data.vpAg_units;
#line 780
  png_write_chunk((png_structrp )write_ptr, (png_const_bytep )(vpAg), (png_const_bytep )(vpag_chunk_data),
                  (size_t )9);
#line 781
  return;
}
}
#line 783 "/home/goblint2/bench/libpng-1.6.39/pngtest.c"
static void write_chunks(png_structp write_ptr , int location )
{
  int i ;

  {
#line 794
  i = 0;
  {
#line 794
  while (1) {
    while_continue: /* CIL Label */ ;
#line 794
    if (! (i < 2)) {
#line 794
      goto while_break;
    }
#line 796
    if (user_chunk_data.location[i] == (location | 0x01)) {
#line 797
      write_sTER_chunk(write_ptr);
    } else
#line 799
    if (user_chunk_data.location[i] == (location | 0x02)) {
#line 800
      write_vpAg_chunk(write_ptr);
    }
#line 794
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 802
  return;
}
}
#line 814 "/home/goblint2/bench/libpng-1.6.39/pngtest.c"
static void pngtest_check_text_support(png_structp png_ptr , png_textp text_ptr ,
                                       int num_text )
{


  {
  {
#line 818
  while (1) {
    while_continue: /* CIL Label */ ;
#line 818
    if (! (num_text > 0)) {
#line 818
      goto while_break;
    }
#line 820
    num_text --;
    {
#line 822
    if ((text_ptr + num_text)->compression == -1) {
#line 822
      goto case_neg_1;
    }
#line 825
    if ((text_ptr + num_text)->compression == 0) {
#line 825
      goto case_0;
    }
#line 834
    if ((text_ptr + num_text)->compression == 2) {
#line 834
      goto case_2;
    }
#line 834
    if ((text_ptr + num_text)->compression == 1) {
#line 834
      goto case_2;
    }
#line 841
    goto switch_default;
    case_neg_1: /* CIL Label */
#line 823
    goto switch_break;
    case_0: /* CIL Label */
#line 831
    goto switch_break;
    case_2: /* CIL Label */
    case_1: /* CIL Label */
#line 839
    goto switch_break;
    switch_default: /* CIL Label */
#line 843
    png_error((png_const_structrp )png_ptr, (png_const_charp )"invalid text chunk compression field");
#line 844
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 847
  return;
}
}
#line 855 "/home/goblint2/bench/libpng-1.6.39/pngtest.c"
static png_FILE_p fpin  ;
#line 856 "/home/goblint2/bench/libpng-1.6.39/pngtest.c"
static png_FILE_p fpout  ;
#line 1730
static int test_one_file(char const   *inname___0 , char const   *outname___0 ) ;
#line 1730 "/home/goblint2/bench/libpng-1.6.39/pngtest.c"
static int wrote_question  =    0;
#line 852 "/home/goblint2/bench/libpng-1.6.39/pngtest.c"
static int test_one_file(char const   *inname___0 , char const   *outname___0 )
{
  pngtest_error_parameters error_parameters ;
  png_structp read_ptr ;
  png_infop read_info_ptr ;
  png_infop end_info_ptr ;
  png_structp write_ptr ;
  png_infop write_info_ptr ;
  png_infop write_end_info_ptr ;
  int interlace_preserved ;
  png_bytep row_buf ;
  unsigned char *png_pixels = 0;
  png_uint_32 y ;
  png_uint_32 width ;
  png_uint_32 height ;
  int volatile   num_passes ;
  int pass ;
  int bit_depth ;
  int color_type ;
  png_structp __attribute__((__malloc__))  tmp ;
  png_structp __attribute__((__malloc__))  tmp___0 ;
  png_infop __attribute__((__malloc__))  tmp___1 ;
  png_infop __attribute__((__malloc__))  tmp___2 ;
  png_infop __attribute__((__malloc__))  tmp___3 ;
  png_infop __attribute__((__malloc__))  tmp___4 ;
  jmp_buf *tmp___5 ;
  int tmp___6 ;
  jmp_buf *tmp___7 ;
  int tmp___8 ;
  int interlace_type ;
  int compression_type ;
  int filter_type ;
  png_uint_32 tmp___9 ;
  png_fixed_point white_x ;
  png_fixed_point white_y ;
  png_fixed_point red_x ;
  png_fixed_point red_y ;
  png_fixed_point green_x ;
  png_fixed_point green_y ;
  png_fixed_point blue_x ;
  png_fixed_point blue_y ;
  png_uint_32 tmp___10 ;
  png_fixed_point gamma___0 ;
  png_uint_32 tmp___11 ;
  png_charp name ;
  png_bytep profile ;
  png_uint_32 proflen ;
  int compression_type___0 ;
  png_uint_32 tmp___12 ;
  int intent ;
  png_uint_32 tmp___13 ;
  png_colorp palette ;
  int num_palette ;
  png_uint_32 tmp___14 ;
  png_color_16p background ;
  png_uint_32 tmp___15 ;
  png_bytep exif ;
  png_uint_32 exif_length ;
  png_uint_32 tmp___16 ;
  png_uint_16p hist ;
  png_uint_32 tmp___17 ;
  png_int_32 offset_x ;
  png_int_32 offset_y ;
  int unit_type ;
  png_uint_32 tmp___18 ;
  png_charp purpose ;
  png_charp units ;
  png_charpp params ;
  png_int_32 X0 ;
  png_int_32 X1 ;
  int type ;
  int nparams ;
  png_uint_32 tmp___19 ;
  png_uint_32 res_x ;
  png_uint_32 res_y ;
  int unit_type___0 ;
  png_uint_32 tmp___20 ;
  png_color_8p sig_bit ;
  png_uint_32 tmp___21 ;
  int unit ;
  double scal_width ;
  double scal_height ;
  png_uint_32 tmp___22 ;
  png_sPLT_tp entries ;
  int num_entries ;
  int tmp___23 ;
  png_textp text_ptr ;
  int num_text ;
  int i ;
  int tmp___24 ;
  png_timep mod_time ;
  int tmp___25 ;
  png_uint_32 tmp___26 ;
  png_bytep trans_alpha ;
  int num_trans ;
  png_color_16p trans_color ;
  int sample_max ;
  png_uint_32 tmp___27 ;
  png_unknown_chunkp unknowns ;
  int num_unknowns ;
  int tmp___28 ;
  size_t tmp___29 ;
  png_voidp __attribute__((__malloc__))  tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  png_textp text_ptr___0 ;
  int num_text___0 ;
  int i___0 ;
  int tmp___33 ;
  png_bytep exif___0 ;
  png_uint_32 exif_length___0 ;
  png_uint_32 tmp___34 ;
  png_timep mod_time___0 ;
  int tmp___35 ;
  png_uint_32 tmp___36 ;
  png_unknown_chunkp unknowns___0 ;
  int num_unknowns___0 ;
  int tmp___37 ;
  png_uint_32 iwidth ;
  png_uint_32 iheight ;
  char *tmp___38 ;
  size_t num_in ;
  size_t num_out ;
  char inbuf[256] ;
  char outbuf[256] ;
  int tmp___39 ;

  {
#line 865
  interlace_preserved = 1;
#line 879
  row_buf = (png_bytep )((void *)0);
  png_pixels = (png_bytep )((void *)0);
#line 880
  error_parameters.file_name = inname___0;
#line 882
  fpin = fopen((char const   * __restrict  )inname___0, (char const   * __restrict  )"rb");
#line 882
  if ((unsigned long )fpin == (unsigned long )((void *)0)) {
#line 884
    fprintf(stdout, (char const   *)"Could not find input file %s\n", inname___0);
#line 885
    return (1);
  }
#line 888
  fpout = fopen((char const   * __restrict  )outname___0, (char const   * __restrict  )"wb");
#line 888
  if ((unsigned long )fpout == (unsigned long )((void *)0)) {
#line 890
    fprintf(stdout, (char const   *)"Could not open output file %s\n", outname___0);
#line 891
    fclose(fpin);
#line 892
    return (1);
  }
#line 901
  tmp = png_create_read_struct((png_const_charp )"1.6.39", (void *)0, (void (*)(png_structp  ,
                                                                                png_const_charp  ))((void *)0),
                               (void (*)(png_structp  , png_const_charp  ))((void *)0));
#line 901
  read_ptr = (png_structp )tmp;
#line 904
  png_set_error_fn((png_structrp )read_ptr, (png_voidp )(& error_parameters), & pngtest_error,
                   & pngtest_warning);
#line 913
  tmp___0 = png_create_write_struct((png_const_charp )"1.6.39", (void *)0, (void (*)(png_structp  ,
                                                                                     png_const_charp  ))((void *)0),
                                    (void (*)(png_structp  , png_const_charp  ))((void *)0));
#line 913
  write_ptr = (png_structp )tmp___0;
#line 916
  png_set_error_fn((png_structrp )write_ptr, (png_voidp )(& error_parameters), & pngtest_error,
                   & pngtest_warning);
#line 920
  tmp___1 = png_create_info_struct((png_const_structrp )read_ptr);
#line 920
  read_info_ptr = (png_infop )tmp___1;
#line 921
  tmp___2 = png_create_info_struct((png_const_structrp )read_ptr);
#line 921
  end_info_ptr = (png_infop )tmp___2;
#line 923
  tmp___3 = png_create_info_struct((png_const_structrp )write_ptr);
#line 923
  write_info_ptr = (png_infop )tmp___3;
#line 924
  tmp___4 = png_create_info_struct((png_const_structrp )write_ptr);
#line 924
  write_end_info_ptr = (png_infop )tmp___4;
#line 928
  init_callback_info((png_const_infop )read_info_ptr);
#line 929
  png_set_read_user_chunk_fn((png_structrp )read_ptr, (png_voidp )(& user_chunk_data),
                             & read_user_chunk_callback);
#line 935
  tmp___5 = png_set_longjmp_fn((png_structrp )read_ptr, & longjmp, sizeof(jmp_buf ));
#line 935
  tmp___6 = _setjmp((struct __jmp_buf_tag *)(*tmp___5));
#line 935
  if (tmp___6) {
#line 937
    fprintf(stdout, (char const   *)"%s -> %s: libpng read error\n", inname___0, outname___0);
#line 938
    png_free((png_const_structrp )read_ptr, (png_voidp )row_buf);
#line 939
    row_buf = (png_bytep )((void *)0);
#line 940
    if (verbose != 0) {
#line 941
      fprintf(stdout, (char const   *)"   destroy read structs\n");
    }
#line 942
    png_destroy_read_struct(& read_ptr, & read_info_ptr, & end_info_ptr);
#line 944
    if (verbose != 0) {
#line 945
      fprintf(stdout, (char const   *)"   destroy write structs\n");
    }
#line 946
    png_destroy_info_struct((png_const_structrp )write_ptr, & write_end_info_ptr);
#line 947
    png_destroy_write_struct(& write_ptr, & write_info_ptr);
#line 949
    fclose(fpin);
#line 950
    fclose(fpout);
#line 951
    return (1);
  }
#line 957
  tmp___7 = png_set_longjmp_fn((png_structrp )write_ptr, & longjmp, sizeof(jmp_buf ));
#line 957
  tmp___8 = _setjmp((struct __jmp_buf_tag *)(*tmp___7));
#line 957
  if (tmp___8) {
#line 959
    fprintf(stdout, (char const   *)"%s -> %s: libpng write error\n", inname___0,
            outname___0);
#line 960
    png_free((png_const_structrp )read_ptr, (png_voidp )row_buf);
#line 961
    if (png_pixels != 0) free(png_pixels);
    row_buf = (png_bytep )((void *)0);
#line 962
    if (verbose != 0) {
#line 963
      fprintf(stdout, (char const   *)"   destroying read structs\n");
    }
#line 964
    png_destroy_read_struct(& read_ptr, & read_info_ptr, & end_info_ptr);
#line 965
    if (verbose != 0) {
#line 966
      fprintf(stdout, (char const   *)"   destroying write structs\n");
    }
#line 967
    png_destroy_info_struct((png_const_structrp )write_ptr, & write_end_info_ptr);
#line 968
    png_destroy_write_struct(& write_ptr, & write_info_ptr);
#line 969
    fclose(fpin);
#line 970
    fclose(fpout);
#line 971
    return (1);
  }
#line 977
  if (strict != 0) {
#line 980
    png_set_benign_errors((png_structrp )read_ptr, 0);
#line 984
    png_set_benign_errors((png_structrp )write_ptr, 0);
  } else
#line 993
  if (relaxed != 0) {
#line 996
    png_set_benign_errors((png_structrp )read_ptr, 1);
#line 999
    png_set_crc_action((png_structrp )read_ptr, 4, 4);
#line 1003
    png_set_option((png_structrp )read_ptr, 8, 3);
#line 1007
    png_set_benign_errors((png_structrp )write_ptr, 1);
  }
#line 1015
  png_init_io((png_structrp )read_ptr, fpin);
#line 1017
  png_init_io((png_structrp )write_ptr, fpout);
#line 1031
  if (status_dots_requested == 1) {
#line 1034
    png_set_write_status_fn((png_structrp )write_ptr, & write_row_callback);
#line 1036
    png_set_read_status_fn((png_structrp )read_ptr, & read_row_callback);
  } else {
#line 1042
    png_set_write_status_fn((png_structrp )write_ptr, (void (*)(png_structp  , png_uint_32  ,
                                                                int  ))((void *)0));
#line 1044
    png_set_read_status_fn((png_structrp )read_ptr, (void (*)(png_structp  , png_uint_32  ,
                                                              int  ))((void *)0));
  }
#line 1048
  png_set_read_user_transform_fn((png_structrp )read_ptr, & read_user_callback);
#line 1051
  zero_samples = (png_uint_32 )0;
#line 1052
  png_set_write_user_transform_fn((png_structrp )write_ptr, & count_zero_samples);
#line 1065
  png_set_keep_unknown_chunks((png_structrp )read_ptr, 3, (png_const_bytep )((void *)0),
                              0);
#line 1069
  png_set_keep_unknown_chunks((png_structrp )write_ptr, 3, (png_const_bytep )((void *)0),
                              0);
#line 1075
  png_read_info((png_structrp )read_ptr, (png_inforp )read_info_ptr);
#line 1083
  user_chunk_data.info_ptr = (png_const_infop )((void *)0);
#line 1090
  tmp___9 = png_get_IHDR((png_const_structrp )read_ptr, (png_const_inforp )read_info_ptr,
                         & width, & height, & bit_depth, & color_type, & interlace_type,
                         & compression_type, & filter_type);
#line 1090
  if (tmp___9 != 0U) {
#line 1093
    png_set_IHDR((png_const_structrp )write_ptr, (png_inforp )write_info_ptr, width,
                 height, bit_depth, color_type, interlace_type, compression_type,
                 filter_type);
    {
#line 1100
    if (interlace_type == 0) {
#line 1100
      goto case_0;
    }
#line 1104
    if (interlace_type == 1) {
#line 1104
      goto case_1;
    }
#line 1108
    goto switch_default;
    case_0: /* CIL Label */
#line 1101
    num_passes = (int volatile   )1;
#line 1102
    goto switch_break;
    case_1: /* CIL Label */
#line 1105
    num_passes = (int volatile   )7;
#line 1106
    goto switch_break;
    switch_default: /* CIL Label */
#line 1109
    png_error((png_const_structrp )read_ptr, (png_const_charp )"invalid interlace type");
    switch_break: /* CIL Label */ ;
    }
  } else {
#line 1115
    png_error((png_const_structrp )read_ptr, (png_const_charp )"png_get_IHDR failed");
  }
#line 1123
  tmp___10 = png_get_cHRM_fixed((png_const_structrp )read_ptr, (png_const_inforp )read_info_ptr,
                                & white_x, & white_y, & red_x, & red_y, & green_x,
                                & green_y, & blue_x, & blue_y);
#line 1123
  if (tmp___10 != 0U) {
#line 1126
    png_set_cHRM_fixed((png_const_structrp )write_ptr, (png_inforp )write_info_ptr,
                       white_x, white_y, red_x, red_y, green_x, green_y, blue_x, blue_y);
  }
#line 1135
  tmp___11 = png_get_gAMA_fixed((png_const_structrp )read_ptr, (png_const_inforp )read_info_ptr,
                                & gamma___0);
#line 1135
  if (tmp___11 != 0U) {
#line 1136
    png_set_gAMA_fixed((png_const_structrp )write_ptr, (png_inforp )write_info_ptr,
                       gamma___0);
  }
#line 1171
  tmp___12 = png_get_iCCP((png_const_structrp )read_ptr, (png_inforp )read_info_ptr,
                          & name, & compression_type___0, & profile, & proflen);
#line 1171
  if (tmp___12 != 0U) {
#line 1174
    png_set_iCCP((png_const_structrp )write_ptr, (png_inforp )write_info_ptr, (png_const_charp )name,
                 compression_type___0, (png_const_bytep )profile, proflen);
  }
#line 1183
  tmp___13 = png_get_sRGB((png_const_structrp )read_ptr, (png_const_inforp )read_info_ptr,
                          & intent);
#line 1183
  if (tmp___13 != 0U) {
#line 1184
    png_set_sRGB((png_const_structrp )write_ptr, (png_inforp )write_info_ptr, intent);
  }
#line 1191
  tmp___14 = png_get_PLTE((png_const_structrp )read_ptr, (png_inforp )read_info_ptr,
                          & palette, & num_palette);
#line 1191
  if (tmp___14 != 0U) {
#line 1192
    png_set_PLTE((png_structrp )write_ptr, (png_inforp )write_info_ptr, (png_const_colorp )palette,
                 num_palette);
  }
#line 1198
  tmp___15 = png_get_bKGD((png_const_structrp )read_ptr, (png_inforp )read_info_ptr,
                          & background);
#line 1198
  if (tmp___15 != 0U) {
#line 1200
    png_set_bKGD((png_const_structrp )write_ptr, (png_inforp )write_info_ptr, (png_const_color_16p )background);
  }
#line 1206
  exif = (png_bytep )((void *)0);
#line 1209
  tmp___16 = png_get_eXIf_1((png_const_structrp )read_ptr, (png_const_inforp )read_info_ptr,
                            & exif_length, & exif);
#line 1209
  if (tmp___16 != 0U) {
#line 1211
    if (exif_length > 1U) {
#line 1212
      fprintf(stdout, (char const   *)" eXIf type %c%c, %lu bytes\n", (int )*(exif + 0),
              (int )*(exif + 1), (unsigned long )exif_length);
    }
#line 1215
    png_set_eXIf_1((png_const_structrp )write_ptr, (png_inforp )write_info_ptr, exif_length,
                   exif);
  }
#line 1224
  tmp___17 = png_get_hIST((png_const_structrp )read_ptr, (png_inforp )read_info_ptr,
                          & hist);
#line 1224
  if (tmp___17 != 0U) {
#line 1225
    png_set_hIST((png_const_structrp )write_ptr, (png_inforp )write_info_ptr, (png_const_uint_16p )hist);
  }
#line 1233
  tmp___18 = png_get_oFFs((png_const_structrp )read_ptr, (png_const_inforp )read_info_ptr,
                          & offset_x, & offset_y, & unit_type);
#line 1233
  if (tmp___18 != 0U) {
#line 1236
    png_set_oFFs((png_const_structrp )write_ptr, (png_inforp )write_info_ptr, offset_x,
                 offset_y, unit_type);
  }
#line 1247
  tmp___19 = png_get_pCAL((png_const_structrp )read_ptr, (png_inforp )read_info_ptr,
                          & purpose, & X0, & X1, & type, & nparams, & units, & params);
#line 1247
  if (tmp___19 != 0U) {
#line 1250
    png_set_pCAL((png_const_structrp )write_ptr, (png_inforp )write_info_ptr, (png_const_charp )purpose,
                 X0, X1, type, nparams, (png_const_charp )units, params);
  }
#line 1260
  tmp___20 = png_get_pHYs((png_const_structrp )read_ptr, (png_const_inforp )read_info_ptr,
                          & res_x, & res_y, & unit_type___0);
#line 1260
  if (tmp___20 != 0U) {
#line 1262
    png_set_pHYs((png_const_structrp )write_ptr, (png_inforp )write_info_ptr, res_x,
                 res_y, unit_type___0);
  }
#line 1269
  tmp___21 = png_get_sBIT((png_const_structrp )read_ptr, (png_inforp )read_info_ptr,
                          & sig_bit);
#line 1269
  if (tmp___21 != 0U) {
#line 1270
    png_set_sBIT((png_const_structrp )write_ptr, (png_inforp )write_info_ptr, (png_const_color_8p )sig_bit);
  }
#line 1280
  tmp___22 = png_get_sCAL((png_const_structrp )read_ptr, (png_const_inforp )read_info_ptr,
                          & unit, & scal_width, & scal_height);
#line 1280
  if (tmp___22 != 0U) {
#line 1283
    png_set_sCAL((png_const_structrp )write_ptr, (png_inforp )write_info_ptr, unit,
                 scal_width, scal_height);
  }
#line 1307
  tmp___23 = png_get_sPLT((png_const_structrp )read_ptr, (png_inforp )read_info_ptr,
                          & entries);
#line 1307
  num_entries = tmp___23;
#line 1308
  if (num_entries) {
#line 1310
    png_set_sPLT((png_const_structrp )write_ptr, (png_inforp )write_info_ptr, (png_const_sPLT_tp )entries,
                 num_entries);
  }
#line 1320
  tmp___24 = png_get_text((png_const_structrp )read_ptr, (png_inforp )read_info_ptr,
                          & text_ptr, & num_text);
#line 1320
  if (tmp___24 > 0) {
#line 1324
    pngtest_check_text_support(read_ptr, text_ptr, num_text);
#line 1326
    if (verbose != 0) {
#line 1330
      fprintf(stdout, (char const   *)"\n");
#line 1331
      i = 0;
      {
#line 1331
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1331
        if (! (i < num_text)) {
#line 1331
          goto while_break;
        }
#line 1333
        fprintf(stdout, (char const   *)"   Text compression[%d]=%d\n", i, (text_ptr + i)->compression);
#line 1331
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 1338
    png_set_text((png_const_structrp )write_ptr, (png_inforp )write_info_ptr, (png_const_textp )text_ptr,
                 num_text);
  }
#line 1346
  tmp___26 = png_get_tIME((png_const_structrp )read_ptr, (png_inforp )read_info_ptr,
                          & mod_time);
#line 1346
  if (tmp___26 != 0U) {
#line 1348
    png_set_tIME((png_const_structrp )write_ptr, (png_inforp )write_info_ptr, (png_const_timep )mod_time);
#line 1350
    tmp___25 = png_convert_to_rfc1123_buffer((char *)(tIME_string), (png_const_timep )mod_time);
#line 1350
    if (tmp___25 != 0) {
#line 1351
      tIME_string[sizeof(tIME_string) - 1UL] = (char )'\000';
    } else {
#line 1355
      strncpy(tIME_string, (char const   *)"*** invalid time ***", sizeof(tIME_string));
#line 1356
      tIME_string[sizeof(tIME_string) - 1UL] = (char )'\000';
    }
#line 1359
    tIME_chunk_present ++;
  }
#line 1370
  tmp___27 = png_get_tRNS((png_const_structrp )read_ptr, (png_inforp )read_info_ptr,
                          & trans_alpha, & num_trans, & trans_color);
#line 1370
  if (tmp___27 != 0U) {
#line 1373
    sample_max = 1 << bit_depth;
#line 1375
    if (color_type == 0) {
#line 1375
      if (! ((int )trans_color->gray > sample_max)) {
#line 1375
        goto _L;
      }
    } else
    _L: /* CIL Label */
#line 1375
    if (color_type == 2) {
#line 1375
      if (! ((int )trans_color->red > sample_max)) {
#line 1375
        if (! ((int )trans_color->green > sample_max)) {
#line 1375
          if (! ((int )trans_color->blue > sample_max)) {
#line 1381
            png_set_tRNS((png_structrp )write_ptr, (png_inforp )write_info_ptr, (png_const_bytep )trans_alpha,
                         num_trans, (png_const_color_16p )trans_color);
          }
        }
      }
    } else {
#line 1381
      png_set_tRNS((png_structrp )write_ptr, (png_inforp )write_info_ptr, (png_const_bytep )trans_alpha,
                   num_trans, (png_const_color_16p )trans_color);
    }
  }
#line 1389
  tmp___28 = png_get_unknown_chunks((png_const_structrp )read_ptr, (png_inforp )read_info_ptr,
                                    & unknowns);
#line 1389
  num_unknowns = tmp___28;
#line 1392
  if (num_unknowns != 0) {
#line 1394
    png_set_unknown_chunks((png_const_structrp )write_ptr, (png_inforp )write_info_ptr,
                           (png_const_unknown_chunkp )unknowns, num_unknowns);
  }
#line 1418
  png_write_info_before_PLTE((png_structrp )write_ptr, (png_const_inforp )write_info_ptr);
#line 1420
  write_chunks(write_ptr, 0x10);
#line 1422
  png_write_info((png_structrp )write_ptr, (png_const_inforp )write_info_ptr);
#line 1424
  write_chunks(write_ptr, 0x20);
#line 1426
  png_write_info((png_structrp )write_ptr, (png_const_inforp )write_end_info_ptr);
#line 1428
  write_chunks(write_ptr, 0x40);
#line 1438
  tmp___29 = png_get_rowbytes((png_const_structrp )read_ptr, (png_const_inforp )read_info_ptr);
#line 1438
  tmp___30 = png_malloc((png_const_structrp )read_ptr, tmp___29);
#line 1438
  row_buf = (png_bytep )tmp___30;
  png_pixels = (unsigned char*) png_malloc(read_ptr, png_get_rowbytes(read_ptr, read_info_ptr));
#line 1451
  tmp___31 = png_set_interlace_handling((png_structrp )read_ptr);
#line 1451
  if (tmp___31 != (int )num_passes) {
#line 1452
    png_error((png_const_structrp )write_ptr, (png_const_charp )"png_set_interlace_handling(read): wrong pass count ");
  }
#line 1454
  tmp___32 = png_set_interlace_handling((png_structrp )write_ptr);
#line 1454
  if (tmp___32 != (int )num_passes) {
#line 1455
    png_error((png_const_structrp )write_ptr, (png_const_charp )"png_set_interlace_handling(write): wrong pass count ");
  }
#line 1466
  pass = 0;
  {
#line 1466
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1466
    if (! (pass < (int )num_passes)) {
#line 1466
      goto while_break___0;
    }
#line 1487
    y = (png_uint_32 )0;
    {
#line 1487
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1487
      if (! (y < height)) {
#line 1487
        goto while_break___1;
      }
#line 1499
      png_read_rows((png_structrp )read_ptr, & row_buf, (png_bytepp )((void *)0),
                    (png_uint_32 )1);
#line 1507
      png_write_rows((png_structrp )write_ptr, & row_buf, (png_uint_32 )1);
#line 1487
      y ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1466
    pass ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1525
  png_free_data((png_const_structrp )read_ptr, (png_inforp )read_info_ptr, 0x0200U,
                -1);
#line 1528
  png_free_data((png_const_structrp )write_ptr, (png_inforp )write_info_ptr, 0x0200U,
                -1);
#line 1534
  png_read_end((png_structrp )read_ptr, (png_inforp )end_info_ptr);
#line 1540
  tmp___33 = png_get_text((png_const_structrp )read_ptr, (png_inforp )end_info_ptr,
                          & text_ptr___0, & num_text___0);
#line 1540
  if (tmp___33 > 0) {
#line 1544
    pngtest_check_text_support(read_ptr, text_ptr___0, num_text___0);
#line 1546
    if (verbose != 0) {
#line 1550
      fprintf(stdout, (char const   *)"\n");
#line 1551
      i___0 = 0;
      {
#line 1551
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1551
        if (! (i___0 < num_text___0)) {
#line 1551
          goto while_break___2;
        }
#line 1553
        fprintf(stdout, (char const   *)"   Text compression[%d]=%d\n", i___0, (text_ptr___0 + i___0)->compression);
#line 1551
        i___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1558
    png_set_text((png_const_structrp )write_ptr, (png_inforp )write_end_info_ptr,
                 (png_const_textp )text_ptr___0, num_text___0);
  }
#line 1564
  exif___0 = (png_bytep )((void *)0);
#line 1567
  tmp___34 = png_get_eXIf_1((png_const_structrp )read_ptr, (png_const_inforp )end_info_ptr,
                            & exif_length___0, & exif___0);
#line 1567
  if (tmp___34 != 0U) {
#line 1569
    if (exif_length___0 > 1U) {
#line 1570
      fprintf(stdout, (char const   *)" eXIf type %c%c, %lu bytes\n", (int )*(exif___0 + 0),
              (int )*(exif___0 + 1), (unsigned long )exif_length___0);
    }
#line 1573
    png_set_eXIf_1((png_const_structrp )write_ptr, (png_inforp )write_end_info_ptr,
                   exif_length___0, exif___0);
  }
#line 1582
  tmp___36 = png_get_tIME((png_const_structrp )read_ptr, (png_inforp )end_info_ptr,
                          & mod_time___0);
#line 1582
  if (tmp___36 != 0U) {
#line 1584
    png_set_tIME((png_const_structrp )write_ptr, (png_inforp )write_end_info_ptr,
                 (png_const_timep )mod_time___0);
#line 1586
    tmp___35 = png_convert_to_rfc1123_buffer((char *)(tIME_string), (png_const_timep )mod_time___0);
#line 1586
    if (tmp___35 != 0) {
#line 1587
      tIME_string[sizeof(tIME_string) - 1UL] = (char )'\000';
    } else {
#line 1591
      strncpy(tIME_string, (char const   *)"*** invalid time ***", sizeof(tIME_string));
#line 1592
      tIME_string[sizeof(tIME_string) - 1UL] = (char )'\000';
    }
#line 1595
    tIME_chunk_present ++;
  }
#line 1603
  tmp___37 = png_get_unknown_chunks((png_const_structrp )read_ptr, (png_inforp )end_info_ptr,
                                    & unknowns___0);
#line 1603
  num_unknowns___0 = tmp___37;
#line 1606
  if (num_unknowns___0 != 0) {
#line 1608
    png_set_unknown_chunks((png_const_structrp )write_ptr, (png_inforp )write_end_info_ptr,
                           (png_const_unknown_chunkp )unknowns___0, num_unknowns___0);
  }
#line 1632
  png_set_text_compression_strategy((png_structrp )write_ptr, 1);
#line 1641
  write_chunks(write_ptr, 0x40);
#line 1643
  png_write_end((png_structrp )write_ptr, (png_inforp )write_end_info_ptr);
#line 1647
  if (verbose != 0) {
#line 1650
    iwidth = png_get_image_width((png_const_structrp )write_ptr, (png_const_inforp )write_info_ptr);
#line 1651
    iheight = png_get_image_height((png_const_structrp )write_ptr, (png_const_inforp )write_info_ptr);
#line 1652
    fprintf(stdout, (char const   *)"\n Image width = %lu, height = %lu\n", (unsigned long )iwidth,
            (unsigned long )iheight);
  }
#line 1660
  png_free((png_const_structrp )read_ptr, (png_voidp )row_buf);
#line 1661
  row_buf = (png_bytep )((void *)0);
#line 1664
  png_destroy_read_struct(& read_ptr, & read_info_ptr, & end_info_ptr);
#line 1667
  png_destroy_info_struct((png_const_structrp )write_ptr, & write_end_info_ptr);
#line 1669
  png_destroy_write_struct(& write_ptr, & write_info_ptr);
#line 1673
  fclose(fpin);
#line 1674
  fclose(fpout);
#line 1680
  if (error_count > 0) {
#line 1685
    fprintf(stdout, (char const   *)"\n  %s: %d libpng errors found (%d warnings)",
            inname___0, error_count, warning_count);
#line 1688
    if (strict != 0) {
#line 1689
      return (1);
    }
  } else
#line 1694
  if (unsupported_chunks > 0) {
#line 1696
    if (strict) {
#line 1696
      tmp___38 = ": IGNORED --strict!";
    } else {
#line 1696
      tmp___38 = "";
    }
#line 1696
    fprintf(stdout, (char const   *)"\n  %s: unsupported chunks (%d)%s", inname___0,
            unsupported_chunks, tmp___38);
  } else
#line 1701
  if (warning_count > 0) {
#line 1703
    fprintf(stdout, (char const   *)"\n  %s: %d libpng warnings found", inname___0,
            warning_count);
#line 1706
    if (strict != 0) {
#line 1707
      return (1);
    }
  }
#line 1711
  fpin = fopen((char const   * __restrict  )inname___0, (char const   * __restrict  )"rb");
#line 1711
  if ((unsigned long )fpin == (unsigned long )((void *)0)) {
#line 1713
    fprintf(stdout, (char const   *)"Could not find file %s\n", inname___0);
#line 1714
    return (1);
  }
#line 1717
  fpout = fopen((char const   * __restrict  )outname___0, (char const   * __restrict  )"rb");
#line 1717
  if ((unsigned long )fpout == (unsigned long )((void *)0)) {
#line 1719
    fprintf(stdout, (char const   *)"Could not find file %s\n", outname___0);
#line 1720
    fclose(fpin);
#line 1721
    return (1);
  }
#line 1726
  if (interlace_preserved != 0) {
    {
#line 1728
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1734
      num_in = fread((void *)(inbuf), (size_t )1, sizeof(inbuf), fpin);
#line 1735
      num_out = fread((void *)(outbuf), (size_t )1, sizeof(outbuf), fpout);
#line 1737
      if (num_in != num_out) {
#line 1739
        fprintf(stdout, (char const   *)"\nFiles %s and %s are of a different size\n",
                inname___0, outname___0);
#line 1742
        if (wrote_question == 0) {
#line 1742
          if (unsupported_chunks == 0) {
#line 1744
            fprintf(stdout, (char const   *)"   Was %s written with the same maximum IDAT chunk size (%d bytes),",
                    inname___0, 8192);
#line 1748
            fprintf(stdout, (char const   *)"\n   filtering heuristic (libpng default), compression");
#line 1750
            fprintf(stdout, (char const   *)" level (zlib default),\n   and zlib version (%s)?\n\n",
                    "1.2.11");
#line 1753
            wrote_question = 1;
          }
        }
#line 1756
        fclose(fpin);
#line 1757
        fclose(fpout);
#line 1759
        if (strict != 0) {
#line 1759
          if (unsupported_chunks == 0) {
#line 1760
            return (1);
          } else {
#line 1763
            return (0);
          }
        } else {
#line 1763
          return (0);
        }
      }
#line 1766
      if (num_in == 0UL) {
#line 1767
        goto while_break___3;
      }
#line 1769
      tmp___39 = memcmp((void const   *)(inbuf), (void const   *)(outbuf), num_in);
#line 1769
      if (tmp___39) {
#line 1771
        fprintf(stdout, (char const   *)"\nFiles %s and %s are different\n", inname___0,
                outname___0);
#line 1774
        if (wrote_question == 0) {
#line 1774
          if (unsupported_chunks == 0) {
#line 1776
            fprintf(stdout, (char const   *)"   Was %s written with the same maximum IDAT chunk size (%d bytes),",
                    inname___0, 8192);
#line 1780
            fprintf(stdout, (char const   *)"\n   filtering heuristic (libpng default), compression");
#line 1782
            fprintf(stdout, (char const   *)" level (zlib default),\n   and zlib version (%s)?\n\n",
                    "1.2.11");
#line 1785
            wrote_question = 1;
          }
        }
#line 1788
        fclose(fpin);
#line 1789
        fclose(fpout);
#line 1796
        if (strict != 0) {
#line 1796
          if (unsupported_chunks == 0) {
#line 1797
            return (1);
          } else {
#line 1800
            return (0);
          }
        } else {
#line 1800
          return (0);
        }
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 1806
  fclose(fpin);
#line 1807
  fclose(fpout);
#line 1809
  return (0);
}
}
#line 1817 "/home/goblint2/bench/libpng-1.6.39/pngtest.c"
static char const   *inname  =    (char const   *)"pngtest.png";
#line 1818 "/home/goblint2/bench/libpng-1.6.39/pngtest.c"
static char const   *outname  =    (char const   *)"pngout.png";
#line 1821 "/home/goblint2/bench/libpng-1.6.39/pngtest.c"
int main(int argc , char **argv )
{
  int multiple ;
  int ierror ;
  png_structp dummy_ptr ;
  png_const_charp tmp ;
  png_const_charp tmp___0 ;
  png_uint_32 tmp___1 ;
  png_const_charp tmp___2 ;
  png_const_charp tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int i ;
  int kerror ;
  int i___0 ;
  int kerror___0 ;
  png_structp __attribute__((__malloc__))  tmp___12 ;
  png_uint_32 tmp___13 ;
  png_uint_32 tmp___14 ;
  png_uint_32 tmp___15 ;
  png_uint_32 tmp___16 ;
  png_alloc_size_t tmp___17 ;
  png_alloc_size_t tmp___18 ;

  {
#line 1824
  multiple = 0;
#line 1825
  ierror = 0;
#line 1829
  fprintf(stdout, (char const   *)"\n Testing libpng version %s\n", "1.6.39");
#line 1830
  fprintf(stdout, (char const   *)"   with zlib   version %s\n", "1.2.11");
#line 1831
  tmp = png_get_copyright((png_const_structrp )((void *)0));
#line 1831
  fprintf(stdout, (char const   *)"%s", tmp);
#line 1833
  tmp___0 = png_get_header_version((png_const_structrp )((void *)0));
#line 1833
  tmp___1 = png_access_version_number();
#line 1833
  fprintf(stdout, (char const   *)" library (%lu):%s", (unsigned long )tmp___1, tmp___0);
#line 1838
  fprintf(stdout, (char const   *)" pngtest (%lu):%s", 10639UL, " libpng version 1.6.39 - November 20, 2022\n");
#line 1854
  tmp___3 = png_get_header_ver((png_const_structrp )((void *)0));
#line 1854
  tmp___4 = strcmp(tmp___3, (char const   *)"1.6.39");
#line 1854
  if (tmp___4) {
#line 1856
    fprintf(stdout, (char const   *)"Warning: versions are different between png.h and png.c\n");
#line 1858
    fprintf(stdout, (char const   *)"  png.h version: %s\n", "1.6.39");
#line 1859
    tmp___2 = png_get_header_ver((png_const_structrp )((void *)0));
#line 1859
    fprintf(stdout, (char const   *)"  png.c version: %s\n\n", tmp___2);
#line 1860
    ierror ++;
  }
#line 1863
  if (argc > 1) {
#line 1865
    tmp___11 = strcmp((char const   *)*(argv + 1), (char const   *)"-m");
#line 1865
    if (tmp___11 == 0) {
#line 1867
      multiple = 1;
#line 1868
      status_dots_requested = 0;
    } else {
#line 1871
      tmp___9 = strcmp((char const   *)*(argv + 1), (char const   *)"-mv");
#line 1871
      if (tmp___9 == 0) {
#line 1874
        multiple = 1;
#line 1875
        verbose = 1;
#line 1876
        status_dots_requested = 1;
      } else {
#line 1871
        tmp___10 = strcmp((char const   *)*(argv + 1), (char const   *)"-vm");
#line 1871
        if (tmp___10 == 0) {
#line 1874
          multiple = 1;
#line 1875
          verbose = 1;
#line 1876
          status_dots_requested = 1;
        } else {
#line 1879
          tmp___8 = strcmp((char const   *)*(argv + 1), (char const   *)"-v");
#line 1879
          if (tmp___8 == 0) {
#line 1881
            verbose = 1;
#line 1882
            status_dots_requested = 1;
#line 1883
            inname = (char const   *)*(argv + 2);
          } else {
#line 1886
            tmp___7 = strcmp((char const   *)*(argv + 1), (char const   *)"--strict");
#line 1886
            if (tmp___7 == 0) {
#line 1888
              status_dots_requested = 0;
#line 1889
              verbose = 1;
#line 1890
              inname = (char const   *)*(argv + 2);
#line 1891
              strict ++;
#line 1892
              relaxed = 0;
#line 1893
              multiple = 1;
            } else {
#line 1896
              tmp___6 = strcmp((char const   *)*(argv + 1), (char const   *)"--relaxed");
#line 1896
              if (tmp___6 == 0) {
#line 1898
                status_dots_requested = 0;
#line 1899
                verbose = 1;
#line 1900
                inname = (char const   *)*(argv + 2);
#line 1901
                strict = 0;
#line 1902
                relaxed ++;
#line 1903
                multiple = 1;
              } else {
#line 1905
                tmp___5 = strcmp((char const   *)*(argv + 1), (char const   *)"--xfail");
#line 1905
                if (tmp___5 == 0) {
#line 1907
                  status_dots_requested = 0;
#line 1908
                  verbose = 1;
#line 1909
                  inname = (char const   *)*(argv + 2);
#line 1910
                  strict = 0;
#line 1911
                  xfail ++;
#line 1912
                  relaxed ++;
#line 1913
                  multiple = 1;
                } else {
#line 1918
                  inname = (char const   *)*(argv + 1);
#line 1919
                  status_dots_requested = 0;
                }
              }
            }
          }
        }
      }
    }
  }
#line 1923
  if (multiple == 0) {
#line 1923
    if (argc == 3 + verbose) {
#line 1924
      outname = (char const   *)*(argv + (2 + verbose));
    }
  }
#line 1926
  if (multiple == 0) {
#line 1926
    if (argc > 3 + verbose) {
#line 1929
      fprintf(stdout, (char const   *)"usage: %s [infile.png] [outfile.png]\n\t%s -m {infile.png}\n",
              *(argv + 0), *(argv + 0));
#line 1932
      fprintf(stdout, (char const   *)"  reads/writes one PNG file (without -m) or multiple files (-m)\n");
#line 1934
      fprintf(stdout, (char const   *)"  with -m %s is used as a temporary file\n",
              outname);
#line 1936
      exit(1);
    } else {
#line 1926
      goto _L;
    }
  } else
  _L: /* CIL Label */
#line 1926
  if (multiple != 0) {
#line 1926
    if (argc < 2) {
#line 1929
      fprintf(stdout, (char const   *)"usage: %s [infile.png] [outfile.png]\n\t%s -m {infile.png}\n",
              *(argv + 0), *(argv + 0));
#line 1932
      fprintf(stdout, (char const   *)"  reads/writes one PNG file (without -m) or multiple files (-m)\n");
#line 1934
      fprintf(stdout, (char const   *)"  with -m %s is used as a temporary file\n",
              outname);
#line 1936
      exit(1);
    }
  }
#line 1939
  if (multiple != 0) {
#line 1945
    i = 2;
    {
#line 1945
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1945
      if (! (i < argc)) {
#line 1945
        goto while_break;
      }
#line 1948
      fprintf(stdout, (char const   *)"\n Testing %s:", *(argv + i));
#line 1952
      kerror = test_one_file((char const   *)*(argv + i), outname);
#line 1953
      if (kerror == 0) {
#line 1956
        fprintf(stdout, (char const   *)"\n PASS (%lu zero samples)\n", (unsigned long )zero_samples);
#line 1962
        if (tIME_chunk_present != 0) {
#line 1963
          fprintf(stdout, (char const   *)" tIME = %s\n", tIME_string);
        }
#line 1965
        tIME_chunk_present = 0;
      } else
#line 1971
      if (xfail) {
#line 1972
        fprintf(stdout, (char const   *)" XFAIL\n");
      } else {
#line 1975
        fprintf(stdout, (char const   *)" FAIL\n");
#line 1976
        ierror += kerror;
      }
#line 1945
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 2016
    i___0 = 0;
    {
#line 2016
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2016
      if (! (i___0 < 3)) {
#line 2016
        goto while_break___0;
      }
#line 2022
      if (i___0 == 1) {
#line 2023
        status_dots_requested = 1;
      } else
#line 2025
      if (verbose == 0) {
#line 2026
        status_dots_requested = 0;
      }
#line 2028
      if (i___0 == 0) {
#line 2030
        fprintf(stdout, (char const   *)"\n Testing %s:", inname);
      } else
#line 2028
      if (verbose == 1) {
#line 2030
        fprintf(stdout, (char const   *)"\n Testing %s:", inname);
      } else
#line 2028
      if (ierror != 0) {
#line 2030
        fprintf(stdout, (char const   *)"\n Testing %s:", inname);
      }
#line 2036
      kerror___0 = test_one_file(inname, outname);
#line 2038
      if (kerror___0 == 0) {
#line 2040
        if (verbose == 1) {
#line 2040
          goto _L___0;
        } else
#line 2040
        if (i___0 == 2) {
          _L___0: /* CIL Label */
#line 2043
          fprintf(stdout, (char const   *)"\n PASS (%lu zero samples)\n", (unsigned long )zero_samples);
#line 2049
          if (tIME_chunk_present != 0) {
#line 2050
            fprintf(stdout, (char const   *)" tIME = %s\n", tIME_string);
          }
        }
      } else {
#line 2057
        if (verbose == 0) {
#line 2057
          if (i___0 != 2) {
#line 2059
            fprintf(stdout, (char const   *)"\n Testing %s:", inname);
          }
        }
#line 2065
        if (xfail) {
#line 2066
          fprintf(stdout, (char const   *)" XFAIL\n");
        } else {
#line 2069
          fprintf(stdout, (char const   *)" FAIL\n");
#line 2070
          ierror += kerror___0;
        }
      }
#line 2016
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 2120
  if (ierror == 0) {
#line 2121
    fprintf(stdout, (char const   *)" libpng passes test\n");
  } else {
#line 2124
    fprintf(stdout, (char const   *)" libpng FAILS test\n");
  }
#line 2126
  tmp___12 = png_create_read_struct((png_const_charp )"1.6.39", (void *)0, (void (*)(png_structp  ,
                                                                                     png_const_charp  ))((void *)0),
                                    (void (*)(png_structp  , png_const_charp  ))((void *)0));
#line 2126
  dummy_ptr = (png_structp )tmp___12;
#line 2127
  fprintf(stdout, (char const   *)" Default limits:\n");
#line 2128
  tmp___13 = png_get_user_width_max((png_const_structrp )dummy_ptr);
#line 2128
  fprintf(stdout, (char const   *)"  width_max  = %lu\n", (unsigned long )tmp___13);
#line 2130
  tmp___14 = png_get_user_height_max((png_const_structrp )dummy_ptr);
#line 2130
  fprintf(stdout, (char const   *)"  height_max = %lu\n", (unsigned long )tmp___14);
#line 2132
  tmp___16 = png_get_chunk_cache_max((png_const_structrp )dummy_ptr);
#line 2132
  if (tmp___16 == 0U) {
#line 2133
    fprintf(stdout, (char const   *)"  cache_max  = unlimited\n");
  } else {
#line 2135
    tmp___15 = png_get_chunk_cache_max((png_const_structrp )dummy_ptr);
#line 2135
    fprintf(stdout, (char const   *)"  cache_max  = %lu\n", (unsigned long )tmp___15);
  }
#line 2137
  tmp___18 = png_get_chunk_malloc_max((png_const_structrp )dummy_ptr);
#line 2137
  if (tmp___18 == 0UL) {
#line 2138
    fprintf(stdout, (char const   *)"  malloc_max = unlimited\n");
  } else {
#line 2140
    tmp___17 = png_get_chunk_malloc_max((png_const_structrp )dummy_ptr);
#line 2140
    fprintf(stdout, (char const   *)"  malloc_max = %lu\n", tmp___17);
  }
#line 2142
  png_destroy_read_struct(& dummy_ptr, (png_infopp )((void *)0), (png_infopp )((void *)0));
#line 2144
  return (ierror != 0);
}
}
#line 101 "/usr/include/stdlib.h"
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 104
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 107
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 112
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__leaf__, __gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__,
__nothrow__)) ;
#line 187
extern long long ( __attribute__((__nonnull__(1), __leaf__)) strtoq)(char const   *__nptr ,
                                                                     char **__endptr ,
                                                                     int __base )  __attribute__((__nothrow__)) ;
#line 192
extern unsigned long long ( __attribute__((__nonnull__(1), __leaf__)) strtouq)(char const   *__nptr ,
                                                                               char **__endptr ,
                                                                               int __base )  __attribute__((__nothrow__)) ;
#line 385
extern char *( __attribute__((__warn_unused_result__, __leaf__)) l64a)(long __n )  __attribute__((__nothrow__)) ;
#line 388
extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) a64l)(char const   *__s )  __attribute__((__pure__,
__nothrow__)) ;
#line 33 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint16_t __bswap_16(__uint16_t __bsx )
{
  short tmp ;

  {
#line 37
  tmp = __builtin_bswap16((short )__bsx);
#line 37
  return ((__uint16_t )tmp);
}
}
#line 48 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint32_t __bswap_32(__uint32_t __bsx )
{
  int tmp ;

  {
#line 52
  tmp = __builtin_bswap32((int )__bsx);
#line 52
  return ((__uint32_t )tmp);
}
}
#line 69 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint64_t __bswap_64(__uint64_t __bsx )
{
  long tmp ;

  {
#line 73
  tmp = __builtin_bswap64((long )__bsx);
#line 73
  return ((__uint64_t )tmp);
}
}
#line 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint16_t __uint16_identity(__uint16_t __x )
{


  {
#line 35
  return (__x);
}
}
#line 38 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint32_t __uint32_identity(__uint32_t __x )
{


  {
#line 41
  return (__x);
}
}
#line 44 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint64_t __uint64_identity(__uint64_t __x )
{


  {
#line 47
  return (__x);
}
}
#line 101 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                  struct timeval *__timeout ) ;
#line 113
extern int pselect(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                   struct timespec  const  *__timeout , __sigset_t const   *__sigmask ) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/select2.h"
extern long __fdelt_chk(long __d ) ;
#line 25
extern long __fdelt_warn(long __d )  __attribute__((__warning__("bit outside of fd_set selected"))) ;
#line 401 "/usr/include/stdlib.h"
extern long ( __attribute__((__leaf__)) random)(void)  __attribute__((__nothrow__)) ;
#line 404
extern void ( __attribute__((__leaf__)) srandom)(unsigned int __seed )  __attribute__((__nothrow__)) ;
#line 410
extern char *( __attribute__((__nonnull__(2), __leaf__)) initstate)(unsigned int __seed ,
                                                                    char *__statebuf ,
                                                                    size_t __statelen )  __attribute__((__nothrow__)) ;
#line 415
extern char *( __attribute__((__nonnull__(1), __leaf__)) setstate)(char *__statebuf )  __attribute__((__nothrow__)) ;
#line 434
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) random_r)(struct random_data *__buf ,
                                                                   int32_t *__result )  __attribute__((__nothrow__)) ;
#line 437
extern int ( __attribute__((__nonnull__(2), __leaf__)) srandom_r)(unsigned int __seed ,
                                                                  struct random_data *__buf )  __attribute__((__nothrow__)) ;
#line 440
extern int ( __attribute__((__nonnull__(2,4), __leaf__)) initstate_r)(unsigned int __seed ,
                                                                      char *__statebuf ,
                                                                      size_t __statelen ,
                                                                      struct random_data *__buf )  __attribute__((__nothrow__)) ;
#line 445
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) setstate_r)(char *__statebuf ,
                                                                     struct random_data *__buf )  __attribute__((__nothrow__)) ;
#line 459
extern int ( __attribute__((__leaf__)) rand_r)(unsigned int *__seed )  __attribute__((__nothrow__)) ;
#line 467
extern double ( __attribute__((__leaf__)) drand48)(void)  __attribute__((__nothrow__)) ;
#line 468
extern double ( __attribute__((__nonnull__(1), __leaf__)) erand48)(unsigned short *__xsubi )  __attribute__((__nothrow__)) ;
#line 471
extern long ( __attribute__((__leaf__)) lrand48)(void)  __attribute__((__nothrow__)) ;
#line 472
extern long ( __attribute__((__nonnull__(1), __leaf__)) nrand48)(unsigned short *__xsubi )  __attribute__((__nothrow__)) ;
#line 476
extern long ( __attribute__((__leaf__)) mrand48)(void)  __attribute__((__nothrow__)) ;
#line 477
extern long ( __attribute__((__nonnull__(1), __leaf__)) jrand48)(unsigned short *__xsubi )  __attribute__((__nothrow__)) ;
#line 481
extern void ( __attribute__((__leaf__)) srand48)(long __seedval )  __attribute__((__nothrow__)) ;
#line 482
extern unsigned short *( __attribute__((__nonnull__(1), __leaf__)) seed48)(unsigned short *__seed16v )  __attribute__((__nothrow__)) ;
#line 484
extern void ( __attribute__((__nonnull__(1), __leaf__)) lcong48)(unsigned short *__param )  __attribute__((__nothrow__)) ;
#line 501
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) drand48_r)(struct drand48_data *__buffer ,
                                                                    double *__result )  __attribute__((__nothrow__)) ;
#line 503
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) erand48_r)(unsigned short *__xsubi ,
                                                                    struct drand48_data *__buffer ,
                                                                    double *__result )  __attribute__((__nothrow__)) ;
#line 508
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) lrand48_r)(struct drand48_data *__buffer ,
                                                                    long *__result )  __attribute__((__nothrow__)) ;
#line 511
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) nrand48_r)(unsigned short *__xsubi ,
                                                                    struct drand48_data *__buffer ,
                                                                    long *__result )  __attribute__((__nothrow__)) ;
#line 517
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) mrand48_r)(struct drand48_data *__buffer ,
                                                                    long *__result )  __attribute__((__nothrow__)) ;
#line 520
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) jrand48_r)(unsigned short *__xsubi ,
                                                                    struct drand48_data *__buffer ,
                                                                    long *__result )  __attribute__((__nothrow__)) ;
#line 526
extern int ( __attribute__((__nonnull__(2), __leaf__)) srand48_r)(long __seedval ,
                                                                  struct drand48_data *__buffer )  __attribute__((__nothrow__)) ;
#line 529
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) seed48_r)(unsigned short *__seed16v ,
                                                                   struct drand48_data *__buffer )  __attribute__((__nothrow__)) ;
#line 532
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) lcong48_r)(unsigned short *__param ,
                                                                    struct drand48_data *__buffer )  __attribute__((__nothrow__)) ;
#line 559
extern void *( __attribute__((__warn_unused_result__, __leaf__)) reallocarray)(void *__ptr ,
                                                                               size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__nothrow__,
__alloc_size__(2,3))) ;
#line 32 "/usr/include/alloca.h"
extern void *( __attribute__((__leaf__)) alloca)(size_t __size )  __attribute__((__nothrow__)) ;
#line 574 "/usr/include/stdlib.h"
extern void *( __attribute__((__warn_unused_result__, __leaf__)) valloc)(size_t __size )  __attribute__((__nothrow__,
__malloc__, __alloc_size__(1))) ;
#line 580
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) posix_memalign)(void **__memptr ,
                                                                                               size_t __alignment ,
                                                                                               size_t __size )  __attribute__((__nothrow__)) ;
#line 610
extern int ( __attribute__((__nonnull__(1), __leaf__)) on_exit)(void (*__func)(int __status ,
                                                                               void *__arg ) ,
                                                                void *__arg )  __attribute__((__nothrow__)) ;
#line 647
extern int ( __attribute__((__nonnull__(1), __leaf__)) putenv)(char *__string )  __attribute__((__nothrow__)) ;
#line 653
extern int ( __attribute__((__nonnull__(2), __leaf__)) setenv)(char const   *__name ,
                                                               char const   *__value ,
                                                               int __replace )  __attribute__((__nothrow__)) ;
#line 657
extern int ( __attribute__((__nonnull__(1), __leaf__)) unsetenv)(char const   *__name )  __attribute__((__nothrow__)) ;
#line 664
extern int ( __attribute__((__leaf__)) clearenv)(void)  __attribute__((__nothrow__)) ;
#line 675
extern char *( __attribute__((__nonnull__(1), __leaf__)) mktemp)(char *__template )  __attribute__((__nothrow__)) ;
#line 688
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1))) mkstemp)(char *__template ) ;
#line 710
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1))) mkstemps)(char *__template ,
                                                                               int __suffixlen ) ;
#line 731
extern char *( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) mkdtemp)(char *__template )  __attribute__((__nothrow__)) ;
#line 800
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) realpath___15)(char const   *__name , char *__resolved )  __attribute__((__nothrow__)) ;
#line 820
__inline extern void *( __attribute__((__warn_unused_result__, __nonnull__(1,2,5),
__gnu_inline__)) bsearch)(void const   *__key , void const   *__base , size_t __nmemb ,
                          size_t __size , int (*__compar)(void const   * , void const   * ) ) ;
#line 872
extern char *( __attribute__((__warn_unused_result__, __nonnull__(3,4), __leaf__)) ecvt)(double __value ,
                                                                                         int __ndigit ,
                                                                                         int *__decpt ,
                                                                                         int *__sign )  __attribute__((__nothrow__)) ;
#line 878
extern char *( __attribute__((__warn_unused_result__, __nonnull__(3,4), __leaf__)) fcvt)(double __value ,
                                                                                         int __ndigit ,
                                                                                         int *__decpt ,
                                                                                         int *__sign )  __attribute__((__nothrow__)) ;
#line 884
extern char *( __attribute__((__warn_unused_result__, __nonnull__(3), __leaf__)) gcvt)(double __value ,
                                                                                       int __ndigit ,
                                                                                       char *__buf )  __attribute__((__nothrow__)) ;
#line 890
extern char *( __attribute__((__warn_unused_result__, __nonnull__(3,4), __leaf__)) qecvt)(long double __value ,
                                                                                          int __ndigit ,
                                                                                          int *__decpt ,
                                                                                          int *__sign )  __attribute__((__nothrow__)) ;
#line 893
extern char *( __attribute__((__warn_unused_result__, __nonnull__(3,4), __leaf__)) qfcvt)(long double __value ,
                                                                                          int __ndigit ,
                                                                                          int *__decpt ,
                                                                                          int *__sign )  __attribute__((__nothrow__)) ;
#line 896
extern char *( __attribute__((__warn_unused_result__, __nonnull__(3), __leaf__)) qgcvt)(long double __value ,
                                                                                        int __ndigit ,
                                                                                        char *__buf )  __attribute__((__nothrow__)) ;
#line 902
extern int ( __attribute__((__nonnull__(3,4,5), __leaf__)) ecvt_r)(double __value ,
                                                                   int __ndigit ,
                                                                   int *__decpt ,
                                                                   int *__sign , char *__buf ,
                                                                   size_t __len )  __attribute__((__nothrow__)) ;
#line 905
extern int ( __attribute__((__nonnull__(3,4,5), __leaf__)) fcvt_r)(double __value ,
                                                                   int __ndigit ,
                                                                   int *__decpt ,
                                                                   int *__sign , char *__buf ,
                                                                   size_t __len )  __attribute__((__nothrow__)) ;
#line 909
extern int ( __attribute__((__nonnull__(3,4,5), __leaf__)) qecvt_r)(long double __value ,
                                                                    int __ndigit ,
                                                                    int *__decpt ,
                                                                    int *__sign ,
                                                                    char *__buf ,
                                                                    size_t __len )  __attribute__((__nothrow__)) ;
#line 913
extern int ( __attribute__((__nonnull__(3,4,5), __leaf__)) qfcvt_r)(long double __value ,
                                                                    int __ndigit ,
                                                                    int *__decpt ,
                                                                    int *__sign ,
                                                                    char *__buf ,
                                                                    size_t __len )  __attribute__((__nothrow__)) ;
#line 929
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar )  __attribute__((__nothrow__)) ;
#line 933
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t *__dst , char const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 936
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) wcstombs)(char *__dst , wchar_t const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 946
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) rpmatch)(char const   *__response )  __attribute__((__nothrow__)) ;
#line 957
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1,2,3), __leaf__)) getsubopt)(char **__optionp ,
                                                                                              char **__tokens ,
                                                                                              char **__valuep )  __attribute__((__nothrow__)) ;
#line 1003
extern int ( __attribute__((__nonnull__(1), __leaf__)) getloadavg)(double *__loadavg ,
                                                                   int __nelem )  __attribute__((__nothrow__)) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) realpath___15)(char const   *__name , char *__resolved )  __attribute__((__nothrow__)) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) realpath___15)(char const   *__name , char *__resolved )
{
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;

  {
#line 39
  tmp___1 = __builtin_object_size((void *)__resolved, 1);
#line 39
  if (tmp___1 != 18446744073709551615UL) {
#line 45
    tmp = __builtin_object_size((void *)__resolved, 1);
#line 45
    tmp___0 = __realpath_chk((char const   * __restrict  )__name, (char * __restrict  )__resolved,
                             tmp);
#line 45
    return (tmp___0);
  }
#line 48
  tmp___2 = __realpath_alias((char const   * __restrict  )__name, (char * __restrict  )__resolved);
#line 48
  return (tmp___2);
}
}
#line 43 "/usr/include/string.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memcpy)(void *__dest , void const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 47
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 54
extern void *( __attribute__((__nonnull__(1,2), __leaf__)) memccpy)(void *__dest ,
                                                                    void const   *__src ,
                                                                    int __c , size_t __n )  __attribute__((__nothrow__)) ;
#line 61
__inline extern void *( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) memset)(void *__dest , int __ch , size_t __len )  __attribute__((__nothrow__)) ;
#line 122
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcpy)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 125
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncpy)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 130
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcat)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 133
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncat)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 156
extern int ( __attribute__((__nonnull__(1,2,3), __leaf__)) strcoll_l)(char const   *__s1 ,
                                                                      char const   *__s2 ,
                                                                      locale_t __l )  __attribute__((__pure__,
__nothrow__)) ;
#line 160
extern size_t ( __attribute__((__nonnull__(2,4), __leaf__)) strxfrm_l)(char *__dest ,
                                                                       char const   *__src ,
                                                                       size_t __n ,
                                                                       locale_t __l )  __attribute__((__nothrow__)) ;
#line 167
extern char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__nothrow__,
__malloc__)) ;
#line 175
extern char *( __attribute__((__nonnull__(1), __leaf__)) strndup)(char const   *__string ,
                                                                  size_t __n )  __attribute__((__nothrow__,
__malloc__)) ;
#line 391
extern size_t ( __attribute__((__nonnull__(1), __leaf__)) strnlen)(char const   *__string ,
                                                                   size_t __maxlen )  __attribute__((__pure__,
__nothrow__)) ;
#line 410
extern int ( __attribute__((__nonnull__(2), __leaf__)) strerror_r)(int __errnum ,
                                                                   char *__buf , size_t __buflen )  __asm__("__xpg_strerror_r") __attribute__((__nothrow__)) ;
#line 428
extern char *( __attribute__((__leaf__)) strerror_l)(int __errnum , locale_t __l )  __attribute__((__nothrow__)) ;
#line 34 "/usr/include/strings.h"
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) bcmp)(void const   *__s1 ,
                                                               void const   *__s2 ,
                                                               size_t __n )  __attribute__((__pure__,
__nothrow__)) ;
#line 38
__inline extern void ( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) bcopy)(void const   *__src , void *__dest , size_t __len )  __attribute__((__nothrow__)) ;
#line 42
__inline extern void ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) bzero)(void *__dest , size_t __len )  __attribute__((__nothrow__)) ;
#line 68
extern char *( __attribute__((__nonnull__(1), __leaf__)) index)(char const   *__s ,
                                                                int __c )  __attribute__((__pure__,
__nothrow__)) ;
#line 96
extern char *( __attribute__((__nonnull__(1), __leaf__)) rindex)(char const   *__s ,
                                                                 int __c )  __attribute__((__pure__,
__nothrow__)) ;
#line 104
extern int ( __attribute__((__leaf__)) ffs)(int __i )  __attribute__((__nothrow__,
__const__)) ;
#line 110
extern int ( __attribute__((__leaf__)) ffsl)(long __l )  __attribute__((__nothrow__,
__const__)) ;
#line 111
extern int ( __attribute__((__leaf__)) ffsll)(long long __ll )  __attribute__((__nothrow__,
__const__)) ;
#line 116
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                     char const   *__s2 )  __attribute__((__pure__,
__nothrow__)) ;
#line 120
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                      char const   *__s2 ,
                                                                      size_t __n )  __attribute__((__pure__,
__nothrow__)) ;
#line 128
extern int ( __attribute__((__nonnull__(1,2,3), __leaf__)) strcasecmp_l)(char const   *__s1 ,
                                                                         char const   *__s2 ,
                                                                         locale_t __loc )  __attribute__((__pure__,
__nothrow__)) ;
#line 133
extern int ( __attribute__((__nonnull__(1,2,4), __leaf__)) strncasecmp_l)(char const   *__s1 ,
                                                                          char const   *__s2 ,
                                                                          size_t __n ,
                                                                          locale_t __loc )  __attribute__((__pure__,
__nothrow__)) ;
#line 22 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void ( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) bcopy)(void const   *__src , void *__dest , size_t __len )  __attribute__((__nothrow__)) ;
#line 22 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void ( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) bcopy)(void const   *__src , void *__dest , size_t __len )
{
  unsigned long tmp ;

  {
#line 25
  tmp = __builtin_object_size(__dest, 0);
#line 25
  __builtin___memmove_chk(__dest, __src, __len, tmp);
#line 26
  return;
}
}
#line 28
__inline extern void ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) bzero)(void *__dest , size_t __len )  __attribute__((__nothrow__)) ;
#line 28 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) bzero)(void *__dest , size_t __len )
{
  unsigned long tmp ;

  {
#line 31
  tmp = __builtin_object_size(__dest, 0);
#line 31
  __builtin___memset_chk(__dest, '\000', __len, tmp);
#line 32
  return;
}
}
#line 436 "/usr/include/string.h"
__inline extern void ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) explicit_bzero)(void *__dest , size_t __len )  __attribute__((__nothrow__)) ;
#line 440
extern char *( __attribute__((__nonnull__(1,2), __leaf__)) strsep)(char **__stringp ,
                                                                   char const   *__delim )  __attribute__((__nothrow__)) ;
#line 447
extern char *( __attribute__((__leaf__)) strsignal)(int __sig )  __attribute__((__nothrow__)) ;
#line 450
extern char *( __attribute__((__nonnull__(1,2), __leaf__)) __stpcpy)(char *__dest ,
                                                                     char const   *__src )  __attribute__((__nothrow__)) ;
#line 452
extern char *( __attribute__((__nonnull__(1,2), __leaf__)) stpcpy)(char *__dest ,
                                                                   char const   *__src )  __attribute__((__nothrow__)) ;
#line 457
extern char *( __attribute__((__nonnull__(1,2), __leaf__)) __stpncpy)(char *__dest ,
                                                                      char const   *__src ,
                                                                      size_t __n )  __attribute__((__nothrow__)) ;
#line 460
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) stpncpy___15)(char *__dest , char const   *__src ,
                                                  size_t __n )  __attribute__((__nothrow__)) ;
#line 77 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
extern void ( __attribute__((__nonnull__(1), __leaf__)) __explicit_bzero_chk)(void *__dest ,
                                                                              size_t __len ,
                                                                              size_t __destlen )  __attribute__((__nothrow__)) ;
#line 80
__inline extern void ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) explicit_bzero)(void *__dest , size_t __len )  __attribute__((__nothrow__)) ;
#line 80 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) explicit_bzero)(void *__dest , size_t __len )
{
  unsigned long tmp ;

  {
#line 83
  tmp = __builtin_object_size(__dest, 0);
#line 83
  __explicit_bzero_chk(__dest, __len, tmp);
#line 84
  return;
}
}
#line 115
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) stpncpy___15)(char *__dest , char const   *__src ,
                                                  size_t __n )  __attribute__((__nothrow__)) ;
#line 115 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) stpncpy___15)(char *__dest , char const   *__src ,
                                                  size_t __n )
{
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;

  {
#line 118
  tmp___1 = __builtin_object_size((void *)__dest, 1);
#line 118
  if (tmp___1 != 18446744073709551615UL) {
#line 118
    if (1) {
#line 120
      tmp = __builtin_object_size((void *)__dest, 1);
#line 120
      tmp___0 = __stpncpy_chk(__dest, __src, __n, tmp);
#line 120
      return (tmp___0);
    } else {
#line 118
      tmp___2 = __builtin_object_size((void *)__dest, 1);
#line 118
      if (__n > tmp___2) {
#line 120
        tmp = __builtin_object_size((void *)__dest, 1);
#line 120
        tmp___0 = __stpncpy_chk(__dest, __src, __n, tmp);
#line 120
        return (tmp___0);
      }
    }
  }
#line 121
  tmp___3 = __stpncpy_alias(__dest, __src, __n);
#line 121
  return (tmp___3);
}
}
#line 152 "/usr/include/stdio.h"
extern int ( __attribute__((__leaf__)) renameat)(int __oldfd , char const   *__old ,
                                                 int __newfd , char const   *__new )  __attribute__((__nothrow__)) ;
#line 192
extern char *( __attribute__((__warn_unused_result__, __leaf__)) tmpnam_r)(char *__s )  __attribute__((__nothrow__)) ;
#line 204
extern char *( __attribute__((__warn_unused_result__, __leaf__)) tempnam)(char const   *__dir ,
                                                                          char const   *__pfx )  __attribute__((__nothrow__,
__malloc__)) ;
#line 227
extern int fflush_unlocked(FILE *__stream ) ;
#line 292
extern FILE *( __attribute__((__warn_unused_result__, __leaf__)) fmemopen)(void *__s ,
                                                                           size_t __len ,
                                                                           char const   *__modes )  __attribute__((__nothrow__)) ;
#line 298
extern FILE *( __attribute__((__warn_unused_result__, __leaf__)) open_memstream)(char **__bufloc ,
                                                                                 size_t *__sizeloc )  __attribute__((__nothrow__)) ;
#line 314
extern void ( __attribute__((__leaf__)) setbuffer)(FILE *__stream , char *__buf ,
                                                   size_t __size )  __attribute__((__nothrow__)) ;
#line 318
extern void ( __attribute__((__leaf__)) setlinebuf)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 326
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) fprintf)(FILE *__stream ,
                                                                                                  char const   *__fmt
                                                                                                  , ...) ;
#line 332
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) printf)(char const   *__fmt
                                                                                                 , ...) ;
#line 334
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) sprintf)(char *__s ,
                                                                                                            char const   *__fmt
                                                                                                            , ...)  __attribute__((__nothrow__)) ;
#line 341
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vfprintf)(FILE *__stream ,
                                                                                                   char const   *__fmt ,
                                                                                                   __gnuc_va_list __ap ) ;
#line 347
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vprintf)(char const   *__fmt ,
                                                                                                  __gnuc_va_list __ap ) ;
#line 349
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vsprintf)(char *__s ,
                                                                                                             char const   *__fmt ,
                                                                                                             __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 354
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) snprintf)(char *__s , size_t __n , char const   *__fmt
                                              , ...)  __attribute__((__nothrow__)) ;
#line 358
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) vsnprintf)(char *__s , size_t __n , char const   *__fmt ,
                                               __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 379
__inline extern int ( /* format attribute */ __attribute__((__gnu_inline__, __artificial__,
__always_inline__)) vdprintf)(int __fd , char const   *__fmt , __gnuc_va_list __ap ) ;
#line 382
__inline extern int ( /* format attribute */ __attribute__((__gnu_inline__, __artificial__,
__always_inline__)) dprintf)(int __fd , char const   *__fmt  , ...) ;
#line 492
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
#line 499
__inline extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
#line 500
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
#line 510
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
#line 528
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
#line 537
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) ;
#line 545
__inline extern int ( __attribute__((__gnu_inline__)) putc_unlocked)(int __c , FILE *__stream ) ;
#line 546
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
#line 553
extern int getw(FILE *__stream ) ;
#line 556
extern int putw(int __w , FILE *__stream ) ;
#line 564
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fgets)(char *__s , int __n , FILE *__stream ) ;
#line 603
extern __ssize_t ( __attribute__((__warn_unused_result__)) __getdelim)(char **__lineptr ,
                                                                       size_t *__n ,
                                                                       int __delimiter ,
                                                                       FILE *__stream ) ;
#line 606
extern __ssize_t ( __attribute__((__warn_unused_result__)) getdelim)(char **__lineptr ,
                                                                     size_t *__n ,
                                                                     int __delimiter ,
                                                                     FILE *__stream ) ;
#line 616
extern __ssize_t ( __attribute__((__warn_unused_result__)) getline)(char **__lineptr ,
                                                                    size_t *__n ,
                                                                    FILE *__stream ) ;
#line 646
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fread)(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 673
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fread_unlocked)(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 675
extern size_t fwrite_unlocked(void const   *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 707
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
#line 712
extern __off_t ( __attribute__((__warn_unused_result__)) ftello)(FILE *__stream ) ;
#line 765
extern void ( __attribute__((__leaf__)) clearerr_unlocked)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 766
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__)) feof_unlocked)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 767
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__)) ferror_unlocked)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h"
extern int sys_nerr ;
#line 27
extern char const   *sys_errlist[] ;
#line 791 "/usr/include/stdio.h"
extern int ( __attribute__((__warn_unused_result__, __leaf__)) fileno_unlocked)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 800
extern FILE *( __attribute__((__warn_unused_result__)) popen)(char const   *__command ,
                                                              char const   *__modes ) ;
#line 806
extern int pclose(FILE *__stream ) ;
#line 840
extern void ( __attribute__((__leaf__)) flockfile)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 844
extern int ( __attribute__((__warn_unused_result__, __leaf__)) ftrylockfile)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 847
extern void ( __attribute__((__leaf__)) funlockfile)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 127 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__)) feof_unlocked)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 127 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__)) feof_unlocked)(FILE *__stream )
{


  {
#line 130
  return ((__stream->_flags & 0x0010) != 0);
}
}
#line 134
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__)) ferror_unlocked)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 134 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__)) ferror_unlocked)(FILE *__stream )
{


  {
#line 137
  return ((__stream->_flags & 0x0020) != 0);
}
}
#line 134 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
extern int ( /* format attribute */  __dprintf_chk)(int __fd , int __flag , char const   *__fmt
                                                    , ...) ;
#line 136
extern int ( /* format attribute */  __vdprintf_chk)(int __fd , int __flag , char const   *__fmt ,
                                                     __gnuc_va_list __arg ) ;
#line 141 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__gnu_inline__, __artificial__,
__always_inline__)) dprintf)(int __fd , char const   *__fmt  , ...)
{
  int tmp ;

  {
#line 144
  tmp = __dprintf_chk(__fd, 1, (char const   * __restrict  )__fmt, __builtin_va_arg_pack());
#line 144
  return (tmp);
}
}
#line 152 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__gnu_inline__, __artificial__,
__always_inline__)) vdprintf)(int __fd , char const   *__fmt , __gnuc_va_list __ap )
{
  int tmp ;

  {
#line 155
  tmp = __vdprintf_chk(__fd, 1, (char const   * __restrict  )__fmt, __ap);
#line 155
  return (tmp);
}
}
#line 329
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_chk)(void *__ptr ,
                                                                              size_t __ptrlen ,
                                                                              size_t __size ,
                                                                              size_t __n ,
                                                                              FILE *__stream ) ;
#line 332
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_alias)(void *__ptr ,
                                                                                size_t __size ,
                                                                                size_t __n ,
                                                                                FILE *__stream )  __asm__("fread_unlocked")  ;
#line 336
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_chk_warn)(void *__ptr ,
                                                                                   size_t __ptrlen ,
                                                                                   size_t __size ,
                                                                                   size_t __n ,
                                                                                   FILE *__stream )  __asm__("__fread_unlocked_chk") __attribute__((__warning__("fread_unlocked called with bigger size * nmemb than length of destination buffer"))) ;
#line 344 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fread_unlocked)(void *__ptr , size_t __size , size_t __n , FILE *__stream )
{
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t __cnt ;
  char *__cptr ;
  int __c ;
  int tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;

  {
#line 348
  tmp___4 = __builtin_object_size(__ptr, 0);
#line 348
  if (tmp___4 != 18446744073709551615UL) {
#line 350
    if (1) {
#line 353
      tmp = __builtin_object_size(__ptr, 0);
#line 353
      tmp___0 = __fread_unlocked_chk((void * __restrict  )__ptr, tmp, __size, __n,
                                     (FILE * __restrict  )__stream);
#line 353
      return (tmp___0);
    } else
#line 350
    if (1) {
#line 353
      tmp = __builtin_object_size(__ptr, 0);
#line 353
      tmp___0 = __fread_unlocked_chk((void * __restrict  )__ptr, tmp, __size, __n,
                                     (FILE * __restrict  )__stream);
#line 353
      return (tmp___0);
    } else
#line 350
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
#line 353
      tmp = __builtin_object_size(__ptr, 0);
#line 353
      tmp___0 = __fread_unlocked_chk((void * __restrict  )__ptr, tmp, __size, __n,
                                     (FILE * __restrict  )__stream);
#line 353
      return (tmp___0);
    }
#line 356
    tmp___3 = __builtin_object_size(__ptr, 0);
#line 356
    if (__size * __n > tmp___3) {
#line 357
      tmp___1 = __builtin_object_size(__ptr, 0);
#line 357
      tmp___2 = __fread_unlocked_chk_warn((void * __restrict  )__ptr, tmp___1, __size,
                                          __n, (FILE * __restrict  )__stream);
#line 357
      return (tmp___2);
    }
  }
#line 362
  if (0) {
#line 362
    if (0) {
#line 362
      if ((__size | __n) < 1UL << (8UL * sizeof(size_t )) / 2UL) {
#line 362
        if (__size * __n <= 8UL) {
#line 367
          __cnt = __size * __n;
#line 368
          __cptr = (char *)__ptr;
#line 369
          if (__cnt == 0UL) {
#line 370
            return ((size_t )0);
          }
          {
#line 372
          while (1) {
            while_continue: /* CIL Label */ ;
#line 372
            if (! (__cnt > 0UL)) {
#line 372
              goto while_break;
            }
#line 374
            tmp___5 = getc_unlocked(__stream);
#line 374
            __c = tmp___5;
#line 375
            if (__c == -1) {
#line 376
              goto while_break;
            }
#line 377
            tmp___6 = __cptr;
#line 377
            __cptr ++;
#line 377
            *tmp___6 = (char )__c;
#line 372
            __cnt --;
          }
          while_break: /* CIL Label */ ;
          }
#line 379
          return ((size_t )(__cptr - (char *)__ptr) / __size);
        }
      }
    }
  }
#line 382
  tmp___7 = __fread_unlocked_alias((void * __restrict  )__ptr, __size, __n, (FILE * __restrict  )__stream);
#line 382
  return (tmp___7);
}
}
#line 191 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngunknown.c"
static struct __anonstruct_chunk_info_47712822 chunk_info[22]  =
#line 191 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngunknown.c"
  {      {{(char )'I', (char )'D', (char )'A', (char )'T', (char )'\000'}, 0x8000U, (((73U << 8) + 68U) << 16) + ((65U << 8) + 84U),
      0, 0, 1, 0},
        {{(char )'P', (char )'L', (char )'T', (char )'E', (char )'\000'}, 0x0008U, (((80U << 8) + 76U) << 16) + ((84U << 8) + 69U),
      0, 0, 0, 0},
        {{(char )'b', (char )'K', (char )'G', (char )'D', (char )'\000'}, 0x0020U, (((98U << 8) + 75U) << 16) + ((71U << 8) + 68U),
      0, 1, 1, 0},
        {{(char )'c', (char )'H', (char )'R', (char )'M', (char )'\000'}, 0x0004U, (((99U << 8) + 72U) << 16) + ((82U << 8) + 77U),
      0, 1, 1, 0},
        {{(char )'e', (char )'X', (char )'I', (char )'f', (char )'\000'}, 0x10000U, (((101U << 8) + 88U) << 16) + ((73U << 8) + 102U),
      0, 1, 2, 0},
        {{(char )'g', (char )'A', (char )'M', (char )'A', (char )'\000'}, 0x0001U, (((103U << 8) + 65U) << 16) + ((77U << 8) + 65U),
      0, 1, 1, 0},
        {{(char )'h', (char )'I', (char )'S', (char )'T', (char )'\000'}, 0x0040U, (((104U << 8) + 73U) << 16) + ((83U << 8) + 84U),
      0, 1, 0, 0},
        {{(char )'i', (char )'C', (char )'C', (char )'P', (char )'\000'}, 0x1000U, (((105U << 8) + 67U) << 16) + ((67U << 8) + 80U),
      0, 1, 0, 0},
        {{(char )'i', (char )'T', (char )'X', (char )'t', (char )'\000'}, 0x20000000U,
      (((105U << 8) + 84U) << 16) + ((88U << 8) + 116U), 0, 1, 0, 0},
        {{(char )'o', (char )'F', (char )'F', (char )'s', (char )'\000'}, 0x0100U, (((111U << 8) + 70U) << 16) + ((70U << 8) + 115U),
      0, 1, 1, 0},
        {{(char )'p', (char )'C', (char )'A', (char )'L', (char )'\000'}, 0x0400U, (((112U << 8) + 67U) << 16) + ((65U << 8) + 76U),
      0, 1, 1, 0},
        {{(char )'p', (char )'H', (char )'Y', (char )'s', (char )'\000'}, 0x0080U, (((112U << 8) + 72U) << 16) + ((89U << 8) + 115U),
      0, 1, 1, 0},
        {{(char )'s', (char )'B', (char )'I', (char )'T', (char )'\000'}, 0x0002U, (((115U << 8) + 66U) << 16) + ((73U << 8) + 84U),
      0, 1, 1, 0},
        {{(char )'s', (char )'C', (char )'A', (char )'L', (char )'\000'}, 0x4000U, (((115U << 8) + 67U) << 16) + ((65U << 8) + 76U),
      0, 1, 1, 0},
        {{(char )'s', (char )'P', (char )'L', (char )'T', (char )'\000'}, 0x2000U, (((115U << 8) + 80U) << 16) + ((76U << 8) + 84U),
      0, 1, 0, 0},
        {{(char )'s', (char )'R', (char )'G', (char )'B', (char )'\000'}, 0x0800U, (((115U << 8) + 82U) << 16) + ((71U << 8) + 66U),
      0, 1, 1, 0},
        {{(char )'t', (char )'E', (char )'X', (char )'t', (char )'\000'}, 0x10000000U,
      (((116U << 8) + 69U) << 16) + ((88U << 8) + 116U), 0, 1, 1, 0},
        {{(char )'t', (char )'I', (char )'M', (char )'E', (char )'\000'}, 0x0200U, (((116U << 8) + 73U) << 16) + ((77U << 8) + 69U),
      0, 1, 1, 0},
        {{(char )'t', (char )'R', (char )'N', (char )'S', (char )'\000'}, 0x0010U, (((116U << 8) + 82U) << 16) + ((78U << 8) + 83U),
      0, 0, 0, 0},
        {{(char )'z', (char )'T', (char )'X', (char )'t', (char )'\000'}, 0x40000000U,
      (((122U << 8) + 84U) << 16) + ((88U << 8) + 116U), 0, 1, 2, 0},
        {{(char )'s', (char )'T', (char )'E', (char )'R', (char )'\000'}, 0x01000000U,
      (((115U << 8) + 84U) << 16) + ((69U << 8) + 82U), 1, 1, 1, 0},
        {{(char )'v', (char )'p', (char )'A', (char )'g', (char )'\000'}, 0x02000000U,
      (((118U << 8) + 112U) << 16) + ((65U << 8) + 103U), 1, 0, 1, 0}};
#line 334 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngunknown.c"
static void clear_keep(void)
{
  int i ;

  {
#line 337
  i = (int )(sizeof(chunk_info) / sizeof(chunk_info[0]));
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    i --;
#line 338
    if (! (i >= 0)) {
#line 338
      goto while_break;
    }
#line 339
    chunk_info[i].keep = 0;
  }
  while_break: /* CIL Label */ ;
  }
#line 340
  return;
}
}
#line 342 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngunknown.c"
static int find(char const   *name )
{
  int i ;
  int tmp ;

  {
#line 345
  i = (int )(sizeof(chunk_info) / sizeof(chunk_info[0]));
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    i --;
#line 346
    if (! (i >= 0)) {
#line 346
      goto while_break;
    }
#line 348
    tmp = memcmp((void const   *)(chunk_info[i].name), (void const   *)name, (size_t )4);
#line 348
    if (tmp == 0) {
#line 349
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 352
  return (i);
}
}
#line 355 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngunknown.c"
static int findb(png_byte const   *name )
{
  int i ;
  int tmp ;

  {
#line 358
  i = (int )(sizeof(chunk_info) / sizeof(chunk_info[0]));
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
#line 359
    i --;
#line 359
    if (! (i >= 0)) {
#line 359
      goto while_break;
    }
#line 361
    tmp = memcmp((void const   *)(chunk_info[i].name), (void const   *)name, (size_t )4);
#line 361
    if (tmp == 0) {
#line 362
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 365
  return (i);
}
}
#line 368 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngunknown.c"
static int find_by_flag(png_uint_32 flag )
{
  int i ;

  {
#line 371
  i = (int )(sizeof(chunk_info) / sizeof(chunk_info[0]));
  {
#line 373
  while (1) {
    while_continue: /* CIL Label */ ;
#line 373
    i --;
#line 373
    if (! (i >= 0)) {
#line 373
      goto while_break;
    }
#line 374
    if (chunk_info[i].flag == flag) {
#line 375
      return (i);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 377
  fprintf(stderr, (char const   *)"pngunknown: internal error\n");
#line 378
  exit(4);
}
}
#line 381 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngunknown.c"
static int ancillary(char const   *name )
{


  {
#line 384
  return ((int )(1U & ((((((unsigned int )*(name + 0) << 8) + (unsigned int )*(name + 1)) << 16) + (((unsigned int )*(name + 2) << 8) + (unsigned int )*(name + 3))) >> 29)));
}
}
#line 388 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngunknown.c"
static int ancillaryb(png_byte const   *name )
{


  {
#line 391
  return ((int )(1U & ((((((unsigned int )*(name + 0) << 8) + (unsigned int )*(name + 1)) << 16) + (((unsigned int )*(name + 2) << 8) + (unsigned int )*(name + 3))) >> 29)));
}
}
#line 411 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngunknown.c"
static char const   init[15]  =
#line 411
  {      (char const   )'i',      (char const   )'n',      (char const   )'i',      (char const   )'t',
        (char const   )'i',      (char const   )'a',      (char const   )'l',      (char const   )'i',
        (char const   )'z',      (char const   )'a',      (char const   )'t',      (char const   )'i',
        (char const   )'o',      (char const   )'n',      (char const   )'\000'};
#line 412 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngunknown.c"
static char const   cmd[13]  =
#line 412
  {      (char const   )'c',      (char const   )'o',      (char const   )'m',      (char const   )'m',
        (char const   )'a',      (char const   )'n',      (char const   )'d',      (char const   )' ',
        (char const   )'l',      (char const   )'i',      (char const   )'n',      (char const   )'e',
        (char const   )'\000'};
#line 414 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngunknown.c"
static void init_display(display *d , char const   *program )
{
  png_infop tmp ;
  int tmp___0 ;

  {
#line 417
  memset((void *)d, 0, sizeof(*d));
#line 418
  d->png_ptr = (png_structp )((void *)0);
#line 419
  tmp = (png_infop )((void *)0);
#line 419
  d->end_ptr = tmp;
#line 419
  d->info_ptr = tmp;
#line 420
  tmp___0 = 0;
#line 420
  d->warning_count = tmp___0;
#line 420
  d->error_count = tmp___0;
#line 421
  d->program = program;
#line 422
  d->file = program;
#line 423
  d->test = init;
#line 424
  return;
}
}
#line 426 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngunknown.c"
static void clean_display(display *d )
{


  {
#line 429
  png_destroy_read_struct(& d->png_ptr, & d->info_ptr, & d->end_ptr);
#line 432
  if ((unsigned long )d->png_ptr != (unsigned long )((void *)0)) {
#line 434
    fprintf(stderr, (char const   *)"%s(%s): png_destroy_read_struct error\n", d->file,
            d->test);
#line 436
    exit(1);
  } else
#line 432
  if ((unsigned long )d->info_ptr != (unsigned long )((void *)0)) {
#line 434
    fprintf(stderr, (char const   *)"%s(%s): png_destroy_read_struct error\n", d->file,
            d->test);
#line 436
    exit(1);
  } else
#line 432
  if ((unsigned long )d->end_ptr != (unsigned long )((void *)0)) {
#line 434
    fprintf(stderr, (char const   *)"%s(%s): png_destroy_read_struct error\n", d->file,
            d->test);
#line 436
    exit(1);
  }
#line 438
  return;
}
}
#line 440
static void display_exit(display *d )  __attribute__((__noreturn__)) ;
#line 440 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngunknown.c"
static void display_exit(display *d )
{


  {
#line 442
  (d->error_count) ++;
#line 444
  if ((unsigned long )d->png_ptr != (unsigned long )((void *)0)) {
#line 445
    clean_display(d);
  }
#line 450
  if ((unsigned long )d->test == (unsigned long )(init)) {
#line 451
    exit(1);
  } else
#line 450
  if ((unsigned long )d->test == (unsigned long )(cmd)) {
#line 451
    exit(1);
  }
#line 453
  longjmp((struct __jmp_buf_tag *)(d->error_return), 1);
}
}
#line 456 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngunknown.c"
static int display_rc(display const   *d , int strict___0 )
{
  int tmp ;

  {
#line 459
  if (strict___0) {
#line 459
    tmp = d->warning_count;
  } else {
#line 459
    tmp = (int )0;
  }
#line 459
  return ((int )(d->error_count + tmp));
}
}
#line 463
static void error(png_structp png_ptr , char const   *message )  __attribute__((__noreturn__)) ;
#line 463 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngunknown.c"
static void error(png_structp png_ptr , char const   *message )
{
  display *d ;
  png_voidp tmp ;

  {
#line 466
  tmp = png_get_error_ptr((png_const_structrp )png_ptr);
#line 466
  d = (display *)tmp;
#line 468
  fprintf(stderr, (char const   *)"%s(%s): libpng error: %s\n", d->file, d->test,
          message);
#line 469
  display_exit(d);
}
}
#line 472 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngunknown.c"
static void warning(png_structp png_ptr , char const   *message )
{
  display *d ;
  png_voidp tmp ;

  {
#line 475
  tmp = png_get_error_ptr((png_const_structrp )png_ptr);
#line 475
  d = (display *)tmp;
#line 477
  fprintf(stderr, (char const   *)"%s(%s): libpng warning: %s\n", d->file, d->test,
          message);
#line 478
  (d->warning_count) ++;
#line 479
  return;
}
}
#line 481 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngunknown.c"
static png_uint_32 get_valid(display *d , png_infop info_ptr )
{
  png_uint_32 flags ;
  png_uint_32 tmp ;
  png_textp text ;
  png_uint_32 ntext ;
  int tmp___0 ;

  {
#line 484
  tmp = png_get_valid((png_const_structrp )d->png_ptr, (png_const_inforp )info_ptr,
                      (png_uint_32 )(~ 0));
#line 484
  flags = tmp;
#line 489
  tmp___0 = png_get_text((png_const_structrp )d->png_ptr, (png_inforp )info_ptr, & text,
                         (int *)((void *)0));
#line 489
  ntext = (png_uint_32 )tmp___0;
  {
#line 491
  while (1) {
    while_continue: /* CIL Label */ ;
#line 491
    if (! (ntext > 0U)) {
#line 491
      goto while_break;
    }
#line 491
    ntext --;
    {
#line 493
    if ((text + ntext)->compression == -1) {
#line 493
      goto case_neg_1;
    }
#line 496
    if ((text + ntext)->compression == 0) {
#line 496
      goto case_0;
    }
#line 500
    if ((text + ntext)->compression == 2) {
#line 500
      goto case_2;
    }
#line 500
    if ((text + ntext)->compression == 1) {
#line 500
      goto case_2;
    }
#line 503
    goto switch_default;
    case_neg_1: /* CIL Label */
#line 494
    flags |= 0x10000000U;
#line 495
    goto switch_break;
    case_0: /* CIL Label */
#line 497
    flags |= 0x40000000U;
#line 498
    goto switch_break;
    case_2: /* CIL Label */
    case_1: /* CIL Label */
#line 501
    flags |= 0x20000000U;
#line 502
    goto switch_break;
    switch_default: /* CIL Label */
#line 504
    fprintf(stderr, (char const   *)"%s(%s): unknown text compression %d\n", d->file,
            d->test, (text + ntext)->compression);
#line 506
    display_exit(d);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 510
  return (flags);
}
}
#line 514 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngunknown.c"
static int read_callback(png_structp pp , png_unknown_chunkp pc )
{
  display *d ;
  png_voidp tmp ;
  int chunk ;
  int tmp___0 ;
  int keep ;
  int discard ;
  png_uint_32 flag ;

  {
#line 520
  tmp = png_get_user_chunk_ptr((png_const_structrp )pp);
#line 520
  d = (display *)tmp;
#line 521
  tmp___0 = findb((png_byte const   *)(pc->name));
#line 521
  chunk = tmp___0;
#line 524
  if (chunk < 0) {
#line 525
    keep = d->keep;
  } else {
#line 529
    keep = chunk_info[chunk].keep;
#line 530
    if (keep == 0) {
#line 535
      if (chunk_info[chunk].unknown) {
#line 536
        keep = d->keep;
      } else {
#line 539
        keep = 1;
      }
    }
  }
  {
#line 551
  if (keep == 1) {
#line 551
    goto case_1;
  }
#line 551
  if (keep == 0) {
#line 551
    goto case_1;
  }
#line 556
  if (keep == 3) {
#line 556
    goto case_3;
  }
#line 556
  if (keep == 2) {
#line 556
    goto case_3;
  }
#line 545
  goto switch_default;
  switch_default: /* CIL Label */
#line 546
  fprintf(stderr, (char const   *)"%s(%s): %d: unrecognized chunk option\n", d->file,
          d->test, chunk_info[chunk].keep);
#line 548
  display_exit(d);
  case_1: /* CIL Label */
  case_0: /* CIL Label */
#line 552
  discard = 1;
#line 553
  goto switch_break;
  case_3: /* CIL Label */
  case_2: /* CIL Label */
#line 557
  discard = 0;
#line 558
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 564
  if (chunk >= 0) {
#line 566
    if (! discard) {
#line 568
      flag = chunk_info[chunk].flag;
#line 570
      if ((int )pc->location & 0x08) {
#line 571
        d->after_IDAT |= flag;
      } else {
#line 574
        d->before_IDAT |= flag;
      }
    }
  }
#line 582
  return (discard);
}
}
#line 590 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngunknown.c"
static png_uint_32 get_unknown(display *d , png_infop info_ptr , int after_IDAT )
{
  png_uint_32 flags ;
  png_unknown_chunkp unknown ;
  int num_unknown ;
  int tmp ;
  int chunk ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 594
  flags = (png_uint_32 )0;
#line 600
  tmp = png_get_unknown_chunks((png_const_structrp )d->png_ptr, (png_inforp )info_ptr,
                               & unknown);
#line 600
  num_unknown = tmp;
  {
#line 602
  while (1) {
    while_continue: /* CIL Label */ ;
#line 602
    num_unknown --;
#line 602
    if (! (num_unknown >= 0)) {
#line 602
      goto while_break;
    }
#line 604
    tmp___0 = findb((png_byte const   *)((unknown + num_unknown)->name));
#line 604
    chunk = tmp___0;
#line 610
    if (chunk < 0) {
      {
#line 621
      if (d->keep == 2) {
#line 621
        goto case_2;
      }
#line 631
      if (d->keep == 3) {
#line 631
        goto case_3;
      }
#line 612
      goto case_1;
      case_1: /* CIL Label */
      case_0: /* CIL Label */
      switch_default: /* CIL Label */
#line 615
      if (d->keep) {
#line 615
        tmp___1 = "discard";
      } else {
#line 615
        tmp___1 = "default";
      }
#line 615
      fprintf(stderr, (char const   *)"%s(%s): %s: %s: unknown chunk saved\n", d->file,
              d->test, tmp___1, (unknown + num_unknown)->name);
#line 618
      (d->error_count) ++;
#line 619
      goto switch_break;
      case_2: /* CIL Label */
#line 622
      tmp___2 = ancillaryb((png_byte const   *)((unknown + num_unknown)->name));
#line 622
      if (! tmp___2) {
#line 624
        fprintf(stderr, (char const   *)"%s(%s): if-safe: %s: unknown critical chunk saved\n",
                d->file, d->test, (unknown + num_unknown)->name);
#line 627
        (d->error_count) ++;
#line 628
        goto switch_break;
      }
      case_3: /* CIL Label */
#line 632
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 636
      flags |= chunk_info[chunk].flag;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 640
  return (flags);
}
}
#line 664 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngunknown.c"
static int check(FILE *fp , int argc , char const   **argv , png_uint_32p flags ,
                 display *d , int set_callback )
{
  int i ;
  int npasses ;
  int ipass ;
  png_uint_32 height ;
  png_structp __attribute__((__malloc__))  tmp ;
  png_infop __attribute__((__malloc__))  tmp___0 ;
  png_infop __attribute__((__malloc__))  tmp___1 ;
  char const   *equals ;
  char *tmp___2 ;
  int chunk ;
  int option ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  png_byte name[5] ;
  int tmp___7 ;
  int tmp___8 ;
  png_byte tmp___9 ;
  png_uint_32 width ;
  png_uint_32 tmp___10 ;
  png_uint_32 wPass ;
  int tmp___11 ;
  int tmp___12 ;
  png_uint_32 y ;
  png_uint_32 y___0 ;

  {
#line 671
  d->keep = 0;
#line 672
  d->before_IDAT = (png_uint_32 )0;
#line 673
  d->after_IDAT = (png_uint_32 )0;
#line 678
  tmp = png_create_read_struct((png_const_charp )"1.6.39", (png_voidp )d, & error,
                               & warning);
#line 678
  d->png_ptr = (png_structp )tmp;
#line 680
  if ((unsigned long )d->png_ptr == (unsigned long )((void *)0)) {
#line 682
    fprintf(stderr, (char const   *)"%s(%s): could not allocate png struct\n", d->file,
            d->test);
#line 685
    exit(1);
  }
#line 688
  tmp___0 = png_create_info_struct((png_const_structrp )d->png_ptr);
#line 688
  d->info_ptr = (png_infop )tmp___0;
#line 689
  tmp___1 = png_create_info_struct((png_const_structrp )d->png_ptr);
#line 689
  d->end_ptr = (png_infop )tmp___1;
#line 690
  if ((unsigned long )d->info_ptr == (unsigned long )((void *)0)) {
#line 692
    fprintf(stderr, (char const   *)"%s(%s): could not allocate png info\n", d->file,
            d->test);
#line 694
    clean_display(d);
#line 695
    exit(1);
  } else
#line 690
  if ((unsigned long )d->end_ptr == (unsigned long )((void *)0)) {
#line 692
    fprintf(stderr, (char const   *)"%s(%s): could not allocate png info\n", d->file,
            d->test);
#line 694
    clean_display(d);
#line 695
    exit(1);
  }
#line 698
  png_init_io((png_structrp )d->png_ptr, fp);
#line 704
  if (set_callback) {
#line 705
    png_set_read_user_chunk_fn((png_structrp )d->png_ptr, (png_voidp )d, & read_callback);
  }
#line 714
  i = 0;
  {
#line 714
  while (1) {
    while_continue: /* CIL Label */ ;
#line 714
    if (! (i < argc)) {
#line 714
      goto while_break;
    }
#line 716
    tmp___2 = strchr(*(argv + i), '=');
#line 716
    equals = (char const   *)tmp___2;
#line 718
    if ((unsigned long )equals != (unsigned long )((void *)0)) {
#line 722
      tmp___6 = strcmp(equals + 1, (char const   *)"default");
#line 722
      if (tmp___6 == 0) {
#line 723
        option = 0;
      } else {
#line 724
        tmp___5 = strcmp(equals + 1, (char const   *)"discard");
#line 724
        if (tmp___5 == 0) {
#line 725
          option = 1;
        } else {
#line 726
          tmp___4 = strcmp(equals + 1, (char const   *)"if-safe");
#line 726
          if (tmp___4 == 0) {
#line 727
            option = 2;
          } else {
#line 728
            tmp___3 = strcmp(equals + 1, (char const   *)"save");
#line 728
            if (tmp___3 == 0) {
#line 729
              option = 3;
            } else {
#line 732
              fprintf(stderr, (char const   *)"%s(%s): %s: unrecognized chunk option\n",
                      d->file, d->test, *(argv + i));
#line 734
              display_exit(d);
            }
          }
        }
      }
      {
#line 739
      if (equals - *(argv + i) == 4L) {
#line 739
        goto case_4;
      }
#line 765
      if (equals - *(argv + i) == 7L) {
#line 765
        goto case_7;
      }
#line 780
      if (equals - *(argv + i) == 3L) {
#line 780
        goto case_3;
      }
#line 799
      goto switch_default;
      case_4: /* CIL Label */
#line 740
      chunk = find(*(argv + i));
#line 742
      if (chunk >= 0) {
#line 756
        memcpy((void *)(name), (void const   *)(chunk_info[chunk].name), (size_t )5);
#line 757
        png_set_keep_unknown_chunks((png_structrp )d->png_ptr, option, (png_const_bytep )(name),
                                    1);
#line 758
        chunk_info[chunk].keep = option;
#line 760
        goto __Cont;
      }
#line 763
      goto switch_break;
      case_7: /* CIL Label */
#line 766
      tmp___7 = memcmp((void const   *)*(argv + i), (void const   *)"default", (size_t )7);
#line 766
      if (tmp___7 == 0) {
#line 772
        png_set_keep_unknown_chunks((png_structrp )d->png_ptr, option, (png_const_bytep )((void *)0),
                                    0);
#line 774
        d->keep = option;
#line 775
        goto __Cont;
      }
#line 778
      goto switch_break;
      case_3: /* CIL Label */
#line 781
      tmp___8 = memcmp((void const   *)*(argv + i), (void const   *)"all", (size_t )3);
#line 781
      if (tmp___8 == 0) {
#line 787
        png_set_keep_unknown_chunks((png_structrp )d->png_ptr, option, (png_const_bytep )((void *)0),
                                    -1);
#line 789
        d->keep = option;
#line 791
        chunk = 0;
        {
#line 791
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 791
          if (! (chunk < (int )(sizeof(chunk_info) / sizeof(chunk_info[0])))) {
#line 791
            goto while_break___0;
          }
#line 792
          if (chunk_info[chunk].all) {
#line 793
            chunk_info[chunk].keep = option;
          }
#line 791
          chunk ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 794
        goto __Cont;
      }
#line 797
      goto switch_break;
      switch_default: /* CIL Label */
#line 801
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 805
    fprintf(stderr, (char const   *)"%s(%s): %s: unrecognized chunk argument\n", d->file,
            d->test, *(argv + i));
#line 807
    display_exit(d);
    __Cont: /* CIL Label */
#line 714
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 810
  png_read_info((png_structrp )d->png_ptr, (png_inforp )d->info_ptr);
#line 812
  tmp___9 = png_get_interlace_type((png_const_structrp )d->png_ptr, (png_const_inforp )d->info_ptr);
  {
#line 814
  if ((int )tmp___9 == 0) {
#line 814
    goto case_0;
  }
#line 818
  if ((int )tmp___9 == 1) {
#line 818
    goto case_1;
  }
#line 822
  goto switch_default___0;
  case_0: /* CIL Label */
#line 815
  npasses = 1;
#line 816
  goto switch_break___0;
  case_1: /* CIL Label */
#line 819
  npasses = 7;
#line 820
  goto switch_break___0;
  switch_default___0: /* CIL Label */
#line 824
  fprintf(stderr, (char const   *)"%s(%s): invalid interlace type\n", d->file, d->test);
#line 825
  clean_display(d);
#line 826
  exit(1);
  switch_break___0: /* CIL Label */ ;
  }
#line 832
  if (chunk_info[0].keep == 0) {
#line 834
    png_start_read_image((png_structrp )d->png_ptr);
#line 835
    height = png_get_image_height((png_const_structrp )d->png_ptr, (png_const_inforp )d->info_ptr);
#line 837
    if (npasses > 1) {
#line 839
      tmp___10 = png_get_image_width((png_const_structrp )d->png_ptr, (png_const_inforp )d->info_ptr);
#line 839
      width = tmp___10;
#line 841
      ipass = 0;
      {
#line 841
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 841
        if (! (ipass < npasses)) {
#line 841
          goto while_break___1;
        }
#line 843
        if (ipass > 1) {
#line 843
          tmp___11 = (7 - ipass) >> 1;
        } else {
#line 843
          tmp___11 = 3;
        }
#line 843
        if (ipass > 1) {
#line 843
          tmp___12 = (7 - ipass) >> 1;
        } else {
#line 843
          tmp___12 = 3;
        }
#line 843
        wPass = (width + (png_uint_32 )(((1 << tmp___11) - 1) - (((1 & ipass) << (3 - ((ipass + 1) >> 1))) & 7))) >> tmp___12;
#line 845
        if (wPass > 0U) {
#line 849
          y = (png_uint_32 )0;
          {
#line 849
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 849
            if (! (y < height)) {
#line 849
              goto while_break___2;
            }
#line 850
            if (((((0x110145AF >> ((7 - ipass) << 2)) & 0xF) | ((0x01145AF0 >> ((7 - ipass) << 2)) & 0xF0)) >> (y & 7U)) & 1) {
#line 851
              png_read_row((png_structrp )d->png_ptr, (png_bytep )((void *)0), (png_bytep )((void *)0));
            }
#line 849
            y ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 841
        ipass ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
#line 860
      y___0 = (png_uint_32 )0;
      {
#line 860
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 860
        if (! (y___0 < height)) {
#line 860
          goto while_break___3;
        }
#line 861
        png_read_row((png_structrp )d->png_ptr, (png_bytep )((void *)0), (png_bytep )((void *)0));
#line 860
        y___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
  }
#line 865
  png_read_end((png_structrp )d->png_ptr, (png_inforp )d->end_ptr);
#line 867
  *(flags + 0) = get_valid(d, d->info_ptr);
#line 868
  *(flags + 1) = get_unknown(d, d->info_ptr, 0);
#line 871
  *(flags + (chunk_info[0].keep != 0)) |= 0x8000U;
#line 874
  *(flags + 2) = get_valid(d, d->end_ptr);
#line 875
  *(flags + 3) = get_unknown(d, d->end_ptr, 1);
#line 877
  clean_display(d);
#line 879
  return (d->keep);
}
}
#line 882 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngunknown.c"
static void check_error(display *d , png_uint_32 flags , char const   *message )
{
  png_uint_32 flag ;
  int i ;
  int tmp ;

  {
  {
#line 885
  while (1) {
    while_continue: /* CIL Label */ ;
#line 885
    if (! flags) {
#line 885
      goto while_break;
    }
#line 887
    flag = flags & (unsigned int )(- ((png_int_32 )flags));
#line 888
    tmp = find_by_flag(flag);
#line 888
    i = tmp;
#line 890
    fprintf(stderr, (char const   *)"%s(%s): chunk %s: %s\n", d->file, d->test, chunk_info[i].name,
            message);
#line 892
    (d->error_count) ++;
#line 894
    flags &= ~ flag;
  }
  while_break: /* CIL Label */ ;
  }
#line 896
  return;
}
}
#line 898 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngunknown.c"
static void check_handling(display *d , int def , png_uint_32 chunks , png_uint_32 known ,
                           png_uint_32 unknown , char const   *position , int set_callback )
{
  png_uint_32 flag ;
  int i ;
  int tmp ;
  int keep ;
  char const   *type ;
  char const   *errorx ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 902
  while (1) {
    while_continue: /* CIL Label */ ;
#line 902
    if (! chunks) {
#line 902
      goto while_break;
    }
#line 904
    flag = chunks & (unsigned int )(- ((png_int_32 )chunks));
#line 905
    tmp = find_by_flag(flag);
#line 905
    i = tmp;
#line 906
    keep = chunk_info[i].keep;
#line 908
    errorx = (char const   *)((void *)0);
#line 910
    if (chunk_info[i].unknown) {
#line 912
      if (keep == 0) {
#line 914
        type = (char const   *)"UNKNOWN (default)";
#line 915
        keep = def;
      } else {
#line 919
        type = (char const   *)"UNKNOWN (specified)";
      }
#line 921
      if (flag & known) {
#line 922
        errorx = (char const   *)"chunk processed";
      } else {
        {
#line 926
        if (keep == 0) {
#line 926
          goto case_0;
        }
#line 931
        if (keep == 1) {
#line 931
          goto case_1;
        }
#line 936
        if (keep == 2) {
#line 936
          goto case_2;
        }
#line 947
        if (keep == 3) {
#line 947
          goto case_3;
        }
#line 952
        goto switch_default;
        case_0: /* CIL Label */
#line 927
        if (flag & unknown) {
#line 928
          errorx = (char const   *)"DEFAULT: unknown chunk saved";
        }
#line 929
        goto switch_break;
        case_1: /* CIL Label */
#line 932
        if (flag & unknown) {
#line 933
          errorx = (char const   *)"DISCARD: unknown chunk saved";
        }
#line 934
        goto switch_break;
        case_2: /* CIL Label */
#line 937
        tmp___0 = ancillary((char const   *)(chunk_info[i].name));
#line 937
        if (tmp___0) {
#line 939
          if (! (flag & unknown)) {
#line 940
            errorx = (char const   *)"IF-SAFE: unknown ancillary chunk lost";
          }
        } else
#line 943
        if (flag & unknown) {
#line 944
          errorx = (char const   *)"IF-SAFE: unknown critical chunk saved";
        }
#line 945
        goto switch_break;
        case_3: /* CIL Label */
#line 948
        if (! (flag & unknown)) {
#line 949
          errorx = (char const   *)"SAVE: unknown chunk lost";
        }
#line 950
        goto switch_break;
        switch_default: /* CIL Label */
#line 953
        errorx = (char const   *)"internal error: bad keep";
#line 954
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    } else {
#line 960
      type = (char const   *)"KNOWN";
#line 962
      if (flag & known) {
#line 967
        if (keep != 0) {
#line 968
          errorx = (char const   *)"!DEFAULT: known chunk processed";
        }
      } else {
        {
#line 973
        if (keep == 0) {
#line 973
          goto case_0___0;
        }
#line 977
        if (keep == 1) {
#line 977
          goto case_1___0;
        }
#line 982
        if (keep == 2) {
#line 982
          goto case_2___0;
        }
#line 993
        if (keep == 3) {
#line 993
          goto case_3___0;
        }
#line 998
        goto switch_default___0;
        case_0___0: /* CIL Label */
#line 974
        errorx = (char const   *)"DEFAULT: known chunk not processed";
#line 975
        goto switch_break___0;
        case_1___0: /* CIL Label */
#line 978
        if (flag & unknown) {
#line 979
          errorx = (char const   *)"DISCARD: known chunk saved";
        }
#line 980
        goto switch_break___0;
        case_2___0: /* CIL Label */
#line 983
        tmp___1 = ancillary((char const   *)(chunk_info[i].name));
#line 983
        if (tmp___1) {
#line 985
          if (! (flag & unknown)) {
#line 986
            errorx = (char const   *)"IF-SAFE: known ancillary chunk lost";
          }
        } else
#line 989
        if (flag & unknown) {
#line 990
          errorx = (char const   *)"IF-SAFE: known critical chunk saved";
        }
#line 991
        goto switch_break___0;
        case_3___0: /* CIL Label */
#line 994
        if (! (flag & unknown)) {
#line 995
          errorx = (char const   *)"SAVE: known chunk lost";
        }
#line 996
        goto switch_break___0;
        switch_default___0: /* CIL Label */
#line 999
        errorx = (char const   *)"internal error: bad keep (2)";
#line 1000
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
      }
    }
#line 1004
    if ((unsigned long )errorx != (unsigned long )((void *)0)) {
#line 1006
      (d->error_count) ++;
#line 1007
      if (set_callback) {
#line 1007
        tmp___2 = ",callback";
      } else {
#line 1007
        tmp___2 = "";
      }
#line 1007
      fprintf(stderr, (char const   *)"%s(%s%s): %s %s %s: %s\n", d->file, d->test,
              tmp___2, type, chunk_info[i].name, position, errorx);
    }
#line 1012
    chunks &= ~ flag;
  }
  while_break: /* CIL Label */ ;
  }
#line 1014
  return;
}
}
#line 1016 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngunknown.c"
static void perform_one_test(FILE *fp , int argc , char const   **argv , png_uint_32 *default_flags ,
                             display *d , int set_callback )
{
  int def ;
  png_uint_32 flags[2][4] ;
  png_uint_32 test ;

  {
#line 1023
  rewind(fp);
#line 1024
  clear_keep();
#line 1025
  memcpy((void *)(flags[0]), (void const   *)default_flags, sizeof(flags[0]));
#line 1027
  def = check(fp, argc, argv, flags[1], d, set_callback);
#line 1039
  if (chunk_info[0].keep != 0) {
#line 1039
    if ((flags[1][3] & 0x8000U) != 0U) {
#line 1041
      flags[0][2] |= 0x8000U;
    }
  }
#line 1048
  check_error(d, (flags[0][0] | flags[0][2]) & (flags[0][1] | flags[0][3]), (char const   *)"chunk handled inconsistently in count tests");
#line 1050
  check_error(d, (flags[1][0] | flags[1][2]) & (flags[1][1] | flags[1][3]), (char const   *)"chunk handled inconsistently in option tests");
#line 1061
  test = flags[1][0] & ~ flags[0][0];
#line 1062
  check_error(d, test, (char const   *)"new known chunk before IDAT");
#line 1063
  test = flags[1][1] & ~ (flags[0][0] | flags[0][1]);
#line 1064
  check_error(d, test, (char const   *)"new unknown chunk before IDAT");
#line 1065
  test = flags[1][2] & ~ flags[0][2];
#line 1066
  check_error(d, test, (char const   *)"new known chunk after IDAT");
#line 1067
  test = flags[1][3] & ~ (flags[0][2] | flags[0][3]);
#line 1068
  check_error(d, test, (char const   *)"new unknown chunk after IDAT");
#line 1075
  check_handling(d, def, flags[0][0] | flags[0][1], flags[1][0], flags[1][1], (char const   *)"before IDAT",
                 set_callback);
#line 1077
  check_handling(d, def, flags[0][2] | flags[0][3], flags[1][2], flags[1][3], (char const   *)"after IDAT",
                 set_callback);
#line 1079
  return;
}
}
#line 1081 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngunknown.c"
static void perform_one_test_safe(FILE *fp , int argc , char const   **argv , png_uint_32 *default_flags ,
                                  display *d , char const   *test )
{
  int tmp ;

  {
#line 1085
  tmp = _setjmp((struct __jmp_buf_tag *)(d->error_return));
#line 1085
  if (tmp == 0) {
#line 1087
    d->test = test;
#line 1089
    perform_one_test(fp, argc, argv, default_flags, d, 0);
#line 1092
    perform_one_test(fp, argc, argv, default_flags, d, 1);
#line 1094
    d->test = init;
  }
#line 1096
  return;
}
}
#line 1098 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngunknown.c"
static char const   *standard_tests[30]  =
#line 1098
  {      (char const   *)"discard",      (char const   *)"default=discard",      (char const   *)((void *)0),      (char const   *)"save",
        (char const   *)"default=save",      (char const   *)((void *)0),      (char const   *)"if-safe",      (char const   *)"default=if-safe",
        (char const   *)((void *)0),      (char const   *)"vpAg",      (char const   *)"vpAg=if-safe",      (char const   *)((void *)0),
        (char const   *)"sTER",      (char const   *)"sTER=if-safe",      (char const   *)((void *)0),      (char const   *)"IDAT",
        (char const   *)"default=discard",      (char const   *)"IDAT=save",      (char const   *)((void *)0),      (char const   *)"sAPI",
        (char const   *)"bKGD=save",      (char const   *)"cHRM=save",      (char const   *)"gAMA=save",      (char const   *)"all=discard",
        (char const   *)"iCCP=save",      (char const   *)"sBIT=save",      (char const   *)"sRGB=save",      (char const   *)"eXIf=save",
        (char const   *)((void *)0),      (char const   *)((void *)0)};
#line 1111
static void usage(char const   *program , char const   *reason )  __attribute__((__noreturn__)) ;
#line 1111 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngunknown.c"
static void usage(char const   *program , char const   *reason )
{


  {
#line 1114
  fprintf(stderr, (char const   *)"pngunknown: %s: usage:\n %s [--strict] --default|{(CHNK|default|all)=(default|discard|if-safe|save)} testfile.png\n",
          reason, program);
#line 1117
  exit(99);
}
}
#line 101 "/usr/include/stdlib.h"
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 104
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 107
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 112
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__leaf__, __gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__,
__nothrow__)) ;
#line 800
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) realpath)(char const   *__name , char *__resolved )  __attribute__((__nothrow__)) ;
#line 820
__inline extern void *( __attribute__((__warn_unused_result__, __nonnull__(1,2,5),
__gnu_inline__)) bsearch)(void const   *__key , void const   *__base , size_t __nmemb ,
                          size_t __size , int (*__compar)(void const   * , void const   * ) ) ;
#line 929
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar )  __attribute__((__nothrow__)) ;
#line 933
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t *__dst , char const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 936
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) wcstombs)(char *__dst , wchar_t const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 43 "/usr/include/string.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memcpy)(void *__dest , void const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 47
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 61
__inline extern void *( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) memset)(void *__dest , int __ch , size_t __len )  __attribute__((__nothrow__)) ;
#line 122
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcpy)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 125
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncpy)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 130
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcat)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 133
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncat)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 38 "/usr/include/strings.h"
__inline extern void ( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) bcopy)(void const   *__src , void *__dest , size_t __len )  __attribute__((__nothrow__)) ;
#line 42
__inline extern void ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) bzero)(void *__dest , size_t __len )  __attribute__((__nothrow__)) ;
#line 436 "/usr/include/string.h"
__inline extern void ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) explicit_bzero)(void *__dest , size_t __len )  __attribute__((__nothrow__)) ;
#line 460
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) stpncpy)(char *__dest , char const   *__src ,
                                             size_t __n )  __attribute__((__nothrow__)) ;
#line 326 "/usr/include/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) fprintf)(FILE *__stream ,
                                                                                                  char const   *__fmt
                                                                                                  , ...) ;
#line 332
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) printf)(char const   *__fmt
                                                                                                 , ...) ;
#line 334
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) sprintf)(char *__s ,
                                                                                                            char const   *__fmt
                                                                                                            , ...)  __attribute__((__nothrow__)) ;
#line 341
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vfprintf)(FILE *__stream ,
                                                                                                   char const   *__fmt ,
                                                                                                   __gnuc_va_list __ap ) ;
#line 347
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vprintf)(char const   *__fmt ,
                                                                                                  __gnuc_va_list __ap ) ;
#line 349
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vsprintf)(char *__s ,
                                                                                                             char const   *__fmt ,
                                                                                                             __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 354
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) snprintf)(char *__s , size_t __n , char const   *__fmt
                                              , ...)  __attribute__((__nothrow__)) ;
#line 358
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) vsnprintf)(char *__s , size_t __n , char const   *__fmt ,
                                               __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 379
__inline extern int ( /* format attribute */ __attribute__((__gnu_inline__, __artificial__,
__always_inline__)) vdprintf)(int __fd , char const   *__fmt , __gnuc_va_list __ap ) ;
#line 382
__inline extern int ( /* format attribute */ __attribute__((__gnu_inline__, __artificial__,
__always_inline__)) dprintf)(int __fd , char const   *__fmt  , ...) ;
#line 492
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
#line 499
__inline extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
#line 500
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
#line 510
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
#line 528
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
#line 537
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) ;
#line 545
__inline extern int ( __attribute__((__gnu_inline__)) putc_unlocked)(int __c , FILE *__stream ) ;
#line 546
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
#line 564
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fgets)(char *__s , int __n , FILE *__stream ) ;
#line 646
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fread)(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 673
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fread_unlocked)(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 766
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__)) feof_unlocked)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 767
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__)) ferror_unlocked)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 79 "/usr/include/ctype.h"
extern unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__nothrow__,
__const__)) ;
#line 81
extern __int32_t const   **( __attribute__((__leaf__)) __ctype_tolower_loc)(void)  __attribute__((__nothrow__,
__const__)) ;
#line 83
extern __int32_t const   **( __attribute__((__leaf__)) __ctype_toupper_loc)(void)  __attribute__((__nothrow__,
__const__)) ;
#line 108
extern int ( __attribute__((__leaf__)) isalnum)(int  )  __attribute__((__nothrow__)) ;
#line 109
extern int ( __attribute__((__leaf__)) isalpha)(int  )  __attribute__((__nothrow__)) ;
#line 110
extern int ( __attribute__((__leaf__)) iscntrl)(int  )  __attribute__((__nothrow__)) ;
#line 111
extern int ( __attribute__((__leaf__)) isdigit)(int  )  __attribute__((__nothrow__)) ;
#line 112
extern int ( __attribute__((__leaf__)) islower)(int  )  __attribute__((__nothrow__)) ;
#line 113
extern int ( __attribute__((__leaf__)) isgraph)(int  )  __attribute__((__nothrow__)) ;
#line 114
extern int ( __attribute__((__leaf__)) isprint)(int  )  __attribute__((__nothrow__)) ;
#line 115
extern int ( __attribute__((__leaf__)) ispunct)(int  )  __attribute__((__nothrow__)) ;
#line 116
extern int ( __attribute__((__leaf__)) isspace)(int  )  __attribute__((__nothrow__)) ;
#line 117
extern int ( __attribute__((__leaf__)) isupper)(int  )  __attribute__((__nothrow__)) ;
#line 118
extern int ( __attribute__((__leaf__)) isxdigit)(int  )  __attribute__((__nothrow__)) ;
#line 122
__inline extern int ( __attribute__((__leaf__, __gnu_inline__)) tolower)(int __c )  __attribute__((__nothrow__)) ;
#line 125
__inline extern int ( __attribute__((__leaf__, __gnu_inline__)) toupper)(int __c )  __attribute__((__nothrow__)) ;
#line 130
extern int ( __attribute__((__leaf__)) isblank)(int  )  __attribute__((__nothrow__)) ;
#line 142
extern int ( __attribute__((__leaf__)) isascii)(int __c )  __attribute__((__nothrow__)) ;
#line 146
extern int ( __attribute__((__leaf__)) toascii)(int __c )  __attribute__((__nothrow__)) ;
#line 150
extern int ( __attribute__((__leaf__)) _toupper)(int  )  __attribute__((__nothrow__)) ;
#line 151
extern int ( __attribute__((__leaf__)) _tolower)(int  )  __attribute__((__nothrow__)) ;
#line 206
__inline extern int ( __attribute__((__leaf__, __gnu_inline__)) tolower)(int __c )  __attribute__((__nothrow__)) ;
#line 206 "/usr/include/ctype.h"
__inline extern int ( __attribute__((__leaf__, __gnu_inline__)) tolower)(int __c )
{
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
#line 209
  if (__c >= -128) {
#line 209
    if (__c < 256) {
#line 209
      tmp = __ctype_tolower_loc();
#line 209
      tmp___0 = *(*tmp + __c);
    } else {
#line 209
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
#line 209
    tmp___0 = (__int32_t const   )__c;
  }
#line 209
  return ((int )tmp___0);
}
}
#line 212
__inline extern int ( __attribute__((__leaf__, __gnu_inline__)) toupper)(int __c )  __attribute__((__nothrow__)) ;
#line 212 "/usr/include/ctype.h"
__inline extern int ( __attribute__((__leaf__, __gnu_inline__)) toupper)(int __c )
{
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
#line 215
  if (__c >= -128) {
#line 215
    if (__c < 256) {
#line 215
      tmp = __ctype_toupper_loc();
#line 215
      tmp___0 = *(*tmp + __c);
    } else {
#line 215
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
#line 215
    tmp___0 = (__int32_t const   )__c;
  }
#line 215
  return ((int )tmp___0);
}
}
#line 251
extern int ( __attribute__((__leaf__)) isalnum_l)(int  , locale_t  )  __attribute__((__nothrow__)) ;
#line 252
extern int ( __attribute__((__leaf__)) isalpha_l)(int  , locale_t  )  __attribute__((__nothrow__)) ;
#line 253
extern int ( __attribute__((__leaf__)) iscntrl_l)(int  , locale_t  )  __attribute__((__nothrow__)) ;
#line 254
extern int ( __attribute__((__leaf__)) isdigit_l)(int  , locale_t  )  __attribute__((__nothrow__)) ;
#line 255
extern int ( __attribute__((__leaf__)) islower_l)(int  , locale_t  )  __attribute__((__nothrow__)) ;
#line 256
extern int ( __attribute__((__leaf__)) isgraph_l)(int  , locale_t  )  __attribute__((__nothrow__)) ;
#line 257
extern int ( __attribute__((__leaf__)) isprint_l)(int  , locale_t  )  __attribute__((__nothrow__)) ;
#line 258
extern int ( __attribute__((__leaf__)) ispunct_l)(int  , locale_t  )  __attribute__((__nothrow__)) ;
#line 259
extern int ( __attribute__((__leaf__)) isspace_l)(int  , locale_t  )  __attribute__((__nothrow__)) ;
#line 260
extern int ( __attribute__((__leaf__)) isupper_l)(int  , locale_t  )  __attribute__((__nothrow__)) ;
#line 261
extern int ( __attribute__((__leaf__)) isxdigit_l)(int  , locale_t  )  __attribute__((__nothrow__)) ;
#line 263
extern int ( __attribute__((__leaf__)) isblank_l)(int  , locale_t  )  __attribute__((__nothrow__)) ;
#line 267
extern int ( __attribute__((__leaf__)) __tolower_l)(int __c , locale_t __l )  __attribute__((__nothrow__)) ;
#line 268
extern int ( __attribute__((__leaf__)) tolower_l)(int __c , locale_t __l )  __attribute__((__nothrow__)) ;
#line 271
extern int ( __attribute__((__leaf__)) __toupper_l)(int __c , locale_t __l )  __attribute__((__nothrow__)) ;
#line 272
extern int ( __attribute__((__leaf__)) toupper_l)(int __c , locale_t __l )  __attribute__((__nothrow__)) ;
#line 177 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern int ( __attribute__((__leaf__)) isinf)(double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 182
extern int ( __attribute__((__leaf__)) finite)(double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 185
extern double ( __attribute__((__leaf__)) drem)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 185
extern double ( __attribute__((__leaf__)) __drem)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 189
extern double ( __attribute__((__leaf__)) significand)(double __x )  __attribute__((__nothrow__)) ;
#line 189
extern double ( __attribute__((__leaf__)) __significand)(double __x )  __attribute__((__nothrow__)) ;
#line 211
extern int ( __attribute__((__leaf__)) isnan)(double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 217
extern double ( __attribute__((__leaf__)) j0)(double  )  __attribute__((__nothrow__)) ;
#line 217
extern double ( __attribute__((__leaf__)) __j0)(double  )  __attribute__((__nothrow__)) ;
#line 218
extern double ( __attribute__((__leaf__)) j1)(double  )  __attribute__((__nothrow__)) ;
#line 218
extern double ( __attribute__((__leaf__)) __j1)(double  )  __attribute__((__nothrow__)) ;
#line 219
extern double ( __attribute__((__leaf__)) jn)(int  , double  )  __attribute__((__nothrow__)) ;
#line 219
extern double ( __attribute__((__leaf__)) __jn)(int  , double  )  __attribute__((__nothrow__)) ;
#line 220
extern double ( __attribute__((__leaf__)) y0)(double  )  __attribute__((__nothrow__)) ;
#line 220
extern double ( __attribute__((__leaf__)) __y0)(double  )  __attribute__((__nothrow__)) ;
#line 221
extern double ( __attribute__((__leaf__)) y1)(double  )  __attribute__((__nothrow__)) ;
#line 221
extern double ( __attribute__((__leaf__)) __y1)(double  )  __attribute__((__nothrow__)) ;
#line 222
extern double ( __attribute__((__leaf__)) yn)(int  , double  )  __attribute__((__nothrow__)) ;
#line 222
extern double ( __attribute__((__leaf__)) __yn)(int  , double  )  __attribute__((__nothrow__)) ;
#line 241
extern double ( __attribute__((__leaf__)) gamma)(double  )  __attribute__((__nothrow__)) ;
#line 241
extern double ( __attribute__((__leaf__)) __gamma)(double  )  __attribute__((__nothrow__)) ;
#line 249
extern double ( __attribute__((__leaf__)) lgamma_r)(double  , int *__signgamp )  __attribute__((__nothrow__)) ;
#line 249
extern double ( __attribute__((__leaf__)) __lgamma_r)(double  , int *__signgamp )  __attribute__((__nothrow__)) ;
#line 400
extern double ( __attribute__((__leaf__)) scalb)(double __x , double __n )  __attribute__((__nothrow__)) ;
#line 400
extern double ( __attribute__((__leaf__)) __scalb)(double __x , double __n )  __attribute__((__nothrow__)) ;
#line 177
extern int ( __attribute__((__leaf__)) isinff)(float __value )  __attribute__((__nothrow__,
__const__)) ;
#line 182
extern int ( __attribute__((__leaf__)) finitef)(float __value )  __attribute__((__nothrow__,
__const__)) ;
#line 185
extern float ( __attribute__((__leaf__)) dremf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 185
extern float ( __attribute__((__leaf__)) __dremf)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 189
extern float ( __attribute__((__leaf__)) significandf)(float __x )  __attribute__((__nothrow__)) ;
#line 189
extern float ( __attribute__((__leaf__)) __significandf)(float __x )  __attribute__((__nothrow__)) ;
#line 211
extern int ( __attribute__((__leaf__)) isnanf)(float __value )  __attribute__((__nothrow__,
__const__)) ;
#line 217
extern float ( __attribute__((__leaf__)) j0f)(float  )  __attribute__((__nothrow__)) ;
#line 217
extern float ( __attribute__((__leaf__)) __j0f)(float  )  __attribute__((__nothrow__)) ;
#line 218
extern float ( __attribute__((__leaf__)) j1f)(float  )  __attribute__((__nothrow__)) ;
#line 218
extern float ( __attribute__((__leaf__)) __j1f)(float  )  __attribute__((__nothrow__)) ;
#line 219
extern float ( __attribute__((__leaf__)) jnf)(int  , float  )  __attribute__((__nothrow__)) ;
#line 219
extern float ( __attribute__((__leaf__)) __jnf)(int  , float  )  __attribute__((__nothrow__)) ;
#line 220
extern float ( __attribute__((__leaf__)) y0f)(float  )  __attribute__((__nothrow__)) ;
#line 220
extern float ( __attribute__((__leaf__)) __y0f)(float  )  __attribute__((__nothrow__)) ;
#line 221
extern float ( __attribute__((__leaf__)) y1f)(float  )  __attribute__((__nothrow__)) ;
#line 221
extern float ( __attribute__((__leaf__)) __y1f)(float  )  __attribute__((__nothrow__)) ;
#line 222
extern float ( __attribute__((__leaf__)) ynf)(int  , float  )  __attribute__((__nothrow__)) ;
#line 222
extern float ( __attribute__((__leaf__)) __ynf)(int  , float  )  __attribute__((__nothrow__)) ;
#line 241
extern float ( __attribute__((__leaf__)) gammaf)(float  )  __attribute__((__nothrow__)) ;
#line 241
extern float ( __attribute__((__leaf__)) __gammaf)(float  )  __attribute__((__nothrow__)) ;
#line 249
extern float ( __attribute__((__leaf__)) lgammaf_r)(float  , int *__signgamp )  __attribute__((__nothrow__)) ;
#line 249
extern float ( __attribute__((__leaf__)) __lgammaf_r)(float  , int *__signgamp )  __attribute__((__nothrow__)) ;
#line 400
extern float ( __attribute__((__leaf__)) scalbf)(float __x , float __n )  __attribute__((__nothrow__)) ;
#line 400
extern float ( __attribute__((__leaf__)) __scalbf)(float __x , float __n )  __attribute__((__nothrow__)) ;
#line 177
extern int ( __attribute__((__leaf__)) isinfl)(long double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 182
extern int ( __attribute__((__leaf__)) finitel)(long double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 185
extern long double ( __attribute__((__leaf__)) dreml)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 185
extern long double ( __attribute__((__leaf__)) __dreml)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 189
extern long double ( __attribute__((__leaf__)) significandl)(long double __x )  __attribute__((__nothrow__)) ;
#line 189
extern long double ( __attribute__((__leaf__)) __significandl)(long double __x )  __attribute__((__nothrow__)) ;
#line 211
extern int ( __attribute__((__leaf__)) isnanl)(long double __value )  __attribute__((__nothrow__,
__const__)) ;
#line 217
extern long double ( __attribute__((__leaf__)) j0l)(long double  )  __attribute__((__nothrow__)) ;
#line 217
extern long double ( __attribute__((__leaf__)) __j0l)(long double  )  __attribute__((__nothrow__)) ;
#line 218
extern long double ( __attribute__((__leaf__)) j1l)(long double  )  __attribute__((__nothrow__)) ;
#line 218
extern long double ( __attribute__((__leaf__)) __j1l)(long double  )  __attribute__((__nothrow__)) ;
#line 219
extern long double ( __attribute__((__leaf__)) jnl)(int  , long double  )  __attribute__((__nothrow__)) ;
#line 219
extern long double ( __attribute__((__leaf__)) __jnl)(int  , long double  )  __attribute__((__nothrow__)) ;
#line 220
extern long double ( __attribute__((__leaf__)) y0l)(long double  )  __attribute__((__nothrow__)) ;
#line 220
extern long double ( __attribute__((__leaf__)) __y0l)(long double  )  __attribute__((__nothrow__)) ;
#line 221
extern long double ( __attribute__((__leaf__)) y1l)(long double  )  __attribute__((__nothrow__)) ;
#line 221
extern long double ( __attribute__((__leaf__)) __y1l)(long double  )  __attribute__((__nothrow__)) ;
#line 222
extern long double ( __attribute__((__leaf__)) ynl)(int  , long double  )  __attribute__((__nothrow__)) ;
#line 222
extern long double ( __attribute__((__leaf__)) __ynl)(int  , long double  )  __attribute__((__nothrow__)) ;
#line 241
extern long double ( __attribute__((__leaf__)) gammal)(long double  )  __attribute__((__nothrow__)) ;
#line 241
extern long double ( __attribute__((__leaf__)) __gammal)(long double  )  __attribute__((__nothrow__)) ;
#line 249
extern long double ( __attribute__((__leaf__)) lgammal_r)(long double  , int *__signgamp )  __attribute__((__nothrow__)) ;
#line 249
extern long double ( __attribute__((__leaf__)) __lgammal_r)(long double  , int *__signgamp )  __attribute__((__nothrow__)) ;
#line 400
extern long double ( __attribute__((__leaf__)) scalbl)(long double __x , long double __n )  __attribute__((__nothrow__)) ;
#line 400
extern long double ( __attribute__((__leaf__)) __scalbl)(long double __x , long double __n )  __attribute__((__nothrow__)) ;
#line 773 "/usr/include/math.h"
extern int signgam ;
#line 17 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/sRGB.h"
static double sRGB_from_linear(double l )
{
  double tmp ;

  {
#line 20
  if (l <= 0.0031308) {
#line 21
    l *= 12.92;
  } else {
#line 24
    tmp = pow(l, (double )1 / 2.4);
#line 24
    l = 1.055 * tmp - 0.055;
  }
#line 26
  return (l);
}
}
#line 29 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/sRGB.h"
static double linear_from_sRGB(double s )
{
  double tmp ;

  {
#line 32
  if (s <= 0.04045) {
#line 33
    return (s / 12.92);
  } else {
#line 36
    tmp = pow((s + 0.055) / 1.055, 2.4);
#line 36
    return (tmp);
  }
}
}
#line 39 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/sRGB.h"
static double YfromRGB(double r , double g , double b )
{


  {
#line 45
  return ((0.2126 * r + 0.7152 * g) + 0.0722 * b);
}
}
#line 78 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static char tmpf[23]  = {      (char )'T',      (char )'M',      (char )'P',      (char )'\000'};
#line 86 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void make_random_bytes(png_uint_32 *seed , void *pv , size_t size )
{
  png_uint_32 u0 ;
  png_uint_32 u1 ;
  png_bytep bytes ;
  size_t i ;
  png_uint_32 u ;
  png_bytep tmp ;

  {
#line 89
  u0 = *(seed + 0);
#line 89
  u1 = *(seed + 1);
#line 90
  bytes = (png_bytep )pv;
#line 96
  i = (size_t )0;
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (! (i < size)) {
#line 96
      goto while_break;
    }
#line 99
    u = ((u0 >> 12) ^ ((u1 << 7) | (u0 >> 25))) & 255U;
#line 100
    u1 <<= 8;
#line 101
    u1 |= u0 >> 24;
#line 102
    u0 <<= 8;
#line 103
    u0 |= u;
#line 104
    tmp = bytes;
#line 104
    bytes ++;
#line 104
    *tmp = (png_byte )u;
#line 96
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  *(seed + 0) = u0;
#line 108
  *(seed + 1) = u1;
#line 109
  return;
}
}
#line 111 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static png_uint_32 color_seed[2]  ;
#line 113 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void reseed(void)
{


  {
#line 116
  color_seed[0] = 0x12345678U;
#line 117
  color_seed[1] = 0x9abcdefU;
#line 118
  return;
}
}
#line 120 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void random_color(png_colorp color )
{


  {
#line 123
  make_random_bytes(color_seed, (void *)color, sizeof(*color));
#line 124
  return;
}
}
#line 129 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static double closestinteger(double x )
{
  double tmp ;

  {
#line 132
  tmp = floor(x + .5);
#line 132
  return (tmp);
}
}
#line 136 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static png_byte u8d(double d )
{


  {
#line 139
  d = closestinteger(d);
#line 140
  return ((png_byte )d);
}
}
#line 143 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static png_uint_16 u16d(double d )
{


  {
#line 146
  d = closestinteger(d);
#line 147
  return ((png_uint_16 )d);
}
}
#line 153 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static double sRGB_to_d[256]  ;
#line 154 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static double g22_to_d[256]  ;
#line 156 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void init_sRGB_to_d(void)
{
  int i ;

  {
#line 161
  sRGB_to_d[0] = (double )0;
#line 162
  i = 1;
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (! (i < 255)) {
#line 162
      goto while_break;
    }
#line 163
    sRGB_to_d[i] = linear_from_sRGB((double )i / 255.);
#line 162
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  sRGB_to_d[255] = (double )1;
#line 166
  g22_to_d[0] = (double )0;
#line 167
  i = 1;
  {
#line 167
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 167
    if (! (i < 255)) {
#line 167
      goto while_break___0;
    }
#line 168
    g22_to_d[i] = pow((double )i / 255., (double )1 / .45455);
#line 167
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 169
  g22_to_d[255] = (double )1;
#line 170
  return;
}
}
#line 172 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static png_byte sRGB(double linear )
{
  double tmp ;
  png_byte tmp___0 ;

  {
#line 175
  tmp = sRGB_from_linear(linear);
#line 175
  tmp___0 = u8d((double )255 * tmp);
#line 175
  return (tmp___0);
}
}
#line 178 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static png_byte isRGB(int fixed_linear )
{
  png_byte tmp ;

  {
#line 181
  tmp = sRGB((double )fixed_linear / 65535.);
#line 181
  return (tmp);
}
}
#line 199 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static png_uint_16 ilinear(int fixed_srgb )
{
  png_uint_16 tmp ;

  {
#line 202
  tmp = u16d((double )65535 * sRGB_to_d[fixed_srgb]);
#line 202
  return (tmp);
}
}
#line 205 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static png_uint_16 ilineara(int fixed_srgb , int alpha )
{
  png_uint_16 tmp ;

  {
#line 208
  tmp = u16d((double )(257 * alpha) * sRGB_to_d[fixed_srgb]);
#line 208
  return (tmp);
}
}
#line 211 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static png_uint_16 ilinear_g22(int fixed_srgb )
{
  png_uint_16 tmp ;

  {
#line 214
  tmp = u16d((double )65535 * g22_to_d[fixed_srgb]);
#line 214
  return (tmp);
}
}
#line 225 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static double YfromRGBint(int ir , int ig , int ib )
{
  double r ;
  double g ;
  double b ;
  double tmp ;

  {
#line 228
  r = (double )ir;
#line 229
  g = (double )ig;
#line 230
  b = (double )ib;
#line 231
  tmp = YfromRGB(r, g, b);
#line 231
  return (tmp);
}
}
#line 340 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void print_opts(png_uint_32 opts )
{


  {
#line 343
  if (opts & 1U) {
#line 344
    printf((char const   *)" --file");
  }
#line 345
  if (opts & 2U) {
#line 346
    printf((char const   *)" --stdio");
  }
#line 347
  if (! (opts & 4U)) {
#line 348
    printf((char const   *)" --nostrict");
  }
#line 349
  if (opts & 8U) {
#line 350
    printf((char const   *)" --verbose");
  }
#line 351
  if (opts & 16U) {
#line 352
    printf((char const   *)" --preserve");
  }
#line 353
  if (opts & 32U) {
#line 354
    printf((char const   *)" --keep-going");
  }
#line 355
  if (opts & 64U) {
#line 356
    printf((char const   *)" --accumulate");
  }
#line 357
  if (! (opts & 128U)) {
#line 358
    printf((char const   *)" --slow");
  }
#line 359
  if (opts & 256U) {
#line 360
    printf((char const   *)" --sRGB-16bit");
  }
#line 361
  if (opts & 512U) {
#line 362
    printf((char const   *)" --noreseed");
  }
#line 364
  if (opts & 1024U) {
#line 365
    printf((char const   *)" --fault-gbg-warning");
  }
#line 367
  return;
}
}
#line 376 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static char const   *format_names[64]  =
#line 376
  {      (char const   *)"sRGB-gray",      (char const   *)"sRGB-gray+alpha",      (char const   *)"sRGB-rgb",      (char const   *)"sRGB-rgb+alpha",
        (char const   *)"linear-gray",      (char const   *)"linear-gray+alpha",      (char const   *)"linear-rgb",      (char const   *)"linear-rgb+alpha",
        (char const   *)"color-mapped-sRGB-gray",      (char const   *)"color-mapped-sRGB-gray+alpha",      (char const   *)"color-mapped-sRGB-rgb",      (char const   *)"color-mapped-sRGB-rgb+alpha",
        (char const   *)"color-mapped-linear-gray",      (char const   *)"color-mapped-linear-gray+alpha",      (char const   *)"color-mapped-linear-rgb",      (char const   *)"color-mapped-linear-rgb+alpha",
        (char const   *)"sRGB-gray",      (char const   *)"sRGB-gray+alpha",      (char const   *)"sRGB-bgr",      (char const   *)"sRGB-bgr+alpha",
        (char const   *)"linear-gray",      (char const   *)"linear-gray+alpha",      (char const   *)"linear-bgr",      (char const   *)"linear-bgr+alpha",
        (char const   *)"color-mapped-sRGB-gray",      (char const   *)"color-mapped-sRGB-gray+alpha",      (char const   *)"color-mapped-sRGB-bgr",      (char const   *)"color-mapped-sRGB-bgr+alpha",
        (char const   *)"color-mapped-linear-gray",      (char const   *)"color-mapped-linear-gray+alpha",      (char const   *)"color-mapped-linear-bgr",      (char const   *)"color-mapped-linear-bgr+alpha",
        (char const   *)"sRGB-gray",      (char const   *)"alpha+sRGB-gray",      (char const   *)"sRGB-rgb",      (char const   *)"alpha+sRGB-rgb",
        (char const   *)"linear-gray",      (char const   *)"alpha+linear-gray",      (char const   *)"linear-rgb",      (char const   *)"alpha+linear-rgb",
        (char const   *)"color-mapped-sRGB-gray",      (char const   *)"color-mapped-alpha+sRGB-gray",      (char const   *)"color-mapped-sRGB-rgb",      (char const   *)"color-mapped-alpha+sRGB-rgb",
        (char const   *)"color-mapped-linear-gray",      (char const   *)"color-mapped-alpha+linear-gray",      (char const   *)"color-mapped-linear-rgb",      (char const   *)"color-mapped-alpha+linear-rgb",
        (char const   *)"sRGB-gray",      (char const   *)"alpha+sRGB-gray",      (char const   *)"sRGB-bgr",      (char const   *)"alpha+sRGB-bgr",
        (char const   *)"linear-gray",      (char const   *)"alpha+linear-gray",      (char const   *)"linear-bgr",      (char const   *)"alpha+linear-bgr",
        (char const   *)"color-mapped-sRGB-gray",      (char const   *)"color-mapped-alpha+sRGB-gray",      (char const   *)"color-mapped-sRGB-bgr",      (char const   *)"color-mapped-alpha+sRGB-bgr",
        (char const   *)"color-mapped-linear-gray",      (char const   *)"color-mapped-alpha+linear-gray",      (char const   *)"color-mapped-linear-bgr",      (char const   *)"color-mapped-alpha+linear-bgr"};
#line 452 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static png_uint_32 formatof(char const   *arg )
{
  char *ep ;
  unsigned long format ;
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 456
  tmp = strtoul((char const   * __restrict  )arg, (char ** __restrict  )(& ep), 0);
#line 456
  format = tmp;
#line 458
  if ((unsigned long )ep > (unsigned long )arg) {
#line 458
    if ((int )*ep == 0) {
#line 458
      if (format < 64UL) {
#line 459
        return ((png_uint_32 )format);
      } else {
#line 458
        goto _L___0;
      }
    } else {
#line 458
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */
    _L: /* CIL Label */
#line 461
    format = 0UL;
    {
#line 461
    while (1) {
      while_continue: /* CIL Label */ ;
#line 461
      if (! (format < 64UL)) {
#line 461
        goto while_break;
      }
#line 463
      tmp___0 = strcmp((char const   *)format_names[format], arg);
#line 463
      if (tmp___0 == 0) {
#line 464
        return ((png_uint_32 )format);
      }
#line 461
      format ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 467
  fprintf(stderr, (char const   *)"pngstest: format name \'%s\' invalid\n", arg);
#line 468
  return ((png_uint_32 )64);
}
}
#line 479 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void format_init(format_list *pf )
{
  int i ;

  {
#line 482
  i = 0;
  {
#line 482
  while (1) {
    while_continue: /* CIL Label */ ;
#line 482
    if (! (i < 2)) {
#line 482
      goto while_break;
    }
#line 483
    pf->bits[i] = (png_uint_32 )0;
#line 482
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 484
  return;
}
}
#line 495 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static int format_is_initial(format_list *pf )
{
  int i ;

  {
#line 498
  i = 0;
  {
#line 498
  while (1) {
    while_continue: /* CIL Label */ ;
#line 498
    if (! (i < 2)) {
#line 498
      goto while_break;
    }
#line 499
    if (pf->bits[i] != 0U) {
#line 500
      return (0);
    }
#line 498
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 502
  return (1);
}
}
#line 505 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static int format_set(format_list *pf , png_uint_32 format )
{
  unsigned int tmp ;

  {
#line 507
  if (format < 64U) {
#line 508
    tmp = pf->bits[format >> 5] | (1U << (format & 31U));
#line 508
    pf->bits[format >> 5] = tmp;
#line 508
    return ((int )tmp);
  }
#line 510
  return (0);
}
}
#line 523 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static int format_isset(format_list *pf , png_uint_32 format )
{
  int tmp ;

  {
#line 525
  if (format < 64U) {
#line 525
    if ((pf->bits[format >> 5] & (1U << (format & 31U))) != 0U) {
#line 525
      tmp = 1;
    } else {
#line 525
      tmp = 0;
    }
  } else {
#line 525
    tmp = 0;
  }
#line 525
  return (tmp);
}
}
#line 529 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void format_default(format_list *pf , int redundant )
{
  int i ;
  png_uint_32 f ;

  {
#line 531
  if (redundant) {
#line 536
    i = 0;
    {
#line 536
    while (1) {
      while_continue: /* CIL Label */ ;
#line 536
      if (! (i < 2)) {
#line 536
        goto while_break;
      }
#line 537
      pf->bits[i] = ~ ((png_uint_32 )0);
#line 536
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 544
    f = (png_uint_32 )0;
    {
#line 544
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 544
      if (! (f < 64U)) {
#line 544
        goto while_break___0;
      }
#line 549
      if ((f & 0x02U) == 0U) {
#line 549
        if ((f & 0x10U) != 0U) {
#line 554
          goto __Cont;
        }
      }
#line 558
      if ((f & 0x01U) == 0U) {
#line 558
        if ((f & 0x20U) != 0U) {
#line 563
          goto __Cont;
        }
      }
#line 565
      format_set(pf, f);
      __Cont: /* CIL Label */
#line 544
      f ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 568
  return;
}
}
#line 593 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void newimage(Image *image )
{


  {
#line 596
  memset((void *)image, 0, sizeof(*image));
#line 597
  return;
}
}
#line 601 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void resetimage(Image *image )
{


  {
#line 604
  if ((unsigned long )image->input_file != (unsigned long )((void *)0)) {
#line 605
    rewind(image->input_file);
  }
#line 606
  return;
}
}
#line 611 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void freebuffer(Image *image )
{


  {
#line 614
  if (image->buffer) {
#line 614
    free((void *)image->buffer);
  }
#line 615
  image->buffer = (png_bytep )((void *)0);
#line 616
  image->bufsize = (size_t )0;
#line 617
  image->allocsize = (size_t )0;
#line 618
  return;
}
}
#line 623 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void freeimage(Image *image )
{


  {
#line 626
  freebuffer(image);
#line 627
  png_image_free(& image->image);
#line 629
  if ((unsigned long )image->input_file != (unsigned long )((void *)0)) {
#line 631
    fclose(image->input_file);
#line 632
    image->input_file = (FILE *)((void *)0);
  }
#line 635
  if ((unsigned long )image->input_memory != (unsigned long )((void *)0)) {
#line 637
    free(image->input_memory);
#line 638
    image->input_memory = (void *)0;
#line 639
    image->input_memory_size = (size_t )0;
  }
#line 642
  if ((int )image->tmpfile_name[0] != 0) {
#line 642
    if ((image->opts & 16U) == 0U) {
#line 644
      remove((char const   *)(image->tmpfile_name));
#line 645
      image->tmpfile_name[0] = (char)0;
    }
  }
#line 647
  return;
}
}
#line 652 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void initimage(Image *image , png_uint_32 opts , char const   *file_name ,
                      int stride_extra )
{


  {
#line 655
  freeimage(image);
#line 656
  memset((void *)(& image->image), 0, sizeof(image->image));
#line 657
  image->opts = opts;
#line 658
  image->file_name = file_name;
#line 659
  image->stride_extra = stride_extra;
#line 660
  return;
}
}
#line 666 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void allocbuffer(Image *image )
{
  size_t size ;
  unsigned int tmp ;
  void *tmp___0 ;

  {
#line 669
  if (image->image.format & 0x08U) {
#line 669
    tmp = 1U;
  } else {
#line 669
    tmp = ((image->image.format & 0x04U) >> 2) + 1U;
  }
#line 669
  size = (size_t )((ptrdiff_t )(tmp * image->image.height) * image->stride);
#line 671
  if (size + 32UL > image->bufsize) {
#line 673
    freebuffer(image);
#line 674
    tmp___0 = malloc(size + 32UL);
#line 674
    image->buffer = (png_bytep )tmp___0;
#line 675
    if ((unsigned long )image->buffer == (unsigned long )((void *)0)) {
#line 677
      fflush(stdout);
#line 678
      fprintf(stderr, (char const   *)"simpletest: out of memory allocating %lu(+32) byte buffer\n",
              size);
#line 681
      exit(1);
    }
#line 683
    image->bufsize = size + 32UL;
  }
#line 686
  memset((void *)image->buffer, 95, image->bufsize);
#line 687
  memset((void *)(image->buffer + 16), 73, size);
#line 688
  image->allocsize = size;
#line 689
  return;
}
}
#line 692 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static int check16(png_const_bytep bp , int b )
{
  int i ;

  {
#line 695
  i = 16;
  {
#line 697
  while (1) {
    while_continue: /* CIL Label */ ;
#line 698
    if ((int const   )*bp != (int const   )b) {
#line 698
      return (1);
    }
#line 697
    i --;
#line 697
    if (! i) {
#line 697
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 701
  return (0);
}
}
#line 705 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void checkbuffer(Image *image , char const   *arg )
{
  int tmp ;
  int tmp___0 ;

  {
#line 708
  tmp = check16((png_const_bytep )image->buffer, 95);
#line 708
  if (tmp) {
#line 710
    fflush(stdout);
#line 711
    fprintf(stderr, (char const   *)"%s: overwrite at start of image buffer\n", arg);
#line 712
    exit(1);
  }
#line 715
  tmp___0 = check16((png_const_bytep )((image->buffer + 16) + image->allocsize), 95);
#line 715
  if (tmp___0) {
#line 717
    fflush(stdout);
#line 718
    fprintf(stderr, (char const   *)"%s: overwrite at end of image buffer\n", arg);
#line 719
    exit(1);
  }
#line 721
  return;
}
}
#line 726 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static int logerror(Image *image , char const   *a1 , char const   *a2 , char const   *a3 )
{


  {
#line 729
  fflush(stdout);
#line 730
  if (image->image.warning_or_error) {
#line 731
    fprintf(stderr, (char const   *)"%s%s%s: %s\n", a1, a2, a3, image->image.message);
  } else {
#line 734
    fprintf(stderr, (char const   *)"%s%s%s\n", a1, a2, a3);
  }
#line 736
  if ((unsigned long )image->image.opaque != (unsigned long )((void *)0)) {
#line 738
    fprintf(stderr, (char const   *)"%s: image opaque pointer non-NULL on error\n",
            image->file_name);
#line 740
    png_image_free(& image->image);
  }
#line 743
  return (0);
}
}
#line 749 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static int logclose(Image *image , FILE *f , char const   *name , char const   *operation )
{
  int e ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 752
  tmp = __errno_location();
#line 752
  e = *tmp;
#line 754
  fclose(f);
#line 755
  tmp___0 = strerror(e);
#line 755
  tmp___1 = logerror(image, name, operation, (char const   *)tmp___0);
#line 755
  return (tmp___1);
}
}
#line 761 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static int checkopaque(Image *image )
{
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 764
  if ((unsigned long )image->image.opaque != (unsigned long )((void *)0)) {
#line 766
    png_image_free(& image->image);
#line 767
    tmp = logerror(image, image->file_name, (char const   *)": opaque not NULL", (char const   *)"");
#line 767
    return (tmp);
  } else
#line 773
  if (image->image.warning_or_error != 0U) {
#line 773
    tmp___4 = strcmp((char const   *)(image->image.message), (char const   *)"libpng does not support gamma+background+rgb_to_gray");
#line 773
    if (tmp___4 == 0) {
#line 773
      tmp___3 = (image->opts & 1024U) != 0U;
    } else {
#line 773
      tmp___3 = (image->opts & 4U) != 0U;
    }
#line 773
    if (tmp___3) {
#line 777
      if ((image->opts & 1024U) != 0U) {
#line 777
        tmp___0 = " --fault-gbg-warning";
      } else {
#line 777
        tmp___0 = " --strict";
      }
#line 777
      tmp___1 = logerror(image, image->file_name, (char const   *)tmp___0, (char const   *)"");
#line 777
      return (tmp___1);
    } else {
#line 781
      return (1);
    }
  } else {
#line 781
    return (1);
  }
}
}
#line 813 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gp_g8(Pixel *p , png_const_voidp pb )
{
  png_const_bytep pp ;
  int tmp ;
  int tmp___0 ;

  {
#line 816
  pp = (png_const_bytep )pb;
#line 818
  tmp___0 = (int )*(pp + 0);
#line 818
  p->b = tmp___0;
#line 818
  tmp = tmp___0;
#line 818
  p->g = tmp;
#line 818
  p->r = tmp;
#line 819
  p->a = 255;
#line 820
  return;
}
}
#line 822 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gp_ga8(Pixel *p , png_const_voidp pb )
{
  png_const_bytep pp ;
  int tmp ;
  int tmp___0 ;

  {
#line 825
  pp = (png_const_bytep )pb;
#line 827
  tmp___0 = (int )*(pp + 0);
#line 827
  p->b = tmp___0;
#line 827
  tmp = tmp___0;
#line 827
  p->g = tmp;
#line 827
  p->r = tmp;
#line 828
  p->a = (int )*(pp + 1);
#line 829
  return;
}
}
#line 832 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gp_ag8(Pixel *p , png_const_voidp pb )
{
  png_const_bytep pp ;
  int tmp ;
  int tmp___0 ;

  {
#line 835
  pp = (png_const_bytep )pb;
#line 837
  tmp___0 = (int )*(pp + 1);
#line 837
  p->b = tmp___0;
#line 837
  tmp = tmp___0;
#line 837
  p->g = tmp;
#line 837
  p->r = tmp;
#line 838
  p->a = (int )*(pp + 0);
#line 839
  return;
}
}
#line 842 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gp_rgb8(Pixel *p , png_const_voidp pb )
{
  png_const_bytep pp ;

  {
#line 845
  pp = (png_const_bytep )pb;
#line 847
  p->r = (int )*(pp + 0);
#line 848
  p->g = (int )*(pp + 1);
#line 849
  p->b = (int )*(pp + 2);
#line 850
  p->a = 255;
#line 851
  return;
}
}
#line 854 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gp_bgr8(Pixel *p , png_const_voidp pb )
{
  png_const_bytep pp ;

  {
#line 857
  pp = (png_const_bytep )pb;
#line 859
  p->r = (int )*(pp + 2);
#line 860
  p->g = (int )*(pp + 1);
#line 861
  p->b = (int )*(pp + 0);
#line 862
  p->a = 255;
#line 863
  return;
}
}
#line 866 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gp_rgba8(Pixel *p , png_const_voidp pb )
{
  png_const_bytep pp ;

  {
#line 869
  pp = (png_const_bytep )pb;
#line 871
  p->r = (int )*(pp + 0);
#line 872
  p->g = (int )*(pp + 1);
#line 873
  p->b = (int )*(pp + 2);
#line 874
  p->a = (int )*(pp + 3);
#line 875
  return;
}
}
#line 878 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gp_bgra8(Pixel *p , png_const_voidp pb )
{
  png_const_bytep pp ;

  {
#line 881
  pp = (png_const_bytep )pb;
#line 883
  p->r = (int )*(pp + 2);
#line 884
  p->g = (int )*(pp + 1);
#line 885
  p->b = (int )*(pp + 0);
#line 886
  p->a = (int )*(pp + 3);
#line 887
  return;
}
}
#line 891 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gp_argb8(Pixel *p , png_const_voidp pb )
{
  png_const_bytep pp ;

  {
#line 894
  pp = (png_const_bytep )pb;
#line 896
  p->r = (int )*(pp + 1);
#line 897
  p->g = (int )*(pp + 2);
#line 898
  p->b = (int )*(pp + 3);
#line 899
  p->a = (int )*(pp + 0);
#line 900
  return;
}
}
#line 904 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gp_abgr8(Pixel *p , png_const_voidp pb )
{
  png_const_bytep pp ;

  {
#line 907
  pp = (png_const_bytep )pb;
#line 909
  p->r = (int )*(pp + 3);
#line 910
  p->g = (int )*(pp + 2);
#line 911
  p->b = (int )*(pp + 1);
#line 912
  p->a = (int )*(pp + 0);
#line 913
  return;
}
}
#line 916 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gp_g16(Pixel *p , png_const_voidp pb )
{
  png_const_uint_16p pp ;
  int tmp ;
  int tmp___0 ;

  {
#line 919
  pp = (png_const_uint_16p )pb;
#line 921
  tmp___0 = (int )*(pp + 0);
#line 921
  p->b = tmp___0;
#line 921
  tmp = tmp___0;
#line 921
  p->g = tmp;
#line 921
  p->r = tmp;
#line 922
  p->a = 65535;
#line 923
  return;
}
}
#line 925 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gp_ga16(Pixel *p , png_const_voidp pb )
{
  png_const_uint_16p pp ;
  int tmp ;
  int tmp___0 ;

  {
#line 928
  pp = (png_const_uint_16p )pb;
#line 930
  tmp___0 = (int )*(pp + 0);
#line 930
  p->b = tmp___0;
#line 930
  tmp = tmp___0;
#line 930
  p->g = tmp;
#line 930
  p->r = tmp;
#line 931
  p->a = (int )*(pp + 1);
#line 932
  return;
}
}
#line 935 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gp_ag16(Pixel *p , png_const_voidp pb )
{
  png_const_uint_16p pp ;
  int tmp ;
  int tmp___0 ;

  {
#line 938
  pp = (png_const_uint_16p )pb;
#line 940
  tmp___0 = (int )*(pp + 1);
#line 940
  p->b = tmp___0;
#line 940
  tmp = tmp___0;
#line 940
  p->g = tmp;
#line 940
  p->r = tmp;
#line 941
  p->a = (int )*(pp + 0);
#line 942
  return;
}
}
#line 945 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gp_rgb16(Pixel *p , png_const_voidp pb )
{
  png_const_uint_16p pp ;

  {
#line 948
  pp = (png_const_uint_16p )pb;
#line 950
  p->r = (int )*(pp + 0);
#line 951
  p->g = (int )*(pp + 1);
#line 952
  p->b = (int )*(pp + 2);
#line 953
  p->a = 65535;
#line 954
  return;
}
}
#line 957 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gp_bgr16(Pixel *p , png_const_voidp pb )
{
  png_const_uint_16p pp ;

  {
#line 960
  pp = (png_const_uint_16p )pb;
#line 962
  p->r = (int )*(pp + 2);
#line 963
  p->g = (int )*(pp + 1);
#line 964
  p->b = (int )*(pp + 0);
#line 965
  p->a = 65535;
#line 966
  return;
}
}
#line 969 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gp_rgba16(Pixel *p , png_const_voidp pb )
{
  png_const_uint_16p pp ;

  {
#line 972
  pp = (png_const_uint_16p )pb;
#line 974
  p->r = (int )*(pp + 0);
#line 975
  p->g = (int )*(pp + 1);
#line 976
  p->b = (int )*(pp + 2);
#line 977
  p->a = (int )*(pp + 3);
#line 978
  return;
}
}
#line 981 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gp_bgra16(Pixel *p , png_const_voidp pb )
{
  png_const_uint_16p pp ;

  {
#line 984
  pp = (png_const_uint_16p )pb;
#line 986
  p->r = (int )*(pp + 2);
#line 987
  p->g = (int )*(pp + 1);
#line 988
  p->b = (int )*(pp + 0);
#line 989
  p->a = (int )*(pp + 3);
#line 990
  return;
}
}
#line 994 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gp_argb16(Pixel *p , png_const_voidp pb )
{
  png_const_uint_16p pp ;

  {
#line 997
  pp = (png_const_uint_16p )pb;
#line 999
  p->r = (int )*(pp + 1);
#line 1000
  p->g = (int )*(pp + 2);
#line 1001
  p->b = (int )*(pp + 3);
#line 1002
  p->a = (int )*(pp + 0);
#line 1003
  return;
}
}
#line 1007 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gp_abgr16(Pixel *p , png_const_voidp pb )
{
  png_const_uint_16p pp ;

  {
#line 1010
  pp = (png_const_uint_16p )pb;
#line 1012
  p->r = (int )*(pp + 3);
#line 1013
  p->g = (int )*(pp + 2);
#line 1014
  p->b = (int )*(pp + 1);
#line 1015
  p->a = (int )*(pp + 0);
#line 1016
  return;
}
}
#line 1020 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void (*get_pixel(png_uint_32 format ))(Pixel *p , png_const_voidp pb )
{


  {
#line 1027
  if (format & 0x04U) {
#line 1029
    if (format & 0x02U) {
#line 1032
      if (format & 0x10U) {
#line 1034
        if (format & 0x01U) {
#line 1037
          if (format & 0x20U) {
#line 1038
            return (& gp_abgr16);
          } else {
#line 1042
            return (& gp_bgra16);
          }
        } else {
#line 1046
          return (& gp_bgr16);
        }
      } else
#line 1052
      if (format & 0x01U) {
#line 1055
        if (format & 0x20U) {
#line 1056
          return (& gp_argb16);
        } else {
#line 1060
          return (& gp_rgba16);
        }
      } else {
#line 1064
        return (& gp_rgb16);
      }
    } else
#line 1070
    if (format & 0x01U) {
#line 1073
      if (format & 0x20U) {
#line 1074
        return (& gp_ag16);
      } else {
#line 1078
        return (& gp_ga16);
      }
    } else {
#line 1082
      return (& gp_g16);
    }
  } else
#line 1088
  if (format & 0x02U) {
#line 1091
    if (format & 0x10U) {
#line 1093
      if (format & 0x01U) {
#line 1096
        if (format & 0x20U) {
#line 1097
          return (& gp_abgr8);
        } else {
#line 1101
          return (& gp_bgra8);
        }
      } else {
#line 1105
        return (& gp_bgr8);
      }
    } else
#line 1111
    if (format & 0x01U) {
#line 1114
      if (format & 0x20U) {
#line 1115
        return (& gp_argb8);
      } else {
#line 1119
        return (& gp_rgba8);
      }
    } else {
#line 1123
      return (& gp_rgb8);
    }
  } else
#line 1129
  if (format & 0x01U) {
#line 1132
    if (format & 0x20U) {
#line 1133
      return (& gp_ag8);
    } else {
#line 1137
      return (& gp_ga8);
    }
  } else {
#line 1141
    return (& gp_g8);
  }
}
}
#line 1203 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gpc_noop(Pixel *out , Pixel const   *in , Background const   *back )
{


  {
#line 1207
  out->r = (int )in->r;
#line 1208
  out->g = (int )in->g;
#line 1209
  out->b = (int )in->b;
#line 1210
  out->a = (int )in->a;
#line 1211
  return;
}
}
#line 1253 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gpc_bckg(Pixel *out , Pixel const   *in , Background const   *back )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  double a ;
  int tmp___3 ;
  int tmp___4 ;
  png_byte tmp___5 ;

  {
#line 1256
  if (in->a <= 0) {
#line 1257
    tmp___0 = (int )back->ig;
#line 1257
    out->b = tmp___0;
#line 1257
    tmp = tmp___0;
#line 1257
    out->g = tmp;
#line 1257
    out->r = tmp;
  } else
#line 1259
  if (in->a >= 255) {
#line 1260
    tmp___2 = (int )in->g;
#line 1260
    out->b = tmp___2;
#line 1260
    tmp___1 = tmp___2;
#line 1260
    out->g = tmp___1;
#line 1260
    out->r = tmp___1;
  } else {
#line 1264
    a = (double )in->a / 255.;
#line 1266
    tmp___5 = sRGB(sRGB_to_d[in->g] * a + (double )(back->dg * (double )((double )1 - a)));
#line 1266
    tmp___4 = (int )tmp___5;
#line 1266
    out->b = tmp___4;
#line 1266
    tmp___3 = tmp___4;
#line 1266
    out->g = tmp___3;
#line 1266
    out->r = tmp___3;
  }
#line 1269
  out->a = 255;
#line 1270
  return;
}
}
#line 1273 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gpc_bckc(Pixel *out , Pixel const   *in , Background const   *back )
{
  double a ;
  png_byte tmp ;
  png_byte tmp___0 ;
  png_byte tmp___1 ;

  {
#line 1276
  if (in->a <= 0) {
#line 1278
    out->r = (int )back->ir;
#line 1279
    out->g = (int )back->ig;
#line 1280
    out->b = (int )back->ib;
  } else
#line 1283
  if (in->a >= 255) {
#line 1285
    out->r = (int )in->r;
#line 1286
    out->g = (int )in->g;
#line 1287
    out->b = (int )in->b;
  } else {
#line 1292
    a = (double )in->a / 255.;
#line 1294
    tmp = sRGB(sRGB_to_d[in->r] * a + (double )(back->dr * (double )((double )1 - a)));
#line 1294
    out->r = (int )tmp;
#line 1295
    tmp___0 = sRGB(sRGB_to_d[in->g] * a + (double )(back->dg * (double )((double )1 - a)));
#line 1295
    out->g = (int )tmp___0;
#line 1296
    tmp___1 = sRGB(sRGB_to_d[in->b] * a + (double )(back->db * (double )((double )1 - a)));
#line 1296
    out->b = (int )tmp___1;
  }
#line 1299
  out->a = 255;
#line 1300
  return;
}
}
#line 1303 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gpc_g8(Pixel *out , Pixel const   *in , Background const   *back )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  png_byte tmp___4 ;

  {
#line 1308
  if (in->r == in->g) {
#line 1308
    if (in->g == in->b) {
#line 1309
      tmp___0 = (int )in->g;
#line 1309
      out->b = tmp___0;
#line 1309
      tmp = tmp___0;
#line 1309
      out->g = tmp;
#line 1309
      out->r = tmp;
    } else {
#line 1308
      goto _L;
    }
  } else {
    _L: /* CIL Label */
#line 1312
    tmp___3 = YfromRGB(sRGB_to_d[in->r], sRGB_to_d[in->g], sRGB_to_d[in->b]);
#line 1312
    tmp___4 = sRGB(tmp___3);
#line 1312
    tmp___2 = (int )tmp___4;
#line 1312
    out->b = tmp___2;
#line 1312
    tmp___1 = tmp___2;
#line 1312
    out->g = tmp___1;
#line 1312
    out->r = tmp___1;
  }
#line 1315
  out->a = (int )in->a;
#line 1316
  return;
}
}
#line 1319 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gpc_g8b(Pixel *out , Pixel const   *in , Background const   *back )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  double tmp___5 ;
  png_byte tmp___6 ;
  double a ;
  int tmp___7 ;
  int tmp___8 ;
  double tmp___9 ;
  png_byte tmp___10 ;

  {
#line 1322
  if (in->a <= 0) {
#line 1323
    tmp___0 = (int )back->ig;
#line 1323
    out->b = tmp___0;
#line 1323
    tmp = tmp___0;
#line 1323
    out->g = tmp;
#line 1323
    out->r = tmp;
  } else
#line 1325
  if (in->a >= 255) {
#line 1327
    if (in->r == in->g) {
#line 1327
      if (in->g == in->b) {
#line 1328
        tmp___2 = (int )in->g;
#line 1328
        out->b = tmp___2;
#line 1328
        tmp___1 = tmp___2;
#line 1328
        out->g = tmp___1;
#line 1328
        out->r = tmp___1;
      } else {
#line 1327
        goto _L;
      }
    } else {
      _L: /* CIL Label */
#line 1331
      tmp___5 = YfromRGB(sRGB_to_d[in->r], sRGB_to_d[in->g], sRGB_to_d[in->b]);
#line 1331
      tmp___6 = sRGB(tmp___5);
#line 1331
      tmp___4 = (int )tmp___6;
#line 1331
      out->b = tmp___4;
#line 1331
      tmp___3 = tmp___4;
#line 1331
      out->g = tmp___3;
#line 1331
      out->r = tmp___3;
    }
  } else {
#line 1337
    a = (double )in->a / 255.;
#line 1339
    tmp___9 = YfromRGB(sRGB_to_d[in->r], sRGB_to_d[in->g], sRGB_to_d[in->b]);
#line 1339
    tmp___10 = sRGB(a * tmp___9 + (double )(back->dg * (double )((double )1 - a)));
#line 1339
    tmp___8 = (int )tmp___10;
#line 1339
    out->b = tmp___8;
#line 1339
    tmp___7 = tmp___8;
#line 1339
    out->g = tmp___7;
#line 1339
    out->r = tmp___7;
  }
#line 1343
  out->a = 255;
#line 1344
  return;
}
}
#line 1348 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gpc_lin(Pixel *out , Pixel const   *in , Background const   *back )
{
  png_uint_16 tmp ;
  png_uint_16 tmp___0 ;
  png_uint_16 tmp___1 ;
  png_uint_16 tmp___2 ;

  {
#line 1353
  tmp = ilinear((int )in->r);
#line 1353
  out->r = (int )tmp;
#line 1355
  if (in->g == in->r) {
#line 1357
    out->g = out->r;
#line 1359
    if (in->b == in->r) {
#line 1360
      out->b = out->r;
    } else {
#line 1363
      tmp___0 = ilinear((int )in->b);
#line 1363
      out->b = (int )tmp___0;
    }
  } else {
#line 1368
    tmp___1 = ilinear((int )in->g);
#line 1368
    out->g = (int )tmp___1;
#line 1370
    if (in->b == in->r) {
#line 1371
      out->b = out->r;
    } else
#line 1373
    if (in->b == in->g) {
#line 1374
      out->b = out->g;
    } else {
#line 1377
      tmp___2 = ilinear((int )in->b);
#line 1377
      out->b = (int )tmp___2;
    }
  }
#line 1380
  out->a = 65535;
#line 1381
  return;
}
}
#line 1384 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gpc_pre(Pixel *out , Pixel const   *in , Background const   *back )
{
  png_uint_16 tmp ;
  png_uint_16 tmp___0 ;
  png_uint_16 tmp___1 ;
  png_uint_16 tmp___2 ;

  {
#line 1389
  tmp = ilineara((int )in->r, (int )in->a);
#line 1389
  out->r = (int )tmp;
#line 1391
  if (in->g == in->r) {
#line 1393
    out->g = out->r;
#line 1395
    if (in->b == in->r) {
#line 1396
      out->b = out->r;
    } else {
#line 1399
      tmp___0 = ilineara((int )in->b, (int )in->a);
#line 1399
      out->b = (int )tmp___0;
    }
  } else {
#line 1404
    tmp___1 = ilineara((int )in->g, (int )in->a);
#line 1404
    out->g = (int )tmp___1;
#line 1406
    if (in->b == in->r) {
#line 1407
      out->b = out->r;
    } else
#line 1409
    if (in->b == in->g) {
#line 1410
      out->b = out->g;
    } else {
#line 1413
      tmp___2 = ilineara((int )in->b, (int )in->a);
#line 1413
      out->b = (int )tmp___2;
    }
  }
#line 1416
  out->a = (int )(in->a * 257);
#line 1417
  return;
}
}
#line 1420 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gpc_preq(Pixel *out , Pixel const   *in , Background const   *back )
{
  png_uint_16 tmp ;
  png_uint_16 tmp___0 ;
  png_uint_16 tmp___1 ;
  png_uint_16 tmp___2 ;

  {
#line 1425
  tmp = ilineara((int )in->r, (int )in->a);
#line 1425
  out->r = (int )tmp;
#line 1427
  if (in->g == in->r) {
#line 1429
    out->g = out->r;
#line 1431
    if (in->b == in->r) {
#line 1432
      out->b = out->r;
    } else {
#line 1435
      tmp___0 = ilineara((int )in->b, (int )in->a);
#line 1435
      out->b = (int )tmp___0;
    }
  } else {
#line 1440
    tmp___1 = ilineara((int )in->g, (int )in->a);
#line 1440
    out->g = (int )tmp___1;
#line 1442
    if (in->b == in->r) {
#line 1443
      out->b = out->r;
    } else
#line 1445
    if (in->b == in->g) {
#line 1446
      out->b = out->g;
    } else {
#line 1449
      tmp___2 = ilineara((int )in->b, (int )in->a);
#line 1449
      out->b = (int )tmp___2;
    }
  }
#line 1452
  out->a = 65535;
#line 1453
  return;
}
}
#line 1456 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gpc_glin(Pixel *out , Pixel const   *in , Background const   *back )
{
  int tmp ;
  int tmp___0 ;
  png_uint_16 tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  double tmp___4 ;
  png_uint_16 tmp___5 ;

  {
#line 1461
  if (in->r == in->g) {
#line 1461
    if (in->g == in->b) {
#line 1462
      tmp___1 = ilinear((int )in->g);
#line 1462
      tmp___0 = (int )tmp___1;
#line 1462
      out->b = tmp___0;
#line 1462
      tmp = tmp___0;
#line 1462
      out->g = tmp;
#line 1462
      out->r = tmp;
    } else {
#line 1461
      goto _L;
    }
  } else {
    _L: /* CIL Label */
#line 1465
    tmp___4 = YfromRGB(sRGB_to_d[in->r], sRGB_to_d[in->g], sRGB_to_d[in->b]);
#line 1465
    tmp___5 = u16d((double )65535 * tmp___4);
#line 1465
    tmp___3 = (int )tmp___5;
#line 1465
    out->b = tmp___3;
#line 1465
    tmp___2 = tmp___3;
#line 1465
    out->g = tmp___2;
#line 1465
    out->r = tmp___2;
  }
#line 1468
  out->a = 65535;
#line 1469
  return;
}
}
#line 1472 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gpc_gpre(Pixel *out , Pixel const   *in , Background const   *back )
{
  int tmp ;
  int tmp___0 ;
  png_uint_16 tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  double tmp___4 ;
  png_uint_16 tmp___5 ;

  {
#line 1477
  if (in->r == in->g) {
#line 1477
    if (in->g == in->b) {
#line 1478
      tmp___1 = ilineara((int )in->g, (int )in->a);
#line 1478
      tmp___0 = (int )tmp___1;
#line 1478
      out->b = tmp___0;
#line 1478
      tmp = tmp___0;
#line 1478
      out->g = tmp;
#line 1478
      out->r = tmp;
    } else {
#line 1477
      goto _L;
    }
  } else {
    _L: /* CIL Label */
#line 1481
    tmp___4 = YfromRGB(sRGB_to_d[in->r], sRGB_to_d[in->g], sRGB_to_d[in->b]);
#line 1481
    tmp___5 = u16d((double )(in->a * 257) * tmp___4);
#line 1481
    tmp___3 = (int )tmp___5;
#line 1481
    out->b = tmp___3;
#line 1481
    tmp___2 = tmp___3;
#line 1481
    out->g = tmp___2;
#line 1481
    out->r = tmp___2;
  }
#line 1484
  out->a = 257 * (int )in->a;
#line 1485
  return;
}
}
#line 1488 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gpc_gprq(Pixel *out , Pixel const   *in , Background const   *back )
{
  int tmp ;
  int tmp___0 ;
  png_uint_16 tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  double tmp___4 ;
  png_uint_16 tmp___5 ;

  {
#line 1493
  if (in->r == in->g) {
#line 1493
    if (in->g == in->b) {
#line 1494
      tmp___1 = ilineara((int )in->g, (int )in->a);
#line 1494
      tmp___0 = (int )tmp___1;
#line 1494
      out->b = tmp___0;
#line 1494
      tmp = tmp___0;
#line 1494
      out->g = tmp;
#line 1494
      out->r = tmp;
    } else {
#line 1493
      goto _L;
    }
  } else {
    _L: /* CIL Label */
#line 1497
    tmp___4 = YfromRGB(sRGB_to_d[in->r], sRGB_to_d[in->g], sRGB_to_d[in->b]);
#line 1497
    tmp___5 = u16d((double )(in->a * 257) * tmp___4);
#line 1497
    tmp___3 = (int )tmp___5;
#line 1497
    out->b = tmp___3;
#line 1497
    tmp___2 = tmp___3;
#line 1497
    out->g = tmp___2;
#line 1497
    out->r = tmp___2;
  }
#line 1500
  out->a = 65535;
#line 1501
  return;
}
}
#line 1505 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gpc_Lin(Pixel *out , Pixel const   *in , Background const   *back )
{
  png_uint_16 tmp ;
  png_uint_16 tmp___0 ;
  png_uint_16 tmp___1 ;
  png_uint_16 tmp___2 ;

  {
#line 1510
  tmp = ilinear_g22((int )in->r);
#line 1510
  out->r = (int )tmp;
#line 1512
  if (in->g == in->r) {
#line 1514
    out->g = out->r;
#line 1516
    if (in->b == in->r) {
#line 1517
      out->b = out->r;
    } else {
#line 1520
      tmp___0 = ilinear_g22((int )in->b);
#line 1520
      out->b = (int )tmp___0;
    }
  } else {
#line 1525
    tmp___1 = ilinear_g22((int )in->g);
#line 1525
    out->g = (int )tmp___1;
#line 1527
    if (in->b == in->r) {
#line 1528
      out->b = out->r;
    } else
#line 1530
    if (in->b == in->g) {
#line 1531
      out->b = out->g;
    } else {
#line 1534
      tmp___2 = ilinear_g22((int )in->b);
#line 1534
      out->b = (int )tmp___2;
    }
  }
#line 1537
  out->a = 65535;
#line 1538
  return;
}
}
#line 1676 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gpc_sRGB(Pixel *out , Pixel const   *in , Background const   *back )
{
  png_byte tmp ;
  png_byte tmp___0 ;
  png_byte tmp___1 ;
  png_byte tmp___2 ;

  {
#line 1681
  tmp = isRGB((int )in->r);
#line 1681
  out->r = (int )tmp;
#line 1683
  if (in->g == in->r) {
#line 1685
    out->g = out->r;
#line 1687
    if (in->b == in->r) {
#line 1688
      out->b = out->r;
    } else {
#line 1691
      tmp___0 = isRGB((int )in->b);
#line 1691
      out->b = (int )tmp___0;
    }
  } else {
#line 1696
    tmp___1 = isRGB((int )in->g);
#line 1696
    out->g = (int )tmp___1;
#line 1698
    if (in->b == in->r) {
#line 1699
      out->b = out->r;
    } else
#line 1701
    if (in->b == in->g) {
#line 1702
      out->b = out->g;
    } else {
#line 1705
      tmp___2 = isRGB((int )in->b);
#line 1705
      out->b = (int )tmp___2;
    }
  }
#line 1708
  out->a = 255;
#line 1709
  return;
}
}
#line 1712 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gpc_unpg(Pixel *out , Pixel const   *in , Background const   *back )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  png_byte tmp___3 ;
  png_byte tmp___4 ;

  {
#line 1717
  if (in->a <= 128) {
#line 1719
    tmp___0 = 255;
#line 1719
    out->b = tmp___0;
#line 1719
    tmp = tmp___0;
#line 1719
    out->g = tmp;
#line 1719
    out->r = tmp;
#line 1720
    out->a = 0;
  } else {
#line 1725
    tmp___3 = sRGB((double )in->g / (double )in->a);
#line 1725
    tmp___2 = (int )tmp___3;
#line 1725
    out->b = tmp___2;
#line 1725
    tmp___1 = tmp___2;
#line 1725
    out->g = tmp___1;
#line 1725
    out->r = tmp___1;
#line 1726
    tmp___4 = u8d((double )in->a / 257.);
#line 1726
    out->a = (int )tmp___4;
  }
#line 1728
  return;
}
}
#line 1731 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gpc_unpc(Pixel *out , Pixel const   *in , Background const   *back )
{
  int tmp ;
  int tmp___0 ;
  png_byte tmp___1 ;
  png_byte tmp___2 ;
  png_byte tmp___3 ;
  png_byte tmp___4 ;

  {
#line 1736
  if (in->a <= 128) {
#line 1738
    tmp___0 = 255;
#line 1738
    out->b = tmp___0;
#line 1738
    tmp = tmp___0;
#line 1738
    out->g = tmp;
#line 1738
    out->r = tmp;
#line 1739
    out->a = 0;
  } else {
#line 1744
    tmp___1 = sRGB((double )in->r / (double )in->a);
#line 1744
    out->r = (int )tmp___1;
#line 1745
    tmp___2 = sRGB((double )in->g / (double )in->a);
#line 1745
    out->g = (int )tmp___2;
#line 1746
    tmp___3 = sRGB((double )in->b / (double )in->a);
#line 1746
    out->b = (int )tmp___3;
#line 1747
    tmp___4 = u8d((double )in->a / 257.);
#line 1747
    out->a = (int )tmp___4;
  }
#line 1749
  return;
}
}
#line 1752 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gpc_b16g(Pixel *out , Pixel const   *in , Background const   *back )
{
  int tmp ;
  int tmp___0 ;
  double a ;
  double a1 ;
  int tmp___1 ;
  int tmp___2 ;
  png_byte tmp___3 ;

  {
#line 1755
  if (in->a <= 0) {
#line 1756
    tmp___0 = (int )back->ig;
#line 1756
    out->b = tmp___0;
#line 1756
    tmp = tmp___0;
#line 1756
    out->g = tmp;
#line 1756
    out->r = tmp;
  } else {
#line 1760
    a = (double )in->a / 65535.;
#line 1761
    a1 = (double )1 - a;
#line 1763
    a /= (double )65535;
#line 1764
    tmp___3 = sRGB((double )in->g * a + (double )(back->dg * (double )a1));
#line 1764
    tmp___2 = (int )tmp___3;
#line 1764
    out->b = tmp___2;
#line 1764
    tmp___1 = tmp___2;
#line 1764
    out->g = tmp___1;
#line 1764
    out->r = tmp___1;
  }
#line 1767
  out->a = 255;
#line 1768
  return;
}
}
#line 1771 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gpc_b16c(Pixel *out , Pixel const   *in , Background const   *back )
{
  double a ;
  double a1 ;
  png_byte tmp ;
  png_byte tmp___0 ;
  png_byte tmp___1 ;

  {
#line 1774
  if (in->a <= 0) {
#line 1776
    out->r = (int )back->ir;
#line 1777
    out->g = (int )back->ig;
#line 1778
    out->b = (int )back->ib;
  } else {
#line 1783
    a = (double )in->a / 65535.;
#line 1784
    a1 = (double )1 - a;
#line 1786
    a /= (double )65535;
#line 1787
    tmp = sRGB((double )in->r * a + (double )(back->dr * (double )a1));
#line 1787
    out->r = (int )tmp;
#line 1788
    tmp___0 = sRGB((double )in->g * a + (double )(back->dg * (double )a1));
#line 1788
    out->g = (int )tmp___0;
#line 1789
    tmp___1 = sRGB((double )in->b * a + (double )(back->db * (double )a1));
#line 1789
    out->b = (int )tmp___1;
  }
#line 1792
  out->a = 255;
#line 1793
  return;
}
}
#line 1796 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gpc_sG(Pixel *out , Pixel const   *in , Background const   *back )
{
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;
  png_byte tmp___2 ;

  {
#line 1801
  tmp___1 = YfromRGBint((int )in->r, (int )in->g, (int )in->b);
#line 1801
  tmp___2 = sRGB(tmp___1 / (double )65535);
#line 1801
  tmp___0 = (int )tmp___2;
#line 1801
  out->b = tmp___0;
#line 1801
  tmp = tmp___0;
#line 1801
  out->g = tmp;
#line 1801
  out->r = tmp;
#line 1802
  out->a = 255;
#line 1803
  return;
}
}
#line 1806 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gpc_sGp(Pixel *out , Pixel const   *in , Background const   *back )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  png_byte tmp___4 ;
  png_byte tmp___5 ;

  {
#line 1811
  if (in->a <= 128) {
#line 1813
    tmp___0 = 255;
#line 1813
    out->b = tmp___0;
#line 1813
    tmp = tmp___0;
#line 1813
    out->g = tmp;
#line 1813
    out->r = tmp;
#line 1814
    out->a = 0;
  } else {
#line 1819
    tmp___3 = YfromRGBint((int )in->r, (int )in->g, (int )in->b);
#line 1819
    tmp___4 = sRGB(tmp___3 / (double )in->a);
#line 1819
    tmp___2 = (int )tmp___4;
#line 1819
    out->b = tmp___2;
#line 1819
    tmp___1 = tmp___2;
#line 1819
    out->g = tmp___1;
#line 1819
    out->r = tmp___1;
#line 1820
    tmp___5 = u8d((double )in->a / 257.);
#line 1820
    out->a = (int )tmp___5;
  }
#line 1822
  return;
}
}
#line 1825 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gpc_sCp(Pixel *out , Pixel const   *in , Background const   *back )
{
  int tmp ;
  int tmp___0 ;
  png_byte tmp___1 ;
  png_byte tmp___2 ;
  png_byte tmp___3 ;
  png_byte tmp___4 ;

  {
#line 1830
  if (in->a <= 128) {
#line 1832
    tmp___0 = 255;
#line 1832
    out->b = tmp___0;
#line 1832
    tmp = tmp___0;
#line 1832
    out->g = tmp;
#line 1832
    out->r = tmp;
#line 1833
    out->a = 0;
  } else {
#line 1838
    tmp___1 = sRGB((double )in->r / (double )in->a);
#line 1838
    out->r = (int )tmp___1;
#line 1839
    tmp___2 = sRGB((double )in->g / (double )in->a);
#line 1839
    out->g = (int )tmp___2;
#line 1840
    tmp___3 = sRGB((double )in->b / (double )in->a);
#line 1840
    out->b = (int )tmp___3;
#line 1841
    tmp___4 = u8d((double )in->a / 257.);
#line 1841
    out->a = (int )tmp___4;
  }
#line 1843
  return;
}
}
#line 1847 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gpc_gb16(Pixel *out , Pixel const   *in , Background const   *back )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  png_byte tmp___3 ;
  double a ;
  double a1 ;
  int tmp___4 ;
  int tmp___5 ;
  png_byte tmp___6 ;

  {
#line 1850
  if (in->a <= 0) {
#line 1851
    tmp___0 = (int )back->ig;
#line 1851
    out->b = tmp___0;
#line 1851
    tmp = tmp___0;
#line 1851
    out->g = tmp;
#line 1851
    out->r = tmp;
  } else
#line 1853
  if (in->a >= 65535) {
#line 1854
    tmp___3 = isRGB((int )in->g);
#line 1854
    tmp___2 = (int )tmp___3;
#line 1854
    out->b = tmp___2;
#line 1854
    tmp___1 = tmp___2;
#line 1854
    out->g = tmp___1;
#line 1854
    out->r = tmp___1;
  } else {
#line 1858
    a = (double )in->a / 65535.;
#line 1859
    a1 = (double )1 - a;
#line 1861
    a /= (double )65535;
#line 1862
    tmp___6 = sRGB((double )in->g * a + (double )(back->dg * (double )a1));
#line 1862
    tmp___5 = (int )tmp___6;
#line 1862
    out->b = tmp___5;
#line 1862
    tmp___4 = tmp___5;
#line 1862
    out->g = tmp___4;
#line 1862
    out->r = tmp___4;
  }
#line 1865
  out->a = 255;
#line 1866
  return;
}
}
#line 1869 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gpc_cb16(Pixel *out , Pixel const   *in , Background const   *back )
{
  png_byte tmp ;
  png_byte tmp___0 ;
  png_byte tmp___1 ;
  double a ;
  double a1 ;
  png_byte tmp___2 ;
  png_byte tmp___3 ;
  png_byte tmp___4 ;

  {
#line 1872
  if (in->a <= 0) {
#line 1874
    out->r = (int )back->ir;
#line 1875
    out->g = (int )back->ig;
#line 1876
    out->b = (int )back->ib;
  } else
#line 1879
  if (in->a >= 65535) {
#line 1881
    tmp = isRGB((int )in->r);
#line 1881
    out->r = (int )tmp;
#line 1882
    tmp___0 = isRGB((int )in->g);
#line 1882
    out->g = (int )tmp___0;
#line 1883
    tmp___1 = isRGB((int )in->b);
#line 1883
    out->b = (int )tmp___1;
  } else {
#line 1888
    a = (double )in->a / 65535.;
#line 1889
    a1 = (double )1 - a;
#line 1891
    a /= (double )65535;
#line 1892
    tmp___2 = sRGB((double )in->r * a + (double )(back->dr * (double )a1));
#line 1892
    out->r = (int )tmp___2;
#line 1893
    tmp___3 = sRGB((double )in->g * a + (double )(back->dg * (double )a1));
#line 1893
    out->g = (int )tmp___3;
#line 1894
    tmp___4 = sRGB((double )in->b * a + (double )(back->db * (double )a1));
#line 1894
    out->b = (int )tmp___4;
  }
#line 1897
  out->a = 255;
#line 1898
  return;
}
}
#line 1902 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gpc_A(Pixel *out , Pixel const   *in , Background const   *back )
{


  {
#line 1906
  out->r = (int )in->r;
#line 1907
  out->g = (int )in->g;
#line 1908
  out->b = (int )in->b;
#line 1909
  out->a = 65535;
#line 1910
  return;
}
}
#line 1913 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gpc_g16(Pixel *out , Pixel const   *in , Background const   *back )
{
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;
  png_uint_16 tmp___2 ;

  {
#line 1917
  tmp___1 = YfromRGBint((int )in->r, (int )in->g, (int )in->b);
#line 1917
  tmp___2 = u16d(tmp___1);
#line 1917
  tmp___0 = (int )tmp___2;
#line 1917
  out->b = tmp___0;
#line 1917
  tmp = tmp___0;
#line 1917
  out->g = tmp;
#line 1917
  out->r = tmp;
#line 1918
  out->a = 65535;
#line 1919
  return;
}
}
#line 1922 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void gpc_g16q(Pixel *out , Pixel const   *in , Background const   *back )
{
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;
  png_uint_16 tmp___2 ;

  {
#line 1926
  tmp___1 = YfromRGBint((int )in->r, (int )in->g, (int )in->b);
#line 1926
  tmp___2 = u16d(tmp___1);
#line 1926
  tmp___0 = (int )tmp___2;
#line 1926
  out->b = tmp___0;
#line 1926
  tmp = tmp___0;
#line 1926
  out->g = tmp;
#line 1926
  out->r = tmp;
#line 1927
  out->a = (int )in->a;
#line 1928
  return;
}
}
#line 1959 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void (*gpc_fn[8][8])(Pixel *out , Pixel const   *in , Background const   *back )  =
#line 1959
  { {        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_noop),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_noop),        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_noop),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_noop),
            (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_Lin),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_Lin),        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_Lin),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_Lin)},
   {        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_bckg),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_noop),        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_bckc),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_noop),
            (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_preq),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_pre),        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_preq),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_pre)},
   {        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_g8),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_g8),        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_noop),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_noop),
            (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_glin),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_glin),        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_lin),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_lin)},
   {        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_g8b),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_g8),        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_bckc),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_noop),
            (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_gprq),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_gpre),        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_preq),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_pre)},
   {        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_sRGB),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_sRGB),        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_sRGB),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_sRGB),
            (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_noop),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_noop),        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_noop),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_noop)},
   {        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_b16g),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_unpg),        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_b16c),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_unpc),
            (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_A),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_noop),        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_A),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_noop)},
   {        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_sG),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_sG),        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_sRGB),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_sRGB),
            (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_g16),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_g16),        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_noop),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_noop)},
   {        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_gb16),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_sGp),        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_cb16),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_sCp),
            (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_g16),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_g16q),        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_A),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_noop)}};
#line 1976 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void (*gpc_fn_colormapped[8][8])(Pixel *out , Pixel const   *in , Background const   *back )  =
#line 1976
  { {        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_noop),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_noop),        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_noop),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_noop),
            (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_lin),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_lin),        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_lin),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_lin)},
   {        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_bckg),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_noop),        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_bckc),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_noop),
            (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_preq),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_pre),        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_preq),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_pre)},
   {        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_g8),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_g8),        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_noop),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_noop),
            (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_glin),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_glin),        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_lin),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_lin)},
   {        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_g8b),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_g8),        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_bckc),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_noop),
            (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_gprq),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_gpre),        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_preq),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_pre)},
   {        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_sRGB),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_sRGB),        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_sRGB),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_sRGB),
            (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_noop),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_noop),        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_noop),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_noop)},
   {        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_b16g),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_unpg),        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_b16c),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_unpc),
            (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_A),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_noop),        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_A),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_noop)},
   {        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_sG),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_sG),        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_sRGB),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_sRGB),
            (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_g16),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_g16),        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_noop),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_noop)},
   {        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_gb16),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_sGp),        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_cb16),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_sCp),
            (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_g16),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_g16q),        (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))(& gpc_A),        (void (*)(Pixel *out ,
                 Pixel const   *in , Background const   *back ))(& gpc_noop)}};
#line 17 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest-errors.h"
static png_uint_16 gpc_error[16][16][4]  =
#line 17 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest-errors.h"
  { { {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )372,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )372,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )372,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )372,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0}},
   { {          (png_uint_16 )0,          (png_uint_16 )19,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )20,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )897,          (png_uint_16 )788,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )897,          (png_uint_16 )788,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )897,          (png_uint_16 )788,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )897,          (png_uint_16 )788,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0}},
   { {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )19,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )19,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )893,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )893,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )811,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )811,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0}},
   { {          (png_uint_16 )0,          (png_uint_16 )16,          (png_uint_16 )17,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )17,          (png_uint_16 )17,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )19,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )850,          (png_uint_16 )875,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )850,          (png_uint_16 )875,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )897,          (png_uint_16 )788,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )897,          (png_uint_16 )788,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0}},
   { {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )9,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )9,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )9,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )9,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0}},
   { {          (png_uint_16 )0,          (png_uint_16 )74,          (png_uint_16 )9,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )20,          (png_uint_16 )9,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )74,          (png_uint_16 )9,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )20,          (png_uint_16 )9,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )1,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )1,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0}},
   { {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )9,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )9,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )9,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )9,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )4,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )4,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0}},
   { {          (png_uint_16 )0,          (png_uint_16 )126,          (png_uint_16 )143,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )11,          (png_uint_16 )7,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )74,          (png_uint_16 )9,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )17,          (png_uint_16 )9,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )4,          (png_uint_16 )4,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )5,          (png_uint_16 )4,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )1,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0}},
   { {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0}},
   { {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0}},
   { {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )13,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )13,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )9,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )9,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )673,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )673,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )674,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )674,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )1,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )1,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )460,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )460,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )263,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )263,          (png_uint_16 )0}},
   { {          (png_uint_16 )0,          (png_uint_16 )6,          (png_uint_16 )8,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )7,          (png_uint_16 )8,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )75,          (png_uint_16 )9,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )9,          (png_uint_16 )9,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )585,          (png_uint_16 )427,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )585,          (png_uint_16 )427,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )717,          (png_uint_16 )514,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )717,          (png_uint_16 )514,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )1,          (png_uint_16 )1,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )1,          (png_uint_16 )1,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )1,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )13323,          (png_uint_16 )460,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )427,          (png_uint_16 )460,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )16480,          (png_uint_16 )263,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )243,          (png_uint_16 )263,          (png_uint_16 )0}},
   { {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )282,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0}},
   { {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )253,          (png_uint_16 )282,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0}},
   { {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )265,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0}},
   { {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )243,          (png_uint_16 )265,          (png_uint_16 )0}}};
#line 101 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest-errors.h"
static png_uint_16 gpc_error_via_linear[16][4][4]  =
#line 101
  { { {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )7,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )7,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )7,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )7,          (png_uint_16 )0}},
   { {          (png_uint_16 )0,          (png_uint_16 )15,          (png_uint_16 )15,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )186,          (png_uint_16 )15,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )15,          (png_uint_16 )15,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )186,          (png_uint_16 )15,          (png_uint_16 )0}},
   { {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )20,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )20,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )15,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )15,          (png_uint_16 )0}},
   { {          (png_uint_16 )0,          (png_uint_16 )16,          (png_uint_16 )17,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )187,          (png_uint_16 )17,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )15,          (png_uint_16 )15,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )186,          (png_uint_16 )15,          (png_uint_16 )0}},
   { {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )1,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )1,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )1,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )1,          (png_uint_16 )0}},
   { {          (png_uint_16 )0,          (png_uint_16 )1,          (png_uint_16 )1,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )1,          (png_uint_16 )1,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )1,          (png_uint_16 )1,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )1,          (png_uint_16 )1,          (png_uint_16 )0}},
   { {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )1,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )1,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )1,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )1,          (png_uint_16 )0}},
   { {          (png_uint_16 )0,          (png_uint_16 )1,          (png_uint_16 )1,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )9,          (png_uint_16 )1,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )1,          (png_uint_16 )1,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )1,          (png_uint_16 )1,          (png_uint_16 )0}},
   { {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0}},
   { {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0}},
   { {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )13,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )13,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )14,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )14,          (png_uint_16 )0}},
   { {          (png_uint_16 )0,          (png_uint_16 )4,          (png_uint_16 )8,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )9,          (png_uint_16 )8,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )9,          (png_uint_16 )5,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )32,          (png_uint_16 )5,          (png_uint_16 )0}},
   { {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0}},
   { {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0}},
   { {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0}},
   { {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )0}}};
#line 137 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest-errors.h"
static png_uint_16 gpc_error_to_colormap[8][8][4]  =
#line 137
  { { {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )9,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )9,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )9,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )9,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )560,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )560,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )560,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )560,          (png_uint_16 )0}},
   { {          (png_uint_16 )0,          (png_uint_16 )19,          (png_uint_16 )9,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )255,          (png_uint_16 )9,          (png_uint_16 )25},
     {          (png_uint_16 )0,          (png_uint_16 )88,          (png_uint_16 )9,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )255,          (png_uint_16 )9,          (png_uint_16 )25},
     {          (png_uint_16 )0,          (png_uint_16 )1012,          (png_uint_16 )928,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )16026,          (png_uint_16 )928,          (png_uint_16 )6425},
     {          (png_uint_16 )0,          (png_uint_16 )1012,          (png_uint_16 )928,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )16026,          (png_uint_16 )928,          (png_uint_16 )6425}},
   { {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )19,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )19,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )25,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )25,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )962,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )962,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )13677,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )13677,          (png_uint_16 )0}},
   { {          (png_uint_16 )0,          (png_uint_16 )63,          (png_uint_16 )77,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )255,          (png_uint_16 )19,          (png_uint_16 )25},
     {          (png_uint_16 )0,          (png_uint_16 )225,          (png_uint_16 )25,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )255,          (png_uint_16 )25,          (png_uint_16 )67},
     {          (png_uint_16 )0,          (png_uint_16 )17534,          (png_uint_16 )18491,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )15736,          (png_uint_16 )2824,          (png_uint_16 )6425},
     {          (png_uint_16 )0,          (png_uint_16 )14019,          (png_uint_16 )13677,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )50115,          (png_uint_16 )13677,          (png_uint_16 )17219}},
   { {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )73,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )73,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )73,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )73,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )18817,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )18817,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )18817,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )18817,          (png_uint_16 )0}},
   { {          (png_uint_16 )0,          (png_uint_16 )74,          (png_uint_16 )74,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )255,          (png_uint_16 )74,          (png_uint_16 )25},
     {          (png_uint_16 )0,          (png_uint_16 )99,          (png_uint_16 )74,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )255,          (png_uint_16 )74,          (png_uint_16 )25},
     {          (png_uint_16 )0,          (png_uint_16 )18919,          (png_uint_16 )18907,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )24549,          (png_uint_16 )18907,          (png_uint_16 )6553},
     {          (png_uint_16 )0,          (png_uint_16 )18919,          (png_uint_16 )18907,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )24549,          (png_uint_16 )18907,          (png_uint_16 )6553}},
   { {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )73,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )73,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )98,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )98,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )18664,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )18664,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )24998,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )0,          (png_uint_16 )24998,          (png_uint_16 )0}},
   { {          (png_uint_16 )0,          (png_uint_16 )181,          (png_uint_16 )196,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )255,          (png_uint_16 )61,          (png_uint_16 )25},
     {          (png_uint_16 )206,          (png_uint_16 )187,          (png_uint_16 )98,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )255,          (png_uint_16 )98,          (png_uint_16 )67},
     {          (png_uint_16 )0,          (png_uint_16 )18141,          (png_uint_16 )18137,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )17494,          (png_uint_16 )17504,          (png_uint_16 )6553},
     {          (png_uint_16 )0,          (png_uint_16 )24979,          (png_uint_16 )24992,          (png_uint_16 )0},
     {          (png_uint_16 )0,          (png_uint_16 )49172,          (png_uint_16 )24992,          (png_uint_16 )17347}}};
#line 2063 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void transform_from_formats(Transform *result , Image *in_image , Image const   *out_image ,
                                   png_const_colorp background , int via_linear )
{
  png_uint_32 in_format ;
  png_uint_32 out_format ;
  png_uint_32 in_base ;
  png_uint_32 out_base ;
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  double tmp___17 ;
  double tmp___18 ;

  {
#line 2070
  memset((void *)result, 0, sizeof(*result));
#line 2073
  result->in_image = in_image;
#line 2074
  result->out_image = out_image;
#line 2076
  in_format = in_image->image.format;
#line 2077
  out_format = (png_uint_32 )out_image->image.format;
#line 2079
  if (in_format & 0x04U) {
#line 2080
    result->in_opaque = 65535;
  } else {
#line 2082
    result->in_opaque = 255;
  }
#line 2084
  result->output_8bit = (out_format & 0x04U) == 0U;
#line 2086
  result->is_palette = 0;
#line 2087
  result->accumulate = (in_image->opts & 64U) != 0U;
#line 2090
  result->in_gp = get_pixel(in_format);
#line 2091
  result->out_gp = get_pixel(out_format);
#line 2094
  in_format &= 15U;
#line 2095
  in_base = in_format & 7U;
#line 2096
  out_format &= 15U;
#line 2097
  out_base = out_format & 7U;
#line 2099
  if (via_linear) {
#line 2102
    if (out_format & 12U) {
#line 2104
      fprintf(stderr, (char const   *)"internal transform via linear error 0x%x->0x%x\n",
              in_format, out_format);
#line 2106
      exit(1);
    }
#line 2109
    result->transform = (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))gpc_fn[in_base][out_base | 0x04U];
#line 2110
    result->from_linear = (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))gpc_fn[out_base | 0x04U][out_base];
#line 2111
    result->error_ptr = gpc_error_via_linear[in_format][out_format];
  } else
#line 2114
  if ((~ in_format & out_format) & 0x08U) {
#line 2120
    result->transform = (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))gpc_fn[in_base][out_base];
#line 2121
    result->from_linear = (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))((void *)0);
#line 2122
    result->error_ptr = gpc_error_to_colormap[in_base][out_base];
  } else {
#line 2133
    if ((in_format & out_format) & 0x08U) {
#line 2134
      result->transform = (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))gpc_fn_colormapped[in_base][out_base];
    } else {
#line 2136
      result->transform = (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))gpc_fn[in_base][out_base];
    }
#line 2137
    result->from_linear = (void (*)(Pixel *out , Pixel const   *in , Background const   *back ))((void *)0);
#line 2138
    result->error_ptr = gpc_error[in_format][out_format];
  }
#line 2145
  result->background = (Background const   *)((void *)0);
#line 2148
  if ((in_format & ~ out_format) & 0x01U) {
#line 2157
    result->background = (Background const   *)(& result->background_color);
#line 2159
    if (out_format & 0x04U) {
#line 2159
      goto _L;
    } else
#line 2159
    if (via_linear) {
      _L: /* CIL Label */
#line 2161
      if (out_format & 0x08U) {
#line 2163
        tmp___0 = 0;
#line 2163
        result->background_color.ib = tmp___0;
#line 2163
        tmp = tmp___0;
#line 2163
        result->background_color.ig = tmp;
#line 2163
        result->background_color.ir = tmp;
#line 2166
        tmp___2 = (double )0;
#line 2166
        result->background_color.db = tmp___2;
#line 2166
        tmp___1 = tmp___2;
#line 2166
        result->background_color.dg = tmp___1;
#line 2166
        result->background_color.dr = tmp___1;
      } else {
#line 2173
        tmp___4 = 18761;
#line 2173
        result->background_color.ib = tmp___4;
#line 2173
        tmp___3 = tmp___4;
#line 2173
        result->background_color.ig = tmp___3;
#line 2173
        result->background_color.ir = tmp___3;
#line 2176
        tmp___6 = (double )0;
#line 2176
        result->background_color.db = tmp___6;
#line 2176
        tmp___5 = tmp___6;
#line 2176
        result->background_color.dg = tmp___5;
#line 2176
        result->background_color.dr = tmp___5;
      }
    } else
#line 2184
    if ((unsigned long )background != (unsigned long )((void *)0)) {
#line 2186
      if (out_format & 0x02U) {
#line 2188
        result->background_color.ir = (int )background->red;
#line 2189
        result->background_color.ig = (int )background->green;
#line 2190
        result->background_color.ib = (int )background->blue;
#line 2194
        result->background_color.dr = sRGB_to_d[background->red];
#line 2195
        result->background_color.dg = sRGB_to_d[background->green];
#line 2196
        result->background_color.db = sRGB_to_d[background->blue];
      } else {
#line 2201
        tmp___8 = (int )background->green;
#line 2201
        result->background_color.ib = tmp___8;
#line 2201
        tmp___7 = tmp___8;
#line 2201
        result->background_color.ig = tmp___7;
#line 2201
        result->background_color.ir = tmp___7;
#line 2207
        tmp___10 = sRGB_to_d[background->green];
#line 2207
        result->background_color.db = tmp___10;
#line 2207
        tmp___9 = tmp___10;
#line 2207
        result->background_color.dg = tmp___9;
#line 2207
        result->background_color.dr = tmp___9;
      }
    } else
#line 2213
    if ((out_format & 0x08U) == 0U) {
#line 2215
      tmp___12 = 73;
#line 2215
      result->background_color.ib = tmp___12;
#line 2215
      tmp___11 = tmp___12;
#line 2215
      result->background_color.ig = tmp___11;
#line 2215
      result->background_color.ir = tmp___11;
#line 2221
      tmp___14 = sRGB_to_d[73];
#line 2221
      result->background_color.db = tmp___14;
#line 2221
      tmp___13 = tmp___14;
#line 2221
      result->background_color.dg = tmp___13;
#line 2221
      result->background_color.dr = tmp___13;
    } else {
#line 2231
      result->background = (Background const   *)((void *)0);
    }
  }
#line 2235
  if ((unsigned long )result->background == (unsigned long )((void *)0)) {
#line 2237
    tmp___16 = -1;
#line 2237
    result->background_color.ib = tmp___16;
#line 2237
    tmp___15 = tmp___16;
#line 2237
    result->background_color.ig = tmp___15;
#line 2237
    result->background_color.ir = tmp___15;
#line 2240
    tmp___18 = 1E30;
#line 2240
    result->background_color.db = tmp___18;
#line 2240
    tmp___17 = tmp___18;
#line 2240
    result->background_color.dg = tmp___17;
#line 2240
    result->background_color.dr = tmp___17;
  }
#line 2247
  result->error[0] = *(result->error_ptr + 0);
#line 2248
  result->error[1] = *(result->error_ptr + 1);
#line 2249
  result->error[2] = *(result->error_ptr + 2);
#line 2250
  result->error[3] = *(result->error_ptr + 3);
#line 2251
  return;
}
}
#line 2316 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static void print_pixel(char *string , Pixel const   *pixel , png_uint_32 format )
{


  {
  {
#line 2321
  if ((format & 3U) == 0U) {
#line 2321
    goto case_0;
  }
#line 2325
  if ((format & 3U) == 0x01U) {
#line 2325
    goto case_1;
  }
#line 2330
  if ((format & 3U) == 0x02U) {
#line 2330
    goto case_2;
  }
#line 2335
  if ((format & 3U) == 3U) {
#line 2335
    goto case_3;
  }
#line 2340
  goto switch_default;
  case_0: /* CIL Label */
#line 2322
  sprintf((char *)string, (char const   *)"%s(%d)", format_names[format], pixel->g);
#line 2323
  goto switch_break;
  case_1: /* CIL Label */
#line 2326
  sprintf((char *)string, (char const   *)"%s(%d,%d)", format_names[format], pixel->g,
          pixel->a);
#line 2328
  goto switch_break;
  case_2: /* CIL Label */
#line 2331
  sprintf((char *)string, (char const   *)"%s(%d,%d,%d)", format_names[format], pixel->r,
          pixel->g, pixel->b);
#line 2333
  goto switch_break;
  case_3: /* CIL Label */
#line 2336
  sprintf((char *)string, (char const   *)"%s(%d,%d,%d,%d)", format_names[format],
          pixel->r, pixel->g, pixel->b, pixel->a);
#line 2338
  goto switch_break;
  switch_default: /* CIL Label */
#line 2341
  sprintf((char *)string, (char const   *)"invalid-format");
#line 2342
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2344
  return;
}
}
#line 2346 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static int logpixel(Transform const   *transform , png_uint_32 x , png_uint_32 y ,
                    Pixel const   *in , Pixel const   *calc , Pixel const   *out ,
                    char const   *reason )
{
  png_uint_32 in_format ;
  png_uint_32 out_format ;
  png_uint_32 back_format ;
  char const   *via_linear ;
  char pixel_in[64] ;
  char pixel_calc[64] ;
  char pixel_out[64] ;
  char pixel_loc[64] ;
  char background_info[100] ;
  Pixel back ;
  char pixel_back[64] ;
  char error_buffer[512] ;
  int tmp ;
  char error_buffer___0[512] ;
  int tmp___0 ;

  {
#line 2350
  in_format = (transform->in_image)->image.format;
#line 2351
  out_format = (png_uint_32 )(transform->out_image)->image.format;
#line 2353
  back_format = out_format & 4294967294U;
#line 2354
  via_linear = (char const   *)"";
#line 2359
  print_pixel((char *)(pixel_in), in, in_format);
#line 2360
  print_pixel((char *)(pixel_calc), calc, out_format);
#line 2361
  print_pixel((char *)(pixel_out), out, out_format);
#line 2363
  if (transform->is_palette) {
#line 2364
    sprintf(pixel_loc, (char const   *)"palette: %lu", (unsigned long )y);
  } else {
#line 2366
    sprintf(pixel_loc, (char const   *)"%lu,%lu", (unsigned long )x, (unsigned long )y);
  }
#line 2368
  if ((unsigned long )transform->from_linear != (unsigned long )((void *)0)) {
#line 2370
    via_linear = (char const   *)" (via linear)";
#line 2375
    back_format |= 0x04U;
  }
#line 2378
  if ((unsigned long )transform->background != (unsigned long )((void *)0)) {
#line 2383
    back.r = (int )(transform->background)->ir;
#line 2384
    back.g = (int )(transform->background)->ig;
#line 2385
    back.b = (int )(transform->background)->ib;
#line 2386
    back.a = -1;
#line 2388
    print_pixel((char *)(pixel_back), (Pixel const   *)(& back), back_format);
#line 2389
    sprintf(background_info, (char const   *)" on background %s", pixel_back);
  } else {
#line 2393
    background_info[0] = (char)0;
  }
#line 2395
  if ((unsigned long )(transform->in_image)->file_name != (unsigned long )(transform->out_image)->file_name) {
#line 2398
    sprintf(error_buffer, (char const   *)"(%s) %s error%s:\n %s%s ->\n       %s\n  not: %s.\nUse --preserve and examine: ",
            pixel_loc, reason, via_linear, pixel_in, background_info, pixel_out, pixel_calc);
#line 2402
    tmp = logerror((Image *)transform->in_image, (transform->in_image)->file_name,
                   (char const   *)(error_buffer), (char const   *)(transform->out_image)->file_name);
#line 2402
    return (tmp);
  } else {
#line 2409
    sprintf(error_buffer___0, (char const   *)"(%s) %s error%s:\n %s%s ->\n       %s\n  not: %s.\n The error happened when reading the original file with this format.",
            pixel_loc, reason, via_linear, pixel_in, background_info, pixel_out, pixel_calc);
#line 2414
    tmp___0 = logerror((Image *)transform->in_image, (transform->in_image)->file_name,
                       (char const   *)(error_buffer___0), (char const   *)"");
#line 2414
    return (tmp___0);
  }
}
}
#line 2419 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static int cmppixel(Transform *transform , png_const_voidp in , png_const_voidp out ,
                    png_uint_32 x , png_uint_32 y )
{
  int maxerr ;
  png_const_charp errmsg ;
  Pixel pixel_in ;
  Pixel pixel_calc ;
  Pixel pixel_out ;
  int err_a ;
  int tmp ;
  int err_r ;
  int tmp___0 ;
  int err_g ;
  int tmp___1 ;
  int err_b ;
  int tmp___2 ;
  int limit ;
  int tmp___3 ;

  {
#line 2427
  (*(transform->in_gp))(& pixel_in, in);
#line 2429
  if ((unsigned long )transform->from_linear == (unsigned long )((void *)0)) {
#line 2430
    (*(transform->transform))(& pixel_calc, (Pixel const   *)(& pixel_in), transform->background);
  } else {
#line 2434
    (*(transform->transform))(& pixel_out, (Pixel const   *)(& pixel_in), transform->background);
#line 2435
    (*(transform->from_linear))(& pixel_calc, (Pixel const   *)(& pixel_out), (Background const   *)((void *)0));
  }
#line 2438
  (*(transform->out_gp))(& pixel_out, out);
#line 2441
  if (pixel_calc.a == pixel_out.a) {
#line 2441
    if (pixel_calc.r == pixel_out.r) {
#line 2441
      if (pixel_calc.g == pixel_out.g) {
#line 2441
        if (pixel_calc.b == pixel_out.b) {
#line 2443
          return (1);
        }
      }
    }
  }
#line 2449
  if (transform->output_8bit) {
#line 2449
    if (pixel_calc.a == 0) {
#line 2449
      if (pixel_out.a == 0) {
#line 2450
        return (1);
      }
    }
  }
#line 2455
  errmsg = (png_const_charp )((void *)0);
#line 2457
  tmp = abs(pixel_calc.a - pixel_out.a);
#line 2457
  err_a = tmp;
#line 2459
  if (err_a > (int )transform->error[3]) {
#line 2462
    if (transform->accumulate) {
#line 2463
      transform->error[3] = (png_uint_16 )err_a;
    } else {
#line 2466
      errmsg = (png_const_charp )"alpha";
    }
  }
#line 2473
  if ((unsigned long )errmsg == (unsigned long )((void *)0)) {
#line 2473
    if (transform->output_8bit) {
#line 2473
      if (pixel_calc.a == 0) {
#line 2475
        return (1);
      } else
#line 2473
      if (pixel_out.a == 0) {
#line 2475
        return (1);
      }
    }
  }
#line 2477
  if ((unsigned long )errmsg == (unsigned long )((void *)0)) {
#line 2479
    tmp___0 = abs(pixel_calc.r - pixel_out.r);
#line 2479
    err_r = tmp___0;
#line 2480
    tmp___1 = abs(pixel_calc.g - pixel_out.g);
#line 2480
    err_g = tmp___1;
#line 2481
    tmp___2 = abs(pixel_calc.b - pixel_out.b);
#line 2481
    err_b = tmp___2;
#line 2484
    if (((err_r | err_g) | err_b) == 0) {
#line 2485
      return (1);
    }
#line 2488
    if (pixel_in.a >= transform->in_opaque) {
#line 2490
      errmsg = (png_const_charp )"opaque component";
#line 2491
      limit = 2;
    } else
#line 2494
    if (pixel_in.a > 0) {
#line 2496
      errmsg = (png_const_charp )"alpha component";
#line 2497
      limit = 1;
    } else {
#line 2502
      errmsg = (png_const_charp )"transparent component (background)";
#line 2503
      limit = 0;
    }
#line 2506
    maxerr = err_r;
#line 2507
    if (maxerr < err_g) {
#line 2507
      maxerr = err_g;
    }
#line 2508
    if (maxerr < err_b) {
#line 2508
      maxerr = err_b;
    }
#line 2510
    if (maxerr <= (int )transform->error[limit]) {
#line 2511
      return (1);
    }
#line 2516
    if (transform->accumulate) {
#line 2518
      transform->error[limit] = (png_uint_16 )maxerr;
#line 2519
      return (1);
    }
  }
#line 2524
  tmp___3 = logpixel((Transform const   *)transform, x, y, (Pixel const   *)(& pixel_in),
                     (Pixel const   *)(& pixel_calc), (Pixel const   *)(& pixel_out),
                     errmsg);
#line 2524
  return (tmp___3);
}
}
#line 2527 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static png_byte component_loc(png_byte *loc , png_uint_32 format )
{
  png_byte channels ;
  png_byte tmp ;
  png_byte tmp___0 ;

  {
#line 2544
  if (format & 0x02U) {
#line 2546
    channels = (png_byte )3;
#line 2548
    *(loc + 2) = (png_byte )1;
#line 2551
    if (format & 0x10U) {
#line 2553
      *(loc + 1) = (png_byte )2;
#line 2554
      *(loc + 3) = (png_byte )0;
    } else {
#line 2560
      *(loc + 1) = (png_byte )0;
#line 2561
      *(loc + 3) = (png_byte )2;
    }
  } else {
#line 2567
    channels = (png_byte )1;
#line 2568
    tmp___0 = (png_byte )0;
#line 2568
    *(loc + 3) = tmp___0;
#line 2568
    tmp = tmp___0;
#line 2568
    *(loc + 2) = tmp;
#line 2568
    *(loc + 1) = tmp;
  }
#line 2571
  if (format & 0x01U) {
#line 2574
    if (format & 0x20U) {
#line 2576
      *(loc + 0) = (png_byte )0;
#line 2577
      *(loc + 1) = (png_byte )((int )*(loc + 1) + 1);
#line 2578
      *(loc + 2) = (png_byte )((int )*(loc + 2) + 1);
#line 2579
      *(loc + 3) = (png_byte )((int )*(loc + 3) + 1);
    } else {
#line 2584
      *(loc + 0) = channels;
    }
#line 2586
    channels = (png_byte )((int )channels + 1);
  } else {
#line 2590
    *(loc + 0) = (png_byte )4;
  }
#line 2592
  return (channels);
}
}
#line 2598 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static int compare_two_images(Image *a , Image *b , int via_linear , png_const_colorp background )
{
  ptrdiff_t stridea ;
  ptrdiff_t strideb ;
  png_const_bytep rowa ;
  png_const_bytep rowb ;
  png_uint_32 width ;
  png_uint_32 height ;
  png_uint_32 formata ;
  png_uint_32 formatb ;
  unsigned int a_sample ;
  unsigned int b_sample ;
  int alpha_added ;
  int alpha_removed ;
  int bchannels ;
  png_uint_32 y ;
  Transform tr ;
  int btoa[4] ;
  int tmp ;
  png_const_bytep ppa ;
  png_const_bytep ppb ;
  int match ;
  png_byte in_use[256] ;
  png_byte amax ;
  png_byte bmax ;
  png_uint_32 x ;
  png_byte bval ;
  png_byte aval ;
  png_const_bytep a_cmap ;
  png_const_bytep b_cmap ;
  int result ;
  char pindex[16] ;
  char pindex___0[16] ;
  int tmp___0 ;
  char pindex___1[43] ;
  int tmp___1 ;
  char pindex___2[43] ;
  int tmp___2 ;
  png_uint_32 alpha_changed ;
  int i ;
  png_byte aloc[4] ;
  png_byte bloc[4] ;
  png_byte tmp___3 ;
  png_const_bytep ppa___0 ;
  png_const_bytep ppb___0 ;
  png_uint_32 x___0 ;
  png_const_bytep psa ;
  png_const_bytep psb ;
  png_const_bytep tmp___4 ;
  png_const_bytep tmp___5 ;
  png_const_uint_16p pua ;
  png_const_uint_16p pub ;
  int tmp___6 ;

  {
#line 2602
  stridea = a->stride;
#line 2603
  strideb = b->stride;
#line 2604
  rowa = (png_const_bytep )(a->buffer + 16);
#line 2605
  rowb = (png_const_bytep )(b->buffer + 16);
#line 2606
  width = a->image.width;
#line 2607
  height = a->image.height;
#line 2608
  formata = a->image.format;
#line 2609
  formatb = b->image.format;
#line 2610
  a_sample = ((formata & 3U) + 1U) * (((formata & 0x04U) >> 2) + 1U);
#line 2611
  b_sample = ((formatb & 3U) + 1U) * (((formatb & 0x04U) >> 2) + 1U);
#line 2616
  btoa[0] = 0;
#line 2616
  btoa[1] = 0;
#line 2616
  btoa[2] = 0;
#line 2616
  btoa[3] = 0;
#line 2619
  if (width != b->image.width) {
#line 2620
    tmp = logerror(a, a->file_name, (char const   *)": width x height changed: ",
                   b->file_name);
#line 2620
    return (tmp);
  } else
#line 2619
  if (height != b->image.height) {
#line 2620
    tmp = logerror(a, a->file_name, (char const   *)": width x height changed: ",
                   b->file_name);
#line 2620
    return (tmp);
  }
#line 2624
  transform_from_formats(& tr, a, (Image const   *)b, background, via_linear);
#line 2627
  if (! (formata & 0x08U)) {
#line 2627
    if (formata & 0x04U) {
#line 2629
      stridea *= 2L;
    }
  }
#line 2631
  if (! (formatb & 0x08U)) {
#line 2631
    if (formatb & 0x04U) {
#line 2633
      strideb *= 2L;
    }
  }
#line 2635
  if (stridea < 0L) {
#line 2635
    rowa += (ptrdiff_t )(height - 1U) * - stridea;
  }
#line 2636
  if (strideb < 0L) {
#line 2636
    rowb += (ptrdiff_t )(height - 1U) * - strideb;
  }
#line 2643
  if ((formata & formatb) & 0x08U) {
#line 2648
    amax = (png_byte )0;
#line 2648
    bmax = (png_byte )0;
#line 2650
    memset((void *)(in_use), 0, sizeof(in_use));
#line 2652
    ppa = rowa;
#line 2653
    ppb = rowb;
#line 2659
    y = (png_uint_32 )0;
#line 2659
    match = 1;
    {
#line 2659
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2659
      if (y < height) {
#line 2659
        if (! match) {
#line 2659
          goto while_break;
        }
      } else {
#line 2659
        goto while_break;
      }
#line 2663
      x = (png_uint_32 )0;
      {
#line 2663
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2663
        if (! (x < width)) {
#line 2663
          goto while_break___0;
        }
#line 2665
        bval = (png_byte )*(ppb + x);
#line 2666
        aval = (png_byte )*(ppa + x);
#line 2668
        if ((int )bval > (int )bmax) {
#line 2669
          bmax = bval;
        }
#line 2671
        if ((int )bval != (int )aval) {
#line 2672
          match = 0;
        }
#line 2674
        in_use[aval] = (png_byte )1;
#line 2675
        if ((int )aval > (int )amax) {
#line 2676
          amax = aval;
        }
#line 2663
        x ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2659
      y ++;
#line 2659
      ppa += stridea;
#line 2659
      ppb += strideb;
    }
    while_break: /* CIL Label */ ;
    }
#line 2681
    if (match) {
#line 2686
      a_cmap = (png_const_bytep )(a->colormap);
#line 2687
      b_cmap = (png_const_bytep )(b->colormap);
#line 2688
      result = 1;
#line 2691
      tr.is_palette = 1;
#line 2693
      y = (png_uint_32 )0;
      {
#line 2693
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2693
        if (! (y < 256U)) {
#line 2693
          goto while_break___1;
        }
#line 2694
        if (in_use[y]) {
#line 2701
          if (y >= a->image.colormap_entries) {
#line 2703
            if ((a->opts & 64U) == 0U) {
#line 2706
              sprintf(pindex, (char const   *)"%lu[%lu]", (unsigned long )y, (unsigned long )a->image.colormap_entries);
#line 2708
              logerror(a, a->file_name, (char const   *)": bad pixel index: ", (char const   *)(pindex));
            }
#line 2710
            result = 0;
          } else
#line 2713
          if (y >= b->image.colormap_entries) {
#line 2715
            if ((b->opts & 64U) == 0U) {
#line 2718
              sprintf(pindex___0, (char const   *)"%lu[%lu]", (unsigned long )y, (unsigned long )b->image.colormap_entries);
#line 2720
              logerror(b, b->file_name, (char const   *)": bad pixel index: ", (char const   *)(pindex___0));
            }
#line 2722
            result = 0;
          } else {
#line 2726
            tmp___0 = cmppixel(& tr, (png_const_voidp )a_cmap, (png_const_voidp )b_cmap,
                               (png_uint_32 )0, y);
#line 2726
            if (! tmp___0) {
#line 2727
              result = 0;
            }
          }
        }
#line 2693
        y ++;
#line 2693
        a_cmap += a_sample;
#line 2693
        b_cmap += b_sample;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2731
      if (a->opts & 64U) {
#line 2733
        *(tr.error_ptr + 0) = tr.error[0];
#line 2734
        *(tr.error_ptr + 1) = tr.error[1];
#line 2735
        *(tr.error_ptr + 2) = tr.error[2];
#line 2736
        *(tr.error_ptr + 3) = tr.error[3];
#line 2737
        result = 1;
      }
#line 2740
      return (result);
    } else
#line 2747
    if ((a->opts & 64U) == 0U) {
#line 2757
      if ((png_uint_32 )amax >= a->image.colormap_entries) {
#line 2760
        sprintf(pindex___1, (char const   *)"%d[%u]", (int )amax, (int )((png_byte )a->image.colormap_entries));
#line 2762
        tmp___1 = logerror(a, a->file_name, (char const   *)": bad pixel index: ",
                           (char const   *)(pindex___1));
#line 2762
        return (tmp___1);
      } else
#line 2765
      if ((png_uint_32 )bmax >= b->image.colormap_entries) {
#line 2768
        sprintf(pindex___2, (char const   *)"%d[%u]", (int )bmax, (int )((png_byte )b->image.colormap_entries));
#line 2770
        tmp___2 = logerror(b, b->file_name, (char const   *)": bad pixel index: ",
                           (char const   *)(pindex___2));
#line 2770
        return (tmp___2);
      }
    }
  }
#line 2790
  if (! (((formata ^ formatb) & 0x04U) | ((formata & (formatb ^ 0x02U)) & 0x02U))) {
#line 2794
    alpha_changed = (formata ^ formatb) & 0x01U;
#line 2799
    alpha_removed = (formata & alpha_changed) != 0U;
#line 2802
    alpha_added = (formatb & alpha_changed) != 0U;
#line 2820
    component_loc((png_byte *)(aloc), formata);
#line 2821
    tmp___3 = component_loc((png_byte *)(bloc), formatb);
#line 2821
    bchannels = (int )tmp___3;
#line 2824
    i = 0;
    {
#line 2824
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2824
      if (! (i < 4)) {
#line 2824
        goto while_break___2;
      }
#line 2826
      if ((int )bloc[i] < 4) {
#line 2827
        btoa[bloc[i]] = (int )aloc[i];
      }
#line 2824
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2830
    if (alpha_added) {
#line 2831
      alpha_added = (int )bloc[0];
    } else {
#line 2834
      alpha_added = 4;
    }
#line 2836
    if (alpha_removed) {
#line 2837
      alpha_removed = (int )aloc[0];
    } else {
#line 2840
      alpha_removed = 4;
    }
  } else {
#line 2849
    bchannels = 0;
#line 2850
    alpha_added = 4;
#line 2850
    alpha_removed = alpha_added;
#line 2851
    btoa[0] = 4;
#line 2851
    btoa[1] = btoa[0];
#line 2851
    btoa[2] = btoa[1];
#line 2851
    btoa[3] = btoa[2];
  }
#line 2854
  y = (png_uint_32 )0;
  {
#line 2854
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2854
    if (! (y < height)) {
#line 2854
      goto while_break___3;
    }
#line 2859
    x___0 = (png_uint_32 )0;
#line 2859
    ppa___0 = rowa;
#line 2859
    ppb___0 = rowb;
    {
#line 2859
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2859
      if (! (x___0 < width)) {
#line 2859
        goto while_break___4;
      }
#line 2863
      if (formata & 0x08U) {
#line 2864
        tmp___4 = ppa___0;
#line 2864
        ppa___0 ++;
#line 2864
        psa = (png_const_bytep )(a->colormap) + a_sample * (unsigned int )*tmp___4;
      } else {
#line 2866
        psa = ppa___0;
#line 2866
        ppa___0 += a_sample;
      }
#line 2868
      if (formatb & 0x08U) {
#line 2869
        tmp___5 = ppb___0;
#line 2869
        ppb___0 ++;
#line 2869
        psb = (png_const_bytep )(b->colormap) + b_sample * (unsigned int )*tmp___5;
      } else {
#line 2871
        psb = ppb___0;
#line 2871
        ppb___0 += b_sample;
      }
#line 2874
      if (bchannels) {
#line 2882
        if (formatb & 0x04U) {
#line 2884
          pua = (png_const_uint_16p )((void const   *)psa);
#line 2885
          pub = (png_const_uint_16p )((void const   *)psb);
          {
#line 2889
          if (bchannels == 4) {
#line 2889
            goto case_4;
          }
#line 2892
          if (bchannels == 3) {
#line 2892
            goto case_3;
          }
#line 2895
          if (bchannels == 2) {
#line 2895
            goto case_2;
          }
#line 2898
          if (bchannels == 1) {
#line 2898
            goto case_1;
          }
#line 2902
          goto switch_default;
          case_4: /* CIL Label */
#line 2890
          if ((int const   )*(pua + btoa[3]) != (int const   )*(pub + 3)) {
#line 2890
            goto switch_break;
          }
          case_3: /* CIL Label */
#line 2893
          if ((int const   )*(pua + btoa[2]) != (int const   )*(pub + 2)) {
#line 2893
            goto switch_break;
          }
          case_2: /* CIL Label */
#line 2896
          if ((int const   )*(pua + btoa[1]) != (int const   )*(pub + 1)) {
#line 2896
            goto switch_break;
          }
          case_1: /* CIL Label */
#line 2899
          if ((int const   )*(pua + btoa[0]) != (int const   )*(pub + 0)) {
#line 2899
            goto switch_break;
          }
#line 2900
          if (alpha_added != 4) {
#line 2900
            if ((int const   )*(pub + alpha_added) != 65535) {
#line 2900
              goto switch_break;
            }
          }
#line 2901
          goto __Cont;
          switch_default: /* CIL Label */
#line 2903
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        } else
#line 2907
        if (alpha_removed == 4) {
#line 2907
          goto _L;
        } else
#line 2907
        if ((int const   )*(psa + alpha_removed) == 255) {
          _L: /* CIL Label */
          {
#line 2911
          if (bchannels == 4) {
#line 2911
            goto case_4___0;
          }
#line 2914
          if (bchannels == 3) {
#line 2914
            goto case_3___0;
          }
#line 2917
          if (bchannels == 2) {
#line 2917
            goto case_2___0;
          }
#line 2920
          if (bchannels == 1) {
#line 2920
            goto case_1___0;
          }
#line 2924
          goto switch_default___0;
          case_4___0: /* CIL Label */
#line 2912
          if ((int const   )*(psa + btoa[3]) != (int const   )*(psb + 3)) {
#line 2912
            goto switch_break___0;
          }
          case_3___0: /* CIL Label */
#line 2915
          if ((int const   )*(psa + btoa[2]) != (int const   )*(psb + 2)) {
#line 2915
            goto switch_break___0;
          }
          case_2___0: /* CIL Label */
#line 2918
          if ((int const   )*(psa + btoa[1]) != (int const   )*(psb + 1)) {
#line 2918
            goto switch_break___0;
          }
          case_1___0: /* CIL Label */
#line 2921
          if ((int const   )*(psa + btoa[0]) != (int const   )*(psb + 0)) {
#line 2921
            goto switch_break___0;
          }
#line 2922
          if (alpha_added != 4) {
#line 2922
            if ((int const   )*(psb + alpha_added) != 255) {
#line 2922
              goto switch_break___0;
            }
          }
#line 2923
          goto __Cont;
          switch_default___0: /* CIL Label */
#line 2925
          goto switch_break___0;
          switch_break___0: /* CIL Label */ ;
          }
        }
      }
#line 2933
      tmp___6 = cmppixel(& tr, (png_const_voidp )psa, (png_const_voidp )psb, x___0,
                         y);
#line 2933
      if (! tmp___6) {
#line 2933
        if ((a->opts & 32U) == 0U) {
#line 2934
          return (0);
        }
      }
      __Cont: /* CIL Label */
#line 2859
      x___0 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 2854
    y ++;
#line 2854
    rowa += stridea;
#line 2854
    rowb += strideb;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2939
  if (a->opts & 64U) {
#line 2941
    *(tr.error_ptr + 0) = tr.error[0];
#line 2942
    *(tr.error_ptr + 1) = tr.error[1];
#line 2943
    *(tr.error_ptr + 2) = tr.error[2];
#line 2944
    *(tr.error_ptr + 3) = tr.error[3];
  }
#line 2947
  return (1);
}
}
#line 2953 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static int read_file(Image *image , png_uint_32 format , png_const_colorp background )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int result ;
  png_uint_32 image_format ;
  char const   *tmp___5 ;
  unsigned int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 2956
  memset((void *)(& image->image), 0, sizeof(image->image));
#line 2957
  image->image.version = (png_uint_32 )1;
#line 2959
  if ((unsigned long )image->input_memory != (unsigned long )((void *)0)) {
#line 2961
    tmp___0 = png_image_begin_read_from_memory(& image->image, (png_const_voidp )image->input_memory,
                                               image->input_memory_size);
#line 2961
    if (! tmp___0) {
#line 2963
      tmp = logerror(image, (char const   *)"memory init: ", image->file_name, (char const   *)"");
#line 2963
      return (tmp);
    }
  } else
#line 2967
  if ((unsigned long )image->input_file != (unsigned long )((void *)0)) {
#line 2969
    tmp___2 = png_image_begin_read_from_stdio(& image->image, image->input_file);
#line 2969
    if (! tmp___2) {
#line 2970
      tmp___1 = logerror(image, (char const   *)"stdio init: ", image->file_name,
                         (char const   *)"");
#line 2970
      return (tmp___1);
    }
  } else {
#line 2975
    tmp___4 = png_image_begin_read_from_file(& image->image, image->file_name);
#line 2975
    if (! tmp___4) {
#line 2976
      tmp___3 = logerror(image, (char const   *)"file init: ", image->file_name, (char const   *)"");
#line 2976
      return (tmp___3);
    }
  }
#line 2987
  if (image->opts & 256U) {
#line 2988
    image->image.flags |= 4U;
  }
#line 2998
  image_format = image->image.format;
#line 3000
  if (image->opts & 8U) {
#line 3002
    if ((format & 0x80000000) != 0U) {
#line 3002
      tmp___5 = (char const   *)"no change";
    } else
#line 3002
    if (image->image.format == format) {
#line 3002
      tmp___5 = (char const   *)"no change";
    } else {
#line 3002
      tmp___5 = (char const   *)format_names[format & 63U];
    }
#line 3002
    printf((char const   *)"%s %lu x %lu %s -> %s", image->file_name, (unsigned long )image->image.width,
           (unsigned long )image->image.height, format_names[image_format & 63U],
           tmp___5);
#line 3009
    if ((unsigned long )background != (unsigned long )((void *)0)) {
#line 3010
      printf((char const   *)" background(%d,%d,%d)\n", (int )background->red, (int )background->green,
             (int )background->blue);
    } else {
#line 3013
      printf((char const   *)"\n");
    }
#line 3015
    fflush(stdout);
  }
#line 3022
  if ((format & 0x80000000) != 0U) {
#line 3024
    if ((format & 0x08U) != 0U) {
#line 3024
      if ((image_format & 0x08U) != 0U) {
#line 3026
        format = (image_format & 4294967288U) | (format & 7U);
      } else {
#line 3029
        format = image_format;
      }
    } else {
#line 3029
      format = image_format;
    }
  }
#line 3032
  image->image.format = format;
#line 3034
  if (image->image.format & 0x08U) {
#line 3034
    tmp___6 = 1U;
  } else {
#line 3034
    tmp___6 = (image->image.format & 3U) + 1U;
  }
#line 3034
  image->stride = (ptrdiff_t )(tmp___6 * image->image.width + (unsigned int )image->stride_extra);
#line 3035
  allocbuffer(image);
#line 3037
  result = png_image_finish_read(& image->image, background, (void *)(image->buffer + 16),
                                 (png_int_32 )image->stride, (void *)(image->colormap));
#line 3040
  checkbuffer(image, image->file_name);
#line 3042
  if (result) {
#line 3043
    tmp___7 = checkopaque(image);
#line 3043
    return (tmp___7);
  } else {
#line 3046
    tmp___8 = logerror(image, image->file_name, (char const   *)": image read failed",
                       (char const   *)"");
#line 3046
    return (tmp___8);
  }
}
}
#line 3054 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static int read_one_file(Image *image )
{
  FILE *f ;
  FILE *tmp ;
  long cb ;
  long tmp___0 ;
  png_bytep b ;
  void *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 3057
  if (! (image->opts & 1U)) {
#line 3057
    goto _L;
  } else
#line 3057
  if (image->opts & 2U) {
    _L: /* CIL Label */
#line 3060
    tmp = fopen((char const   * __restrict  )image->file_name, (char const   * __restrict  )"rb");
#line 3060
    f = tmp;
#line 3062
    if ((unsigned long )f != (unsigned long )((void *)0)) {
#line 3064
      if (image->opts & 1U) {
#line 3065
        image->input_file = f;
      } else {
#line 3069
        tmp___9 = fseek(f, 0L, 2);
#line 3069
        if (tmp___9 == 0) {
#line 3071
          tmp___0 = ftell(f);
#line 3071
          cb = tmp___0;
#line 3073
          if (cb > 0L) {
#line 3076
            if ((unsigned long )cb <= 18446744073709551615UL) {
#line 3079
              tmp___1 = malloc((size_t )cb);
#line 3079
              b = (png_bytep )tmp___1;
#line 3081
              if ((unsigned long )b != (unsigned long )((void *)0)) {
#line 3083
                rewind(f);
#line 3085
                tmp___3 = fread((void *)b, (size_t )cb, (size_t )1, f);
#line 3085
                if (tmp___3 == 1UL) {
#line 3087
                  fclose(f);
#line 3088
                  image->input_memory_size = (size_t )cb;
#line 3089
                  image->input_memory = (png_voidp )b;
                } else {
#line 3094
                  free((void *)b);
#line 3095
                  tmp___2 = logclose(image, f, image->file_name, (char const   *)": read failed: ");
#line 3095
                  return (tmp___2);
                }
              } else {
#line 3101
                tmp___4 = logclose(image, f, image->file_name, (char const   *)": out of memory: ");
#line 3101
                return (tmp___4);
              }
            } else {
#line 3106
              tmp___5 = logclose(image, f, image->file_name, (char const   *)": file too big for this architecture: ");
#line 3106
              return (tmp___5);
            }
          } else
#line 3114
          if (cb == 0L) {
#line 3115
            tmp___6 = logclose(image, f, image->file_name, (char const   *)": zero length: ");
#line 3115
            return (tmp___6);
          } else {
#line 3119
            tmp___7 = logclose(image, f, image->file_name, (char const   *)": tell failed: ");
#line 3119
            return (tmp___7);
          }
        } else {
#line 3124
          tmp___8 = logclose(image, f, image->file_name, (char const   *)": seek failed: ");
#line 3124
          return (tmp___8);
        }
      }
    } else {
#line 3129
      tmp___10 = __errno_location();
#line 3129
      tmp___11 = strerror(*tmp___10);
#line 3129
      tmp___12 = logerror(image, image->file_name, (char const   *)": open failed: ",
                          (char const   *)tmp___11);
#line 3129
      return (tmp___12);
    }
  }
#line 3133
  tmp___13 = read_file(image, 0x80000000, (png_const_colorp )((void *)0));
#line 3133
  return (tmp___13);
}
}
#line 3216
static int write_one_file(Image *output , Image *image , int convert_to_8bit ) ;
#line 3216 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static unsigned int counter  =    0U;
#line 3137 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static int write_one_file(Image *output , Image *image , int convert_to_8bit )
{
  FILE *f ;
  FILE *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char name[32] ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  png_alloc_size_t size ;
  int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  unsigned int tmp___18 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;
  unsigned int tmp___21 ;
  unsigned int tmp___22 ;
  unsigned int tmp___23 ;
  unsigned int tmp___24 ;
  unsigned int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  png_uint_32 original_format ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;

  {
#line 3140
  if (image->opts & 128U) {
#line 3141
    image->image.flags |= 2U;
  }
#line 3143
  if (image->opts & 2U) {
#line 3147
    tmp = tmpfile();
#line 3147
    f = tmp;
#line 3181
    if ((unsigned long )f != (unsigned long )((void *)0)) {
#line 3183
      tmp___4 = png_image_write_to_stdio(& image->image, f, convert_to_8bit, (void const   *)(image->buffer + 16),
                                         (png_int_32 )image->stride, (void const   *)(image->colormap));
#line 3183
      if (tmp___4) {
#line 3186
        tmp___2 = fflush(f);
#line 3186
        if (tmp___2 == 0) {
#line 3188
          rewind(f);
#line 3189
          initimage(output, image->opts, (char const   *)"tmpfile", image->stride_extra);
#line 3190
          output->input_file = f;
#line 3191
          tmp___0 = checkopaque(image);
#line 3191
          if (! tmp___0) {
#line 3192
            return (0);
          }
        } else {
#line 3196
          tmp___1 = logclose(image, f, (char const   *)"tmpfile", (char const   *)": flush: ");
#line 3196
          return (tmp___1);
        }
      } else {
#line 3201
        fclose(f);
#line 3202
        tmp___3 = logerror(image, (char const   *)"tmpfile", (char const   *)": write failed",
                           (char const   *)"");
#line 3202
        return (tmp___3);
      }
    } else {
#line 3207
      tmp___5 = __errno_location();
#line 3207
      tmp___6 = strerror(*tmp___5);
#line 3207
      tmp___7 = logerror(image, (char const   *)"tmpfile", (char const   *)": open: ",
                         (char const   *)tmp___6);
#line 3207
      return (tmp___7);
    }
  } else
#line 3213
  if (image->opts & 1U) {
#line 3219
    counter ++;
#line 3219
    sprintf(name, (char const   *)"%s%u.png", tmpf, counter);
#line 3221
    tmp___10 = png_image_write_to_file(& image->image, (char const   *)(name), convert_to_8bit,
                                       (void const   *)(image->buffer + 16), (png_int_32 )image->stride,
                                       (void const   *)(image->colormap));
#line 3221
    if (tmp___10) {
#line 3224
      initimage(output, image->opts, (char const   *)(output->tmpfile_name), image->stride_extra);
#line 3227
      strcpy(output->tmpfile_name, (char const   *)(name));
#line 3229
      tmp___8 = checkopaque(image);
#line 3229
      if (! tmp___8) {
#line 3230
        return (0);
      }
    } else {
#line 3234
      tmp___9 = logerror(image, (char const   *)(name), (char const   *)": write failed",
                         (char const   *)"");
#line 3234
      return (tmp___9);
    }
  } else {
#line 3244
    tmp___31 = png_image_write_to_memory(& image->image, (void *)0, (png_alloc_size_t * __restrict  )(& size),
                                         convert_to_8bit, (void const   *)(image->buffer + 16),
                                         (png_int_32 )image->stride, (void const   *)(image->colormap));
#line 3244
    if (tmp___31) {
#line 3250
      if (image->image.format & 0x08U) {
#line 3250
        if (image->image.format & 0x01U) {
#line 3250
          tmp___12 = 12U + image->image.colormap_entries;
        } else {
#line 3250
          tmp___12 = 0U;
        }
#line 3250
        tmp___13 = (12U + 3U * image->image.colormap_entries) + tmp___12;
      } else {
#line 3250
        tmp___13 = 0U;
      }
#line 3250
      if (image->image.format & 0x08U) {
#line 3250
        tmp___14 = 1U;
      } else {
#line 3250
        tmp___14 = ((image->image.format & 0x04U) >> 2) + 1U;
      }
#line 3250
      if (image->image.format & 0x08U) {
#line 3250
        tmp___15 = 1U;
      } else {
#line 3250
        tmp___15 = (image->image.format & 3U) + 1U;
      }
#line 3250
      if (image->image.format & 0x08U) {
#line 3250
        tmp___16 = 1U;
      } else {
#line 3250
        tmp___16 = ((image->image.format & 0x04U) >> 2) + 1U;
      }
#line 3250
      if (image->image.format & 0x08U) {
#line 3250
        tmp___17 = 1U;
      } else {
#line 3250
        tmp___17 = (image->image.format & 3U) + 1U;
      }
#line 3250
      if (image->image.format & 0x08U) {
#line 3250
        tmp___18 = 1U;
      } else {
#line 3250
        tmp___18 = ((image->image.format & 0x04U) >> 2) + 1U;
      }
#line 3250
      if (image->image.format & 0x08U) {
#line 3250
        tmp___19 = 1U;
      } else {
#line 3250
        tmp___19 = (image->image.format & 3U) + 1U;
      }
#line 3250
      if (image->image.format & 0x08U) {
#line 3250
        tmp___20 = 1U;
      } else {
#line 3250
        tmp___20 = ((image->image.format & 0x04U) >> 2) + 1U;
      }
#line 3250
      if (image->image.format & 0x08U) {
#line 3250
        tmp___21 = 1U;
      } else {
#line 3250
        tmp___21 = (image->image.format & 3U) + 1U;
      }
#line 3250
      if (image->image.format & 0x08U) {
#line 3250
        tmp___22 = 1U;
      } else {
#line 3250
        tmp___22 = ((image->image.format & 0x04U) >> 2) + 1U;
      }
#line 3250
      if (image->image.format & 0x08U) {
#line 3250
        tmp___23 = 1U;
      } else {
#line 3250
        tmp___23 = (image->image.format & 3U) + 1U;
      }
#line 3250
      if (image->image.format & 0x08U) {
#line 3250
        tmp___24 = 1U;
      } else {
#line 3250
        tmp___24 = ((image->image.format & 0x04U) >> 2) + 1U;
      }
#line 3250
      if (image->image.format & 0x08U) {
#line 3250
        tmp___25 = 1U;
      } else {
#line 3250
        tmp___25 = (image->image.format & 3U) + 1U;
      }
#line 3250
      if (size > ((png_alloc_size_t )((105U + tmp___13) + 12U) + 12UL * (((((png_alloc_size_t )((tmp___14 * image->image.height) * (tmp___15 * image->image.width) + image->image.height) + (((png_alloc_size_t )((tmp___16 * image->image.height) * (tmp___17 * image->image.width) + image->image.height) + 7UL) >> 3)) + (((png_alloc_size_t )((tmp___18 * image->image.height) * (tmp___19 * image->image.width) + image->image.height) + 63UL) >> 6)) + 11UL) / 8192UL)) + ((((png_alloc_size_t )((tmp___20 * image->image.height) * (tmp___21 * image->image.width) + image->image.height) + (((png_alloc_size_t )((tmp___22 * image->image.height) * (tmp___23 * image->image.width) + image->image.height) + 7UL) >> 3)) + (((png_alloc_size_t )((tmp___24 * image->image.height) * (tmp___25 * image->image.width) + image->image.height) + 63UL) >> 6)) + 11UL)) {
#line 3251
        tmp___11 = logerror(image, (char const   *)"memory", (char const   *)": PNG_IMAGE_SIZE_MAX wrong",
                            (char const   *)"");
#line 3251
        return (tmp___11);
      }
#line 3253
      initimage(output, image->opts, (char const   *)"memory", image->stride_extra);
#line 3254
      output->input_memory = malloc(size);
#line 3256
      if ((unsigned long )output->input_memory != (unsigned long )((void *)0)) {
#line 3258
        output->input_memory_size = size;
#line 3260
        tmp___28 = png_image_write_to_memory(& image->image, output->input_memory,
                                             (png_alloc_size_t * __restrict  )(& output->input_memory_size),
                                             convert_to_8bit, (void const   *)(image->buffer + 16),
                                             (png_int_32 )image->stride, (void const   *)(image->colormap));
#line 3260
        if (tmp___28) {
#line 3266
          if (size != output->input_memory_size) {
#line 3267
            tmp___26 = logerror(image, (char const   *)"memory", (char const   *)": memory size wrong",
                                (char const   *)"");
#line 3267
            return (tmp___26);
          }
        } else {
#line 3271
          tmp___27 = logerror(image, (char const   *)"memory", (char const   *)": write failed",
                              (char const   *)"");
#line 3271
          return (tmp___27);
        }
      } else {
#line 3275
        tmp___29 = logerror(image, (char const   *)"memory", (char const   *)": out of memory",
                            (char const   *)"");
#line 3275
        return (tmp___29);
      }
    } else {
#line 3279
      tmp___30 = logerror(image, (char const   *)"memory", (char const   *)": get size:",
                          (char const   *)"");
#line 3279
      return (tmp___30);
    }
  }
#line 3289
  tmp___35 = read_file(output, image->image.format | 0x80000000, (png_const_colorp )((void *)0));
#line 3289
  if (tmp___35) {
#line 3291
    original_format = image->image.format;
#line 3293
    if (convert_to_8bit) {
#line 3294
      original_format &= 4294967291U;
    }
#line 3296
    if ((output->image.format & 7U) != (original_format & 7U)) {
#line 3298
      tmp___32 = logerror(image, image->file_name, (char const   *)": format changed on read: ",
                          output->file_name);
#line 3298
      return (tmp___32);
    }
#line 3301
    tmp___33 = compare_two_images(image, output, 0, (png_const_colorp )((void *)0));
#line 3301
    return (tmp___33);
  } else {
#line 3305
    tmp___34 = logerror(output, (char const   *)(output->tmpfile_name), (char const   *)": read of new file failed",
                        (char const   *)"");
#line 3305
    return (tmp___34);
  }
}
}
#line 3310 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static int testimage(Image *image , png_uint_32 opts , format_list *pf )
{
  int result ;
  Image copy ;
  png_uint_32 counter___0 ;
  Image output ;
  png_uint_32 format ;
  png_color background_color ;
  png_colorp background ;
  int tmp ;

  {
#line 3317
  checkopaque(image);
#line 3318
  copy = *image;
#line 3320
  copy.opts = opts;
#line 3321
  copy.buffer = (png_bytep )((void *)0);
#line 3322
  copy.bufsize = (size_t )0;
#line 3323
  copy.allocsize = (size_t )0;
#line 3325
  image->input_file = (FILE *)((void *)0);
#line 3326
  image->input_memory = (void *)0;
#line 3327
  image->input_memory_size = (size_t )0;
#line 3328
  image->tmpfile_name[0] = (char)0;
#line 3334
  newimage(& output);
#line 3336
  result = 1;
#line 3342
  counter___0 = (png_uint_32 )0;
  {
#line 3342
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3342
    if (! (counter___0 < 128U)) {
#line 3342
      goto while_break;
    }
#line 3343
    tmp = format_isset(pf, counter___0 >> 1);
#line 3343
    if (tmp) {
#line 3345
      format = counter___0 >> 1;
#line 3348
      background = (png_colorp )((void *)0);
#line 3356
      if ((counter___0 & 1U) == 0U) {
#line 3358
        if ((format & 0x01U) == 0U) {
#line 3358
          if ((image->image.format & 0x01U) != 0U) {
#line 3364
            random_color(& background_color);
#line 3365
            background = & background_color;
#line 3371
            if ((format & 0x08U) != 0U) {
#line 3371
              if ((format & 0x04U) == 0U) {
#line 3373
                counter___0 ++;
              }
            }
          } else {
#line 3380
            counter___0 ++;
          }
        } else {
#line 3380
          counter___0 ++;
        }
      }
#line 3384
      resetimage(& copy);
#line 3385
      copy.opts = opts;
#line 3387
      result = read_file(& copy, format, (png_const_colorp )background);
#line 3388
      if (! result) {
#line 3389
        goto while_break;
      }
#line 3392
      result = compare_two_images(image, & copy, 0, (png_const_colorp )background);
#line 3393
      if (! result) {
#line 3394
        goto while_break;
      }
#line 3401
      output.opts = opts;
#line 3402
      result = write_one_file(& output, & copy, 0);
#line 3403
      if (! result) {
#line 3404
        goto while_break;
      }
#line 3409
      result = compare_two_images(image, & output, 0, (png_const_colorp )background);
#line 3410
      if (! result) {
#line 3411
        goto while_break;
      }
#line 3413
      if ((format & 0x04U) != 0U) {
#line 3413
        if ((format & 0x08U) == 0U) {
#line 3418
          output.opts = opts;
#line 3419
          result = write_one_file(& output, & copy, 1);
#line 3420
          if (! result) {
#line 3421
            goto while_break;
          }
#line 3432
          result = compare_two_images(image, & output, 1, (png_const_colorp )background);
#line 3434
          if (! result) {
#line 3435
            goto while_break;
          }
        }
      }
    }
#line 3342
    counter___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3440
  freeimage(& output);
#line 3443
  freeimage(& copy);
#line 3445
  return (result);
}
}
#line 3448 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static int test_one_file___0(char const   *file_name , format_list *formats , png_uint_32 opts ,
                             int stride_extra , int log_pass )
{
  int result ;
  Image image ;

  {
#line 3455
  if (! (opts & 512U)) {
#line 3456
    reseed();
  }
#line 3457
  newimage(& image);
#line 3458
  initimage(& image, opts, file_name, stride_extra);
#line 3459
  result = read_one_file(& image);
#line 3460
  if (result) {
#line 3461
    result = testimage(& image, opts, formats);
  }
#line 3462
  freeimage(& image);
#line 3465
  fflush(stderr);
#line 3467
  if (log_pass) {
#line 3469
    if (result) {
#line 3470
      printf((char const   *)"PASS:");
    } else {
#line 3473
      printf((char const   *)"FAIL:");
    }
#line 3479
    print_opts(opts);
#line 3480
    printf((char const   *)" %s\n", file_name);
#line 3482
    fflush(stdout);
  } else
#line 3485
  if (! result) {
#line 3486
    exit(1);
  }
#line 3488
  return (result);
}
}
#line 3639 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngstest.c"
static char buffer[4096]  ;
#line 77 "/usr/include/signal.h"
extern __sighandler_t ( __attribute__((__leaf__)) __sysv_signal)(int __sig , void (*__handler)(int  ) )  __attribute__((__nothrow__)) ;
#line 80
extern __sighandler_t ( __attribute__((__leaf__)) sysv_signal)(int __sig , void (*__handler)(int  ) )  __attribute__((__nothrow__)) ;
#line 88
extern __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig , void (*__handler)(int  ) )  __attribute__((__nothrow__)) ;
#line 112
extern int ( __attribute__((__leaf__)) kill)(__pid_t __pid , int __sig )  __attribute__((__nothrow__)) ;
#line 119
extern int ( __attribute__((__leaf__)) killpg)(__pid_t __pgrp , int __sig )  __attribute__((__nothrow__)) ;
#line 123
extern int ( __attribute__((__leaf__)) raise)(int __sig )  __attribute__((__nothrow__)) ;
#line 127
extern __sighandler_t ( __attribute__((__leaf__)) ssignal)(int __sig , void (*__handler)(int  ) )  __attribute__((__nothrow__)) ;
#line 129
extern int ( __attribute__((__leaf__)) gsignal)(int __sig )  __attribute__((__nothrow__)) ;
#line 134
extern void psignal(int __sig , char const   *__s ) ;
#line 137
extern void psiginfo(siginfo_t const   *__pinfo , char const   *__s ) ;
#line 151
extern int sigpause(int __sig )  __asm__("__xpg_sigpause")  ;
#line 170
extern int ( __attribute__((__leaf__)) sigblock)(int __mask )  __attribute__((__nothrow__,
__deprecated__)) ;
#line 173
extern int ( __attribute__((__leaf__)) sigsetmask)(int __mask )  __attribute__((__nothrow__,
__deprecated__)) ;
#line 176
extern int ( __attribute__((__leaf__)) siggetmask)(void)  __attribute__((__nothrow__,
__deprecated__)) ;
#line 196
extern int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set )  __attribute__((__nothrow__)) ;
#line 199
extern int ( __attribute__((__nonnull__(1), __leaf__)) sigfillset)(sigset_t *__set )  __attribute__((__nothrow__)) ;
#line 202
extern int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                  int __signo )  __attribute__((__nothrow__)) ;
#line 205
extern int ( __attribute__((__nonnull__(1), __leaf__)) sigdelset)(sigset_t *__set ,
                                                                  int __signo )  __attribute__((__nothrow__)) ;
#line 208
extern int ( __attribute__((__nonnull__(1), __leaf__)) sigismember)(sigset_t const   *__set ,
                                                                    int __signo )  __attribute__((__nothrow__)) ;
#line 213
extern int ( __attribute__((__nonnull__(1), __leaf__)) sigisemptyset)(sigset_t const   *__set )  __attribute__((__nothrow__)) ;
#line 216
extern int ( __attribute__((__nonnull__(1,2,3), __leaf__)) sigandset)(sigset_t *__set ,
                                                                      sigset_t const   *__left ,
                                                                      sigset_t const   *__right )  __attribute__((__nothrow__)) ;
#line 220
extern int ( __attribute__((__nonnull__(1,2,3), __leaf__)) sigorset)(sigset_t *__set ,
                                                                     sigset_t const   *__left ,
                                                                     sigset_t const   *__right )  __attribute__((__nothrow__)) ;
#line 229
extern int ( __attribute__((__leaf__)) sigprocmask)(int __how , sigset_t const   * __restrict  __set ,
                                                    sigset_t * __restrict  __oset )  __attribute__((__nothrow__)) ;
#line 237
extern int ( __attribute__((__nonnull__(1))) sigsuspend)(sigset_t const   *__set ) ;
#line 240
extern int ( __attribute__((__leaf__)) sigaction)(int __sig , struct sigaction  const  * __restrict  __act ,
                                                  struct sigaction * __restrict  __oact )  __attribute__((__nothrow__)) ;
#line 244
extern int ( __attribute__((__nonnull__(1), __leaf__)) sigpending)(sigset_t *__set )  __attribute__((__nothrow__)) ;
#line 252
extern int ( __attribute__((__nonnull__(1,2))) sigwait)(sigset_t const   * __restrict  __set ,
                                                        int * __restrict  __sig ) ;
#line 261
extern int ( __attribute__((__nonnull__(1))) sigwaitinfo)(sigset_t const   * __restrict  __set ,
                                                          siginfo_t * __restrict  __info ) ;
#line 269
extern int ( __attribute__((__nonnull__(1))) sigtimedwait)(sigset_t const   * __restrict  __set ,
                                                           siginfo_t * __restrict  __info ,
                                                           struct timespec  const  * __restrict  __timeout ) ;
#line 276
extern int ( __attribute__((__leaf__)) sigqueue)(__pid_t __pid , int __sig , union sigval  const  __val )  __attribute__((__nothrow__)) ;
#line 286
extern char const   *_sys_siglist[65] ;
#line 287
extern char const   *sys_siglist[65] ;
#line 294
extern int ( __attribute__((__leaf__)) sigreturn)(struct sigcontext *__scp )  __attribute__((__nothrow__)) ;
#line 314
extern int ( __attribute__((__leaf__)) siginterrupt)(int __sig , int __interrupt )  __attribute__((__nothrow__)) ;
#line 321
extern int ( __attribute__((__leaf__)) sigaltstack)(stack_t const   * __restrict  __ss ,
                                                    stack_t * __restrict  __oss )  __attribute__((__nothrow__)) ;
#line 335
extern int ( __attribute__((__leaf__)) sigstack)(struct sigstack *__ss , struct sigstack *__oss )  __attribute__((__nothrow__,
__deprecated__)) ;
#line 343
extern int ( __attribute__((__leaf__)) sighold)(int __sig )  __attribute__((__nothrow__)) ;
#line 346
extern int ( __attribute__((__leaf__)) sigrelse)(int __sig )  __attribute__((__nothrow__)) ;
#line 349
extern int ( __attribute__((__leaf__)) sigignore)(int __sig )  __attribute__((__nothrow__)) ;
#line 352
extern __sighandler_t ( __attribute__((__leaf__)) sigset)(int __sig , void (*__disp)(int  ) )  __attribute__((__nothrow__)) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/sigthread.h"
extern int ( __attribute__((__leaf__)) pthread_sigmask)(int __how , __sigset_t const   * __restrict  __newmask ,
                                                        __sigset_t * __restrict  __oldmask )  __attribute__((__nothrow__)) ;
#line 36
extern int ( __attribute__((__leaf__)) pthread_kill)(pthread_t __threadid , int __signo )  __attribute__((__nothrow__)) ;
#line 40
extern int ( __attribute__((__leaf__)) pthread_sigqueue)(pthread_t __threadid , int __signo ,
                                                         union sigval  const  __value )  __attribute__((__nothrow__)) ;
#line 366 "/usr/include/signal.h"
extern int ( __attribute__((__leaf__)) __libc_current_sigrtmin)(void)  __attribute__((__nothrow__)) ;
#line 368
extern int ( __attribute__((__leaf__)) __libc_current_sigrtmax)(void)  __attribute__((__nothrow__)) ;
#line 29 "/usr/include/x86_64-linux-gnu/bits/signal_ext.h"
extern int tgkill(__pid_t __tgid , __pid_t __tid , int __signal ) ;
#line 164 "/usr/include/stdio.h"
extern int ( __attribute__((__leaf__)) renameat2)(int __oldfd , char const   *__old ,
                                                  int __newfd , char const   *__new ,
                                                  unsigned int __flags )  __attribute__((__nothrow__)) ;
#line 183
extern FILE *( __attribute__((__warn_unused_result__)) tmpfile64)(void) ;
#line 237
extern int fcloseall(void) ;
#line 270
extern FILE *( __attribute__((__warn_unused_result__)) fopen64)(char const   * __restrict  __filename ,
                                                                char const   * __restrict  __modes ) ;
#line 272
extern FILE *( __attribute__((__warn_unused_result__)) freopen64)(char const   * __restrict  __filename ,
                                                                  char const   * __restrict  __modes ,
                                                                  FILE * __restrict  __stream ) ;
#line 285
extern FILE *( __attribute__((__warn_unused_result__, __leaf__)) fopencookie)(void * __restrict  __magic_cookie ,
                                                                              char const   * __restrict  __modes ,
                                                                              cookie_io_functions_t __io_funcs )  __attribute__((__nothrow__)) ;
#line 326
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) fprintf)(FILE *__stream ,
                                                                                                  char const   *__fmt
                                                                                                  , ...) ;
#line 332
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) printf)(char const   *__fmt
                                                                                                 , ...) ;
#line 334
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) sprintf)(char *__s ,
                                                                                                            char const   *__fmt
                                                                                                            , ...)  __attribute__((__nothrow__)) ;
#line 341
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vfprintf)(FILE *__stream ,
                                                                                                   char const   *__fmt ,
                                                                                                   __gnuc_va_list __ap ) ;
#line 347
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vprintf)(char const   *__fmt ,
                                                                                                  __gnuc_va_list __ap ) ;
#line 349
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vsprintf)(char *__s ,
                                                                                                             char const   *__fmt ,
                                                                                                             __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 354
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) snprintf)(char *__s , size_t __n , char const   *__fmt
                                              , ...)  __attribute__((__nothrow__)) ;
#line 358
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) vsnprintf)(char *__s , size_t __n , char const   *__fmt ,
                                               __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 366
__inline extern int ( /* format attribute */ __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vasprintf)(char **__ptr ,
                                                                         char const   *__fmt ,
                                                                         __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 369
__inline extern int ( /* format attribute */ __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) __asprintf)(char **__ptr ,
                                                                          char const   *__fmt
                                                                          , ...)  __attribute__((__nothrow__)) ;
#line 372
__inline extern int ( /* format attribute */ __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) asprintf)(char **__ptr ,
                                                                        char const   *__fmt
                                                                        , ...)  __attribute__((__nothrow__)) ;
#line 379
__inline extern int ( /* format attribute */ __attribute__((__gnu_inline__, __artificial__,
__always_inline__)) vdprintf)(int __fd , char const   *__fmt , __gnuc_va_list __ap ) ;
#line 382
__inline extern int ( /* format attribute */ __attribute__((__gnu_inline__, __artificial__,
__always_inline__)) dprintf)(int __fd , char const   *__fmt  , ...) ;
#line 492
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
#line 499
__inline extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
#line 500
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
#line 510
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
#line 528
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
#line 537
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) ;
#line 545
__inline extern int ( __attribute__((__gnu_inline__)) putc_unlocked)(int __c , FILE *__stream ) ;
#line 546
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
#line 564
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fgets)(char *__s , int __n , FILE *__stream ) ;
#line 587
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fgets_unlocked)(char *__s , int __n , FILE *__stream ) ;
#line 616
__inline extern __ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__)) getline___0)(char **__lineptr ,
                                                                                                 size_t *__n ,
                                                                                                 FILE *__stream ) ;
#line 646
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fread)(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 662
extern int fputs_unlocked(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 673
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fread_unlocked)(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 750
extern int fseeko64(FILE *__stream , __off_t __off , int __whence ) ;
#line 751
extern __off_t ( __attribute__((__warn_unused_result__)) ftello64)(FILE *__stream ) ;
#line 752
extern int fgetpos64(FILE * __restrict  __stream , fpos64_t * __restrict  __pos ) ;
#line 753
extern int fsetpos64(FILE *__stream , fpos64_t const   *__pos ) ;
#line 766
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__)) feof_unlocked)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 767
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__)) ferror_unlocked)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 30 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h"
extern int _sys_nerr ;
#line 31
extern char const   *_sys_errlist[] ;
#line 818 "/usr/include/stdio.h"
extern char *cuserid(char *__s ) ;
#line 826
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) obstack_printf)(struct obstack *__obstack , char const   *__fmt
                                                    , ...)  __attribute__((__nothrow__)) ;
#line 829
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) obstack_vprintf)(struct obstack *__obstack , char const   *__fmt ,
                                                     __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 117 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern __ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__)) getline___0)(char **__lineptr ,
                                                                                                 size_t *__n ,
                                                                                                 FILE *__stream )
{
  __ssize_t tmp ;

  {
#line 120
  tmp = __getdelim((char ** __restrict  )__lineptr, (size_t * __restrict  )__n, '\n',
                   (FILE * __restrict  )__stream);
#line 120
  return (tmp);
}
}
#line 161 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
extern int ( /* format attribute */ __attribute__((__warn_unused_result__, __leaf__)) __asprintf_chk)(char ** __restrict  __ptr ,
                                                                                                      int __flag ,
                                                                                                      char const   * __restrict  __fmt
                                                                                                      , ...)  __attribute__((__nothrow__)) ;
#line 164
extern int ( /* format attribute */ __attribute__((__warn_unused_result__, __leaf__)) __vasprintf_chk)(char ** __restrict  __ptr ,
                                                                                                       int __flag ,
                                                                                                       char const   * __restrict  __fmt ,
                                                                                                       __gnuc_va_list __arg )  __attribute__((__nothrow__)) ;
#line 167
extern int ( /* format attribute */ __attribute__((__leaf__)) __obstack_printf_chk)(struct obstack * __restrict  __obstack ,
                                                                                    int __flag ,
                                                                                    char const   * __restrict  __format
                                                                                    , ...)  __attribute__((__nothrow__)) ;
#line 171
extern int ( /* format attribute */ __attribute__((__leaf__)) __obstack_vprintf_chk)(struct obstack * __restrict  __obstack ,
                                                                                     int __flag ,
                                                                                     char const   * __restrict  __format ,
                                                                                     __gnuc_va_list __args )  __attribute__((__nothrow__)) ;
#line 178
__inline extern int ( /* format attribute */ __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) asprintf)(char **__ptr ,
                                                                        char const   *__fmt
                                                                        , ...)  __attribute__((__nothrow__)) ;
#line 178 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) asprintf)(char **__ptr ,
                                                                        char const   *__fmt
                                                                        , ...)
{
  int tmp ;

  {
#line 181
  tmp = __asprintf_chk((char ** __restrict  )__ptr, 1, (char const   * __restrict  )__fmt,
                       __builtin_va_arg_pack());
#line 181
  return (tmp);
}
}
#line 193
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) obstack_printf)(struct obstack *__obstack , char const   *__fmt
                                                    , ...)  __attribute__((__nothrow__)) ;
#line 193 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) obstack_printf)(struct obstack *__obstack , char const   *__fmt
                                                    , ...)
{
  int tmp ;

  {
#line 197
  tmp = __obstack_printf_chk((struct obstack * __restrict  )__obstack, 1, (char const   * __restrict  )__fmt,
                             __builtin_va_arg_pack());
#line 197
  return (tmp);
}
}
#line 209
__inline extern int ( /* format attribute */ __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vasprintf)(char **__ptr ,
                                                                         char const   *__fmt ,
                                                                         __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 209 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vasprintf)(char **__ptr ,
                                                                         char const   *__fmt ,
                                                                         __gnuc_va_list __ap )
{
  int tmp ;

  {
#line 213
  tmp = __vasprintf_chk((char ** __restrict  )__ptr, 1, (char const   * __restrict  )__fmt,
                        __ap);
#line 213
  return (tmp);
}
}
#line 216
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) obstack_vprintf)(struct obstack *__obstack , char const   *__fmt ,
                                                     __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 216 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) obstack_vprintf)(struct obstack *__obstack , char const   *__fmt ,
                                                     __gnuc_va_list __ap )
{
  int tmp ;

  {
#line 220
  tmp = __obstack_vprintf_chk((struct obstack * __restrict  )__obstack, 1, (char const   * __restrict  )__fmt,
                              __ap);
#line 220
  return (tmp);
}
}
#line 301
extern char *( __attribute__((__warn_unused_result__)) __fgets_unlocked_chk)(char * __restrict  __s ,
                                                                             size_t __size ,
                                                                             int __n ,
                                                                             FILE * __restrict  __stream ) ;
#line 303
extern char *( __attribute__((__warn_unused_result__)) __fgets_unlocked_alias)(char * __restrict  __s ,
                                                                               int __n ,
                                                                               FILE * __restrict  __stream )  __asm__("fgets_unlocked")  ;
#line 306
extern char *( __attribute__((__warn_unused_result__)) __fgets_unlocked_chk_warn)(char * __restrict  __s ,
                                                                                  size_t __size ,
                                                                                  int __n ,
                                                                                  FILE * __restrict  __stream )  __asm__("__fgets_unlocked_chk") __attribute__((__warning__("fgets_unlocked called with bigger size than length of destination buffer"))) ;
#line 312 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fgets_unlocked)(char *__s , int __n , FILE *__stream )
{
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;

  {
#line 315
  tmp___4 = __builtin_object_size((void *)__s, 1);
#line 315
  if (tmp___4 != 18446744073709551615UL) {
#line 317
    if (1) {
#line 318
      tmp = __builtin_object_size((void *)__s, 1);
#line 318
      tmp___0 = __fgets_unlocked_chk((char * __restrict  )__s, tmp, __n, (FILE * __restrict  )__stream);
#line 318
      return (tmp___0);
    } else
#line 317
    if (__n <= 0) {
#line 318
      tmp = __builtin_object_size((void *)__s, 1);
#line 318
      tmp___0 = __fgets_unlocked_chk((char * __restrict  )__s, tmp, __n, (FILE * __restrict  )__stream);
#line 318
      return (tmp___0);
    }
#line 320
    tmp___3 = __builtin_object_size((void *)__s, 1);
#line 320
    if ((size_t )__n > tmp___3) {
#line 321
      tmp___1 = __builtin_object_size((void *)__s, 1);
#line 321
      tmp___2 = __fgets_unlocked_chk_warn((char * __restrict  )__s, tmp___1, __n,
                                          (FILE * __restrict  )__stream);
#line 321
      return (tmp___2);
    }
  }
#line 323
  tmp___5 = __fgets_unlocked_alias((char * __restrict  )__s, __n, (FILE * __restrict  )__stream);
#line 323
  return (tmp___5);
}
}
#line 124 "/usr/include/x86_64-linux-gnu/bits/fenv.h"
extern int ( __attribute__((__leaf__)) __feraiseexcept_renamed)(int  )  __asm__("feraiseexcept") __attribute__((__nothrow__)) ;
#line 126
__inline extern void ( __attribute__((__leaf__, __gnu_inline__, __always_inline__)) __feraiseexcept_invalid_divbyzero)(int __excepts )  __attribute__((__nothrow__)) ;
#line 126 "/usr/include/x86_64-linux-gnu/bits/fenv.h"
__inline extern void ( __attribute__((__leaf__, __gnu_inline__, __always_inline__)) __feraiseexcept_invalid_divbyzero)(int __excepts )
{
  float __f ;
  float __f___0 ;
  float __g ;

  {
#line 129
  if ((0x01 & __excepts) != 0) {
#line 132
    __f = (float )0.0;
#line 135
    __asm__  volatile   ("divss %0, %0 ": : "x" (__f));
  }
#line 142
  if ((0x04 & __excepts) != 0) {
#line 144
    __f___0 = (float )1.0;
#line 145
    __g = (float )0.0;
#line 148
    __asm__  volatile   ("divss %1, %0": : "x" (__f___0), "x" (__g));
  }
#line 155
  return;
}
}
#line 156
__inline extern int ( __attribute__((__leaf__, __gnu_inline__)) feraiseexcept)(int __excepts )  __attribute__((__nothrow__)) ;
#line 71 "/usr/include/fenv.h"
extern int ( __attribute__((__leaf__)) feclearexcept)(int __excepts )  __attribute__((__nothrow__)) ;
#line 75
extern int ( __attribute__((__leaf__)) fegetexceptflag)(fexcept_t *__flagp , int __excepts )  __attribute__((__nothrow__)) ;
#line 83
extern int ( __attribute__((__leaf__)) fesetexcept)(int __excepts )  __attribute__((__nothrow__)) ;
#line 88
extern int ( __attribute__((__leaf__)) fesetexceptflag)(fexcept_t const   *__flagp ,
                                                        int __excepts )  __attribute__((__nothrow__)) ;
#line 92
extern int ( __attribute__((__leaf__)) fetestexcept)(int __excepts )  __attribute__((__nothrow__)) ;
#line 97
extern int ( __attribute__((__leaf__)) fetestexceptflag)(fexcept_t const   *__flagp ,
                                                         int __excepts )  __attribute__((__nothrow__)) ;
#line 104
extern int ( __attribute__((__leaf__)) fegetround)(void)  __attribute__((__pure__,
__nothrow__)) ;
#line 107
extern int ( __attribute__((__leaf__)) fesetround)(int __rounding_direction )  __attribute__((__nothrow__)) ;
#line 114
extern int ( __attribute__((__leaf__)) fegetenv)(fenv_t *__envp )  __attribute__((__nothrow__)) ;
#line 119
extern int ( __attribute__((__leaf__)) feholdexcept)(fenv_t *__envp )  __attribute__((__nothrow__)) ;
#line 123
extern int ( __attribute__((__leaf__)) fesetenv)(fenv_t const   *__envp )  __attribute__((__nothrow__)) ;
#line 128
extern int ( __attribute__((__leaf__)) feupdateenv)(fenv_t const   *__envp )  __attribute__((__nothrow__)) ;
#line 136
extern int ( __attribute__((__leaf__)) fegetmode)(femode_t *__modep )  __attribute__((__nothrow__)) ;
#line 140
extern int ( __attribute__((__leaf__)) fesetmode)(femode_t const   *__modep )  __attribute__((__nothrow__)) ;
#line 161
extern int ( __attribute__((__leaf__)) feenableexcept)(int __excepts )  __attribute__((__nothrow__)) ;
#line 166
extern int ( __attribute__((__leaf__)) fedisableexcept)(int __excepts )  __attribute__((__nothrow__)) ;
#line 169
extern int ( __attribute__((__leaf__)) fegetexcept)(void)  __attribute__((__nothrow__)) ;
#line 78 "/usr/include/x86_64-linux-gnu/bits/time.h"
extern int ( __attribute__((__leaf__)) clock_adjtime)(__clockid_t __clock_id , struct timex *__utx )  __attribute__((__nothrow__)) ;
#line 95 "/usr/include/time.h"
extern char *( __attribute__((__leaf__)) strptime)(char const   * __restrict  __s ,
                                                   char const   * __restrict  __fmt ,
                                                   struct tm *__tp )  __attribute__((__nothrow__)) ;
#line 111
extern char *( __attribute__((__leaf__)) strptime_l)(char const   * __restrict  __s ,
                                                     char const   * __restrict  __fmt ,
                                                     struct tm *__tp , locale_t __loc )  __attribute__((__nothrow__)) ;
#line 274
extern int getdate_err ;
#line 283
extern struct tm *getdate(char const   *__string ) ;
#line 297
extern int getdate_r(char const   * __restrict  __string , struct tm * __restrict  __resbufp ) ;
#line 292 "/usr/include/unistd.h"
extern int ( __attribute__((__nonnull__(1), __leaf__)) euidaccess)(char const   *__name ,
                                                                   int __type )  __attribute__((__nothrow__)) ;
#line 296
extern int ( __attribute__((__nonnull__(1), __leaf__)) eaccess)(char const   *__name ,
                                                                int __type )  __attribute__((__nothrow__)) ;
#line 304
extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__)) faccessat)(int __fd ,
                                                                                          char const   *__file ,
                                                                                          int __type ,
                                                                                          int __flag )  __attribute__((__nothrow__)) ;
#line 345
extern __off_t ( __attribute__((__leaf__)) lseek64)(int __fd , __off_t __offset ,
                                                    int __whence )  __attribute__((__nothrow__)) ;
#line 360
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) read)(int __fd , void *__buf , size_t __nbytes ) ;
#line 376
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) pread)(int __fd , void *__buf , size_t __nbytes , __off_t __offset ) ;
#line 384
extern ssize_t ( __attribute__((__warn_unused_result__)) pwrite)(int __fd , void const   *__buf ,
                                                                 size_t __n , __off_t __offset ) ;
#line 404
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) pread64)(int __fd , void *__buf , size_t __nbytes , __off_t __offset ) ;
#line 408
extern ssize_t ( __attribute__((__warn_unused_result__)) pwrite64)(int __fd , void const   *__buf ,
                                                                   size_t __n , __off_t __offset ) ;
#line 422
extern int ( __attribute__((__warn_unused_result__, __leaf__)) pipe2)(int *__pipedes ,
                                                                      int __flags )  __attribute__((__nothrow__)) ;
#line 452
extern __useconds_t ( __attribute__((__leaf__)) ualarm)(__useconds_t __value , __useconds_t __interval )  __attribute__((__nothrow__)) ;
#line 460
extern int usleep(__useconds_t __useconds ) ;
#line 478
extern int ( __attribute__((__warn_unused_result__, __leaf__)) fchown)(int __fd ,
                                                                       __uid_t __owner ,
                                                                       __gid_t __group )  __attribute__((__nothrow__)) ;
#line 483
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) lchown)(char const   *__file ,
                                                                                       __uid_t __owner ,
                                                                                       __gid_t __group )  __attribute__((__nothrow__)) ;
#line 491
extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__)) fchownat)(int __fd ,
                                                                                         char const   *__file ,
                                                                                         __uid_t __owner ,
                                                                                         __gid_t __group ,
                                                                                         int __flag )  __attribute__((__nothrow__)) ;
#line 501
extern int ( __attribute__((__warn_unused_result__, __leaf__)) fchdir)(int __fd )  __attribute__((__nothrow__)) ;
#line 511
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size )  __attribute__((__nothrow__)) ;
#line 517
extern char *( __attribute__((__leaf__)) get_current_dir_name)(void)  __attribute__((__nothrow__)) ;
#line 525
__inline extern char __attribute__((__deprecated__))  *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __gnu_inline__, __artificial__, __always_inline__)) getwd)(char *__buf )  __attribute__((__nothrow__,
__deprecated__)) ;
#line 539
extern int ( __attribute__((__leaf__)) dup3)(int __fd , int __fd2 , int __flags )  __attribute__((__nothrow__)) ;
#line 545
extern char **environ ;
#line 557
extern int ( __attribute__((__nonnull__(2), __leaf__)) fexecve)(int __fd , char **__argv ,
                                                                char **__envp )  __attribute__((__nothrow__)) ;
#line 590
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) execvpe)(char const   *__file ,
                                                                  char **__argv ,
                                                                  char **__envp )  __attribute__((__nothrow__)) ;
#line 598
extern int ( __attribute__((__warn_unused_result__, __leaf__)) nice)(int __inc )  __attribute__((__nothrow__)) ;
#line 623
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) confstr)(int __name , char *__buf , size_t __len )  __attribute__((__nothrow__)) ;
#line 639
extern __pid_t ( __attribute__((__leaf__)) getpgid)(__pid_t __pid )  __attribute__((__nothrow__)) ;
#line 660
extern int ( __attribute__((__leaf__)) setpgrp)(void)  __attribute__((__nothrow__)) ;
#line 671
extern __pid_t ( __attribute__((__leaf__)) getsid)(__pid_t __pid )  __attribute__((__nothrow__)) ;
#line 689
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list )  __attribute__((__nothrow__)) ;
#line 693
extern int ( __attribute__((__leaf__)) group_member)(__gid_t __gid )  __attribute__((__nothrow__)) ;
#line 705
extern int ( __attribute__((__warn_unused_result__, __leaf__)) setreuid)(__uid_t __ruid ,
                                                                         __uid_t __euid )  __attribute__((__nothrow__)) ;
#line 710
extern int ( __attribute__((__warn_unused_result__, __leaf__)) seteuid)(__uid_t __uid )  __attribute__((__nothrow__)) ;
#line 722
extern int ( __attribute__((__warn_unused_result__, __leaf__)) setregid)(__gid_t __rgid ,
                                                                         __gid_t __egid )  __attribute__((__nothrow__)) ;
#line 727
extern int ( __attribute__((__warn_unused_result__, __leaf__)) setegid)(__gid_t __gid )  __attribute__((__nothrow__)) ;
#line 733
extern int ( __attribute__((__leaf__)) getresuid)(__uid_t *__ruid , __uid_t *__euid ,
                                                  __uid_t *__suid )  __attribute__((__nothrow__)) ;
#line 738
extern int ( __attribute__((__leaf__)) getresgid)(__gid_t *__rgid , __gid_t *__egid ,
                                                  __gid_t *__sgid )  __attribute__((__nothrow__)) ;
#line 743
extern int ( __attribute__((__warn_unused_result__, __leaf__)) setresuid)(__uid_t __ruid ,
                                                                          __uid_t __euid ,
                                                                          __uid_t __suid )  __attribute__((__nothrow__)) ;
#line 748
extern int ( __attribute__((__warn_unused_result__, __leaf__)) setresgid)(__gid_t __rgid ,
                                                                          __gid_t __egid ,
                                                                          __gid_t __sgid )  __attribute__((__nothrow__)) ;
#line 764
extern __pid_t ( __attribute__((__leaf__)) vfork)(void)  __attribute__((__nothrow__)) ;
#line 774
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                               size_t __buflen )  __attribute__((__nothrow__)) ;
#line 784
extern int ( __attribute__((__leaf__)) ttyslot)(void)  __attribute__((__nothrow__)) ;
#line 795
extern int ( __attribute__((__warn_unused_result__, __nonnull__(2,4), __leaf__)) linkat)(int __fromfd ,
                                                                                         char const   *__from ,
                                                                                         int __tofd ,
                                                                                         char const   *__to ,
                                                                                         int __flags )  __attribute__((__nothrow__)) ;
#line 802
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1,2), __leaf__)) symlink)(char const   *__from ,
                                                                                          char const   *__to )  __attribute__((__nothrow__)) ;
#line 808
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(1,2),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) readlink)(char const   *__path ,
                                                                        char *__buf ,
                                                                        size_t __len )  __attribute__((__nothrow__)) ;
#line 815
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1,3), __leaf__)) symlinkat)(char const   *__from ,
                                                                                            int __tofd ,
                                                                                            char const   *__to )  __attribute__((__nothrow__)) ;
#line 819
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(2,3),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) readlinkat)(int __fd ,
                                                                          char const   *__path ,
                                                                          char *__buf ,
                                                                          size_t __len )  __attribute__((__nothrow__)) ;
#line 829
extern int ( __attribute__((__nonnull__(2), __leaf__)) unlinkat)(int __fd , char const   *__name ,
                                                                 int __flag )  __attribute__((__nothrow__)) ;
#line 856
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__, __artificial__,
__always_inline__)) getlogin_r)(char *__buf , size_t __buflen ) ;
#line 861
extern int ( __attribute__((__nonnull__(1), __leaf__)) setlogin)(char const   *__name )  __attribute__((__nothrow__)) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h"
extern char *optarg ;
#line 50
extern int optind ;
#line 55
extern int opterr ;
#line 59
extern int optopt ;
#line 91
extern int ( __attribute__((__nonnull__(2,3), __leaf__)) getopt)(int ___argc , char **___argv ,
                                                                 char const   *__shortopts )  __attribute__((__nothrow__)) ;
#line 877 "/usr/include/unistd.h"
__inline extern int ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) gethostname)(char *__buf , size_t __buflen )  __attribute__((__nothrow__)) ;
#line 884
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) sethostname)(char const   *__name ,
                                                                                            size_t __len )  __attribute__((__nothrow__)) ;
#line 889
extern int ( __attribute__((__warn_unused_result__, __leaf__)) sethostid)(long __id )  __attribute__((__nothrow__)) ;
#line 895
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) getdomainname)(char *__buf , size_t __buflen )  __attribute__((__nothrow__)) ;
#line 897
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) setdomainname)(char const   *__name ,
                                                                                              size_t __len )  __attribute__((__nothrow__)) ;
#line 904
extern int ( __attribute__((__leaf__)) vhangup)(void)  __attribute__((__nothrow__)) ;
#line 907
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) revoke)(char const   *__file )  __attribute__((__nothrow__)) ;
#line 915
extern int ( __attribute__((__nonnull__(1), __leaf__)) profil)(unsigned short *__sample_buffer ,
                                                               size_t __size , size_t __offset ,
                                                               unsigned int __scale )  __attribute__((__nothrow__)) ;
#line 923
extern int ( __attribute__((__leaf__)) acct)(char const   *__name )  __attribute__((__nothrow__)) ;
#line 927
extern char *( __attribute__((__leaf__)) getusershell)(void)  __attribute__((__nothrow__)) ;
#line 928
extern void ( __attribute__((__leaf__)) endusershell)(void)  __attribute__((__nothrow__)) ;
#line 929
extern void ( __attribute__((__leaf__)) setusershell)(void)  __attribute__((__nothrow__)) ;
#line 935
extern int ( __attribute__((__warn_unused_result__, __leaf__)) daemon)(int __nochdir ,
                                                                       int __noclose )  __attribute__((__nothrow__)) ;
#line 942
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) chroot)(char const   *__path )  __attribute__((__nothrow__)) ;
#line 946
extern char *( __attribute__((__nonnull__(1))) getpass)(char const   *__prompt ) ;
#line 960
extern int ( __attribute__((__leaf__)) syncfs)(int __fd )  __attribute__((__nothrow__)) ;
#line 967
extern long gethostid(void) ;
#line 970
extern void ( __attribute__((__leaf__)) sync)(void)  __attribute__((__nothrow__)) ;
#line 976
extern int ( __attribute__((__leaf__)) getpagesize)(void)  __attribute__((__nothrow__,
__const__)) ;
#line 981
extern int ( __attribute__((__leaf__)) getdtablesize)(void)  __attribute__((__nothrow__)) ;
#line 991
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) truncate)(char const   *__file ,
                                                                                         __off_t __length )  __attribute__((__nothrow__)) ;
#line 1003
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) truncate64)(char const   *__file ,
                                                                                           __off_t __length )  __attribute__((__nothrow__)) ;
#line 1014
extern int ( __attribute__((__warn_unused_result__, __leaf__)) ftruncate)(int __fd ,
                                                                          __off_t __length )  __attribute__((__nothrow__)) ;
#line 1024
extern int ( __attribute__((__warn_unused_result__, __leaf__)) ftruncate64)(int __fd ,
                                                                            __off_t __length )  __attribute__((__nothrow__)) ;
#line 1035
extern int ( __attribute__((__warn_unused_result__, __leaf__)) brk)(void *__addr )  __attribute__((__nothrow__)) ;
#line 1041
extern void *( __attribute__((__leaf__)) sbrk)(intptr_t __delta )  __attribute__((__nothrow__)) ;
#line 1056
extern long ( __attribute__((__leaf__)) syscall)(long __sysno  , ...)  __attribute__((__nothrow__)) ;
#line 1079
extern int ( __attribute__((__warn_unused_result__)) lockf)(int __fd , int __cmd ,
                                                            __off_t __len ) ;
#line 1089
extern int ( __attribute__((__warn_unused_result__)) lockf64)(int __fd , int __cmd ,
                                                              __off_t __len ) ;
#line 1107
extern ssize_t copy_file_range(int __infd , __off_t *__pinoff , int __outfd , __off_t *__poutoff ,
                               size_t __length , unsigned int __flags ) ;
#line 1115
extern int fdatasync(int __fildes ) ;
#line 1124
extern char *( __attribute__((__nonnull__(1,2), __leaf__)) crypt)(char const   *__key ,
                                                                  char const   *__salt )  __attribute__((__nothrow__)) ;
#line 1133
extern void ( __attribute__((__nonnull__(1,2), __leaf__)) swab)(void const   * __restrict  __from ,
                                                                void * __restrict  __to ,
                                                                ssize_t __n )  __attribute__((__nothrow__)) ;
#line 1161
extern int ( __attribute__((__warn_unused_result__)) getentropy)(void *__buffer ,
                                                                 size_t __length ) ;
#line 48 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread_chk)(int __fd , void *__buf ,
                                                                      size_t __nbytes ,
                                                                      __off_t __offset ,
                                                                      size_t __bufsize ) ;
#line 50
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread64_chk)(int __fd ,
                                                                        void *__buf ,
                                                                        size_t __nbytes ,
                                                                        __off_t __offset ,
                                                                        size_t __bufsize ) ;
#line 52
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread_alias)(int __fd ,
                                                                        void *__buf ,
                                                                        size_t __nbytes ,
                                                                        __off_t __offset )  __asm__("pread")  ;
#line 55
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread64_alias)(int __fd ,
                                                                          void *__buf ,
                                                                          size_t __nbytes ,
                                                                          __off_t __offset )  __asm__("pread64")  ;
#line 58
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread_chk_warn)(int __fd ,
                                                                           void *__buf ,
                                                                           size_t __nbytes ,
                                                                           __off_t __offset ,
                                                                           size_t __bufsize )  __asm__("__pread_chk") __attribute__((__warning__("pread called with bigger length than size of the destination buffer"))) ;
#line 63
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread64_chk_warn)(int __fd ,
                                                                             void *__buf ,
                                                                             size_t __nbytes ,
                                                                             __off_t __offset ,
                                                                             size_t __bufsize )  __asm__("__pread64_chk") __attribute__((__warning__("pread64 called with bigger length than size of the destination buffer"))) ;
#line 71 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) pread)(int __fd , void *__buf , size_t __nbytes , __off_t __offset )
{
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 74
  tmp___4 = __builtin_object_size(__buf, 0);
#line 74
  if (tmp___4 != 18446744073709551615UL) {
#line 76
    if (1) {
#line 77
      tmp = __builtin_object_size(__buf, 0);
#line 77
      tmp___0 = __pread_chk(__fd, __buf, __nbytes, __offset, tmp);
#line 77
      return (tmp___0);
    }
#line 79
    tmp___3 = __builtin_object_size(__buf, 0);
#line 79
    if (__nbytes > tmp___3) {
#line 80
      tmp___1 = __builtin_object_size(__buf, 0);
#line 80
      tmp___2 = __pread_chk_warn(__fd, __buf, __nbytes, __offset, tmp___1);
#line 80
      return (tmp___2);
    }
  }
#line 83
  tmp___5 = __pread_alias(__fd, __buf, __nbytes, __offset);
#line 83
  return (tmp___5);
}
}
#line 104 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) pread64)(int __fd , void *__buf , size_t __nbytes , __off_t __offset )
{
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 107
  tmp___4 = __builtin_object_size(__buf, 0);
#line 107
  if (tmp___4 != 18446744073709551615UL) {
#line 109
    if (1) {
#line 110
      tmp = __builtin_object_size(__buf, 0);
#line 110
      tmp___0 = __pread64_chk(__fd, __buf, __nbytes, __offset, tmp);
#line 110
      return (tmp___0);
    }
#line 112
    tmp___3 = __builtin_object_size(__buf, 0);
#line 112
    if (__nbytes > tmp___3) {
#line 113
      tmp___1 = __builtin_object_size(__buf, 0);
#line 113
      tmp___2 = __pread64_chk_warn(__fd, __buf, __nbytes, __offset, tmp___1);
#line 113
      return (tmp___2);
    }
  }
#line 117
  tmp___5 = __pread64_alias(__fd, __buf, __nbytes, __offset);
#line 117
  return (tmp___5);
}
}
#line 123
extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(1,2), __leaf__)) __readlink_chk)(char const   * __restrict  __path ,
                                                                                                     char * __restrict  __buf ,
                                                                                                     size_t __len ,
                                                                                                     size_t __buflen )  __attribute__((__nothrow__)) ;
#line 127
extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(1,2), __leaf__)) __readlink_alias)(char const   * __restrict  __path ,
                                                                                                       char * __restrict  __buf ,
                                                                                                       size_t __len )  __asm__("readlink") __attribute__((__nothrow__)) ;
#line 131
extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(1,2), __leaf__)) __readlink_chk_warn)(char const   * __restrict  __path ,
                                                                                                          char * __restrict  __buf ,
                                                                                                          size_t __len ,
                                                                                                          size_t __buflen )  __asm__("__readlink_chk") __attribute__((__warning__("readlink called with bigger length than size of destination buffer"),
__nothrow__)) ;
#line 138
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(1,2),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) readlink)(char const   *__path ,
                                                                        char *__buf ,
                                                                        size_t __len )  __attribute__((__nothrow__)) ;
#line 138 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(1,2),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) readlink)(char const   *__path ,
                                                                        char *__buf ,
                                                                        size_t __len )
{
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 142
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 142
  if (tmp___4 != 18446744073709551615UL) {
#line 144
    if (1) {
#line 145
      tmp = __builtin_object_size((void *)__buf, 1);
#line 145
      tmp___0 = __readlink_chk((char const   * __restrict  )__path, (char * __restrict  )__buf,
                               __len, tmp);
#line 145
      return (tmp___0);
    }
#line 147
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 147
    if (__len > tmp___3) {
#line 148
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 148
      tmp___2 = __readlink_chk_warn((char const   * __restrict  )__path, (char * __restrict  )__buf,
                                    __len, tmp___1);
#line 148
      return (tmp___2);
    }
  }
#line 150
  tmp___5 = __readlink_alias((char const   * __restrict  )__path, (char * __restrict  )__buf,
                             __len);
#line 150
  return (tmp___5);
}
}
#line 155
extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(2,3), __leaf__)) __readlinkat_chk)(int __fd ,
                                                                                                       char const   * __restrict  __path ,
                                                                                                       char * __restrict  __buf ,
                                                                                                       size_t __len ,
                                                                                                       size_t __buflen )  __attribute__((__nothrow__)) ;
#line 159
extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(2,3), __leaf__)) __readlinkat_alias)(int __fd ,
                                                                                                         char const   * __restrict  __path ,
                                                                                                         char * __restrict  __buf ,
                                                                                                         size_t __len )  __asm__("readlinkat") __attribute__((__nothrow__)) ;
#line 164
extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(2,3), __leaf__)) __readlinkat_chk_warn)(int __fd ,
                                                                                                            char const   * __restrict  __path ,
                                                                                                            char * __restrict  __buf ,
                                                                                                            size_t __len ,
                                                                                                            size_t __buflen )  __asm__("__readlinkat_chk") __attribute__((__warning__("readlinkat called with bigger length than size of destination buffer"),
__nothrow__)) ;
#line 172
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(2,3),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) readlinkat)(int __fd ,
                                                                          char const   *__path ,
                                                                          char *__buf ,
                                                                          size_t __len )  __attribute__((__nothrow__)) ;
#line 172 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(2,3),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) readlinkat)(int __fd ,
                                                                          char const   *__path ,
                                                                          char *__buf ,
                                                                          size_t __len )
{
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 176
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 176
  if (tmp___4 != 18446744073709551615UL) {
#line 178
    if (1) {
#line 179
      tmp = __builtin_object_size((void *)__buf, 1);
#line 179
      tmp___0 = __readlinkat_chk(__fd, (char const   * __restrict  )__path, (char * __restrict  )__buf,
                                 __len, tmp);
#line 179
      return (tmp___0);
    }
#line 181
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 181
    if (__len > tmp___3) {
#line 182
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 182
      tmp___2 = __readlinkat_chk_warn(__fd, (char const   * __restrict  )__path, (char * __restrict  )__buf,
                                      __len, tmp___1);
#line 182
      return (tmp___2);
    }
  }
#line 185
  tmp___5 = __readlinkat_alias(__fd, (char const   * __restrict  )__path, (char * __restrict  )__buf,
                               __len);
#line 185
  return (tmp___5);
}
}
#line 214
extern char *( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) __getwd_chk)(char *__buf ,
                                                                                              size_t buflen )  __attribute__((__nothrow__)) ;
#line 216
extern char *( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) __getwd_warn)(char *__buf )  __asm__("getwd") __attribute__((__warning__("please use getcwd instead, as getwd doesn\'t specify buffer size"),
__nothrow__)) ;
#line 220
__inline extern char __attribute__((__deprecated__))  *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __gnu_inline__, __artificial__, __always_inline__)) getwd)(char *__buf )  __attribute__((__nothrow__,
__deprecated__)) ;
#line 220 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char __attribute__((__deprecated__))  *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __gnu_inline__, __artificial__, __always_inline__)) getwd)(char *__buf )
{
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;

  {
#line 223
  tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 223
  if (tmp___1 != 18446744073709551615UL) {
#line 224
    tmp = __builtin_object_size((void *)__buf, 1);
#line 224
    tmp___0 = __getwd_chk(__buf, tmp);
#line 224
    return ((char __attribute__((__deprecated__))  *)tmp___0);
  }
#line 225
  tmp___2 = __getwd_warn(__buf);
#line 225
  return ((char __attribute__((__deprecated__))  *)tmp___2);
}
}
#line 306
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_chk)(char *__buf , size_t __buflen ,
                                                               size_t __nreal ) ;
#line 308
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_alias)(char *__buf , size_t __buflen )  __asm__("getlogin_r")  ;
#line 310
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_chk_warn)(char *__buf ,
                                                                    size_t __buflen ,
                                                                    size_t __nreal )  __asm__("__getlogin_r_chk") __attribute__((__warning__("getlogin_r called with bigger buflen than size of destination buffer"))) ;
#line 316 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__, __artificial__,
__always_inline__)) getlogin_r)(char *__buf , size_t __buflen )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 319
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 319
  if (tmp___4 != 18446744073709551615UL) {
#line 321
    if (1) {
#line 322
      tmp = __builtin_object_size((void *)__buf, 1);
#line 322
      tmp___0 = __getlogin_r_chk(__buf, __buflen, tmp);
#line 322
      return (tmp___0);
    }
#line 324
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 324
    if (__buflen > tmp___3) {
#line 325
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 325
      tmp___2 = __getlogin_r_chk_warn(__buf, __buflen, tmp___1);
#line 325
      return (tmp___2);
    }
  }
#line 327
  tmp___5 = __getlogin_r_alias(__buf, __buflen);
#line 327
  return (tmp___5);
}
}
#line 333
extern int ( __attribute__((__nonnull__(1), __leaf__)) __gethostname_chk)(char *__buf ,
                                                                          size_t __buflen ,
                                                                          size_t __nreal )  __attribute__((__nothrow__)) ;
#line 335
extern int ( __attribute__((__nonnull__(1), __leaf__)) __gethostname_alias)(char *__buf ,
                                                                            size_t __buflen )  __asm__("gethostname") __attribute__((__nothrow__)) ;
#line 337
extern int ( __attribute__((__nonnull__(1), __leaf__)) __gethostname_chk_warn)(char *__buf ,
                                                                               size_t __buflen ,
                                                                               size_t __nreal )  __asm__("__gethostname_chk") __attribute__((__warning__("gethostname called with bigger buflen than size of destination buffer"),
__nothrow__)) ;
#line 343
__inline extern int ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) gethostname)(char *__buf , size_t __buflen )  __attribute__((__nothrow__)) ;
#line 343 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) gethostname)(char *__buf , size_t __buflen )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 346
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 346
  if (tmp___4 != 18446744073709551615UL) {
#line 348
    if (1) {
#line 349
      tmp = __builtin_object_size((void *)__buf, 1);
#line 349
      tmp___0 = __gethostname_chk(__buf, __buflen, tmp);
#line 349
      return (tmp___0);
    }
#line 351
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 351
    if (__buflen > tmp___3) {
#line 352
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 352
      tmp___2 = __gethostname_chk_warn(__buf, __buflen, tmp___1);
#line 352
      return (tmp___2);
    }
  }
#line 354
  tmp___5 = __gethostname_alias(__buf, __buflen);
#line 354
  return (tmp___5);
}
}
#line 360
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) __getdomainname_chk)(char *__buf ,
                                                                                                    size_t __buflen ,
                                                                                                    size_t __nreal )  __attribute__((__nothrow__)) ;
#line 362
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) __getdomainname_alias)(char *__buf ,
                                                                                                      size_t __buflen )  __asm__("getdomainname") __attribute__((__nothrow__)) ;
#line 365
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) __getdomainname_chk_warn)(char *__buf ,
                                                                                                         size_t __buflen ,
                                                                                                         size_t __nreal )  __asm__("__getdomainname_chk") __attribute__((__warning__("getdomainname called with bigger buflen than size of destination buffer"),
__nothrow__)) ;
#line 372
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) getdomainname)(char *__buf , size_t __buflen )  __attribute__((__nothrow__)) ;
#line 372 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) getdomainname)(char *__buf , size_t __buflen )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 375
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 375
  if (tmp___4 != 18446744073709551615UL) {
#line 377
    if (1) {
#line 378
      tmp = __builtin_object_size((void *)__buf, 1);
#line 378
      tmp___0 = __getdomainname_chk(__buf, __buflen, tmp);
#line 378
      return (tmp___0);
    }
#line 380
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 380
    if (__buflen > tmp___3) {
#line 381
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 381
      tmp___2 = __getdomainname_chk_warn(__buf, __buflen, tmp___1);
#line 381
      return (tmp___2);
    }
  }
#line 383
  tmp___5 = __getdomainname_alias(__buf, __buflen);
#line 383
  return (tmp___5);
}
}
#line 34 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h"
extern __pid_t ( __attribute__((__leaf__)) gettid)(void)  __attribute__((__nothrow__)) ;
#line 1840 "/usr/include/zlib.h"
extern gzFile gzopen64(char const   * , char const   * ) ;
#line 1841
extern off_t gzseek64(gzFile  , off_t  , int  ) ;
#line 1842
extern off_t gztell64(gzFile  ) ;
#line 1843
extern off_t gzoffset64(gzFile  ) ;
#line 1844
extern uLong adler32_combine64(uLong  , uLong  , off_t  ) ;
#line 1845
extern uLong crc32_combine64(uLong  , uLong  , off_t  ) ;
#line 101 "/usr/include/stdlib.h"
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 104
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 107
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 112
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__leaf__, __gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__,
__nothrow__)) ;
#line 140
extern float ( __attribute__((__nonnull__(1), __leaf__)) strtof32)(char const   * __restrict  __nptr ,
                                                                   char ** __restrict  __endptr )  __attribute__((__nothrow__)) ;
#line 146
extern double ( __attribute__((__nonnull__(1), __leaf__)) strtof64)(char const   * __restrict  __nptr ,
                                                                    char ** __restrict  __endptr )  __attribute__((__nothrow__)) ;
#line 152
extern _Float128 ( __attribute__((__nonnull__(1), __leaf__)) strtof128)(char const   * __restrict  __nptr ,
                                                                        char ** __restrict  __endptr )  __attribute__((__nothrow__)) ;
#line 158
extern double ( __attribute__((__nonnull__(1), __leaf__)) strtof32x)(char const   * __restrict  __nptr ,
                                                                     char ** __restrict  __endptr )  __attribute__((__nothrow__)) ;
#line 164
extern long double ( __attribute__((__nonnull__(1), __leaf__)) strtof64x)(char const   * __restrict  __nptr ,
                                                                          char ** __restrict  __endptr )  __attribute__((__nothrow__)) ;
#line 212
extern int ( __attribute__((__nonnull__(3), __leaf__)) strfromd)(char *__dest , size_t __size ,
                                                                 char const   *__format ,
                                                                 double __f )  __attribute__((__nothrow__)) ;
#line 216
extern int ( __attribute__((__nonnull__(3), __leaf__)) strfromf)(char *__dest , size_t __size ,
                                                                 char const   *__format ,
                                                                 float __f )  __attribute__((__nothrow__)) ;
#line 220
extern int ( __attribute__((__nonnull__(3), __leaf__)) strfroml)(char *__dest , size_t __size ,
                                                                 char const   *__format ,
                                                                 long double __f )  __attribute__((__nothrow__)) ;
#line 232
extern int ( __attribute__((__nonnull__(3), __leaf__)) strfromf32)(char *__dest ,
                                                                   size_t __size ,
                                                                   char const   *__format ,
                                                                   float __f )  __attribute__((__nothrow__)) ;
#line 238
extern int ( __attribute__((__nonnull__(3), __leaf__)) strfromf64)(char *__dest ,
                                                                   size_t __size ,
                                                                   char const   *__format ,
                                                                   double __f )  __attribute__((__nothrow__)) ;
#line 244
extern int ( __attribute__((__nonnull__(3), __leaf__)) strfromf128)(char *__dest ,
                                                                    size_t __size ,
                                                                    char const   *__format ,
                                                                    _Float128 __f )  __attribute__((__nothrow__)) ;
#line 250
extern int ( __attribute__((__nonnull__(3), __leaf__)) strfromf32x)(char *__dest ,
                                                                    size_t __size ,
                                                                    char const   *__format ,
                                                                    double __f )  __attribute__((__nothrow__)) ;
#line 256
extern int ( __attribute__((__nonnull__(3), __leaf__)) strfromf64x)(char *__dest ,
                                                                    size_t __size ,
                                                                    char const   *__format ,
                                                                    long double __f )  __attribute__((__nothrow__)) ;
#line 274
extern long ( __attribute__((__nonnull__(1,4), __leaf__)) strtol_l)(char const   * __restrict  __nptr ,
                                                                    char ** __restrict  __endptr ,
                                                                    int __base , locale_t __loc )  __attribute__((__nothrow__)) ;
#line 278
extern unsigned long ( __attribute__((__nonnull__(1,4), __leaf__)) strtoul_l)(char const   * __restrict  __nptr ,
                                                                              char ** __restrict  __endptr ,
                                                                              int __base ,
                                                                              locale_t __loc )  __attribute__((__nothrow__)) ;
#line 284
extern long long ( __attribute__((__nonnull__(1,4), __leaf__)) strtoll_l)(char const   * __restrict  __nptr ,
                                                                          char ** __restrict  __endptr ,
                                                                          int __base ,
                                                                          locale_t __loc )  __attribute__((__nothrow__)) ;
#line 290
extern unsigned long long ( __attribute__((__nonnull__(1,4), __leaf__)) strtoull_l)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ,
                                                                                    locale_t __loc )  __attribute__((__nothrow__)) ;
#line 295
extern double ( __attribute__((__nonnull__(1,3), __leaf__)) strtod_l)(char const   * __restrict  __nptr ,
                                                                      char ** __restrict  __endptr ,
                                                                      locale_t __loc )  __attribute__((__nothrow__)) ;
#line 299
extern float ( __attribute__((__nonnull__(1,3), __leaf__)) strtof_l)(char const   * __restrict  __nptr ,
                                                                     char ** __restrict  __endptr ,
                                                                     locale_t __loc )  __attribute__((__nothrow__)) ;
#line 303
extern long double ( __attribute__((__nonnull__(1,3), __leaf__)) strtold_l)(char const   * __restrict  __nptr ,
                                                                            char ** __restrict  __endptr ,
                                                                            locale_t __loc )  __attribute__((__nothrow__)) ;
#line 316
extern float ( __attribute__((__nonnull__(1,3), __leaf__)) strtof32_l)(char const   * __restrict  __nptr ,
                                                                       char ** __restrict  __endptr ,
                                                                       locale_t __loc )  __attribute__((__nothrow__)) ;
#line 323
extern double ( __attribute__((__nonnull__(1,3), __leaf__)) strtof64_l)(char const   * __restrict  __nptr ,
                                                                        char ** __restrict  __endptr ,
                                                                        locale_t __loc )  __attribute__((__nothrow__)) ;
#line 330
extern _Float128 ( __attribute__((__nonnull__(1,3), __leaf__)) strtof128_l)(char const   * __restrict  __nptr ,
                                                                            char ** __restrict  __endptr ,
                                                                            locale_t __loc )  __attribute__((__nothrow__)) ;
#line 337
extern double ( __attribute__((__nonnull__(1,3), __leaf__)) strtof32x_l)(char const   * __restrict  __nptr ,
                                                                         char ** __restrict  __endptr ,
                                                                         locale_t __loc )  __attribute__((__nothrow__)) ;
#line 344
extern long double ( __attribute__((__nonnull__(1,3), __leaf__)) strtof64x_l)(char const   * __restrict  __nptr ,
                                                                              char ** __restrict  __endptr ,
                                                                              locale_t __loc )  __attribute__((__nothrow__)) ;
#line 639
extern char *( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) secure_getenv)(char const   *__name )  __attribute__((__nothrow__)) ;
#line 698
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1))) mkstemp64)(char *__template ) ;
#line 720
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1))) mkstemps64)(char *__template ,
                                                                                 int __suffixlen ) ;
#line 742
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1))) mkostemp)(char *__template ,
                                                                               int __flags ) ;
#line 752
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1))) mkostemp64)(char *__template ,
                                                                                 int __flags ) ;
#line 762
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1))) mkostemps)(char *__template ,
                                                                                int __suffixlen ,
                                                                                int __flags ) ;
#line 774
extern int ( __attribute__((__warn_unused_result__, __nonnull__(1))) mkostemps64)(char *__template ,
                                                                                  int __suffixlen ,
                                                                                  int __flags ) ;
#line 790
extern char *( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) canonicalize_file_name)(char const   *__name )  __attribute__((__nothrow__)) ;
#line 800
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) realpath___17)(char const   *__name , char *__resolved )  __attribute__((__nothrow__)) ;
#line 820
__inline extern void *( __attribute__((__warn_unused_result__, __nonnull__(1,2,5),
__gnu_inline__)) bsearch)(void const   *__key , void const   *__base , size_t __nmemb ,
                          size_t __size , int (*__compar)(void const   * , void const   * ) ) ;
#line 833
extern void ( __attribute__((__nonnull__(1,4))) qsort_r)(void *__base , size_t __nmemb ,
                                                         size_t __size , int (*__compar)(void const   * ,
                                                                                         void const   * ,
                                                                                         void * ) ,
                                                         void *__arg ) ;
#line 929
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar )  __attribute__((__nothrow__)) ;
#line 933
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t *__dst , char const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 936
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) wcstombs)(char *__dst , wchar_t const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 968
extern int ( __attribute__((__warn_unused_result__)) posix_openpt)(int __oflag ) ;
#line 976
extern int ( __attribute__((__leaf__)) grantpt)(int __fd )  __attribute__((__nothrow__)) ;
#line 980
extern int ( __attribute__((__leaf__)) unlockpt)(int __fd )  __attribute__((__nothrow__)) ;
#line 985
extern char *( __attribute__((__warn_unused_result__, __leaf__)) ptsname)(int __fd )  __attribute__((__nothrow__)) ;
#line 992
__inline extern int ( __attribute__((__nonnull__(2), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) ptsname_r___17)(int __fd , char *__buf , size_t __buflen )  __attribute__((__nothrow__)) ;
#line 996
extern int getpt(void) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) realpath___17)(char const   *__name , char *__resolved )  __attribute__((__nothrow__)) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) realpath___17)(char const   *__name , char *__resolved )
{
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;

  {
#line 39
  tmp___4 = __builtin_object_size((void *)__resolved, 1);
#line 39
  if (tmp___4 != 18446744073709551615UL) {
#line 42
    tmp___1 = __builtin_object_size((void *)__resolved, 1);
#line 42
    if (tmp___1 < 4096UL) {
#line 43
      tmp = __builtin_object_size((void *)__resolved, 1);
#line 43
      tmp___0 = __realpath_chk_warn((char const   * __restrict  )__name, (char * __restrict  )__resolved,
                                    tmp);
#line 43
      return (tmp___0);
    }
#line 45
    tmp___2 = __builtin_object_size((void *)__resolved, 1);
#line 45
    tmp___3 = __realpath_chk((char const   * __restrict  )__name, (char * __restrict  )__resolved,
                             tmp___2);
#line 45
    return (tmp___3);
  }
#line 48
  tmp___5 = __realpath_alias((char const   * __restrict  )__name, (char * __restrict  )__resolved);
#line 48
  return (tmp___5);
}
}
#line 63
__inline extern int ( __attribute__((__nonnull__(2), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) ptsname_r___17)(int __fd , char *__buf , size_t __buflen )  __attribute__((__nothrow__)) ;
#line 63 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ( __attribute__((__nonnull__(2), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) ptsname_r___17)(int __fd , char *__buf , size_t __buflen )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 66
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 66
  if (tmp___4 != 18446744073709551615UL) {
#line 68
    if (1) {
#line 69
      tmp = __builtin_object_size((void *)__buf, 1);
#line 69
      tmp___0 = __ptsname_r_chk(__fd, __buf, __buflen, tmp);
#line 69
      return (tmp___0);
    }
#line 70
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 70
    if (__buflen > tmp___3) {
#line 71
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 71
      tmp___2 = __ptsname_r_chk_warn(__fd, __buf, __buflen, tmp___1);
#line 71
      return (tmp___2);
    }
  }
#line 73
  tmp___5 = __ptsname_r_alias(__fd, __buf, __buflen);
#line 73
  return (tmp___5);
}
}
#line 43 "/usr/include/string.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memcpy)(void *__dest , void const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 47
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 61
__inline extern void *( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) memset)(void *__dest , int __ch , size_t __len )  __attribute__((__nothrow__)) ;
#line 104
extern void *( __attribute__((__nonnull__(1), __leaf__)) rawmemchr)(void const   *__s ,
                                                                    int __c )  __attribute__((__pure__,
__nothrow__)) ;
#line 115
extern void *( __attribute__((__nonnull__(1), __leaf__)) memrchr)(void const   *__s ,
                                                                  int __c , size_t __n )  __attribute__((__pure__,
__nothrow__)) ;
#line 122
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcpy)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 125
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncpy)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 130
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcat)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 133
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncat)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 266
extern char *( __attribute__((__nonnull__(1), __leaf__)) strchrnul)(char const   *__s ,
                                                                    int __c )  __attribute__((__pure__,
__nothrow__)) ;
#line 360
extern char *( __attribute__((__nonnull__(1,2), __leaf__)) strcasestr)(char const   *__haystack ,
                                                                       char const   *__needle )  __attribute__((__pure__,
__nothrow__)) ;
#line 369
extern void *( __attribute__((__nonnull__(1,3), __leaf__)) memmem)(void const   *__haystack ,
                                                                   size_t __haystacklen ,
                                                                   void const   *__needle ,
                                                                   size_t __needlelen )  __attribute__((__pure__,
__nothrow__)) ;
#line 375
extern void *( __attribute__((__nonnull__(1,2), __leaf__)) __mempcpy)(void * __restrict  __dest ,
                                                                      void const   * __restrict  __src ,
                                                                      size_t __n )  __attribute__((__nothrow__)) ;
#line 378
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) mempcpy)(void *__dest , void const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 38 "/usr/include/strings.h"
__inline extern void ( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) bcopy)(void const   *__src , void *__dest , size_t __len )  __attribute__((__nothrow__)) ;
#line 42
__inline extern void ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) bzero)(void *__dest , size_t __len )  __attribute__((__nothrow__)) ;
#line 436 "/usr/include/string.h"
__inline extern void ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) explicit_bzero)(void *__dest , size_t __len )  __attribute__((__nothrow__)) ;
#line 452
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) stpcpy___0)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 460
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) stpncpy)(char *__dest , char const   *__src ,
                                             size_t __n )  __attribute__((__nothrow__)) ;
#line 467
extern int ( __attribute__((__nonnull__(1,2), __leaf__)) strverscmp)(char const   *__s1 ,
                                                                     char const   *__s2 )  __attribute__((__pure__,
__nothrow__)) ;
#line 471
extern char *( __attribute__((__nonnull__(1), __leaf__)) strfry)(char *__string )  __attribute__((__nothrow__)) ;
#line 474
extern void *( __attribute__((__nonnull__(1), __leaf__)) memfrob)(void *__s , size_t __n )  __attribute__((__nothrow__)) ;
#line 487
extern char *( __attribute__((__nonnull__(1), __leaf__)) basename)(char const   *__filename )  __attribute__((__nothrow__)) ;
#line 44 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) mempcpy)(void *__dest , void const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 44 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) mempcpy)(void *__dest , void const   *__src ,
                                             size_t __len )
{
  unsigned long tmp ;
  void *tmp___0 ;

  {
#line 48
  tmp = __builtin_object_size(__dest, 0);
#line 48
  tmp___0 = __builtin___mempcpy_chk(__dest, __src, __len, tmp);
#line 48
  return (tmp___0);
}
}
#line 94
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) stpcpy___0)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 94 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) stpcpy___0)(char *__dest , char const   *__src )
{
  unsigned long tmp ;
  char *tmp___0 ;

  {
#line 97
  tmp = __builtin_object_size((void *)__dest, 1);
#line 97
  tmp___0 = __builtin___stpcpy_chk(__dest, __src, tmp);
#line 97
  return (tmp___0);
}
}
#line 79 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern void ( __attribute__((__leaf__)) sincos)(double __x , double *__sinx , double *__cosx )  __attribute__((__nothrow__)) ;
#line 79
extern void ( __attribute__((__leaf__)) __sincos)(double __x , double *__sinx , double *__cosx )  __attribute__((__nothrow__)) ;
#line 114
extern double ( __attribute__((__leaf__)) exp10)(double __x )  __attribute__((__nothrow__)) ;
#line 114
extern double ( __attribute__((__leaf__)) __exp10)(double __x )  __attribute__((__nothrow__)) ;
#line 266
extern double ( __attribute__((__leaf__)) nextdown)(double __x )  __attribute__((__nothrow__)) ;
#line 266
extern double ( __attribute__((__leaf__)) __nextdown)(double __x )  __attribute__((__nothrow__)) ;
#line 268
extern double ( __attribute__((__leaf__)) nextup)(double __x )  __attribute__((__nothrow__)) ;
#line 268
extern double ( __attribute__((__leaf__)) __nextup)(double __x )  __attribute__((__nothrow__)) ;
#line 285
extern long ( __attribute__((__leaf__)) llogb)(double __x )  __attribute__((__nothrow__)) ;
#line 285
extern long ( __attribute__((__leaf__)) __llogb)(double __x )  __attribute__((__nothrow__)) ;
#line 340
extern double ( __attribute__((__leaf__)) roundeven)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 340
extern double ( __attribute__((__leaf__)) __roundeven)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 344
extern __intmax_t ( __attribute__((__leaf__)) fromfp)(double __x , int __round , unsigned int __width )  __attribute__((__nothrow__)) ;
#line 344
extern __intmax_t ( __attribute__((__leaf__)) __fromfp)(double __x , int __round ,
                                                        unsigned int __width )  __attribute__((__nothrow__)) ;
#line 349
extern __uintmax_t ( __attribute__((__leaf__)) ufromfp)(double __x , int __round ,
                                                        unsigned int __width )  __attribute__((__nothrow__)) ;
#line 349
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfp)(double __x , int __round ,
                                                          unsigned int __width )  __attribute__((__nothrow__)) ;
#line 355
extern __intmax_t ( __attribute__((__leaf__)) fromfpx)(double __x , int __round ,
                                                       unsigned int __width )  __attribute__((__nothrow__)) ;
#line 355
extern __intmax_t ( __attribute__((__leaf__)) __fromfpx)(double __x , int __round ,
                                                         unsigned int __width )  __attribute__((__nothrow__)) ;
#line 361
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpx)(double __x , int __round ,
                                                         unsigned int __width )  __attribute__((__nothrow__)) ;
#line 361
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpx)(double __x , int __round ,
                                                           unsigned int __width )  __attribute__((__nothrow__)) ;
#line 365
extern double ( __attribute__((__leaf__)) fmaxmag)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 365
extern double ( __attribute__((__leaf__)) __fmaxmag)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 368
extern double ( __attribute__((__leaf__)) fminmag)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 368
extern double ( __attribute__((__leaf__)) __fminmag)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 371
extern int ( __attribute__((__leaf__)) canonicalize)(double *__cx , double const   *__x )  __attribute__((__nothrow__)) ;
#line 376
extern int ( __attribute__((__leaf__)) totalorder)(double const   *__x , double const   *__y )  __attribute__((__pure__,
__nothrow__)) ;
#line 381
extern int ( __attribute__((__leaf__)) totalordermag)(double const   *__x , double const   *__y )  __attribute__((__pure__,
__nothrow__)) ;
#line 386
extern double ( __attribute__((__leaf__)) getpayload)(double const   *__x )  __attribute__((__nothrow__)) ;
#line 386
extern double ( __attribute__((__leaf__)) __getpayload)(double const   *__x )  __attribute__((__nothrow__)) ;
#line 389
extern int ( __attribute__((__leaf__)) setpayload)(double *__x , double __payload )  __attribute__((__nothrow__)) ;
#line 392
extern int ( __attribute__((__leaf__)) setpayloadsig)(double *__x , double __payload )  __attribute__((__nothrow__)) ;
#line 79
extern void ( __attribute__((__leaf__)) sincosf)(float __x , float *__sinx , float *__cosx )  __attribute__((__nothrow__)) ;
#line 79
extern void ( __attribute__((__leaf__)) __sincosf)(float __x , float *__sinx , float *__cosx )  __attribute__((__nothrow__)) ;
#line 114
extern float ( __attribute__((__leaf__)) exp10f)(float __x )  __attribute__((__nothrow__)) ;
#line 114
extern float ( __attribute__((__leaf__)) __exp10f)(float __x )  __attribute__((__nothrow__)) ;
#line 266
extern float ( __attribute__((__leaf__)) nextdownf)(float __x )  __attribute__((__nothrow__)) ;
#line 266
extern float ( __attribute__((__leaf__)) __nextdownf)(float __x )  __attribute__((__nothrow__)) ;
#line 268
extern float ( __attribute__((__leaf__)) nextupf)(float __x )  __attribute__((__nothrow__)) ;
#line 268
extern float ( __attribute__((__leaf__)) __nextupf)(float __x )  __attribute__((__nothrow__)) ;
#line 285
extern long ( __attribute__((__leaf__)) llogbf)(float __x )  __attribute__((__nothrow__)) ;
#line 285
extern long ( __attribute__((__leaf__)) __llogbf)(float __x )  __attribute__((__nothrow__)) ;
#line 340
extern float ( __attribute__((__leaf__)) roundevenf)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 340
extern float ( __attribute__((__leaf__)) __roundevenf)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 344
extern __intmax_t ( __attribute__((__leaf__)) fromfpf)(float __x , int __round , unsigned int __width )  __attribute__((__nothrow__)) ;
#line 344
extern __intmax_t ( __attribute__((__leaf__)) __fromfpf)(float __x , int __round ,
                                                         unsigned int __width )  __attribute__((__nothrow__)) ;
#line 349
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpf)(float __x , int __round ,
                                                         unsigned int __width )  __attribute__((__nothrow__)) ;
#line 349
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpf)(float __x , int __round ,
                                                           unsigned int __width )  __attribute__((__nothrow__)) ;
#line 355
extern __intmax_t ( __attribute__((__leaf__)) fromfpxf)(float __x , int __round ,
                                                        unsigned int __width )  __attribute__((__nothrow__)) ;
#line 355
extern __intmax_t ( __attribute__((__leaf__)) __fromfpxf)(float __x , int __round ,
                                                          unsigned int __width )  __attribute__((__nothrow__)) ;
#line 361
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpxf)(float __x , int __round ,
                                                          unsigned int __width )  __attribute__((__nothrow__)) ;
#line 361
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpxf)(float __x , int __round ,
                                                            unsigned int __width )  __attribute__((__nothrow__)) ;
#line 365
extern float ( __attribute__((__leaf__)) fmaxmagf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 365
extern float ( __attribute__((__leaf__)) __fmaxmagf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 368
extern float ( __attribute__((__leaf__)) fminmagf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 368
extern float ( __attribute__((__leaf__)) __fminmagf)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 371
extern int ( __attribute__((__leaf__)) canonicalizef)(float *__cx , float const   *__x )  __attribute__((__nothrow__)) ;
#line 376
extern int ( __attribute__((__leaf__)) totalorderf)(float const   *__x , float const   *__y )  __attribute__((__pure__,
__nothrow__)) ;
#line 381
extern int ( __attribute__((__leaf__)) totalordermagf)(float const   *__x , float const   *__y )  __attribute__((__pure__,
__nothrow__)) ;
#line 386
extern float ( __attribute__((__leaf__)) getpayloadf)(float const   *__x )  __attribute__((__nothrow__)) ;
#line 386
extern float ( __attribute__((__leaf__)) __getpayloadf)(float const   *__x )  __attribute__((__nothrow__)) ;
#line 389
extern int ( __attribute__((__leaf__)) setpayloadf)(float *__x , float __payload )  __attribute__((__nothrow__)) ;
#line 392
extern int ( __attribute__((__leaf__)) setpayloadsigf)(float *__x , float __payload )  __attribute__((__nothrow__)) ;
#line 79
extern void ( __attribute__((__leaf__)) sincosl)(long double __x , long double *__sinx ,
                                                 long double *__cosx )  __attribute__((__nothrow__)) ;
#line 79
extern void ( __attribute__((__leaf__)) __sincosl)(long double __x , long double *__sinx ,
                                                   long double *__cosx )  __attribute__((__nothrow__)) ;
#line 114
extern long double ( __attribute__((__leaf__)) exp10l)(long double __x )  __attribute__((__nothrow__)) ;
#line 114
extern long double ( __attribute__((__leaf__)) __exp10l)(long double __x )  __attribute__((__nothrow__)) ;
#line 266
extern long double ( __attribute__((__leaf__)) nextdownl)(long double __x )  __attribute__((__nothrow__)) ;
#line 266
extern long double ( __attribute__((__leaf__)) __nextdownl)(long double __x )  __attribute__((__nothrow__)) ;
#line 268
extern long double ( __attribute__((__leaf__)) nextupl)(long double __x )  __attribute__((__nothrow__)) ;
#line 268
extern long double ( __attribute__((__leaf__)) __nextupl)(long double __x )  __attribute__((__nothrow__)) ;
#line 285
extern long ( __attribute__((__leaf__)) llogbl)(long double __x )  __attribute__((__nothrow__)) ;
#line 285
extern long ( __attribute__((__leaf__)) __llogbl)(long double __x )  __attribute__((__nothrow__)) ;
#line 340
extern long double ( __attribute__((__leaf__)) roundevenl)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 340
extern long double ( __attribute__((__leaf__)) __roundevenl)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 344
extern __intmax_t ( __attribute__((__leaf__)) fromfpl)(long double __x , int __round ,
                                                       unsigned int __width )  __attribute__((__nothrow__)) ;
#line 344
extern __intmax_t ( __attribute__((__leaf__)) __fromfpl)(long double __x , int __round ,
                                                         unsigned int __width )  __attribute__((__nothrow__)) ;
#line 349
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpl)(long double __x , int __round ,
                                                         unsigned int __width )  __attribute__((__nothrow__)) ;
#line 349
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpl)(long double __x , int __round ,
                                                           unsigned int __width )  __attribute__((__nothrow__)) ;
#line 355
extern __intmax_t ( __attribute__((__leaf__)) fromfpxl)(long double __x , int __round ,
                                                        unsigned int __width )  __attribute__((__nothrow__)) ;
#line 355
extern __intmax_t ( __attribute__((__leaf__)) __fromfpxl)(long double __x , int __round ,
                                                          unsigned int __width )  __attribute__((__nothrow__)) ;
#line 361
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpxl)(long double __x , int __round ,
                                                          unsigned int __width )  __attribute__((__nothrow__)) ;
#line 361
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpxl)(long double __x , int __round ,
                                                            unsigned int __width )  __attribute__((__nothrow__)) ;
#line 365
extern long double ( __attribute__((__leaf__)) fmaxmagl)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 365
extern long double ( __attribute__((__leaf__)) __fmaxmagl)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 368
extern long double ( __attribute__((__leaf__)) fminmagl)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 368
extern long double ( __attribute__((__leaf__)) __fminmagl)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 371
extern int ( __attribute__((__leaf__)) canonicalizel)(long double *__cx , long double const   *__x )  __attribute__((__nothrow__)) ;
#line 376
extern int ( __attribute__((__leaf__)) totalorderl)(long double const   *__x , long double const   *__y )  __attribute__((__pure__,
__nothrow__)) ;
#line 381
extern int ( __attribute__((__leaf__)) totalordermagl)(long double const   *__x ,
                                                       long double const   *__y )  __attribute__((__pure__,
__nothrow__)) ;
#line 386
extern long double ( __attribute__((__leaf__)) getpayloadl)(long double const   *__x )  __attribute__((__nothrow__)) ;
#line 386
extern long double ( __attribute__((__leaf__)) __getpayloadl)(long double const   *__x )  __attribute__((__nothrow__)) ;
#line 389
extern int ( __attribute__((__leaf__)) setpayloadl)(long double *__x , long double __payload )  __attribute__((__nothrow__)) ;
#line 392
extern int ( __attribute__((__leaf__)) setpayloadsigl)(long double *__x , long double __payload )  __attribute__((__nothrow__)) ;
#line 53
extern float ( __attribute__((__leaf__)) acosf32)(float __x )  __attribute__((__nothrow__)) ;
#line 53
extern float ( __attribute__((__leaf__)) __acosf32)(float __x )  __attribute__((__nothrow__)) ;
#line 55
extern float ( __attribute__((__leaf__)) asinf32)(float __x )  __attribute__((__nothrow__)) ;
#line 55
extern float ( __attribute__((__leaf__)) __asinf32)(float __x )  __attribute__((__nothrow__)) ;
#line 57
extern float ( __attribute__((__leaf__)) atanf32)(float __x )  __attribute__((__nothrow__)) ;
#line 57
extern float ( __attribute__((__leaf__)) __atanf32)(float __x )  __attribute__((__nothrow__)) ;
#line 59
extern float ( __attribute__((__leaf__)) atan2f32)(float __y , float __x )  __attribute__((__nothrow__)) ;
#line 59
extern float ( __attribute__((__leaf__)) __atan2f32)(float __y , float __x )  __attribute__((__nothrow__)) ;
#line 62
extern float ( __attribute__((__leaf__)) cosf32)(float __x )  __attribute__((__nothrow__)) ;
#line 62
extern float ( __attribute__((__leaf__)) __cosf32)(float __x )  __attribute__((__nothrow__)) ;
#line 64
extern float ( __attribute__((__leaf__)) sinf32)(float __x )  __attribute__((__nothrow__)) ;
#line 64
extern float ( __attribute__((__leaf__)) __sinf32)(float __x )  __attribute__((__nothrow__)) ;
#line 66
extern float ( __attribute__((__leaf__)) tanf32)(float __x )  __attribute__((__nothrow__)) ;
#line 66
extern float ( __attribute__((__leaf__)) __tanf32)(float __x )  __attribute__((__nothrow__)) ;
#line 71
extern float ( __attribute__((__leaf__)) coshf32)(float __x )  __attribute__((__nothrow__)) ;
#line 71
extern float ( __attribute__((__leaf__)) __coshf32)(float __x )  __attribute__((__nothrow__)) ;
#line 73
extern float ( __attribute__((__leaf__)) sinhf32)(float __x )  __attribute__((__nothrow__)) ;
#line 73
extern float ( __attribute__((__leaf__)) __sinhf32)(float __x )  __attribute__((__nothrow__)) ;
#line 75
extern float ( __attribute__((__leaf__)) tanhf32)(float __x )  __attribute__((__nothrow__)) ;
#line 75
extern float ( __attribute__((__leaf__)) __tanhf32)(float __x )  __attribute__((__nothrow__)) ;
#line 79
extern void ( __attribute__((__leaf__)) sincosf32)(float __x , float *__sinx , float *__cosx )  __attribute__((__nothrow__)) ;
#line 79
extern void ( __attribute__((__leaf__)) __sincosf32)(float __x , float *__sinx , float *__cosx )  __attribute__((__nothrow__)) ;
#line 85
extern float ( __attribute__((__leaf__)) acoshf32)(float __x )  __attribute__((__nothrow__)) ;
#line 85
extern float ( __attribute__((__leaf__)) __acoshf32)(float __x )  __attribute__((__nothrow__)) ;
#line 87
extern float ( __attribute__((__leaf__)) asinhf32)(float __x )  __attribute__((__nothrow__)) ;
#line 87
extern float ( __attribute__((__leaf__)) __asinhf32)(float __x )  __attribute__((__nothrow__)) ;
#line 89
extern float ( __attribute__((__leaf__)) atanhf32)(float __x )  __attribute__((__nothrow__)) ;
#line 89
extern float ( __attribute__((__leaf__)) __atanhf32)(float __x )  __attribute__((__nothrow__)) ;
#line 95
extern float ( __attribute__((__leaf__)) expf32)(float __x )  __attribute__((__nothrow__)) ;
#line 95
extern float ( __attribute__((__leaf__)) __expf32)(float __x )  __attribute__((__nothrow__)) ;
#line 98
extern float ( __attribute__((__leaf__)) frexpf32)(float __x , int *__exponent )  __attribute__((__nothrow__)) ;
#line 98
extern float ( __attribute__((__leaf__)) __frexpf32)(float __x , int *__exponent )  __attribute__((__nothrow__)) ;
#line 101
extern float ( __attribute__((__leaf__)) ldexpf32)(float __x , int __exponent )  __attribute__((__nothrow__)) ;
#line 101
extern float ( __attribute__((__leaf__)) __ldexpf32)(float __x , int __exponent )  __attribute__((__nothrow__)) ;
#line 104
extern float ( __attribute__((__leaf__)) logf32)(float __x )  __attribute__((__nothrow__)) ;
#line 104
extern float ( __attribute__((__leaf__)) __logf32)(float __x )  __attribute__((__nothrow__)) ;
#line 107
extern float ( __attribute__((__leaf__)) log10f32)(float __x )  __attribute__((__nothrow__)) ;
#line 107
extern float ( __attribute__((__leaf__)) __log10f32)(float __x )  __attribute__((__nothrow__)) ;
#line 110
extern float ( __attribute__((__leaf__)) modff32)(float __x , float *__iptr )  __attribute__((__nothrow__)) ;
#line 110
extern float ( __attribute__((__nonnull__(2), __leaf__)) __modff32)(float __x , float *__iptr )  __attribute__((__nothrow__)) ;
#line 114
extern float ( __attribute__((__leaf__)) exp10f32)(float __x )  __attribute__((__nothrow__)) ;
#line 114
extern float ( __attribute__((__leaf__)) __exp10f32)(float __x )  __attribute__((__nothrow__)) ;
#line 119
extern float ( __attribute__((__leaf__)) expm1f32)(float __x )  __attribute__((__nothrow__)) ;
#line 119
extern float ( __attribute__((__leaf__)) __expm1f32)(float __x )  __attribute__((__nothrow__)) ;
#line 122
extern float ( __attribute__((__leaf__)) log1pf32)(float __x )  __attribute__((__nothrow__)) ;
#line 122
extern float ( __attribute__((__leaf__)) __log1pf32)(float __x )  __attribute__((__nothrow__)) ;
#line 125
extern float ( __attribute__((__leaf__)) logbf32)(float __x )  __attribute__((__nothrow__)) ;
#line 125
extern float ( __attribute__((__leaf__)) __logbf32)(float __x )  __attribute__((__nothrow__)) ;
#line 130
extern float ( __attribute__((__leaf__)) exp2f32)(float __x )  __attribute__((__nothrow__)) ;
#line 130
extern float ( __attribute__((__leaf__)) __exp2f32)(float __x )  __attribute__((__nothrow__)) ;
#line 133
extern float ( __attribute__((__leaf__)) log2f32)(float __x )  __attribute__((__nothrow__)) ;
#line 133
extern float ( __attribute__((__leaf__)) __log2f32)(float __x )  __attribute__((__nothrow__)) ;
#line 140
extern float ( __attribute__((__leaf__)) powf32)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 140
extern float ( __attribute__((__leaf__)) __powf32)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 143
extern float ( __attribute__((__leaf__)) sqrtf32)(float __x )  __attribute__((__nothrow__)) ;
#line 143
extern float ( __attribute__((__leaf__)) __sqrtf32)(float __x )  __attribute__((__nothrow__)) ;
#line 147
extern float ( __attribute__((__leaf__)) hypotf32)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 147
extern float ( __attribute__((__leaf__)) __hypotf32)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 152
extern float ( __attribute__((__leaf__)) cbrtf32)(float __x )  __attribute__((__nothrow__)) ;
#line 152
extern float ( __attribute__((__leaf__)) __cbrtf32)(float __x )  __attribute__((__nothrow__)) ;
#line 159
extern float ( __attribute__((__leaf__)) ceilf32)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 159
extern float ( __attribute__((__leaf__)) __ceilf32)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 162
extern float ( __attribute__((__leaf__)) fabsf32)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 162
extern float ( __attribute__((__leaf__)) __fabsf32)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 165
extern float ( __attribute__((__leaf__)) floorf32)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 165
extern float ( __attribute__((__leaf__)) __floorf32)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 168
extern float ( __attribute__((__leaf__)) fmodf32)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 168
extern float ( __attribute__((__leaf__)) __fmodf32)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 196
extern float ( __attribute__((__leaf__)) copysignf32)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 196
extern float ( __attribute__((__leaf__)) __copysignf32)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 201
extern float ( __attribute__((__leaf__)) nanf32)(char const   *__tagb )  __attribute__((__nothrow__)) ;
#line 201
extern float ( __attribute__((__leaf__)) __nanf32)(char const   *__tagb )  __attribute__((__nothrow__)) ;
#line 217
extern float ( __attribute__((__leaf__)) j0f32)(float  )  __attribute__((__nothrow__)) ;
#line 217
extern float ( __attribute__((__leaf__)) __j0f32)(float  )  __attribute__((__nothrow__)) ;
#line 218
extern float ( __attribute__((__leaf__)) j1f32)(float  )  __attribute__((__nothrow__)) ;
#line 218
extern float ( __attribute__((__leaf__)) __j1f32)(float  )  __attribute__((__nothrow__)) ;
#line 219
extern float ( __attribute__((__leaf__)) jnf32)(int  , float  )  __attribute__((__nothrow__)) ;
#line 219
extern float ( __attribute__((__leaf__)) __jnf32)(int  , float  )  __attribute__((__nothrow__)) ;
#line 220
extern float ( __attribute__((__leaf__)) y0f32)(float  )  __attribute__((__nothrow__)) ;
#line 220
extern float ( __attribute__((__leaf__)) __y0f32)(float  )  __attribute__((__nothrow__)) ;
#line 221
extern float ( __attribute__((__leaf__)) y1f32)(float  )  __attribute__((__nothrow__)) ;
#line 221
extern float ( __attribute__((__leaf__)) __y1f32)(float  )  __attribute__((__nothrow__)) ;
#line 222
extern float ( __attribute__((__leaf__)) ynf32)(int  , float  )  __attribute__((__nothrow__)) ;
#line 222
extern float ( __attribute__((__leaf__)) __ynf32)(int  , float  )  __attribute__((__nothrow__)) ;
#line 228
extern float ( __attribute__((__leaf__)) erff32)(float  )  __attribute__((__nothrow__)) ;
#line 228
extern float ( __attribute__((__leaf__)) __erff32)(float  )  __attribute__((__nothrow__)) ;
#line 229
extern float ( __attribute__((__leaf__)) erfcf32)(float  )  __attribute__((__nothrow__)) ;
#line 229
extern float ( __attribute__((__leaf__)) __erfcf32)(float  )  __attribute__((__nothrow__)) ;
#line 230
extern float ( __attribute__((__leaf__)) lgammaf32)(float  )  __attribute__((__nothrow__)) ;
#line 230
extern float ( __attribute__((__leaf__)) __lgammaf32)(float  )  __attribute__((__nothrow__)) ;
#line 235
extern float ( __attribute__((__leaf__)) tgammaf32)(float  )  __attribute__((__nothrow__)) ;
#line 235
extern float ( __attribute__((__leaf__)) __tgammaf32)(float  )  __attribute__((__nothrow__)) ;
#line 249
extern float ( __attribute__((__leaf__)) lgammaf32_r)(float  , int *__signgamp )  __attribute__((__nothrow__)) ;
#line 249
extern float ( __attribute__((__leaf__)) __lgammaf32_r)(float  , int *__signgamp )  __attribute__((__nothrow__)) ;
#line 256
extern float ( __attribute__((__leaf__)) rintf32)(float __x )  __attribute__((__nothrow__)) ;
#line 256
extern float ( __attribute__((__leaf__)) __rintf32)(float __x )  __attribute__((__nothrow__)) ;
#line 259
extern float ( __attribute__((__leaf__)) nextafterf32)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 259
extern float ( __attribute__((__leaf__)) __nextafterf32)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 266
extern float ( __attribute__((__leaf__)) nextdownf32)(float __x )  __attribute__((__nothrow__)) ;
#line 266
extern float ( __attribute__((__leaf__)) __nextdownf32)(float __x )  __attribute__((__nothrow__)) ;
#line 268
extern float ( __attribute__((__leaf__)) nextupf32)(float __x )  __attribute__((__nothrow__)) ;
#line 268
extern float ( __attribute__((__leaf__)) __nextupf32)(float __x )  __attribute__((__nothrow__)) ;
#line 272
extern float ( __attribute__((__leaf__)) remainderf32)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 272
extern float ( __attribute__((__leaf__)) __remainderf32)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 276
extern float ( __attribute__((__leaf__)) scalbnf32)(float __x , int __n )  __attribute__((__nothrow__)) ;
#line 276
extern float ( __attribute__((__leaf__)) __scalbnf32)(float __x , int __n )  __attribute__((__nothrow__)) ;
#line 280
extern int ( __attribute__((__leaf__)) ilogbf32)(float __x )  __attribute__((__nothrow__)) ;
#line 280
extern int ( __attribute__((__leaf__)) __ilogbf32)(float __x )  __attribute__((__nothrow__)) ;
#line 285
extern long ( __attribute__((__leaf__)) llogbf32)(float __x )  __attribute__((__nothrow__)) ;
#line 285
extern long ( __attribute__((__leaf__)) __llogbf32)(float __x )  __attribute__((__nothrow__)) ;
#line 290
extern float ( __attribute__((__leaf__)) scalblnf32)(float __x , long __n )  __attribute__((__nothrow__)) ;
#line 290
extern float ( __attribute__((__leaf__)) __scalblnf32)(float __x , long __n )  __attribute__((__nothrow__)) ;
#line 294
extern float ( __attribute__((__leaf__)) nearbyintf32)(float __x )  __attribute__((__nothrow__)) ;
#line 294
extern float ( __attribute__((__leaf__)) __nearbyintf32)(float __x )  __attribute__((__nothrow__)) ;
#line 298
extern float ( __attribute__((__leaf__)) roundf32)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 298
extern float ( __attribute__((__leaf__)) __roundf32)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 302
extern float ( __attribute__((__leaf__)) truncf32)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 302
extern float ( __attribute__((__leaf__)) __truncf32)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 307
extern float ( __attribute__((__leaf__)) remquof32)(float __x , float __y , int *__quo )  __attribute__((__nothrow__)) ;
#line 307
extern float ( __attribute__((__leaf__)) __remquof32)(float __x , float __y , int *__quo )  __attribute__((__nothrow__)) ;
#line 314
extern long ( __attribute__((__leaf__)) lrintf32)(float __x )  __attribute__((__nothrow__)) ;
#line 314
extern long ( __attribute__((__leaf__)) __lrintf32)(float __x )  __attribute__((__nothrow__)) ;
#line 316
extern long long ( __attribute__((__leaf__)) llrintf32)(float __x )  __attribute__((__nothrow__)) ;
#line 316
extern long long ( __attribute__((__leaf__)) __llrintf32)(float __x )  __attribute__((__nothrow__)) ;
#line 320
extern long ( __attribute__((__leaf__)) lroundf32)(float __x )  __attribute__((__nothrow__)) ;
#line 320
extern long ( __attribute__((__leaf__)) __lroundf32)(float __x )  __attribute__((__nothrow__)) ;
#line 322
extern long long ( __attribute__((__leaf__)) llroundf32)(float __x )  __attribute__((__nothrow__)) ;
#line 322
extern long long ( __attribute__((__leaf__)) __llroundf32)(float __x )  __attribute__((__nothrow__)) ;
#line 326
extern float ( __attribute__((__leaf__)) fdimf32)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 326
extern float ( __attribute__((__leaf__)) __fdimf32)(float __x , float __y )  __attribute__((__nothrow__)) ;
#line 329
extern float ( __attribute__((__leaf__)) fmaxf32)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 329
extern float ( __attribute__((__leaf__)) __fmaxf32)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 332
extern float ( __attribute__((__leaf__)) fminf32)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 332
extern float ( __attribute__((__leaf__)) __fminf32)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 335
extern float ( __attribute__((__leaf__)) fmaf32)(float __x , float __y , float __z )  __attribute__((__nothrow__)) ;
#line 335
extern float ( __attribute__((__leaf__)) __fmaf32)(float __x , float __y , float __z )  __attribute__((__nothrow__)) ;
#line 340
extern float ( __attribute__((__leaf__)) roundevenf32)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 340
extern float ( __attribute__((__leaf__)) __roundevenf32)(float __x )  __attribute__((__nothrow__,
__const__)) ;
#line 344
extern __intmax_t ( __attribute__((__leaf__)) fromfpf32)(float __x , int __round ,
                                                         unsigned int __width )  __attribute__((__nothrow__)) ;
#line 344
extern __intmax_t ( __attribute__((__leaf__)) __fromfpf32)(float __x , int __round ,
                                                           unsigned int __width )  __attribute__((__nothrow__)) ;
#line 349
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpf32)(float __x , int __round ,
                                                           unsigned int __width )  __attribute__((__nothrow__)) ;
#line 349
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpf32)(float __x , int __round ,
                                                             unsigned int __width )  __attribute__((__nothrow__)) ;
#line 355
extern __intmax_t ( __attribute__((__leaf__)) fromfpxf32)(float __x , int __round ,
                                                          unsigned int __width )  __attribute__((__nothrow__)) ;
#line 355
extern __intmax_t ( __attribute__((__leaf__)) __fromfpxf32)(float __x , int __round ,
                                                            unsigned int __width )  __attribute__((__nothrow__)) ;
#line 361
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpxf32)(float __x , int __round ,
                                                            unsigned int __width )  __attribute__((__nothrow__)) ;
#line 361
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpxf32)(float __x , int __round ,
                                                              unsigned int __width )  __attribute__((__nothrow__)) ;
#line 365
extern float ( __attribute__((__leaf__)) fmaxmagf32)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 365
extern float ( __attribute__((__leaf__)) __fmaxmagf32)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 368
extern float ( __attribute__((__leaf__)) fminmagf32)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 368
extern float ( __attribute__((__leaf__)) __fminmagf32)(float __x , float __y )  __attribute__((__nothrow__,
__const__)) ;
#line 371
extern int ( __attribute__((__leaf__)) canonicalizef32)(float *__cx , float const   *__x )  __attribute__((__nothrow__)) ;
#line 376
extern int ( __attribute__((__leaf__)) totalorderf32)(float const   *__x , float const   *__y )  __attribute__((__pure__,
__nothrow__)) ;
#line 381
extern int ( __attribute__((__leaf__)) totalordermagf32)(float const   *__x , float const   *__y )  __attribute__((__pure__,
__nothrow__)) ;
#line 386
extern float ( __attribute__((__leaf__)) getpayloadf32)(float const   *__x )  __attribute__((__nothrow__)) ;
#line 386
extern float ( __attribute__((__leaf__)) __getpayloadf32)(float const   *__x )  __attribute__((__nothrow__)) ;
#line 389
extern int ( __attribute__((__leaf__)) setpayloadf32)(float *__x , float __payload )  __attribute__((__nothrow__)) ;
#line 392
extern int ( __attribute__((__leaf__)) setpayloadsigf32)(float *__x , float __payload )  __attribute__((__nothrow__)) ;
#line 53
extern double ( __attribute__((__leaf__)) acosf64)(double __x )  __attribute__((__nothrow__)) ;
#line 53
extern double ( __attribute__((__leaf__)) __acosf64)(double __x )  __attribute__((__nothrow__)) ;
#line 55
extern double ( __attribute__((__leaf__)) asinf64)(double __x )  __attribute__((__nothrow__)) ;
#line 55
extern double ( __attribute__((__leaf__)) __asinf64)(double __x )  __attribute__((__nothrow__)) ;
#line 57
extern double ( __attribute__((__leaf__)) atanf64)(double __x )  __attribute__((__nothrow__)) ;
#line 57
extern double ( __attribute__((__leaf__)) __atanf64)(double __x )  __attribute__((__nothrow__)) ;
#line 59
extern double ( __attribute__((__leaf__)) atan2f64)(double __y , double __x )  __attribute__((__nothrow__)) ;
#line 59
extern double ( __attribute__((__leaf__)) __atan2f64)(double __y , double __x )  __attribute__((__nothrow__)) ;
#line 62
extern double ( __attribute__((__leaf__)) cosf64)(double __x )  __attribute__((__nothrow__)) ;
#line 62
extern double ( __attribute__((__leaf__)) __cosf64)(double __x )  __attribute__((__nothrow__)) ;
#line 64
extern double ( __attribute__((__leaf__)) sinf64)(double __x )  __attribute__((__nothrow__)) ;
#line 64
extern double ( __attribute__((__leaf__)) __sinf64)(double __x )  __attribute__((__nothrow__)) ;
#line 66
extern double ( __attribute__((__leaf__)) tanf64)(double __x )  __attribute__((__nothrow__)) ;
#line 66
extern double ( __attribute__((__leaf__)) __tanf64)(double __x )  __attribute__((__nothrow__)) ;
#line 71
extern double ( __attribute__((__leaf__)) coshf64)(double __x )  __attribute__((__nothrow__)) ;
#line 71
extern double ( __attribute__((__leaf__)) __coshf64)(double __x )  __attribute__((__nothrow__)) ;
#line 73
extern double ( __attribute__((__leaf__)) sinhf64)(double __x )  __attribute__((__nothrow__)) ;
#line 73
extern double ( __attribute__((__leaf__)) __sinhf64)(double __x )  __attribute__((__nothrow__)) ;
#line 75
extern double ( __attribute__((__leaf__)) tanhf64)(double __x )  __attribute__((__nothrow__)) ;
#line 75
extern double ( __attribute__((__leaf__)) __tanhf64)(double __x )  __attribute__((__nothrow__)) ;
#line 79
extern void ( __attribute__((__leaf__)) sincosf64)(double __x , double *__sinx , double *__cosx )  __attribute__((__nothrow__)) ;
#line 79
extern void ( __attribute__((__leaf__)) __sincosf64)(double __x , double *__sinx ,
                                                     double *__cosx )  __attribute__((__nothrow__)) ;
#line 85
extern double ( __attribute__((__leaf__)) acoshf64)(double __x )  __attribute__((__nothrow__)) ;
#line 85
extern double ( __attribute__((__leaf__)) __acoshf64)(double __x )  __attribute__((__nothrow__)) ;
#line 87
extern double ( __attribute__((__leaf__)) asinhf64)(double __x )  __attribute__((__nothrow__)) ;
#line 87
extern double ( __attribute__((__leaf__)) __asinhf64)(double __x )  __attribute__((__nothrow__)) ;
#line 89
extern double ( __attribute__((__leaf__)) atanhf64)(double __x )  __attribute__((__nothrow__)) ;
#line 89
extern double ( __attribute__((__leaf__)) __atanhf64)(double __x )  __attribute__((__nothrow__)) ;
#line 95
extern double ( __attribute__((__leaf__)) expf64)(double __x )  __attribute__((__nothrow__)) ;
#line 95
extern double ( __attribute__((__leaf__)) __expf64)(double __x )  __attribute__((__nothrow__)) ;
#line 98
extern double ( __attribute__((__leaf__)) frexpf64)(double __x , int *__exponent )  __attribute__((__nothrow__)) ;
#line 98
extern double ( __attribute__((__leaf__)) __frexpf64)(double __x , int *__exponent )  __attribute__((__nothrow__)) ;
#line 101
extern double ( __attribute__((__leaf__)) ldexpf64)(double __x , int __exponent )  __attribute__((__nothrow__)) ;
#line 101
extern double ( __attribute__((__leaf__)) __ldexpf64)(double __x , int __exponent )  __attribute__((__nothrow__)) ;
#line 104
extern double ( __attribute__((__leaf__)) logf64)(double __x )  __attribute__((__nothrow__)) ;
#line 104
extern double ( __attribute__((__leaf__)) __logf64)(double __x )  __attribute__((__nothrow__)) ;
#line 107
extern double ( __attribute__((__leaf__)) log10f64)(double __x )  __attribute__((__nothrow__)) ;
#line 107
extern double ( __attribute__((__leaf__)) __log10f64)(double __x )  __attribute__((__nothrow__)) ;
#line 110
extern double ( __attribute__((__leaf__)) modff64)(double __x , double *__iptr )  __attribute__((__nothrow__)) ;
#line 110
extern double ( __attribute__((__nonnull__(2), __leaf__)) __modff64)(double __x ,
                                                                     double *__iptr )  __attribute__((__nothrow__)) ;
#line 114
extern double ( __attribute__((__leaf__)) exp10f64)(double __x )  __attribute__((__nothrow__)) ;
#line 114
extern double ( __attribute__((__leaf__)) __exp10f64)(double __x )  __attribute__((__nothrow__)) ;
#line 119
extern double ( __attribute__((__leaf__)) expm1f64)(double __x )  __attribute__((__nothrow__)) ;
#line 119
extern double ( __attribute__((__leaf__)) __expm1f64)(double __x )  __attribute__((__nothrow__)) ;
#line 122
extern double ( __attribute__((__leaf__)) log1pf64)(double __x )  __attribute__((__nothrow__)) ;
#line 122
extern double ( __attribute__((__leaf__)) __log1pf64)(double __x )  __attribute__((__nothrow__)) ;
#line 125
extern double ( __attribute__((__leaf__)) logbf64)(double __x )  __attribute__((__nothrow__)) ;
#line 125
extern double ( __attribute__((__leaf__)) __logbf64)(double __x )  __attribute__((__nothrow__)) ;
#line 130
extern double ( __attribute__((__leaf__)) exp2f64)(double __x )  __attribute__((__nothrow__)) ;
#line 130
extern double ( __attribute__((__leaf__)) __exp2f64)(double __x )  __attribute__((__nothrow__)) ;
#line 133
extern double ( __attribute__((__leaf__)) log2f64)(double __x )  __attribute__((__nothrow__)) ;
#line 133
extern double ( __attribute__((__leaf__)) __log2f64)(double __x )  __attribute__((__nothrow__)) ;
#line 140
extern double ( __attribute__((__leaf__)) powf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 140
extern double ( __attribute__((__leaf__)) __powf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 143
extern double ( __attribute__((__leaf__)) sqrtf64)(double __x )  __attribute__((__nothrow__)) ;
#line 143
extern double ( __attribute__((__leaf__)) __sqrtf64)(double __x )  __attribute__((__nothrow__)) ;
#line 147
extern double ( __attribute__((__leaf__)) hypotf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 147
extern double ( __attribute__((__leaf__)) __hypotf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 152
extern double ( __attribute__((__leaf__)) cbrtf64)(double __x )  __attribute__((__nothrow__)) ;
#line 152
extern double ( __attribute__((__leaf__)) __cbrtf64)(double __x )  __attribute__((__nothrow__)) ;
#line 159
extern double ( __attribute__((__leaf__)) ceilf64)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 159
extern double ( __attribute__((__leaf__)) __ceilf64)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 162
extern double ( __attribute__((__leaf__)) fabsf64)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 162
extern double ( __attribute__((__leaf__)) __fabsf64)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 165
extern double ( __attribute__((__leaf__)) floorf64)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 165
extern double ( __attribute__((__leaf__)) __floorf64)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 168
extern double ( __attribute__((__leaf__)) fmodf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 168
extern double ( __attribute__((__leaf__)) __fmodf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 196
extern double ( __attribute__((__leaf__)) copysignf64)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 196
extern double ( __attribute__((__leaf__)) __copysignf64)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 201
extern double ( __attribute__((__leaf__)) nanf64)(char const   *__tagb )  __attribute__((__nothrow__)) ;
#line 201
extern double ( __attribute__((__leaf__)) __nanf64)(char const   *__tagb )  __attribute__((__nothrow__)) ;
#line 217
extern double ( __attribute__((__leaf__)) j0f64)(double  )  __attribute__((__nothrow__)) ;
#line 217
extern double ( __attribute__((__leaf__)) __j0f64)(double  )  __attribute__((__nothrow__)) ;
#line 218
extern double ( __attribute__((__leaf__)) j1f64)(double  )  __attribute__((__nothrow__)) ;
#line 218
extern double ( __attribute__((__leaf__)) __j1f64)(double  )  __attribute__((__nothrow__)) ;
#line 219
extern double ( __attribute__((__leaf__)) jnf64)(int  , double  )  __attribute__((__nothrow__)) ;
#line 219
extern double ( __attribute__((__leaf__)) __jnf64)(int  , double  )  __attribute__((__nothrow__)) ;
#line 220
extern double ( __attribute__((__leaf__)) y0f64)(double  )  __attribute__((__nothrow__)) ;
#line 220
extern double ( __attribute__((__leaf__)) __y0f64)(double  )  __attribute__((__nothrow__)) ;
#line 221
extern double ( __attribute__((__leaf__)) y1f64)(double  )  __attribute__((__nothrow__)) ;
#line 221
extern double ( __attribute__((__leaf__)) __y1f64)(double  )  __attribute__((__nothrow__)) ;
#line 222
extern double ( __attribute__((__leaf__)) ynf64)(int  , double  )  __attribute__((__nothrow__)) ;
#line 222
extern double ( __attribute__((__leaf__)) __ynf64)(int  , double  )  __attribute__((__nothrow__)) ;
#line 228
extern double ( __attribute__((__leaf__)) erff64)(double  )  __attribute__((__nothrow__)) ;
#line 228
extern double ( __attribute__((__leaf__)) __erff64)(double  )  __attribute__((__nothrow__)) ;
#line 229
extern double ( __attribute__((__leaf__)) erfcf64)(double  )  __attribute__((__nothrow__)) ;
#line 229
extern double ( __attribute__((__leaf__)) __erfcf64)(double  )  __attribute__((__nothrow__)) ;
#line 230
extern double ( __attribute__((__leaf__)) lgammaf64)(double  )  __attribute__((__nothrow__)) ;
#line 230
extern double ( __attribute__((__leaf__)) __lgammaf64)(double  )  __attribute__((__nothrow__)) ;
#line 235
extern double ( __attribute__((__leaf__)) tgammaf64)(double  )  __attribute__((__nothrow__)) ;
#line 235
extern double ( __attribute__((__leaf__)) __tgammaf64)(double  )  __attribute__((__nothrow__)) ;
#line 249
extern double ( __attribute__((__leaf__)) lgammaf64_r)(double  , int *__signgamp )  __attribute__((__nothrow__)) ;
#line 249
extern double ( __attribute__((__leaf__)) __lgammaf64_r)(double  , int *__signgamp )  __attribute__((__nothrow__)) ;
#line 256
extern double ( __attribute__((__leaf__)) rintf64)(double __x )  __attribute__((__nothrow__)) ;
#line 256
extern double ( __attribute__((__leaf__)) __rintf64)(double __x )  __attribute__((__nothrow__)) ;
#line 259
extern double ( __attribute__((__leaf__)) nextafterf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 259
extern double ( __attribute__((__leaf__)) __nextafterf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 266
extern double ( __attribute__((__leaf__)) nextdownf64)(double __x )  __attribute__((__nothrow__)) ;
#line 266
extern double ( __attribute__((__leaf__)) __nextdownf64)(double __x )  __attribute__((__nothrow__)) ;
#line 268
extern double ( __attribute__((__leaf__)) nextupf64)(double __x )  __attribute__((__nothrow__)) ;
#line 268
extern double ( __attribute__((__leaf__)) __nextupf64)(double __x )  __attribute__((__nothrow__)) ;
#line 272
extern double ( __attribute__((__leaf__)) remainderf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 272
extern double ( __attribute__((__leaf__)) __remainderf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 276
extern double ( __attribute__((__leaf__)) scalbnf64)(double __x , int __n )  __attribute__((__nothrow__)) ;
#line 276
extern double ( __attribute__((__leaf__)) __scalbnf64)(double __x , int __n )  __attribute__((__nothrow__)) ;
#line 280
extern int ( __attribute__((__leaf__)) ilogbf64)(double __x )  __attribute__((__nothrow__)) ;
#line 280
extern int ( __attribute__((__leaf__)) __ilogbf64)(double __x )  __attribute__((__nothrow__)) ;
#line 285
extern long ( __attribute__((__leaf__)) llogbf64)(double __x )  __attribute__((__nothrow__)) ;
#line 285
extern long ( __attribute__((__leaf__)) __llogbf64)(double __x )  __attribute__((__nothrow__)) ;
#line 290
extern double ( __attribute__((__leaf__)) scalblnf64)(double __x , long __n )  __attribute__((__nothrow__)) ;
#line 290
extern double ( __attribute__((__leaf__)) __scalblnf64)(double __x , long __n )  __attribute__((__nothrow__)) ;
#line 294
extern double ( __attribute__((__leaf__)) nearbyintf64)(double __x )  __attribute__((__nothrow__)) ;
#line 294
extern double ( __attribute__((__leaf__)) __nearbyintf64)(double __x )  __attribute__((__nothrow__)) ;
#line 298
extern double ( __attribute__((__leaf__)) roundf64)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 298
extern double ( __attribute__((__leaf__)) __roundf64)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 302
extern double ( __attribute__((__leaf__)) truncf64)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 302
extern double ( __attribute__((__leaf__)) __truncf64)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 307
extern double ( __attribute__((__leaf__)) remquof64)(double __x , double __y , int *__quo )  __attribute__((__nothrow__)) ;
#line 307
extern double ( __attribute__((__leaf__)) __remquof64)(double __x , double __y , int *__quo )  __attribute__((__nothrow__)) ;
#line 314
extern long ( __attribute__((__leaf__)) lrintf64)(double __x )  __attribute__((__nothrow__)) ;
#line 314
extern long ( __attribute__((__leaf__)) __lrintf64)(double __x )  __attribute__((__nothrow__)) ;
#line 316
extern long long ( __attribute__((__leaf__)) llrintf64)(double __x )  __attribute__((__nothrow__)) ;
#line 316
extern long long ( __attribute__((__leaf__)) __llrintf64)(double __x )  __attribute__((__nothrow__)) ;
#line 320
extern long ( __attribute__((__leaf__)) lroundf64)(double __x )  __attribute__((__nothrow__)) ;
#line 320
extern long ( __attribute__((__leaf__)) __lroundf64)(double __x )  __attribute__((__nothrow__)) ;
#line 322
extern long long ( __attribute__((__leaf__)) llroundf64)(double __x )  __attribute__((__nothrow__)) ;
#line 322
extern long long ( __attribute__((__leaf__)) __llroundf64)(double __x )  __attribute__((__nothrow__)) ;
#line 326
extern double ( __attribute__((__leaf__)) fdimf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 326
extern double ( __attribute__((__leaf__)) __fdimf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 329
extern double ( __attribute__((__leaf__)) fmaxf64)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 329
extern double ( __attribute__((__leaf__)) __fmaxf64)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 332
extern double ( __attribute__((__leaf__)) fminf64)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 332
extern double ( __attribute__((__leaf__)) __fminf64)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 335
extern double ( __attribute__((__leaf__)) fmaf64)(double __x , double __y , double __z )  __attribute__((__nothrow__)) ;
#line 335
extern double ( __attribute__((__leaf__)) __fmaf64)(double __x , double __y , double __z )  __attribute__((__nothrow__)) ;
#line 340
extern double ( __attribute__((__leaf__)) roundevenf64)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 340
extern double ( __attribute__((__leaf__)) __roundevenf64)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 344
extern __intmax_t ( __attribute__((__leaf__)) fromfpf64)(double __x , int __round ,
                                                         unsigned int __width )  __attribute__((__nothrow__)) ;
#line 344
extern __intmax_t ( __attribute__((__leaf__)) __fromfpf64)(double __x , int __round ,
                                                           unsigned int __width )  __attribute__((__nothrow__)) ;
#line 349
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpf64)(double __x , int __round ,
                                                           unsigned int __width )  __attribute__((__nothrow__)) ;
#line 349
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpf64)(double __x , int __round ,
                                                             unsigned int __width )  __attribute__((__nothrow__)) ;
#line 355
extern __intmax_t ( __attribute__((__leaf__)) fromfpxf64)(double __x , int __round ,
                                                          unsigned int __width )  __attribute__((__nothrow__)) ;
#line 355
extern __intmax_t ( __attribute__((__leaf__)) __fromfpxf64)(double __x , int __round ,
                                                            unsigned int __width )  __attribute__((__nothrow__)) ;
#line 361
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpxf64)(double __x , int __round ,
                                                            unsigned int __width )  __attribute__((__nothrow__)) ;
#line 361
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpxf64)(double __x , int __round ,
                                                              unsigned int __width )  __attribute__((__nothrow__)) ;
#line 365
extern double ( __attribute__((__leaf__)) fmaxmagf64)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 365
extern double ( __attribute__((__leaf__)) __fmaxmagf64)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 368
extern double ( __attribute__((__leaf__)) fminmagf64)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 368
extern double ( __attribute__((__leaf__)) __fminmagf64)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 371
extern int ( __attribute__((__leaf__)) canonicalizef64)(double *__cx , double const   *__x )  __attribute__((__nothrow__)) ;
#line 376
extern int ( __attribute__((__leaf__)) totalorderf64)(double const   *__x , double const   *__y )  __attribute__((__pure__,
__nothrow__)) ;
#line 381
extern int ( __attribute__((__leaf__)) totalordermagf64)(double const   *__x , double const   *__y )  __attribute__((__pure__,
__nothrow__)) ;
#line 386
extern double ( __attribute__((__leaf__)) getpayloadf64)(double const   *__x )  __attribute__((__nothrow__)) ;
#line 386
extern double ( __attribute__((__leaf__)) __getpayloadf64)(double const   *__x )  __attribute__((__nothrow__)) ;
#line 389
extern int ( __attribute__((__leaf__)) setpayloadf64)(double *__x , double __payload )  __attribute__((__nothrow__)) ;
#line 392
extern int ( __attribute__((__leaf__)) setpayloadsigf64)(double *__x , double __payload )  __attribute__((__nothrow__)) ;
#line 53
extern _Float128 ( __attribute__((__leaf__)) acosf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 53
extern _Float128 ( __attribute__((__leaf__)) __acosf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 55
extern _Float128 ( __attribute__((__leaf__)) asinf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 55
extern _Float128 ( __attribute__((__leaf__)) __asinf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 57
extern _Float128 ( __attribute__((__leaf__)) atanf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 57
extern _Float128 ( __attribute__((__leaf__)) __atanf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 59
extern _Float128 ( __attribute__((__leaf__)) atan2f128)(_Float128 __y , _Float128 __x )  __attribute__((__nothrow__)) ;
#line 59
extern _Float128 ( __attribute__((__leaf__)) __atan2f128)(_Float128 __y , _Float128 __x )  __attribute__((__nothrow__)) ;
#line 62
extern _Float128 ( __attribute__((__leaf__)) cosf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 62
extern _Float128 ( __attribute__((__leaf__)) __cosf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 64
extern _Float128 ( __attribute__((__leaf__)) sinf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 64
extern _Float128 ( __attribute__((__leaf__)) __sinf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 66
extern _Float128 ( __attribute__((__leaf__)) tanf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 66
extern _Float128 ( __attribute__((__leaf__)) __tanf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 71
extern _Float128 ( __attribute__((__leaf__)) coshf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 71
extern _Float128 ( __attribute__((__leaf__)) __coshf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 73
extern _Float128 ( __attribute__((__leaf__)) sinhf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 73
extern _Float128 ( __attribute__((__leaf__)) __sinhf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 75
extern _Float128 ( __attribute__((__leaf__)) tanhf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 75
extern _Float128 ( __attribute__((__leaf__)) __tanhf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 79
extern void ( __attribute__((__leaf__)) sincosf128)(_Float128 __x , _Float128 *__sinx ,
                                                    _Float128 *__cosx )  __attribute__((__nothrow__)) ;
#line 79
extern void ( __attribute__((__leaf__)) __sincosf128)(_Float128 __x , _Float128 *__sinx ,
                                                      _Float128 *__cosx )  __attribute__((__nothrow__)) ;
#line 85
extern _Float128 ( __attribute__((__leaf__)) acoshf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 85
extern _Float128 ( __attribute__((__leaf__)) __acoshf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 87
extern _Float128 ( __attribute__((__leaf__)) asinhf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 87
extern _Float128 ( __attribute__((__leaf__)) __asinhf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 89
extern _Float128 ( __attribute__((__leaf__)) atanhf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 89
extern _Float128 ( __attribute__((__leaf__)) __atanhf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 95
extern _Float128 ( __attribute__((__leaf__)) expf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 95
extern _Float128 ( __attribute__((__leaf__)) __expf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 98
extern _Float128 ( __attribute__((__leaf__)) frexpf128)(_Float128 __x , int *__exponent )  __attribute__((__nothrow__)) ;
#line 98
extern _Float128 ( __attribute__((__leaf__)) __frexpf128)(_Float128 __x , int *__exponent )  __attribute__((__nothrow__)) ;
#line 101
extern _Float128 ( __attribute__((__leaf__)) ldexpf128)(_Float128 __x , int __exponent )  __attribute__((__nothrow__)) ;
#line 101
extern _Float128 ( __attribute__((__leaf__)) __ldexpf128)(_Float128 __x , int __exponent )  __attribute__((__nothrow__)) ;
#line 104
extern _Float128 ( __attribute__((__leaf__)) logf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 104
extern _Float128 ( __attribute__((__leaf__)) __logf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 107
extern _Float128 ( __attribute__((__leaf__)) log10f128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 107
extern _Float128 ( __attribute__((__leaf__)) __log10f128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 110
extern _Float128 ( __attribute__((__leaf__)) modff128)(_Float128 __x , _Float128 *__iptr )  __attribute__((__nothrow__)) ;
#line 110
extern _Float128 ( __attribute__((__nonnull__(2), __leaf__)) __modff128)(_Float128 __x ,
                                                                         _Float128 *__iptr )  __attribute__((__nothrow__)) ;
#line 114
extern _Float128 ( __attribute__((__leaf__)) exp10f128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 114
extern _Float128 ( __attribute__((__leaf__)) __exp10f128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 119
extern _Float128 ( __attribute__((__leaf__)) expm1f128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 119
extern _Float128 ( __attribute__((__leaf__)) __expm1f128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 122
extern _Float128 ( __attribute__((__leaf__)) log1pf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 122
extern _Float128 ( __attribute__((__leaf__)) __log1pf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 125
extern _Float128 ( __attribute__((__leaf__)) logbf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 125
extern _Float128 ( __attribute__((__leaf__)) __logbf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 130
extern _Float128 ( __attribute__((__leaf__)) exp2f128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 130
extern _Float128 ( __attribute__((__leaf__)) __exp2f128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 133
extern _Float128 ( __attribute__((__leaf__)) log2f128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 133
extern _Float128 ( __attribute__((__leaf__)) __log2f128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 140
extern _Float128 ( __attribute__((__leaf__)) powf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 140
extern _Float128 ( __attribute__((__leaf__)) __powf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 143
extern _Float128 ( __attribute__((__leaf__)) sqrtf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 143
extern _Float128 ( __attribute__((__leaf__)) __sqrtf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 147
extern _Float128 ( __attribute__((__leaf__)) hypotf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 147
extern _Float128 ( __attribute__((__leaf__)) __hypotf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 152
extern _Float128 ( __attribute__((__leaf__)) cbrtf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 152
extern _Float128 ( __attribute__((__leaf__)) __cbrtf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 159
extern _Float128 ( __attribute__((__leaf__)) ceilf128)(_Float128 __x )  __attribute__((__nothrow__,
__const__)) ;
#line 159
extern _Float128 ( __attribute__((__leaf__)) __ceilf128)(_Float128 __x )  __attribute__((__nothrow__,
__const__)) ;
#line 162
extern _Float128 ( __attribute__((__leaf__)) fabsf128)(_Float128 __x )  __attribute__((__nothrow__,
__const__)) ;
#line 162
extern _Float128 ( __attribute__((__leaf__)) __fabsf128)(_Float128 __x )  __attribute__((__nothrow__,
__const__)) ;
#line 165
extern _Float128 ( __attribute__((__leaf__)) floorf128)(_Float128 __x )  __attribute__((__nothrow__,
__const__)) ;
#line 165
extern _Float128 ( __attribute__((__leaf__)) __floorf128)(_Float128 __x )  __attribute__((__nothrow__,
__const__)) ;
#line 168
extern _Float128 ( __attribute__((__leaf__)) fmodf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 168
extern _Float128 ( __attribute__((__leaf__)) __fmodf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 196
extern _Float128 ( __attribute__((__leaf__)) copysignf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__,
__const__)) ;
#line 196
extern _Float128 ( __attribute__((__leaf__)) __copysignf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__,
__const__)) ;
#line 201
extern _Float128 ( __attribute__((__leaf__)) nanf128)(char const   *__tagb )  __attribute__((__nothrow__)) ;
#line 201
extern _Float128 ( __attribute__((__leaf__)) __nanf128)(char const   *__tagb )  __attribute__((__nothrow__)) ;
#line 217
extern _Float128 ( __attribute__((__leaf__)) j0f128)(_Float128  )  __attribute__((__nothrow__)) ;
#line 217
extern _Float128 ( __attribute__((__leaf__)) __j0f128)(_Float128  )  __attribute__((__nothrow__)) ;
#line 218
extern _Float128 ( __attribute__((__leaf__)) j1f128)(_Float128  )  __attribute__((__nothrow__)) ;
#line 218
extern _Float128 ( __attribute__((__leaf__)) __j1f128)(_Float128  )  __attribute__((__nothrow__)) ;
#line 219
extern _Float128 ( __attribute__((__leaf__)) jnf128)(int  , _Float128  )  __attribute__((__nothrow__)) ;
#line 219
extern _Float128 ( __attribute__((__leaf__)) __jnf128)(int  , _Float128  )  __attribute__((__nothrow__)) ;
#line 220
extern _Float128 ( __attribute__((__leaf__)) y0f128)(_Float128  )  __attribute__((__nothrow__)) ;
#line 220
extern _Float128 ( __attribute__((__leaf__)) __y0f128)(_Float128  )  __attribute__((__nothrow__)) ;
#line 221
extern _Float128 ( __attribute__((__leaf__)) y1f128)(_Float128  )  __attribute__((__nothrow__)) ;
#line 221
extern _Float128 ( __attribute__((__leaf__)) __y1f128)(_Float128  )  __attribute__((__nothrow__)) ;
#line 222
extern _Float128 ( __attribute__((__leaf__)) ynf128)(int  , _Float128  )  __attribute__((__nothrow__)) ;
#line 222
extern _Float128 ( __attribute__((__leaf__)) __ynf128)(int  , _Float128  )  __attribute__((__nothrow__)) ;
#line 228
extern _Float128 ( __attribute__((__leaf__)) erff128)(_Float128  )  __attribute__((__nothrow__)) ;
#line 228
extern _Float128 ( __attribute__((__leaf__)) __erff128)(_Float128  )  __attribute__((__nothrow__)) ;
#line 229
extern _Float128 ( __attribute__((__leaf__)) erfcf128)(_Float128  )  __attribute__((__nothrow__)) ;
#line 229
extern _Float128 ( __attribute__((__leaf__)) __erfcf128)(_Float128  )  __attribute__((__nothrow__)) ;
#line 230
extern _Float128 ( __attribute__((__leaf__)) lgammaf128)(_Float128  )  __attribute__((__nothrow__)) ;
#line 230
extern _Float128 ( __attribute__((__leaf__)) __lgammaf128)(_Float128  )  __attribute__((__nothrow__)) ;
#line 235
extern _Float128 ( __attribute__((__leaf__)) tgammaf128)(_Float128  )  __attribute__((__nothrow__)) ;
#line 235
extern _Float128 ( __attribute__((__leaf__)) __tgammaf128)(_Float128  )  __attribute__((__nothrow__)) ;
#line 249
extern _Float128 ( __attribute__((__leaf__)) lgammaf128_r)(_Float128  , int *__signgamp )  __attribute__((__nothrow__)) ;
#line 249
extern _Float128 ( __attribute__((__leaf__)) __lgammaf128_r)(_Float128  , int *__signgamp )  __attribute__((__nothrow__)) ;
#line 256
extern _Float128 ( __attribute__((__leaf__)) rintf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 256
extern _Float128 ( __attribute__((__leaf__)) __rintf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 259
extern _Float128 ( __attribute__((__leaf__)) nextafterf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 259
extern _Float128 ( __attribute__((__leaf__)) __nextafterf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 266
extern _Float128 ( __attribute__((__leaf__)) nextdownf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 266
extern _Float128 ( __attribute__((__leaf__)) __nextdownf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 268
extern _Float128 ( __attribute__((__leaf__)) nextupf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 268
extern _Float128 ( __attribute__((__leaf__)) __nextupf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 272
extern _Float128 ( __attribute__((__leaf__)) remainderf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 272
extern _Float128 ( __attribute__((__leaf__)) __remainderf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 276
extern _Float128 ( __attribute__((__leaf__)) scalbnf128)(_Float128 __x , int __n )  __attribute__((__nothrow__)) ;
#line 276
extern _Float128 ( __attribute__((__leaf__)) __scalbnf128)(_Float128 __x , int __n )  __attribute__((__nothrow__)) ;
#line 280
extern int ( __attribute__((__leaf__)) ilogbf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 280
extern int ( __attribute__((__leaf__)) __ilogbf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 285
extern long ( __attribute__((__leaf__)) llogbf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 285
extern long ( __attribute__((__leaf__)) __llogbf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 290
extern _Float128 ( __attribute__((__leaf__)) scalblnf128)(_Float128 __x , long __n )  __attribute__((__nothrow__)) ;
#line 290
extern _Float128 ( __attribute__((__leaf__)) __scalblnf128)(_Float128 __x , long __n )  __attribute__((__nothrow__)) ;
#line 294
extern _Float128 ( __attribute__((__leaf__)) nearbyintf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 294
extern _Float128 ( __attribute__((__leaf__)) __nearbyintf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 298
extern _Float128 ( __attribute__((__leaf__)) roundf128)(_Float128 __x )  __attribute__((__nothrow__,
__const__)) ;
#line 298
extern _Float128 ( __attribute__((__leaf__)) __roundf128)(_Float128 __x )  __attribute__((__nothrow__,
__const__)) ;
#line 302
extern _Float128 ( __attribute__((__leaf__)) truncf128)(_Float128 __x )  __attribute__((__nothrow__,
__const__)) ;
#line 302
extern _Float128 ( __attribute__((__leaf__)) __truncf128)(_Float128 __x )  __attribute__((__nothrow__,
__const__)) ;
#line 307
extern _Float128 ( __attribute__((__leaf__)) remquof128)(_Float128 __x , _Float128 __y ,
                                                         int *__quo )  __attribute__((__nothrow__)) ;
#line 307
extern _Float128 ( __attribute__((__leaf__)) __remquof128)(_Float128 __x , _Float128 __y ,
                                                           int *__quo )  __attribute__((__nothrow__)) ;
#line 314
extern long ( __attribute__((__leaf__)) lrintf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 314
extern long ( __attribute__((__leaf__)) __lrintf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 316
extern long long ( __attribute__((__leaf__)) llrintf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 316
extern long long ( __attribute__((__leaf__)) __llrintf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 320
extern long ( __attribute__((__leaf__)) lroundf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 320
extern long ( __attribute__((__leaf__)) __lroundf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 322
extern long long ( __attribute__((__leaf__)) llroundf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 322
extern long long ( __attribute__((__leaf__)) __llroundf128)(_Float128 __x )  __attribute__((__nothrow__)) ;
#line 326
extern _Float128 ( __attribute__((__leaf__)) fdimf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 326
extern _Float128 ( __attribute__((__leaf__)) __fdimf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 329
extern _Float128 ( __attribute__((__leaf__)) fmaxf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__,
__const__)) ;
#line 329
extern _Float128 ( __attribute__((__leaf__)) __fmaxf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__,
__const__)) ;
#line 332
extern _Float128 ( __attribute__((__leaf__)) fminf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__,
__const__)) ;
#line 332
extern _Float128 ( __attribute__((__leaf__)) __fminf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__,
__const__)) ;
#line 335
extern _Float128 ( __attribute__((__leaf__)) fmaf128)(_Float128 __x , _Float128 __y ,
                                                      _Float128 __z )  __attribute__((__nothrow__)) ;
#line 335
extern _Float128 ( __attribute__((__leaf__)) __fmaf128)(_Float128 __x , _Float128 __y ,
                                                        _Float128 __z )  __attribute__((__nothrow__)) ;
#line 340
extern _Float128 ( __attribute__((__leaf__)) roundevenf128)(_Float128 __x )  __attribute__((__nothrow__,
__const__)) ;
#line 340
extern _Float128 ( __attribute__((__leaf__)) __roundevenf128)(_Float128 __x )  __attribute__((__nothrow__,
__const__)) ;
#line 344
extern __intmax_t ( __attribute__((__leaf__)) fromfpf128)(_Float128 __x , int __round ,
                                                          unsigned int __width )  __attribute__((__nothrow__)) ;
#line 344
extern __intmax_t ( __attribute__((__leaf__)) __fromfpf128)(_Float128 __x , int __round ,
                                                            unsigned int __width )  __attribute__((__nothrow__)) ;
#line 349
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpf128)(_Float128 __x , int __round ,
                                                            unsigned int __width )  __attribute__((__nothrow__)) ;
#line 349
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpf128)(_Float128 __x , int __round ,
                                                              unsigned int __width )  __attribute__((__nothrow__)) ;
#line 355
extern __intmax_t ( __attribute__((__leaf__)) fromfpxf128)(_Float128 __x , int __round ,
                                                           unsigned int __width )  __attribute__((__nothrow__)) ;
#line 355
extern __intmax_t ( __attribute__((__leaf__)) __fromfpxf128)(_Float128 __x , int __round ,
                                                             unsigned int __width )  __attribute__((__nothrow__)) ;
#line 361
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpxf128)(_Float128 __x , int __round ,
                                                             unsigned int __width )  __attribute__((__nothrow__)) ;
#line 361
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpxf128)(_Float128 __x , int __round ,
                                                               unsigned int __width )  __attribute__((__nothrow__)) ;
#line 365
extern _Float128 ( __attribute__((__leaf__)) fmaxmagf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__,
__const__)) ;
#line 365
extern _Float128 ( __attribute__((__leaf__)) __fmaxmagf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__,
__const__)) ;
#line 368
extern _Float128 ( __attribute__((__leaf__)) fminmagf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__,
__const__)) ;
#line 368
extern _Float128 ( __attribute__((__leaf__)) __fminmagf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__,
__const__)) ;
#line 371
extern int ( __attribute__((__leaf__)) canonicalizef128)(_Float128 *__cx , _Float128 const   *__x )  __attribute__((__nothrow__)) ;
#line 376
extern int ( __attribute__((__leaf__)) totalorderf128)(_Float128 const   *__x , _Float128 const   *__y )  __attribute__((__pure__,
__nothrow__)) ;
#line 381
extern int ( __attribute__((__leaf__)) totalordermagf128)(_Float128 const   *__x ,
                                                          _Float128 const   *__y )  __attribute__((__pure__,
__nothrow__)) ;
#line 386
extern _Float128 ( __attribute__((__leaf__)) getpayloadf128)(_Float128 const   *__x )  __attribute__((__nothrow__)) ;
#line 386
extern _Float128 ( __attribute__((__leaf__)) __getpayloadf128)(_Float128 const   *__x )  __attribute__((__nothrow__)) ;
#line 389
extern int ( __attribute__((__leaf__)) setpayloadf128)(_Float128 *__x , _Float128 __payload )  __attribute__((__nothrow__)) ;
#line 392
extern int ( __attribute__((__leaf__)) setpayloadsigf128)(_Float128 *__x , _Float128 __payload )  __attribute__((__nothrow__)) ;
#line 53
extern double ( __attribute__((__leaf__)) acosf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 53
extern double ( __attribute__((__leaf__)) __acosf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 55
extern double ( __attribute__((__leaf__)) asinf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 55
extern double ( __attribute__((__leaf__)) __asinf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 57
extern double ( __attribute__((__leaf__)) atanf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 57
extern double ( __attribute__((__leaf__)) __atanf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 59
extern double ( __attribute__((__leaf__)) atan2f32x)(double __y , double __x )  __attribute__((__nothrow__)) ;
#line 59
extern double ( __attribute__((__leaf__)) __atan2f32x)(double __y , double __x )  __attribute__((__nothrow__)) ;
#line 62
extern double ( __attribute__((__leaf__)) cosf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 62
extern double ( __attribute__((__leaf__)) __cosf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 64
extern double ( __attribute__((__leaf__)) sinf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 64
extern double ( __attribute__((__leaf__)) __sinf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 66
extern double ( __attribute__((__leaf__)) tanf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 66
extern double ( __attribute__((__leaf__)) __tanf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 71
extern double ( __attribute__((__leaf__)) coshf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 71
extern double ( __attribute__((__leaf__)) __coshf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 73
extern double ( __attribute__((__leaf__)) sinhf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 73
extern double ( __attribute__((__leaf__)) __sinhf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 75
extern double ( __attribute__((__leaf__)) tanhf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 75
extern double ( __attribute__((__leaf__)) __tanhf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 79
extern void ( __attribute__((__leaf__)) sincosf32x)(double __x , double *__sinx ,
                                                    double *__cosx )  __attribute__((__nothrow__)) ;
#line 79
extern void ( __attribute__((__leaf__)) __sincosf32x)(double __x , double *__sinx ,
                                                      double *__cosx )  __attribute__((__nothrow__)) ;
#line 85
extern double ( __attribute__((__leaf__)) acoshf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 85
extern double ( __attribute__((__leaf__)) __acoshf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 87
extern double ( __attribute__((__leaf__)) asinhf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 87
extern double ( __attribute__((__leaf__)) __asinhf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 89
extern double ( __attribute__((__leaf__)) atanhf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 89
extern double ( __attribute__((__leaf__)) __atanhf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 95
extern double ( __attribute__((__leaf__)) expf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 95
extern double ( __attribute__((__leaf__)) __expf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 98
extern double ( __attribute__((__leaf__)) frexpf32x)(double __x , int *__exponent )  __attribute__((__nothrow__)) ;
#line 98
extern double ( __attribute__((__leaf__)) __frexpf32x)(double __x , int *__exponent )  __attribute__((__nothrow__)) ;
#line 101
extern double ( __attribute__((__leaf__)) ldexpf32x)(double __x , int __exponent )  __attribute__((__nothrow__)) ;
#line 101
extern double ( __attribute__((__leaf__)) __ldexpf32x)(double __x , int __exponent )  __attribute__((__nothrow__)) ;
#line 104
extern double ( __attribute__((__leaf__)) logf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 104
extern double ( __attribute__((__leaf__)) __logf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 107
extern double ( __attribute__((__leaf__)) log10f32x)(double __x )  __attribute__((__nothrow__)) ;
#line 107
extern double ( __attribute__((__leaf__)) __log10f32x)(double __x )  __attribute__((__nothrow__)) ;
#line 110
extern double ( __attribute__((__leaf__)) modff32x)(double __x , double *__iptr )  __attribute__((__nothrow__)) ;
#line 110
extern double ( __attribute__((__nonnull__(2), __leaf__)) __modff32x)(double __x ,
                                                                      double *__iptr )  __attribute__((__nothrow__)) ;
#line 114
extern double ( __attribute__((__leaf__)) exp10f32x)(double __x )  __attribute__((__nothrow__)) ;
#line 114
extern double ( __attribute__((__leaf__)) __exp10f32x)(double __x )  __attribute__((__nothrow__)) ;
#line 119
extern double ( __attribute__((__leaf__)) expm1f32x)(double __x )  __attribute__((__nothrow__)) ;
#line 119
extern double ( __attribute__((__leaf__)) __expm1f32x)(double __x )  __attribute__((__nothrow__)) ;
#line 122
extern double ( __attribute__((__leaf__)) log1pf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 122
extern double ( __attribute__((__leaf__)) __log1pf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 125
extern double ( __attribute__((__leaf__)) logbf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 125
extern double ( __attribute__((__leaf__)) __logbf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 130
extern double ( __attribute__((__leaf__)) exp2f32x)(double __x )  __attribute__((__nothrow__)) ;
#line 130
extern double ( __attribute__((__leaf__)) __exp2f32x)(double __x )  __attribute__((__nothrow__)) ;
#line 133
extern double ( __attribute__((__leaf__)) log2f32x)(double __x )  __attribute__((__nothrow__)) ;
#line 133
extern double ( __attribute__((__leaf__)) __log2f32x)(double __x )  __attribute__((__nothrow__)) ;
#line 140
extern double ( __attribute__((__leaf__)) powf32x)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 140
extern double ( __attribute__((__leaf__)) __powf32x)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 143
extern double ( __attribute__((__leaf__)) sqrtf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 143
extern double ( __attribute__((__leaf__)) __sqrtf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 147
extern double ( __attribute__((__leaf__)) hypotf32x)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 147
extern double ( __attribute__((__leaf__)) __hypotf32x)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 152
extern double ( __attribute__((__leaf__)) cbrtf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 152
extern double ( __attribute__((__leaf__)) __cbrtf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 159
extern double ( __attribute__((__leaf__)) ceilf32x)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 159
extern double ( __attribute__((__leaf__)) __ceilf32x)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 162
extern double ( __attribute__((__leaf__)) fabsf32x)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 162
extern double ( __attribute__((__leaf__)) __fabsf32x)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 165
extern double ( __attribute__((__leaf__)) floorf32x)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 165
extern double ( __attribute__((__leaf__)) __floorf32x)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 168
extern double ( __attribute__((__leaf__)) fmodf32x)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 168
extern double ( __attribute__((__leaf__)) __fmodf32x)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 196
extern double ( __attribute__((__leaf__)) copysignf32x)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 196
extern double ( __attribute__((__leaf__)) __copysignf32x)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 201
extern double ( __attribute__((__leaf__)) nanf32x)(char const   *__tagb )  __attribute__((__nothrow__)) ;
#line 201
extern double ( __attribute__((__leaf__)) __nanf32x)(char const   *__tagb )  __attribute__((__nothrow__)) ;
#line 217
extern double ( __attribute__((__leaf__)) j0f32x)(double  )  __attribute__((__nothrow__)) ;
#line 217
extern double ( __attribute__((__leaf__)) __j0f32x)(double  )  __attribute__((__nothrow__)) ;
#line 218
extern double ( __attribute__((__leaf__)) j1f32x)(double  )  __attribute__((__nothrow__)) ;
#line 218
extern double ( __attribute__((__leaf__)) __j1f32x)(double  )  __attribute__((__nothrow__)) ;
#line 219
extern double ( __attribute__((__leaf__)) jnf32x)(int  , double  )  __attribute__((__nothrow__)) ;
#line 219
extern double ( __attribute__((__leaf__)) __jnf32x)(int  , double  )  __attribute__((__nothrow__)) ;
#line 220
extern double ( __attribute__((__leaf__)) y0f32x)(double  )  __attribute__((__nothrow__)) ;
#line 220
extern double ( __attribute__((__leaf__)) __y0f32x)(double  )  __attribute__((__nothrow__)) ;
#line 221
extern double ( __attribute__((__leaf__)) y1f32x)(double  )  __attribute__((__nothrow__)) ;
#line 221
extern double ( __attribute__((__leaf__)) __y1f32x)(double  )  __attribute__((__nothrow__)) ;
#line 222
extern double ( __attribute__((__leaf__)) ynf32x)(int  , double  )  __attribute__((__nothrow__)) ;
#line 222
extern double ( __attribute__((__leaf__)) __ynf32x)(int  , double  )  __attribute__((__nothrow__)) ;
#line 228
extern double ( __attribute__((__leaf__)) erff32x)(double  )  __attribute__((__nothrow__)) ;
#line 228
extern double ( __attribute__((__leaf__)) __erff32x)(double  )  __attribute__((__nothrow__)) ;
#line 229
extern double ( __attribute__((__leaf__)) erfcf32x)(double  )  __attribute__((__nothrow__)) ;
#line 229
extern double ( __attribute__((__leaf__)) __erfcf32x)(double  )  __attribute__((__nothrow__)) ;
#line 230
extern double ( __attribute__((__leaf__)) lgammaf32x)(double  )  __attribute__((__nothrow__)) ;
#line 230
extern double ( __attribute__((__leaf__)) __lgammaf32x)(double  )  __attribute__((__nothrow__)) ;
#line 235
extern double ( __attribute__((__leaf__)) tgammaf32x)(double  )  __attribute__((__nothrow__)) ;
#line 235
extern double ( __attribute__((__leaf__)) __tgammaf32x)(double  )  __attribute__((__nothrow__)) ;
#line 249
extern double ( __attribute__((__leaf__)) lgammaf32x_r)(double  , int *__signgamp )  __attribute__((__nothrow__)) ;
#line 249
extern double ( __attribute__((__leaf__)) __lgammaf32x_r)(double  , int *__signgamp )  __attribute__((__nothrow__)) ;
#line 256
extern double ( __attribute__((__leaf__)) rintf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 256
extern double ( __attribute__((__leaf__)) __rintf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 259
extern double ( __attribute__((__leaf__)) nextafterf32x)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 259
extern double ( __attribute__((__leaf__)) __nextafterf32x)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 266
extern double ( __attribute__((__leaf__)) nextdownf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 266
extern double ( __attribute__((__leaf__)) __nextdownf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 268
extern double ( __attribute__((__leaf__)) nextupf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 268
extern double ( __attribute__((__leaf__)) __nextupf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 272
extern double ( __attribute__((__leaf__)) remainderf32x)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 272
extern double ( __attribute__((__leaf__)) __remainderf32x)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 276
extern double ( __attribute__((__leaf__)) scalbnf32x)(double __x , int __n )  __attribute__((__nothrow__)) ;
#line 276
extern double ( __attribute__((__leaf__)) __scalbnf32x)(double __x , int __n )  __attribute__((__nothrow__)) ;
#line 280
extern int ( __attribute__((__leaf__)) ilogbf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 280
extern int ( __attribute__((__leaf__)) __ilogbf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 285
extern long ( __attribute__((__leaf__)) llogbf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 285
extern long ( __attribute__((__leaf__)) __llogbf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 290
extern double ( __attribute__((__leaf__)) scalblnf32x)(double __x , long __n )  __attribute__((__nothrow__)) ;
#line 290
extern double ( __attribute__((__leaf__)) __scalblnf32x)(double __x , long __n )  __attribute__((__nothrow__)) ;
#line 294
extern double ( __attribute__((__leaf__)) nearbyintf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 294
extern double ( __attribute__((__leaf__)) __nearbyintf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 298
extern double ( __attribute__((__leaf__)) roundf32x)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 298
extern double ( __attribute__((__leaf__)) __roundf32x)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 302
extern double ( __attribute__((__leaf__)) truncf32x)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 302
extern double ( __attribute__((__leaf__)) __truncf32x)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 307
extern double ( __attribute__((__leaf__)) remquof32x)(double __x , double __y , int *__quo )  __attribute__((__nothrow__)) ;
#line 307
extern double ( __attribute__((__leaf__)) __remquof32x)(double __x , double __y ,
                                                        int *__quo )  __attribute__((__nothrow__)) ;
#line 314
extern long ( __attribute__((__leaf__)) lrintf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 314
extern long ( __attribute__((__leaf__)) __lrintf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 316
extern long long ( __attribute__((__leaf__)) llrintf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 316
extern long long ( __attribute__((__leaf__)) __llrintf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 320
extern long ( __attribute__((__leaf__)) lroundf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 320
extern long ( __attribute__((__leaf__)) __lroundf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 322
extern long long ( __attribute__((__leaf__)) llroundf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 322
extern long long ( __attribute__((__leaf__)) __llroundf32x)(double __x )  __attribute__((__nothrow__)) ;
#line 326
extern double ( __attribute__((__leaf__)) fdimf32x)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 326
extern double ( __attribute__((__leaf__)) __fdimf32x)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 329
extern double ( __attribute__((__leaf__)) fmaxf32x)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 329
extern double ( __attribute__((__leaf__)) __fmaxf32x)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 332
extern double ( __attribute__((__leaf__)) fminf32x)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 332
extern double ( __attribute__((__leaf__)) __fminf32x)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 335
extern double ( __attribute__((__leaf__)) fmaf32x)(double __x , double __y , double __z )  __attribute__((__nothrow__)) ;
#line 335
extern double ( __attribute__((__leaf__)) __fmaf32x)(double __x , double __y , double __z )  __attribute__((__nothrow__)) ;
#line 340
extern double ( __attribute__((__leaf__)) roundevenf32x)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 340
extern double ( __attribute__((__leaf__)) __roundevenf32x)(double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 344
extern __intmax_t ( __attribute__((__leaf__)) fromfpf32x)(double __x , int __round ,
                                                          unsigned int __width )  __attribute__((__nothrow__)) ;
#line 344
extern __intmax_t ( __attribute__((__leaf__)) __fromfpf32x)(double __x , int __round ,
                                                            unsigned int __width )  __attribute__((__nothrow__)) ;
#line 349
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpf32x)(double __x , int __round ,
                                                            unsigned int __width )  __attribute__((__nothrow__)) ;
#line 349
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpf32x)(double __x , int __round ,
                                                              unsigned int __width )  __attribute__((__nothrow__)) ;
#line 355
extern __intmax_t ( __attribute__((__leaf__)) fromfpxf32x)(double __x , int __round ,
                                                           unsigned int __width )  __attribute__((__nothrow__)) ;
#line 355
extern __intmax_t ( __attribute__((__leaf__)) __fromfpxf32x)(double __x , int __round ,
                                                             unsigned int __width )  __attribute__((__nothrow__)) ;
#line 361
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpxf32x)(double __x , int __round ,
                                                             unsigned int __width )  __attribute__((__nothrow__)) ;
#line 361
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpxf32x)(double __x , int __round ,
                                                               unsigned int __width )  __attribute__((__nothrow__)) ;
#line 365
extern double ( __attribute__((__leaf__)) fmaxmagf32x)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 365
extern double ( __attribute__((__leaf__)) __fmaxmagf32x)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 368
extern double ( __attribute__((__leaf__)) fminmagf32x)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 368
extern double ( __attribute__((__leaf__)) __fminmagf32x)(double __x , double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 371
extern int ( __attribute__((__leaf__)) canonicalizef32x)(double *__cx , double const   *__x )  __attribute__((__nothrow__)) ;
#line 376
extern int ( __attribute__((__leaf__)) totalorderf32x)(double const   *__x , double const   *__y )  __attribute__((__pure__,
__nothrow__)) ;
#line 381
extern int ( __attribute__((__leaf__)) totalordermagf32x)(double const   *__x , double const   *__y )  __attribute__((__pure__,
__nothrow__)) ;
#line 386
extern double ( __attribute__((__leaf__)) getpayloadf32x)(double const   *__x )  __attribute__((__nothrow__)) ;
#line 386
extern double ( __attribute__((__leaf__)) __getpayloadf32x)(double const   *__x )  __attribute__((__nothrow__)) ;
#line 389
extern int ( __attribute__((__leaf__)) setpayloadf32x)(double *__x , double __payload )  __attribute__((__nothrow__)) ;
#line 392
extern int ( __attribute__((__leaf__)) setpayloadsigf32x)(double *__x , double __payload )  __attribute__((__nothrow__)) ;
#line 53
extern long double ( __attribute__((__leaf__)) acosf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 53
extern long double ( __attribute__((__leaf__)) __acosf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 55
extern long double ( __attribute__((__leaf__)) asinf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 55
extern long double ( __attribute__((__leaf__)) __asinf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 57
extern long double ( __attribute__((__leaf__)) atanf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 57
extern long double ( __attribute__((__leaf__)) __atanf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 59
extern long double ( __attribute__((__leaf__)) atan2f64x)(long double __y , long double __x )  __attribute__((__nothrow__)) ;
#line 59
extern long double ( __attribute__((__leaf__)) __atan2f64x)(long double __y , long double __x )  __attribute__((__nothrow__)) ;
#line 62
extern long double ( __attribute__((__leaf__)) cosf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 62
extern long double ( __attribute__((__leaf__)) __cosf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 64
extern long double ( __attribute__((__leaf__)) sinf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 64
extern long double ( __attribute__((__leaf__)) __sinf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 66
extern long double ( __attribute__((__leaf__)) tanf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 66
extern long double ( __attribute__((__leaf__)) __tanf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 71
extern long double ( __attribute__((__leaf__)) coshf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 71
extern long double ( __attribute__((__leaf__)) __coshf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 73
extern long double ( __attribute__((__leaf__)) sinhf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 73
extern long double ( __attribute__((__leaf__)) __sinhf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 75
extern long double ( __attribute__((__leaf__)) tanhf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 75
extern long double ( __attribute__((__leaf__)) __tanhf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 79
extern void ( __attribute__((__leaf__)) sincosf64x)(long double __x , long double *__sinx ,
                                                    long double *__cosx )  __attribute__((__nothrow__)) ;
#line 79
extern void ( __attribute__((__leaf__)) __sincosf64x)(long double __x , long double *__sinx ,
                                                      long double *__cosx )  __attribute__((__nothrow__)) ;
#line 85
extern long double ( __attribute__((__leaf__)) acoshf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 85
extern long double ( __attribute__((__leaf__)) __acoshf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 87
extern long double ( __attribute__((__leaf__)) asinhf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 87
extern long double ( __attribute__((__leaf__)) __asinhf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 89
extern long double ( __attribute__((__leaf__)) atanhf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 89
extern long double ( __attribute__((__leaf__)) __atanhf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 95
extern long double ( __attribute__((__leaf__)) expf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 95
extern long double ( __attribute__((__leaf__)) __expf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 98
extern long double ( __attribute__((__leaf__)) frexpf64x)(long double __x , int *__exponent )  __attribute__((__nothrow__)) ;
#line 98
extern long double ( __attribute__((__leaf__)) __frexpf64x)(long double __x , int *__exponent )  __attribute__((__nothrow__)) ;
#line 101
extern long double ( __attribute__((__leaf__)) ldexpf64x)(long double __x , int __exponent )  __attribute__((__nothrow__)) ;
#line 101
extern long double ( __attribute__((__leaf__)) __ldexpf64x)(long double __x , int __exponent )  __attribute__((__nothrow__)) ;
#line 104
extern long double ( __attribute__((__leaf__)) logf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 104
extern long double ( __attribute__((__leaf__)) __logf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 107
extern long double ( __attribute__((__leaf__)) log10f64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 107
extern long double ( __attribute__((__leaf__)) __log10f64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 110
extern long double ( __attribute__((__leaf__)) modff64x)(long double __x , long double *__iptr )  __attribute__((__nothrow__)) ;
#line 110
extern long double ( __attribute__((__nonnull__(2), __leaf__)) __modff64x)(long double __x ,
                                                                           long double *__iptr )  __attribute__((__nothrow__)) ;
#line 114
extern long double ( __attribute__((__leaf__)) exp10f64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 114
extern long double ( __attribute__((__leaf__)) __exp10f64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 119
extern long double ( __attribute__((__leaf__)) expm1f64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 119
extern long double ( __attribute__((__leaf__)) __expm1f64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 122
extern long double ( __attribute__((__leaf__)) log1pf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 122
extern long double ( __attribute__((__leaf__)) __log1pf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 125
extern long double ( __attribute__((__leaf__)) logbf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 125
extern long double ( __attribute__((__leaf__)) __logbf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 130
extern long double ( __attribute__((__leaf__)) exp2f64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 130
extern long double ( __attribute__((__leaf__)) __exp2f64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 133
extern long double ( __attribute__((__leaf__)) log2f64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 133
extern long double ( __attribute__((__leaf__)) __log2f64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 140
extern long double ( __attribute__((__leaf__)) powf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 140
extern long double ( __attribute__((__leaf__)) __powf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 143
extern long double ( __attribute__((__leaf__)) sqrtf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 143
extern long double ( __attribute__((__leaf__)) __sqrtf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 147
extern long double ( __attribute__((__leaf__)) hypotf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 147
extern long double ( __attribute__((__leaf__)) __hypotf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 152
extern long double ( __attribute__((__leaf__)) cbrtf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 152
extern long double ( __attribute__((__leaf__)) __cbrtf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 159
extern long double ( __attribute__((__leaf__)) ceilf64x)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 159
extern long double ( __attribute__((__leaf__)) __ceilf64x)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 162
extern long double ( __attribute__((__leaf__)) fabsf64x)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 162
extern long double ( __attribute__((__leaf__)) __fabsf64x)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 165
extern long double ( __attribute__((__leaf__)) floorf64x)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 165
extern long double ( __attribute__((__leaf__)) __floorf64x)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 168
extern long double ( __attribute__((__leaf__)) fmodf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 168
extern long double ( __attribute__((__leaf__)) __fmodf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 196
extern long double ( __attribute__((__leaf__)) copysignf64x)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 196
extern long double ( __attribute__((__leaf__)) __copysignf64x)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 201
extern long double ( __attribute__((__leaf__)) nanf64x)(char const   *__tagb )  __attribute__((__nothrow__)) ;
#line 201
extern long double ( __attribute__((__leaf__)) __nanf64x)(char const   *__tagb )  __attribute__((__nothrow__)) ;
#line 217
extern long double ( __attribute__((__leaf__)) j0f64x)(long double  )  __attribute__((__nothrow__)) ;
#line 217
extern long double ( __attribute__((__leaf__)) __j0f64x)(long double  )  __attribute__((__nothrow__)) ;
#line 218
extern long double ( __attribute__((__leaf__)) j1f64x)(long double  )  __attribute__((__nothrow__)) ;
#line 218
extern long double ( __attribute__((__leaf__)) __j1f64x)(long double  )  __attribute__((__nothrow__)) ;
#line 219
extern long double ( __attribute__((__leaf__)) jnf64x)(int  , long double  )  __attribute__((__nothrow__)) ;
#line 219
extern long double ( __attribute__((__leaf__)) __jnf64x)(int  , long double  )  __attribute__((__nothrow__)) ;
#line 220
extern long double ( __attribute__((__leaf__)) y0f64x)(long double  )  __attribute__((__nothrow__)) ;
#line 220
extern long double ( __attribute__((__leaf__)) __y0f64x)(long double  )  __attribute__((__nothrow__)) ;
#line 221
extern long double ( __attribute__((__leaf__)) y1f64x)(long double  )  __attribute__((__nothrow__)) ;
#line 221
extern long double ( __attribute__((__leaf__)) __y1f64x)(long double  )  __attribute__((__nothrow__)) ;
#line 222
extern long double ( __attribute__((__leaf__)) ynf64x)(int  , long double  )  __attribute__((__nothrow__)) ;
#line 222
extern long double ( __attribute__((__leaf__)) __ynf64x)(int  , long double  )  __attribute__((__nothrow__)) ;
#line 228
extern long double ( __attribute__((__leaf__)) erff64x)(long double  )  __attribute__((__nothrow__)) ;
#line 228
extern long double ( __attribute__((__leaf__)) __erff64x)(long double  )  __attribute__((__nothrow__)) ;
#line 229
extern long double ( __attribute__((__leaf__)) erfcf64x)(long double  )  __attribute__((__nothrow__)) ;
#line 229
extern long double ( __attribute__((__leaf__)) __erfcf64x)(long double  )  __attribute__((__nothrow__)) ;
#line 230
extern long double ( __attribute__((__leaf__)) lgammaf64x)(long double  )  __attribute__((__nothrow__)) ;
#line 230
extern long double ( __attribute__((__leaf__)) __lgammaf64x)(long double  )  __attribute__((__nothrow__)) ;
#line 235
extern long double ( __attribute__((__leaf__)) tgammaf64x)(long double  )  __attribute__((__nothrow__)) ;
#line 235
extern long double ( __attribute__((__leaf__)) __tgammaf64x)(long double  )  __attribute__((__nothrow__)) ;
#line 249
extern long double ( __attribute__((__leaf__)) lgammaf64x_r)(long double  , int *__signgamp )  __attribute__((__nothrow__)) ;
#line 249
extern long double ( __attribute__((__leaf__)) __lgammaf64x_r)(long double  , int *__signgamp )  __attribute__((__nothrow__)) ;
#line 256
extern long double ( __attribute__((__leaf__)) rintf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 256
extern long double ( __attribute__((__leaf__)) __rintf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 259
extern long double ( __attribute__((__leaf__)) nextafterf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 259
extern long double ( __attribute__((__leaf__)) __nextafterf64x)(long double __x ,
                                                                long double __y )  __attribute__((__nothrow__)) ;
#line 266
extern long double ( __attribute__((__leaf__)) nextdownf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 266
extern long double ( __attribute__((__leaf__)) __nextdownf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 268
extern long double ( __attribute__((__leaf__)) nextupf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 268
extern long double ( __attribute__((__leaf__)) __nextupf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 272
extern long double ( __attribute__((__leaf__)) remainderf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 272
extern long double ( __attribute__((__leaf__)) __remainderf64x)(long double __x ,
                                                                long double __y )  __attribute__((__nothrow__)) ;
#line 276
extern long double ( __attribute__((__leaf__)) scalbnf64x)(long double __x , int __n )  __attribute__((__nothrow__)) ;
#line 276
extern long double ( __attribute__((__leaf__)) __scalbnf64x)(long double __x , int __n )  __attribute__((__nothrow__)) ;
#line 280
extern int ( __attribute__((__leaf__)) ilogbf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 280
extern int ( __attribute__((__leaf__)) __ilogbf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 285
extern long ( __attribute__((__leaf__)) llogbf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 285
extern long ( __attribute__((__leaf__)) __llogbf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 290
extern long double ( __attribute__((__leaf__)) scalblnf64x)(long double __x , long __n )  __attribute__((__nothrow__)) ;
#line 290
extern long double ( __attribute__((__leaf__)) __scalblnf64x)(long double __x , long __n )  __attribute__((__nothrow__)) ;
#line 294
extern long double ( __attribute__((__leaf__)) nearbyintf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 294
extern long double ( __attribute__((__leaf__)) __nearbyintf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 298
extern long double ( __attribute__((__leaf__)) roundf64x)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 298
extern long double ( __attribute__((__leaf__)) __roundf64x)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 302
extern long double ( __attribute__((__leaf__)) truncf64x)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 302
extern long double ( __attribute__((__leaf__)) __truncf64x)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 307
extern long double ( __attribute__((__leaf__)) remquof64x)(long double __x , long double __y ,
                                                           int *__quo )  __attribute__((__nothrow__)) ;
#line 307
extern long double ( __attribute__((__leaf__)) __remquof64x)(long double __x , long double __y ,
                                                             int *__quo )  __attribute__((__nothrow__)) ;
#line 314
extern long ( __attribute__((__leaf__)) lrintf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 314
extern long ( __attribute__((__leaf__)) __lrintf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 316
extern long long ( __attribute__((__leaf__)) llrintf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 316
extern long long ( __attribute__((__leaf__)) __llrintf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 320
extern long ( __attribute__((__leaf__)) lroundf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 320
extern long ( __attribute__((__leaf__)) __lroundf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 322
extern long long ( __attribute__((__leaf__)) llroundf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 322
extern long long ( __attribute__((__leaf__)) __llroundf64x)(long double __x )  __attribute__((__nothrow__)) ;
#line 326
extern long double ( __attribute__((__leaf__)) fdimf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 326
extern long double ( __attribute__((__leaf__)) __fdimf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 329
extern long double ( __attribute__((__leaf__)) fmaxf64x)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 329
extern long double ( __attribute__((__leaf__)) __fmaxf64x)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 332
extern long double ( __attribute__((__leaf__)) fminf64x)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 332
extern long double ( __attribute__((__leaf__)) __fminf64x)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 335
extern long double ( __attribute__((__leaf__)) fmaf64x)(long double __x , long double __y ,
                                                        long double __z )  __attribute__((__nothrow__)) ;
#line 335
extern long double ( __attribute__((__leaf__)) __fmaf64x)(long double __x , long double __y ,
                                                          long double __z )  __attribute__((__nothrow__)) ;
#line 340
extern long double ( __attribute__((__leaf__)) roundevenf64x)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 340
extern long double ( __attribute__((__leaf__)) __roundevenf64x)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 344
extern __intmax_t ( __attribute__((__leaf__)) fromfpf64x)(long double __x , int __round ,
                                                          unsigned int __width )  __attribute__((__nothrow__)) ;
#line 344
extern __intmax_t ( __attribute__((__leaf__)) __fromfpf64x)(long double __x , int __round ,
                                                            unsigned int __width )  __attribute__((__nothrow__)) ;
#line 349
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpf64x)(long double __x , int __round ,
                                                            unsigned int __width )  __attribute__((__nothrow__)) ;
#line 349
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpf64x)(long double __x , int __round ,
                                                              unsigned int __width )  __attribute__((__nothrow__)) ;
#line 355
extern __intmax_t ( __attribute__((__leaf__)) fromfpxf64x)(long double __x , int __round ,
                                                           unsigned int __width )  __attribute__((__nothrow__)) ;
#line 355
extern __intmax_t ( __attribute__((__leaf__)) __fromfpxf64x)(long double __x , int __round ,
                                                             unsigned int __width )  __attribute__((__nothrow__)) ;
#line 361
extern __uintmax_t ( __attribute__((__leaf__)) ufromfpxf64x)(long double __x , int __round ,
                                                             unsigned int __width )  __attribute__((__nothrow__)) ;
#line 361
extern __uintmax_t ( __attribute__((__leaf__)) __ufromfpxf64x)(long double __x , int __round ,
                                                               unsigned int __width )  __attribute__((__nothrow__)) ;
#line 365
extern long double ( __attribute__((__leaf__)) fmaxmagf64x)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 365
extern long double ( __attribute__((__leaf__)) __fmaxmagf64x)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 368
extern long double ( __attribute__((__leaf__)) fminmagf64x)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 368
extern long double ( __attribute__((__leaf__)) __fminmagf64x)(long double __x , long double __y )  __attribute__((__nothrow__,
__const__)) ;
#line 371
extern int ( __attribute__((__leaf__)) canonicalizef64x)(long double *__cx , long double const   *__x )  __attribute__((__nothrow__)) ;
#line 376
extern int ( __attribute__((__leaf__)) totalorderf64x)(long double const   *__x ,
                                                       long double const   *__y )  __attribute__((__pure__,
__nothrow__)) ;
#line 381
extern int ( __attribute__((__leaf__)) totalordermagf64x)(long double const   *__x ,
                                                          long double const   *__y )  __attribute__((__pure__,
__nothrow__)) ;
#line 386
extern long double ( __attribute__((__leaf__)) getpayloadf64x)(long double const   *__x )  __attribute__((__nothrow__)) ;
#line 386
extern long double ( __attribute__((__leaf__)) __getpayloadf64x)(long double const   *__x )  __attribute__((__nothrow__)) ;
#line 389
extern int ( __attribute__((__leaf__)) setpayloadf64x)(long double *__x , long double __payload )  __attribute__((__nothrow__)) ;
#line 392
extern int ( __attribute__((__leaf__)) setpayloadsigf64x)(long double *__x , long double __payload )  __attribute__((__nothrow__)) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h"
extern float ( __attribute__((__leaf__)) fadd)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 27
extern float ( __attribute__((__leaf__)) fdiv)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 30
extern float ( __attribute__((__leaf__)) fmul)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 33
extern float ( __attribute__((__leaf__)) fsub)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 24
extern float ( __attribute__((__leaf__)) faddl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 27
extern float ( __attribute__((__leaf__)) fdivl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 30
extern float ( __attribute__((__leaf__)) fmull)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 33
extern float ( __attribute__((__leaf__)) fsubl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 24
extern double ( __attribute__((__leaf__)) daddl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 27
extern double ( __attribute__((__leaf__)) ddivl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 30
extern double ( __attribute__((__leaf__)) dmull)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 33
extern double ( __attribute__((__leaf__)) dsubl)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 24
extern float ( __attribute__((__leaf__)) f32addf32x)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 27
extern float ( __attribute__((__leaf__)) f32divf32x)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 30
extern float ( __attribute__((__leaf__)) f32mulf32x)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 33
extern float ( __attribute__((__leaf__)) f32subf32x)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 24
extern float ( __attribute__((__leaf__)) f32addf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 27
extern float ( __attribute__((__leaf__)) f32divf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 30
extern float ( __attribute__((__leaf__)) f32mulf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 33
extern float ( __attribute__((__leaf__)) f32subf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 24
extern float ( __attribute__((__leaf__)) f32addf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 27
extern float ( __attribute__((__leaf__)) f32divf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 30
extern float ( __attribute__((__leaf__)) f32mulf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 33
extern float ( __attribute__((__leaf__)) f32subf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 24
extern float ( __attribute__((__leaf__)) f32addf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 27
extern float ( __attribute__((__leaf__)) f32divf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 30
extern float ( __attribute__((__leaf__)) f32mulf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 33
extern float ( __attribute__((__leaf__)) f32subf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 24
extern double ( __attribute__((__leaf__)) f32xaddf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 27
extern double ( __attribute__((__leaf__)) f32xdivf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 30
extern double ( __attribute__((__leaf__)) f32xmulf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 33
extern double ( __attribute__((__leaf__)) f32xsubf64)(double __x , double __y )  __attribute__((__nothrow__)) ;
#line 24
extern double ( __attribute__((__leaf__)) f32xaddf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 27
extern double ( __attribute__((__leaf__)) f32xdivf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 30
extern double ( __attribute__((__leaf__)) f32xmulf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 33
extern double ( __attribute__((__leaf__)) f32xsubf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 24
extern double ( __attribute__((__leaf__)) f32xaddf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 27
extern double ( __attribute__((__leaf__)) f32xdivf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 30
extern double ( __attribute__((__leaf__)) f32xmulf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 33
extern double ( __attribute__((__leaf__)) f32xsubf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 24
extern double ( __attribute__((__leaf__)) f64addf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 27
extern double ( __attribute__((__leaf__)) f64divf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 30
extern double ( __attribute__((__leaf__)) f64mulf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 33
extern double ( __attribute__((__leaf__)) f64subf64x)(long double __x , long double __y )  __attribute__((__nothrow__)) ;
#line 24
extern double ( __attribute__((__leaf__)) f64addf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 27
extern double ( __attribute__((__leaf__)) f64divf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 30
extern double ( __attribute__((__leaf__)) f64mulf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 33
extern double ( __attribute__((__leaf__)) f64subf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 24
extern long double ( __attribute__((__leaf__)) f64xaddf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 27
extern long double ( __attribute__((__leaf__)) f64xdivf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 30
extern long double ( __attribute__((__leaf__)) f64xmulf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 33
extern long double ( __attribute__((__leaf__)) f64xsubf128)(_Float128 __x , _Float128 __y )  __attribute__((__nothrow__)) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h"
extern int ( __attribute__((__leaf__)) __iscanonicall)(long double __x )  __attribute__((__nothrow__,
__const__)) ;
#line 201 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
void const   * volatile  make_volatile_for_gnu  ;
#line 214 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static size_t safecat(char *buffer___0 , size_t bufsize , size_t pos , char const   *cat )
{
  size_t tmp ;
  char const   *tmp___0 ;

  {
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    if (pos < bufsize) {
#line 217
      if ((unsigned long )cat != (unsigned long )((void *)0)) {
#line 217
        if (! ((int const   )*cat != 0)) {
#line 217
          goto while_break;
        }
      } else {
#line 217
        goto while_break;
      }
    } else {
#line 217
      goto while_break;
    }
#line 218
    tmp = pos;
#line 218
    pos ++;
#line 218
    tmp___0 = cat;
#line 218
    cat ++;
#line 218
    *(buffer___0 + tmp) = (char )*tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  if (pos >= bufsize) {
#line 221
    pos = bufsize - 1UL;
  }
#line 223
  *(buffer___0 + pos) = (char)0;
#line 224
  return (pos);
}
}
#line 227 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static size_t safecatn(char *buffer___0 , size_t bufsize , size_t pos , int n )
{
  char number[64] ;
  size_t tmp ;

  {
#line 230
  sprintf(number, (char const   *)"%d", n);
#line 231
  tmp = safecat(buffer___0, bufsize, pos, (char const   *)(number));
#line 231
  return (tmp);
}
}
#line 235 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static size_t safecatd(char *buffer___0 , size_t bufsize , size_t pos , double d ,
                       int precision )
{
  char number[64] ;
  size_t tmp ;

  {
#line 239
  sprintf(number, (char const   *)"%.*f", precision, d);
#line 240
  tmp = safecat(buffer___0, bufsize, pos, (char const   *)(number));
#line 240
  return (tmp);
}
}
#line 244 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static char const   invalid[8]  =
#line 244
  {      (char const   )'i',      (char const   )'n',      (char const   )'v',      (char const   )'a',
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )'\000'};
#line 245 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static char const   sep[3]  = {      (char const   )':',      (char const   )' ',      (char const   )'\000'};
#line 247 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static char const   *colour_types[8]  =
#line 247
  {      (char const   *)"grayscale",      invalid,      (char const   *)"truecolour",      (char const   *)"indexed-colour",
        (char const   *)"grayscale with alpha",      invalid,      (char const   *)"truecolour with alpha",      invalid};
#line 255 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static png_fixed_point fix(double d )
{


  {
#line 258
  d = floor(d * (double )100000 + .5);
#line 259
  return ((png_fixed_point )d);
}
}
#line 270 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void make_random_bytes___0(png_uint_32 *seed , void *pv , size_t size )
{
  png_uint_32 u0 ;
  png_uint_32 u1 ;
  png_bytep bytes ;
  size_t i ;
  png_uint_32 u ;
  png_bytep tmp ;

  {
#line 273
  u0 = *(seed + 0);
#line 273
  u1 = *(seed + 1);
#line 274
  bytes = (png_bytep )pv;
#line 280
  i = (size_t )0;
  {
#line 280
  while (1) {
    while_continue: /* CIL Label */ ;
#line 280
    if (! (i < size)) {
#line 280
      goto while_break;
    }
#line 283
    u = ((u0 >> 12) ^ ((u1 << 7) | (u0 >> 25))) & 255U;
#line 284
    u1 <<= 8;
#line 285
    u1 |= u0 >> 24;
#line 286
    u0 <<= 8;
#line 287
    u0 |= u;
#line 288
    tmp = bytes;
#line 288
    bytes ++;
#line 288
    *tmp = (png_byte )u;
#line 280
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 291
  *(seed + 0) = u0;
#line 292
  *(seed + 1) = u1;
#line 293
  return;
}
}
#line 295 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void make_four_random_bytes(png_uint_32 *seed , png_bytep bytes )
{


  {
#line 298
  make_random_bytes___0(seed, (void *)bytes, (size_t )4);
#line 299
  return;
}
}
#line 306
static void randomize(void *pv , size_t size ) ;
#line 306 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static png_uint_32 random_seed[2]  = {      (png_uint_32 )0x56789abc,      (png_uint_32 )0xd};
#line 303 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void randomize(void *pv , size_t size )
{


  {
#line 307
  make_random_bytes___0(random_seed, pv, size);
#line 308
  return;
}
}
#line 313 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static png_byte random_byte(void)
{
  unsigned char b1[1] ;

  {
#line 317
  randomize((void *)(b1), sizeof(b1));
#line 318
  return (b1[0]);
}
}
#line 322 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static png_uint_16 random_u16(void)
{
  unsigned char b2[2] ;

  {
#line 326
  randomize((void *)(b2), sizeof(b2));
#line 327
  return ((png_uint_16 )(((unsigned int )b2[0] << 8) + (unsigned int )*(b2 + 1)));
}
}
#line 332 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static png_uint_32 random_u32(void)
{
  unsigned char b4[4] ;

  {
#line 336
  randomize((void *)(b4), sizeof(b4));
#line 337
  return (((((png_uint_32 )b4[0] << 24) + ((png_uint_32 )*(b4 + 1) << 16)) + ((png_uint_32 )*(b4 + 2) << 8)) + (png_uint_32 )*(b4 + 3));
}
}
#line 345 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static unsigned int random_mod(unsigned int max )
{
  png_uint_16 tmp ;

  {
#line 348
  tmp = random_u16();
#line 348
  return ((unsigned int )tmp % max);
}
}
#line 354 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int random_choice(void)
{
  png_byte tmp ;

  {
#line 357
  tmp = random_byte();
#line 357
  return ((int )tmp & 1);
}
}
#line 380 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static size_t standard_name(char *buffer___0 , size_t bufsize , size_t pos , png_byte colour_type ,
                            int bit_depth , unsigned int npalette , int interlace_type ,
                            png_uint_32 w , png_uint_32 h , int do_interlace )
{


  {
#line 385
  pos = safecat(buffer___0, bufsize, pos, colour_types[colour_type]);
#line 386
  if ((int )colour_type == 3) {
#line 388
    pos = safecat(buffer___0, bufsize, pos, (char const   *)"[");
#line 389
    pos = safecatn(buffer___0, bufsize, pos, (int )npalette);
#line 390
    pos = safecat(buffer___0, bufsize, pos, (char const   *)"]");
  } else
#line 393
  if (npalette != 0U) {
#line 394
    pos = safecat(buffer___0, bufsize, pos, (char const   *)"+tRNS");
  }
#line 396
  pos = safecat(buffer___0, bufsize, pos, (char const   *)" ");
#line 397
  pos = safecatn(buffer___0, bufsize, pos, bit_depth);
#line 398
  pos = safecat(buffer___0, bufsize, pos, (char const   *)" bit");
#line 400
  if (interlace_type != 0) {
#line 402
    pos = safecat(buffer___0, bufsize, pos, (char const   *)" interlaced");
#line 403
    if (do_interlace) {
#line 404
      pos = safecat(buffer___0, bufsize, pos, (char const   *)"(pngvalid)");
    } else {
#line 406
      pos = safecat(buffer___0, bufsize, pos, (char const   *)"(libpng)");
    }
  }
#line 409
  if (w > 0U) {
#line 411
    pos = safecat(buffer___0, bufsize, pos, (char const   *)" ");
#line 412
    pos = safecatn(buffer___0, bufsize, pos, (int )w);
#line 413
    pos = safecat(buffer___0, bufsize, pos, (char const   *)"x");
#line 414
    pos = safecatn(buffer___0, bufsize, pos, (int )h);
  } else
#line 409
  if (h > 0U) {
#line 411
    pos = safecat(buffer___0, bufsize, pos, (char const   *)" ");
#line 412
    pos = safecatn(buffer___0, bufsize, pos, (int )w);
#line 413
    pos = safecat(buffer___0, bufsize, pos, (char const   *)"x");
#line 414
    pos = safecatn(buffer___0, bufsize, pos, (int )h);
  }
#line 417
  return (pos);
}
}
#line 420 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static size_t standard_name_from_id(char *buffer___0 , size_t bufsize , size_t pos ,
                                    png_uint_32 id )
{
  size_t tmp ;

  {
#line 423
  tmp = standard_name(buffer___0, bufsize, pos, (png_byte )(id & 0x7U), (int )((png_byte )((id >> 3) & 0x1fU)),
                      (id >> 8) & 31U, (int )((png_byte )((id >> 13) & 3U)), (id >> 16) & 255U,
                      (id >> 24) & 255U, (int )((id >> 15) & 1U));
#line 423
  return (tmp);
}
}
#line 450 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int next_format(png_bytep colour_type , png_bytep bit_depth , unsigned int *palette_number ,
                       int low_depth_gray , int tRNS )
{
  unsigned int pn ;
  png_byte ct ;
  unsigned int tmp ;

  {
#line 454
  if ((int )*bit_depth == 0) {
#line 456
    *colour_type = (png_byte )0;
#line 457
    if (low_depth_gray) {
#line 458
      *bit_depth = (png_byte )1;
    } else {
#line 460
      *bit_depth = (png_byte )8;
    }
#line 461
    *palette_number = 0U;
#line 462
    return (1);
  }
#line 465
  if ((int )*colour_type < 4) {
#line 470
    (*palette_number) ++;
#line 470
    pn = *palette_number;
#line 471
    ct = *colour_type;
#line 473
    if ((int )ct == 0) {
#line 473
      goto _L___1;
    } else
#line 473
    if ((int )ct == 2) {
      _L___1: /* CIL Label */
#line 473
      if (tRNS) {
#line 473
        if (pn < 2U) {
#line 475
          return (1);
        } else {
#line 473
          goto _L___0;
        }
      } else {
#line 473
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */
    _L: /* CIL Label */
#line 473
    if ((int )ct == 3) {
#line 473
      if ((int )*bit_depth > 4) {
#line 473
        tmp = 1U;
      } else {
#line 473
        tmp = 16U;
      }
#line 473
      if (pn < tmp) {
#line 475
        return (1);
      }
    }
#line 478
    *palette_number = 0U;
  }
#line 481
  *bit_depth = (png_byte )((int )*bit_depth << 1);
#line 484
  if ((int )*bit_depth <= 8) {
#line 489
    return (1);
  } else
#line 484
  if ((int )*colour_type != 3) {
#line 484
    if ((int )*bit_depth <= 16) {
#line 489
      return (1);
    }
  }
  {
#line 494
  if ((int )*colour_type == 0) {
#line 494
    goto case_0;
  }
#line 499
  if ((int )*colour_type == 2) {
#line 499
    goto case_2;
  }
#line 504
  if ((int )*colour_type == 3) {
#line 504
    goto case_3;
  }
#line 509
  if ((int )*colour_type == 4) {
#line 509
    goto case_4;
  }
#line 514
  goto switch_default;
  case_0: /* CIL Label */
#line 495
  *colour_type = (png_byte )2;
#line 496
  *bit_depth = (png_byte )8;
#line 497
  return (1);
  case_2: /* CIL Label */
#line 500
  *colour_type = (png_byte )3;
#line 501
  *bit_depth = (png_byte )1;
#line 502
  return (1);
  case_3: /* CIL Label */
#line 505
  *colour_type = (png_byte )4;
#line 506
  *bit_depth = (png_byte )8;
#line 507
  return (1);
  case_4: /* CIL Label */
#line 510
  *colour_type = (png_byte )6;
#line 511
  *bit_depth = (png_byte )8;
#line 512
  return (1);
  switch_default: /* CIL Label */
#line 515
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 520 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static unsigned int sample(png_const_bytep row , png_byte colour_type , png_byte bit_depth ,
                           png_uint_32 x , unsigned int sample_index , int swap16 ,
                           int littleendian )
{
  png_uint_32 bit_index ;
  png_uint_32 result ;

  {
#line 527
  x *= (png_uint_32 )bit_depth;
#line 528
  bit_index = x;
#line 530
  if (((int )colour_type & 1) == 0) {
#line 532
    if ((int )colour_type & 2) {
#line 533
      bit_index *= 3U;
    }
#line 535
    if ((int )colour_type & 4) {
#line 536
      bit_index += x;
    }
#line 539
    if ((int )colour_type & 6) {
#line 540
      bit_index += sample_index * (unsigned int )bit_depth;
    }
  }
#line 544
  row += bit_index >> 3;
#line 545
  result = (png_uint_32 )*row;
#line 547
  if ((int )bit_depth == 8) {
#line 548
    return (result);
  } else
#line 550
  if ((int )bit_depth > 8) {
#line 552
    if (swap16) {
#line 553
      row ++;
#line 553
      return ((png_uint_32 )((int const   )*row << 8) + result);
    } else {
#line 555
      row ++;
#line 555
      return ((result << 8) + (png_uint_32 )*row);
    }
  }
#line 562
  bit_index &= 7U;
#line 564
  if (! littleendian) {
#line 565
    bit_index = (8U - bit_index) - (png_uint_32 )bit_depth;
  }
#line 567
  return ((result >> bit_index) & ((1U << (int )bit_depth) - 1U));
}
}
#line 579 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void pixel_copy(png_bytep toBuffer , png_uint_32 toIndex , png_const_bytep fromBuffer ,
                       png_uint_32 fromIndex , unsigned int pixelSize , int littleendian )
{
  unsigned int destMask ;
  unsigned int tmp ;
  unsigned int destByte ;
  unsigned int sourceByte ;

  {
#line 587
  toIndex *= pixelSize;
#line 588
  fromIndex *= pixelSize;
#line 589
  if (pixelSize < 8U) {
#line 592
    if (littleendian) {
#line 592
      tmp = toIndex & 7U;
    } else {
#line 592
      tmp = (8U - pixelSize) - (toIndex & 7U);
    }
#line 592
    destMask = ((1U << pixelSize) - 1U) << tmp;
#line 595
    destByte = (unsigned int )*(toBuffer + (toIndex >> 3)) & ~ destMask;
#line 596
    sourceByte = (unsigned int )*(fromBuffer + (fromIndex >> 3));
#line 599
    fromIndex &= 7U;
#line 600
    if (littleendian) {
#line 602
      if (fromIndex > 0U) {
#line 602
        sourceByte >>= fromIndex;
      }
#line 603
      if ((toIndex & 7U) > 0U) {
#line 603
        sourceByte <<= toIndex & 7U;
      }
    } else {
#line 608
      if (fromIndex > 0U) {
#line 608
        sourceByte <<= fromIndex;
      }
#line 609
      if ((toIndex & 7U) > 0U) {
#line 609
        sourceByte >>= toIndex & 7U;
      }
    }
#line 612
    *(toBuffer + (toIndex >> 3)) = (png_byte )(destByte | (sourceByte & destMask));
  } else {
#line 615
    memmove((void *)(toBuffer + (toIndex >> 3)), (void const   *)(fromBuffer + (fromIndex >> 3)),
            (size_t )(pixelSize >> 3));
  }
#line 616
  return;
}
}
#line 622 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void row_copy(png_bytep toBuffer , png_const_bytep fromBuffer , unsigned int bitWidth ,
                     int littleendian )
{
  unsigned int mask ;

  {
#line 626
  memcpy((void *)toBuffer, (void const   *)fromBuffer, (size_t )(bitWidth >> 3));
#line 628
  if ((bitWidth & 7U) != 0U) {
#line 632
    toBuffer += bitWidth >> 3;
#line 633
    fromBuffer += bitWidth >> 3;
#line 634
    if (littleendian) {
#line 635
      mask = (unsigned int )(0xff << (bitWidth & 7U));
    } else {
#line 637
      mask = (unsigned int )(0xff >> (bitWidth & 7U));
    }
#line 638
    *toBuffer = (png_byte )(((unsigned int )*toBuffer & mask) | ((unsigned int )*fromBuffer & ~ mask));
  }
#line 640
  return;
}
}
#line 645 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int pixel_cmp(png_const_bytep pa , png_const_bytep pb , png_uint_32 bit_width )
{
  int tmp ;
  png_uint_32 where ;

  {
#line 673
  tmp = memcmp((void const   *)pa, (void const   *)pb, (size_t )((bit_width + 7U) >> 3));
#line 673
  if (tmp == 0) {
#line 674
    return (0);
  }
#line 679
  where = (png_uint_32 )0;
  {
#line 681
  while (1) {
    while_continue: /* CIL Label */ ;
#line 681
    if (! ((int const   )*(pa + where) == (int const   )*(pb + where))) {
#line 681
      goto while_break;
    }
#line 681
    where ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 682
  return ((int )(1U + where));
}
}
#line 808
static void store_pool_mark(png_bytep mark ) ;
#line 808 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static png_uint_32 store_seed[2]  = {      (png_uint_32 )0x12345678,      (png_uint_32 )1};
#line 805 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void store_pool_mark(png_bytep mark )
{


  {
#line 810
  make_four_random_bytes(store_seed, mark);
#line 811
  return;
}
}
#line 817 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static png_uint_32 random_32(void)
{
  png_byte mark[4] ;
  png_uint_32 result ;

  {
  {
#line 821
  while (1) {
    while_continue: /* CIL Label */ ;
#line 826
    store_pool_mark(mark);
#line 827
    result = ((((png_uint_32 )mark[0] << 24) + ((png_uint_32 )*(mark + 1) << 16)) + ((png_uint_32 )*(mark + 2) << 8)) + (png_uint_32 )*(mark + 3);
#line 829
    if (result != 0U) {
#line 830
      return (result);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 835 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void store_pool_init(png_store *ps , store_pool *pool )
{
  png_alloc_size_t tmp ;
  png_alloc_size_t tmp___0 ;
  png_alloc_size_t tmp___1 ;
  png_alloc_size_t tmp___2 ;
  png_alloc_size_t tmp___3 ;

  {
#line 838
  memset((void *)pool, 0, sizeof(*pool));
#line 840
  pool->store = ps;
#line 841
  pool->list = (struct store_memory *)((void *)0);
#line 842
  tmp___1 = (png_alloc_size_t )0;
#line 842
  pool->total = tmp___1;
#line 842
  tmp___0 = tmp___1;
#line 842
  pool->limit = tmp___0;
#line 842
  tmp = tmp___0;
#line 842
  pool->current = tmp;
#line 842
  pool->max = tmp;
#line 843
  tmp___3 = (png_alloc_size_t )0;
#line 843
  pool->max_total = tmp___3;
#line 843
  tmp___2 = tmp___3;
#line 843
  pool->max_limit = tmp___2;
#line 843
  pool->max_max = tmp___2;
#line 844
  store_pool_mark(pool->mark);
#line 845
  return;
}
}
#line 847 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void store_init(png_store *ps )
{
  int tmp ;
  png_store_file *tmp___0 ;

  {
#line 850
  memset((void *)ps, 0, sizeof(*ps));
#line 851
  ps->exception_context.penv = (jmp_buf *)0;
#line 852
  store_pool_init(ps, & ps->read_memory_pool);
#line 853
  store_pool_init(ps, & ps->write_memory_pool);
#line 854
  ps->verbose = 0U;
#line 855
  ps->treat_warnings_as_errors = 0U;
#line 856
  ps->expect_error = 0U;
#line 857
  ps->expect_warning = 0U;
#line 858
  ps->saw_warning = 0U;
#line 859
  ps->speed = 0U;
#line 860
  ps->progressive = 0U;
#line 861
  ps->validated = 0U;
#line 862
  tmp = 0;
#line 862
  ps->nwarnings = tmp;
#line 862
  ps->nerrors = tmp;
#line 863
  ps->pread = (png_structp )((void *)0);
#line 864
  ps->piread = (png_infop )((void *)0);
#line 865
  tmp___0 = (png_store_file *)((void *)0);
#line 865
  ps->current = tmp___0;
#line 865
  ps->saved = tmp___0;
#line 866
  ps->next = (png_store_buffer *)((void *)0);
#line 867
  ps->readpos = (size_t )0;
#line 868
  ps->image = (png_byte *)((void *)0);
#line 869
  ps->cb_image = (size_t )0;
#line 870
  ps->cb_row = (size_t )0;
#line 871
  ps->image_h = (png_uint_32 )0;
#line 872
  ps->pwrite = (png_structp )((void *)0);
#line 873
  ps->piwrite = (png_infop )((void *)0);
#line 874
  ps->writepos = (size_t )0;
#line 875
  ps->chunkpos = (png_uint_32 )8;
#line 876
  ps->chunktype = (png_uint_32 )0;
#line 877
  ps->chunklen = (png_uint_32 )16;
#line 878
  ps->IDAT_size = (png_uint_32 )0;
#line 879
  ps->IDAT_bits = 0U;
#line 880
  ps->new.prev = (struct png_store_buffer *)((void *)0);
#line 881
  ps->palette = (store_palette_entry *)((void *)0);
#line 882
  ps->npalette = 0;
#line 883
  ps->noptions = 0;
#line 884
  return;
}
}
#line 886 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void store_freebuffer(png_store_buffer *psb )
{


  {
#line 889
  if (psb->prev) {
#line 891
    store_freebuffer(psb->prev);
#line 892
    free((void *)psb->prev);
#line 893
    psb->prev = (struct png_store_buffer *)((void *)0);
  }
#line 895
  return;
}
}
#line 897 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void store_freenew(png_store *ps )
{


  {
#line 900
  store_freebuffer(& ps->new);
#line 901
  ps->writepos = (size_t )0;
#line 902
  ps->chunkpos = (png_uint_32 )8;
#line 903
  ps->chunktype = (png_uint_32 )0;
#line 904
  ps->chunklen = (png_uint_32 )16;
#line 905
  ps->IDAT_size = (png_uint_32 )0;
#line 906
  ps->IDAT_bits = 0U;
#line 907
  if ((unsigned long )ps->palette != (unsigned long )((void *)0)) {
#line 909
    free((void *)ps->palette);
#line 910
    ps->palette = (store_palette_entry *)((void *)0);
#line 911
    ps->npalette = 0;
  }
#line 913
  return;
}
}
#line 915 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void store_storenew(png_store *ps )
{
  png_store_buffer *pb ;
  void *tmp ;

  {
#line 920
  tmp = malloc(sizeof(*pb));
#line 920
  pb = (png_store_buffer *)tmp;
#line 922
  if ((unsigned long )pb == (unsigned long )((void *)0)) {
#line 923
    png_error((png_const_structrp )ps->pwrite, (png_const_charp )"store new: OOM");
  }
#line 925
  *pb = ps->new;
#line 926
  ps->new.prev = pb;
#line 927
  ps->writepos = (size_t )0;
#line 928
  return;
}
}
#line 930 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void store_freefile(png_store_file **ppf )
{


  {
#line 933
  if ((unsigned long )*ppf != (unsigned long )((void *)0)) {
#line 935
    store_freefile(& (*ppf)->next);
#line 937
    store_freebuffer(& (*ppf)->data);
#line 938
    (*ppf)->datacount = (size_t )0;
#line 939
    if ((unsigned long )(*ppf)->palette != (unsigned long )((void *)0)) {
#line 941
      free((void *)(*ppf)->palette);
#line 942
      (*ppf)->palette = (store_palette_entry *)((void *)0);
#line 943
      (*ppf)->npalette = 0;
    }
#line 945
    free((void *)*ppf);
#line 946
    *ppf = (png_store_file *)((void *)0);
  }
#line 948
  return;
}
}
#line 950 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static unsigned int bits_of(png_uint_32 num )
{
  unsigned int b ;

  {
#line 954
  b = 0U;
#line 956
  if (num & 0xffff0000U) {
#line 956
    b += 16U;
#line 956
    num >>= 16;
  }
#line 957
  if (num & 0xff00U) {
#line 957
    b += 8U;
#line 957
    num >>= 8;
  }
#line 958
  if (num & 0xf0U) {
#line 958
    b += 4U;
#line 958
    num >>= 4;
  }
#line 959
  if (num & 0xcU) {
#line 959
    b += 2U;
#line 959
    num >>= 2;
  }
#line 960
  if (num & 0x2U) {
#line 960
    b ++;
#line 960
    num >>= 1;
  }
#line 961
  if (num) {
#line 961
    b ++;
  }
#line 963
  return (b);
}
}
#line 969 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void store_storefile(png_store *ps , png_uint_32 id )
{
  png_store_file *pf ;
  void *tmp ;

  {
#line 974
  if (ps->chunkpos != 0U) {
#line 976
    png_error((png_const_structrp )ps->pwrite, (png_const_charp )"storefile: incomplete write");
  } else
#line 974
  if (ps->chunktype != 0U) {
#line 976
    png_error((png_const_structrp )ps->pwrite, (png_const_charp )"storefile: incomplete write");
  } else
#line 974
  if (ps->chunklen != 0U) {
#line 976
    png_error((png_const_structrp )ps->pwrite, (png_const_charp )"storefile: incomplete write");
  } else
#line 974
  if (ps->IDAT_size == 0U) {
#line 976
    png_error((png_const_structrp )ps->pwrite, (png_const_charp )"storefile: incomplete write");
  }
#line 978
  tmp = malloc(sizeof(*pf));
#line 978
  pf = (png_store_file *)tmp;
#line 979
  if ((unsigned long )pf == (unsigned long )((void *)0)) {
#line 980
    png_error((png_const_structrp )ps->pwrite, (png_const_charp )"storefile: OOM");
  }
#line 981
  safecat(pf->name, sizeof(pf->name), (size_t )0, (char const   *)(ps->wname));
#line 982
  pf->id = id;
#line 983
  pf->data = ps->new;
#line 984
  pf->datacount = ps->writepos;
#line 985
  pf->IDAT_size = ps->IDAT_size;
#line 986
  pf->IDAT_bits = bits_of(ps->IDAT_size);
#line 988
  if (pf->IDAT_bits == 0U) {
#line 989
    png_error((png_const_structrp )ps->pwrite, (png_const_charp )"storefile: 0 sized IDAT");
  }
#line 990
  ps->new.prev = (struct png_store_buffer *)((void *)0);
#line 991
  ps->writepos = (size_t )0;
#line 992
  ps->chunkpos = (png_uint_32 )8;
#line 993
  ps->chunktype = (png_uint_32 )0;
#line 994
  ps->chunklen = (png_uint_32 )16;
#line 995
  ps->IDAT_size = (png_uint_32 )0;
#line 996
  pf->palette = ps->palette;
#line 997
  pf->npalette = ps->npalette;
#line 998
  ps->palette = (store_palette_entry *)0;
#line 999
  ps->npalette = 0;
#line 1002
  pf->next = ps->saved;
#line 1003
  ps->saved = pf;
#line 1004
  return;
}
}
#line 1007 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static size_t store_message(png_store *ps , png_const_structp pp , char *buffer___0 ,
                            size_t bufsize , size_t pos , char const   *msg )
{


  {
#line 1011
  if ((unsigned long )pp != (unsigned long )((void *)0)) {
#line 1011
    if ((unsigned long )pp == (unsigned long )ps->pread) {
#line 1014
      pos = safecat(buffer___0, bufsize, pos, (char const   *)"read: ");
#line 1016
      if ((unsigned long )ps->current != (unsigned long )((void *)0)) {
#line 1018
        pos = safecat(buffer___0, bufsize, pos, (char const   *)((ps->current)->name));
#line 1019
        pos = safecat(buffer___0, bufsize, pos, sep);
      }
    } else {
#line 1011
      goto _L;
    }
  } else
  _L: /* CIL Label */
#line 1023
  if ((unsigned long )pp != (unsigned long )((void *)0)) {
#line 1023
    if ((unsigned long )pp == (unsigned long )ps->pwrite) {
#line 1026
      pos = safecat(buffer___0, bufsize, pos, (char const   *)"write: ");
#line 1027
      pos = safecat(buffer___0, bufsize, pos, (char const   *)(ps->wname));
#line 1028
      pos = safecat(buffer___0, bufsize, pos, sep);
    } else {
#line 1034
      pos = safecat(buffer___0, bufsize, pos, (char const   *)"pngvalid: ");
    }
  } else {
#line 1034
    pos = safecat(buffer___0, bufsize, pos, (char const   *)"pngvalid: ");
  }
#line 1037
  if ((int )ps->test[0] != 0) {
#line 1039
    pos = safecat(buffer___0, bufsize, pos, (char const   *)(ps->test));
#line 1040
    pos = safecat(buffer___0, bufsize, pos, sep);
  }
#line 1042
  pos = safecat(buffer___0, bufsize, pos, msg);
#line 1043
  return (pos);
}
}
#line 1047 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void store_verbose(png_store *ps , png_const_structp pp , png_const_charp prefix ,
                          png_const_charp message )
{
  char buffer___0[512] ;

  {
#line 1053
  if (prefix) {
#line 1054
    fputs((char const   * __restrict  )prefix, (FILE * __restrict  )stderr);
  }
#line 1056
  store_message(ps, pp, buffer___0, sizeof(buffer___0), (size_t )0, message);
#line 1057
  fputs((char const   * __restrict  )(buffer___0), (FILE * __restrict  )stderr);
#line 1058
  fputc('\n', stderr);
#line 1059
  return;
}
}
#line 1062 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void store_log(png_store *ps , png_const_structp pp , png_const_charp message ,
                      int is_error )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 1070
  if (is_error) {
#line 1070
    tmp = ps->nerrors;
#line 1070
    (ps->nerrors) ++;
#line 1070
    tmp___2 = tmp == 0;
  } else {
#line 1070
    tmp___0 = ps->nwarnings;
#line 1070
    (ps->nwarnings) ++;
#line 1070
    if (tmp___0 == 0) {
#line 1070
      if (ps->nerrors == 0) {
#line 1070
        tmp___1 = 1;
      } else {
#line 1070
        tmp___1 = 0;
      }
    } else {
#line 1070
      tmp___1 = 0;
    }
#line 1070
    tmp___2 = tmp___1;
  }
#line 1070
  if (tmp___2) {
#line 1072
    store_message(ps, pp, ps->error, sizeof(ps->error), (size_t )0, message);
  }
#line 1074
  if (ps->verbose) {
#line 1075
    if (is_error) {
#line 1075
      tmp___3 = "error: ";
    } else {
#line 1075
      tmp___3 = "warning: ";
    }
#line 1075
    store_verbose(ps, pp, (png_const_charp )tmp___3, message);
  }
#line 1076
  return;
}
}
#line 1080 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void internal_error(png_store *ps , png_const_charp message )
{
  struct exception_context *the_exception_context ;

  {
#line 1083
  store_log(ps, (png_const_structp )((void *)0), message, 1);
#line 1087
  the_exception_context = & ps->exception_context;
  {
#line 1088
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1088
    the_exception_context->v.etmp = (struct png_store * volatile  )ps;
#line 1088
    longjmp((struct __jmp_buf_tag *)(*(the_exception_context->penv)), 1);
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1094 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void store_error(png_structp ppIn , png_const_charp message )
{
  png_const_structp pp ;
  png_store *ps ;
  png_voidp tmp ;
  struct exception_context *the_exception_context ;

  {
#line 1097
  pp = (png_const_structp )ppIn;
#line 1098
  tmp = png_get_error_ptr((png_const_structrp )pp);
#line 1098
  ps = (png_store *)tmp;
#line 1100
  if (! ps->expect_error) {
#line 1101
    store_log(ps, pp, message, 1);
  }
#line 1105
  the_exception_context = & ps->exception_context;
  {
#line 1106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1106
    the_exception_context->v.etmp = (struct png_store * volatile  )ps;
#line 1106
    longjmp((struct __jmp_buf_tag *)(*(the_exception_context->penv)), 1);
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1110 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void store_warning(png_structp ppIn , png_const_charp message )
{
  png_const_structp pp ;
  png_store *ps ;
  png_voidp tmp ;

  {
#line 1113
  pp = (png_const_structp )ppIn;
#line 1114
  tmp = png_get_error_ptr((png_const_structrp )pp);
#line 1114
  ps = (png_store *)tmp;
#line 1116
  if (! ps->expect_warning) {
#line 1117
    store_log(ps, pp, message, 0);
  } else {
#line 1119
    ps->saw_warning = 1U;
  }
#line 1120
  return;
}
}
#line 1126 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static png_bytep store_image_row(png_store const   *ps , png_const_structp pp , int nImage ,
                                 png_uint_32 y )
{
  size_t coffset ;

  {
#line 1130
  coffset = (size_t )((size_t )((png_uint_32 )nImage * ps->image_h + (png_uint_32 )y) * (ps->cb_row + 5UL) + 2UL);
#line 1132
  if ((unsigned long )ps->image == (unsigned long )((void *)0)) {
#line 1133
    png_error((png_const_structrp )pp, (png_const_charp )"no allocated image");
  }
#line 1135
  if ((coffset + (size_t )ps->cb_row) + 3UL > (size_t )ps->cb_image) {
#line 1136
    png_error((png_const_structrp )pp, (png_const_charp )"image too small");
  }
#line 1138
  return ((png_bytep )(ps->image + coffset));
}
}
#line 1141 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void store_image_free(png_store *ps , png_const_structp pp )
{
  png_bytep image ;

  {
#line 1144
  if ((unsigned long )ps->image != (unsigned long )((void *)0)) {
#line 1146
    image = ps->image;
#line 1148
    if ((int )*(image + -1) != 0xed) {
#line 1148
      goto _L;
    } else
#line 1148
    if ((int )*(image + ps->cb_image) != 0xfe) {
      _L: /* CIL Label */
#line 1150
      if ((unsigned long )pp != (unsigned long )((void *)0)) {
#line 1151
        png_error((png_const_structrp )pp, (png_const_charp )"png_store image overwrite (1)");
      } else {
#line 1153
        store_log(ps, (png_const_structp )((void *)0), (png_const_charp )"png_store image overwrite (2)",
                  1);
      }
    }
#line 1156
    ps->image = (png_byte *)((void *)0);
#line 1157
    ps->cb_image = (size_t )0;
#line 1158
    image --;
#line 1159
    free((void *)image);
  }
#line 1161
  return;
}
}
#line 1163 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void store_ensure_image(png_store *ps , png_const_structp pp , int nImages ,
                               size_t cbRow , png_uint_32 cRows )
{
  size_t cb ;
  png_bytep image ;
  void *tmp ;
  png_uint_32 y ;
  png_bytep row ;
  png_bytep tmp___0 ;

  {
#line 1167
  cb = (size_t )((png_uint_32 )nImages * cRows) * (cbRow + 5UL);
#line 1169
  if (ps->cb_image < cb) {
#line 1173
    store_image_free(ps, pp);
#line 1176
    tmp = malloc(cb + 2UL);
#line 1176
    image = (png_bytep )tmp;
#line 1177
    if ((unsigned long )image == (unsigned long )((void *)0)) {
#line 1180
      if ((unsigned long )pp == (unsigned long )((void *)0)) {
#line 1181
        return;
      }
#line 1183
      png_error((png_const_structrp )pp, (png_const_charp )"OOM allocating image buffer");
    }
#line 1187
    image ++;
#line 1188
    *(image + -1) = (png_byte )0xed;
#line 1189
    *(image + cb) = (png_byte )0xfe;
#line 1191
    ps->image = image;
#line 1192
    ps->cb_image = cb;
  }
#line 1199
  ps->cb_row = cbRow;
#line 1200
  ps->image_h = cRows;
#line 1208
  memset((void *)ps->image, 178, cb);
  {
#line 1211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1211
    nImages --;
#line 1211
    if (! (nImages >= 0)) {
#line 1211
      goto while_break;
    }
#line 1215
    y = (png_uint_32 )0;
    {
#line 1215
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1215
      if (! (y < cRows)) {
#line 1215
        goto while_break___0;
      }
#line 1217
      tmp___0 = store_image_row((png_store const   *)ps, pp, nImages, y);
#line 1217
      row = tmp___0;
#line 1220
      *(row + -2) = (png_byte )190;
#line 1221
      *(row + -1) = (png_byte )239;
#line 1222
      *(row + cbRow) = (png_byte )222;
#line 1223
      *(row + (cbRow + 1UL)) = (png_byte )173;
#line 1224
      *(row + (cbRow + 2UL)) = (png_byte )17;
#line 1215
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1227
  return;
}
}
#line 1230 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void store_image_check(png_store const   *ps , png_const_structp pp , int iImage )
{
  png_const_bytep image ;
  size_t cbRow ;
  png_uint_32 rows ;

  {
#line 1233
  image = (png_const_bytep )ps->image;
#line 1235
  if ((int const   )*(image + -1) != 237) {
#line 1236
    png_error((png_const_structrp )pp, (png_const_charp )"image overwrite");
  } else
#line 1235
  if ((int const   )*(image + ps->cb_image) != 254) {
#line 1236
    png_error((png_const_structrp )pp, (png_const_charp )"image overwrite");
  } else {
#line 1239
    cbRow = (size_t )ps->cb_row;
#line 1240
    rows = (png_uint_32 )ps->image_h;
#line 1242
    image += ((size_t )iImage * (cbRow + 5UL)) * (size_t )ps->image_h;
#line 1244
    image += 2;
    {
#line 1246
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1246
      if (! (rows > 0U)) {
#line 1246
        goto while_break;
      }
#line 1248
      if ((int const   )*(image + -2) != 190) {
#line 1249
        png_error((png_const_structrp )pp, (png_const_charp )"row start overwritten");
      } else
#line 1248
      if ((int const   )*(image + -1) != 239) {
#line 1249
        png_error((png_const_structrp )pp, (png_const_charp )"row start overwritten");
      }
#line 1251
      if ((int const   )*(image + cbRow) != 222) {
#line 1253
        png_error((png_const_structrp )pp, (png_const_charp )"row end overwritten");
      } else
#line 1251
      if ((int const   )*(image + (cbRow + 1UL)) != 173) {
#line 1253
        png_error((png_const_structrp )pp, (png_const_charp )"row end overwritten");
      } else
#line 1251
      if ((int const   )*(image + (cbRow + 2UL)) != 17) {
#line 1253
        png_error((png_const_structrp )pp, (png_const_charp )"row end overwritten");
      }
#line 1255
      image += cbRow + 5UL;
#line 1246
      rows --;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1258
  return;
}
}
#line 1261 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int valid_chunktype(png_uint_32 chunktype )
{
  unsigned int i ;
  unsigned int c ;

  {
#line 1269
  i = 0U;
  {
#line 1269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1269
    if (! (i < 4U)) {
#line 1269
      goto while_break;
    }
#line 1271
    c = chunktype & 0xffU;
#line 1273
    if (c >= 65U) {
#line 1273
      if (! (c <= 90U)) {
#line 1273
        goto _L;
      }
    } else
    _L: /* CIL Label */
#line 1273
    if (c >= 97U) {
#line 1273
      if (! (c <= 122U)) {
#line 1274
        return (0);
      }
    } else {
#line 1274
      return (0);
    }
#line 1276
    chunktype >>= 8;
#line 1269
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1279
  return (1);
}
}
#line 1282 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void store_write(png_structp ppIn , png_bytep pb , size_t st )
{
  png_const_structp pp ;
  png_store *ps ;
  png_voidp tmp ;
  size_t writepos ;
  png_uint_32 chunkpos ;
  png_uint_32 chunktype ;
  png_uint_32 chunklen ;
  png_byte b ;
  png_bytep tmp___0 ;
  size_t tmp___1 ;
  png_byte b___0 ;
  png_bytep tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t cb ;

  {
#line 1285
  pp = (png_const_structp )ppIn;
#line 1286
  tmp = png_get_io_ptr((png_const_structrp )pp);
#line 1286
  ps = (png_store *)tmp;
#line 1287
  writepos = ps->writepos;
#line 1288
  chunkpos = ps->chunkpos;
#line 1289
  chunktype = ps->chunktype;
#line 1290
  chunklen = ps->chunklen;
#line 1292
  if ((unsigned long )ps->pwrite != (unsigned long )pp) {
#line 1293
    png_error((png_const_structrp )pp, (png_const_charp )"store state damaged");
  }
#line 1299
  if (st > 2147483647UL) {
#line 1300
    png_error((png_const_structrp )pp, (png_const_charp )"unexpected write size");
  }
  {
#line 1306
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1306
    if (! (st > 0UL)) {
#line 1306
      goto while_break;
    }
#line 1308
    if (writepos >= 500UL) {
#line 1309
      store_storenew(ps);
#line 1309
      writepos = (size_t )0;
    }
#line 1311
    if (chunkpos < 4U) {
#line 1313
      tmp___0 = pb;
#line 1313
      pb ++;
#line 1313
      b = *tmp___0;
#line 1314
      st --;
#line 1315
      chunklen = (chunklen << 8) + (png_uint_32 )b;
#line 1316
      tmp___1 = writepos;
#line 1316
      writepos ++;
#line 1316
      ps->new.buffer[tmp___1] = b;
#line 1317
      chunkpos ++;
    } else
#line 1320
    if (chunkpos < 8U) {
#line 1322
      tmp___2 = pb;
#line 1322
      pb ++;
#line 1322
      b___0 = *tmp___2;
#line 1323
      st --;
#line 1324
      chunktype = (chunktype << 8) + (png_uint_32 )b___0;
#line 1325
      tmp___3 = writepos;
#line 1325
      writepos ++;
#line 1325
      ps->new.buffer[tmp___3] = b___0;
#line 1327
      chunkpos ++;
#line 1327
      if (chunkpos == 8U) {
#line 1329
        chunklen &= 0xffffffffU;
#line 1330
        if (chunklen > 0x7fffffffU) {
#line 1331
          png_error((png_const_structrp )pp, (png_const_charp )"chunk length too great");
        }
#line 1333
        chunktype &= 0xffffffffU;
#line 1334
        if (chunktype == (png_uint_32 )((((73 << 24) + (68 << 16)) + (65 << 8)) + 84)) {
#line 1336
          if (chunklen > ~ ps->IDAT_size) {
#line 1337
            png_error((png_const_structrp )pp, (png_const_charp )"pngvalid internal image too large");
          }
#line 1339
          ps->IDAT_size += chunklen;
        } else {
#line 1342
          tmp___4 = valid_chunktype(chunktype);
#line 1342
          if (! tmp___4) {
#line 1343
            png_error((png_const_structrp )pp, (png_const_charp )"invalid chunk type");
          }
        }
#line 1345
        chunklen += 12U;
      }
    } else {
#line 1351
      cb = st;
#line 1353
      if (cb > 500UL - writepos) {
#line 1354
        cb = 500UL - writepos;
      }
#line 1356
      if (cb > (size_t )(chunklen - chunkpos)) {
#line 1357
        cb = (size_t )(chunklen - chunkpos);
      }
#line 1359
      memcpy((void *)(ps->new.buffer + writepos), (void const   *)pb, cb);
#line 1360
      chunkpos += (png_uint_32 )cb;
#line 1361
      pb += cb;
#line 1362
      writepos += cb;
#line 1363
      st -= cb;
#line 1365
      if (chunkpos >= chunklen) {
#line 1366
        chunklen = (png_uint_32 )0;
#line 1366
        chunktype = chunklen;
#line 1366
        chunkpos = chunktype;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1370
  ps->writepos = writepos;
#line 1371
  ps->chunkpos = chunkpos;
#line 1372
  ps->chunktype = chunktype;
#line 1373
  ps->chunklen = chunklen;
#line 1374
  return;
}
}
#line 1376 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void store_flush(png_structp ppIn )
{


  {
#line 1380
  return;
}
}
#line 1383 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static size_t store_read_buffer_size(png_store *ps )
{


  {
#line 1387
  if ((unsigned long )ps->next != (unsigned long )(& (ps->current)->data)) {
#line 1388
    return ((size_t )500);
  }
#line 1390
  return ((ps->current)->datacount);
}
}
#line 1394 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static size_t store_read_buffer_avail(png_store *ps )
{
  png_store_buffer *next ;
  size_t cbAvail ;

  {
#line 1397
  if ((unsigned long )ps->current != (unsigned long )((void *)0)) {
#line 1397
    if ((unsigned long )ps->next != (unsigned long )((void *)0)) {
#line 1399
      next = & (ps->current)->data;
#line 1400
      cbAvail = (ps->current)->datacount;
      {
#line 1402
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1402
        if ((unsigned long )next != (unsigned long )ps->next) {
#line 1402
          if (! ((unsigned long )next != (unsigned long )((void *)0))) {
#line 1402
            goto while_break;
          }
        } else {
#line 1402
          goto while_break;
        }
#line 1404
        next = next->prev;
#line 1405
        cbAvail += 500UL;
      }
      while_break: /* CIL Label */ ;
      }
#line 1408
      if ((unsigned long )next != (unsigned long )ps->next) {
#line 1409
        png_error((png_const_structrp )ps->pread, (png_const_charp )"buffer read error");
      }
#line 1411
      if (cbAvail > ps->readpos) {
#line 1412
        return (cbAvail - ps->readpos);
      }
    }
  }
#line 1415
  return ((size_t )0);
}
}
#line 1418 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int store_read_buffer_next(png_store *ps )
{
  png_store_buffer *pbOld ;
  png_store_buffer *pbNew ;

  {
#line 1421
  pbOld = ps->next;
#line 1422
  pbNew = & (ps->current)->data;
#line 1423
  if ((unsigned long )pbOld != (unsigned long )pbNew) {
    {
#line 1425
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1425
      if ((unsigned long )pbNew != (unsigned long )((void *)0)) {
#line 1425
        if (! ((unsigned long )pbNew->prev != (unsigned long )pbOld)) {
#line 1425
          goto while_break;
        }
      } else {
#line 1425
        goto while_break;
      }
#line 1426
      pbNew = pbNew->prev;
    }
    while_break: /* CIL Label */ ;
    }
#line 1428
    if ((unsigned long )pbNew != (unsigned long )((void *)0)) {
#line 1430
      ps->next = pbNew;
#line 1431
      ps->readpos = (size_t )0;
#line 1432
      return (1);
    }
#line 1435
    png_error((png_const_structrp )ps->pread, (png_const_charp )"buffer lost");
  }
#line 1438
  return (0);
}
}
#line 1444 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void store_read_imp(png_store *ps , png_bytep pb , size_t st )
{
  size_t cbAvail ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 1447
  if ((unsigned long )ps->current == (unsigned long )((void *)0)) {
#line 1448
    png_error((png_const_structrp )ps->pread, (png_const_charp )"store state damaged");
  } else
#line 1447
  if ((unsigned long )ps->next == (unsigned long )((void *)0)) {
#line 1448
    png_error((png_const_structrp )ps->pread, (png_const_charp )"store state damaged");
  }
  {
#line 1450
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1450
    if (! (st > 0UL)) {
#line 1450
      goto while_break;
    }
#line 1452
    tmp = store_read_buffer_size(ps);
#line 1452
    cbAvail = tmp - ps->readpos;
#line 1454
    if (cbAvail > 0UL) {
#line 1456
      if (cbAvail > st) {
#line 1456
        cbAvail = st;
      }
#line 1457
      memcpy((void *)pb, (void const   *)((ps->next)->buffer + ps->readpos), cbAvail);
#line 1458
      st -= cbAvail;
#line 1459
      pb += cbAvail;
#line 1460
      ps->readpos += cbAvail;
    } else {
#line 1463
      tmp___0 = store_read_buffer_next(ps);
#line 1463
      if (! tmp___0) {
#line 1464
        png_error((png_const_structrp )ps->pread, (png_const_charp )"read beyond end of file");
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1466
  return;
}
}
#line 1468 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static size_t store_read_chunk(png_store *ps , png_bytep pb , size_t max , size_t min )
{
  png_uint_32 chunklen ;
  png_uint_32 chunktype ;
  png_uint_32 chunkpos ;
  size_t st ;
  png_byte buffer___0[8] ;
  png_uint_32 IDAT_pos ;
  png_uint_32 IDAT_len ;
  png_uint_32 IDAT_size ;
  png_byte random___0 ;
  png_byte tmp ;
  png_byte buffer___1[4] ;
  png_uint_32 b ;
  unsigned int shift ;
  png_bytep tmp___0 ;
  uInt avail ;
  png_byte buffer___2[4] ;
  uLong b___0 ;
  unsigned int shift___0 ;
  png_bytep tmp___1 ;
  png_uint_32 b___1 ;
  unsigned int shift___1 ;
  png_bytep tmp___2 ;
  size_t avail___0 ;
  size_t tmp___3 ;

  {
#line 1471
  chunklen = ps->chunklen;
#line 1472
  chunktype = ps->chunktype;
#line 1473
  chunkpos = ps->chunkpos;
#line 1474
  st = max;
#line 1476
  if (st > 0UL) {
    {
#line 1476
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1478
      if (chunkpos >= chunklen) {
#line 1483
        store_read_imp(ps, buffer___0, (size_t )8U);
#line 1484
        chunklen = (((((png_uint_32 )buffer___0[0] << 24) + ((png_uint_32 )*(buffer___0 + 1) << 16)) + ((png_uint_32 )*(buffer___0 + 2) << 8)) + (png_uint_32 )*(buffer___0 + 3)) + 12U;
#line 1485
        chunktype = ((((png_uint_32 )*(buffer___0 + 4U) << 24) + ((png_uint_32 )*((buffer___0 + 4U) + 1) << 16)) + ((png_uint_32 )*((buffer___0 + 4U) + 2) << 8)) + (png_uint_32 )*((buffer___0 + 4U) + 3);
#line 1486
        chunkpos = 0U;
      }
#line 1489
      if (chunktype == (png_uint_32 )((((73 << 24) + (68 << 16)) + (65 << 8)) + 84)) {
#line 1491
        IDAT_pos = ps->IDAT_pos;
#line 1492
        IDAT_len = ps->IDAT_len;
#line 1493
        IDAT_size = ps->IDAT_size;
#line 1496
        if (chunkpos < 8U) {
#line 1497
          chunkpos = 8U;
        }
#line 1499
        if (IDAT_pos == IDAT_len) {
#line 1501
          tmp = random_byte();
#line 1501
          random___0 = tmp;
#line 1508
          if (IDAT_len == 0U) {
            {
#line 1512
            if (((unsigned int )random___0 & 3U) == 0U) {
#line 1512
              goto case_0;
            }
#line 1513
            if (((unsigned int )random___0 & 3U) == 1U) {
#line 1513
              goto case_1;
            }
#line 1514
            goto switch_default;
            case_0: /* CIL Label */
#line 1512
            IDAT_len = 12U;
#line 1512
            goto switch_break;
            case_1: /* CIL Label */
#line 1513
            IDAT_len = 13U;
#line 1513
            goto switch_break;
            switch_default: /* CIL Label */
#line 1514
            IDAT_len = random_u32();
#line 1515
            IDAT_len %= IDAT_size;
#line 1516
            IDAT_len += 13U;
#line 1517
            goto switch_break;
            switch_break: /* CIL Label */ ;
            }
          } else
#line 1521
          if (IDAT_size == 0U) {
#line 1524
            if (chunkpos != chunklen - 4U) {
#line 1525
              png_error((png_const_structrp )ps->pread, (png_const_charp )"internal: IDAT size mismatch");
            }
#line 1532
            if (((unsigned int )random___0 & 3U) == 0U) {
#line 1533
              IDAT_len = 12U;
            } else {
#line 1542
              store_read_imp(ps, buffer___1, (size_t )4U);
#line 1543
              chunkpos += 4U;
#line 1544
              ps->IDAT_pos = IDAT_pos;
#line 1545
              ps->IDAT_len = IDAT_len;
#line 1546
              ps->IDAT_size = 0U;
#line 1547
              goto __Cont;
            }
          } else {
#line 1556
            IDAT_len = random_u32();
#line 1557
            IDAT_len &= (1U << (1U + (unsigned int )random___0 % ps->IDAT_bits)) - 1U;
#line 1558
            if (IDAT_len > IDAT_size) {
#line 1559
              IDAT_len = IDAT_size;
            }
#line 1560
            IDAT_len += 12U;
          }
#line 1563
          IDAT_pos = 0U;
#line 1564
          ps->IDAT_crc = (uLong )0x35af061e;
        }
#line 1567
        if (IDAT_pos < 8U) {
          {
#line 1567
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1572
            if (IDAT_pos < 4U) {
#line 1573
              b = IDAT_len - 12U;
            } else {
#line 1576
              b = (png_uint_32 )((((73 << 24) + (68 << 16)) + (65 << 8)) + 84);
            }
#line 1578
            shift = 3U & IDAT_pos;
#line 1579
            IDAT_pos ++;
#line 1581
            if (shift < 3U) {
#line 1582
              b >>= 8U * (3U - shift);
            }
#line 1584
            tmp___0 = pb;
#line 1584
            pb ++;
#line 1584
            *tmp___0 = (png_byte )(0xffU & b);
#line 1567
            st --;
#line 1567
            if (st > 0UL) {
#line 1567
              if (! (IDAT_pos < 8U)) {
#line 1567
                goto while_break___0;
              }
            } else {
#line 1567
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        } else
#line 1588
        if (IDAT_pos < IDAT_len - 4U) {
#line 1590
          if (chunkpos < chunklen - 4U) {
#line 1592
            avail = (uInt )-1;
#line 1594
            if (avail > (IDAT_len - 4U) - IDAT_pos) {
#line 1595
              avail = (IDAT_len - 4U) - IDAT_pos;
            }
#line 1597
            if ((size_t )avail > st) {
#line 1598
              avail = (uInt )st;
            }
#line 1600
            if (avail > (chunklen - 4U) - chunkpos) {
#line 1601
              avail = (chunklen - 4U) - chunkpos;
            }
#line 1603
            store_read_imp(ps, pb, (size_t )avail);
#line 1604
            ps->IDAT_crc = crc32(ps->IDAT_crc, (Bytef const   *)pb, avail);
#line 1605
            pb += (size_t )avail;
#line 1606
            st -= (size_t )avail;
#line 1607
            chunkpos += avail;
#line 1608
            IDAT_size -= avail;
#line 1609
            IDAT_pos += avail;
          } else {
#line 1616
            store_read_imp(ps, buffer___2, (size_t )4U);
#line 1617
            chunkpos += 4U;
          }
        } else {
          {
#line 1621
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1623
            b___0 = ps->IDAT_crc;
#line 1624
            shift___0 = IDAT_len - IDAT_pos;
#line 1625
            IDAT_pos ++;
#line 1627
            if (shift___0 > 1U) {
#line 1628
              b___0 >>= 8U * (shift___0 - 1U);
            }
#line 1630
            tmp___1 = pb;
#line 1630
            pb ++;
#line 1630
            *tmp___1 = (png_byte )(255UL & b___0);
#line 1621
            st --;
#line 1621
            if (st > 0UL) {
#line 1621
              if (! (IDAT_pos < IDAT_len)) {
#line 1621
                goto while_break___1;
              }
            } else {
#line 1621
              goto while_break___1;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 1634
        ps->IDAT_pos = IDAT_pos;
#line 1635
        ps->IDAT_len = IDAT_len;
#line 1636
        ps->IDAT_size = IDAT_size;
      } else {
#line 1644
        if (ps->IDAT_len > 0U) {
#line 1644
          if (ps->IDAT_size > 0U) {
#line 1645
            png_error((png_const_structrp )ps->pread, (png_const_charp )"internal: missing IDAT data");
          }
        }
#line 1647
        if (chunktype == (png_uint_32 )((((73 << 24) + (69 << 16)) + (78 << 8)) + 68)) {
#line 1647
          if (ps->IDAT_len == 0U) {
#line 1648
            png_error((png_const_structrp )ps->pread, (png_const_charp )"internal: missing IDAT");
          }
        }
#line 1650
        if (chunkpos < 8U) {
          {
#line 1650
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1655
            if (chunkpos < 4U) {
#line 1656
              b___1 = chunklen - 12U;
            } else {
#line 1659
              b___1 = chunktype;
            }
#line 1661
            shift___1 = 3U & chunkpos;
#line 1662
            chunkpos ++;
#line 1664
            if (shift___1 < 3U) {
#line 1665
              b___1 >>= 8U * (3U - shift___1);
            }
#line 1667
            tmp___2 = pb;
#line 1667
            pb ++;
#line 1667
            *tmp___2 = (png_byte )(0xffU & b___1);
#line 1650
            st --;
#line 1650
            if (st > 0UL) {
#line 1650
              if (! (chunkpos < 8U)) {
#line 1650
                goto while_break___2;
              }
            } else {
#line 1650
              goto while_break___2;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
        } else {
#line 1673
          avail___0 = st;
#line 1675
          if (avail___0 > (size_t )(chunklen - chunkpos)) {
#line 1676
            avail___0 = (size_t )(chunklen - chunkpos);
          }
#line 1678
          store_read_imp(ps, pb, avail___0);
#line 1679
          pb += avail___0;
#line 1680
          st -= avail___0;
#line 1681
          chunkpos += (png_uint_32 )avail___0;
#line 1686
          if (chunkpos >= chunklen) {
#line 1686
            if (max - st >= min) {
#line 1686
              tmp___3 = store_read_buffer_avail(ps);
#line 1686
              if (tmp___3 == 0UL) {
#line 1688
                goto while_break;
              }
            }
          }
        }
      }
      __Cont: /* CIL Label */
#line 1476
      if (! (st > 0UL)) {
#line 1476
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1694
  ps->chunklen = chunklen;
#line 1695
  ps->chunktype = chunktype;
#line 1696
  ps->chunkpos = chunkpos;
#line 1698
  return (st);
}
}
#line 1701 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void store_read(png_structp ppIn , png_bytep pb , size_t st )
{
  png_const_structp pp ;
  png_store *ps ;
  png_voidp tmp ;

  {
#line 1704
  pp = (png_const_structp )ppIn;
#line 1705
  tmp = png_get_io_ptr((png_const_structrp )pp);
#line 1705
  ps = (png_store *)tmp;
#line 1707
  if ((unsigned long )ps == (unsigned long )((void *)0)) {
#line 1708
    png_error((png_const_structrp )pp, (png_const_charp )"bad store read call");
  } else
#line 1707
  if ((unsigned long )ps->pread != (unsigned long )pp) {
#line 1708
    png_error((png_const_structrp )pp, (png_const_charp )"bad store read call");
  }
#line 1710
  store_read_chunk(ps, pb, st, st);
#line 1711
  return;
}
}
#line 1727
static void store_progressive_read(png_store *ps , png_structp pp , png_infop pi ) ;
#line 1727 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static png_uint_32 noise  =    (png_uint_32 )2;
#line 1713 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void store_progressive_read(png_store *ps , png_structp pp , png_infop pi )
{
  size_t cb ;
  png_byte buffer___0[512] ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 1716
  if ((unsigned long )ps->pread != (unsigned long )pp) {
#line 1717
    png_error((png_const_structrp )pp, (png_const_charp )"store state damaged (progressive)");
  } else
#line 1716
  if ((unsigned long )ps->current == (unsigned long )((void *)0)) {
#line 1717
    png_error((png_const_structrp )pp, (png_const_charp )"store state damaged (progressive)");
  } else
#line 1716
  if ((unsigned long )ps->next == (unsigned long )((void *)0)) {
#line 1717
    png_error((png_const_structrp )pp, (png_const_charp )"store state damaged (progressive)");
  }
  {
#line 1725
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1725
    tmp___0 = store_read_buffer_avail(ps);
#line 1725
    if (! (tmp___0 > 0UL)) {
#line 1725
      goto while_break;
    }
#line 1732
    noise = (noise << 9) | ((noise ^ (noise >> 4)) & 511U);
#line 1733
    cb = (size_t )(noise & 511U);
#line 1734
    tmp = store_read_chunk(ps, buffer___0, cb, (size_t )1);
#line 1734
    cb -= tmp;
#line 1735
    png_process_data((png_structrp )pp, (png_inforp )pi, buffer___0, cb);
  }
  while_break: /* CIL Label */ ;
  }
#line 1737
  return;
}
}
#line 1741 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static store_palette_entry *store_write_palette(png_store *ps , int npalette )
{
  void *tmp ;

  {
#line 1744
  if ((unsigned long )ps->pwrite == (unsigned long )((void *)0)) {
#line 1745
    store_log(ps, (png_const_structp )((void *)0), (png_const_charp )"attempt to write palette without write stream",
              1);
  }
#line 1747
  if ((unsigned long )ps->palette != (unsigned long )((void *)0)) {
#line 1748
    png_error((png_const_structrp )ps->pwrite, (png_const_charp )"multiple store_write_palette calls");
  }
#line 1751
  if (npalette > 0) {
#line 1753
    tmp = malloc((unsigned long )npalette * sizeof(*(ps->palette)));
#line 1753
    ps->palette = (store_palette_entry *)tmp;
#line 1756
    if ((unsigned long )ps->palette == (unsigned long )((void *)0)) {
#line 1757
      png_error((png_const_structrp )ps->pwrite, (png_const_charp )"store new palette: OOM");
    }
#line 1759
    ps->npalette = npalette;
  }
#line 1762
  return (ps->palette);
}
}
#line 1766 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static store_palette_entry *store_current_palette(png_store *ps , int *npalette )
{


  {
#line 1772
  if ((unsigned long )ps->current == (unsigned long )((void *)0)) {
#line 1774
    store_log(ps, (png_const_structp )ps->pread, (png_const_charp )"no current stream for palette",
              1);
#line 1775
    return ((store_palette_entry *)((void *)0));
  }
#line 1779
  *npalette = (ps->current)->npalette;
#line 1780
  return ((ps->current)->palette);
}
}
#line 1805 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void store_pool_error(png_store *ps , png_const_structp pp , char const   *msg )
{


  {
#line 1808
  if ((unsigned long )pp != (unsigned long )((void *)0)) {
#line 1809
    png_error((png_const_structrp )pp, msg);
  }
#line 1815
  store_log(ps, pp, msg, 1);
#line 1816
  return;
}
}
#line 1818 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void store_memory_free(png_const_structp pp , store_pool *pool , store_memory *memory )
{
  png_alloc_size_t cb ;
  int tmp ;
  int tmp___0 ;

  {
#line 1825
  if ((unsigned long )memory->pool != (unsigned long )pool) {
#line 1826
    store_pool_error(pool->store, pp, (char const   *)"memory corrupted (pool)");
  } else {
#line 1828
    tmp___0 = memcmp((void const   *)(memory->mark), (void const   *)(pool->mark),
                     sizeof(memory->mark));
#line 1828
    if (tmp___0 != 0) {
#line 1829
      store_pool_error(pool->store, pp, (char const   *)"memory corrupted (start)");
    } else {
#line 1834
      cb = memory->size;
#line 1836
      if (cb > pool->max) {
#line 1837
        store_pool_error(pool->store, pp, (char const   *)"memory corrupted (size)");
      } else {
#line 1839
        tmp = memcmp((void const   *)((png_bytep )(memory + 1) + cb), (void const   *)(pool->mark),
                     sizeof(pool->mark));
#line 1839
        if (tmp != 0) {
#line 1841
          store_pool_error(pool->store, pp, (char const   *)"memory corrupted (end)");
        } else {
#line 1846
          pool->current -= cb;
#line 1847
          free((void *)memory);
        }
      }
    }
  }
#line 1850
  return;
}
}
#line 1852 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void store_pool_delete(png_store *ps , store_pool *pool )
{
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  store_memory *next ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 1855
  if ((unsigned long )pool->list != (unsigned long )((void *)0)) {
#line 1857
    if ((unsigned long )pool == (unsigned long )(& ps->read_memory_pool)) {
#line 1857
      if ((unsigned long )ps->current != (unsigned long )((void *)0)) {
#line 1857
        tmp = (ps->current)->name;
      } else {
#line 1857
        tmp = "unknown file";
      }
#line 1857
      tmp___0 = tmp;
    } else {
#line 1857
      tmp___0 = ps->wname;
    }
#line 1857
    if ((unsigned long )pool == (unsigned long )(& ps->read_memory_pool)) {
#line 1857
      tmp___1 = "read";
    } else {
#line 1857
      tmp___1 = "write";
    }
#line 1857
    fprintf(stderr, (char const   *)"%s: %s %s: memory lost (list follows):\n", ps->test,
            tmp___1, tmp___0);
#line 1861
    (ps->nerrors) ++;
    {
#line 1863
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1865
      next = pool->list;
#line 1866
      pool->list = next->next;
#line 1867
      next->next = (struct store_memory *)((void *)0);
#line 1869
      fprintf(stderr, (char const   *)"\t%lu bytes @ %p\n", next->size, (void const   *)(next + 1));
#line 1874
      store_memory_free((png_const_structp )((void *)0), pool, next);
#line 1863
      if (! ((unsigned long )pool->list != (unsigned long )((void *)0))) {
#line 1863
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1880
  if (pool->max > pool->max_max) {
#line 1880
    pool->max_max = pool->max;
  }
#line 1881
  pool->max = (png_alloc_size_t )0;
#line 1882
  if (pool->current != 0UL) {
#line 1883
    if ((unsigned long )pool == (unsigned long )(& ps->read_memory_pool)) {
#line 1883
      if ((unsigned long )ps->current != (unsigned long )((void *)0)) {
#line 1883
        tmp___2 = (ps->current)->name;
      } else {
#line 1883
        tmp___2 = "unknown file";
      }
#line 1883
      tmp___3 = tmp___2;
    } else {
#line 1883
      tmp___3 = ps->wname;
    }
#line 1883
    if ((unsigned long )pool == (unsigned long )(& ps->read_memory_pool)) {
#line 1883
      tmp___4 = "read";
    } else {
#line 1883
      tmp___4 = "write";
    }
#line 1883
    fprintf(stderr, (char const   *)"%s: %s %s: memory counter mismatch (internal error)\n",
            ps->test, tmp___4, tmp___3);
  }
#line 1887
  pool->current = (png_alloc_size_t )0;
#line 1889
  if (pool->limit > pool->max_limit) {
#line 1890
    pool->max_limit = pool->limit;
  }
#line 1892
  pool->limit = (png_alloc_size_t )0;
#line 1894
  if (pool->total > pool->max_total) {
#line 1895
    pool->max_total = pool->total;
  }
#line 1897
  pool->total = (png_alloc_size_t )0;
#line 1900
  store_pool_mark(pool->mark);
#line 1901
  return;
}
}
#line 1904 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static png_voidp store_malloc(png_structp ppIn , png_alloc_size_t cb )
{
  png_const_structp pp ;
  store_pool *pool ;
  png_voidp tmp ;
  store_memory *new ;
  void *tmp___0 ;

  {
#line 1907
  pp = (png_const_structp )ppIn;
#line 1908
  tmp = png_get_mem_ptr((png_const_structrp )pp);
#line 1908
  pool = (store_pool *)tmp;
#line 1909
  tmp___0 = malloc((cb + sizeof(*new)) + sizeof(pool->mark));
#line 1909
  new = (store_memory *)tmp___0;
#line 1912
  if ((unsigned long )new != (unsigned long )((void *)0)) {
#line 1914
    if (cb > pool->max) {
#line 1915
      pool->max = cb;
    }
#line 1917
    pool->current += cb;
#line 1919
    if (pool->current > pool->limit) {
#line 1920
      pool->limit = pool->current;
    }
#line 1922
    pool->total += cb;
#line 1924
    new->size = cb;
#line 1925
    memcpy((void *)(new->mark), (void const   *)(pool->mark), sizeof(new->mark));
#line 1926
    memcpy((void *)((png_byte *)(new + 1) + cb), (void const   *)(pool->mark), sizeof(pool->mark));
#line 1927
    new->pool = pool;
#line 1928
    new->next = pool->list;
#line 1929
    pool->list = new;
#line 1930
    new ++;
  } else {
#line 1947
    store_log(pool->store, pp, (png_const_charp )"out of memory", 1);
  }
#line 1950
  return ((png_voidp )new);
}
}
#line 1953 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void store_free(png_structp ppIn , png_voidp memory )
{
  png_const_structp pp ;
  store_pool *pool ;
  png_voidp tmp ;
  store_memory *this ;
  store_memory **test ;

  {
#line 1956
  pp = (png_const_structp )ppIn;
#line 1957
  tmp = png_get_mem_ptr((png_const_structrp )pp);
#line 1957
  pool = (store_pool *)tmp;
#line 1958
  this = (store_memory *)memory;
#line 1965
  if ((unsigned long )pp != (unsigned long )(pool->store)->pread) {
#line 1965
    if ((unsigned long )pp != (unsigned long )(pool->store)->pwrite) {
#line 1966
      pp = (png_const_structp )((void *)0);
    }
  }
#line 1971
  this --;
#line 1972
  test = & pool->list;
  {
#line 1972
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1972
    if (! ((unsigned long )*test != (unsigned long )this)) {
#line 1972
      goto while_break;
    }
#line 1974
    if ((unsigned long )*test == (unsigned long )((void *)0)) {
#line 1976
      store_pool_error(pool->store, pp, (char const   *)"bad pointer to free");
#line 1977
      return;
    }
#line 1972
    test = & (*test)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1982
  *test = this->next;
#line 1983
  this->next = (struct store_memory *)((void *)0);
#line 1984
  store_memory_free(pp, pool, this);
#line 1985
  return;
}
}
#line 1990 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void store_write_reset(png_store *ps )
{
  struct exception_context *the_exception_context ;
  jmp_buf *exception__prev ;
  jmp_buf exception__env ;
  int tmp ;
  int tmp___0 ;

  {
#line 1993
  if ((unsigned long )ps->pwrite != (unsigned long )((void *)0)) {
#line 1995
    the_exception_context = & ps->exception_context;
#line 1997
    exception__prev = the_exception_context->penv;
#line 1997
    the_exception_context->penv = & exception__env;
#line 1997
    tmp = _setjmp((struct __jmp_buf_tag *)(exception__env));
#line 1997
    if (tmp == 0) {
      {
#line 1997
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1998
        png_destroy_write_struct(& ps->pwrite, & ps->piwrite);
#line 1997
        the_exception_context->caught = 0;
#line 1997
        if (! the_exception_context->caught) {
#line 1997
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 2000
      the_exception_context->caught = 1;
    }
#line 2000
    the_exception_context->penv = exception__prev;
#line 2000
    if (! the_exception_context->caught) {
#line 2000
      tmp___0 = 1;
    } else
#line 2000
    if (0) {
#line 2000
      tmp___0 = 1;
    } else {
#line 2000
      tmp___0 = 0;
    }
#line 2005
    ps->pwrite = (png_structp )((void *)0);
#line 2006
    ps->piwrite = (png_infop )((void *)0);
  }
#line 2013
  store_pool_delete(ps, & ps->write_memory_pool);
#line 2016
  store_freenew(ps);
#line 2017
  return;
}
}
#line 2024 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static png_structp set_store_for_write(png_store *ps , png_infopp ppi , char const   *name )
{
  struct exception_context *the_exception_context ;
  jmp_buf *exception__prev ;
  jmp_buf exception__env ;
  png_structp __attribute__((__malloc__))  tmp ;
  png_structp __attribute__((__malloc__))  tmp___0 ;
  int opt ;
  int tmp___1 ;
  png_infop tmp___2 ;
  png_infop __attribute__((__malloc__))  tmp___3 ;
  int tmp___4 ;

  {
#line 2027
  the_exception_context = & ps->exception_context;
#line 2029
  exception__prev = the_exception_context->penv;
#line 2029
  the_exception_context->penv = & exception__env;
#line 2029
  tmp___4 = _setjmp((struct __jmp_buf_tag *)(exception__env));
#line 2029
  if (tmp___4 == 0) {
    {
#line 2029
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2031
      if ((unsigned long )ps->pwrite != (unsigned long )((void *)0)) {
#line 2032
        png_error((png_const_structrp )ps->pwrite, (png_const_charp )"write store already in use");
      }
#line 2034
      store_write_reset(ps);
#line 2035
      safecat(ps->wname, sizeof(ps->wname), (size_t )0, name);
#line 2041
      if (! ps->speed) {
#line 2042
        tmp = png_create_write_struct_2((png_const_charp )"1.6.39", (png_voidp )ps,
                                        & store_error, & store_warning, (png_voidp )(& ps->write_memory_pool),
                                        & store_malloc, & store_free);
#line 2042
        ps->pwrite = (png_structp )tmp;
      } else {
#line 2048
        tmp___0 = png_create_write_struct((png_const_charp )"1.6.39", (png_voidp )ps,
                                          & store_error, & store_warning);
#line 2048
        ps->pwrite = (png_structp )tmp___0;
      }
#line 2051
      png_set_write_fn((png_structrp )ps->pwrite, (png_voidp )ps, & store_write, & store_flush);
#line 2056
      opt = 0;
      {
#line 2056
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2056
        if (! (opt < ps->noptions)) {
#line 2056
          goto while_break___0;
        }
#line 2057
        tmp___1 = png_set_option((png_structrp )ps->pwrite, (int )ps->options[opt].option,
                                 (int )ps->options[opt].setting);
#line 2057
        if (tmp___1 == 1) {
#line 2059
          png_error((png_const_structrp )ps->pwrite, (png_const_charp )"png option invalid");
        }
#line 2056
        opt ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2063
      if ((unsigned long )ppi != (unsigned long )((void *)0)) {
#line 2064
        tmp___3 = png_create_info_struct((png_const_structrp )ps->pwrite);
#line 2064
        tmp___2 = (png_infop )tmp___3;
#line 2064
        ps->piwrite = tmp___2;
#line 2064
        *ppi = tmp___2;
      }
#line 2029
      the_exception_context->caught = 0;
#line 2029
      if (! the_exception_context->caught) {
#line 2029
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 2067
    the_exception_context->caught = 1;
  }
#line 2067
  the_exception_context->penv = exception__prev;
#line 2067
  if (! (! the_exception_context->caught)) {
#line 2067
    if (! 0) {
#line 2068
      return ((png_structp )((void *)0));
    }
  }
#line 2070
  return (ps->pwrite);
}
}
#line 2077 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void store_read_reset(png_store *ps )
{
  struct exception_context *the_exception_context ;
  jmp_buf *exception__prev ;
  jmp_buf exception__env ;
  int tmp ;
  int tmp___0 ;

  {
#line 2081
  if ((unsigned long )ps->pread != (unsigned long )((void *)0)) {
#line 2083
    the_exception_context = & ps->exception_context;
#line 2085
    exception__prev = the_exception_context->penv;
#line 2085
    the_exception_context->penv = & exception__env;
#line 2085
    tmp = _setjmp((struct __jmp_buf_tag *)(exception__env));
#line 2085
    if (tmp == 0) {
      {
#line 2085
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2086
        png_destroy_read_struct(& ps->pread, & ps->piread, (png_infopp )((void *)0));
#line 2085
        the_exception_context->caught = 0;
#line 2085
        if (! the_exception_context->caught) {
#line 2085
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 2088
      the_exception_context->caught = 1;
    }
#line 2088
    the_exception_context->penv = exception__prev;
#line 2088
    if (! the_exception_context->caught) {
#line 2088
      tmp___0 = 1;
    } else
#line 2088
    if (0) {
#line 2088
      tmp___0 = 1;
    } else {
#line 2088
      tmp___0 = 0;
    }
#line 2093
    ps->pread = (png_structp )((void *)0);
#line 2094
    ps->piread = (png_infop )((void *)0);
  }
#line 2100
  store_pool_delete(ps, & ps->read_memory_pool);
#line 2103
  ps->current = (png_store_file *)((void *)0);
#line 2104
  ps->next = (png_store_buffer *)((void *)0);
#line 2105
  ps->readpos = (size_t )0;
#line 2106
  ps->validated = 0U;
#line 2108
  ps->chunkpos = (png_uint_32 )8;
#line 2109
  ps->chunktype = (png_uint_32 )0;
#line 2110
  ps->chunklen = (png_uint_32 )16;
#line 2111
  ps->IDAT_size = (png_uint_32 )0;
#line 2112
  return;
}
}
#line 2115 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void store_read_set(png_store *ps , png_uint_32 id )
{
  png_store_file *pf ;
  size_t pos ;
  char msg[128] ;

  {
#line 2118
  pf = ps->saved;
  {
#line 2120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2120
    if (! ((unsigned long )pf != (unsigned long )((void *)0))) {
#line 2120
      goto while_break;
    }
#line 2122
    if (pf->id == id) {
#line 2124
      ps->current = pf;
#line 2125
      ps->next = (png_store_buffer *)((void *)0);
#line 2126
      ps->IDAT_size = pf->IDAT_size;
#line 2127
      ps->IDAT_bits = pf->IDAT_bits;
#line 2128
      ps->IDAT_len = (png_uint_32 )0;
#line 2129
      ps->IDAT_pos = (png_uint_32 )0;
#line 2130
      ps->IDAT_crc = 0UL;
#line 2131
      store_read_buffer_next(ps);
#line 2132
      return;
    }
#line 2135
    pf = pf->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2142
  pos = standard_name_from_id(msg, sizeof(msg), (size_t )0, id);
#line 2143
  pos = safecat(msg, sizeof(msg), pos, (char const   *)": file not found");
#line 2144
  png_error((png_const_structrp )ps->pread, (png_const_charp )(msg));
}
}
#line 2153 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static png_structp set_store_for_read(png_store *ps , png_infopp ppi , png_uint_32 id ,
                                      char const   *name )
{
  png_structp __attribute__((__malloc__))  tmp ;
  png_structp __attribute__((__malloc__))  tmp___0 ;
  struct exception_context *the_exception_context ;
  int opt ;
  int tmp___1 ;
  png_infop tmp___2 ;
  png_infop __attribute__((__malloc__))  tmp___3 ;

  {
#line 2158
  safecat(ps->test, sizeof(ps->test), (size_t )0, name);
#line 2160
  if ((unsigned long )ps->pread != (unsigned long )((void *)0)) {
#line 2161
    png_error((png_const_structrp )ps->pread, (png_const_charp )"read store already in use");
  }
#line 2163
  store_read_reset(ps);
#line 2172
  if (! ps->speed) {
#line 2173
    tmp = png_create_read_struct_2((png_const_charp )"1.6.39", (png_voidp )ps, & store_error,
                                   & store_warning, (png_voidp )(& ps->read_memory_pool),
                                   & store_malloc, & store_free);
#line 2173
    ps->pread = (png_structp )tmp;
  } else {
#line 2179
    tmp___0 = png_create_read_struct((png_const_charp )"1.6.39", (png_voidp )ps, & store_error,
                                     & store_warning);
#line 2179
    ps->pread = (png_structp )tmp___0;
  }
#line 2182
  if ((unsigned long )ps->pread == (unsigned long )((void *)0)) {
#line 2184
    the_exception_context = & ps->exception_context;
#line 2186
    store_log(ps, (png_const_structp )((void *)0), (png_const_charp )"png_create_read_struct returned NULL (unexpected)",
              1);
    {
#line 2189
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2189
      the_exception_context->v.etmp = (struct png_store * volatile  )ps;
#line 2189
      longjmp((struct __jmp_buf_tag *)(*(the_exception_context->penv)), 1);
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2195
  opt = 0;
  {
#line 2195
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2195
    if (! (opt < ps->noptions)) {
#line 2195
      goto while_break___0;
    }
#line 2196
    tmp___1 = png_set_option((png_structrp )ps->pread, (int )ps->options[opt].option,
                             (int )ps->options[opt].setting);
#line 2196
    if (tmp___1 == 1) {
#line 2198
      png_error((png_const_structrp )ps->pread, (png_const_charp )"png option invalid");
    }
#line 2195
    opt ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2202
  store_read_set(ps, id);
#line 2204
  if ((unsigned long )ppi != (unsigned long )((void *)0)) {
#line 2205
    tmp___3 = png_create_info_struct((png_const_structrp )ps->pread);
#line 2205
    tmp___2 = (png_infop )tmp___3;
#line 2205
    ps->piread = tmp___2;
#line 2205
    *ppi = tmp___2;
  }
#line 2207
  return (ps->pread);
}
}
#line 2214 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void store_delete(png_store *ps )
{


  {
#line 2217
  store_write_reset(ps);
#line 2218
  store_read_reset(ps);
#line 2219
  store_freefile(& ps->saved);
#line 2220
  store_image_free(ps, (png_const_structp )((void *)0));
#line 2221
  return;
}
}
#line 2263 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static double chromaticity_x(CIE_color c )
{


  {
#line 2266
  return (c.X / ((c.X + c.Y) + c.Z));
}
}
#line 2269 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static double chromaticity_y(CIE_color c )
{


  {
#line 2272
  return (c.Y / ((c.X + c.Y) + c.Z));
}
}
#line 2275 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static CIE_color white_point(color_encoding const   *encoding )
{
  CIE_color white ;

  {
#line 2280
  white.X = (double )((encoding->red.X + encoding->green.X) + encoding->blue.X);
#line 2281
  white.Y = (double )((encoding->red.Y + encoding->green.Y) + encoding->blue.Y);
#line 2282
  white.Z = (double )((encoding->red.Z + encoding->green.Z) + encoding->blue.Z);
#line 2284
  return (white);
}
}
#line 2289 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void normalize_color_encoding(color_encoding *encoding )
{
  double whiteY ;

  {
#line 2292
  whiteY = (double )((encoding->red.Y + encoding->green.Y) + encoding->blue.Y);
#line 2295
  if (whiteY != (double )1) {
#line 2297
    encoding->red.X /= (double )whiteY;
#line 2298
    encoding->red.Y /= (double )whiteY;
#line 2299
    encoding->red.Z /= (double )whiteY;
#line 2300
    encoding->green.X /= (double )whiteY;
#line 2301
    encoding->green.Y /= (double )whiteY;
#line 2302
    encoding->green.Z /= (double )whiteY;
#line 2303
    encoding->blue.X /= (double )whiteY;
#line 2304
    encoding->blue.Y /= (double )whiteY;
#line 2305
    encoding->blue.Z /= (double )whiteY;
  }
#line 2307
  return;
}
}
#line 2311 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static size_t safecat_color_encoding(char *buffer___0 , size_t bufsize , size_t pos ,
                                     color_encoding const   *e , double encoding_gamma )
{


  {
#line 2315
  if ((unsigned long )e != (unsigned long )((color_encoding const   *)0)) {
#line 2317
    if (encoding_gamma != (double )0) {
#line 2318
      pos = safecat(buffer___0, bufsize, pos, (char const   *)"(");
    }
#line 2319
    pos = safecat(buffer___0, bufsize, pos, (char const   *)"R(");
#line 2320
    pos = safecatd(buffer___0, bufsize, pos, (double )e->red.X, 4);
#line 2321
    pos = safecat(buffer___0, bufsize, pos, (char const   *)",");
#line 2322
    pos = safecatd(buffer___0, bufsize, pos, (double )e->red.Y, 4);
#line 2323
    pos = safecat(buffer___0, bufsize, pos, (char const   *)",");
#line 2324
    pos = safecatd(buffer___0, bufsize, pos, (double )e->red.Z, 4);
#line 2325
    pos = safecat(buffer___0, bufsize, pos, (char const   *)"),G(");
#line 2326
    pos = safecatd(buffer___0, bufsize, pos, (double )e->green.X, 4);
#line 2327
    pos = safecat(buffer___0, bufsize, pos, (char const   *)",");
#line 2328
    pos = safecatd(buffer___0, bufsize, pos, (double )e->green.Y, 4);
#line 2329
    pos = safecat(buffer___0, bufsize, pos, (char const   *)",");
#line 2330
    pos = safecatd(buffer___0, bufsize, pos, (double )e->green.Z, 4);
#line 2331
    pos = safecat(buffer___0, bufsize, pos, (char const   *)"),B(");
#line 2332
    pos = safecatd(buffer___0, bufsize, pos, (double )e->blue.X, 4);
#line 2333
    pos = safecat(buffer___0, bufsize, pos, (char const   *)",");
#line 2334
    pos = safecatd(buffer___0, bufsize, pos, (double )e->blue.Y, 4);
#line 2335
    pos = safecat(buffer___0, bufsize, pos, (char const   *)",");
#line 2336
    pos = safecatd(buffer___0, bufsize, pos, (double )e->blue.Z, 4);
#line 2337
    pos = safecat(buffer___0, bufsize, pos, (char const   *)")");
#line 2338
    if (encoding_gamma != (double )0) {
#line 2339
      pos = safecat(buffer___0, bufsize, pos, (char const   *)")");
    }
  }
#line 2342
  if (encoding_gamma != (double )0) {
#line 2344
    pos = safecat(buffer___0, bufsize, pos, (char const   *)"^");
#line 2345
    pos = safecatd(buffer___0, bufsize, pos, encoding_gamma, 5);
  }
#line 2348
  return (pos);
}
}
#line 2501 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int fail(png_modifier *pm___0 )
{
  int tmp ;

  {
#line 2503
  if (! pm___0->log) {
#line 2503
    if (! pm___0->this.verbose) {
#line 2503
      if (pm___0->this.nerrors > 0) {
#line 2503
        tmp = 1;
      } else
#line 2503
      if (pm___0->this.treat_warnings_as_errors) {
#line 2503
        if (pm___0->this.nwarnings > 0) {
#line 2503
          tmp = 1;
        } else {
#line 2503
          tmp = 0;
        }
      } else {
#line 2503
        tmp = 0;
      }
    } else {
#line 2503
      tmp = 0;
    }
  } else {
#line 2503
    tmp = 0;
  }
#line 2503
  return (tmp);
}
}
#line 2507 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void modifier_init(png_modifier *pm___0 )
{
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;

  {
#line 2510
  memset((void *)pm___0, 0, sizeof(*pm___0));
#line 2511
  store_init(& pm___0->this);
#line 2512
  pm___0->modifications = (struct png_modification *)((void *)0);
#line 2513
  pm___0->state = (modifier_state )0;
#line 2514
  pm___0->sbitlow = (png_byte )1U;
#line 2515
  pm___0->ngammas = 0U;
#line 2516
  pm___0->ngamma_tests = 0U;
#line 2517
  pm___0->gammas = (double *)0;
#line 2518
  pm___0->current_gamma = (double )0;
#line 2519
  pm___0->encodings = (color_encoding const   *)0;
#line 2520
  pm___0->nencodings = 0U;
#line 2521
  pm___0->current_encoding = (color_encoding const   *)0;
#line 2522
  pm___0->encoding_counter = 0U;
#line 2523
  pm___0->encoding_ignored = 0;
#line 2524
  pm___0->repeat = 0U;
#line 2525
  pm___0->test_uses_encoding = 0U;
#line 2526
  tmp___1 = (double )0;
#line 2526
  pm___0->maxcalc8 = tmp___1;
#line 2526
  tmp___0 = tmp___1;
#line 2526
  pm___0->maxabs8 = tmp___0;
#line 2526
  tmp = tmp___0;
#line 2526
  pm___0->maxpc8 = tmp;
#line 2526
  pm___0->maxout8 = tmp;
#line 2527
  tmp___4 = (double )0;
#line 2527
  pm___0->maxcalc16 = tmp___4;
#line 2527
  tmp___3 = tmp___4;
#line 2527
  pm___0->maxabs16 = tmp___3;
#line 2527
  tmp___2 = tmp___3;
#line 2527
  pm___0->maxpc16 = tmp___2;
#line 2527
  pm___0->maxout16 = tmp___2;
#line 2528
  pm___0->maxcalcG = (double )0;
#line 2529
  pm___0->limit = 4E-3;
#line 2530
  tmp___5 = (double )0;
#line 2530
  pm___0->log16 = tmp___5;
#line 2530
  pm___0->log8 = tmp___5;
#line 2531
  tmp___7 = (double )0;
#line 2531
  pm___0->error_gray_8 = tmp___7;
#line 2531
  tmp___6 = tmp___7;
#line 2531
  pm___0->error_gray_4 = tmp___6;
#line 2531
  pm___0->error_gray_2 = tmp___6;
#line 2532
  tmp___9 = (double )0;
#line 2532
  pm___0->error_color_16 = tmp___9;
#line 2532
  tmp___8 = tmp___9;
#line 2532
  pm___0->error_color_8 = tmp___8;
#line 2532
  pm___0->error_gray_16 = tmp___8;
#line 2533
  pm___0->error_indexed = (double )0;
#line 2534
  pm___0->use_update_info = 0;
#line 2535
  pm___0->interlace_type = 0;
#line 2536
  pm___0->test_standard = 0U;
#line 2537
  pm___0->test_size = 0U;
#line 2538
  pm___0->test_transform = 0U;
#line 2540
  pm___0->test_tRNS = 1U;
#line 2544
  pm___0->use_input_precision = 0U;
#line 2545
  pm___0->use_input_precision_sbit = 0U;
#line 2546
  pm___0->use_input_precision_16to8 = 0U;
#line 2547
  pm___0->calculations_use_input_precision = 0U;
#line 2548
  pm___0->assume_16_bit_calculations = 0U;
#line 2549
  pm___0->test_gamma_threshold = 0U;
#line 2550
  pm___0->test_gamma_transform = 0U;
#line 2551
  pm___0->test_gamma_sbit = 0U;
#line 2552
  pm___0->test_gamma_scale16 = 0U;
#line 2553
  pm___0->test_gamma_background = 0U;
#line 2554
  pm___0->test_gamma_alpha_mode = 0U;
#line 2555
  pm___0->test_gamma_expand16 = 0U;
#line 2556
  pm___0->test_lbg = 1U;
#line 2557
  pm___0->test_lbg_gamma_threshold = 1U;
#line 2558
  pm___0->test_lbg_gamma_transform = 1U;
#line 2559
  pm___0->test_lbg_gamma_sbit = 1U;
#line 2560
  pm___0->test_lbg_gamma_composition = 1U;
#line 2561
  pm___0->test_exhaustive = 0U;
#line 2562
  pm___0->log = 0U;
#line 2565
  return;
}
}
#line 2586 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static double digitize(double value , int depth , int do_round )
{
  unsigned int digitization_factor ;
  double tmp ;

  {
#line 2594
  digitization_factor = (1U << depth) - 1U;
#line 2599
  if (value <= (double )0) {
#line 2600
    value = (double )0;
  } else
#line 2602
  if (value >= (double )1) {
#line 2603
    value = (double )1;
  }
#line 2605
  value *= (double )digitization_factor;
#line 2606
  if (do_round) {
#line 2606
    value += .5;
  }
#line 2607
  tmp = floor(value);
#line 2607
  return (tmp / (double )digitization_factor);
}
}
#line 2613 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static double abserr(png_modifier const   *pm___0 , int in_depth , int out_depth )
{
  int tmp ;

  {
#line 2618
  if (pm___0->assume_16_bit_calculations) {
#line 2620
    return ((double )pm___0->maxabs16);
  } else {
#line 2618
    if (pm___0->calculations_use_input_precision) {
#line 2618
      tmp = in_depth;
    } else {
#line 2618
      tmp = out_depth;
    }
#line 2618
    if (tmp == 16) {
#line 2620
      return ((double )pm___0->maxabs16);
    } else {
#line 2622
      return ((double )pm___0->maxabs8);
    }
  }
}
}
#line 2625 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static double calcerr(png_modifier const   *pm___0 , int in_depth , int out_depth )
{
  int tmp ;

  {
#line 2630
  if (pm___0->calculations_use_input_precision) {
#line 2630
    tmp = in_depth;
  } else {
#line 2630
    tmp = out_depth;
  }
#line 2630
  if (tmp == 16) {
#line 2631
    return ((double )pm___0->maxcalc16);
  } else
#line 2632
  if (pm___0->assume_16_bit_calculations) {
#line 2633
    return ((double )pm___0->maxcalcG);
  } else {
#line 2635
    return ((double )pm___0->maxcalc8);
  }
}
}
#line 2638 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static double pcerr(png_modifier const   *pm___0 , int in_depth , int out_depth )
{
  int tmp ;

  {
#line 2643
  if (pm___0->assume_16_bit_calculations) {
#line 2645
    return ((double )(pm___0->maxpc16 * (double ).01));
  } else {
#line 2643
    if (pm___0->calculations_use_input_precision) {
#line 2643
      tmp = in_depth;
    } else {
#line 2643
      tmp = out_depth;
    }
#line 2643
    if (tmp == 16) {
#line 2645
      return ((double )(pm___0->maxpc16 * (double ).01));
    } else {
#line 2647
      return ((double )(pm___0->maxpc8 * (double ).01));
    }
  }
}
}
#line 2661 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static double outerr(png_modifier const   *pm___0 , int in_depth , int out_depth )
{
  int tmp ;

  {
#line 2670
  if (out_depth == 2) {
#line 2671
    return (.73182 - .5);
  }
#line 2673
  if (out_depth == 4) {
#line 2674
    return (.90644 - .5);
  }
#line 2676
  if (pm___0->calculations_use_input_precision) {
#line 2676
    tmp = in_depth;
  } else {
#line 2676
    tmp = out_depth;
  }
#line 2676
  if (tmp == 16) {
#line 2677
    return ((double )pm___0->maxout16);
  } else
#line 2682
  if (out_depth == 16) {
#line 2683
    return ((double )(pm___0->maxout8 * (double )257));
  } else {
#line 2686
    return ((double )pm___0->maxout8);
  }
}
}
#line 2693 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static double outlog(png_modifier const   *pm___0 , int in_depth , int out_depth )
{
  int tmp ;

  {
#line 2698
  if (out_depth <= 8) {
#line 2700
    if (pm___0->log8 == (double )0) {
#line 2701
      return ((double )256);
    }
#line 2703
    if (out_depth < 8) {
#line 2704
      return ((double )((pm___0->log8 / (double )255) * (double )((1 << out_depth) - 1)));
    }
#line 2706
    return ((double )pm___0->log8);
  }
#line 2709
  if (pm___0->calculations_use_input_precision) {
#line 2709
    tmp = in_depth;
  } else {
#line 2709
    tmp = out_depth;
  }
#line 2709
  if (tmp == 16) {
#line 2711
    if (pm___0->log16 == (double )0) {
#line 2712
      return ((double )65536);
    }
#line 2714
    return ((double )pm___0->log16);
  }
#line 2720
  if (pm___0->log8 == (double )0) {
#line 2721
    return ((double )65536);
  }
#line 2723
  return ((double )(pm___0->log8 * (double )257));
}
}
#line 2731 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int output_quantization_factor(png_modifier const   *pm___0 , int in_depth ,
                                      int out_depth )
{


  {
#line 2734
  if (out_depth == 16) {
#line 2734
    if (in_depth != 16) {
#line 2734
      if (pm___0->calculations_use_input_precision) {
#line 2736
        return (257);
      } else {
#line 2738
        return (1);
      }
    } else {
#line 2738
      return (1);
    }
  } else {
#line 2738
    return (1);
  }
}
}
#line 2770 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void modification_reset(png_modification *pmm )
{


  {
#line 2773
  if ((unsigned long )pmm != (unsigned long )((void *)0)) {
#line 2775
    pmm->modified = 0U;
#line 2776
    pmm->added = 0U;
#line 2777
    pmm->removed = 0U;
#line 2778
    modification_reset(pmm->next);
  }
#line 2780
  return;
}
}
#line 2782 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void modification_init(png_modification *pmm )
{


  {
#line 2785
  memset((void *)pmm, 0, sizeof(*pmm));
#line 2786
  pmm->next = (struct png_modification *)((void *)0);
#line 2787
  pmm->chunk = (png_uint_32 )0;
#line 2788
  pmm->modify_fn = (int (*)(struct png_modifier *pm , struct png_modification *me ,
                            int add ))((void *)0);
#line 2789
  pmm->add = (png_uint_32 )0;
#line 2790
  modification_reset(pmm);
#line 2791
  return;
}
}
#line 2794 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void modifier_current_encoding(png_modifier const   *pm___0 , color_encoding *ce )
{


  {
#line 2797
  if ((unsigned long )pm___0->current_encoding != (unsigned long )((color_encoding const   *)0)) {
#line 2798
    *ce = (color_encoding )*(pm___0->current_encoding);
  } else {
#line 2801
    memset((void *)ce, 0, sizeof(*ce));
  }
#line 2803
  ce->gamma = (double )pm___0->current_gamma;
#line 2804
  return;
}
}
#line 2808 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static size_t safecat_current_encoding(char *buffer___0 , size_t bufsize , size_t pos ,
                                       png_modifier const   *pm___0 )
{


  {
#line 2812
  pos = safecat_color_encoding(buffer___0, bufsize, pos, (color_encoding const   *)pm___0->current_encoding,
                               (double )pm___0->current_gamma);
#line 2815
  if (pm___0->encoding_ignored) {
#line 2816
    pos = safecat(buffer___0, bufsize, pos, (char const   *)"[overridden]");
  }
#line 2818
  return (pos);
}
}
#line 2839 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static unsigned int modifier_total_encodings(png_modifier const   *pm___0 )
{
  unsigned int tmp ;

  {
#line 2842
  if ((int )pm___0->bit_depth == 16) {
#line 2842
    tmp = pm___0->nencodings;
  } else
#line 2842
  if (pm___0->assume_16_bit_calculations) {
#line 2842
    tmp = pm___0->nencodings;
  } else {
#line 2842
    tmp = (unsigned int )0;
  }
#line 2842
  return ((unsigned int )(((1U + pm___0->ngammas) + pm___0->nencodings) + tmp));
}
}
#line 2857 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void modifier_encoding_iterate(png_modifier *pm___0 )
{
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 2860
  if (! pm___0->repeat) {
#line 2860
    if (pm___0->test_uses_encoding) {
#line 2863
      if (pm___0->test_exhaustive) {
#line 2865
        (pm___0->encoding_counter) ++;
#line 2865
        tmp = modifier_total_encodings((png_modifier const   *)pm___0);
#line 2865
        if (pm___0->encoding_counter >= tmp) {
#line 2866
          pm___0->encoding_counter = 0U;
        }
      } else
#line 2874
      if (pm___0->encoding_counter == 0U) {
#line 2875
        tmp___0 = modifier_total_encodings((png_modifier const   *)pm___0);
#line 2875
        tmp___1 = random_mod(tmp___0 - 1U);
#line 2875
        pm___0->encoding_counter = tmp___1 + 1U;
      } else {
#line 2877
        pm___0->encoding_counter = 0U;
      }
#line 2880
      if (pm___0->encoding_counter > 0U) {
#line 2881
        pm___0->repeat = 1U;
      }
    } else {
#line 2860
      goto _L;
    }
  } else
  _L: /* CIL Label */
#line 2884
  if (! pm___0->repeat) {
#line 2885
    pm___0->encoding_counter = 0U;
  }
#line 2886
  return;
}
}
#line 2888 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void modifier_reset(png_modifier *pm___0 )
{
  png_uint_32 tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  png_byte tmp___2 ;

  {
#line 2891
  store_read_reset(& pm___0->this);
#line 2892
  pm___0->limit = 4E-3;
#line 2893
  tmp = (png_uint_32 )0;
#line 2893
  pm___0->pending_chunk = tmp;
#line 2893
  pm___0->pending_len = tmp;
#line 2894
  tmp___1 = (size_t )0;
#line 2894
  pm___0->buffer_position = tmp___1;
#line 2894
  tmp___0 = tmp___1;
#line 2894
  pm___0->buffer_count = tmp___0;
#line 2894
  pm___0->flush = tmp___0;
#line 2895
  pm___0->modifications = (struct png_modification *)((void *)0);
#line 2896
  pm___0->state = (modifier_state )0;
#line 2897
  modifier_encoding_iterate(pm___0);
#line 2902
  pm___0->test_uses_encoding = 0U;
#line 2903
  pm___0->current_gamma = (double )0;
#line 2904
  pm___0->current_encoding = (color_encoding const   *)0;
#line 2905
  pm___0->encoding_ignored = 0;
#line 2907
  tmp___2 = (png_byte )0;
#line 2907
  pm___0->colour_type = tmp___2;
#line 2907
  pm___0->bit_depth = tmp___2;
#line 2908
  return;
}
}
#line 2914 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void modifier_set_encoding(png_modifier *pm___0 )
{
  unsigned int i ;

  {
#line 2921
  pm___0->current_gamma = (double )0;
#line 2922
  pm___0->current_encoding = (color_encoding const   *)0;
#line 2923
  pm___0->encoding_ignored = 0;
#line 2926
  if (pm___0->encoding_counter > 0U) {
#line 2931
    if (pm___0->encoding_counter <= pm___0->ngammas) {
#line 2932
      pm___0->current_gamma = (double )1 / *(pm___0->gammas + (pm___0->encoding_counter - 1U));
    } else {
#line 2936
      i = pm___0->encoding_counter - pm___0->ngammas;
#line 2938
      if (i >= pm___0->nencodings) {
#line 2940
        i %= pm___0->nencodings;
#line 2941
        pm___0->current_gamma = (double )1;
      } else {
#line 2945
        pm___0->current_gamma = (double )(pm___0->encodings + i)->gamma;
      }
#line 2947
      pm___0->current_encoding = pm___0->encodings + i;
    }
  }
#line 2950
  return;
}
}
#line 2955 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int modifier_color_encoding_is_sRGB(png_modifier const   *pm___0 )
{
  int tmp ;

  {
#line 2958
  if ((unsigned long )pm___0->current_encoding != (unsigned long )((color_encoding const   *)0)) {
#line 2958
    if ((unsigned long )pm___0->current_encoding == (unsigned long )pm___0->encodings) {
#line 2958
      if ((pm___0->current_encoding)->gamma == pm___0->current_gamma) {
#line 2958
        tmp = 1;
      } else {
#line 2958
        tmp = 0;
      }
    } else {
#line 2958
      tmp = 0;
    }
  } else {
#line 2958
    tmp = 0;
  }
#line 2958
  return (tmp);
}
}
#line 2962 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int modifier_color_encoding_is_set(png_modifier const   *pm___0 )
{


  {
#line 2965
  return (pm___0->current_gamma != (double )0);
}
}
#line 2969 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void modifier_crc(png_bytep buffer___0 )
{
  uInt datalen ;
  uLong crc ;
  uLong tmp ;

  {
#line 2975
  datalen = ((((png_uint_32 )*buffer___0 << 24) + ((png_uint_32 )*(buffer___0 + 1) << 16)) + ((png_uint_32 )*(buffer___0 + 2) << 8)) + (png_uint_32 )*(buffer___0 + 3);
#line 2976
  tmp = crc32((uLong )0, (Bytef const   *)(buffer___0 + 4), datalen + 4U);
#line 2976
  crc = tmp;
#line 2979
  png_save_uint_32((buffer___0 + datalen) + 8, (png_uint_32 )crc);
#line 2980
  return;
}
}
#line 2982 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void modifier_setbuffer(png_modifier *pm___0 )
{


  {
#line 2985
  modifier_crc(pm___0->buffer);
#line 2986
  pm___0->buffer_count = (size_t )((((((png_uint_32 )pm___0->buffer[0] << 24) + ((png_uint_32 )*(pm___0->buffer + 1) << 16)) + ((png_uint_32 )*(pm___0->buffer + 2) << 8)) + (png_uint_32 )*(pm___0->buffer + 3)) + 12U);
#line 2987
  pm___0->buffer_position = (size_t )0;
#line 2988
  return;
}
}
#line 3005
static void modifier_read_imp(png_modifier *pm___0 , png_bytep pb , size_t st ) ;
#line 3005 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static png_byte sign[8]  =
#line 3005
  {      (png_byte )137,      (png_byte )80,      (png_byte )78,      (png_byte )71,
        (png_byte )13,      (png_byte )10,      (png_byte )26,      (png_byte )10};
#line 2994 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void modifier_read_imp(png_modifier *pm___0 , png_bytep pb , size_t st )
{
  size_t cb ;
  png_uint_32 len ;
  png_uint_32 chunk ;
  png_modification *mod ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t s ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 2997
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2997
    if (! (st > 0UL)) {
#line 2997
      goto while_break;
    }
#line 3003
    if (pm___0->buffer_position >= pm___0->buffer_count) {
      {
#line 3006
      if ((unsigned int )pm___0->state == 0U) {
#line 3006
        goto case_0;
      }
#line 3016
      if ((unsigned int )pm___0->state == 1U) {
#line 3016
        goto case_1;
      }
#line 3049
      goto switch_default;
      case_0: /* CIL Label */
#line 3007
      store_read_chunk(& pm___0->this, pm___0->buffer, (size_t )8, (size_t )8);
#line 3008
      pm___0->buffer_count = (size_t )8;
#line 3009
      pm___0->buffer_position = (size_t )0;
#line 3011
      tmp = memcmp((void const   *)(pm___0->buffer), (void const   *)(sign), (size_t )8);
#line 3011
      if (tmp != 0) {
#line 3012
        png_error((png_const_structrp )pm___0->this.pread, (png_const_charp )"invalid PNG file signature");
      }
#line 3013
      pm___0->state = (modifier_state )1;
#line 3014
      goto switch_break;
      case_1: /* CIL Label */
#line 3017
      store_read_chunk(& pm___0->this, pm___0->buffer, (size_t )25, (size_t )25);
#line 3018
      pm___0->buffer_count = (size_t )25;
#line 3019
      pm___0->buffer_position = (size_t )0;
#line 3021
      if (((((png_uint_32 )pm___0->buffer[0] << 24) + ((png_uint_32 )*(pm___0->buffer + 1) << 16)) + ((png_uint_32 )*(pm___0->buffer + 2) << 8)) + (png_uint_32 )*(pm___0->buffer + 3) != 13U) {
#line 3023
        png_error((png_const_structrp )pm___0->this.pread, (png_const_charp )"invalid IHDR");
      } else
#line 3021
      if (((((png_uint_32 )*(pm___0->buffer + 4) << 24) + ((png_uint_32 )*((pm___0->buffer + 4) + 1) << 16)) + ((png_uint_32 )*((pm___0->buffer + 4) + 2) << 8)) + (png_uint_32 )*((pm___0->buffer + 4) + 3) != (png_uint_32 )((((73 << 24) + (72 << 16)) + (68 << 8)) + 82)) {
#line 3023
        png_error((png_const_structrp )pm___0->this.pread, (png_const_charp )"invalid IHDR");
      }
#line 3026
      mod = pm___0->modifications;
      {
#line 3027
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3027
        if (! ((unsigned long )mod != (unsigned long )((void *)0))) {
#line 3027
          goto while_break___0;
        }
#line 3029
        if (mod->chunk == (png_uint_32 )((((73 << 24) + (72 << 16)) + (68 << 8)) + 82)) {
#line 3029
          if (mod->modify_fn) {
#line 3029
            tmp___0 = (*(mod->modify_fn))(pm___0, mod, 0);
#line 3029
            if (tmp___0) {
#line 3032
              mod->modified = 1U;
#line 3033
              modifier_setbuffer(pm___0);
            }
          }
        }
#line 3037
        mod = mod->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 3041
      pm___0->bit_depth = pm___0->buffer[16];
#line 3042
      pm___0->colour_type = pm___0->buffer[17];
#line 3044
      pm___0->state = (modifier_state )2;
#line 3045
      pm___0->flush = (size_t )0;
#line 3046
      goto switch_break;
      switch_default: /* CIL Label */
      case_2: /* CIL Label */
#line 3054
      cb = pm___0->flush;
#line 3054
      if (cb > 0UL) {
#line 3056
        if (cb > st) {
#line 3056
          cb = st;
        }
#line 3057
        pm___0->flush -= cb;
#line 3058
        store_read_chunk(& pm___0->this, pb, cb, cb);
#line 3059
        pb += cb;
#line 3060
        st -= cb;
#line 3061
        if (st == 0UL) {
#line 3061
          return;
        }
      }
#line 3067
      if (pm___0->pending_chunk != 0U) {
#line 3069
        png_save_uint_32(pm___0->buffer, pm___0->pending_len);
#line 3070
        png_save_uint_32(pm___0->buffer + 4, pm___0->pending_chunk);
#line 3071
        pm___0->pending_len = (png_uint_32 )0;
#line 3072
        pm___0->pending_chunk = (png_uint_32 )0;
      } else {
#line 3075
        store_read_chunk(& pm___0->this, pm___0->buffer, (size_t )8, (size_t )8);
      }
#line 3077
      pm___0->buffer_count = (size_t )8;
#line 3078
      pm___0->buffer_position = (size_t )0;
#line 3081
      len = ((((png_uint_32 )pm___0->buffer[0] << 24) + ((png_uint_32 )*(pm___0->buffer + 1) << 16)) + ((png_uint_32 )*(pm___0->buffer + 2) << 8)) + (png_uint_32 )*(pm___0->buffer + 3);
#line 3082
      chunk = ((((png_uint_32 )*(pm___0->buffer + 4) << 24) + ((png_uint_32 )*((pm___0->buffer + 4) + 1) << 16)) + ((png_uint_32 )*((pm___0->buffer + 4) + 2) << 8)) + (png_uint_32 )*((pm___0->buffer + 4) + 3);
#line 3087
      if (chunk == (png_uint_32 )((((80 << 24) + (76 << 16)) + (84 << 8)) + 69)) {
#line 3087
        goto _L___0;
      } else
#line 3087
      if (chunk == (png_uint_32 )((((73 << 24) + (68 << 16)) + (65 << 8)) + 84)) {
#line 3087
        goto _L___0;
      } else
#line 3087
      if (chunk == (png_uint_32 )((((73 << 24) + (69 << 16)) + (78 << 8)) + 68)) {
        _L___0: /* CIL Label */
#line 3090
        mod = pm___0->modifications;
        {
#line 3092
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 3092
          if (! ((unsigned long )mod != (unsigned long )((void *)0))) {
#line 3092
            goto while_break___1;
          }
#line 3094
          if (mod->add == chunk) {
#line 3094
            goto _L;
          } else
#line 3094
          if (mod->add == (png_uint_32 )((((80 << 24) + (76 << 16)) + (84 << 8)) + 69)) {
#line 3094
            if (chunk == (png_uint_32 )((((73 << 24) + (68 << 16)) + (65 << 8)) + 84)) {
              _L: /* CIL Label */
#line 3094
              if ((unsigned long )mod->modify_fn != (unsigned long )((void *)0)) {
#line 3094
                if (! mod->modified) {
#line 3094
                  if (! mod->added) {
#line 3101
                    mod->added = 1U;
#line 3103
                    tmp___1 = (*(mod->modify_fn))(pm___0, mod, 1);
#line 3103
                    if (tmp___1) {
#line 3106
                      if (pm___0->buffer_count > 0UL) {
#line 3107
                        modifier_setbuffer(pm___0);
                      } else {
#line 3111
                        pm___0->buffer_position = (size_t )0;
#line 3112
                        mod->removed = 1U;
                      }
#line 3118
                      pm___0->pending_len = len;
#line 3119
                      pm___0->pending_chunk = chunk;
#line 3120
                      goto while_break___1;
                    }
                  }
                }
              }
            }
          }
#line 3124
          mod = mod->next;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 3131
        if ((unsigned long )mod != (unsigned long )((void *)0)) {
#line 3132
          goto switch_break;
        }
      }
#line 3139
      if ((unsigned long )(len + 12U) <= sizeof(pm___0->buffer)) {
#line 3141
        s = (size_t )(len + 12U) - pm___0->buffer_count;
#line 3142
        store_read_chunk(& pm___0->this, pm___0->buffer + pm___0->buffer_count, s,
                         s);
#line 3143
        pm___0->buffer_count = (size_t )(len + 12U);
#line 3146
        mod = pm___0->modifications;
        {
#line 3147
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 3147
          if (! ((unsigned long )mod != (unsigned long )((void *)0))) {
#line 3147
            goto while_break___2;
          }
#line 3149
          if (mod->chunk == chunk) {
#line 3151
            if ((unsigned long )mod->modify_fn == (unsigned long )((void *)0)) {
#line 3154
              tmp___2 = (size_t )0;
#line 3154
              pm___0->buffer_position = tmp___2;
#line 3154
              pm___0->buffer_count = tmp___2;
#line 3155
              mod->removed = 1U;
#line 3156
              goto while_break___2;
            } else {
#line 3159
              tmp___3 = (*(mod->modify_fn))(pm___0, mod, 0);
#line 3159
              if (tmp___3) {
#line 3161
                mod->modified = 1U;
#line 3163
                if (pm___0->buffer_count == 0UL) {
#line 3165
                  pm___0->buffer_position = (size_t )0;
#line 3166
                  goto while_break___2;
                }
#line 3168
                modifier_setbuffer(pm___0);
              }
            }
          }
#line 3172
          mod = mod->next;
        }
        while_break___2: /* CIL Label */ ;
        }
      } else {
#line 3177
        pm___0->flush = (size_t )(len + 12U) - pm___0->buffer_count;
      }
#line 3180
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 3186
    cb = pm___0->buffer_count - pm___0->buffer_position;
#line 3188
    if (cb > st) {
#line 3189
      cb = st;
    }
#line 3191
    memcpy((void *)pb, (void const   *)(pm___0->buffer + pm___0->buffer_position),
           cb);
#line 3192
    st -= cb;
#line 3193
    pb += cb;
#line 3194
    pm___0->buffer_position += cb;
  }
  while_break: /* CIL Label */ ;
  }
#line 3196
  return;
}
}
#line 3199 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void modifier_read(png_structp ppIn , png_bytep pb , size_t st )
{
  png_const_structp pp ;
  png_modifier *pm___0 ;
  png_voidp tmp ;

  {
#line 3202
  pp = (png_const_structp )ppIn;
#line 3203
  tmp = png_get_io_ptr((png_const_structrp )pp);
#line 3203
  pm___0 = (png_modifier *)tmp;
#line 3205
  if ((unsigned long )pm___0 == (unsigned long )((void *)0)) {
#line 3206
    png_error((png_const_structrp )pp, (png_const_charp )"bad modifier_read call");
  } else
#line 3205
  if ((unsigned long )pm___0->this.pread != (unsigned long )pp) {
#line 3206
    png_error((png_const_structrp )pp, (png_const_charp )"bad modifier_read call");
  }
#line 3208
  modifier_read_imp(pm___0, pb, st);
#line 3209
  return;
}
}
#line 3229
static void modifier_progressive_read(png_modifier *pm___0 , png_structp pp , png_infop pi ) ;
#line 3229 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static png_uint_32 noise___0  =    (png_uint_32 )1;
#line 3214 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void modifier_progressive_read(png_modifier *pm___0 , png_structp pp , png_infop pi )
{
  size_t cb ;
  size_t cbAvail ;
  png_byte buffer___0[512] ;

  {
#line 3217
  if ((unsigned long )pm___0->this.pread != (unsigned long )pp) {
#line 3219
    png_error((png_const_structrp )pp, (png_const_charp )"store state damaged (progressive)");
  } else
#line 3217
  if ((unsigned long )pm___0->this.current == (unsigned long )((void *)0)) {
#line 3219
    png_error((png_const_structrp )pp, (png_const_charp )"store state damaged (progressive)");
  } else
#line 3217
  if ((unsigned long )pm___0->this.next == (unsigned long )((void *)0)) {
#line 3219
    png_error((png_const_structrp )pp, (png_const_charp )"store state damaged (progressive)");
  }
  {
#line 3227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3234
    noise___0 = (noise___0 << 9) | ((noise___0 ^ (noise___0 >> 4)) & 511U);
#line 3235
    cb = (size_t )(noise___0 & 511U);
#line 3242
    cbAvail = store_read_buffer_avail(& pm___0->this);
#line 3243
    if (pm___0->buffer_count > pm___0->buffer_position) {
#line 3244
      cbAvail += pm___0->buffer_count - pm___0->buffer_position;
    }
#line 3246
    if (cb > cbAvail) {
#line 3249
      if (cbAvail == 0UL) {
#line 3250
        goto while_break;
      }
#line 3252
      cb = cbAvail;
    }
#line 3255
    modifier_read_imp(pm___0, buffer___0, cb);
#line 3256
    png_process_data((png_structrp )pp, (png_inforp )pi, buffer___0, cb);
  }
  while_break: /* CIL Label */ ;
  }
#line 3262
  if (pm___0->buffer_count > pm___0->buffer_position) {
#line 3265
    png_error((png_const_structrp )pp, (png_const_charp )"progressive read implementation error");
  } else
#line 3262
  if ((unsigned long )pm___0->this.next != (unsigned long )(& (pm___0->this.current)->data)) {
#line 3265
    png_error((png_const_structrp )pp, (png_const_charp )"progressive read implementation error");
  } else
#line 3262
  if (pm___0->this.readpos < (pm___0->this.current)->datacount) {
#line 3265
    png_error((png_const_structrp )pp, (png_const_charp )"progressive read implementation error");
  }
#line 3266
  return;
}
}
#line 3269 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static png_structp set_modifier_for_read(png_modifier *pm___0 , png_infopp ppi , png_uint_32 id ,
                                         char const   *name )
{
  png_structp tmp ;

  {
#line 3277
  pm___0->state = (modifier_state )0;
#line 3278
  pm___0->bit_depth = (png_byte )0;
#line 3279
  pm___0->colour_type = (png_byte )255;
#line 3281
  pm___0->pending_len = (png_uint_32 )0;
#line 3282
  pm___0->pending_chunk = (png_uint_32 )0;
#line 3283
  pm___0->flush = (size_t )0;
#line 3284
  pm___0->buffer_count = (size_t )0;
#line 3285
  pm___0->buffer_position = (size_t )0;
#line 3287
  tmp = set_store_for_read(& pm___0->this, ppi, id, name);
#line 3287
  return (tmp);
}
}
#line 3302 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int gama_modify(png_modifier *pm___0 , png_modification *me , int add )
{


  {
#line 3307
  png_save_uint_32(pm___0->buffer, (png_uint_32 )4);
#line 3308
  png_save_uint_32(pm___0->buffer + 4, (png_uint_32 )((((103 << 24) + (65 << 16)) + (77 << 8)) + 65));
#line 3309
  png_save_uint_32(pm___0->buffer + 8, (png_uint_32 )((gama_modification *)me)->gamma);
#line 3310
  return (1);
}
}
#line 3313 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void gama_modification_init(gama_modification *me , png_modifier *pm___0 ,
                                   double gammad )
{
  double g ;
  png_fixed_point tmp ;

  {
#line 3318
  modification_init(& me->this);
#line 3319
  me->this.chunk = (png_uint_32 )((((103 << 24) + (65 << 16)) + (77 << 8)) + 65);
#line 3320
  me->this.modify_fn = & gama_modify;
#line 3321
  me->this.add = (png_uint_32 )((((80 << 24) + (76 << 16)) + (84 << 8)) + 69);
#line 3322
  tmp = fix(gammad);
#line 3322
  g = (double )tmp;
#line 3323
  me->gamma = (png_fixed_point )g;
#line 3324
  me->this.next = pm___0->modifications;
#line 3325
  pm___0->modifications = & me->this;
#line 3326
  return;
}
}
#line 3335 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int chrm_modify(png_modifier *pm___0 , png_modification *me , int add )
{


  {
#line 3340
  png_save_uint_32(pm___0->buffer, (png_uint_32 )32);
#line 3341
  png_save_uint_32(pm___0->buffer + 4, (png_uint_32 )((((99 << 24) + (72 << 16)) + (82 << 8)) + 77));
#line 3342
  png_save_uint_32(pm___0->buffer + 8, (png_uint_32 )((chrm_modification *)me)->wx);
#line 3343
  png_save_uint_32(pm___0->buffer + 12, (png_uint_32 )((chrm_modification *)me)->wy);
#line 3344
  png_save_uint_32(pm___0->buffer + 16, (png_uint_32 )((chrm_modification *)me)->rx);
#line 3345
  png_save_uint_32(pm___0->buffer + 20, (png_uint_32 )((chrm_modification *)me)->ry);
#line 3346
  png_save_uint_32(pm___0->buffer + 24, (png_uint_32 )((chrm_modification *)me)->gx);
#line 3347
  png_save_uint_32(pm___0->buffer + 28, (png_uint_32 )((chrm_modification *)me)->gy);
#line 3348
  png_save_uint_32(pm___0->buffer + 32, (png_uint_32 )((chrm_modification *)me)->bx);
#line 3349
  png_save_uint_32(pm___0->buffer + 36, (png_uint_32 )((chrm_modification *)me)->by);
#line 3350
  return (1);
}
}
#line 3353 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void chrm_modification_init(chrm_modification *me , png_modifier *pm___0 ,
                                   color_encoding const   *encoding )
{
  CIE_color white ;
  CIE_color tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;

  {
#line 3357
  tmp = white_point(encoding);
#line 3357
  white = tmp;
#line 3360
  me->encoding = encoding;
#line 3363
  tmp___0 = chromaticity_x(white);
#line 3363
  me->wx = fix(tmp___0);
#line 3364
  tmp___1 = chromaticity_y(white);
#line 3364
  me->wy = fix(tmp___1);
#line 3366
  tmp___2 = chromaticity_x((CIE_color )encoding->red);
#line 3366
  me->rx = fix(tmp___2);
#line 3367
  tmp___3 = chromaticity_y((CIE_color )encoding->red);
#line 3367
  me->ry = fix(tmp___3);
#line 3368
  tmp___4 = chromaticity_x((CIE_color )encoding->green);
#line 3368
  me->gx = fix(tmp___4);
#line 3369
  tmp___5 = chromaticity_y((CIE_color )encoding->green);
#line 3369
  me->gy = fix(tmp___5);
#line 3370
  tmp___6 = chromaticity_x((CIE_color )encoding->blue);
#line 3370
  me->bx = fix(tmp___6);
#line 3371
  tmp___7 = chromaticity_y((CIE_color )encoding->blue);
#line 3371
  me->by = fix(tmp___7);
#line 3373
  modification_init(& me->this);
#line 3374
  me->this.chunk = (png_uint_32 )((((99 << 24) + (72 << 16)) + (82 << 8)) + 77);
#line 3375
  me->this.modify_fn = & chrm_modify;
#line 3376
  me->this.add = (png_uint_32 )((((80 << 24) + (76 << 16)) + (84 << 8)) + 69);
#line 3377
  me->this.next = pm___0->modifications;
#line 3378
  pm___0->modifications = & me->this;
#line 3379
  return;
}
}
#line 3387 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int srgb_modify(png_modifier *pm___0 , png_modification *me , int add )
{


  {
#line 3392
  png_save_uint_32(pm___0->buffer, (png_uint_32 )1);
#line 3393
  png_save_uint_32(pm___0->buffer + 4, (png_uint_32 )((((115 << 24) + (82 << 16)) + (71 << 8)) + 66));
#line 3394
  pm___0->buffer[8] = ((srgb_modification *)me)->intent;
#line 3395
  return (1);
}
}
#line 3398 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void srgb_modification_init(srgb_modification *me , png_modifier *pm___0 ,
                                   png_byte intent )
{


  {
#line 3401
  modification_init(& me->this);
#line 3402
  me->this.chunk = (png_uint_32 )((((115 << 24) + (66 << 16)) + (73 << 8)) + 84);
#line 3404
  if ((int )intent <= 3) {
#line 3406
    me->this.modify_fn = & srgb_modify;
#line 3407
    me->this.add = (png_uint_32 )((((80 << 24) + (76 << 16)) + (84 << 8)) + 69);
#line 3408
    me->intent = intent;
  } else {
#line 3413
    me->this.modify_fn = (int (*)(struct png_modifier *pm , struct png_modification *me ,
                                  int add ))0;
#line 3414
    me->this.add = (png_uint_32 )0;
#line 3415
    me->intent = (png_byte )0;
  }
#line 3418
  me->this.next = pm___0->modifications;
#line 3419
  pm___0->modifications = & me->this;
#line 3420
  return;
}
}
#line 3429 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int sbit_modify(png_modifier *pm___0 , png_modification *me , int add )
{
  png_byte sbit ;
  int cb ;
  size_t tmp ;

  {
#line 3432
  sbit = ((sbit_modification *)me)->sbit;
#line 3433
  if ((int )pm___0->bit_depth > (int )sbit) {
#line 3435
    cb = 0;
    {
#line 3438
    if ((int )pm___0->colour_type == 0) {
#line 3438
      goto case_0;
    }
#line 3443
    if ((int )pm___0->colour_type == 3) {
#line 3443
      goto case_3;
    }
#line 3443
    if ((int )pm___0->colour_type == 2) {
#line 3443
      goto case_3;
    }
#line 3447
    if ((int )pm___0->colour_type == 4) {
#line 3447
      goto case_4;
    }
#line 3451
    if ((int )pm___0->colour_type == 6) {
#line 3451
      goto case_6;
    }
#line 3455
    goto switch_default;
    case_0: /* CIL Label */
#line 3439
    cb = 1;
#line 3440
    goto switch_break;
    case_3: /* CIL Label */
    case_2: /* CIL Label */
#line 3444
    cb = 3;
#line 3445
    goto switch_break;
    case_4: /* CIL Label */
#line 3448
    cb = 2;
#line 3449
    goto switch_break;
    case_6: /* CIL Label */
#line 3452
    cb = 4;
#line 3453
    goto switch_break;
    switch_default: /* CIL Label */
#line 3456
    png_error((png_const_structrp )pm___0->this.pread, (png_const_charp )"unexpected colour type in sBIT modification");
    switch_break: /* CIL Label */ ;
    }
#line 3460
    png_save_uint_32(pm___0->buffer, (png_uint_32 )cb);
#line 3461
    png_save_uint_32(pm___0->buffer + 4, (png_uint_32 )((((115 << 24) + (66 << 16)) + (73 << 8)) + 84));
    {
#line 3463
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3463
      if (! (cb > 0)) {
#line 3463
        goto while_break;
      }
#line 3464
      cb --;
#line 3464
      *((pm___0->buffer + 8) + cb) = sbit;
    }
    while_break: /* CIL Label */ ;
    }
#line 3466
    return (1);
  } else
#line 3468
  if (! add) {
#line 3471
    tmp = (size_t )0;
#line 3471
    pm___0->buffer_position = tmp;
#line 3471
    pm___0->buffer_count = tmp;
#line 3472
    return (1);
  } else {
#line 3475
    return (0);
  }
}
}
#line 3478 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void sbit_modification_init(sbit_modification *me , png_modifier *pm___0 ,
                                   png_byte sbit )
{


  {
#line 3481
  modification_init(& me->this);
#line 3482
  me->this.chunk = (png_uint_32 )((((115 << 24) + (66 << 16)) + (73 << 8)) + 84);
#line 3483
  me->this.modify_fn = & sbit_modify;
#line 3484
  me->this.add = (png_uint_32 )((((80 << 24) + (76 << 16)) + (84 << 8)) + 69);
#line 3485
  me->sbit = sbit;
#line 3486
  me->this.next = pm___0->modifications;
#line 3487
  pm___0->modifications = & me->this;
#line 3488
  return;
}
}
#line 3548
static store_palette_entry *make_standard_palette(png_store *ps , int npalette , int do_tRNS ) ;
#line 3548 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static png_uint_32 palette_seed[2]  = {      0x87654321,      (png_uint_32 )9};
#line 3545 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static store_palette_entry *make_standard_palette(png_store *ps , int npalette , int do_tRNS )
{
  int i ;
  png_byte values[256][4] ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  int j ;
  png_byte random_bytes[4] ;
  png_byte need[256] ;
  png_byte b ;
  int tmp___2 ;
  store_palette_entry *palette ;
  png_byte selector[4] ;

  {
#line 3550
  i = 0;
  {
#line 3555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3555
    if (! (i < 8)) {
#line 3555
      goto while_break;
    }
#line 3557
    if (i & 1) {
#line 3557
      tmp = 255U;
    } else {
#line 3557
      tmp = 0U;
    }
#line 3557
    values[i][1] = (png_byte )tmp;
#line 3558
    if (i & 2) {
#line 3558
      tmp___0 = 255U;
    } else {
#line 3558
      tmp___0 = 0U;
    }
#line 3558
    values[i][2] = (png_byte )tmp___0;
#line 3559
    if (i & 4) {
#line 3559
      tmp___1 = 255U;
    } else {
#line 3559
      tmp___1 = 0U;
    }
#line 3559
    values[i][3] = (png_byte )tmp___1;
#line 3555
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3564
  j = 0;
#line 3568
  need[0] = (png_byte )0;
#line 3569
  memset((void *)(need + 1), 1, sizeof(need) - 2UL);
#line 3570
  need[255] = (png_byte )0;
  {
#line 3572
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3572
    if (! (i < 70)) {
#line 3572
      goto while_break___0;
    }
#line 3576
    if (j == 0) {
#line 3578
      make_four_random_bytes(palette_seed, random_bytes);
#line 3579
      j = 4;
    }
#line 3582
    j --;
#line 3582
    b = random_bytes[j];
#line 3583
    if (need[b]) {
#line 3585
      values[i][1] = b;
#line 3586
      values[i][2] = b;
#line 3587
      tmp___2 = i;
#line 3587
      i ++;
#line 3587
      values[tmp___2][3] = b;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3597
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3597
    if (! (i < 256)) {
#line 3597
      goto while_break___1;
    }
#line 3598
    make_four_random_bytes(palette_seed, values[i]);
#line 3597
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3607
  make_four_random_bytes(palette_seed, selector);
#line 3609
  if (do_tRNS) {
#line 3610
    i = 0;
    {
#line 3610
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3610
      if (! (i < 256)) {
#line 3610
        goto while_break___2;
      }
#line 3611
      values[i][0] = (png_byte )(i ^ (int )selector[0]);
#line 3610
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
#line 3614
    i = 0;
    {
#line 3614
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 3614
      if (! (i < 256)) {
#line 3614
        goto while_break___3;
      }
#line 3615
      values[i][0] = (png_byte )255;
#line 3614
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 3626
  palette = store_write_palette(ps, npalette);
#line 3628
  i = 0;
  {
#line 3628
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 3628
    if (! (i < npalette)) {
#line 3628
      goto while_break___4;
    }
#line 3630
    (palette + i)->alpha = values[i ^ (int )selector[1]][0];
#line 3631
    (palette + i)->red = values[i ^ (int )selector[1]][1];
#line 3632
    (palette + i)->green = values[i ^ (int )selector[1]][2];
#line 3633
    (palette + i)->blue = values[i ^ (int )selector[1]][3];
#line 3628
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 3636
  return (palette);
}
}
#line 3644 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void init_standard_palette(png_store *ps , png_structp pp , png_infop pi ,
                                  int npalette , int do_tRNS )
{
  store_palette_entry *ppal ;
  store_palette_entry *tmp ;
  int i ;
  png_color palette[256] ;
  png_byte tmp___0 ;
  png_byte tmp___1 ;
  int i___0 ;
  int j ;
  png_byte tRNS[256] ;
  png_byte tmp___2 ;

  {
#line 3648
  tmp = make_standard_palette(ps, npalette, do_tRNS);
#line 3648
  ppal = tmp;
#line 3655
  i = 0;
  {
#line 3655
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3655
    if (! (i < npalette)) {
#line 3655
      goto while_break;
    }
#line 3657
    palette[i].red = (ppal + i)->red;
#line 3658
    palette[i].green = (ppal + i)->green;
#line 3659
    palette[i].blue = (ppal + i)->blue;
#line 3655
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3663
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3663
    if (! (i < 256)) {
#line 3663
      goto while_break___0;
    }
#line 3664
    tmp___1 = (png_byte )42;
#line 3664
    palette[i].blue = tmp___1;
#line 3664
    tmp___0 = tmp___1;
#line 3664
    palette[i].green = tmp___0;
#line 3664
    palette[i].red = tmp___0;
#line 3663
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3666
  png_set_PLTE((png_structrp )pp, (png_inforp )pi, (png_const_colorp )(palette), npalette);
#line 3669
  if (do_tRNS) {
#line 3675
    j = 0;
#line 3675
    i___0 = j;
    {
#line 3675
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3675
      if (! (i___0 < npalette)) {
#line 3675
        goto while_break___1;
      }
#line 3676
      tmp___2 = (ppal + i___0)->alpha;
#line 3676
      tRNS[i___0] = tmp___2;
#line 3676
      if ((int )tmp___2 < 255) {
#line 3677
        j = i___0 + 1;
      }
#line 3675
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 3680
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3680
      if (! (i___0 < 256)) {
#line 3680
        goto while_break___2;
      }
#line 3681
      tRNS[i___0] = (png_byte )24;
#line 3680
      i___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 3684
    if (j > 0) {
#line 3685
      png_set_tRNS((png_structrp )pp, (png_inforp )pi, (png_const_bytep )(tRNS), j,
                   (png_const_color_16p )0);
    }
  }
#line 3688
  return;
}
}
#line 3691 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void set_random_tRNS(png_structp pp , png_infop pi , png_byte colour_type ,
                            int bit_depth )
{
  png_color_16 tRNS ;
  png_uint_16 mask ;

  {
#line 3701
  mask = (png_uint_16 )((1U << bit_depth) - 1U);
#line 3703
  randomize((void *)(& tRNS), sizeof(tRNS));
#line 3705
  if ((int )colour_type & 2) {
#line 3707
    if (bit_depth == 8) {
#line 3709
      tRNS.red = random_u16();
#line 3710
      tRNS.green = random_u16();
#line 3711
      tRNS.blue = (png_uint_16 )((int )tRNS.red ^ (int )tRNS.green);
#line 3712
      tRNS.red = (png_uint_16 )((int )tRNS.red & (int )mask);
#line 3713
      tRNS.green = (png_uint_16 )((int )tRNS.green & (int )mask);
#line 3714
      tRNS.blue = (png_uint_16 )((int )tRNS.blue & (int )mask);
    } else {
#line 3719
      tRNS.red = random_u16();
#line 3720
      tRNS.green = (png_uint_16 )((int )tRNS.red * 257);
#line 3721
      tRNS.blue = (png_uint_16 )((int )tRNS.green * 17);
    }
  } else {
#line 3727
    tRNS.gray = random_u16();
#line 3728
    tRNS.gray = (png_uint_16 )((int )tRNS.gray & (int )mask);
  }
#line 3731
  png_set_tRNS((png_structrp )pp, (png_inforp )pi, (png_const_bytep )((void *)0),
               0, (png_const_color_16p )(& tRNS));
#line 3732
  return;
}
}
#line 3738 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int npasses_from_interlace_type(png_const_structp pp , int interlace_type )
{


  {
  {
#line 3746
  if (interlace_type == 0) {
#line 3746
    goto case_0;
  }
#line 3749
  if (interlace_type == 1) {
#line 3749
    goto case_1;
  }
#line 3743
  goto switch_default;
  switch_default: /* CIL Label */
#line 3744
  png_error((png_const_structrp )pp, (png_const_charp )"invalid interlace type");
  case_0: /* CIL Label */
#line 3747
  return (1);
  case_1: /* CIL Label */
#line 3750
  return (7);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 3754 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static unsigned int bit_size(png_const_structp pp , png_byte colour_type , png_byte bit_depth )
{


  {
  {
#line 3761
  if ((int )colour_type == 0) {
#line 3761
    goto case_0;
  }
#line 3763
  if ((int )colour_type == 2) {
#line 3763
    goto case_2;
  }
#line 3765
  if ((int )colour_type == 3) {
#line 3765
    goto case_3;
  }
#line 3767
  if ((int )colour_type == 4) {
#line 3767
    goto case_4;
  }
#line 3769
  if ((int )colour_type == 6) {
#line 3769
    goto case_6;
  }
#line 3759
  goto switch_default;
  switch_default: /* CIL Label */
#line 3759
  png_error((png_const_structrp )pp, (png_const_charp )"invalid color type");
  case_0: /* CIL Label */
#line 3761
  return ((unsigned int )bit_depth);
  case_2: /* CIL Label */
#line 3763
  return ((unsigned int )(3 * (int )bit_depth));
  case_3: /* CIL Label */
#line 3765
  return ((unsigned int )bit_depth);
  case_4: /* CIL Label */
#line 3767
  return ((unsigned int )(2 * (int )bit_depth));
  case_6: /* CIL Label */
#line 3769
  return ((unsigned int )(4 * (int )bit_depth));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 3779 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static size_t transform_rowsize(png_const_structp pp , png_byte colour_type , png_byte bit_depth )
{
  unsigned int tmp ;

  {
#line 3783
  tmp = bit_size(pp, colour_type, bit_depth);
#line 3783
  return ((size_t )((128U * tmp) / 8U));
}
}
#line 3791 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static png_uint_32 transform_height(png_const_structp pp , png_byte colour_type ,
                                    png_byte bit_depth )
{
  unsigned int tmp ;

  {
#line 3794
  tmp = bit_size(pp, colour_type, bit_depth);
  {
#line 3798
  if (tmp == 4U) {
#line 3798
    goto case_4;
  }
#line 3798
  if (tmp == 2U) {
#line 3798
    goto case_4;
  }
#line 3798
  if (tmp == 1U) {
#line 3798
    goto case_4;
  }
#line 3801
  if (tmp == 8U) {
#line 3801
    goto case_8;
  }
#line 3804
  if (tmp == 16U) {
#line 3804
    goto case_16;
  }
#line 3808
  if (tmp == 32U) {
#line 3808
    goto case_32;
  }
#line 3808
  if (tmp == 24U) {
#line 3808
    goto case_32;
  }
#line 3812
  if (tmp == 64U) {
#line 3812
    goto case_64;
  }
#line 3812
  if (tmp == 48U) {
#line 3812
    goto case_64;
  }
#line 3816
  goto switch_default;
  case_4: /* CIL Label */
  case_2: /* CIL Label */
  case_1: /* CIL Label */
#line 3799
  return ((png_uint_32 )1);
  case_8: /* CIL Label */
#line 3802
  return ((png_uint_32 )2);
  case_16: /* CIL Label */
#line 3805
  return ((png_uint_32 )512);
  case_32: /* CIL Label */
  case_24: /* CIL Label */
#line 3809
  return ((png_uint_32 )512);
  case_64: /* CIL Label */
  case_48: /* CIL Label */
#line 3813
  return ((png_uint_32 )2048);
  switch_default: /* CIL Label */
#line 3817
  return ((png_uint_32 )0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 3825 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static png_uint_32 standard_width(png_const_structp pp , png_uint_32 id )
{
  png_uint_32 width ;

  {
#line 3828
  width = (id >> 16) & 255U;
#line 3831
  if (width == 0U) {
#line 3832
    width = 128U;
  }
#line 3834
  return (width);
}
}
#line 3837 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static png_uint_32 standard_height(png_const_structp pp , png_uint_32 id )
{
  png_uint_32 height ;

  {
#line 3840
  height = (id >> 24) & 255U;
#line 3842
  if (height == 0U) {
#line 3843
    height = transform_height(pp, (png_byte )(id & 0x7U), (png_byte )((id >> 3) & 0x1fU));
  }
#line 3845
  return (height);
}
}
#line 3848 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static png_uint_32 standard_rowsize(png_const_structp pp , png_uint_32 id )
{
  png_uint_32 width ;
  png_uint_32 tmp ;
  unsigned int tmp___0 ;

  {
#line 3851
  tmp = standard_width(pp, id);
#line 3851
  width = tmp;
#line 3854
  tmp___0 = bit_size(pp, (png_byte )(id & 0x7U), (png_byte )((id >> 3) & 0x1fU));
#line 3854
  width *= tmp___0;
#line 3855
  return ((width + 7U) / 8U);
}
}
#line 3859 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void transform_row(png_const_structp pp , png_byte *buffer___0 , png_byte colour_type ,
                          png_byte bit_depth , png_uint_32 y )
{
  png_uint_32 v ;
  png_uint_32 i ;
  unsigned int tmp ;
  png_uint_32 t ;
  png_uint_32 tmp___0 ;
  png_uint_32 t___0 ;
  png_uint_32 tmp___1 ;

  {
#line 3863
  v = y << 7;
#line 3864
  i = (png_uint_32 )0;
#line 3866
  tmp = bit_size(pp, colour_type, bit_depth);
  {
#line 3868
  if (tmp == 1U) {
#line 3868
    goto case_1;
  }
#line 3872
  if (tmp == 2U) {
#line 3872
    goto case_2;
  }
#line 3876
  if (tmp == 4U) {
#line 3876
    goto case_4;
  }
#line 3880
  if (tmp == 8U) {
#line 3880
    goto case_8;
  }
#line 3885
  if (tmp == 16U) {
#line 3885
    goto case_16;
  }
#line 3899
  if (tmp == 24U) {
#line 3899
    goto case_24;
  }
#line 3913
  if (tmp == 32U) {
#line 3913
    goto case_32;
  }
#line 3927
  if (tmp == 48U) {
#line 3927
    goto case_48;
  }
#line 3947
  if (tmp == 64U) {
#line 3947
    goto case_64;
  }
#line 3965
  goto switch_default;
  case_1: /* CIL Label */
  {
#line 3869
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3869
    if (! (i < 16U)) {
#line 3869
      goto while_break;
    }
#line 3869
    *(buffer___0 + i) = (png_byte )(v & 255U);
#line 3869
    v += 17U;
#line 3869
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3870
  return;
  case_2: /* CIL Label */
  {
#line 3873
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3873
    if (! (i < 32U)) {
#line 3873
      goto while_break___0;
    }
#line 3873
    *(buffer___0 + i) = (png_byte )(v & 255U);
#line 3873
    v += 33U;
#line 3873
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3874
  return;
  case_4: /* CIL Label */
  {
#line 3877
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3877
    if (! (i < 64U)) {
#line 3877
      goto while_break___1;
    }
#line 3877
    *(buffer___0 + i) = (png_byte )(v & 255U);
#line 3877
    v += 65U;
#line 3877
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3878
  return;
  case_8: /* CIL Label */
  {
#line 3882
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3882
    if (! (i < 128U)) {
#line 3882
      goto while_break___2;
    }
#line 3882
    *(buffer___0 + i) = (png_byte )(v & 255U);
#line 3882
    v ++;
#line 3882
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3883
  return;
  case_16: /* CIL Label */
  {
#line 3889
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 3889
    if (! (i < 128U)) {
#line 3889
      goto while_break___3;
    }
#line 3891
    *(buffer___0 + 2U * i) = (png_byte )((v >> 8) & 255U);
#line 3892
    *(buffer___0 + (2U * i + 1U)) = (png_byte )(v & 255U);
#line 3893
    v ++;
#line 3894
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 3897
  return;
  case_24: /* CIL Label */
  {
#line 3901
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 3901
    if (! (i < 128U)) {
#line 3901
      goto while_break___4;
    }
#line 3904
    *(buffer___0 + 3U * i) = (png_byte )((v >> 8) & 255U);
#line 3905
    *(buffer___0 + (3U * i + 1U)) = (png_byte )(v & 255U);
#line 3906
    *(buffer___0 + (3U * i + 2U)) = (png_byte )(((v >> 8) ^ v) & 255U);
#line 3907
    v ++;
#line 3908
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 3911
  return;
  case_32: /* CIL Label */
  {
#line 3915
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 3915
    if (! (i < 128U)) {
#line 3915
      goto while_break___5;
    }
#line 3917
    *(buffer___0 + 4U * i) = (png_byte )((v >> 8) & 255U);
#line 3918
    *(buffer___0 + (4U * i + 1U)) = (png_byte )(v & 255U);
#line 3919
    *(buffer___0 + (4U * i + 2U)) = (png_byte )((v >> 8) & 255U);
#line 3920
    *(buffer___0 + (4U * i + 3U)) = (png_byte )(v & 255U);
#line 3921
    v ++;
#line 3922
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 3925
  return;
  case_48: /* CIL Label */
  {
#line 3931
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 3931
    if (! (i < 128U)) {
#line 3931
      goto while_break___6;
    }
#line 3933
    tmp___0 = v;
#line 3933
    v ++;
#line 3933
    t = tmp___0;
#line 3934
    *(buffer___0 + 6U * i) = (png_byte )((t >> 8) & 255U);
#line 3935
    *(buffer___0 + (6U * i + 1U)) = (png_byte )(t & 255U);
#line 3936
    t *= 257U;
#line 3937
    *(buffer___0 + (6U * i + 2U)) = (png_byte )((t >> 8) & 255U);
#line 3938
    *(buffer___0 + (6U * i + 3U)) = (png_byte )(t & 255U);
#line 3939
    t *= 17U;
#line 3940
    *(buffer___0 + (6U * i + 4U)) = (png_byte )((t >> 8) & 255U);
#line 3941
    *(buffer___0 + (6U * i + 5U)) = (png_byte )(t & 255U);
#line 3942
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 3945
  return;
  case_64: /* CIL Label */
  {
#line 3949
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 3949
    if (! (i < 128U)) {
#line 3949
      goto while_break___7;
    }
#line 3951
    tmp___1 = v;
#line 3951
    v ++;
#line 3951
    t___0 = tmp___1;
#line 3952
    *(buffer___0 + 8U * i) = (png_byte )((t___0 >> 8) & 255U);
#line 3953
    *(buffer___0 + (8U * i + 1U)) = (png_byte )(t___0 & 255U);
#line 3954
    *(buffer___0 + (8U * i + 4U)) = (png_byte )((t___0 >> 8) & 255U);
#line 3955
    *(buffer___0 + (8U * i + 5U)) = (png_byte )(t___0 & 255U);
#line 3956
    t___0 *= 257U;
#line 3957
    *(buffer___0 + (8U * i + 2U)) = (png_byte )((t___0 >> 8) & 255U);
#line 3958
    *(buffer___0 + (8U * i + 3U)) = (png_byte )(t___0 & 255U);
#line 3959
    *(buffer___0 + (8U * i + 6U)) = (png_byte )((t___0 >> 8) & 255U);
#line 3960
    *(buffer___0 + (8U * i + 7U)) = (png_byte )(t___0 & 255U);
#line 3961
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 3963
  return;
  switch_default: /* CIL Label */
#line 3966
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3969
  png_error((png_const_structrp )pp, (png_const_charp )"internal error");
}
}
#line 4031 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void interlace_row(png_bytep buffer___0 , png_const_bytep imageRow , unsigned int pixel_size ,
                          png_uint_32 w , int pass , int littleendian )
{
  png_uint_32 xin ;
  png_uint_32 xout ;
  png_uint_32 xstep ;
  int tmp ;

  {
#line 4044
  xin = (png_uint_32 )(((1 & pass) << (3 - ((pass + 1) >> 1))) & 7);
#line 4045
  if (pass > 1) {
#line 4045
    tmp = (7 - pass) >> 1;
  } else {
#line 4045
    tmp = 3;
  }
#line 4045
  xstep = 1U << tmp;
#line 4047
  xout = (png_uint_32 )0;
  {
#line 4047
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4047
    if (! (xin < w)) {
#line 4047
      goto while_break;
    }
#line 4049
    pixel_copy(buffer___0, xout, imageRow, xin, pixel_size, littleendian);
#line 4050
    xout ++;
#line 4047
    xin += xstep;
  }
  while_break: /* CIL Label */ ;
  }
#line 4052
  return;
}
}
#line 4055 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void deinterlace_row(png_bytep buffer___0 , png_const_bytep row , unsigned int pixel_size ,
                            png_uint_32 w , int pass , int littleendian )
{
  png_uint_32 xin ;
  png_uint_32 xout ;
  png_uint_32 xstep ;
  int tmp ;

  {
#line 4066
  xout = (png_uint_32 )(((1 & pass) << (3 - ((pass + 1) >> 1))) & 7);
#line 4067
  if (pass > 1) {
#line 4067
    tmp = (7 - pass) >> 1;
  } else {
#line 4067
    tmp = 3;
  }
#line 4067
  xstep = 1U << tmp;
#line 4069
  xin = (png_uint_32 )0;
  {
#line 4069
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4069
    if (! (xout < w)) {
#line 4069
      goto while_break;
    }
#line 4071
    pixel_copy(buffer___0, xout, row, xin, pixel_size, littleendian);
#line 4072
    xin ++;
#line 4069
    xout += xstep;
  }
  while_break: /* CIL Label */ ;
  }
#line 4074
  return;
}
}
#line 4084 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void choose_random_filter(png_structp pp , int start )
{
  int filters ;
  unsigned int tmp ;

  {
#line 4090
  tmp = random_mod(256U);
#line 4090
  filters = (int )(248U & tmp);
#line 4093
  if (filters != 0) {
#line 4095
    if (start) {
#line 4095
      if (filters < 0x20) {
#line 4096
        filters |= 0x20;
      }
    }
#line 4098
    png_set_filter((png_structrp )pp, 0, filters);
  }
#line 4100
  return;
}
}
#line 4140
static void make_transform_image(png_store *ps , png_byte const   colour_type , png_byte const   bit_depth ,
                                 unsigned int palette_number , int interlace_type ,
                                 png_const_charp name ) ;
#line 4140 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static char key[11]  =
#line 4140
  {      (char )'i',      (char )'m',      (char )'a',      (char )'g',
        (char )'e',      (char )' ',      (char )'n',      (char )'a',
        (char )'m',      (char )'e',      (char )'\000'};
#line 4231 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static char key___0[11]  =
#line 4231
  {      (char )'e',      (char )'n',      (char )'d',      (char )' ',
        (char )'m',      (char )'a',      (char )'r',      (char )'k',
        (char )'e',      (char )'r',      (char )'\000'};
#line 4232 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static char comment[4]  = {      (char )'e',      (char )'n',      (char )'d',      (char )'\000'};
#line 4105 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void make_transform_image(png_store *ps , png_byte const   colour_type , png_byte const   bit_depth ,
                                 unsigned int palette_number , int interlace_type ,
                                 png_const_charp name )
{
  struct exception_context *the_exception_context ;
  png_store *fault ;
  jmp_buf *exception__prev ;
  jmp_buf exception__env ;
  png_infop pi ;
  png_structp pp ;
  png_structp tmp ;
  png_uint_32 h ;
  png_uint_32 w ;
  size_t pos ;
  png_text text ;
  char copy[64] ;
  int npasses ;
  int tmp___0 ;
  int pass ;
  int tmp___1 ;
  png_uint_32 y ;
  png_byte buffer___0[1024U] ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  png_text text___0 ;
  int tmp___5 ;

  {
#line 4110
  the_exception_context = & ps->exception_context;
#line 4114
  exception__prev = the_exception_context->penv;
#line 4114
  the_exception_context->penv = & exception__env;
#line 4114
  tmp___5 = _setjmp((struct __jmp_buf_tag *)(exception__env));
#line 4114
  if (tmp___5 == 0) {
    {
#line 4114
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4117
      tmp = set_store_for_write((png_store *)ps, & pi, name);
#line 4117
      pp = tmp;
#line 4124
      if ((unsigned long )pp == (unsigned long )((void *)0)) {
        {
#line 4125
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 4125
          the_exception_context->v.etmp = (struct png_store * volatile  )ps;
#line 4125
          longjmp((struct __jmp_buf_tag *)(*(the_exception_context->penv)), 1);
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 4127
      w = 128U;
#line 4128
      h = transform_height((png_const_structp )pp, (png_byte )colour_type, (png_byte )bit_depth);
#line 4130
      png_set_IHDR((png_const_structrp )pp, (png_inforp )pi, w, h, (int )bit_depth,
                   (int )colour_type, interlace_type, 0, 0);
#line 4148
      text.compression = 0;
#line 4149
      text.key = key;
#line 4151
      pos = safecat(copy, sizeof(copy), (size_t )0, (char const   *)(ps->wname));
#line 4152
      text.text = copy;
#line 4153
      text.text_length = pos;
#line 4154
      text.itxt_length = (size_t )0;
#line 4155
      text.lang = (png_charp )0;
#line 4156
      text.lang_key = (png_charp )0;
#line 4158
      png_set_text((png_const_structrp )pp, (png_inforp )pi, (png_const_textp )(& text),
                   1);
#line 4162
      if ((int const   )colour_type == 3) {
#line 4163
        init_standard_palette((png_store *)ps, pp, pi, (int )(1U << (int const   )bit_depth),
                              1);
      } else
#line 4166
      if (palette_number) {
#line 4167
        set_random_tRNS(pp, pi, (png_byte )colour_type, (int )bit_depth);
      }
#line 4170
      png_write_info((png_structrp )pp, (png_const_inforp )pi);
#line 4172
      tmp___3 = png_get_rowbytes((png_const_structrp )pp, (png_const_inforp )pi);
#line 4172
      tmp___4 = transform_rowsize((png_const_structp )pp, (png_byte )colour_type,
                                  (png_byte )bit_depth);
#line 4172
      if (tmp___3 != tmp___4) {
#line 4174
        png_error((png_const_structrp )pp, (png_const_charp )"transform row size incorrect");
      } else {
#line 4182
        tmp___0 = png_set_interlace_handling((png_structrp )pp);
#line 4182
        npasses = tmp___0;
#line 4185
        tmp___1 = npasses_from_interlace_type((png_const_structp )pp, interlace_type);
#line 4185
        if (npasses != tmp___1) {
#line 4186
          png_error((png_const_structrp )pp, (png_const_charp )"write: png_set_interlace_handling failed");
        }
#line 4188
        pass = 0;
        {
#line 4188
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 4188
          if (! (pass < npasses)) {
#line 4188
            goto while_break___1;
          }
#line 4195
          y = (png_uint_32 )0;
          {
#line 4195
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 4195
            if (! (y < h)) {
#line 4195
              goto while_break___2;
            }
#line 4199
            transform_row((png_const_structp )pp, (png_byte *)(buffer___0), (png_byte )colour_type,
                          (png_byte )bit_depth, y);
#line 4223
            if (pass == 0) {
#line 4223
              if (y == 0U) {
#line 4223
                tmp___2 = 1;
              } else {
#line 4223
                tmp___2 = 0;
              }
            } else {
#line 4223
              tmp___2 = 0;
            }
#line 4223
            choose_random_filter(pp, tmp___2);
#line 4224
            png_write_row((png_structrp )pp, (png_const_bytep )(buffer___0));
#line 4195
            y ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 4188
          pass ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 4238
      text___0.compression = 0;
#line 4239
      text___0.key = key___0;
#line 4240
      text___0.text = comment;
#line 4241
      text___0.text_length = sizeof(comment) - 1UL;
#line 4242
      text___0.itxt_length = (size_t )0;
#line 4243
      text___0.lang = (png_charp )0;
#line 4244
      text___0.lang_key = (png_charp )0;
#line 4246
      png_set_text((png_const_structrp )pp, (png_inforp )pi, (png_const_textp )(& text___0),
                   1);
#line 4250
      png_write_end((png_structrp )pp, (png_inforp )pi);
#line 4253
      store_storefile((png_store *)ps, ((unsigned int )((int const   )colour_type + ((int const   )bit_depth << 3)) + (palette_number << 8)) + (unsigned int )(interlace_type << 13));
#line 4256
      store_write_reset((png_store *)ps);
#line 4114
      the_exception_context->caught = 0;
#line 4114
      if (! the_exception_context->caught) {
#line 4114
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 4259
    the_exception_context->caught = 1;
  }
#line 4259
  the_exception_context->penv = exception__prev;
#line 4259
  if (! (! the_exception_context->caught)) {
#line 4259
    fault = (png_store *)the_exception_context->v.etmp;
#line 4259
    if (! 0) {
#line 4265
      store_write_reset(fault);
    }
  }
#line 4267
  return;
}
}
#line 4269 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void make_transform_images(png_modifier *pm___0 )
{
  png_byte colour_type ;
  png_byte bit_depth ;
  unsigned int palette_number ;
  int interlace_type ;
  char name[64] ;
  int tmp ;

  {
#line 4272
  colour_type = (png_byte )0;
#line 4273
  bit_depth = (png_byte )0;
#line 4274
  palette_number = 0U;
#line 4277
  safecat(pm___0->this.test, sizeof(pm___0->this.test), (size_t )0, (char const   *)"make standard images");
  {
#line 4283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4283
    tmp = next_format(& colour_type, & bit_depth, & palette_number, 1, 1);
#line 4283
    if (! tmp) {
#line 4283
      goto while_break;
    }
#line 4287
    interlace_type = 0;
    {
#line 4287
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4287
      if (! (interlace_type < 2)) {
#line 4287
        goto while_break___0;
      }
#line 4292
      standard_name(name, sizeof(name), (size_t )0, colour_type, (int )bit_depth,
                    palette_number, interlace_type, (png_uint_32 )0, (png_uint_32 )0,
                    0);
#line 4294
      make_transform_image((png_store *)(& pm___0->this), (png_byte const   )colour_type,
                           (png_byte const   )bit_depth, palette_number, interlace_type,
                           (png_const_charp )(name));
#line 4287
      interlace_type ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4298
  return;
}
}
#line 4303 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void size_row(png_byte *buffer___0 , png_uint_32 bit_width , png_uint_32 y )
{
  png_byte *tmp ;
  png_uint_32 tmp___0 ;
  png_uint_32 mask ;

  {
#line 4307
  y = ((((y & 1U) << 7) + ((y & 2U) << 6)) + ((y & 4U) << 5)) + ((y & 8U) << 4);
#line 4309
  y ^= 165U;
  {
#line 4311
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4311
    if (! (bit_width >= 8U)) {
#line 4311
      goto while_break;
    }
#line 4312
    tmp = buffer___0;
#line 4312
    buffer___0 ++;
#line 4312
    tmp___0 = y;
#line 4312
    y ++;
#line 4312
    *tmp = (png_byte )tmp___0;
#line 4312
    bit_width -= 8U;
  }
  while_break: /* CIL Label */ ;
  }
#line 4317
  if (bit_width > 0U) {
#line 4319
    mask = (1U << (8U - bit_width)) - 1U;
#line 4320
    *buffer___0 = (png_byte )(((unsigned int )*buffer___0 & mask) | (y & ~ mask));
  }
#line 4322
  return;
}
}
#line 4360
static void make_size_image(png_store *ps , png_byte const   colour_type , png_byte const   bit_depth ,
                            int const   interlace_type , png_uint_32 const   w , png_uint_32 const   h ,
                            int const   do_interlace ) ;
#line 4360 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static char key___1[11]  =
#line 4360
  {      (char )'i',      (char )'m',      (char )'a',      (char )'g',
        (char )'e',      (char )' ',      (char )'n',      (char )'a',
        (char )'m',      (char )'e',      (char )'\000'};
#line 4484 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static char key___2[11]  =
#line 4484
  {      (char )'e',      (char )'n',      (char )'d',      (char )' ',
        (char )'m',      (char )'a',      (char )'r',      (char )'k',
        (char )'e',      (char )'r',      (char )'\000'};
#line 4485 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static char comment___0[4]  = {      (char )'e',      (char )'n',      (char )'d',      (char )'\000'};
#line 4324 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void make_size_image(png_store *ps , png_byte const   colour_type , png_byte const   bit_depth ,
                            int const   interlace_type , png_uint_32 const   w , png_uint_32 const   h ,
                            int const   do_interlace )
{
  struct exception_context *the_exception_context ;
  png_store *fault ;
  jmp_buf *exception__prev ;
  jmp_buf exception__env ;
  png_infop pi ;
  png_structp pp ;
  unsigned int pixel_size ;
  char name[64] ;
  png_uint_32 id ;
  size_t pos ;
  png_text text ;
  char copy[64] ;
  int npasses ;
  int tmp ;
  png_uint_32 y ;
  int pass ;
  png_byte image[16][128U] ;
  int tmp___0 ;
  png_uint_32 wPass ;
  int tmp___1 ;
  int tmp___2 ;
  png_const_bytep row ;
  png_byte tempRow[128U] ;
  int filters ;
  unsigned int tmp___3 ;
  size_t tmp___4 ;
  png_text text___0 ;
  int tmp___5 ;

  {
#line 4330
  the_exception_context = & ps->exception_context;
#line 4334
  exception__prev = the_exception_context->penv;
#line 4334
  the_exception_context->penv = & exception__env;
#line 4334
  tmp___5 = _setjmp((struct __jmp_buf_tag *)(exception__env));
#line 4334
  if (tmp___5 == 0) {
    {
#line 4334
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4342
      id = (png_uint_32 )(((png_uint_32 const   )((((int const   )colour_type + ((int const   )bit_depth << 3)) + (interlace_type << 13)) + (int const   )((do_interlace != 0) << 15)) + (w << 16)) + (h << 24));
#line 4345
      standard_name_from_id(name, sizeof(name), (size_t )0, id);
#line 4346
      pp = set_store_for_write((png_store *)ps, & pi, (char const   *)(name));
#line 4352
      if ((unsigned long )pp == (unsigned long )((void *)0)) {
        {
#line 4353
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 4353
          the_exception_context->v.etmp = (struct png_store * volatile  )ps;
#line 4353
          longjmp((struct __jmp_buf_tag *)(*(the_exception_context->penv)), 1);
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 4355
      png_set_IHDR((png_const_structrp )pp, (png_inforp )pi, (png_uint_32 )w, (png_uint_32 )h,
                   (int )bit_depth, (int )colour_type, (int )interlace_type, 0, 0);
#line 4368
      text.compression = 0;
#line 4369
      text.key = key___1;
#line 4371
      pos = safecat(copy, sizeof(copy), (size_t )0, (char const   *)(ps->wname));
#line 4372
      text.text = copy;
#line 4373
      text.text_length = pos;
#line 4374
      text.itxt_length = (size_t )0;
#line 4375
      text.lang = (png_charp )0;
#line 4376
      text.lang_key = (png_charp )0;
#line 4378
      png_set_text((png_const_structrp )pp, (png_inforp )pi, (png_const_textp )(& text),
                   1);
#line 4382
      if ((int const   )colour_type == 3) {
#line 4383
        init_standard_palette((png_store *)ps, pp, pi, (int )(1U << (int const   )bit_depth),
                              0);
      }
#line 4385
      png_write_info((png_structrp )pp, (png_const_inforp )pi);
#line 4391
      pixel_size = bit_size((png_const_structp )pp, (png_byte )colour_type, (png_byte )bit_depth);
#line 4392
      tmp___4 = png_get_rowbytes((png_const_structrp )pp, (png_const_inforp )pi);
#line 4392
      if (tmp___4 != (size_t )((w * (png_uint_32 const   )pixel_size + 7U) / 8U)) {
#line 4393
        png_error((png_const_structrp )pp, (png_const_charp )"size row size incorrect");
      } else {
#line 4397
        tmp = npasses_from_interlace_type((png_const_structp )pp, (int )interlace_type);
#line 4397
        npasses = tmp;
#line 4405
        memset((void *)(image), 0xff, sizeof(image));
#line 4407
        if (! do_interlace) {
#line 4407
          tmp___0 = png_set_interlace_handling((png_structrp )pp);
#line 4407
          if (npasses != tmp___0) {
#line 4409
            png_error((png_const_structrp )pp, (png_const_charp )"write: png_set_interlace_handling failed");
          }
        }
#line 4412
        y = (png_uint_32 )0;
        {
#line 4412
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 4412
          if (! (y < (png_uint_32 )h)) {
#line 4412
            goto while_break___1;
          }
#line 4413
          size_row((png_byte *)(image[y]), (png_uint_32 )(w * (png_uint_32 const   )pixel_size),
                   y);
#line 4412
          y ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 4415
        pass = 0;
        {
#line 4415
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 4415
          if (! (pass < npasses)) {
#line 4415
            goto while_break___2;
          }
#line 4418
          if (pass > 1) {
#line 4418
            tmp___1 = (7 - pass) >> 1;
          } else {
#line 4418
            tmp___1 = 3;
          }
#line 4418
          if (pass > 1) {
#line 4418
            tmp___2 = (7 - pass) >> 1;
          } else {
#line 4418
            tmp___2 = 3;
          }
#line 4418
          wPass = (png_uint_32 )((w + (png_uint_32 const   )(((1 << tmp___1) - 1) - (((1 & pass) << (3 - ((pass + 1) >> 1))) & 7))) >> tmp___2);
#line 4424
          y = (png_uint_32 )0;
          {
#line 4424
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 4424
            if (! (y < (png_uint_32 )h)) {
#line 4424
              goto while_break___3;
            }
#line 4426
            row = (png_const_bytep )(image[y]);
#line 4433
            if (do_interlace) {
#line 4433
              if (interlace_type == 1) {
#line 4441
                if (((((0x110145AF >> ((7 - pass) << 2)) & 0xF) | ((0x01145AF0 >> ((7 - pass) << 2)) & 0xF0)) >> (y & 7U)) & 1) {
#line 4441
                  if (wPass > 0U) {
#line 4446
                    memset((void *)(tempRow), 0xff, sizeof(tempRow));
#line 4447
                    interlace_row(tempRow, row, pixel_size, (png_uint_32 )w, pass,
                                  0);
#line 4449
                    row = (png_const_bytep )(tempRow);
                  } else {
#line 4452
                    goto __Cont;
                  }
                } else {
#line 4452
                  goto __Cont;
                }
              }
            }
#line 4467
            tmp___3 = random_mod(5U);
#line 4467
            filters = 8 << tmp___3;
#line 4469
            if (pass == 0) {
#line 4469
              if (y == 0U) {
#line 4469
                if (filters < 0x20) {
#line 4471
                  filters |= 0x20;
                } else
#line 4469
                if (w == 1U) {
#line 4471
                  filters |= 0x20;
                }
              }
            }
#line 4473
            png_set_filter((png_structrp )pp, 0, filters);
#line 4477
            png_write_row((png_structrp )pp, row);
            __Cont: /* CIL Label */
#line 4424
            y ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 4415
          pass ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 4491
      text___0.compression = 0;
#line 4492
      text___0.key = key___2;
#line 4493
      text___0.text = comment___0;
#line 4494
      text___0.text_length = sizeof(comment___0) - 1UL;
#line 4495
      text___0.itxt_length = (size_t )0;
#line 4496
      text___0.lang = (png_charp )0;
#line 4497
      text___0.lang_key = (png_charp )0;
#line 4499
      png_set_text((png_const_structrp )pp, (png_inforp )pi, (png_const_textp )(& text___0),
                   1);
#line 4503
      png_write_end((png_structrp )pp, (png_inforp )pi);
#line 4506
      store_storefile((png_store *)ps, id);
#line 4508
      store_write_reset((png_store *)ps);
#line 4334
      the_exception_context->caught = 0;
#line 4334
      if (! the_exception_context->caught) {
#line 4334
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 4511
    the_exception_context->caught = 1;
  }
#line 4511
  the_exception_context->penv = exception__prev;
#line 4511
  if (! (! the_exception_context->caught)) {
#line 4511
    fault = (png_store *)the_exception_context->v.etmp;
#line 4511
    if (! 0) {
#line 4517
      store_write_reset(fault);
    }
  }
#line 4519
  return;
}
}
#line 4521 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void make_size(png_store *ps , png_byte const   colour_type , int bdlo , int const   bdhi )
{
  png_uint_32 width ;
  png_uint_32 height ;

  {
  {
#line 4525
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4525
    if (! (bdlo <= (int )bdhi)) {
#line 4525
      goto while_break;
    }
#line 4529
    width = (png_uint_32 )1;
    {
#line 4529
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4529
      if (! (width <= 16U)) {
#line 4529
        goto while_break___0;
      }
#line 4533
      height = (png_uint_32 )1;
      {
#line 4533
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 4533
        if (! (height <= 16U)) {
#line 4533
          goto while_break___1;
        }
#line 4539
        make_size_image(ps, colour_type, (png_byte const   )((png_byte )(1U << bdlo)),
                        (int const   )0, (png_uint_32 const   )width, (png_uint_32 const   )height,
                        (int const   )0);
#line 4541
        make_size_image(ps, colour_type, (png_byte const   )((png_byte )(1U << bdlo)),
                        (int const   )0, (png_uint_32 const   )width, (png_uint_32 const   )height,
                        (int const   )1);
#line 4544
        make_size_image(ps, colour_type, (png_byte const   )((png_byte )(1U << bdlo)),
                        (int const   )1, (png_uint_32 const   )width, (png_uint_32 const   )height,
                        (int const   )0);
#line 4551
        make_size_image(ps, colour_type, (png_byte const   )((png_byte )(1U << bdlo)),
                        (int const   )1, (png_uint_32 const   )width, (png_uint_32 const   )height,
                        (int const   )1);
#line 4533
        height ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 4529
      width ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4525
    bdlo ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4557
  return;
}
}
#line 4559 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void make_size_images(png_store *ps )
{


  {
#line 4563
  safecat(ps->test, sizeof(ps->test), (size_t )0, (char const   *)"make size images");
#line 4567
  make_size((png_store *)ps, (png_byte const   )0, 0, (int const   )4);
#line 4568
  make_size((png_store *)ps, (png_byte const   )2, 3, (int const   )4);
#line 4569
  make_size((png_store *)ps, (png_byte const   )3, 0, (int const   )3);
#line 4570
  make_size((png_store *)ps, (png_byte const   )4, 3, (int const   )4);
#line 4571
  make_size((png_store *)ps, (png_byte const   )6, 3, (int const   )4);
#line 4572
  return;
}
}
#line 4576 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void standard_row(png_const_structp pp , png_byte *std , png_uint_32 id , png_uint_32 y )
{
  unsigned int tmp ;

  {
#line 4580
  if (((id >> 16) & 255U) == 0U) {
#line 4581
    transform_row(pp, std, (png_byte )(id & 0x7U), (png_byte )((id >> 3) & 0x1fU),
                  y);
  } else {
#line 4583
    tmp = bit_size(pp, (png_byte )(id & 0x7U), (png_byte )((id >> 3) & 0x1fU));
#line 4583
    size_row((png_byte *)std, ((id >> 16) & 255U) * tmp, y);
  }
#line 4585
  return;
}
}
#line 4597 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void sBIT0_error_fn(png_structp pp , png_infop pi )
{
  png_color_8 bad ;

  {
#line 4602
  bad.alpha = (png_byte )0;
#line 4602
  bad.gray = bad.alpha;
#line 4602
  bad.blue = bad.gray;
#line 4602
  bad.green = bad.blue;
#line 4602
  bad.red = bad.green;
#line 4603
  png_set_sBIT((png_const_structrp )pp, (png_inforp )pi, (png_const_color_8p )(& bad));
#line 4604
  return;
}
}
#line 4606 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void sBIT_error_fn(png_structp pp , png_infop pi )
{
  png_byte bit_depth ;
  png_color_8 bad ;
  png_byte tmp ;

  {
#line 4612
  tmp = png_get_color_type((png_const_structrp )pp, (png_const_inforp )pi);
#line 4612
  if ((int )tmp == 3) {
#line 4613
    bit_depth = (png_byte )8;
  } else {
#line 4616
    bit_depth = png_get_bit_depth((png_const_structrp )pp, (png_const_inforp )pi);
  }
#line 4619
  bad.alpha = (png_byte )((int )bit_depth + 1);
#line 4619
  bad.gray = bad.alpha;
#line 4619
  bad.blue = bad.gray;
#line 4619
  bad.green = bad.blue;
#line 4619
  bad.red = bad.green;
#line 4621
  png_set_sBIT((png_const_structrp )pp, (png_inforp )pi, (png_const_color_8p )(& bad));
#line 4622
  return;
}
}
#line 4629 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static struct __anonstruct_error_test_969491036  const  error_test[2]  = {      {& sBIT0_error_fn, (char const   *)"sBIT(0): failed to detect error", 1U},
        {& sBIT_error_fn, (char const   *)"sBIT(too big): failed to detect error", 1U}};
#line 4639 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void make_error(png_store *ps , png_byte const   colour_type , png_byte bit_depth ,
                       int interlace_type , int test , png_const_charp name )
{
  struct exception_context *the_exception_context ;
  png_store *fault ;
  jmp_buf *exception__prev ;
  jmp_buf exception__env ;
  png_infop pi ;
  png_structp pp ;
  png_structp tmp ;
  png_uint_32 w ;
  png_uint_32 h ;
  jmp_buf *exception_prev_1 ;
  jmp_buf exception_env_1 ;
  int tmp___0 ;
  int tmp___1 ;
  int npasses ;
  int tmp___2 ;
  int pass ;
  int tmp___3 ;
  png_uint_32 y ;
  png_byte buffer___0[1024U] ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;

  {
#line 4643
  the_exception_context = & ps->exception_context;
#line 4647
  exception__prev = the_exception_context->penv;
#line 4647
  the_exception_context->penv = & exception__env;
#line 4647
  tmp___6 = _setjmp((struct __jmp_buf_tag *)(exception__env));
#line 4647
  if (tmp___6 == 0) {
    {
#line 4647
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4650
      tmp = set_store_for_write((png_store *)ps, & pi, name);
#line 4650
      pp = tmp;
#line 4652
      make_volatile_for_gnu = (void const   * volatile  )(& pp);
#line 4654
      if ((unsigned long )pp == (unsigned long )((void *)0)) {
        {
#line 4655
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 4655
          the_exception_context->v.etmp = (struct png_store * volatile  )ps;
#line 4655
          longjmp((struct __jmp_buf_tag *)(*(the_exception_context->penv)), 1);
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 4657
      w = 128U;
#line 4658
      make_volatile_for_gnu = (void const   * volatile  )(& w);
#line 4659
      h = transform_height((png_const_structp )pp, (png_byte )colour_type, bit_depth);
#line 4660
      make_volatile_for_gnu = (void const   * volatile  )(& h);
#line 4661
      png_set_IHDR((png_const_structrp )pp, (png_inforp )pi, w, h, (int )bit_depth,
                   (int )colour_type, interlace_type, 0, 0);
#line 4664
      if ((int const   )colour_type == 3) {
#line 4665
        init_standard_palette((png_store *)ps, pp, pi, (int )(1U << (int )bit_depth),
                              0);
      }
#line 4672
      exception_prev_1 = the_exception_context->penv;
#line 4672
      the_exception_context->penv = & exception_env_1;
#line 4672
      tmp___0 = _setjmp((struct __jmp_buf_tag *)(exception_env_1));
#line 4672
      if (tmp___0 == 0) {
        {
#line 4672
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 4674
          make_volatile_for_gnu = (void const   * volatile  )(& exception_prev_1);
#line 4677
          ps->expect_error = (unsigned int )(! error_test[test].warning);
#line 4678
          ps->expect_warning = (unsigned int )error_test[test].warning;
#line 4679
          ps->saw_warning = 0U;
#line 4680
          (*(error_test[test].fn))(pp, pi);
#line 4683
          png_write_info((png_structrp )pp, (png_const_inforp )pi);
#line 4686
          if (ps->expect_warning) {
#line 4686
            if (ps->saw_warning) {
              {
#line 4687
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 4687
                the_exception_context->v.etmp = (struct png_store * volatile  )ps;
#line 4687
                longjmp((struct __jmp_buf_tag *)(*(the_exception_context->penv)),
                        1);
              }
              while_break___2: /* CIL Label */ ;
              }
            }
          }
#line 4692
          store_log((png_store *)ps, (png_const_structp )pp, (png_const_charp )error_test[test].msg,
                    1);
#line 4672
          the_exception_context->caught = 0;
#line 4672
          if (! the_exception_context->caught) {
#line 4672
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
#line 4695
        the_exception_context->caught = 1;
      }
#line 4695
      the_exception_context->penv = exception_prev_1;
#line 4695
      if (! the_exception_context->caught) {
#line 4695
        tmp___1 = 1;
      } else {
#line 4695
        fault = (png_store *)the_exception_context->v.etmp;
#line 4695
        if (0) {
#line 4695
          tmp___1 = 1;
        } else {
#line 4695
          tmp___1 = 0;
        }
      }
#line 4702
      ps->expect_warning = 0U;
#line 4704
      if (ps->expect_error) {
#line 4705
        ps->expect_error = 0U;
      } else {
#line 4714
        tmp___4 = png_get_rowbytes((png_const_structrp )pp, (png_const_inforp )pi);
#line 4714
        tmp___5 = transform_rowsize((png_const_structp )pp, (png_byte )colour_type,
                                    bit_depth);
#line 4714
        if (tmp___4 != tmp___5) {
#line 4716
          png_error((png_const_structrp )pp, (png_const_charp )"row size incorrect");
        } else {
#line 4720
          tmp___2 = png_set_interlace_handling((png_structrp )pp);
#line 4720
          npasses = tmp___2;
#line 4723
          tmp___3 = npasses_from_interlace_type((png_const_structp )pp, interlace_type);
#line 4723
          if (npasses != tmp___3) {
#line 4724
            png_error((png_const_structrp )pp, (png_const_charp )"write: png_set_interlace_handling failed");
          }
#line 4726
          pass = 0;
          {
#line 4726
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 4726
            if (! (pass < npasses)) {
#line 4726
              goto while_break___3;
            }
#line 4730
            y = (png_uint_32 )0;
            {
#line 4730
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 4730
              if (! (y < h)) {
#line 4730
                goto while_break___4;
              }
#line 4734
              transform_row((png_const_structp )pp, (png_byte *)(buffer___0), (png_byte )colour_type,
                            bit_depth, y);
#line 4760
              png_write_row((png_structrp )pp, (png_const_bytep )(buffer___0));
#line 4730
              y ++;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 4726
            pass ++;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 4765
        png_write_end((png_structrp )pp, (png_inforp )pi);
      }
#line 4769
      store_write_reset((png_store *)ps);
#line 4647
      the_exception_context->caught = 0;
#line 4647
      if (! the_exception_context->caught) {
#line 4647
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 4772
    the_exception_context->caught = 1;
  }
#line 4772
  the_exception_context->penv = exception__prev;
#line 4772
  if (! (! the_exception_context->caught)) {
#line 4772
    fault = (png_store *)the_exception_context->v.etmp;
#line 4772
    if (! 0) {
#line 4774
      store_write_reset(fault);
    }
  }
#line 4776
  return;
}
}
#line 4778 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int make_errors(png_modifier *pm___0 , png_byte const   colour_type , int bdlo ,
                       int const   bdhi )
{
  int interlace_type ;
  unsigned int test ;
  char name[64] ;
  int tmp ;

  {
  {
#line 4782
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4782
    if (! (bdlo <= (int )bdhi)) {
#line 4782
      goto while_break;
    }
#line 4786
    interlace_type = 0;
    {
#line 4786
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4786
      if (! (interlace_type < 2)) {
#line 4786
        goto while_break___0;
      }
#line 4792
      standard_name(name, sizeof(name), (size_t )0, (png_byte )colour_type, 1 << bdlo,
                    0U, interlace_type, (png_uint_32 )0, (png_uint_32 )0, 0);
#line 4795
      test = 0U;
      {
#line 4795
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 4795
        if (! (test < (unsigned int )(sizeof(error_test) / sizeof(error_test[0])))) {
#line 4795
          goto while_break___1;
        }
#line 4797
        make_error((png_store *)(& pm___0->this), colour_type, (png_byte )(1U << bdlo),
                   interlace_type, (int )test, (png_const_charp )(name));
#line 4800
        tmp = fail((png_modifier *)pm___0);
#line 4800
        if (tmp) {
#line 4801
          return (0);
        }
#line 4795
        test ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 4786
      interlace_type ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4782
    bdlo ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4806
  return (1);
}
}
#line 4810 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void perform_error_test(png_modifier *pm___0 )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 4815
  safecat(pm___0->this.test, sizeof(pm___0->this.test), (size_t )0, (char const   *)"error test");
#line 4817
  tmp = make_errors((png_modifier *)pm___0, (png_byte const   )0, 0, (int const   )4);
#line 4817
  if (! tmp) {
#line 4818
    return;
  }
#line 4820
  tmp___0 = make_errors((png_modifier *)pm___0, (png_byte const   )2, 3, (int const   )4);
#line 4820
  if (! tmp___0) {
#line 4821
    return;
  }
#line 4823
  tmp___1 = make_errors((png_modifier *)pm___0, (png_byte const   )3, 0, (int const   )3);
#line 4823
  if (! tmp___1) {
#line 4824
    return;
  }
#line 4826
  tmp___2 = make_errors((png_modifier *)pm___0, (png_byte const   )4, 3, (int const   )4);
#line 4826
  if (! tmp___2) {
#line 4827
    return;
  }
#line 4829
  tmp___3 = make_errors((png_modifier *)pm___0, (png_byte const   )6, 3, (int const   )4);
#line 4829
  if (! tmp___3) {
#line 4830
    return;
  }
#line 4834
  return;
}
}
#line 4839 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void perform_formatting_test(png_store *ps )
{
  struct exception_context *the_exception_context ;
  png_store *fault ;
  jmp_buf *exception__prev ;
  jmp_buf exception__env ;
  png_const_charp correct ;
  png_const_charp result ;
  char timestring[29] ;
  png_structp pp ;
  png_time pt ;
  int tmp ;
  size_t pos ;
  char msg[128] ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 4846
  the_exception_context = & ps->exception_context;
#line 4848
  exception__prev = the_exception_context->penv;
#line 4848
  the_exception_context->penv = & exception__env;
#line 4848
  tmp___1 = _setjmp((struct __jmp_buf_tag *)(exception__env));
#line 4848
  if (tmp___1 == 0) {
    {
#line 4848
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4850
      correct = (png_const_charp )"29 Aug 2079 13:53:60 +0000";
#line 4858
      pp = set_store_for_write(ps, (png_infopp )((void *)0), (char const   *)"libpng formatting test");
#line 4860
      if ((unsigned long )pp == (unsigned long )((void *)0)) {
        {
#line 4861
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 4861
          the_exception_context->v.etmp = (struct png_store * volatile  )ps;
#line 4861
          longjmp((struct __jmp_buf_tag *)(*(the_exception_context->penv)), 1);
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 4865
      pt.year = (png_uint_16 )2079;
#line 4866
      pt.month = (png_byte )8;
#line 4867
      pt.day = (png_byte )29;
#line 4868
      pt.hour = (png_byte )13;
#line 4869
      pt.minute = (png_byte )53;
#line 4870
      pt.second = (png_byte )60;
#line 4875
      tmp = png_convert_to_rfc1123_buffer((char *)(timestring), (png_const_timep )(& pt));
#line 4875
      if (tmp) {
#line 4876
        result = (png_const_charp )(timestring);
      } else {
#line 4879
        result = (png_const_charp )((void *)0);
      }
#line 4882
      if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 4883
        png_error((png_const_structrp )pp, (png_const_charp )"png_convert_to_rfc1123 failed");
      }
#line 4885
      tmp___0 = strcmp(result, correct);
#line 4885
      if (tmp___0 != 0) {
#line 4887
        pos = (size_t )0;
#line 4890
        pos = safecat(msg, sizeof(msg), pos, (char const   *)"png_convert_to_rfc1123(");
#line 4891
        pos = safecat(msg, sizeof(msg), pos, correct);
#line 4892
        pos = safecat(msg, sizeof(msg), pos, (char const   *)") returned: \'");
#line 4893
        pos = safecat(msg, sizeof(msg), pos, result);
#line 4894
        pos = safecat(msg, sizeof(msg), pos, (char const   *)"\'");
#line 4896
        png_error((png_const_structrp )pp, (png_const_charp )(msg));
      }
#line 4899
      store_write_reset(ps);
#line 4848
      the_exception_context->caught = 0;
#line 4848
      if (! the_exception_context->caught) {
#line 4848
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 4902
    the_exception_context->caught = 1;
  }
#line 4902
  the_exception_context->penv = exception__prev;
#line 4902
  if (! (! the_exception_context->caught)) {
#line 4902
    fault = (png_store *)the_exception_context->v.etmp;
#line 4902
    if (! 0) {
#line 4904
      store_write_reset(fault);
    }
  }
#line 4909
  return;
}
}
#line 4971 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void standard_display_init(standard_display *dp , png_store *ps , png_uint_32 id ,
                                  int do_interlace , int use_update_info )
{
  png_byte tmp ;
  png_byte tmp___0 ;
  png_byte tmp___1 ;
  png_byte tmp___2 ;
  png_byte tmp___3 ;
  png_byte tmp___4 ;

  {
#line 4975
  memset((void *)dp, 0, sizeof(*dp));
#line 4977
  dp->ps = ps;
#line 4978
  dp->colour_type = (png_byte )(id & 0x7U);
#line 4979
  dp->bit_depth = (png_byte )((id >> 3) & 0x1fU);
#line 4980
  if ((int )dp->bit_depth < 1) {
#line 4981
    internal_error(ps, (png_const_charp )"internal: bad bit depth");
  } else
#line 4980
  if ((int )dp->bit_depth > 16) {
#line 4981
    internal_error(ps, (png_const_charp )"internal: bad bit depth");
  }
#line 4982
  if ((int )dp->colour_type == 3) {
#line 4983
    tmp___1 = (png_byte )8;
#line 4983
    dp->alpha_sBIT = tmp___1;
#line 4983
    tmp___0 = tmp___1;
#line 4983
    dp->green_sBIT = tmp___0;
#line 4983
    tmp = tmp___0;
#line 4983
    dp->blue_sBIT = tmp;
#line 4983
    dp->red_sBIT = tmp;
  } else {
#line 4985
    tmp___4 = dp->bit_depth;
#line 4985
    dp->alpha_sBIT = tmp___4;
#line 4985
    tmp___3 = tmp___4;
#line 4985
    dp->green_sBIT = tmp___3;
#line 4985
    tmp___2 = tmp___3;
#line 4985
    dp->blue_sBIT = tmp___2;
#line 4985
    dp->red_sBIT = tmp___2;
  }
#line 4987
  dp->interlace_type = (png_byte )((id >> 13) & 3U);
#line 4989
  dp->id = id;
#line 4991
  dp->w = (png_uint_32 )0;
#line 4992
  dp->h = (png_uint_32 )0;
#line 4993
  dp->npasses = 0;
#line 4994
  dp->pixel_size = (png_uint_32 )0;
#line 4995
  dp->bit_width = (png_uint_32 )0;
#line 4996
  dp->cbRow = (size_t )0;
#line 4997
  dp->do_interlace = do_interlace;
#line 4998
  dp->littleendian = 0;
#line 4999
  dp->is_transparent = 0;
#line 5000
  dp->speed = (int )ps->speed;
#line 5001
  dp->use_update_info = use_update_info;
#line 5002
  dp->npalette = 0;
#line 5004
  memset((void *)(& dp->transparent), 0, sizeof(dp->transparent));
#line 5006
  memset((void *)(dp->palette), 0xff, sizeof(dp->palette));
#line 5007
  return;
}
}
#line 5012 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void standard_palette_init(standard_display *dp )
{
  store_palette_entry *palette ;
  store_palette_entry *tmp ;
  int i ;

  {
#line 5015
  tmp = store_current_palette(dp->ps, & dp->npalette);
#line 5015
  palette = tmp;
#line 5018
  if (dp->npalette > 0) {
#line 5020
    i = dp->npalette;
#line 5021
    memcpy((void *)(dp->palette), (void const   *)palette, (unsigned long )i * sizeof(*palette));
    {
#line 5024
    while (1) {
      while_continue: /* CIL Label */ ;
#line 5024
      i --;
#line 5024
      if (! (i >= 0)) {
#line 5024
        goto while_break;
      }
#line 5025
      if ((int )(palette + i)->alpha < 255) {
#line 5026
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 5030
    if (i >= 0) {
#line 5031
      dp->is_transparent = 1;
    } else {
#line 5033
      dp->is_transparent = 0;
    }
  }
#line 5038
  return;
}
}
#line 5044 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int read_palette(struct store_palette_entry *palette , int *npalette , png_const_structp pp ,
                        png_infop pi )
{
  png_colorp pal ;
  png_bytep trans_alpha ;
  int num ;
  int i ;
  png_uint_32 tmp ;
  int i___0 ;
  int i___1 ;
  png_uint_32 tmp___0 ;

  {
#line 5052
  pal = (png_colorp )0;
#line 5053
  *npalette = -1;
#line 5055
  tmp = png_get_PLTE((png_const_structrp )pp, (png_inforp )pi, & pal, npalette);
#line 5055
  if (tmp & 0x0008U) {
#line 5057
    i = *npalette;
#line 5059
    if (i <= 0) {
#line 5060
      png_error((png_const_structrp )pp, (png_const_charp )"validate: invalid PLTE count");
    } else
#line 5059
    if (i > 256) {
#line 5060
      png_error((png_const_structrp )pp, (png_const_charp )"validate: invalid PLTE count");
    }
    {
#line 5062
    while (1) {
      while_continue: /* CIL Label */ ;
#line 5062
      i --;
#line 5062
      if (! (i >= 0)) {
#line 5062
        goto while_break;
      }
#line 5064
      (palette + i)->red = (pal + i)->red;
#line 5065
      (palette + i)->green = (pal + i)->green;
#line 5066
      (palette + i)->blue = (pal + i)->blue;
    }
    while_break: /* CIL Label */ ;
    }
#line 5072
    memset((void *)(palette + *npalette), 126, (unsigned long )(256 - *npalette) * sizeof(*palette));
  } else {
#line 5077
    if (*npalette != -1) {
#line 5078
      png_error((png_const_structrp )pp, (png_const_charp )"validate: invalid PLTE result");
    }
#line 5080
    *npalette = 0;
#line 5081
    memset((void *)palette, 113, sizeof(store_palette ));
  }
#line 5084
  trans_alpha = (png_bytep )0;
#line 5085
  num = 2;
#line 5086
  tmp___0 = png_get_tRNS((png_const_structrp )pp, (png_inforp )pi, & trans_alpha,
                         & num, (png_color_16p *)0);
#line 5086
  if ((tmp___0 & 0x0010U) != 0U) {
#line 5086
    if ((unsigned long )trans_alpha != (unsigned long )((void *)0)) {
#line 5086
      goto _L___2;
    } else
#line 5086
    if (num != 1) {
      _L___2: /* CIL Label */
#line 5086
      if ((unsigned long )trans_alpha != (unsigned long )((void *)0)) {
#line 5086
        if (num == 0) {
#line 5086
          goto _L___1;
        } else {
#line 5086
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */
#line 5103
        if ((unsigned long )trans_alpha == (unsigned long )((void *)0)) {
#line 5104
          png_error((png_const_structrp )pp, (png_const_charp )"validate: unexpected png_get_tRNS (palette) result");
        } else
#line 5103
        if (num <= 0) {
#line 5104
          png_error((png_const_structrp )pp, (png_const_charp )"validate: unexpected png_get_tRNS (palette) result");
        } else
#line 5103
        if (num > 256) {
#line 5104
          png_error((png_const_structrp )pp, (png_const_charp )"validate: unexpected png_get_tRNS (palette) result");
        } else
#line 5103
        if (num > *npalette) {
#line 5104
          png_error((png_const_structrp )pp, (png_const_charp )"validate: unexpected png_get_tRNS (palette) result");
        }
#line 5106
        i___0 = 0;
        {
#line 5106
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 5106
          if (! (i___0 < num)) {
#line 5106
            goto while_break___0;
          }
#line 5107
          (palette + i___0)->alpha = *(trans_alpha + i___0);
#line 5106
          i___0 ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 5109
        num = *npalette;
        {
#line 5109
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 5109
          if (! (i___0 < num)) {
#line 5109
            goto while_break___1;
          }
#line 5110
          (palette + i___0)->alpha = (png_byte )255;
#line 5109
          i___0 ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 5112
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 5112
          if (! (i___0 < 256)) {
#line 5112
            goto while_break___2;
          }
#line 5113
          (palette + i___0)->alpha = (png_byte )33;
#line 5112
          i___0 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 5115
        return (1);
      }
    } else {
#line 5086
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */
    _L: /* CIL Label */
#line 5123
    i___1 = 0;
#line 5123
    num = *npalette;
    {
#line 5123
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 5123
      if (! (i___1 < num)) {
#line 5123
        goto while_break___3;
      }
#line 5124
      (palette + i___1)->alpha = (png_byte )255;
#line 5123
      i___1 ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 5126
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 5126
      if (! (i___1 < 256)) {
#line 5126
        goto while_break___4;
      }
#line 5127
      (palette + i___1)->alpha = (png_byte )55;
#line 5126
      i___1 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 5129
    return (0);
  }
}
}
#line 5136 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void standard_palette_validate(standard_display *dp , png_const_structp pp ,
                                      png_infop pi )
{
  int npalette ;
  store_palette palette ;
  int tmp ;
  size_t pos ;
  char msg[64] ;
  int i ;

  {
#line 5143
  tmp = read_palette((struct store_palette_entry *)(palette), & npalette, pp, pi);
#line 5143
  if (tmp != dp->is_transparent) {
#line 5144
    png_error((png_const_structrp )pp, (png_const_charp )"validate: palette transparency changed");
  }
#line 5146
  if (npalette != dp->npalette) {
#line 5148
    pos = (size_t )0;
#line 5151
    pos = safecat(msg, sizeof(msg), pos, (char const   *)"validate: palette size changed: ");
#line 5152
    pos = safecatn(msg, sizeof(msg), pos, dp->npalette);
#line 5153
    pos = safecat(msg, sizeof(msg), pos, (char const   *)" -> ");
#line 5154
    pos = safecatn(msg, sizeof(msg), pos, npalette);
#line 5155
    png_error((png_const_structrp )pp, (png_const_charp )(msg));
  }
#line 5159
  i = npalette;
  {
#line 5161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5161
    i --;
#line 5161
    if (! (i >= 0)) {
#line 5161
      goto while_break;
    }
#line 5162
    if ((int )palette[i].red != (int )dp->palette[i].red) {
#line 5166
      png_error((png_const_structrp )pp, (png_const_charp )"validate: PLTE or tRNS chunk changed");
    } else
#line 5162
    if ((int )palette[i].green != (int )dp->palette[i].green) {
#line 5166
      png_error((png_const_structrp )pp, (png_const_charp )"validate: PLTE or tRNS chunk changed");
    } else
#line 5162
    if ((int )palette[i].blue != (int )dp->palette[i].blue) {
#line 5166
      png_error((png_const_structrp )pp, (png_const_charp )"validate: PLTE or tRNS chunk changed");
    } else
#line 5162
    if ((int )palette[i].alpha != (int )dp->palette[i].alpha) {
#line 5166
      png_error((png_const_structrp )pp, (png_const_charp )"validate: PLTE or tRNS chunk changed");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5168
  return;
}
}
#line 5178 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void standard_info_part1(standard_display *dp , png_structp pp , png_infop pi )
{
  png_byte tmp ;
  png_byte tmp___0 ;
  png_byte tmp___1 ;
  png_byte tmp___2 ;
  png_byte tmp___3 ;
  png_uint_32 tmp___4 ;
  png_uint_32 tmp___5 ;
  png_color_8p sBIT ;
  int sBIT_invalid ;
  png_byte tmp___6 ;
  png_byte tmp___7 ;
  png_uint_32 tmp___8 ;
  size_t tmp___9 ;
  png_uint_32 tmp___10 ;
  png_color_16p trans_color ;
  png_uint_16 tmp___11 ;
  png_uint_16 tmp___12 ;
  png_uint_32 tmp___13 ;
  int tmp___14 ;

  {
#line 5181
  tmp = png_get_bit_depth((png_const_structrp )pp, (png_const_inforp )pi);
#line 5181
  if ((int )tmp != (int )dp->bit_depth) {
#line 5182
    png_error((png_const_structrp )pp, (png_const_charp )"validate: bit depth changed");
  }
#line 5184
  tmp___0 = png_get_color_type((png_const_structrp )pp, (png_const_inforp )pi);
#line 5184
  if ((int )tmp___0 != (int )dp->colour_type) {
#line 5185
    png_error((png_const_structrp )pp, (png_const_charp )"validate: color type changed");
  }
#line 5187
  tmp___1 = png_get_filter_type((png_const_structrp )pp, (png_const_inforp )pi);
#line 5187
  if ((int )tmp___1 != 0) {
#line 5188
    png_error((png_const_structrp )pp, (png_const_charp )"validate: filter type changed");
  }
#line 5190
  tmp___2 = png_get_interlace_type((png_const_structrp )pp, (png_const_inforp )pi);
#line 5190
  if ((int )tmp___2 != (int )dp->interlace_type) {
#line 5191
    png_error((png_const_structrp )pp, (png_const_charp )"validate: interlacing changed");
  }
#line 5193
  tmp___3 = png_get_compression_type((png_const_structrp )pp, (png_const_inforp )pi);
#line 5193
  if ((int )tmp___3 != 0) {
#line 5194
    png_error((png_const_structrp )pp, (png_const_charp )"validate: compression type changed");
  }
#line 5196
  dp->w = png_get_image_width((png_const_structrp )pp, (png_const_inforp )pi);
#line 5198
  tmp___4 = standard_width((png_const_structp )pp, dp->id);
#line 5198
  if (dp->w != tmp___4) {
#line 5199
    png_error((png_const_structrp )pp, (png_const_charp )"validate: image width changed");
  }
#line 5201
  dp->h = png_get_image_height((png_const_structrp )pp, (png_const_inforp )pi);
#line 5203
  tmp___5 = standard_height((png_const_structp )pp, dp->id);
#line 5203
  if (dp->h != tmp___5) {
#line 5204
    png_error((png_const_structrp )pp, (png_const_charp )"validate: image height changed");
  }
#line 5210
  sBIT = (png_color_8p )0;
#line 5212
  tmp___8 = png_get_sBIT((png_const_structrp )pp, (png_inforp )pi, & sBIT);
#line 5212
  if (tmp___8 & 0x0002U) {
#line 5214
    sBIT_invalid = 0;
#line 5216
    if ((unsigned long )sBIT == (unsigned long )((png_color_8p )0)) {
#line 5217
      png_error((png_const_structrp )pp, (png_const_charp )"validate: unexpected png_get_sBIT result");
    }
#line 5219
    if ((int )dp->colour_type & 2) {
#line 5221
      if ((int )sBIT->red == 0) {
#line 5222
        sBIT_invalid = 1;
      } else
#line 5221
      if ((int )sBIT->red > (int )dp->bit_depth) {
#line 5222
        sBIT_invalid = 1;
      } else {
#line 5224
        dp->red_sBIT = sBIT->red;
      }
#line 5226
      if ((int )sBIT->green == 0) {
#line 5227
        sBIT_invalid = 1;
      } else
#line 5226
      if ((int )sBIT->green > (int )dp->bit_depth) {
#line 5227
        sBIT_invalid = 1;
      } else {
#line 5229
        dp->green_sBIT = sBIT->green;
      }
#line 5231
      if ((int )sBIT->blue == 0) {
#line 5232
        sBIT_invalid = 1;
      } else
#line 5231
      if ((int )sBIT->blue > (int )dp->bit_depth) {
#line 5232
        sBIT_invalid = 1;
      } else {
#line 5234
        dp->blue_sBIT = sBIT->blue;
      }
    } else
#line 5239
    if ((int )sBIT->gray == 0) {
#line 5240
      sBIT_invalid = 1;
    } else
#line 5239
    if ((int )sBIT->gray > (int )dp->bit_depth) {
#line 5240
      sBIT_invalid = 1;
    } else {
#line 5242
      tmp___7 = sBIT->gray;
#line 5242
      dp->red_sBIT = tmp___7;
#line 5242
      tmp___6 = tmp___7;
#line 5242
      dp->green_sBIT = tmp___6;
#line 5242
      dp->blue_sBIT = tmp___6;
    }
#line 5248
    if ((int )dp->colour_type & 4) {
#line 5250
      if ((int )sBIT->alpha == 0) {
#line 5251
        sBIT_invalid = 1;
      } else
#line 5250
      if ((int )sBIT->alpha > (int )dp->bit_depth) {
#line 5251
        sBIT_invalid = 1;
      } else {
#line 5253
        dp->alpha_sBIT = sBIT->alpha;
      }
    }
#line 5256
    if (sBIT_invalid) {
#line 5257
      png_error((png_const_structrp )pp, (png_const_charp )"validate: sBIT value out of range");
    }
  }
#line 5266
  tmp___9 = png_get_rowbytes((png_const_structrp )pp, (png_const_inforp )pi);
#line 5266
  tmp___10 = standard_rowsize((png_const_structp )pp, dp->id);
#line 5266
  if (tmp___9 != (size_t )tmp___10) {
#line 5267
    png_error((png_const_structrp )pp, (png_const_charp )"validate: row size changed");
  }
#line 5272
  standard_palette_validate(dp, (png_const_structp )pp, pi);
#line 5279
  trans_color = (png_color_16p )0;
#line 5281
  tmp___13 = png_get_tRNS((png_const_structrp )pp, (png_inforp )pi, (png_bytep *)0,
                          (int *)0, & trans_color);
#line 5281
  if (tmp___13 & 0x0010U) {
#line 5283
    if ((unsigned long )trans_color == (unsigned long )((png_color_16p )0)) {
#line 5284
      png_error((png_const_structrp )pp, (png_const_charp )"validate: unexpected png_get_tRNS (color) result");
    }
    {
#line 5288
    if ((int )dp->colour_type == 0) {
#line 5288
      goto case_0;
    }
#line 5294
    if ((int )dp->colour_type == 2) {
#line 5294
      goto case_2;
    }
#line 5301
    if ((int )dp->colour_type == 3) {
#line 5301
      goto case_3;
    }
#line 5308
    goto switch_default;
    case_0: /* CIL Label */
#line 5289
    tmp___12 = trans_color->gray;
#line 5289
    dp->transparent.blue = tmp___12;
#line 5289
    tmp___11 = tmp___12;
#line 5289
    dp->transparent.green = tmp___11;
#line 5289
    dp->transparent.red = tmp___11;
#line 5291
    dp->has_tRNS = 1;
#line 5292
    goto switch_break;
    case_2: /* CIL Label */
#line 5295
    dp->transparent.red = trans_color->red;
#line 5296
    dp->transparent.green = trans_color->green;
#line 5297
    dp->transparent.blue = trans_color->blue;
#line 5298
    dp->has_tRNS = 1;
#line 5299
    goto switch_break;
    case_3: /* CIL Label */
#line 5305
    png_error((png_const_structrp )pp, (png_const_charp )"validate: unexpected png_get_tRNS result");
#line 5306
    goto switch_break;
    switch_default: /* CIL Label */
#line 5309
    png_error((png_const_structrp )pp, (png_const_charp )"validate: invalid tRNS chunk with alpha image");
    switch_break: /* CIL Label */ ;
    }
  }
#line 5318
  dp->npasses = npasses_from_interlace_type((png_const_structp )pp, (int )dp->interlace_type);
#line 5319
  if (! dp->do_interlace) {
#line 5322
    tmp___14 = png_set_interlace_handling((png_structrp )pp);
#line 5322
    if (dp->npasses != tmp___14) {
#line 5323
      png_error((png_const_structrp )pp, (png_const_charp )"validate: file changed interlace type");
    }
  }
#line 5336
  return;
}
}
#line 5342 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void standard_info_part2(standard_display *dp , png_const_structp pp , png_const_infop pi ,
                                int nImages )
{
  png_byte ct ;
  png_byte tmp ;
  png_byte bd ;
  png_byte tmp___0 ;
  png_uint_32 tmp___1 ;

  {
#line 5348
  tmp = png_get_color_type((png_const_structrp )pp, (png_const_inforp )pi);
#line 5348
  ct = tmp;
#line 5349
  tmp___0 = png_get_bit_depth((png_const_structrp )pp, (png_const_inforp )pi);
#line 5349
  bd = tmp___0;
#line 5351
  if ((int )bd >= 8) {
#line 5351
    if ((int )ct == 2) {
#line 5351
      goto _L;
    } else
#line 5351
    if ((int )ct == 0) {
      _L: /* CIL Label */
#line 5351
      if (dp->filler) {
#line 5353
        ct = (png_byte )((int )ct | 4);
      }
    }
  }
#line 5355
  dp->pixel_size = bit_size(pp, ct, bd);
#line 5357
  tmp___1 = png_get_image_width((png_const_structrp )pp, (png_const_inforp )pi);
#line 5357
  dp->bit_width = tmp___1 * dp->pixel_size;
#line 5358
  dp->cbRow = png_get_rowbytes((png_const_structrp )pp, (png_const_inforp )pi);
#line 5361
  if (dp->cbRow != (size_t )((dp->bit_width + 7U) / 8U)) {
#line 5362
    png_error((png_const_structrp )pp, (png_const_charp )"bad png_get_rowbytes calculation");
  }
#line 5365
  store_ensure_image(dp->ps, pp, nImages, dp->cbRow, dp->h);
#line 5366
  return;
}
}
#line 5368 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void standard_info_imp(standard_display *dp , png_structp pp , png_infop pi ,
                              int nImages )
{
  int i ;
  int tmp ;

  {
#line 5375
  standard_info_part1(dp, pp, pi);
#line 5380
  if (dp->use_update_info) {
#line 5383
    i = dp->use_update_info;
    {
#line 5384
    while (1) {
      while_continue: /* CIL Label */ ;
#line 5384
      tmp = i;
#line 5384
      i --;
#line 5384
      if (! (tmp > 0)) {
#line 5384
        goto while_break;
      }
#line 5385
      png_read_update_info((png_structrp )pp, (png_inforp )pi);
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 5389
    png_start_read_image((png_structrp )pp);
  }
#line 5394
  standard_info_part2(dp, (png_const_structp )pp, (png_const_infop )pi, nImages);
#line 5395
  return;
}
}
#line 5397 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void standard_info(png_structp pp , png_infop pi )
{
  standard_display *dp ;
  png_voidp tmp ;

  {
#line 5400
  tmp = png_get_progressive_ptr((png_const_structrp )pp);
#line 5400
  dp = (standard_display *)tmp;
#line 5406
  standard_info_imp(dp, pp, pi, 1);
#line 5407
  return;
}
}
#line 5409 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void progressive_row(png_structp ppIn , png_bytep new_row , png_uint_32 y ,
                            int pass )
{
  png_const_structp pp ;
  standard_display const   *dp ;
  png_voidp tmp ;
  png_bytep row ;
  png_uint_32 tmp___0 ;
  png_byte tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 5412
  pp = (png_const_structp )ppIn;
#line 5413
  tmp = png_get_progressive_ptr((png_const_structrp )pp);
#line 5413
  dp = (standard_display const   *)tmp;
#line 5421
  if ((unsigned long )new_row != (unsigned long )((void *)0)) {
#line 5428
    if (dp->do_interlace) {
#line 5428
      if ((int )dp->interlace_type == 1) {
#line 5432
        tmp___0 = png_get_current_row_number((png_const_structrp )pp);
#line 5432
        if (y != tmp___0) {
#line 5433
          png_error((png_const_structrp )pp, (png_const_charp )"png_get_current_row_number is broken");
        }
#line 5435
        tmp___1 = png_get_current_pass_number((png_const_structrp )pp);
#line 5435
        if (pass != (int )tmp___1) {
#line 5436
          png_error((png_const_structrp )pp, (png_const_charp )"png_get_current_pass_number is broken");
        }
#line 5439
        if (pass > 2) {
#line 5439
          tmp___2 = (8 - pass) >> 1;
        } else {
#line 5439
          tmp___2 = 3;
        }
#line 5439
        y = (y << tmp___2) + (png_uint_32 )(((1 & ~ pass) << (3 - (pass >> 1))) & 7);
      }
    }
#line 5443
    if (y >= (png_uint_32 )dp->h) {
#line 5444
      png_error((png_const_structrp )pp, (png_const_charp )"invalid y to progressive row callback");
    }
#line 5446
    row = store_image_row((png_store const   *)dp->ps, pp, 0, y);
#line 5450
    if (dp->do_interlace) {
#line 5453
      if ((int )dp->interlace_type == 1) {
#line 5454
        deinterlace_row(row, (png_const_bytep )new_row, (unsigned int )dp->pixel_size,
                        (png_uint_32 )dp->w, pass, (int )dp->littleendian);
      } else {
#line 5457
        row_copy(row, (png_const_bytep )new_row, (unsigned int )(dp->pixel_size * dp->w),
                 (int )dp->littleendian);
      }
    } else {
#line 5461
      png_progressive_combine_row((png_const_structrp )pp, row, (png_const_bytep )new_row);
    }
  } else
#line 5465
  if ((int )dp->interlace_type == 1) {
#line 5465
    if (((((0x110145AF >> ((7 - pass) << 2)) & 0xF) | ((0x01145AF0 >> ((7 - pass) << 2)) & 0xF0)) >> (y & 7U)) & 1) {
#line 5465
      if (pass > 1) {
#line 5465
        tmp___3 = (7 - pass) >> 1;
      } else {
#line 5465
        tmp___3 = 3;
      }
#line 5465
      if (pass > 1) {
#line 5465
        tmp___4 = (7 - pass) >> 1;
      } else {
#line 5465
        tmp___4 = 3;
      }
#line 5465
      if ((dp->w + (png_uint_32 )(((1 << tmp___3) - 1) - (((1 & pass) << (3 - ((pass + 1) >> 1))) & 7))) >> tmp___4 > 0U) {
#line 5468
        png_error((png_const_structrp )pp, (png_const_charp )"missing row in progressive de-interlacing");
      }
    }
  }
#line 5469
  return;
}
}
#line 5471 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void sequential_row(standard_display *dp , png_structp pp , png_infop pi ,
                           int iImage , int iDisplay )
{
  int npasses ;
  int do_interlace ;
  int tmp ;
  png_uint_32 height ;
  png_uint_32 tmp___0 ;
  png_uint_32 width ;
  png_uint_32 tmp___1 ;
  png_store const   *ps ;
  int pass ;
  png_uint_32 y ;
  png_uint_32 wPass ;
  int tmp___2 ;
  int tmp___3 ;
  png_byte row[1024U] ;
  png_byte display[1024U] ;
  png_bytep tmp___4 ;
  png_bytep tmp___5 ;
  png_bytep tmp___6 ;
  png_bytep tmp___7 ;
  png_bytep tmp___8 ;
  png_bytep tmp___9 ;

  {
#line 5475
  npasses = dp->npasses;
#line 5476
  if (dp->do_interlace) {
#line 5476
    if ((int )dp->interlace_type == 1) {
#line 5476
      tmp = 1;
    } else {
#line 5476
      tmp = 0;
    }
  } else {
#line 5476
    tmp = 0;
  }
#line 5476
  do_interlace = tmp;
#line 5478
  tmp___0 = standard_height((png_const_structp )pp, dp->id);
#line 5478
  height = tmp___0;
#line 5479
  tmp___1 = standard_width((png_const_structp )pp, dp->id);
#line 5479
  width = tmp___1;
#line 5480
  ps = (png_store const   *)dp->ps;
#line 5483
  pass = 0;
  {
#line 5483
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5483
    if (! (pass < npasses)) {
#line 5483
      goto while_break;
    }
#line 5486
    if (pass > 1) {
#line 5486
      tmp___2 = (7 - pass) >> 1;
    } else {
#line 5486
      tmp___2 = 3;
    }
#line 5486
    if (pass > 1) {
#line 5486
      tmp___3 = (7 - pass) >> 1;
    } else {
#line 5486
      tmp___3 = 3;
    }
#line 5486
    wPass = (width + (png_uint_32 )(((1 << tmp___2) - 1) - (((1 & pass) << (3 - ((pass + 1) >> 1))) & 7))) >> tmp___3;
#line 5488
    y = (png_uint_32 )0;
    {
#line 5488
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 5488
      if (! (y < height)) {
#line 5488
        goto while_break___0;
      }
#line 5490
      if (do_interlace) {
#line 5495
        if (wPass > 0U) {
#line 5495
          if (((((0x110145AF >> ((7 - pass) << 2)) & 0xF) | ((0x01145AF0 >> ((7 - pass) << 2)) & 0xF0)) >> (y & 7U)) & 1) {
#line 5508
            memset((void *)(row), 0xc5, sizeof(row));
#line 5509
            memset((void *)(display), 0x5c, sizeof(display));
#line 5511
            png_read_row((png_structrp )pp, row, display);
#line 5513
            if (iImage >= 0) {
#line 5514
              tmp___4 = store_image_row(ps, (png_const_structp )pp, iImage, y);
#line 5514
              deinterlace_row(tmp___4, (png_const_bytep )(row), dp->pixel_size, dp->w,
                              pass, dp->littleendian);
            }
#line 5517
            if (iDisplay >= 0) {
#line 5518
              tmp___5 = store_image_row(ps, (png_const_structp )pp, iDisplay, y);
#line 5518
              deinterlace_row(tmp___5, (png_const_bytep )(display), dp->pixel_size,
                              dp->w, pass, dp->littleendian);
            }
          }
        }
      } else {
#line 5523
        if (iDisplay >= 0) {
#line 5523
          tmp___6 = store_image_row(ps, (png_const_structp )pp, iDisplay, y);
#line 5523
          tmp___7 = tmp___6;
        } else {
#line 5523
          tmp___7 = (png_bytep )((void *)0);
        }
#line 5523
        if (iImage >= 0) {
#line 5523
          tmp___8 = store_image_row(ps, (png_const_structp )pp, iImage, y);
#line 5523
          tmp___9 = tmp___8;
        } else {
#line 5523
          tmp___9 = (png_bytep )((void *)0);
        }
#line 5523
        png_read_row((png_structrp )pp, tmp___9, tmp___7);
      }
#line 5488
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 5483
    pass ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5532
  png_read_end((png_structrp )pp, (png_inforp )pi);
#line 5533
  return;
}
}
#line 5536 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void standard_check_text(png_const_structp pp , png_const_textp tp , png_const_charp keyword ,
                                png_const_charp text )
{
  char msg[1024] ;
  size_t pos ;
  size_t tmp ;
  size_t ok ;
  char buf[64] ;
  int tmp___0 ;
  char buf___0[64] ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
#line 5541
  tmp = safecat(msg, sizeof(msg), (size_t )0, (char const   *)"text: ");
#line 5541
  pos = tmp;
#line 5544
  pos = safecat(msg, sizeof(msg), pos, keyword);
#line 5545
  pos = safecat(msg, sizeof(msg), pos, (char const   *)": ");
#line 5546
  ok = pos;
#line 5548
  if (tp->compression != 0) {
#line 5552
    sprintf(buf, (char const   *)"compression [%d->%d], ", 0, tp->compression);
#line 5554
    pos = safecat(msg, sizeof(msg), pos, (char const   *)(buf));
  }
#line 5557
  if ((unsigned long )tp->key == (unsigned long )((void *)0)) {
#line 5557
    goto _L;
  } else {
#line 5557
    tmp___0 = strcmp((char const   *)tp->key, keyword);
#line 5557
    if (tmp___0 != 0) {
      _L: /* CIL Label */
#line 5559
      pos = safecat(msg, sizeof(msg), pos, (char const   *)"keyword \"");
#line 5560
      if ((unsigned long )tp->key != (unsigned long )((void *)0)) {
#line 5562
        pos = safecat(msg, sizeof(msg), pos, (char const   *)tp->key);
#line 5563
        pos = safecat(msg, sizeof(msg), pos, (char const   *)"\", ");
      } else {
#line 5567
        pos = safecat(msg, sizeof(msg), pos, (char const   *)"null, ");
      }
    }
  }
#line 5570
  if ((unsigned long )tp->text == (unsigned long )((void *)0)) {
#line 5571
    pos = safecat(msg, sizeof(msg), pos, (char const   *)"text lost, ");
  } else {
#line 5575
    tmp___2 = strlen(text);
#line 5575
    if (tp->text_length != (size_t )tmp___2) {
#line 5578
      tmp___1 = strlen(text);
#line 5578
      sprintf(buf___0, (char const   *)"text length changed[%lu->%lu], ", tmp___1,
              (unsigned long )tp->text_length);
#line 5580
      pos = safecat(msg, sizeof(msg), pos, (char const   *)(buf___0));
    }
#line 5583
    tmp___3 = strcmp((char const   *)tp->text, text);
#line 5583
    if (tmp___3 != 0) {
#line 5585
      pos = safecat(msg, sizeof(msg), pos, (char const   *)"text becomes \"");
#line 5586
      pos = safecat(msg, sizeof(msg), pos, (char const   *)tp->text);
#line 5587
      pos = safecat(msg, sizeof(msg), pos, (char const   *)"\" (was \"");
#line 5588
      pos = safecat(msg, sizeof(msg), pos, text);
#line 5589
      pos = safecat(msg, sizeof(msg), pos, (char const   *)"\"), ");
    }
  }
#line 5593
  if (tp->itxt_length != 0UL) {
#line 5594
    pos = safecat(msg, sizeof(msg), pos, (char const   *)"iTXt length set, ");
  }
#line 5596
  if ((unsigned long )tp->lang != (unsigned long )((void *)0)) {
#line 5598
    pos = safecat(msg, sizeof(msg), pos, (char const   *)"iTXt language \"");
#line 5599
    pos = safecat(msg, sizeof(msg), pos, (char const   *)tp->lang);
#line 5600
    pos = safecat(msg, sizeof(msg), pos, (char const   *)"\", ");
  }
#line 5603
  if ((unsigned long )tp->lang_key != (unsigned long )((void *)0)) {
#line 5605
    pos = safecat(msg, sizeof(msg), pos, (char const   *)"iTXt keyword \"");
#line 5606
    pos = safecat(msg, sizeof(msg), pos, (char const   *)tp->lang_key);
#line 5607
    pos = safecat(msg, sizeof(msg), pos, (char const   *)"\", ");
  }
#line 5610
  if (pos > ok) {
#line 5612
    msg[pos - 2UL] = (char )'\000';
#line 5613
    png_error((png_const_structrp )pp, (png_const_charp )(msg));
  }
#line 5615
  return;
}
}
#line 5617 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void standard_text_validate(standard_display *dp , png_const_structp pp , png_infop pi ,
                                   int check_end )
{
  png_textp tp ;
  png_uint_32 num_text ;
  int tmp ;
  char msg[64] ;

  {
#line 5621
  tp = (png_textp )((void *)0);
#line 5622
  tmp = png_get_text((png_const_structrp )pp, (png_inforp )pi, & tp, (int *)((void *)0));
#line 5622
  num_text = (png_uint_32 )tmp;
#line 5624
  if (num_text == 2U) {
#line 5624
    if ((unsigned long )tp != (unsigned long )((void *)0)) {
#line 5626
      standard_check_text(pp, (png_const_textp )tp, (png_const_charp )"image name",
                          (png_const_charp )(((dp->ps)->current)->name));
#line 5632
      if (check_end) {
#line 5633
        standard_check_text(pp, (png_const_textp )(tp + 1), (png_const_charp )"end marker",
                            (png_const_charp )"end");
      }
    } else {
#line 5640
      sprintf(msg, (char const   *)"expected two text items, got %lu", (unsigned long )num_text);
#line 5642
      png_error((png_const_structrp )pp, (png_const_charp )(msg));
    }
  } else {
#line 5640
    sprintf(msg, (char const   *)"expected two text items, got %lu", (unsigned long )num_text);
#line 5642
    png_error((png_const_structrp )pp, (png_const_charp )(msg));
  }
#line 5644
  return;
}
}
#line 5649 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void standard_row_validate(standard_display *dp , png_const_structp pp , int iImage ,
                                  int iDisplay , png_uint_32 y )
{
  int where ;
  png_byte std[1024U] ;
  char msg[64] ;
  png_bytep tmp ;
  png_bytep tmp___0 ;
  char msg___0[64] ;
  png_bytep tmp___1 ;
  png_bytep tmp___2 ;

  {
#line 5659
  memset((void *)(std), 178, sizeof(std));
#line 5660
  standard_row(pp, (png_byte *)(std), dp->id, y);
#line 5667
  if (iImage >= 0) {
#line 5667
    tmp___0 = store_image_row((png_store const   *)dp->ps, pp, iImage, y);
#line 5667
    where = pixel_cmp((png_const_bytep )(std), (png_const_bytep )tmp___0, dp->bit_width);
#line 5667
    if (where != 0) {
#line 5672
      tmp = store_image_row((png_store const   *)dp->ps, pp, iImage, y);
#line 5672
      sprintf(msg, (char const   *)"PNG image row[%lu][%d] changed from %.2x to %.2x",
              (unsigned long )y, where - 1, (int )std[where - 1], (int )*(tmp + (where - 1)));
#line 5675
      png_error((png_const_structrp )pp, (png_const_charp )(msg));
    }
  }
#line 5678
  if (iDisplay >= 0) {
#line 5678
    tmp___2 = store_image_row((png_store const   *)dp->ps, pp, iDisplay, y);
#line 5678
    where = pixel_cmp((png_const_bytep )(std), (png_const_bytep )tmp___2, dp->bit_width);
#line 5678
    if (where != 0) {
#line 5683
      tmp___1 = store_image_row((png_store const   *)dp->ps, pp, iDisplay, y);
#line 5683
      sprintf(msg___0, (char const   *)"display row[%lu][%d] changed from %.2x to %.2x",
              (unsigned long )y, where - 1, (int )std[where - 1], (int )*(tmp___1 + (where - 1)));
#line 5686
      png_error((png_const_structrp )pp, (png_const_charp )(msg___0));
    }
  }
#line 5688
  return;
}
}
#line 5690 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void standard_image_validate(standard_display *dp , png_const_structp pp ,
                                    int iImage , int iDisplay )
{
  png_uint_32 y ;

  {
#line 5696
  if (iImage >= 0) {
#line 5697
    store_image_check((png_store const   *)dp->ps, pp, iImage);
  }
#line 5699
  if (iDisplay >= 0) {
#line 5700
    store_image_check((png_store const   *)dp->ps, pp, iDisplay);
  }
#line 5702
  y = (png_uint_32 )0;
  {
#line 5702
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5702
    if (! (y < dp->h)) {
#line 5702
      goto while_break;
    }
#line 5703
    standard_row_validate(dp, pp, iImage, iDisplay, y);
#line 5702
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5706
  (dp->ps)->validated = 1U;
#line 5707
  return;
}
}
#line 5709 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void standard_end(png_structp ppIn , png_infop pi )
{
  png_const_structp pp ;
  standard_display *dp ;
  png_voidp tmp ;

  {
#line 5712
  pp = (png_const_structp )ppIn;
#line 5713
  tmp = png_get_progressive_ptr((png_const_structrp )pp);
#line 5713
  dp = (standard_display *)tmp;
#line 5721
  standard_text_validate(dp, pp, pi, 1);
#line 5723
  standard_image_validate(dp, pp, 0, -1);
#line 5724
  return;
}
}
#line 5727 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void standard_test(png_store *psIn , png_uint_32 const   id , int do_interlace ,
                          int use_update_info )
{
  standard_display d ;
  struct exception_context *the_exception_context ;
  png_store *fault ;
  jmp_buf *exception__prev ;
  jmp_buf exception__env ;
  png_structp pp ;
  png_infop pi ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 5732
  the_exception_context = & psIn->exception_context;
#line 5737
  standard_display_init(& d, (png_store *)psIn, (png_uint_32 )id, do_interlace, use_update_info);
#line 5742
  exception__prev = the_exception_context->penv;
#line 5742
  the_exception_context->penv = & exception__env;
#line 5742
  tmp___2 = _setjmp((struct __jmp_buf_tag *)(exception__env));
#line 5742
  if (tmp___2 == 0) {
    {
#line 5742
    while (1) {
      while_continue: /* CIL Label */ ;
#line 5750
      if (d.do_interlace) {
#line 5750
        if ((d.ps)->progressive) {
#line 5750
          tmp = "pngvalid progressive deinterlacer";
        } else {
#line 5750
          tmp = "pngvalid sequential deinterlacer";
        }
#line 5750
        tmp___1 = tmp;
      } else {
#line 5750
        if ((d.ps)->progressive) {
#line 5750
          tmp___0 = "progressive reader";
        } else {
#line 5750
          tmp___0 = "sequential reader";
        }
#line 5750
        tmp___1 = tmp___0;
      }
#line 5750
      pp = set_store_for_read(d.ps, & pi, d.id, (char const   *)tmp___1);
#line 5757
      standard_palette_init(& d);
#line 5760
      if ((d.ps)->progressive) {
#line 5762
        png_set_progressive_read_fn((png_structrp )pp, (png_voidp )(& d), & standard_info,
                                    & progressive_row, & standard_end);
#line 5766
        store_progressive_read(d.ps, pp, pi);
      } else {
#line 5771
        png_set_read_fn((png_structrp )pp, (png_voidp )d.ps, & store_read);
#line 5774
        png_read_info((png_structrp )pp, (png_inforp )pi);
#line 5779
        standard_info_imp(& d, pp, pi, 2);
#line 5786
        sequential_row(& d, pp, pi, 0, 1);
#line 5791
        if (! d.speed) {
#line 5793
          standard_text_validate(& d, (png_const_structp )pp, pi, 1);
#line 5794
          standard_image_validate(& d, (png_const_structp )pp, 0, 1);
        } else {
#line 5797
          (d.ps)->validated = 1U;
        }
      }
#line 5802
      if (! (d.ps)->validated) {
#line 5803
        png_error((png_const_structrp )pp, (png_const_charp )"image read failed silently");
      }
#line 5742
      the_exception_context->caught = 0;
#line 5742
      if (! the_exception_context->caught) {
#line 5742
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 5808
    the_exception_context->caught = 1;
  }
#line 5808
  the_exception_context->penv = exception__prev;
#line 5808
  if (! (! the_exception_context->caught)) {
#line 5808
    fault = (png_store *)the_exception_context->v.etmp;
#line 5808
    if (! 0) {
#line 5809
      d.ps = fault;
    }
  }
#line 5812
  store_read_reset(d.ps);
#line 5813
  return;
}
}
#line 5815 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int test_standard(png_modifier *pm___0 , png_byte const   colour_type , int bdlo ,
                         int const   bdhi )
{
  int interlace_type ;
  int tmp ;

  {
  {
#line 5819
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5819
    if (! (bdlo <= (int )bdhi)) {
#line 5819
      goto while_break;
    }
#line 5823
    interlace_type = 0;
    {
#line 5823
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 5823
      if (! (interlace_type < 2)) {
#line 5823
        goto while_break___0;
      }
#line 5826
      standard_test((png_store *)(& pm___0->this), (png_uint_32 const   )((png_uint_32 )(((int const   )colour_type + (int const   )((int )((png_byte )(1U << bdlo)) << 3)) + (int const   )(interlace_type << 13))),
                    0, pm___0->use_update_info);
#line 5830
      tmp = fail((png_modifier *)pm___0);
#line 5830
      if (tmp) {
#line 5831
        return (0);
      }
#line 5823
      interlace_type ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 5819
    bdlo ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5835
  return (1);
}
}
#line 5838 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void perform_standard_test(png_modifier *pm___0 )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 5844
  tmp = test_standard((png_modifier *)pm___0, (png_byte const   )0, 0, (int const   )4);
#line 5844
  if (! tmp) {
#line 5845
    return;
  }
#line 5847
  tmp___0 = test_standard((png_modifier *)pm___0, (png_byte const   )2, 3, (int const   )4);
#line 5847
  if (! tmp___0) {
#line 5848
    return;
  }
#line 5850
  tmp___1 = test_standard((png_modifier *)pm___0, (png_byte const   )3, 0, (int const   )3);
#line 5850
  if (! tmp___1) {
#line 5851
    return;
  }
#line 5853
  tmp___2 = test_standard((png_modifier *)pm___0, (png_byte const   )4, 3, (int const   )4);
#line 5853
  if (! tmp___2) {
#line 5854
    return;
  }
#line 5856
  tmp___3 = test_standard((png_modifier *)pm___0, (png_byte const   )6, 3, (int const   )4);
#line 5856
  if (! tmp___3) {
#line 5857
    return;
  }
#line 5858
  return;
}
}
#line 5873
static int test_size(png_modifier *pm___0 , png_byte const   colour_type , int bdlo ,
                     int const   bdhi ) ;
#line 5873 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static png_byte const   hinc[5]  = {      (png_byte const   )1,      (png_byte const   )3,      (png_byte const   )11,      (png_byte const   )1,
        (png_byte const   )5};
#line 5874 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static png_byte const   winc[5]  = {      (png_byte const   )1,      (png_byte const   )9,      (png_byte const   )5,      (png_byte const   )7,
        (png_byte const   )1};
#line 5862 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int test_size(png_modifier *pm___0 , png_byte const   colour_type , int bdlo ,
                     int const   bdhi )
{
  int save_bdlo ;
  png_uint_32 h ;
  png_uint_32 w ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  png_uint_32 h___0 ;
  png_uint_32 w___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 5875
  save_bdlo = bdlo;
  {
#line 5877
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5877
    if (! (bdlo <= (int )bdhi)) {
#line 5877
      goto while_break;
    }
#line 5881
    h = (png_uint_32 )1;
    {
#line 5881
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 5881
      if (! (h <= 16U)) {
#line 5881
        goto while_break___0;
      }
#line 5883
      w = (png_uint_32 )1;
      {
#line 5883
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 5883
        if (! (w <= 16U)) {
#line 5883
          goto while_break___1;
        }
#line 5890
        standard_test((png_store *)(& pm___0->this), (png_uint_32 const   )(((png_uint_32 )((int const   )colour_type + (int const   )((int )((png_byte )(1U << bdlo)) << 3)) + (w << 16)) + (h << 24)),
                      0, pm___0->use_update_info);
#line 5894
        tmp = fail((png_modifier *)pm___0);
#line 5894
        if (tmp) {
#line 5895
          return (0);
        }
#line 5897
        standard_test((png_store *)(& pm___0->this), (png_uint_32 const   )(((png_uint_32 )(((int const   )colour_type + (int const   )((int )((png_byte )(1U << bdlo)) << 3)) + (int const   )(1 << 15)) + (w << 16)) + (h << 24)),
                      0, pm___0->use_update_info);
#line 5901
        tmp___0 = fail((png_modifier *)pm___0);
#line 5901
        if (tmp___0) {
#line 5902
          return (0);
        }
#line 5908
        standard_test((png_store *)(& pm___0->this), (png_uint_32 const   )(((png_uint_32 )((int const   )colour_type + (int const   )((int )((png_byte )(1U << bdlo)) << 3)) + (w << 16)) + (h << 24)),
                      1, pm___0->use_update_info);
#line 5912
        tmp___1 = fail((png_modifier *)pm___0);
#line 5912
        if (tmp___1) {
#line 5913
          return (0);
        }
#line 5917
        standard_test((png_store *)(& pm___0->this), (png_uint_32 const   )(((png_uint_32 )((((int const   )colour_type + (int const   )((int )((png_byte )(1U << bdlo)) << 3)) + (int const   )(1 << 13)) + (int const   )(1 << 15)) + (w << 16)) + (h << 24)),
                      1, pm___0->use_update_info);
#line 5921
        tmp___2 = fail((png_modifier *)pm___0);
#line 5921
        if (tmp___2) {
#line 5922
          return (0);
        }
#line 5883
        w += (png_uint_32 )winc[bdlo];
      }
      while_break___1: /* CIL Label */ ;
      }
#line 5881
      h += (png_uint_32 )hinc[bdlo];
    }
    while_break___0: /* CIL Label */ ;
    }
#line 5877
    bdlo ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5931
  bdlo = save_bdlo;
  {
#line 5931
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 5931
    if (! (bdlo <= (int )bdhi)) {
#line 5931
      goto while_break___2;
    }
#line 5935
    h___0 = (png_uint_32 )1;
    {
#line 5935
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 5935
      if (! (h___0 <= 16U)) {
#line 5935
        goto while_break___3;
      }
#line 5937
      w___0 = (png_uint_32 )1;
      {
#line 5937
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 5937
        if (! (w___0 <= 16U)) {
#line 5937
          goto while_break___4;
        }
#line 5946
        standard_test((png_store *)(& pm___0->this), (png_uint_32 const   )(((png_uint_32 )((((int const   )colour_type + (int const   )((int )((png_byte )(1U << bdlo)) << 3)) + (int const   )(1 << 13)) + (int const   )(1 << 15)) + (w___0 << 16)) + (h___0 << 24)),
                      0, pm___0->use_update_info);
#line 5950
        tmp___3 = fail((png_modifier *)pm___0);
#line 5950
        if (tmp___3) {
#line 5951
          return (0);
        }
#line 5957
        standard_test((png_store *)(& pm___0->this), (png_uint_32 const   )(((png_uint_32 )(((int const   )colour_type + (int const   )((int )((png_byte )(1U << bdlo)) << 3)) + (int const   )(1 << 13)) + (w___0 << 16)) + (h___0 << 24)),
                      1, pm___0->use_update_info);
#line 5961
        tmp___4 = fail((png_modifier *)pm___0);
#line 5961
        if (tmp___4) {
#line 5962
          return (0);
        }
#line 5968
        standard_test((png_store *)(& pm___0->this), (png_uint_32 const   )(((png_uint_32 )(((int const   )colour_type + (int const   )((int )((png_byte )(1U << bdlo)) << 3)) + (int const   )(1 << 13)) + (w___0 << 16)) + (h___0 << 24)),
                      0, pm___0->use_update_info);
#line 5972
        tmp___5 = fail((png_modifier *)pm___0);
#line 5972
        if (tmp___5) {
#line 5973
          return (0);
        }
#line 5937
        w___0 += (png_uint_32 )winc[bdlo];
      }
      while_break___4: /* CIL Label */ ;
      }
#line 5935
      h___0 += (png_uint_32 )hinc[bdlo];
    }
    while_break___3: /* CIL Label */ ;
    }
#line 5931
    bdlo ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 5980
  return (1);
}
}
#line 5983 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void perform_size_test(png_modifier *pm___0 )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 5989
  tmp = test_size((png_modifier *)pm___0, (png_byte const   )0, 0, (int const   )4);
#line 5989
  if (! tmp) {
#line 5990
    return;
  }
#line 5992
  tmp___0 = test_size((png_modifier *)pm___0, (png_byte const   )2, 3, (int const   )4);
#line 5992
  if (! tmp___0) {
#line 5993
    return;
  }
#line 6003
  tmp___1 = test_size((png_modifier *)pm___0, (png_byte const   )4, 3, (int const   )4);
#line 6003
  if (! tmp___1) {
#line 6004
    return;
  }
#line 6006
  tmp___2 = test_size((png_modifier *)pm___0, (png_byte const   )6, 3, (int const   )4);
#line 6006
  if (! tmp___2) {
#line 6007
    return;
  }
#line 6008
  return;
}
}
#line 6053 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_pixel_setf(image_pixel *this , unsigned int rMax , unsigned int gMax ,
                             unsigned int bMax , unsigned int aMax )
{


  {
#line 6057
  this->redf = (double )this->red / (double )rMax;
#line 6058
  this->greenf = (double )this->green / (double )gMax;
#line 6059
  this->bluef = (double )this->blue / (double )bMax;
#line 6060
  this->alphaf = (double )this->alpha / (double )aMax;
#line 6062
  if (this->red < rMax) {
#line 6063
    this->rede = this->redf * (double )2.22044604925031308084726333618164062e-16L;
  } else {
#line 6065
    this->rede = (double )0;
  }
#line 6066
  if (this->green < gMax) {
#line 6067
    this->greene = this->greenf * (double )2.22044604925031308084726333618164062e-16L;
  } else {
#line 6069
    this->greene = (double )0;
  }
#line 6070
  if (this->blue < bMax) {
#line 6071
    this->bluee = this->bluef * (double )2.22044604925031308084726333618164062e-16L;
  } else {
#line 6073
    this->bluee = (double )0;
  }
#line 6074
  if (this->alpha < aMax) {
#line 6075
    this->alphae = this->alphaf * (double )2.22044604925031308084726333618164062e-16L;
  } else {
#line 6077
    this->alphae = (double )0;
  }
#line 6078
  return;
}
}
#line 6084 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_pixel_init(image_pixel *this , png_const_bytep row , png_byte colour_type ,
                             png_byte bit_depth , png_uint_32 x , struct store_palette_entry *palette ,
                             image_pixel const   *format )
{
  png_byte sample_depth ;
  int tmp ;
  unsigned int max ;
  int swap16 ;
  int tmp___0 ;
  int littleendian ;
  int tmp___1 ;
  int sig_bits ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  png_byte tmp___6 ;
  png_byte tmp___7 ;
  png_byte tmp___8 ;
  unsigned int i ;
  unsigned int i___0 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;

  {
#line 6089
  if ((int )colour_type == 3) {
#line 6089
    tmp = 8;
  } else {
#line 6089
    tmp = (int )bit_depth;
  }
#line 6089
  sample_depth = (png_byte )tmp;
#line 6091
  max = (1U << (int )sample_depth) - 1U;
#line 6092
  if ((unsigned long )format != (unsigned long )((image_pixel const   *)0)) {
#line 6092
    if (format->swap16) {
#line 6092
      tmp___0 = 1;
    } else {
#line 6092
      tmp___0 = 0;
    }
  } else {
#line 6092
    tmp___0 = 0;
  }
#line 6092
  swap16 = tmp___0;
#line 6093
  if ((unsigned long )format != (unsigned long )((image_pixel const   *)0)) {
#line 6093
    if (format->littleendian) {
#line 6093
      tmp___1 = 1;
    } else {
#line 6093
      tmp___1 = 0;
    }
  } else {
#line 6093
    tmp___1 = 0;
  }
#line 6093
  littleendian = tmp___1;
#line 6094
  if ((unsigned long )format != (unsigned long )((image_pixel const   *)0)) {
#line 6094
    if (format->sig_bits) {
#line 6094
      tmp___2 = 1;
    } else {
#line 6094
      tmp___2 = 0;
    }
  } else {
#line 6094
    tmp___2 = 0;
  }
#line 6094
  sig_bits = tmp___2;
#line 6100
  tmp___5 = sample(row, colour_type, bit_depth, x, 0U, swap16, littleendian);
#line 6100
  this->blue = tmp___5;
#line 6100
  tmp___4 = tmp___5;
#line 6100
  this->green = tmp___4;
#line 6100
  tmp___3 = tmp___4;
#line 6100
  this->red = tmp___3;
#line 6100
  this->palette_index = tmp___3;
#line 6102
  this->alpha = max;
#line 6103
  tmp___8 = sample_depth;
#line 6103
  this->alpha_sBIT = tmp___8;
#line 6103
  tmp___7 = tmp___8;
#line 6103
  this->blue_sBIT = tmp___7;
#line 6103
  tmp___6 = tmp___7;
#line 6103
  this->green_sBIT = tmp___6;
#line 6103
  this->red_sBIT = tmp___6;
#line 6107
  if ((int )colour_type == 3) {
#line 6110
    if ((unsigned long )palette != (unsigned long )((struct store_palette_entry *)0)) {
#line 6112
      i = this->palette_index;
#line 6114
      this->red = (unsigned int )(palette + i)->red;
#line 6115
      this->green = (unsigned int )(palette + i)->green;
#line 6116
      this->blue = (unsigned int )(palette + i)->blue;
#line 6117
      this->alpha = (unsigned int )(palette + i)->alpha;
    }
  } else {
#line 6123
    i___0 = 0U;
#line 6125
    if (((int )colour_type & 4) != 0) {
#line 6125
      if ((unsigned long )format != (unsigned long )((image_pixel const   *)0)) {
#line 6125
        if (format->alpha_first) {
#line 6127
          this->alpha = this->red;
#line 6129
          tmp___11 = sample(row, colour_type, bit_depth, x, 1U, swap16, littleendian);
#line 6129
          this->blue = tmp___11;
#line 6129
          tmp___10 = tmp___11;
#line 6129
          this->green = tmp___10;
#line 6129
          tmp___9 = tmp___10;
#line 6129
          this->red = tmp___9;
#line 6129
          this->palette_index = tmp___9;
#line 6131
          i___0 = 1U;
        }
      }
    }
#line 6134
    if ((int )colour_type & 2) {
#line 6137
      i___0 ++;
#line 6137
      this->green = sample(row, colour_type, bit_depth, x, i___0, swap16, littleendian);
#line 6140
      if ((unsigned long )format != (unsigned long )((image_pixel const   *)0)) {
#line 6140
        if (format->swap_rgb) {
#line 6141
          i___0 ++;
#line 6141
          this->red = sample(row, colour_type, bit_depth, x, i___0, swap16, littleendian);
        } else {
#line 6144
          i___0 ++;
#line 6144
          this->blue = sample(row, colour_type, bit_depth, x, i___0, swap16, littleendian);
        }
      } else {
#line 6144
        i___0 ++;
#line 6144
        this->blue = sample(row, colour_type, bit_depth, x, i___0, swap16, littleendian);
      }
    } else
#line 6148
    if ((unsigned long )format != (unsigned long )((image_pixel const   *)0)) {
#line 6148
      if (format->mono_inverted) {
#line 6149
        tmp___13 = this->red ^ max;
#line 6149
        this->blue = tmp___13;
#line 6149
        tmp___12 = tmp___13;
#line 6149
        this->green = tmp___12;
#line 6149
        this->red = tmp___12;
      }
    }
#line 6151
    if (((int )colour_type & 4) != 0) {
#line 6153
      if ((unsigned long )format == (unsigned long )((image_pixel const   *)0)) {
#line 6154
        i___0 ++;
#line 6154
        this->alpha = sample(row, colour_type, bit_depth, x, i___0, swap16, littleendian);
      } else
#line 6153
      if (! format->alpha_first) {
#line 6154
        i___0 ++;
#line 6154
        this->alpha = sample(row, colour_type, bit_depth, x, i___0, swap16, littleendian);
      }
#line 6157
      if ((unsigned long )format != (unsigned long )((image_pixel const   *)0)) {
#line 6157
        if (format->alpha_inverted) {
#line 6158
          this->alpha ^= max;
        }
      }
    }
  }
#line 6166
  if (sig_bits) {
#line 6166
    tmp___14 = (1U << (int )format->alpha_sBIT) - 1U;
  } else {
#line 6166
    tmp___14 = max;
  }
#line 6166
  if (sig_bits) {
#line 6166
    tmp___15 = (1U << (int )format->blue_sBIT) - 1U;
  } else {
#line 6166
    tmp___15 = max;
  }
#line 6166
  if (sig_bits) {
#line 6166
    tmp___16 = (1U << (int )format->green_sBIT) - 1U;
  } else {
#line 6166
    tmp___16 = max;
  }
#line 6166
  if (sig_bits) {
#line 6166
    tmp___17 = (1U << (int )format->red_sBIT) - 1U;
  } else {
#line 6166
    tmp___17 = max;
  }
#line 6166
  image_pixel_setf(this, tmp___17, tmp___16, tmp___15, tmp___14);
#line 6175
  this->colour_type = colour_type;
#line 6176
  this->bit_depth = bit_depth;
#line 6177
  this->sample_depth = sample_depth;
#line 6178
  this->have_tRNS = 0U;
#line 6179
  this->swap_rgb = 0U;
#line 6180
  this->alpha_first = 0U;
#line 6181
  this->alpha_inverted = 0U;
#line 6182
  this->mono_inverted = 0U;
#line 6183
  this->swap16 = 0U;
#line 6184
  this->littleendian = 0U;
#line 6185
  this->sig_bits = 0U;
#line 6186
  return;
}
}
#line 6198 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_pixel_convert_PLTE(image_pixel *this )
{


  {
#line 6201
  if ((int )this->colour_type == 3) {
#line 6203
    if (this->have_tRNS) {
#line 6205
      this->colour_type = (png_byte )6;
#line 6206
      this->have_tRNS = 0U;
    } else {
#line 6209
      this->colour_type = (png_byte )2;
    }
#line 6214
    this->bit_depth = (png_byte )8;
  }
#line 6216
  return;
}
}
#line 6225 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_pixel_add_alpha(image_pixel *this , standard_display const   *display ,
                                  int for_background )
{
  png_byte tmp ;

  {
#line 6229
  if ((int )this->colour_type == 3) {
#line 6230
    image_pixel_convert_PLTE(this);
  }
#line 6232
  if (((int )this->colour_type & 4) == 0) {
#line 6234
    if ((int )this->colour_type == 0) {
#line 6237
      if (! for_background) {
#line 6237
        if ((int )this->bit_depth < 8) {
#line 6238
          tmp = (png_byte )8;
#line 6238
          this->sample_depth = tmp;
#line 6238
          this->bit_depth = tmp;
        }
      }
#line 6241
      if (this->have_tRNS) {
#line 6251
        this->have_tRNS = 0U;
#line 6256
        if (this->red == (unsigned int )display->transparent.red) {
#line 6257
          this->alphaf = (double )0;
        } else {
#line 6259
          this->alphaf = (double )1;
        }
      } else {
#line 6262
        this->alphaf = (double )1;
      }
#line 6264
      this->colour_type = (png_byte )4;
    } else
#line 6267
    if ((int )this->colour_type == 2) {
#line 6269
      if (this->have_tRNS) {
#line 6271
        this->have_tRNS = 0U;
#line 6276
        if (this->red == (unsigned int )display->transparent.red) {
#line 6276
          if (this->green == (unsigned int )display->transparent.green) {
#line 6276
            if (this->blue == (unsigned int )display->transparent.blue) {
#line 6279
              this->alphaf = (double )0;
            } else {
#line 6281
              this->alphaf = (double )1;
            }
          } else {
#line 6281
            this->alphaf = (double )1;
          }
        } else {
#line 6281
          this->alphaf = (double )1;
        }
      } else {
#line 6284
        this->alphaf = (double )1;
      }
#line 6286
      this->colour_type = (png_byte )6;
    }
#line 6292
    this->alphae = (double )0;
#line 6293
    this->alpha_sBIT = (png_byte )display->alpha_sBIT;
  }
#line 6295
  return;
}
}
#line 6377 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void transform_set_encoding(transform_display *this )
{
  png_modifier *pm___0 ;
  int tmp ;
  int tmp___0 ;

  {
#line 6383
  pm___0 = this->pm;
#line 6385
  modifier_set_encoding(pm___0);
#line 6387
  tmp___0 = modifier_color_encoding_is_set((png_modifier const   *)pm___0);
#line 6387
  if (tmp___0) {
#line 6389
    tmp = modifier_color_encoding_is_sRGB((png_modifier const   *)pm___0);
#line 6389
    if (tmp) {
#line 6390
      srgb_modification_init(& this->srgb_mod, pm___0, (png_byte )3);
    } else {
#line 6395
      gama_modification_init(& this->gama_mod, pm___0, pm___0->current_gamma);
#line 6397
      if ((unsigned long )pm___0->current_encoding != (unsigned long )((color_encoding const   *)0)) {
#line 6398
        chrm_modification_init(& this->chrm_mod, pm___0, pm___0->current_encoding);
      }
    }
  }
#line 6401
  return;
}
}
#line 6404 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_ini_end(image_transform const   *this , transform_display *that )
{


  {
#line 6410
  return;
}
}
#line 6412 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_set_end(image_transform const   *this , transform_display *that ,
                                    png_structp pp , png_infop pi )
{


  {
#line 6420
  return;
}
}
#line 6425 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static unsigned int sample_scale(double sample_value , unsigned int scale )
{


  {
#line 6428
  sample_value = floor(sample_value * (double )scale + .5);
#line 6431
  if (! (sample_value > (double )0)) {
#line 6432
    sample_value = (double )0;
  } else
#line 6433
  if (sample_value > (double )scale) {
#line 6434
    sample_value = (double )scale;
  }
#line 6436
  return ((unsigned int )sample_value);
}
}
#line 6439 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_mod_end(image_transform const   *this , image_pixel *that ,
                                    png_const_structp pp , transform_display const   *display )
{
  unsigned int scale ;
  int sig_bits ;
  unsigned int tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 6443
  scale = (1U << (int )that->sample_depth) - 1U;
#line 6444
  sig_bits = (int )that->sig_bits;
#line 6457
  that->red = sample_scale(that->redf, scale);
#line 6463
  if (sig_bits) {
#line 6463
    if ((int )that->red_sBIT < (int )that->sample_depth) {
#line 6464
      that->red >>= (int )that->sample_depth - (int )that->red_sBIT;
    }
  }
#line 6476
  that->rede += 1. / (double )(2U * ((1U << (int )that->red_sBIT) - 1U));
#line 6478
  if ((int )that->colour_type & 2) {
#line 6480
    that->green = sample_scale(that->greenf, scale);
#line 6481
    if (sig_bits) {
#line 6481
      if ((int )that->green_sBIT < (int )that->sample_depth) {
#line 6482
        that->green >>= (int )that->sample_depth - (int )that->green_sBIT;
      }
    }
#line 6484
    that->blue = sample_scale(that->bluef, scale);
#line 6485
    if (sig_bits) {
#line 6485
      if ((int )that->blue_sBIT < (int )that->sample_depth) {
#line 6486
        that->blue >>= (int )that->sample_depth - (int )that->blue_sBIT;
      }
    }
#line 6488
    that->greene += 1. / (double )(2U * ((1U << (int )that->green_sBIT) - 1U));
#line 6489
    that->bluee += 1. / (double )(2U * ((1U << (int )that->blue_sBIT) - 1U));
  } else {
#line 6493
    tmp = that->red;
#line 6493
    that->green = tmp;
#line 6493
    that->blue = tmp;
#line 6494
    tmp___0 = that->redf;
#line 6494
    that->greenf = tmp___0;
#line 6494
    that->bluef = tmp___0;
#line 6495
    tmp___1 = that->rede;
#line 6495
    that->greene = tmp___1;
#line 6495
    that->bluee = tmp___1;
  }
#line 6498
  if ((int )that->colour_type & 4) {
#line 6501
    that->alpha = sample_scale(that->alphaf, scale);
#line 6502
    that->alphae += 1. / (double )(2U * ((1U << (int )that->alpha_sBIT) - 1U));
  } else
#line 6498
  if ((int )that->colour_type == 3) {
#line 6501
    that->alpha = sample_scale(that->alphaf, scale);
#line 6502
    that->alphae += 1. / (double )(2U * ((1U << (int )that->alpha_sBIT) - 1U));
  } else {
#line 6506
    that->alpha = scale;
#line 6507
    that->alphaf = (double )1;
#line 6508
    that->alphae = (double )0;
  }
#line 6511
  if (sig_bits) {
#line 6511
    if ((int )that->alpha_sBIT < (int )that->sample_depth) {
#line 6512
      that->alpha >>= (int )that->sample_depth - (int )that->alpha_sBIT;
    }
  }
#line 6513
  return;
}
}
#line 6516 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static image_transform image_transform_end  =
#line 6516
     {(char const   *)"(end)", 1, (struct image_transform *)0, 0U, 0U, (struct image_transform  const  *)0,
    & image_transform_ini_end, & image_transform_set_end, & image_transform_mod_end,
    (int (*)(struct image_transform *this , struct image_transform  const  **that ,
             png_byte colour_type , png_byte bit_depth ))0};
#line 6533 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void transform_display_init(transform_display *dp , png_modifier *pm___0 ,
                                   png_uint_32 id , image_transform const   *transform_list )
{


  {
#line 6537
  memset((void *)dp, 0, sizeof(*dp));
#line 6540
  standard_display_init(& dp->this, & pm___0->this, id, 0, pm___0->use_update_info);
#line 6544
  dp->pm = pm___0;
#line 6545
  dp->transform_list = transform_list;
#line 6546
  dp->max_gamma_8 = 16U;
#line 6549
  dp->output_colour_type = (png_byte )255;
#line 6550
  dp->output_bit_depth = (png_byte )255;
#line 6551
  dp->unpacked = (png_byte )0;
#line 6552
  return;
}
}
#line 6554 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void transform_info_imp(transform_display *dp , png_structp pp , png_infop pi )
{
  int i ;
  char message[128] ;
  size_t pos ;
  image_pixel test_pixel ;
  char message___0[128] ;
  size_t pos___0 ;
  size_t tmp ;
  char message___1[128] ;
  size_t pos___1 ;
  size_t tmp___0 ;
  char message___2[128] ;
  size_t pos___2 ;
  size_t tmp___1 ;
  char message___3[128] ;
  size_t pos___3 ;
  size_t tmp___2 ;

  {
#line 6558
  standard_info_part1(& dp->this, pp, pi);
#line 6561
  (*((dp->transform_list)->set))(dp->transform_list, dp, pp, pi);
#line 6565
  i = dp->this.use_update_info;
  {
#line 6567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6568
    png_read_update_info((png_structrp )pp, (png_inforp )pi);
#line 6567
    i --;
#line 6567
    if (! (i > 0)) {
#line 6567
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 6573
  standard_info_part2(& dp->this, (png_const_structp )pp, (png_const_infop )pi, 1);
#line 6576
  dp->output_colour_type = png_get_color_type((png_const_structrp )pp, (png_const_inforp )pi);
#line 6577
  dp->output_bit_depth = png_get_bit_depth((png_const_structrp )pp, (png_const_inforp )pi);
#line 6582
  if ((int )dp->output_bit_depth >= 8) {
#line 6582
    if ((int )dp->output_colour_type == 2) {
#line 6582
      goto _L;
    } else
#line 6582
    if ((int )dp->output_colour_type == 0) {
      _L: /* CIL Label */
#line 6582
      if (dp->this.filler) {
#line 6585
        dp->output_colour_type = (png_byte )((int )dp->output_colour_type | 4);
      }
    }
  }
  {
#line 6593
  if ((int )dp->output_colour_type == 3) {
#line 6593
    goto case_3;
  }
#line 6596
  if ((int )dp->output_colour_type == 0) {
#line 6596
    goto case_0;
  }
#line 6601
  goto switch_default;
  case_3: /* CIL Label */
#line 6594
  if ((int )dp->output_bit_depth > 8) {
#line 6594
    goto error;
  }
  case_0: /* CIL Label */
#line 6597
  if ((int )dp->output_bit_depth == 1) {
#line 6599
    goto switch_break;
  } else
#line 6597
  if ((int )dp->output_bit_depth == 2) {
#line 6599
    goto switch_break;
  } else
#line 6597
  if ((int )dp->output_bit_depth == 4) {
#line 6599
    goto switch_break;
  }
  switch_default: /* CIL Label */
#line 6602
  if ((int )dp->output_bit_depth == 8) {
#line 6603
    goto switch_break;
  } else
#line 6602
  if ((int )dp->output_bit_depth == 16) {
#line 6603
    goto switch_break;
  }
  error:
#line 6610
  pos = safecat(message, sizeof(message), (size_t )0, (char const   *)"invalid final bit depth: colour type(");
#line 6612
  pos = safecatn(message, sizeof(message), pos, (int )dp->output_colour_type);
#line 6613
  pos = safecat(message, sizeof(message), pos, (char const   *)") with bit depth: ");
#line 6614
  pos = safecatn(message, sizeof(message), pos, (int )dp->output_bit_depth);
#line 6616
  png_error((png_const_structrp )pp, (png_const_charp )(message));
  switch_break: /* CIL Label */ ;
  }
#line 6627
  memset((void *)(& test_pixel), 0, sizeof(test_pixel));
#line 6628
  test_pixel.colour_type = dp->this.colour_type;
#line 6629
  test_pixel.bit_depth = dp->this.bit_depth;
#line 6630
  if ((int )test_pixel.colour_type == 3) {
#line 6631
    test_pixel.sample_depth = (png_byte )8;
  } else {
#line 6633
    test_pixel.sample_depth = test_pixel.bit_depth;
  }
#line 6637
  test_pixel.have_tRNS = (unsigned int )(dp->this.is_transparent != 0);
#line 6638
  test_pixel.alpha_sBIT = test_pixel.sample_depth;
#line 6638
  test_pixel.blue_sBIT = test_pixel.alpha_sBIT;
#line 6638
  test_pixel.green_sBIT = test_pixel.blue_sBIT;
#line 6638
  test_pixel.red_sBIT = test_pixel.green_sBIT;
#line 6641
  (*((dp->transform_list)->mod))(dp->transform_list, & test_pixel, (png_const_structp )pp,
                                 (struct transform_display  const  *)dp);
#line 6643
  if ((int )test_pixel.colour_type != (int )dp->output_colour_type) {
#line 6646
    tmp = safecat(message___0, sizeof(message___0), (size_t )0, (char const   *)"colour type ");
#line 6646
    pos___0 = tmp;
#line 6648
    pos___0 = safecatn(message___0, sizeof(message___0), pos___0, (int )dp->output_colour_type);
#line 6649
    pos___0 = safecat(message___0, sizeof(message___0), pos___0, (char const   *)" expected ");
#line 6650
    pos___0 = safecatn(message___0, sizeof(message___0), pos___0, (int )test_pixel.colour_type);
#line 6652
    png_error((png_const_structrp )pp, (png_const_charp )(message___0));
  }
#line 6655
  if ((int )test_pixel.bit_depth != (int )dp->output_bit_depth) {
#line 6658
    tmp___0 = safecat(message___1, sizeof(message___1), (size_t )0, (char const   *)"bit depth ");
#line 6658
    pos___1 = tmp___0;
#line 6660
    pos___1 = safecatn(message___1, sizeof(message___1), pos___1, (int )dp->output_bit_depth);
#line 6661
    pos___1 = safecat(message___1, sizeof(message___1), pos___1, (char const   *)" expected ");
#line 6662
    pos___1 = safecatn(message___1, sizeof(message___1), pos___1, (int )test_pixel.bit_depth);
#line 6664
    png_error((png_const_structrp )pp, (png_const_charp )(message___1));
  }
#line 6669
  if ((int )test_pixel.colour_type == 3) {
#line 6669
    if ((int )test_pixel.sample_depth != 8) {
#line 6671
      png_error((png_const_structrp )pp, (png_const_charp )"pngvalid: internal: palette sample depth not 8");
    } else {
#line 6669
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */
#line 6672
  if (dp->unpacked) {
#line 6672
    if ((int )test_pixel.bit_depth != 8) {
#line 6673
      png_error((png_const_structrp )pp, (png_const_charp )"pngvalid: internal: bad unpacked pixel depth");
    } else {
#line 6672
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */
#line 6674
  if (! dp->unpacked) {
#line 6674
    if ((int )test_pixel.colour_type != 3) {
#line 6674
      if ((int )test_pixel.bit_depth != (int )test_pixel.sample_depth) {
#line 6678
        tmp___1 = safecat(message___2, sizeof(message___2), (size_t )0, (char const   *)"internal: sample depth ");
#line 6678
        pos___2 = tmp___1;
#line 6685
        pos___2 = safecatn(message___2, sizeof(message___2), pos___2, (int )test_pixel.sample_depth);
#line 6686
        pos___2 = safecat(message___2, sizeof(message___2), pos___2, (char const   *)" expected ");
#line 6687
        pos___2 = safecatn(message___2, sizeof(message___2), pos___2, (int )test_pixel.bit_depth);
#line 6689
        png_error((png_const_structrp )pp, (png_const_charp )(message___2));
      } else {
#line 6674
        goto _L___1;
      }
    } else {
#line 6674
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */
  _L___0: /* CIL Label */
#line 6691
  if ((int )test_pixel.bit_depth != (int )dp->output_bit_depth) {
#line 6697
    tmp___2 = safecat(message___3, sizeof(message___3), (size_t )0, (char const   *)"internal: bit depth ");
#line 6697
    pos___3 = tmp___2;
#line 6700
    pos___3 = safecatn(message___3, sizeof(message___3), pos___3, (int )dp->output_bit_depth);
#line 6701
    pos___3 = safecat(message___3, sizeof(message___3), pos___3, (char const   *)" expected ");
#line 6702
    pos___3 = safecatn(message___3, sizeof(message___3), pos___3, (int )test_pixel.bit_depth);
#line 6704
    png_error((png_const_structrp )pp, (png_const_charp )(message___3));
  }
#line 6707
  return;
}
}
#line 6709 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void transform_info(png_structp pp , png_infop pi )
{
  png_voidp tmp ;

  {
#line 6712
  tmp = png_get_progressive_ptr((png_const_structrp )pp);
#line 6712
  transform_info_imp((transform_display *)tmp, pp, pi);
#line 6714
  return;
}
}
#line 6716 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void transform_range_check(png_const_structp pp , unsigned int r , unsigned int g ,
                                  unsigned int b , unsigned int a , unsigned int in_digitized ,
                                  double in , unsigned int out , png_byte sample_depth ,
                                  double err , double limit , char const   *name ,
                                  double digitization_error )
{
  unsigned int max ;
  double in_min ;
  double tmp ;
  double in_max ;
  double tmp___0 ;
  char message[256] ;
  size_t pos ;

  {
#line 6728
  max = (1U << (int )sample_depth) - 1U;
#line 6729
  tmp = ceil((in - err) * (double )max - digitization_error);
#line 6729
  in_min = tmp;
#line 6730
  tmp___0 = floor((in + err) * (double )max + digitization_error);
#line 6730
  in_max = tmp___0;
#line 6731
  if ((double )out >= in_min) {
#line 6731
    if (! ((double )out <= in_max)) {
#line 6731
      goto _L;
    }
  } else {
    _L: /* CIL Label */
#line 6736
    pos = safecat(message, sizeof(message), (size_t )0, name);
#line 6737
    pos = safecat(message, sizeof(message), pos, (char const   *)" output value error: rgba(");
#line 6738
    pos = safecatn(message, sizeof(message), pos, (int )r);
#line 6739
    pos = safecat(message, sizeof(message), pos, (char const   *)",");
#line 6740
    pos = safecatn(message, sizeof(message), pos, (int )g);
#line 6741
    pos = safecat(message, sizeof(message), pos, (char const   *)",");
#line 6742
    pos = safecatn(message, sizeof(message), pos, (int )b);
#line 6743
    pos = safecat(message, sizeof(message), pos, (char const   *)",");
#line 6744
    pos = safecatn(message, sizeof(message), pos, (int )a);
#line 6745
    pos = safecat(message, sizeof(message), pos, (char const   *)"): ");
#line 6746
    pos = safecatn(message, sizeof(message), pos, (int )out);
#line 6747
    pos = safecat(message, sizeof(message), pos, (char const   *)" expected: ");
#line 6748
    pos = safecatn(message, sizeof(message), pos, (int )in_digitized);
#line 6749
    pos = safecat(message, sizeof(message), pos, (char const   *)" (");
#line 6750
    pos = safecatd(message, sizeof(message), pos, (in - err) * (double )max, 3);
#line 6751
    pos = safecat(message, sizeof(message), pos, (char const   *)"..");
#line 6752
    pos = safecatd(message, sizeof(message), pos, (in + err) * (double )max, 3);
#line 6753
    pos = safecat(message, sizeof(message), pos, (char const   *)")");
#line 6755
    png_error((png_const_structrp )pp, (png_const_charp )(message));
  }
#line 6759
  return;
}
}
#line 6761 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void transform_image_validate(transform_display *dp , png_const_structp pp ,
                                     png_infop pi )
{
  png_store const   *ps ;
  png_byte in_ct ;
  png_byte in_bd ;
  png_uint_32 w ;
  png_uint_32 h ;
  png_byte out_ct ;
  png_byte out_bd ;
  png_byte sample_depth ;
  int tmp ;
  png_byte red_sBIT ;
  png_byte green_sBIT ;
  png_byte blue_sBIT ;
  png_byte alpha_sBIT ;
  int have_tRNS ;
  double digitization_error ;
  store_palette out_palette ;
  png_uint_32 y ;
  int npalette ;
  png_byte in_sample_depth ;
  png_const_bytep pRow ;
  png_bytep tmp___0 ;
  png_uint_32 x ;
  png_byte std[1024U] ;
  image_pixel in_pixel ;
  image_pixel out_pixel ;
  unsigned int r ;
  unsigned int g ;
  unsigned int b ;
  unsigned int a ;

  {
#line 6766
  ps = (png_store const   *)dp->this.ps;
#line 6767
  in_ct = dp->this.colour_type;
#line 6768
  in_bd = dp->this.bit_depth;
#line 6769
  w = dp->this.w;
#line 6770
  h = dp->this.h;
#line 6771
  out_ct = dp->output_colour_type;
#line 6772
  out_bd = dp->output_bit_depth;
#line 6773
  if ((int )out_ct == 3) {
#line 6773
    tmp = 8;
  } else {
#line 6773
    tmp = (int )out_bd;
  }
#line 6773
  sample_depth = (png_byte )tmp;
#line 6775
  red_sBIT = dp->this.red_sBIT;
#line 6776
  green_sBIT = dp->this.green_sBIT;
#line 6777
  blue_sBIT = dp->this.blue_sBIT;
#line 6778
  alpha_sBIT = dp->this.alpha_sBIT;
#line 6779
  have_tRNS = dp->this.is_transparent;
#line 6788
  store_image_check((png_store const   *)dp->this.ps, pp, 0);
#line 6793
  if ((int )out_ct == 3) {
#line 6798
    npalette = -1;
#line 6800
    read_palette((struct store_palette_entry *)(out_palette), & npalette, pp, pi);
#line 6801
    if (npalette != dp->this.npalette) {
#line 6802
      png_error((png_const_structrp )pp, (png_const_charp )"unexpected change in palette size");
    }
#line 6804
    digitization_error = .5;
  } else {
#line 6810
    memset((void *)(out_palette), 0x5e, sizeof(out_palette));
#line 6816
    if ((int )in_ct == 3) {
#line 6817
      in_sample_depth = (png_byte )8;
    } else
#line 6816
    if ((int )in_bd < 16) {
#line 6817
      in_sample_depth = (png_byte )8;
    } else {
#line 6819
      in_sample_depth = in_bd;
    }
#line 6821
    if ((int )sample_depth != 16) {
#line 6823
      digitization_error = .5;
    } else
#line 6821
    if ((int )in_sample_depth > 8) {
#line 6823
      digitization_error = .5;
    } else
#line 6821
    if (! (dp->pm)->calculations_use_input_precision) {
#line 6823
      digitization_error = .5;
    } else {
#line 6829
      digitization_error = .5 * (double )257;
    }
  }
#line 6832
  y = (png_uint_32 )0;
  {
#line 6832
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6832
    if (! (y < h)) {
#line 6832
      goto while_break;
    }
#line 6834
    tmp___0 = store_image_row((png_store const   *)ps, pp, 0, y);
#line 6834
    pRow = (png_const_bytep )tmp___0;
#line 6840
    transform_row(pp, (png_byte *)(std), in_ct, in_bd, y);
#line 6845
    x = (png_uint_32 )0;
    {
#line 6845
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 6845
      if (! (x < w)) {
#line 6845
        goto while_break___0;
      }
#line 6851
      image_pixel_init(& in_pixel, (png_const_bytep )(std), in_ct, in_bd, x, (struct store_palette_entry *)(dp->this.palette),
                       (image_pixel const   *)((void *)0));
#line 6854
      in_pixel.red_sBIT = red_sBIT;
#line 6855
      in_pixel.green_sBIT = green_sBIT;
#line 6856
      in_pixel.blue_sBIT = blue_sBIT;
#line 6857
      in_pixel.alpha_sBIT = alpha_sBIT;
#line 6858
      in_pixel.have_tRNS = (unsigned int )(have_tRNS != 0);
#line 6861
      r = in_pixel.red;
#line 6862
      g = in_pixel.green;
#line 6863
      b = in_pixel.blue;
#line 6864
      a = in_pixel.alpha;
#line 6870
      (*((dp->transform_list)->mod))(dp->transform_list, & in_pixel, pp, (struct transform_display  const  *)dp);
#line 6876
      image_pixel_init(& out_pixel, (png_const_bytep )pRow, out_ct, out_bd, x, (struct store_palette_entry *)(out_palette),
                       (image_pixel const   *)(& in_pixel));
#line 6882
      if ((int )in_ct == 3) {
#line 6882
        if ((int )out_ct == 3) {
#line 6885
          if (in_pixel.palette_index != out_pixel.palette_index) {
#line 6886
            png_error((png_const_structrp )pp, (png_const_charp )"unexpected transformed palette index");
          }
        }
      }
#line 6892
      if (in_pixel.red != out_pixel.red) {
#line 6893
        transform_range_check(pp, r, g, b, a, in_pixel.red, in_pixel.redf, out_pixel.red,
                              sample_depth, in_pixel.rede, (dp->pm)->limit + 1. / (double )(2U * ((1U << (int )in_pixel.red_sBIT) - 1U)),
                              (char const   *)"red/gray", digitization_error);
      }
#line 6898
      if (((int )out_ct & 2) != 0) {
#line 6898
        if (in_pixel.green != out_pixel.green) {
#line 6900
          transform_range_check(pp, r, g, b, a, in_pixel.green, in_pixel.greenf, out_pixel.green,
                                sample_depth, in_pixel.greene, (dp->pm)->limit + 1. / (double )(2U * ((1U << (int )in_pixel.green_sBIT) - 1U)),
                                (char const   *)"green", digitization_error);
        }
      }
#line 6905
      if (((int )out_ct & 2) != 0) {
#line 6905
        if (in_pixel.blue != out_pixel.blue) {
#line 6907
          transform_range_check(pp, r, g, b, a, in_pixel.blue, in_pixel.bluef, out_pixel.blue,
                                sample_depth, in_pixel.bluee, (dp->pm)->limit + 1. / (double )(2U * ((1U << (int )in_pixel.blue_sBIT) - 1U)),
                                (char const   *)"blue", digitization_error);
        }
      }
#line 6912
      if (((int )out_ct & 4) != 0) {
#line 6912
        if (in_pixel.alpha != out_pixel.alpha) {
#line 6914
          transform_range_check(pp, r, g, b, a, in_pixel.alpha, in_pixel.alphaf, out_pixel.alpha,
                                sample_depth, in_pixel.alphae, (dp->pm)->limit + 1. / (double )(2U * ((1U << (int )in_pixel.alpha_sBIT) - 1U)),
                                (char const   *)"alpha", digitization_error);
        }
      }
#line 6845
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 6832
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6922
  (dp->this.ps)->validated = 1U;
#line 6923
  return;
}
}
#line 6925 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void transform_end(png_structp ppIn , png_infop pi )
{
  png_const_structp pp ;
  transform_display *dp ;
  png_voidp tmp ;

  {
#line 6928
  pp = (png_const_structp )ppIn;
#line 6929
  tmp = png_get_progressive_ptr((png_const_structrp )pp);
#line 6929
  dp = (transform_display *)tmp;
#line 6932
  if (! dp->this.speed) {
#line 6933
    transform_image_validate(dp, pp, pi);
  } else {
#line 6935
    (dp->this.ps)->validated = 1U;
  }
#line 6936
  return;
}
}
#line 6939 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void transform_test(png_modifier *pmIn , png_uint_32 idIn , image_transform const   *transform_listIn ,
                           char const   *name )
{
  transform_display d ;
  struct exception_context *the_exception_context ;
  png_store *fault ;
  jmp_buf *exception__prev ;
  jmp_buf exception__env ;
  size_t pos ;
  png_structp pp ;
  png_infop pi ;
  char full_name[256] ;
  int tmp ;

  {
#line 6944
  the_exception_context = & pmIn->this.exception_context;
#line 6946
  transform_display_init(& d, pmIn, idIn, transform_listIn);
#line 6948
  exception__prev = the_exception_context->penv;
#line 6948
  the_exception_context->penv = & exception__env;
#line 6948
  tmp = _setjmp((struct __jmp_buf_tag *)(exception__env));
#line 6948
  if (tmp == 0) {
    {
#line 6948
    while (1) {
      while_continue: /* CIL Label */ ;
#line 6950
      pos = (size_t )0;
#line 6958
      transform_set_encoding(& d);
#line 6961
      (*((d.transform_list)->ini))(d.transform_list, & d);
#line 6964
      pos = safecat(full_name, sizeof(full_name), pos, (char const   *)name);
#line 6965
      pos = safecat_current_encoding(full_name, sizeof(full_name), pos, (png_modifier const   *)d.pm);
#line 6968
      pp = set_modifier_for_read(d.pm, & pi, d.this.id, (char const   *)(full_name));
#line 6969
      standard_palette_init(& d.this);
#line 6984
      if ((d.pm)->this.progressive) {
#line 6987
        png_set_progressive_read_fn((png_structrp )pp, (png_voidp )(& d), & transform_info,
                                    & progressive_row, & transform_end);
#line 6991
        modifier_progressive_read(d.pm, pp, pi);
      } else {
#line 6996
        png_set_read_fn((png_structrp )pp, (png_voidp )d.pm, & modifier_read);
#line 6999
        png_read_info((png_structrp )pp, (png_inforp )pi);
#line 7002
        transform_info_imp(& d, pp, pi);
#line 7004
        sequential_row(& d.this, pp, pi, -1, 0);
#line 7006
        if (! d.this.speed) {
#line 7007
          transform_image_validate(& d, (png_const_structp )pp, pi);
        } else {
#line 7009
          (d.this.ps)->validated = 1U;
        }
      }
#line 7012
      modifier_reset(d.pm);
#line 6948
      the_exception_context->caught = 0;
#line 6948
      if (! the_exception_context->caught) {
#line 6948
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 7015
    the_exception_context->caught = 1;
  }
#line 7015
  the_exception_context->penv = exception__prev;
#line 7015
  if (! (! the_exception_context->caught)) {
#line 7015
    fault = (png_store *)the_exception_context->v.etmp;
#line 7015
    if (! 0) {
#line 7017
      modifier_reset((png_modifier *)((void *)fault));
    }
  }
#line 7019
  return;
}
}
#line 7042
void image_transform_default_ini(image_transform const   *this , transform_display *that ) ;
#line 7045 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
void image_transform_default_ini(image_transform const   *this , transform_display *that )
{


  {
#line 7049
  (*((this->next)->ini))((struct image_transform  const  *)this->next, that);
#line 7050
  return;
}
}
#line 7053 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int image_transform_default_add(image_transform *this , image_transform const   **that ,
                                       png_byte colour_type , png_byte bit_depth )
{


  {
#line 7060
  this->next = *that;
#line 7061
  *that = (image_transform const   *)this;
#line 7063
  return (1);
}
}
#line 7069 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_palette_to_rgb_set(image_transform const   *this ,
                                                       transform_display *that , png_structp pp ,
                                                       png_infop pi )
{


  {
#line 7073
  png_set_palette_to_rgb((png_structrp )pp);
#line 7074
  (*((this->next)->set))((struct image_transform  const  *)this->next, that, pp, pi);
#line 7075
  return;
}
}
#line 7077 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_palette_to_rgb_mod(image_transform const   *this ,
                                                       image_pixel *that , png_const_structp pp ,
                                                       transform_display const   *display )
{


  {
#line 7082
  if ((int )that->colour_type == 3) {
#line 7083
    image_pixel_convert_PLTE(that);
  }
#line 7085
  (*((this->next)->mod))((struct image_transform  const  *)this->next, that, pp, display);
#line 7086
  return;
}
}
#line 7088 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int image_transform_png_set_palette_to_rgb_add(image_transform *this , image_transform const   **that ,
                                                      png_byte colour_type , png_byte bit_depth )
{


  {
#line 7094
  this->next = *that;
#line 7095
  *that = (image_transform const   *)this;
#line 7097
  return ((int )colour_type == 3);
}
}
#line 7100 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static image_transform image_transform_palette_to_rgb  =
#line 7100
     {(char const   *)"palette_to_rgb", 1, (struct image_transform *)(& image_transform_end),
    0U, 0U, (struct image_transform  const  *)0, & image_transform_default_ini, & image_transform_png_set_palette_to_rgb_set,
    & image_transform_png_set_palette_to_rgb_mod, & image_transform_png_set_palette_to_rgb_add};
#line 7107 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_tRNS_to_alpha_set(image_transform const   *this ,
                                                      transform_display *that , png_structp pp ,
                                                      png_infop pi )
{


  {
#line 7111
  png_set_tRNS_to_alpha((png_structrp )pp);
#line 7116
  if (that->this.has_tRNS) {
#line 7117
    that->this.is_transparent = 1;
  }
#line 7119
  (*((this->next)->set))((struct image_transform  const  *)this->next, that, pp, pi);
#line 7120
  return;
}
}
#line 7122 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_tRNS_to_alpha_mod(image_transform const   *this ,
                                                      image_pixel *that , png_const_structp pp ,
                                                      transform_display const   *display )
{


  {
#line 7129
  if ((int )that->colour_type == 3) {
#line 7130
    image_pixel_convert_PLTE(that);
  }
#line 7136
  if (that->have_tRNS) {
#line 7141
    image_pixel_add_alpha(that, (standard_display const   *)(& display->this), 0);
  } else {
#line 7147
    if ((int )that->bit_depth < 8) {
#line 7148
      that->bit_depth = (png_byte )8;
    }
#line 7149
    if ((int )that->sample_depth < 8) {
#line 7150
      that->sample_depth = (png_byte )8;
    }
  }
#line 7154
  (*((this->next)->mod))((struct image_transform  const  *)this->next, that, pp, display);
#line 7155
  return;
}
}
#line 7157 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int image_transform_png_set_tRNS_to_alpha_add(image_transform *this , image_transform const   **that ,
                                                     png_byte colour_type , png_byte bit_depth )
{


  {
#line 7163
  this->next = *that;
#line 7164
  *that = (image_transform const   *)this;
#line 7171
  return (((int )colour_type & 4) == 0);
}
}
#line 7178 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static image_transform image_transform_tRNS_to_alpha  =
#line 7178
     {(char const   *)"tRNS_to_alpha", 1, (struct image_transform *)(& image_transform_palette_to_rgb),
    0U, 0U, (struct image_transform  const  *)0, & image_transform_default_ini, & image_transform_png_set_tRNS_to_alpha_set,
    & image_transform_png_set_tRNS_to_alpha_mod, & image_transform_png_set_tRNS_to_alpha_add};
#line 7185 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_gray_to_rgb_set(image_transform const   *this ,
                                                    transform_display *that , png_structp pp ,
                                                    png_infop pi )
{


  {
#line 7189
  png_set_gray_to_rgb((png_structrp )pp);
#line 7191
  (*((this->next)->set))((struct image_transform  const  *)this->next, that, pp, pi);
#line 7192
  return;
}
}
#line 7194 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_gray_to_rgb_mod(image_transform const   *this ,
                                                    image_pixel *that , png_const_structp pp ,
                                                    transform_display const   *display )
{
  png_byte tmp ;

  {
#line 7204
  if (((int )that->colour_type & 2) == 0) {
#line 7204
    if (that->have_tRNS) {
#line 7205
      image_pixel_add_alpha(that, (standard_display const   *)(& display->this), 0);
    }
  }
#line 7208
  if ((int )that->colour_type == 0) {
#line 7211
    if ((int )that->bit_depth < 8) {
#line 7212
      tmp = (png_byte )8;
#line 7212
      that->bit_depth = tmp;
#line 7212
      that->sample_depth = tmp;
    }
#line 7217
    that->colour_type = (png_byte )2;
  } else
#line 7220
  if ((int )that->colour_type == 4) {
#line 7221
    that->colour_type = (png_byte )6;
  }
#line 7223
  (*((this->next)->mod))((struct image_transform  const  *)this->next, that, pp, display);
#line 7224
  return;
}
}
#line 7226 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int image_transform_png_set_gray_to_rgb_add(image_transform *this , image_transform const   **that ,
                                                   png_byte colour_type , png_byte bit_depth )
{


  {
#line 7232
  this->next = *that;
#line 7233
  *that = (image_transform const   *)this;
#line 7235
  return (((int )colour_type & 2) == 0);
}
}
#line 7238 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static image_transform image_transform_gray_to_rgb  =
#line 7238
     {(char const   *)"gray_to_rgb", 1, (struct image_transform *)(& image_transform_tRNS_to_alpha),
    0U, 0U, (struct image_transform  const  *)0, & image_transform_default_ini, & image_transform_png_set_gray_to_rgb_set,
    & image_transform_png_set_gray_to_rgb_mod, & image_transform_png_set_gray_to_rgb_add};
#line 7245 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_expand_set(image_transform const   *this , transform_display *that ,
                                               png_structp pp , png_infop pi )
{


  {
#line 7249
  png_set_expand((png_structrp )pp);
#line 7251
  if (that->this.has_tRNS) {
#line 7252
    that->this.is_transparent = 1;
  }
#line 7254
  (*((this->next)->set))((struct image_transform  const  *)this->next, that, pp, pi);
#line 7255
  return;
}
}
#line 7257 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_expand_mod(image_transform const   *this , image_pixel *that ,
                                               png_const_structp pp , transform_display const   *display )
{
  png_byte tmp ;

  {
#line 7263
  if ((int )that->colour_type == 3) {
#line 7264
    image_pixel_convert_PLTE(that);
  } else
#line 7265
  if ((int )that->bit_depth < 8) {
#line 7266
    tmp = (png_byte )8;
#line 7266
    that->bit_depth = tmp;
#line 7266
    that->sample_depth = tmp;
  }
#line 7268
  if (that->have_tRNS) {
#line 7269
    image_pixel_add_alpha(that, (standard_display const   *)(& display->this), 0);
  }
#line 7271
  (*((this->next)->mod))((struct image_transform  const  *)this->next, that, pp, display);
#line 7272
  return;
}
}
#line 7274 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int image_transform_png_set_expand_add(image_transform *this , image_transform const   **that ,
                                              png_byte colour_type , png_byte bit_depth )
{


  {
#line 7280
  this->next = *that;
#line 7281
  *that = (image_transform const   *)this;
#line 7286
  return (((int )colour_type & 4) == 0);
}
}
#line 7289 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static image_transform image_transform_expand  =
#line 7289
     {(char const   *)"expand", 1, (struct image_transform *)(& image_transform_gray_to_rgb),
    0U, 0U, (struct image_transform  const  *)0, & image_transform_default_ini, & image_transform_png_set_expand_set,
    & image_transform_png_set_expand_mod, & image_transform_png_set_expand_add};
#line 7298 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_expand_gray_1_2_4_to_8_set(image_transform const   *this ,
                                                               transform_display *that ,
                                                               png_structp pp , png_infop pi )
{


  {
#line 7303
  png_set_expand_gray_1_2_4_to_8((png_structrp )pp);
#line 7305
  (*((this->next)->set))((struct image_transform  const  *)this->next, that, pp, pi);
#line 7306
  return;
}
}
#line 7308 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_expand_gray_1_2_4_to_8_mod(image_transform const   *this ,
                                                               image_pixel *that ,
                                                               png_const_structp pp ,
                                                               transform_display const   *display )
{


  {
#line 7314
  image_transform_png_set_expand_mod(this, that, pp, display);
#line 7323
  return;
}
}
#line 7325 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int image_transform_png_set_expand_gray_1_2_4_to_8_add(image_transform *this ,
                                                              image_transform const   **that ,
                                                              png_byte colour_type ,
                                                              png_byte bit_depth )
{
  int tmp ;

  {
#line 7330
  tmp = image_transform_png_set_expand_add(this, that, colour_type, bit_depth);
#line 7330
  return (tmp);
}
}
#line 7345 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static image_transform image_transform_expand_gray_1_2_4_to_8  =
#line 7345
     {(char const   *)"expand_gray_1_2_4_to_8", 1, (struct image_transform *)(& image_transform_expand),
    0U, 0U, (struct image_transform  const  *)0, & image_transform_default_ini, & image_transform_png_set_expand_gray_1_2_4_to_8_set,
    & image_transform_png_set_expand_gray_1_2_4_to_8_mod, & image_transform_png_set_expand_gray_1_2_4_to_8_add};
#line 7352 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_expand_16_set(image_transform const   *this ,
                                                  transform_display *that , png_structp pp ,
                                                  png_infop pi )
{


  {
#line 7356
  png_set_expand_16((png_structrp )pp);
#line 7360
  if (that->this.has_tRNS) {
#line 7361
    that->this.is_transparent = 1;
  }
#line 7364
  (*((this->next)->set))((struct image_transform  const  *)this->next, that, pp, pi);
#line 7365
  return;
}
}
#line 7367 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_expand_16_mod(image_transform const   *this ,
                                                  image_pixel *that , png_const_structp pp ,
                                                  transform_display const   *display )
{
  png_byte tmp ;

  {
#line 7375
  if ((int )that->colour_type == 3) {
#line 7376
    image_pixel_convert_PLTE(that);
  }
#line 7378
  if (that->have_tRNS) {
#line 7379
    image_pixel_add_alpha(that, (standard_display const   *)(& display->this), 0);
  }
#line 7381
  if ((int )that->bit_depth < 16) {
#line 7382
    tmp = (png_byte )16;
#line 7382
    that->bit_depth = tmp;
#line 7382
    that->sample_depth = tmp;
  }
#line 7384
  (*((this->next)->mod))((struct image_transform  const  *)this->next, that, pp, display);
#line 7385
  return;
}
}
#line 7387 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int image_transform_png_set_expand_16_add(image_transform *this , image_transform const   **that ,
                                                 png_byte colour_type , png_byte bit_depth )
{


  {
#line 7393
  this->next = *that;
#line 7394
  *that = (image_transform const   *)this;
#line 7397
  return ((int )bit_depth < 16);
}
}
#line 7400 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static image_transform image_transform_expand_16  =
#line 7400
     {(char const   *)"expand_16", 1, (struct image_transform *)(& image_transform_expand_gray_1_2_4_to_8),
    0U, 0U, (struct image_transform  const  *)0, & image_transform_default_ini, & image_transform_png_set_expand_16_set,
    & image_transform_png_set_expand_16_mod, & image_transform_png_set_expand_16_add};
#line 7407 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_scale_16_set(image_transform const   *this , transform_display *that ,
                                                 png_structp pp , png_infop pi )
{


  {
#line 7411
  png_set_scale_16((png_structrp )pp);
#line 7414
  that->max_gamma_8 = 11U;
#line 7416
  (*((this->next)->set))((struct image_transform  const  *)this->next, that, pp, pi);
#line 7417
  return;
}
}
#line 7419 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_scale_16_mod(image_transform const   *this , image_pixel *that ,
                                                 png_const_structp pp , transform_display const   *display )
{
  png_byte tmp ;

  {
#line 7424
  if ((int )that->bit_depth == 16) {
#line 7426
    tmp = (png_byte )8;
#line 7426
    that->bit_depth = tmp;
#line 7426
    that->sample_depth = tmp;
#line 7427
    if ((int )that->red_sBIT > 8) {
#line 7427
      that->red_sBIT = (png_byte )8;
    }
#line 7428
    if ((int )that->green_sBIT > 8) {
#line 7428
      that->green_sBIT = (png_byte )8;
    }
#line 7429
    if ((int )that->blue_sBIT > 8) {
#line 7429
      that->blue_sBIT = (png_byte )8;
    }
#line 7430
    if ((int )that->alpha_sBIT > 8) {
#line 7430
      that->alpha_sBIT = (png_byte )8;
    }
  }
#line 7433
  (*((this->next)->mod))((struct image_transform  const  *)this->next, that, pp, display);
#line 7434
  return;
}
}
#line 7436 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int image_transform_png_set_scale_16_add(image_transform *this , image_transform const   **that ,
                                                png_byte colour_type , png_byte bit_depth )
{


  {
#line 7442
  this->next = *that;
#line 7443
  *that = (image_transform const   *)this;
#line 7445
  return ((int )bit_depth > 8);
}
}
#line 7448 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static image_transform image_transform_scale_16  =
#line 7448
     {(char const   *)"scale_16", 1, (struct image_transform *)(& image_transform_expand_16),
    0U, 0U, (struct image_transform  const  *)0, & image_transform_default_ini, & image_transform_png_set_scale_16_set,
    & image_transform_png_set_scale_16_mod, & image_transform_png_set_scale_16_add};
#line 7455 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_strip_16_set(image_transform const   *this , transform_display *that ,
                                                 png_structp pp , png_infop pi )
{


  {
#line 7459
  png_set_strip_16((png_structrp )pp);
#line 7462
  that->max_gamma_8 = 11U;
#line 7464
  (*((this->next)->set))((struct image_transform  const  *)this->next, that, pp, pi);
#line 7465
  return;
}
}
#line 7467 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_strip_16_mod(image_transform const   *this , image_pixel *that ,
                                                 png_const_structp pp , transform_display const   *display )
{
  png_byte tmp ;

  {
#line 7472
  if ((int )that->bit_depth == 16) {
#line 7474
    tmp = (png_byte )8;
#line 7474
    that->bit_depth = tmp;
#line 7474
    that->sample_depth = tmp;
#line 7475
    if ((int )that->red_sBIT > 8) {
#line 7475
      that->red_sBIT = (png_byte )8;
    }
#line 7476
    if ((int )that->green_sBIT > 8) {
#line 7476
      that->green_sBIT = (png_byte )8;
    }
#line 7477
    if ((int )that->blue_sBIT > 8) {
#line 7477
      that->blue_sBIT = (png_byte )8;
    }
#line 7478
    if ((int )that->alpha_sBIT > 8) {
#line 7478
      that->alpha_sBIT = (png_byte )8;
    }
  }
#line 7504
  (*((this->next)->mod))((struct image_transform  const  *)this->next, that, pp, display);
#line 7505
  return;
}
}
#line 7507 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int image_transform_png_set_strip_16_add(image_transform *this , image_transform const   **that ,
                                                png_byte colour_type , png_byte bit_depth )
{


  {
#line 7513
  this->next = *that;
#line 7514
  *that = (image_transform const   *)this;
#line 7516
  return ((int )bit_depth > 8);
}
}
#line 7519 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static image_transform image_transform_strip_16  =
#line 7519
     {(char const   *)"strip_16", 1, (struct image_transform *)(& image_transform_scale_16),
    0U, 0U, (struct image_transform  const  *)0, & image_transform_default_ini, & image_transform_png_set_strip_16_set,
    & image_transform_png_set_strip_16_mod, & image_transform_png_set_strip_16_add};
#line 7526 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_strip_alpha_set(image_transform const   *this ,
                                                    transform_display *that , png_structp pp ,
                                                    png_infop pi )
{


  {
#line 7530
  png_set_strip_alpha((png_structrp )pp);
#line 7531
  (*((this->next)->set))((struct image_transform  const  *)this->next, that, pp, pi);
#line 7532
  return;
}
}
#line 7534 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_strip_alpha_mod(image_transform const   *this ,
                                                    image_pixel *that , png_const_structp pp ,
                                                    transform_display const   *display )
{


  {
#line 7539
  if ((int )that->colour_type == 4) {
#line 7540
    that->colour_type = (png_byte )0;
  } else
#line 7541
  if ((int )that->colour_type == 6) {
#line 7542
    that->colour_type = (png_byte )2;
  }
#line 7544
  that->have_tRNS = 0U;
#line 7545
  that->alphaf = (double )1;
#line 7547
  (*((this->next)->mod))((struct image_transform  const  *)this->next, that, pp, display);
#line 7548
  return;
}
}
#line 7550 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int image_transform_png_set_strip_alpha_add(image_transform *this , image_transform const   **that ,
                                                   png_byte colour_type , png_byte bit_depth )
{


  {
#line 7556
  this->next = *that;
#line 7557
  *that = (image_transform const   *)this;
#line 7559
  return (((int )colour_type & 4) != 0);
}
}
#line 7562 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static image_transform image_transform_strip_alpha  =
#line 7562
     {(char const   *)"strip_alpha", 1, (struct image_transform *)(& image_transform_strip_16),
    0U, 0U, (struct image_transform  const  *)0, & image_transform_default_ini, & image_transform_png_set_strip_alpha_set,
    & image_transform_png_set_strip_alpha_mod, & image_transform_png_set_strip_alpha_add};
#line 7606 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static struct __anonstruct_image_transform_data_rgb_to_gray_394210925 image_transform_data_rgb_to_gray  ;
#line 7610 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_rgb_to_gray_ini(image_transform const   *this ,
                                                    transform_display *that )
{
  png_modifier *pm___0 ;
  color_encoding const   *e ;
  double whiteY ;
  png_uint_32 ru ;
  double total ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 7614
  pm___0 = that->pm;
#line 7615
  e = pm___0->current_encoding;
#line 7620
  pm___0->test_uses_encoding = 1U;
#line 7625
  if ((unsigned long )e != (unsigned long )((color_encoding const   *)0)) {
#line 7630
    whiteY = (e->red.Y + e->green.Y) + e->blue.Y;
#line 7632
    image_transform_data_rgb_to_gray.red_coefficient = (double )e->red.Y;
#line 7633
    image_transform_data_rgb_to_gray.green_coefficient = (double )e->green.Y;
#line 7634
    image_transform_data_rgb_to_gray.blue_coefficient = (double )e->blue.Y;
#line 7636
    if (whiteY != (double )1) {
#line 7638
      image_transform_data_rgb_to_gray.red_coefficient /= (double )whiteY;
#line 7639
      image_transform_data_rgb_to_gray.green_coefficient /= (double )whiteY;
#line 7640
      image_transform_data_rgb_to_gray.blue_coefficient /= (double )whiteY;
    }
  } else {
#line 7648
    image_transform_data_rgb_to_gray.red_coefficient = (double )6968 / 32768.;
#line 7649
    image_transform_data_rgb_to_gray.green_coefficient = (double )23434 / 32768.;
#line 7650
    image_transform_data_rgb_to_gray.blue_coefficient = (double )2366 / 32768.;
  }
#line 7658
  image_transform_data_rgb_to_gray.gamma = pm___0->current_gamma;
#line 7661
  if (image_transform_data_rgb_to_gray.gamma == (double )0) {
#line 7662
    image_transform_data_rgb_to_gray.gamma = (double )1;
  }
#line 7668
  if (pm___0->test_exhaustive) {
#line 7674
    image_transform_data_rgb_to_gray.coefficients_overridden = ! image_transform_data_rgb_to_gray.coefficients_overridden;
#line 7675
    pm___0->repeat = (unsigned int )(image_transform_data_rgb_to_gray.coefficients_overridden != 0);
  } else {
#line 7679
    image_transform_data_rgb_to_gray.coefficients_overridden = random_choice();
  }
#line 7681
  if (image_transform_data_rgb_to_gray.coefficients_overridden) {
#line 7689
    ru = random_u32();
#line 7690
    total = (double )(ru & 65535U) / 65535.;
#line 7690
    image_transform_data_rgb_to_gray.green_coefficient = total;
#line 7691
    ru >>= 16;
#line 7692
    image_transform_data_rgb_to_gray.red_coefficient = (((double )1 - total) * (double )(ru & 65535U)) / 65535.;
#line 7693
    total += image_transform_data_rgb_to_gray.red_coefficient;
#line 7694
    image_transform_data_rgb_to_gray.blue_coefficient = (double )1 - total;
#line 7697
    image_transform_data_rgb_to_gray.red_to_set = image_transform_data_rgb_to_gray.red_coefficient;
#line 7698
    image_transform_data_rgb_to_gray.green_to_set = image_transform_data_rgb_to_gray.green_coefficient;
#line 7705
    pm___0->encoding_ignored = 1;
  } else {
#line 7710
    image_transform_data_rgb_to_gray.red_to_set = (double )-1;
#line 7711
    image_transform_data_rgb_to_gray.green_to_set = (double )-1;
  }
#line 7717
  if (image_transform_data_rgb_to_gray.gamma != (double )1) {
#line 7719
    if ((int )that->this.bit_depth == 16) {
#line 7719
      goto _L;
    } else
#line 7719
    if (pm___0->assume_16_bit_calculations) {
      _L: /* CIL Label */
#line 7731
      if ((int )that->this.bit_depth < 16) {
#line 7732
        that->max_gamma_8 = 11U;
      }
#line 7734
      if ((int )that->this.bit_depth == 16) {
#line 7734
        tmp = 8.;
      } else
#line 7734
      if (that->max_gamma_8 > 14U) {
#line 7734
        tmp = 8.;
      } else {
#line 7734
        tmp = 6. + (double )(1 << (15U - that->max_gamma_8));
      }
#line 7734
      tmp___0 = pow(tmp / (double )65535, image_transform_data_rgb_to_gray.gamma);
#line 7734
      (that->pm)->limit += tmp___0;
    } else {
#line 7754
      tmp___1 = pow(2.0 / (double )255, image_transform_data_rgb_to_gray.gamma);
#line 7754
      (that->pm)->limit += tmp___1;
    }
  } else
#line 7766
  if ((int )that->this.bit_depth != 16) {
#line 7766
    if (! pm___0->assume_16_bit_calculations) {
#line 7767
      (that->pm)->limit += 4E-3;
    }
  }
#line 7769
  return;
}
}
#line 7771 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_rgb_to_gray_set(image_transform const   *this ,
                                                    transform_display *that , png_structp pp ,
                                                    png_infop pi )
{
  int error_action ;
  double rX ;
  double gX ;
  double bX ;
  double rY ;
  double gY ;
  double bY ;
  double rZ ;
  double gZ ;
  double bZ ;
  double maxe ;
  char const   *el ;
  color_encoding e ;
  color_encoding o ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double err ;
  double tmp___2 ;
  double err___0 ;
  double tmp___3 ;
  double err___1 ;
  double tmp___4 ;
  double err___2 ;
  double tmp___5 ;
  double err___3 ;
  double tmp___6 ;
  double err___4 ;
  double tmp___7 ;
  double err___5 ;
  double tmp___8 ;
  double err___6 ;
  double tmp___9 ;
  double err___7 ;
  double tmp___10 ;
  size_t pos ;
  char buffer___0[256] ;
  png_uint_32 tmp___11 ;

  {
#line 7775
  error_action = 1;
#line 7778
  png_set_rgb_to_gray((png_structrp )pp, error_action, image_transform_data_rgb_to_gray.red_to_set,
                      image_transform_data_rgb_to_gray.green_to_set);
#line 7785
  if ((unsigned long )(that->pm)->current_encoding != (unsigned long )((color_encoding const   *)0)) {
#line 7808
    tmp___11 = png_get_cHRM_XYZ((png_const_structrp )pp, (png_const_inforp )pi, & rX,
                                & rY, & rZ, & gX, & gY, & gZ, & bX, & bY, & bZ);
#line 7808
    if ((tmp___11 & 0x0004U) != 0U) {
#line 7818
      modifier_current_encoding((png_modifier const   *)that->pm, & o);
#line 7819
      normalize_color_encoding(& o);
#line 7825
      if (image_transform_data_rgb_to_gray.red_to_set == (double )-1) {
#line 7825
        if (image_transform_data_rgb_to_gray.green_to_set == (double )-1) {
#line 7825
          tmp = fabs(o.red.Y - image_transform_data_rgb_to_gray.red_coefficient);
#line 7825
          if (tmp > (double )2.22044604925031308084726333618164062e-16L) {
#line 7829
            png_error((png_const_structrp )pp, (png_const_charp )"internal pngvalid cHRM coefficient error");
          } else {
#line 7825
            tmp___0 = fabs(o.green.Y - image_transform_data_rgb_to_gray.green_coefficient);
#line 7825
            if (tmp___0 > (double )2.22044604925031308084726333618164062e-16L) {
#line 7829
              png_error((png_const_structrp )pp, (png_const_charp )"internal pngvalid cHRM coefficient error");
            } else {
#line 7825
              tmp___1 = fabs(o.blue.Y - image_transform_data_rgb_to_gray.blue_coefficient);
#line 7825
              if (tmp___1 > (double )2.22044604925031308084726333618164062e-16L) {
#line 7829
                png_error((png_const_structrp )pp, (png_const_charp )"internal pngvalid cHRM coefficient error");
              }
            }
          }
        }
      }
#line 7832
      e.gamma = o.gamma;
#line 7833
      e.red.X = rX;
#line 7834
      e.red.Y = rY;
#line 7835
      e.red.Z = rZ;
#line 7836
      e.green.X = gX;
#line 7837
      e.green.Y = gY;
#line 7838
      e.green.Z = gZ;
#line 7839
      e.blue.X = bX;
#line 7840
      e.blue.Y = bY;
#line 7841
      e.blue.Z = bZ;
#line 7846
      maxe = (double )0;
#line 7847
      el = (char const   *)"-";
#line 7859
      tmp___2 = fabs(o.red.X - e.red.X);
#line 7859
      err = tmp___2;
#line 7859
      if (err > maxe) {
#line 7859
        maxe = err;
#line 7859
        el = (char const   *)"red(X)";
      }
#line 7860
      tmp___3 = fabs(o.red.Y - e.red.Y);
#line 7860
      err___0 = tmp___3;
#line 7860
      if (err___0 > maxe) {
#line 7860
        maxe = err___0;
#line 7860
        el = (char const   *)"red(Y)";
      }
#line 7861
      tmp___4 = fabs(o.red.Z - e.red.Z);
#line 7861
      err___1 = tmp___4;
#line 7861
      if (err___1 > maxe) {
#line 7861
        maxe = err___1;
#line 7861
        el = (char const   *)"red(Z)";
      }
#line 7862
      tmp___5 = fabs(o.green.X - e.green.X);
#line 7862
      err___2 = tmp___5;
#line 7862
      if (err___2 > maxe) {
#line 7862
        maxe = err___2;
#line 7862
        el = (char const   *)"green(X)";
      }
#line 7863
      tmp___6 = fabs(o.green.Y - e.green.Y);
#line 7863
      err___3 = tmp___6;
#line 7863
      if (err___3 > maxe) {
#line 7863
        maxe = err___3;
#line 7863
        el = (char const   *)"green(Y)";
      }
#line 7864
      tmp___7 = fabs(o.green.Z - e.green.Z);
#line 7864
      err___4 = tmp___7;
#line 7864
      if (err___4 > maxe) {
#line 7864
        maxe = err___4;
#line 7864
        el = (char const   *)"green(Z)";
      }
#line 7865
      tmp___8 = fabs(o.blue.X - e.blue.X);
#line 7865
      err___5 = tmp___8;
#line 7865
      if (err___5 > maxe) {
#line 7865
        maxe = err___5;
#line 7865
        el = (char const   *)"blue(X)";
      }
#line 7866
      tmp___9 = fabs(o.blue.Y - e.blue.Y);
#line 7866
      err___6 = tmp___9;
#line 7866
      if (err___6 > maxe) {
#line 7866
        maxe = err___6;
#line 7866
        el = (char const   *)"blue(Y)";
      }
#line 7867
      tmp___10 = fabs(o.blue.Z - e.blue.Z);
#line 7867
      err___7 = tmp___10;
#line 7867
      if (err___7 > maxe) {
#line 7867
        maxe = err___7;
#line 7867
        el = (char const   *)"blue(Z)";
      }
#line 7873
      if (maxe >= 1E-5) {
#line 7875
        pos = (size_t )0;
#line 7878
        pos = safecat(buffer___0, sizeof(buffer___0), pos, (char const   *)"FP");
#line 7879
        pos = safecat(buffer___0, sizeof(buffer___0), pos, (char const   *)" cHRM ");
#line 7880
        pos = safecat(buffer___0, sizeof(buffer___0), pos, el);
#line 7881
        pos = safecat(buffer___0, sizeof(buffer___0), pos, (char const   *)" error: ");
#line 7882
        pos = safecatd(buffer___0, sizeof(buffer___0), pos, maxe, 7);
#line 7883
        pos = safecat(buffer___0, sizeof(buffer___0), pos, (char const   *)" ");
#line 7885
        pos = safecat_color_encoding(buffer___0, sizeof(buffer___0), pos, (color_encoding const   *)(& o),
                                     (double )0);
#line 7886
        pos = safecat(buffer___0, sizeof(buffer___0), pos, (char const   *)" -> ");
#line 7887
        pos = safecat_color_encoding(buffer___0, sizeof(buffer___0), pos, (color_encoding const   *)(& e),
                                     (double )0);
#line 7889
        png_error((png_const_structrp )pp, (png_const_charp )(buffer___0));
      }
    }
  }
#line 7895
  (*((this->next)->set))((struct image_transform  const  *)this->next, that, pp, pi);
#line 7896
  return;
}
}
#line 7898 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_rgb_to_gray_mod(image_transform const   *this ,
                                                    image_pixel *that , png_const_structp pp ,
                                                    transform_display const   *display )
{
  double gray ;
  double err ;
  png_modifier *pm___0 ;
  unsigned int sample_depth ;
  unsigned int calc_depth ;
  unsigned int tmp ;
  unsigned int gamma_depth ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  int isgray ;
  double r ;
  double g ;
  double b ;
  double rlo ;
  double rhi ;
  double glo ;
  double ghi ;
  double blo ;
  double bhi ;
  double graylo ;
  double grayhi ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  int tmp___8 ;
  double power ;
  double abse ;
  int tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  double tmp___15 ;
  double tmp___16 ;
  double tmp___17 ;
  double tmp___18 ;
  double tmp___19 ;
  double tmp___20 ;
  double tmp___21 ;
  double tmp___22 ;
  double tmp___23 ;
  double tmp___24 ;
  double tmp___25 ;
  double tmp___26 ;
  double tmp___27 ;
  int do_round ;
  int tmp___28 ;
  double ce ;
  double tmp___29 ;
  double tmp___30 ;
  double power___0 ;
  double tmp___31 ;
  double tmp___32 ;
  double tmp___33 ;
  double tmp___34 ;
  double tmp___35 ;
  double tmp___36 ;
  double tmp___37 ;
  double tmp___38 ;
  double tmp___39 ;
  double tmp___40 ;
  double tmp___41 ;
  double tmp___42 ;
  double tmp___43 ;
  double tmp___44 ;
  double tmp___45 ;
  png_byte tmp___46 ;

  {
#line 7903
  if (((int )that->colour_type & 2) != 0) {
#line 7908
    if ((int )that->colour_type == 3) {
#line 7909
      image_pixel_convert_PLTE(that);
    }
#line 7915
    pm___0 = (png_modifier *)display->pm;
#line 7916
    sample_depth = (unsigned int )that->sample_depth;
#line 7917
    if (pm___0->assume_16_bit_calculations) {
#line 7917
      tmp = 16U;
    } else {
#line 7917
      tmp = sample_depth;
    }
#line 7917
    calc_depth = tmp;
#line 7919
    if (sample_depth == 16U) {
#line 7919
      tmp___1 = display->max_gamma_8;
    } else {
#line 7919
      if (pm___0->assume_16_bit_calculations) {
#line 7919
        tmp___0 = display->max_gamma_8;
      } else {
#line 7919
        tmp___0 = (unsigned int )sample_depth;
      }
#line 7919
      tmp___1 = tmp___0;
    }
#line 7919
    gamma_depth = (unsigned int )tmp___1;
#line 7946
    rhi = that->redf;
#line 7946
    rlo = rhi;
#line 7946
    r = rlo;
#line 7947
    rlo -= that->rede;
#line 7948
    tmp___2 = digitize(rlo * ((double )1 - (double )2.22044604925031308084726333618164062e-16L),
                       (int )calc_depth, 1);
#line 7948
    rlo = tmp___2 * ((double )1 - (double )2.22044604925031308084726333618164062e-16L);
#line 7949
    rhi += that->rede;
#line 7950
    tmp___3 = digitize(rhi * ((double )1 + (double )2.22044604925031308084726333618164062e-16L),
                       (int )calc_depth, 1);
#line 7950
    rhi = tmp___3 * ((double )1 + (double )2.22044604925031308084726333618164062e-16L);
#line 7952
    ghi = that->greenf;
#line 7952
    glo = ghi;
#line 7952
    g = glo;
#line 7953
    glo -= that->greene;
#line 7954
    tmp___4 = digitize(glo * ((double )1 - (double )2.22044604925031308084726333618164062e-16L),
                       (int )calc_depth, 1);
#line 7954
    glo = tmp___4 * ((double )1 - (double )2.22044604925031308084726333618164062e-16L);
#line 7955
    ghi += that->greene;
#line 7956
    tmp___5 = digitize(ghi * ((double )1 + (double )2.22044604925031308084726333618164062e-16L),
                       (int )calc_depth, 1);
#line 7956
    ghi = tmp___5 * ((double )1 + (double )2.22044604925031308084726333618164062e-16L);
#line 7958
    bhi = that->bluef;
#line 7958
    blo = bhi;
#line 7958
    b = blo;
#line 7959
    blo -= that->bluee;
#line 7960
    tmp___6 = digitize(blo * ((double )1 - (double )2.22044604925031308084726333618164062e-16L),
                       (int )calc_depth, 1);
#line 7960
    blo = tmp___6 * ((double )1 - (double )2.22044604925031308084726333618164062e-16L);
#line 7961
    bhi += that->bluee;
#line 7962
    tmp___7 = digitize(bhi * ((double )1 + (double )2.22044604925031308084726333618164062e-16L),
                       (int )calc_depth, 1);
#line 7962
    bhi = tmp___7 * ((double )1 + (double )2.22044604925031308084726333618164062e-16L);
#line 7964
    if (r == g) {
#line 7964
      if (g == b) {
#line 7964
        tmp___8 = 1;
      } else {
#line 7964
        tmp___8 = 0;
      }
    } else {
#line 7964
      tmp___8 = 0;
    }
#line 7964
    isgray = tmp___8;
#line 7966
    if (image_transform_data_rgb_to_gray.gamma != (double )1) {
#line 7968
      power = (double )((double )1 / image_transform_data_rgb_to_gray.gamma);
#line 7969
      if (sample_depth == 16U) {
#line 7969
        tmp___9 = 65535;
      } else {
#line 7969
        tmp___9 = 255;
      }
#line 7969
      abse = (double )(.5 / (double )tmp___9);
#line 7975
      if (gamma_depth != calc_depth) {
#line 7977
        tmp___10 = digitize(rlo * ((double )1 - (double )2.22044604925031308084726333618164062e-16L),
                            (int )gamma_depth, 0);
#line 7977
        rlo = tmp___10 * ((double )1 - (double )2.22044604925031308084726333618164062e-16L);
#line 7978
        tmp___11 = digitize(rhi * ((double )1 + (double )2.22044604925031308084726333618164062e-16L),
                            (int )gamma_depth, 0);
#line 7978
        rhi = tmp___11 * ((double )1 + (double )2.22044604925031308084726333618164062e-16L);
#line 7979
        tmp___12 = digitize(glo * ((double )1 - (double )2.22044604925031308084726333618164062e-16L),
                            (int )gamma_depth, 0);
#line 7979
        glo = tmp___12 * ((double )1 - (double )2.22044604925031308084726333618164062e-16L);
#line 7980
        tmp___13 = digitize(ghi * ((double )1 + (double )2.22044604925031308084726333618164062e-16L),
                            (int )gamma_depth, 0);
#line 7980
        ghi = tmp___13 * ((double )1 + (double )2.22044604925031308084726333618164062e-16L);
#line 7981
        tmp___14 = digitize(blo * ((double )1 - (double )2.22044604925031308084726333618164062e-16L),
                            (int )gamma_depth, 0);
#line 7981
        blo = tmp___14 * ((double )1 - (double )2.22044604925031308084726333618164062e-16L);
#line 7982
        tmp___15 = digitize(bhi * ((double )1 + (double )2.22044604925031308084726333618164062e-16L),
                            (int )gamma_depth, 0);
#line 7982
        bhi = tmp___15 * ((double )1 + (double )2.22044604925031308084726333618164062e-16L);
      }
#line 7986
      r = pow(r, (double )power);
#line 7987
      tmp___16 = pow(rlo, (double )power);
#line 7987
      tmp___17 = digitize(tmp___16 - (double )(abse * (double )((double )1 - (double )2.22044604925031308084726333618164062e-16L)),
                          (int )calc_depth, 1);
#line 7987
      rlo = tmp___17 * ((double )1 - (double )2.22044604925031308084726333618164062e-16L);
#line 7988
      tmp___18 = pow(rhi, (double )power);
#line 7988
      tmp___19 = digitize(tmp___18 + (double )(abse * (double )((double )1 + (double )2.22044604925031308084726333618164062e-16L)),
                          (int )calc_depth, 1);
#line 7988
      rhi = tmp___19 * ((double )1 + (double )2.22044604925031308084726333618164062e-16L);
#line 7990
      g = pow(g, (double )power);
#line 7991
      tmp___20 = pow(glo, (double )power);
#line 7991
      tmp___21 = digitize(tmp___20 - (double )(abse * (double )((double )1 - (double )2.22044604925031308084726333618164062e-16L)),
                          (int )calc_depth, 1);
#line 7991
      glo = tmp___21 * ((double )1 - (double )2.22044604925031308084726333618164062e-16L);
#line 7992
      tmp___22 = pow(ghi, (double )power);
#line 7992
      tmp___23 = digitize(tmp___22 + (double )(abse * (double )((double )1 + (double )2.22044604925031308084726333618164062e-16L)),
                          (int )calc_depth, 1);
#line 7992
      ghi = tmp___23 * ((double )1 + (double )2.22044604925031308084726333618164062e-16L);
#line 7994
      b = pow(b, (double )power);
#line 7995
      tmp___24 = pow(blo, (double )power);
#line 7995
      tmp___25 = digitize(tmp___24 - (double )(abse * (double )((double )1 - (double )2.22044604925031308084726333618164062e-16L)),
                          (int )calc_depth, 1);
#line 7995
      blo = tmp___25 * ((double )1 - (double )2.22044604925031308084726333618164062e-16L);
#line 7996
      tmp___26 = pow(bhi, (double )power);
#line 7996
      tmp___27 = digitize(tmp___26 + (double )(abse * (double )((double )1 + (double )2.22044604925031308084726333618164062e-16L)),
                          (int )calc_depth, 1);
#line 7996
      bhi = tmp___27 * ((double )1 + (double )2.22044604925031308084726333618164062e-16L);
    }
#line 8009
    gray = (r * image_transform_data_rgb_to_gray.red_coefficient + g * image_transform_data_rgb_to_gray.green_coefficient) + b * image_transform_data_rgb_to_gray.blue_coefficient;
#line 8013
    if (image_transform_data_rgb_to_gray.gamma != (double )1) {
#line 8013
      tmp___28 = 1;
    } else
#line 8013
    if (calc_depth == 16U) {
#line 8013
      tmp___28 = 1;
    } else {
#line 8013
      tmp___28 = 0;
    }
#line 8013
    do_round = tmp___28;
#line 8014
    ce = (double )(2. / (double )32768);
#line 8016
    tmp___29 = digitize((rlo * (image_transform_data_rgb_to_gray.red_coefficient - (double )ce) + glo * (image_transform_data_rgb_to_gray.green_coefficient - (double )ce)) + (blo * (image_transform_data_rgb_to_gray.blue_coefficient - (double )ce)) * ((double )1 - (double )2.22044604925031308084726333618164062e-16L),
                        (int )calc_depth, do_round);
#line 8016
    graylo = tmp___29 * ((double )1 - (double )2.22044604925031308084726333618164062e-16L);
#line 8019
    if (graylo > gray) {
#line 8020
      graylo = gray;
    }
#line 8022
    tmp___30 = digitize((rhi * (image_transform_data_rgb_to_gray.red_coefficient + (double )ce) + ghi * (image_transform_data_rgb_to_gray.green_coefficient + (double )ce)) + (bhi * (image_transform_data_rgb_to_gray.blue_coefficient + (double )ce)) * ((double )1 + (double )2.22044604925031308084726333618164062e-16L),
                        (int )calc_depth, do_round);
#line 8022
    grayhi = tmp___30 * ((double )1 + (double )2.22044604925031308084726333618164062e-16L);
#line 8025
    if (grayhi < gray) {
#line 8026
      grayhi = gray;
    }
#line 8030
    if (image_transform_data_rgb_to_gray.gamma != (double )1) {
#line 8032
      power___0 = (double )image_transform_data_rgb_to_gray.gamma;
#line 8035
      if (gamma_depth != sample_depth) {
#line 8037
        tmp___31 = digitize(rlo * ((double )1 - (double )2.22044604925031308084726333618164062e-16L),
                            (int )gamma_depth, 0);
#line 8037
        rlo = tmp___31 * ((double )1 - (double )2.22044604925031308084726333618164062e-16L);
#line 8038
        tmp___32 = digitize(rhi * ((double )1 + (double )2.22044604925031308084726333618164062e-16L),
                            (int )gamma_depth, 0);
#line 8038
        rhi = tmp___32 * ((double )1 + (double )2.22044604925031308084726333618164062e-16L);
#line 8039
        tmp___33 = digitize(glo * ((double )1 - (double )2.22044604925031308084726333618164062e-16L),
                            (int )gamma_depth, 0);
#line 8039
        glo = tmp___33 * ((double )1 - (double )2.22044604925031308084726333618164062e-16L);
#line 8040
        tmp___34 = digitize(ghi * ((double )1 + (double )2.22044604925031308084726333618164062e-16L),
                            (int )gamma_depth, 0);
#line 8040
        ghi = tmp___34 * ((double )1 + (double )2.22044604925031308084726333618164062e-16L);
#line 8041
        tmp___35 = digitize(blo * ((double )1 - (double )2.22044604925031308084726333618164062e-16L),
                            (int )gamma_depth, 0);
#line 8041
        blo = tmp___35 * ((double )1 - (double )2.22044604925031308084726333618164062e-16L);
#line 8042
        tmp___36 = digitize(bhi * ((double )1 + (double )2.22044604925031308084726333618164062e-16L),
                            (int )gamma_depth, 0);
#line 8042
        bhi = tmp___36 * ((double )1 + (double )2.22044604925031308084726333618164062e-16L);
      }
#line 8045
      gray = pow(gray, (double )power___0);
#line 8046
      tmp___37 = pow(graylo, (double )power___0);
#line 8046
      tmp___38 = digitize(tmp___37 * ((double )1 - (double )2.22044604925031308084726333618164062e-16L),
                          (int )sample_depth, 1);
#line 8046
      graylo = tmp___38 * ((double )1 - (double )2.22044604925031308084726333618164062e-16L);
#line 8047
      tmp___39 = pow(grayhi, (double )power___0);
#line 8047
      tmp___40 = digitize(tmp___39 * ((double )1 + (double )2.22044604925031308084726333618164062e-16L),
                          (int )sample_depth, 1);
#line 8047
      grayhi = tmp___40 * ((double )1 + (double )2.22044604925031308084726333618164062e-16L);
    }
#line 8058
    if (isgray) {
#line 8059
      err = ((that->rede + that->greene) + that->bluee) / (double )3;
    } else {
#line 8063
      err = fabs(grayhi - gray);
#line 8065
      tmp___41 = fabs(gray - graylo);
#line 8065
      if (tmp___41 > err) {
#line 8066
        err = fabs(graylo - gray);
      }
    }
#line 8215
    tmp___43 = gray;
#line 8215
    that->redf = tmp___43;
#line 8215
    tmp___42 = tmp___43;
#line 8215
    that->greenf = tmp___42;
#line 8215
    that->bluef = tmp___42;
#line 8216
    tmp___45 = err;
#line 8216
    that->rede = tmp___45;
#line 8216
    tmp___44 = tmp___45;
#line 8216
    that->greene = tmp___44;
#line 8216
    that->bluee = tmp___44;
#line 8219
    if ((int )that->red_sBIT > (int )that->green_sBIT) {
#line 8220
      that->red_sBIT = that->green_sBIT;
    }
#line 8221
    if ((int )that->red_sBIT > (int )that->blue_sBIT) {
#line 8222
      that->red_sBIT = that->blue_sBIT;
    }
#line 8223
    tmp___46 = that->red_sBIT;
#line 8223
    that->green_sBIT = tmp___46;
#line 8223
    that->blue_sBIT = tmp___46;
#line 8226
    if ((int )that->colour_type == 2) {
#line 8227
      that->colour_type = (png_byte )0;
    } else
#line 8228
    if ((int )that->colour_type == 6) {
#line 8229
      that->colour_type = (png_byte )4;
    }
  }
#line 8232
  (*((this->next)->mod))((struct image_transform  const  *)this->next, that, pp, display);
#line 8233
  return;
}
}
#line 8235 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int image_transform_png_set_rgb_to_gray_add(image_transform *this , image_transform const   **that ,
                                                   png_byte colour_type , png_byte bit_depth )
{


  {
#line 8241
  this->next = *that;
#line 8242
  *that = (image_transform const   *)this;
#line 8244
  return (((int )colour_type & 2) != 0);
}
}
#line 8248 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static image_transform image_transform_rgb_to_gray  =
#line 8248
     {(char const   *)"rgb_to_gray", 1, (struct image_transform *)(& image_transform_strip_alpha),
    0U, 0U, (struct image_transform  const  *)0, & image_transform_png_set_rgb_to_gray_ini,
    & image_transform_png_set_rgb_to_gray_set, & image_transform_png_set_rgb_to_gray_mod,
    & image_transform_png_set_rgb_to_gray_add};
#line 8265 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static image_pixel image_transform_data_background  ;
#line 8267 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_background_set(image_transform const   *this ,
                                                   transform_display *that , png_structp pp ,
                                                   png_infop pi )
{
  png_byte colour_type ;
  png_byte bit_depth ;
  png_byte random_bytes[8] ;
  int expand ;
  png_color_16 back ;

  {
#line 8281
  randomize((void *)(& random_bytes), sizeof(random_bytes));
#line 8286
  colour_type = that->this.colour_type;
#line 8287
  if ((int )colour_type == 3) {
#line 8289
    colour_type = (png_byte )2;
#line 8290
    bit_depth = (png_byte )8;
#line 8291
    expand = 0;
  } else {
#line 8296
    if (that->this.has_tRNS) {
#line 8297
      that->this.is_transparent = 1;
    }
#line 8299
    bit_depth = that->this.bit_depth;
#line 8300
    expand = 1;
  }
#line 8303
  image_pixel_init(& image_transform_data_background, (png_const_bytep )(random_bytes),
                   colour_type, bit_depth, (png_uint_32 )0, (struct store_palette_entry *)0,
                   (image_pixel const   *)((void *)0));
#line 8309
  randomize((void *)(& back), sizeof(back));
#line 8311
  if ((int )colour_type & 2) {
#line 8313
    back.red = (png_uint_16 )image_transform_data_background.red;
#line 8314
    back.green = (png_uint_16 )image_transform_data_background.green;
#line 8315
    back.blue = (png_uint_16 )image_transform_data_background.blue;
  } else {
#line 8319
    back.gray = (png_uint_16 )image_transform_data_background.red;
  }
#line 8322
  png_set_background((png_structrp )pp, (png_const_color_16p )(& back), 2, expand,
                     (double )0);
#line 8327
  (*((this->next)->set))((struct image_transform  const  *)this->next, that, pp, pi);
#line 8328
  return;
}
}
#line 8330 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_background_mod(image_transform const   *this ,
                                                   image_pixel *that , png_const_structp pp ,
                                                   transform_display const   *display )
{
  double alf ;

  {
#line 8336
  if (that->have_tRNS) {
#line 8336
    if ((int )that->colour_type != 3) {
#line 8337
      image_pixel_add_alpha(that, (standard_display const   *)(& display->this), 1);
    }
  }
#line 8340
  if (that->alphaf < (double )1) {
#line 8343
    if (that->alphaf <= (double )0) {
#line 8345
      that->redf = image_transform_data_background.redf;
#line 8346
      that->greenf = image_transform_data_background.greenf;
#line 8347
      that->bluef = image_transform_data_background.bluef;
#line 8349
      that->rede = image_transform_data_background.rede;
#line 8350
      that->greene = image_transform_data_background.greene;
#line 8351
      that->bluee = image_transform_data_background.bluee;
#line 8353
      that->red_sBIT = image_transform_data_background.red_sBIT;
#line 8354
      that->green_sBIT = image_transform_data_background.green_sBIT;
#line 8355
      that->blue_sBIT = image_transform_data_background.blue_sBIT;
    } else {
#line 8360
      alf = (double )1 - that->alphaf;
#line 8362
      that->redf = that->redf * that->alphaf + image_transform_data_background.redf * alf;
#line 8363
      that->rede = (that->rede * that->alphaf + image_transform_data_background.rede * alf) + (double )2.22044604925031308084726333618164062e-16L;
#line 8365
      that->greenf = that->greenf * that->alphaf + image_transform_data_background.greenf * alf;
#line 8366
      that->greene = (that->greene * that->alphaf + image_transform_data_background.greene * alf) + (double )2.22044604925031308084726333618164062e-16L;
#line 8368
      that->bluef = that->bluef * that->alphaf + image_transform_data_background.bluef * alf;
#line 8369
      that->bluee = (that->bluee * that->alphaf + image_transform_data_background.bluee * alf) + (double )2.22044604925031308084726333618164062e-16L;
    }
#line 8374
    that->alphaf = (double )1;
#line 8375
    that->alphae = (double )0;
  }
#line 8378
  if ((int )that->colour_type == 6) {
#line 8379
    that->colour_type = (png_byte )2;
  } else
#line 8380
  if ((int )that->colour_type == 4) {
#line 8381
    that->colour_type = (png_byte )0;
  }
#line 8384
  (*((this->next)->mod))((struct image_transform  const  *)this->next, that, pp, display);
#line 8385
  return;
}
}
#line 8390 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static image_transform image_transform_background  =
#line 8390
     {(char const   *)"background", 1, (struct image_transform *)(& image_transform_rgb_to_gray),
    0U, 0U, (struct image_transform  const  *)0, & image_transform_default_ini, & image_transform_png_set_background_set,
    & image_transform_png_set_background_mod, & image_transform_default_add};
#line 8415 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_invert_alpha_set(image_transform const   *this ,
                                                     transform_display *that , png_structp pp ,
                                                     png_infop pi )
{


  {
#line 8419
  png_set_invert_alpha((png_structrp )pp);
#line 8420
  (*((this->next)->set))((struct image_transform  const  *)this->next, that, pp, pi);
#line 8421
  return;
}
}
#line 8423 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_invert_alpha_mod(image_transform const   *this ,
                                                     image_pixel *that , png_const_structp pp ,
                                                     transform_display const   *display )
{


  {
#line 8428
  if ((int )that->colour_type & 4) {
#line 8429
    that->alpha_inverted = 1U;
  }
#line 8431
  (*((this->next)->mod))((struct image_transform  const  *)this->next, that, pp, display);
#line 8432
  return;
}
}
#line 8434 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int image_transform_png_set_invert_alpha_add(image_transform *this , image_transform const   **that ,
                                                    png_byte colour_type , png_byte bit_depth )
{


  {
#line 8440
  this->next = *that;
#line 8441
  *that = (image_transform const   *)this;
#line 8444
  return (((int )colour_type & 4) != 0);
}
}
#line 8447 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static image_transform image_transform_invert_alpha  =
#line 8447
     {(char const   *)"invert_alpha", 1, (struct image_transform *)(& image_transform_background),
    0U, 0U, (struct image_transform  const  *)0, & image_transform_default_ini, & image_transform_png_set_invert_alpha_set,
    & image_transform_png_set_invert_alpha_mod, & image_transform_png_set_invert_alpha_add};
#line 8461 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_bgr_set(image_transform const   *this , transform_display *that ,
                                            png_structp pp , png_infop pi )
{


  {
#line 8465
  png_set_bgr((png_structrp )pp);
#line 8466
  (*((this->next)->set))((struct image_transform  const  *)this->next, that, pp, pi);
#line 8467
  return;
}
}
#line 8469 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_bgr_mod(image_transform const   *this , image_pixel *that ,
                                            png_const_structp pp , transform_display const   *display )
{


  {
#line 8474
  if ((int )that->colour_type == 2) {
#line 8476
    that->swap_rgb = 1U;
  } else
#line 8474
  if ((int )that->colour_type == 6) {
#line 8476
    that->swap_rgb = 1U;
  }
#line 8478
  (*((this->next)->mod))((struct image_transform  const  *)this->next, that, pp, display);
#line 8479
  return;
}
}
#line 8481 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int image_transform_png_set_bgr_add(image_transform *this , image_transform const   **that ,
                                           png_byte colour_type , png_byte bit_depth )
{
  int tmp ;

  {
#line 8487
  this->next = *that;
#line 8488
  *that = (image_transform const   *)this;
#line 8490
  if ((int )colour_type == 2) {
#line 8490
    tmp = 1;
  } else
#line 8490
  if ((int )colour_type == 6) {
#line 8490
    tmp = 1;
  } else {
#line 8490
    tmp = 0;
  }
#line 8490
  return (tmp);
}
}
#line 8494 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static image_transform image_transform_bgr  =
#line 8494
     {(char const   *)"bgr", 1, (struct image_transform *)(& image_transform_invert_alpha),
    0U, 0U, (struct image_transform  const  *)0, & image_transform_default_ini, & image_transform_png_set_bgr_set,
    & image_transform_png_set_bgr_mod, & image_transform_png_set_bgr_add};
#line 8508 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_swap_alpha_set(image_transform const   *this ,
                                                   transform_display *that , png_structp pp ,
                                                   png_infop pi )
{


  {
#line 8512
  png_set_swap_alpha((png_structrp )pp);
#line 8513
  (*((this->next)->set))((struct image_transform  const  *)this->next, that, pp, pi);
#line 8514
  return;
}
}
#line 8516 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_swap_alpha_mod(image_transform const   *this ,
                                                   image_pixel *that , png_const_structp pp ,
                                                   transform_display const   *display )
{


  {
#line 8521
  if ((int )that->colour_type == 4) {
#line 8523
    that->alpha_first = 1U;
  } else
#line 8521
  if ((int )that->colour_type == 6) {
#line 8523
    that->alpha_first = 1U;
  }
#line 8525
  (*((this->next)->mod))((struct image_transform  const  *)this->next, that, pp, display);
#line 8526
  return;
}
}
#line 8528 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int image_transform_png_set_swap_alpha_add(image_transform *this , image_transform const   **that ,
                                                  png_byte colour_type , png_byte bit_depth )
{
  int tmp ;

  {
#line 8534
  this->next = *that;
#line 8535
  *that = (image_transform const   *)this;
#line 8537
  if ((int )colour_type == 4) {
#line 8537
    tmp = 1;
  } else
#line 8537
  if ((int )colour_type == 6) {
#line 8537
    tmp = 1;
  } else {
#line 8537
    tmp = 0;
  }
#line 8537
  return (tmp);
}
}
#line 8541 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static image_transform image_transform_swap_alpha  =
#line 8541
     {(char const   *)"swap_alpha", 1, (struct image_transform *)(& image_transform_bgr),
    0U, 0U, (struct image_transform  const  *)0, & image_transform_default_ini, & image_transform_png_set_swap_alpha_set,
    & image_transform_png_set_swap_alpha_mod, & image_transform_png_set_swap_alpha_add};
#line 8553 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_swap_set(image_transform const   *this , transform_display *that ,
                                             png_structp pp , png_infop pi )
{


  {
#line 8557
  png_set_swap((png_structrp )pp);
#line 8558
  (*((this->next)->set))((struct image_transform  const  *)this->next, that, pp, pi);
#line 8559
  return;
}
}
#line 8561 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_swap_mod(image_transform const   *this , image_pixel *that ,
                                             png_const_structp pp , transform_display const   *display )
{


  {
#line 8566
  if ((int )that->bit_depth == 16) {
#line 8567
    that->swap16 = 1U;
  }
#line 8569
  (*((this->next)->mod))((struct image_transform  const  *)this->next, that, pp, display);
#line 8570
  return;
}
}
#line 8572 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int image_transform_png_set_swap_add(image_transform *this , image_transform const   **that ,
                                            png_byte colour_type , png_byte bit_depth )
{


  {
#line 8578
  this->next = *that;
#line 8579
  *that = (image_transform const   *)this;
#line 8581
  return ((int )bit_depth == 16);
}
}
#line 8584 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static image_transform image_transform_swap  =
#line 8584
     {(char const   *)"swap", 1, (struct image_transform *)(& image_transform_swap_alpha),
    0U, 0U, (struct image_transform  const  *)0, & image_transform_default_ini, & image_transform_png_set_swap_set,
    & image_transform_png_set_swap_mod, & image_transform_png_set_swap_add};
#line 8605 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static struct __anonstruct_image_transform_data_filler_51946980 image_transform_data_filler  ;
#line 8607 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_filler_set(image_transform const   *this , transform_display *that ,
                                               png_structp pp , png_infop pi )
{


  {
#line 8615
  image_transform_data_filler.filler = random_u32();
#line 8616
  image_transform_data_filler.flags = random_choice();
#line 8618
  png_set_filler((png_structrp )pp, image_transform_data_filler.filler, image_transform_data_filler.flags);
#line 8623
  that->this.filler = (png_byte )1;
#line 8625
  (*((this->next)->set))((struct image_transform  const  *)this->next, that, pp, pi);
#line 8626
  return;
}
}
#line 8628 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_filler_mod(image_transform const   *this , image_pixel *that ,
                                               png_const_structp pp , transform_display const   *display )
{
  unsigned int max ;

  {
#line 8633
  if ((int )that->bit_depth >= 8) {
#line 8633
    if ((int )that->colour_type == 2) {
#line 8633
      goto _L;
    } else
#line 8633
    if ((int )that->colour_type == 0) {
      _L: /* CIL Label */
#line 8637
      max = (1U << (int )that->bit_depth) - 1U;
#line 8638
      that->alpha = image_transform_data_filler.filler & max;
#line 8639
      that->alphaf = (double )that->alpha / (double )max;
#line 8640
      that->alphae = (double )0;
#line 8648
      that->colour_type = (png_byte )((int )that->colour_type | 4);
#line 8649
      that->alpha_first = (unsigned int )(image_transform_data_filler.flags == 0);
    }
  }
#line 8652
  (*((this->next)->mod))((struct image_transform  const  *)this->next, that, pp, display);
#line 8653
  return;
}
}
#line 8655 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int image_transform_png_set_filler_add(image_transform *this , image_transform const   **that ,
                                              png_byte colour_type , png_byte bit_depth )
{
  int tmp ;

  {
#line 8659
  this->next = *that;
#line 8660
  *that = (image_transform const   *)this;
#line 8662
  if ((int )bit_depth >= 8) {
#line 8662
    if ((int )colour_type == 2) {
#line 8662
      tmp = 1;
    } else
#line 8662
    if ((int )colour_type == 0) {
#line 8662
      tmp = 1;
    } else {
#line 8662
      tmp = 0;
    }
  } else {
#line 8662
    tmp = 0;
  }
#line 8662
  return (tmp);
}
}
#line 8667 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static image_transform image_transform_filler  =
#line 8667
     {(char const   *)"filler", 1, (struct image_transform *)(& image_transform_swap),
    0U, 0U, (struct image_transform  const  *)0, & image_transform_default_ini, & image_transform_png_set_filler_set,
    & image_transform_png_set_filler_mod, & image_transform_png_set_filler_add};
#line 8678 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static struct __anonstruct_image_transform_data_add_alpha_51946981 image_transform_data_add_alpha  ;
#line 8680 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_add_alpha_set(image_transform const   *this ,
                                                  transform_display *that , png_structp pp ,
                                                  png_infop pi )
{


  {
#line 8688
  image_transform_data_add_alpha.filler = random_u32();
#line 8689
  image_transform_data_add_alpha.flags = random_choice();
#line 8691
  png_set_add_alpha((png_structrp )pp, image_transform_data_add_alpha.filler, image_transform_data_add_alpha.flags);
#line 8692
  (*((this->next)->set))((struct image_transform  const  *)this->next, that, pp, pi);
#line 8693
  return;
}
}
#line 8695 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_add_alpha_mod(image_transform const   *this ,
                                                  image_pixel *that , png_const_structp pp ,
                                                  transform_display const   *display )
{
  unsigned int max ;

  {
#line 8700
  if ((int )that->bit_depth >= 8) {
#line 8700
    if ((int )that->colour_type == 2) {
#line 8700
      goto _L;
    } else
#line 8700
    if ((int )that->colour_type == 0) {
      _L: /* CIL Label */
#line 8704
      max = (1U << (int )that->bit_depth) - 1U;
#line 8705
      that->alpha = image_transform_data_add_alpha.filler & max;
#line 8706
      that->alphaf = (double )that->alpha / (double )max;
#line 8707
      that->alphae = (double )0;
#line 8709
      that->colour_type = (png_byte )((int )that->colour_type | 4);
#line 8710
      that->alpha_first = (unsigned int )(image_transform_data_add_alpha.flags == 0);
    }
  }
#line 8713
  (*((this->next)->mod))((struct image_transform  const  *)this->next, that, pp, display);
#line 8714
  return;
}
}
#line 8716 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int image_transform_png_set_add_alpha_add(image_transform *this , image_transform const   **that ,
                                                 png_byte colour_type , png_byte bit_depth )
{
  int tmp ;

  {
#line 8720
  this->next = *that;
#line 8721
  *that = (image_transform const   *)this;
#line 8723
  if ((int )bit_depth >= 8) {
#line 8723
    if ((int )colour_type == 2) {
#line 8723
      tmp = 1;
    } else
#line 8723
    if ((int )colour_type == 0) {
#line 8723
      tmp = 1;
    } else {
#line 8723
      tmp = 0;
    }
  } else {
#line 8723
    tmp = 0;
  }
#line 8723
  return (tmp);
}
}
#line 8728 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static image_transform image_transform_add_alpha  =
#line 8728
     {(char const   *)"add_alpha", 1, (struct image_transform *)(& image_transform_filler),
    0U, 0U, (struct image_transform  const  *)0, & image_transform_default_ini, & image_transform_png_set_add_alpha_set,
    & image_transform_png_set_add_alpha_mod, & image_transform_png_set_add_alpha_add};
#line 8743 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_packing_set(image_transform const   *this , transform_display *that ,
                                                png_structp pp , png_infop pi )
{


  {
#line 8747
  png_set_packing((png_structrp )pp);
#line 8748
  that->unpacked = (png_byte )1;
#line 8749
  (*((this->next)->set))((struct image_transform  const  *)this->next, that, pp, pi);
#line 8750
  return;
}
}
#line 8752 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_packing_mod(image_transform const   *this , image_pixel *that ,
                                                png_const_structp pp , transform_display const   *display )
{


  {
#line 8761
  if ((int )that->bit_depth < 8) {
#line 8762
    that->bit_depth = (png_byte )8;
  }
#line 8764
  (*((this->next)->mod))((struct image_transform  const  *)this->next, that, pp, display);
#line 8765
  return;
}
}
#line 8767 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int image_transform_png_set_packing_add(image_transform *this , image_transform const   **that ,
                                               png_byte colour_type , png_byte bit_depth )
{


  {
#line 8773
  this->next = *that;
#line 8774
  *that = (image_transform const   *)this;
#line 8777
  return ((int )bit_depth < 8);
}
}
#line 8780 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static image_transform image_transform_packing  =
#line 8780
     {(char const   *)"packing", 1, (struct image_transform *)(& image_transform_add_alpha),
    0U, 0U, (struct image_transform  const  *)0, & image_transform_default_ini, & image_transform_png_set_packing_set,
    & image_transform_png_set_packing_mod, & image_transform_png_set_packing_add};
#line 8793 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_packswap_set(image_transform const   *this , transform_display *that ,
                                                 png_structp pp , png_infop pi )
{


  {
#line 8797
  png_set_packswap((png_structrp )pp);
#line 8798
  that->this.littleendian = 1;
#line 8799
  (*((this->next)->set))((struct image_transform  const  *)this->next, that, pp, pi);
#line 8800
  return;
}
}
#line 8802 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_packswap_mod(image_transform const   *this , image_pixel *that ,
                                                 png_const_structp pp , transform_display const   *display )
{


  {
#line 8807
  if ((int )that->bit_depth < 8) {
#line 8808
    that->littleendian = 1U;
  }
#line 8810
  (*((this->next)->mod))((struct image_transform  const  *)this->next, that, pp, display);
#line 8811
  return;
}
}
#line 8813 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int image_transform_png_set_packswap_add(image_transform *this , image_transform const   **that ,
                                                png_byte colour_type , png_byte bit_depth )
{


  {
#line 8819
  this->next = *that;
#line 8820
  *that = (image_transform const   *)this;
#line 8822
  return ((int )bit_depth < 8);
}
}
#line 8825 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static image_transform image_transform_packswap  =
#line 8825
     {(char const   *)"packswap", 1, (struct image_transform *)(& image_transform_packing),
    0U, 0U, (struct image_transform  const  *)0, & image_transform_default_ini, & image_transform_png_set_packswap_set,
    & image_transform_png_set_packswap_mod, & image_transform_png_set_packswap_add};
#line 8883 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static png_color_8 image_transform_data_shift  ;
#line 8885 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_shift_set(image_transform const   *this , transform_display *that ,
                                              png_structp pp , png_infop pi )
{
  unsigned int depth ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;

  {
#line 8895
  depth = (unsigned int )that->this.bit_depth;
#line 8897
  tmp = random_mod(depth);
#line 8897
  image_transform_data_shift.red = (png_byte )(tmp + 1U);
#line 8898
  tmp___0 = random_mod(depth);
#line 8898
  image_transform_data_shift.green = (png_byte )(tmp___0 + 1U);
#line 8899
  tmp___1 = random_mod(depth);
#line 8899
  image_transform_data_shift.blue = (png_byte )(tmp___1 + 1U);
#line 8900
  tmp___2 = random_mod(depth);
#line 8900
  image_transform_data_shift.gray = (png_byte )(tmp___2 + 1U);
#line 8901
  tmp___3 = random_mod(depth);
#line 8901
  image_transform_data_shift.alpha = (png_byte )(tmp___3 + 1U);
#line 8903
  png_set_shift((png_structrp )pp, (png_const_color_8p )(& image_transform_data_shift));
#line 8904
  (*((this->next)->set))((struct image_transform  const  *)this->next, that, pp, pi);
#line 8905
  return;
}
}
#line 8907 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_png_set_shift_mod(image_transform const   *this , image_pixel *that ,
                                              png_const_structp pp , transform_display const   *display )
{
  png_byte tmp ;
  png_byte tmp___0 ;

  {
#line 8915
  if ((int )that->colour_type != 3) {
#line 8917
    that->sig_bits = 1U;
#line 8923
    if ((int )that->colour_type & 2) {
#line 8925
      that->red_sBIT = image_transform_data_shift.red;
#line 8926
      that->green_sBIT = image_transform_data_shift.green;
#line 8927
      that->blue_sBIT = image_transform_data_shift.blue;
    } else {
#line 8931
      tmp___0 = image_transform_data_shift.gray;
#line 8931
      that->blue_sBIT = tmp___0;
#line 8931
      tmp = tmp___0;
#line 8931
      that->green_sBIT = tmp;
#line 8931
      that->red_sBIT = tmp;
    }
#line 8933
    that->alpha_sBIT = image_transform_data_shift.alpha;
  }
#line 8936
  (*((this->next)->mod))((struct image_transform  const  *)this->next, that, pp, display);
#line 8937
  return;
}
}
#line 8939 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int image_transform_png_set_shift_add(image_transform *this , image_transform const   **that ,
                                             png_byte colour_type , png_byte bit_depth )
{


  {
#line 8945
  this->next = *that;
#line 8946
  *that = (image_transform const   *)this;
#line 8948
  return ((int )colour_type != 3);
}
}
#line 8951 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static image_transform image_transform_shift  =
#line 8951
     {(char const   *)"shift", 1, (struct image_transform *)(& image_transform_packswap),
    0U, 0U, (struct image_transform  const  *)0, & image_transform_default_ini, & image_transform_png_set_shift_set,
    & image_transform_png_set_shift_mod, & image_transform_png_set_shift_add};
#line 8989 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static image_transform *image_transform_first  =    (image_transform *)(& image_transform_shift);
#line 8997
static void transform_enable(char const   *name ) ;
#line 8997 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int all_disabled  =    0;
#line 8991 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void transform_enable(char const   *name )
{
  int found_it ;
  image_transform *list ;
  int tmp ;

  {
#line 8998
  found_it = 0;
#line 8999
  list = (image_transform *)image_transform_first;
  {
#line 9001
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9001
    if (! ((unsigned long )list != (unsigned long )(& image_transform_end))) {
#line 9001
      goto while_break;
    }
#line 9003
    tmp = strcmp(list->name, name);
#line 9003
    if (tmp == 0) {
#line 9005
      list->enable = 1;
#line 9006
      found_it = 1;
    } else
#line 9008
    if (! all_disabled) {
#line 9009
      list->enable = 0;
    }
#line 9011
    list = (image_transform *)list->list;
  }
  while_break: /* CIL Label */ ;
  }
#line 9014
  all_disabled = 1;
#line 9016
  if (! found_it) {
#line 9018
    fprintf(stderr, (char const   *)"pngvalid: --transform-enable=%s: unknown transform\n",
            name);
#line 9020
    exit(99);
  }
#line 9022
  return;
}
}
#line 9024 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void transform_disable(char const   *name )
{
  image_transform *list ;
  int tmp ;

  {
#line 9027
  list = (image_transform *)image_transform_first;
  {
#line 9029
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9029
    if (! ((unsigned long )list != (unsigned long )(& image_transform_end))) {
#line 9029
      goto while_break;
    }
#line 9031
    tmp = strcmp(list->name, name);
#line 9031
    if (tmp == 0) {
#line 9033
      list->enable = 0;
#line 9034
      return;
    }
#line 9037
    list = (image_transform *)list->list;
  }
  while_break: /* CIL Label */ ;
  }
#line 9040
  fprintf(stderr, (char const   *)"pngvalid: --transform-disable=%s: unknown transform\n",
          name);
#line 9042
  exit(99);
}
}
#line 9045 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void image_transform_reset_count(void)
{
  image_transform *next ;
  int count ;

  {
#line 9048
  next = (image_transform *)image_transform_first;
#line 9049
  count = 0;
  {
#line 9051
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9051
    if (! ((unsigned long )next != (unsigned long )(& image_transform_end))) {
#line 9051
      goto while_break;
    }
#line 9053
    next->local_use = 0U;
#line 9054
    next->next = (struct image_transform  const  *)0;
#line 9055
    next = (image_transform *)next->list;
#line 9056
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 9062
  if (count > 32) {
#line 9062
    abort();
  }
#line 9063
  return;
}
}
#line 9065 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int image_transform_test_counter(png_uint_32 counter___0 , unsigned int max )
{
  image_transform *next ;
  int tmp ;

  {
#line 9071
  next = (image_transform *)image_transform_first;
  {
#line 9073
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9073
    if (! ((unsigned long )next != (unsigned long )(& image_transform_end))) {
#line 9073
      goto while_break;
    }
#line 9076
    counter___0 >>= 1;
#line 9079
    if (max > 1U) {
#line 9079
      if (next->local_use < max) {
#line 9080
        return (1);
      }
    }
#line 9081
    next = (image_transform *)next->list;
  }
  while_break: /* CIL Label */ ;
  }
#line 9084
  if (max <= 1U) {
#line 9084
    if (counter___0 == 0U) {
#line 9084
      tmp = 1;
    } else {
#line 9084
      tmp = 0;
    }
  } else {
#line 9084
    tmp = 0;
  }
#line 9084
  return (tmp);
}
}
#line 9087 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static png_uint_32 image_transform_add(image_transform const   **this , unsigned int max ,
                                       png_uint_32 counter___0 , char *name , size_t sizeof_name ,
                                       size_t *pos , png_byte colour_type , png_byte bit_depth )
{
  png_uint_32 mask ;
  image_transform *list ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 9092
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9101
    if (counter___0 == 0U) {
#line 9103
      image_transform_reset_count();
#line 9104
      if (max <= 1U) {
#line 9105
        counter___0 = (png_uint_32 )1;
      } else {
#line 9107
        counter___0 = random_32();
      }
    } else {
      {
#line 9113
      if (max == 0U) {
#line 9113
        goto case_0;
      }
#line 9114
      if (max == 1U) {
#line 9114
        goto case_1;
      }
#line 9115
      goto switch_default;
      case_0: /* CIL Label */
#line 9113
      counter___0 ++;
#line 9113
      goto switch_break;
      case_1: /* CIL Label */
#line 9114
      counter___0 <<= 1;
#line 9114
      goto switch_break;
      switch_default: /* CIL Label */
#line 9115
      counter___0 = random_32();
#line 9115
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 9120
    *this = (image_transform const   *)(& image_transform_end);
#line 9121
    list = (image_transform *)image_transform_first;
#line 9122
    mask = (png_uint_32 )1;
    {
#line 9125
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 9125
      if (! ((unsigned long )list != (unsigned long )(& image_transform_end))) {
#line 9125
        goto while_break___0;
      }
#line 9127
      if ((counter___0 & mask) != 0U) {
#line 9127
        if (list->enable) {
#line 9127
          if (max == 0U) {
#line 9127
            goto _L;
          } else
#line 9127
          if (list->local_use < max) {
            _L: /* CIL Label */
#line 9131
            tmp = (*(list->add))(list, this, colour_type, bit_depth);
#line 9131
            if (tmp) {
#line 9134
              *pos = safecat(name, sizeof_name, *pos, (char const   *)" +");
#line 9135
              *pos = safecat(name, sizeof_name, *pos, list->name);
            } else
#line 9131
            if (max == 0U) {
#line 9134
              *pos = safecat(name, sizeof_name, *pos, (char const   *)" +");
#line 9135
              *pos = safecat(name, sizeof_name, *pos, list->name);
            } else {
#line 9141
              *this = list->next;
#line 9142
              list->next = (struct image_transform  const  *)0;
#line 9147
              list->local_use = max;
            }
          }
        }
      }
#line 9151
      mask <<= 1;
#line 9152
      list = (image_transform *)list->list;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 9156
    if ((unsigned long )*this != (unsigned long )(& image_transform_end)) {
#line 9157
      return (counter___0);
    }
#line 9160
    tmp___0 = image_transform_test_counter(counter___0, max);
#line 9160
    if (! tmp___0) {
#line 9161
      return ((png_uint_32 )0);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 9165 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void perform_transform_test(png_modifier *pm___0 )
{
  png_byte colour_type ;
  png_byte bit_depth ;
  unsigned int palette_number ;
  png_uint_32 counter___0 ;
  size_t base_pos ;
  char name[64] ;
  size_t pos ;
  image_transform const   *list ;
  int tmp ;
  int tmp___0 ;

  {
#line 9168
  colour_type = (png_byte )0;
#line 9169
  bit_depth = (png_byte )0;
#line 9170
  palette_number = 0U;
  {
#line 9172
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9172
    tmp___0 = next_format(& colour_type, & bit_depth, & palette_number, (int )pm___0->test_lbg,
                          (int )pm___0->test_tRNS);
#line 9172
    if (! tmp___0) {
#line 9172
      goto while_break;
    }
#line 9175
    counter___0 = (png_uint_32 )0;
#line 9179
    base_pos = safecat(name, sizeof(name), (size_t )0, (char const   *)"transform:");
    {
#line 9181
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 9183
      pos = base_pos;
#line 9184
      list = (image_transform const   *)0;
#line 9189
      counter___0 = image_transform_add(& list, 1U, counter___0, name, sizeof(name),
                                        & pos, colour_type, bit_depth);
#line 9192
      if (counter___0 == 0U) {
#line 9193
        goto while_break___0;
      }
      {
#line 9196
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 9198
        pm___0->repeat = 0U;
#line 9199
        transform_test(pm___0, ((unsigned int )((int )colour_type + ((int )bit_depth << 3)) + (palette_number << 8)) + (unsigned int )(pm___0->interlace_type << 13),
                       list, (char const   *)(name));
#line 9202
        tmp = fail(pm___0);
#line 9202
        if (tmp) {
#line 9203
          return;
        }
#line 9196
        if (! pm___0->repeat) {
#line 9196
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 9208
  return;
}
}
#line 9241 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void gamma_display_init(gamma_display *dp , png_modifier *pm___0 , png_uint_32 id ,
                               double file_gamma , double screen_gamma , png_byte sbit ,
                               int threshold_test , int use_input_precision , int scale16 ,
                               int expand16 , int do_background , png_color_16 const   *pointer_to_the_background_color ,
                               double background_gamma )
{
  double tmp ;
  double tmp___0 ;

  {
#line 9249
  standard_display_init(& dp->this, & pm___0->this, id, 0, pm___0->use_update_info);
#line 9253
  dp->pm = pm___0;
#line 9254
  dp->file_gamma = file_gamma;
#line 9255
  dp->screen_gamma = screen_gamma;
#line 9256
  dp->background_gamma = background_gamma;
#line 9257
  dp->sbit = sbit;
#line 9258
  dp->threshold_test = threshold_test;
#line 9259
  dp->use_input_precision = use_input_precision;
#line 9260
  dp->scale16 = scale16;
#line 9261
  dp->expand16 = expand16;
#line 9262
  dp->do_background = do_background;
#line 9263
  if (do_background) {
#line 9263
    if ((unsigned long )pointer_to_the_background_color != (unsigned long )((png_color_16 const   *)0)) {
#line 9264
      dp->background_color = (png_color_16 )*pointer_to_the_background_color;
    } else {
#line 9266
      memset((void *)(& dp->background_color), 0, sizeof(dp->background_color));
    }
  } else {
#line 9266
    memset((void *)(& dp->background_color), 0, sizeof(dp->background_color));
  }
#line 9269
  tmp___0 = (double )0;
#line 9269
  dp->maxerrabs = tmp___0;
#line 9269
  tmp = tmp___0;
#line 9269
  dp->maxerrpc = tmp;
#line 9269
  dp->maxerrout = tmp;
#line 9270
  return;
}
}
#line 9272 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void gamma_info_imp(gamma_display *dp , png_structp pp , png_infop pi )
{
  int mode ;
  double sg ;
  double bg ;
  int i ;

  {
#line 9276
  standard_info_part1(& dp->this, pp, pi);
#line 9283
  if (dp->scale16) {
#line 9285
    png_set_scale_16((png_structrp )pp);
  }
#line 9295
  if (dp->expand16) {
#line 9297
    png_set_expand_16((png_structrp )pp);
  }
#line 9302
  if (dp->do_background >= 4) {
#line 9307
    mode = dp->do_background - 4;
#line 9313
    sg = (double )dp->screen_gamma;
#line 9319
    png_set_alpha_mode((png_structrp )pp, mode, (double )sg);
#line 9328
    if (mode == 1) {
#line 9328
      if (sg != (double )1) {
#line 9331
        png_set_gamma((png_structrp )pp, (double )sg, dp->file_gamma);
      }
    }
  } else {
#line 9347
    png_set_gamma((png_structrp )pp, dp->screen_gamma, dp->file_gamma);
#line 9356
    if (dp->do_background) {
#line 9361
      bg = (double )dp->background_gamma;
#line 9367
      png_set_background((png_structrp )pp, (png_const_color_16p )(& dp->background_color),
                         dp->do_background, 0, (double )bg);
    }
  }
#line 9380
  i = dp->this.use_update_info;
  {
#line 9382
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9383
    png_read_update_info((png_structrp )pp, (png_inforp )pi);
#line 9382
    i --;
#line 9382
    if (! (i > 0)) {
#line 9382
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 9388
  standard_info_part2(& dp->this, (png_const_structp )pp, (png_const_infop )pi, 1);
#line 9389
  return;
}
}
#line 9391 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void gamma_info(png_structp pp , png_infop pi )
{
  png_voidp tmp ;

  {
#line 9394
  tmp = png_get_progressive_ptr((png_const_structrp )pp);
#line 9394
  gamma_info_imp((gamma_display *)tmp, pp, pi);
#line 9396
  return;
}
}
#line 9433 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void init_validate_info(validate_info *vi , gamma_display *dp , png_const_structp pp ,
                               int in_depth , int out_depth )
{
  unsigned int outmax ;
  double tmp ;
  double tmp___0 ;
  double bg_inverse ;
  double r ;
  double g ;
  double b ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;

  {
#line 9437
  outmax = (1U << out_depth) - 1U;
#line 9439
  vi->pp = pp;
#line 9440
  vi->dp = dp;
#line 9442
  if ((int )dp->sbit > 0) {
#line 9442
    if ((int )dp->sbit < in_depth) {
#line 9444
      vi->sbit = dp->sbit;
#line 9445
      vi->isbit_shift = (unsigned int )(in_depth - (int )dp->sbit);
    } else {
#line 9450
      vi->sbit = (png_byte )in_depth;
#line 9451
      vi->isbit_shift = 0U;
    }
  } else {
#line 9450
    vi->sbit = (png_byte )in_depth;
#line 9451
    vi->isbit_shift = 0U;
  }
#line 9454
  vi->sbit_max = (1U << (int )vi->sbit) - 1U;
#line 9459
  vi->screen_gamma = dp->screen_gamma;
#line 9460
  tmp___0 = fabs(vi->screen_gamma - (double )1);
#line 9460
  if (tmp___0 < (double )5000 * .00001) {
#line 9461
    tmp = (double )0;
#line 9461
    vi->screen_inverse = tmp;
#line 9461
    vi->screen_gamma = tmp;
  } else {
#line 9463
    vi->screen_inverse = (double )1 / vi->screen_gamma;
  }
#line 9465
  vi->use_input_precision = dp->use_input_precision;
#line 9466
  vi->outmax = outmax;
#line 9467
  vi->maxabs = abserr((png_modifier const   *)dp->pm, in_depth, out_depth);
#line 9468
  vi->maxpc = pcerr((png_modifier const   *)dp->pm, in_depth, out_depth);
#line 9469
  vi->maxcalc = calcerr((png_modifier const   *)dp->pm, in_depth, out_depth);
#line 9470
  vi->maxout = outerr((png_modifier const   *)dp->pm, in_depth, out_depth);
#line 9471
  vi->outquant = output_quantization_factor((png_modifier const   *)dp->pm, in_depth,
                                            out_depth);
#line 9472
  vi->maxout_total = vi->maxout + (double )vi->outquant * .5;
#line 9473
  vi->outlog = outlog((png_modifier const   *)dp->pm, in_depth, out_depth);
#line 9475
  if (((int )dp->this.colour_type & 4) != 0) {
#line 9475
    goto _L;
  } else
#line 9475
  if ((int )dp->this.colour_type == 3) {
#line 9475
    if (dp->this.is_transparent) {
#line 9475
      goto _L;
    } else {
#line 9475
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */
#line 9475
  if ((int )dp->this.colour_type == 0) {
#line 9475
    goto _L___0;
  } else
#line 9475
  if ((int )dp->this.colour_type == 2) {
    _L___0: /* CIL Label */
#line 9475
    if (dp->this.has_tRNS) {
      _L: /* CIL Label */
#line 9480
      vi->do_background = dp->do_background;
#line 9482
      if (vi->do_background != 0) {
#line 9484
        bg_inverse = (double )((double )1 / dp->background_gamma);
#line 9488
        r = (double )dp->background_color.red;
#line 9488
        r /= (double )outmax;
#line 9489
        g = (double )dp->background_color.green;
#line 9489
        g /= (double )outmax;
#line 9490
        b = (double )dp->background_color.blue;
#line 9490
        b /= (double )outmax;
#line 9498
        r = pow(r, (double )bg_inverse);
#line 9499
        g = pow(g, (double )bg_inverse);
#line 9500
        b = pow(b, (double )bg_inverse);
#line 9503
        vi->background_red = r;
#line 9504
        vi->background_green = g;
#line 9505
        vi->background_blue = b;
      }
    } else {
#line 9509
      vi->do_background = 0;
    }
  } else {
#line 9509
    vi->do_background = 0;
  }
#line 9511
  if (vi->do_background == 0) {
#line 9512
    tmp___2 = (double )0;
#line 9512
    vi->background_blue = tmp___2;
#line 9512
    tmp___1 = tmp___2;
#line 9512
    vi->background_green = tmp___1;
#line 9512
    vi->background_red = tmp___1;
  }
#line 9514
  vi->gamma_correction = (double )1 / (dp->file_gamma * dp->screen_gamma);
#line 9515
  tmp___3 = fabs(vi->gamma_correction - (double )1);
#line 9515
  if (tmp___3 < (double )5000 * .00001) {
#line 9516
    vi->gamma_correction = (double )0;
  }
#line 9518
  vi->file_inverse = (double )1 / dp->file_gamma;
#line 9519
  tmp___4 = fabs(vi->file_inverse - (double )1);
#line 9519
  if (tmp___4 < (double )5000 * .00001) {
#line 9520
    vi->file_inverse = (double )0;
  }
#line 9522
  vi->scale16 = dp->scale16;
#line 9523
  return;
}
}
#line 9530 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static double gamma_component_compose(int do_background , double input_sample , double alpha ,
                                      double background , int *compose )
{


  {
  {
#line 9539
  if (do_background == 3) {
#line 9539
    goto case_3;
  }
#line 9539
  if (do_background == 2) {
#line 9539
    goto case_3;
  }
#line 9539
  if (do_background == 1) {
#line 9539
    goto case_3;
  }
#line 9563
  if (do_background == 6) {
#line 9563
    goto case_6;
  }
#line 9563
  if (do_background == 7) {
#line 9563
    goto case_6;
  }
#line 9563
  if (do_background == 5) {
#line 9563
    goto case_6;
  }
#line 9583
  goto switch_default;
  case_3: /* CIL Label */
  case_2: /* CIL Label */
  case_1: /* CIL Label */
#line 9541
  if (alpha < (double )1) {
#line 9543
    if (alpha > (double )0) {
#line 9545
      input_sample = input_sample * alpha + background * ((double )1 - alpha);
#line 9546
      if ((unsigned long )compose != (unsigned long )((void *)0)) {
#line 9547
        *compose = 1;
      }
    } else {
#line 9551
      input_sample = background;
    }
  }
#line 9553
  goto switch_break;
  case_6: /* CIL Label */
  case_7: /* CIL Label */
  case_5: /* CIL Label */
#line 9568
  if (alpha < (double )1) {
#line 9570
    if (alpha > (double )0) {
#line 9572
      input_sample *= alpha;
#line 9573
      if ((unsigned long )compose != (unsigned long )((void *)0)) {
#line 9574
        *compose = 1;
      }
    } else {
#line 9578
      input_sample = (double )0;
    }
  }
#line 9580
  goto switch_break;
  switch_default: /* CIL Label */ ;
#line 9590
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 9593
  return (input_sample);
}
}
#line 9597 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static double gamma_component_validate(char const   *name , validate_info const   *vi ,
                                       unsigned int id , unsigned int od , double const   alpha ,
                                       double const   background )
{
  unsigned int isbit ;
  unsigned int sbit_max ;
  unsigned int outmax ;
  int do_background ;
  double i ;
  double encoded_sample ;
  double encoded_error ;
  double input_sample ;
  double output ;
  double error___0 ;
  double encoded_sample___0 ;
  double encoded_error___0 ;
  double es_lo ;
  double es_hi ;
  int compose ;
  int output_is_encoded ;
  int log_max_error ;
  png_const_charp pass ;
  int tcompose ;
  double percentage_error ;
  double tmp ;
  double low_value ;
  double tmp___0 ;
  double high_value ;
  double tmp___1 ;
  double is_lo ;
  double is_hi ;
  double tmp___2 ;
  size_t pos ;
  int precision ;
  int tmp___3 ;
  int use_input ;
  int use_background ;
  int do_compose ;
  char msg[256] ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 9603
  isbit = id >> vi->isbit_shift;
#line 9604
  sbit_max = (unsigned int )vi->sbit_max;
#line 9605
  outmax = (unsigned int )vi->outmax;
#line 9606
  do_background = (int )vi->do_background;
#line 9614
  i = (double )isbit;
#line 9614
  i /= (double )sbit_max;
#line 9620
  if (alpha == (double const   )1) {
#line 9620
    goto _L;
  } else
#line 9620
  if (! do_background) {
#line 9620
    goto _L;
  } else
#line 9620
  if (do_background == 4) {
#line 9620
    goto _L;
  } else
#line 9620
  if (alpha < (double const   )0) {
#line 9620
    if (do_background != 7) {
      _L: /* CIL Label */
#line 9635
      encoded_sample = i;
#line 9640
      if (alpha >= (double const   )0) {
#line 9640
        if (vi->gamma_correction > (double )0) {
#line 9641
          encoded_sample = pow(encoded_sample, (double )vi->gamma_correction);
        }
      }
#line 9642
      encoded_sample *= (double )outmax;
#line 9644
      encoded_error = fabs((double )od - encoded_sample);
#line 9646
      if (encoded_error > (vi->dp)->maxerrout) {
#line 9647
        (vi->dp)->maxerrout = encoded_error;
      }
#line 9649
      if (encoded_error < (double )vi->maxout_total) {
#line 9649
        if (encoded_error < (double )vi->outlog) {
#line 9650
          return (i);
        }
      }
    }
  }
#line 9662
  input_sample = i;
#line 9665
  compose = 0;
#line 9667
  log_max_error = 1;
#line 9668
  pass = (png_const_charp )0;
#line 9673
  if (alpha >= (double const   )0) {
#line 9677
    if (vi->file_inverse > (double )0) {
#line 9678
      input_sample = pow(input_sample, (double )vi->file_inverse);
    }
#line 9681
    tcompose = 0;
#line 9682
    input_sample = gamma_component_compose(do_background, input_sample, (double )alpha,
                                           (double )background, & tcompose);
#line 9685
    if (tcompose) {
#line 9686
      compose = 1;
    }
  }
#line 9692
  output = (double )od;
#line 9693
  output /= (double )outmax;
#line 9695
  output_is_encoded = vi->screen_gamma > (double )0;
#line 9697
  if (alpha < (double const   )0) {
#line 9700
    if (do_background != 7) {
#line 9706
      output_is_encoded = 0;
#line 9707
      log_max_error = 0;
    }
  } else
#line 9714
  if (do_background == 6) {
#line 9714
    if (alpha < (double const   )1) {
#line 9717
      if (alpha > (double const   )0) {
#line 9717
        log_max_error = 0;
      }
#line 9718
      output_is_encoded = 0;
    }
  }
#line 9723
  if (output_is_encoded) {
#line 9724
    output = pow(output, (double )vi->screen_gamma);
  }
#line 9729
  encoded_sample___0 = input_sample;
#line 9730
  if (output_is_encoded) {
#line 9731
    encoded_sample___0 = pow(encoded_sample___0, (double )vi->screen_inverse);
  }
#line 9732
  encoded_sample___0 *= (double )outmax;
#line 9734
  encoded_error___0 = fabs((double )od - encoded_sample___0);
#line 9739
  if (log_max_error) {
#line 9739
    if (encoded_error___0 > (vi->dp)->maxerrout) {
#line 9740
      (vi->dp)->maxerrout = encoded_error___0;
    }
  }
#line 9742
  if (encoded_error___0 < (double )vi->maxout_total) {
#line 9744
    if (encoded_error___0 < (double )vi->outlog) {
#line 9745
      return (i);
    }
#line 9750
    pass = (png_const_charp )"less than maxout:\n";
  }
#line 9767
  error___0 = fabs(input_sample - output);
#line 9769
  if (log_max_error) {
#line 9769
    if (error___0 > (vi->dp)->maxerrabs) {
#line 9770
      (vi->dp)->maxerrabs = error___0;
    }
  }
#line 9775
  if (log_max_error) {
#line 9775
    if (input_sample > .5) {
#line 9777
      percentage_error = error___0 / input_sample;
#line 9778
      if (percentage_error > (vi->dp)->maxerrpc) {
#line 9779
        (vi->dp)->maxerrpc = percentage_error;
      }
    }
  }
#line 9789
  tmp = input_sample * (double )vi->maxpc;
#line 9790
  if (tmp < (double )vi->maxabs) {
#line 9790
    tmp = (double )vi->maxabs;
  }
#line 9797
  if (compose) {
#line 9797
    if (tmp < (double )vi->maxcalc) {
#line 9797
      tmp = (double )vi->maxcalc;
    }
  }
#line 9802
  es_lo = encoded_sample___0 - (double )vi->maxout;
#line 9804
  if (es_lo > (double )0) {
#line 9804
    if (input_sample - tmp > (double )0) {
#line 9806
      low_value = input_sample - tmp;
#line 9807
      if (output_is_encoded) {
#line 9808
        low_value = pow(low_value, (double )vi->screen_inverse);
      }
#line 9809
      low_value *= (double )outmax;
#line 9810
      if (low_value < es_lo) {
#line 9810
        es_lo = low_value;
      }
#line 9813
      tmp___0 = ceil(es_lo / (double )vi->outquant - .5);
#line 9813
      es_lo = tmp___0 * (double )vi->outquant;
    } else {
#line 9817
      es_lo = (double )0;
    }
  } else {
#line 9817
    es_lo = (double )0;
  }
#line 9819
  es_hi = encoded_sample___0 + (double )vi->maxout;
#line 9821
  if (es_hi < (double )outmax) {
#line 9821
    if (input_sample + tmp < (double )1) {
#line 9823
      high_value = input_sample + tmp;
#line 9824
      if (output_is_encoded) {
#line 9825
        high_value = pow(high_value, (double )vi->screen_inverse);
      }
#line 9826
      high_value *= (double )outmax;
#line 9827
      if (high_value > es_hi) {
#line 9827
        es_hi = high_value;
      }
#line 9829
      tmp___1 = floor(es_hi / (double )vi->outquant + .5);
#line 9829
      es_hi = tmp___1 * (double )vi->outquant;
    } else {
#line 9833
      es_hi = (double )outmax;
    }
  } else {
#line 9833
    es_hi = (double )outmax;
  }
#line 9840
  if ((double )od >= es_lo) {
#line 9840
    if ((double )od <= es_hi) {
#line 9843
      if (encoded_error___0 < (double )vi->outlog) {
#line 9844
        return (i);
      }
#line 9846
      if ((unsigned long )pass == (unsigned long )((png_const_charp )0)) {
#line 9847
        pass = (png_const_charp )"within digitization limits:\n";
      }
    }
  }
#line 9860
  if ((unsigned long )pass == (unsigned long )((png_const_charp )0)) {
#line 9860
    if (vi->use_input_precision) {
#line 9860
      if ((vi->dp)->sbit) {
#line 9878
        tmp___2 = ((double )isbit - .5) / (double )sbit_max;
#line 9880
        if (tmp___2 <= (double )0) {
#line 9881
          tmp___2 = (double )0;
        } else
#line 9883
        if (alpha >= (double const   )0) {
#line 9883
          if (vi->file_inverse > (double )0) {
#line 9883
            if (tmp___2 < (double )1) {
#line 9884
              tmp___2 = pow(tmp___2, (double )vi->file_inverse);
            }
          }
        }
#line 9886
        tmp___2 = gamma_component_compose(do_background, tmp___2, (double )alpha,
                                          (double )background, (int *)((void *)0));
#line 9889
        if (output_is_encoded) {
#line 9889
          if (tmp___2 > (double )0) {
#line 9889
            if (tmp___2 < (double )1) {
#line 9890
              tmp___2 = pow(tmp___2, (double )vi->screen_inverse);
            }
          }
        }
#line 9892
        is_lo = ceil((double )outmax * tmp___2 - (double )vi->maxout_total);
#line 9894
        if (is_lo < (double )0) {
#line 9895
          is_lo = (double )0;
        }
#line 9897
        tmp___2 = ((double )isbit + .5) / (double )sbit_max;
#line 9899
        if (tmp___2 >= (double )1) {
#line 9900
          tmp___2 = (double )1;
        } else
#line 9902
        if (alpha >= (double const   )0) {
#line 9902
          if (vi->file_inverse > (double )0) {
#line 9902
            if (tmp___2 < (double )1) {
#line 9903
              tmp___2 = pow(tmp___2, (double )vi->file_inverse);
            }
          }
        }
#line 9905
        tmp___2 = gamma_component_compose(do_background, tmp___2, (double )alpha,
                                          (double )background, (int *)((void *)0));
#line 9908
        if (output_is_encoded) {
#line 9908
          if (tmp___2 > (double )0) {
#line 9908
            if (tmp___2 < (double )1) {
#line 9909
              tmp___2 = pow(tmp___2, (double )vi->screen_inverse);
            }
          }
        }
#line 9911
        is_hi = floor((double )outmax * tmp___2 + (double )vi->maxout_total);
#line 9913
        if (is_hi > (double )outmax) {
#line 9914
          is_hi = (double )outmax;
        }
#line 9916
        if (! ((double )od < is_lo)) {
#line 9916
          if (! ((double )od > is_hi)) {
#line 9918
            if (encoded_error___0 < (double )vi->outlog) {
#line 9919
              return (i);
            }
#line 9921
            pass = (png_const_charp )"within input precision limits:\n";
          }
        }
      } else {
#line 9977
        is_lo = es_lo;
#line 9977
        is_hi = es_hi;
      }
    } else {
#line 9977
      is_lo = es_lo;
#line 9977
      is_hi = es_hi;
    }
  } else {
#line 9977
    is_lo = es_lo;
#line 9977
    is_hi = es_hi;
  }
#line 9984
  pos = (size_t )0;
#line 9988
  if (outmax >= 1000U) {
#line 9988
    tmp___3 = 6;
  } else {
#line 9988
    tmp___3 = 3;
  }
#line 9988
  precision = tmp___3;
#line 9989
  use_input = 1;
#line 9989
  use_background = 0;
#line 9989
  do_compose = 0;
#line 9992
  if ((unsigned long )pass != (unsigned long )((png_const_charp )0)) {
#line 9993
    pos = safecat(msg, sizeof(msg), pos, (char const   *)"\n\t");
  }
  {
#line 10003
  if (do_background == 3) {
#line 10003
    goto case_3;
  }
#line 10003
  if (do_background == 2) {
#line 10003
    goto case_3;
  }
#line 10003
  if (do_background == 1) {
#line 10003
    goto case_3;
  }
#line 10010
  if (do_background == 6) {
#line 10010
    goto case_6;
  }
#line 10010
  if (do_background == 7) {
#line 10010
    goto case_6;
  }
#line 10010
  if (do_background == 5) {
#line 10010
    goto case_6;
  }
#line 10016
  goto switch_default;
  case_3: /* CIL Label */
  case_2: /* CIL Label */
  case_1: /* CIL Label */
#line 10004
  if (alpha >= (double const   )0) {
#line 10004
    if (alpha < (double const   )1) {
#line 10004
      tmp___4 = 1;
    } else {
#line 10004
      tmp___4 = 0;
    }
  } else {
#line 10004
    tmp___4 = 0;
  }
#line 10004
  use_background = tmp___4;
  case_6: /* CIL Label */
  case_7: /* CIL Label */
  case_5: /* CIL Label */
#line 10012
  if (alpha > (double const   )0) {
#line 10012
    if (alpha < (double const   )1) {
#line 10012
      tmp___5 = 1;
    } else {
#line 10012
      tmp___5 = 0;
    }
  } else {
#line 10012
    tmp___5 = 0;
  }
#line 10012
  do_compose = tmp___5;
#line 10013
  use_input = alpha != (double const   )0;
#line 10014
  goto switch_break;
  switch_default: /* CIL Label */
#line 10017
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 10021
  if (compose != do_compose) {
#line 10022
    png_error((png_const_structrp )vi->pp, (png_const_charp )"internal error (compose)");
  }
#line 10025
  pos = safecat(msg, sizeof(msg), pos, name);
#line 10026
  pos = safecat(msg, sizeof(msg), pos, (char const   *)"(");
#line 10027
  pos = safecatn(msg, sizeof(msg), pos, (int )id);
#line 10028
  if (use_input) {
#line 10028
    goto _L___0;
  } else
#line 10028
  if ((unsigned long )pass != (unsigned long )((png_const_charp )0)) {
    _L___0: /* CIL Label */
#line 10030
    if (isbit != id) {
#line 10033
      pos = safecat(msg, sizeof(msg), pos, (char const   *)", sbit(");
#line 10034
      pos = safecatn(msg, sizeof(msg), pos, (int )vi->sbit);
#line 10035
      pos = safecat(msg, sizeof(msg), pos, (char const   *)"): ");
#line 10036
      pos = safecatn(msg, sizeof(msg), pos, (int )isbit);
    }
#line 10038
    pos = safecat(msg, sizeof(msg), pos, (char const   *)"/");
#line 10040
    pos = safecatn(msg, sizeof(msg), pos, (int )vi->sbit_max);
  }
#line 10042
  pos = safecat(msg, sizeof(msg), pos, (char const   *)")");
#line 10047
  if (compose) {
#line 10047
    goto _L___2;
  } else
#line 10047
  if ((unsigned long )pass != (unsigned long )((png_const_charp )0)) {
    _L___2: /* CIL Label */
#line 10054
    if (use_input) {
#line 10054
      goto _L___1;
    } else
#line 10054
    if ((unsigned long )pass != (unsigned long )((png_const_charp )0)) {
      _L___1: /* CIL Label */
#line 10056
      if (vi->file_inverse > (double )0) {
#line 10058
        pos = safecat(msg, sizeof(msg), pos, (char const   *)"^");
#line 10059
        pos = safecatd(msg, sizeof(msg), pos, (double )vi->file_inverse, 2);
      } else {
#line 10063
        pos = safecat(msg, sizeof(msg), pos, (char const   *)"[linear]");
      }
#line 10065
      pos = safecat(msg, sizeof(msg), pos, (char const   *)"*(alpha)");
#line 10066
      pos = safecatd(msg, sizeof(msg), pos, (double )alpha, precision);
    }
#line 10073
    if (use_background) {
#line 10075
      if (use_input) {
#line 10075
        tmp___6 = "+";
      } else {
#line 10075
        tmp___6 = " ";
      }
#line 10075
      pos = safecat(msg, sizeof(msg), pos, (char const   *)tmp___6);
#line 10076
      pos = safecat(msg, sizeof(msg), pos, (char const   *)"(background)");
#line 10077
      pos = safecatd(msg, sizeof(msg), pos, (double )background, precision);
#line 10078
      pos = safecat(msg, sizeof(msg), pos, (char const   *)"*");
#line 10079
      pos = safecatd(msg, sizeof(msg), pos, (double )((double const   )1 - alpha),
                     precision);
    }
  }
#line 10087
  if (compose) {
#line 10087
    goto _L___3;
  } else
#line 10087
  if (alpha < (double const   )0) {
#line 10087
    goto _L___3;
  } else
#line 10087
  if ((unsigned long )pass != (unsigned long )((png_const_charp )0)) {
    _L___3: /* CIL Label */
#line 10089
    if ((unsigned long )pass != (unsigned long )((png_const_charp )0)) {
#line 10089
      tmp___7 = " =\n\t";
    } else {
#line 10089
      tmp___7 = " = ";
    }
#line 10089
    pos = safecat(msg, sizeof(msg), pos, (char const   *)tmp___7);
#line 10091
    pos = safecatd(msg, sizeof(msg), pos, input_sample, precision);
#line 10092
    pos = safecat(msg, sizeof(msg), pos, (char const   *)" (libpng: ");
#line 10093
    pos = safecatd(msg, sizeof(msg), pos, output, precision);
#line 10094
    pos = safecat(msg, sizeof(msg), pos, (char const   *)")");
#line 10097
    if (output_is_encoded) {
#line 10099
      pos = safecat(msg, sizeof(msg), pos, (char const   *)" ^");
#line 10100
      pos = safecatd(msg, sizeof(msg), pos, (double )vi->screen_inverse, 2);
#line 10101
      pos = safecat(msg, sizeof(msg), pos, (char const   *)"(to screen) =");
    } else {
#line 10105
      pos = safecat(msg, sizeof(msg), pos, (char const   *)" [screen is linear] =");
    }
  }
#line 10108
  if (! compose) {
#line 10108
    if (alpha >= (double const   )0) {
#line 10108
      goto _L___4;
    } else {
#line 10108
      goto _L___5;
    }
  } else
  _L___5: /* CIL Label */
#line 10108
  if ((unsigned long )pass != (unsigned long )((png_const_charp )0)) {
    _L___4: /* CIL Label */
#line 10110
    if ((unsigned long )pass != (unsigned long )((png_const_charp )0)) {
#line 10111
      pos = safecat(msg, sizeof(msg), pos, (char const   *)"\n\t[overall:");
    }
#line 10118
    if (vi->gamma_correction > (double )0) {
#line 10120
      pos = safecat(msg, sizeof(msg), pos, (char const   *)" ^");
#line 10121
      pos = safecatd(msg, sizeof(msg), pos, (double )vi->gamma_correction, 2);
#line 10122
      pos = safecat(msg, sizeof(msg), pos, (char const   *)"(gamma correction) =");
    } else {
#line 10126
      pos = safecat(msg, sizeof(msg), pos, (char const   *)" [no gamma correction] =");
    }
#line 10129
    if ((unsigned long )pass != (unsigned long )((png_const_charp )0)) {
#line 10130
      pos = safecat(msg, sizeof(msg), pos, (char const   *)"]");
    }
  }
#line 10136
  if ((unsigned long )pass != (unsigned long )((png_const_charp )0)) {
#line 10136
    tmp___8 = "\n\t";
  } else {
#line 10136
    tmp___8 = " ";
  }
#line 10136
  pos = safecat(msg, sizeof(msg), pos, (char const   *)tmp___8);
#line 10137
  pos = safecatd(msg, sizeof(msg), pos, is_lo, 1);
#line 10138
  pos = safecat(msg, sizeof(msg), pos, (char const   *)" < ");
#line 10139
  pos = safecatd(msg, sizeof(msg), pos, encoded_sample___0, 1);
#line 10140
  pos = safecat(msg, sizeof(msg), pos, (char const   *)" (libpng: ");
#line 10141
  pos = safecatn(msg, sizeof(msg), pos, (int )od);
#line 10142
  pos = safecat(msg, sizeof(msg), pos, (char const   *)")");
#line 10143
  pos = safecat(msg, sizeof(msg), pos, (char const   *)"/");
#line 10144
  pos = safecatn(msg, sizeof(msg), pos, (int )outmax);
#line 10145
  pos = safecat(msg, sizeof(msg), pos, (char const   *)" < ");
#line 10146
  pos = safecatd(msg, sizeof(msg), pos, is_hi, 1);
#line 10148
  if ((unsigned long )pass == (unsigned long )((png_const_charp )0)) {
#line 10151
    png_warning((png_const_structrp )vi->pp, (png_const_charp )(msg));
  } else {
#line 10158
    store_verbose(& ((vi->dp)->pm)->this, (png_const_structp )vi->pp, pass, (png_const_charp )(msg));
  }
#line 10163
  return (i);
}
}
#line 10166 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void gamma_image_validate(gamma_display *dp , png_const_structp pp , png_infop pi )
{
  png_store const   *ps ;
  png_byte in_ct ;
  png_byte in_bd ;
  png_uint_32 w ;
  png_uint_32 h ;
  size_t cbRow ;
  png_byte out_ct ;
  png_byte tmp ;
  png_byte out_bd ;
  png_byte tmp___0 ;
  unsigned int samples_per_pixel ;
  unsigned int tmp___1 ;
  int processing ;
  png_uint_32 y ;
  store_palette_entry const   *in_palette ;
  int in_is_transparent ;
  int process_tRNS ;
  int out_npalette ;
  int out_is_transparent ;
  store_palette out_palette ;
  validate_info vi ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  png_const_bytep pRow ;
  png_bytep tmp___6 ;
  png_byte std[1024U] ;
  unsigned int x ;
  double alpha ;
  unsigned int in_index ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int out_index ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int input_alpha ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int output_alpha ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  unsigned int tmp___18 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;
  unsigned int tmp___21 ;
  unsigned int tmp___22 ;
  unsigned int tmp___23 ;
  unsigned int tmp___24 ;
  unsigned int tmp___25 ;
  unsigned int tmp___26 ;
  unsigned int tmp___27 ;
  unsigned int tmp___28 ;
  unsigned int tmp___29 ;
  unsigned int tmp___30 ;
  char msg[64] ;
  int tmp___31 ;

  {
#line 10171
  ps = (png_store const   *)dp->this.ps;
#line 10172
  in_ct = dp->this.colour_type;
#line 10173
  in_bd = dp->this.bit_depth;
#line 10174
  w = dp->this.w;
#line 10175
  h = dp->this.h;
#line 10176
  cbRow = (size_t )dp->this.cbRow;
#line 10177
  tmp = png_get_color_type((png_const_structrp )pp, (png_const_inforp )pi);
#line 10177
  out_ct = tmp;
#line 10178
  tmp___0 = png_get_bit_depth((png_const_structrp )pp, (png_const_inforp )pi);
#line 10178
  out_bd = tmp___0;
#line 10219
  if ((unsigned int )out_ct & 2U) {
#line 10219
    tmp___1 = 3U;
  } else {
#line 10219
    tmp___1 = 1U;
  }
#line 10219
  samples_per_pixel = tmp___1;
#line 10222
  in_palette = (store_palette_entry const   *)(dp->this.palette);
#line 10223
  in_is_transparent = dp->this.is_transparent;
#line 10225
  out_npalette = -1;
#line 10226
  out_is_transparent = 0;
#line 10231
  store_image_check((png_store const   *)dp->this.ps, pp, 0);
#line 10236
  if ((int )out_ct == 3) {
#line 10236
    tmp___2 = 8;
  } else {
#line 10236
    tmp___2 = (int )out_bd;
  }
#line 10236
  if ((int )in_ct == 3) {
#line 10236
    tmp___3 = 8;
  } else {
#line 10236
    tmp___3 = (int )in_bd;
  }
#line 10236
  init_validate_info(& vi, dp, pp, tmp___3, tmp___2);
#line 10238
  if (vi.gamma_correction > (double )0) {
#line 10238
    if (! dp->threshold_test) {
#line 10238
      tmp___4 = 1;
    } else {
#line 10238
      goto _L;
    }
  } else
  _L: /* CIL Label */
#line 10238
  if ((int )in_bd != (int )out_bd) {
#line 10238
    tmp___4 = 1;
  } else
#line 10238
  if ((int )in_ct != (int )out_ct) {
#line 10238
    tmp___4 = 1;
  } else
#line 10238
  if (vi.do_background) {
#line 10238
    tmp___4 = 1;
  } else {
#line 10238
    tmp___4 = 0;
  }
#line 10238
  processing = tmp___4;
#line 10240
  if (dp->this.has_tRNS) {
#line 10240
    if (vi.do_background) {
#line 10240
      tmp___5 = 1;
    } else {
#line 10240
      tmp___5 = 0;
    }
  } else {
#line 10240
    tmp___5 = 0;
  }
#line 10240
  process_tRNS = tmp___5;
#line 10249
  if ((int )in_ct == 3) {
#line 10249
    if ((int )out_ct == 3) {
#line 10250
      processing = 0;
    }
  }
#line 10252
  if (processing) {
#line 10252
    if ((int )out_ct == 3) {
#line 10253
      out_is_transparent = read_palette((struct store_palette_entry *)(out_palette),
                                        & out_npalette, pp, pi);
    }
  }
#line 10255
  y = (png_uint_32 )0;
  {
#line 10255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10255
    if (! (y < h)) {
#line 10255
      goto while_break;
    }
#line 10257
    tmp___6 = store_image_row((png_store const   *)ps, pp, 0, y);
#line 10257
    pRow = (png_const_bytep )tmp___6;
#line 10260
    transform_row(pp, (png_byte *)(std), in_ct, in_bd, y);
#line 10262
    if (processing) {
#line 10266
      x = 0U;
      {
#line 10266
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 10266
        if (! (x < w)) {
#line 10266
          goto while_break___0;
        }
#line 10268
        alpha = (double )1;
#line 10271
        if ((int )in_ct == 3) {
#line 10271
          tmp___7 = sample((png_const_bytep )(std), (png_byte )3, in_bd, x, 0U, 0,
                           0);
#line 10271
          tmp___8 = tmp___7;
        } else {
#line 10271
          tmp___8 = 256U;
        }
#line 10271
        in_index = tmp___8;
#line 10273
        if ((int )out_ct == 3) {
#line 10273
          tmp___9 = sample((png_const_bytep )(std), (png_byte )3, out_bd, x, 0U, 0,
                           0);
#line 10273
          tmp___10 = tmp___9;
        } else {
#line 10273
          tmp___10 = 256U;
        }
#line 10273
        out_index = tmp___10;
#line 10279
        if (((int )in_ct & 4) != 0) {
#line 10279
          goto _L___0;
        } else
#line 10279
        if ((int )in_ct == 3) {
#line 10279
          if (in_is_transparent) {
            _L___0: /* CIL Label */
#line 10282
            if ((int )in_ct == 3) {
#line 10282
              tmp___12 = (unsigned int )dp->this.palette[in_index].alpha;
            } else {
#line 10282
              tmp___11 = sample((png_const_bytep )(std), in_ct, in_bd, x, samples_per_pixel,
                                0, 0);
#line 10282
              tmp___12 = tmp___11;
            }
#line 10282
            input_alpha = tmp___12;
#line 10286
            output_alpha = 65536U;
#line 10288
            if ((int )out_ct == 3) {
#line 10290
              if (out_is_transparent) {
#line 10291
                output_alpha = (unsigned int )out_palette[out_index].alpha;
              }
            } else
#line 10294
            if (((int )out_ct & 4) != 0) {
#line 10295
              output_alpha = sample(pRow, out_ct, out_bd, x, samples_per_pixel, 0,
                                    0);
            }
#line 10298
            if (output_alpha != 65536U) {
#line 10299
              alpha = gamma_component_validate((char const   *)"alpha", (validate_info const   *)(& vi),
                                               input_alpha, output_alpha, (double const   )-1,
                                               (double const   )0);
            } else {
#line 10307
              alpha = (double )(input_alpha >> vi.isbit_shift);
#line 10308
              alpha /= (double )vi.sbit_max;
            }
          } else {
#line 10279
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */
#line 10312
        if (process_tRNS) {
          {
#line 10320
          if ((int )in_ct == 0) {
#line 10320
            goto case_0;
          }
#line 10326
          if ((int )in_ct == 2) {
#line 10326
            goto case_2;
          }
#line 10336
          goto switch_default;
          case_0: /* CIL Label */
#line 10321
          tmp___13 = sample((png_const_bytep )(std), in_ct, in_bd, x, 0U, 0, 0);
#line 10321
          if (tmp___13 == (unsigned int )dp->this.transparent.red) {
#line 10323
            alpha = (double )0;
          }
#line 10324
          goto switch_break;
          case_2: /* CIL Label */
#line 10327
          tmp___14 = sample((png_const_bytep )(std), in_ct, in_bd, x, 0U, 0, 0);
#line 10327
          if (tmp___14 == (unsigned int )dp->this.transparent.red) {
#line 10327
            tmp___15 = sample((png_const_bytep )(std), in_ct, in_bd, x, 1U, 0, 0);
#line 10327
            if (tmp___15 == (unsigned int )dp->this.transparent.green) {
#line 10327
              tmp___16 = sample((png_const_bytep )(std), in_ct, in_bd, x, 2U, 0, 0);
#line 10327
              if (tmp___16 == (unsigned int )dp->this.transparent.blue) {
#line 10333
                alpha = (double )0;
              }
            }
          }
#line 10334
          goto switch_break;
          switch_default: /* CIL Label */
#line 10337
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        }
#line 10342
        if (((int )in_ct & 2) == 0) {
#line 10343
          tmp___17 = sample(pRow, out_ct, out_bd, x, 0U, 0, 0);
#line 10343
          tmp___18 = sample((png_const_bytep )(std), in_ct, in_bd, x, 0U, 0, 0);
#line 10343
          gamma_component_validate((char const   *)"gray", (validate_info const   *)(& vi),
                                   tmp___18, tmp___17, (double const   )alpha, (double const   )vi.background_red);
        } else {
#line 10349
          if ((int )out_ct == 3) {
#line 10349
            tmp___20 = (unsigned int )out_palette[out_index].red;
          } else {
#line 10349
            tmp___19 = sample(pRow, out_ct, out_bd, x, 0U, 0, 0);
#line 10349
            tmp___20 = tmp___19;
          }
#line 10349
          if ((int )in_ct == 3) {
#line 10349
            tmp___22 = (unsigned int )(in_palette + in_index)->red;
          } else {
#line 10349
            tmp___21 = sample((png_const_bytep )(std), in_ct, in_bd, x, 0U, 0, 0);
#line 10349
            tmp___22 = tmp___21;
          }
#line 10349
          gamma_component_validate((char const   *)"red", (validate_info const   *)(& vi),
                                   tmp___22, tmp___20, (double const   )alpha, (double const   )vi.background_red);
#line 10356
          if ((int )out_ct == 3) {
#line 10356
            tmp___24 = (unsigned int )out_palette[out_index].green;
          } else {
#line 10356
            tmp___23 = sample(pRow, out_ct, out_bd, x, 1U, 0, 0);
#line 10356
            tmp___24 = tmp___23;
          }
#line 10356
          if ((int )in_ct == 3) {
#line 10356
            tmp___26 = (unsigned int )(in_palette + in_index)->green;
          } else {
#line 10356
            tmp___25 = sample((png_const_bytep )(std), in_ct, in_bd, x, 1U, 0, 0);
#line 10356
            tmp___26 = tmp___25;
          }
#line 10356
          gamma_component_validate((char const   *)"green", (validate_info const   *)(& vi),
                                   tmp___26, tmp___24, (double const   )alpha, (double const   )vi.background_green);
#line 10363
          if ((int )out_ct == 3) {
#line 10363
            tmp___28 = (unsigned int )out_palette[out_index].blue;
          } else {
#line 10363
            tmp___27 = sample(pRow, out_ct, out_bd, x, 2U, 0, 0);
#line 10363
            tmp___28 = tmp___27;
          }
#line 10363
          if ((int )in_ct == 3) {
#line 10363
            tmp___30 = (unsigned int )(in_palette + in_index)->blue;
          } else {
#line 10363
            tmp___29 = sample((png_const_bytep )(std), in_ct, in_bd, x, 2U, 0, 0);
#line 10363
            tmp___30 = tmp___29;
          }
#line 10363
          gamma_component_validate((char const   *)"blue", (validate_info const   *)(& vi),
                                   tmp___30, tmp___28, (double const   )alpha, (double const   )vi.background_blue);
        }
#line 10266
        x ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 10373
      tmp___31 = memcmp((void const   *)(std), (void const   *)pRow, (size_t )cbRow);
#line 10373
      if (tmp___31 != 0) {
#line 10378
        sprintf(msg, (char const   *)"gamma: below threshold row %lu changed", (unsigned long )y);
#line 10381
        png_error((png_const_structrp )pp, (png_const_charp )(msg));
      }
    }
#line 10255
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 10385
  (dp->this.ps)->validated = 1U;
#line 10386
  return;
}
}
#line 10388 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void gamma_end(png_structp ppIn , png_infop pi )
{
  png_const_structp pp ;
  gamma_display *dp ;
  png_voidp tmp ;

  {
#line 10391
  pp = (png_const_structp )ppIn;
#line 10392
  tmp = png_get_progressive_ptr((png_const_structrp )pp);
#line 10392
  dp = (gamma_display *)tmp;
#line 10394
  if (! dp->this.speed) {
#line 10395
    gamma_image_validate(dp, pp, pi);
  } else {
#line 10397
    (dp->this.ps)->validated = 1U;
  }
#line 10398
  return;
}
}
#line 10406 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void gamma_test(png_modifier *pmIn , png_byte colour_typeIn , png_byte bit_depthIn ,
                       int palette_numberIn , int interlace_typeIn , double const   file_gammaIn ,
                       double const   screen_gammaIn , png_byte sbitIn , int threshold_testIn ,
                       char const   *name , int use_input_precisionIn , int scale16In ,
                       int expand16In , int do_backgroundIn , png_color_16 const   *bkgd_colorIn ,
                       double bkgd_gammaIn )
{
  gamma_display d ;
  struct exception_context *the_exception_context ;
  png_store *fault ;
  jmp_buf *exception__prev ;
  jmp_buf exception__env ;
  png_structp pp ;
  png_infop pi ;
  gama_modification gama_mod ;
  srgb_modification srgb_mod ;
  sbit_modification sbit_mod ;
  int tmp ;

  {
#line 10418
  the_exception_context = & pmIn->this.exception_context;
#line 10420
  gamma_display_init(& d, pmIn, (png_uint_32 )((((int )colour_typeIn + ((int )bit_depthIn << 3)) + (palette_numberIn << 8)) + (interlace_typeIn << 13)),
                     (double )file_gammaIn, (double )screen_gammaIn, sbitIn, threshold_testIn,
                     use_input_precisionIn, scale16In, expand16In, do_backgroundIn,
                     bkgd_colorIn, bkgd_gammaIn);
#line 10426
  exception__prev = the_exception_context->penv;
#line 10426
  the_exception_context->penv = & exception__env;
#line 10426
  tmp = _setjmp((struct __jmp_buf_tag *)(exception__env));
#line 10426
  if (tmp == 0) {
    {
#line 10426
    while (1) {
      while_continue: /* CIL Label */ ;
#line 10435
      (d.pm)->encoding_counter = 0U;
#line 10436
      modifier_set_encoding(d.pm);
#line 10437
      (d.pm)->current_gamma = d.file_gamma;
#line 10442
      (d.pm)->modifications = (struct png_modification *)((void *)0);
#line 10443
      gama_modification_init(& gama_mod, d.pm, d.file_gamma);
#line 10444
      srgb_modification_init(& srgb_mod, d.pm, (png_byte )127);
#line 10445
      if ((int )d.sbit > 0) {
#line 10446
        sbit_modification_init(& sbit_mod, d.pm, d.sbit);
      }
#line 10448
      modification_reset((d.pm)->modifications);
#line 10451
      pp = set_modifier_for_read(d.pm, & pi, d.this.id, name);
#line 10452
      standard_palette_init(& d.this);
#line 10455
      if ((d.pm)->this.progressive) {
#line 10458
        png_set_progressive_read_fn((png_structrp )pp, (png_voidp )(& d), & gamma_info,
                                    & progressive_row, & gamma_end);
#line 10462
        modifier_progressive_read(d.pm, pp, pi);
      } else {
#line 10467
        png_set_read_fn((png_structrp )pp, (png_voidp )d.pm, & modifier_read);
#line 10470
        png_read_info((png_structrp )pp, (png_inforp )pi);
#line 10473
        gamma_info_imp(& d, pp, pi);
#line 10475
        sequential_row(& d.this, pp, pi, -1, 0);
#line 10477
        if (! d.this.speed) {
#line 10478
          gamma_image_validate(& d, (png_const_structp )pp, pi);
        } else {
#line 10480
          (d.this.ps)->validated = 1U;
        }
      }
#line 10483
      modifier_reset(d.pm);
#line 10485
      if ((d.pm)->log) {
#line 10485
        if (! d.threshold_test) {
#line 10485
          if (! d.this.speed) {
#line 10486
            fprintf(stderr, (char const   *)"%d bit %s %s: max error %f (%.2g, %2g%%)\n",
                    (int )d.this.bit_depth, colour_types[d.this.colour_type], name,
                    d.maxerrout, d.maxerrabs, (double )100 * d.maxerrpc);
          }
        }
      }
#line 10491
      if ((int )d.this.colour_type == 0) {
#line 10491
        goto _L___0;
      } else
#line 10491
      if ((int )d.this.colour_type == 4) {
        _L___0: /* CIL Label */
        {
#line 10495
        if ((int )d.this.bit_depth == 1) {
#line 10495
          goto case_1;
        }
#line 10498
        if ((int )d.this.bit_depth == 2) {
#line 10498
          goto case_2;
        }
#line 10504
        if ((int )d.this.bit_depth == 4) {
#line 10504
          goto case_4;
        }
#line 10510
        if ((int )d.this.bit_depth == 8) {
#line 10510
          goto case_8;
        }
#line 10516
        if ((int )d.this.bit_depth == 16) {
#line 10516
          goto case_16;
        }
#line 10522
        goto switch_default;
        case_1: /* CIL Label */
#line 10496
        goto switch_break;
        case_2: /* CIL Label */
#line 10499
        if (d.maxerrout > (d.pm)->error_gray_2) {
#line 10500
          (d.pm)->error_gray_2 = d.maxerrout;
        }
#line 10502
        goto switch_break;
        case_4: /* CIL Label */
#line 10505
        if (d.maxerrout > (d.pm)->error_gray_4) {
#line 10506
          (d.pm)->error_gray_4 = d.maxerrout;
        }
#line 10508
        goto switch_break;
        case_8: /* CIL Label */
#line 10511
        if (d.maxerrout > (d.pm)->error_gray_8) {
#line 10512
          (d.pm)->error_gray_8 = d.maxerrout;
        }
#line 10514
        goto switch_break;
        case_16: /* CIL Label */
#line 10517
        if (d.maxerrout > (d.pm)->error_gray_16) {
#line 10518
          (d.pm)->error_gray_16 = d.maxerrout;
        }
#line 10520
        goto switch_break;
        switch_default: /* CIL Label */
#line 10523
        png_error((png_const_structrp )pp, (png_const_charp )"bad bit depth (internal: 1)");
        switch_break: /* CIL Label */ ;
        }
      } else
#line 10527
      if ((int )d.this.colour_type == 2) {
#line 10527
        goto _L;
      } else
#line 10527
      if ((int )d.this.colour_type == 6) {
        _L: /* CIL Label */
        {
#line 10531
        if ((int )d.this.bit_depth == 8) {
#line 10531
          goto case_8___0;
        }
#line 10538
        if ((int )d.this.bit_depth == 16) {
#line 10538
          goto case_16___0;
        }
#line 10545
        goto switch_default___0;
        case_8___0: /* CIL Label */
#line 10533
        if (d.maxerrout > (d.pm)->error_color_8) {
#line 10534
          (d.pm)->error_color_8 = d.maxerrout;
        }
#line 10536
        goto switch_break___0;
        case_16___0: /* CIL Label */
#line 10540
        if (d.maxerrout > (d.pm)->error_color_16) {
#line 10541
          (d.pm)->error_color_16 = d.maxerrout;
        }
#line 10543
        goto switch_break___0;
        switch_default___0: /* CIL Label */
#line 10546
        png_error((png_const_structrp )pp, (png_const_charp )"bad bit depth (internal: 2)");
        switch_break___0: /* CIL Label */ ;
        }
      } else
#line 10550
      if ((int )d.this.colour_type == 3) {
#line 10552
        if (d.maxerrout > (d.pm)->error_indexed) {
#line 10553
          (d.pm)->error_indexed = d.maxerrout;
        }
      }
#line 10426
      the_exception_context->caught = 0;
#line 10426
      if (! the_exception_context->caught) {
#line 10426
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 10557
    the_exception_context->caught = 1;
  }
#line 10557
  the_exception_context->penv = exception__prev;
#line 10557
  if (! (! the_exception_context->caught)) {
#line 10557
    fault = (png_store *)the_exception_context->v.etmp;
#line 10557
    if (! 0) {
#line 10558
      modifier_reset((png_modifier *)((void *)fault));
    }
  }
#line 10559
  return;
}
}
#line 10561 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void gamma_threshold_test(png_modifier *pm___0 , png_byte colour_type , png_byte bit_depth ,
                                 int interlace_type , double file_gamma , double screen_gamma )
{
  size_t pos ;
  char name[64] ;

  {
#line 10565
  pos = (size_t )0;
#line 10567
  pos = safecat(name, sizeof(name), pos, (char const   *)"threshold ");
#line 10568
  pos = safecatd(name, sizeof(name), pos, file_gamma, 3);
#line 10569
  pos = safecat(name, sizeof(name), pos, (char const   *)"/");
#line 10570
  pos = safecatd(name, sizeof(name), pos, screen_gamma, 3);
#line 10572
  gamma_test(pm___0, colour_type, bit_depth, 0, interlace_type, (double const   )file_gamma,
             (double const   )screen_gamma, (png_byte )0, 1, (char const   *)(name),
             0, 0, 0, 0, (png_color_16 const   *)0, (double )0);
#line 10577
  return;
}
}
#line 10579 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void perform_gamma_threshold_tests(png_modifier *pm___0 )
{
  png_byte colour_type ;
  png_byte bit_depth ;
  unsigned int palette_number ;
  double test_gamma ;
  int tmp ;
  int tmp___0 ;

  {
#line 10582
  colour_type = (png_byte )0;
#line 10583
  bit_depth = (png_byte )0;
#line 10584
  palette_number = 0U;
  {
#line 10593
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10593
    tmp___0 = next_format(& colour_type, & bit_depth, & palette_number, (int )pm___0->test_lbg_gamma_threshold,
                          (int )pm___0->test_tRNS);
#line 10593
    if (! tmp___0) {
#line 10593
      goto while_break;
    }
#line 10595
    if (palette_number < 2U) {
#line 10597
      test_gamma = 1.0;
      {
#line 10598
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 10598
        if (! (test_gamma >= .4)) {
#line 10598
          goto while_break___0;
        }
#line 10603
        gamma_threshold_test(pm___0, colour_type, bit_depth, pm___0->interlace_type,
                             test_gamma, (double )1 / test_gamma);
#line 10605
        test_gamma *= .95;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 10609
      gamma_threshold_test(pm___0, colour_type, bit_depth, pm___0->interlace_type,
                           .45455, 2.2);
#line 10612
      tmp = fail(pm___0);
#line 10612
      if (tmp) {
#line 10613
        return;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 10615
  return;
}
}
#line 10617 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void gamma_transform_test(png_modifier *pm___0 , png_byte colour_type , png_byte bit_depth ,
                                 int palette_number , int interlace_type , double const   file_gamma ,
                                 double const   screen_gamma , png_byte sbit , int use_input_precision ,
                                 int scale16 )
{
  size_t pos ;
  char name[64] ;

  {
#line 10624
  pos = (size_t )0;
#line 10627
  if ((int )sbit != (int )bit_depth) {
#line 10627
    if ((int )sbit != 0) {
#line 10629
      pos = safecat(name, sizeof(name), pos, (char const   *)"sbit(");
#line 10630
      pos = safecatn(name, sizeof(name), pos, (int )sbit);
#line 10631
      pos = safecat(name, sizeof(name), pos, (char const   *)") ");
    } else {
#line 10635
      pos = safecat(name, sizeof(name), pos, (char const   *)"gamma ");
    }
  } else {
#line 10635
    pos = safecat(name, sizeof(name), pos, (char const   *)"gamma ");
  }
#line 10637
  if (scale16) {
#line 10638
    pos = safecat(name, sizeof(name), pos, (char const   *)"16to8 ");
  }
#line 10640
  pos = safecatd(name, sizeof(name), pos, (double )file_gamma, 3);
#line 10641
  pos = safecat(name, sizeof(name), pos, (char const   *)"->");
#line 10642
  pos = safecatd(name, sizeof(name), pos, (double )screen_gamma, 3);
#line 10644
  gamma_test(pm___0, colour_type, bit_depth, palette_number, interlace_type, file_gamma,
             screen_gamma, sbit, 0, (char const   *)(name), use_input_precision, scale16,
             (int )pm___0->test_gamma_expand16, 0, (png_color_16 const   *)0, (double )0);
#line 10647
  return;
}
}
#line 10649 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void perform_gamma_transform_tests(png_modifier *pm___0 )
{
  png_byte colour_type ;
  png_byte bit_depth ;
  unsigned int palette_number ;
  unsigned int i ;
  unsigned int j ;
  int tmp ;
  int tmp___0 ;

  {
#line 10651
  colour_type = (png_byte )0;
#line 10652
  bit_depth = (png_byte )0;
#line 10653
  palette_number = 0U;
  {
#line 10655
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10655
    tmp___0 = next_format(& colour_type, & bit_depth, & palette_number, (int )pm___0->test_lbg_gamma_transform,
                          (int )pm___0->test_tRNS);
#line 10655
    if (! tmp___0) {
#line 10655
      goto while_break;
    }
#line 10660
    i = 0U;
    {
#line 10660
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 10660
      if (! (i < pm___0->ngamma_tests)) {
#line 10660
        goto while_break___0;
      }
#line 10662
      j = 0U;
      {
#line 10662
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 10662
        if (! (j < pm___0->ngamma_tests)) {
#line 10662
          goto while_break___1;
        }
#line 10664
        if (i != j) {
#line 10666
          gamma_transform_test(pm___0, colour_type, bit_depth, (int )palette_number,
                               pm___0->interlace_type, (double const   )((double )1 / *(pm___0->gammas + i)),
                               (double const   )*(pm___0->gammas + j), (png_byte )0,
                               (int )pm___0->use_input_precision, 0);
#line 10670
          tmp = fail(pm___0);
#line 10670
          if (tmp) {
#line 10671
            return;
          }
        }
#line 10662
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 10660
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 10676
  return;
}
}
#line 10678 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void perform_gamma_sbit_tests(png_modifier *pm___0 )
{
  png_byte sbit ;
  png_byte colour_type ;
  png_byte bit_depth ;
  unsigned int npalette ;
  unsigned int i ;
  unsigned int j ;
  int tmp ;
  int tmp___0 ;

  {
#line 10686
  sbit = pm___0->sbitlow;
  {
#line 10686
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10686
    if (! ((int )sbit < 1 << 4)) {
#line 10686
      goto while_break;
    }
#line 10688
    colour_type = (png_byte )0;
#line 10688
    bit_depth = (png_byte )0;
#line 10689
    npalette = 0U;
    {
#line 10691
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 10691
      tmp___0 = next_format(& colour_type, & bit_depth, & npalette, (int )pm___0->test_lbg_gamma_sbit,
                            (int )pm___0->test_tRNS);
#line 10691
      if (! tmp___0) {
#line 10691
        goto while_break___0;
      }
#line 10693
      if (((int )colour_type & 4) == 0) {
#line 10693
        if ((int )colour_type == 3) {
#line 10693
          if ((int )sbit < 8) {
#line 10693
            goto _L;
          } else {
#line 10693
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */
#line 10693
        if ((int )colour_type != 3) {
#line 10693
          if ((int )sbit < (int )bit_depth) {
            _L: /* CIL Label */
#line 10699
            i = 0U;
            {
#line 10699
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 10699
              if (! (i < pm___0->ngamma_tests)) {
#line 10699
                goto while_break___1;
              }
#line 10703
              j = 0U;
              {
#line 10703
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 10703
                if (! (j < pm___0->ngamma_tests)) {
#line 10703
                  goto while_break___2;
                }
#line 10705
                if (i != j) {
#line 10707
                  gamma_transform_test(pm___0, colour_type, bit_depth, (int )npalette,
                                       pm___0->interlace_type, (double const   )((double )1 / *(pm___0->gammas + i)),
                                       (double const   )*(pm___0->gammas + j), sbit,
                                       (int )pm___0->use_input_precision_sbit, 0);
#line 10711
                  tmp = fail(pm___0);
#line 10711
                  if (tmp) {
#line 10712
                    return;
                  }
                }
#line 10703
                j ++;
              }
              while_break___2: /* CIL Label */ ;
              }
#line 10699
              i ++;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 10686
    sbit = (png_byte )((int )sbit + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 10718
  return;
}
}
#line 10725 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void perform_gamma_scale16_tests(png_modifier *pm___0 )
{
  unsigned int i ;
  unsigned int j ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;

  {
#line 10744
  i = 0U;
  {
#line 10744
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10744
    if (! (i < pm___0->ngamma_tests)) {
#line 10744
      goto while_break;
    }
#line 10746
    j = 0U;
    {
#line 10746
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 10746
      if (! (j < pm___0->ngamma_tests)) {
#line 10746
        goto while_break___0;
      }
#line 10748
      if (i != j) {
#line 10748
        tmp___3 = fabs(*(pm___0->gammas + j) / *(pm___0->gammas + i) - (double )1);
#line 10748
        if (tmp___3 >= (double )5000 * .00001) {
#line 10751
          gamma_transform_test(pm___0, (png_byte )0, (png_byte )16, 0, pm___0->interlace_type,
                               (double const   )((double )1 / *(pm___0->gammas + i)),
                               (double const   )*(pm___0->gammas + j), (png_byte )11,
                               (int )pm___0->use_input_precision_16to8, 1);
#line 10755
          tmp = fail(pm___0);
#line 10755
          if (tmp) {
#line 10756
            return;
          }
#line 10758
          gamma_transform_test(pm___0, (png_byte )2, (png_byte )16, 0, pm___0->interlace_type,
                               (double const   )((double )1 / *(pm___0->gammas + i)),
                               (double const   )*(pm___0->gammas + j), (png_byte )11,
                               (int )pm___0->use_input_precision_16to8, 1);
#line 10762
          tmp___0 = fail(pm___0);
#line 10762
          if (tmp___0) {
#line 10763
            return;
          }
#line 10765
          gamma_transform_test(pm___0, (png_byte )4, (png_byte )16, 0, pm___0->interlace_type,
                               (double const   )((double )1 / *(pm___0->gammas + i)),
                               (double const   )*(pm___0->gammas + j), (png_byte )11,
                               (int )pm___0->use_input_precision_16to8, 1);
#line 10769
          tmp___1 = fail(pm___0);
#line 10769
          if (tmp___1) {
#line 10770
            return;
          }
#line 10772
          gamma_transform_test(pm___0, (png_byte )6, (png_byte )16, 0, pm___0->interlace_type,
                               (double const   )((double )1 / *(pm___0->gammas + i)),
                               (double const   )*(pm___0->gammas + j), (png_byte )11,
                               (int )pm___0->use_input_precision_16to8, 1);
#line 10776
          tmp___2 = fail(pm___0);
#line 10776
          if (tmp___2) {
#line 10777
            return;
          }
        }
      }
#line 10746
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 10744
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 10781
  return;
}
}
#line 10786 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void gamma_composition_test(png_modifier *pm___0 , png_byte colour_type , png_byte bit_depth ,
                                   int palette_number , int interlace_type , double const   file_gamma ,
                                   double const   screen_gamma , int use_input_precision ,
                                   int do_background , int expand_16 )
{
  size_t pos ;
  png_const_charp base ;
  double bg ;
  char name[128] ;
  png_color_16 background ;
  png_uint_32 r ;
  png_uint_32 tmp ;
  double tmp___0 ;
  png_uint_32 r___0 ;
  png_uint_32 tmp___1 ;

  {
#line 10794
  pos = (size_t )0;
  {
#line 10807
  if (do_background == 1) {
#line 10807
    goto case_1;
  }
#line 10811
  if (do_background == 2) {
#line 10811
    goto case_2;
  }
#line 10815
  if (do_background == 3) {
#line 10815
    goto case_3;
  }
#line 10824
  if (do_background == 4) {
#line 10824
    goto case_4;
  }
#line 10828
  if (do_background == 5) {
#line 10828
    goto case_5;
  }
#line 10832
  if (do_background == 6) {
#line 10832
    goto case_6;
  }
#line 10836
  if (do_background == 7) {
#line 10836
    goto case_7;
  }
#line 10803
  goto switch_default;
  switch_default: /* CIL Label */
#line 10804
  base = (png_const_charp )"";
#line 10805
  bg = (double )4;
#line 10806
  goto switch_break;
  case_1: /* CIL Label */
#line 10808
  base = (png_const_charp )" bckg(Screen):";
#line 10809
  bg = (double )((double const   )1 / screen_gamma);
#line 10810
  goto switch_break;
  case_2: /* CIL Label */
#line 10812
  base = (png_const_charp )" bckg(File):";
#line 10813
  bg = (double )file_gamma;
#line 10814
  goto switch_break;
  case_3: /* CIL Label */
#line 10816
  base = (png_const_charp )" bckg(Unique):";
#line 10821
  bg = (double )((file_gamma + screen_gamma) / (double const   )3);
#line 10822
  goto switch_break;
  case_4: /* CIL Label */
#line 10825
  base = (png_const_charp )" alpha(PNG)";
#line 10826
  bg = (double )4;
#line 10827
  goto switch_break;
  case_5: /* CIL Label */
#line 10829
  base = (png_const_charp )" alpha(Porter-Duff)";
#line 10830
  bg = (double )4;
#line 10831
  goto switch_break;
  case_6: /* CIL Label */
#line 10833
  base = (png_const_charp )" alpha(Optimized)";
#line 10834
  bg = (double )4;
#line 10835
  goto switch_break;
  case_7: /* CIL Label */
#line 10837
  base = (png_const_charp )" alpha(Broken)";
#line 10838
  bg = (double )4;
#line 10839
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 10846
  if (expand_16) {
#line 10846
    goto _L___0;
  } else
#line 10846
  if ((int )bit_depth == 16) {
    _L___0: /* CIL Label */
#line 10848
    tmp = random_32();
#line 10848
    r = tmp;
#line 10850
    background.red = (png_uint_16 )r;
#line 10851
    background.green = (png_uint_16 )(r >> 16);
#line 10852
    r = random_32();
#line 10853
    background.blue = (png_uint_16 )r;
#line 10854
    background.gray = (png_uint_16 )(r >> 16);
#line 10863
    if (expand_16) {
#line 10863
      if (do_background == 3) {
#line 10863
        goto _L;
      } else
#line 10863
      if (do_background == 2) {
        _L: /* CIL Label */
#line 10863
        tmp___0 = fabs(bg * (double )screen_gamma - (double )1);
#line 10863
        if (tmp___0 > (double )5000 * .00001) {
#line 10871
          background.red = (png_uint_16 )(((int )background.red >> 8) * 257);
#line 10872
          background.green = (png_uint_16 )(((int )background.green >> 8) * 257);
#line 10873
          background.blue = (png_uint_16 )(((int )background.blue >> 8) * 257);
#line 10874
          background.gray = (png_uint_16 )(((int )background.gray >> 8) * 257);
        }
      }
    }
  } else {
#line 10881
    tmp___1 = random_32();
#line 10881
    r___0 = tmp___1;
#line 10883
    background.red = (png_uint_16 )((png_byte )r___0);
#line 10884
    background.green = (png_uint_16 )((png_byte )(r___0 >> 8));
#line 10885
    background.blue = (png_uint_16 )((png_byte )(r___0 >> 16));
#line 10886
    background.gray = (png_uint_16 )((png_byte )(r___0 >> 24));
  }
#line 10889
  background.index = (png_byte )193;
#line 10891
  if (! ((int )colour_type & 2)) {
#line 10898
    if ((int )bit_depth < 8) {
#line 10899
      background.gray = (png_uint_16 )((int )background.gray & (int )((png_uint_16 )((1U << (int )bit_depth) - 1U)));
    }
#line 10904
    background.blue = background.gray;
#line 10904
    background.green = background.blue;
#line 10904
    background.red = background.green;
  }
#line 10907
  pos = safecat(name, sizeof(name), pos, (char const   *)"gamma ");
#line 10908
  pos = safecatd(name, sizeof(name), pos, (double )file_gamma, 3);
#line 10909
  pos = safecat(name, sizeof(name), pos, (char const   *)"->");
#line 10910
  pos = safecatd(name, sizeof(name), pos, (double )screen_gamma, 3);
#line 10912
  pos = safecat(name, sizeof(name), pos, base);
#line 10913
  if (do_background < 4) {
#line 10916
    pos = safecat(name, sizeof(name), pos, (char const   *)"(");
#line 10919
    if ((int )colour_type & 2) {
#line 10921
      pos = safecatn(name, sizeof(name), pos, (int )background.red);
#line 10922
      pos = safecat(name, sizeof(name), pos, (char const   *)",");
#line 10923
      pos = safecatn(name, sizeof(name), pos, (int )background.green);
#line 10924
      pos = safecat(name, sizeof(name), pos, (char const   *)",");
#line 10925
      pos = safecatn(name, sizeof(name), pos, (int )background.blue);
    } else {
#line 10928
      pos = safecatn(name, sizeof(name), pos, (int )background.gray);
    }
#line 10929
    pos = safecat(name, sizeof(name), pos, (char const   *)")^");
#line 10930
    pos = safecatd(name, sizeof(name), pos, bg, 3);
  }
#line 10933
  gamma_test(pm___0, colour_type, bit_depth, palette_number, interlace_type, file_gamma,
             screen_gamma, (png_byte )0, 0, (char const   *)(name), use_input_precision,
             0, expand_16, do_background, (png_color_16 const   *)(& background),
             bg);
#line 10936
  return;
}
}
#line 10939 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void perform_gamma_composition_tests(png_modifier *pm___0 , int do_background ,
                                            int expand_16 )
{
  png_byte colour_type ;
  png_byte bit_depth ;
  unsigned int palette_number ;
  unsigned int i ;
  unsigned int j ;
  int tmp ;
  int tmp___0 ;

  {
#line 10943
  colour_type = (png_byte )0;
#line 10944
  bit_depth = (png_byte )0;
#line 10945
  palette_number = 0U;
  {
#line 10953
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10953
    tmp___0 = next_format(& colour_type, & bit_depth, & palette_number, (int )pm___0->test_lbg_gamma_composition,
                          (int )pm___0->test_tRNS);
#line 10953
    if (! tmp___0) {
#line 10953
      goto while_break;
    }
#line 10955
    if (((int )colour_type & 4) != 0) {
#line 10955
      goto _L;
    } else
#line 10955
    if ((int )colour_type != 3) {
#line 10955
      if (palette_number != 0U) {
        _L: /* CIL Label */
#line 10965
        i = 0U;
        {
#line 10965
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 10965
          if (! (i < pm___0->ngamma_tests)) {
#line 10965
            goto while_break___0;
          }
#line 10967
          j = 0U;
          {
#line 10967
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 10967
            if (! (j < pm___0->ngamma_tests)) {
#line 10967
              goto while_break___1;
            }
#line 10969
            gamma_composition_test(pm___0, colour_type, bit_depth, (int )palette_number,
                                   pm___0->interlace_type, (double const   )((double )1 / *(pm___0->gammas + i)),
                                   (double const   )*(pm___0->gammas + j), (int )pm___0->use_input_precision,
                                   do_background, expand_16);
#line 10973
            tmp = fail(pm___0);
#line 10973
            if (tmp) {
#line 10974
              return;
            }
#line 10967
            j ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 10965
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 10978
  return;
}
}
#line 10981 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void init_gamma_errors(png_modifier *pm___0 )
{
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 10985
  tmp___0 = - 1.;
#line 10985
  pm___0->error_gray_8 = tmp___0;
#line 10985
  tmp = tmp___0;
#line 10985
  pm___0->error_gray_4 = tmp;
#line 10985
  pm___0->error_gray_2 = tmp;
#line 10986
  pm___0->error_color_8 = - 1.;
#line 10987
  pm___0->error_indexed = - 1.;
#line 10988
  tmp___1 = - 1.;
#line 10988
  pm___0->error_color_16 = tmp___1;
#line 10988
  pm___0->error_gray_16 = tmp___1;
#line 10989
  return;
}
}
#line 10991 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void print_one(char const   *leader , double err )
{


  {
#line 10994
  if (err != - 1.) {
#line 10995
    printf((char const   *)" %s %.5f\n", leader, err);
  }
#line 10996
  return;
}
}
#line 10998 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void summarize_gamma_errors(png_modifier *pm___0 , png_const_charp who , int low_bit_depth ,
                                   int indexed )
{


  {
#line 11002
  fflush(stderr);
#line 11004
  if (who) {
#line 11005
    printf((char const   *)"\nGamma correction with %s:\n", who);
  } else {
#line 11008
    printf((char const   *)"\nBasic gamma correction:\n");
  }
#line 11010
  if (low_bit_depth) {
#line 11012
    print_one((char const   *)" 2 bit gray: ", pm___0->error_gray_2);
#line 11013
    print_one((char const   *)" 4 bit gray: ", pm___0->error_gray_4);
#line 11014
    print_one((char const   *)" 8 bit gray: ", pm___0->error_gray_8);
#line 11015
    print_one((char const   *)" 8 bit color:", pm___0->error_color_8);
#line 11016
    if (indexed) {
#line 11017
      print_one((char const   *)" indexed:    ", pm___0->error_indexed);
    }
  }
#line 11020
  print_one((char const   *)"16 bit gray: ", pm___0->error_gray_16);
#line 11021
  print_one((char const   *)"16 bit color:", pm___0->error_color_16);
#line 11023
  fflush(stdout);
#line 11024
  return;
}
}
#line 11026 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void perform_gamma_test(png_modifier *pm___0 , int summary )
{
  unsigned int calculations_use_input_precision ;
  double maxout8 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int do_background ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 11031
  calculations_use_input_precision = pm___0->calculations_use_input_precision;
#line 11034
  maxout8 = pm___0->maxout8;
#line 11038
  if (! pm___0->this.speed) {
#line 11038
    if (pm___0->test_gamma_threshold) {
#line 11040
      perform_gamma_threshold_tests(pm___0);
#line 11042
      tmp = fail(pm___0);
#line 11042
      if (tmp) {
#line 11043
        return;
      }
    }
  }
#line 11047
  if (pm___0->test_gamma_transform) {
#line 11049
    if (summary) {
#line 11051
      fflush(stderr);
#line 11052
      printf((char const   *)"Gamma correction error summary\n\n");
#line 11053
      printf((char const   *)"The printed value is the maximum error in the pixel values\n");
#line 11054
      printf((char const   *)"calculated by the libpng gamma correction code.  The error\n");
#line 11055
      printf((char const   *)"is calculated as the difference between the output pixel\n");
#line 11056
      printf((char const   *)"value (always an integer) and the ideal value from the\n");
#line 11057
      printf((char const   *)"libpng specification (typically not an integer).\n\n");
#line 11059
      printf((char const   *)"Expect this value to be less than .5 for 8 bit formats,\n");
#line 11060
      printf((char const   *)"less than 1 for formats with fewer than 8 bits and a small\n");
#line 11061
      printf((char const   *)"number (typically less than 5) for the 16 bit formats.\n");
#line 11062
      printf((char const   *)"For performance reasons the value for 16 bit formats\n");
#line 11063
      printf((char const   *)"increases when the image file includes an sBIT chunk.\n");
#line 11064
      fflush(stdout);
    }
#line 11067
    init_gamma_errors(pm___0);
#line 11071
    if (pm___0->test_gamma_expand16) {
#line 11072
      pm___0->calculations_use_input_precision = 1U;
    }
#line 11073
    perform_gamma_transform_tests(pm___0);
#line 11074
    if (! calculations_use_input_precision) {
#line 11075
      pm___0->calculations_use_input_precision = 0U;
    }
#line 11077
    if (summary) {
#line 11078
      summarize_gamma_errors(pm___0, (png_const_charp )((void *)0), 1, 1);
    }
#line 11080
    tmp___0 = fail(pm___0);
#line 11080
    if (tmp___0) {
#line 11081
      return;
    }
  }
#line 11085
  if (pm___0->test_gamma_sbit) {
#line 11087
    init_gamma_errors(pm___0);
#line 11088
    perform_gamma_sbit_tests(pm___0);
#line 11090
    if (summary) {
#line 11091
      summarize_gamma_errors(pm___0, (png_const_charp )"sBIT", (unsigned int )pm___0->sbitlow < 8U,
                             1);
    }
#line 11093
    tmp___1 = fail(pm___0);
#line 11093
    if (tmp___1) {
#line 11094
      return;
    }
  }
#line 11098
  if (pm___0->test_gamma_scale16) {
#line 11101
    init_gamma_errors(pm___0);
#line 11102
    perform_gamma_scale16_tests(pm___0);
#line 11104
    if (summary) {
#line 11106
      fflush(stderr);
#line 11107
      printf((char const   *)"\nGamma correction with 16 to 8 bit reduction:\n");
#line 11108
      printf((char const   *)" 16 bit gray:  %.5f\n", pm___0->error_gray_16);
#line 11109
      printf((char const   *)" 16 bit color: %.5f\n", pm___0->error_color_16);
#line 11110
      fflush(stdout);
    }
#line 11113
    tmp___2 = fail(pm___0);
#line 11113
    if (tmp___2) {
#line 11114
      return;
    }
  }
#line 11119
  if (pm___0->test_gamma_background) {
#line 11121
    init_gamma_errors(pm___0);
#line 11126
    if (pm___0->test_gamma_expand16) {
#line 11128
      pm___0->calculations_use_input_precision = 1U;
#line 11129
      pm___0->maxout8 = .499;
    }
#line 11131
    perform_gamma_composition_tests(pm___0, 3, (int )pm___0->test_gamma_expand16);
#line 11133
    if (! calculations_use_input_precision) {
#line 11134
      pm___0->calculations_use_input_precision = 0U;
    }
#line 11135
    pm___0->maxout8 = maxout8;
#line 11137
    if (summary) {
#line 11138
      summarize_gamma_errors(pm___0, (png_const_charp )"background", 1, 0);
    }
#line 11140
    tmp___3 = fail(pm___0);
#line 11140
    if (tmp___3) {
#line 11141
      return;
    }
  }
#line 11146
  if (pm___0->test_gamma_alpha_mode) {
#line 11150
    init_gamma_errors(pm___0);
#line 11155
    if (pm___0->test_gamma_expand16) {
#line 11156
      pm___0->calculations_use_input_precision = 1U;
    }
#line 11157
    do_background = 5;
    {
#line 11157
    while (1) {
      while_continue: /* CIL Label */ ;
#line 11157
      if (do_background <= 7) {
#line 11157
        tmp___4 = fail(pm___0);
#line 11157
        if (tmp___4) {
#line 11157
          goto while_break;
        }
      } else {
#line 11157
        goto while_break;
      }
#line 11160
      perform_gamma_composition_tests(pm___0, do_background, (int )pm___0->test_gamma_expand16);
#line 11157
      do_background ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 11162
    if (! calculations_use_input_precision) {
#line 11163
      pm___0->calculations_use_input_precision = 0U;
    }
#line 11165
    if (summary) {
#line 11166
      summarize_gamma_errors(pm___0, (png_const_charp )"alpha mode", 1, 0);
    }
#line 11168
    tmp___5 = fail(pm___0);
#line 11168
    if (tmp___5) {
#line 11169
      return;
    }
  }
#line 11172
  return;
}
}
#line 11183 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static png_byte const   adam7[8][8]  =
#line 11183
  { {        (png_byte const   )1,        (png_byte const   )6,        (png_byte const   )4,        (png_byte const   )6,
            (png_byte const   )2,        (png_byte const   )6,        (png_byte const   )4,        (png_byte const   )6},
   {        (png_byte const   )7,        (png_byte const   )7,        (png_byte const   )7,        (png_byte const   )7,
            (png_byte const   )7,        (png_byte const   )7,        (png_byte const   )7,        (png_byte const   )7},
   {        (png_byte const   )5,        (png_byte const   )6,        (png_byte const   )5,        (png_byte const   )6,
            (png_byte const   )5,        (png_byte const   )6,        (png_byte const   )5,        (png_byte const   )6},
   {        (png_byte const   )7,        (png_byte const   )7,        (png_byte const   )7,        (png_byte const   )7,
            (png_byte const   )7,        (png_byte const   )7,        (png_byte const   )7,        (png_byte const   )7},
   {        (png_byte const   )3,        (png_byte const   )6,        (png_byte const   )4,        (png_byte const   )6,
            (png_byte const   )3,        (png_byte const   )6,        (png_byte const   )4,        (png_byte const   )6},
   {        (png_byte const   )7,        (png_byte const   )7,        (png_byte const   )7,        (png_byte const   )7,
            (png_byte const   )7,        (png_byte const   )7,        (png_byte const   )7,        (png_byte const   )7},
   {        (png_byte const   )5,        (png_byte const   )6,        (png_byte const   )5,        (png_byte const   )6,
            (png_byte const   )5,        (png_byte const   )6,        (png_byte const   )5,        (png_byte const   )6},
   {        (png_byte const   )7,        (png_byte const   )7,        (png_byte const   )7,        (png_byte const   )7,
            (png_byte const   )7,        (png_byte const   )7,        (png_byte const   )7,        (png_byte const   )7}};
#line 11199 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static png_uint_32 png_pass_start_row(int pass )
{
  int x ;
  int y ;

  {
#line 11203
  pass ++;
#line 11204
  y = 0;
  {
#line 11204
  while (1) {
    while_continue: /* CIL Label */ ;
#line 11204
    if (! (y < 8)) {
#line 11204
      goto while_break;
    }
#line 11205
    x = 0;
    {
#line 11205
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 11205
      if (! (x < 8)) {
#line 11205
        goto while_break___0;
      }
#line 11206
      if ((int const   )adam7[y][x] == (int const   )pass) {
#line 11207
        return ((png_uint_32 )y);
      }
#line 11205
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 11204
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 11208
  return ((png_uint_32 )0xf);
}
}
#line 11211 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static png_uint_32 png_pass_start_col(int pass )
{
  int x ;
  int y ;

  {
#line 11215
  pass ++;
#line 11216
  x = 0;
  {
#line 11216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 11216
    if (! (x < 8)) {
#line 11216
      goto while_break;
    }
#line 11217
    y = 0;
    {
#line 11217
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 11217
      if (! (y < 8)) {
#line 11217
        goto while_break___0;
      }
#line 11218
      if ((int const   )adam7[y][x] == (int const   )pass) {
#line 11219
        return ((png_uint_32 )x);
      }
#line 11217
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 11216
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 11220
  return ((png_uint_32 )0xf);
}
}
#line 11223 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int png_pass_row_shift(int pass )
{
  int x ;
  int y ;
  int base ;
  int inc ;

  {
#line 11226
  base = -1;
#line 11226
  inc = 8;
#line 11227
  pass ++;
#line 11228
  y = 0;
  {
#line 11228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 11228
    if (! (y < 8)) {
#line 11228
      goto while_break;
    }
#line 11230
    x = 0;
    {
#line 11230
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 11230
      if (! (x < 8)) {
#line 11230
        goto while_break___0;
      }
#line 11232
      if ((int const   )adam7[y][x] == (int const   )pass) {
#line 11234
        if (base == -1) {
#line 11235
          base = y;
        } else
#line 11236
        if (! (base == y)) {
#line 11238
          if (inc == y - base) {
#line 11239
            base = y;
          } else
#line 11240
          if (inc == 8) {
#line 11241
            inc = y - base;
#line 11241
            base = y;
          } else
#line 11242
          if (inc != y - base) {
#line 11243
            return (0xff);
          }
        }
      }
#line 11230
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 11228
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 11248
  if (base == -1) {
#line 11248
    return (0xfe);
  }
  {
#line 11253
  if (inc == 2) {
#line 11253
    goto case_2;
  }
#line 11254
  if (inc == 4) {
#line 11254
    goto case_4;
  }
#line 11255
  if (inc == 8) {
#line 11255
    goto case_8;
  }
#line 11256
  goto switch_default;
  case_2: /* CIL Label */
#line 11253
  return (1);
  case_4: /* CIL Label */
#line 11254
  return (2);
  case_8: /* CIL Label */
#line 11255
  return (3);
  switch_default: /* CIL Label */
#line 11256
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 11260
  return ((inc << 8) + 0xfd);
}
}
#line 11263 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int png_pass_col_shift(int pass )
{
  int x ;
  int y ;
  int base ;
  int inc ;

  {
#line 11266
  base = -1;
#line 11266
  inc = 8;
#line 11267
  pass ++;
#line 11268
  x = 0;
  {
#line 11268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 11268
    if (! (x < 8)) {
#line 11268
      goto while_break;
    }
#line 11270
    y = 0;
    {
#line 11270
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 11270
      if (! (y < 8)) {
#line 11270
        goto while_break___0;
      }
#line 11272
      if ((int const   )adam7[y][x] == (int const   )pass) {
#line 11274
        if (base == -1) {
#line 11275
          base = x;
        } else
#line 11276
        if (! (base == x)) {
#line 11278
          if (inc == x - base) {
#line 11279
            base = x;
          } else
#line 11280
          if (inc == 8) {
#line 11281
            inc = x - base;
#line 11281
            base = x;
          } else
#line 11282
          if (inc != x - base) {
#line 11283
            return (0xff);
          }
        }
      }
#line 11270
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 11268
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 11288
  if (base == -1) {
#line 11288
    return (0xfe);
  }
  {
#line 11293
  if (inc == 1) {
#line 11293
    goto case_1;
  }
#line 11294
  if (inc == 2) {
#line 11294
    goto case_2;
  }
#line 11295
  if (inc == 4) {
#line 11295
    goto case_4;
  }
#line 11296
  if (inc == 8) {
#line 11296
    goto case_8;
  }
#line 11297
  goto switch_default;
  case_1: /* CIL Label */
#line 11293
  return (0);
  case_2: /* CIL Label */
#line 11294
  return (1);
  case_4: /* CIL Label */
#line 11295
  return (2);
  case_8: /* CIL Label */
#line 11296
  return (3);
  switch_default: /* CIL Label */
#line 11297
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 11301
  return ((inc << 8) + 0xfd);
}
}
#line 11304 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static png_uint_32 png_row_from_pass_row(png_uint_32 yIn , int pass )
{


  {
  {
#line 11310
  if (pass == 0) {
#line 11310
    goto case_0;
  }
#line 11311
  if (pass == 1) {
#line 11311
    goto case_1;
  }
#line 11312
  if (pass == 2) {
#line 11312
    goto case_2;
  }
#line 11313
  if (pass == 3) {
#line 11313
    goto case_3;
  }
#line 11314
  if (pass == 4) {
#line 11314
    goto case_4;
  }
#line 11315
  if (pass == 5) {
#line 11315
    goto case_5;
  }
#line 11316
  if (pass == 6) {
#line 11316
    goto case_6;
  }
#line 11317
  goto switch_default;
  case_0: /* CIL Label */
#line 11310
  return (yIn * 8U);
  case_1: /* CIL Label */
#line 11311
  return (yIn * 8U);
  case_2: /* CIL Label */
#line 11312
  return (yIn * 8U + 4U);
  case_3: /* CIL Label */
#line 11313
  return (yIn * 4U);
  case_4: /* CIL Label */
#line 11314
  return (yIn * 4U + 2U);
  case_5: /* CIL Label */
#line 11315
  return (yIn * 2U);
  case_6: /* CIL Label */
#line 11316
  return (yIn * 2U + 1U);
  switch_default: /* CIL Label */
#line 11317
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 11320
  return ((png_uint_32 )0xff);
}
}
#line 11323 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static png_uint_32 png_col_from_pass_col(png_uint_32 xIn , int pass )
{


  {
  {
#line 11329
  if (pass == 0) {
#line 11329
    goto case_0;
  }
#line 11330
  if (pass == 1) {
#line 11330
    goto case_1;
  }
#line 11331
  if (pass == 2) {
#line 11331
    goto case_2;
  }
#line 11332
  if (pass == 3) {
#line 11332
    goto case_3;
  }
#line 11333
  if (pass == 4) {
#line 11333
    goto case_4;
  }
#line 11334
  if (pass == 5) {
#line 11334
    goto case_5;
  }
#line 11335
  if (pass == 6) {
#line 11335
    goto case_6;
  }
#line 11336
  goto switch_default;
  case_0: /* CIL Label */
#line 11329
  return (xIn * 8U);
  case_1: /* CIL Label */
#line 11330
  return (xIn * 8U + 4U);
  case_2: /* CIL Label */
#line 11331
  return (xIn * 4U);
  case_3: /* CIL Label */
#line 11332
  return (xIn * 4U + 2U);
  case_4: /* CIL Label */
#line 11333
  return (xIn * 2U);
  case_5: /* CIL Label */
#line 11334
  return (xIn * 2U + 1U);
  case_6: /* CIL Label */
#line 11335
  return (xIn);
  switch_default: /* CIL Label */
#line 11336
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 11339
  return ((png_uint_32 )0xff);
}
}
#line 11342 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int png_row_in_interlace_pass(png_uint_32 y , int pass )
{
  int x ;

  {
#line 11347
  y &= 7U;
#line 11348
  pass ++;
#line 11349
  x = 0;
  {
#line 11349
  while (1) {
    while_continue: /* CIL Label */ ;
#line 11349
    if (! (x < 8)) {
#line 11349
      goto while_break;
    }
#line 11350
    if ((int const   )adam7[y][x] == (int const   )pass) {
#line 11351
      return (1);
    }
#line 11349
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 11353
  return (0);
}
}
#line 11356 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static int png_col_in_interlace_pass(png_uint_32 x , int pass )
{
  int y ;

  {
#line 11361
  x &= 7U;
#line 11362
  pass ++;
#line 11363
  y = 0;
  {
#line 11363
  while (1) {
    while_continue: /* CIL Label */ ;
#line 11363
    if (! (y < 8)) {
#line 11363
      goto while_break;
    }
#line 11364
    if ((int const   )adam7[y][x] == (int const   )pass) {
#line 11365
      return (1);
    }
#line 11363
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 11367
  return (0);
}
}
#line 11370 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static png_uint_32 png_pass_rows(png_uint_32 height , int pass )
{
  png_uint_32 tiles ;
  png_uint_32 rows ;
  unsigned int x ;
  unsigned int y ;

  {
#line 11373
  tiles = height >> 3;
#line 11374
  rows = (png_uint_32 )0;
#line 11377
  height &= 7U;
#line 11378
  pass ++;
#line 11379
  y = 0U;
  {
#line 11379
  while (1) {
    while_continue: /* CIL Label */ ;
#line 11379
    if (! (y < 8U)) {
#line 11379
      goto while_break;
    }
#line 11381
    x = 0U;
    {
#line 11381
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 11381
      if (! (x < 8U)) {
#line 11381
        goto while_break___0;
      }
#line 11383
      if ((int const   )adam7[y][x] == (int const   )pass) {
#line 11385
        rows += tiles;
#line 11386
        if (y < height) {
#line 11386
          rows ++;
        }
#line 11387
        goto while_break___0;
      }
#line 11381
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 11379
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 11392
  return (rows);
}
}
#line 11395 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static png_uint_32 png_pass_cols(png_uint_32 width , int pass )
{
  png_uint_32 tiles ;
  png_uint_32 cols ;
  unsigned int x ;
  unsigned int y ;

  {
#line 11398
  tiles = width >> 3;
#line 11399
  cols = (png_uint_32 )0;
#line 11402
  width &= 7U;
#line 11403
  pass ++;
#line 11404
  x = 0U;
  {
#line 11404
  while (1) {
    while_continue: /* CIL Label */ ;
#line 11404
    if (! (x < 8U)) {
#line 11404
      goto while_break;
    }
#line 11406
    y = 0U;
    {
#line 11406
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 11406
      if (! (y < 8U)) {
#line 11406
        goto while_break___0;
      }
#line 11408
      if ((int const   )adam7[y][x] == (int const   )pass) {
#line 11410
        cols += tiles;
#line 11411
        if (x < width) {
#line 11411
          cols ++;
        }
#line 11412
        goto while_break___0;
      }
#line 11406
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 11404
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 11417
  return (cols);
}
}
#line 11420 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void perform_interlace_macro_validation(void)
{
  int pass ;
  png_uint_32 m ;
  png_uint_32 f ;
  png_uint_32 v ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  png_uint_32 tmp___2 ;
  int tmp___3 ;
  png_uint_32 tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 11432
  pass = 0;
  {
#line 11432
  while (1) {
    while_continue: /* CIL Label */ ;
#line 11432
    if (! (pass < 7)) {
#line 11432
      goto while_break;
    }
#line 11436
    m = (png_uint_32 )(((1 & ~ pass) << (3 - (pass >> 1))) & 7);
#line 11437
    f = png_pass_start_row(pass);
#line 11438
    if (m != f) {
#line 11440
      fprintf(stderr, (char const   *)"PNG_PASS_START_ROW(%d) = %u != %x\n", pass,
              m, f);
#line 11441
      exit(99);
    }
#line 11444
    m = (png_uint_32 )(((1 & pass) << (3 - ((pass + 1) >> 1))) & 7);
#line 11445
    f = png_pass_start_col(pass);
#line 11446
    if (m != f) {
#line 11448
      fprintf(stderr, (char const   *)"PNG_PASS_START_COL(%d) = %u != %x\n", pass,
              m, f);
#line 11449
      exit(99);
    }
#line 11452
    if (pass > 2) {
#line 11452
      m = (png_uint_32 )((8 - pass) >> 1);
    } else {
#line 11452
      m = (png_uint_32 )3;
    }
#line 11453
    tmp = png_pass_row_shift(pass);
#line 11453
    f = (png_uint_32 )tmp;
#line 11454
    if (m != f) {
#line 11456
      fprintf(stderr, (char const   *)"PNG_PASS_ROW_SHIFT(%d) = %u != %x\n", pass,
              m, f);
#line 11457
      exit(99);
    }
#line 11460
    if (pass > 1) {
#line 11460
      m = (png_uint_32 )((7 - pass) >> 1);
    } else {
#line 11460
      m = (png_uint_32 )3;
    }
#line 11461
    tmp___0 = png_pass_col_shift(pass);
#line 11461
    f = (png_uint_32 )tmp___0;
#line 11462
    if (m != f) {
#line 11464
      fprintf(stderr, (char const   *)"PNG_PASS_COL_SHIFT(%d) = %u != %x\n", pass,
              m, f);
#line 11465
      exit(99);
    }
#line 11477
    v = (png_uint_32 )0;
    {
#line 11477
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 11487
      tmp___2 = png_pass_rows(0xFFFFFFFFU, pass);
#line 11487
      if (v < tmp___2) {
#line 11489
        if (pass > 2) {
#line 11489
          tmp___1 = (8 - pass) >> 1;
        } else {
#line 11489
          tmp___1 = 3;
        }
#line 11489
        m = (v << tmp___1) + (png_uint_32 )(((1 & ~ pass) << (3 - (pass >> 1))) & 7);
#line 11490
        f = png_row_from_pass_row(v, pass);
#line 11491
        if (m != f) {
#line 11493
          fprintf(stderr, (char const   *)"PNG_ROW_FROM_PASS_ROW(%u, %d) = %u != %x\n",
                  v, pass, m, f);
#line 11495
          exit(99);
        }
      }
#line 11499
      tmp___4 = png_pass_cols(0xFFFFFFFFU, pass);
#line 11499
      if (v < tmp___4) {
#line 11501
        if (pass > 1) {
#line 11501
          tmp___3 = (7 - pass) >> 1;
        } else {
#line 11501
          tmp___3 = 3;
        }
#line 11501
        m = (v << tmp___3) + (png_uint_32 )(((1 & pass) << (3 - ((pass + 1) >> 1))) & 7);
#line 11502
        f = png_col_from_pass_col(v, pass);
#line 11503
        if (m != f) {
#line 11505
          fprintf(stderr, (char const   *)"PNG_COL_FROM_PASS_COL(%u, %d) = %u != %x\n",
                  v, pass, m, f);
#line 11507
          exit(99);
        }
      }
#line 11511
      m = (png_uint_32 )(((((0x110145AF >> ((7 - pass) << 2)) & 0xF) | ((0x01145AF0 >> ((7 - pass) << 2)) & 0xF0)) >> (v & 7U)) & 1);
#line 11512
      tmp___5 = png_row_in_interlace_pass(v, pass);
#line 11512
      f = (png_uint_32 )tmp___5;
#line 11513
      if (m != f) {
#line 11515
        fprintf(stderr, (char const   *)"PNG_ROW_IN_INTERLACE_PASS(%u, %d) = %u != %x\n",
                v, pass, m, f);
#line 11517
        exit(99);
      }
#line 11520
      m = (png_uint_32 )(((((0x110145AF >> ((6 - pass) << 2)) & 0xF) | ((0x01145AF0 >> ((6 - pass) << 2)) & 0xF0)) >> (v & 7U)) & 1);
#line 11521
      tmp___6 = png_col_in_interlace_pass(v, pass);
#line 11521
      f = (png_uint_32 )tmp___6;
#line 11522
      if (m != f) {
#line 11524
        fprintf(stderr, (char const   *)"PNG_COL_IN_INTERLACE_PASS(%u, %d) = %u != %x\n",
                v, pass, m, f);
#line 11526
        exit(99);
      }
#line 11530
      v ++;
#line 11531
      if (pass > 2) {
#line 11531
        tmp___7 = (8 - pass) >> 1;
      } else {
#line 11531
        tmp___7 = 3;
      }
#line 11531
      if (pass > 2) {
#line 11531
        tmp___8 = (8 - pass) >> 1;
      } else {
#line 11531
        tmp___8 = 3;
      }
#line 11531
      m = (v + (png_uint_32 )(((1 << tmp___7) - 1) - (((1 & ~ pass) << (3 - (pass >> 1))) & 7))) >> tmp___8;
#line 11532
      f = png_pass_rows(v, pass);
#line 11533
      if (m != f) {
#line 11535
        fprintf(stderr, (char const   *)"PNG_PASS_ROWS(%u, %d) = %u != %x\n", v, pass,
                m, f);
#line 11537
        exit(99);
      }
#line 11540
      if (pass > 1) {
#line 11540
        tmp___9 = (7 - pass) >> 1;
      } else {
#line 11540
        tmp___9 = 3;
      }
#line 11540
      if (pass > 1) {
#line 11540
        tmp___10 = (7 - pass) >> 1;
      } else {
#line 11540
        tmp___10 = 3;
      }
#line 11540
      m = (v + (png_uint_32 )(((1 << tmp___9) - 1) - (((1 & pass) << (3 - ((pass + 1) >> 1))) & 7))) >> tmp___10;
#line 11541
      f = png_pass_cols(v, pass);
#line 11542
      if (m != f) {
#line 11544
        fprintf(stderr, (char const   *)"PNG_PASS_COLS(%u, %d) = %u != %x\n", v, pass,
                m, f);
#line 11546
        exit(99);
      }
#line 11552
      if (v > 1024U) {
#line 11554
        if (v == 2147483647U) {
#line 11555
          goto while_break___0;
        }
#line 11557
        v = (v << 1) ^ v;
#line 11558
        if (v >= 2147483647U) {
#line 11559
          v = 2147483646U;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 11432
    pass ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 11563
  return;
}
}
#line 11576 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static color_encoding const   test_encodings[5]  = {      {(double )1 / 2.2, {0.412390799265959, 0.212639005871510, 0.019330818715592},
      {0.357584339383878, 0.715168678767756, 0.119194779794626}, {0.180480788401834,
                                                                  0.072192315360734,
                                                                  0.950532152249660}},
        {(double )1 / 1.6,
      {0.797760489672303, 0.288071128229293, 0.000000000000000}, {0.135185837175740,
                                                                  0.711843217810102,
                                                                  0.000000000000000},
      {0.031349349581525, 0.000085653960605, 0.825104602510460}},
        {(double )1 / ((double )2 + 51. / (double )256), {0.576669042910131, 0.297344975250536,
                                                       0.027031361386412}, {0.185558237906546,
                                                                            0.627363566255466,
                                                                            0.070688852535827},
      {0.188228646234995, 0.075291458493998, 0.991337536837639}},
        {(double )1 / ((double )2 + 51. / (double )256), {0.716500716779386, 0.258728243040113,
                                                       0.000000000000000}, {0.101020574397477,
                                                                            0.724682314948566,
                                                                            0.051211818965388},
      {0.146774385252705, 0.016589442011321, 0.773892783545073}},
        {1.45 / 2.2, {0.716500716779386, 0.000000000000000, 0.000000000000000}, {0.101020574397477,
                                                                              1.000000000000000,
                                                                              0.051211818965388},
      {0.146774385252705, 0.000000000000000, 0.773892783545073}}};
#line 11612 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static png_modifier pm  ;
#line 11614 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static void signal_handler(int signum )
{
  size_t pos ;
  char msg[64] ;
  struct exception_context *the_exception_context ;

  {
#line 11617
  pos = (size_t )0;
#line 11620
  pos = safecat(msg, sizeof(msg), pos, (char const   *)"caught signal: ");
  {
#line 11624
  if (signum == 6) {
#line 11624
    goto case_6;
  }
#line 11628
  if (signum == 8) {
#line 11628
    goto case_8;
  }
#line 11632
  if (signum == 4) {
#line 11632
    goto case_4;
  }
#line 11636
  if (signum == 2) {
#line 11636
    goto case_2;
  }
#line 11640
  if (signum == 11) {
#line 11640
    goto case_11;
  }
#line 11644
  if (signum == 15) {
#line 11644
    goto case_15;
  }
#line 11648
  goto switch_default;
  case_6: /* CIL Label */
#line 11625
  pos = safecat(msg, sizeof(msg), pos, (char const   *)"abort");
#line 11626
  goto switch_break;
  case_8: /* CIL Label */
#line 11629
  pos = safecat(msg, sizeof(msg), pos, (char const   *)"floating point exception");
#line 11630
  goto switch_break;
  case_4: /* CIL Label */
#line 11633
  pos = safecat(msg, sizeof(msg), pos, (char const   *)"illegal instruction");
#line 11634
  goto switch_break;
  case_2: /* CIL Label */
#line 11637
  pos = safecat(msg, sizeof(msg), pos, (char const   *)"interrupt");
#line 11638
  goto switch_break;
  case_11: /* CIL Label */
#line 11641
  pos = safecat(msg, sizeof(msg), pos, (char const   *)"invalid memory access");
#line 11642
  goto switch_break;
  case_15: /* CIL Label */
#line 11645
  pos = safecat(msg, sizeof(msg), pos, (char const   *)"termination request");
#line 11646
  goto switch_break;
  switch_default: /* CIL Label */
#line 11649
  pos = safecat(msg, sizeof(msg), pos, (char const   *)"unknown ");
#line 11650
  pos = safecatn(msg, sizeof(msg), pos, signum);
#line 11651
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 11654
  store_log(& pm.this, (png_const_structp )((void *)0), (png_const_charp )(msg), 1);
#line 11659
  if (signum != 15) {
#line 11661
    the_exception_context = & pm.this.exception_context;
    {
#line 11664
    while (1) {
      while_continue: /* CIL Label */ ;
#line 11664
      the_exception_context->v.etmp = (struct png_store * volatile  )(& pm.this);
#line 11664
      longjmp((struct __jmp_buf_tag *)(*(the_exception_context->penv)), 1);
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 11668
    exit(1);
  }
}
}
#line 11686 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngvalid.c"
static double gammas[9]  =
#line 11686
  {      2.2,      1.0,      2.2 / 1.45,      1.8,
        1.5,      2.4,      2.5,      2.62,
        2.9};
#line 101 "/usr/include/stdlib.h"
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 104
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 107
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 112
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__leaf__, __gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__,
__nothrow__)) ;
#line 800
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) realpath)(char const   *__name , char *__resolved )  __attribute__((__nothrow__)) ;
#line 820
__inline extern void *( __attribute__((__warn_unused_result__, __nonnull__(1,2,5),
__gnu_inline__)) bsearch)(void const   *__key , void const   *__base , size_t __nmemb ,
                          size_t __size , int (*__compar)(void const   * , void const   * ) ) ;
#line 929
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar )  __attribute__((__nothrow__)) ;
#line 933
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t *__dst , char const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 936
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) wcstombs)(char *__dst , wchar_t const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 43 "/usr/include/string.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memcpy)(void *__dest , void const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 47
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 61
__inline extern void *( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) memset)(void *__dest , int __ch , size_t __len )  __attribute__((__nothrow__)) ;
#line 122
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcpy)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 125
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncpy)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 130
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcat)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 133
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncat)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 38 "/usr/include/strings.h"
__inline extern void ( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) bcopy)(void const   *__src , void *__dest , size_t __len )  __attribute__((__nothrow__)) ;
#line 42
__inline extern void ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) bzero)(void *__dest , size_t __len )  __attribute__((__nothrow__)) ;
#line 436 "/usr/include/string.h"
__inline extern void ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) explicit_bzero)(void *__dest , size_t __len )  __attribute__((__nothrow__)) ;
#line 460
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) stpncpy)(char *__dest , char const   *__src ,
                                             size_t __n )  __attribute__((__nothrow__)) ;
#line 326 "/usr/include/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) fprintf)(FILE *__stream ,
                                                                                                  char const   *__fmt
                                                                                                  , ...) ;
#line 332
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) printf)(char const   *__fmt
                                                                                                 , ...) ;
#line 334
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) sprintf)(char *__s ,
                                                                                                            char const   *__fmt
                                                                                                            , ...)  __attribute__((__nothrow__)) ;
#line 341
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vfprintf)(FILE *__stream ,
                                                                                                   char const   *__fmt ,
                                                                                                   __gnuc_va_list __ap ) ;
#line 347
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vprintf)(char const   *__fmt ,
                                                                                                  __gnuc_va_list __ap ) ;
#line 349
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vsprintf)(char *__s ,
                                                                                                             char const   *__fmt ,
                                                                                                             __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 354
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) snprintf)(char *__s , size_t __n , char const   *__fmt
                                              , ...)  __attribute__((__nothrow__)) ;
#line 358
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) vsnprintf)(char *__s , size_t __n , char const   *__fmt ,
                                               __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 379
__inline extern int ( /* format attribute */ __attribute__((__gnu_inline__, __artificial__,
__always_inline__)) vdprintf)(int __fd , char const   *__fmt , __gnuc_va_list __ap ) ;
#line 382
__inline extern int ( /* format attribute */ __attribute__((__gnu_inline__, __artificial__,
__always_inline__)) dprintf)(int __fd , char const   *__fmt  , ...) ;
#line 492
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
#line 499
__inline extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
#line 500
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
#line 510
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
#line 528
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
#line 537
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) ;
#line 545
__inline extern int ( __attribute__((__gnu_inline__)) putc_unlocked)(int __c , FILE *__stream ) ;
#line 546
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
#line 564
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fgets)(char *__s , int __n , FILE *__stream ) ;
#line 646
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fread)(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 673
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fread_unlocked)(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 766
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__)) feof_unlocked)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 767
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__)) ferror_unlocked)(FILE *__stream )  __attribute__((__nothrow__)) ;
#line 3 "lib/libc/stub/include/assert.h"
extern void __goblint_assert(int expression ) ;
#line 119 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static struct transform_info transform_info___0[21]  =
#line 119 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
  {      {(char const   *)"STRIP_16", 0x0001, (png_uint_32 )0, (png_byte )0, (png_byte )0,
      (png_byte )16, (png_byte )1, (png_byte )0},
        {(char const   *)"STRIP_ALPHA", 0x0002, (png_uint_32 )0, (png_byte )4, (png_byte )0,
      (png_byte )31, (png_byte )1, (png_byte )0},
        {(char const   *)"PACKING", 0x0004, (png_uint_32 )0, (png_byte )0, (png_byte )0,
      (png_byte )7, (png_byte )3, (png_byte )0},
        {(char const   *)"PACKSWAP", 0x0008, (png_uint_32 )0, (png_byte )0, (png_byte )0,
      (png_byte )7, (png_byte )3, (png_byte )0},
        {(char const   *)"EXPAND", 0x0010, (png_uint_32 )0, (png_byte )1, (png_byte )0,
      (png_byte )31, (png_byte )1, (png_byte )0},
        {(char const   *)"EXPAND", 0x0010, (png_uint_32 )0, (png_byte )0, (png_byte )2,
      (png_byte )31, (png_byte )1, (png_byte )0},
        {(char const   *)"EXPAND", 0x0010, 0x0010U, (png_byte )0, (png_byte )4, (png_byte )31,
      (png_byte )1, (png_byte )0},
        {(char const   *)"INVERT_MONO", 0x0020, (png_uint_32 )0, (png_byte )0, (png_byte )2,
      (png_byte )31, (png_byte )3, (png_byte )0},
        {(char const   *)"SHIFT", 0x0040, 0x0002U, (png_byte )0, (png_byte )0, (png_byte )31,
      (png_byte )3, (png_byte )0},
        {(char const   *)"BGR", 0x0080, (png_uint_32 )0, (png_byte )2, (png_byte )1,
      (png_byte )24, (png_byte )3, (png_byte )0},
        {(char const   *)"SWAP_ALPHA", 0x0100, (png_uint_32 )0, (png_byte )4, (png_byte )0,
      (png_byte )24, (png_byte )3, (png_byte )0},
        {(char const   *)"SWAP_ENDIAN", 0x0200, (png_uint_32 )0, (png_byte )0, (png_byte )1,
      (png_byte )16, (png_byte )3, (png_byte )0},
        {(char const   *)"INVERT_ALPHA", 0x0400, (png_uint_32 )0, (png_byte )4, (png_byte )0,
      (png_byte )24, (png_byte )3, (png_byte )0},
        {(char const   *)"STRIP_FILLER_BEFORE", 0x0800, (png_uint_32 )0, (png_byte )4,
      (png_byte )1, (png_byte )24, (png_byte )2, (png_byte )0},
        {(char const   *)"STRIP_FILLER_AFTER", 0x1000, (png_uint_32 )0, (png_byte )4,
      (png_byte )1, (png_byte )24, (png_byte )2, (png_byte )0},
        {(char const   *)"GRAY_TO_RGB", 0x2000, (png_uint_32 )0, (png_byte )0, (png_byte )2,
      (png_byte )31, (png_byte )1, (png_byte )0},
        {(char const   *)"GRAY_TO_RGB", 0x2000, (png_uint_32 )0, (png_byte )1, (png_byte )0,
      (png_byte )31, (png_byte )1, (png_byte )0},
        {(char const   *)"EXPAND_16", 0x4000, (png_uint_32 )0, (png_byte )0, (png_byte )0,
      (png_byte )15, (png_byte )1, (png_byte )0},
        {(char const   *)"EXPAND_16", 0x4000, 0x0010U, (png_byte )0, (png_byte )4, (png_byte )16,
      (png_byte )1, (png_byte )0},
        {(char const   *)"SCALE_16", 0x8000, (png_uint_32 )0, (png_byte )0, (png_byte )0,
      (png_byte )16, (png_byte )1, (png_byte )0},
        {(char const   *)((void *)0), 0, (png_uint_32 )0, (png_byte )0, (png_byte )0,
      (png_byte )0, (png_byte )0, (png_byte )0}};
#line 276 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static int known_bad_combos[1][2]  = { {        1088,        0}};
#line 282 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static int is_combo(int transforms )
{


  {
#line 285
  return (transforms & (transforms - 1));
}
}
#line 288 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static int first_transform(int transforms )
{


  {
#line 291
  return (transforms & - transforms);
}
}
#line 294 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static int is_bad_combo(int transforms )
{
  unsigned int i ;
  int combo ;

  {
#line 299
  i = 0U;
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 299
    if (! ((unsigned long )i < sizeof(known_bad_combos) / sizeof(known_bad_combos[0]))) {
#line 299
      goto while_break;
    }
#line 301
    combo = known_bad_combos[i][0];
#line 303
    if ((combo & transforms) == combo) {
#line 303
      if ((transforms & known_bad_combos[i][1]) == 0) {
#line 305
        return (1);
      }
    }
#line 299
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 308
  return (0);
}
}
#line 311 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static char const   *transform_name(int t )
{
  unsigned int i ;

  {
#line 319
  t &= - t;
#line 321
  i = 0U;
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 321
    if (! ((unsigned long )i < sizeof(transform_info___0) / sizeof(transform_info___0[0]))) {
#line 321
      goto while_break;
    }
#line 322
    if ((unsigned long )transform_info___0[i].name != (unsigned long )((void *)0)) {
#line 323
      if ((transform_info___0[i].transform & t) != 0) {
#line 324
        return (transform_info___0[i].name);
      }
    }
#line 321
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 326
  return ((char const   *)"invalid transform");
}
}
#line 333 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static unsigned int read_transforms  ;
#line 333 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static unsigned int write_transforms  ;
#line 333 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static unsigned int rw_transforms  ;
#line 335 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static void validate_T(void)
{
  unsigned int i ;

  {
#line 341
  i = 0U;
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (! ((unsigned long )i < sizeof(transform_info___0) / sizeof(transform_info___0[0]))) {
#line 341
      goto while_break;
    }
#line 343
    if ((unsigned long )transform_info___0[i].name != (unsigned long )((void *)0)) {
#line 345
      if ((int )transform_info___0[i].when & 1) {
#line 346
        read_transforms |= (unsigned int )transform_info___0[i].transform;
      }
#line 348
      if ((int )transform_info___0[i].when & 2) {
#line 349
        write_transforms |= (unsigned int )transform_info___0[i].transform;
      }
    }
#line 341
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 356
  rw_transforms = read_transforms & write_transforms;
#line 357
  return;
}
}
#line 384 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static void buffer_init(struct buffer *buffer___0 )
{


  {
#line 388
  buffer___0->first.next = (struct buffer_list *)((void *)0);
#line 389
  buffer___0->last = (struct buffer_list *)((void *)0);
#line 390
  buffer___0->current = (struct buffer_list *)((void *)0);
#line 391
  return;
}
}
#line 393 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static void buffer_destroy_list(struct buffer_list *list )
{
  struct buffer_list *next ;

  {
#line 396
  if ((unsigned long )list != (unsigned long )((void *)0)) {
#line 398
    next = list->next;
#line 399
    free((void *)list);
#line 400
    buffer_destroy_list(next);
  }
#line 402
  return;
}
}
#line 404 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static void buffer_destroy(struct buffer *buffer___0 )
{
  struct buffer_list *list ;

  {
#line 407
  list = buffer___0->first.next;
#line 408
  buffer_init(buffer___0);
#line 409
  buffer_destroy_list(list);
#line 410
  return;
}
}
#line 413 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static void buffer_start_write(struct buffer *buffer___0 )
{


  {
#line 416
  buffer___0->last = & buffer___0->first;
#line 417
  buffer___0->end_count = (size_t )0;
#line 418
  buffer___0->current = (struct buffer_list *)((void *)0);
#line 419
  return;
}
}
#line 422 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static void buffer_start_read(struct buffer *buffer___0 )
{


  {
#line 425
  buffer___0->current = & buffer___0->first;
#line 426
  buffer___0->read_count = (size_t )0;
#line 427
  return;
}
}
#line 434 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static struct buffer *get_buffer(png_structp pp )
{
  png_voidp tmp ;

  {
#line 438
  tmp = png_get_io_ptr((png_const_structrp )pp);
#line 438
  return ((struct buffer *)tmp);
}
}
#line 441 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static struct buffer_list *buffer_extend(struct buffer_list *current )
{
  struct buffer_list *add ;
  void *tmp ;

  {
#line 446
  __goblint_assert((unsigned long )current->next == (unsigned long )((void *)0));
#line 448
  tmp = malloc(sizeof(struct buffer_list ));
#line 448
  add = (struct buffer_list *)tmp;
#line 449
  if ((unsigned long )add == (unsigned long )((void *)0)) {
#line 450
    return ((struct buffer_list *)((void *)0));
  }
#line 452
  add->next = (struct buffer_list *)((void *)0);
#line 453
  current->next = add;
#line 455
  return (add);
}
}
#line 461 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static int buffer_from_file(struct buffer *buffer___0 , FILE *fp )
{
  struct buffer_list *last ;
  size_t count ;
  size_t r ;
  size_t tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;

  {
#line 464
  last = & buffer___0->first;
#line 465
  count = (size_t )0;
  {
#line 467
  while (1) {
    while_continue: /* CIL Label */ ;
#line 469
    tmp = fread((void *)(last->buffer + count), (size_t )1, sizeof(last->buffer) - count,
                fp);
#line 469
    r = tmp;
#line 472
    if (r > 0UL) {
#line 474
      count += r;
#line 476
      if (count >= sizeof(last->buffer)) {
#line 478
        __goblint_assert(count == sizeof(last->buffer));
#line 479
        count = (size_t )0;
#line 481
        if ((unsigned long )last->next == (unsigned long )((void *)0)) {
#line 483
          last = buffer_extend(last);
#line 484
          if ((unsigned long )last == (unsigned long )((void *)0)) {
#line 485
            return (12);
          }
        } else {
#line 489
          last = last->next;
        }
      }
    } else {
#line 495
      tmp___0 = feof(fp);
#line 495
      if (tmp___0) {
#line 497
        buffer___0->last = last;
#line 498
        buffer___0->end_count = count;
#line 499
        return (0);
      }
#line 503
      tmp___4 = __errno_location();
#line 503
      if (*tmp___4 == 0) {
#line 503
        tmp___3 = 34;
      } else {
#line 503
        tmp___2 = __errno_location();
#line 503
        tmp___3 = *tmp___2;
      }
#line 503
      return (tmp___3);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 591 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static void display_init(struct display *dp )
{


  {
#line 598
  memset((void *)dp, 0, sizeof(*dp));
#line 599
  dp->options = (png_uint_32 )2;
#line 600
  dp->filename = (char const   *)((void *)0);
#line 601
  dp->operation = (char const   *)((void *)0);
#line 602
  dp->original_pp = (png_structp )((void *)0);
#line 603
  dp->original_ip = (png_infop )((void *)0);
#line 604
  dp->original_rows = (png_bytepp )((void *)0);
#line 605
  dp->read_pp = (png_structp )((void *)0);
#line 606
  dp->read_ip = (png_infop )((void *)0);
#line 607
  buffer_init(& dp->original_file);
#line 610
  dp->write_pp = (png_structp )((void *)0);
#line 611
  buffer_init(& dp->written_file);
#line 613
  return;
}
}
#line 615 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static void display_clean_read(struct display *dp )
{


  {
#line 618
  if ((unsigned long )dp->read_pp != (unsigned long )((void *)0)) {
#line 619
    png_destroy_read_struct(& dp->read_pp, & dp->read_ip, (png_infopp )((void *)0));
  }
#line 620
  return;
}
}
#line 623 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static void display_clean_write(struct display *dp )
{


  {
#line 626
  if ((unsigned long )dp->write_pp != (unsigned long )((void *)0)) {
#line 627
    png_destroy_write_struct(& dp->write_pp, (png_infopp )((void *)0));
  }
#line 628
  return;
}
}
#line 631 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static void display_clean(struct display *dp )
{


  {
#line 635
  display_clean_write(dp);
#line 637
  display_clean_read(dp);
#line 639
  dp->original_rowbytes = (size_t )0;
#line 640
  dp->original_rows = (png_bytepp )((void *)0);
#line 641
  dp->chunks = (png_uint_32 )0;
#line 643
  png_destroy_read_struct(& dp->original_pp, & dp->original_ip, (png_infopp )((void *)0));
#line 645
  dp->results = (png_uint_32 )0;
#line 646
  return;
}
}
#line 648 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static void display_destroy(struct display *dp )
{


  {
#line 653
  buffer_destroy(& dp->written_file);
#line 656
  buffer_destroy(& dp->original_file);
#line 657
  return;
}
}
#line 659 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static struct display *get_dp(png_structp pp )
{
  struct display *dp ;
  png_voidp tmp ;

  {
#line 663
  tmp = png_get_error_ptr((png_const_structrp )pp);
#line 663
  dp = (struct display *)tmp;
#line 665
  if ((unsigned long )dp == (unsigned long )((void *)0)) {
#line 667
    fprintf(stderr, (char const   *)"pngimage: internal error (no display)\n");
#line 668
    exit(99);
  }
#line 671
  return (dp);
}
}
#line 683 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static void ( /* format attribute */  display_log)(struct display *dp , error_level level ,
                                                   char const   *fmt  , ...)
{
  char const   *lp ;
  va_list ap ;
  char const   *tmp ;
  int tr ;
  int trx ;
  int start ;
  int trz ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
#line 689
  dp->results |= 1U << (unsigned int )level;
#line 691
  if ((unsigned int )level > (unsigned int )((error_level )(dp->options & 15U))) {
    {
#line 698
    if ((unsigned int )level == 1U) {
#line 698
      goto case_1;
    }
#line 699
    if ((unsigned int )level == 3U) {
#line 699
      goto case_3;
    }
#line 700
    if ((unsigned int )level == 4U) {
#line 700
      goto case_4;
    }
#line 701
    if ((unsigned int )level == 6U) {
#line 701
      goto case_6;
    }
#line 702
    if ((unsigned int )level == 7U) {
#line 702
      goto case_7;
    }
#line 703
    if ((unsigned int )level == 8U) {
#line 703
      goto case_8;
    }
#line 704
    if ((unsigned int )level == 9U) {
#line 704
      goto case_9;
    }
#line 705
    if ((unsigned int )level == 11U) {
#line 705
      goto case_11;
    }
#line 709
    goto switch_default;
    case_1: /* CIL Label */
#line 698
    lp = (char const   *)"information";
#line 698
    goto switch_break;
    case_3: /* CIL Label */
#line 699
    lp = (char const   *)"warning(libpng)";
#line 699
    goto switch_break;
    case_4: /* CIL Label */
#line 700
    lp = (char const   *)"warning(pngimage)";
#line 700
    goto switch_break;
    case_6: /* CIL Label */
#line 701
    lp = (char const   *)"error(continuable)";
#line 701
    goto switch_break;
    case_7: /* CIL Label */
#line 702
    lp = (char const   *)"error(libpng)";
#line 702
    goto switch_break;
    case_8: /* CIL Label */
#line 703
    lp = (char const   *)"bug(libpng)";
#line 703
    goto switch_break;
    case_9: /* CIL Label */
#line 704
    lp = (char const   *)"error(pngimage)";
#line 704
    goto switch_break;
    case_11: /* CIL Label */
#line 705
    lp = (char const   *)"error(user)";
#line 705
    goto switch_break;
    switch_default: /* CIL Label */
    case_10: /* CIL Label */
    case_5: /* CIL Label */
    case_2: /* CIL Label */
    case_0: /* CIL Label */
    case_12: /* CIL Label */
#line 709
    lp = (char const   *)"bug(pngimage)";
#line 709
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 712
    if ((unsigned long )dp->filename != (unsigned long )((void *)0)) {
#line 712
      tmp = dp->filename;
    } else {
#line 712
      tmp = (char const   *)"<stdin>";
    }
#line 712
    fprintf(stderr, (char const   *)"%s: %s: %s", tmp, lp, dp->operation);
#line 715
    if (dp->transforms != 0) {
#line 717
      tr = dp->transforms;
#line 719
      tmp___2 = is_combo(tr);
#line 719
      if (tmp___2) {
#line 721
        if (dp->options & 2048U) {
#line 723
          trx = tr;
#line 725
          fprintf(stderr, (char const   *)"(");
#line 726
          if (trx) {
#line 728
            start = 0;
            {
#line 730
            while (1) {
              while_continue: /* CIL Label */ ;
#line 730
              if (! trx) {
#line 730
                goto while_break;
              }
#line 732
              trz = trx & - trx;
#line 734
              if (start) {
#line 734
                fprintf(stderr, (char const   *)"+");
              }
#line 735
              tmp___0 = transform_name(trz);
#line 735
              fprintf(stderr, (char const   *)"%s", tmp___0);
#line 736
              start = 1;
#line 737
              trx &= ~ trz;
            }
            while_break: /* CIL Label */ ;
            }
          } else {
#line 742
            fprintf(stderr, (char const   *)"-");
          }
#line 743
          fprintf(stderr, (char const   *)")");
        } else {
#line 747
          fprintf(stderr, (char const   *)"(0x%x)", tr);
        }
      } else {
#line 751
        tmp___1 = transform_name(tr);
#line 751
        fprintf(stderr, (char const   *)"(%s)", tmp___1);
      }
    }
#line 754
    fprintf(stderr, (char const   *)": ");
#line 756
    __builtin_va_start(ap, fmt);
#line 757
    vfprintf(stderr, fmt, ap);
#line 758
    __builtin_va_end(ap);
#line 760
    fputc('\n', stderr);
  }
#line 765
  if ((unsigned int )level > 6U) {
#line 766
    longjmp((struct __jmp_buf_tag *)(dp->error_return), (int )level);
  } else
#line 765
  if ((unsigned int )level > 5U) {
#line 765
    if (! (dp->options & 128U)) {
#line 766
      longjmp((struct __jmp_buf_tag *)(dp->error_return), (int )level);
    }
  }
#line 767
  return;
}
}
#line 770 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static void display_warning(png_structp pp , png_const_charp warning___0 )
{
  struct display *tmp ;

  {
#line 773
  tmp = get_dp(pp);
#line 773
  display_log(tmp, (error_level )3, (char const   *)"%s", warning___0);
#line 774
  return;
}
}
#line 776 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static void display_error(png_structp pp , png_const_charp error___0 )
{
  struct display *dp ;
  struct display *tmp ;

  {
#line 779
  tmp = get_dp(pp);
#line 779
  dp = tmp;
#line 781
  display_log(dp, (error_level )7, (char const   *)"%s", error___0);
#line 782
  return;
}
}
#line 784 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static void display_cache_file(struct display *dp , char const   *filename )
{
  FILE *fp ;
  int ret ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 791
  dp->filename = filename;
#line 793
  if ((unsigned long )filename != (unsigned long )((void *)0)) {
#line 795
    fp = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"rb");
#line 796
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 797
      tmp = __errno_location();
#line 797
      tmp___0 = strerror(*tmp);
#line 797
      display_log(dp, (error_level )11, (char const   *)"open failed: %s", tmp___0);
    }
  } else {
#line 801
    fp = stdin;
  }
#line 803
  ret = buffer_from_file(& dp->original_file, fp);
#line 805
  fclose(fp);
#line 807
  if (ret != 0) {
#line 808
    tmp___1 = strerror(ret);
#line 808
    display_log(dp, (error_level )9, (char const   *)"read failed: %s", tmp___1);
  }
#line 809
  return;
}
}
#line 811 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static void buffer_read(struct display *dp , struct buffer *bp , png_bytep data ,
                        size_t size )
{
  struct buffer_list *last ;
  size_t read_count ;
  size_t avail ;

  {
#line 815
  last = bp->current;
#line 816
  read_count = bp->read_count;
  {
#line 818
  while (1) {
    while_continue: /* CIL Label */ ;
#line 818
    if (! (size > 0UL)) {
#line 818
      goto while_break;
    }
#line 822
    if ((unsigned long )last == (unsigned long )((void *)0)) {
#line 825
      display_log(dp, (error_level )11, (char const   *)"file truncated (%lu bytes)",
                  size);
#line 828
      goto while_break;
    } else
#line 822
    if ((unsigned long )last == (unsigned long )bp->last) {
#line 822
      if (read_count >= bp->end_count) {
#line 825
        display_log(dp, (error_level )11, (char const   *)"file truncated (%lu bytes)",
                    size);
#line 828
        goto while_break;
      } else {
#line 822
        goto _L;
      }
    } else
    _L: /* CIL Label */
#line 831
    if (read_count >= sizeof(last->buffer)) {
#line 834
      last = last->next;
#line 835
      read_count = (size_t )0;
#line 836
      bp->current = last;
#line 839
      if ((unsigned long )last == (unsigned long )((void *)0)) {
#line 841
        display_log(dp, (error_level )12, (char const   *)"damaged buffer list");
#line 843
        goto while_break;
      }
    }
#line 847
    avail = sizeof(last->buffer) - read_count;
#line 848
    if (avail > size) {
#line 849
      avail = size;
    }
#line 851
    memcpy((void *)data, (void const   *)(last->buffer + read_count), avail);
#line 852
    read_count += avail;
#line 853
    size -= avail;
#line 854
    data += avail;
  }
  while_break: /* CIL Label */ ;
  }
#line 857
  bp->read_count = read_count;
#line 858
  return;
}
}
#line 860 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static void read_function(png_structp pp , png_bytep data , size_t size )
{
  struct buffer *tmp ;
  struct display *tmp___0 ;

  {
#line 863
  tmp = get_buffer(pp);
#line 863
  tmp___0 = get_dp(pp);
#line 863
  buffer_read(tmp___0, tmp, data, size);
#line 864
  return;
}
}
#line 866 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static void read_png(struct display *dp , struct buffer *bp , char const   *operation ,
                     int transforms )
{
  png_structp pp ;
  png_infop ip ;
  png_structp __attribute__((__malloc__))  tmp ;
  png_infop __attribute__((__malloc__))  tmp___0 ;

  {
#line 876
  display_clean_read(dp);
#line 878
  if ((unsigned long )operation != (unsigned long )((void *)0)) {
#line 880
    dp->operation = operation;
#line 881
    dp->transforms = transforms;
  }
#line 884
  tmp = png_create_read_struct((png_const_charp )"1.6.39", (png_voidp )dp, & display_error,
                               & display_warning);
#line 884
  pp = (png_structp )tmp;
#line 884
  dp->read_pp = pp;
#line 886
  if ((unsigned long )pp == (unsigned long )((void *)0)) {
#line 887
    display_log(dp, (error_level )7, (char const   *)"failed to create read struct");
  }
#line 892
  tmp___0 = png_create_info_struct((png_const_structrp )pp);
#line 892
  ip = (png_infop )tmp___0;
#line 892
  dp->read_ip = ip;
#line 893
  if ((unsigned long )ip == (unsigned long )((void *)0)) {
#line 894
    display_log(dp, (error_level )7, (char const   *)"failed to create info struct");
  }
#line 898
  png_set_user_limits((png_structrp )pp, (png_uint_32 )0x7fffffff, (png_uint_32 )0x7fffffff);
#line 902
  buffer_start_read(bp);
#line 903
  png_set_read_fn((png_structrp )pp, (png_voidp )bp, & read_function);
#line 905
  png_read_png((png_structrp )pp, (png_inforp )ip, transforms, (void *)0);
#line 922
  return;
}
}
#line 924 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static void update_display(struct display *dp )
{
  png_structp pp ;
  png_infop ip ;
  png_uint_32 tmp ;
  png_uint_32 chunks ;
  int active ;
  int inactive ;
  int ct ;
  int bd ;
  unsigned int i ;
  int transform ;

  {
#line 934
  read_png(dp, & dp->original_file, (char const   *)"original read", 0);
#line 937
  pp = dp->read_pp;
#line 937
  dp->original_pp = pp;
#line 937
  dp->read_pp = (png_structp )((void *)0);
#line 938
  ip = dp->read_ip;
#line 938
  dp->original_ip = ip;
#line 938
  dp->read_ip = (png_infop )((void *)0);
#line 940
  dp->original_rowbytes = png_get_rowbytes((png_const_structrp )pp, (png_const_inforp )ip);
#line 941
  if (dp->original_rowbytes == 0UL) {
#line 942
    display_log(dp, (error_level )8, (char const   *)"png_get_rowbytes returned 0");
  }
#line 944
  dp->chunks = png_get_valid((png_const_structrp )pp, (png_const_inforp )ip, 0xffffffff);
#line 945
  if ((dp->chunks & 0x8000U) == 0U) {
#line 946
    display_log(dp, (error_level )8, (char const   *)"png_read_png did not set IDAT flag");
  }
#line 948
  dp->original_rows = png_get_rows((png_const_structrp )pp, (png_const_inforp )ip);
#line 949
  if ((unsigned long )dp->original_rows == (unsigned long )((void *)0)) {
#line 950
    display_log(dp, (error_level )8, (char const   *)"png_read_png did not create row buffers");
  }
#line 952
  tmp = png_get_IHDR((png_const_structrp )pp, (png_const_inforp )ip, & dp->width,
                     & dp->height, & dp->bit_depth, & dp->color_type, & dp->interlace_method,
                     & dp->compression_method, & dp->filter_method);
#line 952
  if (! tmp) {
#line 955
    display_log(dp, (error_level )8, (char const   *)"png_get_IHDR failed");
  }
#line 962
  chunks = dp->chunks;
#line 963
  active = 0;
#line 963
  inactive = 0;
#line 964
  ct = dp->color_type;
#line 965
  bd = dp->bit_depth;
#line 968
  i = 0U;
  {
#line 968
  while (1) {
    while_continue: /* CIL Label */ ;
#line 968
    if (! ((unsigned long )i < sizeof(transform_info___0) / sizeof(transform_info___0[0]))) {
#line 968
      goto while_break;
    }
#line 970
    if ((unsigned long )transform_info___0[i].name != (unsigned long )((void *)0)) {
#line 972
      transform = transform_info___0[i].transform;
#line 974
      if (transform_info___0[i].valid_chunks == 0U) {
#line 974
        goto _L___3;
      } else
#line 974
      if ((transform_info___0[i].valid_chunks & chunks) != 0U) {
        _L___3: /* CIL Label */
#line 974
        if (((int )transform_info___0[i].color_mask_required & ct) == (int )transform_info___0[i].color_mask_required) {
#line 974
          if (((int )transform_info___0[i].color_mask_absent & ct) == 0) {
#line 974
            if (((int )transform_info___0[i].bit_depths & bd) != 0) {
#line 974
              if (((int )transform_info___0[i].when & 1) != 0) {
#line 981
                active |= transform;
              } else {
#line 974
                goto _L___2;
              }
            } else {
#line 974
              goto _L___2;
            }
          } else {
#line 974
            goto _L___2;
          }
        } else {
#line 974
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */
      _L___1: /* CIL Label */
      _L___0: /* CIL Label */
      _L: /* CIL Label */
#line 983
      if (((int )transform_info___0[i].when & 1) != 0) {
#line 984
        inactive |= transform;
      }
    }
#line 968
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 992
  inactive &= ~ active;
#line 994
  dp->active_transforms = active;
#line 995
  dp->ignored_transforms = inactive;
#line 997
  return;
}
}
#line 999 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static int compare_read(struct display *dp , int applied_transforms )
{
  size_t rowbytes ;
  png_uint_32 width ;
  png_uint_32 height ;
  int bit_depth ;
  int color_type ;
  int interlace_method ;
  int compression_method ;
  int filter_method ;
  char const   *e ;
  png_uint_32 tmp ;
  unsigned long chunks ;
  png_uint_32 tmp___0 ;
  png_bytepp rows ;
  png_bytepp tmp___1 ;
  unsigned int mask ;
  unsigned long y ;
  png_bytep row ;
  png_bytep orig ;
  size_t x ;
  int tmp___2 ;
  unsigned long y___0 ;
  int bpp ;
  png_byte sig_bits[8] ;
  png_color_8p sBIT ;
  png_uint_32 tmp___3 ;
  int b ;
  int b___0 ;
  unsigned int sig ;
  png_bytep row___0 ;
  png_bytep orig___0 ;
  unsigned long x___0 ;
  int b___1 ;
  png_bytep tmp___4 ;
  png_bytep tmp___5 ;

  {
#line 1007
  e = (char const   *)((void *)0);
#line 1009
  tmp = png_get_IHDR((png_const_structrp )dp->read_pp, (png_const_inforp )dp->read_ip,
                     & width, & height, & bit_depth, & color_type, & interlace_method,
                     & compression_method, & filter_method);
#line 1009
  if (! tmp) {
#line 1011
    display_log(dp, (error_level )8, (char const   *)"png_get_IHDR failed");
  }
#line 1018
  if (width != dp->width) {
#line 1018
    display_log(dp, (error_level )4, (char const   *)"IHDR width(%lu) changed to %lu",
                (unsigned long )dp->width, (unsigned long )width);
#line 1018
    e = (char const   *)"width";
  }
#line 1019
  if (height != dp->height) {
#line 1019
    display_log(dp, (error_level )4, (char const   *)"IHDR height(%lu) changed to %lu",
                (unsigned long )dp->height, (unsigned long )height);
#line 1019
    e = (char const   *)"height";
  }
#line 1020
  if (bit_depth != dp->bit_depth) {
#line 1020
    display_log(dp, (error_level )4, (char const   *)"IHDR bit_depth(%lu) changed to %lu",
                (unsigned long )dp->bit_depth, (unsigned long )bit_depth);
#line 1020
    e = (char const   *)"bit_depth";
  }
#line 1021
  if (color_type != dp->color_type) {
#line 1021
    display_log(dp, (error_level )4, (char const   *)"IHDR color_type(%lu) changed to %lu",
                (unsigned long )dp->color_type, (unsigned long )color_type);
#line 1021
    e = (char const   *)"color_type";
  }
#line 1022
  if (interlace_method != dp->interlace_method) {
#line 1022
    display_log(dp, (error_level )4, (char const   *)"IHDR interlace_method(%lu) changed to %lu",
                (unsigned long )dp->interlace_method, (unsigned long )interlace_method);
#line 1022
    e = (char const   *)"interlace_method";
  }
#line 1023
  if (compression_method != dp->compression_method) {
#line 1023
    display_log(dp, (error_level )4, (char const   *)"IHDR compression_method(%lu) changed to %lu",
                (unsigned long )dp->compression_method, (unsigned long )compression_method);
#line 1023
    e = (char const   *)"compression_method";
  }
#line 1024
  if (filter_method != dp->filter_method) {
#line 1024
    display_log(dp, (error_level )4, (char const   *)"IHDR filter_method(%lu) changed to %lu",
                (unsigned long )dp->filter_method, (unsigned long )filter_method);
#line 1024
    e = (char const   *)"filter_method";
  }
#line 1027
  if (e) {
#line 1028
    display_log(dp, (error_level )9, (char const   *)"IHDR changed (%s)", e);
  }
#line 1034
  tmp___0 = png_get_valid((png_const_structrp )dp->read_pp, (png_const_inforp )dp->read_ip,
                          0xffffffff);
#line 1034
  chunks = (unsigned long )tmp___0;
#line 1037
  if (chunks != (unsigned long )dp->chunks) {
#line 1038
    display_log(dp, (error_level )6, (char const   *)"PNG chunks changed from 0x%lx to 0x%lx",
                (unsigned long )dp->chunks, chunks);
  }
#line 1043
  rowbytes = png_get_rowbytes((png_const_structrp )dp->read_pp, (png_const_inforp )dp->read_ip);
#line 1048
  if (rowbytes != dp->original_rowbytes) {
#line 1049
    display_log(dp, (error_level )9, (char const   *)"PNG rowbytes changed from %lu to %lu",
                dp->original_rowbytes, rowbytes);
  }
#line 1056
  tmp___1 = png_get_rows((png_const_structrp )dp->read_pp, (png_const_inforp )dp->read_ip);
#line 1056
  rows = tmp___1;
#line 1059
  if (bit_depth < 8) {
#line 1065
    mask = (unsigned int )(0xff & (0xff00 >> ((png_uint_32 )bit_depth * width & 7U)));
  } else {
#line 1069
    mask = 0U;
  }
#line 1071
  if ((unsigned long )rows == (unsigned long )((void *)0)) {
#line 1072
    display_log(dp, (error_level )8, (char const   *)"png_get_rows returned NULL");
  }
#line 1074
  if ((applied_transforms & 0x0040) == 0) {
#line 1074
    goto _L___0;
  } else
#line 1074
  if ((dp->active_transforms & 0x0040) == 0) {
#line 1074
    goto _L___0;
  } else
#line 1074
  if (color_type == 3) {
    _L___0: /* CIL Label */
#line 1080
    y = 0UL;
    {
#line 1080
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1080
      if (! (y < (unsigned long )height)) {
#line 1080
        goto while_break;
      }
#line 1082
      row = *(rows + y);
#line 1083
      orig = *(dp->original_rows + y);
#line 1085
      tmp___2 = memcmp((void const   *)row, (void const   *)orig, rowbytes - (size_t )(mask != 0U));
#line 1085
      if (tmp___2 != 0) {
#line 1085
        goto _L;
      } else
#line 1085
      if (mask != 0U) {
#line 1085
        if (((unsigned int )*(row + (rowbytes - 1UL)) & mask) != ((unsigned int )*(orig + (rowbytes - 1UL)) & mask)) {
          _L: /* CIL Label */
#line 1091
          x = (size_t )0;
          {
#line 1091
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1091
            if (! (x < rowbytes - 1UL)) {
#line 1091
              goto while_break___0;
            }
#line 1092
            if ((int )*(row + x) != (int )*(orig + x)) {
#line 1093
              goto while_break___0;
            }
#line 1091
            x ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 1095
          display_log(dp, (error_level )6, (char const   *)"byte(%lu,%lu) changed 0x%.2x -> 0x%.2x",
                      x, y, (int )*(orig + x), (int )*(row + x));
#line 1098
          return (0);
        }
      }
#line 1080
      y ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1112
    tmp___3 = png_get_sBIT((png_const_structrp )dp->read_pp, (png_inforp )dp->read_ip,
                           & sBIT);
#line 1112
    if (tmp___3 != 0x0002U) {
#line 1113
      display_log(dp, (error_level )12, (char const   *)"active shift transform but no sBIT in file");
    }
    {
#line 1118
    if (color_type == 0) {
#line 1118
      goto case_0;
    }
#line 1123
    if (color_type == 4) {
#line 1123
      goto case_4;
    }
#line 1129
    if (color_type == 2) {
#line 1129
      goto case_2;
    }
#line 1136
    if (color_type == 6) {
#line 1136
      goto case_6;
    }
#line 1144
    goto switch_default;
    case_0: /* CIL Label */
#line 1119
    sig_bits[0] = sBIT->gray;
#line 1120
    bpp = bit_depth;
#line 1121
    goto switch_break;
    case_4: /* CIL Label */
#line 1124
    sig_bits[0] = sBIT->gray;
#line 1125
    sig_bits[1] = sBIT->alpha;
#line 1126
    bpp = 2 * bit_depth;
#line 1127
    goto switch_break;
    case_2: /* CIL Label */
#line 1130
    sig_bits[0] = sBIT->red;
#line 1131
    sig_bits[1] = sBIT->green;
#line 1132
    sig_bits[2] = sBIT->blue;
#line 1133
    bpp = 3 * bit_depth;
#line 1134
    goto switch_break;
    case_6: /* CIL Label */
#line 1137
    sig_bits[0] = sBIT->red;
#line 1138
    sig_bits[1] = sBIT->green;
#line 1139
    sig_bits[2] = sBIT->blue;
#line 1140
    sig_bits[3] = sBIT->alpha;
#line 1141
    bpp = 4 * bit_depth;
#line 1142
    goto switch_break;
    switch_default: /* CIL Label */
#line 1145
    display_log(dp, (error_level )7, (char const   *)"invalid colour type %d", color_type);
#line 1148
    memset((void *)(sig_bits), 0, sizeof(sig_bits));
#line 1149
    bpp = 0;
#line 1150
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1156
    b = 0;
    {
#line 1156
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1156
      if (! (8 * b < bpp)) {
#line 1156
        goto while_break___1;
      }
#line 1162
      if ((int )sig_bits[b] == 0) {
#line 1163
        display_log(dp, (error_level )8, (char const   *)"invalid sBIT[%u]  value %d returned for PNG bit depth %d",
                    b, (int )sig_bits[b], bit_depth);
      } else
#line 1162
      if ((int )sig_bits[b] > bit_depth) {
#line 1163
        display_log(dp, (error_level )8, (char const   *)"invalid sBIT[%u]  value %d returned for PNG bit depth %d",
                    b, (int )sig_bits[b], bit_depth);
      }
#line 1156
      b ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1169
    if (bpp < 8) {
#line 1169
      if (bpp != bit_depth) {
#line 1174
        display_log(dp, (error_level )12, (char const   *)"invalid bpp %u for bit_depth %u",
                    bpp, bit_depth);
      }
    }
    {
#line 1182
    if (bit_depth == 16) {
#line 1182
      goto case_16;
    }
#line 1192
    if (bit_depth == 8) {
#line 1192
      goto case_8;
    }
#line 1197
    if (bit_depth == 1) {
#line 1197
      goto case_1;
    }
#line 1202
    if (bit_depth == 2) {
#line 1202
      goto case_2___0;
    }
#line 1210
    if (bit_depth == 4) {
#line 1210
      goto case_4___0;
    }
#line 1217
    goto switch_default___0;
    case_16: /* CIL Label */
#line 1183
    b___0 = bpp >> 4;
    {
#line 1183
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1183
      if (! (b___0 > 0)) {
#line 1183
        goto while_break___2;
      }
#line 1185
      sig = 0xffff0000 >> (int )sig_bits[b___0];
#line 1187
      sig_bits[2 * b___0 + 1] = (png_byte )sig;
#line 1188
      sig_bits[2 * b___0] = (png_byte )(sig >> 8);
#line 1183
      b___0 --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1190
    goto switch_break___0;
    case_8: /* CIL Label */
#line 1193
    b___0 = 0;
    {
#line 1193
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1193
      if (! (b___0 * 8 < bpp)) {
#line 1193
        goto while_break___3;
      }
#line 1194
      sig_bits[b___0] = (png_byte )(0xff00 >> (int )sig_bits[b___0]);
#line 1193
      b___0 ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1195
    goto switch_break___0;
    case_1: /* CIL Label */
#line 1199
    sig_bits[0] = (png_byte )0xff;
#line 1200
    goto switch_break___0;
    case_2___0: /* CIL Label */
#line 1204
    b___0 = 0x3 & ((0x3 << 2) >> (int )sig_bits[0]);
#line 1205
    b___0 |= b___0 << 2;
#line 1206
    b___0 |= b___0 << 4;
#line 1207
    sig_bits[0] = (png_byte )b___0;
#line 1208
    goto switch_break___0;
    case_4___0: /* CIL Label */
#line 1212
    b___0 = 0xf & ((0xf << 4) >> (int )sig_bits[0]);
#line 1213
    b___0 |= b___0 << 4;
#line 1214
    sig_bits[0] = (png_byte )b___0;
#line 1215
    goto switch_break___0;
    switch_default___0: /* CIL Label */
#line 1218
    display_log(dp, (error_level )8, (char const   *)"invalid bit depth %d", bit_depth);
#line 1219
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 1225
    bpp = (bpp + 7) >> 3;
#line 1228
    if (mask != 0U) {
#line 1230
      mask &= (unsigned int )sig_bits[0];
#line 1232
      if (bpp != 1) {
#line 1233
        display_log(dp, (error_level )12, (char const   *)"mask calculation error %u, %u",
                    bpp, mask);
      } else
#line 1232
      if (mask == 0U) {
#line 1233
        display_log(dp, (error_level )12, (char const   *)"mask calculation error %u, %u",
                    bpp, mask);
      }
    }
#line 1237
    y___0 = 0UL;
    {
#line 1237
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1237
      if (! (y___0 < (unsigned long )height)) {
#line 1237
        goto while_break___4;
      }
#line 1239
      row___0 = *(rows + y___0);
#line 1240
      orig___0 = *(dp->original_rows + y___0);
#line 1243
      x___0 = 0UL;
      {
#line 1243
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1243
        if (! (x___0 < (unsigned long )(width - (png_uint_32 )(mask != 0U)))) {
#line 1243
          goto while_break___5;
        }
#line 1247
        b___1 = 0;
        {
#line 1247
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1247
          if (! (b___1 < bpp)) {
#line 1247
            goto while_break___6;
          }
#line 1249
          tmp___4 = row___0;
#line 1249
          row___0 ++;
#line 1249
          tmp___5 = orig___0;
#line 1249
          orig___0 ++;
#line 1249
          if (((int )*tmp___4 & (int )sig_bits[b___1]) != ((int )*tmp___5 & (int )sig_bits[b___1])) {
#line 1251
            display_log(dp, (error_level )6, (char const   *)"significant bits at (%lu[%u],%lu) changed %.2x->%.2x",
                        x___0, b___1, y___0, (int )*(orig___0 + -1), (int )*(row___0 + -1));
#line 1254
            return (0);
          }
#line 1247
          b___1 ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 1243
        x___0 ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1259
      if (mask != 0U) {
#line 1259
        if (((unsigned int )*row___0 & mask) != ((unsigned int )*orig___0 & mask)) {
#line 1261
          display_log(dp, (error_level )6, (char const   *)"significant bits at (%lu[end],%lu) changed",
                      x___0, y___0);
#line 1263
          return (0);
        }
      }
#line 1237
      y___0 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 1273
  return (1);
}
}
#line 1277 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static void buffer_write(struct display *dp , struct buffer *buffer___0 , png_bytep data ,
                         size_t size )
{
  struct buffer_list *last ;
  size_t end_count ;
  size_t avail ;

  {
#line 1285
  last = buffer___0->last;
#line 1286
  end_count = buffer___0->end_count;
  {
#line 1288
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1288
    if (! (size > 0UL)) {
#line 1288
      goto while_break;
    }
#line 1292
    if (end_count >= sizeof(last->buffer)) {
#line 1294
      if ((unsigned long )last->next == (unsigned long )((void *)0)) {
#line 1296
        last = buffer_extend(last);
#line 1298
        if ((unsigned long )last == (unsigned long )((void *)0)) {
#line 1299
          display_log(dp, (error_level )9, (char const   *)"out of memory saving file");
        }
      } else {
#line 1303
        last = last->next;
      }
#line 1305
      buffer___0->last = last;
#line 1306
      end_count = (size_t )0;
    }
#line 1309
    avail = sizeof(last->buffer) - end_count;
#line 1310
    if (avail > size) {
#line 1311
      avail = size;
    }
#line 1313
    memcpy((void *)(last->buffer + end_count), (void const   *)data, avail);
#line 1314
    end_count += avail;
#line 1315
    size -= avail;
#line 1316
    data += avail;
  }
  while_break: /* CIL Label */ ;
  }
#line 1319
  buffer___0->end_count = end_count;
#line 1320
  return;
}
}
#line 1322 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static void write_function(png_structp pp , png_bytep data , size_t size )
{
  struct buffer *tmp ;
  struct display *tmp___0 ;

  {
#line 1325
  tmp = get_buffer(pp);
#line 1325
  tmp___0 = get_dp(pp);
#line 1325
  buffer_write(tmp___0, tmp, data, size);
#line 1326
  return;
}
}
#line 1328 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static void write_png(struct display *dp , png_infop ip , int transforms )
{
  png_structp __attribute__((__malloc__))  tmp ;
  int ct ;

  {
#line 1331
  display_clean_write(dp);
#line 1333
  buffer_start_write(& dp->written_file);
#line 1334
  dp->operation = (char const   *)"write";
#line 1335
  dp->transforms = transforms;
#line 1337
  tmp = png_create_write_struct((png_const_charp )"1.6.39", (png_voidp )dp, & display_error,
                                & display_warning);
#line 1337
  dp->write_pp = (png_structp )tmp;
#line 1340
  if ((unsigned long )dp->write_pp == (unsigned long )((void *)0)) {
#line 1341
    display_log(dp, (error_level )9, (char const   *)"failed to create write png_struct");
  }
#line 1343
  png_set_write_fn((png_structrp )dp->write_pp, (png_voidp )(& dp->written_file),
                   & write_function, (void (*)(png_structp  ))((void *)0));
#line 1348
  png_set_user_limits((png_structrp )dp->write_pp, (png_uint_32 )0x7fffffff, (png_uint_32 )0x7fffffff);
#line 1354
  if (transforms & 2052) {
#line 1358
    ct = dp->color_type;
#line 1360
    if (transforms & 2048) {
#line 1362
      ct &= -5;
    }
#line 1364
    png_set_IHDR((png_const_structrp )dp->write_pp, (png_inforp )ip, dp->width, dp->height,
                 dp->bit_depth, ct, dp->interlace_method, dp->compression_method,
                 dp->filter_method);
  }
#line 1368
  png_write_png((png_structrp )dp->write_pp, (png_inforp )ip, transforms, (void *)0);
#line 1373
  display_clean_write(dp);
#line 1374
  return;
}
}
#line 1377 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static int skip_transform(struct display *dp , int tr )
{
  int next ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 1381
  if ((dp->options & 256U) != 0U) {
#line 1381
    tmp___1 = is_bad_combo(tr);
#line 1381
    if (tmp___1) {
#line 1386
      if ((dp->options & 512U) != 0U) {
#line 1388
        printf((char const   *)"SKIP: %s transforms ", dp->filename);
        {
#line 1390
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1390
          if (! (tr != 0)) {
#line 1390
            goto while_break;
          }
#line 1392
          tmp = first_transform(tr);
#line 1392
          next = tmp;
#line 1393
          tr &= ~ next;
#line 1395
          tmp___0 = transform_name(next);
#line 1395
          printf((char const   *)"%s", tmp___0);
#line 1396
          if (tr != 0) {
#line 1397
            putchar('+');
          }
        }
        while_break: /* CIL Label */ ;
        }
#line 1400
        putchar('\n');
      } else {
#line 1404
        display_log(dp, (error_level )1, (char const   *)"%s: skipped known bad combo 0x%x",
                    dp->filename, tr);
      }
#line 1407
      return (1);
    }
  }
#line 1410
  return (0);
}
}
#line 1413 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static void test_one_file___1(struct display *dp , char const   *filename )
{
  int tmp ;
  int tmp___0 ;
  unsigned int active ;
  int exhaustive ;
  unsigned int current ;
  int tmp___1 ;
  unsigned int bad_transforms ;
  unsigned int bad_combo ;
  unsigned int bad_combo_list ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned int next ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
#line 1419
  dp->operation = (char const   *)"cache file";
#line 1420
  dp->transforms = 0;
#line 1421
  display_cache_file(dp, filename);
#line 1422
  update_display(dp);
#line 1427
  if (dp->ignored_transforms != 0) {
#line 1429
    read_png(dp, & dp->original_file, (char const   *)"ignored transforms", dp->ignored_transforms);
#line 1433
    tmp = compare_read(dp, 0);
#line 1433
    if (! tmp) {
#line 1434
      return;
    }
  }
#line 1442
  dp->operation = (char const   *)"write";
#line 1443
  write_png(dp, dp->original_ip, 0);
#line 1444
  read_png(dp, & dp->written_file, (char const   *)((void *)0), 0);
#line 1445
  tmp___0 = compare_read(dp, 0);
#line 1445
  if (! tmp___0) {
#line 1446
    return;
  }
#line 1457
  active = (unsigned int )dp->active_transforms;
#line 1458
  exhaustive = (dp->options & 16U) != 0U;
#line 1459
  tmp___1 = first_transform((int )active);
#line 1459
  current = (unsigned int )tmp___1;
#line 1460
  bad_transforms = 0U;
#line 1461
  bad_combo = ~ 0U;
#line 1462
  bad_combo_list = 0U;
  {
#line 1464
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1466
    read_png(dp, & dp->original_file, (char const   *)"active transforms", (int )current);
#line 1479
    if ((current & write_transforms) == current) {
#line 1486
      dp->operation = (char const   *)"reversible transforms";
#line 1487
      write_png(dp, dp->read_ip, (int )current);
#line 1492
      read_png(dp, & dp->written_file, (char const   *)((void *)0), 0);
#line 1493
      tmp___3 = compare_read(dp, (int )current);
#line 1493
      if (! tmp___3) {
#line 1500
        tmp___2 = is_combo((int )current);
#line 1500
        if (tmp___2) {
#line 1502
          bad_combo &= current;
#line 1503
          bad_combo_list |= current;
        } else {
#line 1507
          bad_transforms |= current;
        }
      }
    }
#line 1513
    if (exhaustive) {
#line 1515
      next = current;
      {
#line 1517
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1519
        if (next == read_transforms) {
#line 1520
          goto combo;
        }
#line 1522
        next ++;
#line 1517
        if (! ((next & read_transforms) <= current)) {
#line 1517
          if (! ((next & active) == 0U)) {
#line 1517
            if (! ((next & bad_transforms) != 0U)) {
#line 1517
              tmp___4 = skip_transform(dp, (int )next);
#line 1517
              if (! tmp___4) {
#line 1517
                goto while_break___0;
              }
            }
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1531
      __goblint_assert((next & read_transforms) == next);
#line 1532
      current = next;
    } else {
#line 1537
      active &= ~ current;
#line 1539
      if (active == 0U) {
#line 1540
        goto combo;
      }
#line 1542
      tmp___5 = first_transform((int )active);
#line 1542
      current = (unsigned int )tmp___5;
    }
  }
  while_break: /* CIL Label */ ;
  }
  combo:
#line 1547
  if (dp->options & 1024U) {
#line 1553
    if (bad_combo != 4294967295U) {
#line 1554
      printf((char const   *)"%s[0x%x]: PROBLEM: 0x%x[0x%x] ANTIDOTE: 0x%x\n", dp->filename,
             active, bad_combo, bad_combo_list, rw_transforms & ~ bad_combo_list);
    } else {
#line 1559
      if (dp->options & 256U) {
#line 1559
        tmp___6 = "additional ";
      } else {
#line 1559
        tmp___6 = "";
      }
#line 1559
      printf((char const   *)"%s: no %sbad combos found\n", dp->filename, tmp___6);
    }
  }
#line 1563
  return;
}
}
#line 1565 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/pngimage.c"
static int do_test(struct display *dp , char const   *file )
{
  int ret ;
  int tmp ;

  {
#line 1569
  tmp = _setjmp((struct __jmp_buf_tag *)(dp->error_return));
#line 1569
  ret = tmp;
#line 1571
  if (ret == 0) {
#line 1573
    test_one_file___1(dp, file);
#line 1574
    return (0);
  } else
#line 1577
  if (ret < 5) {
#line 1578
    display_log(dp, (error_level )12, (char const   *)"unexpected return code %d",
                ret);
  }
#line 1580
  return (ret);
}
}
#line 394 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static option const   options[23] ;
#line 326 "/usr/include/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) fprintf)(FILE *__stream ,
                                                                                                  char const   *__fmt
                                                                                                  , ...) ;
#line 332
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) printf)(char const   *__fmt
                                                                                                 , ...) ;
#line 334
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) sprintf)(char *__s ,
                                                                                                            char const   *__fmt
                                                                                                            , ...)  __attribute__((__nothrow__)) ;
#line 341
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vfprintf)(FILE *__stream ,
                                                                                                   char const   *__fmt ,
                                                                                                   __gnuc_va_list __ap ) ;
#line 347
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vprintf)(char const   *__fmt ,
                                                                                                  __gnuc_va_list __ap ) ;
#line 349
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vsprintf)(char *__s ,
                                                                                                             char const   *__fmt ,
                                                                                                             __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 354
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) snprintf)(char *__s , size_t __n , char const   *__fmt
                                              , ...)  __attribute__((__nothrow__)) ;
#line 358
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) vsnprintf)(char *__s , size_t __n , char const   *__fmt ,
                                               __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 492
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
#line 528
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
#line 564
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fgets)(char *__s , int __n , FILE *__stream ) ;
#line 646
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fread)(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 101 "/usr/include/stdlib.h"
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 104
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 107
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 112
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__leaf__, __gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__,
__nothrow__)) ;
#line 820
__inline extern void *( __attribute__((__warn_unused_result__, __nonnull__(1,2,5),
__gnu_inline__)) bsearch)(void const   *__key , void const   *__base , size_t __nmemb ,
                          size_t __size , int (*__compar)(void const   * , void const   * ) ) ;
#line 929
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar )  __attribute__((__nothrow__)) ;
#line 933
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t *__dst , char const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 936
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) wcstombs)(char *__dst , wchar_t const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) realpath___19)(char const   * __restrict  __name ,
                                                   char * __restrict  __resolved )  __attribute__((__nothrow__)) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) realpath___19)(char const   * __restrict  __name ,
                                                   char * __restrict  __resolved )
{
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;

  {
#line 39
  tmp___4 = __builtin_object_size((void *)__resolved, 1);
#line 39
  if (tmp___4 != 18446744073709551615UL) {
#line 42
    tmp___1 = __builtin_object_size((void *)__resolved, 1);
#line 42
    if (tmp___1 < 4096UL) {
#line 43
      tmp = __builtin_object_size((void *)__resolved, 1);
#line 43
      tmp___0 = __realpath_chk_warn(__name, __resolved, tmp);
#line 43
      return (tmp___0);
    }
#line 45
    tmp___2 = __builtin_object_size((void *)__resolved, 1);
#line 45
    tmp___3 = __realpath_chk(__name, __resolved, tmp___2);
#line 45
    return (tmp___3);
  }
#line 48
  tmp___5 = __realpath_alias(__name, __resolved);
#line 48
  return (tmp___5);
}
}
#line 43 "/usr/include/string.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memcpy)(void *__dest , void const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 47
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 61
__inline extern void *( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) memset)(void *__dest , int __ch , size_t __len )  __attribute__((__nothrow__)) ;
#line 122
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcpy)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 125
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncpy)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 130
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcat)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 133
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncat)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 360 "/usr/include/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) read)(int __fd , void *__buf , size_t __nbytes ) ;
#line 511
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size )  __attribute__((__nothrow__)) ;
#line 689
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list )  __attribute__((__nothrow__)) ;
#line 774
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                               size_t __buflen )  __attribute__((__nothrow__)) ;
#line 205 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__)) stat)(char const   *__path ,
                                                                                        struct stat *__statbuf )  __attribute__((__nothrow__)) ;
#line 210
__inline extern int ( __attribute__((__nonnull__(2), __leaf__, __gnu_inline__)) fstat)(int __fd ,
                                                                                       struct stat *__statbuf )  __attribute__((__nothrow__)) ;
#line 280
extern int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                              __mode_t __mode )  __attribute__((__nothrow__)) ;
#line 308
extern __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask )  __attribute__((__nothrow__)) ;
#line 317
extern int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                              __mode_t __mode )  __attribute__((__nothrow__)) ;
#line 346
extern int ( __attribute__((__nonnull__(1), __leaf__)) mkfifo)(char const   *__path ,
                                                               __mode_t __mode )  __attribute__((__nothrow__)) ;
#line 395
extern int ( __attribute__((__nonnull__(3), __leaf__)) __fxstat)(int __ver , int __fildes ,
                                                                 struct stat *__stat_buf )  __attribute__((__nothrow__)) ;
#line 397
extern int ( __attribute__((__nonnull__(2,3), __leaf__)) __xstat)(int __ver , char const   *__filename ,
                                                                  struct stat *__stat_buf )  __attribute__((__nothrow__)) ;
#line 399
extern int ( __attribute__((__nonnull__(2,3), __leaf__)) __lxstat)(int __ver , char const   *__filename ,
                                                                   struct stat *__stat_buf )  __attribute__((__nothrow__)) ;
#line 401
extern int ( __attribute__((__nonnull__(3,4), __leaf__)) __fxstatat)(int __ver , int __fildes ,
                                                                     char const   *__filename ,
                                                                     struct stat *__stat_buf ,
                                                                     int __flag )  __attribute__((__nothrow__)) ;
#line 438
extern int ( __attribute__((__nonnull__(2,4), __leaf__)) __xmknod)(int __ver , char const   *__path ,
                                                                   __mode_t __mode ,
                                                                   __dev_t *__dev )  __attribute__((__nothrow__)) ;
#line 441
extern int ( __attribute__((__nonnull__(3,5), __leaf__)) __xmknodat)(int __ver , int __fd ,
                                                                     char const   *__path ,
                                                                     __mode_t __mode ,
                                                                     __dev_t *__dev )  __attribute__((__nothrow__)) ;
#line 452
__inline extern int ( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__)) stat)(char const   *__path ,
                                                                                        struct stat *__statbuf )  __attribute__((__nothrow__)) ;
#line 452 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__)) stat)(char const   *__path ,
                                                                                        struct stat *__statbuf )
{
  int tmp ;

  {
#line 455
  tmp = __xstat(1, __path, __statbuf);
#line 455
  return (tmp);
}
}
#line 466
__inline extern int ( __attribute__((__nonnull__(2), __leaf__, __gnu_inline__)) fstat)(int __fd ,
                                                                                       struct stat *__statbuf )  __attribute__((__nothrow__)) ;
#line 466 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(2), __leaf__, __gnu_inline__)) fstat)(int __fd ,
                                                                                       struct stat *__statbuf )
{
  int tmp ;

  {
#line 469
  tmp = __fxstat(1, __fd, __statbuf);
#line 469
  return (tmp);
}
}
#line 161 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static char const   range_lo[4]  = {      (char const   )'l',      (char const   )'o',      (char const   )'w',      (char const   )'\000'};
#line 162 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static char const   range_hi[5]  = {      (char const   )'h',      (char const   )'i',      (char const   )'g',      (char const   )'h',
        (char const   )'\000'};
#line 163 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static char const   all[4]  = {      (char const   )'a',      (char const   )'l',      (char const   )'l',      (char const   )'\000'};
#line 192 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static value_list const   vl_strategy[6]  = {      {(char const   *)"huffman", 2},
        {(char const   *)"RLE", 3},
        {(char const   *)"fixed", 4},
        {(char const   *)"filtered", 1},
        {(char const   *)"default", 0},
        {all, 0}};
#line 203 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static value_list const   vl_windowBits_text[5]  = {      {(char const   *)"default", 15},
        {(char const   *)"minimum", 8},
        {range_lo, 8},
        {range_hi, 15},
        {all, 0}};
#line 211 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static value_list const   vl_level[8]  =
#line 211
  {      {(char const   *)"default", -1},
        {(char const   *)"none", 0},
        {(char const   *)"speed", 1},
        {(char const   *)"best", 9},
        {(char const   *)"0", 0},
        {range_lo, 1},
        {range_hi, 9},
        {all, 0}};
#line 221 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static value_list const   vl_memLevel[10]  =
#line 221
  {      {(char const   *)"max", 9},
        {(char const   *)"1", 1},
        {(char const   *)"default", 8},
        {(char const   *)"2", 2},
        {(char const   *)"3", 3},
        {(char const   *)"4", 4},
        {(char const   *)"5", 5},
        {range_lo, 6},
        {range_hi, 9},
        {all, 0}};
#line 235 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static value_list const   vl_filter[7]  = {      {all, 248},
        {(char const   *)"off", 0x00},
        {(char const   *)"none", 0x08},
        {(char const   *)"sub", 0x10},
        {(char const   *)"up", 0x20},
        {(char const   *)"avg", 0x40},
        {(char const   *)"paeth", 0x80}};
#line 257 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static value_list const   vl_IDAT_size[4]  = {      {(char const   *)"default", 0x7FFFFFFF},
        {(char const   *)"minimal", 1},
        {range_lo, 1},
        {range_hi, 0x7FFFFFFF}};
#line 268 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static value_list const   vl_log_depth[4]  = {      {(char const   *)"on", 1},
        {(char const   *)"off", 0},
        {range_lo, 0},
        {range_hi, 8}};
#line 269 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static value_list const   vl_on_off[2]  = {      {(char const   *)"on", 1},
        {(char const   *)"off", 0}};
#line 273 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static value_list vl_windowBits_IDAT[5]  = {      {(char const   *)"default", 15},
        {(char const   *)"small", 9},
        {range_lo, 8},
        {range_hi, 15},
        {all, 0}};
#line 291 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static option const   options[23]  =
#line 291
  {      {(char const   *)"verbose", (png_uint_32 )0, (png_byte )0, (png_byte )2, vl_on_off},
        {(char const   *)"warnings",
      (png_uint_32 )2, (png_byte )0, (png_byte )2, vl_on_off},
        {(char const   *)"errors", (png_uint_32 )5, (png_byte )0, (png_byte )2, vl_on_off},
        {(char const   *)"quiet",
      (png_uint_32 )10, (png_byte )0, (png_byte )2, vl_on_off},
        {(char const   *)"strict", (png_uint_32 )0x010, (png_byte )0, (png_byte )2, vl_on_off},
        {(char const   *)"log",
      (png_uint_32 )0x020, (png_byte )0, (png_byte )2, vl_on_off},
        {(char const   *)"continue", (png_uint_32 )0x040, (png_byte )0, (png_byte )2,
      vl_on_off},
        {(char const   *)"sizes", (png_uint_32 )0x080, (png_byte )0, (png_byte )2, vl_on_off},
        {(char const   *)"search",
      (png_uint_32 )0x100, (png_byte )0, (png_byte )2, vl_on_off},
        {(char const   *)"nowrite", (png_uint_32 )0x200, (png_byte )0, (png_byte )2,
      vl_on_off},
        {(char const   *)"ignore-palette-index", (png_uint_32 )0x400, (png_byte )0, (png_byte )2,
      vl_on_off},
        {(char const   *)"fix-palette-index", (png_uint_32 )0x800, (png_byte )0, (png_byte )2,
      vl_on_off},
        {(char const   *)"strategy", 0x80000000, (png_byte )1, (png_byte )(sizeof(vl_strategy) / sizeof(vl_strategy[0])),
      vl_strategy},
        {(char const   *)"text-strategy", 0x80000000, (png_byte )0, (png_byte )(sizeof(vl_strategy) / sizeof(vl_strategy[0])),
      vl_strategy},
        {(char const   *)"windowBits", 0x80000000, (png_byte )1, (png_byte )(sizeof(vl_windowBits_IDAT) / sizeof(vl_windowBits_IDAT[0])),
      (value_list const   *)(vl_windowBits_IDAT)},
        {(char const   *)"text-windowBits", 0x80000000, (png_byte )0, (png_byte )(sizeof(vl_windowBits_text) / sizeof(vl_windowBits_text[0])),
      vl_windowBits_text},
        {(char const   *)"level", 0x80000000, (png_byte )1, (png_byte )(sizeof(vl_level) / sizeof(vl_level[0])),
      vl_level},
        {(char const   *)"text-level", 0x80000000, (png_byte )0, (png_byte )(sizeof(vl_level) / sizeof(vl_level[0])),
      vl_level},
        {(char const   *)"memLevel", 0x80000000, (png_byte )1, (png_byte )(sizeof(vl_memLevel) / sizeof(vl_memLevel[0])),
      vl_memLevel},
        {(char const   *)"text-memLevel", 0x80000000, (png_byte )0, (png_byte )(sizeof(vl_memLevel) / sizeof(vl_memLevel[0])),
      vl_memLevel},
        {(char const   *)"IDAT-size", 0x80000000, (png_byte )0, (png_byte )(sizeof(vl_IDAT_size) / sizeof(vl_IDAT_size[0])),
      vl_IDAT_size},
        {(char const   *)"log-depth", 0x80000000, (png_byte )0, (png_byte )(sizeof(vl_log_depth) / sizeof(vl_log_depth[0])),
      vl_log_depth},
        {(char const   *)"filter", 0x80000001, (png_byte )0, (png_byte )(sizeof(vl_filter) / sizeof(vl_filter[0])),
      vl_filter}};
#line 380 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static char const   *cts(int ct )
{


  {
  {
#line 385
  if (ct == 3) {
#line 385
    goto case_3;
  }
#line 386
  if (ct == 0) {
#line 386
    goto case_0;
  }
#line 387
  if (ct == 4) {
#line 387
    goto case_4;
  }
#line 388
  if (ct == 2) {
#line 388
    goto case_2;
  }
#line 389
  if (ct == 6) {
#line 389
    goto case_6;
  }
#line 390
  goto switch_default;
  case_3: /* CIL Label */
#line 385
  return ((char const   *)"P");
  case_0: /* CIL Label */
#line 386
  return ((char const   *)"G");
  case_4: /* CIL Label */
#line 387
  return ((char const   *)"GA");
  case_2: /* CIL Label */
#line 388
  return ((char const   *)"RGB");
  case_6: /* CIL Label */
#line 389
  return ((char const   *)"RGBA");
  switch_default: /* CIL Label */
#line 390
  return ((char const   *)"INVALID");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 484 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static void display_init___0(struct display___0 *dp )
{


  {
#line 491
  memset((void *)dp, 0, sizeof(*dp));
#line 492
  dp->operation = (char const   *)"internal error";
#line 493
  dp->filename = (char const   *)"command line";
#line 494
  dp->output_file = (char const   *)"no output file";
#line 495
  dp->options = (png_uint_32 )2;
#line 496
  dp->fp = (FILE *)((void *)0);
#line 497
  dp->read_pp = (png_structp )((void *)0);
#line 498
  dp->ip = (png_infop )((void *)0);
#line 499
  dp->write_pp = (png_structp )((void *)0);
#line 500
  dp->min_windowBits = -1;
#line 502
  dp->text_ptr = (png_textp )((void *)0);
#line 503
  dp->num_text = 0;
#line 504
  dp->text_stashed = 0;
#line 506
  return;
}
}
#line 508 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static void display_clean_read___0(struct display___0 *dp , int freeinfo )
{
  png_infop *tmp ;
  FILE *fp ;

  {
#line 511
  if ((unsigned long )dp->read_pp != (unsigned long )((void *)0)) {
#line 512
    if (freeinfo) {
#line 512
      tmp = & dp->ip;
    } else {
#line 512
      tmp = (png_infop *)((void *)0);
    }
#line 512
    png_destroy_read_struct(& dp->read_pp, tmp, (png_infopp )((void *)0));
  }
#line 514
  if ((unsigned long )dp->fp != (unsigned long )((void *)0)) {
#line 516
    fp = dp->fp;
#line 517
    dp->fp = (FILE *)((void *)0);
#line 518
    fclose(fp);
  }
#line 520
  return;
}
}
#line 522 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static void display_clean_write___0(struct display___0 *dp , int freeinfo )
{
  FILE *fp ;
  png_infop *tmp ;

  {
#line 525
  if ((unsigned long )dp->fp != (unsigned long )((void *)0)) {
#line 527
    fp = dp->fp;
#line 528
    dp->fp = (FILE *)((void *)0);
#line 529
    fclose(fp);
  }
#line 532
  if ((unsigned long )dp->write_pp != (unsigned long )((void *)0)) {
#line 533
    if (freeinfo) {
#line 533
      tmp = & dp->ip;
    } else {
#line 533
      tmp = (png_infop *)((void *)0);
    }
#line 533
    png_destroy_write_struct(& dp->write_pp, tmp);
  }
#line 534
  return;
}
}
#line 536 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static void display_clean___0(struct display___0 *dp )
{


  {
#line 539
  display_clean_read___0(dp, 1);
#line 540
  display_clean_write___0(dp, 1);
#line 541
  dp->output_file = (char const   *)((void *)0);
#line 547
  if (dp->text_stashed) {
#line 549
    dp->text_stashed = 0;
#line 550
    dp->num_text = 0;
#line 551
    free((void *)dp->text_ptr);
#line 552
    dp->text_ptr = (png_textp )((void *)0);
  }
#line 557
  dp->results = (png_uint_32 )0;
#line 558
  return;
}
}
#line 560 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static void display_destroy___0(struct display___0 *dp )
{


  {
#line 564
  display_clean___0(dp);
#line 565
  return;
}
}
#line 567 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static struct display___0 *get_dp___0(png_structp pp )
{
  struct display___0 *dp ;
  png_voidp tmp ;

  {
#line 571
  tmp = png_get_error_ptr((png_const_structrp )pp);
#line 571
  dp = (struct display___0 *)tmp;
#line 573
  if ((unsigned long )dp == (unsigned long )((void *)0)) {
#line 575
    fprintf(stderr, (char const   *)"pngcp: internal error (no display)\n");
#line 576
    exit(99);
  }
#line 579
  return (dp);
}
}
#line 591 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static void ( /* format attribute */  display_log___0)(struct display___0 *dp , error_level level ,
                                                       char const   *fmt  , ...)
{
  char const   *lp ;
  va_list ap ;
  char const   *tmp ;

  {
#line 597
  dp->results |= 1U << (unsigned int )level;
#line 599
  if ((unsigned int )level > (unsigned int )((error_level )(dp->options & 15U))) {
    {
#line 606
    if ((unsigned int )level == 1U) {
#line 606
      goto case_1;
    }
#line 607
    if ((unsigned int )level == 3U) {
#line 607
      goto case_3;
    }
#line 608
    if ((unsigned int )level == 4U) {
#line 608
      goto case_4;
    }
#line 609
    if ((unsigned int )level == 6U) {
#line 609
      goto case_6;
    }
#line 610
    if ((unsigned int )level == 7U) {
#line 610
      goto case_7;
    }
#line 611
    if ((unsigned int )level == 8U) {
#line 611
      goto case_8;
    }
#line 612
    if ((unsigned int )level == 9U) {
#line 612
      goto case_9;
    }
#line 613
    if ((unsigned int )level == 11U) {
#line 613
      goto case_11;
    }
#line 617
    goto switch_default;
    case_1: /* CIL Label */
#line 606
    lp = (char const   *)"information";
#line 606
    goto switch_break;
    case_3: /* CIL Label */
#line 607
    lp = (char const   *)"warning(libpng)";
#line 607
    goto switch_break;
    case_4: /* CIL Label */
#line 608
    lp = (char const   *)"warning(pngcp)";
#line 608
    goto switch_break;
    case_6: /* CIL Label */
#line 609
    lp = (char const   *)"error(continuable)";
#line 609
    goto switch_break;
    case_7: /* CIL Label */
#line 610
    lp = (char const   *)"error(libpng)";
#line 610
    goto switch_break;
    case_8: /* CIL Label */
#line 611
    lp = (char const   *)"bug(libpng)";
#line 611
    goto switch_break;
    case_9: /* CIL Label */
#line 612
    lp = (char const   *)"error(pngcp)";
#line 612
    goto switch_break;
    case_11: /* CIL Label */
#line 613
    lp = (char const   *)"error(user)";
#line 613
    goto switch_break;
    switch_default: /* CIL Label */
    case_10: /* CIL Label */
    case_5: /* CIL Label */
    case_2: /* CIL Label */
    case_0: /* CIL Label */
    case_12: /* CIL Label */
#line 617
    lp = (char const   *)"bug(pngcp)";
#line 617
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 620
    if ((unsigned long )dp->filename != (unsigned long )((void *)0)) {
#line 620
      tmp = dp->filename;
    } else {
#line 620
      tmp = (char const   *)"<stdin>";
    }
#line 620
    fprintf(stderr, (char const   *)"%s: %s: %s", tmp, lp, dp->operation);
#line 623
    fprintf(stderr, (char const   *)": ");
#line 625
    __builtin_va_start(ap, fmt);
#line 626
    vfprintf(stderr, fmt, ap);
#line 627
    __builtin_va_end(ap);
#line 629
    fputc('\n', stderr);
  }
#line 634
  if ((unsigned int )level > 6U) {
#line 634
    goto _L;
  } else
#line 634
  if ((unsigned int )level > 5U) {
#line 634
    if (! (dp->options & 64U)) {
      _L: /* CIL Label */
#line 636
      if (dp->errset) {
#line 637
        longjmp((struct __jmp_buf_tag *)(dp->error_return), (int )level);
      } else {
#line 640
        exit(99);
      }
    }
  }
#line 642
  return;
}
}
#line 645 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static void text_stash(struct display___0 *dp )
{
  png_textp chunks ;
  void *tmp ;

  {
#line 666
  chunks = (png_textp )((void *)0);
#line 668
  dp->num_text = png_get_text((png_const_structrp )dp->write_pp, (png_inforp )dp->ip,
                              & chunks, (int *)((void *)0));
#line 670
  if (dp->num_text > 0) {
#line 672
    tmp = malloc((unsigned long )dp->num_text * sizeof(*chunks));
#line 672
    dp->text_ptr = (png_textp )tmp;
#line 674
    if ((unsigned long )dp->text_ptr == (unsigned long )((void *)0)) {
#line 675
      display_log___0(dp, (error_level )9, (char const   *)"text chunks: stash malloc failed");
    } else {
#line 678
      memcpy((void *)dp->text_ptr, (void const   *)chunks, (unsigned long )dp->num_text * sizeof(*chunks));
    }
  }
#line 681
  dp->text_stashed = 1;
#line 682
  return;
}
}
#line 686 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static void text_restore(struct display___0 *dp )
{


  {
#line 690
  if ((unsigned long )dp->text_ptr != (unsigned long )((void *)0)) {
#line 691
    png_set_text((png_const_structrp )dp->write_pp, (png_inforp )dp->ip, (png_const_textp )dp->text_ptr,
                 dp->num_text);
  }
#line 692
  return;
}
}
#line 714 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static png_byte option_index(struct display___0 *dp , char const   *opt , size_t len )
{
  png_byte j ;
  int tmp ;
  int tmp___0 ;

  {
#line 723
  j = (png_byte )0;
  {
#line 723
  while (1) {
    while_continue: /* CIL Label */ ;
#line 723
    if (! ((unsigned long )j < sizeof(options) / sizeof(options[0]))) {
#line 723
      goto while_break;
    }
#line 724
    tmp = strncmp((char const   *)options[j].name, opt, len);
#line 724
    if (tmp == 0) {
#line 724
      if ((int const   )*(options[j].name + len) == 0) {
#line 725
        return (j);
      }
    }
#line 723
    j = (png_byte )((int )j + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 730
  if (dp->errset) {
#line 730
    tmp___0 = 12;
  } else {
#line 730
    tmp___0 = 11;
  }
#line 730
  display_log___0(dp, (error_level )tmp___0, (char const   *)"%.*s: unknown option",
                  (int )len, opt);
#line 732
  abort();
}
}
#line 738 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static int get_option(struct display___0 *dp , char const   *opt , int *value )
{
  png_byte i ;
  size_t tmp ;
  png_byte tmp___0 ;

  {
#line 741
  tmp = strlen(opt);
#line 741
  tmp___0 = option_index(dp, opt, tmp);
#line 741
  i = tmp___0;
#line 743
  if (dp->entry[i]) {
#line 745
    *value = dp->value[i];
#line 746
    return (1);
  } else {
#line 750
    return (0);
  }
}
}
#line 753 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static int set_opt_string_(struct display___0 *dp , unsigned int sp , png_byte opt ,
                           char const   *entry_name )
{
  int offset ;
  int add ;

  {
#line 760
  if (sp > 0U) {
#line 761
    offset = dp->stack[sp - 1U].opt_string_end;
  } else {
#line 764
    offset = dp->opt_string_start;
  }
#line 766
  if ((unsigned long )entry_name == (unsigned long )(range_lo)) {
#line 767
    add = sprintf(dp->curr + offset, (char const   *)" --%s=%d", options[opt].name,
                  dp->value[opt]);
  } else {
#line 771
    add = sprintf(dp->curr + offset, (char const   *)" --%s=%s", options[opt].name,
                  entry_name);
  }
#line 773
  if (add < 0) {
#line 774
    display_log___0(dp, (error_level )12, (char const   *)"sprintf failed");
  }
#line 776
  __goblint_assert(offset + add < (int )sizeof(dp->curr));
#line 777
  return (offset + add);
}
}
#line 780 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static void set_opt_string(struct display___0 *dp , unsigned int sp )
{


  {
#line 784
  dp->stack[sp].opt_string_end = set_opt_string_(dp, sp, dp->stack[sp].opt, (char const   *)(options[dp->stack[sp].opt].values + dp->stack[sp].entry)->name);
#line 786
  return;
}
}
#line 788 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static void record_opt(struct display___0 *dp , png_byte opt , char const   *entry_name )
{
  unsigned int sp ;
  int offset ;
  int tmp ;

  {
#line 795
  sp = dp->csp;
#line 797
  if (sp >= dp->tsp) {
#line 803
    tmp = set_opt_string_(dp, sp, opt, entry_name);
#line 803
    offset = tmp;
#line 805
    if (sp > 0U) {
#line 806
      dp->stack[sp - 1U].opt_string_end = offset;
    } else {
#line 809
      dp->opt_string_start = offset;
    }
  }
#line 813
  return;
}
}
#line 815 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static int opt_list_end(struct display___0 *dp , png_byte opt , png_byte entry )
{
  int tmp ;
  int tmp___0 ;

  {
#line 818
  if ((unsigned long )(options[opt].values + entry)->name == (unsigned long )(range_lo)) {
#line 819
    if ((unsigned int )entry + 1U >= (unsigned int )options[opt].value_count) {
#line 819
      tmp = 1;
    } else
#line 819
    if ((unsigned long )(options[opt].values + ((unsigned int )entry + 1U))->name != (unsigned long )(range_hi)) {
#line 819
      tmp = 1;
    } else
#line 819
    if ((options[opt].values + ((unsigned int )entry + 1U))->value <= (int )dp->value[opt]) {
#line 819
      tmp = 1;
    } else {
#line 819
      tmp = 0;
    }
#line 819
    return (tmp);
  } else {
#line 824
    if ((unsigned int )entry + 1U >= (unsigned int )options[opt].value_count) {
#line 824
      tmp___0 = 1;
    } else
#line 824
    if ((unsigned long )(options[opt].values + ((unsigned int )entry + 1U))->name == (unsigned long )(all)) {
#line 824
      tmp___0 = 1;
    } else {
#line 824
      tmp___0 = 0;
    }
#line 824
    return (tmp___0);
  }
}
}
#line 828 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static void push_opt(struct display___0 *dp , unsigned int sp , png_byte opt , int search )
{
  png_byte entry ;
  char const   *entry_name ;
  int tmp ;
  png_alloc_size_t tmp___0 ;
  png_alloc_size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 838
  if (sp == dp->tsp) {
#line 838
    if (sp < 8U) {
#line 838
      tmp = 1;
    } else {
#line 838
      tmp = 0;
    }
  } else {
#line 838
    tmp = 0;
  }
#line 838
  __goblint_assert(tmp);
#line 843
  entry = (png_byte )options[opt].value_count;
#line 844
  __goblint_assert((unsigned int )entry > 0U);
  {
#line 846
  while (1) {
    while_continue: /* CIL Label */ ;
#line 848
    entry = (png_byte )((int )entry - 1);
#line 848
    entry_name = (char const   *)(options[opt].values + entry)->name;
#line 849
    if ((unsigned long )entry_name == (unsigned long )(range_lo)) {
#line 850
      goto while_break;
    }
#line 846
    if (! ((unsigned int )entry > 0U)) {
#line 846
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 854
  dp->tsp = sp + 1U;
#line 855
  tmp___1 = (png_alloc_size_t )-1;
#line 855
  dp->stack[sp].hi_size = tmp___1;
#line 855
  tmp___0 = tmp___1;
#line 855
  dp->stack[sp].lo_size = tmp___0;
#line 855
  dp->stack[sp].best_size = tmp___0;
#line 859
  if (search) {
#line 859
    if ((unsigned long )entry_name == (unsigned long )(range_lo)) {
#line 861
      dp->stack[sp].lo = (int )(options[opt].values + entry)->value;
#line 863
      if ((int )entry + 1 < (int )options[opt].value_count) {
#line 863
        if ((unsigned long )(options[opt].values + ((int )entry + 1))->name == (unsigned long )(range_hi)) {
#line 863
          tmp___2 = 1;
        } else {
#line 863
          tmp___2 = 0;
        }
      } else {
#line 863
        tmp___2 = 0;
      }
#line 863
      __goblint_assert(tmp___2);
#line 865
      dp->stack[sp].hi = (int )(options[opt].values + ((int )entry + 1))->value;
    } else {
#line 871
      dp->stack[sp].lo = 0x7fffffff;
#line 872
      dp->stack[sp].hi = (-0x7FFFFFFF-1);
    }
  } else {
#line 871
    dp->stack[sp].lo = 0x7fffffff;
#line 872
    dp->stack[sp].hi = (-0x7FFFFFFF-1);
  }
#line 875
  dp->stack[sp].opt = opt;
#line 876
  dp->stack[sp].entry = entry;
#line 877
  tmp___3 = (int )(options[opt].values + entry)->value;
#line 877
  dp->value[opt] = tmp___3;
#line 877
  dp->stack[sp].best_val = tmp___3;
#line 879
  set_opt_string(dp, sp);
#line 884
  tmp___4 = opt_list_end(dp, opt, entry);
#line 884
  if (tmp___4) {
#line 886
    dp->stack[sp].end = (png_byte )1;
#line 890
    if ((int )opt != dp->min_windowBits) {
#line 891
      display_log___0(dp, (error_level )4, (char const   *)"%s: only testing one value",
                      options[opt].name);
    }
  } else {
#line 897
    dp->stack[sp].end = (png_byte )0;
#line 898
    dp->nsp = dp->tsp;
  }
#line 905
  if (! dp->text_stashed) {
#line 905
    text_stash(dp);
  }
#line 906
  return;
}
}
#line 908 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static void next_opt(struct display___0 *dp , unsigned int sp )
{
  int search ;
  png_byte entry ;
  png_byte opt ;
  char const   *entry_name ;
  int tmp ;
  png_alloc_size_t best_size ;
  int lo ;
  int hi ;
  int val ;
  png_alloc_size_t lo_size ;
  png_alloc_size_t hi_size ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 917
  search = 0;
#line 922
  if (sp + 1U == dp->tsp) {
#line 922
    if (! dp->stack[sp].end) {
#line 922
      tmp = 1;
    } else {
#line 922
      tmp = 0;
    }
  } else {
#line 922
    tmp = 0;
  }
#line 922
  __goblint_assert(tmp);
#line 924
  opt = dp->stack[sp].opt;
#line 925
  entry = dp->stack[sp].entry;
#line 926
  __goblint_assert((unsigned int )entry + 1U < (unsigned int )options[opt].value_count);
#line 927
  entry_name = (char const   *)(options[opt].values + entry)->name;
#line 928
  __goblint_assert((unsigned long )entry_name != (unsigned long )((void *)0));
#line 933
  if ((unsigned long )entry_name == (unsigned long )(range_lo)) {
#line 939
    if (dp->stack[sp].lo > dp->stack[sp].hi) {
#line 940
      (dp->value[opt]) ++;
    } else {
#line 945
      best_size = dp->stack[sp].best_size;
#line 946
      lo = dp->stack[sp].lo;
#line 947
      hi = dp->stack[sp].hi;
#line 948
      val = dp->value[opt];
#line 950
      search = 1;
#line 951
      __goblint_assert(best_size < 18446744073709551615UL);
#line 953
      if (val == lo) {
#line 956
        dp->stack[sp].lo_size = best_size;
#line 957
        __goblint_assert(hi > val);
#line 959
        if (hi == val + 1) {
#line 960
          dp->stack[sp].end = (png_byte )1;
        }
#line 962
        val = hi;
      } else
#line 965
      if (val == hi) {
#line 967
        dp->stack[sp].hi_size = best_size;
#line 968
        __goblint_assert(val > lo + 1);
#line 970
        if (val == lo + 2) {
#line 971
          dp->stack[sp].end = (png_byte )1;
        }
#line 973
        val = (lo + val) / 2;
      } else {
#line 978
        lo_size = dp->stack[sp].lo_size;
#line 979
        hi_size = dp->stack[sp].hi_size;
#line 982
        if (lo_size < 18446744073709551615UL) {
#line 982
          if (hi_size < 18446744073709551615UL) {
#line 982
            tmp___0 = 1;
          } else {
#line 982
            tmp___0 = 0;
          }
        } else {
#line 982
          tmp___0 = 0;
        }
#line 982
        __goblint_assert(tmp___0);
#line 987
        if (val < lo) {
#line 990
          dp->stack[sp].lo = val;
#line 991
          dp->stack[sp].lo_size = best_size;
#line 992
          val = lo;
#line 993
          best_size = lo_size;
#line 994
          lo = dp->stack[sp].lo;
#line 995
          lo_size = dp->stack[sp].lo_size;
        } else
#line 998
        if (val > hi) {
#line 1001
          dp->stack[sp].hi = val;
#line 1002
          dp->stack[sp].hi_size = best_size;
#line 1003
          val = hi;
#line 1004
          best_size = hi_size;
#line 1005
          hi = dp->stack[sp].hi;
#line 1006
          hi_size = dp->stack[sp].hi_size;
        }
#line 1010
        if (lo < val) {
#line 1010
          if (val < hi) {
#line 1010
            tmp___1 = 1;
          } else {
#line 1010
            tmp___1 = 0;
          }
        } else {
#line 1010
          tmp___1 = 0;
        }
#line 1010
        __goblint_assert(tmp___1);
#line 1015
        if (hi == lo + 3) {
#line 1020
          if (val == lo + 1) {
#line 1020
            tmp___2 = 2;
          } else {
#line 1020
            tmp___2 = 1;
          }
#line 1020
          val = lo + tmp___2;
#line 1021
          if (lo < val) {
#line 1021
            if (val < hi) {
#line 1021
              tmp___3 = 1;
            } else {
#line 1021
              tmp___3 = 0;
            }
          } else {
#line 1021
            tmp___3 = 0;
          }
#line 1021
          __goblint_assert(tmp___3);
#line 1022
          dp->stack[sp].end = (png_byte )1;
        } else {
#line 1033
          __goblint_assert(hi > lo + 3);
#line 1035
          if (lo_size <= best_size) {
#line 1035
            if (best_size <= hi_size) {
#line 1042
              if (val == lo + 1) {
#line 1044
                val ++;
#line 1045
                dp->stack[sp].end = (png_byte )1;
              } else {
#line 1050
                hi = val;
#line 1050
                dp->stack[sp].hi = hi;
#line 1051
                dp->stack[sp].hi_size = best_size;
#line 1052
                val = (lo + val) / 2;
              }
            } else {
#line 1035
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */
#line 1056
          if (lo_size >= best_size) {
#line 1056
            if (best_size >= hi_size) {
#line 1062
              if (val == hi - 1) {
#line 1064
                val --;
#line 1065
                dp->stack[sp].end = (png_byte )1;
              } else {
#line 1070
                lo = val;
#line 1070
                dp->stack[sp].lo = lo;
#line 1071
                dp->stack[sp].lo_size = best_size;
#line 1072
                val = (val + hi) / 2;
              }
            } else {
#line 1056
              goto _L;
            }
          } else
          _L: /* CIL Label */
#line 1091
          if (lo_size <= hi_size) {
#line 1093
            dp->stack[sp].hi = val;
#line 1094
            dp->stack[sp].hi_size = best_size;
#line 1095
            hi --;
#line 1095
            val = hi;
          } else {
#line 1100
            dp->stack[sp].lo = val;
#line 1101
            dp->stack[sp].lo_size = best_size;
#line 1102
            lo ++;
#line 1102
            val = lo;
          }
#line 1108
          __goblint_assert(hi > lo + 1);
#line 1109
          if (hi <= lo + 2) {
#line 1110
            dp->stack[sp].end = (png_byte )1;
          }
        }
      }
#line 1114
      __goblint_assert(val != dp->stack[sp].best_val);
#line 1115
      dp->value[opt] = val;
#line 1116
      dp->stack[sp].best_size = (png_alloc_size_t )-1;
    }
  } else {
#line 1123
    entry = (png_byte )((int )entry + 1);
#line 1123
    dp->value[opt] = (int )(options[opt].values + entry)->value;
#line 1124
    dp->stack[sp].entry = entry;
  }
#line 1127
  set_opt_string(dp, sp);
#line 1129
  if (! search) {
#line 1129
    tmp___4 = opt_list_end(dp, opt, entry);
#line 1129
    if (tmp___4) {
#line 1130
      dp->stack[sp].end = (png_byte )1;
    } else {
#line 1129
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */
#line 1132
  if (! dp->stack[sp].end) {
#line 1133
    dp->nsp = dp->tsp;
  }
#line 1134
  return;
}
}
#line 1136 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static int compare_option(struct display___0  const  *dp , unsigned int sp )
{
  int opt ;

  {
#line 1139
  opt = (int )dp->stack[sp].opt;
#line 1144
  if (dp->stack[sp].best_val < (int )dp->value[opt]) {
#line 1145
    return (-1);
  } else
#line 1150
  if (dp->stack[sp].best_val > (int )dp->value[opt]) {
#line 1152
    if (dp->stack[sp].lo <= dp->stack[sp].hi) {
#line 1153
      return (1);
    } else {
#line 1156
      return (-1);
    }
  } else {
#line 1160
    return (0);
  }
}
}
#line 1163 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static int advance_opt(struct display___0 *dp , png_byte opt , int search )
{
  unsigned int sp ;
  unsigned int tmp ;
  int ret ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1166
  tmp = dp->csp;
#line 1166
  (dp->csp) ++;
#line 1166
  sp = tmp;
#line 1168
  __goblint_assert(sp >= dp->nsp);
#line 1189
  if (sp >= dp->tsp) {
#line 1191
    push_opt(dp, sp, opt, search);
#line 1192
    return (1);
  } else {
#line 1197
    ret = 0;
#line 1204
    if (dp->write_size > 0UL) {
#line 1204
      if (dp->write_size < 18446744073709551615UL) {
#line 1204
        tmp___0 = 1;
      } else {
#line 1204
        tmp___0 = 0;
      }
    } else {
#line 1204
      tmp___0 = 0;
    }
#line 1204
    __goblint_assert(tmp___0);
#line 1206
    if (dp->stack[sp].best_size > dp->write_size) {
#line 1210
      dp->stack[sp].best_size = dp->write_size;
#line 1211
      dp->stack[sp].best_val = dp->value[opt];
    } else
#line 1206
    if (dp->stack[sp].best_size == dp->write_size) {
#line 1206
      tmp___1 = compare_option((struct display___0  const  *)dp, sp);
#line 1206
      if (tmp___1 > 0) {
#line 1210
        dp->stack[sp].best_size = dp->write_size;
#line 1211
        dp->stack[sp].best_val = dp->value[opt];
      }
    }
#line 1214
    if (sp + 1U >= dp->tsp) {
#line 1216
      next_opt(dp, sp);
#line 1217
      ret = 1;
    } else
#line 1220
    if (! dp->stack[sp].end) {
#line 1221
      dp->nsp = sp + 1U;
    }
#line 1223
    return (ret);
  }
}
}
#line 1227 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static int getallopts_(struct display___0 *dp , png_byte opt , int *value , int record )
{
  char const   *entry_name ;

  {
#line 1232
  if (dp->entry[opt]) {
#line 1238
    entry_name = (char const   *)(options[opt].values + ((int )dp->entry[opt] - 1))->name;
#line 1240
    if ((unsigned long )entry_name == (unsigned long )(all)) {
#line 1241
      advance_opt(dp, opt, 0);
    } else
#line 1243
    if (record) {
#line 1244
      record_opt(dp, opt, entry_name);
    }
#line 1246
    *value = dp->value[opt];
#line 1247
    return (1);
  } else {
#line 1251
    return (0);
  }
}
}
#line 1254 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static int getallopts(struct display___0 *dp , char const   *opt_str , int *value )
{
  size_t tmp ;
  png_byte tmp___0 ;
  int tmp___1 ;

  {
#line 1257
  tmp = strlen(opt_str);
#line 1257
  tmp___0 = option_index(dp, opt_str, tmp);
#line 1257
  tmp___1 = getallopts_(dp, tmp___0, value, 0);
#line 1257
  return (tmp___1);
}
}
#line 1260 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static int getsearchopts(struct display___0 *dp , char const   *opt_str , int *value )
{
  png_byte istrat ;
  png_byte opt ;
  size_t tmp ;
  png_byte tmp___0 ;
  int record ;
  char const   *entry_name ;
  int tmp___1 ;
  png_byte tmp___2 ;
  png_byte tmp___3 ;
  png_byte tmp___4 ;

  {
#line 1265
  tmp = strlen(opt_str);
#line 1265
  tmp___0 = option_index(dp, opt_str, tmp);
#line 1265
  opt = tmp___0;
#line 1266
  record = (int )options[opt].search;
#line 1272
  tmp___1 = getallopts_(dp, opt, value, record);
#line 1272
  if (tmp___1) {
#line 1273
    return (1);
  } else
#line 1275
  if (! record) {
#line 1276
    return (0);
  }
#line 1279
  istrat = option_index(dp, (char const   *)"strategy", sizeof("strategy") - 1UL);
#line 1280
  entry_name = range_lo;
#line 1282
  if ((int )opt == (int )istrat) {
#line 1283
    advance_opt(dp, opt, 0);
#line 1283
    record = 0;
  } else {
#line 1285
    tmp___4 = option_index(dp, (char const   *)"level", sizeof("level") - 1UL);
#line 1285
    if ((int )opt == (int )tmp___4) {
#line 1288
      if (dp->value[istrat] == 3) {
#line 1289
        dp->value[opt] = 1;
      } else
#line 1288
      if (dp->value[istrat] == 2) {
#line 1289
        dp->value[opt] = 1;
      } else {
#line 1292
        advance_opt(dp, opt, 1);
#line 1292
        record = 0;
      }
    } else {
#line 1295
      tmp___3 = option_index(dp, (char const   *)"windowBits", sizeof("windowBits") - 1UL);
#line 1295
      if ((int )opt == (int )tmp___3) {
#line 1302
        if (dp->value[istrat] == 2) {
#line 1303
          dp->value[opt] = 8;
        } else
#line 1305
        if (dp->value[istrat] == 3) {
#line 1306
          dp->value[opt] = 9;
        } else {
#line 1309
          advance_opt(dp, opt, 1);
#line 1309
          record = 0;
        }
      } else {
#line 1312
        tmp___2 = option_index(dp, (char const   *)"memLevel", sizeof("memLevel") - 1UL);
#line 1312
        if ((int )opt == (int )tmp___2) {
#line 1317
          dp->value[opt] = 9;
        } else {
#line 1322
          __goblint_assert((unsigned long )((char *)0) == (unsigned long )"reached");
        }
      }
    }
  }
#line 1324
  if (record) {
#line 1325
    record_opt(dp, opt, entry_name);
  }
#line 1328
  *value = dp->value[opt];
#line 1329
  return (1);
}
}
#line 1332 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static int find_val(struct display___0 *dp , png_byte opt , char const   *str , size_t len )
{
  int rlo ;
  int rhi ;
  png_byte j ;
  png_byte irange ;
  int tmp ;
  char *ep ;
  long l ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 1339
  rlo = 0x7fffffff;
#line 1339
  rhi = (-0x7FFFFFFF-1);
#line 1340
  irange = (png_byte )0;
#line 1342
  j = (png_byte )1U;
  {
#line 1342
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1342
    if (! ((int )j <= (int )options[opt].value_count)) {
#line 1342
      goto while_break;
    }
#line 1344
    tmp = strncmp((char const   *)(options[opt].values + ((unsigned int )j - 1U))->name,
                  str, len);
#line 1344
    if (tmp == 0) {
#line 1344
      if ((int const   )*((options[opt].values + ((unsigned int )j - 1U))->name + len) == 0) {
#line 1347
        dp->entry[opt] = j;
#line 1348
        return ((int )(options[opt].values + ((unsigned int )j - 1U))->value);
      } else {
#line 1344
        goto _L;
      }
    } else
    _L: /* CIL Label */
#line 1350
    if ((unsigned long )(options[opt].values + ((unsigned int )j - 1U))->name == (unsigned long )(range_lo)) {
#line 1351
      rlo = (int )(options[opt].values + ((unsigned int )j - 1U))->value;
#line 1351
      irange = j;
    } else
#line 1352
    if ((unsigned long )(options[opt].values + ((unsigned int )j - 1U))->name == (unsigned long )(range_hi)) {
#line 1353
      rhi = (int )(options[opt].values + ((unsigned int )j - 1U))->value;
    }
#line 1342
    j = (png_byte )((int )j + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 1357
  if ((int )irange > 0) {
#line 1359
    ep = (char *)((void *)0);
#line 1360
    tmp___0 = strtol((char const   * __restrict  )str, (char ** __restrict  )(& ep),
                     0);
#line 1360
    l = tmp___0;
#line 1362
    if ((unsigned long )ep == (unsigned long )(str + len)) {
#line 1362
      if (l >= (long )rlo) {
#line 1362
        if (l <= (long )rhi) {
#line 1364
          dp->entry[opt] = irange;
#line 1365
          return ((int )l);
        }
      }
    }
  }
#line 1369
  if (dp->errset) {
#line 1369
    tmp___1 = 12;
  } else {
#line 1369
    tmp___1 = 11;
  }
#line 1369
  display_log___0(dp, (error_level )tmp___1, (char const   *)"%s: unknown value setting \'%.*s\'",
                  options[opt].name, (int )len, str);
#line 1372
  abort();
}
}
#line 1375 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static int opt_check(struct display___0 *dp , char const   *arg )
{
  int i ;
  int negate ;
  int tmp ;
  int val ;
  png_byte j ;
  char const   *list ;
  size_t tmp___0 ;
  int v ;
  int iv ;

  {
#line 1378
  __goblint_assert(dp->errset == 0U);
#line 1380
  if ((unsigned long )arg != (unsigned long )((void *)0)) {
#line 1380
    if ((int const   )*(arg + 0) == 45) {
#line 1380
      if ((int const   )*(arg + 1) == 45) {
#line 1382
        i = 0;
#line 1382
        tmp = strncmp(arg + 2, (char const   *)"no-", (size_t )3);
#line 1382
        negate = tmp == 0;
#line 1385
        if (negate) {
#line 1386
          arg += 5;
        } else {
#line 1389
          arg += 2;
        }
        {
#line 1392
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1392
          if ((int const   )*(arg + i) != 0) {
#line 1392
            if (! ((int const   )*(arg + i) != 61)) {
#line 1392
              goto while_break;
            }
          } else {
#line 1392
            goto while_break;
          }
#line 1392
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 1397
        j = option_index(dp, arg, (size_t )i);
#line 1400
        if ((int const   )*(arg + i) == 0) {
#line 1402
          val = (int )(options[j].values + negate)->value;
#line 1403
          dp->entry[j] = (png_byte )((unsigned int )negate + 1U);
        } else {
#line 1408
          list = arg + (i + 1);
#line 1413
          if (options[j].opt != 2147483649U) {
#line 1416
            tmp___0 = strlen(list);
#line 1416
            val = find_val(dp, j, list, tmp___0);
#line 1418
            if (negate) {
#line 1420
              if (options[j].opt < 2147483648U) {
#line 1421
                val = ! val;
              } else {
#line 1425
                display_log___0(dp, (error_level )11, (char const   *)"%.*s: option=arg cannot be negated",
                                i, arg);
#line 1427
                abort();
              }
            }
          } else {
#line 1439
            if (negate) {
#line 1440
              val = (int )(options[j].values + 0)->value;
            } else {
#line 1443
              val = 0;
            }
            {
#line 1445
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 1445
              if (! ((int const   )*list != 0)) {
#line 1445
                goto while_break___0;
              }
#line 1452
              iv = 0;
              {
#line 1453
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 1453
                iv ++;
#line 1453
                if ((int const   )*(list + iv) != 0) {
#line 1453
                  if (! ((int const   )*(list + iv) != 44)) {
#line 1453
                    goto while_break___1;
                  }
                } else {
#line 1453
                  goto while_break___1;
                }
              }
              while_break___1: /* CIL Label */ ;
              }
#line 1455
              v = find_val(dp, j, list, (size_t )iv);
#line 1457
              if (negate) {
#line 1458
                val &= ~ v;
              } else {
#line 1461
                val |= v;
              }
#line 1463
              list += iv;
#line 1464
              if ((int const   )*list != 0) {
#line 1465
                list ++;
              }
            }
            while_break___0: /* CIL Label */ ;
            }
          }
        }
#line 1471
        dp->value[j] = val;
#line 1473
        if (options[j].opt < 15U) {
#line 1476
          if (val) {
#line 1477
            dp->options = (dp->options & 4294967280U) | (unsigned int )options[j].opt;
          } else {
#line 1480
            display_log___0(dp, (error_level )11, (char const   *)"%.*s: messages cannot be turned off individually; set a message level",
                            i, arg);
          }
        } else
#line 1485
        if (options[j].opt < 2147483648U) {
#line 1487
          if (val) {
#line 1488
            dp->options |= (unsigned int )options[j].opt;
          } else {
#line 1491
            dp->options &= (unsigned int )(~ options[j].opt);
          }
        }
#line 1494
        return (1);
      } else {
#line 1498
        return (0);
      }
    } else {
#line 1498
      return (0);
    }
  } else {
#line 1498
    return (0);
  }
}
}
#line 1581 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static int checkdir(char const   *pathname )
{
  struct stat buf ;
  int tmp ;
  int tmp___0 ;

  {
#line 1585
  tmp = stat(pathname, & buf);
#line 1585
  if (tmp == 0) {
#line 1585
    if ((buf.st_mode & 61440U) == 16384U) {
#line 1585
      tmp___0 = 1;
    } else {
#line 1585
      tmp___0 = 0;
    }
  } else {
#line 1585
    tmp___0 = 0;
  }
#line 1585
  return (tmp___0);
}
}
#line 1593 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static int isdir(struct display___0 *dp , char const   *pathname )
{
  struct stat buf ;
  int ret ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;

  {
#line 1596
  if ((unsigned long )pathname == (unsigned long )((void *)0)) {
#line 1597
    return (0);
  } else
#line 1599
  if ((int const   )*(pathname + 0) == 0) {
#line 1600
    return (1);
  } else {
#line 1605
    tmp = stat(pathname, & buf);
#line 1605
    ret = tmp;
#line 1607
    if (ret == 0) {
#line 1609
      if ((buf.st_mode & 61440U) == 16384U) {
#line 1610
        return (1);
      }
#line 1613
      tmp___2 = access(pathname, 2);
#line 1613
      if (tmp___2 != 0) {
#line 1614
        tmp___0 = __errno_location();
#line 1614
        tmp___1 = strerror(*tmp___0);
#line 1614
        display_log___0(dp, (error_level )11, (char const   *)"%s: cannot be written (%s)",
                        pathname, tmp___1);
      }
#line 1617
      return (0);
    } else {
#line 1623
      tmp___5 = __errno_location();
#line 1623
      if (*tmp___5 != 2) {
#line 1624
        tmp___3 = __errno_location();
#line 1624
        tmp___4 = strerror(*tmp___3);
#line 1624
        display_log___0(dp, (error_level )11, (char const   *)"%s: invalid output name (%s)",
                        pathname, tmp___4);
      }
#line 1627
      return (0);
    }
  }
}
}
#line 1632 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static void makename(struct display___0 *dp , char const   *dir , char const   *infile )
{
  size_t dsize ;
  size_t tmp ;
  size_t isize ;
  size_t tmp___0 ;
  size_t istart ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 1636
  dp->namebuf[0] = (char)0;
#line 1638
  if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 1639
    display_log___0(dp, (error_level )12, (char const   *)"NULL name to makename");
  } else
#line 1638
  if ((unsigned long )infile == (unsigned long )((void *)0)) {
#line 1639
    display_log___0(dp, (error_level )12, (char const   *)"NULL name to makename");
  } else {
#line 1643
    tmp = strlen(dir);
#line 1643
    dsize = tmp;
#line 1645
    if (dsize <= sizeof(dp->namebuf) - 2UL) {
#line 1647
      tmp___0 = strlen(infile);
#line 1647
      isize = tmp___0;
#line 1648
      istart = isize - 1UL;
#line 1651
      if ((int const   )*(infile + istart) == 47) {
#line 1652
        display_log___0(dp, (error_level )12, (char const   *)"infile with trailing /");
      }
#line 1654
      memcpy((void *)(dp->namebuf), (void const   *)dir, dsize);
#line 1655
      if (dsize > 0UL) {
#line 1655
        if ((int )dp->namebuf[dsize - 1UL] != 47) {
#line 1656
          tmp___1 = dsize;
#line 1656
          dsize ++;
#line 1656
          dp->namebuf[tmp___1] = (char )'/';
        }
      }
      {
#line 1659
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1659
        if (istart > 0UL) {
#line 1659
          if (! ((int const   )*(infile + (istart - 1UL)) != 47)) {
#line 1659
            goto while_break;
          }
        } else {
#line 1659
          goto while_break;
        }
#line 1660
        istart --;
      }
      while_break: /* CIL Label */ ;
      }
#line 1662
      isize -= istart;
#line 1663
      infile += istart;
#line 1665
      if (dsize + isize < sizeof(dp->namebuf)) {
#line 1667
        memcpy((void *)(dp->namebuf + dsize), (void const   *)infile, isize + 1UL);
#line 1669
        tmp___2 = isdir(dp, (char const   *)(dp->namebuf));
#line 1669
        if (tmp___2) {
#line 1670
          display_log___0(dp, (error_level )11, (char const   *)"%s: output file is a directory",
                          dp->namebuf);
        }
      } else {
#line 1676
        dp->namebuf[dsize] = (char)0;
#line 1677
        display_log___0(dp, (error_level )11, (char const   *)"%s%s: output file name too long",
                        dp->namebuf, infile);
      }
    } else {
#line 1683
      display_log___0(dp, (error_level )11, (char const   *)"%s: output directory name too long",
                      dir);
    }
  }
#line 1685
  return;
}
}
#line 1688 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static void display_warning___0(png_structp pp , png_const_charp warning___0 )
{
  struct display___0 *dp ;
  struct display___0 *tmp ;
  struct display___0 *tmp___0 ;

  {
#line 1691
  tmp = get_dp___0(pp);
#line 1691
  dp = tmp;
#line 1694
  if (! dp->no_warnings) {
#line 1695
    tmp___0 = get_dp___0(pp);
#line 1695
    display_log___0(tmp___0, (error_level )3, (char const   *)"%s", warning___0);
  }
#line 1696
  return;
}
}
#line 1698 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static void display_error___0(png_structp pp , png_const_charp error___0 )
{
  struct display___0 *dp ;
  struct display___0 *tmp ;

  {
#line 1701
  tmp = get_dp___0(pp);
#line 1701
  dp = tmp;
#line 1703
  display_log___0(dp, (error_level )7, (char const   *)"%s", error___0);
#line 1704
  return;
}
}
#line 1706 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static void display_start_read(struct display___0 *dp , char const   *filename )
{
  png_uint_32 tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 1709
  if ((unsigned long )filename != (unsigned long )((void *)0)) {
#line 1711
    dp->filename = filename;
#line 1712
    dp->fp = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"rb");
  } else {
#line 1717
    dp->filename = (char const   *)"<stdin>";
#line 1718
    dp->fp = stdin;
  }
#line 1721
  tmp = 0U;
#line 1721
  dp->h = tmp;
#line 1721
  dp->w = tmp;
#line 1722
  dp->bpp = 0;
#line 1723
  dp->size = (png_alloc_size_t )0U;
#line 1724
  dp->read_size = (png_alloc_size_t )0U;
#line 1726
  if ((unsigned long )dp->fp == (unsigned long )((void *)0)) {
#line 1727
    tmp___0 = __errno_location();
#line 1727
    tmp___1 = strerror(*tmp___0);
#line 1727
    display_log___0(dp, (error_level )11, (char const   *)"file open failed (%s)",
                    tmp___1);
  }
#line 1728
  return;
}
}
#line 1730 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static void read_function___0(png_structp pp , png_bytep data , size_t size )
{
  struct display___0 *dp ;
  struct display___0 *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 1733
  tmp = get_dp___0(pp);
#line 1733
  dp = tmp;
#line 1735
  if (size == 0UL) {
#line 1736
    dp->read_size += size;
  } else {
#line 1735
    tmp___3 = fread((void *)data, size, (size_t )1U, dp->fp);
#line 1735
    if (tmp___3 == 1UL) {
#line 1736
      dp->read_size += size;
    } else {
#line 1740
      tmp___2 = feof(dp->fp);
#line 1740
      if (tmp___2) {
#line 1741
        display_log___0(dp, (error_level )7, (char const   *)"PNG file truncated");
      } else {
#line 1743
        tmp___0 = __errno_location();
#line 1743
        tmp___1 = strerror(*tmp___0);
#line 1743
        display_log___0(dp, (error_level )7, (char const   *)"PNG file read failed (%s)",
                        tmp___1);
      }
    }
  }
#line 1746
  return;
}
}
#line 1748 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static void read_png___0(struct display___0 *dp , char const   *filename )
{
  png_structp __attribute__((__malloc__))  tmp ;
  png_infop __attribute__((__malloc__))  tmp___0 ;
  png_byte tmp___1 ;
  png_byte tmp___2 ;
  png_alloc_size_t rb ;
  size_t tmp___3 ;
  int max ;
  int tmp___4 ;
  png_colorp palette ;
  int num ;
  png_uint_32 tmp___5 ;
  int i ;
  png_color newpal[256] ;

  {
#line 1756
  if ((unsigned long )dp->read_pp != (unsigned long )((void *)0)) {
#line 1758
    display_log___0(dp, (error_level )6, (char const   *)"unexpected png_read_struct");
#line 1759
    display_clean_read___0(dp, 1);
  }
#line 1762
  display_start_read(dp, filename);
#line 1764
  tmp = png_create_read_struct((png_const_charp )"1.6.39", (png_voidp )dp, & display_error___0,
                               & display_warning___0);
#line 1764
  dp->read_pp = (png_structp )tmp;
#line 1766
  if ((unsigned long )dp->read_pp == (unsigned long )((void *)0)) {
#line 1767
    display_log___0(dp, (error_level )7, (char const   *)"failed to create read struct");
  }
#line 1770
  png_set_benign_errors((png_structrp )dp->read_pp, 1);
#line 1774
  if ((dp->options & 2048U) != 0U) {
#line 1775
    png_set_check_for_invalid_index((png_structrp )dp->read_pp, 1);
  } else
#line 1781
  if ((dp->options & 1024U) != 0U) {
#line 1782
    png_set_check_for_invalid_index((png_structrp )dp->read_pp, -1);
  }
#line 1785
  if ((unsigned long )dp->ip != (unsigned long )((void *)0)) {
#line 1788
    display_log___0(dp, (error_level )6, (char const   *)"read_png: freeing old info struct");
#line 1789
    png_destroy_info_struct((png_const_structrp )dp->read_pp, & dp->ip);
  }
#line 1795
  tmp___0 = png_create_info_struct((png_const_structrp )dp->read_pp);
#line 1795
  dp->ip = (png_infop )tmp___0;
#line 1796
  if ((unsigned long )dp->ip == (unsigned long )((void *)0)) {
#line 1797
    png_error((png_const_structrp )dp->read_pp, (png_const_charp )"failed to create info struct");
  }
#line 1800
  png_set_read_fn((png_structrp )dp->read_pp, (png_voidp )dp, & read_function___0);
#line 1803
  png_set_keep_unknown_chunks((png_structrp )dp->read_pp, 3, (png_const_bytep )((void *)0),
                              0);
#line 1809
  png_set_user_limits((png_structrp )dp->read_pp, (png_uint_32 )0x7fffffff, (png_uint_32 )0x7fffffff);
#line 1814
  png_read_png((png_structrp )dp->read_pp, (png_inforp )dp->ip, 0, (void *)0);
#line 1816
  dp->w = png_get_image_width((png_const_structrp )dp->read_pp, (png_const_inforp )dp->ip);
#line 1817
  dp->h = png_get_image_height((png_const_structrp )dp->read_pp, (png_const_inforp )dp->ip);
#line 1818
  dp->ct = png_get_color_type((png_const_structrp )dp->read_pp, (png_const_inforp )dp->ip);
#line 1819
  tmp___1 = png_get_bit_depth((png_const_structrp )dp->read_pp, (png_const_inforp )dp->ip);
#line 1819
  tmp___2 = png_get_channels((png_const_structrp )dp->read_pp, (png_const_inforp )dp->ip);
#line 1819
  dp->bpp = (int )tmp___1 * (int )tmp___2;
#line 1826
  tmp___3 = png_get_rowbytes((png_const_structrp )dp->read_pp, (png_const_inforp )dp->ip);
#line 1826
  rb = tmp___3;
#line 1828
  if (rb == 0UL) {
#line 1829
    png_error((png_const_structrp )dp->read_pp, (png_const_charp )"invalid row byte count from libpng");
  }
#line 1832
  if ((18446744073709551615UL - (png_alloc_size_t )dp->h) / rb < (png_alloc_size_t )dp->h) {
#line 1833
    png_error((png_const_structrp )dp->read_pp, (png_const_charp )"image too large");
  }
#line 1835
  dp->size = rb * (png_alloc_size_t )dp->h + (png_alloc_size_t )dp->h;
#line 1839
  if ((int )dp->ct == 3) {
#line 1839
    if ((dp->options & 2048U) != 0U) {
#line 1841
      tmp___4 = png_get_palette_max((png_const_structp )dp->read_pp, (png_const_infop )dp->ip);
#line 1841
      max = tmp___4;
#line 1842
      palette = (png_colorp )((void *)0);
#line 1843
      num = -1;
#line 1845
      tmp___5 = png_get_PLTE((png_const_structrp )dp->read_pp, (png_inforp )dp->ip,
                             & palette, & num);
#line 1845
      if (tmp___5 != 0x0008U) {
#line 1847
        display_log___0(dp, (error_level )7, (char const   *)"invalid png_get_PLTE result");
      } else
#line 1845
      if (max < 0) {
#line 1847
        display_log___0(dp, (error_level )7, (char const   *)"invalid png_get_PLTE result");
      } else
#line 1845
      if (num <= 0) {
#line 1847
        display_log___0(dp, (error_level )7, (char const   *)"invalid png_get_PLTE result");
      } else
#line 1845
      if ((unsigned long )palette == (unsigned long )((void *)0)) {
#line 1847
        display_log___0(dp, (error_level )7, (char const   *)"invalid png_get_PLTE result");
      }
#line 1849
      if (max >= num) {
#line 1855
        i = 0;
        {
#line 1855
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1855
          if (! (i < num)) {
#line 1855
            goto while_break;
          }
#line 1856
          newpal[i] = *(palette + i);
#line 1855
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 1859
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1859
          if (! (i <= max)) {
#line 1859
            goto while_break___0;
          }
#line 1861
          newpal[i].red = (png_byte )0xbe;
#line 1862
          newpal[i].green = (png_byte )0xad;
#line 1863
          newpal[i].blue = (png_byte )0xed;
#line 1859
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1866
        png_set_PLTE((png_structrp )dp->read_pp, (png_inforp )dp->ip, (png_const_colorp )(newpal),
                     i);
      }
    }
  }
#line 1878
  display_clean_read___0(dp, 0);
#line 1879
  dp->operation = (char const   *)"none";
#line 1880
  return;
}
}
#line 1882 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static void display_start_write(struct display___0 *dp , char const   *filename )
{
  int *tmp ;
  char *tmp___0 ;

  {
#line 1885
  __goblint_assert((unsigned long )dp->fp == (unsigned long )((void *)0));
#line 1887
  if ((dp->options & 512U) != 0U) {
#line 1888
    dp->output_file = (char const   *)"<no write>";
  } else {
#line 1892
    if ((unsigned long )filename != (unsigned long )((void *)0)) {
#line 1894
      dp->output_file = filename;
#line 1895
      dp->fp = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"wb");
    } else {
#line 1900
      dp->output_file = (char const   *)"<stdout>";
#line 1901
      dp->fp = stdout;
    }
#line 1904
    if ((unsigned long )dp->fp == (unsigned long )((void *)0)) {
#line 1905
      tmp = __errno_location();
#line 1905
      tmp___0 = strerror(*tmp);
#line 1905
      display_log___0(dp, (error_level )11, (char const   *)"%s: file open failed (%s)",
                      dp->output_file, tmp___0);
    }
  }
#line 1908
  return;
}
}
#line 1910 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static void write_function___0(png_structp pp , png_bytep data , size_t size )
{
  struct display___0 *dp ;
  struct display___0 *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;

  {
#line 1913
  tmp = get_dp___0(pp);
#line 1913
  dp = tmp;
#line 1918
  if ((unsigned long )dp->fp == (unsigned long )((void *)0)) {
#line 1918
    goto _L;
  } else {
#line 1918
    tmp___2 = fwrite((void const   * __restrict  )data, size, (size_t )1U, (FILE * __restrict  )dp->fp);
#line 1918
    if (tmp___2 == 1UL) {
      _L: /* CIL Label */
#line 1920
      dp->write_size += size;
#line 1921
      if (dp->write_size < size) {
#line 1922
        png_error((png_const_structrp )pp, (png_const_charp )"IDAT size overflow");
      } else
#line 1921
      if (dp->write_size == 18446744073709551615UL) {
#line 1922
        png_error((png_const_structrp )pp, (png_const_charp )"IDAT size overflow");
      }
    } else {
#line 1926
      tmp___0 = __errno_location();
#line 1926
      tmp___1 = strerror(*tmp___0);
#line 1926
      display_log___0(dp, (error_level )11, (char const   *)"%s: PNG file write failed (%s)",
                      dp->output_file, tmp___1);
    }
  }
#line 1928
  return;
}
}
#line 1944 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static void search_compression(struct display___0 *dp )
{
  int val ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1952
  tmp = getsearchopts(dp, (char const   *)"strategy", & val);
#line 1952
  if (tmp) {
#line 1952
    png_set_compression_strategy((png_structrp )dp->write_pp, val);
  }
#line 1952
  tmp___0 = getsearchopts(dp, (char const   *)"windowBits", & val);
#line 1952
  if (tmp___0) {
#line 1952
    png_set_compression_window_bits((png_structrp )dp->write_pp, val);
  }
#line 1952
  tmp___1 = getsearchopts(dp, (char const   *)"level", & val);
#line 1952
  if (tmp___1) {
#line 1952
    png_set_compression_level((png_structrp )dp->write_pp, val);
  }
#line 1952
  tmp___2 = getsearchopts(dp, (char const   *)"memLevel", & val);
#line 1952
  if (tmp___2) {
#line 1952
    png_set_compression_mem_level((png_structrp )dp->write_pp, val);
  }
#line 1954
  return;
}
}
#line 1956 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static void set_compression(struct display___0 *dp )
{
  int val ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1963
  tmp = getallopts(dp, (char const   *)"strategy", & val);
#line 1963
  if (tmp) {
#line 1963
    png_set_compression_strategy((png_structrp )dp->write_pp, val);
  }
#line 1963
  tmp___0 = getallopts(dp, (char const   *)"windowBits", & val);
#line 1963
  if (tmp___0) {
#line 1963
    png_set_compression_window_bits((png_structrp )dp->write_pp, val);
  }
#line 1963
  tmp___1 = getallopts(dp, (char const   *)"level", & val);
#line 1963
  if (tmp___1) {
#line 1963
    png_set_compression_level((png_structrp )dp->write_pp, val);
  }
#line 1963
  tmp___2 = getallopts(dp, (char const   *)"memLevel", & val);
#line 1963
  if (tmp___2) {
#line 1963
    png_set_compression_mem_level((png_structrp )dp->write_pp, val);
  }
#line 1965
  return;
}
}
#line 1988 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static void set_text_compression(struct display___0 *dp )
{
  int val ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1995
  tmp = getallopts(dp, (char const   *)"text-strategy", & val);
#line 1995
  if (tmp) {
#line 1995
    png_set_text_compression_strategy((png_structrp )dp->write_pp, val);
  }
#line 1995
  tmp___0 = getallopts(dp, (char const   *)"text-windowBits", & val);
#line 1995
  if (tmp___0) {
#line 1995
    png_set_text_compression_window_bits((png_structrp )dp->write_pp, val);
  }
#line 1995
  tmp___1 = getallopts(dp, (char const   *)"text-level", & val);
#line 1995
  if (tmp___1) {
#line 1995
    png_set_text_compression_level((png_structrp )dp->write_pp, val);
  }
#line 1995
  tmp___2 = getallopts(dp, (char const   *)"text-memLevel", & val);
#line 1995
  if (tmp___2) {
#line 1995
    png_set_text_compression_mem_level((png_structrp )dp->write_pp, val);
  }
#line 1997
  return;
}
}
#line 2002 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static void write_png___0(struct display___0 *dp , char const   *destname )
{
  png_structp __attribute__((__malloc__))  tmp ;
  unsigned int tmp___0 ;
  int val ;
  int tmp___1 ;
  int val___0 ;
  int tmp___2 ;
  FILE *fp ;
  int *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;

  {
#line 2008
  if ((unsigned long )dp->ip == (unsigned long )((void *)0)) {
#line 2009
    display_log___0(dp, (error_level )12, (char const   *)"missing png_info");
  }
#line 2014
  if ((unsigned long )dp->write_pp != (unsigned long )((void *)0)) {
#line 2016
    display_log___0(dp, (error_level )6, (char const   *)"unexpected png_write_struct");
#line 2017
    display_clean_write___0(dp, 0);
  }
#line 2020
  display_start_write(dp, destname);
#line 2022
  tmp = png_create_write_struct((png_const_charp )"1.6.39", (png_voidp )dp, & display_error___0,
                                & display_warning___0);
#line 2022
  dp->write_pp = (png_structp )tmp;
#line 2025
  if ((unsigned long )dp->write_pp == (unsigned long )((void *)0)) {
#line 2026
    display_log___0(dp, (error_level )7, (char const   *)"failed to create write png_struct");
  }
#line 2029
  png_set_benign_errors((png_structrp )dp->write_pp, 1);
#line 2032
  png_set_write_fn((png_structrp )dp->write_pp, (png_voidp )dp, & write_function___0,
                   (void (*)(png_structp  ))((void *)0));
#line 2035
  if ((dp->options & 1024U) != 0U) {
#line 2036
    png_set_check_for_invalid_index((png_structrp )dp->write_pp, -1);
  }
#line 2043
  if (dp->text_stashed) {
#line 2043
    text_restore(dp);
  }
#line 2046
  png_set_keep_unknown_chunks((png_structrp )dp->write_pp, 3, (png_const_bytep )((void *)0),
                              0);
#line 2052
  png_set_user_limits((png_structrp )dp->write_pp, (png_uint_32 )0x7fffffff, (png_uint_32 )0x7fffffff);
#line 2057
  dp->tsp = dp->nsp;
#line 2058
  tmp___0 = 0U;
#line 2058
  dp->csp = tmp___0;
#line 2058
  dp->nsp = tmp___0;
#line 2076
  if (dp->options & 256U) {
#line 2077
    search_compression(dp);
  } else {
#line 2079
    set_compression(dp);
  }
#line 2081
  set_text_compression(dp);
#line 2087
  tmp___1 = get_option(dp, (char const   *)"IDAT-size", & val);
#line 2087
  if (tmp___1) {
#line 2088
    png_set_compression_buffer_size((png_structrp )dp->write_pp, (size_t )val);
  }
#line 2096
  tmp___2 = get_option(dp, (char const   *)"filter", & val___0);
#line 2096
  if (tmp___2) {
#line 2097
    png_set_filter((png_structrp )dp->write_pp, 0, val___0);
  }
#line 2102
  dp->write_size = (png_alloc_size_t )0U;
#line 2104
  png_write_png((png_structrp )dp->write_pp, (png_inforp )dp->ip, 0, (void *)0);
#line 2108
  if ((unsigned long )dp->fp != (unsigned long )((void *)0)) {
#line 2110
    fp = dp->fp;
#line 2111
    dp->fp = (FILE *)((void *)0);
#line 2112
    tmp___6 = fclose(fp);
#line 2112
    if (tmp___6) {
#line 2113
      tmp___3 = __errno_location();
#line 2113
      tmp___4 = strerror(*tmp___3);
#line 2113
      if ((unsigned long )destname == (unsigned long )((void *)0)) {
#line 2113
        tmp___5 = (char const   *)"stdout";
      } else {
#line 2113
        tmp___5 = destname;
      }
#line 2113
      display_log___0(dp, (error_level )9, (char const   *)"%s: write failed (%s)",
                      tmp___5, tmp___4);
    }
  }
#line 2117
  dp->operation = (char const   *)"none";
#line 2118
  return;
}
}
#line 2120 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static void set_windowBits_hi(struct display___0 *dp )
{
  int wb ;
  int i ;
  png_byte tmp ;

  {
#line 2126
  wb = 15;
#line 2127
  i = (int )(sizeof(vl_windowBits_IDAT) / sizeof(vl_windowBits_IDAT[0]));
  {
#line 2129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2129
    if (wb > 8) {
#line 2129
      if (! (dp->size <= (png_alloc_size_t )(1U << (wb - 1)))) {
#line 2129
        goto while_break;
      }
    } else {
#line 2129
      goto while_break;
    }
#line 2129
    wb --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2131
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2131
    i --;
#line 2131
    if (! (i >= 0)) {
#line 2131
      goto while_break___0;
    }
#line 2131
    if ((unsigned long )vl_windowBits_IDAT[i].name == (unsigned long )(range_hi)) {
#line 2131
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2133
  __goblint_assert(i > 1);
#line 2134
  vl_windowBits_IDAT[i].value = wb;
#line 2136
  i --;
#line 2136
  __goblint_assert((unsigned long )vl_windowBits_IDAT[i].name == (unsigned long )(range_lo));
#line 2137
  if (wb > 8) {
#line 2137
    vl_windowBits_IDAT[i].value = 9;
  } else {
#line 2137
    vl_windowBits_IDAT[i].value = 8;
  }
#line 2143
  if (wb == 8) {
#line 2144
    tmp = option_index(dp, (char const   *)"windowBits", sizeof("windowBits") - 1UL);
#line 2144
    dp->min_windowBits = (int )tmp;
  }
#line 2145
  return;
}
}
#line 2147 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static int better_options(struct display___0  const  *dp )
{
  unsigned int sp ;
  int c ;
  int tmp ;
  int tmp___0 ;

  {
#line 2166
  sp = 0U;
  {
#line 2166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2166
    if (! (sp < (unsigned int )dp->csp)) {
#line 2166
      goto while_break;
    }
#line 2168
    tmp = compare_option(dp, sp);
#line 2168
    c = tmp;
#line 2170
    if (c < 0) {
#line 2171
      return (0);
    } else
#line 2173
    if (c > 0) {
#line 2174
      return (1);
    }
#line 2166
    sp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2177
  if (0) {
#line 2177
    if ("unreached") {
#line 2177
      tmp___0 = 1;
    } else {
#line 2177
      tmp___0 = 0;
    }
  } else {
#line 2177
    tmp___0 = 0;
  }
#line 2177
  __goblint_assert(tmp___0);
#line 2178
  return (0);
}
}
#line 2180 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static void print_search_results(struct display___0 *dp )
{
  char const   *tmp ;

  {
#line 2183
  __goblint_assert((unsigned long )dp->filename != (unsigned long )((void *)0));
#line 2184
  tmp = cts((int )dp->ct);
#line 2184
  printf((char const   *)"%s [%ld x %ld %d bpp %s, %lu bytes] %lu -> %lu with \'%s\'\n",
         dp->filename, (unsigned long )dp->w, (unsigned long )dp->h, dp->bpp, tmp,
         dp->size, dp->read_size, dp->best_size, dp->best);
#line 2188
  fflush(stdout);
#line 2189
  return;
}
}
#line 2191 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static void log_search(struct display___0 *dp , unsigned int log_depth )
{


  {
#line 2195
  if (dp->nsp <= log_depth) {
#line 2197
    print_search_results(dp);
#line 2199
    dp->best_size = (png_alloc_size_t )-1;
  }
#line 2201
  return;
}
}
#line 2203 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static void cp_one_file(struct display___0 *dp , char const   *filename , char const   *destname )
{
  unsigned int log_depth ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int val ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  char *tmpname ;
  char tmpbuf[sizeof(dp->namebuf) + 4UL] ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
#line 2208
  dp->filename = filename;
#line 2209
  dp->operation = (char const   *)"read";
#line 2210
  dp->no_warnings = 0;
#line 2213
  if ((unsigned long )filename != (unsigned long )((void *)0)) {
#line 2213
    tmp___1 = access(filename, 4);
#line 2213
    if (tmp___1 != 0) {
#line 2214
      tmp = __errno_location();
#line 2214
      tmp___0 = strerror(*tmp);
#line 2214
      display_log___0(dp, (error_level )11, (char const   *)"%s: invalid file name (%s)",
                      filename, tmp___0);
    }
  }
#line 2217
  read_png___0(dp, filename);
#line 2220
  dp->operation = (char const   *)"write";
#line 2223
  set_windowBits_hi(dp);
#line 2229
  tmp___2 = get_option(dp, (char const   *)"log-depth", & val);
#line 2229
  if (tmp___2) {
#line 2229
    if (val >= 0) {
#line 2230
      log_depth = (unsigned int )val;
    } else {
#line 2233
      log_depth = 0U;
    }
  } else {
#line 2233
    log_depth = 0U;
  }
#line 2236
  if ((unsigned long )destname != (unsigned long )((void *)0)) {
#line 2238
    tmp___7 = isdir(dp, destname);
#line 2238
    if (tmp___7) {
#line 2240
      makename(dp, destname, filename);
#line 2241
      destname = (char const   *)(dp->namebuf);
    } else {
#line 2244
      tmp___5 = access(destname, 2);
#line 2244
      if (tmp___5 != 0) {
#line 2244
        tmp___6 = __errno_location();
#line 2244
        if (*tmp___6 != 2) {
#line 2245
          tmp___3 = __errno_location();
#line 2245
          tmp___4 = strerror(*tmp___3);
#line 2245
          display_log___0(dp, (error_level )11, (char const   *)"%s: invalid output name (%s)",
                          destname, tmp___4);
        }
      }
    }
  }
#line 2249
  dp->nsp = 0U;
#line 2250
  dp->curr[0] = (char)0;
#line 2251
  dp->opt_string_start = 0;
#line 2252
  dp->best[0] = (char)0;
#line 2253
  dp->best_size = (png_alloc_size_t )-1;
#line 2254
  write_png___0(dp, destname);
#line 2257
  strcpy(dp->best, (char const   *)(dp->curr));
#line 2258
  dp->best_size = dp->write_size;
#line 2260
  if (dp->nsp > 0U) {
#line 2263
    if ((int )dp->curr[0] == 32) {
#line 2263
      if (dp->tsp > 0U) {
#line 2263
        tmp___8 = 1;
      } else {
#line 2263
        tmp___8 = 0;
      }
    } else {
#line 2263
      tmp___8 = 0;
    }
#line 2263
    __goblint_assert(tmp___8);
#line 2266
    log_search(dp, log_depth);
#line 2267
    dp->no_warnings = 1;
#line 2270
    if ((unsigned long )destname != (unsigned long )((void *)0)) {
#line 2272
      strcpy(tmpbuf, destname);
#line 2273
      strcat(tmpbuf, (char const   *)".tmp");
#line 2274
      tmpname = tmpbuf;
    } else {
#line 2278
      tmpname = (char *)((void *)0);
    }
    {
#line 2281
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2286
      display_clean_write___0(dp, 0);
#line 2287
      write_png___0(dp, (char const   *)tmpname);
#line 2292
      __goblint_assert(dp->csp > 0U);
#line 2294
      if (dp->write_size < dp->best_size) {
#line 2294
        goto _L;
      } else
#line 2294
      if (dp->write_size == dp->best_size) {
#line 2294
        tmp___15 = better_options((struct display___0  const  *)dp);
#line 2294
        if (tmp___15) {
          _L: /* CIL Label */
#line 2297
          if ((unsigned long )destname != (unsigned long )((void *)0)) {
#line 2297
            tmp___11 = rename((char const   *)tmpname, destname);
#line 2297
            if (tmp___11 != 0) {
#line 2298
              tmp___9 = __errno_location();
#line 2298
              tmp___10 = strerror(*tmp___9);
#line 2298
              display_log___0(dp, (error_level )9, (char const   *)"rename %s %s failed (%s)",
                              tmpname, destname, tmp___10);
            }
          }
#line 2301
          strcpy(dp->best, (char const   *)(dp->curr));
#line 2302
          dp->best_size = dp->write_size;
        } else {
#line 2294
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */
#line 2305
      if ((unsigned long )tmpname != (unsigned long )((void *)0)) {
#line 2305
        tmp___14 = unlink((char const   *)tmpname);
#line 2305
        if (tmp___14 != 0) {
#line 2306
          tmp___12 = __errno_location();
#line 2306
          tmp___13 = strerror(*tmp___12);
#line 2306
          display_log___0(dp, (error_level )4, (char const   *)"unlink %s failed (%s)",
                          tmpname, tmp___13);
        }
      }
#line 2309
      log_search(dp, log_depth);
#line 2281
      if (! (dp->nsp > 0U)) {
#line 2281
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 2314
    dp->write_size = dp->best_size;
  }
#line 2317
  display_clean_write___0(dp, 1);
#line 2318
  return;
}
}
#line 2320 "/home/goblint2/bench/libpng-1.6.39/contrib/tools/pngcp.c"
static int cppng(struct display___0 *dp , char const   *file , char const   * volatile  dest )
{
  int ret ;
  int tmp ;

  {
#line 2326
  tmp = _setjmp((struct __jmp_buf_tag *)(dp->error_return));
#line 2326
  ret = tmp;
#line 2328
  if (ret == 0) {
#line 2330
    dp->errset = 1U;
#line 2331
    cp_one_file(dp, file, (char const   *)dest);
#line 2332
    dp->errset = 0U;
#line 2333
    return (0);
  } else {
#line 2338
    dp->errset = 0U;
#line 2340
    if (ret < 5) {
#line 2341
      display_log___0(dp, (error_level )12, (char const   *)"unexpected return code %d",
                      ret);
    }
#line 2343
    return (ret);
  }
}
}
#line 101 "/usr/include/stdlib.h"
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 104
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 107
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__, __nothrow__)) ;
#line 112
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__leaf__, __gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__,
__nothrow__)) ;
#line 820
__inline extern void *( __attribute__((__warn_unused_result__, __nonnull__(1,2,5),
__gnu_inline__)) bsearch)(void const   *__key , void const   *__base , size_t __nmemb ,
                          size_t __size , int (*__compar)(void const   * , void const   * ) ) ;
#line 929
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar )  __attribute__((__nothrow__)) ;
#line 933
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t *__dst , char const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 936
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) wcstombs)(char *__dst , wchar_t const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 326 "/usr/include/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) fprintf)(FILE *__stream ,
                                                                                                  char const   *__fmt
                                                                                                  , ...) ;
#line 332
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) printf)(char const   *__fmt
                                                                                                 , ...) ;
#line 334
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) sprintf)(char *__s ,
                                                                                                            char const   *__fmt
                                                                                                            , ...)  __attribute__((__nothrow__)) ;
#line 341
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vfprintf)(FILE *__stream ,
                                                                                                   char const   *__fmt ,
                                                                                                   __gnuc_va_list __ap ) ;
#line 347
__inline extern int ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) vprintf)(char const   *__fmt ,
                                                                                                  __gnuc_va_list __ap ) ;
#line 349
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) vsprintf)(char *__s ,
                                                                                                             char const   *__fmt ,
                                                                                                             __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 354
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) snprintf)(char *__s , size_t __n , char const   *__fmt
                                              , ...)  __attribute__((__nothrow__)) ;
#line 358
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) vsnprintf)(char *__s , size_t __n , char const   *__fmt ,
                                               __gnuc_va_list __ap )  __attribute__((__nothrow__)) ;
#line 492
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
#line 528
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
#line 564
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fgets)(char *__s , int __n , FILE *__stream ) ;
#line 646
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) fread)(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 43 "/usr/include/string.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memcpy)(void *__dest , void const   *__src , size_t __len )  __attribute__((__nothrow__)) ;
#line 47
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 61
__inline extern void *( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) memset)(void *__dest , int __ch , size_t __len )  __attribute__((__nothrow__)) ;
#line 122
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcpy)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 125
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncpy)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 130
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strcat)(char *__dest , char const   *__src )  __attribute__((__nothrow__)) ;
#line 133
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) strncat)(char *__dest , char const   *__src ,
                                             size_t __len )  __attribute__((__nothrow__)) ;
#line 66 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/timepng.c"
static void read_and_copy(png_structp png_ptr , png_bytep buffer___0 , size_t cb )
{
  io_data *io ;
  png_voidp tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
#line 69
  tmp = png_get_io_ptr((png_const_structrp )png_ptr);
#line 69
  io = (io_data *)tmp;
#line 71
  tmp___2 = fread((void *)buffer___0, cb, (size_t )1, io->input);
#line 71
  if (tmp___2 != 1UL) {
#line 72
    tmp___0 = __errno_location();
#line 72
    tmp___1 = strerror(*tmp___0);
#line 72
    png_error((png_const_structrp )png_ptr, (png_const_charp )tmp___1);
  }
#line 74
  tmp___3 = fwrite((void const   * __restrict  )buffer___0, cb, (size_t )1, (FILE * __restrict  )io->output);
#line 74
  if (tmp___3 != 1UL) {
#line 76
    perror((char const   *)"temporary file");
#line 77
    fprintf(stderr, (char const   *)"temporary file PNG write failed\n");
#line 78
    exit(1);
  }
#line 80
  return;
}
}
#line 82 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/timepng.c"
static void read_by_row(png_structp png_ptr , png_infop info_ptr , FILE *write_ptr ,
                        FILE *read_ptr )
{
  png_bytep row ;
  png_bytep display ;
  io_data io_copy ;
  size_t rowbytes ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  png_uint_32 height ;
  png_uint_32 tmp___2 ;
  int passes ;
  int tmp___3 ;
  int pass ;
  png_uint_32 y ;
  png_uint_32 tmp___4 ;

  {
#line 88
  row = (png_bytep )((void *)0);
#line 88
  display = (png_bytep )((void *)0);
#line 91
  if ((unsigned long )write_ptr != (unsigned long )((void *)0)) {
#line 94
    io_copy.input = read_ptr;
#line 95
    io_copy.output = write_ptr;
#line 96
    png_set_read_fn((png_structrp )png_ptr, (png_voidp )(& io_copy), & read_and_copy);
  }
#line 99
  png_read_info((png_structrp )png_ptr, (png_inforp )info_ptr);
#line 102
  tmp = png_get_rowbytes((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
#line 102
  rowbytes = tmp;
#line 104
  tmp___0 = malloc(rowbytes);
#line 104
  row = (png_bytep )tmp___0;
#line 105
  tmp___1 = malloc(rowbytes);
#line 105
  display = (png_bytep )tmp___1;
#line 107
  if ((unsigned long )row == (unsigned long )((void *)0)) {
#line 108
    png_error((png_const_structrp )png_ptr, (png_const_charp )"OOM allocating row buffers");
  } else
#line 107
  if ((unsigned long )display == (unsigned long )((void *)0)) {
#line 108
    png_error((png_const_structrp )png_ptr, (png_const_charp )"OOM allocating row buffers");
  }
#line 111
  tmp___2 = png_get_image_height((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
#line 111
  height = tmp___2;
#line 112
  tmp___3 = png_set_interlace_handling((png_structrp )png_ptr);
#line 112
  passes = tmp___3;
#line 115
  png_start_read_image((png_structrp )png_ptr);
#line 117
  pass = 0;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (pass < passes)) {
#line 117
      goto while_break;
    }
#line 119
    y = height;
    {
#line 125
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 125
      tmp___4 = y;
#line 125
      y --;
#line 125
      if (! (tmp___4 > 0U)) {
#line 125
        goto while_break___0;
      }
#line 126
      png_read_row((png_structrp )png_ptr, row, display);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 117
    pass ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  png_read_end((png_structrp )png_ptr, (png_inforp )info_ptr);
#line 135
  free((void *)row);
#line 136
  free((void *)display);
#line 137
  return;
}
}
#line 139 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/timepng.c"
static void no_warnings(png_structp png_ptr , png_const_charp warning___0 )
{


  {
#line 144
  return;
}
}
#line 146 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/timepng.c"
static int read_png___1(FILE *fp , png_int_32 transforms , FILE *write_file )
{
  png_structp png_ptr ;
  png_structp __attribute__((__malloc__))  tmp ;
  png_infop info_ptr ;
  jmp_buf *tmp___0 ;
  int tmp___1 ;
  png_infop __attribute__((__malloc__))  tmp___2 ;

  {
#line 148
  tmp = png_create_read_struct((png_const_charp )"1.6.39", (png_voidp )0, (void (*)(png_structp  ,
                                                                                    png_const_charp  ))0,
                               & no_warnings);
#line 148
  png_ptr = (png_structp )tmp;
#line 150
  info_ptr = (png_infop )((void *)0);
#line 152
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 153
    return (0);
  }
#line 155
  tmp___0 = png_set_longjmp_fn((png_structrp )png_ptr, & longjmp, sizeof(jmp_buf ));
#line 155
  tmp___1 = _setjmp((struct __jmp_buf_tag *)(*tmp___0));
#line 155
  if (tmp___1) {
#line 157
    png_destroy_read_struct(& png_ptr, & info_ptr, (png_infopp )((void *)0));
#line 158
    return (0);
  }
#line 162
  png_set_benign_errors((png_structrp )png_ptr, 1);
#line 164
  png_init_io((png_structrp )png_ptr, fp);
#line 166
  tmp___2 = png_create_info_struct((png_const_structrp )png_ptr);
#line 166
  info_ptr = (png_infop )tmp___2;
#line 168
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 169
    png_error((png_const_structrp )png_ptr, (png_const_charp )"OOM allocating info structure");
  }
#line 171
  if (transforms < 0) {
#line 172
    read_by_row(png_ptr, info_ptr, write_file, fp);
  } else {
#line 175
    png_read_png((png_structrp )png_ptr, (png_inforp )info_ptr, transforms, (void *)0);
  }
#line 177
  png_destroy_read_struct(& png_ptr, & info_ptr, (png_infopp )((void *)0));
#line 178
  return (1);
}
}
#line 181 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/timepng.c"
static int mytime(struct timespec *t )
{
  int tmp ;

  {
#line 184
  tmp = clock_gettime(2, t);
#line 184
  if (! tmp) {
#line 185
    return (1);
  }
#line 187
  perror((char const   *)"CLOCK_PROCESS_CPUTIME_ID");
#line 188
  fprintf(stderr, (char const   *)"timepng: could not get the time\n");
#line 189
  return (0);
}
}
#line 192 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/timepng.c"
static int perform_one_test___0(FILE *fp , int nfiles , png_int_32 transforms )
{
  int i ;
  struct timespec before ;
  struct timespec after ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned long s ;
  long ns ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 198
  rewind(fp);
#line 200
  tmp___1 = mytime(& before);
#line 200
  if (tmp___1) {
#line 202
    i = 0;
    {
#line 202
    while (1) {
      while_continue: /* CIL Label */ ;
#line 202
      if (! (i < nfiles)) {
#line 202
        goto while_break;
      }
#line 204
      tmp___0 = read_png___1(fp, transforms, (FILE *)((void *)0));
#line 204
      if (tmp___0) {
#line 206
        tmp = ferror(fp);
#line 206
        if (tmp) {
#line 208
          perror((char const   *)"temporary file");
#line 209
          fprintf(stderr, (char const   *)"file %d: error reading PNG data\n", i);
#line 210
          return (0);
        }
      } else {
#line 216
        perror((char const   *)"temporary file");
#line 217
        fprintf(stderr, (char const   *)"file %d: error from libpng\n", i);
#line 218
        return (0);
      }
#line 202
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 224
    return (0);
  }
#line 226
  tmp___3 = mytime(& after);
#line 226
  if (tmp___3) {
#line 231
    s = (unsigned long )(after.tv_sec - before.tv_sec);
#line 232
    ns = after.tv_nsec - before.tv_nsec;
#line 234
    if (ns < 0L) {
#line 236
      s --;
#line 237
      ns += 1000000000L;
#line 239
      if (ns < 0L) {
#line 241
        fprintf(stderr, (char const   *)"timepng: bad clock from kernel\n");
#line 242
        return (0);
      }
    }
#line 246
    printf((char const   *)"%lu.%.9ld\n", s, ns);
#line 247
    fflush(stdout);
#line 248
    tmp___2 = ferror(stdout);
#line 248
    if (tmp___2) {
#line 250
      fprintf(stderr, (char const   *)"timepng: error writing output\n");
#line 251
      return (0);
    }
#line 255
    return (1);
  } else {
#line 259
    return (0);
  }
}
}
#line 262 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/timepng.c"
static int add_one_file(FILE *fp , char *name )
{
  FILE *ip ;
  FILE *tmp ;
  int ok ;
  fpos_t pos ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 264
  tmp = fopen((char const   * __restrict  )name, (char const   * __restrict  )"rb");
#line 264
  ip = tmp;
#line 266
  if ((unsigned long )ip != (unsigned long )((void *)0)) {
#line 271
    ok = 0;
#line 274
    tmp___0 = fgetpos((FILE * __restrict  )fp, (fpos_t * __restrict  )(& pos));
#line 274
    if (tmp___0) {
#line 277
      perror((char const   *)"temporary file");
#line 278
      fprintf(stderr, (char const   *)"temporary file fgetpos error\n");
#line 279
      exit(1);
    }
#line 282
    tmp___2 = read_png___1(ip, -1, fp);
#line 282
    if (tmp___2) {
#line 284
      tmp___1 = ferror(ip);
#line 284
      if (tmp___1) {
#line 286
        perror((char const   *)name);
#line 287
        fprintf(stderr, (char const   *)"%s: read error\n", name);
      } else {
#line 291
        ok = 1;
      }
    } else {
#line 295
      fprintf(stderr, (char const   *)"%s: file not added\n", name);
    }
#line 297
    fclose(ip);
#line 300
    tmp___3 = ferror(fp);
#line 300
    if (tmp___3) {
#line 302
      perror((char const   *)"temporary file");
#line 303
      fprintf(stderr, (char const   *)"temporary file write error\n");
#line 304
      exit(1);
    }
#line 307
    if (ok) {
#line 308
      return (1);
    }
#line 314
    tmp___4 = fsetpos(fp, (fpos_t const   *)(& pos));
#line 314
    if (tmp___4) {
#line 316
      perror((char const   *)"temporary file");
#line 317
      fprintf(stderr, (char const   *)"temporary file fsetpos error\n");
#line 318
      exit(1);
    }
  } else {
#line 325
    perror((char const   *)name);
#line 326
    fprintf(stderr, (char const   *)"%s: open failed\n", name);
  }
#line 329
  return (0);
}
}
#line 332 "/home/goblint2/bench/libpng-1.6.39/contrib/libtests/timepng.c"
static void usage___0(FILE *fp )
{


  {
#line 335
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 335
    fclose(fp);
  }
#line 337
  fprintf(stderr, (char const   *)"Usage:\n timepng --assemble <assembly> {files}\n  Read the files into <assembly>, output the count.  Options are ignored.\n timepng --dissemble <assembly> <count> [options]\n  Time <count> files from <assembly>, additional files may not be given.\n Otherwise:\n  Read the files into a temporary file and time the decode\nTransforms:\n  --by-image: read by image with png_read_png\n  --<transform>: implies by-image, use PNG_TRANSFORM_<transform>\n  Otherwise: read by row using png_read_row (to a single row buffer)\n");
#line 349
  fprintf(stderr, (char const   *)"{files}:\n  PNG files to copy into the assembly and time.  Invalid files are skipped\n  with appropriate error messages.  If no files are given the list of files\n  is read from stdin with each file name terminated by a newline\nOutput:\n  For --assemble the output is the name of the assembly file followed by the\n  count of the files it contains; the arguments for --dissemble.  Otherwise\n  the output is the total decode time in seconds.\n");
#line 359
  exit(99);
}
}
