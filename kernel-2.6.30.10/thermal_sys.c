/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

typedef unsigned short __kernel_mode_t;
typedef unsigned int __kernel_size_t;
typedef int __kernel_ssize_t;
typedef unsigned short __u16;
typedef unsigned int __u32;
typedef unsigned long long u64;
typedef __u32 __kernel_dev_t;
typedef __kernel_dev_t dev_t;
typedef __kernel_mode_t mode_t;
typedef __kernel_size_t size_t;
typedef __kernel_ssize_t ssize_t;
typedef unsigned int gfp_t;
struct task_struct;
struct task_struct;
struct task_struct;
struct task_struct;
struct task_struct;
struct module;
struct module;
typedef __builtin_va_list __gnuc_va_list;
typedef __gnuc_va_list va_list;
struct bug_entry {
   unsigned long bug_addr ;
   char const   *file ;
   unsigned short line ;
   unsigned short flags ;
};
struct completion;
struct completion;
struct raw_spinlock;
struct raw_spinlock;
struct task_struct;
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
struct task_struct;
struct raw_spinlock {
   unsigned int slock ;
};
typedef struct raw_spinlock raw_spinlock_t;
struct task_struct;
struct lock_class_key {

};
struct __anonstruct_spinlock_t_32 {
   raw_spinlock_t raw_lock ;
};
typedef struct __anonstruct_spinlock_t_32 spinlock_t;
struct __anonstruct_atomic_t_34 {
   int counter ;
};
typedef struct __anonstruct_atomic_t_34 atomic_t;
typedef atomic_t atomic_long_t;
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
typedef struct __wait_queue_head wait_queue_head_t;
struct task_struct;
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
};
struct device;
struct device;
struct pm_message {
   int event ;
};
typedef struct pm_message pm_message_t;
struct pm_ops {
   int (*prepare)(struct device *dev ) ;
   void (*complete)(struct device *dev ) ;
   int (*suspend)(struct device *dev ) ;
   int (*resume)(struct device *dev ) ;
   int (*freeze)(struct device *dev ) ;
   int (*thaw)(struct device *dev ) ;
   int (*poweroff)(struct device *dev ) ;
   int (*restore)(struct device *dev ) ;
};
struct pm_ext_ops {
   struct pm_ops base ;
   int (*suspend_noirq)(struct device *dev ) ;
   int (*resume_noirq)(struct device *dev ) ;
   int (*freeze_noirq)(struct device *dev ) ;
   int (*thaw_noirq)(struct device *dev ) ;
   int (*poweroff_noirq)(struct device *dev ) ;
   int (*restore_noirq)(struct device *dev ) ;
};
enum dpm_state {
    DPM_INVALID = 0,
    DPM_ON = 1,
    DPM_PREPARING = 2,
    DPM_RESUMING = 3,
    DPM_SUSPENDING = 4,
    DPM_OFF = 5,
    DPM_OFF_IRQ = 6
} ;
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int can_wakeup : 1 ;
   unsigned int should_wakeup : 1 ;
   enum dpm_state status ;
   struct list_head entry ;
};
struct task_struct;
typedef __u32 Elf32_Addr;
typedef __u16 Elf32_Half;
typedef __u32 Elf32_Word;
struct elf32_sym {
   Elf32_Word st_name ;
   Elf32_Addr st_value ;
   Elf32_Word st_size ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf32_Half st_shndx ;
};
typedef struct elf32_sym Elf32_Sym;
struct kobject;
struct kobject;
struct module;
struct attribute {
   char const   *name ;
   struct module *owner ;
   mode_t mode ;
};
struct attribute_group {
   char const   *name ;
   mode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
};
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
struct kref {
   atomic_t refcount ;
};
struct kset;
struct kobj_type;
struct sysfs_dirent;
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct sysfs_dirent *sd ;
   struct kref kref ;
   unsigned int state_initialized : 1 ;
   unsigned int state_in_sysfs : 1 ;
   unsigned int state_add_uevent_sent : 1 ;
   unsigned int state_remove_uevent_sent : 1 ;
};
struct kobj_type {
   void (*release)(struct kobject *kobj ) ;
   struct sysfs_ops *sysfs_ops ;
   struct attribute **default_attrs ;
};
struct kobj_uevent_env {
   char *envp[32] ;
   int envp_idx ;
   char buf[2048] ;
   int buflen ;
};
struct kset_uevent_ops {
   int (*filter)(struct kset *kset , struct kobject *kobj ) ;
   char const   *(*name)(struct kset *kset , struct kobject *kobj ) ;
   int (*uevent)(struct kset *kset , struct kobject *kobj , struct kobj_uevent_env *env ) ;
};
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops *uevent_ops ;
};
struct module;
struct module;
struct marker;
struct marker;
typedef void marker_probe_func(void *probe_private , void *call_private , char const   *fmt ,
                               va_list *args );
struct marker_probe_closure {
   marker_probe_func *func ;
   void *probe_private ;
};
struct marker {
   char const   *name ;
   char const   *format ;
   char state ;
   char ptype ;
   void (*call)(struct marker  const  *mdata , void *call_private  , ...) ;
   struct marker_probe_closure single ;
   struct marker_probe_closure *multi ;
} __attribute__((__aligned__(8))) ;
struct __anonstruct_local_t_98 {
   atomic_long_t a ;
};
typedef struct __anonstruct_local_t_98 local_t;
struct mod_arch_specific {

};
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
struct module;
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module * , char const   * ,
                    size_t count ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
};
struct exception_table_entry;
struct exception_table_entry;
struct module_ref {
   local_t count ;
} __attribute__((__aligned__((1) <<  (7) ))) ;
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2
} ;
struct module_param_attrs;
struct module_sect_attrs;
struct module_notes_attrs;
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[64U - sizeof(unsigned long )] ;
   struct module_kobject mkobj ;
   struct module_param_attrs *param_attrs ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry  const  *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   void *unwind_info ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf32_Sym *symtab ;
   unsigned int num_symtab ;
   char *strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   void *percpu ;
   char *args ;
   struct marker *markers ;
   unsigned int num_markers ;
   struct list_head modules_which_use_me ;
   struct task_struct *waiter ;
   void (*exit)(void) ;
   struct module_ref ref[64] ;
};
struct device_driver;
struct device_driver;
struct module;
struct device;
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
struct klist_node;
struct klist_node;
struct klist {
   spinlock_t k_lock ;
   struct list_head k_list ;
   void (*get)(struct klist_node * ) ;
   void (*put)(struct klist_node * ) ;
};
struct klist_node {
   struct klist *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
   struct completion n_removed ;
};
struct semaphore {
   spinlock_t lock ;
   unsigned int count ;
   struct list_head wait_list ;
};
struct dev_archdata {
   void *acpi_handle ;
};
struct device;
struct device_driver;
struct driver_private;
struct driver_private;
struct class;
struct class;
struct class_private;
struct class_private;
struct bus_type;
struct bus_type;
struct bus_type_private;
struct bus_type_private;
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type *bus , char *buf ) ;
   ssize_t (*store)(struct bus_type *bus , char const   *buf , size_t count ) ;
};
struct device_attribute;
struct driver_attribute;
struct bus_type {
   char const   *name ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   int (*match)(struct device *dev , struct device_driver *drv ) ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*suspend_late)(struct device *dev , pm_message_t state ) ;
   int (*resume_early)(struct device *dev ) ;
   int (*resume)(struct device *dev ) ;
   struct pm_ext_ops *pm ;
   struct bus_type_private *p ;
};
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct attribute_group **groups ;
   struct pm_ops *pm ;
   struct driver_private *p ;
};
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver *driver , char *buf ) ;
   ssize_t (*store)(struct device_driver *driver , char const   *buf , size_t count ) ;
};
struct class_attribute;
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct device_attribute *dev_attrs ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   void (*class_release)(struct class *class ) ;
   void (*dev_release)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct pm_ops *pm ;
   struct class_private *p ;
};
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class *class , char *buf ) ;
   ssize_t (*store)(struct class *class , char const   *buf , size_t count ) ;
};
struct device_type {
   char const   *name ;
   struct attribute_group **groups ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   void (*release)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct pm_ops *pm ;
};
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device *dev , struct device_attribute *attr , char *buf ) ;
   ssize_t (*store)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                    size_t count ) ;
};
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
struct dma_coherent_mem;
struct device {
   struct klist klist_children ;
   struct klist_node knode_parent ;
   struct klist_node knode_driver ;
   struct klist_node knode_bus ;
   struct device *parent ;
   struct kobject kobj ;
   char bus_id[20] ;
   char const   *init_name ;
   struct device_type *type ;
   unsigned int uevent_suppress : 1 ;
   struct semaphore sem ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *driver_data ;
   void *platform_data ;
   struct dev_pm_info power ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct list_head node ;
   struct class *class ;
   dev_t devt ;
   struct attribute_group **groups ;
   void (*release)(struct device *dev ) ;
};
struct rcu_head {
   struct rcu_head *next ;
   void (*func)(struct rcu_head *head ) ;
};
struct idr_layer {
   unsigned long bitmap ;
   struct idr_layer *ary[1 << 5] ;
   int count ;
   int layer ;
   struct rcu_head rcu_head ;
};
struct idr {
   struct idr_layer *top ;
   struct idr_layer *id_free ;
   int layers ;
   int id_free_cnt ;
   spinlock_t lock ;
};
struct thermal_zone_device;
struct thermal_zone_device;
struct thermal_cooling_device;
struct thermal_cooling_device;
struct thermal_zone_device_ops {
   int (*bind)(struct thermal_zone_device * , struct thermal_cooling_device * ) ;
   int (*unbind)(struct thermal_zone_device * , struct thermal_cooling_device * ) ;
   int (*get_temp)(struct thermal_zone_device * , char * ) ;
   int (*get_mode)(struct thermal_zone_device * , char * ) ;
   int (*set_mode)(struct thermal_zone_device * , char const   * ) ;
   int (*get_trip_type)(struct thermal_zone_device * , int  , char * ) ;
   int (*get_trip_temp)(struct thermal_zone_device * , int  , char * ) ;
   int (*get_crit_temp)(struct thermal_zone_device * , unsigned long * ) ;
};
struct thermal_cooling_device_ops {
   int (*get_max_state)(struct thermal_cooling_device * , char * ) ;
   int (*get_cur_state)(struct thermal_cooling_device * , char * ) ;
   int (*set_cur_state)(struct thermal_cooling_device * , unsigned int  ) ;
};
struct thermal_cooling_device {
   int id ;
   char type[20] ;
   struct device device ;
   void *devdata ;
   struct thermal_cooling_device_ops *ops ;
   struct list_head node ;
};
struct thermal_hwmon_device {
   char type[20] ;
   struct device *device ;
   int count ;
   struct list_head tz_list ;
   struct list_head node ;
};
struct thermal_hwmon_attr {
   struct device_attribute attr ;
   char name[16] ;
};
struct thermal_zone_device {
   int id ;
   char type[20] ;
   struct device device ;
   void *devdata ;
   int trips ;
   struct thermal_zone_device_ops *ops ;
   struct list_head cooling_devices ;
   struct idr idr ;
   struct mutex lock ;
   struct list_head node ;
   struct list_head hwmon_node ;
   struct thermal_hwmon_device *hwmon ;
   struct thermal_hwmon_attr temp_input ;
   struct thermal_hwmon_attr temp_crit ;
};
struct thermal_cooling_device_instance {
   int id ;
   char name[20] ;
   struct thermal_zone_device *tz ;
   struct thermal_cooling_device *cdev ;
   int trip ;
   char attr_name[20] ;
   struct device_attribute attr ;
   struct list_head node ;
};
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
extern int ( /* format attribute */  sprintf)(char *buf , char const   *fmt  , ...) ;
extern int ( /* format attribute */  snprintf)(char *buf , size_t size , char const   *fmt 
                                               , ...) ;
extern int ( /* format attribute */  sscanf)(char const   * , char const   *  , ...) ;
extern char *strcpy(char *dest , char const   *src ) ;
extern int strcmp(char const   *cs , char const   *ct ) ;
extern int strncmp(char const   *cs , char const   *ct , size_t count ) ;
extern size_t strlen(char const   *s ) ;
extern size_t strlcpy(char * , char const   * , size_t  ) ;
__inline static void prefetch(void const   *x ) 
{ 

  {
  {
  __asm__  volatile   ("661:\n\t"
                       ".byte 0x8d,0x74,0x26,0x00\n"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "prefetchnta (%1)"
                       "\n664:\n"
                       ".previous": : "i" (25), "r" (x));
  }
  return;
}
}
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 

  {
  {
  list->next = list;
  list->prev = list;
  }
  return;
}
}
__inline static void __list_add(struct list_head *new , struct list_head *prev , struct list_head *next ) 
{ 

  {
  {
  next->prev = new;
  new->next = next;
  new->prev = prev;
  prev->next = new;
  }
  return;
}
}
__inline static void list_add(struct list_head *new , struct list_head *head ) 
{ 

  {
  {
  __list_add(new, head, head->next);
  }
  return;
}
}
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 

  {
  {
  __list_add(new, head->prev, head);
  }
  return;
}
}
__inline static void __list_del(struct list_head *prev , struct list_head *next ) 
{ 

  {
  {
  next->prev = prev;
  prev->next = next;
  }
  return;
}
}
__inline static void list_del(struct list_head *entry ) 
{ 

  {
  {
  __list_del(entry->prev, entry->next);
  entry->next = (struct list_head *)((void *)1048832);
  entry->prev = (struct list_head *)((void *)2097664);
  }
  return;
}
}
__inline static int list_empty(struct list_head  const  *head ) 
{ 

  {
  return ((unsigned int )head->next == (unsigned int )head);
}
}
register unsigned long current_stack_pointer  __asm__("esp") __attribute__((__used__))  ;
extern void __mutex_init(struct mutex *lock , char const   *name , struct lock_class_key *key ) ;
extern void mutex_lock(struct mutex *lock ) ;
extern void mutex_unlock(struct mutex *lock ) ;
extern int sysfs_create_link(struct kobject *kobj , struct kobject *target , char const   *name ) ;
extern void sysfs_remove_link(struct kobject *kobj , char const   *name ) ;
extern void kfree(void const   * ) ;
extern void *__kmalloc(size_t size , gfp_t flags ) ;
__inline static void *( __attribute__((__always_inline__)) kmalloc)(size_t size ,
                                                                    gfp_t flags ) 
{ void *tmp___2 ;

  {
  {
  tmp___2 = __kmalloc(size, flags);
  }
  return (tmp___2);
}
}
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ void *tmp ;

  {
  {
  tmp = kmalloc(size, flags | 32768U);
  }
  return (tmp);
}
}
extern int __class_register(struct class *class , struct lock_class_key *key ) ;
extern void class_unregister(struct class *class ) ;
extern int device_create_file(struct device *device , struct device_attribute *entry ) ;
extern void device_remove_file(struct device *dev , struct device_attribute *attr ) ;
extern int device_register(struct device *dev ) ;
extern void device_unregister(struct device *dev ) ;
__inline static void *ERR_PTR(long error ) 
{ 

  {
  return ((void *)error);
}
}
__inline static long PTR_ERR(void const   *ptr ) 
{ 

  {
  return ((long )ptr);
}
}
__inline static long IS_ERR(void const   *ptr ) 
{ long tmp ;

  {
  {
  tmp = __builtin_expect((long )(! (! ((unsigned long )ptr >= 4294963201UL))), 0L);
  }
  return (tmp);
}
}
extern int idr_pre_get(struct idr *idp , gfp_t gfp_mask ) ;
extern int idr_get_new(struct idr *idp , void *ptr , int *id ) ;
extern void idr_remove(struct idr *idp , int id ) ;
extern void idr_destroy(struct idr *idp ) ;
extern void idr_init(struct idr *idp ) ;
struct thermal_zone_device *thermal_zone_device_register(char *type , int trips ,
                                                         void *devdata , struct thermal_zone_device_ops *ops ) ;
void thermal_zone_device_unregister(struct thermal_zone_device *tz ) ;
int thermal_zone_bind_cooling_device(struct thermal_zone_device *tz , int trip , struct thermal_cooling_device *cdev ) ;
int thermal_zone_unbind_cooling_device(struct thermal_zone_device *tz , int trip ,
                                       struct thermal_cooling_device *cdev ) ;
struct thermal_cooling_device *thermal_cooling_device_register(char *type , void *devdata ,
                                                               struct thermal_cooling_device_ops *ops ) ;
void thermal_cooling_device_unregister(struct thermal_cooling_device *cdev ) ;
static struct idr thermal_tz_idr  =    {(struct idr_layer *)((void *)0), (struct idr_layer *)((void *)0), 0, 0, {{0U}}};
static struct idr thermal_cdev_idr  =    {(struct idr_layer *)((void *)0),
    (struct idr_layer *)((void *)0), 0, 0, {{0U}}};
static struct mutex thermal_idr_lock  =    {{1}, {{0U}}, {& thermal_idr_lock.wait_list, & thermal_idr_lock.wait_list}};
static struct list_head thermal_tz_list  =    {& thermal_tz_list, & thermal_tz_list};
static struct list_head thermal_cdev_list  =    {& thermal_cdev_list, & thermal_cdev_list};
static struct mutex thermal_list_lock  =    {{1}, {{0U}}, {& thermal_list_lock.wait_list, & thermal_list_lock.wait_list}};
static int get_idr(struct idr *idr , struct mutex *lock , int *id ) 
{ int err ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  again: 
  {
  tmp = idr_pre_get(idr, 208U);
  }
  if (tmp == 0) {
    {
    tmp___0 = 1;
    }
  } else {
    {
    tmp___0 = 0;
    }
  }
  {
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
  if (tmp___1) {
    return (-12);
  }
  if (lock) {
    {
    mutex_lock(lock);
    }
  }
  {
  err = idr_get_new(idr, (void *)0, id);
  }
  if (lock) {
    {
    mutex_unlock(lock);
    }
  }
  {
  tmp___3 = __builtin_expect((long )(! (! (err == -11))), 0L);
  }
  if (tmp___3) {
    goto again;
  } else {
    {
    tmp___2 = __builtin_expect((long )(! (! err)), 0L);
    }
    if (tmp___2) {
      return (err);
    }
  }
  {
  *id = (int )((unsigned int )*id & ((1U << (sizeof(int ) * 8U - 1U)) - 1U));
  }
  return (0);
}
}
static void release_idr(struct idr *idr , struct mutex *lock , int id ) 
{ 

  {
  if (lock) {
    {
    mutex_lock(lock);
    }
  }
  {
  idr_remove(idr, id);
  }
  if (lock) {
    {
    mutex_unlock(lock);
    }
  }
  return;
}
}
static ssize_t type_show(struct device *dev , struct device_attribute *attr , char *buf ) 
{ struct thermal_zone_device *tz ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  tz = (struct thermal_zone_device *)((char *)__mptr - (unsigned int )(& ((struct thermal_zone_device *)0)->device));
  tmp = sprintf(buf, "%s\n", tz->type);
  }
  return (tmp);
}
}
static ssize_t temp_show(struct device *dev , struct device_attribute *attr , char *buf ) 
{ struct thermal_zone_device *tz ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  tz = (struct thermal_zone_device *)((char *)__mptr - (unsigned int )(& ((struct thermal_zone_device *)0)->device));
  }
  if (! (tz->ops)->get_temp) {
    return (-1);
  }
  {
  tmp = (*((tz->ops)->get_temp))(tz, buf);
  }
  return (tmp);
}
}
static ssize_t mode_show(struct device *dev , struct device_attribute *attr , char *buf ) 
{ struct thermal_zone_device *tz ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  tz = (struct thermal_zone_device *)((char *)__mptr - (unsigned int )(& ((struct thermal_zone_device *)0)->device));
  }
  if (! (tz->ops)->get_mode) {
    return (-1);
  }
  {
  tmp = (*((tz->ops)->get_mode))(tz, buf);
  }
  return (tmp);
}
}
static ssize_t mode_store(struct device *dev , struct device_attribute *attr , char const   *buf ,
                          size_t count ) 
{ struct thermal_zone_device *tz ;
  struct device  const  *__mptr ;
  int result ;

  {
  {
  __mptr = (struct device  const  *)dev;
  tz = (struct thermal_zone_device *)((char *)__mptr - (unsigned int )(& ((struct thermal_zone_device *)0)->device));
  }
  if (! (tz->ops)->set_mode) {
    return (-1);
  }
  {
  result = (*((tz->ops)->set_mode))(tz, buf);
  }
  if (result) {
    return (result);
  }
  return ((int )count);
}
}
static ssize_t trip_point_type_show(struct device *dev , struct device_attribute *attr ,
                                    char *buf ) 
{ struct thermal_zone_device *tz ;
  struct device  const  *__mptr ;
  int trip ;
  int tmp ;
  int tmp___0 ;

  {
  {
  __mptr = (struct device  const  *)dev;
  tz = (struct thermal_zone_device *)((char *)__mptr - (unsigned int )(& ((struct thermal_zone_device *)0)->device));
  }
  if (! (tz->ops)->get_trip_type) {
    return (-1);
  }
  {
  tmp = sscanf(attr->attr.name, "trip_point_%d_type", & trip);
  }
  if (! tmp) {
    return (-22);
  }
  {
  tmp___0 = (*((tz->ops)->get_trip_type))(tz, trip, buf);
  }
  return (tmp___0);
}
}
static ssize_t trip_point_temp_show(struct device *dev , struct device_attribute *attr ,
                                    char *buf ) 
{ struct thermal_zone_device *tz ;
  struct device  const  *__mptr ;
  int trip ;
  int tmp ;
  int tmp___0 ;

  {
  {
  __mptr = (struct device  const  *)dev;
  tz = (struct thermal_zone_device *)((char *)__mptr - (unsigned int )(& ((struct thermal_zone_device *)0)->device));
  }
  if (! (tz->ops)->get_trip_temp) {
    return (-1);
  }
  {
  tmp = sscanf(attr->attr.name, "trip_point_%d_temp", & trip);
  }
  if (! tmp) {
    return (-22);
  }
  {
  tmp___0 = (*((tz->ops)->get_trip_temp))(tz, trip, buf);
  }
  return (tmp___0);
}
}
static struct device_attribute dev_attr_type  =    {{"type", (struct module *)0, (mode_t )292}, & type_show, (ssize_t (*)(struct device *dev ,
                                                                          struct device_attribute *attr ,
                                                                          char const   *buf ,
                                                                          size_t count ))((void *)0)};
static struct device_attribute dev_attr_temp  =    {{"temp",
     (struct module *)0, (mode_t )292}, & temp_show, (ssize_t (*)(struct device *dev ,
                                                                  struct device_attribute *attr ,
                                                                  char const   *buf ,
                                                                  size_t count ))((void *)0)};
static struct device_attribute dev_attr_mode  =    {{"mode",
     (struct module *)0, (mode_t )420}, & mode_show, & mode_store};
static struct device_attribute trip_point_attrs[24]  = 
  {      {{"trip_point_0_type", (struct module *)0, (mode_t )292}, & trip_point_type_show,
      (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                   size_t count ))((void *)0)}, 
        {{"trip_point_0_temp", (struct module *)0, (mode_t )292}, & trip_point_temp_show,
      (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                   size_t count ))((void *)0)}, 
        {{"trip_point_1_type", (struct module *)0, (mode_t )292}, & trip_point_type_show,
      (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                   size_t count ))((void *)0)}, 
        {{"trip_point_1_temp", (struct module *)0, (mode_t )292}, & trip_point_temp_show,
      (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                   size_t count ))((void *)0)}, 
        {{"trip_point_2_type", (struct module *)0, (mode_t )292}, & trip_point_type_show,
      (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                   size_t count ))((void *)0)}, 
        {{"trip_point_2_temp", (struct module *)0, (mode_t )292}, & trip_point_temp_show,
      (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                   size_t count ))((void *)0)}, 
        {{"trip_point_3_type", (struct module *)0, (mode_t )292}, & trip_point_type_show,
      (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                   size_t count ))((void *)0)}, 
        {{"trip_point_3_temp", (struct module *)0, (mode_t )292}, & trip_point_temp_show,
      (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                   size_t count ))((void *)0)}, 
        {{"trip_point_4_type", (struct module *)0, (mode_t )292}, & trip_point_type_show,
      (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                   size_t count ))((void *)0)}, 
        {{"trip_point_4_temp", (struct module *)0, (mode_t )292}, & trip_point_temp_show,
      (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                   size_t count ))((void *)0)}, 
        {{"trip_point_5_type", (struct module *)0, (mode_t )292}, & trip_point_type_show,
      (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                   size_t count ))((void *)0)}, 
        {{"trip_point_5_temp", (struct module *)0, (mode_t )292}, & trip_point_temp_show,
      (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                   size_t count ))((void *)0)}, 
        {{"trip_point_6_type", (struct module *)0, (mode_t )292}, & trip_point_type_show,
      (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                   size_t count ))((void *)0)}, 
        {{"trip_point_6_temp", (struct module *)0, (mode_t )292}, & trip_point_temp_show,
      (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                   size_t count ))((void *)0)}, 
        {{"trip_point_7_type", (struct module *)0, (mode_t )292}, & trip_point_type_show,
      (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                   size_t count ))((void *)0)}, 
        {{"trip_point_7_temp", (struct module *)0, (mode_t )292}, & trip_point_temp_show,
      (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                   size_t count ))((void *)0)}, 
        {{"trip_point_8_type", (struct module *)0, (mode_t )292}, & trip_point_type_show,
      (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                   size_t count ))((void *)0)}, 
        {{"trip_point_8_temp", (struct module *)0, (mode_t )292}, & trip_point_temp_show,
      (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                   size_t count ))((void *)0)}, 
        {{"trip_point_9_type", (struct module *)0, (mode_t )292}, & trip_point_type_show,
      (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                   size_t count ))((void *)0)}, 
        {{"trip_point_9_temp", (struct module *)0, (mode_t )292}, & trip_point_temp_show,
      (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                   size_t count ))((void *)0)}, 
        {{"trip_point_10_type", (struct module *)0, (mode_t )292}, & trip_point_type_show,
      (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                   size_t count ))((void *)0)}, 
        {{"trip_point_10_temp", (struct module *)0, (mode_t )292}, & trip_point_temp_show,
      (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                   size_t count ))((void *)0)}, 
        {{"trip_point_11_type", (struct module *)0, (mode_t )292}, & trip_point_type_show,
      (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                   size_t count ))((void *)0)}, 
        {{"trip_point_11_temp", (struct module *)0, (mode_t )292}, & trip_point_temp_show,
      (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                   size_t count ))((void *)0)}};
static ssize_t thermal_cooling_device_type_show(struct device *dev , struct device_attribute *attr ,
                                                char *buf ) 
{ struct thermal_cooling_device *cdev ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  cdev = (struct thermal_cooling_device *)((char *)__mptr - (unsigned int )(& ((struct thermal_cooling_device *)0)->device));
  tmp = sprintf(buf, "%s\n", cdev->type);
  }
  return (tmp);
}
}
static ssize_t thermal_cooling_device_max_state_show(struct device *dev , struct device_attribute *attr ,
                                                     char *buf ) 
{ struct thermal_cooling_device *cdev ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  cdev = (struct thermal_cooling_device *)((char *)__mptr - (unsigned int )(& ((struct thermal_cooling_device *)0)->device));
  tmp = (*((cdev->ops)->get_max_state))(cdev, buf);
  }
  return (tmp);
}
}
static ssize_t thermal_cooling_device_cur_state_show(struct device *dev , struct device_attribute *attr ,
                                                     char *buf ) 
{ struct thermal_cooling_device *cdev ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  cdev = (struct thermal_cooling_device *)((char *)__mptr - (unsigned int )(& ((struct thermal_cooling_device *)0)->device));
  tmp = (*((cdev->ops)->get_cur_state))(cdev, buf);
  }
  return (tmp);
}
}
static ssize_t thermal_cooling_device_cur_state_store(struct device *dev , struct device_attribute *attr ,
                                                      char const   *buf , size_t count ) 
{ struct thermal_cooling_device *cdev ;
  struct device  const  *__mptr ;
  int state ;
  int result ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  cdev = (struct thermal_cooling_device *)((char *)__mptr - (unsigned int )(& ((struct thermal_cooling_device *)0)->device));
  tmp = sscanf(buf, "%d\n", & state);
  }
  if (! tmp) {
    return (-22);
  }
  if (state < 0) {
    return (-22);
  }
  {
  result = (*((cdev->ops)->set_cur_state))(cdev, (unsigned int )state);
  }
  if (result) {
    return (result);
  }
  return ((int )count);
}
}
static struct device_attribute dev_attr_cdev_type  =    {{"type", (struct module *)0, (mode_t )292}, & thermal_cooling_device_type_show,
    (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                 size_t count ))((void *)0)};
static struct device_attribute dev_attr_max_state  =    {{"max_state", (struct module *)0, (mode_t )292}, & thermal_cooling_device_max_state_show,
    (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                 size_t count ))((void *)0)};
static struct device_attribute dev_attr_cur_state  =    {{"cur_state", (struct module *)0, (mode_t )420}, & thermal_cooling_device_cur_state_show,
    & thermal_cooling_device_cur_state_store};
static ssize_t thermal_cooling_device_trip_point_show(struct device *dev , struct device_attribute *attr ,
                                                      char *buf ) 
{ struct thermal_cooling_device_instance *instance ;
  struct device_attribute  const  *__mptr ;
  int tmp ;
  int tmp___0 ;

  {
  {
  __mptr = (struct device_attribute  const  *)attr;
  instance = (struct thermal_cooling_device_instance *)((char *)__mptr - (unsigned int )(& ((struct thermal_cooling_device_instance *)0)->attr));
  }
  if (instance->trip == -1) {
    {
    tmp = sprintf(buf, "-1\n");
    }
    return (tmp);
  } else {
    {
    tmp___0 = sprintf(buf, "%d\n", instance->trip);
    }
    return (tmp___0);
  }
}
}
extern struct device *hwmon_device_register(struct device *dev ) ;
extern void hwmon_device_unregister(struct device *dev ) ;
static struct list_head thermal_hwmon_list  =    {& thermal_hwmon_list, & thermal_hwmon_list};
static ssize_t name_show(struct device *dev , struct device_attribute *attr , char *buf ) 
{ struct thermal_hwmon_device *hwmon ;
  int tmp ;

  {
  {
  hwmon = (struct thermal_hwmon_device *)dev->driver_data;
  tmp = sprintf(buf, "%s\n", hwmon->type);
  }
  return (tmp);
}
}
static struct device_attribute dev_attr_name  =    {{"name", (struct module *)0, (mode_t )292}, & name_show, (ssize_t (*)(struct device *dev ,
                                                                          struct device_attribute *attr ,
                                                                          char const   *buf ,
                                                                          size_t count ))((void *)0)};
static ssize_t temp_input_show(struct device *dev ,
                               struct device_attribute *attr , char *buf ) 
{ struct thermal_hwmon_attr *hwmon_attr ;
  struct device_attribute  const  *__mptr ;
  struct thermal_zone_device *tz ;
  struct thermal_hwmon_attr  const  *__mptr___0 ;
  int tmp ;

  {
  {
  __mptr = (struct device_attribute  const  *)attr;
  hwmon_attr = (struct thermal_hwmon_attr *)((char *)__mptr - (unsigned int )(& ((struct thermal_hwmon_attr *)0)->attr));
  __mptr___0 = (struct thermal_hwmon_attr  const  *)hwmon_attr;
  tz = (struct thermal_zone_device *)((char *)__mptr___0 - (unsigned int )(& ((struct thermal_zone_device *)0)->temp_input));
  tmp = (*((tz->ops)->get_temp))(tz, buf);
  }
  return (tmp);
}
}
static ssize_t temp_crit_show(struct device *dev , struct device_attribute *attr ,
                              char *buf ) 
{ struct thermal_hwmon_attr *hwmon_attr ;
  struct device_attribute  const  *__mptr ;
  struct thermal_zone_device *tz ;
  struct thermal_hwmon_attr  const  *__mptr___0 ;
  int tmp ;

  {
  {
  __mptr = (struct device_attribute  const  *)attr;
  hwmon_attr = (struct thermal_hwmon_attr *)((char *)__mptr - (unsigned int )(& ((struct thermal_hwmon_attr *)0)->attr));
  __mptr___0 = (struct thermal_hwmon_attr  const  *)hwmon_attr;
  tz = (struct thermal_zone_device *)((char *)__mptr___0 - (unsigned int )(& ((struct thermal_zone_device *)0)->temp_crit));
  tmp = (*((tz->ops)->get_trip_temp))(tz, 0, buf);
  }
  return (tmp);
}
}
static int thermal_add_hwmon_sysfs(struct thermal_zone_device *tz ) 
{ struct thermal_hwmon_device *hwmon ;
  int new_hwmon_device ;
  int result ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  unsigned long temperature ;
  int tmp___3 ;

  {
  {
  new_hwmon_device = 1;
  mutex_lock(& thermal_list_lock);
  __mptr = (struct list_head  const  *)thermal_hwmon_list.next;
  hwmon = (struct thermal_hwmon_device *)((char *)__mptr - (unsigned int )(& ((struct thermal_hwmon_device *)0)->node));
  }
  {
  while (1) {
    while_0_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)hwmon->node.next);
    }
    if (! ((unsigned int )(& hwmon->node) != (unsigned int )(& thermal_hwmon_list))) {
      goto while_0_break;
    }
    {
    tmp = strcmp((char const   *)(hwmon->type), (char const   *)(tz->type));
    }
    if (! tmp) {
      {
      new_hwmon_device = 0;
      mutex_unlock(& thermal_list_lock);
      }
      goto register_sys_interface;
    }
    {
    __mptr___0 = (struct list_head  const  *)hwmon->node.next;
    hwmon = (struct thermal_hwmon_device *)((char *)__mptr___0 - (unsigned int )(& ((struct thermal_hwmon_device *)0)->node));
    }
  }
  while_0_break: /* CIL Label */ ;
  }
  {
  mutex_unlock(& thermal_list_lock);
  tmp___0 = kzalloc(sizeof(struct thermal_hwmon_device ), 208U);
  hwmon = (struct thermal_hwmon_device *)tmp___0;
  }
  if (! hwmon) {
    return (-12);
  }
  {
  INIT_LIST_HEAD(& hwmon->tz_list);
  strlcpy(hwmon->type, (char const   *)(tz->type), 20U);
  hwmon->device = hwmon_device_register((struct device *)((void *)0));
  tmp___2 = IS_ERR((void const   *)hwmon->device);
  }
  if (tmp___2) {
    {
    tmp___1 = PTR_ERR((void const   *)hwmon->device);
    result = (int )tmp___1;
    }
    goto free_mem;
  }
  {
  (hwmon->device)->driver_data = (void *)hwmon;
  result = device_create_file(hwmon->device, & dev_attr_name);
  }
  if (result) {
    goto unregister_hwmon_device;
  }
  register_sys_interface: 
  {
  tz->hwmon = hwmon;
  (hwmon->count) ++;
  snprintf(tz->temp_input.name, 20U, "temp%d_input", hwmon->count);
  tz->temp_input.attr.attr.name = (char const   *)(tz->temp_input.name);
  tz->temp_input.attr.attr.mode = (unsigned short)292;
  tz->temp_input.attr.show = & temp_input_show;
  result = device_create_file(hwmon->device, & tz->temp_input.attr);
  }
  if (result) {
    goto unregister_hwmon_device;
  }
  if ((tz->ops)->get_crit_temp) {
    {
    tmp___3 = (*((tz->ops)->get_crit_temp))(tz, & temperature);
    }
    if (! tmp___3) {
      {
      snprintf(tz->temp_crit.name, 20U, "temp%d_crit", hwmon->count);
      tz->temp_crit.attr.attr.name = (char const   *)(tz->temp_crit.name);
      tz->temp_crit.attr.attr.mode = (unsigned short)292;
      tz->temp_crit.attr.show = & temp_crit_show;
      result = device_create_file(hwmon->device, & tz->temp_crit.attr);
      }
      if (result) {
        goto unregister_hwmon_device;
      }
    }
  }
  {
  mutex_lock(& thermal_list_lock);
  }
  if (new_hwmon_device) {
    {
    list_add_tail(& hwmon->node, & thermal_hwmon_list);
    }
  }
  {
  list_add_tail(& tz->hwmon_node, & hwmon->tz_list);
  mutex_unlock(& thermal_list_lock);
  }
  return (0);
  unregister_hwmon_device: 
  {
  device_remove_file(hwmon->device, & tz->temp_crit.attr);
  device_remove_file(hwmon->device, & tz->temp_input.attr);
  }
  if (new_hwmon_device) {
    {
    device_remove_file(hwmon->device, & dev_attr_name);
    hwmon_device_unregister(hwmon->device);
    }
  }
  free_mem: 
  if (new_hwmon_device) {
    {
    kfree((void const   *)hwmon);
    }
  }
  return (result);
}
}
static void thermal_remove_hwmon_sysfs(struct thermal_zone_device *tz ) 
{ struct thermal_hwmon_device *hwmon ;
  int tmp ;

  {
  {
  hwmon = tz->hwmon;
  tz->hwmon = (struct thermal_hwmon_device *)((void *)0);
  device_remove_file(hwmon->device, & tz->temp_input.attr);
  device_remove_file(hwmon->device, & tz->temp_crit.attr);
  mutex_lock(& thermal_list_lock);
  list_del(& tz->hwmon_node);
  tmp = list_empty((struct list_head  const  *)(& hwmon->tz_list));
  }
  if (! tmp) {
    {
    mutex_unlock(& thermal_list_lock);
    }
    return;
  }
  {
  list_del(& hwmon->node);
  mutex_unlock(& thermal_list_lock);
  device_remove_file(hwmon->device, & dev_attr_name);
  hwmon_device_unregister(hwmon->device);
  kfree((void const   *)hwmon);
  }
  return;
}
}
int thermal_zone_bind_cooling_device(struct thermal_zone_device *tz , int trip , struct thermal_cooling_device *cdev ) 
{ struct thermal_cooling_device_instance *dev ;
  struct thermal_cooling_device_instance *pos ;
  struct thermal_zone_device *pos1 ;
  struct thermal_cooling_device *pos2 ;
  int result ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  void *tmp ;
  struct list_head  const  *__mptr___3 ;
  struct list_head  const  *__mptr___4 ;

  {
  if (trip >= tz->trips) {
    return (-22);
  } else {
    if (trip < 0) {
      if (trip != -1) {
        return (-22);
      }
    }
  }
  {
  __mptr = (struct list_head  const  *)thermal_tz_list.next;
  pos1 = (struct thermal_zone_device *)((char *)__mptr - (unsigned int )(& ((struct thermal_zone_device *)0)->node));
  }
  {
  while (1) {
    while_1_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)pos1->node.next);
    }
    if (! ((unsigned int )(& pos1->node) != (unsigned int )(& thermal_tz_list))) {
      goto while_1_break;
    }
    if ((unsigned int )pos1 == (unsigned int )tz) {
      goto while_1_break;
    }
    {
    __mptr___0 = (struct list_head  const  *)pos1->node.next;
    pos1 = (struct thermal_zone_device *)((char *)__mptr___0 - (unsigned int )(& ((struct thermal_zone_device *)0)->node));
    }
  }
  while_1_break: /* CIL Label */ ;
  }
  {
  __mptr___1 = (struct list_head  const  *)thermal_cdev_list.next;
  pos2 = (struct thermal_cooling_device *)((char *)__mptr___1 - (unsigned int )(& ((struct thermal_cooling_device *)0)->node));
  }
  {
  while (1) {
    while_2_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)pos2->node.next);
    }
    if (! ((unsigned int )(& pos2->node) != (unsigned int )(& thermal_cdev_list))) {
      goto while_2_break;
    }
    if ((unsigned int )pos2 == (unsigned int )cdev) {
      goto while_2_break;
    }
    {
    __mptr___2 = (struct list_head  const  *)pos2->node.next;
    pos2 = (struct thermal_cooling_device *)((char *)__mptr___2 - (unsigned int )(& ((struct thermal_cooling_device *)0)->node));
    }
  }
  while_2_break: /* CIL Label */ ;
  }
  if ((unsigned int )tz != (unsigned int )pos1) {
    return (-22);
  } else {
    if ((unsigned int )cdev != (unsigned int )pos2) {
      return (-22);
    }
  }
  {
  tmp = kzalloc(sizeof(struct thermal_cooling_device_instance ), 208U);
  dev = (struct thermal_cooling_device_instance *)tmp;
  }
  if (! dev) {
    return (-12);
  }
  {
  dev->tz = tz;
  dev->cdev = cdev;
  dev->trip = trip;
  result = get_idr(& tz->idr, & tz->lock, & dev->id);
  }
  if (result) {
    goto free_mem;
  }
  {
  sprintf(dev->name, "cdev%d", dev->id);
  result = sysfs_create_link(& tz->device.kobj, & cdev->device.kobj, (char const   *)(dev->name));
  }
  if (result) {
    goto release_idr;
  }
  {
  sprintf(dev->attr_name, "cdev%d_trip_point", dev->id);
  dev->attr.attr.name = (char const   *)(dev->attr_name);
  dev->attr.attr.mode = (unsigned short)292;
  dev->attr.show = & thermal_cooling_device_trip_point_show;
  result = device_create_file(& tz->device, & dev->attr);
  }
  if (result) {
    goto remove_symbol_link;
  }
  {
  mutex_lock(& tz->lock);
  __mptr___3 = (struct list_head  const  *)tz->cooling_devices.next;
  pos = (struct thermal_cooling_device_instance *)((char *)__mptr___3 - (unsigned int )(& ((struct thermal_cooling_device_instance *)0)->node));
  }
  {
  while (1) {
    while_3_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)pos->node.next);
    }
    if (! ((unsigned int )(& pos->node) != (unsigned int )(& tz->cooling_devices))) {
      goto while_3_break;
    }
    if ((unsigned int )pos->tz == (unsigned int )tz) {
      if (pos->trip == trip) {
        if ((unsigned int )pos->cdev == (unsigned int )cdev) {
          {
          result = -17;
          }
          goto while_3_break;
        }
      }
    }
    {
    __mptr___4 = (struct list_head  const  *)pos->node.next;
    pos = (struct thermal_cooling_device_instance *)((char *)__mptr___4 - (unsigned int )(& ((struct thermal_cooling_device_instance *)0)->node));
    }
  }
  while_3_break: /* CIL Label */ ;
  }
  if (! result) {
    {
    list_add_tail(& dev->node, & tz->cooling_devices);
    }
  }
  {
  mutex_unlock(& tz->lock);
  }
  if (! result) {
    return (0);
  }
  {
  device_remove_file(& tz->device, & dev->attr);
  }
  remove_symbol_link: 
  {
  sysfs_remove_link(& tz->device.kobj, (char const   *)(dev->name));
  }
  release_idr: 
  {
  release_idr(& tz->idr, & tz->lock, dev->id);
  }
  free_mem: 
  {
  kfree((void const   *)dev);
  }
  return (result);
}
}
extern void *__crc_thermal_zone_bind_cooling_device  __attribute__((__weak__)) ;
static unsigned long const   __kcrctab_thermal_zone_bind_cooling_device  __attribute__((__used__,
__unused__, __section__("__kcrctab")))  =    (unsigned long const   )((unsigned long )(& __crc_thermal_zone_bind_cooling_device));
static char const   __kstrtab_thermal_zone_bind_cooling_device[33]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'t',      (char const   )'h',      (char const   )'e',      (char const   )'r', 
        (char const   )'m',      (char const   )'a',      (char const   )'l',      (char const   )'_', 
        (char const   )'z',      (char const   )'o',      (char const   )'n',      (char const   )'e', 
        (char const   )'_',      (char const   )'b',      (char const   )'i',      (char const   )'n', 
        (char const   )'d',      (char const   )'_',      (char const   )'c',      (char const   )'o', 
        (char const   )'o',      (char const   )'l',      (char const   )'i',      (char const   )'n', 
        (char const   )'g',      (char const   )'_',      (char const   )'d',      (char const   )'e', 
        (char const   )'v',      (char const   )'i',      (char const   )'c',      (char const   )'e', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_thermal_zone_bind_cooling_device  __attribute__((__used__,
__unused__, __section__("__ksymtab")))  =    {(unsigned long )(& thermal_zone_bind_cooling_device), __kstrtab_thermal_zone_bind_cooling_device};
int thermal_zone_unbind_cooling_device(struct thermal_zone_device *tz ,
                                       int trip , struct thermal_cooling_device *cdev ) 
{ struct thermal_cooling_device_instance *pos ;
  struct thermal_cooling_device_instance *next ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
  {
  mutex_lock(& tz->lock);
  __mptr = (struct list_head  const  *)tz->cooling_devices.next;
  pos = (struct thermal_cooling_device_instance *)((char *)__mptr - (unsigned int )(& ((struct thermal_cooling_device_instance *)0)->node));
  __mptr___0 = (struct list_head  const  *)pos->node.next;
  next = (struct thermal_cooling_device_instance *)((char *)__mptr___0 - (unsigned int )(& ((struct thermal_cooling_device_instance *)0)->node));
  }
  {
  while (1) {
    while_4_continue: /* CIL Label */ ;
    if (! ((unsigned int )(& pos->node) != (unsigned int )(& tz->cooling_devices))) {
      goto while_4_break;
    }
    if ((unsigned int )pos->tz == (unsigned int )tz) {
      if (pos->trip == trip) {
        if ((unsigned int )pos->cdev == (unsigned int )cdev) {
          {
          list_del(& pos->node);
          mutex_unlock(& tz->lock);
          }
          goto unbind;
        }
      }
    }
    {
    pos = next;
    __mptr___1 = (struct list_head  const  *)next->node.next;
    next = (struct thermal_cooling_device_instance *)((char *)__mptr___1 - (unsigned int )(& ((struct thermal_cooling_device_instance *)0)->node));
    }
  }
  while_4_break: /* CIL Label */ ;
  }
  {
  mutex_unlock(& tz->lock);
  }
  return (-19);
  unbind: 
  {
  device_remove_file(& tz->device, & pos->attr);
  sysfs_remove_link(& tz->device.kobj, (char const   *)(pos->name));
  release_idr(& tz->idr, & tz->lock, pos->id);
  kfree((void const   *)pos);
  }
  return (0);
}
}
extern void *__crc_thermal_zone_unbind_cooling_device  __attribute__((__weak__)) ;
static unsigned long const   __kcrctab_thermal_zone_unbind_cooling_device  __attribute__((__used__,
__unused__, __section__("__kcrctab")))  =    (unsigned long const   )((unsigned long )(& __crc_thermal_zone_unbind_cooling_device));
static char const   __kstrtab_thermal_zone_unbind_cooling_device[35]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'t',      (char const   )'h',      (char const   )'e',      (char const   )'r', 
        (char const   )'m',      (char const   )'a',      (char const   )'l',      (char const   )'_', 
        (char const   )'z',      (char const   )'o',      (char const   )'n',      (char const   )'e', 
        (char const   )'_',      (char const   )'u',      (char const   )'n',      (char const   )'b', 
        (char const   )'i',      (char const   )'n',      (char const   )'d',      (char const   )'_', 
        (char const   )'c',      (char const   )'o',      (char const   )'o',      (char const   )'l', 
        (char const   )'i',      (char const   )'n',      (char const   )'g',      (char const   )'_', 
        (char const   )'d',      (char const   )'e',      (char const   )'v',      (char const   )'i', 
        (char const   )'c',      (char const   )'e',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_thermal_zone_unbind_cooling_device  __attribute__((__used__,
__unused__, __section__("__ksymtab")))  =    {(unsigned long )(& thermal_zone_unbind_cooling_device), __kstrtab_thermal_zone_unbind_cooling_device};
static void thermal_release(struct device *dev ) 
{ struct thermal_zone_device *tz ;
  struct thermal_cooling_device *cdev ;
  struct device  const  *__mptr ;
  struct device  const  *__mptr___0 ;
  int tmp ;

  {
  {
  tmp = strncmp((char const   *)(dev->bus_id), "thermal_zone", sizeof("thermal_zone") - 1U);
  }
  if (tmp) {
    {
    __mptr___0 = (struct device  const  *)dev;
    cdev = (struct thermal_cooling_device *)((char *)__mptr___0 - (unsigned int )(& ((struct thermal_cooling_device *)0)->device));
    kfree((void const   *)cdev);
    }
  } else {
    {
    __mptr = (struct device  const  *)dev;
    tz = (struct thermal_zone_device *)((char *)__mptr - (unsigned int )(& ((struct thermal_zone_device *)0)->device));
    kfree((void const   *)tz);
    }
  }
  return;
}
}
static struct class thermal_class  = 
     {"thermal", (struct module *)0, (struct class_attribute *)0, (struct device_attribute *)0,
    (struct kobject *)0, (int (*)(struct device *dev , struct kobj_uevent_env *env ))0,
    (void (*)(struct class *class ))0, & thermal_release, (int (*)(struct device *dev ,
                                                                   pm_message_t state ))0,
    (int (*)(struct device *dev ))0, (struct pm_ops *)0, (struct class_private *)0};
struct thermal_cooling_device *thermal_cooling_device_register(char *type ,
                                                               void *devdata , struct thermal_cooling_device_ops *ops ) 
{ struct thermal_cooling_device *cdev ;
  struct thermal_zone_device *pos ;
  int result ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  void *tmp___6 ;

  {
  {
  tmp___0 = strlen((char const   *)type);
  }
  if (tmp___0 >= 20U) {
    {
    tmp = ERR_PTR(-22L);
    }
    return ((struct thermal_cooling_device *)tmp);
  }
  if (! ops) {
    {
    tmp___1 = ERR_PTR(-22L);
    }
    return ((struct thermal_cooling_device *)tmp___1);
  } else {
    if (! ops->get_max_state) {
      {
      tmp___1 = ERR_PTR(-22L);
      }
      return ((struct thermal_cooling_device *)tmp___1);
    } else {
      if (! ops->get_cur_state) {
        {
        tmp___1 = ERR_PTR(-22L);
        }
        return ((struct thermal_cooling_device *)tmp___1);
      } else {
        if (! ops->set_cur_state) {
          {
          tmp___1 = ERR_PTR(-22L);
          }
          return ((struct thermal_cooling_device *)tmp___1);
        }
      }
    }
  }
  {
  tmp___2 = kzalloc(sizeof(struct thermal_cooling_device ), 208U);
  cdev = (struct thermal_cooling_device *)tmp___2;
  }
  if (! cdev) {
    {
    tmp___3 = ERR_PTR(-12L);
    }
    return ((struct thermal_cooling_device *)tmp___3);
  }
  {
  result = get_idr(& thermal_cdev_idr, & thermal_idr_lock, & cdev->id);
  }
  if (result) {
    {
    kfree((void const   *)cdev);
    tmp___4 = ERR_PTR((long )result);
    }
    return ((struct thermal_cooling_device *)tmp___4);
  }
  {
  strcpy(cdev->type, (char const   *)type);
  cdev->ops = ops;
  cdev->device.class = & thermal_class;
  cdev->devdata = devdata;
  sprintf(cdev->device.bus_id, "cooling_device%d", cdev->id);
  result = device_register(& cdev->device);
  }
  if (result) {
    {
    release_idr(& thermal_cdev_idr, & thermal_idr_lock, cdev->id);
    kfree((void const   *)cdev);
    tmp___5 = ERR_PTR((long )result);
    }
    return ((struct thermal_cooling_device *)tmp___5);
  }
  if (type) {
    {
    result = device_create_file(& cdev->device, & dev_attr_cdev_type);
    }
    if (result) {
      goto unregister;
    }
  }
  {
  result = device_create_file(& cdev->device, & dev_attr_max_state);
  }
  if (result) {
    goto unregister;
  }
  {
  result = device_create_file(& cdev->device, & dev_attr_cur_state);
  }
  if (result) {
    goto unregister;
  }
  {
  mutex_lock(& thermal_list_lock);
  list_add(& cdev->node, & thermal_cdev_list);
  __mptr = (struct list_head  const  *)thermal_tz_list.next;
  pos = (struct thermal_zone_device *)((char *)__mptr - (unsigned int )(& ((struct thermal_zone_device *)0)->node));
  }
  {
  while (1) {
    while_5_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)pos->node.next);
    }
    if (! ((unsigned int )(& pos->node) != (unsigned int )(& thermal_tz_list))) {
      goto while_5_break;
    }
    if (! (pos->ops)->bind) {
      goto __Cont;
    }
    {
    result = (*((pos->ops)->bind))(pos, cdev);
    }
    if (result) {
      goto while_5_break;
    }
    __Cont: /* CIL Label */ 
    {
    __mptr___0 = (struct list_head  const  *)pos->node.next;
    pos = (struct thermal_zone_device *)((char *)__mptr___0 - (unsigned int )(& ((struct thermal_zone_device *)0)->node));
    }
  }
  while_5_break: /* CIL Label */ ;
  }
  {
  mutex_unlock(& thermal_list_lock);
  }
  if (! result) {
    return (cdev);
  }
  unregister: 
  {
  release_idr(& thermal_cdev_idr, & thermal_idr_lock, cdev->id);
  device_unregister(& cdev->device);
  tmp___6 = ERR_PTR((long )result);
  }
  return ((struct thermal_cooling_device *)tmp___6);
}
}
extern void *__crc_thermal_cooling_device_register  __attribute__((__weak__)) ;
static unsigned long const   __kcrctab_thermal_cooling_device_register  __attribute__((__used__,
__unused__, __section__("__kcrctab")))  =    (unsigned long const   )((unsigned long )(& __crc_thermal_cooling_device_register));
static char const   __kstrtab_thermal_cooling_device_register[32]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'t',      (char const   )'h',      (char const   )'e',      (char const   )'r', 
        (char const   )'m',      (char const   )'a',      (char const   )'l',      (char const   )'_', 
        (char const   )'c',      (char const   )'o',      (char const   )'o',      (char const   )'l', 
        (char const   )'i',      (char const   )'n',      (char const   )'g',      (char const   )'_', 
        (char const   )'d',      (char const   )'e',      (char const   )'v',      (char const   )'i', 
        (char const   )'c',      (char const   )'e',      (char const   )'_',      (char const   )'r', 
        (char const   )'e',      (char const   )'g',      (char const   )'i',      (char const   )'s', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_thermal_cooling_device_register  __attribute__((__used__,
__unused__, __section__("__ksymtab")))  =    {(unsigned long )(& thermal_cooling_device_register), __kstrtab_thermal_cooling_device_register};
void thermal_cooling_device_unregister(struct thermal_cooling_device *cdev ) 
{ struct thermal_zone_device *tz ;
  struct thermal_cooling_device *pos ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;

  {
  {
  pos = (struct thermal_cooling_device *)((void *)0);
  }
  if (! cdev) {
    return;
  }
  {
  mutex_lock(& thermal_list_lock);
  __mptr = (struct list_head  const  *)thermal_cdev_list.next;
  pos = (struct thermal_cooling_device *)((char *)__mptr - (unsigned int )(& ((struct thermal_cooling_device *)0)->node));
  }
  {
  while (1) {
    while_6_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)pos->node.next);
    }
    if (! ((unsigned int )(& pos->node) != (unsigned int )(& thermal_cdev_list))) {
      goto while_6_break;
    }
    if ((unsigned int )pos == (unsigned int )cdev) {
      goto while_6_break;
    }
    {
    __mptr___0 = (struct list_head  const  *)pos->node.next;
    pos = (struct thermal_cooling_device *)((char *)__mptr___0 - (unsigned int )(& ((struct thermal_cooling_device *)0)->node));
    }
  }
  while_6_break: /* CIL Label */ ;
  }
  if ((unsigned int )pos != (unsigned int )cdev) {
    {
    mutex_unlock(& thermal_list_lock);
    }
    return;
  }
  {
  list_del(& cdev->node);
  __mptr___1 = (struct list_head  const  *)thermal_tz_list.next;
  tz = (struct thermal_zone_device *)((char *)__mptr___1 - (unsigned int )(& ((struct thermal_zone_device *)0)->node));
  }
  {
  while (1) {
    while_7_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)tz->node.next);
    }
    if (! ((unsigned int )(& tz->node) != (unsigned int )(& thermal_tz_list))) {
      goto while_7_break;
    }
    if (! (tz->ops)->unbind) {
      goto __Cont;
    }
    {
    (*((tz->ops)->unbind))(tz, cdev);
    }
    __Cont: /* CIL Label */ 
    {
    __mptr___2 = (struct list_head  const  *)tz->node.next;
    tz = (struct thermal_zone_device *)((char *)__mptr___2 - (unsigned int )(& ((struct thermal_zone_device *)0)->node));
    }
  }
  while_7_break: /* CIL Label */ ;
  }
  {
  mutex_unlock(& thermal_list_lock);
  }
  if (cdev->type[0]) {
    {
    device_remove_file(& cdev->device, & dev_attr_cdev_type);
    }
  }
  {
  device_remove_file(& cdev->device, & dev_attr_max_state);
  device_remove_file(& cdev->device, & dev_attr_cur_state);
  release_idr(& thermal_cdev_idr, & thermal_idr_lock, cdev->id);
  device_unregister(& cdev->device);
  }
  return;
}
}
extern void *__crc_thermal_cooling_device_unregister  __attribute__((__weak__)) ;
static unsigned long const   __kcrctab_thermal_cooling_device_unregister  __attribute__((__used__,
__unused__, __section__("__kcrctab")))  =    (unsigned long const   )((unsigned long )(& __crc_thermal_cooling_device_unregister));
static char const   __kstrtab_thermal_cooling_device_unregister[34]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'t',      (char const   )'h',      (char const   )'e',      (char const   )'r', 
        (char const   )'m',      (char const   )'a',      (char const   )'l',      (char const   )'_', 
        (char const   )'c',      (char const   )'o',      (char const   )'o',      (char const   )'l', 
        (char const   )'i',      (char const   )'n',      (char const   )'g',      (char const   )'_', 
        (char const   )'d',      (char const   )'e',      (char const   )'v',      (char const   )'i', 
        (char const   )'c',      (char const   )'e',      (char const   )'_',      (char const   )'u', 
        (char const   )'n',      (char const   )'r',      (char const   )'e',      (char const   )'g', 
        (char const   )'i',      (char const   )'s',      (char const   )'t',      (char const   )'e', 
        (char const   )'r',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_thermal_cooling_device_unregister  __attribute__((__used__,
__unused__, __section__("__ksymtab")))  =    {(unsigned long )(& thermal_cooling_device_unregister), __kstrtab_thermal_cooling_device_unregister};
static struct lock_class_key __key___0  ;
struct thermal_zone_device *thermal_zone_device_register(char *type , int trips ,
                                                         void *devdata , struct thermal_zone_device_ops *ops ) 
{ struct thermal_zone_device *tz ;
  struct thermal_cooling_device *pos ;
  int result ;
  int count ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  void *tmp___7 ;

  {
  {
  tmp___0 = strlen((char const   *)type);
  }
  if (tmp___0 >= 20U) {
    {
    tmp = ERR_PTR(-22L);
    }
    return ((struct thermal_zone_device *)tmp);
  }
  if (trips > 12) {
    {
    tmp___1 = ERR_PTR(-22L);
    }
    return ((struct thermal_zone_device *)tmp___1);
  } else {
    if (trips < 0) {
      {
      tmp___1 = ERR_PTR(-22L);
      }
      return ((struct thermal_zone_device *)tmp___1);
    }
  }
  if (! ops) {
    {
    tmp___2 = ERR_PTR(-22L);
    }
    return ((struct thermal_zone_device *)tmp___2);
  } else {
    if (! ops->get_temp) {
      {
      tmp___2 = ERR_PTR(-22L);
      }
      return ((struct thermal_zone_device *)tmp___2);
    }
  }
  {
  tmp___3 = kzalloc(sizeof(struct thermal_zone_device ), 208U);
  tz = (struct thermal_zone_device *)tmp___3;
  }
  if (! tz) {
    {
    tmp___4 = ERR_PTR(-12L);
    }
    return ((struct thermal_zone_device *)tmp___4);
  }
  {
  INIT_LIST_HEAD(& tz->cooling_devices);
  idr_init(& tz->idr);
  }
  {
  while (1) {
    while_8_continue: /* CIL Label */ ;
    {
    __mutex_init(& tz->lock, "&tz->lock", & __key___0);
    }
    goto while_8_break;
  }
  while_8_break: /* CIL Label */ ;
  }
  {
  result = get_idr(& thermal_tz_idr, & thermal_idr_lock, & tz->id);
  }
  if (result) {
    {
    kfree((void const   *)tz);
    tmp___5 = ERR_PTR((long )result);
    }
    return ((struct thermal_zone_device *)tmp___5);
  }
  {
  strcpy(tz->type, (char const   *)type);
  tz->ops = ops;
  tz->device.class = & thermal_class;
  tz->devdata = devdata;
  tz->trips = trips;
  sprintf(tz->device.bus_id, "thermal_zone%d", tz->id);
  result = device_register(& tz->device);
  }
  if (result) {
    {
    release_idr(& thermal_tz_idr, & thermal_idr_lock, tz->id);
    kfree((void const   *)tz);
    tmp___6 = ERR_PTR((long )result);
    }
    return ((struct thermal_zone_device *)tmp___6);
  }
  if (type) {
    {
    result = device_create_file(& tz->device, & dev_attr_type);
    }
    if (result) {
      goto unregister;
    }
  }
  {
  result = device_create_file(& tz->device, & dev_attr_temp);
  }
  if (result) {
    goto unregister;
  }
  if (ops->get_mode) {
    {
    result = device_create_file(& tz->device, & dev_attr_mode);
    }
    if (result) {
      goto unregister;
    }
  }
  {
  count = 0;
  }
  {
  while (1) {
    while_9_continue: /* CIL Label */ ;
    if (! (count < trips)) {
      goto while_9_break;
    }
    {
    while (1) {
      while_10_continue: /* CIL Label */ ;
      {
      result = device_create_file(& tz->device, & trip_point_attrs[count * 2]);
      }
      if (result) {
        goto while_10_break;
      }
      {
      result = device_create_file(& tz->device, & trip_point_attrs[count * 2 + 1]);
      }
      goto while_10_break;
    }
    while_10_break: /* CIL Label */ ;
    }
    if (result) {
      goto unregister;
    }
    {
    count ++;
    }
  }
  while_9_break: /* CIL Label */ ;
  }
  {
  result = thermal_add_hwmon_sysfs(tz);
  }
  if (result) {
    goto unregister;
  }
  {
  mutex_lock(& thermal_list_lock);
  list_add_tail(& tz->node, & thermal_tz_list);
  }
  if (ops->bind) {
    {
    __mptr = (struct list_head  const  *)thermal_cdev_list.next;
    pos = (struct thermal_cooling_device *)((char *)__mptr - (unsigned int )(& ((struct thermal_cooling_device *)0)->node));
    }
    {
    while (1) {
      while_11_continue: /* CIL Label */ ;
      {
      prefetch((void const   *)pos->node.next);
      }
      if (! ((unsigned int )(& pos->node) != (unsigned int )(& thermal_cdev_list))) {
        goto while_11_break;
      }
      {
      result = (*(ops->bind))(tz, pos);
      }
      if (result) {
        goto while_11_break;
      }
      {
      __mptr___0 = (struct list_head  const  *)pos->node.next;
      pos = (struct thermal_cooling_device *)((char *)__mptr___0 - (unsigned int )(& ((struct thermal_cooling_device *)0)->node));
      }
    }
    while_11_break: /* CIL Label */ ;
    }
  }
  {
  mutex_unlock(& thermal_list_lock);
  }
  if (! result) {
    return (tz);
  }
  unregister: 
  {
  release_idr(& thermal_tz_idr, & thermal_idr_lock, tz->id);
  device_unregister(& tz->device);
  tmp___7 = ERR_PTR((long )result);
  }
  return ((struct thermal_zone_device *)tmp___7);
}
}
extern void *__crc_thermal_zone_device_register  __attribute__((__weak__)) ;
static unsigned long const   __kcrctab_thermal_zone_device_register  __attribute__((__used__,
__unused__, __section__("__kcrctab")))  =    (unsigned long const   )((unsigned long )(& __crc_thermal_zone_device_register));
static char const   __kstrtab_thermal_zone_device_register[29]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'t',      (char const   )'h',      (char const   )'e',      (char const   )'r', 
        (char const   )'m',      (char const   )'a',      (char const   )'l',      (char const   )'_', 
        (char const   )'z',      (char const   )'o',      (char const   )'n',      (char const   )'e', 
        (char const   )'_',      (char const   )'d',      (char const   )'e',      (char const   )'v', 
        (char const   )'i',      (char const   )'c',      (char const   )'e',      (char const   )'_', 
        (char const   )'r',      (char const   )'e',      (char const   )'g',      (char const   )'i', 
        (char const   )'s',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_thermal_zone_device_register  __attribute__((__used__,
__unused__, __section__("__ksymtab")))  =    {(unsigned long )(& thermal_zone_device_register), __kstrtab_thermal_zone_device_register};
void thermal_zone_device_unregister(struct thermal_zone_device *tz ) 
{ struct thermal_cooling_device *cdev ;
  struct thermal_zone_device *pos ;
  int count ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;

  {
  {
  pos = (struct thermal_zone_device *)((void *)0);
  }
  if (! tz) {
    return;
  }
  {
  mutex_lock(& thermal_list_lock);
  __mptr = (struct list_head  const  *)thermal_tz_list.next;
  pos = (struct thermal_zone_device *)((char *)__mptr - (unsigned int )(& ((struct thermal_zone_device *)0)->node));
  }
  {
  while (1) {
    while_12_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)pos->node.next);
    }
    if (! ((unsigned int )(& pos->node) != (unsigned int )(& thermal_tz_list))) {
      goto while_12_break;
    }
    if ((unsigned int )pos == (unsigned int )tz) {
      goto while_12_break;
    }
    {
    __mptr___0 = (struct list_head  const  *)pos->node.next;
    pos = (struct thermal_zone_device *)((char *)__mptr___0 - (unsigned int )(& ((struct thermal_zone_device *)0)->node));
    }
  }
  while_12_break: /* CIL Label */ ;
  }
  if ((unsigned int )pos != (unsigned int )tz) {
    {
    mutex_unlock(& thermal_list_lock);
    }
    return;
  }
  {
  list_del(& tz->node);
  }
  if ((tz->ops)->unbind) {
    {
    __mptr___1 = (struct list_head  const  *)thermal_cdev_list.next;
    cdev = (struct thermal_cooling_device *)((char *)__mptr___1 - (unsigned int )(& ((struct thermal_cooling_device *)0)->node));
    }
    {
    while (1) {
      while_13_continue: /* CIL Label */ ;
      {
      prefetch((void const   *)cdev->node.next);
      }
      if (! ((unsigned int )(& cdev->node) != (unsigned int )(& thermal_cdev_list))) {
        goto while_13_break;
      }
      {
      (*((tz->ops)->unbind))(tz, cdev);
      __mptr___2 = (struct list_head  const  *)cdev->node.next;
      cdev = (struct thermal_cooling_device *)((char *)__mptr___2 - (unsigned int )(& ((struct thermal_cooling_device *)0)->node));
      }
    }
    while_13_break: /* CIL Label */ ;
    }
  }
  {
  mutex_unlock(& thermal_list_lock);
  }
  if (tz->type[0]) {
    {
    device_remove_file(& tz->device, & dev_attr_type);
    }
  }
  {
  device_remove_file(& tz->device, & dev_attr_temp);
  }
  if ((tz->ops)->get_mode) {
    {
    device_remove_file(& tz->device, & dev_attr_mode);
    }
  }
  {
  count = 0;
  }
  {
  while (1) {
    while_14_continue: /* CIL Label */ ;
    if (! (count < tz->trips)) {
      goto while_14_break;
    }
    {
    while (1) {
      while_15_continue: /* CIL Label */ ;
      {
      device_remove_file(& tz->device, & trip_point_attrs[count * 2]);
      device_remove_file(& tz->device, & trip_point_attrs[count * 2 + 1]);
      }
      goto while_15_break;
    }
    while_15_break: /* CIL Label */ ;
    }
    {
    count ++;
    }
  }
  while_14_break: /* CIL Label */ ;
  }
  {
  thermal_remove_hwmon_sysfs(tz);
  release_idr(& thermal_tz_idr, & thermal_idr_lock, tz->id);
  idr_destroy(& tz->idr);
  }
  {
  while (1) {
    while_16_continue: /* CIL Label */ ;
    goto while_16_break;
  }
  while_16_break: /* CIL Label */ ;
  }
  {
  device_unregister(& tz->device);
  }
  return;
}
}
extern void *__crc_thermal_zone_device_unregister  __attribute__((__weak__)) ;
static unsigned long const   __kcrctab_thermal_zone_device_unregister  __attribute__((__used__,
__unused__, __section__("__kcrctab")))  =    (unsigned long const   )((unsigned long )(& __crc_thermal_zone_device_unregister));
static char const   __kstrtab_thermal_zone_device_unregister[31]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'t',      (char const   )'h',      (char const   )'e',      (char const   )'r', 
        (char const   )'m',      (char const   )'a',      (char const   )'l',      (char const   )'_', 
        (char const   )'z',      (char const   )'o',      (char const   )'n',      (char const   )'e', 
        (char const   )'_',      (char const   )'d',      (char const   )'e',      (char const   )'v', 
        (char const   )'i',      (char const   )'c',      (char const   )'e',      (char const   )'_', 
        (char const   )'u',      (char const   )'n',      (char const   )'r',      (char const   )'e', 
        (char const   )'g',      (char const   )'i',      (char const   )'s',      (char const   )'t', 
        (char const   )'e',      (char const   )'r',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_thermal_zone_device_unregister  __attribute__((__used__,
__unused__, __section__("__ksymtab")))  =    {(unsigned long )(& thermal_zone_device_unregister), __kstrtab_thermal_zone_device_unregister};
static struct lock_class_key __key___1  ;
static int __attribute__((__cold__))  thermal_init(void)  __attribute__((__section__(".init.text"))) ;
static int __attribute__((__cold__))  thermal_init(void) 
{ int result ;
  int tmp ;

  {
  {
  result = 0;
  tmp = __class_register(& thermal_class, & __key___1);
  result = tmp;
  }
  if (result) {
    {
    idr_destroy(& thermal_tz_idr);
    idr_destroy(& thermal_cdev_idr);
    }
    {
    while (1) {
      while_17_continue: /* CIL Label */ ;
      goto while_17_break;
    }
    while_17_break: /* CIL Label */ ;
    }
    {
    while (1) {
      while_18_continue: /* CIL Label */ ;
      goto while_18_break;
    }
    while_18_break: /* CIL Label */ ;
    }
  }
  return ((int __attribute__((__cold__))  )result);
}
}
static void __attribute__((__cold__))  thermal_exit(void)  __attribute__((__used__,
__section__(".exit.text"))) ;
static void __attribute__((__cold__))  thermal_exit(void) 
{ 

  {
  {
  class_unregister(& thermal_class);
  idr_destroy(& thermal_tz_idr);
  idr_destroy(& thermal_cdev_idr);
  }
  {
  while (1) {
    while_19_continue: /* CIL Label */ ;
    goto while_19_break;
  }
  while_19_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_20_continue: /* CIL Label */ ;
    goto while_20_break;
  }
  while_20_break: /* CIL Label */ ;
  }
  return;
}
}
static int (*__initcall_thermal_init4)(void)  __attribute__((__used__, __section__(".initcall4.init")))  =    (int (*)(void))(& thermal_init);
static void (*__exitcall_thermal_exit)(void)  __attribute__((__used__,
__section__(".exitcall.exit")))  =    (void (*)(void))(& thermal_exit);
