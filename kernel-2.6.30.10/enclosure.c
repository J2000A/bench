/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

typedef unsigned short __kernel_mode_t;
typedef unsigned int __kernel_size_t;
typedef int __kernel_ssize_t;
typedef unsigned short __u16;
typedef unsigned int __u32;
typedef unsigned long long u64;
typedef __u32 __kernel_dev_t;
typedef __kernel_dev_t dev_t;
typedef __kernel_mode_t mode_t;
typedef __kernel_size_t size_t;
typedef __kernel_ssize_t ssize_t;
typedef unsigned int gfp_t;
struct device;
struct device;
struct task_struct;
struct task_struct;
struct task_struct;
struct task_struct;
struct task_struct;
struct module;
struct module;
typedef __builtin_va_list __gnuc_va_list;
typedef __gnuc_va_list va_list;
struct bug_entry {
   unsigned long bug_addr ;
   char const   *file ;
   unsigned short line ;
   unsigned short flags ;
};
struct completion;
struct completion;
struct raw_spinlock;
struct raw_spinlock;
struct task_struct;
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
struct __anonstruct_atomic_t_27 {
   int counter ;
};
typedef struct __anonstruct_atomic_t_27 atomic_t;
typedef atomic_t atomic_long_t;
struct kobject;
struct kobject;
struct module;
struct attribute {
   char const   *name ;
   struct module *owner ;
   mode_t mode ;
};
struct attribute_group {
   char const   *name ;
   mode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
};
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
struct task_struct;
struct raw_spinlock {
   unsigned int slock ;
};
typedef struct raw_spinlock raw_spinlock_t;
struct task_struct;
struct lock_class_key {

};
struct __anonstruct_spinlock_t_33 {
   raw_spinlock_t raw_lock ;
};
typedef struct __anonstruct_spinlock_t_33 spinlock_t;
struct kref {
   atomic_t refcount ;
};
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
typedef struct __wait_queue_head wait_queue_head_t;
struct task_struct;
struct kset;
struct kobj_type;
struct sysfs_dirent;
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct sysfs_dirent *sd ;
   struct kref kref ;
   unsigned int state_initialized : 1 ;
   unsigned int state_in_sysfs : 1 ;
   unsigned int state_add_uevent_sent : 1 ;
   unsigned int state_remove_uevent_sent : 1 ;
};
struct kobj_type {
   void (*release)(struct kobject *kobj ) ;
   struct sysfs_ops *sysfs_ops ;
   struct attribute **default_attrs ;
};
struct kobj_uevent_env {
   char *envp[32] ;
   int envp_idx ;
   char buf[2048] ;
   int buflen ;
};
struct kset_uevent_ops {
   int (*filter)(struct kset *kset , struct kobject *kobj ) ;
   char const   *(*name)(struct kset *kset , struct kobject *kobj ) ;
   int (*uevent)(struct kset *kset , struct kobject *kobj , struct kobj_uevent_env *env ) ;
};
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops *uevent_ops ;
};
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
struct klist_node;
struct klist_node;
struct klist {
   spinlock_t k_lock ;
   struct list_head k_list ;
   void (*get)(struct klist_node * ) ;
   void (*put)(struct klist_node * ) ;
};
struct klist_node {
   struct klist *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
   struct completion n_removed ;
};
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
};
struct device;
struct pm_message {
   int event ;
};
typedef struct pm_message pm_message_t;
struct pm_ops {
   int (*prepare)(struct device *dev ) ;
   void (*complete)(struct device *dev ) ;
   int (*suspend)(struct device *dev ) ;
   int (*resume)(struct device *dev ) ;
   int (*freeze)(struct device *dev ) ;
   int (*thaw)(struct device *dev ) ;
   int (*poweroff)(struct device *dev ) ;
   int (*restore)(struct device *dev ) ;
};
struct pm_ext_ops {
   struct pm_ops base ;
   int (*suspend_noirq)(struct device *dev ) ;
   int (*resume_noirq)(struct device *dev ) ;
   int (*freeze_noirq)(struct device *dev ) ;
   int (*thaw_noirq)(struct device *dev ) ;
   int (*poweroff_noirq)(struct device *dev ) ;
   int (*restore_noirq)(struct device *dev ) ;
};
enum dpm_state {
    DPM_INVALID = 0,
    DPM_ON = 1,
    DPM_PREPARING = 2,
    DPM_RESUMING = 3,
    DPM_SUSPENDING = 4,
    DPM_OFF = 5,
    DPM_OFF_IRQ = 6
} ;
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int can_wakeup : 1 ;
   unsigned int should_wakeup : 1 ;
   enum dpm_state status ;
   struct list_head entry ;
};
struct task_struct;
typedef __u32 Elf32_Addr;
typedef __u16 Elf32_Half;
typedef __u32 Elf32_Word;
struct elf32_sym {
   Elf32_Word st_name ;
   Elf32_Addr st_value ;
   Elf32_Word st_size ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf32_Half st_shndx ;
};
typedef struct elf32_sym Elf32_Sym;
struct module;
struct module;
struct marker;
struct marker;
typedef void marker_probe_func(void *probe_private , void *call_private , char const   *fmt ,
                               va_list *args );
struct marker_probe_closure {
   marker_probe_func *func ;
   void *probe_private ;
};
struct marker {
   char const   *name ;
   char const   *format ;
   char state ;
   char ptype ;
   void (*call)(struct marker  const  *mdata , void *call_private  , ...) ;
   struct marker_probe_closure single ;
   struct marker_probe_closure *multi ;
} __attribute__((__aligned__(8))) ;
struct __anonstruct_local_t_98 {
   atomic_long_t a ;
};
typedef struct __anonstruct_local_t_98 local_t;
struct mod_arch_specific {

};
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
struct module;
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module * , char const   * ,
                    size_t count ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
};
struct exception_table_entry;
struct exception_table_entry;
struct module_ref {
   local_t count ;
} __attribute__((__aligned__((1) <<  (7) ))) ;
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2
} ;
struct module_param_attrs;
struct module_sect_attrs;
struct module_notes_attrs;
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[64U - sizeof(unsigned long )] ;
   struct module_kobject mkobj ;
   struct module_param_attrs *param_attrs ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry  const  *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   void *unwind_info ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf32_Sym *symtab ;
   unsigned int num_symtab ;
   char *strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   void *percpu ;
   char *args ;
   struct marker *markers ;
   unsigned int num_markers ;
   struct list_head modules_which_use_me ;
   struct task_struct *waiter ;
   void (*exit)(void) ;
   struct module_ref ref[64] ;
};
struct device_driver;
struct device_driver;
struct module;
struct semaphore {
   spinlock_t lock ;
   unsigned int count ;
   struct list_head wait_list ;
};
struct dev_archdata {
   void *acpi_handle ;
};
struct device;
struct device_driver;
struct driver_private;
struct driver_private;
struct class;
struct class;
struct class_private;
struct class_private;
struct bus_type;
struct bus_type;
struct bus_type_private;
struct bus_type_private;
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type *bus , char *buf ) ;
   ssize_t (*store)(struct bus_type *bus , char const   *buf , size_t count ) ;
};
struct device_attribute;
struct driver_attribute;
struct bus_type {
   char const   *name ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   int (*match)(struct device *dev , struct device_driver *drv ) ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*suspend_late)(struct device *dev , pm_message_t state ) ;
   int (*resume_early)(struct device *dev ) ;
   int (*resume)(struct device *dev ) ;
   struct pm_ext_ops *pm ;
   struct bus_type_private *p ;
};
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct attribute_group **groups ;
   struct pm_ops *pm ;
   struct driver_private *p ;
};
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver *driver , char *buf ) ;
   ssize_t (*store)(struct device_driver *driver , char const   *buf , size_t count ) ;
};
struct class_attribute;
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct device_attribute *dev_attrs ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   void (*class_release)(struct class *class ) ;
   void (*dev_release)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct pm_ops *pm ;
   struct class_private *p ;
};
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class *class , char *buf ) ;
   ssize_t (*store)(struct class *class , char const   *buf , size_t count ) ;
};
struct device_type {
   char const   *name ;
   struct attribute_group **groups ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   void (*release)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct pm_ops *pm ;
};
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device *dev , struct device_attribute *attr , char *buf ) ;
   ssize_t (*store)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                    size_t count ) ;
};
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
struct dma_coherent_mem;
struct device {
   struct klist klist_children ;
   struct klist_node knode_parent ;
   struct klist_node knode_driver ;
   struct klist_node knode_bus ;
   struct device *parent ;
   struct kobject kobj ;
   char bus_id[20] ;
   char const   *init_name ;
   struct device_type *type ;
   unsigned int uevent_suppress : 1 ;
   struct semaphore sem ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *driver_data ;
   void *platform_data ;
   struct dev_pm_info power ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct list_head node ;
   struct class *class ;
   dev_t devt ;
   struct attribute_group **groups ;
   void (*release)(struct device *dev ) ;
};
enum enclosure_component_type {
    ENCLOSURE_COMPONENT_DEVICE = 1,
    ENCLOSURE_COMPONENT_ARRAY_DEVICE = 23
} ;
enum enclosure_status {
    ENCLOSURE_STATUS_UNSUPPORTED = 0,
    ENCLOSURE_STATUS_OK = 1,
    ENCLOSURE_STATUS_CRITICAL = 2,
    ENCLOSURE_STATUS_NON_CRITICAL = 3,
    ENCLOSURE_STATUS_UNRECOVERABLE = 4,
    ENCLOSURE_STATUS_NOT_INSTALLED = 5,
    ENCLOSURE_STATUS_UNKNOWN = 6,
    ENCLOSURE_STATUS_UNAVAILABLE = 7
} ;
enum enclosure_component_setting {
    ENCLOSURE_SETTING_DISABLED = 0,
    ENCLOSURE_SETTING_ENABLED = 1,
    ENCLOSURE_SETTING_BLINK_A_ON_OFF = 2,
    ENCLOSURE_SETTING_BLINK_A_OFF_ON = 3,
    ENCLOSURE_SETTING_BLINK_B_ON_OFF = 6,
    ENCLOSURE_SETTING_BLINK_B_OFF_ON = 7
} ;
struct enclosure_device;
struct enclosure_device;
struct enclosure_component;
struct enclosure_component;
struct enclosure_component_callbacks {
   void (*get_status)(struct enclosure_device * , struct enclosure_component * ) ;
   int (*set_status)(struct enclosure_device * , struct enclosure_component * , enum enclosure_status  ) ;
   void (*get_fault)(struct enclosure_device * , struct enclosure_component * ) ;
   int (*set_fault)(struct enclosure_device * , struct enclosure_component * , enum enclosure_component_setting  ) ;
   void (*get_active)(struct enclosure_device * , struct enclosure_component * ) ;
   int (*set_active)(struct enclosure_device * , struct enclosure_component * , enum enclosure_component_setting  ) ;
   void (*get_locate)(struct enclosure_device * , struct enclosure_component * ) ;
   int (*set_locate)(struct enclosure_device * , struct enclosure_component * , enum enclosure_component_setting  ) ;
};
struct enclosure_component {
   void *scratch ;
   struct device cdev ;
   struct device *dev ;
   enum enclosure_component_type type ;
   int number ;
   int fault ;
   int active ;
   int locate ;
   enum enclosure_status status ;
};
struct enclosure_device {
   void *scratch ;
   struct list_head node ;
   struct device edev ;
   struct enclosure_component_callbacks *cb ;
   int components ;
   struct enclosure_component component[0] ;
};
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
extern unsigned long simple_strtoul(char const   * , char ** , unsigned int  ) ;
extern int ( /* format attribute */  snprintf)(char *buf , size_t size , char const   *fmt 
                                               , ...) ;
extern char *strcpy(char *dest , char const   *src ) ;
extern char *strcat(char *dest , char const   *src ) ;
extern int strncmp(char const   *cs , char const   *ct , size_t count ) ;
extern size_t strlen(char const   *s ) ;
__inline static void prefetch(void const   *x ) 
{ 

  {
  {
  __asm__  volatile   ("661:\n\t"
                       ".byte 0x8d,0x74,0x26,0x00\n"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "prefetchnta (%1)"
                       "\n664:\n"
                       ".previous": : "i" (25), "r" (x));
  }
  return;
}
}
__inline static void __list_add(struct list_head *new , struct list_head *prev , struct list_head *next ) 
{ 

  {
  {
  next->prev = new;
  new->next = next;
  new->prev = prev;
  prev->next = new;
  }
  return;
}
}
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 

  {
  {
  __list_add(new, head->prev, head);
  }
  return;
}
}
__inline static void __list_del(struct list_head *prev , struct list_head *next ) 
{ 

  {
  {
  next->prev = prev;
  prev->next = next;
  }
  return;
}
}
__inline static void list_del(struct list_head *entry ) 
{ 

  {
  {
  __list_del(entry->prev, entry->next);
  entry->next = (struct list_head *)((void *)1048832);
  entry->prev = (struct list_head *)((void *)2097664);
  }
  return;
}
}
extern int sysfs_create_link(struct kobject *kobj , struct kobject *target , char const   *name ) ;
extern void sysfs_remove_link(struct kobject *kobj , char const   *name ) ;
register unsigned long current_stack_pointer  __asm__("esp") __attribute__((__used__))  ;
extern void mutex_lock(struct mutex *lock ) ;
extern void mutex_unlock(struct mutex *lock ) ;
extern void kfree(void const   * ) ;
extern void *__kmalloc(size_t size , gfp_t flags ) ;
__inline static void *( __attribute__((__always_inline__)) kmalloc)(size_t size ,
                                                                    gfp_t flags ) 
{ void *tmp___2 ;

  {
  {
  tmp___2 = __kmalloc(size, flags);
  }
  return (tmp___2);
}
}
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ void *tmp ;

  {
  {
  tmp = kmalloc(size, flags | 32768U);
  }
  return (tmp);
}
}
extern int __class_register(struct class *class , struct lock_class_key *key ) ;
extern void class_unregister(struct class *class ) ;
extern int device_register(struct device *dev ) ;
extern void device_unregister(struct device *dev ) ;
extern int device_add(struct device *dev ) ;
extern void device_del(struct device *dev ) ;
extern struct device *get_device(struct device *dev ) ;
extern void put_device(struct device *dev ) ;
__inline static struct enclosure_device *to_enclosure_device(struct device *dev ) 
{ struct device  const  *__mptr ;

  {
  {
  __mptr = (struct device  const  *)dev;
  }
  return ((struct enclosure_device *)((char *)__mptr - (unsigned int )(& ((struct enclosure_device *)0)->edev)));
}
}
__inline static struct enclosure_component *to_enclosure_component(struct device *dev ) 
{ struct device  const  *__mptr ;

  {
  {
  __mptr = (struct device  const  *)dev;
  }
  return ((struct enclosure_component *)((char *)__mptr - (unsigned int )(& ((struct enclosure_component *)0)->cdev)));
}
}
struct enclosure_device *enclosure_register(struct device *dev , char const   *name ,
                                            int components , struct enclosure_component_callbacks *cb ) ;
void enclosure_unregister(struct enclosure_device *edev ) ;
struct enclosure_component *enclosure_component_register(struct enclosure_device *edev ,
                                                         unsigned int number , enum enclosure_component_type type ,
                                                         char const   *name ) ;
int enclosure_add_device(struct enclosure_device *edev , int component , struct device *dev ) ;
int enclosure_remove_device(struct enclosure_device *edev , int component ) ;
struct enclosure_device *enclosure_find(struct device *dev ) ;
int enclosure_for_each_device(int (*fn)(struct enclosure_device * , void * ) , void *data ) ;
__inline static void *ERR_PTR(long error ) 
{ 

  {
  return ((void *)error);
}
}
static struct list_head container_list  =    {& container_list, & container_list};
static struct mutex container_list_lock  =    {{1}, {{0U}}, {& container_list_lock.wait_list, & container_list_lock.wait_list}};
static struct class enclosure_class ;
struct enclosure_device *enclosure_find(struct device *dev ) 
{ struct enclosure_device *edev ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
  {
  mutex_lock(& container_list_lock);
  __mptr = (struct list_head  const  *)container_list.next;
  edev = (struct enclosure_device *)((char *)__mptr - (unsigned int )(& ((struct enclosure_device *)0)->node));
  }
  {
  while (1) {
    while_0_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)edev->node.next);
    }
    if (! ((unsigned int )(& edev->node) != (unsigned int )(& container_list))) {
      goto while_0_break;
    }
    if ((unsigned int )edev->edev.parent == (unsigned int )dev) {
      {
      get_device(& edev->edev);
      mutex_unlock(& container_list_lock);
      }
      return (edev);
    }
    {
    __mptr___0 = (struct list_head  const  *)edev->node.next;
    edev = (struct enclosure_device *)((char *)__mptr___0 - (unsigned int )(& ((struct enclosure_device *)0)->node));
    }
  }
  while_0_break: /* CIL Label */ ;
  }
  {
  mutex_unlock(& container_list_lock);
  }
  return ((struct enclosure_device *)((void *)0));
}
}
extern void *__crc_enclosure_find  __attribute__((__weak__)) ;
static unsigned long const   __kcrctab_enclosure_find  __attribute__((__used__, __unused__,
__section__("__kcrctab_gpl")))  =    (unsigned long const   )((unsigned long )(& __crc_enclosure_find));
static char const   __kstrtab_enclosure_find[15]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'e',      (char const   )'n',      (char const   )'c',      (char const   )'l', 
        (char const   )'o',      (char const   )'s',      (char const   )'u',      (char const   )'r', 
        (char const   )'e',      (char const   )'_',      (char const   )'f',      (char const   )'i', 
        (char const   )'n',      (char const   )'d',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_enclosure_find  __attribute__((__used__,
__unused__, __section__("__ksymtab_gpl")))  =    {(unsigned long )(& enclosure_find), __kstrtab_enclosure_find};
int enclosure_for_each_device(int (*fn)(struct enclosure_device * , void * ) , void *data ) 
{ int error ;
  struct enclosure_device *edev ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
  {
  error = 0;
  mutex_lock(& container_list_lock);
  __mptr = (struct list_head  const  *)container_list.next;
  edev = (struct enclosure_device *)((char *)__mptr - (unsigned int )(& ((struct enclosure_device *)0)->node));
  }
  {
  while (1) {
    while_1_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)edev->node.next);
    }
    if (! ((unsigned int )(& edev->node) != (unsigned int )(& container_list))) {
      goto while_1_break;
    }
    {
    error = (*fn)(edev, data);
    }
    if (error) {
      goto while_1_break;
    }
    {
    __mptr___0 = (struct list_head  const  *)edev->node.next;
    edev = (struct enclosure_device *)((char *)__mptr___0 - (unsigned int )(& ((struct enclosure_device *)0)->node));
    }
  }
  while_1_break: /* CIL Label */ ;
  }
  {
  mutex_unlock(& container_list_lock);
  }
  return (error);
}
}
extern void *__crc_enclosure_for_each_device  __attribute__((__weak__)) ;
static unsigned long const   __kcrctab_enclosure_for_each_device  __attribute__((__used__,
__unused__, __section__("__kcrctab_gpl")))  =    (unsigned long const   )((unsigned long )(& __crc_enclosure_for_each_device));
static char const   __kstrtab_enclosure_for_each_device[26]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'e',      (char const   )'n',      (char const   )'c',      (char const   )'l', 
        (char const   )'o',      (char const   )'s',      (char const   )'u',      (char const   )'r', 
        (char const   )'e',      (char const   )'_',      (char const   )'f',      (char const   )'o', 
        (char const   )'r',      (char const   )'_',      (char const   )'e',      (char const   )'a', 
        (char const   )'c',      (char const   )'h',      (char const   )'_',      (char const   )'d', 
        (char const   )'e',      (char const   )'v',      (char const   )'i',      (char const   )'c', 
        (char const   )'e',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_enclosure_for_each_device  __attribute__((__used__,
__unused__, __section__("__ksymtab_gpl")))  =    {(unsigned long )(& enclosure_for_each_device), __kstrtab_enclosure_for_each_device};
struct enclosure_device *enclosure_register(struct device *dev ,
                                            char const   *name , int components ,
                                            struct enclosure_component_callbacks *cb ) 
{ struct enclosure_device *edev ;
  void *tmp ;
  int err ;
  int i ;
  long tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
  tmp = kzalloc(sizeof(struct enclosure_device ) + sizeof(struct enclosure_component ) * (unsigned int )components,
                208U);
  edev = (struct enclosure_device *)tmp;
  }
  {
  while (1) {
    while_2_continue: /* CIL Label */ ;
    {
    tmp___0 = __builtin_expect((long )(! (! (! cb))), 0L);
    }
    if (tmp___0) {
      {
      while (1) {
        while_3_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("./misc/enclosure.c"), "i" (112),
                             "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_4_continue: /* CIL Label */ ;
        }
        while_4_break: /* CIL Label */ ;
        }
        goto while_3_break;
      }
      while_3_break: /* CIL Label */ ;
      }
    }
    goto while_2_break;
  }
  while_2_break: /* CIL Label */ ;
  }
  if (! edev) {
    {
    tmp___1 = ERR_PTR(-12L);
    }
    return ((struct enclosure_device *)tmp___1);
  }
  {
  edev->components = components;
  edev->edev.class = & enclosure_class;
  edev->edev.parent = get_device(dev);
  edev->cb = cb;
  snprintf(edev->edev.bus_id, 20U, "%s", name);
  err = device_register(& edev->edev);
  }
  if (err) {
    goto err;
  }
  {
  i = 0;
  }
  {
  while (1) {
    while_5_continue: /* CIL Label */ ;
    if (! (i < components)) {
      goto while_5_break;
    }
    {
    edev->component[i].number = -1;
    i ++;
    }
  }
  while_5_break: /* CIL Label */ ;
  }
  {
  mutex_lock(& container_list_lock);
  list_add_tail(& edev->node, & container_list);
  mutex_unlock(& container_list_lock);
  }
  return (edev);
  err: 
  {
  put_device(edev->edev.parent);
  kfree((void const   *)edev);
  tmp___2 = ERR_PTR((long )err);
  }
  return ((struct enclosure_device *)tmp___2);
}
}
extern void *__crc_enclosure_register  __attribute__((__weak__)) ;
static unsigned long const   __kcrctab_enclosure_register  __attribute__((__used__,
__unused__, __section__("__kcrctab_gpl")))  =    (unsigned long const   )((unsigned long )(& __crc_enclosure_register));
static char const   __kstrtab_enclosure_register[19]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'e',      (char const   )'n',      (char const   )'c',      (char const   )'l', 
        (char const   )'o',      (char const   )'s',      (char const   )'u',      (char const   )'r', 
        (char const   )'e',      (char const   )'_',      (char const   )'r',      (char const   )'e', 
        (char const   )'g',      (char const   )'i',      (char const   )'s',      (char const   )'t', 
        (char const   )'e',      (char const   )'r',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_enclosure_register  __attribute__((__used__,
__unused__, __section__("__ksymtab_gpl")))  =    {(unsigned long )(& enclosure_register), __kstrtab_enclosure_register};
static struct enclosure_component_callbacks enclosure_null_callbacks  ;
void enclosure_unregister(struct enclosure_device *edev ) 
{ int i ;

  {
  {
  mutex_lock(& container_list_lock);
  list_del(& edev->node);
  mutex_unlock(& container_list_lock);
  i = 0;
  }
  {
  while (1) {
    while_6_continue: /* CIL Label */ ;
    if (! (i < edev->components)) {
      goto while_6_break;
    }
    if (edev->component[i].number != -1) {
      {
      device_unregister(& edev->component[i].cdev);
      }
    }
    {
    i ++;
    }
  }
  while_6_break: /* CIL Label */ ;
  }
  {
  edev->cb = & enclosure_null_callbacks;
  device_unregister(& edev->edev);
  }
  return;
}
}
extern void *__crc_enclosure_unregister  __attribute__((__weak__)) ;
static unsigned long const   __kcrctab_enclosure_unregister  __attribute__((__used__,
__unused__, __section__("__kcrctab_gpl")))  =    (unsigned long const   )((unsigned long )(& __crc_enclosure_unregister));
static char const   __kstrtab_enclosure_unregister[21]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'e',      (char const   )'n',      (char const   )'c',      (char const   )'l', 
        (char const   )'o',      (char const   )'s',      (char const   )'u',      (char const   )'r', 
        (char const   )'e',      (char const   )'_',      (char const   )'u',      (char const   )'n', 
        (char const   )'r',      (char const   )'e',      (char const   )'g',      (char const   )'i', 
        (char const   )'s',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_enclosure_unregister  __attribute__((__used__,
__unused__, __section__("__ksymtab_gpl")))  =    {(unsigned long )(& enclosure_unregister), __kstrtab_enclosure_unregister};
static void enclosure_link_name(struct enclosure_component *cdev , char *name ) 
{ 

  {
  {
  strcpy(name, "enclosure_device:");
  strcat(name, (char const   *)(cdev->cdev.bus_id));
  }
  return;
}
}
static void enclosure_remove_links(struct enclosure_component *cdev ) 
{ char name[64] ;

  {
  {
  enclosure_link_name(cdev, name);
  sysfs_remove_link(& (cdev->dev)->kobj, (char const   *)(name));
  sysfs_remove_link(& cdev->cdev.kobj, "device");
  }
  return;
}
}
static int enclosure_add_links(struct enclosure_component *cdev ) 
{ int error ;
  char name[64] ;

  {
  {
  error = sysfs_create_link(& cdev->cdev.kobj, & (cdev->dev)->kobj, "device");
  }
  if (error) {
    return (error);
  }
  {
  enclosure_link_name(cdev, name);
  error = sysfs_create_link(& (cdev->dev)->kobj, & cdev->cdev.kobj, (char const   *)(name));
  }
  if (error) {
    {
    sysfs_remove_link(& cdev->cdev.kobj, "device");
    }
  }
  return (error);
}
}
static void enclosure_release(struct device *cdev ) 
{ struct enclosure_device *edev ;
  struct enclosure_device *tmp ;

  {
  {
  tmp = to_enclosure_device(cdev);
  edev = tmp;
  put_device(cdev->parent);
  kfree((void const   *)edev);
  }
  return;
}
}
static void enclosure_component_release(struct device *dev ) 
{ struct enclosure_component *cdev ;
  struct enclosure_component *tmp ;

  {
  {
  tmp = to_enclosure_component(dev);
  cdev = tmp;
  }
  if (cdev->dev) {
    {
    enclosure_remove_links(cdev);
    put_device(cdev->dev);
    }
  }
  {
  put_device(dev->parent);
  }
  return;
}
}
static struct attribute_group *enclosure_groups[2] ;
struct enclosure_component *enclosure_component_register(struct enclosure_device *edev ,
                                                         unsigned int number , enum enclosure_component_type type ,
                                                         char const   *name ) 
{ struct enclosure_component *ecomp ;
  struct device *cdev ;
  int err ;
  void *tmp ;
  void *tmp___0 ;

  {
  if (number >= (unsigned int )edev->components) {
    {
    tmp = ERR_PTR(-22L);
    }
    return ((struct enclosure_component *)tmp);
  }
  {
  ecomp = & edev->component[number];
  }
  if (ecomp->number != -1) {
    {
    tmp___0 = ERR_PTR(-22L);
    }
    return ((struct enclosure_component *)tmp___0);
  }
  {
  ecomp->type = type;
  ecomp->number = (int )number;
  cdev = & ecomp->cdev;
  cdev->parent = get_device(& edev->edev);
  }
  if (name) {
    {
    snprintf(cdev->bus_id, 20U, "%s", name);
    }
  } else {
    {
    snprintf(cdev->bus_id, 20U, "%u", number);
    }
  }
  {
  cdev->release = & enclosure_component_release;
  cdev->groups = enclosure_groups;
  err = device_register(cdev);
  }
  if (err) {
    {
    ERR_PTR((long )err);
    }
  }
  return (ecomp);
}
}
extern void *__crc_enclosure_component_register  __attribute__((__weak__)) ;
static unsigned long const   __kcrctab_enclosure_component_register  __attribute__((__used__,
__unused__, __section__("__kcrctab_gpl")))  =    (unsigned long const   )((unsigned long )(& __crc_enclosure_component_register));
static char const   __kstrtab_enclosure_component_register[29]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'e',      (char const   )'n',      (char const   )'c',      (char const   )'l', 
        (char const   )'o',      (char const   )'s',      (char const   )'u',      (char const   )'r', 
        (char const   )'e',      (char const   )'_',      (char const   )'c',      (char const   )'o', 
        (char const   )'m',      (char const   )'p',      (char const   )'o',      (char const   )'n', 
        (char const   )'e',      (char const   )'n',      (char const   )'t',      (char const   )'_', 
        (char const   )'r',      (char const   )'e',      (char const   )'g',      (char const   )'i', 
        (char const   )'s',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_enclosure_component_register  __attribute__((__used__,
__unused__, __section__("__ksymtab_gpl")))  =    {(unsigned long )(& enclosure_component_register), __kstrtab_enclosure_component_register};
int enclosure_add_device(struct enclosure_device *edev ,
                         int component , struct device *dev ) 
{ struct enclosure_component *cdev ;
  int tmp ;

  {
  if (! edev) {
    return (-22);
  } else {
    if (component >= edev->components) {
      return (-22);
    }
  }
  {
  cdev = & edev->component[component];
  }
  if (cdev->dev) {
    {
    enclosure_remove_links(cdev);
    }
  }
  {
  put_device(cdev->dev);
  cdev->dev = get_device(dev);
  tmp = enclosure_add_links(cdev);
  }
  return (tmp);
}
}
extern void *__crc_enclosure_add_device  __attribute__((__weak__)) ;
static unsigned long const   __kcrctab_enclosure_add_device  __attribute__((__used__,
__unused__, __section__("__kcrctab_gpl")))  =    (unsigned long const   )((unsigned long )(& __crc_enclosure_add_device));
static char const   __kstrtab_enclosure_add_device[21]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'e',      (char const   )'n',      (char const   )'c',      (char const   )'l', 
        (char const   )'o',      (char const   )'s',      (char const   )'u',      (char const   )'r', 
        (char const   )'e',      (char const   )'_',      (char const   )'a',      (char const   )'d', 
        (char const   )'d',      (char const   )'_',      (char const   )'d',      (char const   )'e', 
        (char const   )'v',      (char const   )'i',      (char const   )'c',      (char const   )'e', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_enclosure_add_device  __attribute__((__used__,
__unused__, __section__("__ksymtab_gpl")))  =    {(unsigned long )(& enclosure_add_device), __kstrtab_enclosure_add_device};
int enclosure_remove_device(struct enclosure_device *edev , int component ) 
{ struct enclosure_component *cdev ;
  int tmp ;

  {
  if (! edev) {
    return (-22);
  } else {
    if (component >= edev->components) {
      return (-22);
    }
  }
  {
  cdev = & edev->component[component];
  device_del(& cdev->cdev);
  put_device(cdev->dev);
  cdev->dev = (struct device *)((void *)0);
  tmp = device_add(& cdev->cdev);
  }
  return (tmp);
}
}
extern void *__crc_enclosure_remove_device  __attribute__((__weak__)) ;
static unsigned long const   __kcrctab_enclosure_remove_device  __attribute__((__used__,
__unused__, __section__("__kcrctab_gpl")))  =    (unsigned long const   )((unsigned long )(& __crc_enclosure_remove_device));
static char const   __kstrtab_enclosure_remove_device[24]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'e',      (char const   )'n',      (char const   )'c',      (char const   )'l', 
        (char const   )'o',      (char const   )'s',      (char const   )'u',      (char const   )'r', 
        (char const   )'e',      (char const   )'_',      (char const   )'r',      (char const   )'e', 
        (char const   )'m',      (char const   )'o',      (char const   )'v',      (char const   )'e', 
        (char const   )'_',      (char const   )'d',      (char const   )'e',      (char const   )'v', 
        (char const   )'i',      (char const   )'c',      (char const   )'e',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_enclosure_remove_device  __attribute__((__used__,
__unused__, __section__("__ksymtab_gpl")))  =    {(unsigned long )(& enclosure_remove_device), __kstrtab_enclosure_remove_device};
static ssize_t enclosure_show_components(struct device *cdev ,
                                         struct device_attribute *attr , char *buf ) 
{ struct enclosure_device *edev ;
  struct enclosure_device *tmp ;
  int tmp___0 ;

  {
  {
  tmp = to_enclosure_device(cdev);
  edev = tmp;
  tmp___0 = snprintf(buf, 40U, "%d\n", edev->components);
  }
  return (tmp___0);
}
}
static struct device_attribute enclosure_attrs[2]  = {      {{"components", (struct module *)0, (mode_t )292}, & enclosure_show_components,
      (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                   size_t count ))((void *)0)}, 
        {{(char const   *)((void *)0), (struct module *)0, (unsigned short)0}, (ssize_t (*)(struct device *dev ,
                                                                                         struct device_attribute *attr ,
                                                                                         char *buf ))0,
      (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                   size_t count ))0}};
static struct class enclosure_class  = 
     {"enclosure", (struct module *)0, (struct class_attribute *)0, enclosure_attrs,
    (struct kobject *)0, (int (*)(struct device *dev , struct kobj_uevent_env *env ))0,
    (void (*)(struct class *class ))0, & enclosure_release, (int (*)(struct device *dev ,
                                                                     pm_message_t state ))0,
    (int (*)(struct device *dev ))0, (struct pm_ops *)0, (struct class_private *)0};
static char const   * const  enclosure_status[8]  = 
  {      (char const   * const  )"unsupported",      (char const   * const  )"OK",      (char const   * const  )"critical",      (char const   * const  )"non-critical", 
        (char const   * const  )"unrecoverable",      (char const   * const  )"not installed",      (char const   * const  )"unknown",      (char const   * const  )"unavailable"};
static char const   * const  enclosure_type[24]  = 
  {      (char const   * const  )0,      (char const   * const  )"device",      (char const   * const  )0,      (char const   * const  )0, 
        (char const   * const  )0,      (char const   * const  )0,      (char const   * const  )0,      (char const   * const  )0, 
        (char const   * const  )0,      (char const   * const  )0,      (char const   * const  )0,      (char const   * const  )0, 
        (char const   * const  )0,      (char const   * const  )0,      (char const   * const  )0,      (char const   * const  )0, 
        (char const   * const  )0,      (char const   * const  )0,      (char const   * const  )0,      (char const   * const  )0, 
        (char const   * const  )0,      (char const   * const  )0,      (char const   * const  )0,      (char const   * const  )"array device"};
static ssize_t get_component_fault(struct device *cdev , struct device_attribute *attr ,
                                   char *buf ) 
{ struct enclosure_device *edev ;
  struct enclosure_device *tmp ;
  struct enclosure_component *ecomp ;
  struct enclosure_component *tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp = to_enclosure_device(cdev->parent);
  edev = tmp;
  tmp___0 = to_enclosure_component(cdev);
  ecomp = tmp___0;
  }
  if ((edev->cb)->get_fault) {
    {
    (*((edev->cb)->get_fault))(edev, ecomp);
    }
  }
  {
  tmp___1 = snprintf(buf, 40U, "%d\n", ecomp->fault);
  }
  return (tmp___1);
}
}
static ssize_t set_component_fault(struct device *cdev , struct device_attribute *attr ,
                                   char const   *buf , size_t count ) 
{ struct enclosure_device *edev ;
  struct enclosure_device *tmp ;
  struct enclosure_component *ecomp ;
  struct enclosure_component *tmp___0 ;
  int val ;
  unsigned long tmp___1 ;

  {
  {
  tmp = to_enclosure_device(cdev->parent);
  edev = tmp;
  tmp___0 = to_enclosure_component(cdev);
  ecomp = tmp___0;
  tmp___1 = simple_strtoul(buf, (char **)((void *)0), 0U);
  val = (int )tmp___1;
  }
  if ((edev->cb)->set_fault) {
    {
    (*((edev->cb)->set_fault))(edev, ecomp, (enum enclosure_component_setting )val);
    }
  }
  return ((int )count);
}
}
static ssize_t get_component_status(struct device *cdev , struct device_attribute *attr ,
                                    char *buf ) 
{ struct enclosure_device *edev ;
  struct enclosure_device *tmp ;
  struct enclosure_component *ecomp ;
  struct enclosure_component *tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp = to_enclosure_device(cdev->parent);
  edev = tmp;
  tmp___0 = to_enclosure_component(cdev);
  ecomp = tmp___0;
  }
  if ((edev->cb)->get_status) {
    {
    (*((edev->cb)->get_status))(edev, ecomp);
    }
  }
  {
  tmp___1 = snprintf(buf, 40U, "%s\n", enclosure_status[ecomp->status]);
  }
  return (tmp___1);
}
}
static ssize_t set_component_status(struct device *cdev , struct device_attribute *attr ,
                                    char const   *buf , size_t count ) 
{ struct enclosure_device *edev ;
  struct enclosure_device *tmp ;
  struct enclosure_component *ecomp ;
  struct enclosure_component *tmp___0 ;
  int i ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
  {
  tmp = to_enclosure_device(cdev->parent);
  edev = tmp;
  tmp___0 = to_enclosure_component(cdev);
  ecomp = tmp___0;
  i = 0;
  }
  {
  while (1) {
    while_7_continue: /* CIL Label */ ;
    if (! enclosure_status[i]) {
      goto while_7_break;
    }
    {
    tmp___1 = strlen((char const   *)enclosure_status[i]);
    tmp___2 = strncmp(buf, (char const   *)enclosure_status[i], tmp___1);
    }
    if (tmp___2 == 0) {
      {
      tmp___3 = strlen((char const   *)enclosure_status[i]);
      }
      if ((int const   )*(buf + tmp___3) == 10) {
        goto while_7_break;
      } else {
        {
        tmp___4 = strlen((char const   *)enclosure_status[i]);
        }
        if ((int const   )*(buf + tmp___4) == 0) {
          goto while_7_break;
        }
      }
    }
    {
    i ++;
    }
  }
  while_7_break: /* CIL Label */ ;
  }
  if (enclosure_status[i]) {
    if ((edev->cb)->set_status) {
      {
      (*((edev->cb)->set_status))(edev, ecomp, (enum enclosure_status )i);
      }
      return ((int )count);
    } else {
      return (-22);
    }
  } else {
    return (-22);
  }
}
}
static ssize_t get_component_active(struct device *cdev , struct device_attribute *attr ,
                                    char *buf ) 
{ struct enclosure_device *edev ;
  struct enclosure_device *tmp ;
  struct enclosure_component *ecomp ;
  struct enclosure_component *tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp = to_enclosure_device(cdev->parent);
  edev = tmp;
  tmp___0 = to_enclosure_component(cdev);
  ecomp = tmp___0;
  }
  if ((edev->cb)->get_active) {
    {
    (*((edev->cb)->get_active))(edev, ecomp);
    }
  }
  {
  tmp___1 = snprintf(buf, 40U, "%d\n", ecomp->active);
  }
  return (tmp___1);
}
}
static ssize_t set_component_active(struct device *cdev , struct device_attribute *attr ,
                                    char const   *buf , size_t count ) 
{ struct enclosure_device *edev ;
  struct enclosure_device *tmp ;
  struct enclosure_component *ecomp ;
  struct enclosure_component *tmp___0 ;
  int val ;
  unsigned long tmp___1 ;

  {
  {
  tmp = to_enclosure_device(cdev->parent);
  edev = tmp;
  tmp___0 = to_enclosure_component(cdev);
  ecomp = tmp___0;
  tmp___1 = simple_strtoul(buf, (char **)((void *)0), 0U);
  val = (int )tmp___1;
  }
  if ((edev->cb)->set_active) {
    {
    (*((edev->cb)->set_active))(edev, ecomp, (enum enclosure_component_setting )val);
    }
  }
  return ((int )count);
}
}
static ssize_t get_component_locate(struct device *cdev , struct device_attribute *attr ,
                                    char *buf ) 
{ struct enclosure_device *edev ;
  struct enclosure_device *tmp ;
  struct enclosure_component *ecomp ;
  struct enclosure_component *tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp = to_enclosure_device(cdev->parent);
  edev = tmp;
  tmp___0 = to_enclosure_component(cdev);
  ecomp = tmp___0;
  }
  if ((edev->cb)->get_locate) {
    {
    (*((edev->cb)->get_locate))(edev, ecomp);
    }
  }
  {
  tmp___1 = snprintf(buf, 40U, "%d\n", ecomp->locate);
  }
  return (tmp___1);
}
}
static ssize_t set_component_locate(struct device *cdev , struct device_attribute *attr ,
                                    char const   *buf , size_t count ) 
{ struct enclosure_device *edev ;
  struct enclosure_device *tmp ;
  struct enclosure_component *ecomp ;
  struct enclosure_component *tmp___0 ;
  int val ;
  unsigned long tmp___1 ;

  {
  {
  tmp = to_enclosure_device(cdev->parent);
  edev = tmp;
  tmp___0 = to_enclosure_component(cdev);
  ecomp = tmp___0;
  tmp___1 = simple_strtoul(buf, (char **)((void *)0), 0U);
  val = (int )tmp___1;
  }
  if ((edev->cb)->set_locate) {
    {
    (*((edev->cb)->set_locate))(edev, ecomp, (enum enclosure_component_setting )val);
    }
  }
  return ((int )count);
}
}
static ssize_t get_component_type(struct device *cdev , struct device_attribute *attr ,
                                  char *buf ) 
{ struct enclosure_component *ecomp ;
  struct enclosure_component *tmp ;
  int tmp___0 ;

  {
  {
  tmp = to_enclosure_component(cdev);
  ecomp = tmp;
  tmp___0 = snprintf(buf, 40U, "%s\n", enclosure_type[ecomp->type]);
  }
  return (tmp___0);
}
}
static struct device_attribute dev_attr_fault  =    {{"fault", (struct module *)0, (mode_t )420}, & get_component_fault, & set_component_fault};
static struct device_attribute dev_attr_status  =    {{"status",
     (struct module *)0, (mode_t )420}, & get_component_status, & set_component_status};
static struct device_attribute dev_attr_active  =    {{"active",
     (struct module *)0, (mode_t )420}, & get_component_active, & set_component_active};
static struct device_attribute dev_attr_locate  =    {{"locate",
     (struct module *)0, (mode_t )420}, & get_component_locate, & set_component_locate};
static struct device_attribute dev_attr_type  =    {{"type",
     (struct module *)0, (mode_t )292}, & get_component_type, (ssize_t (*)(struct device *dev ,
                                                                           struct device_attribute *attr ,
                                                                           char const   *buf ,
                                                                           size_t count ))((void *)0)};
static struct attribute *enclosure_component_attrs[6]  = {      & dev_attr_fault.attr,      & dev_attr_status.attr,      & dev_attr_active.attr,      & dev_attr_locate.attr, 
        & dev_attr_type.attr,      (struct attribute *)((void *)0)};
static struct attribute_group enclosure_group  =    {(char const   *)0,
    (mode_t (*)(struct kobject * , struct attribute * , int  ))0, enclosure_component_attrs};
static struct attribute_group *enclosure_groups[2]  = {      & enclosure_group,      (struct attribute_group *)((void *)0)};
static struct lock_class_key __key___0  ;
static int __attribute__((__cold__))  enclosure_init(void)  __attribute__((__section__(".init.text"))) ;
static int __attribute__((__cold__))  enclosure_init(void) 
{ int err ;
  int tmp ;

  {
  {
  tmp = __class_register(& enclosure_class, & __key___0);
  err = tmp;
  }
  if (err) {
    return ((int __attribute__((__cold__))  )err);
  }
  return ((int __attribute__((__cold__))  )0);
}
}
static void __attribute__((__cold__))  enclosure_exit(void)  __attribute__((__used__,
__section__(".exit.text"))) ;
static void __attribute__((__cold__))  enclosure_exit(void) 
{ 

  {
  {
  class_unregister(& enclosure_class);
  }
  return;
}
}
static int (*__initcall_enclosure_init6)(void)  __attribute__((__used__, __section__(".initcall6.init")))  =    (int (*)(void))(& enclosure_init);
static void (*__exitcall_enclosure_exit)(void)  __attribute__((__used__,
__section__(".exitcall.exit")))  =    (void (*)(void))(& enclosure_exit);
