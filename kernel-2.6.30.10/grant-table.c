/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

typedef unsigned int __kernel_size_t;
typedef signed char __s8;
typedef short __s16;
typedef unsigned short __u16;
typedef unsigned int __u32;
typedef unsigned long long __u64;
typedef unsigned short u16;
typedef __kernel_size_t size_t;
typedef __s8 int8_t;
typedef __s16 int16_t;
typedef __u16 uint16_t;
typedef __u32 uint32_t;
typedef __u64 uint64_t;
typedef unsigned int gfp_t;
struct __xchg_dummy {
   unsigned long a[100] ;
};
struct bug_entry {
   unsigned long bug_addr ;
   char const   *file ;
   unsigned short line ;
   unsigned short flags ;
};
struct raw_spinlock;
struct raw_spinlock;
struct raw_spinlock {
   unsigned int slock ;
};
typedef struct raw_spinlock raw_spinlock_t;
struct __anonstruct_spinlock_t_32 {
   raw_spinlock_t raw_lock ;
};
typedef struct __anonstruct_spinlock_t_32 spinlock_t;
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
typedef unsigned long *__guest_handle_ulong;
typedef uint16_t domid_t;
struct __anonstruct_domU_127 {
   unsigned long mfn ;
   uint32_t evtchn ;
};
struct __anonstruct_dom0_128 {
   uint32_t info_off ;
   uint32_t info_size ;
};
union __anonunion_console_126 {
   struct __anonstruct_domU_127 domU ;
   struct __anonstruct_dom0_128 dom0 ;
};
struct start_info {
   char magic[32] ;
   unsigned long nr_pages ;
   unsigned long shared_info ;
   uint32_t flags ;
   unsigned long store_mfn ;
   uint32_t store_evtchn ;
   union __anonunion_console_126 console ;
   unsigned long pt_base ;
   unsigned long nr_pt_frames ;
   unsigned long mfn_list ;
   unsigned long mod_start ;
   unsigned long mod_len ;
   int8_t cmd_line[1024] ;
};
struct __anonstruct_hypercall_page_134 {
   char _entry[32] ;
};
struct grant_entry {
   uint16_t flags ;
   domid_t domid ;
   uint32_t frame ;
};
typedef uint32_t grant_ref_t;
struct gnttab_setup_table {
   domid_t dom ;
   uint32_t nr_frames ;
   int16_t status ;
   __guest_handle_ulong frame_list ;
};
struct gnttab_query_size {
   domid_t dom ;
   uint32_t nr_frames ;
   uint32_t max_nr_frames ;
   int16_t status ;
};
struct gnttab_free_callback {
   struct gnttab_free_callback *next ;
   void (*fn)(void * ) ;
   void *arg ;
   u16 count ;
};
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
__inline static unsigned long __sync_cmpxchg(void volatile   *ptr , unsigned long old ,
                                             unsigned long new , int size ) 
{ unsigned long prev ;

  {
  if (size == 1) {
    goto switch_0_1;
  } else {
    if (size == 2) {
      goto switch_0_2;
    } else {
      if (size == 4) {
        goto switch_0_4;
      } else {
        if (0) {
          switch_0_1: /* CIL Label */ 
          {
          __asm__  volatile   ("lock; cmpxchgb %b1,%2": "=a" (prev): "q" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
          return (prev);
          switch_0_2: /* CIL Label */ 
          {
          __asm__  volatile   ("lock; cmpxchgw %w1,%2": "=a" (prev): "r" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
          return (prev);
          switch_0_4: /* CIL Label */ 
          {
          __asm__  volatile   ("lock; cmpxchgl %1,%2": "=a" (prev): "r" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
          return (prev);
        } else {
          switch_0_break: /* CIL Label */ ;
        }
      }
    }
  }
  return (old);
}
}
extern int ( /* format attribute */ __attribute__((__regparm__(0))) printk)(char const   *fmt 
                                                                            , ...)  __attribute__((__cold__)) ;
__inline static void rep_nop(void) 
{ 

  {
  {
  __asm__  volatile   ("rep; nop": : : "memory");
  }
  return;
}
}
__inline static void cpu_relax(void) 
{ 

  {
  {
  rep_nop();
  }
  return;
}
}
register unsigned long current_stack_pointer  __asm__("esp") __attribute__((__used__))  ;
extern unsigned long _spin_lock_irqsave(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags )  __attribute__((__section__(".spinlock.text"))) ;
extern unsigned long __get_free_pages(gfp_t gfp_mask , unsigned int order ) ;
extern void free_pages(unsigned long addr , unsigned int order ) ;
extern void kfree(void const   * ) ;
extern void *__kmalloc(size_t size , gfp_t flags ) ;
__inline static void *( __attribute__((__always_inline__)) kmalloc)(size_t size ,
                                                                    gfp_t flags ) 
{ void *tmp___2 ;

  {
  {
  tmp___2 = __kmalloc(size, flags);
  }
  return (tmp___2);
}
}
extern struct __anonstruct_hypercall_page_134 hypercall_page[] ;
__inline static int HYPERVISOR_grant_table_op(unsigned int cmd , void *uop , unsigned int count ) 
{ register unsigned long __res  __asm__("eax")  ;
  register unsigned long __arg1  __asm__("ebx")  ;
  register unsigned long __arg2  __asm__("ecx")  ;
  register unsigned long __arg3  __asm__("edx")  ;
  register unsigned long __arg4  __asm__("esi")  ;
  register unsigned long __arg5  __asm__("edi")  ;

  {
  {
  __arg1 = __arg1;
  __arg2 = __arg2;
  __arg3 = __arg3;
  __arg4 = __arg4;
  __arg5 = __arg5;
  __arg1 = (unsigned long )cmd;
  __arg2 = (unsigned long )uop;
  __arg3 = (unsigned long )count;
  __asm__  volatile   ("call hypercall_page+%c[offset]": "=r" (__res), "+r" (__arg1),
                       "+r" (__arg2), "+r" (__arg3): [offset] "i" (20U * sizeof(hypercall_page[0])): "memory",
                       "edi", "esi");
  }
  return ((int )__res);
}
}
extern struct start_info *xen_start_info ;
int gnttab_suspend(void) ;
int gnttab_resume(void) ;
int gnttab_grant_foreign_access(domid_t domid , unsigned long frame , int readonly ) ;
int gnttab_end_foreign_access_ref(grant_ref_t ref , int readonly ) ;
void gnttab_end_foreign_access(grant_ref_t ref , int readonly , unsigned long page ) ;
int gnttab_grant_foreign_transfer(domid_t domid , unsigned long pfn ) ;
unsigned long gnttab_end_foreign_transfer_ref(grant_ref_t ref ) ;
unsigned long gnttab_end_foreign_transfer(grant_ref_t ref ) ;
int gnttab_query_foreign_access(grant_ref_t ref ) ;
int gnttab_alloc_grant_references(u16 count , grant_ref_t *head ) ;
void gnttab_free_grant_reference(grant_ref_t ref ) ;
void gnttab_free_grant_references(grant_ref_t head ) ;
int gnttab_empty_grant_references(grant_ref_t const   *private_head ) ;
int gnttab_claim_grant_reference(grant_ref_t *private_head ) ;
void gnttab_release_grant_reference(grant_ref_t *private_head , grant_ref_t release ) ;
void gnttab_request_free_callback(struct gnttab_free_callback *callback , void (*fn)(void * ) ,
                                  void *arg , u16 count ) ;
void gnttab_cancel_free_callback(struct gnttab_free_callback *callback ) ;
void gnttab_grant_foreign_access_ref(grant_ref_t ref , domid_t domid , unsigned long frame ,
                                     int readonly ) ;
void gnttab_grant_foreign_transfer_ref(grant_ref_t ref , domid_t domid , unsigned long pfn ) ;
extern int arch_gnttab_map_shared(unsigned long *frames , unsigned long nr_gframes ,
                                  unsigned long max_nr_gframes , struct grant_entry **__shared ) ;
extern void arch_gnttab_unmap_shared(struct grant_entry *shared , unsigned long nr_gframes ) ;
static grant_ref_t **gnttab_list  ;
static unsigned int nr_grant_frames  ;
static unsigned int boot_max_nr_grant_frames  ;
static int gnttab_free_count  ;
static grant_ref_t gnttab_free_head  ;
static spinlock_t gnttab_list_lock  =    {{0U}};
static struct grant_entry *shared  ;
static struct gnttab_free_callback *gnttab_free_callback_list  ;
static int gnttab_expand(unsigned int req_entries ) ;
__inline static grant_ref_t *__gnttab_entry(grant_ref_t entry ) 
{ 

  {
  return (*(gnttab_list + (unsigned long )entry / ((1UL << 12) / (unsigned long )sizeof(grant_ref_t ))) + (unsigned long )entry % ((1UL << 12) / (unsigned long )sizeof(grant_ref_t )));
}
}
static int get_free_entries(unsigned int count ) 
{ unsigned long flags ;
  int ref ;
  int rc ;
  grant_ref_t head ;
  grant_ref_t *tmp ;
  unsigned int tmp___0 ;
  grant_ref_t *tmp___1 ;
  grant_ref_t *tmp___2 ;

  {
  {
  while (1) {
    while_1_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& gnttab_list_lock);
    }
    goto while_1_break;
  }
  while_1_break: /* CIL Label */ ;
  }
  if ((unsigned int )gnttab_free_count < count) {
    {
    rc = gnttab_expand(count - (unsigned int )gnttab_free_count);
    }
    if (rc < 0) {
      {
      while (1) {
        while_2_continue: /* CIL Label */ ;
        {
        _spin_unlock_irqrestore(& gnttab_list_lock, flags);
        }
        goto while_2_break;
      }
      while_2_break: /* CIL Label */ ;
      }
      return (rc);
    }
  }
  {
  head = gnttab_free_head;
  ref = (int )head;
  gnttab_free_count = (int )((unsigned int )gnttab_free_count - count);
  }
  {
  while (1) {
    while_3_continue: /* CIL Label */ ;
    {
    tmp___0 = count;
    count --;
    }
    if (! (tmp___0 > 1U)) {
      goto while_3_break;
    }
    {
    tmp = __gnttab_entry(head);
    head = *tmp;
    }
  }
  while_3_break: /* CIL Label */ ;
  }
  {
  tmp___1 = __gnttab_entry(head);
  gnttab_free_head = *tmp___1;
  tmp___2 = __gnttab_entry(head);
  *tmp___2 = 4294967295U;
  }
  {
  while (1) {
    while_4_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& gnttab_list_lock, flags);
    }
    goto while_4_break;
  }
  while_4_break: /* CIL Label */ ;
  }
  return (ref);
}
}
static void do_free_callbacks(void) 
{ struct gnttab_free_callback *callback ;
  struct gnttab_free_callback *next ;

  {
  {
  callback = gnttab_free_callback_list;
  gnttab_free_callback_list = (struct gnttab_free_callback *)((void *)0);
  }
  {
  while (1) {
    while_5_continue: /* CIL Label */ ;
    if (! ((unsigned int )callback != (unsigned int )((void *)0))) {
      goto while_5_break;
    }
    {
    next = callback->next;
    }
    if (gnttab_free_count >= (int )callback->count) {
      {
      callback->next = (struct gnttab_free_callback *)((void *)0);
      (*(callback->fn))(callback->arg);
      }
    } else {
      {
      callback->next = gnttab_free_callback_list;
      gnttab_free_callback_list = callback;
      }
    }
    {
    callback = next;
    }
  }
  while_5_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static void check_free_callbacks(void) 
{ long tmp ;

  {
  {
  tmp = __builtin_expect((long )(! (! gnttab_free_callback_list)), 0L);
  }
  if (tmp) {
    {
    do_free_callbacks();
    }
  }
  return;
}
}
static void put_free_entry(grant_ref_t ref ) 
{ unsigned long flags ;
  grant_ref_t *tmp ;

  {
  {
  while (1) {
    while_6_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& gnttab_list_lock);
    }
    goto while_6_break;
  }
  while_6_break: /* CIL Label */ ;
  }
  {
  tmp = __gnttab_entry(ref);
  *tmp = gnttab_free_head;
  gnttab_free_head = ref;
  gnttab_free_count ++;
  check_free_callbacks();
  }
  {
  while (1) {
    while_7_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& gnttab_list_lock, flags);
    }
    goto while_7_break;
  }
  while_7_break: /* CIL Label */ ;
  }
  return;
}
}
static void update_grant_entry(grant_ref_t ref , domid_t domid , unsigned long frame ,
                               unsigned int flags ) 
{ 

  {
  {
  (shared + ref)->frame = (unsigned int )frame;
  (shared + ref)->domid = domid;
  __asm__  volatile   ("661:\n\t"
                       "lock; addl $0,0(%%esp)"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "sfence"
                       "\n664:\n"
                       ".previous": : "i" (25): "memory");
  (shared + ref)->flags = (unsigned short )flags;
  }
  return;
}
}
void gnttab_grant_foreign_access_ref(grant_ref_t ref , domid_t domid , unsigned long frame ,
                                     int readonly ) 
{ unsigned int tmp ;

  {
  if (readonly) {
    {
    tmp = 1U << 2;
    }
  } else {
    {
    tmp = 0U;
    }
  }
  {
  update_grant_entry(ref, domid, frame, 1U | tmp);
  }
  return;
}
}
extern void *__crc_gnttab_grant_foreign_access_ref  __attribute__((__weak__)) ;
static unsigned long const   __kcrctab_gnttab_grant_foreign_access_ref  __attribute__((__used__,
__unused__, __section__("__kcrctab_gpl")))  =    (unsigned long const   )((unsigned long )(& __crc_gnttab_grant_foreign_access_ref));
static char const   __kstrtab_gnttab_grant_foreign_access_ref[32]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'g',      (char const   )'n',      (char const   )'t',      (char const   )'t', 
        (char const   )'a',      (char const   )'b',      (char const   )'_',      (char const   )'g', 
        (char const   )'r',      (char const   )'a',      (char const   )'n',      (char const   )'t', 
        (char const   )'_',      (char const   )'f',      (char const   )'o',      (char const   )'r', 
        (char const   )'e',      (char const   )'i',      (char const   )'g',      (char const   )'n', 
        (char const   )'_',      (char const   )'a',      (char const   )'c',      (char const   )'c', 
        (char const   )'e',      (char const   )'s',      (char const   )'s',      (char const   )'_', 
        (char const   )'r',      (char const   )'e',      (char const   )'f',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_gnttab_grant_foreign_access_ref  __attribute__((__used__,
__unused__, __section__("__ksymtab_gpl")))  =    {(unsigned long )(& gnttab_grant_foreign_access_ref), __kstrtab_gnttab_grant_foreign_access_ref};
int gnttab_grant_foreign_access(domid_t domid ,
                                unsigned long frame , int readonly ) 
{ int ref ;
  long tmp ;

  {
  {
  ref = get_free_entries(1U);
  tmp = __builtin_expect((long )(! (! (ref < 0))), 0L);
  }
  if (tmp) {
    return (-28);
  }
  {
  gnttab_grant_foreign_access_ref((unsigned int )ref, domid, frame, readonly);
  }
  return (ref);
}
}
extern void *__crc_gnttab_grant_foreign_access  __attribute__((__weak__)) ;
static unsigned long const   __kcrctab_gnttab_grant_foreign_access  __attribute__((__used__,
__unused__, __section__("__kcrctab_gpl")))  =    (unsigned long const   )((unsigned long )(& __crc_gnttab_grant_foreign_access));
static char const   __kstrtab_gnttab_grant_foreign_access[28]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'g',      (char const   )'n',      (char const   )'t',      (char const   )'t', 
        (char const   )'a',      (char const   )'b',      (char const   )'_',      (char const   )'g', 
        (char const   )'r',      (char const   )'a',      (char const   )'n',      (char const   )'t', 
        (char const   )'_',      (char const   )'f',      (char const   )'o',      (char const   )'r', 
        (char const   )'e',      (char const   )'i',      (char const   )'g',      (char const   )'n', 
        (char const   )'_',      (char const   )'a',      (char const   )'c',      (char const   )'c', 
        (char const   )'e',      (char const   )'s',      (char const   )'s',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_gnttab_grant_foreign_access  __attribute__((__used__,
__unused__, __section__("__ksymtab_gpl")))  =    {(unsigned long )(& gnttab_grant_foreign_access), __kstrtab_gnttab_grant_foreign_access};
int gnttab_query_foreign_access(grant_ref_t ref ) 
{ u16 nflags ;

  {
  {
  nflags = (shared + ref)->flags;
  }
  return ((int )((unsigned int )nflags & ((1U << 3) | (1U << 4))));
}
}
extern void *__crc_gnttab_query_foreign_access  __attribute__((__weak__)) ;
static unsigned long const   __kcrctab_gnttab_query_foreign_access  __attribute__((__used__,
__unused__, __section__("__kcrctab_gpl")))  =    (unsigned long const   )((unsigned long )(& __crc_gnttab_query_foreign_access));
static char const   __kstrtab_gnttab_query_foreign_access[28]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'g',      (char const   )'n',      (char const   )'t',      (char const   )'t', 
        (char const   )'a',      (char const   )'b',      (char const   )'_',      (char const   )'q', 
        (char const   )'u',      (char const   )'e',      (char const   )'r',      (char const   )'y', 
        (char const   )'_',      (char const   )'f',      (char const   )'o',      (char const   )'r', 
        (char const   )'e',      (char const   )'i',      (char const   )'g',      (char const   )'n', 
        (char const   )'_',      (char const   )'a',      (char const   )'c',      (char const   )'c', 
        (char const   )'e',      (char const   )'s',      (char const   )'s',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_gnttab_query_foreign_access  __attribute__((__used__,
__unused__, __section__("__ksymtab_gpl")))  =    {(unsigned long )(& gnttab_query_foreign_access), __kstrtab_gnttab_query_foreign_access};
int gnttab_end_foreign_access_ref(grant_ref_t ref ,
                                  int readonly ) 
{ u16 flags ;
  u16 nflags ;
  unsigned long tmp ;

  {
  {
  nflags = (shared + ref)->flags;
  }
  {
  while (1) {
    while_8_continue: /* CIL Label */ ;
    {
    flags = nflags;
    }
    if ((unsigned int )flags & ((1U << 3) | (1U << 4))) {
      {
      printk("<1>WARNING: g.e. still in use!\n");
      }
      return (0);
    }
    {
    tmp = __sync_cmpxchg((void volatile   *)(& (shared + ref)->flags), (unsigned long )flags,
                         0UL, (int )sizeof((shared + ref)->flags));
    nflags = (unsigned short )tmp;
    }
    if (! ((int )nflags != (int )flags)) {
      goto while_8_break;
    }
  }
  while_8_break: /* CIL Label */ ;
  }
  return (1);
}
}
extern void *__crc_gnttab_end_foreign_access_ref  __attribute__((__weak__)) ;
static unsigned long const   __kcrctab_gnttab_end_foreign_access_ref  __attribute__((__used__,
__unused__, __section__("__kcrctab_gpl")))  =    (unsigned long const   )((unsigned long )(& __crc_gnttab_end_foreign_access_ref));
static char const   __kstrtab_gnttab_end_foreign_access_ref[30]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'g',      (char const   )'n',      (char const   )'t',      (char const   )'t', 
        (char const   )'a',      (char const   )'b',      (char const   )'_',      (char const   )'e', 
        (char const   )'n',      (char const   )'d',      (char const   )'_',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )'e',      (char const   )'i', 
        (char const   )'g',      (char const   )'n',      (char const   )'_',      (char const   )'a', 
        (char const   )'c',      (char const   )'c',      (char const   )'e',      (char const   )'s', 
        (char const   )'s',      (char const   )'_',      (char const   )'r',      (char const   )'e', 
        (char const   )'f',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_gnttab_end_foreign_access_ref  __attribute__((__used__,
__unused__, __section__("__ksymtab_gpl")))  =    {(unsigned long )(& gnttab_end_foreign_access_ref), __kstrtab_gnttab_end_foreign_access_ref};
void gnttab_end_foreign_access(grant_ref_t ref ,
                               int readonly , unsigned long page ) 
{ int tmp ;

  {
  {
  tmp = gnttab_end_foreign_access_ref(ref, readonly);
  }
  if (tmp) {
    {
    put_free_entry(ref);
    }
    if (page != 0UL) {
      {
      free_pages(page, 0U);
      }
    }
  } else {
    {
    printk("<4>WARNING: leaking g.e. and page still in use!\n");
    }
  }
  return;
}
}
extern void *__crc_gnttab_end_foreign_access  __attribute__((__weak__)) ;
static unsigned long const   __kcrctab_gnttab_end_foreign_access  __attribute__((__used__,
__unused__, __section__("__kcrctab_gpl")))  =    (unsigned long const   )((unsigned long )(& __crc_gnttab_end_foreign_access));
static char const   __kstrtab_gnttab_end_foreign_access[26]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'g',      (char const   )'n',      (char const   )'t',      (char const   )'t', 
        (char const   )'a',      (char const   )'b',      (char const   )'_',      (char const   )'e', 
        (char const   )'n',      (char const   )'d',      (char const   )'_',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )'e',      (char const   )'i', 
        (char const   )'g',      (char const   )'n',      (char const   )'_',      (char const   )'a', 
        (char const   )'c',      (char const   )'c',      (char const   )'e',      (char const   )'s', 
        (char const   )'s',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_gnttab_end_foreign_access  __attribute__((__used__,
__unused__, __section__("__ksymtab_gpl")))  =    {(unsigned long )(& gnttab_end_foreign_access), __kstrtab_gnttab_end_foreign_access};
int gnttab_grant_foreign_transfer(domid_t domid ,
                                  unsigned long pfn ) 
{ int ref ;
  long tmp ;

  {
  {
  ref = get_free_entries(1U);
  tmp = __builtin_expect((long )(! (! (ref < 0))), 0L);
  }
  if (tmp) {
    return (-28);
  }
  {
  gnttab_grant_foreign_transfer_ref((unsigned int )ref, domid, pfn);
  }
  return (ref);
}
}
extern void *__crc_gnttab_grant_foreign_transfer  __attribute__((__weak__)) ;
static unsigned long const   __kcrctab_gnttab_grant_foreign_transfer  __attribute__((__used__,
__unused__, __section__("__kcrctab_gpl")))  =    (unsigned long const   )((unsigned long )(& __crc_gnttab_grant_foreign_transfer));
static char const   __kstrtab_gnttab_grant_foreign_transfer[30]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'g',      (char const   )'n',      (char const   )'t',      (char const   )'t', 
        (char const   )'a',      (char const   )'b',      (char const   )'_',      (char const   )'g', 
        (char const   )'r',      (char const   )'a',      (char const   )'n',      (char const   )'t', 
        (char const   )'_',      (char const   )'f',      (char const   )'o',      (char const   )'r', 
        (char const   )'e',      (char const   )'i',      (char const   )'g',      (char const   )'n', 
        (char const   )'_',      (char const   )'t',      (char const   )'r',      (char const   )'a', 
        (char const   )'n',      (char const   )'s',      (char const   )'f',      (char const   )'e', 
        (char const   )'r',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_gnttab_grant_foreign_transfer  __attribute__((__used__,
__unused__, __section__("__ksymtab_gpl")))  =    {(unsigned long )(& gnttab_grant_foreign_transfer), __kstrtab_gnttab_grant_foreign_transfer};
void gnttab_grant_foreign_transfer_ref(grant_ref_t ref ,
                                       domid_t domid , unsigned long pfn ) 
{ 

  {
  {
  update_grant_entry(ref, domid, pfn, 2U);
  }
  return;
}
}
extern void *__crc_gnttab_grant_foreign_transfer_ref  __attribute__((__weak__)) ;
static unsigned long const   __kcrctab_gnttab_grant_foreign_transfer_ref  __attribute__((__used__,
__unused__, __section__("__kcrctab_gpl")))  =    (unsigned long const   )((unsigned long )(& __crc_gnttab_grant_foreign_transfer_ref));
static char const   __kstrtab_gnttab_grant_foreign_transfer_ref[34]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'g',      (char const   )'n',      (char const   )'t',      (char const   )'t', 
        (char const   )'a',      (char const   )'b',      (char const   )'_',      (char const   )'g', 
        (char const   )'r',      (char const   )'a',      (char const   )'n',      (char const   )'t', 
        (char const   )'_',      (char const   )'f',      (char const   )'o',      (char const   )'r', 
        (char const   )'e',      (char const   )'i',      (char const   )'g',      (char const   )'n', 
        (char const   )'_',      (char const   )'t',      (char const   )'r',      (char const   )'a', 
        (char const   )'n',      (char const   )'s',      (char const   )'f',      (char const   )'e', 
        (char const   )'r',      (char const   )'_',      (char const   )'r',      (char const   )'e', 
        (char const   )'f',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_gnttab_grant_foreign_transfer_ref  __attribute__((__used__,
__unused__, __section__("__ksymtab_gpl")))  =    {(unsigned long )(& gnttab_grant_foreign_transfer_ref), __kstrtab_gnttab_grant_foreign_transfer_ref};
unsigned long gnttab_end_foreign_transfer_ref(grant_ref_t ref ) 
{ unsigned long frame ;
  u16 flags ;
  unsigned long tmp ;
  long tmp___0 ;

  {
  {
  while (1) {
    while_9_continue: /* CIL Label */ ;
    {
    flags = (shared + ref)->flags;
    }
    if ((unsigned int )flags & (1U << 2)) {
      goto while_9_break;
    }
    {
    tmp = __sync_cmpxchg((void volatile   *)(& (shared + ref)->flags), (unsigned long )flags,
                         0UL, (int )sizeof((shared + ref)->flags));
    }
    if ((int )((unsigned short )tmp) == (int )flags) {
      return (0UL);
    }
    {
    cpu_relax();
    }
  }
  while_9_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_10_continue: /* CIL Label */ ;
    if (! (! ((unsigned int )flags & (1U << 3)))) {
      goto while_10_break;
    }
    {
    flags = (shared + ref)->flags;
    cpu_relax();
    }
  }
  while_10_break: /* CIL Label */ ;
  }
  {
  __asm__  volatile   ("661:\n\t"
                       "lock; addl $0,0(%%esp)"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "lfence"
                       "\n664:\n"
                       ".previous": : "i" (26): "memory");
  frame = (unsigned long )(shared + ref)->frame;
  }
  {
  while (1) {
    while_11_continue: /* CIL Label */ ;
    {
    tmp___0 = __builtin_expect((long )(! (! (frame == 0UL))), 0L);
    }
    if (tmp___0) {
      {
      while (1) {
        while_12_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("xen/grant-table.c"), "i" (269),
                             "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_13_continue: /* CIL Label */ ;
        }
        while_13_break: /* CIL Label */ ;
        }
        goto while_12_break;
      }
      while_12_break: /* CIL Label */ ;
      }
    }
    goto while_11_break;
  }
  while_11_break: /* CIL Label */ ;
  }
  return (frame);
}
}
extern void *__crc_gnttab_end_foreign_transfer_ref  __attribute__((__weak__)) ;
static unsigned long const   __kcrctab_gnttab_end_foreign_transfer_ref  __attribute__((__used__,
__unused__, __section__("__kcrctab_gpl")))  =    (unsigned long const   )((unsigned long )(& __crc_gnttab_end_foreign_transfer_ref));
static char const   __kstrtab_gnttab_end_foreign_transfer_ref[32]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'g',      (char const   )'n',      (char const   )'t',      (char const   )'t', 
        (char const   )'a',      (char const   )'b',      (char const   )'_',      (char const   )'e', 
        (char const   )'n',      (char const   )'d',      (char const   )'_',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )'e',      (char const   )'i', 
        (char const   )'g',      (char const   )'n',      (char const   )'_',      (char const   )'t', 
        (char const   )'r',      (char const   )'a',      (char const   )'n',      (char const   )'s', 
        (char const   )'f',      (char const   )'e',      (char const   )'r',      (char const   )'_', 
        (char const   )'r',      (char const   )'e',      (char const   )'f',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_gnttab_end_foreign_transfer_ref  __attribute__((__used__,
__unused__, __section__("__ksymtab_gpl")))  =    {(unsigned long )(& gnttab_end_foreign_transfer_ref), __kstrtab_gnttab_end_foreign_transfer_ref};
unsigned long gnttab_end_foreign_transfer(grant_ref_t ref ) 
{ unsigned long frame ;
  unsigned long tmp ;

  {
  {
  tmp = gnttab_end_foreign_transfer_ref(ref);
  frame = tmp;
  put_free_entry(ref);
  }
  return (frame);
}
}
extern void *__crc_gnttab_end_foreign_transfer  __attribute__((__weak__)) ;
static unsigned long const   __kcrctab_gnttab_end_foreign_transfer  __attribute__((__used__,
__unused__, __section__("__kcrctab_gpl")))  =    (unsigned long const   )((unsigned long )(& __crc_gnttab_end_foreign_transfer));
static char const   __kstrtab_gnttab_end_foreign_transfer[28]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'g',      (char const   )'n',      (char const   )'t',      (char const   )'t', 
        (char const   )'a',      (char const   )'b',      (char const   )'_',      (char const   )'e', 
        (char const   )'n',      (char const   )'d',      (char const   )'_',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )'e',      (char const   )'i', 
        (char const   )'g',      (char const   )'n',      (char const   )'_',      (char const   )'t', 
        (char const   )'r',      (char const   )'a',      (char const   )'n',      (char const   )'s', 
        (char const   )'f',      (char const   )'e',      (char const   )'r',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_gnttab_end_foreign_transfer  __attribute__((__used__,
__unused__, __section__("__ksymtab_gpl")))  =    {(unsigned long )(& gnttab_end_foreign_transfer), __kstrtab_gnttab_end_foreign_transfer};
void gnttab_free_grant_reference(grant_ref_t ref ) 
{ 

  {
  {
  put_free_entry(ref);
  }
  return;
}
}
extern void *__crc_gnttab_free_grant_reference  __attribute__((__weak__)) ;
static unsigned long const   __kcrctab_gnttab_free_grant_reference  __attribute__((__used__,
__unused__, __section__("__kcrctab_gpl")))  =    (unsigned long const   )((unsigned long )(& __crc_gnttab_free_grant_reference));
static char const   __kstrtab_gnttab_free_grant_reference[28]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'g',      (char const   )'n',      (char const   )'t',      (char const   )'t', 
        (char const   )'a',      (char const   )'b',      (char const   )'_',      (char const   )'f', 
        (char const   )'r',      (char const   )'e',      (char const   )'e',      (char const   )'_', 
        (char const   )'g',      (char const   )'r',      (char const   )'a',      (char const   )'n', 
        (char const   )'t',      (char const   )'_',      (char const   )'r',      (char const   )'e', 
        (char const   )'f',      (char const   )'e',      (char const   )'r',      (char const   )'e', 
        (char const   )'n',      (char const   )'c',      (char const   )'e',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_gnttab_free_grant_reference  __attribute__((__used__,
__unused__, __section__("__ksymtab_gpl")))  =    {(unsigned long )(& gnttab_free_grant_reference), __kstrtab_gnttab_free_grant_reference};
void gnttab_free_grant_references(grant_ref_t head ) 
{ grant_ref_t ref ;
  unsigned long flags ;
  int count ;
  grant_ref_t *tmp ;
  grant_ref_t *tmp___0 ;
  grant_ref_t *tmp___1 ;

  {
  {
  count = 1;
  }
  if (head == 4294967295U) {
    return;
  }
  {
  while (1) {
    while_14_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& gnttab_list_lock);
    }
    goto while_14_break;
  }
  while_14_break: /* CIL Label */ ;
  }
  {
  ref = head;
  }
  {
  while (1) {
    while_15_continue: /* CIL Label */ ;
    {
    tmp___0 = __gnttab_entry(ref);
    }
    if (! (*tmp___0 != 4294967295U)) {
      goto while_15_break;
    }
    {
    tmp = __gnttab_entry(ref);
    ref = *tmp;
    count ++;
    }
  }
  while_15_break: /* CIL Label */ ;
  }
  {
  tmp___1 = __gnttab_entry(ref);
  *tmp___1 = gnttab_free_head;
  gnttab_free_head = head;
  gnttab_free_count += count;
  check_free_callbacks();
  }
  {
  while (1) {
    while_16_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& gnttab_list_lock, flags);
    }
    goto while_16_break;
  }
  while_16_break: /* CIL Label */ ;
  }
  return;
}
}
extern void *__crc_gnttab_free_grant_references  __attribute__((__weak__)) ;
static unsigned long const   __kcrctab_gnttab_free_grant_references  __attribute__((__used__,
__unused__, __section__("__kcrctab_gpl")))  =    (unsigned long const   )((unsigned long )(& __crc_gnttab_free_grant_references));
static char const   __kstrtab_gnttab_free_grant_references[29]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'g',      (char const   )'n',      (char const   )'t',      (char const   )'t', 
        (char const   )'a',      (char const   )'b',      (char const   )'_',      (char const   )'f', 
        (char const   )'r',      (char const   )'e',      (char const   )'e',      (char const   )'_', 
        (char const   )'g',      (char const   )'r',      (char const   )'a',      (char const   )'n', 
        (char const   )'t',      (char const   )'_',      (char const   )'r',      (char const   )'e', 
        (char const   )'f',      (char const   )'e',      (char const   )'r',      (char const   )'e', 
        (char const   )'n',      (char const   )'c',      (char const   )'e',      (char const   )'s', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_gnttab_free_grant_references  __attribute__((__used__,
__unused__, __section__("__ksymtab_gpl")))  =    {(unsigned long )(& gnttab_free_grant_references), __kstrtab_gnttab_free_grant_references};
int gnttab_alloc_grant_references(u16 count ,
                                  grant_ref_t *head ) 
{ int h ;
  int tmp ;

  {
  {
  tmp = get_free_entries((unsigned int )count);
  h = tmp;
  }
  if (h < 0) {
    return (-28);
  }
  {
  *head = (unsigned int )h;
  }
  return (0);
}
}
extern void *__crc_gnttab_alloc_grant_references  __attribute__((__weak__)) ;
static unsigned long const   __kcrctab_gnttab_alloc_grant_references  __attribute__((__used__,
__unused__, __section__("__kcrctab_gpl")))  =    (unsigned long const   )((unsigned long )(& __crc_gnttab_alloc_grant_references));
static char const   __kstrtab_gnttab_alloc_grant_references[30]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'g',      (char const   )'n',      (char const   )'t',      (char const   )'t', 
        (char const   )'a',      (char const   )'b',      (char const   )'_',      (char const   )'a', 
        (char const   )'l',      (char const   )'l',      (char const   )'o',      (char const   )'c', 
        (char const   )'_',      (char const   )'g',      (char const   )'r',      (char const   )'a', 
        (char const   )'n',      (char const   )'t',      (char const   )'_',      (char const   )'r', 
        (char const   )'e',      (char const   )'f',      (char const   )'e',      (char const   )'r', 
        (char const   )'e',      (char const   )'n',      (char const   )'c',      (char const   )'e', 
        (char const   )'s',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_gnttab_alloc_grant_references  __attribute__((__used__,
__unused__, __section__("__ksymtab_gpl")))  =    {(unsigned long )(& gnttab_alloc_grant_references), __kstrtab_gnttab_alloc_grant_references};
int gnttab_empty_grant_references(grant_ref_t const   *private_head ) 
{ 

  {
  return (*private_head == 4294967295U);
}
}
extern void *__crc_gnttab_empty_grant_references  __attribute__((__weak__)) ;
static unsigned long const   __kcrctab_gnttab_empty_grant_references  __attribute__((__used__,
__unused__, __section__("__kcrctab_gpl")))  =    (unsigned long const   )((unsigned long )(& __crc_gnttab_empty_grant_references));
static char const   __kstrtab_gnttab_empty_grant_references[30]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'g',      (char const   )'n',      (char const   )'t',      (char const   )'t', 
        (char const   )'a',      (char const   )'b',      (char const   )'_',      (char const   )'e', 
        (char const   )'m',      (char const   )'p',      (char const   )'t',      (char const   )'y', 
        (char const   )'_',      (char const   )'g',      (char const   )'r',      (char const   )'a', 
        (char const   )'n',      (char const   )'t',      (char const   )'_',      (char const   )'r', 
        (char const   )'e',      (char const   )'f',      (char const   )'e',      (char const   )'r', 
        (char const   )'e',      (char const   )'n',      (char const   )'c',      (char const   )'e', 
        (char const   )'s',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_gnttab_empty_grant_references  __attribute__((__used__,
__unused__, __section__("__ksymtab_gpl")))  =    {(unsigned long )(& gnttab_empty_grant_references), __kstrtab_gnttab_empty_grant_references};
int gnttab_claim_grant_reference(grant_ref_t *private_head ) 
{ grant_ref_t g ;
  long tmp ;
  grant_ref_t *tmp___0 ;

  {
  {
  g = *private_head;
  tmp = __builtin_expect((long )(! (! (g == 4294967295U))), 0L);
  }
  if (tmp) {
    return (-28);
  }
  {
  tmp___0 = __gnttab_entry(g);
  *private_head = *tmp___0;
  }
  return ((int )g);
}
}
extern void *__crc_gnttab_claim_grant_reference  __attribute__((__weak__)) ;
static unsigned long const   __kcrctab_gnttab_claim_grant_reference  __attribute__((__used__,
__unused__, __section__("__kcrctab_gpl")))  =    (unsigned long const   )((unsigned long )(& __crc_gnttab_claim_grant_reference));
static char const   __kstrtab_gnttab_claim_grant_reference[29]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'g',      (char const   )'n',      (char const   )'t',      (char const   )'t', 
        (char const   )'a',      (char const   )'b',      (char const   )'_',      (char const   )'c', 
        (char const   )'l',      (char const   )'a',      (char const   )'i',      (char const   )'m', 
        (char const   )'_',      (char const   )'g',      (char const   )'r',      (char const   )'a', 
        (char const   )'n',      (char const   )'t',      (char const   )'_',      (char const   )'r', 
        (char const   )'e',      (char const   )'f',      (char const   )'e',      (char const   )'r', 
        (char const   )'e',      (char const   )'n',      (char const   )'c',      (char const   )'e', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_gnttab_claim_grant_reference  __attribute__((__used__,
__unused__, __section__("__ksymtab_gpl")))  =    {(unsigned long )(& gnttab_claim_grant_reference), __kstrtab_gnttab_claim_grant_reference};
void gnttab_release_grant_reference(grant_ref_t *private_head ,
                                    grant_ref_t release ) 
{ grant_ref_t *tmp ;

  {
  {
  tmp = __gnttab_entry(release);
  *tmp = *private_head;
  *private_head = release;
  }
  return;
}
}
extern void *__crc_gnttab_release_grant_reference  __attribute__((__weak__)) ;
static unsigned long const   __kcrctab_gnttab_release_grant_reference  __attribute__((__used__,
__unused__, __section__("__kcrctab_gpl")))  =    (unsigned long const   )((unsigned long )(& __crc_gnttab_release_grant_reference));
static char const   __kstrtab_gnttab_release_grant_reference[31]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'g',      (char const   )'n',      (char const   )'t',      (char const   )'t', 
        (char const   )'a',      (char const   )'b',      (char const   )'_',      (char const   )'r', 
        (char const   )'e',      (char const   )'l',      (char const   )'e',      (char const   )'a', 
        (char const   )'s',      (char const   )'e',      (char const   )'_',      (char const   )'g', 
        (char const   )'r',      (char const   )'a',      (char const   )'n',      (char const   )'t', 
        (char const   )'_',      (char const   )'r',      (char const   )'e',      (char const   )'f', 
        (char const   )'e',      (char const   )'r',      (char const   )'e',      (char const   )'n', 
        (char const   )'c',      (char const   )'e',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_gnttab_release_grant_reference  __attribute__((__used__,
__unused__, __section__("__ksymtab_gpl")))  =    {(unsigned long )(& gnttab_release_grant_reference), __kstrtab_gnttab_release_grant_reference};
void gnttab_request_free_callback(struct gnttab_free_callback *callback ,
                                  void (*fn)(void * ) , void *arg , u16 count ) 
{ unsigned long flags ;

  {
  {
  while (1) {
    while_17_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& gnttab_list_lock);
    }
    goto while_17_break;
  }
  while_17_break: /* CIL Label */ ;
  }
  if (callback->next) {
    goto out;
  }
  {
  callback->fn = fn;
  callback->arg = arg;
  callback->count = count;
  callback->next = gnttab_free_callback_list;
  gnttab_free_callback_list = callback;
  check_free_callbacks();
  }
  out: 
  {
  while (1) {
    while_18_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& gnttab_list_lock, flags);
    }
    goto while_18_break;
  }
  while_18_break: /* CIL Label */ ;
  }
  return;
}
}
extern void *__crc_gnttab_request_free_callback  __attribute__((__weak__)) ;
static unsigned long const   __kcrctab_gnttab_request_free_callback  __attribute__((__used__,
__unused__, __section__("__kcrctab_gpl")))  =    (unsigned long const   )((unsigned long )(& __crc_gnttab_request_free_callback));
static char const   __kstrtab_gnttab_request_free_callback[29]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'g',      (char const   )'n',      (char const   )'t',      (char const   )'t', 
        (char const   )'a',      (char const   )'b',      (char const   )'_',      (char const   )'r', 
        (char const   )'e',      (char const   )'q',      (char const   )'u',      (char const   )'e', 
        (char const   )'s',      (char const   )'t',      (char const   )'_',      (char const   )'f', 
        (char const   )'r',      (char const   )'e',      (char const   )'e',      (char const   )'_', 
        (char const   )'c',      (char const   )'a',      (char const   )'l',      (char const   )'l', 
        (char const   )'b',      (char const   )'a',      (char const   )'c',      (char const   )'k', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_gnttab_request_free_callback  __attribute__((__used__,
__unused__, __section__("__ksymtab_gpl")))  =    {(unsigned long )(& gnttab_request_free_callback), __kstrtab_gnttab_request_free_callback};
void gnttab_cancel_free_callback(struct gnttab_free_callback *callback ) 
{ struct gnttab_free_callback **pcb ;
  unsigned long flags ;

  {
  {
  while (1) {
    while_19_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& gnttab_list_lock);
    }
    goto while_19_break;
  }
  while_19_break: /* CIL Label */ ;
  }
  {
  pcb = & gnttab_free_callback_list;
  }
  {
  while (1) {
    while_20_continue: /* CIL Label */ ;
    if (! *pcb) {
      goto while_20_break;
    }
    if ((unsigned int )*pcb == (unsigned int )callback) {
      {
      *pcb = callback->next;
      }
      goto while_20_break;
    }
    {
    pcb = & (*pcb)->next;
    }
  }
  while_20_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_21_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& gnttab_list_lock, flags);
    }
    goto while_21_break;
  }
  while_21_break: /* CIL Label */ ;
  }
  return;
}
}
extern void *__crc_gnttab_cancel_free_callback  __attribute__((__weak__)) ;
static unsigned long const   __kcrctab_gnttab_cancel_free_callback  __attribute__((__used__,
__unused__, __section__("__kcrctab_gpl")))  =    (unsigned long const   )((unsigned long )(& __crc_gnttab_cancel_free_callback));
static char const   __kstrtab_gnttab_cancel_free_callback[28]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'g',      (char const   )'n',      (char const   )'t',      (char const   )'t', 
        (char const   )'a',      (char const   )'b',      (char const   )'_',      (char const   )'c', 
        (char const   )'a',      (char const   )'n',      (char const   )'c',      (char const   )'e', 
        (char const   )'l',      (char const   )'_',      (char const   )'f',      (char const   )'r', 
        (char const   )'e',      (char const   )'e',      (char const   )'_',      (char const   )'c', 
        (char const   )'a',      (char const   )'l',      (char const   )'l',      (char const   )'b', 
        (char const   )'a',      (char const   )'c',      (char const   )'k',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_gnttab_cancel_free_callback  __attribute__((__used__,
__unused__, __section__("__ksymtab_gpl")))  =    {(unsigned long )(& gnttab_cancel_free_callback), __kstrtab_gnttab_cancel_free_callback};
static int grow_gnttab_list(unsigned int more_frames ) 
{ unsigned int new_nr_grant_frames ;
  unsigned int extra_entries ;
  unsigned int i ;
  unsigned int nr_glist_frames ;
  unsigned int new_nr_glist_frames ;
  unsigned long tmp ;
  grant_ref_t *tmp___0 ;
  grant_ref_t *tmp___1 ;

  {
  {
  new_nr_grant_frames = nr_grant_frames + more_frames;
  extra_entries = (unsigned int )((unsigned long )more_frames * ((1UL << 12) / (unsigned long )sizeof(struct grant_entry )));
  nr_glist_frames = (unsigned int )((((unsigned long )nr_grant_frames * ((1UL << 12) / (unsigned long )sizeof(struct grant_entry )) + (1UL << 12) / (unsigned long )sizeof(grant_ref_t )) - 1UL) / ((1UL << 12) / (unsigned long )sizeof(grant_ref_t )));
  new_nr_glist_frames = (unsigned int )((((unsigned long )new_nr_grant_frames * ((1UL << 12) / (unsigned long )sizeof(struct grant_entry )) + (1UL << 12) / (unsigned long )sizeof(grant_ref_t )) - 1UL) / ((1UL << 12) / (unsigned long )sizeof(grant_ref_t )));
  i = nr_glist_frames;
  }
  {
  while (1) {
    while_22_continue: /* CIL Label */ ;
    if (! (i < new_nr_glist_frames)) {
      goto while_22_break;
    }
    {
    tmp = __get_free_pages(32U, 0U);
    *(gnttab_list + i) = (grant_ref_t *)tmp;
    }
    if (! *(gnttab_list + i)) {
      goto grow_nomem;
    }
    {
    i ++;
    }
  }
  while_22_break: /* CIL Label */ ;
  }
  {
  i = (unsigned int )(((1UL << 12) / (unsigned long )sizeof(struct grant_entry )) * (unsigned long )nr_grant_frames);
  }
  {
  while (1) {
    while_23_continue: /* CIL Label */ ;
    if (! ((unsigned long )i < ((1UL << 12) / (unsigned long )sizeof(struct grant_entry )) * (unsigned long )new_nr_grant_frames - 1UL)) {
      goto while_23_break;
    }
    {
    tmp___0 = __gnttab_entry(i);
    *tmp___0 = i + 1U;
    i ++;
    }
  }
  while_23_break: /* CIL Label */ ;
  }
  {
  tmp___1 = __gnttab_entry(i);
  *tmp___1 = gnttab_free_head;
  gnttab_free_head = (unsigned int )(((1UL << 12) / (unsigned long )sizeof(struct grant_entry )) * (unsigned long )nr_grant_frames);
  gnttab_free_count = (int )((unsigned int )gnttab_free_count + extra_entries);
  nr_grant_frames = new_nr_grant_frames;
  check_free_callbacks();
  }
  return (0);
  grow_nomem: 
  {
  while (1) {
    while_24_continue: /* CIL Label */ ;
    if (! (i >= nr_glist_frames)) {
      goto while_24_break;
    }
    {
    free_pages((unsigned long )*(gnttab_list + i), 0U);
    i --;
    }
  }
  while_24_break: /* CIL Label */ ;
  }
  return (-12);
}
}
static unsigned int __max_nr_grant_frames(void) 
{ struct gnttab_query_size query ;
  int rc ;

  {
  {
  query.dom = (unsigned short)32752;
  rc = HYPERVISOR_grant_table_op(6U, (void *)(& query), 1U);
  }
  if (rc < 0) {
    return (4U);
  } else {
    if ((int )query.status != 0) {
      return (4U);
    }
  }
  return (query.max_nr_frames);
}
}
__inline static unsigned int max_nr_grant_frames(void) 
{ unsigned int xen_max ;
  unsigned int tmp ;

  {
  {
  tmp = __max_nr_grant_frames();
  xen_max = tmp;
  }
  if (xen_max > boot_max_nr_grant_frames) {
    return (boot_max_nr_grant_frames);
  }
  return (xen_max);
}
}
static int gnttab_map(unsigned int start_idx , unsigned int end_idx ) 
{ struct gnttab_setup_table setup ;
  unsigned long *frames ;
  unsigned int nr_gframes ;
  int rc ;
  void *tmp ;
  int tmp___0 ;
  long tmp___1 ;
  unsigned int tmp___2 ;
  long tmp___3 ;

  {
  {
  nr_gframes = end_idx + 1U;
  tmp = kmalloc(nr_gframes * sizeof(unsigned long ), 32U);
  frames = (unsigned long *)tmp;
  }
  if (! frames) {
    return (-12);
  }
  {
  setup.dom = (unsigned short)32752;
  setup.nr_frames = nr_gframes;
  }
  {
  while (1) {
    while_25_continue: /* CIL Label */ ;
    if (sizeof(setup.frame_list) == 8U) {
      {
      *((uint64_t *)(& setup.frame_list)) = 0ULL;
      }
    }
    {
    setup.frame_list = frames;
    }
    goto while_25_break;
  }
  while_25_break: /* CIL Label */ ;
  }
  {
  rc = HYPERVISOR_grant_table_op(2U, (void *)(& setup), 1U);
  }
  if (rc == -38) {
    {
    kfree((void const   *)frames);
    }
    return (-38);
  }
  {
  while (1) {
    while_26_continue: /* CIL Label */ ;
    if (rc) {
      {
      tmp___0 = 1;
      }
    } else {
      if (setup.status) {
        {
        tmp___0 = 1;
        }
      } else {
        {
        tmp___0 = 0;
        }
      }
    }
    {
    tmp___1 = __builtin_expect((long )tmp___0, 0L);
    }
    if (tmp___1) {
      {
      while (1) {
        while_27_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("xen/grant-table.c"), "i" (463),
                             "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_28_continue: /* CIL Label */ ;
        }
        while_28_break: /* CIL Label */ ;
        }
        goto while_27_break;
      }
      while_27_break: /* CIL Label */ ;
      }
    }
    goto while_26_break;
  }
  while_26_break: /* CIL Label */ ;
  }
  {
  tmp___2 = max_nr_grant_frames();
  rc = arch_gnttab_map_shared(frames, (unsigned long )nr_gframes, (unsigned long )tmp___2,
                              & shared);
  }
  {
  while (1) {
    while_29_continue: /* CIL Label */ ;
    {
    tmp___3 = __builtin_expect((long )(! (! rc)), 0L);
    }
    if (tmp___3) {
      {
      while (1) {
        while_30_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("xen/grant-table.c"), "i" (467),
                             "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_31_continue: /* CIL Label */ ;
        }
        while_31_break: /* CIL Label */ ;
        }
        goto while_30_break;
      }
      while_30_break: /* CIL Label */ ;
      }
    }
    goto while_29_break;
  }
  while_29_break: /* CIL Label */ ;
  }
  {
  kfree((void const   *)frames);
  }
  return (0);
}
}
int gnttab_resume(void) 
{ unsigned int tmp ;
  int tmp___0 ;

  {
  {
  tmp = max_nr_grant_frames();
  }
  if (tmp < nr_grant_frames) {
    return (-38);
  }
  {
  tmp___0 = gnttab_map(0U, nr_grant_frames - 1U);
  }
  return (tmp___0);
}
}
int gnttab_suspend(void) 
{ 

  {
  {
  arch_gnttab_unmap_shared(shared, (unsigned long )nr_grant_frames);
  }
  return (0);
}
}
static int gnttab_expand(unsigned int req_entries ) 
{ int rc ;
  unsigned int cur ;
  unsigned int extra ;
  unsigned int tmp ;

  {
  {
  cur = nr_grant_frames;
  extra = (unsigned int )(((unsigned long )req_entries + ((1UL << 12) / (unsigned long )sizeof(struct grant_entry ) - 1UL)) / ((1UL << 12) / (unsigned long )sizeof(struct grant_entry )));
  tmp = max_nr_grant_frames();
  }
  if (cur + extra > tmp) {
    return (-28);
  }
  {
  rc = gnttab_map(cur, (cur + extra) - 1U);
  }
  if (rc == 0) {
    {
    rc = grow_gnttab_list(extra);
    }
  }
  return (rc);
}
}
static int __attribute__((__cold__))  gnttab_init(void)  __attribute__((__section__(".devinit.text"))) ;
static int __attribute__((__cold__))  gnttab_init(void) 
{ int i ;
  unsigned int max_nr_glist_frames ;
  unsigned int nr_glist_frames ;
  unsigned int nr_init_grefs ;
  int tmp ;
  void *tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  grant_ref_t *tmp___3 ;
  grant_ref_t *tmp___4 ;

  {
  if (xen_start_info) {
    {
    tmp = 1;
    }
  } else {
    {
    tmp = 0;
    }
  }
  if (! tmp) {
    return ((int __attribute__((__cold__))  )-19);
  }
  {
  nr_grant_frames = 1U;
  boot_max_nr_grant_frames = __max_nr_grant_frames();
  max_nr_glist_frames = (unsigned int )(((unsigned long )boot_max_nr_grant_frames * ((1UL << 12) / (unsigned long )sizeof(struct grant_entry ))) / ((1UL << 12) / (unsigned long )sizeof(grant_ref_t )));
  tmp___0 = kmalloc(max_nr_glist_frames * sizeof(grant_ref_t *), 208U);
  gnttab_list = (grant_ref_t **)tmp___0;
  }
  if ((unsigned int )gnttab_list == (unsigned int )((void *)0)) {
    return ((int __attribute__((__cold__))  )-12);
  }
  {
  nr_glist_frames = (unsigned int )((((unsigned long )nr_grant_frames * ((1UL << 12) / (unsigned long )sizeof(struct grant_entry )) + (1UL << 12) / (unsigned long )sizeof(grant_ref_t )) - 1UL) / ((1UL << 12) / (unsigned long )sizeof(grant_ref_t )));
  i = 0;
  }
  {
  while (1) {
    while_32_continue: /* CIL Label */ ;
    if (! ((unsigned int )i < nr_glist_frames)) {
      goto while_32_break;
    }
    {
    tmp___1 = __get_free_pages(208U, 0U);
    *(gnttab_list + i) = (grant_ref_t *)tmp___1;
    }
    if ((unsigned int )*(gnttab_list + i) == (unsigned int )((void *)0)) {
      goto ini_nomem;
    }
    {
    i ++;
    }
  }
  while_32_break: /* CIL Label */ ;
  }
  {
  tmp___2 = gnttab_resume();
  }
  if (tmp___2 < 0) {
    return ((int __attribute__((__cold__))  )-19);
  }
  {
  nr_init_grefs = (unsigned int )((unsigned long )nr_grant_frames * ((1UL << 12) / (unsigned long )sizeof(struct grant_entry )));
  i = 8;
  }
  {
  while (1) {
    while_33_continue: /* CIL Label */ ;
    if (! ((unsigned int )i < nr_init_grefs - 1U)) {
      goto while_33_break;
    }
    {
    tmp___3 = __gnttab_entry((unsigned int )i);
    *tmp___3 = (unsigned int )(i + 1);
    i ++;
    }
  }
  while_33_break: /* CIL Label */ ;
  }
  {
  tmp___4 = __gnttab_entry(nr_init_grefs - 1U);
  *tmp___4 = 4294967295U;
  gnttab_free_count = (int )(nr_init_grefs - 8U);
  gnttab_free_head = 8U;
  printk("Grant table initialized\n");
  }
  return ((int __attribute__((__cold__))  )0);
  ini_nomem: 
  {
  i --;
  }
  {
  while (1) {
    while_34_continue: /* CIL Label */ ;
    if (! (i >= 0)) {
      goto while_34_break;
    }
    {
    free_pages((unsigned long )*(gnttab_list + i), 0U);
    i --;
    }
  }
  while_34_break: /* CIL Label */ ;
  }
  {
  kfree((void const   *)gnttab_list);
  }
  return ((int __attribute__((__cold__))  )-12);
}
}
static int (*__initcall_gnttab_init1)(void)  __attribute__((__used__, __section__(".initcall1.init")))  =    (int (*)(void))(& gnttab_init);
