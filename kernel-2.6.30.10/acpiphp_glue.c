/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

typedef unsigned short __kernel_mode_t;
typedef unsigned short __kernel_nlink_t;
typedef long __kernel_off_t;
typedef unsigned int __kernel_size_t;
typedef int __kernel_ssize_t;
typedef long __kernel_time_t;
typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;
typedef long long __kernel_loff_t;
typedef signed char __s8;
typedef unsigned char __u8;
typedef short __s16;
typedef unsigned short __u16;
typedef int __s32;
typedef unsigned int __u32;
typedef unsigned long long __u64;
typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned int u32;
typedef unsigned long long u64;
typedef unsigned short umode_t;
typedef __u32 __kernel_dev_t;
typedef __kernel_dev_t dev_t;
typedef __kernel_mode_t mode_t;
typedef __kernel_nlink_t nlink_t;
typedef __kernel_off_t off_t;
typedef __kernel_uid32_t uid_t;
typedef __kernel_gid32_t gid_t;
typedef __kernel_loff_t loff_t;
typedef __kernel_size_t size_t;
typedef __kernel_ssize_t ssize_t;
typedef __kernel_time_t time_t;
typedef u64 sector_t;
typedef u64 blkcnt_t;
typedef unsigned int gfp_t;
typedef u32 resource_size_t;
struct task_struct;
struct task_struct;
struct mm_struct;
struct mm_struct;
struct vm86_regs {
   long ebx ;
   long ecx ;
   long edx ;
   long esi ;
   long edi ;
   long ebp ;
   long eax ;
   long __null_ds ;
   long __null_es ;
   long __null_fs ;
   long __null_gs ;
   long orig_eax ;
   long eip ;
   unsigned short cs ;
   unsigned short __csh ;
   long eflags ;
   long esp ;
   unsigned short ss ;
   unsigned short __ssh ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
struct revectored_struct {
   unsigned long __map[8] ;
};
struct vm86_struct {
   struct vm86_regs regs ;
   unsigned long flags ;
   unsigned long screen_bitmap ;
   unsigned long cpu_type ;
   struct revectored_struct int_revectored ;
   struct revectored_struct int21_revectored ;
};
struct task_struct;
struct task_struct;
struct info {
   long ___orig_eip ;
   long ___ebx ;
   long ___ecx ;
   long ___edx ;
   long ___esi ;
   long ___edi ;
   long ___ebp ;
   long ___eax ;
   long ___ds ;
   long ___es ;
   long ___fs ;
   long ___orig_eax ;
   long ___eip ;
   long ___cs ;
   long ___eflags ;
   long ___esp ;
   long ___ss ;
   long ___vm86_es ;
   long ___vm86_ds ;
   long ___vm86_fs ;
   long ___vm86_gs ;
};
struct task_struct;
struct module;
struct module;
typedef __builtin_va_list __gnuc_va_list;
typedef __gnuc_va_list va_list;
struct bug_entry {
   unsigned long bug_addr ;
   char const   *file ;
   unsigned short line ;
   unsigned short flags ;
};
struct completion;
struct completion;
struct pid;
struct pid;
typedef unsigned long pteval_t;
typedef unsigned long pgdval_t;
typedef unsigned long pgprotval_t;
union __anonunion_pte_t_10 {
   pteval_t pte ;
   pteval_t pte_low ;
};
typedef union __anonunion_pte_t_10 pte_t;
struct page;
struct __anonstruct_pgd_t_11 {
   pgdval_t pgd ;
};
typedef struct __anonstruct_pgd_t_11 pgd_t;
struct __anonstruct_pgprot_t_12 {
   pgprotval_t pgprot ;
};
typedef struct __anonstruct_pgprot_t_12 pgprot_t;
struct page;
struct __anonstruct_pud_t_13 {
   pgd_t pgd ;
};
typedef struct __anonstruct_pud_t_13 pud_t;
struct mm_struct;
struct __anonstruct_pmd_t_14 {
   pud_t pud ;
};
typedef struct __anonstruct_pmd_t_14 pmd_t;
struct __anonstruct_cpumask_t_15 {
   unsigned long bits[((64U + 8U * sizeof(long )) - 1U) / (8U * sizeof(long ))] ;
};
typedef struct __anonstruct_cpumask_t_15 cpumask_t;
enum km_type {
    KM_BOUNCE_READ = 0,
    KM_SKB_SUNRPC_DATA = 1,
    KM_SKB_DATA_SOFTIRQ = 2,
    KM_USER0 = 3,
    KM_USER1 = 4,
    KM_BIO_SRC_IRQ = 5,
    KM_BIO_DST_IRQ = 6,
    KM_PTE0 = 7,
    KM_PTE1 = 8,
    KM_IRQ0 = 9,
    KM_IRQ1 = 10,
    KM_SOFTIRQ0 = 11,
    KM_SOFTIRQ1 = 12,
    KM_TYPE_NR = 13
} ;
struct __anonstruct____missing_field_name_17 {
   unsigned int a ;
   unsigned int b ;
};
struct __anonstruct____missing_field_name_18 {
   u16 limit0 ;
   u16 base0 ;
   unsigned int base1 : 8 ;
   unsigned int type : 4 ;
   unsigned int s : 1 ;
   unsigned int dpl : 2 ;
   unsigned int p : 1 ;
   unsigned int limit : 4 ;
   unsigned int avl : 1 ;
   unsigned int l : 1 ;
   unsigned int d : 1 ;
   unsigned int g : 1 ;
   unsigned int base2 : 8 ;
};
union __anonunion____missing_field_name_16 {
   struct __anonstruct____missing_field_name_17 __annonCompField1 ;
   struct __anonstruct____missing_field_name_18 __annonCompField2 ;
};
struct desc_struct {
   union __anonunion____missing_field_name_16 __annonCompField3 ;
} __attribute__((__packed__)) ;
typedef struct desc_struct gate_desc;
struct desc_ptr {
   unsigned short size ;
   unsigned long address ;
} __attribute__((__packed__)) ;
struct page;
struct thread_struct;
struct thread_struct;
struct desc_ptr;
struct tss_struct;
struct tss_struct;
struct mm_struct;
struct desc_struct;
struct pv_init_ops {
   unsigned int (*patch)(u8 type , u16 clobber , void *insnbuf , unsigned long addr ,
                         unsigned int len ) ;
   void (*arch_setup)(void) ;
   char *(*memory_setup)(void) ;
   void (*post_allocator_init)(void) ;
   void (*banner)(void) ;
};
struct pv_lazy_ops {
   void (*enter)(void) ;
   void (*leave)(void) ;
};
struct pv_time_ops {
   void (*time_init)(void) ;
   unsigned long (*get_wallclock)(void) ;
   int (*set_wallclock)(unsigned long  ) ;
   unsigned long long (*sched_clock)(void) ;
   unsigned long (*get_tsc_khz)(void) ;
};
struct pv_cpu_ops {
   unsigned long (*get_debugreg)(int regno ) ;
   void (*set_debugreg)(int regno , unsigned long value ) ;
   void (*clts)(void) ;
   unsigned long (*read_cr0)(void) ;
   void (*write_cr0)(unsigned long  ) ;
   unsigned long (*read_cr4_safe)(void) ;
   unsigned long (*read_cr4)(void) ;
   void (*write_cr4)(unsigned long  ) ;
   void (*load_tr_desc)(void) ;
   void (*load_gdt)(struct desc_ptr  const  * ) ;
   void (*load_idt)(struct desc_ptr  const  * ) ;
   void (*store_gdt)(struct desc_ptr * ) ;
   void (*store_idt)(struct desc_ptr * ) ;
   void (*set_ldt)(void const   *desc , unsigned int entries ) ;
   unsigned long (*store_tr)(void) ;
   void (*load_tls)(struct thread_struct *t , unsigned int cpu ) ;
   void (*write_ldt_entry)(struct desc_struct *ldt , int entrynum , void const   *desc ) ;
   void (*write_gdt_entry)(struct desc_struct * , int entrynum , void const   *desc ,
                           int size ) ;
   void (*write_idt_entry)(gate_desc * , int entrynum , gate_desc const   *gate ) ;
   void (*load_sp0)(struct tss_struct *tss , struct thread_struct *t ) ;
   void (*set_iopl_mask)(unsigned int mask ) ;
   void (*wbinvd)(void) ;
   void (*io_delay)(void) ;
   void (*cpuid)(unsigned int *eax , unsigned int *ebx , unsigned int *ecx , unsigned int *edx ) ;
   u64 (*read_msr)(unsigned int msr , int *err ) ;
   int (*write_msr)(unsigned int msr , unsigned int low , unsigned int high ) ;
   u64 (*read_tsc)(void) ;
   u64 (*read_pmc)(int counter ) ;
   unsigned long long (*read_tscp)(unsigned int *aux ) ;
   void (*irq_enable_sysexit)(void) ;
   void (*usergs_sysret64)(void) ;
   void (*usergs_sysret32)(void) ;
   void (*iret)(void) ;
   void (*swapgs)(void) ;
   struct pv_lazy_ops lazy_mode ;
};
struct pv_irq_ops {
   void (*init_IRQ)(void) ;
   unsigned long (*save_fl)(void) ;
   void (*restore_fl)(unsigned long  ) ;
   void (*irq_disable)(void) ;
   void (*irq_enable)(void) ;
   void (*safe_halt)(void) ;
   void (*halt)(void) ;
};
struct pv_apic_ops {
   void (*apic_write)(unsigned long reg , u32 v ) ;
   u32 (*apic_read)(unsigned long reg ) ;
   void (*setup_boot_clock)(void) ;
   void (*setup_secondary_clock)(void) ;
   void (*startup_ipi_hook)(int phys_apicid , unsigned long start_eip , unsigned long start_esp ) ;
};
struct pv_mmu_ops {
   void (*pagetable_setup_start)(pgd_t *pgd_base ) ;
   void (*pagetable_setup_done)(pgd_t *pgd_base ) ;
   unsigned long (*read_cr2)(void) ;
   void (*write_cr2)(unsigned long  ) ;
   unsigned long (*read_cr3)(void) ;
   void (*write_cr3)(unsigned long  ) ;
   void (*activate_mm)(struct mm_struct *prev , struct mm_struct *next ) ;
   void (*dup_mmap)(struct mm_struct *oldmm , struct mm_struct *mm ) ;
   void (*exit_mmap)(struct mm_struct *mm ) ;
   void (*flush_tlb_user)(void) ;
   void (*flush_tlb_kernel)(void) ;
   void (*flush_tlb_single)(unsigned long addr ) ;
   void (*flush_tlb_others)(cpumask_t const   *cpus , struct mm_struct *mm , unsigned long va ) ;
   int (*pgd_alloc)(struct mm_struct *mm ) ;
   void (*pgd_free)(struct mm_struct *mm , pgd_t *pgd ) ;
   void (*alloc_pte)(struct mm_struct *mm , u32 pfn ) ;
   void (*alloc_pmd)(struct mm_struct *mm , u32 pfn ) ;
   void (*alloc_pmd_clone)(u32 pfn , u32 clonepfn , u32 start , u32 count ) ;
   void (*alloc_pud)(struct mm_struct *mm , u32 pfn ) ;
   void (*release_pte)(u32 pfn ) ;
   void (*release_pmd)(u32 pfn ) ;
   void (*release_pud)(u32 pfn ) ;
   void (*set_pte)(pte_t *ptep , pte_t pteval ) ;
   void (*set_pte_at)(struct mm_struct *mm , unsigned long addr , pte_t *ptep , pte_t pteval ) ;
   void (*set_pmd)(pmd_t *pmdp , pmd_t pmdval ) ;
   void (*pte_update)(struct mm_struct *mm , unsigned long addr , pte_t *ptep ) ;
   void (*pte_update_defer)(struct mm_struct *mm , unsigned long addr , pte_t *ptep ) ;
   pte_t (*ptep_modify_prot_start)(struct mm_struct *mm , unsigned long addr , pte_t *ptep ) ;
   void (*ptep_modify_prot_commit)(struct mm_struct *mm , unsigned long addr , pte_t *ptep ,
                                   pte_t pte ) ;
   pteval_t (*pte_val)(pte_t  ) ;
   pteval_t (*pte_flags)(pte_t  ) ;
   pte_t (*make_pte)(pteval_t pte ) ;
   pgdval_t (*pgd_val)(pgd_t  ) ;
   pgd_t (*make_pgd)(pgdval_t pgd ) ;
   void *(*kmap_atomic_pte)(struct page *page , enum km_type type ) ;
   struct pv_lazy_ops lazy_mode ;
   void (*set_fixmap)(unsigned int idx , unsigned long phys , pgprot_t flags ) ;
};
struct raw_spinlock;
struct raw_spinlock;
struct pv_lock_ops {
   int (*spin_is_locked)(struct raw_spinlock *lock ) ;
   int (*spin_is_contended)(struct raw_spinlock *lock ) ;
   void (*spin_lock)(struct raw_spinlock *lock ) ;
   int (*spin_trylock)(struct raw_spinlock *lock ) ;
   void (*spin_unlock)(struct raw_spinlock *lock ) ;
};
struct paravirt_patch_template {
   struct pv_init_ops pv_init_ops ;
   struct pv_time_ops pv_time_ops ;
   struct pv_cpu_ops pv_cpu_ops ;
   struct pv_irq_ops pv_irq_ops ;
   struct pv_apic_ops pv_apic_ops ;
   struct pv_mmu_ops pv_mmu_ops ;
   struct pv_lock_ops pv_lock_ops ;
};
struct task_struct;
struct x86_hw_tss {
   unsigned short back_link ;
   unsigned short __blh ;
   unsigned long sp0 ;
   unsigned short ss0 ;
   unsigned short __ss0h ;
   unsigned long sp1 ;
   unsigned short ss1 ;
   unsigned short __ss1h ;
   unsigned long sp2 ;
   unsigned short ss2 ;
   unsigned short __ss2h ;
   unsigned long __cr3 ;
   unsigned long ip ;
   unsigned long flags ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long bx ;
   unsigned long sp ;
   unsigned long bp ;
   unsigned long si ;
   unsigned long di ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short cs ;
   unsigned short __csh ;
   unsigned short ss ;
   unsigned short __ssh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
   unsigned short ldt ;
   unsigned short __ldth ;
   unsigned short trace ;
   unsigned short io_bitmap_base ;
} __attribute__((__packed__)) ;
struct tss_struct {
   struct x86_hw_tss x86_tss ;
   unsigned long io_bitmap[8192U / sizeof(long ) + 1U] ;
   unsigned long io_bitmap_max ;
   struct thread_struct *io_bitmap_owner ;
   unsigned long stack[64] ;
} __attribute__((__aligned__((1) <<  (7) ))) ;
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20] ;
   u32 status ;
};
struct __anonstruct____missing_field_name_24 {
   u64 rip ;
   u64 rdp ;
};
struct __anonstruct____missing_field_name_25 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
union __anonunion____missing_field_name_23 {
   struct __anonstruct____missing_field_name_24 __annonCompField4 ;
   struct __anonstruct____missing_field_name_25 __annonCompField5 ;
};
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_23 __annonCompField6 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32] ;
   u32 xmm_space[64] ;
   u32 padding[24] ;
} __attribute__((__aligned__(16))) ;
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct info *info ;
   u32 entry_eip ;
};
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
};
struct kmem_cache;
struct thread_struct {
   struct desc_struct tls_array[3] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long sysenter_cs ;
   unsigned long ip ;
   unsigned long fs ;
   unsigned long gs ;
   unsigned long debugreg0 ;
   unsigned long debugreg1 ;
   unsigned long debugreg2 ;
   unsigned long debugreg3 ;
   unsigned long debugreg6 ;
   unsigned long debugreg7 ;
   unsigned long cr2 ;
   unsigned long trap_no ;
   unsigned long error_code ;
   union thread_xstate *xstate ;
   struct vm86_struct *vm86_info ;
   unsigned long screen_bitmap ;
   unsigned long v86flags ;
   unsigned long v86mask ;
   unsigned long saved_sp0 ;
   unsigned int saved_fs ;
   unsigned int saved_gs ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   unsigned long debugctlmsr ;
   unsigned long ds_area_msr ;
};
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
struct hlist_node;
struct hlist_head {
   struct hlist_node *first ;
};
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
struct timespec;
struct timespec;
struct task_struct;
struct raw_spinlock {
   unsigned int slock ;
};
typedef struct raw_spinlock raw_spinlock_t;
struct __anonstruct_raw_rwlock_t_31 {
   unsigned int lock ;
};
typedef struct __anonstruct_raw_rwlock_t_31 raw_rwlock_t;
struct task_struct;
struct lock_class_key {

};
struct __anonstruct_spinlock_t_32 {
   raw_spinlock_t raw_lock ;
};
typedef struct __anonstruct_spinlock_t_32 spinlock_t;
struct __anonstruct_rwlock_t_33 {
   raw_rwlock_t raw_lock ;
};
typedef struct __anonstruct_rwlock_t_33 rwlock_t;
struct __anonstruct_atomic_t_34 {
   int counter ;
};
typedef struct __anonstruct_atomic_t_34 atomic_t;
typedef atomic_t atomic_long_t;
struct seqcount {
   unsigned int sequence ;
};
typedef struct seqcount seqcount_t;
struct timespec {
   time_t tv_sec ;
   long tv_nsec ;
};
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   uid_t uid ;
   gid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
typedef struct __wait_queue_head wait_queue_head_t;
struct task_struct;
struct page;
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
};
struct rw_semaphore;
struct rw_semaphore;
struct rw_semaphore {
   long count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
};
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
struct page;
struct file;
struct file;
struct device;
struct device;
struct pm_message {
   int event ;
};
typedef struct pm_message pm_message_t;
struct pm_ops {
   int (*prepare)(struct device *dev ) ;
   void (*complete)(struct device *dev ) ;
   int (*suspend)(struct device *dev ) ;
   int (*resume)(struct device *dev ) ;
   int (*freeze)(struct device *dev ) ;
   int (*thaw)(struct device *dev ) ;
   int (*poweroff)(struct device *dev ) ;
   int (*restore)(struct device *dev ) ;
};
struct pm_ext_ops {
   struct pm_ops base ;
   int (*suspend_noirq)(struct device *dev ) ;
   int (*resume_noirq)(struct device *dev ) ;
   int (*freeze_noirq)(struct device *dev ) ;
   int (*thaw_noirq)(struct device *dev ) ;
   int (*poweroff_noirq)(struct device *dev ) ;
   int (*restore_noirq)(struct device *dev ) ;
};
enum dpm_state {
    DPM_INVALID = 0,
    DPM_ON = 1,
    DPM_PREPARING = 2,
    DPM_RESUMING = 3,
    DPM_SUSPENDING = 4,
    DPM_OFF = 5,
    DPM_OFF_IRQ = 6
} ;
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int can_wakeup : 1 ;
   unsigned int should_wakeup : 1 ;
   enum dpm_state status ;
   struct list_head entry ;
};
struct __anonstruct_mm_context_t_38 {
   void *ldt ;
   int size ;
   struct mutex lock ;
   void *vdso ;
};
typedef struct __anonstruct_mm_context_t_38 mm_context_t;
struct pci_bus;
struct pci_bus;
struct vm_area_struct;
struct vm_area_struct;
struct file;
struct file;
struct task_struct;
struct file;
typedef __u32 Elf32_Addr;
typedef __u16 Elf32_Half;
typedef __u32 Elf32_Word;
struct elf32_sym {
   Elf32_Word st_name ;
   Elf32_Addr st_value ;
   Elf32_Word st_size ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf32_Half st_shndx ;
};
typedef struct elf32_sym Elf32_Sym;
struct kobject;
struct kobject;
struct module;
struct attribute {
   char const   *name ;
   struct module *owner ;
   mode_t mode ;
};
struct attribute_group {
   char const   *name ;
   mode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
};
struct vm_area_struct;
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct kobject * , struct bin_attribute * , char * , loff_t  ,
                   size_t  ) ;
   ssize_t (*write)(struct kobject * , struct bin_attribute * , char * , loff_t  ,
                    size_t  ) ;
   int (*mmap)(struct kobject * , struct bin_attribute *attr , struct vm_area_struct *vma ) ;
};
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
struct kref {
   atomic_t refcount ;
};
struct kset;
struct kobj_type;
struct sysfs_dirent;
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct sysfs_dirent *sd ;
   struct kref kref ;
   unsigned int state_initialized : 1 ;
   unsigned int state_in_sysfs : 1 ;
   unsigned int state_add_uevent_sent : 1 ;
   unsigned int state_remove_uevent_sent : 1 ;
};
struct kobj_type {
   void (*release)(struct kobject *kobj ) ;
   struct sysfs_ops *sysfs_ops ;
   struct attribute **default_attrs ;
};
struct kobj_uevent_env {
   char *envp[32] ;
   int envp_idx ;
   char buf[2048] ;
   int buflen ;
};
struct kset_uevent_ops {
   int (*filter)(struct kset *kset , struct kobject *kobj ) ;
   char const   *(*name)(struct kset *kset , struct kobject *kobj ) ;
   int (*uevent)(struct kset *kset , struct kobject *kobj , struct kobj_uevent_env *env ) ;
};
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops *uevent_ops ;
};
struct module;
struct module;
struct marker;
struct marker;
typedef void marker_probe_func(void *probe_private , void *call_private , char const   *fmt ,
                               va_list *args );
struct marker_probe_closure {
   marker_probe_func *func ;
   void *probe_private ;
};
struct marker {
   char const   *name ;
   char const   *format ;
   char state ;
   char ptype ;
   void (*call)(struct marker  const  *mdata , void *call_private  , ...) ;
   struct marker_probe_closure single ;
   struct marker_probe_closure *multi ;
} __attribute__((__aligned__(8))) ;
struct kmem_cache_cpu {
   void **freelist ;
   struct page *page ;
   int node ;
   unsigned int offset ;
   unsigned int objsize ;
};
struct kmem_cache_node {
   spinlock_t list_lock ;
   unsigned long nr_partial ;
   unsigned long min_partial ;
   struct list_head partial ;
   atomic_long_t nr_slabs ;
   atomic_long_t total_objects ;
   struct list_head full ;
};
struct kmem_cache_order_objects {
   unsigned long x ;
};
struct kmem_cache {
   unsigned long flags ;
   int size ;
   int objsize ;
   int offset ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_node local_node ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   struct kmem_cache_cpu *cpu_slab[64] ;
};
struct __anonstruct_local_t_98 {
   atomic_long_t a ;
};
typedef struct __anonstruct_local_t_98 local_t;
struct mod_arch_specific {

};
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
struct module;
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module * , char const   * ,
                    size_t count ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
};
struct exception_table_entry;
struct exception_table_entry;
struct notifier_block;
struct module_ref {
   local_t count ;
} __attribute__((__aligned__((1) <<  (7) ))) ;
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2
} ;
struct module_param_attrs;
struct module_sect_attrs;
struct module_notes_attrs;
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[64U - sizeof(unsigned long )] ;
   struct module_kobject mkobj ;
   struct module_param_attrs *param_attrs ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry  const  *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   void *unwind_info ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf32_Sym *symtab ;
   unsigned int num_symtab ;
   char *strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   void *percpu ;
   char *args ;
   struct marker *markers ;
   unsigned int num_markers ;
   struct list_head modules_which_use_me ;
   struct task_struct *waiter ;
   void (*exit)(void) ;
   struct module_ref ref[64] ;
};
struct device_driver;
struct device_driver;
struct module;
typedef unsigned long kernel_ulong_t;
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
struct acpi_device_id {
   __u8 id[16] ;
   kernel_ulong_t driver_data ;
};
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
struct pci_dev;
struct device;
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
struct klist_node;
struct klist_node;
struct klist {
   spinlock_t k_lock ;
   struct list_head k_list ;
   void (*get)(struct klist_node * ) ;
   void (*put)(struct klist_node * ) ;
};
struct klist_node {
   struct klist *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
   struct completion n_removed ;
};
struct semaphore {
   spinlock_t lock ;
   unsigned int count ;
   struct list_head wait_list ;
};
struct dev_archdata {
   void *acpi_handle ;
};
struct device;
struct device_driver;
struct driver_private;
struct driver_private;
struct class;
struct class;
struct class_private;
struct class_private;
struct bus_type;
struct bus_type;
struct bus_type_private;
struct bus_type_private;
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type *bus , char *buf ) ;
   ssize_t (*store)(struct bus_type *bus , char const   *buf , size_t count ) ;
};
struct device_attribute;
struct driver_attribute;
struct bus_type {
   char const   *name ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   int (*match)(struct device *dev , struct device_driver *drv ) ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*suspend_late)(struct device *dev , pm_message_t state ) ;
   int (*resume_early)(struct device *dev ) ;
   int (*resume)(struct device *dev ) ;
   struct pm_ext_ops *pm ;
   struct bus_type_private *p ;
};
struct notifier_block;
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct attribute_group **groups ;
   struct pm_ops *pm ;
   struct driver_private *p ;
};
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver *driver , char *buf ) ;
   ssize_t (*store)(struct device_driver *driver , char const   *buf , size_t count ) ;
};
struct class_attribute;
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct device_attribute *dev_attrs ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   void (*class_release)(struct class *class ) ;
   void (*dev_release)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct pm_ops *pm ;
   struct class_private *p ;
};
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class *class , char *buf ) ;
   ssize_t (*store)(struct class *class , char const   *buf , size_t count ) ;
};
struct device_type {
   char const   *name ;
   struct attribute_group **groups ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   void (*release)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct pm_ops *pm ;
};
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device *dev , struct device_attribute *attr , char *buf ) ;
   ssize_t (*store)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                    size_t count ) ;
};
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
struct dma_coherent_mem;
struct device {
   struct klist klist_children ;
   struct klist_node knode_parent ;
   struct klist_node knode_driver ;
   struct klist_node knode_bus ;
   struct device *parent ;
   struct kobject kobj ;
   char bus_id[20] ;
   char const   *init_name ;
   struct device_type *type ;
   unsigned int uevent_suppress : 1 ;
   struct semaphore sem ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *driver_data ;
   void *platform_data ;
   struct dev_pm_info power ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct list_head node ;
   struct class *class ;
   dev_t devt ;
   struct attribute_group **groups ;
   void (*release)(struct device *dev ) ;
};
struct hotplug_slot;
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
typedef int pci_power_t;
typedef unsigned int pci_channel_state_t;
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
typedef unsigned short pci_dev_flags_t;
typedef unsigned short pci_bus_flags_t;
struct pci_vpd;
struct pci_vpd;
struct proc_dir_entry;
struct pci_driver;
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_type ;
   u8 rom_base_reg ;
   u8 pin ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   int pm_cap ;
   unsigned int pme_support : 5 ;
   unsigned int d1_support : 1 ;
   unsigned int d2_support : 1 ;
   unsigned int no_d1d2 : 1 ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[12] ;
   unsigned int transparent : 1 ;
   unsigned int multifunction : 1 ;
   unsigned int is_added : 1 ;
   unsigned int is_busmaster : 1 ;
   unsigned int no_msi : 1 ;
   unsigned int block_ucfg_access : 1 ;
   unsigned int broken_parity_status : 1 ;
   unsigned int msi_enabled : 1 ;
   unsigned int msix_enabled : 1 ;
   unsigned int is_managed : 1 ;
   unsigned int is_pcie : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[12] ;
   struct bin_attribute *res_attr_wc[12] ;
   struct list_head msi_list ;
   struct pci_vpd *vpd ;
};
struct pci_ops;
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[16] ;
   struct pci_ops *ops ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char secondary ;
   unsigned char subordinate ;
   char name[48] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned int is_added : 1 ;
};
struct pci_ops {
   int (*read)(struct pci_bus *bus , unsigned int devfn , int where , int size , u32 *val ) ;
   int (*write)(struct pci_bus *bus , unsigned int devfn , int where , int size ,
                u32 val ) ;
};
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
   unsigned int use_driver_data : 1 ;
};
typedef unsigned int pci_ers_result_t;
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev *dev , enum pci_channel_state error ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev *dev ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev *dev ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev *dev ) ;
   void (*resume)(struct pci_dev *dev ) ;
};
struct module;
struct pci_driver {
   struct list_head node ;
   char *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev *dev , struct pci_device_id  const  *id ) ;
   void (*remove)(struct pci_dev *dev ) ;
   int (*suspend)(struct pci_dev *dev , pm_message_t state ) ;
   int (*suspend_late)(struct pci_dev *dev , pm_message_t state ) ;
   int (*resume_early)(struct pci_dev *dev ) ;
   int (*resume)(struct pci_dev *dev ) ;
   void (*shutdown)(struct pci_dev *dev ) ;
   struct pm_ext_ops *pm ;
   struct pci_error_handlers *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
struct pci_dev;
struct vm_area_struct;
struct rb_node {
   unsigned long rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
} __attribute__((__aligned__(sizeof(long )))) ;
struct rb_root {
   struct rb_node *rb_node ;
};
struct prio_tree_node;
struct raw_prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
};
struct prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
   unsigned long start ;
   unsigned long last ;
};
struct prio_tree_root {
   struct prio_tree_node *prio_tree_node ;
   unsigned short index_bits ;
   unsigned short raw ;
};
struct task_struct;
struct task_struct;
struct address_space;
struct address_space;
typedef atomic_long_t mm_counter_t;
struct __anonstruct____missing_field_name_101 {
   u16 inuse ;
   u16 objects ;
};
union __anonunion____missing_field_name_100 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_101 __annonCompField10 ;
};
struct __anonstruct____missing_field_name_103 {
   unsigned long private ;
   struct address_space *mapping ;
};
union __anonunion____missing_field_name_102 {
   struct __anonstruct____missing_field_name_103 __annonCompField12 ;
   spinlock_t ptl ;
   struct kmem_cache *slab ;
   struct page *first_page ;
};
union __anonunion____missing_field_name_104 {
   unsigned long index ;
   void *freelist ;
};
struct page {
   unsigned long flags ;
   atomic_t _count ;
   union __anonunion____missing_field_name_100 __annonCompField11 ;
   union __anonunion____missing_field_name_102 __annonCompField13 ;
   union __anonunion____missing_field_name_104 __annonCompField14 ;
   struct list_head lru ;
   unsigned long page_cgroup ;
};
struct __anonstruct_vm_set_106 {
   struct list_head list ;
   void *parent ;
   struct vm_area_struct *head ;
};
union __anonunion_shared_105 {
   struct __anonstruct_vm_set_106 vm_set ;
   struct raw_prio_tree_node prio_tree_node ;
};
struct anon_vma;
struct vm_operations_struct;
struct vm_area_struct {
   struct mm_struct *vm_mm ;
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct rb_node vm_rb ;
   union __anonunion_shared_105 shared ;
   struct list_head anon_vma_node ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   unsigned long vm_truncate_count ;
};
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
struct kioctx;
struct mmu_notifier_mm;
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   struct vm_area_struct *mmap_cache ;
   unsigned long (*get_unmapped_area)(struct file *filp , unsigned long addr , unsigned long len ,
                                      unsigned long pgoff , unsigned long flags ) ;
   void (*unmap_area)(struct mm_struct *mm , unsigned long addr ) ;
   unsigned long mmap_base ;
   unsigned long task_size ;
   unsigned long cached_hole_size ;
   unsigned long free_area_cache ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   int map_count ;
   struct rw_semaphore mmap_sem ;
   spinlock_t page_table_lock ;
   struct list_head mmlist ;
   mm_counter_t _file_rss ;
   mm_counter_t _anon_rss ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long reserved_vm ;
   unsigned long def_flags ;
   unsigned long nr_ptes ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[40] ;
   cpumask_t cpu_vm_mask ;
   mm_context_t context ;
   unsigned int faultstamp ;
   unsigned int token_priority ;
   unsigned int last_interval ;
   unsigned long flags ;
   struct core_state *core_state ;
   rwlock_t ioctx_list_lock ;
   struct kioctx *ioctx_list ;
   struct task_struct *owner ;
   struct file *exe_file ;
   unsigned long num_exe_file_vmas ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
};
struct anon_vma;
struct file_ra_state;
struct file_ra_state;
struct writeback_control;
struct writeback_control;
struct file;
struct mm_struct;
struct vm_area_struct;
struct vm_area_struct;
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *page ;
};
struct vm_operations_struct {
   void (*open)(struct vm_area_struct *area ) ;
   void (*close)(struct vm_area_struct *area ) ;
   int (*fault)(struct vm_area_struct *vma , struct vm_fault *vmf ) ;
   int (*page_mkwrite)(struct vm_area_struct *vma , struct page *page ) ;
   int (*access)(struct vm_area_struct *vma , unsigned long addr , void *buf , int len ,
                 int write ) ;
};
struct inode;
struct inode;
struct page;
struct pci_sysdata {
   int domain ;
   int node ;
};
struct pci_dev;
enum pci_bus_speed {
    PCI_SPEED_33MHz = 0,
    PCI_SPEED_66MHz = 1,
    PCI_SPEED_66MHz_PCIX = 2,
    PCI_SPEED_100MHz_PCIX = 3,
    PCI_SPEED_133MHz_PCIX = 4,
    PCI_SPEED_66MHz_PCIX_ECC = 5,
    PCI_SPEED_100MHz_PCIX_ECC = 6,
    PCI_SPEED_133MHz_PCIX_ECC = 7,
    PCI_SPEED_66MHz_PCIX_266 = 9,
    PCI_SPEED_100MHz_PCIX_266 = 10,
    PCI_SPEED_133MHz_PCIX_266 = 11,
    PCI_SPEED_66MHz_PCIX_533 = 17,
    PCI_SPEED_100MHz_PCIX_533 = 18,
    PCI_SPEED_133MHz_PCIX_533 = 19,
    PCI_SPEED_UNKNOWN = 255
} ;
struct hotplug_slot;
struct hotplug_slot_ops {
   struct module *owner ;
   int (*enable_slot)(struct hotplug_slot *slot ) ;
   int (*disable_slot)(struct hotplug_slot *slot ) ;
   int (*set_attention_status)(struct hotplug_slot *slot , u8 value ) ;
   int (*hardware_test)(struct hotplug_slot *slot , u32 value ) ;
   int (*get_power_status)(struct hotplug_slot *slot , u8 *value ) ;
   int (*get_attention_status)(struct hotplug_slot *slot , u8 *value ) ;
   int (*get_latch_status)(struct hotplug_slot *slot , u8 *value ) ;
   int (*get_adapter_status)(struct hotplug_slot *slot , u8 *value ) ;
   int (*get_max_bus_speed)(struct hotplug_slot *slot , enum pci_bus_speed *value ) ;
   int (*get_cur_bus_speed)(struct hotplug_slot *slot , enum pci_bus_speed *value ) ;
};
struct hotplug_slot_info {
   u8 power_status ;
   u8 attention_status ;
   u8 latch_status ;
   u8 adapter_status ;
   enum pci_bus_speed max_bus_speed ;
   enum pci_bus_speed cur_bus_speed ;
};
struct hotplug_slot {
   struct hotplug_slot_ops *ops ;
   struct hotplug_slot_info *info ;
   void (*release)(struct hotplug_slot *slot ) ;
   void *private ;
   struct list_head slot_list ;
   struct pci_slot *pci_slot ;
};
struct hpp_type0 {
   u32 revision ;
   u8 cache_line_size ;
   u8 latency_timer ;
   u8 enable_serr ;
   u8 enable_perr ;
};
struct hpp_type1 {
   u32 revision ;
   u8 max_mem_read ;
   u8 avg_max_split ;
   u16 tot_max_split ;
};
struct hpp_type2 {
   u32 revision ;
   u32 unc_err_mask_and ;
   u32 unc_err_mask_or ;
   u32 unc_err_sever_and ;
   u32 unc_err_sever_or ;
   u32 cor_err_mask_and ;
   u32 cor_err_mask_or ;
   u32 adv_err_cap_and ;
   u32 adv_err_cap_or ;
   u16 pci_exp_devctl_and ;
   u16 pci_exp_devctl_or ;
   u16 pci_exp_lnkctl_and ;
   u16 pci_exp_lnkctl_or ;
   u32 sec_unc_err_sever_and ;
   u32 sec_unc_err_sever_or ;
   u32 sec_unc_err_mask_and ;
   u32 sec_unc_err_mask_or ;
};
struct hotplug_params {
   struct hpp_type0 *t0 ;
   struct hpp_type1 *t1 ;
   struct hpp_type2 *t2 ;
   struct hpp_type0 type0_data ;
   struct hpp_type1 type1_data ;
   struct hpp_type2 type2_data ;
};
typedef u32 acpi_size;
typedef u32 acpi_io_address;
typedef u32 acpi_status;
typedef char *acpi_string;
typedef void *acpi_handle;
typedef unsigned long long acpi_integer;
typedef u32 acpi_object_type;
struct __anonstruct_integer_108 {
   acpi_object_type type ;
   acpi_integer value ;
};
struct __anonstruct_string_109 {
   acpi_object_type type ;
   u32 length ;
   char *pointer ;
};
struct __anonstruct_buffer_110 {
   acpi_object_type type ;
   u32 length ;
   u8 *pointer ;
};
struct __anonstruct_package_111 {
   acpi_object_type type ;
   u32 count ;
   union acpi_object *elements ;
};
struct __anonstruct_reference_112 {
   acpi_object_type type ;
   acpi_object_type actual_type ;
   acpi_handle handle ;
};
struct __anonstruct_processor_113 {
   acpi_object_type type ;
   u32 proc_id ;
   acpi_io_address pblk_address ;
   u32 pblk_length ;
};
struct __anonstruct_power_resource_114 {
   acpi_object_type type ;
   u32 system_level ;
   u32 resource_order ;
};
union acpi_object {
   acpi_object_type type ;
   struct __anonstruct_integer_108 integer ;
   struct __anonstruct_string_109 string ;
   struct __anonstruct_buffer_110 buffer ;
   struct __anonstruct_package_111 package ;
   struct __anonstruct_reference_112 reference ;
   struct __anonstruct_processor_113 processor ;
   struct __anonstruct_power_resource_114 power_resource ;
};
struct acpi_object_list {
   u32 count ;
   union acpi_object *pointer ;
};
struct acpi_buffer {
   acpi_size length ;
   void *pointer ;
};
struct acpi_compatible_id {
   char value[48] ;
};
struct acpi_compatible_id_list {
   u32 count ;
   u32 size ;
   struct acpi_compatible_id id[1] ;
};
struct acpi_pci_id {
   u16 segment ;
   u16 bus ;
   u16 device ;
   u16 function ;
};
#pragma pack(1)
#pragma pack()
#pragma pack(1)
#pragma pack()
#pragma pack(1)
struct acpi_subtable_header {
   u8 type ;
   u8 length ;
};
struct acpi_madt_io_apic {
   struct acpi_subtable_header header ;
   u8 id ;
   u8 reserved ;
   u32 address ;
   u32 global_irq_base ;
};
struct acpi_madt_io_sapic {
   struct acpi_subtable_header header ;
   u8 id ;
   u8 reserved ;
   u32 global_irq_base ;
   u64 address ;
};
#pragma pack()
#pragma pack(4)
#pragma pack()
struct acpi_handle_list {
   u32 count ;
   acpi_handle handles[10] ;
};
struct rcu_head {
   struct rcu_head *next ;
   void (*func)(struct rcu_head *head ) ;
};
struct nameidata;
struct nameidata;
struct path;
struct path;
struct vfsmount;
struct vfsmount;
struct qstr {
   unsigned int hash ;
   unsigned int len ;
   unsigned char const   *name ;
};
struct dcookie_struct;
struct dcookie_struct;
union __anonunion_d_u_120 {
   struct list_head d_child ;
   struct rcu_head d_rcu ;
};
struct dentry_operations;
struct super_block;
struct dentry {
   atomic_t d_count ;
   unsigned int d_flags ;
   spinlock_t d_lock ;
   struct inode *d_inode ;
   struct hlist_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct list_head d_lru ;
   union __anonunion_d_u_120 d_u ;
   struct list_head d_subdirs ;
   struct list_head d_alias ;
   unsigned long d_time ;
   struct dentry_operations *d_op ;
   struct super_block *d_sb ;
   void *d_fsdata ;
   struct dcookie_struct *d_cookie ;
   int d_mounted ;
   unsigned char d_iname[36] ;
};
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , struct nameidata * ) ;
   int (*d_hash)(struct dentry * , struct qstr * ) ;
   int (*d_compare)(struct dentry * , struct qstr * , struct qstr * ) ;
   int (*d_delete)(struct dentry * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
};
struct dentry;
struct vfsmount;
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
struct radix_tree_node;
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
struct pid_namespace;
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3] ;
   struct rcu_head rcu ;
   struct upid numbers[1] ;
};
struct pid_namespace;
struct task_struct;
struct export_operations;
struct export_operations;
struct iovec;
struct iovec;
struct nameidata;
struct kiocb;
struct kiocb;
struct pipe_inode_info;
struct pipe_inode_info;
struct poll_table_struct;
struct poll_table_struct;
struct kstatfs;
struct kstatfs;
struct vm_area_struct;
struct vfsmount;
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   uid_t ia_uid ;
   gid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
struct if_dqblk {
   __u64 dqb_bhardlimit ;
   __u64 dqb_bsoftlimit ;
   __u64 dqb_curspace ;
   __u64 dqb_ihardlimit ;
   __u64 dqb_isoftlimit ;
   __u64 dqb_curinodes ;
   __u64 dqb_btime ;
   __u64 dqb_itime ;
   __u32 dqb_valid ;
};
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8] ;
};
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
typedef struct fs_qfilestat fs_qfilestat_t;
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
struct v1_mem_dqinfo {

};
struct v2_mem_dqinfo {
   unsigned int dqi_blocks ;
   unsigned int dqi_free_blk ;
   unsigned int dqi_free_entry ;
};
typedef __kernel_uid32_t qid_t;
typedef __u64 qsize_t;
struct mem_dqblk {
   __u32 dqb_bhardlimit ;
   __u32 dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   __u32 dqb_ihardlimit ;
   __u32 dqb_isoftlimit ;
   __u32 dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
struct quota_format_type;
struct quota_format_type;
union __anonunion_u_124 {
   struct v1_mem_dqinfo v1_i ;
   struct v2_mem_dqinfo v2_i ;
};
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   union __anonunion_u_124 u ;
};
struct super_block;
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   unsigned int dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   short dq_type ;
   struct mem_dqblk dq_dqb ;
};
struct quota_format_ops {
   int (*check_quota_file)(struct super_block *sb , int type ) ;
   int (*read_file_info)(struct super_block *sb , int type ) ;
   int (*write_file_info)(struct super_block *sb , int type ) ;
   int (*free_file_info)(struct super_block *sb , int type ) ;
   int (*read_dqblk)(struct dquot *dquot ) ;
   int (*commit_dqblk)(struct dquot *dquot ) ;
   int (*release_dqblk)(struct dquot *dquot ) ;
};
struct dquot_operations {
   int (*initialize)(struct inode * , int  ) ;
   int (*drop)(struct inode * ) ;
   int (*alloc_space)(struct inode * , qsize_t  , int  ) ;
   int (*alloc_inode)(struct inode  const  * , unsigned long  ) ;
   int (*free_space)(struct inode * , qsize_t  ) ;
   int (*free_inode)(struct inode  const  * , unsigned long  ) ;
   int (*transfer)(struct inode * , struct iattr * ) ;
   int (*write_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
};
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , char * , int  ) ;
   int (*quota_off)(struct super_block * , int  , int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , int  , qid_t  , struct if_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , int  , qid_t  , struct if_dqblk * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
   int (*get_xquota)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
   int (*set_xquota)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
};
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2] ;
   struct mem_dqinfo info[2] ;
   struct quota_format_ops *ops[2] ;
};
struct page;
struct address_space;
struct writeback_control;
union __anonunion_arg_126 {
   char *buf ;
   void *data ;
};
struct __anonstruct_read_descriptor_t_125 {
   size_t written ;
   size_t count ;
   union __anonunion_arg_126 arg ;
   int error ;
};
typedef struct __anonstruct_read_descriptor_t_125 read_descriptor_t;
struct address_space_operations {
   int (*writepage)(struct page *page , struct writeback_control *wbc ) ;
   int (*readpage)(struct file * , struct page * ) ;
   void (*sync_page)(struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page *page ) ;
   int (*readpages)(struct file *filp , struct address_space *mapping , struct list_head *pages ,
                    unsigned int nr_pages ) ;
   int (*prepare_write)(struct file * , struct page * , unsigned int  , unsigned int  ) ;
   int (*commit_write)(struct file * , struct page * , unsigned int  , unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space *mapping , loff_t pos ,
                      unsigned int len , unsigned int flags , struct page **pagep ,
                      void **fsdata ) ;
   int (*write_end)(struct file * , struct address_space *mapping , loff_t pos , unsigned int len ,
                    unsigned int copied , struct page *page , void *fsdata ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned long  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iovec  const  *iov , loff_t offset ,
                        unsigned long nr_segs ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long  , int  , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , read_descriptor_t * , unsigned long  ) ;
};
struct backing_dev_info;
struct backing_dev_info;
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct prio_tree_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   spinlock_t i_mmap_lock ;
   unsigned int truncate_count ;
   unsigned long nrpages ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   struct address_space *assoc_mapping ;
} __attribute__((__aligned__(sizeof(long )))) ;
struct hd_struct;
struct gendisk;
struct block_device {
   dev_t bd_dev ;
   struct inode *bd_inode ;
   int bd_openers ;
   struct mutex bd_mutex ;
   struct semaphore bd_mount_sem ;
   struct list_head bd_inodes ;
   void *bd_holder ;
   int bd_holders ;
   struct list_head bd_holder_list ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct list_head bd_list ;
   struct backing_dev_info *bd_inode_backing_dev_info ;
   unsigned long bd_private ;
};
struct inode_operations;
struct file_operations;
struct file_lock;
struct cdev;
union __anonunion____missing_field_name_127 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
struct dnotify_struct;
struct inode {
   struct hlist_node i_hash ;
   struct list_head i_list ;
   struct list_head i_sb_list ;
   struct list_head i_dentry ;
   unsigned long i_ino ;
   atomic_t i_count ;
   unsigned int i_nlink ;
   uid_t i_uid ;
   gid_t i_gid ;
   dev_t i_rdev ;
   u64 i_version ;
   loff_t i_size ;
   seqcount_t i_size_seqcount ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned short i_bytes ;
   umode_t i_mode ;
   spinlock_t i_lock ;
   struct mutex i_mutex ;
   struct rw_semaphore i_alloc_sem ;
   struct inode_operations  const  *i_op ;
   struct file_operations  const  *i_fop ;
   struct super_block *i_sb ;
   struct file_lock *i_flock ;
   struct address_space *i_mapping ;
   struct address_space i_data ;
   struct dquot *i_dquot[2] ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_127 __annonCompField15 ;
   int i_cindex ;
   __u32 i_generation ;
   unsigned long i_dnotify_mask ;
   struct dnotify_struct *i_dnotify ;
   struct list_head inotify_watches ;
   struct mutex inotify_mutex ;
   unsigned long i_state ;
   unsigned long dirtied_when ;
   unsigned int i_flags ;
   atomic_t i_writecount ;
   void *i_security ;
   void *i_private ;
};
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   uid_t uid ;
   uid_t euid ;
   int signum ;
};
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   int mmap_miss ;
   loff_t prev_pos ;
};
union __anonunion_f_u_128 {
   struct list_head fu_list ;
   struct rcu_head fu_rcuhead ;
};
struct file {
   union __anonunion_f_u_128 f_u ;
   struct path f_path ;
   struct file_operations  const  *f_op ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   mode_t f_mode ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   unsigned int f_uid ;
   unsigned int f_gid ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   spinlock_t f_ep_lock ;
   struct address_space *f_mapping ;
};
struct files_struct;
typedef struct files_struct *fl_owner_t;
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
struct lock_manager_operations {
   int (*fl_compare_owner)(struct file_lock * , struct file_lock * ) ;
   void (*fl_notify)(struct file_lock * ) ;
   int (*fl_grant)(struct file_lock * , struct file_lock * , int  ) ;
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
   void (*fl_break)(struct file_lock * ) ;
   int (*fl_mylease)(struct file_lock * , struct file_lock * ) ;
   int (*fl_change)(struct file_lock ** , int  ) ;
};
struct nlm_lockowner;
struct nlm_lockowner;
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
struct nfs4_lock_state;
struct nfs4_lock_state;
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
struct fasync_struct;
struct __anonstruct_afs_130 {
   struct list_head link ;
   int state ;
};
union __anonunion_fl_u_129 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_130 afs ;
};
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned char fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   struct file_lock_operations *fl_ops ;
   struct lock_manager_operations *fl_lmops ;
   union __anonunion_fl_u_129 fl_u ;
};
struct fasync_struct {
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
};
struct file_system_type;
struct super_operations;
struct xattr_handler;
struct mtd_info;
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned long s_blocksize ;
   unsigned char s_blocksize_bits ;
   unsigned char s_dirt ;
   unsigned long long s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations *dq_op ;
   struct quotactl_ops *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   struct mutex s_lock ;
   int s_count ;
   int s_syncing ;
   int s_need_sync_fs ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler **s_xattr ;
   struct list_head s_inodes ;
   struct list_head s_dirty ;
   struct list_head s_io ;
   struct list_head s_more_io ;
   struct hlist_head s_anon ;
   struct list_head s_files ;
   struct list_head s_dentry_lru ;
   int s_nr_dentry_unused ;
   struct block_device *s_bdev ;
   struct mtd_info *s_mtd ;
   struct list_head s_instances ;
   struct quota_info s_dquot ;
   int s_frozen ;
   wait_queue_head_t s_wait_unfrozen ;
   char s_id[32] ;
   void *s_fs_info ;
   struct mutex s_vfs_rename_mutex ;
   u32 s_time_gran ;
   char *s_subtype ;
   char *s_options ;
};
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   int (*readdir)(struct file * , void * , int (*)(void * , char const   * , int  ,
                                                   loff_t  , u64  , unsigned int  ) ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   int (*ioctl)(struct inode * , struct file * , unsigned int  , unsigned long  ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t id ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , struct dentry * , int datasync ) ;
   int (*aio_fsync)(struct kiocb * , int datasync ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*dir_notify)(struct file *filp , unsigned long arg ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** ) ;
   int (*fsetattr)(struct file * , struct iattr * ) ;
};
struct inode_operations {
   int (*create)(struct inode * , struct dentry * , int  , struct nameidata * ) ;
   struct dentry *(*lookup)(struct inode * , struct dentry * , struct nameidata * ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , int  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , int  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   void (*truncate)(struct inode * ) ;
   int (*permission)(struct inode * , int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount *mnt , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   void (*truncate_range)(struct inode * , loff_t  , loff_t  ) ;
   long (*fallocate)(struct inode *inode , int mode , loff_t offset , loff_t len ) ;
};
struct seq_file;
struct seq_file;
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block *sb ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * ) ;
   int (*write_inode)(struct inode * , int  ) ;
   void (*drop_inode)(struct inode * ) ;
   void (*delete_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   void (*write_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block *sb , int wait ) ;
   void (*write_super_lockfs)(struct super_block * ) ;
   void (*unlockfs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*clear_inode)(struct inode * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct vfsmount * ) ;
   int (*show_stats)(struct seq_file * , struct vfsmount * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
};
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   int (*get_sb)(struct file_system_type * , int  , char const   * , void * , struct vfsmount * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct list_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
   struct lock_class_key i_alloc_sem_key ;
};
struct completion;
struct mm_struct;
typedef int read_proc_t(char *page , char **start , off_t off , int count , int *eof ,
                        void *data );
typedef int write_proc_t(struct file *file , char const   *buffer , unsigned long count ,
                         void *data );
struct proc_dir_entry {
   unsigned int low_ino ;
   unsigned short namelen ;
   char const   *name ;
   mode_t mode ;
   nlink_t nlink ;
   uid_t uid ;
   gid_t gid ;
   loff_t size ;
   struct inode_operations  const  *proc_iops ;
   struct file_operations  const  *proc_fops ;
   struct module *owner ;
   struct proc_dir_entry *next ;
   struct proc_dir_entry *parent ;
   struct proc_dir_entry *subdir ;
   void *data ;
   read_proc_t *read_proc ;
   write_proc_t *write_proc ;
   atomic_t count ;
   int pde_users ;
   spinlock_t pde_unload_lock ;
   struct completion *pde_unload_completion ;
   struct list_head pde_openers ;
};
struct pid_namespace;
enum acpi_bus_removal_type {
    ACPI_BUS_REMOVAL_NORMAL = 0,
    ACPI_BUS_REMOVAL_EJECT = 1,
    ACPI_BUS_REMOVAL_SUPRISE = 2,
    ACPI_BUS_REMOVAL_TYPE_COUNT = 3
} ;
struct acpi_driver;
struct acpi_driver;
struct acpi_device;
struct acpi_device;
struct acpi_bus_ops {
   u32 acpi_op_add : 1 ;
   u32 acpi_op_remove : 1 ;
   u32 acpi_op_lock : 1 ;
   u32 acpi_op_start : 1 ;
   u32 acpi_op_stop : 1 ;
   u32 acpi_op_suspend : 1 ;
   u32 acpi_op_resume : 1 ;
   u32 acpi_op_scan : 1 ;
   u32 acpi_op_bind : 1 ;
   u32 acpi_op_unbind : 1 ;
   u32 acpi_op_shutdown : 1 ;
   u32 reserved : 21 ;
};
struct acpi_device_ops {
   int (*add)(struct acpi_device *device ) ;
   int (*remove)(struct acpi_device *device , int type ) ;
   int (*lock)(struct acpi_device *device , int type ) ;
   int (*start)(struct acpi_device *device ) ;
   int (*stop)(struct acpi_device *device , int type ) ;
   int (*suspend)(struct acpi_device *device , pm_message_t state ) ;
   int (*resume)(struct acpi_device *device ) ;
   int (*scan)(struct acpi_device *device ) ;
   int (*bind)(struct acpi_device *device ) ;
   int (*unbind)(struct acpi_device *device ) ;
   int (*shutdown)(struct acpi_device *device ) ;
};
struct acpi_driver {
   char name[80] ;
   char class[80] ;
   struct acpi_device_id  const  *ids ;
   struct acpi_device_ops ops ;
   struct device_driver drv ;
   struct module *owner ;
};
struct acpi_device_status {
   u32 present : 1 ;
   u32 enabled : 1 ;
   u32 show_in_ui : 1 ;
   u32 functional : 1 ;
   u32 battery_present : 1 ;
   u32 reserved : 27 ;
};
struct acpi_device_flags {
   u32 dynamic_status : 1 ;
   u32 hardware_id : 1 ;
   u32 compatible_ids : 1 ;
   u32 bus_address : 1 ;
   u32 unique_id : 1 ;
   u32 removable : 1 ;
   u32 ejectable : 1 ;
   u32 lockable : 1 ;
   u32 suprise_removal_ok : 1 ;
   u32 power_manageable : 1 ;
   u32 performance_manageable : 1 ;
   u32 wake_capable : 1 ;
   u32 force_power_state : 1 ;
   u32 reserved : 19 ;
};
struct acpi_device_dir {
   struct proc_dir_entry *entry ;
};
typedef char acpi_bus_id[5];
typedef unsigned long acpi_bus_address;
typedef char acpi_hardware_id[15];
typedef char acpi_unique_id[9];
typedef char acpi_device_name[40];
typedef char acpi_device_class[20];
struct acpi_device_pnp {
   acpi_bus_id bus_id ;
   acpi_bus_address bus_address ;
   acpi_hardware_id hardware_id ;
   struct acpi_compatible_id_list *cid_list ;
   acpi_unique_id unique_id ;
   acpi_device_name device_name ;
   acpi_device_class device_class ;
};
struct acpi_device_power_flags {
   u32 explicit_get : 1 ;
   u32 power_resources : 1 ;
   u32 inrush_current : 1 ;
   u32 power_removed : 1 ;
   u32 reserved : 28 ;
};
struct __anonstruct_flags_134 {
   u8 valid : 1 ;
   u8 explicit_set : 1 ;
   u8 reserved : 6 ;
};
struct acpi_device_power_state {
   struct __anonstruct_flags_134 flags ;
   int power ;
   int latency ;
   struct acpi_handle_list resources ;
};
struct acpi_device_power {
   int state ;
   struct acpi_device_power_flags flags ;
   struct acpi_device_power_state states[4] ;
};
struct acpi_device_perf_flags {
   u8 reserved : 8 ;
};
struct __anonstruct_flags_135 {
   u8 valid : 1 ;
   u8 reserved : 7 ;
};
struct acpi_device_perf_state {
   struct __anonstruct_flags_135 flags ;
   u8 power ;
   u8 performance ;
   int latency ;
};
struct acpi_device_perf {
   int state ;
   struct acpi_device_perf_flags flags ;
   int state_count ;
   struct acpi_device_perf_state *states ;
};
struct acpi_device_wakeup_flags {
   u8 valid : 1 ;
   u8 prepared : 1 ;
   u8 run_wake : 1 ;
};
struct acpi_device_wakeup_state {
   u8 enabled : 1 ;
};
struct acpi_device_wakeup {
   acpi_handle gpe_device ;
   acpi_integer gpe_number ;
   acpi_integer sleep_state ;
   struct acpi_handle_list resources ;
   struct acpi_device_wakeup_state state ;
   struct acpi_device_wakeup_flags flags ;
};
struct acpi_device {
   acpi_handle handle ;
   struct acpi_device *parent ;
   struct list_head children ;
   struct list_head node ;
   struct list_head wakeup_list ;
   struct list_head g_list ;
   struct acpi_device_status status ;
   struct acpi_device_flags flags ;
   struct acpi_device_pnp pnp ;
   struct acpi_device_power power ;
   struct acpi_device_wakeup wakeup ;
   struct acpi_device_perf performance ;
   struct acpi_device_dir dir ;
   struct acpi_device_ops ops ;
   struct acpi_driver *driver ;
   void *driver_data ;
   struct device dev ;
   struct acpi_bus_ops bus_ops ;
   enum acpi_bus_removal_type removal_type ;
};
struct pci_vpd_ops {
   int (*read)(struct pci_dev *dev , int pos , int size , char *buf ) ;
   int (*write)(struct pci_dev *dev , int pos , int size , char const   *buf ) ;
   void (*release)(struct pci_dev *dev ) ;
};
struct pci_vpd {
   unsigned int len ;
   struct pci_vpd_ops *ops ;
   struct bin_attribute *attr ;
};
struct pci_bus;
struct pci_dev;
struct acpi_pci_driver {
   struct acpi_pci_driver *next ;
   int (*add)(acpi_handle handle ) ;
   void (*remove)(acpi_handle handle ) ;
};
struct acpiphp_bridge;
struct acpiphp_bridge;
struct acpiphp_slot;
struct acpiphp_slot;
struct slot {
   struct hotplug_slot *hotplug_slot ;
   struct acpiphp_slot *acpi_slot ;
   struct hotplug_slot_info info ;
};
struct acpiphp_func;
struct acpiphp_bridge {
   struct list_head list ;
   acpi_handle handle ;
   struct acpiphp_slot *slots ;
   struct acpiphp_func *func ;
   int type ;
   int nr_slots ;
   u32 flags ;
   struct pci_bus *pci_bus ;
   struct pci_dev *pci_dev ;
   struct hotplug_params hpp ;
   spinlock_t res_lock ;
};
struct acpiphp_slot {
   struct acpiphp_slot *next ;
   struct acpiphp_bridge *bridge ;
   struct list_head funcs ;
   struct slot *slot ;
   struct mutex crit_sect ;
   u8 device ;
   u32 sun ;
   u32 flags ;
};
struct acpiphp_func {
   struct acpiphp_slot *slot ;
   struct acpiphp_bridge *bridge ;
   struct list_head sibling ;
   struct pci_dev *pci_dev ;
   struct notifier_block nb ;
   acpi_handle handle ;
   u8 function ;
   u32 flags ;
};
struct acpiphp_ioapic {
   struct pci_dev *dev ;
   u32 gsi_base ;
   struct list_head list ;
};
extern int ( /* format attribute */ __attribute__((__regparm__(0))) printk)(char const   *fmt 
                                                                            , ...)  __attribute__((__cold__)) ;
__inline static void *( __attribute__((__always_inline__)) __constant_c_and_count_memset)(void *s ,
                                                                                          unsigned long pattern ,
                                                                                          size_t count ) 
{ int d0 ;
  int d1 ;
  unsigned long eax ;

  {
  if ((int )count == 0) {
    goto switch_0_0;
  } else {
    if ((int )count == 1) {
      goto switch_0_1;
    } else {
      if ((int )count == 2) {
        goto switch_0_2;
      } else {
        if ((int )count == 3) {
          goto switch_0_3;
        } else {
          if ((int )count == 4) {
            goto switch_0_4;
          } else {
            if (0) {
              switch_0_0: /* CIL Label */ 
              return (s);
              switch_0_1: /* CIL Label */ 
              {
              *((unsigned char *)s) = (unsigned char )(pattern & 255UL);
              }
              return (s);
              switch_0_2: /* CIL Label */ 
              {
              *((unsigned short *)s) = (unsigned short )(pattern & 65535UL);
              }
              return (s);
              switch_0_3: /* CIL Label */ 
              {
              *((unsigned short *)s) = (unsigned short )(pattern & 65535UL);
              *((unsigned char *)s + 2) = (unsigned char )(pattern & 255UL);
              }
              return (s);
              switch_0_4: /* CIL Label */ 
              {
              *((unsigned long *)s) = pattern;
              }
              return (s);
            } else {
              switch_0_break: /* CIL Label */ ;
            }
          }
        }
      }
    }
  }
  {
  eax = pattern;
  }
  if ((int )(count % 4U) == 0) {
    goto switch_1_0;
  } else {
    if ((int )(count % 4U) == 1) {
      goto switch_1_1;
    } else {
      if ((int )(count % 4U) == 2) {
        goto switch_1_2;
      } else {
        {
        goto switch_1_default;
        if (0) {
          switch_1_0: /* CIL Label */ 
          {
          __asm__  volatile   ("rep ; stosl"
                               "": "=&c" (d0), "=&D" (d1): "a" (eax), "0" (count / 4U),
                               "1" ((long )s): "memory");
          }
          return (s);
          switch_1_1: /* CIL Label */ 
          {
          __asm__  volatile   ("rep ; stosl"
                               "\n\tstosb": "=&c" (d0), "=&D" (d1): "a" (eax), "0" (count / 4U),
                               "1" ((long )s): "memory");
          }
          return (s);
          switch_1_2: /* CIL Label */ 
          {
          __asm__  volatile   ("rep ; stosl"
                               "\n\tstosw": "=&c" (d0), "=&D" (d1): "a" (eax), "0" (count / 4U),
                               "1" ((long )s): "memory");
          }
          return (s);
          switch_1_default: /* CIL Label */ 
          {
          __asm__  volatile   ("rep ; stosl"
                               "\n\tstosw\n\tstosb": "=&c" (d0), "=&D" (d1): "a" (eax),
                               "0" (count / 4U), "1" ((long )s): "memory");
          }
          return (s);
        } else {
          switch_1_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
}
}
extern struct pv_lock_ops pv_lock_ops ;
__inline static void ( __attribute__((__always_inline__)) __raw_spin_unlock)(struct raw_spinlock *lock ) 
{ unsigned long __eax ;
  unsigned long __edx ;
  unsigned long __ecx ;

  {
  {
  __asm__  volatile   (""
                       "771:\n\t"
                       "call *%[paravirt_opptr];"
                       "\n"
                       "772:\n"
                       ".pushsection .parainstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       " 771b\n"
                       "  .byte "
                       "%c[paravirt_typenum]"
                       "\n"
                       "  .byte 772b-771b\n"
                       "  .short "
                       "%c[paravirt_clobber]"
                       "\n"
                       ".popsection\n"
                       "": "=a" (__eax), "=d" (__edx), "=c" (__ecx): [paravirt_typenum] "i" ((unsigned int )(& ((struct paravirt_patch_template *)0)->pv_lock_ops.spin_unlock) / sizeof(void *)),
                       [paravirt_opptr] "m" (pv_lock_ops.spin_unlock), [paravirt_clobber] "i" ((1 << 3) - 1),
                       "0" ((unsigned long )lock): "memory", "cc");
  }
  return;
}
}
__inline static void prefetch(void const   *x ) 
{ 

  {
  {
  __asm__  volatile   ("661:\n\t"
                       ".byte 0x8d,0x74,0x26,0x00\n"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "prefetchnta (%1)"
                       "\n664:\n"
                       ".previous": : "i" (25), "r" (x));
  }
  return;
}
}
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 

  {
  {
  list->next = list;
  list->prev = list;
  }
  return;
}
}
__inline static void __list_add(struct list_head *new , struct list_head *prev , struct list_head *next ) 
{ 

  {
  {
  next->prev = new;
  new->next = next;
  new->prev = prev;
  prev->next = new;
  }
  return;
}
}
__inline static void list_add(struct list_head *new , struct list_head *head ) 
{ 

  {
  {
  __list_add(new, head, head->next);
  }
  return;
}
}
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 

  {
  {
  __list_add(new, head->prev, head);
  }
  return;
}
}
__inline static void __list_del(struct list_head *prev , struct list_head *next ) 
{ 

  {
  {
  next->prev = prev;
  prev->next = next;
  }
  return;
}
}
__inline static void list_del(struct list_head *entry ) 
{ 

  {
  {
  __list_del(entry->prev, entry->next);
  entry->next = (struct list_head *)((void *)1048832);
  entry->prev = (struct list_head *)((void *)2097664);
  }
  return;
}
}
register unsigned long current_stack_pointer  __asm__("esp") __attribute__((__used__))  ;
extern void _spin_lock(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void __mutex_init(struct mutex *lock , char const   *name , struct lock_class_key *key ) ;
extern void mutex_lock(struct mutex *lock ) ;
extern void mutex_unlock(struct mutex *lock ) ;
extern void kfree(void const   * ) ;
extern void *__kmalloc(size_t size , gfp_t flags ) ;
__inline static void *( __attribute__((__always_inline__)) kmalloc)(size_t size ,
                                                                    gfp_t flags ) 
{ void *tmp___2 ;

  {
  {
  tmp___2 = __kmalloc(size, flags);
  }
  return (tmp___2);
}
}
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ void *tmp ;

  {
  {
  tmp = kmalloc(size, flags | 32768U);
  }
  return (tmp);
}
}
__inline static char const   *dev_name(struct device  const  *dev ) 
{ 

  {
  return ((char const   *)(dev->bus_id));
}
}
extern struct pci_bus *pci_find_bus(int domain , int busnr ) ;
extern void pci_bus_add_devices(struct pci_bus *bus ) ;
extern int pci_scan_slot(struct pci_bus *bus , int devfn ) ;
extern struct pci_dev *pci_dev_get(struct pci_dev *dev ) ;
extern void pci_dev_put(struct pci_dev *dev ) ;
extern void pci_remove_bus_device(struct pci_dev *dev ) ;
extern void pci_stop_bus_device(struct pci_dev *dev ) ;
extern struct pci_dev *pci_get_slot(struct pci_bus *bus , unsigned int devfn ) ;
extern int pci_bus_read_config_word(struct pci_bus *bus , unsigned int devfn , int where ,
                                    u16 *val ) ;
extern int pci_bus_read_config_dword(struct pci_bus *bus , unsigned int devfn , int where ,
                                     u32 *val ) ;
extern int pci_bus_write_config_byte(struct pci_bus *bus , unsigned int devfn , int where ,
                                     u8 val ) ;
extern int pci_bus_write_config_word(struct pci_bus *bus , unsigned int devfn , int where ,
                                     u16 val ) ;
extern int pci_bus_write_config_dword(struct pci_bus *bus , unsigned int devfn , int where ,
                                      u32 val ) ;
__inline static int pci_read_config_word(struct pci_dev *dev , int where , u16 *val ) 
{ int tmp ;

  {
  {
  tmp = pci_bus_read_config_word(dev->bus, dev->devfn, where, val);
  }
  return (tmp);
}
}
__inline static int pci_read_config_dword(struct pci_dev *dev , int where , u32 *val ) 
{ int tmp ;

  {
  {
  tmp = pci_bus_read_config_dword(dev->bus, dev->devfn, where, val);
  }
  return (tmp);
}
}
__inline static int pci_write_config_byte(struct pci_dev *dev , int where , u8 val ) 
{ int tmp ;

  {
  {
  tmp = pci_bus_write_config_byte(dev->bus, dev->devfn, where, val);
  }
  return (tmp);
}
}
__inline static int pci_write_config_word(struct pci_dev *dev , int where , u16 val ) 
{ int tmp ;

  {
  {
  tmp = pci_bus_write_config_word(dev->bus, dev->devfn, where, val);
  }
  return (tmp);
}
}
__inline static int pci_write_config_dword(struct pci_dev *dev , int where , u32 val ) 
{ int tmp ;

  {
  {
  tmp = pci_bus_write_config_dword(dev->bus, dev->devfn, where, val);
  }
  return (tmp);
}
}
extern int pci_enable_device(struct pci_dev *dev ) ;
extern void pci_disable_device(struct pci_dev *dev ) ;
extern void pci_set_master(struct pci_dev *dev ) ;
extern void pci_bus_assign_resources(struct pci_bus *bus ) ;
extern void pci_bus_size_bridges(struct pci_bus *bus ) ;
extern int pci_request_region(struct pci_dev * , int  , char const   * ) ;
extern void pci_release_region(struct pci_dev * , int  ) ;
extern void pci_enable_bridges(struct pci_bus *bus ) ;
extern int pci_scan_bridge(struct pci_bus *bus , struct pci_dev *dev , int max , int pass ) ;
extern unsigned char pci_bus_max_busnr(struct pci_bus *bus ) ;
__inline static int pci_domain_nr(struct pci_bus *bus ) 
{ struct pci_sysdata *sd ;

  {
  {
  sd = (struct pci_sysdata *)bus->sysdata;
  }
  return (sd->domain);
}
}
__inline static char const   *pci_name(struct pci_dev *pdev ) 
{ char const   *tmp ;

  {
  {
  tmp = dev_name((struct device  const  *)(& pdev->dev));
  }
  return (tmp);
}
}
extern acpi_status acpi_walk_namespace(acpi_object_type type , acpi_handle start_object ,
                                       u32 max_depth , acpi_status (*user_function)(acpi_handle obj_handle ,
                                                                                    u32 nesting_level ,
                                                                                    void *context ,
                                                                                    void **return_value ) ,
                                       void *context , void **return_value ) ;
extern acpi_status acpi_get_name(acpi_handle handle , u32 name_type , struct acpi_buffer *ret_path_ptr ) ;
extern acpi_status acpi_get_handle(acpi_handle parent , acpi_string pathname , acpi_handle *ret_handle ) ;
extern acpi_status acpi_evaluate_object(acpi_handle object , acpi_string pathname ,
                                        struct acpi_object_list *parameter_objects ,
                                        struct acpi_buffer *return_object_buffer ) ;
extern acpi_status acpi_get_parent(acpi_handle object , acpi_handle *out_handle ) ;
extern acpi_status acpi_install_notify_handler(acpi_handle device , u32 handler_type ,
                                               void (*handler)(acpi_handle device ,
                                                               u32 value , void *context ) ,
                                               void *context ) ;
extern acpi_status acpi_remove_notify_handler(acpi_handle device , u32 handler_type ,
                                              void (*handler)(acpi_handle device ,
                                                              u32 value , void *context ) ) ;
extern acpi_status acpi_evaluate_integer(acpi_handle handle , acpi_string pathname ,
                                         struct acpi_object_list *arguments , unsigned long *data ) ;
extern int acpi_bus_get_device(acpi_handle handle , struct acpi_device **device ) ;
extern int acpi_bus_add(struct acpi_device **child , struct acpi_device *parent ,
                        acpi_handle handle , int type ) ;
extern int acpi_bus_trim(struct acpi_device *start , int rmdevice ) ;
extern int acpi_bus_start(struct acpi_device *device ) ;
extern acpi_status acpi_get_hp_params_from_firmware(struct pci_bus *bus , struct hotplug_params *hpp ) ;
extern int acpi_root_bridge(acpi_handle handle ) ;
extern acpi_status acpi_get_pci_id(acpi_handle handle , struct acpi_pci_id *id ) ;
extern int is_dock_device(acpi_handle handle ) ;
extern int register_dock_notifier(struct notifier_block *nb ) ;
extern void unregister_dock_notifier(struct notifier_block *nb ) ;
extern int register_hotplug_dock_device(acpi_handle handle , void (*handler)(acpi_handle device ,
                                                                             u32 value ,
                                                                             void *context ) ,
                                        void *context ) ;
extern void unregister_hotplug_dock_device(acpi_handle handle ) ;
extern int acpi_register_ioapic(acpi_handle handle , u64 phys_addr , u32 gsi_base ) ;
extern int acpi_unregister_ioapic(acpi_handle handle , u32 gsi_base ) ;
extern int acpi_pci_register_driver(struct acpi_pci_driver *driver ) ;
extern void acpi_pci_unregister_driver(struct acpi_pci_driver *driver ) ;
extern int acpiphp_register_hotplug_slot(struct acpiphp_slot *slot ) ;
extern void acpiphp_unregister_hotplug_slot(struct acpiphp_slot *slot ) ;
int __attribute__((__cold__))  acpiphp_glue_init(void)  __attribute__((__section__(".init.text"))) ;
void acpiphp_glue_exit(void) ;
int __attribute__((__cold__))  acpiphp_get_num_slots(void)  __attribute__((__section__(".init.text"))) ;
int acpiphp_enable_slot(struct acpiphp_slot *slot ) ;
int acpiphp_disable_slot(struct acpiphp_slot *slot ) ;
int acpiphp_eject_slot(struct acpiphp_slot *slot ) ;
u8 acpiphp_get_power_status(struct acpiphp_slot *slot ) ;
u8 acpiphp_get_latch_status(struct acpiphp_slot *slot ) ;
u8 acpiphp_get_adapter_status(struct acpiphp_slot *slot ) ;
extern int acpiphp_debug ;
static struct list_head bridge_list  =    {& bridge_list, & bridge_list};
static struct list_head ioapic_list  =    {& ioapic_list, & ioapic_list};
static spinlock_t ioapic_list_lock  =    {{0U}};
static void handle_hotplug_event_bridge(acpi_handle handle , u32 type , void *context ) ;
static void acpiphp_sanitize_bus(struct pci_bus *bus ) ;
static void acpiphp_set_hpp_values(acpi_handle handle , struct pci_bus *bus ) ;
static void handle_hotplug_event_func(acpi_handle handle , u32 type , void *context ) ;
static int is_ejectable(acpi_handle handle ) 
{ acpi_status status ;
  acpi_handle tmp ;

  {
  {
  status = acpi_get_handle(handle, (char *)"_ADR", & tmp);
  }
  if (status) {
    return (0);
  }
  {
  status = acpi_get_handle(handle, (char *)"_EJ0", & tmp);
  }
  if (status) {
    return (0);
  }
  return (1);
}
}
static acpi_status is_ejectable_slot(acpi_handle handle , u32 lvl , void *context ,
                                     void **rv ) 
{ int *count ;
  int tmp ;

  {
  {
  count = (int *)context;
  tmp = is_ejectable(handle);
  }
  if (tmp) {
    {
    (*count) ++;
    }
    return (16387U);
  } else {
    return (0U);
  }
}
}
static acpi_status is_pci_dock_device(acpi_handle handle , u32 lvl , void *context ,
                                      void **rv ) 
{ int *count ;
  int tmp ;

  {
  {
  count = (int *)context;
  tmp = is_dock_device(handle);
  }
  if (tmp) {
    {
    (*count) ++;
    }
    return (16387U);
  } else {
    return (0U);
  }
}
}
static int post_dock_fixups(struct notifier_block *nb , unsigned long val , void *v ) 
{ struct acpiphp_func *func ;
  struct notifier_block  const  *__mptr ;
  struct pci_bus *bus ;
  u32 buses ;

  {
  {
  __mptr = (struct notifier_block  const  *)nb;
  func = (struct acpiphp_func *)((char *)__mptr - (unsigned int )(& ((struct acpiphp_func *)0)->nb));
  bus = ((func->slot)->bridge)->pci_bus;
  }
  if (! bus->self) {
    return (1);
  }
  {
  pci_read_config_dword(bus->self, 24, & buses);
  }
  if (((buses >> 8) & 255U) != (unsigned int )bus->secondary) {
    {
    buses = (((buses & 4278190080U) | (unsigned int )bus->primary) | ((unsigned int )bus->secondary << 8)) | ((unsigned int )bus->subordinate << 16);
    pci_write_config_dword(bus->self, 24, buses);
    }
  }
  return (1);
}
}
static struct lock_class_key __key___0  ;
static acpi_status register_slot(acpi_handle handle , u32 lvl , void *context , void **rv ) 
{ struct acpiphp_bridge *bridge ;
  struct acpiphp_slot *slot ;
  struct acpiphp_func *newfunc ;
  acpi_handle tmp ;
  acpi_status status ;
  unsigned long adr ;
  unsigned long sun ;
  int device ;
  int function ;
  int retval ;
  int tmp___0 ;
  void *tmp___1 ;
  acpi_status tmp___2 ;
  acpi_status tmp___3 ;
  acpi_status tmp___4 ;
  acpi_status tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
  bridge = (struct acpiphp_bridge *)context;
  status = 0U;
  status = acpi_evaluate_integer(handle, (char *)"_ADR", (struct acpi_object_list *)((void *)0),
                                 & adr);
  }
  if (status) {
    return (0U);
  }
  {
  status = acpi_get_handle(handle, (char *)"_EJ0", & tmp);
  }
  if (status) {
    {
    tmp___0 = is_dock_device(handle);
    }
    if (! tmp___0) {
      return (0U);
    }
  }
  {
  device = (int )((adr >> 16) & 65535UL);
  function = (int )(adr & 65535UL);
  tmp___1 = kzalloc(sizeof(struct acpiphp_func ), 208U);
  newfunc = (struct acpiphp_func *)tmp___1;
  }
  if (! newfunc) {
    return (4U);
  }
  {
  INIT_LIST_HEAD(& newfunc->sibling);
  newfunc->handle = handle;
  newfunc->function = (unsigned char )function;
  }
  if (! status) {
    {
    newfunc->flags = 2U;
    }
  }
  {
  tmp___2 = acpi_get_handle(handle, (char *)"_STA", & tmp);
  }
  if (! tmp___2) {
    {
    newfunc->flags |= 1U;
    }
  }
  {
  tmp___3 = acpi_get_handle(handle, (char *)"_PS0", & tmp);
  }
  if (! tmp___3) {
    {
    newfunc->flags |= 16U;
    }
  }
  {
  tmp___4 = acpi_get_handle(handle, (char *)"_PS3", & tmp);
  }
  if (! tmp___4) {
    {
    newfunc->flags |= 128U;
    }
  }
  {
  tmp___5 = acpi_get_handle(handle, (char *)"_DCK", & tmp);
  }
  if (! tmp___5) {
    {
    newfunc->flags |= 256U;
    }
  }
  {
  status = acpi_evaluate_integer(handle, (char *)"_SUN", (struct acpi_object_list *)((void *)0),
                                 & sun);
  }
  if (status) {
    {
    sun = (unsigned long )(bridge->nr_slots + 1);
    }
  }
  {
  slot = bridge->slots;
  }
  {
  while (1) {
    while_2_continue: /* CIL Label */ ;
    if (! slot) {
      goto while_2_break;
    }
    if ((int )slot->device == device) {
      if ((unsigned long )slot->sun != sun) {
        {
        printk("<4>%s: sibling found, but _SUN doesn\'t match!\n", "acpiphp_glue");
        }
      }
      goto while_2_break;
    }
    {
    slot = slot->next;
    }
  }
  while_2_break: /* CIL Label */ ;
  }
  if (! slot) {
    {
    tmp___6 = kzalloc(sizeof(struct acpiphp_slot ), 208U);
    slot = (struct acpiphp_slot *)tmp___6;
    }
    if (! slot) {
      {
      kfree((void const   *)newfunc);
      }
      return (4U);
    }
    {
    slot->bridge = bridge;
    slot->device = (unsigned char )device;
    slot->sun = (unsigned int )sun;
    INIT_LIST_HEAD(& slot->funcs);
    }
    {
    while (1) {
      while_3_continue: /* CIL Label */ ;
      {
      __mutex_init(& slot->crit_sect, "&slot->crit_sect", & __key___0);
      }
      goto while_3_break;
    }
    while_3_break: /* CIL Label */ ;
    }
    {
    slot->next = bridge->slots;
    bridge->slots = slot;
    (bridge->nr_slots) ++;
    }
    {
    while (1) {
      while_4_continue: /* CIL Label */ ;
      if (acpiphp_debug) {
        {
        tmp___7 = pci_domain_nr(bridge->pci_bus);
        printk("<7>%s: found ACPI PCI Hotplug slot %d at PCI %04x:%02x:%02x\n", "acpiphp_glue",
               slot->sun, tmp___7, (bridge->pci_bus)->number, slot->device);
        }
      }
      goto while_4_break;
    }
    while_4_break: /* CIL Label */ ;
    }
    {
    retval = acpiphp_register_hotplug_slot(slot);
    }
    if (retval) {
      if (retval == -16) {
        {
        printk("<4>%s: Slot %d already registered by another hotplug driver\n", "acpiphp_glue",
               slot->sun);
        }
      } else {
        {
        printk("<4>%s: acpiphp_register_hotplug_slot failed (err code = 0x%x)\n",
               "acpiphp_glue", retval);
        }
      }
      goto err_exit;
    }
  }
  {
  newfunc->slot = slot;
  list_add_tail(& newfunc->sibling, & slot->funcs);
  newfunc->pci_dev = pci_get_slot(bridge->pci_bus, (unsigned int )(((device & 31) << 3) | (function & 7)));
  }
  if (newfunc->pci_dev) {
    {
    slot->flags |= 3U;
    }
  }
  {
  tmp___10 = is_dock_device(handle);
  }
  if (tmp___10) {
    {
    newfunc->flags &= 4294967293U;
    tmp___8 = register_hotplug_dock_device(handle, & handle_hotplug_event_func, (void *)newfunc);
    }
    if (tmp___8) {
      {
      while (1) {
        while_5_continue: /* CIL Label */ ;
        if (acpiphp_debug) {
          {
          printk("<7>%s: failed to register dock device\n", "acpiphp_glue");
          }
        }
        goto while_5_break;
      }
      while_5_break: /* CIL Label */ ;
      }
    }
    {
    newfunc->nb.notifier_call = & post_dock_fixups;
    tmp___9 = register_dock_notifier(& newfunc->nb);
    }
    if (tmp___9) {
      {
      while (1) {
        while_6_continue: /* CIL Label */ ;
        if (acpiphp_debug) {
          {
          printk("<7>%s: failed to register a dock notifier", "acpiphp_glue");
          }
        }
        goto while_6_break;
      }
      while_6_break: /* CIL Label */ ;
      }
    }
  }
  if (! (newfunc->flags & 256U)) {
    {
    status = acpi_install_notify_handler(handle, 1U, & handle_hotplug_event_func,
                                         (void *)newfunc);
    }
    if (status) {
      {
      printk("<3>%s: failed to register interrupt notify handler\n", "acpiphp_glue");
      }
    }
  } else {
    {
    status = 0U;
    }
  }
  return (status);
  err_exit: 
  {
  (bridge->nr_slots) --;
  bridge->slots = slot->next;
  kfree((void const   *)slot);
  kfree((void const   *)newfunc);
  }
  return (0U);
}
}
static int detect_ejectable_slots(acpi_handle *bridge_handle ) 
{ acpi_status status ;
  int count ;

  {
  {
  count = 0;
  status = acpi_walk_namespace(6U, (void *)bridge_handle, 1U, & is_ejectable_slot,
                               (void *)(& count), (void **)((void *)0));
  }
  if (! count) {
    {
    status = acpi_walk_namespace(6U, (void *)bridge_handle, 1U, & is_pci_dock_device,
                                 (void *)(& count), (void **)((void *)0));
    }
  }
  return (count);
}
}
static void decode_hpp(struct acpiphp_bridge *bridge ) 
{ acpi_status status ;

  {
  {
  status = acpi_get_hp_params_from_firmware(bridge->pci_bus, & bridge->hpp);
  }
  if (status) {
    goto _L;
  } else {
    if (! bridge->hpp.t0) {
      goto _L;
    } else {
      if ((bridge->hpp.t0)->revision > 1U) {
        _L: /* CIL Label */ 
        {
        printk("<4>%s: Could not get hotplug parameters. Use defaults\n", "decode_hpp");
        bridge->hpp.t0 = & bridge->hpp.type0_data;
        (bridge->hpp.t0)->revision = 0U;
        (bridge->hpp.t0)->cache_line_size = (unsigned char)16;
        (bridge->hpp.t0)->latency_timer = (unsigned char)64;
        (bridge->hpp.t0)->enable_serr = (unsigned char)0;
        (bridge->hpp.t0)->enable_perr = (unsigned char)0;
        }
      }
    }
  }
  return;
}
}
static void init_bridge_misc(struct acpiphp_bridge *bridge ) 
{ acpi_status status ;

  {
  {
  decode_hpp(bridge);
  list_add(& bridge->list, & bridge_list);
  status = acpi_walk_namespace(6U, bridge->handle, 1U, & register_slot, (void *)bridge,
                               (void **)((void *)0));
  }
  if (status) {
    {
    list_del(& bridge->list);
    }
    return;
  }
  if (bridge->type != 0) {
    if (bridge->flags & 2U) {
      if (bridge->func) {
        {
        status = acpi_remove_notify_handler((bridge->func)->handle, 1U, & handle_hotplug_event_func);
        }
        if (status) {
          {
          printk("<3>%s: failed to remove notify handler\n", "acpiphp_glue");
          }
        }
      }
    }
    {
    status = acpi_install_notify_handler(bridge->handle, 1U, & handle_hotplug_event_bridge,
                                         (void *)bridge);
    }
    if (status) {
      {
      printk("<3>%s: failed to register interrupt notify handler\n", "acpiphp_glue");
      }
    }
  }
  return;
}
}
static struct acpiphp_func *acpiphp_bridge_handle_to_function(acpi_handle handle ) 
{ struct list_head *node ;
  struct list_head *l ;
  struct acpiphp_bridge *bridge ;
  struct acpiphp_slot *slot ;
  struct acpiphp_func *func ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
  {
  node = bridge_list.next;
  }
  {
  while (1) {
    while_7_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)node->next);
    }
    if (! ((unsigned int )node != (unsigned int )(& bridge_list))) {
      goto while_7_break;
    }
    {
    __mptr = (struct list_head  const  *)node;
    bridge = (struct acpiphp_bridge *)((char *)__mptr - (unsigned int )(& ((struct acpiphp_bridge *)0)->list));
    slot = bridge->slots;
    }
    {
    while (1) {
      while_8_continue: /* CIL Label */ ;
      if (! slot) {
        goto while_8_break;
      }
      {
      l = slot->funcs.next;
      }
      {
      while (1) {
        while_9_continue: /* CIL Label */ ;
        {
        prefetch((void const   *)l->next);
        }
        if (! ((unsigned int )l != (unsigned int )(& slot->funcs))) {
          goto while_9_break;
        }
        {
        __mptr___0 = (struct list_head  const  *)l;
        func = (struct acpiphp_func *)((char *)__mptr___0 - (unsigned int )(& ((struct acpiphp_func *)0)->sibling));
        }
        if ((unsigned int )func->handle == (unsigned int )handle) {
          return (func);
        }
        {
        l = l->next;
        }
      }
      while_9_break: /* CIL Label */ ;
      }
      {
      slot = slot->next;
      }
    }
    while_8_break: /* CIL Label */ ;
    }
    {
    node = node->next;
    }
  }
  while_7_break: /* CIL Label */ ;
  }
  return ((struct acpiphp_func *)((void *)0));
}
}
__inline static void config_p2p_bridge_flags(struct acpiphp_bridge *bridge ) 
{ acpi_handle dummy_handle ;
  acpi_status tmp ;
  acpi_status tmp___0 ;
  acpi_status tmp___1 ;
  acpi_status tmp___2 ;
  struct acpiphp_func *func ;

  {
  {
  tmp = acpi_get_handle(bridge->handle, (char *)"_STA", & dummy_handle);
  }
  if (! tmp) {
    {
    bridge->flags |= 1U;
    }
  }
  {
  tmp___0 = acpi_get_handle(bridge->handle, (char *)"_EJ0", & dummy_handle);
  }
  if (! tmp___0) {
    {
    bridge->flags |= 2U;
    }
  }
  {
  tmp___1 = acpi_get_handle(bridge->handle, (char *)"_PS0", & dummy_handle);
  }
  if (! tmp___1) {
    {
    bridge->flags |= 16U;
    }
  }
  {
  tmp___2 = acpi_get_handle(bridge->handle, (char *)"_PS3", & dummy_handle);
  }
  if (! tmp___2) {
    {
    bridge->flags |= 128U;
    }
  }
  if (bridge->flags & 2U) {
    {
    while (1) {
      while_10_continue: /* CIL Label */ ;
      if (acpiphp_debug) {
        {
        printk("<7>%s: found ejectable p2p bridge\n", "acpiphp_glue");
        }
      }
      goto while_10_break;
    }
    while_10_break: /* CIL Label */ ;
    }
    {
    func = acpiphp_bridge_handle_to_function(bridge->handle);
    }
    if (! func) {
      return;
    }
    {
    bridge->func = func;
    func->bridge = bridge;
    }
  }
  return;
}
}
static void add_host_bridge(acpi_handle *handle , struct pci_bus *pci_bus ) 
{ struct acpiphp_bridge *bridge ;
  void *tmp ;
  spinlock_t __constr_expr_0 ;

  {
  {
  tmp = kzalloc(sizeof(struct acpiphp_bridge ), 208U);
  bridge = (struct acpiphp_bridge *)tmp;
  }
  if ((unsigned int )bridge == (unsigned int )((void *)0)) {
    return;
  }
  {
  bridge->type = 0;
  bridge->handle = (void *)handle;
  bridge->pci_bus = pci_bus;
  }
  {
  while (1) {
    while_11_continue: /* CIL Label */ ;
    {
    __constr_expr_0.raw_lock.slock = 0U;
    bridge->res_lock = __constr_expr_0;
    }
    goto while_11_break;
  }
  while_11_break: /* CIL Label */ ;
  }
  {
  init_bridge_misc(bridge);
  }
  return;
}
}
static void add_p2p_bridge(acpi_handle *handle , struct pci_dev *pci_dev ) 
{ struct acpiphp_bridge *bridge ;
  void *tmp ;
  spinlock_t __constr_expr_0 ;

  {
  {
  tmp = kzalloc(sizeof(struct acpiphp_bridge ), 208U);
  bridge = (struct acpiphp_bridge *)tmp;
  }
  if ((unsigned int )bridge == (unsigned int )((void *)0)) {
    {
    printk("<3>%s: out of memory\n", "acpiphp_glue");
    }
    return;
  }
  {
  bridge->type = 1;
  bridge->handle = (void *)handle;
  config_p2p_bridge_flags(bridge);
  bridge->pci_dev = pci_dev_get(pci_dev);
  bridge->pci_bus = pci_dev->subordinate;
  }
  if (! bridge->pci_bus) {
    {
    printk("<3>%s: This is not a PCI-to-PCI bridge!\n", "acpiphp_glue");
    }
    goto err;
  }
  {
  while (1) {
    while_12_continue: /* CIL Label */ ;
    {
    __constr_expr_0.raw_lock.slock = 0U;
    bridge->res_lock = __constr_expr_0;
    }
    goto while_12_break;
  }
  while_12_break: /* CIL Label */ ;
  }
  {
  init_bridge_misc(bridge);
  }
  return;
  err: 
  {
  pci_dev_put(pci_dev);
  kfree((void const   *)bridge);
  }
  return;
}
}
static acpi_status find_p2p_bridge(acpi_handle handle , u32 lvl , void *context ,
                                   void **rv ) 
{ acpi_status status ;
  acpi_handle dummy_handle ;
  unsigned long tmp ;
  int device ;
  int function ;
  struct pci_dev *dev ;
  struct pci_bus *pci_bus ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
  {
  pci_bus = (struct pci_bus *)context;
  status = acpi_get_handle(handle, (char *)"_ADR", & dummy_handle);
  }
  if (status) {
    return (0U);
  }
  {
  status = acpi_evaluate_integer(handle, (char *)"_ADR", (struct acpi_object_list *)((void *)0),
                                 & tmp);
  }
  if (status) {
    {
    while (1) {
      while_13_continue: /* CIL Label */ ;
      if (acpiphp_debug) {
        {
        printk("<7>%s: %s: _ADR evaluation failure\n", "acpiphp_glue", "find_p2p_bridge");
        }
      }
      goto while_13_break;
    }
    while_13_break: /* CIL Label */ ;
    }
    return (0U);
  }
  {
  device = (int )((tmp >> 16) & 65535UL);
  function = (int )(tmp & 65535UL);
  dev = pci_get_slot(pci_bus, (unsigned int )(((device & 31) << 3) | (function & 7)));
  }
  if (! dev) {
    goto out;
  } else {
    if (! dev->subordinate) {
      goto out;
    }
  }
  {
  tmp___1 = detect_ejectable_slots((acpi_handle *)handle);
  }
  if (tmp___1 > 0) {
    {
    while (1) {
      while_14_continue: /* CIL Label */ ;
      if (acpiphp_debug) {
        {
        tmp___0 = pci_name(dev);
        printk("<7>%s: found PCI-to-PCI bridge at PCI %s\n", "acpiphp_glue", tmp___0);
        }
      }
      goto while_14_break;
    }
    while_14_break: /* CIL Label */ ;
    }
    {
    add_p2p_bridge((acpi_handle *)handle, dev);
    }
  }
  {
  status = acpi_walk_namespace(6U, handle, 1U, & find_p2p_bridge, (void *)dev->subordinate,
                               (void **)((void *)0));
  }
  if (status) {
    {
    printk("<4>%s: find_p2p_bridge failed (error code = 0x%x)\n", "acpiphp_glue",
           status);
    }
  }
  out: 
  {
  pci_dev_put(dev);
  }
  return (0U);
}
}
static int add_bridge(acpi_handle handle ) 
{ acpi_status status ;
  unsigned long tmp ;
  int seg ;
  int bus ;
  acpi_handle dummy_handle ;
  struct pci_bus *pci_bus ;
  int tmp___0 ;

  {
  {
  status = acpi_get_handle(handle, (char *)"_STA", & dummy_handle);
  }
  if (! status) {
    {
    status = acpi_evaluate_integer(handle, (char *)"_STA", (struct acpi_object_list *)((void *)0),
                                   & tmp);
    }
    if (status) {
      {
      while (1) {
        while_15_continue: /* CIL Label */ ;
        if (acpiphp_debug) {
          {
          printk("<7>%s: %s: _STA evaluation failure\n", "acpiphp_glue", "add_bridge");
          }
        }
        goto while_15_break;
      }
      while_15_break: /* CIL Label */ ;
      }
      return (0);
    }
    if ((tmp & 8UL) == 0UL) {
      return (0);
    }
  }
  {
  status = acpi_evaluate_integer(handle, (char *)"_SEG", (struct acpi_object_list *)((void *)0),
                                 & tmp);
  }
  if (! status) {
    {
    seg = (int )tmp;
    }
  } else {
    {
    seg = 0;
    }
  }
  {
  status = acpi_evaluate_integer(handle, (char *)"_BBN", (struct acpi_object_list *)((void *)0),
                                 & tmp);
  }
  if (! status) {
    {
    bus = (int )tmp;
    }
  } else {
    {
    printk("<4>%s: can\'t get bus number, assuming 0\n", "acpiphp_glue");
    bus = 0;
    }
  }
  {
  pci_bus = pci_find_bus(seg, bus);
  }
  if (! pci_bus) {
    {
    printk("<3>%s: Can\'t find bus %04x:%02x\n", "acpiphp_glue", seg, bus);
    }
    return (0);
  }
  {
  tmp___0 = detect_ejectable_slots((acpi_handle *)handle);
  }
  if (tmp___0 > 0) {
    {
    while (1) {
      while_16_continue: /* CIL Label */ ;
      if (acpiphp_debug) {
        {
        printk("<7>%s: found PCI host-bus bridge with hot-pluggable slots\n", "acpiphp_glue");
        }
      }
      goto while_16_break;
    }
    while_16_break: /* CIL Label */ ;
    }
    {
    add_host_bridge((acpi_handle *)handle, pci_bus);
    }
  }
  {
  status = acpi_walk_namespace(6U, handle, 1U, & find_p2p_bridge, (void *)pci_bus,
                               (void **)((void *)0));
  }
  if (status) {
    {
    printk("<4>%s: find_p2p_bridge failed (error code = 0x%x)\n", "acpiphp_glue",
           status);
    }
  }
  return (0);
}
}
static struct acpiphp_bridge *acpiphp_handle_to_bridge(acpi_handle handle ) 
{ struct list_head *head ;
  struct acpiphp_bridge *bridge ;
  struct list_head  const  *__mptr ;

  {
  {
  head = bridge_list.next;
  }
  {
  while (1) {
    while_17_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)head->next);
    }
    if (! ((unsigned int )head != (unsigned int )(& bridge_list))) {
      goto while_17_break;
    }
    {
    __mptr = (struct list_head  const  *)head;
    bridge = (struct acpiphp_bridge *)((char *)__mptr - (unsigned int )(& ((struct acpiphp_bridge *)0)->list));
    }
    if ((unsigned int )bridge->handle == (unsigned int )handle) {
      return (bridge);
    }
    {
    head = head->next;
    }
  }
  while_17_break: /* CIL Label */ ;
  }
  return ((struct acpiphp_bridge *)((void *)0));
}
}
static void cleanup_bridge(struct acpiphp_bridge *bridge ) 
{ struct list_head *list ;
  struct list_head *tmp ;
  struct acpiphp_slot *slot ;
  acpi_status status ;
  acpi_handle handle ;
  struct acpiphp_slot *next ;
  struct acpiphp_func *func ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;

  {
  {
  handle = bridge->handle;
  status = acpi_remove_notify_handler(handle, 1U, & handle_hotplug_event_bridge);
  }
  if (status) {
    {
    printk("<3>%s: failed to remove notify handler\n", "acpiphp_glue");
    }
  }
  if (bridge->type != 0) {
    if (bridge->flags & 2U) {
      if (bridge->func) {
        {
        status = acpi_install_notify_handler((bridge->func)->handle, 1U, & handle_hotplug_event_func,
                                             (void *)bridge->func);
        }
        if (status) {
          {
          printk("<3>%s: failed to install interrupt notify handler\n", "acpiphp_glue");
          }
        }
      }
    }
  }
  {
  slot = bridge->slots;
  }
  {
  while (1) {
    while_18_continue: /* CIL Label */ ;
    if (! slot) {
      goto while_18_break;
    }
    {
    next = slot->next;
    list = slot->funcs.next;
    tmp = list->next;
    }
    {
    while (1) {
      while_19_continue: /* CIL Label */ ;
      if (! ((unsigned int )list != (unsigned int )(& slot->funcs))) {
        goto while_19_break;
      }
      {
      __mptr = (struct list_head  const  *)list;
      func = (struct acpiphp_func *)((char *)__mptr - (unsigned int )(& ((struct acpiphp_func *)0)->sibling));
      tmp___0 = is_dock_device(func->handle);
      }
      if (tmp___0) {
        {
        unregister_hotplug_dock_device(func->handle);
        unregister_dock_notifier(& func->nb);
        }
      }
      if (! (func->flags & 256U)) {
        {
        status = acpi_remove_notify_handler(func->handle, 1U, & handle_hotplug_event_func);
        }
        if (status) {
          {
          printk("<3>%s: failed to remove notify handler\n", "acpiphp_glue");
          }
        }
      }
      {
      pci_dev_put(func->pci_dev);
      list_del(list);
      kfree((void const   *)func);
      list = tmp;
      tmp = list->next;
      }
    }
    while_19_break: /* CIL Label */ ;
    }
    {
    acpiphp_unregister_hotplug_slot(slot);
    list_del(& slot->funcs);
    kfree((void const   *)slot);
    slot = next;
    }
  }
  while_18_break: /* CIL Label */ ;
  }
  {
  pci_dev_put(bridge->pci_dev);
  list_del(& bridge->list);
  kfree((void const   *)bridge);
  }
  return;
}
}
static acpi_status cleanup_p2p_bridge(acpi_handle handle , u32 lvl , void *context ,
                                      void **rv ) 
{ struct acpiphp_bridge *bridge ;

  {
  {
  acpi_walk_namespace(6U, handle, 1U, & cleanup_p2p_bridge, (void *)0, (void **)((void *)0));
  bridge = acpiphp_handle_to_bridge(handle);
  }
  if (bridge) {
    {
    cleanup_bridge(bridge);
    }
  }
  return (0U);
}
}
static void remove_bridge(acpi_handle handle ) 
{ struct acpiphp_bridge *bridge ;

  {
  {
  acpi_walk_namespace(6U, handle, 1U, & cleanup_p2p_bridge, (void *)0, (void **)((void *)0));
  bridge = acpiphp_handle_to_bridge(handle);
  }
  if (bridge) {
    {
    cleanup_bridge(bridge);
    }
  } else {
    {
    acpi_remove_notify_handler(handle, 1U, & handle_hotplug_event_bridge);
    }
  }
  return;
}
}
static struct pci_dev *get_apic_pci_info(acpi_handle handle ) 
{ struct acpi_pci_id id ;
  struct pci_bus *bus ;
  struct pci_dev *dev ;
  acpi_status tmp ;

  {
  {
  tmp = acpi_get_pci_id(handle, & id);
  }
  if (tmp) {
    return ((struct pci_dev *)((void *)0));
  }
  {
  bus = pci_find_bus((int )id.segment, (int )id.bus);
  }
  if (! bus) {
    return ((struct pci_dev *)((void *)0));
  }
  {
  dev = pci_get_slot(bus, (unsigned int )((((int )id.device & 31) << 3) | ((int )id.function & 7)));
  }
  if (! dev) {
    return ((struct pci_dev *)((void *)0));
  }
  if (dev->class != 524304U) {
    if (dev->class != 524320U) {
      {
      pci_dev_put(dev);
      }
      return ((struct pci_dev *)((void *)0));
    }
  }
  return (dev);
}
}
static int get_gsi_base(acpi_handle handle , u32 *gsi_base ) 
{ acpi_status status ;
  int result ;
  unsigned long gsb ;
  struct acpi_buffer buffer ;
  union acpi_object *obj ;
  void *table ;

  {
  {
  result = -1;
  buffer.length = 4294967295U;
  buffer.pointer = (void *)0;
  status = acpi_evaluate_integer(handle, (char *)"_GSB", (struct acpi_object_list *)((void *)0),
                                 & gsb);
  }
  if (! status) {
    {
    *gsi_base = (unsigned int )gsb;
    }
    return (0);
  }
  {
  status = acpi_evaluate_object(handle, (char *)"_MAT", (struct acpi_object_list *)((void *)0),
                                & buffer);
  }
  if (status) {
    return (-1);
  } else {
    if (! buffer.length) {
      return (-1);
    } else {
      if (! buffer.pointer) {
        return (-1);
      }
    }
  }
  {
  obj = (union acpi_object *)buffer.pointer;
  }
  if (obj->type != 3U) {
    goto out;
  }
  {
  table = (void *)obj->buffer.pointer;
  }
  if ((int )((struct acpi_subtable_header *)table)->type == 6) {
    goto switch_20_6;
  } else {
    if ((int )((struct acpi_subtable_header *)table)->type == 1) {
      goto switch_20_1;
    } else {
      {
      goto switch_20_default;
      if (0) {
        switch_20_6: /* CIL Label */ 
        {
        *gsi_base = ((struct acpi_madt_io_sapic *)table)->global_irq_base;
        result = 0;
        }
        goto switch_20_break;
        switch_20_1: /* CIL Label */ 
        {
        *gsi_base = ((struct acpi_madt_io_apic *)table)->global_irq_base;
        result = 0;
        }
        goto switch_20_break;
        switch_20_default: /* CIL Label */ 
        {

        }
        goto switch_20_break;
      } else {
        switch_20_break: /* CIL Label */ ;
      }
      }
    }
  }
  out: 
  {
  kfree((void const   *)buffer.pointer);
  }
  return (result);
}
}
static acpi_status ioapic_add(acpi_handle handle , u32 lvl , void *context , void **rv ) 
{ acpi_status status ;
  unsigned long sta ;
  acpi_handle tmp ;
  struct pci_dev *pdev ;
  u32 gsi_base ;
  u64 phys_addr ;
  struct acpiphp_ioapic *ioapic ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
  status = acpi_evaluate_integer(handle, (char *)"_STA", (struct acpi_object_list *)((void *)0),
                                 & sta);
  }
  if (! status) {
    if (sta != 15UL) {
      return (16390U);
    }
  }
  {
  status = acpi_get_handle(handle, (char *)"_HID", & tmp);
  }
  if (! status) {
    return (16390U);
  }
  {
  tmp___0 = get_gsi_base(handle, & gsi_base);
  }
  if (tmp___0) {
    return (0U);
  }
  {
  tmp___1 = kmalloc(sizeof(*ioapic), 208U);
  ioapic = (struct acpiphp_ioapic *)tmp___1;
  }
  if (! ioapic) {
    return (4U);
  }
  {
  pdev = get_apic_pci_info(handle);
  }
  if (! pdev) {
    goto exit_kfree;
  }
  {
  tmp___2 = pci_enable_device(pdev);
  }
  if (tmp___2) {
    goto exit_pci_dev_put;
  }
  {
  pci_set_master(pdev);
  tmp___3 = pci_request_region(pdev, 0, "I/O APIC(acpiphp)");
  }
  if (tmp___3) {
    goto exit_pci_disable_device;
  }
  {
  phys_addr = (unsigned long long )pdev->resource[0].start;
  tmp___4 = acpi_register_ioapic(handle, phys_addr, gsi_base);
  }
  if (tmp___4) {
    goto exit_pci_release_region;
  }
  {
  ioapic->gsi_base = gsi_base;
  ioapic->dev = pdev;
  _spin_lock(& ioapic_list_lock);
  list_add_tail(& ioapic->list, & ioapic_list);
  }
  {
  while (1) {
    while_21_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& ioapic_list_lock.raw_lock);
    }
    goto while_21_break;
  }
  while_21_break: /* CIL Label */ ;
  }
  return (0U);
  exit_pci_release_region: 
  {
  pci_release_region(pdev, 0);
  }
  exit_pci_disable_device: 
  {
  pci_disable_device(pdev);
  }
  exit_pci_dev_put: 
  {
  pci_dev_put(pdev);
  }
  exit_kfree: 
  {
  kfree((void const   *)ioapic);
  }
  return (0U);
}
}
static acpi_status ioapic_remove(acpi_handle handle , u32 lvl , void *context , void **rv ) 
{ acpi_status status ;
  unsigned long sta ;
  acpi_handle tmp ;
  u32 gsi_base ;
  struct acpiphp_ioapic *pos ;
  struct acpiphp_ioapic *n ;
  struct acpiphp_ioapic *ioapic ;
  int tmp___0 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
  {
  ioapic = (struct acpiphp_ioapic *)((void *)0);
  status = acpi_evaluate_integer(handle, (char *)"_STA", (struct acpi_object_list *)((void *)0),
                                 & sta);
  }
  if (! status) {
    if (sta != 15UL) {
      return (16390U);
    }
  }
  {
  status = acpi_get_handle(handle, (char *)"_HID", & tmp);
  }
  if (! status) {
    return (16390U);
  }
  {
  tmp___0 = get_gsi_base(handle, & gsi_base);
  }
  if (tmp___0) {
    return (0U);
  }
  {
  acpi_unregister_ioapic(handle, gsi_base);
  _spin_lock(& ioapic_list_lock);
  __mptr = (struct list_head  const  *)ioapic_list.next;
  pos = (struct acpiphp_ioapic *)((char *)__mptr - (unsigned int )(& ((struct acpiphp_ioapic *)0)->list));
  __mptr___0 = (struct list_head  const  *)pos->list.next;
  n = (struct acpiphp_ioapic *)((char *)__mptr___0 - (unsigned int )(& ((struct acpiphp_ioapic *)0)->list));
  }
  {
  while (1) {
    while_22_continue: /* CIL Label */ ;
    if (! ((unsigned int )(& pos->list) != (unsigned int )(& ioapic_list))) {
      goto while_22_break;
    }
    if (pos->gsi_base != gsi_base) {
      goto __Cont;
    }
    {
    ioapic = pos;
    list_del(& ioapic->list);
    }
    goto while_22_break;
    __Cont: /* CIL Label */ 
    {
    pos = n;
    __mptr___1 = (struct list_head  const  *)n->list.next;
    n = (struct acpiphp_ioapic *)((char *)__mptr___1 - (unsigned int )(& ((struct acpiphp_ioapic *)0)->list));
    }
  }
  while_22_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_23_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& ioapic_list_lock.raw_lock);
    }
    goto while_23_break;
  }
  while_23_break: /* CIL Label */ ;
  }
  if (! ioapic) {
    return (0U);
  }
  {
  pci_release_region(ioapic->dev, 0);
  pci_disable_device(ioapic->dev);
  pci_dev_put(ioapic->dev);
  kfree((void const   *)ioapic);
  }
  return (0U);
}
}
static int acpiphp_configure_ioapics(acpi_handle handle ) 
{ 

  {
  {
  ioapic_add(handle, 0U, (void *)0, (void **)((void *)0));
  acpi_walk_namespace(6U, handle, ~ 0U, & ioapic_add, (void *)0, (void **)((void *)0));
  }
  return (0);
}
}
static int acpiphp_unconfigure_ioapics(acpi_handle handle ) 
{ 

  {
  {
  ioapic_remove(handle, 0U, (void *)0, (void **)((void *)0));
  acpi_walk_namespace(6U, handle, ~ 0U, & ioapic_remove, (void *)0, (void **)((void *)0));
  }
  return (0);
}
}
static int power_on_slot(struct acpiphp_slot *slot ) 
{ acpi_status status ;
  struct acpiphp_func *func ;
  struct list_head *l ;
  int retval ;
  struct list_head  const  *__mptr ;

  {
  {
  retval = 0;
  }
  if (slot->flags & 1U) {
    goto err_exit;
  }
  {
  l = slot->funcs.next;
  }
  {
  while (1) {
    while_24_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)l->next);
    }
    if (! ((unsigned int )l != (unsigned int )(& slot->funcs))) {
      goto while_24_break;
    }
    {
    __mptr = (struct list_head  const  *)l;
    func = (struct acpiphp_func *)((char *)__mptr - (unsigned int )(& ((struct acpiphp_func *)0)->sibling));
    }
    if (func->flags & 16U) {
      {
      while (1) {
        while_25_continue: /* CIL Label */ ;
        if (acpiphp_debug) {
          {
          printk("<7>%s: %s: executing _PS0\n", "acpiphp_glue", "power_on_slot");
          }
        }
        goto while_25_break;
      }
      while_25_break: /* CIL Label */ ;
      }
      {
      status = acpi_evaluate_object(func->handle, (char *)"_PS0", (struct acpi_object_list *)((void *)0),
                                    (struct acpi_buffer *)((void *)0));
      }
      if (status) {
        {
        printk("<4>%s: %s: _PS0 failed\n", "acpiphp_glue", "power_on_slot");
        retval = -1;
        }
        goto err_exit;
      } else {
        goto while_24_break;
      }
    }
    {
    l = l->next;
    }
  }
  while_24_break: /* CIL Label */ ;
  }
  {
  slot->flags |= 1U;
  }
  err_exit: 
  return (retval);
}
}
static int power_off_slot(struct acpiphp_slot *slot ) 
{ acpi_status status ;
  struct acpiphp_func *func ;
  struct list_head *l ;
  int retval ;
  struct list_head  const  *__mptr ;

  {
  {
  retval = 0;
  }
  if ((slot->flags & 1U) == 0U) {
    goto err_exit;
  }
  {
  l = slot->funcs.next;
  }
  {
  while (1) {
    while_26_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)l->next);
    }
    if (! ((unsigned int )l != (unsigned int )(& slot->funcs))) {
      goto while_26_break;
    }
    {
    __mptr = (struct list_head  const  *)l;
    func = (struct acpiphp_func *)((char *)__mptr - (unsigned int )(& ((struct acpiphp_func *)0)->sibling));
    }
    if (func->flags & 128U) {
      {
      status = acpi_evaluate_object(func->handle, (char *)"_PS3", (struct acpi_object_list *)((void *)0),
                                    (struct acpi_buffer *)((void *)0));
      }
      if (status) {
        {
        printk("<4>%s: %s: _PS3 failed\n", "acpiphp_glue", "power_off_slot");
        retval = -1;
        }
        goto err_exit;
      } else {
        goto while_26_break;
      }
    }
    {
    l = l->next;
    }
  }
  while_26_break: /* CIL Label */ ;
  }
  {
  slot->flags &= 4294967294U;
  }
  err_exit: 
  return (retval);
}
}
static unsigned char acpiphp_max_busnr(struct pci_bus *bus ) 
{ struct list_head *tmp ;
  unsigned char max ;
  unsigned char n ;
  struct list_head  const  *__mptr ;

  {
  {
  max = bus->secondary;
  tmp = bus->children.next;
  }
  {
  while (1) {
    while_27_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)tmp->next);
    }
    if (! ((unsigned int )tmp != (unsigned int )(& bus->children))) {
      goto while_27_break;
    }
    {
    __mptr = (struct list_head  const  *)tmp;
    n = pci_bus_max_busnr((struct pci_bus *)((char *)__mptr - (unsigned int )(& ((struct pci_bus *)0)->node)));
    }
    if ((int )n > (int )max) {
      {
      max = n;
      }
    }
    {
    tmp = tmp->next;
    }
  }
  while_27_break: /* CIL Label */ ;
  }
  return (max);
}
}
static int acpiphp_bus_add(struct acpiphp_func *func ) 
{ acpi_handle phandle ;
  struct acpi_device *device ;
  struct acpi_device *pdevice ;
  int ret_val ;
  int tmp ;
  int tmp___0 ;

  {
  {
  acpi_get_parent(func->handle, & phandle);
  tmp = acpi_bus_get_device(phandle, & pdevice);
  }
  if (tmp) {
    {
    while (1) {
      while_28_continue: /* CIL Label */ ;
      if (acpiphp_debug) {
        {
        printk("<7>%s: no parent device, assuming NULL\n", "acpiphp_glue");
        }
      }
      goto while_28_break;
    }
    while_28_break: /* CIL Label */ ;
    }
    {
    pdevice = (struct acpi_device *)((void *)0);
    }
  }
  {
  tmp___0 = acpi_bus_get_device(func->handle, & device);
  }
  if (! tmp___0) {
    {
    while (1) {
      while_29_continue: /* CIL Label */ ;
      if (acpiphp_debug) {
        {
        printk("<7>%s: bus exists... trim\n", "acpiphp_glue");
        }
      }
      goto while_29_break;
    }
    while_29_break: /* CIL Label */ ;
    }
    {
    ret_val = acpi_bus_trim(device, 1);
    }
    {
    while (1) {
      while_30_continue: /* CIL Label */ ;
      if (acpiphp_debug) {
        {
        printk("<7>%s: acpi_bus_trim return %x\n", "acpiphp_glue", ret_val);
        }
      }
      goto while_30_break;
    }
    while_30_break: /* CIL Label */ ;
    }
  }
  {
  ret_val = acpi_bus_add(& device, pdevice, func->handle, 0);
  }
  if (ret_val) {
    {
    while (1) {
      while_31_continue: /* CIL Label */ ;
      if (acpiphp_debug) {
        {
        printk("<7>%s: error adding bus, %x\n", "acpiphp_glue", - ret_val);
        }
      }
      goto while_31_break;
    }
    while_31_break: /* CIL Label */ ;
    }
    goto acpiphp_bus_add_out;
  }
  {
  ret_val = acpi_bus_start(device);
  }
  acpiphp_bus_add_out: 
  return (ret_val);
}
}
static int acpiphp_bus_trim(acpi_handle handle ) 
{ struct acpi_device *device ;
  int retval ;

  {
  {
  retval = acpi_bus_get_device(handle, & device);
  }
  if (retval) {
    {
    while (1) {
      while_32_continue: /* CIL Label */ ;
      if (acpiphp_debug) {
        {
        printk("<7>%s: acpi_device not found\n", "acpiphp_glue");
        }
      }
      goto while_32_break;
    }
    while_32_break: /* CIL Label */ ;
    }
    return (retval);
  }
  {
  retval = acpi_bus_trim(device, 1);
  }
  if (retval) {
    {
    printk("<3>%s: cannot remove from acpi list\n", "acpiphp_glue");
    }
  }
  return (retval);
}
}
static int ( __attribute__((__noinline__)) enable_device)(struct acpiphp_slot *slot )  __attribute__((__section__(".ref.text"))) ;
static int ( __attribute__((__noinline__)) enable_device)(struct acpiphp_slot *slot ) 
{ struct pci_dev *dev ;
  struct pci_bus *bus ;
  struct list_head *l ;
  struct acpiphp_func *func ;
  int retval ;
  int num ;
  int max ;
  int pass ;
  acpi_status status ;
  unsigned char tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  struct list_head  const  *__mptr___3 ;
  struct list_head  const  *__mptr___4 ;

  {
  {
  bus = (slot->bridge)->pci_bus;
  retval = 0;
  }
  if (slot->flags & 2U) {
    goto err_exit;
  }
  {
  dev = pci_get_slot(bus, (unsigned int )(((int )slot->device & 31) << 3));
  }
  if (dev) {
    {
    printk("<3>%s: pci_dev structure already exists.\n", "acpiphp_glue");
    pci_dev_put(dev);
    retval = -1;
    }
    goto err_exit;
  }
  {
  num = pci_scan_slot(bus, ((int )slot->device & 31) << 3);
  }
  if (num == 0) {
    {
    printk("<3>%s: No new device found\n", "acpiphp_glue");
    retval = -1;
    }
    goto err_exit;
  }
  {
  tmp = acpiphp_max_busnr(bus);
  max = (int )tmp;
  pass = 0;
  }
  {
  while (1) {
    while_33_continue: /* CIL Label */ ;
    if (! (pass < 2)) {
      goto while_33_break;
    }
    {
    __mptr = (struct list_head  const  *)bus->devices.next;
    dev = (struct pci_dev *)((char *)__mptr - (unsigned int )(& ((struct pci_dev *)0)->bus_list));
    }
    {
    while (1) {
      while_34_continue: /* CIL Label */ ;
      {
      prefetch((void const   *)dev->bus_list.next);
      }
      if (! ((unsigned int )(& dev->bus_list) != (unsigned int )(& bus->devices))) {
        goto while_34_break;
      }
      if (((dev->devfn >> 3) & 31U) != (unsigned int )slot->device) {
        goto __Cont;
      }
      if ((int )dev->hdr_type == 1) {
        goto _L;
      } else {
        if ((int )dev->hdr_type == 2) {
          _L: /* CIL Label */ 
          {
          max = pci_scan_bridge(bus, dev, max, pass);
          }
          if (pass) {
            if (dev->subordinate) {
              {
              pci_bus_size_bridges(dev->subordinate);
              }
            }
          }
        }
      }
      __Cont: /* CIL Label */ 
      {
      __mptr___0 = (struct list_head  const  *)dev->bus_list.next;
      dev = (struct pci_dev *)((char *)__mptr___0 - (unsigned int )(& ((struct pci_dev *)0)->bus_list));
      }
    }
    while_34_break: /* CIL Label */ ;
    }
    {
    pass ++;
    }
  }
  while_33_break: /* CIL Label */ ;
  }
  {
  l = slot->funcs.next;
  }
  {
  while (1) {
    while_35_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)l->next);
    }
    if (! ((unsigned int )l != (unsigned int )(& slot->funcs))) {
      goto while_35_break;
    }
    {
    __mptr___1 = (struct list_head  const  *)l;
    func = (struct acpiphp_func *)((char *)__mptr___1 - (unsigned int )(& ((struct acpiphp_func *)0)->sibling));
    acpiphp_bus_add(func);
    l = l->next;
    }
  }
  while_35_break: /* CIL Label */ ;
  }
  {
  pci_bus_assign_resources(bus);
  acpiphp_sanitize_bus(bus);
  acpiphp_set_hpp_values((slot->bridge)->handle, bus);
  __mptr___2 = (struct list_head  const  *)slot->funcs.next;
  func = (struct acpiphp_func *)((char *)__mptr___2 - (unsigned int )(& ((struct acpiphp_func *)0)->sibling));
  }
  {
  while (1) {
    while_36_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)func->sibling.next);
    }
    if (! ((unsigned int )(& func->sibling) != (unsigned int )(& slot->funcs))) {
      goto while_36_break;
    }
    {
    acpiphp_configure_ioapics(func->handle);
    __mptr___3 = (struct list_head  const  *)func->sibling.next;
    func = (struct acpiphp_func *)((char *)__mptr___3 - (unsigned int )(& ((struct acpiphp_func *)0)->sibling));
    }
  }
  while_36_break: /* CIL Label */ ;
  }
  {
  pci_enable_bridges(bus);
  pci_bus_add_devices(bus);
  l = slot->funcs.next;
  }
  {
  while (1) {
    while_37_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)l->next);
    }
    if (! ((unsigned int )l != (unsigned int )(& slot->funcs))) {
      goto while_37_break;
    }
    {
    __mptr___4 = (struct list_head  const  *)l;
    func = (struct acpiphp_func *)((char *)__mptr___4 - (unsigned int )(& ((struct acpiphp_func *)0)->sibling));
    func->pci_dev = pci_get_slot(bus, (unsigned int )((((int )slot->device & 31) << 3) | ((int )func->function & 7)));
    }
    if (! func->pci_dev) {
      goto __Cont___0;
    }
    if ((int )(func->pci_dev)->hdr_type != 1) {
      if ((int )(func->pci_dev)->hdr_type != 2) {
        goto __Cont___0;
      }
    }
    {
    status = find_p2p_bridge(func->handle, 1U, (void *)bus, (void **)((void *)0));
    }
    if (status) {
      {
      printk("<4>%s: find_p2p_bridge failed (error code = 0x%x)\n", "acpiphp_glue",
             status);
      }
    }
    __Cont___0: /* CIL Label */ 
    {
    l = l->next;
    }
  }
  while_37_break: /* CIL Label */ ;
  }
  {
  slot->flags |= 2U;
  }
  err_exit: 
  return (retval);
}
}
static void disable_bridges(struct pci_bus *bus ) 
{ struct pci_dev *dev ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
  {
  __mptr = (struct list_head  const  *)bus->devices.next;
  dev = (struct pci_dev *)((char *)__mptr - (unsigned int )(& ((struct pci_dev *)0)->bus_list));
  }
  {
  while (1) {
    while_38_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)dev->bus_list.next);
    }
    if (! ((unsigned int )(& dev->bus_list) != (unsigned int )(& bus->devices))) {
      goto while_38_break;
    }
    if (dev->subordinate) {
      {
      disable_bridges(dev->subordinate);
      pci_disable_device(dev);
      }
    }
    {
    __mptr___0 = (struct list_head  const  *)dev->bus_list.next;
    dev = (struct pci_dev *)((char *)__mptr___0 - (unsigned int )(& ((struct pci_dev *)0)->bus_list));
    }
  }
  while_38_break: /* CIL Label */ ;
  }
  return;
}
}
static int disable_device(struct acpiphp_slot *slot ) 
{ int retval ;
  struct acpiphp_func *func ;
  struct list_head *l ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
  {
  retval = 0;
  }
  if (! (slot->flags & 2U)) {
    goto err_exit;
  }
  {
  l = slot->funcs.next;
  }
  {
  while (1) {
    while_39_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)l->next);
    }
    if (! ((unsigned int )l != (unsigned int )(& slot->funcs))) {
      goto while_39_break;
    }
    {
    __mptr = (struct list_head  const  *)l;
    func = (struct acpiphp_func *)((char *)__mptr - (unsigned int )(& ((struct acpiphp_func *)0)->sibling));
    }
    if (func->bridge) {
      {
      cleanup_p2p_bridge((func->bridge)->handle, 1U, (void *)0, (void **)((void *)0));
      func->bridge = (struct acpiphp_bridge *)((void *)0);
      }
    }
    if (func->pci_dev) {
      {
      pci_stop_bus_device(func->pci_dev);
      }
      if ((func->pci_dev)->subordinate) {
        {
        disable_bridges((func->pci_dev)->subordinate);
        pci_disable_device(func->pci_dev);
        }
      }
    }
    {
    l = l->next;
    }
  }
  while_39_break: /* CIL Label */ ;
  }
  {
  l = slot->funcs.next;
  }
  {
  while (1) {
    while_40_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)l->next);
    }
    if (! ((unsigned int )l != (unsigned int )(& slot->funcs))) {
      goto while_40_break;
    }
    {
    __mptr___0 = (struct list_head  const  *)l;
    func = (struct acpiphp_func *)((char *)__mptr___0 - (unsigned int )(& ((struct acpiphp_func *)0)->sibling));
    acpiphp_unconfigure_ioapics(func->handle);
    acpiphp_bus_trim(func->handle);
    }
    if (! func->pci_dev) {
      goto __Cont;
    }
    {
    pci_remove_bus_device(func->pci_dev);
    pci_dev_put(func->pci_dev);
    func->pci_dev = (struct pci_dev *)((void *)0);
    }
    __Cont: /* CIL Label */ 
    {
    l = l->next;
    }
  }
  while_40_break: /* CIL Label */ ;
  }
  {
  slot->flags &= 4294967293U;
  }
  err_exit: 
  return (retval);
}
}
static unsigned int get_slot_status(struct acpiphp_slot *slot ) 
{ acpi_status status ;
  unsigned long sta ;
  u32 dvid ;
  struct list_head *l ;
  struct acpiphp_func *func ;
  struct list_head  const  *__mptr ;

  {
  {
  sta = 0UL;
  l = slot->funcs.next;
  }
  {
  while (1) {
    while_41_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)l->next);
    }
    if (! ((unsigned int )l != (unsigned int )(& slot->funcs))) {
      goto while_41_break;
    }
    {
    __mptr = (struct list_head  const  *)l;
    func = (struct acpiphp_func *)((char *)__mptr - (unsigned int )(& ((struct acpiphp_func *)0)->sibling));
    }
    if (func->flags & 1U) {
      {
      status = acpi_evaluate_integer(func->handle, (char *)"_STA", (struct acpi_object_list *)((void *)0),
                                     & sta);
      }
      if (! status) {
        if (sta) {
          goto while_41_break;
        }
      }
    } else {
      {
      pci_bus_read_config_dword((slot->bridge)->pci_bus, (unsigned int )((((int )slot->device & 31) << 3) | ((int )func->function & 7)),
                                0, & dvid);
      }
      if (dvid != 4294967295U) {
        {
        sta = 15UL;
        }
        goto while_41_break;
      }
    }
    {
    l = l->next;
    }
  }
  while_41_break: /* CIL Label */ ;
  }
  return ((unsigned int )sta);
}
}
int acpiphp_eject_slot(struct acpiphp_slot *slot ) 
{ acpi_status status ;
  struct acpiphp_func *func ;
  struct list_head *l ;
  struct acpi_object_list arg_list ;
  union acpi_object arg ;
  struct list_head  const  *__mptr ;

  {
  {
  l = slot->funcs.next;
  }
  {
  while (1) {
    while_42_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)l->next);
    }
    if (! ((unsigned int )l != (unsigned int )(& slot->funcs))) {
      goto while_42_break;
    }
    {
    __mptr = (struct list_head  const  *)l;
    func = (struct acpiphp_func *)((char *)__mptr - (unsigned int )(& ((struct acpiphp_func *)0)->sibling));
    }
    if (func->flags & 2U) {
      {
      arg_list.count = 1U;
      arg_list.pointer = & arg;
      arg.type = 1U;
      arg.integer.value = 1ULL;
      status = acpi_evaluate_object(func->handle, (char *)"_EJ0", & arg_list, (struct acpi_buffer *)((void *)0));
      }
      if (status) {
        {
        printk("<4>%s: %s: _EJ0 failed\n", "acpiphp_glue", "acpiphp_eject_slot");
        }
        return (-1);
      } else {
        goto while_42_break;
      }
    }
    {
    l = l->next;
    }
  }
  while_42_break: /* CIL Label */ ;
  }
  return (0);
}
}
static int acpiphp_check_bridge(struct acpiphp_bridge *bridge ) 
{ struct acpiphp_slot *slot ;
  int retval ;
  int enabled ;
  int disabled ;
  unsigned int status ;
  unsigned int tmp ;

  {
  {
  retval = 0;
  disabled = 0;
  enabled = disabled;
  slot = bridge->slots;
  }
  {
  while (1) {
    while_43_continue: /* CIL Label */ ;
    if (! slot) {
      goto while_43_break;
    }
    {
    tmp = get_slot_status(slot);
    status = tmp;
    }
    if (slot->flags & 2U) {
      if (status == 15U) {
        goto __Cont;
      }
      {
      retval = acpiphp_disable_slot(slot);
      }
      if (retval) {
        {
        printk("<3>%s: Error occurred in disabling\n", "acpiphp_glue");
        }
        goto err_exit;
      } else {
        {
        acpiphp_eject_slot(slot);
        }
      }
      {
      disabled ++;
      }
    } else {
      if (status != 15U) {
        goto __Cont;
      }
      {
      retval = acpiphp_enable_slot(slot);
      }
      if (retval) {
        {
        printk("<3>%s: Error occurred in enabling\n", "acpiphp_glue");
        }
        goto err_exit;
      }
      {
      enabled ++;
      }
    }
    __Cont: /* CIL Label */ 
    {
    slot = slot->next;
    }
  }
  while_43_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_44_continue: /* CIL Label */ ;
    if (acpiphp_debug) {
      {
      printk("<7>%s: %s: %d enabled, %d disabled\n", "acpiphp_glue", "acpiphp_check_bridge",
             enabled, disabled);
      }
    }
    goto while_44_break;
  }
  while_44_break: /* CIL Label */ ;
  }
  err_exit: 
  return (retval);
}
}
static void program_hpp(struct pci_dev *dev , struct acpiphp_bridge *bridge ) 
{ u16 pci_cmd ;
  u16 pci_bctl ;
  struct pci_dev *cdev ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
  if (! ((int )dev->hdr_type == 0)) {
    if ((int )dev->hdr_type == 1) {
      if (! (dev->class >> 8 == 1540U)) {
        return;
      }
    } else {
      return;
    }
  }
  if (dev->class >> 8 == 1536U) {
    return;
  }
  {
  pci_write_config_byte(dev, 12, (bridge->hpp.t0)->cache_line_size);
  pci_write_config_byte(dev, 13, (bridge->hpp.t0)->latency_timer);
  pci_read_config_word(dev, 4, & pci_cmd);
  }
  if ((bridge->hpp.t0)->enable_serr) {
    {
    pci_cmd = (unsigned short )((int )pci_cmd | 256);
    }
  } else {
    {
    pci_cmd = (unsigned short )((int )pci_cmd & -257);
    }
  }
  if ((bridge->hpp.t0)->enable_perr) {
    {
    pci_cmd = (unsigned short )((int )pci_cmd | 64);
    }
  } else {
    {
    pci_cmd = (unsigned short )((int )pci_cmd & -65);
    }
  }
  {
  pci_write_config_word(dev, 4, pci_cmd);
  }
  if (dev->class >> 8 == 1540U) {
    {
    pci_write_config_byte(dev, 27, (bridge->hpp.t0)->latency_timer);
    pci_read_config_word(dev, 62, & pci_bctl);
    }
    if ((bridge->hpp.t0)->enable_serr) {
      {
      pci_bctl = (unsigned short )((int )pci_bctl | 2);
      }
    } else {
      {
      pci_bctl = (unsigned short )((int )pci_bctl & -3);
      }
    }
    if ((bridge->hpp.t0)->enable_perr) {
      {
      pci_bctl = (unsigned short )((int )pci_bctl | 1);
      }
    } else {
      {
      pci_bctl = (unsigned short )((int )pci_bctl & -2);
      }
    }
    {
    pci_write_config_word(dev, 62, pci_bctl);
    }
    if (dev->subordinate) {
      {
      __mptr = (struct list_head  const  *)(dev->subordinate)->devices.next;
      cdev = (struct pci_dev *)((char *)__mptr - (unsigned int )(& ((struct pci_dev *)0)->bus_list));
      }
      {
      while (1) {
        while_45_continue: /* CIL Label */ ;
        {
        prefetch((void const   *)cdev->bus_list.next);
        }
        if (! ((unsigned int )(& cdev->bus_list) != (unsigned int )(& (dev->subordinate)->devices))) {
          goto while_45_break;
        }
        {
        program_hpp(cdev, bridge);
        __mptr___0 = (struct list_head  const  *)cdev->bus_list.next;
        cdev = (struct pci_dev *)((char *)__mptr___0 - (unsigned int )(& ((struct pci_dev *)0)->bus_list));
        }
      }
      while_45_break: /* CIL Label */ ;
      }
    }
  }
  return;
}
}
static void acpiphp_set_hpp_values(acpi_handle handle , struct pci_bus *bus ) 
{ struct acpiphp_bridge bridge ;
  struct pci_dev *dev ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
  {
  __constant_c_and_count_memset((void *)(& bridge), 0UL, sizeof(bridge));
  bridge.handle = handle;
  bridge.pci_bus = bus;
  bridge.pci_dev = bus->self;
  decode_hpp(& bridge);
  __mptr = (struct list_head  const  *)bus->devices.next;
  dev = (struct pci_dev *)((char *)__mptr - (unsigned int )(& ((struct pci_dev *)0)->bus_list));
  }
  {
  while (1) {
    while_46_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)dev->bus_list.next);
    }
    if (! ((unsigned int )(& dev->bus_list) != (unsigned int )(& bus->devices))) {
      goto while_46_break;
    }
    {
    program_hpp(dev, & bridge);
    __mptr___0 = (struct list_head  const  *)dev->bus_list.next;
    dev = (struct pci_dev *)((char *)__mptr___0 - (unsigned int )(& ((struct pci_dev *)0)->bus_list));
    }
  }
  while_46_break: /* CIL Label */ ;
  }
  return;
}
}
static void acpiphp_sanitize_bus(struct pci_bus *bus ) 
{ struct pci_dev *dev ;
  int i ;
  unsigned long type_mask ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct resource *res ;

  {
  {
  type_mask = 768UL;
  __mptr = (struct list_head  const  *)bus->devices.next;
  dev = (struct pci_dev *)((char *)__mptr - (unsigned int )(& ((struct pci_dev *)0)->bus_list));
  }
  {
  while (1) {
    while_47_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)dev->bus_list.next);
    }
    if (! ((unsigned int )(& dev->bus_list) != (unsigned int )(& bus->devices))) {
      goto while_47_break;
    }
    {
    i = 0;
    }
    {
    while (1) {
      while_48_continue: /* CIL Label */ ;
      if (! (i < 7)) {
        goto while_48_break;
      }
      {
      res = & dev->resource[i];
      }
      if (res->flags & type_mask) {
        if (! res->start) {
          if (res->end) {
            {
            pci_remove_bus_device(dev);
            }
            goto while_48_break;
          }
        }
      }
      {
      i ++;
      }
    }
    while_48_break: /* CIL Label */ ;
    }
    {
    __mptr___0 = (struct list_head  const  *)dev->bus_list.next;
    dev = (struct pci_dev *)((char *)__mptr___0 - (unsigned int )(& ((struct pci_dev *)0)->bus_list));
    }
  }
  while_47_break: /* CIL Label */ ;
  }
  return;
}
}
static int acpiphp_configure_bridge(acpi_handle handle ) 
{ struct acpi_pci_id pci_id ;
  struct pci_bus *bus ;
  acpi_status tmp ;

  {
  {
  tmp = acpi_get_pci_id(handle, & pci_id);
  }
  if (tmp) {
    {
    printk("<3>%s: cannot get PCI domain and bus number for bridge\n", "acpiphp_glue");
    }
    return (-22);
  }
  {
  bus = pci_find_bus((int )pci_id.segment, (int )pci_id.bus);
  }
  if (! bus) {
    {
    printk("<3>%s: cannot find bus %d:%d\n", "acpiphp_glue", pci_id.segment, pci_id.bus);
    }
    return (-22);
  }
  {
  pci_bus_size_bridges(bus);
  pci_bus_assign_resources(bus);
  acpiphp_sanitize_bus(bus);
  acpiphp_set_hpp_values(handle, bus);
  pci_enable_bridges(bus);
  acpiphp_configure_ioapics(handle);
  }
  return (0);
}
}
static void handle_bridge_insertion(acpi_handle handle , u32 type ) 
{ struct acpi_device *device ;
  struct acpi_device *pdevice ;
  acpi_handle phandle ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (type != 0U) {
    if (type != 1U) {
      {
      printk("<3>%s: unexpected notification type %d\n", "acpiphp_glue", type);
      }
      return;
    }
  }
  {
  acpi_get_parent(handle, & phandle);
  tmp = acpi_bus_get_device(phandle, & pdevice);
  }
  if (tmp) {
    {
    while (1) {
      while_49_continue: /* CIL Label */ ;
      if (acpiphp_debug) {
        {
        printk("<7>%s: no parent device, assuming NULL\n", "acpiphp_glue");
        }
      }
      goto while_49_break;
    }
    while_49_break: /* CIL Label */ ;
    }
    {
    pdevice = (struct acpi_device *)((void *)0);
    }
  }
  {
  tmp___0 = acpi_bus_add(& device, pdevice, handle, 0);
  }
  if (tmp___0) {
    {
    printk("<3>%s: cannot add bridge to acpi list\n", "acpiphp_glue");
    }
    return;
  }
  {
  tmp___1 = acpiphp_configure_bridge(handle);
  }
  if (tmp___1) {
    {
    printk("<3>%s: cannot configure and start bridge\n", "acpiphp_glue");
    }
  } else {
    {
    tmp___2 = acpi_bus_start(device);
    }
    if (tmp___2) {
      {
      printk("<3>%s: cannot configure and start bridge\n", "acpiphp_glue");
      }
    } else {
      {
      add_bridge(handle);
      }
    }
  }
  return;
}
}
static acpi_status count_sub_bridges(acpi_handle handle , u32 lvl , void *context ,
                                     void **rv ) 
{ int *count ;
  struct acpiphp_bridge *bridge ;

  {
  {
  count = (int *)context;
  bridge = acpiphp_handle_to_bridge(handle);
  }
  if (bridge) {
    {
    (*count) ++;
    }
  }
  return (0U);
}
}
static acpi_status check_sub_bridges(acpi_handle handle , u32 lvl , void *context ,
                                     void **rv ) 
{ struct acpiphp_bridge *bridge ;
  char objname[64] ;
  struct acpi_buffer buffer ;

  {
  {
  buffer.length = sizeof(objname);
  buffer.pointer = (void *)(objname);
  bridge = acpiphp_handle_to_bridge(handle);
  }
  if (bridge) {
    {
    acpi_get_name(handle, 0U, & buffer);
    }
    {
    while (1) {
      while_50_continue: /* CIL Label */ ;
      if (acpiphp_debug) {
        {
        printk("<7>%s: %s: re-enumerating slots under %s\n", "acpiphp_glue", "check_sub_bridges",
               objname);
        }
      }
      goto while_50_break;
    }
    while_50_break: /* CIL Label */ ;
    }
    {
    acpiphp_check_bridge(bridge);
    }
  }
  return (0U);
}
}
static void handle_hotplug_event_bridge(acpi_handle handle , u32 type , void *context ) 
{ struct acpiphp_bridge *bridge ;
  char objname[64] ;
  struct acpi_buffer buffer ;
  struct acpi_device *device ;
  int num_sub_bridges ;
  int tmp ;
  struct acpiphp_slot *slot ;
  int tmp___0 ;

  {
  {
  buffer.length = sizeof(objname);
  buffer.pointer = (void *)(objname);
  num_sub_bridges = 0;
  tmp = acpi_bus_get_device(handle, & device);
  }
  if (tmp) {
    {
    handle_bridge_insertion(handle, type);
    }
    return;
  }
  {
  bridge = acpiphp_handle_to_bridge(handle);
  }
  if (type == 0U) {
    {
    acpi_walk_namespace(6U, handle, ~ 0U, & count_sub_bridges, (void *)(& num_sub_bridges),
                        (void **)((void *)0));
    }
  }
  if (! bridge) {
    if (! num_sub_bridges) {
      {
      printk("<3>%s: cannot get bridge info\n", "acpiphp_glue");
      }
      return;
    }
  }
  {
  acpi_get_name(handle, 0U, & buffer);
  }
  if ((int )type == (unsigned char)0) {
    goto switch_51_0;
  } else {
    if ((int )type == (unsigned char)1) {
      goto switch_51_1;
    } else {
      if ((int )type == (unsigned char)2) {
        goto switch_51_2;
      } else {
        if ((int )type == (unsigned char)3) {
          goto switch_51_3;
        } else {
          if ((int )type == (unsigned char)5) {
            goto switch_51_5;
          } else {
            if ((int )type == (unsigned char)6) {
              goto switch_51_6;
            } else {
              if ((int )type == (unsigned char)7) {
                goto switch_51_7;
              } else {
                {
                goto switch_51_default;
                if (0) {
                  switch_51_0: /* CIL Label */ 
                  {
                  while (1) {
                    while_52_continue: /* CIL Label */ ;
                    if (acpiphp_debug) {
                      {
                      printk("<7>%s: %s: Bus check notify on %s\n", "acpiphp_glue",
                             "handle_hotplug_event_bridge", objname);
                      }
                    }
                    goto while_52_break;
                  }
                  while_52_break: /* CIL Label */ ;
                  }
                  if (bridge) {
                    {
                    while (1) {
                      while_53_continue: /* CIL Label */ ;
                      if (acpiphp_debug) {
                        {
                        printk("<7>%s: %s: re-enumerating slots under %s\n", "acpiphp_glue",
                               "handle_hotplug_event_bridge", objname);
                        }
                      }
                      goto while_53_break;
                    }
                    while_53_break: /* CIL Label */ ;
                    }
                    {
                    acpiphp_check_bridge(bridge);
                    }
                  }
                  if (num_sub_bridges) {
                    {
                    acpi_walk_namespace(6U, handle, ~ 0U, & check_sub_bridges, (void *)0,
                                        (void **)((void *)0));
                    }
                  }
                  goto switch_51_break;
                  switch_51_1: /* CIL Label */ 
                  {
                  while (1) {
                    while_54_continue: /* CIL Label */ ;
                    if (acpiphp_debug) {
                      {
                      printk("<7>%s: %s: Device check notify on %s\n", "acpiphp_glue",
                             "handle_hotplug_event_bridge", objname);
                      }
                    }
                    goto while_54_break;
                  }
                  while_54_break: /* CIL Label */ ;
                  }
                  {
                  acpiphp_check_bridge(bridge);
                  }
                  goto switch_51_break;
                  switch_51_2: /* CIL Label */ 
                  {
                  while (1) {
                    while_55_continue: /* CIL Label */ ;
                    if (acpiphp_debug) {
                      {
                      printk("<7>%s: %s: Device wake notify on %s\n", "acpiphp_glue",
                             "handle_hotplug_event_bridge", objname);
                      }
                    }
                    goto while_55_break;
                  }
                  while_55_break: /* CIL Label */ ;
                  }
                  goto switch_51_break;
                  switch_51_3: /* CIL Label */ 
                  {
                  while (1) {
                    while_56_continue: /* CIL Label */ ;
                    if (acpiphp_debug) {
                      {
                      printk("<7>%s: %s: Device eject notify on %s\n", "acpiphp_glue",
                             "handle_hotplug_event_bridge", objname);
                      }
                    }
                    goto while_56_break;
                  }
                  while_56_break: /* CIL Label */ ;
                  }
                  if (bridge->type != 0) {
                    if (bridge->flags & 2U) {
                      {
                      slot = (bridge->func)->slot;
                      tmp___0 = acpiphp_disable_slot(slot);
                      }
                      if (! tmp___0) {
                        {
                        acpiphp_eject_slot(slot);
                        }
                      }
                    }
                  }
                  goto switch_51_break;
                  switch_51_5: /* CIL Label */ 
                  {
                  printk("<3>Device %s cannot be configured due to a frequency mismatch\n",
                         objname);
                  }
                  goto switch_51_break;
                  switch_51_6: /* CIL Label */ 
                  {
                  printk("<3>Device %s cannot be configured due to a bus mode mismatch\n",
                         objname);
                  }
                  goto switch_51_break;
                  switch_51_7: /* CIL Label */ 
                  {
                  printk("<3>Device %s has suffered a power fault\n", objname);
                  }
                  goto switch_51_break;
                  switch_51_default: /* CIL Label */ 
                  {
                  printk("<4>%s: notify_handler: unknown event type 0x%x for %s\n",
                         "acpiphp_glue", type, objname);
                  }
                  goto switch_51_break;
                } else {
                  switch_51_break: /* CIL Label */ ;
                }
                }
              }
            }
          }
        }
      }
    }
  }
  return;
}
}
static void handle_hotplug_event_func(acpi_handle handle , u32 type , void *context ) 
{ struct acpiphp_func *func ;
  char objname[64] ;
  struct acpi_buffer buffer ;
  int tmp ;

  {
  {
  buffer.length = sizeof(objname);
  buffer.pointer = (void *)(objname);
  acpi_get_name(handle, 0U, & buffer);
  func = (struct acpiphp_func *)context;
  }
  if ((int )type == (unsigned char)0) {
    goto switch_57_0;
  } else {
    if ((int )type == (unsigned char)1) {
      goto switch_57_1;
    } else {
      if ((int )type == (unsigned char)2) {
        goto switch_57_2;
      } else {
        if ((int )type == (unsigned char)3) {
          goto switch_57_3;
        } else {
          {
          goto switch_57_default;
          if (0) {
            switch_57_0: /* CIL Label */ 
            {
            while (1) {
              while_58_continue: /* CIL Label */ ;
              if (acpiphp_debug) {
                {
                printk("<7>%s: %s: Bus check notify on %s\n", "acpiphp_glue", "handle_hotplug_event_func",
                       objname);
                }
              }
              goto while_58_break;
            }
            while_58_break: /* CIL Label */ ;
            }
            {
            acpiphp_enable_slot(func->slot);
            }
            goto switch_57_break;
            switch_57_1: /* CIL Label */ 
            {
            while (1) {
              while_59_continue: /* CIL Label */ ;
              if (acpiphp_debug) {
                {
                printk("<7>%s: %s: Device check notify on %s\n", "acpiphp_glue", "handle_hotplug_event_func",
                       objname);
                }
              }
              goto while_59_break;
            }
            while_59_break: /* CIL Label */ ;
            }
            {
            acpiphp_check_bridge((func->slot)->bridge);
            }
            goto switch_57_break;
            switch_57_2: /* CIL Label */ 
            {
            while (1) {
              while_60_continue: /* CIL Label */ ;
              if (acpiphp_debug) {
                {
                printk("<7>%s: %s: Device wake notify on %s\n", "acpiphp_glue", "handle_hotplug_event_func",
                       objname);
                }
              }
              goto while_60_break;
            }
            while_60_break: /* CIL Label */ ;
            }
            goto switch_57_break;
            switch_57_3: /* CIL Label */ 
            {
            while (1) {
              while_61_continue: /* CIL Label */ ;
              if (acpiphp_debug) {
                {
                printk("<7>%s: %s: Device eject notify on %s\n", "acpiphp_glue", "handle_hotplug_event_func",
                       objname);
                }
              }
              goto while_61_break;
            }
            while_61_break: /* CIL Label */ ;
            }
            {
            tmp = acpiphp_disable_slot(func->slot);
            }
            if (! tmp) {
              {
              acpiphp_eject_slot(func->slot);
              }
            }
            goto switch_57_break;
            switch_57_default: /* CIL Label */ 
            {
            printk("<4>%s: notify_handler: unknown event type 0x%x for %s\n", "acpiphp_glue",
                   type, objname);
            }
            goto switch_57_break;
          } else {
            switch_57_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
  return;
}
}
static acpi_status find_root_bridges(acpi_handle handle , u32 lvl , void *context ,
                                     void **rv ) 
{ int *count ;
  int tmp ;

  {
  {
  count = (int *)context;
  tmp = acpi_root_bridge(handle);
  }
  if (tmp) {
    {
    acpi_install_notify_handler(handle, 1U, & handle_hotplug_event_bridge, (void *)0);
    (*count) ++;
    }
  }
  return (0U);
}
}
static struct acpi_pci_driver acpi_pci_hp_driver  =    {(struct acpi_pci_driver *)0, & add_bridge, & remove_bridge};
int __attribute__((__cold__))  acpiphp_glue_init(void)  __attribute__((__section__(".init.text"))) ;
int __attribute__((__cold__))  acpiphp_glue_init(void) 
{ int num ;

  {
  {
  num = 0;
  acpi_walk_namespace(6U, (void *)((acpi_handle *)((void *)((u8 *)((void *)0) + 4294967295U))),
                      ~ 0U, & find_root_bridges, (void *)(& num), (void **)((void *)0));
  }
  if (num <= 0) {
    return ((int __attribute__((__cold__))  )-1);
  } else {
    {
    acpi_pci_register_driver(& acpi_pci_hp_driver);
    }
  }
  return ((int __attribute__((__cold__))  )0);
}
}
void acpiphp_glue_exit(void) 
{ 

  {
  {
  acpi_pci_unregister_driver(& acpi_pci_hp_driver);
  }
  return;
}
}
int __attribute__((__cold__))  acpiphp_get_num_slots(void)  __attribute__((__section__(".init.text"))) ;
int __attribute__((__cold__))  acpiphp_get_num_slots(void) 
{ struct acpiphp_bridge *bridge ;
  int num_slots ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  char const   *tmp ;
  int tmp___0 ;

  {
  {
  num_slots = 0;
  __mptr = (struct list_head  const  *)bridge_list.next;
  bridge = (struct acpiphp_bridge *)((char *)__mptr - (unsigned int )(& ((struct acpiphp_bridge *)0)->list));
  }
  {
  while (1) {
    while_62_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)bridge->list.next);
    }
    if (! ((unsigned int )(& bridge->list) != (unsigned int )(& bridge_list))) {
      goto while_62_break;
    }
    {
    while (1) {
      while_63_continue: /* CIL Label */ ;
      if (acpiphp_debug) {
        if (bridge->nr_slots == 1) {
          {
          tmp = "";
          }
        } else {
          {
          tmp = "s";
          }
        }
        {
        tmp___0 = pci_domain_nr(bridge->pci_bus);
        printk("<7>%s: Bus %04x:%02x has %d slot%s\n", "acpiphp_glue", tmp___0, (bridge->pci_bus)->number,
               bridge->nr_slots, tmp);
        }
      }
      goto while_63_break;
    }
    while_63_break: /* CIL Label */ ;
    }
    {
    num_slots += bridge->nr_slots;
    __mptr___0 = (struct list_head  const  *)bridge->list.next;
    bridge = (struct acpiphp_bridge *)((char *)__mptr___0 - (unsigned int )(& ((struct acpiphp_bridge *)0)->list));
    }
  }
  while_62_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_64_continue: /* CIL Label */ ;
    if (acpiphp_debug) {
      {
      printk("<7>%s: Total %d slots\n", "acpiphp_glue", num_slots);
      }
    }
    goto while_64_break;
  }
  while_64_break: /* CIL Label */ ;
  }
  return ((int __attribute__((__cold__))  )num_slots);
}
}
int acpiphp_enable_slot(struct acpiphp_slot *slot ) 
{ int retval ;
  unsigned int tmp ;

  {
  {
  mutex_lock(& slot->crit_sect);
  retval = power_on_slot(slot);
  }
  if (retval) {
    goto err_exit;
  }
  {
  tmp = get_slot_status(slot);
  }
  if (tmp == 15U) {
    {
    retval = enable_device(slot);
    }
    if (retval) {
      {
      power_off_slot(slot);
      }
    }
  } else {
    {
    while (1) {
      while_65_continue: /* CIL Label */ ;
      if (acpiphp_debug) {
        {
        printk("<7>%s: %s: Slot status is not ACPI_STA_ALL\n", "acpiphp_glue", "acpiphp_enable_slot");
        }
      }
      goto while_65_break;
    }
    while_65_break: /* CIL Label */ ;
    }
    {
    power_off_slot(slot);
    }
  }
  err_exit: 
  {
  mutex_unlock(& slot->crit_sect);
  }
  return (retval);
}
}
int acpiphp_disable_slot(struct acpiphp_slot *slot ) 
{ int retval ;

  {
  {
  retval = 0;
  mutex_lock(& slot->crit_sect);
  retval = disable_device(slot);
  }
  if (retval) {
    goto err_exit;
  }
  {
  retval = power_off_slot(slot);
  }
  if (retval) {
    goto err_exit;
  }
  err_exit: 
  {
  mutex_unlock(& slot->crit_sect);
  }
  return (retval);
}
}
u8 acpiphp_get_power_status(struct acpiphp_slot *slot ) 
{ 

  {
  return ((unsigned char )(slot->flags & 1U));
}
}
u8 acpiphp_get_latch_status(struct acpiphp_slot *slot ) 
{ unsigned int sta ;
  int tmp ;

  {
  {
  sta = get_slot_status(slot);
  }
  if (sta & 4U) {
    {
    tmp = 0;
    }
  } else {
    {
    tmp = 1;
    }
  }
  return ((unsigned char )tmp);
}
}
u8 acpiphp_get_adapter_status(struct acpiphp_slot *slot ) 
{ unsigned int sta ;
  int tmp ;

  {
  {
  sta = get_slot_status(slot);
  }
  if (sta == 0U) {
    {
    tmp = 0;
    }
  } else {
    {
    tmp = 1;
    }
  }
  return ((unsigned char )tmp);
}
}
