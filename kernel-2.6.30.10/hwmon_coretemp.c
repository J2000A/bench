/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

typedef unsigned short __kernel_mode_t;
typedef unsigned int __kernel_size_t;
typedef int __kernel_ssize_t;
typedef unsigned char __u8;
typedef unsigned short __u16;
typedef unsigned int __u32;
typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned int u32;
typedef unsigned long long u64;
typedef __u32 __kernel_dev_t;
typedef __kernel_dev_t dev_t;
typedef __kernel_mode_t mode_t;
typedef __kernel_size_t size_t;
typedef __kernel_ssize_t ssize_t;
typedef unsigned int gfp_t;
typedef u32 resource_size_t;
struct task_struct;
struct task_struct;
struct cpuinfo_x86;
struct cpuinfo_x86;
struct task_struct;
struct task_struct;
struct task_struct;
struct module;
struct module;
typedef __builtin_va_list __gnuc_va_list;
typedef __gnuc_va_list va_list;
struct bug_entry {
   unsigned long bug_addr ;
   char const   *file ;
   unsigned short line ;
   unsigned short flags ;
};
struct completion;
struct completion;
struct __anonstruct_cpumask_t_15 {
   unsigned long bits[((64U + 8U * sizeof(long )) - 1U) / (8U * sizeof(long ))] ;
};
typedef struct __anonstruct_cpumask_t_15 cpumask_t;
struct raw_spinlock;
struct raw_spinlock;
struct task_struct;
struct cpuinfo_x86 {
   __u8 x86 ;
   __u8 x86_vendor ;
   __u8 x86_model ;
   __u8 x86_mask ;
   char wp_works_ok ;
   char hlt_works_ok ;
   char hard_math ;
   char rfu ;
   char fdiv_bug ;
   char f00f_bug ;
   char coma_bug ;
   char pad0 ;
   int cpuid_level ;
   __u32 x86_capability[8] ;
   char x86_vendor_id[16] ;
   char x86_model_id[64] ;
   int x86_cache_size ;
   int x86_cache_alignment ;
   int x86_power ;
   unsigned long loops_per_jiffy ;
   cpumask_t llc_shared_map ;
   u16 x86_max_cores ;
   u16 apicid ;
   u16 initial_apicid ;
   u16 x86_clflush_size ;
   u16 booted_cores ;
   u16 phys_proc_id ;
   u16 cpu_core_id ;
   u16 cpu_index ;
} __attribute__((__aligned__((1) <<  (7) ))) ;
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
struct task_struct;
struct raw_spinlock {
   unsigned int slock ;
};
typedef struct raw_spinlock raw_spinlock_t;
struct task_struct;
struct lock_class_key {

};
struct __anonstruct_spinlock_t_32 {
   raw_spinlock_t raw_lock ;
};
typedef struct __anonstruct_spinlock_t_32 spinlock_t;
struct __anonstruct_atomic_t_34 {
   int counter ;
};
typedef struct __anonstruct_atomic_t_34 atomic_t;
typedef atomic_t atomic_long_t;
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
typedef struct __wait_queue_head wait_queue_head_t;
struct task_struct;
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
};
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
struct device;
struct device;
struct pm_message {
   int event ;
};
typedef struct pm_message pm_message_t;
struct pm_ops {
   int (*prepare)(struct device *dev ) ;
   void (*complete)(struct device *dev ) ;
   int (*suspend)(struct device *dev ) ;
   int (*resume)(struct device *dev ) ;
   int (*freeze)(struct device *dev ) ;
   int (*thaw)(struct device *dev ) ;
   int (*poweroff)(struct device *dev ) ;
   int (*restore)(struct device *dev ) ;
};
struct pm_ext_ops {
   struct pm_ops base ;
   int (*suspend_noirq)(struct device *dev ) ;
   int (*resume_noirq)(struct device *dev ) ;
   int (*freeze_noirq)(struct device *dev ) ;
   int (*thaw_noirq)(struct device *dev ) ;
   int (*poweroff_noirq)(struct device *dev ) ;
   int (*restore_noirq)(struct device *dev ) ;
};
enum dpm_state {
    DPM_INVALID = 0,
    DPM_ON = 1,
    DPM_PREPARING = 2,
    DPM_RESUMING = 3,
    DPM_SUSPENDING = 4,
    DPM_OFF = 5,
    DPM_OFF_IRQ = 6
} ;
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int can_wakeup : 1 ;
   unsigned int should_wakeup : 1 ;
   enum dpm_state status ;
   struct list_head entry ;
};
struct task_struct;
typedef __u32 Elf32_Addr;
typedef __u16 Elf32_Half;
typedef __u32 Elf32_Word;
struct elf32_sym {
   Elf32_Word st_name ;
   Elf32_Addr st_value ;
   Elf32_Word st_size ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf32_Half st_shndx ;
};
typedef struct elf32_sym Elf32_Sym;
struct kobject;
struct kobject;
struct module;
struct attribute {
   char const   *name ;
   struct module *owner ;
   mode_t mode ;
};
struct attribute_group {
   char const   *name ;
   mode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
};
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
struct kref {
   atomic_t refcount ;
};
struct kset;
struct kobj_type;
struct sysfs_dirent;
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct sysfs_dirent *sd ;
   struct kref kref ;
   unsigned int state_initialized : 1 ;
   unsigned int state_in_sysfs : 1 ;
   unsigned int state_add_uevent_sent : 1 ;
   unsigned int state_remove_uevent_sent : 1 ;
};
struct kobj_type {
   void (*release)(struct kobject *kobj ) ;
   struct sysfs_ops *sysfs_ops ;
   struct attribute **default_attrs ;
};
struct kobj_uevent_env {
   char *envp[32] ;
   int envp_idx ;
   char buf[2048] ;
   int buflen ;
};
struct kset_uevent_ops {
   int (*filter)(struct kset *kset , struct kobject *kobj ) ;
   char const   *(*name)(struct kset *kset , struct kobject *kobj ) ;
   int (*uevent)(struct kset *kset , struct kobject *kobj , struct kobj_uevent_env *env ) ;
};
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops *uevent_ops ;
};
struct module;
struct module;
struct marker;
struct marker;
typedef void marker_probe_func(void *probe_private , void *call_private , char const   *fmt ,
                               va_list *args );
struct marker_probe_closure {
   marker_probe_func *func ;
   void *probe_private ;
};
struct marker {
   char const   *name ;
   char const   *format ;
   char state ;
   char ptype ;
   void (*call)(struct marker  const  *mdata , void *call_private  , ...) ;
   struct marker_probe_closure single ;
   struct marker_probe_closure *multi ;
} __attribute__((__aligned__(8))) ;
struct __anonstruct_local_t_98 {
   atomic_long_t a ;
};
typedef struct __anonstruct_local_t_98 local_t;
struct mod_arch_specific {

};
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
struct module;
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module * , char const   * ,
                    size_t count ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
};
struct exception_table_entry;
struct exception_table_entry;
struct notifier_block;
struct module_ref {
   local_t count ;
} __attribute__((__aligned__((1) <<  (7) ))) ;
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2
} ;
struct module_param_attrs;
struct module_sect_attrs;
struct module_notes_attrs;
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[64U - sizeof(unsigned long )] ;
   struct module_kobject mkobj ;
   struct module_param_attrs *param_attrs ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry  const  *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   void *unwind_info ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf32_Sym *symtab ;
   unsigned int num_symtab ;
   char *strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   void *percpu ;
   char *args ;
   struct marker *markers ;
   unsigned int num_markers ;
   struct list_head modules_which_use_me ;
   struct task_struct *waiter ;
   void (*exit)(void) ;
   struct module_ref ref[64] ;
};
struct device_driver;
struct device_driver;
struct module;
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
struct device;
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
struct klist_node;
struct klist_node;
struct klist {
   spinlock_t k_lock ;
   struct list_head k_list ;
   void (*get)(struct klist_node * ) ;
   void (*put)(struct klist_node * ) ;
};
struct klist_node {
   struct klist *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
   struct completion n_removed ;
};
struct semaphore {
   spinlock_t lock ;
   unsigned int count ;
   struct list_head wait_list ;
};
struct dev_archdata {
   void *acpi_handle ;
};
struct device;
struct device_driver;
struct driver_private;
struct driver_private;
struct class;
struct class;
struct class_private;
struct class_private;
struct bus_type;
struct bus_type;
struct bus_type_private;
struct bus_type_private;
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type *bus , char *buf ) ;
   ssize_t (*store)(struct bus_type *bus , char const   *buf , size_t count ) ;
};
struct device_attribute;
struct driver_attribute;
struct bus_type {
   char const   *name ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   int (*match)(struct device *dev , struct device_driver *drv ) ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*suspend_late)(struct device *dev , pm_message_t state ) ;
   int (*resume_early)(struct device *dev ) ;
   int (*resume)(struct device *dev ) ;
   struct pm_ext_ops *pm ;
   struct bus_type_private *p ;
};
struct notifier_block;
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct attribute_group **groups ;
   struct pm_ops *pm ;
   struct driver_private *p ;
};
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver *driver , char *buf ) ;
   ssize_t (*store)(struct device_driver *driver , char const   *buf , size_t count ) ;
};
struct class_attribute;
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct device_attribute *dev_attrs ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   void (*class_release)(struct class *class ) ;
   void (*dev_release)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct pm_ops *pm ;
   struct class_private *p ;
};
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class *class , char *buf ) ;
   ssize_t (*store)(struct class *class , char const   *buf , size_t count ) ;
};
struct device_type {
   char const   *name ;
   struct attribute_group **groups ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   void (*release)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct pm_ops *pm ;
};
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device *dev , struct device_attribute *attr , char *buf ) ;
   ssize_t (*store)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                    size_t count ) ;
};
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
struct dma_coherent_mem;
struct device {
   struct klist klist_children ;
   struct klist_node knode_parent ;
   struct klist_node knode_driver ;
   struct klist_node knode_bus ;
   struct device *parent ;
   struct kobject kobj ;
   char bus_id[20] ;
   char const   *init_name ;
   struct device_type *type ;
   unsigned int uevent_suppress : 1 ;
   struct semaphore sem ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *driver_data ;
   void *platform_data ;
   struct dev_pm_info power ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct list_head node ;
   struct class *class ;
   dev_t devt ;
   struct attribute_group **groups ;
   void (*release)(struct device *dev ) ;
};
struct sensor_device_attribute {
   struct device_attribute dev_attr ;
   int index ;
};
struct platform_device {
   char const   *name ;
   int id ;
   struct device dev ;
   u32 num_resources ;
   struct resource *resource ;
};
struct platform_driver {
   int (*probe)(struct platform_device * ) ;
   int (*remove)(struct platform_device * ) ;
   void (*shutdown)(struct platform_device * ) ;
   int (*suspend)(struct platform_device * , pm_message_t state ) ;
   int (*suspend_late)(struct platform_device * , pm_message_t state ) ;
   int (*resume_early)(struct platform_device * ) ;
   int (*resume)(struct platform_device * ) ;
   struct pm_ext_ops *pm ;
   struct device_driver driver ;
};
struct notifier_block;
struct coretemp_data;
struct coretemp_data {
   struct device *hwmon_dev ;
   struct mutex update_lock ;
   char const   *name ;
   u32 id ;
   char valid ;
   unsigned long last_updated ;
   int temp ;
   int tjmax ;
   int ttarget ;
   u8 alarm ;
};
struct pdev_entry {
   struct list_head list ;
   struct platform_device *pdev ;
   unsigned int cpu ;
};
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
extern unsigned long __per_cpu_offset[64] ;
extern int ( /* format attribute */  sprintf)(char *buf , char const   *fmt  , ...) ;
extern int ( /* format attribute */ __attribute__((__regparm__(0))) printk)(char const   *fmt 
                                                                            , ...)  __attribute__((__cold__)) ;
extern int __next_cpu(int n , cpumask_t const   *srcp ) ;
extern cpumask_t cpu_online_map ;
extern int rdmsr_on_cpu(unsigned int cpu , u32 msr_no , u32 *l , u32 *h ) ;
extern int rdmsr_safe_on_cpu(unsigned int cpu , u32 msr_no , u32 *l , u32 *h ) ;
extern struct cpuinfo_x86 per_cpu__cpu_info ;
__inline static void __list_add(struct list_head *new , struct list_head *prev , struct list_head *next ) 
{ 

  {
  {
  next->prev = new;
  new->next = next;
  new->prev = prev;
  prev->next = new;
  }
  return;
}
}
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 

  {
  {
  __list_add(new, head->prev, head);
  }
  return;
}
}
__inline static void __list_del(struct list_head *prev , struct list_head *next ) 
{ 

  {
  {
  next->prev = prev;
  prev->next = next;
  }
  return;
}
}
__inline static void list_del(struct list_head *entry ) 
{ 

  {
  {
  __list_del(entry->prev, entry->next);
  entry->next = (struct list_head *)((void *)1048832);
  entry->prev = (struct list_head *)((void *)2097664);
  }
  return;
}
}
__inline static int list_empty(struct list_head  const  *head ) 
{ 

  {
  return ((unsigned int )head->next == (unsigned int )head);
}
}
register unsigned long current_stack_pointer  __asm__("esp") __attribute__((__used__))  ;
extern void __mutex_init(struct mutex *lock , char const   *name , struct lock_class_key *key ) ;
extern void mutex_lock(struct mutex *lock ) ;
extern void mutex_unlock(struct mutex *lock ) ;
extern int sysfs_create_group(struct kobject *kobj , struct attribute_group  const  *grp ) ;
extern void sysfs_remove_group(struct kobject *kobj , struct attribute_group  const  *grp ) ;
extern void kfree(void const   * ) ;
extern unsigned long volatile   jiffies  __attribute__((__section__(".data"))) ;
extern void *__kmalloc(size_t size , gfp_t flags ) ;
__inline static void *( __attribute__((__always_inline__)) kmalloc)(size_t size ,
                                                                    gfp_t flags ) 
{ void *tmp___2 ;

  {
  {
  tmp___2 = __kmalloc(size, flags);
  }
  return (tmp___2);
}
}
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ void *tmp ;

  {
  {
  tmp = kmalloc(size, flags | 32768U);
  }
  return (tmp);
}
}
extern int device_create_file(struct device *device , struct device_attribute *entry ) ;
extern void device_remove_file(struct device *dev , struct device_attribute *attr ) ;
__inline static char const   *dev_name(struct device  const  *dev ) 
{ 

  {
  return ((char const   *)(dev->bus_id));
}
}
__inline static void *dev_get_drvdata(struct device *dev ) 
{ 

  {
  return (dev->driver_data);
}
}
__inline static void dev_set_drvdata(struct device *dev , void *data ) 
{ 

  {
  {
  dev->driver_data = data;
  }
  return;
}
}
extern char const   *dev_driver_string(struct device  const  *dev ) ;
extern struct device *hwmon_device_register(struct device *dev ) ;
extern void hwmon_device_unregister(struct device *dev ) ;
__inline static long PTR_ERR(void const   *ptr ) 
{ 

  {
  return ((long )ptr);
}
}
__inline static long IS_ERR(void const   *ptr ) 
{ long tmp ;

  {
  {
  tmp = __builtin_expect((long )(! (! ((unsigned long )ptr >= 4294963201UL))), 0L);
  }
  return (tmp);
}
}
extern void platform_device_unregister(struct platform_device * ) ;
extern struct platform_device *platform_device_alloc(char const   *name , int id ) ;
extern int platform_device_add(struct platform_device *pdev ) ;
extern void platform_device_put(struct platform_device *pdev ) ;
extern int platform_driver_register(struct platform_driver * ) ;
extern void platform_driver_unregister(struct platform_driver * ) ;
extern int register_cpu_notifier(struct notifier_block *nb ) ;
extern void unregister_cpu_notifier(struct notifier_block *nb ) ;
static struct coretemp_data *coretemp_update_device(struct device *dev ) ;
static ssize_t show_name(struct device *dev , struct device_attribute *devattr , char *buf ) 
{ int ret ;
  struct sensor_device_attribute *attr ;
  struct device_attribute  const  *__mptr ;
  struct coretemp_data *data ;
  void *tmp ;

  {
  {
  __mptr = (struct device_attribute  const  *)devattr;
  attr = (struct sensor_device_attribute *)((char *)__mptr - (unsigned int )(& ((struct sensor_device_attribute *)0)->dev_attr));
  tmp = dev_get_drvdata(dev);
  data = (struct coretemp_data *)tmp;
  }
  if (attr->index == 4) {
    {
    ret = sprintf(buf, "%s\n", data->name);
    }
  } else {
    {
    ret = sprintf(buf, "Core %d\n", data->id);
    }
  }
  return (ret);
}
}
static ssize_t show_alarm(struct device *dev , struct device_attribute *devattr ,
                          char *buf ) 
{ struct coretemp_data *data ;
  struct coretemp_data *tmp ;
  int tmp___0 ;

  {
  {
  tmp = coretemp_update_device(dev);
  data = tmp;
  tmp___0 = sprintf(buf, "%d\n", data->alarm);
  }
  return (tmp___0);
}
}
static ssize_t show_temp(struct device *dev , struct device_attribute *devattr , char *buf ) 
{ struct sensor_device_attribute *attr ;
  struct device_attribute  const  *__mptr ;
  struct coretemp_data *data ;
  struct coretemp_data *tmp ;
  int err ;
  int tmp___0 ;

  {
  {
  __mptr = (struct device_attribute  const  *)devattr;
  attr = (struct sensor_device_attribute *)((char *)__mptr - (unsigned int )(& ((struct sensor_device_attribute *)0)->dev_attr));
  tmp = coretemp_update_device(dev);
  data = tmp;
  }
  if (attr->index == 0) {
    if (data->valid) {
      {
      tmp___0 = sprintf(buf, "%d\n", data->temp);
      err = tmp___0;
      }
    } else {
      {
      err = -11;
      }
    }
  } else {
    if (attr->index == 1) {
      {
      err = sprintf(buf, "%d\n", data->tjmax);
      }
    } else {
      {
      err = sprintf(buf, "%d\n", data->ttarget);
      }
    }
  }
  return (err);
}
}
static struct sensor_device_attribute sensor_dev_attr_temp1_input  =    {{{"temp1_input", (struct module *)0, (mode_t )292}, & show_temp, (ssize_t (*)(struct device *dev ,
                                                                                  struct device_attribute *attr ,
                                                                                  char const   *buf ,
                                                                                  size_t count ))((void *)0)},
    0};
static struct sensor_device_attribute sensor_dev_attr_temp1_crit  =    {{{"temp1_crit", (struct module *)0, (mode_t )292}, & show_temp, (ssize_t (*)(struct device *dev ,
                                                                                 struct device_attribute *attr ,
                                                                                 char const   *buf ,
                                                                                 size_t count ))((void *)0)},
    1};
static struct sensor_device_attribute sensor_dev_attr_temp1_max  =    {{{"temp1_max", (struct module *)0, (mode_t )292}, & show_temp, (ssize_t (*)(struct device *dev ,
                                                                                struct device_attribute *attr ,
                                                                                char const   *buf ,
                                                                                size_t count ))((void *)0)},
    2};
static struct device_attribute dev_attr_temp1_crit_alarm  =    {{"temp1_crit_alarm", (struct module *)0, (mode_t )292}, & show_alarm, (ssize_t (*)(struct device *dev ,
                                                                                       struct device_attribute *attr ,
                                                                                       char const   *buf ,
                                                                                       size_t count ))((void *)0)};
static struct sensor_device_attribute sensor_dev_attr_temp1_label  =    {{{"temp1_label",
      (struct module *)0, (mode_t )292}, & show_name, (ssize_t (*)(struct device *dev ,
                                                                   struct device_attribute *attr ,
                                                                   char const   *buf ,
                                                                   size_t count ))((void *)0)},
    3};
static struct sensor_device_attribute sensor_dev_attr_name  =    {{{"name", (struct module *)0, (mode_t )292}, & show_name, (ssize_t (*)(struct device *dev ,
                                                                           struct device_attribute *attr ,
                                                                           char const   *buf ,
                                                                           size_t count ))((void *)0)},
    4};
static struct attribute *coretemp_attributes[6]  = {      & sensor_dev_attr_name.dev_attr.attr,      & sensor_dev_attr_temp1_label.dev_attr.attr,      & dev_attr_temp1_crit_alarm.attr,      & sensor_dev_attr_temp1_input.dev_attr.attr, 
        & sensor_dev_attr_temp1_crit.dev_attr.attr,      (struct attribute *)((void *)0)};
static struct attribute_group  const  coretemp_group  =    {(char const   *)0, (mode_t (*)(struct kobject * , struct attribute * , int  ))0,
    coretemp_attributes};
static struct coretemp_data *coretemp_update_device(struct device *dev ) 
{ struct coretemp_data *data ;
  void *tmp ;
  u32 eax ;
  u32 edx ;

  {
  {
  tmp = dev_get_drvdata(dev);
  data = (struct coretemp_data *)tmp;
  mutex_lock(& data->update_lock);
  }
  if (! data->valid) {
    goto _L;
  } else {
    if ((long )(data->last_updated + 250UL) - (long )jiffies < 0L) {
      _L: /* CIL Label */ 
      {
      data->valid = (char)0;
      rdmsr_on_cpu(data->id, 412U, & eax, & edx);
      data->alarm = (unsigned char )((eax >> 5) & 1U);
      }
      if (eax & 2147483648U) {
        {
        data->temp = (int )((unsigned int )data->tjmax - ((eax >> 16) & 127U) * 1000U);
        data->valid = (char)1;
        }
      }
      {
      data->last_updated = (unsigned long )jiffies;
      }
    }
  }
  {
  mutex_unlock(& data->update_lock);
  }
  return (data);
}
}
static int __attribute__((__cold__))  adjust_tjmax(struct cpuinfo_x86 *c , u32 id ,
                                                   struct device *dev )  __attribute__((__section__(".devinit.text"))) ;
static int __attribute__((__cold__))  adjust_tjmax(struct cpuinfo_x86 *c , u32 id ,
                                                   struct device *dev ) 
{ int tjmax ;
  int ismobile ;
  int err ;
  u32 eax ;
  u32 edx ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
  {
  tjmax = 100000;
  ismobile = 1;
  }
  if ((int )c->x86_model == 15) {
    if ((int )c->x86_mask < 4) {
      {
      ismobile = 0;
      }
    }
  }
  if ((int )c->x86_model > 14) {
    if (ismobile) {
      {
      err = rdmsr_safe_on_cpu(id, 23U, & eax, & edx);
      }
      if (err) {
        {
        tmp = dev_name((struct device  const  *)dev);
        tmp___0 = dev_driver_string((struct device  const  *)dev);
        printk("<4>%s %s: Unable to access MSR 0x17, assuming desktop CPU\n", tmp___0,
               tmp);
        ismobile = 0;
        }
      } else {
        if (! (eax & 268435456U)) {
          {
          ismobile = 0;
          }
        }
      }
    }
  }
  if (ismobile) {
    {
    err = rdmsr_safe_on_cpu(id, 238U, & eax, & edx);
    }
    if (err) {
      {
      tmp___1 = dev_name((struct device  const  *)dev);
      tmp___2 = dev_driver_string((struct device  const  *)dev);
      printk("<4>%s %s: Unable to access MSR 0xEE, for Tjmax, left at default", tmp___2,
             tmp___1);
      }
    } else {
      if (eax & 1073741824U) {
        {
        tjmax = 85000;
        }
      }
    }
  } else {
    {
    tmp___3 = dev_name((struct device  const  *)dev);
    tmp___4 = dev_driver_string((struct device  const  *)dev);
    printk("<4>%s %s: Using relative temperature scale!\n", tmp___4, tmp___3);
    }
  }
  return ((int __attribute__((__cold__))  )tjmax);
}
}
static struct lock_class_key __key___0  ;
static int __attribute__((__cold__))  coretemp_probe(struct platform_device *pdev )  __attribute__((__section__(".devinit.text"))) ;
static int __attribute__((__cold__))  coretemp_probe(struct platform_device *pdev ) 
{ struct coretemp_data *data ;
  struct cpuinfo_x86 *c ;
  unsigned long __ptr ;
  int err ;
  u32 eax ;
  u32 edx ;
  char const   *tmp ;
  char const   *tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  int __attribute__((__cold__))  tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  long tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  long tmp___12 ;

  {
  {
  __asm__  ("": "=r" (__ptr): "0" (& per_cpu__cpu_info));
  c = (struct cpuinfo_x86 *)(__ptr + __per_cpu_offset[pdev->id]);
  tmp___1 = kzalloc(sizeof(struct coretemp_data ), 208U);
  data = (struct coretemp_data *)tmp___1;
  }
  if (! data) {
    {
    err = -12;
    tmp = dev_name((struct device  const  *)(& pdev->dev));
    tmp___0 = dev_driver_string((struct device  const  *)(& pdev->dev));
    printk("<3>%s %s: Out of memory\n", tmp___0, tmp);
    }
    goto exit;
  }
  {
  data->id = (unsigned int )pdev->id;
  data->name = "coretemp";
  }
  {
  while (1) {
    while_0_continue: /* CIL Label */ ;
    {
    __mutex_init(& data->update_lock, "&data->update_lock", & __key___0);
    }
    goto while_0_break;
  }
  while_0_break: /* CIL Label */ ;
  }
  {
  err = rdmsr_safe_on_cpu(data->id, 412U, & eax, & edx);
  }
  if (err) {
    {
    tmp___2 = dev_name((struct device  const  *)(& pdev->dev));
    tmp___3 = dev_driver_string((struct device  const  *)(& pdev->dev));
    printk("<3>%s %s: Unable to access THERM_STATUS MSR, giving up\n", tmp___3, tmp___2);
    }
    goto exit_free;
  }
  if ((int )c->x86_model == 14) {
    if ((int )c->x86_mask < 12) {
      {
      rdmsr_on_cpu(data->id, 139U, & eax, & edx);
      }
      if (edx < 57U) {
        {
        err = -19;
        tmp___4 = dev_name((struct device  const  *)(& pdev->dev));
        tmp___5 = dev_driver_string((struct device  const  *)(& pdev->dev));
        printk("<3>%s %s: Errata AE18 not fixed, update BIOS or microcode of the CPU!\n",
               tmp___5, tmp___4);
        }
        goto exit_free;
      }
    }
  }
  {
  tmp___6 = adjust_tjmax(c, data->id, & pdev->dev);
  data->tjmax = (int )tmp___6;
  dev_set_drvdata(& pdev->dev, (void *)data);
  }
  if ((int )c->x86_model > 14) {
    {
    err = rdmsr_safe_on_cpu(data->id, 418U, & eax, & edx);
    }
    if (err) {
      {
      tmp___7 = dev_name((struct device  const  *)(& pdev->dev));
      tmp___8 = dev_driver_string((struct device  const  *)(& pdev->dev));
      printk("<4>%s %s: Unable to read IA32_TEMPERATURE_TARGET MSR\n", tmp___8, tmp___7);
      }
    } else {
      {
      data->ttarget = (int )((unsigned int )data->tjmax - ((eax >> 8) & 255U) * 1000U);
      err = device_create_file(& pdev->dev, & sensor_dev_attr_temp1_max.dev_attr);
      }
      if (err) {
        goto exit_free;
      }
    }
  }
  {
  err = sysfs_create_group(& pdev->dev.kobj, & coretemp_group);
  }
  if (err) {
    goto exit_dev;
  }
  {
  data->hwmon_dev = hwmon_device_register(& pdev->dev);
  tmp___12 = IS_ERR((void const   *)data->hwmon_dev);
  }
  if (tmp___12) {
    {
    tmp___9 = PTR_ERR((void const   *)data->hwmon_dev);
    err = (int )tmp___9;
    tmp___10 = dev_name((struct device  const  *)(& pdev->dev));
    tmp___11 = dev_driver_string((struct device  const  *)(& pdev->dev));
    printk("<3>%s %s: Class registration failed (%d)\n", tmp___11, tmp___10, err);
    }
    goto exit_class;
  }
  return ((int __attribute__((__cold__))  )0);
  exit_class: 
  {
  sysfs_remove_group(& pdev->dev.kobj, & coretemp_group);
  }
  exit_dev: 
  {
  device_remove_file(& pdev->dev, & sensor_dev_attr_temp1_max.dev_attr);
  }
  exit_free: 
  {
  kfree((void const   *)data);
  }
  exit: 
  return ((int __attribute__((__cold__))  )err);
}
}
static int __attribute__((__cold__))  coretemp_remove(struct platform_device *pdev )  __attribute__((__used__,
__section__(".devexit.text"))) ;
static int __attribute__((__cold__))  coretemp_remove(struct platform_device *pdev ) 
{ struct coretemp_data *data ;
  void *tmp ;

  {
  {
  tmp = dev_get_drvdata(& pdev->dev);
  data = (struct coretemp_data *)tmp;
  hwmon_device_unregister(data->hwmon_dev);
  sysfs_remove_group(& pdev->dev.kobj, & coretemp_group);
  device_remove_file(& pdev->dev, & sensor_dev_attr_temp1_max.dev_attr);
  dev_set_drvdata(& pdev->dev, (void *)0);
  kfree((void const   *)data);
  }
  return ((int __attribute__((__cold__))  )0);
}
}
static struct platform_driver coretemp_driver  = 
     {(int (*)(struct platform_device * ))(& coretemp_probe), (int (*)(struct platform_device * ))(& coretemp_remove),
    (void (*)(struct platform_device * ))0, (int (*)(struct platform_device * , pm_message_t state ))0,
    (int (*)(struct platform_device * , pm_message_t state ))0, (int (*)(struct platform_device * ))0,
    (int (*)(struct platform_device * ))0, (struct pm_ext_ops *)0, {"coretemp", (struct bus_type *)0,
                                                                    (struct module *)0,
                                                                    (char const   *)0,
                                                                    (int (*)(struct device *dev ))0,
                                                                    (int (*)(struct device *dev ))0,
                                                                    (void (*)(struct device *dev ))0,
                                                                    (int (*)(struct device *dev ,
                                                                             pm_message_t state ))0,
                                                                    (int (*)(struct device *dev ))0,
                                                                    (struct attribute_group **)0,
                                                                    (struct pm_ops *)0,
                                                                    (struct driver_private *)0}};
static struct list_head pdev_list  =    {& pdev_list,
    & pdev_list};
static struct mutex pdev_list_mutex  =    {{1}, {{0U}}, {& pdev_list_mutex.wait_list, & pdev_list_mutex.wait_list}};
static int __attribute__((__cold__))  coretemp_device_add(unsigned int cpu )  __attribute__((__section__(".cpuinit.text"))) ;
static int __attribute__((__cold__))  coretemp_device_add(unsigned int cpu ) 
{ int err ;
  struct platform_device *pdev ;
  struct pdev_entry *pdev_entry ;
  void *tmp ;

  {
  {
  pdev = platform_device_alloc("coretemp", (int )cpu);
  }
  if (! pdev) {
    {
    err = -12;
    printk("<3>coretemp: Device allocation failed\n");
    }
    goto exit;
  }
  {
  tmp = kzalloc(sizeof(struct pdev_entry ), 208U);
  pdev_entry = (struct pdev_entry *)tmp;
  }
  if (! pdev_entry) {
    {
    err = -12;
    }
    goto exit_device_put;
  }
  {
  err = platform_device_add(pdev);
  }
  if (err) {
    {
    printk("<3>coretemp: Device addition failed (%d)\n", err);
    }
    goto exit_device_free;
  }
  {
  pdev_entry->pdev = pdev;
  pdev_entry->cpu = cpu;
  mutex_lock(& pdev_list_mutex);
  list_add_tail(& pdev_entry->list, & pdev_list);
  mutex_unlock(& pdev_list_mutex);
  }
  return ((int __attribute__((__cold__))  )0);
  exit_device_free: 
  {
  kfree((void const   *)pdev_entry);
  }
  exit_device_put: 
  {
  platform_device_put(pdev);
  }
  exit: 
  return ((int __attribute__((__cold__))  )err);
}
}
static void coretemp_device_remove(unsigned int cpu ) 
{ struct pdev_entry *p ;
  struct pdev_entry *n ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
  {
  mutex_lock(& pdev_list_mutex);
  __mptr = (struct list_head  const  *)pdev_list.next;
  p = (struct pdev_entry *)((char *)__mptr - (unsigned int )(& ((struct pdev_entry *)0)->list));
  __mptr___0 = (struct list_head  const  *)p->list.next;
  n = (struct pdev_entry *)((char *)__mptr___0 - (unsigned int )(& ((struct pdev_entry *)0)->list));
  }
  {
  while (1) {
    while_1_continue: /* CIL Label */ ;
    if (! ((unsigned int )(& p->list) != (unsigned int )(& pdev_list))) {
      goto while_1_break;
    }
    if (p->cpu == cpu) {
      {
      platform_device_unregister(p->pdev);
      list_del(& p->list);
      kfree((void const   *)p);
      }
    }
    {
    p = n;
    __mptr___1 = (struct list_head  const  *)n->list.next;
    n = (struct pdev_entry *)((char *)__mptr___1 - (unsigned int )(& ((struct pdev_entry *)0)->list));
    }
  }
  while_1_break: /* CIL Label */ ;
  }
  {
  mutex_unlock(& pdev_list_mutex);
  }
  return;
}
}
static int __attribute__((__cold__))  coretemp_cpu_callback(struct notifier_block *nfb ,
                                                            unsigned long action ,
                                                            void *hcpu )  __attribute__((__section__(".cpuinit.text"))) ;
static int __attribute__((__cold__))  coretemp_cpu_callback(struct notifier_block *nfb ,
                                                            unsigned long action ,
                                                            void *hcpu ) 
{ unsigned int cpu ;

  {
  {
  cpu = (unsigned int )((unsigned long )hcpu);
  }
  if ((int )action == 2) {
    goto switch_2_2;
  } else {
    if ((int )action == 6) {
      goto switch_2_2;
    } else {
      if ((int )action == 5) {
        goto switch_2_5;
      } else {
        if (0) {
          switch_2_2: /* CIL Label */ 
          switch_2_6: /* CIL Label */ 
          {
          coretemp_device_add(cpu);
          }
          goto switch_2_break;
          switch_2_5: /* CIL Label */ 
          {
          coretemp_device_remove(cpu);
          }
          goto switch_2_break;
        } else {
          switch_2_break: /* CIL Label */ ;
        }
      }
    }
  }
  return ((int __attribute__((__cold__))  )1);
}
}
static struct notifier_block coretemp_cpu_notifier  __attribute__((__section__(".ref.data")))  =    {(int (*)(struct notifier_block * ,
             unsigned long  , void * ))(& coretemp_cpu_callback), (struct notifier_block *)0,
    0};
static int __attribute__((__cold__))  coretemp_init(void)  __attribute__((__section__(".init.text"))) ;
static int __attribute__((__cold__))  coretemp_init(void) 
{ int i ;
  int err ;
  struct pdev_entry *p ;
  struct pdev_entry *n ;
  unsigned long __ptr ;
  struct cpuinfo_x86 *c ;
  unsigned long __ptr___0 ;
  int __attribute__((__cold__))  tmp ;
  int tmp___0 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
  {
  err = -19;
  __asm__  ("": "=r" (__ptr): "0" (& per_cpu__cpu_info));
  }
  if ((int )((struct cpuinfo_x86 *)(__ptr + __per_cpu_offset[0]))->x86_vendor != 0) {
    goto exit;
  }
  {
  err = platform_driver_register(& coretemp_driver);
  }
  if (err) {
    goto exit;
  }
  {
  i = -1;
  }
  {
  while (1) {
    while_3_continue: /* CIL Label */ ;
    {
    i = __next_cpu(i, (cpumask_t const   *)(& cpu_online_map));
    }
    if (! (i < 64)) {
      goto while_3_break;
    }
    {
    __asm__  ("": "=r" (__ptr___0): "0" (& per_cpu__cpu_info));
    c = (struct cpuinfo_x86 *)(__ptr___0 + __per_cpu_offset[i]);
    }
    if (c->cpuid_level < 0) {
      goto _L;
    } else {
      if ((int )c->x86 != 6) {
        goto _L;
      } else {
        if (! ((int )c->x86_model == 14)) {
          if (! ((int )c->x86_model == 15)) {
            if (! ((int )c->x86_model == 22)) {
              if (! ((int )c->x86_model == 23)) {
                if (! ((int )c->x86_model == 26)) {
                  _L: /* CIL Label */ 
                  if ((int )c->x86 == 6) {
                    if ((int )c->x86_model > 15) {
                      {
                      printk("<4>coretemp: Unknown CPU model %x\n", c->x86_model);
                      }
                    }
                  }
                  goto __Cont;
                }
              }
            }
          }
        }
      }
    }
    {
    tmp = coretemp_device_add((unsigned int )i);
    err = (int )tmp;
    }
    if (err) {
      goto exit_devices_unreg;
    }
    __Cont: /* CIL Label */ 
    {

    }
  }
  while_3_break: /* CIL Label */ ;
  }
  {
  tmp___0 = list_empty((struct list_head  const  *)(& pdev_list));
  }
  if (tmp___0) {
    {
    err = -19;
    }
    goto exit_driver_unreg;
  }
  {
  register_cpu_notifier(& coretemp_cpu_notifier);
  }
  return ((int __attribute__((__cold__))  )0);
  exit_devices_unreg: 
  {
  mutex_lock(& pdev_list_mutex);
  __mptr = (struct list_head  const  *)pdev_list.next;
  p = (struct pdev_entry *)((char *)__mptr - (unsigned int )(& ((struct pdev_entry *)0)->list));
  __mptr___0 = (struct list_head  const  *)p->list.next;
  n = (struct pdev_entry *)((char *)__mptr___0 - (unsigned int )(& ((struct pdev_entry *)0)->list));
  }
  {
  while (1) {
    while_4_continue: /* CIL Label */ ;
    if (! ((unsigned int )(& p->list) != (unsigned int )(& pdev_list))) {
      goto while_4_break;
    }
    {
    platform_device_unregister(p->pdev);
    list_del(& p->list);
    kfree((void const   *)p);
    p = n;
    __mptr___1 = (struct list_head  const  *)n->list.next;
    n = (struct pdev_entry *)((char *)__mptr___1 - (unsigned int )(& ((struct pdev_entry *)0)->list));
    }
  }
  while_4_break: /* CIL Label */ ;
  }
  {
  mutex_unlock(& pdev_list_mutex);
  }
  exit_driver_unreg: 
  {
  platform_driver_unregister(& coretemp_driver);
  }
  exit: 
  return ((int __attribute__((__cold__))  )err);
}
}
static void __attribute__((__cold__))  coretemp_exit(void)  __attribute__((__used__,
__section__(".exit.text"))) ;
static void __attribute__((__cold__))  coretemp_exit(void) 
{ struct pdev_entry *p ;
  struct pdev_entry *n ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
  {
  unregister_cpu_notifier(& coretemp_cpu_notifier);
  mutex_lock(& pdev_list_mutex);
  __mptr = (struct list_head  const  *)pdev_list.next;
  p = (struct pdev_entry *)((char *)__mptr - (unsigned int )(& ((struct pdev_entry *)0)->list));
  __mptr___0 = (struct list_head  const  *)p->list.next;
  n = (struct pdev_entry *)((char *)__mptr___0 - (unsigned int )(& ((struct pdev_entry *)0)->list));
  }
  {
  while (1) {
    while_5_continue: /* CIL Label */ ;
    if (! ((unsigned int )(& p->list) != (unsigned int )(& pdev_list))) {
      goto while_5_break;
    }
    {
    platform_device_unregister(p->pdev);
    list_del(& p->list);
    kfree((void const   *)p);
    p = n;
    __mptr___1 = (struct list_head  const  *)n->list.next;
    n = (struct pdev_entry *)((char *)__mptr___1 - (unsigned int )(& ((struct pdev_entry *)0)->list));
    }
  }
  while_5_break: /* CIL Label */ ;
  }
  {
  mutex_unlock(& pdev_list_mutex);
  platform_driver_unregister(& coretemp_driver);
  }
  return;
}
}
static int (*__initcall_coretemp_init6)(void)  __attribute__((__used__, __section__(".initcall6.init")))  =    (int (*)(void))(& coretemp_init);
static void (*__exitcall_coretemp_exit)(void)  __attribute__((__used__,
__section__(".exitcall.exit")))  =    (void (*)(void))(& coretemp_exit);
